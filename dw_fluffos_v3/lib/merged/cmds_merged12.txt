# Total Tokens: 13617
# Total Files Merged: 3
# Total Characters: 45397

o.c
==================================================

#include <top_ten_tables.h>
int cmd(string filter, string arg);
string* determine_location( object person ) {
    mixed *areas, *place;
    areas = ({
        ({ "/d/liaison/NEWBIE", ({ "Misc", "The newbie area" }) }),
        ({ "/room/air", ({ "Misc", "The air" }) }),
        ({ "/room/void", ({ "Misc", "The void" }) }),
        ({ "/room/rubbish", ({ "Misc", "The rubbish room" }) }),
        ({ "/room/departures", ({ "Misc", "The departures lounge" }) }),
        ({ "/room/jail", ({ "Misc", "Jail" }) }),
        ({ "/w/", ({ "Misc", "/w dirs" }) }),
        ({ "/d/cwc/utils/interview", ({ "CWC", "Interview room" }) }),
        ({ "/d/cwc/common", ({ "CWC", "Commonroom" }) }),
        ({ "/d/cwc/Brown_Islands", ({ "CWC", "Brown Islands" }) }),
        ({ "/d/cwc/Bes_Pelargic/Bad_Poo-Ning/roads/medina",
            ({ "CWC", "Medina" }) }),
        ({ "/d/cwc/Bes_Pelargic/Sum_Bing/roads/snail",
            ({ "CWC", "The Snail" }) }),
        ({ "/d/cwc/Bes_Pelargic", ({ "CWC", "Bes Pelargic" }) }),
        ({ "/d/cwc/Hunghung", ({ "CWC", "HungHung" }) }),
        ({ "/d/cwc/Isle_of_Tonahamen", ({ "CWC", "Isle of Tonahamen" }) }),
        ({ "/d/cwc/families/mcsweeny", ({ "CWC", "McSweeney Estate" }) }),
        ({ "/d/cwc/Maps", ({ "CWC", "Terrains" }) }),
        ({ "/d/cwc", ({ "CWC", "?" }) }),
        ({ "/d/guilds/assassins/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/thieves/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/BesPelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/Hunghung", ({ "CWC", "HH guilds" }) }),
        ({ "/d/guilds/priests/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/wizards/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/witches/bespelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/underworld/moving_shop/rooms/cwc", ({ "CWC", "F-shop" }) }),
        ({ "/d/am/utils/interview", ({ "AM", "Interview room" }) }),
        ({ "/d/am/shades", ({ "AM", "The Shades" }) }),
        ({ "/d/am/common", ({ "AM", "Commonroom" }) }),
        ({ "/d/am", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/special/player_shops", ({ "AM", "Tarnach's" }) }),
        ({ "/d/guilds/merchants", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/guilds/assassins/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/thieves/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/warriors/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/priests/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/wizards/Ankh-Morpork",
            ({ "AM", "Unseen University" }) }),
        ({ "/d/guilds/witches/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/witches/am", ({ "AM", "AM guilds" }) }),
        ({ "/d/klatch/utils/interview", ({ "Klatch", "Interview room" }) }),
        ({ "/d/klatch/common", ({ "Klatch", "Commonroom" }) }),
        ({ "/d/klatch/djel/city", ({ "Klatch", "KLK" }) }),
        ({ "/d/klatch/djel/necropolis", ({ "Klatch", "Necropolis" }) }),
        ({ "/d/klatch/djel/netherworld", ({ "Klatch", "Netherworld" }) }),
        ({ "/d/klatch/tsort/desert/roads",
            ({ "Klatch", "Tsort desert road" }) }),
        ({ "/d/klatch/tsort/desert", ({ "Klatch", "Tsort desert" }) }),
        ({ "/d/klatch/tsort", ({ "Klatch", "Tsort" }) }),
        ({ "/d/klatch/Maps", ({ "Klatch", "Terrains" }) }),
        ({ "/d/klatch", ({ "Klatch", "?" }) }),
        ({ "/d/guilds/assassins/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/thieves/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/warriors/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Djelibeybi", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Ephebe", ({ "Klatch", "Ephebe guilds" }) }),
        ({ "/d/guilds/wizards/Tsort", ({ "Klatch", "Tsort guilds" }) }),
        ({ "/d/guilds/witches/klk", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/ram/utils/interview", ({ "Ram", "Interview room" }) }),
        ({ "/d/ram/common", ({ "Ram", "Commonroom" }) }),
        ({ "/d/ram/Gloomy_Forest", ({ "Ram", "Gloomy forest" }) }),
        ({ "/d/ram/Lancre_Kingdom", ({ "Ram", "Lancre Kingdom" }) }),
        ({ "/d/ram/Listening_Monks", ({ "Ram", "Listening Monks" }) }),
        ({ "/d/ram/Razorback", ({ "Ram", "Razorback" }) }),
        ({ "/d/ram/Slice", ({ "Ram", "Slice" }) }),
        ({ "/d/ram/Sprite_Caverns", ({ "Ram", "Sprite caverns" }) }),
        ({ "/d/ram/Temple_of_Soyin", ({ "Ram", "Temple of Soyin" }) }),
        ({ "/d/ram/Uberwald", ({ "Ram", "Uberwald" }) }),
        ({ "/d/ram/badass", ({ "Ram", "Bad Ass" }) }),
        ({ "/d/ram/madstoat", ({ "Ram", "Mad Stoat" }) }),
        ({ "/d/ram/ohulan", ({ "Ram", "Ohulan-Cutash" }) }),
        ({ "/d/ram/foothills", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/bridge", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/moorland", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/gorge_road", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/Lower_Valleys", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/lancre_town", ({ "Ram", "Lancre Town" }) }),
        ({ "/d/ram/bandit_camp", ({ "Ram", "Bandit camp" }) }),
        ({ "/d/ram/druid_circle", ({ "Ram", "Druid circle" }) }),
        ({ "/d/ram/mountains", ({ "Ram", "Ramtops" }) }),
        ({ "/d/ram", ({ "Ram", "?" }) }),
        ({ "/d/guilds/assassins/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/thieves/Madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/warriors/Lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/priests/Monks-of-Cool", ({ "Ram", "Monks of Cool" }) }),
        ({ "/d/guilds/priests/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/wizards/Creel-Springs",
            ({ "Ram", "Creel Springs guilds" }) }),
        ({ "/d/guilds/witches/badass", ({ "Ram", "Bad Ass guilds" }) }),
        ({ "/d/guilds/witches/lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/witches/madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/witches/razorback", ({ "Ram", "Razorback guilds" }) }),
        ({ "/d/sur/utils/interview", ({ "Sur", "Interview room" }) }),
        ({ "/d/sur/common", ({ "Sur", "Commonroom" }) }),
        ({ "/d/sur/Maps", ({ "Sur", "Terrains" }) }),
        ({ "/d/sur/Dinky", ({ "Sur", "Dinky" }) }),
        ({ "/d/sur/Sto_Helit", ({ "Sur", "Sto Helit" }) }),
        ({ "/d/sur/StoLat", ({ "Sur", "Sto Lat" }) }),
        ({ "/d/sur/Hillshire", ({ "Sur", "Hillshire" }) }),
        ({ "/d/sur/Holywood", ({ "Sur", "Holywood" }) }),
        ({ "/d/sur/Nowhere", ({ "Sur", "Nowhere" }) }),
        ({ "/d/sur/PekanFord", ({ "Sur", "Pekan Ford" }) }),
        ({ "/d/sur/Sheepridge", ({ "Sur", "Sheepridge" }) }),
        ({ "/d/sur/Scrogden", ({ "Sur", "Scrogden" }) }),
        ({ "/d/sur/items/carriage", ({ "Sur", "Carriage" }) }),
        ({ "/d/sur", ({ "Sur", "?" }) }),
        ({ "/d/guilds/assassins/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/assassins/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/assassins/Sheepridge",
            ({ "Sur", "Sheepridge guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/thieves/Pekan_Ford", ({ "Sur", "PF guilds" }) }),
        ({ "/d/guilds/warriors/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/priests/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/wizards/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/witches/skund", ({ "Sur", "Skund guilds" }) }),
        ({ "/d/guilds/witches/stolat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/forn/utils/interview", ({ "Forn", "Interview room" }) }),
        ({ "/d/forn/common", ({ "Forn", "Commonroom" }) }),
        ({ "/d/forn/genua", ({ "Forn", "Genua" }) }),
        ({ "/d/forn", ({ "Forn", "?" }) }),
        ({ "/d/guilds/assassins/Genua", ({ "Forn", "Genua guilds" }) }),
        ({ "/d/special/utils/interview", ({ "Special", "Interview room" }) }),
        ({ "/d/special/common", ({ "Special", "Commonroom" }) }),
        ({ "/d/special/ctf", ({ "Special", "CTF" }) }),
        ({ "/d/special", ({ "Special", "?" }) }),
        ({ "/d/playtesters/utils/interview", ({ "Playtesters",
            "Interview room" }) }),
        ({ "/d/playtesters/common", ({ "Playtesters", "Commonroom" }) }),
        ({ "/d/playtesters/palace_rooms", ({ "Playtesters", "Palace" }) }),
        ({ "/d/playtesters", ({ "Playtesters", "?" }) }),
        ({ "/d/liaison/utils/interview", ({ "Liaison", "Interview room" }) }),
        ({ "/d/liaison/common", ({ "Liaison", "Commonroom" }) }),
        ({ "/d/liaison", ({ "Liaison", "?" }) }),
        ({ "/d/underworld/common", ({ "Underworld", "Commonroom" }) }),
        ({ "/d/underworld/death", ({ "Underworld", "Death's domain" }) }),
        ({ "/d/underworld/lspace", ({ "Underworld", "L-space" }) }),
        ({ "/d/underworld/moving_shop", ({ "Underworld", "T-shop" }) }),
        ({ "/d/underworld", ({ "Underworld", "?" }) }),
        ({ "/d/guilds/common", ({ "Guilds", "Commonroom" }) }),
        ({ "/d/guilds/assassins", ({ "Guilds", "Assassins" }) }),
        ({ "/d/guilds/thieves", ({ "Guilds", "Thieves" }) }),
        ({ "/d/guilds/warriors", ({ "Guilds", "Warriors" }) }),
        ({ "/d/guilds/priests/rooms", ({ "Guilds", "Passage rooms" }) }),
        ({ "/d/guilds/priests", ({ "Guilds", "Priests" }) }),
        ({ "/d/guilds/wizards", ({ "Guilds", "Wizards" }) }),
        ({ "/room/magic_circle", ({ "Guilds", "Witches' circle" }) }),
        ({ "/d/guilds/witches", ({ "Guilds", "Witches" }) }),
        ({ "/d/guilds", ({ "Guilds", "?" }) }),
        ({ "/d/admin/room/domain_control", ({ "Admin", "Domain control" }) }),
        ({ "/d/admin", ({ "Admin", "?" }) }),
        ({ "/d", ({ "Other", "Unknown /d room" }) }),
    });
    if( !environment(person) ) {
        return ({ "Other", "No environment" });
    }
    foreach( place in areas ) {
        if( strsrch( file_name(environment(person)), place[0] ) == 0 ) {
            return place[1];
        }
    }
    return ({ "Other", "Unknown environment" });
}
int get_guild_id(object person) {
    switch(person->query_guild_ob()) {
        case "/std/guilds/warrior":
            return 0;
        case "/std/guilds/assassin":
            return 1;
        case "/std/guilds/thief":
            return 2;
        case "/std/guilds/wizard":
            return 3;
        case "/std/guilds/priest":
            return 4;
        case "/std/guilds/witch":
            return 5;
        default:
            return 6;
    }
}
mapping get_dist( string filter, string arg ) {
    mapping ps;
    object *people, person;
    string *loc;
    int to_add;
    people = filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) );
    ps = ([ ]);
    foreach( person in people ) {
        loc = determine_location(person);
        if( !ps[loc[0]] ) {
            if( filter == "average" ) {
                ps[loc[0]] = ({ ([ ]), 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]] = ({ ([ ]), 0, 0 });
            }
        }
        ps[loc[0]][1]++;
        if( !ps[loc[0]][0][loc[1]] ) {
            if( filter == "average" ) {
                ps[loc[0]][0][loc[1]] = ({ 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]][0][loc[1]] = ({ 0, 0 });
            }
        }
        ps[loc[0]][0][loc[1]][0]++;
        switch(filter) {
            case "verbosity":
                if( person->query_verbose(arg) ) {
                    ps[loc[0]][2]++;
                    ps[loc[0]][0][loc[1]][1]++;
                }
                break;
            case "average":
                to_add = 0;
                if( arg == "guild level" ) {
                    to_add = person->query_level();
                }
                if( arg == "rating" ) {
                    to_add = (int)TOP_TEN_HANDLER->calculate_rating(person);
                }
                if( arg == "age" ) {
                    to_add = -person->query_time_on();
                }
                if( to_add < ps[loc[0]][2][0] || ps[loc[0]][2][0] == -1 ) {
                    ps[loc[0]][2][0] = to_add;
                }
                ps[loc[0]][2][1] += to_add;
                if( to_add > ps[loc[0]][2][2] ) {
                    ps[loc[0]][2][2] = to_add;
                }
                if( to_add < ps[loc[0]][0][loc[1]][1][0] ||
                    ps[loc[0]][0][loc[1]][1][0] == -1 ) {
                    ps[loc[0]][0][loc[1]][1][0] = to_add;
                }
                ps[loc[0]][0][loc[1]][1][1] += to_add;
                if( to_add > ps[loc[0]][0][loc[1]][1][2] ) {
                    ps[loc[0]][0][loc[1]][1][2] = to_add;
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    if( !ps[loc[0]][2] ) {
                        ps[loc[0]][2] = ({0,0,0,0,0,0,0});
                    }
                    if( !ps[loc[0]][0][loc[1]][1] ) {
                        ps[loc[0]][0][loc[1]][1] = ({0,0,0,0,0,0,0});
                    }
                    to_add = get_guild_id(person);
                    ps[loc[0]][2][to_add]++;
                    ps[loc[0]][0][loc[1]][1][to_add]++;
                }
                break;
            default:
        }
    }
    return ps;
}
int cmd( string filter, string arg, int verbose ) {
    string place, zone, *guilds;
    mapping players, zones;
    int total, i, j;
    string tmp;
    string ret;
    ret = "";
    players = get_dist(filter,arg);
    total = sizeof(filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) ));
    guilds = ({ "Warriors", "Assassins", "Thieves", "Wizards", "Priests",
        "Witches", "Adventurers" });
    tmp = "\n";
    tmp+= sprintf( "%-27s", "Distribution of players:" );
    if( filter == "category" && arg == "guild" ) {
        j = (this_player()->query_cols() - 27) / (sizeof(guilds));
        for( i=0; i<sizeof(guilds); i++ ) {
            tmp += sprintf( "%" + j + ".3s", guilds[i] );
        }
    }
    if( filter == "average" ) {
        if( arg == "age" ) {
            j = (this_player()->query_cols() - 27);
            tmp += sprintf( "%-" + j + "s", "   Average age" );
        }
        else {
            j = (this_player()->query_cols() - 27) / 3;
            tmp += sprintf( "%" + j + "s", "Lowest" );
            tmp += sprintf( "%" + j + "s", "Average" );
            tmp += sprintf( "%" + j + "s", "Highest" );
        }
    }
    tmp += "\n\n";
    ret += tmp;
    foreach( place in keys(players) ) {
        tmp = "%^YELLOW%^";
        tmp+= sprintf( "%-24.24s", place );
        tmp+= sprintf( "%3.1i", players[place][1] );
        switch( filter ) {
            case "verbosity":
                tmp += players[place][2] + "/" +
                    players[place][1] + " verbose " + arg;
                break;
            case "average":
                if( arg == "age" ) {
                    tmp += sprintf( "%-"+ j +"s", "   " + query_time_string(
                        players[place][2][1] / players[place][1] ) );
                }
                else {
                    tmp += sprintf( "%"+ j +".1i", players[place][2][0] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][1] /
                        players[place][1] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][2] );
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    for( i=0; i<sizeof(guilds); i++ ) {
                        tmp += sprintf( "%" + j + ".1i",
                            players[place][2][i] );
                    }
                }
                break;
            default:
                tmp += "   (";
                tmp += sprintf( "%3s",
                    ((100 * players[place][1]) / total + "%") );
                tmp += ")";
                break;
        }
        tmp += "%^RESET%^";
        tmp += "\n";
        ret += tmp;
        if (verbose) {
           zones = players[place][0];
           foreach( zone in keys( zones ) ) {
               tmp = sprintf( "%-24.24s", ("  - " + zone) );
               tmp+= sprintf( "%3.1i", zones[zone][0] );
               switch( filter ) {
                   case "verbosity":
                       tmp += " (" + zones[zone][1] + "/" + zones[zone][0] +
                           " verbose " + arg + ")";
                       break;
                   case "average":
                       if( arg == "age" ) {
                           tmp += sprintf( "%-"+ j +"s", "   " +
                               query_time_string( zones[zone][1][1] /
                               zones[zone][0] ) );
                       }
                       else {
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][1] /
                               zones[zone][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][2] );
                       }
                       break;
                   case "category":
                       if( arg == "guild" ) {
                           for( i=0; i<sizeof(guilds); i++ ) {
                               if( !zones[zone][1][i] ) {
                                   tmp += "%^BLACK%^";
                                   tmp += sprintf( "%" + j + ".1i",
                                        zones[zone][1][i] );
                                   tmp += "%^RESET%^";
                               }
                               else {
                                   tmp += sprintf( "%" + j + ".1i",
                                       zones[zone][1][i] );
                               }
                           }
                       }
                       break;
                   default:
                       tmp += "   (";
                       tmp += sprintf( "%3s",
                           ((100 * zones[zone][0]) / total + "%") );
                       tmp += ")";
                       break;
               }
               tmp += "\n";
               ret += tmp;
           }
        }
        if (verbose) {
           ret += "\n";
        }
    }
    ret += "Total = " + total + "\n";
    write("$P$Distribution$P$" + ret);
    return 1;
}
mixed *query_patterns() {
    return ({
        "by domain", (: cmd(0, 0, 0) :),
        "by guild level",  (: cmd("average", "guild level", 0) :),
        "by rating",  (: cmd("average", "rating", 0) :),
        "by age",  (: cmd("average", "age", 0) :),
        "by guild",  (: cmd("category", "guild", 0) :),
        "verbose by domain", (: cmd(0, 0, 1) :),
        "verbose by guild level",  (: cmd("average", "guild level", 1) :),
        "verbose by rating",  (: cmd("average", "rating", 1) :),
        "verbose by age",  (: cmd("average", "age", 1) :),
        "verbose by guild",  (: cmd("category", "guild", 1) :),
    });
}

==================================================
FILE: creator/todo.c
==================================================

inherit "/cmds/base";
class todo_item {
   string type;
   int id;
   int priority;
   string description;
   int time_added;
   int time_to_finish;
}
#define TODO_PRIVATE 0x8000
#define TODO_PRIORITY_MASK (~TODO_PRIVATE)
private mapping todo_lists;
private mapping changed;
private int save_callout_id;
void create() {
   ::create();
   todo_lists = ([ ]);
   changed = ([ ]);
   seteuid("Root");
}
private class todo_item *query_todo_list(string player) {
   string data;
   class todo_item *stuff;
   class todo_item *new_stuff;
   class todo_item item;
   class todo_item new_item;
   if (todo_lists[player]) {
      return todo_lists[player];
   }
   data = read_file("/w/" + player + "/save/todo_list.o");
   if (!data) {
      return ({ });
   }
   stuff = restore_variable(data);
   if (!stuff) {
      return ({ });
   }
   if (sizeof(stuff) &&
       sizeof(stuff[0]) != 6) {
      new_stuff = ({ });
      foreach (item in stuff) {
         new_item = new(class todo_item);
         new_item->priority = item->priority;
         new_item->type = item->type;
         new_item->description = item->description;
         new_item->id = item->id;
         new_item->time_added = time();
         new_item->time_to_finish = time();
         new_stuff += ({ new_item });
      }
      stuff = new_stuff;
   }
   return stuff;
}
private void save_todo_lists() {
   int times;
   string player;
   string data;
   save_callout_id = 0;
   foreach (player, times in changed) {
      data = save_variable(todo_lists[player]);
      write_file("/w/" + player + "/save/todo_list.o", data, 1);
   }
   changed = ([ ]);
   todo_lists = ([ ]);
}
private void set_todo_list(string player, class todo_item *data) {
   todo_lists[player] = data;
   changed[player] = time();
   if (!save_callout_id) {
      save_callout_id = call_out((: save_todo_lists :), 120);
   }
}
private int query_next_id(string player) {
   class todo_item *data;
   class todo_item item;
   int id;
   data = query_todo_list(player);
   id = 1;
   foreach (item in data) {
      if (item->id >= id) {
         id = item->id + 1;
      }
   }
   return id;
}
string query_priority_name(int priority) {
   string extra;
   extra = " ";
   if (priority & TODO_PRIVATE) {
      extra = "P";
   }
   switch (priority & TODO_PRIORITY_MASK) {
      case 0 :
         return "VL" + extra;
      case 1 :
         return " L" + extra;
      case 2 :
         return " H" + extra;
      case 3 :
         return "VH" + extra;
      case 4 :
         return " U" + extra;
      default :
         return " F" + extra;
   }
}
int query_priority_number(string priority) {
   int mask;
   priority = lower_case(priority);
   mask = 0;
   if (priority[<1] == 'p') {
      mask = TODO_PRIVATE;
      priority = priority[0..<2];
   }
   switch (priority) {
      case "vl" :
         return 0 | mask;
      case "l" :
         return 1 | mask;
      case "h" :
         return 2 | mask;
      case "vh" :
         return 3 | mask;
      case "u" :
         return 4 | mask;
   }
   return -1;
}
string query_todo_line(class todo_item item, int brief, int cols) {
  if(brief) {
  return sprintf("%s%-=*s\n",
                  query_priority_name(item->priority),
                  cols - 3,
                  item->description);
  }
  return sprintf("#%3d %s (%s) Added at %s\n    %-=*s\n",
                  item->id,
                  query_priority_name(item->priority),
                  item->type,
                  ctime(item->time_added),
                  cols - 4,
                  item->description);
}
int sort_function(class todo_item bing,
                  class todo_item bing2) {
   if ((bing->priority & TODO_PRIORITY_MASK) == (bing2->priority & TODO_PRIORITY_MASK)) {
      if (bing->type == bing2->type) {
         return bing->id - bing2->id;
      }
      return strcmp(bing->type, bing2->type);
   }
   return (bing2->priority & TODO_PRIORITY_MASK) - (bing->priority & TODO_PRIORITY_MASK);
}
class todo_item *sort_todo_list(class todo_item *data) {
   return sort_array(data, (: sort_function :));
}
string query_todo_list_string(class todo_item *items, int brief) {
   class todo_item bing;
   string data;
   data = "";
   if (sizeof(items)) {
      foreach (bing in items) {
         data += query_todo_line(bing, brief, this_player()->query_cols());
      }
   }
   return data;
}
private int list_todo(int brief) {
   class todo_item* items;
   string data;
   items = query_todo_list(this_player()->query_name());
   if (sizeof(items)) {
     data = query_todo_list_string(items, brief);
   } else {
      data = "No items in your todo list.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int list_todo_creator(string player) {
   class todo_item* items;
   string data;
   items = query_todo_list(player);
   if (sizeof(items)) {
      items = filter(items, (: !($1->priority & TODO_PRIVATE) :));
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in " + capitalize(player) + "'s todo list.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int list_todo_priority(int priority) {
   class todo_item *items;
   string data;
   items = query_todo_list(this_player()->query_name());
   items = filter(items, (: ($1->priority & TODO_PRIORITY_MASK) == $(priority) :) );
   if (sizeof(items)) {
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in your todo list with the specified priority.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int list_todo_type(string type) {
   class todo_item *items;
   string data;
   type = lower_case(type);
   items = query_todo_list(this_player()->query_name());
   items = filter(items, (: $1->type == $(type) :) );
   if (sizeof(items)) {
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in your todo list with a type of " + type + ".\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int add_item(string priority, string type, string description) {
   int priority_num;
   class todo_item frog;
   class todo_item *data;
   priority_num = query_priority_number(priority);
   if (priority_num == -1) {
      add_failed_mess("Unknown priority '" + priority +
                      "', only VL, L, H, VH and U allowed.\n");
      return 0;
   }
   if (strlen(type) > 10) {
      add_failed_mess("The type cannot be more than 10 characters long.\n");
      return 0;
   }
   if (file_size("/w/" + this_player()->query_name() + "/save") != -2) {
      add_failed_mess("There is no save directory in your home directory.  "
                      "This is needed for operation of this command.\n");
      return 0;
   }
   frog = new(class todo_item);
   frog->priority = priority_num;
   frog->description = description;
   frog->type = lower_case(type);
   frog->id = query_next_id(this_player()->query_name());
   frog->time_added = time();
   frog->time_to_finish = time() + (60 * 60 * 24) * 7;
   data = query_todo_list(this_player()->query_name());
   data += ({ frog });
   data = sort_todo_list(data);
   set_todo_list(this_player()->query_name(), data);
   add_succeeded_mess(({ "You added a new item #" + frog->id +
                         " to your todo list.\n", "" }));
   return 1;
}
private void confirm_complete_item(string response, int id) {
   class todo_item *data;
   class todo_item item;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Ok, canceling the completion of the item.\n");
      return ;
   }
   data = query_todo_list(this_player()->query_name());
   foreach (item in data) {
      if (item->id == id) {
         data -= ({ item });
         set_todo_list(this_player()->query_name(), data);
         write("Ok, completed list id #" + id + ".\n");
         return ;
      }
   }
   write("Unable to find the item.  Someone must have run off with it!\n");
   return ;
}
class todo_item find_todo_id(class todo_item *data, int id) {
   class todo_item item;
   foreach (item in data) {
      if (item->id == id) {
         return item;
      }
   }
   return 0;
}
private int complete_item(int id) {
   class todo_item *data;
   class todo_item item;
   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      write(query_todo_line(item, 0, this_player()->query_cols()) +
            "Are you sure you wish to complete this todo list item? ");
      input_to((: confirm_complete_item :), 0, id);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id + " to complete.\n");
   return 0;
}
private int change_priority(int id, string new_priority) {
   class todo_item *data;
   class todo_item item;
   int priority_num;
   priority_num = query_priority_number(new_priority);
   if (priority_num == -1) {
      add_failed_mess("Unknown priority '" + new_priority +
                      "', only VL, L, H, VH and U allowed.\n");
      return 0;
   }
   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      item->priority = priority_num;
      add_succeeded_mess(({ "Change the priority of #" + id +
                            " to " + new_priority + ".\n", "" }));
      set_todo_list(this_player()->query_name(), data);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id +
                   " to change the priority of.\n");
   return 0;
}
private int change_description(int id, string new_description) {
   class todo_item *data;
   class todo_item item;
   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      item->description = new_description;
      set_todo_list(this_player()->query_name(), data);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id +
                   " to change the description of.\n");
   return 0;
}
mixed *query_patterns() {
   return ({
             "", (: list_todo(1) :),
             "list", (: list_todo(0) :),
             "list type <string'type'>", (: list_todo_type($4[0]) :),
             "list urgent", (: list_todo_priority(4) :),
             "list very high", (: list_todo_priority(3) :),
             "list high", (: list_todo_priority(2) :),
             "list low", (: list_todo_priority(1) :),
             "list very low", (: list_todo_priority(0) :),
               "list brief", (: list_todo(1) :),
             "creator <string'name'>", (: list_todo_creator($4[0]) :),
             "add <word'priority'> <word'type'> <string'description'>",
                   (: add_item($4[0], $4[1], $4[2]) :),
             "complete <number'todo id'>", (: complete_item($4[0]) :),
             "change priority <number'todo it'> <word'priority'>",
                   (: change_priority($4[0], $4[1]) :),
             "change description <number'todo id'> <string'description'>",
                   (: change_description($4[0], $4[1]) :),
           });
}
void dest_me() {
   save_todo_lists();
   ::dest_me();
}

==================================================
FILE: creator/weapons.c
==================================================

#include <weapon.h>
inherit "/cmds/base";
mapping _weapons;
mapping _items;
mapping _matched;
mapping _conditions = ([ "cloth" : 800, "rubber" : 100, "hide" : 700, "leather" : 600, "wood" : 500, "bone" : 200, "silver" : 300, "copper" : 400, "stone" : 400, "bronze" : 500, "iron" : 700, "steel" : 900, "klatchian steel" : 1100, "octiron" : 1300 ]);
mapping _chances = ([ "cloth" : 20, "rubber" : 19, "hide" : 17, "leather" : 15, "wood" : 12, "bone" : 8, "silver" : 15, "copper" : 10, "stone" : 3, "bronze" : 8, "iron" : 6, "steel" : 4, "klatchian steel" : 2, "octiron" : 0 ]);
mapping _weights = ([ "cloth" : 1, "rubber" : 3, "hide" : 2, "leather" : 2, "wood" : 3, "bone" : 3, "silver" : 6, "copper" : 6, "stone" : 5, "bronze" : 5, "iron" : 5, "steel" : 5, "klatchian steel" : 5, "octiron" : 5 ]);
mapping _equivalents = ([ "chocolate" : "rubber",
                          "earthworm" : "octiron" ]);
mapping _specials = ([ "bash" : "smash",
                       "hack" : "chop",
                       "stab" : "pierce",
                       "slash" : "slice" ]);
mapping _types = ([ "strike" : "blunt",
                    "bash" : "blunt",
                    "smash" : "blunt",
                    "hack" : "sharp",
                    "chop" : "sharp",
                    "poke" : "pierce",
                    "stab" : "pierce",
                    "pierce" : "pierce",
                    "cut" : "sharp",
                    "slash" : "sharp",
                    "slice" : "sharp",
                    "spike" : "pierce",
                    "fire" : "any" ]);
nosave string *_attack_types = ({ "blunt", "sharp", "pierce", "fire" });
void create() {
  ::create();
  _weapons = "/obj/handlers/armoury"->make_list("/obj/nweapons/",
                                                ({".c", ".wep"}));
}
string warn(int i) {
  switch(i) {
  case 2:
    return "  %^BOLD%^%^RED%^!%^RESET%^ ";
  case 1:
    return "  %^ORANGE%^o%^RESET%^ ";
  default:
    return "  %^GREEN%^-%^RESET%^ ";
  }
}
int *calc_rating(object weapon) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;
    data = (mixed *)weapon->query_attack_data();
    if ( !( size = sizeof( data ) ) )
      return ({ 0, 0 });
    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
    }
    return ({ ave, max });
}
int calc_ave(mixed damage) {
  if(arrayp(damage))
    return damage[F_FIXED] + (damage[F_NUM] * (1 + damage[F_DIE])) / 2;
  return damage;
}
int calc_max(mixed damage) {
  if(arrayp(damage))
    return damage[F_FIXED] + (damage[F_NUM] * damage[F_DIE]);
  return damage;
}
object *filter(object who) {
  object *tmp;
  if(who->query_creator())
    return ({});
  tmp = who->query_weapons();
  switch(sizeof(tmp)) {
  case 2:
    if(tmp[0]->query_property("virtual name")) {
      if(tmp[0]->query_property("virtual name") ==
         tmp[1]->query_property("virtual name"))
        return ({ tmp[0] });
    } else {
      if(base_name(tmp[0]) == base_name(tmp[1]))
        return ({ tmp[0] });
    }
    break;
  default:
  }
  return tmp;
}
int list(string type) {
  mapping weapons;
  object wep;
  mixed *data;
  string *names, *types, str;
  int i;
  weapons = "/obj/handlers/armoury"->query_items("weapons");
  foreach(str in keys(weapons)) {
    if(str == "twoedge" || str == "kring" ||
       strsrch(weapons[str], "ranged") != -1 ||
       strsrch(weapons[str], "misc") != -1)
      continue;
    wep = "/obj/handlers/armoury"->request_item(str);
    if(!wep)
      continue;
    types = wep->query_attack_types();
    if(type && types && member_array(type, types) == -1)
      continue;
    data = wep->query_attack_data();
    names = wep->query_attack_names();
    for(i=0; i<sizeof(data); i += W_ARRAY_SIZE) {
      printf("%-30s %8s %3d %3d %3d %6s\n",
             wep->query_short(),
             names[i / W_ARRAY_SIZE],
             data[i + W_CHANCE],
             calc_ave(data[i+W_DAMAGE]),
             calc_max(data[i+W_DAMAGE]),
             data[i+W_SKILL]);
      write_file("/w/ceres/WEAPONS.csv",
                 sprintf("%s,%s,%d,%d,%d,%s\n",
                         wep->query_short(),
                         names[i / W_ARRAY_SIZE],
                         data[i + W_CHANCE],
                         calc_ave(data[i+W_DAMAGE]),
                         calc_max(data[i+W_DAMAGE]),
                         data[i+W_SKILL]));
    }
    wep->dest_me();
  }
  return 1;
}
int sort_weapons(int wep1, int wep2) {
  if(wep1 > wep2)
    return -1;
  if(wep1 < wep2)
    return 1;
  return 0;
}
int players() {
  mapping weapons;
  object wep, *weps;
  mixed *data;
  string str;
  data = map(users(), "filter");
  weapons = ([ ]);
  foreach(weps in data) {
    if(weps) {
      foreach(wep in weps) {
        if(wep->query_property("virtual name"))
          str = (clone_object(wep->query_property("virtual name"))->query_short());
        else
          str = base_name(wep)->query_short();
        if(!weapons[str])
          weapons[str] = 1;
        else
          weapons[str] += 1;
      }
    }
  }
  foreach(str in sort_array(keys(weapons),
                            (: sort_weapons($(weapons)[$1],
                                            $(weapons)[$2]) :)))
    if(str && weapons[str])
      printf("%d %s\n", weapons[str], str);
  return 1;
}
private string *map_materials(string *materials) {
  string str;
  foreach(str in materials) {
    if(_equivalents[str]) {
      materials -= ({ str });
      materials += ({ _equivalents[str] });
    }
  }
  return materials;
}
void total(object pl) {
  write("Total of " + _matched[pl] + " weapons found.\n");
}
void check(int bad_only, string type, string search, string *weapons,
           object pl) {
  string str, *materials, att, ret;
  string *tstr, *anames;
  object wep;
  int cond, dc, ave, max, weight, tmp, bad, count;
  mixed *data;
  float wf;
  count = 0;
  foreach(str in weapons) {
    bad = 0;
    if(wep)
      wep->dest_me();
    if(str == "twoedge" || str == "kring")
      continue;
    if(bad_only && (strsrch(str, "bow") != -1 ||
                    str == "satin knife boots" || str == "knife boots" ||
                    strsrch(_items[pl][str], "ranged") != -1 ||
                    strsrch(_items[pl][str], "misc") != -1))
      continue;
    if(search != "" && strsrch(str, search) == -1 &&
       strsrch(_items[pl][str], search) == -1)
      continue;
    wep = clone_object(_items[pl][str]);
    if(!wep || !wep->query_short())
      continue;
    materials = map_materials(wep->query_materials());
    cond = wep->query_max_cond();
    dc = wep->query_damage_chance();
    ret = "";
    if(search)
      ret = sprintf("\n");
    ret += sprintf("%s (%s)\n", capitalize(wep->query_short()),
                   _items[pl][str]);
    tstr = ({ });
    if(!sizeof(materials) || sizeof(materials - keys(_conditions)))
      tstr += ({ "materials" });
    else
      ret += warn(0) + sprintf("is made of %s\n",
                               query_multiple_short(materials));
    if(wep->query_length() == 1)
      tstr += ({ "length" });
    if(wep->query_width() == 1)
      tstr += ({ "width" });
    if(!wep->query_weight())
      tstr += ({ "weight" });
    if(sizeof(tstr)) {
      if(sizeof(tstr) == 1 && tstr[0] == "width") {
        ret += warn(1);
      } else {
        ret += warn(2);
        bad = 2;
      }
      ret += sprintf("has no %s\n", replace(query_multiple_short(tstr),
                                            "and", "or"));
      if(member_array("materials", tstr) != -1) {
        tell_object(pl, ret);
        continue;
      }
    }
    if(wep->query_length() != 1 && wep->query_width() != 1)
      ret += warn(0) + sprintf("is %s%d\" (%dcm) by %s%d\" (%dcm) "
                               "and weighs %.1f%s (%.1fkg)\n",
                               (wep->query_length() / 12) > 0 ?
                               (wep->query_length() / 12) + "'" : "",
                               wep->query_length() % 12,
                               to_int(wep->query_length() * 2.54),
                               (wep->query_width() / 12) > 0 ?
                               (wep->query_width() / 12) + "'" : "",
                               wep->query_width() % 12,
                               to_int(wep->query_width() * 2.54),
                               wep->query_weight() / 9.0,
                               (wep->query_weight() / 9.0) == 1.0 ? "lb" :
                               "lbs",
                               wep->query_weight() / 20.0);
    wf = 0;
    foreach(tstr in materials)
      wf += _weights[tstr];
    wf /= sizeof(materials);
    wf = (wep->query_weight() * (wep->query_weight() / 2)) /
      (wep->query_length() * wep->query_width() * wf);
    if(wf < 0.5 || wf > 3.0) {
      ret += warn(1);
      if(bad < 2)
        bad = 1;
    } else
      ret += warn(0);
    ret += sprintf("has weight factor of %.1f [0.5/1.0/3.0] "
                   "(%%^ORANGE%%^Experimental%%^RESET%%^)\n", wf);
    switch(type) {
    case "weapons":
      weight = 10 + 2 * sqrt(wep->query_weight());
      break;
    case "armours":
      weight = 5 + 2 * sqrt(wep->query_weight());
      break;
    case "clothes":
      weight = 2 * sqrt(wep->query_weight());
      break;
    }
    tmp = 0;
    foreach(tstr in materials)
      tmp += _conditions[tstr];
    tmp /= sizeof(materials);
    tmp *= weight;
    if((cond < tmp - tmp/10) || (cond > tmp + tmp/10)) {
      ret += warn(2) + sprintf("has max cond of %d should be [%d/%d/%d]\n",
                               cond, tmp - tmp/10, tmp, tmp + tmp/10);
      tell_object(pl, ret);
      continue;
    } else if(search)
      ret += warn(0) + sprintf("has max cond of %d [%d/%d/%d]\n",
                               cond, tmp - tmp/10, tmp, tmp + tmp/10);
    tmp = 0;
    foreach(tstr in materials)
      tmp += _chances[tstr];
    tmp /= sizeof(materials);
    if(dc < tmp -1 || dc > tmp+1) {
      ret += warn(2) + sprintf("has damage chance of %d should be "
                               "[%d/%d/%d]\n",
                               dc, tmp-1, tmp, tmp+1);
      bad = 2;
    } else if(search)
      ret += warn(0) + sprintf("has damage chance of %d [%d/%d/%d]\n",
                               dc, tmp-1, tmp, tmp+1);
    anames = wep->query_attack_names();
    if(!sizeof(anames)) {
      ret += warn(2) + sprintf("has no attacks.\n");
      tell_object(pl, ret);
      continue;
    }
    foreach(att in anames) {
      if(!_specials[att] && member_array(att, keys(_types)) == -1) {
        ret += warn(1) + sprintf("has non-standard %s attack\n", att);
        if(bad < 2)
          bad = 1;
      } else if(wep->query_weight() < 30 &&
         member_array(att, values(_specials)) != -1) {
        ret += warn(2) + sprintf("has %s but is too light\n", att);
        bad = 2;
      } else if(wep->query_weight() > 50 && _specials[att] &&
                member_array(_specials[att], anames) == -1) {
        ret += warn(1) + sprintf("has %s but not %s\n", att, _specials[att]);
        if(bad < 2)
          bad = 1;
      }
    }
    data = wep->query_attack_data();
    for(tmp=0; tmp < sizeof(data); tmp += W_ARRAY_SIZE) {
      if(member_array(data[tmp+W_TYPE], _attack_types) == -1) {
        ret += warn(2) + sprintf("has unknown attack type %s\n",
                                 data[tmp+W_TYPE]);
        bad = 2;
      }
      if(member_array(data[tmp+W_SKILL], values(_types)) == -1) {
        ret += warn(2) + sprintf("has unknown attack skill %s\n",
                                 data[tmp+W_SKILL]);
        bad = 2;
      }
      if(_types[anames[tmp/W_ARRAY_SIZE]] &&
         _types[anames[tmp/W_ARRAY_SIZE]] != "any" &&
         _types[anames[tmp/W_ARRAY_SIZE]] != data[tmp+W_SKILL]) {
        ret += warn(2) + sprintf("has attack %s with skill of %s\n",
                                 anames[tmp/W_ARRAY_SIZE], data[tmp+W_SKILL]);
        bad = 2;
      }
      if(data[tmp+W_FUNCTION]) {
        ret += warn(1) + sprintf("has attack function %s on %s attack\n",
                                 data[tmp+W_FUNCTION],
                                 anames[tmp/W_ARRAY_SIZE]);
        bad = 1;
      }
    }
    if(strsrch(_items[pl][str], "axe") == -1 &&
       strsrch(wep->query_long(), "axe") == -1) {
      if(member_array("chop", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has chop attack but is not an axe.\n");
        if(bad < 2)
          bad = 1;
      }
      if(member_array("hack", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has chop attack but is not an axe.\n");
        if(bad < 2)
          bad = 1;
      }
    } else {
      if(member_array("slash", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has slash attack but is an axe.\n");
        if(bad < 2)
          bad = 1;
      }
      if(member_array("slice", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has slice attack but is an axe.\n");
        if(bad < 2)
          bad = 1;
      }
    }
    if(cond) {
      data = calc_rating(wep);
      ave = data[0];
      max = data[1];
      if(ave > 140 || max > 300) {
        ret += warn(2);
        bad = 2;
      } else
        ret += warn(0);
      ret += sprintf("has damage of %d/%d max permitted is [140/300]\n",
                     ave, max);
      tmp = (100 * ave * max) / cond;
      if(tmp < 75 || tmp > 150) {
        ret += warn(1);
        if(bad < 2)
          bad = 1;
      } else
        ret += warn(0);
      ret += sprintf("has damage factor of %d [75/150] "
                     "(%%^ORANGE%%^Experimental%%^RESET%%^)\n",
                     tmp);
    }
    if(bad >= bad_only) {
      tell_object(pl, ret);
      count++;
    }
  }
  _matched[pl] += count;
  return;
}
int do_check(int bad_only, string type) {
  string *tmp, search;
  int i;
  if(!_items)
    _items = ([ ]);
  if(!_matched)
    _matched = ([ ]);
  if(type == "armours" || type == "clothes") {
    _items[this_player()] = "/obj/handlers/armoury"->query_items(type);
    search = "";
  } else if(type == "weapons") {
    _items[this_player()] = _weapons;
    search = "";
  } else {
    search = type;
    type = "weapons";
    _items[this_player()] = _weapons;
  }
  _matched[this_player()] = 0;
  tmp = keys(_items[this_player()]);
  if(!sizeof(tmp))
    return notify_fail("No items matched.\n");
  for(i=0; i<sizeof(tmp); i+= 50) {
    if(i+50 < sizeof(tmp)) {
      call_out("check", 0, bad_only, type, search, tmp[i..i+49],
               this_player());
    } else
      call_out("check", 0, bad_only, type, search, tmp[i..], this_player());
  }
  call_out("total", 1, this_player());
  return 1;
}
mixed *query_patterns() {
  return ({
              "players", (: players() :),
              "check", (: do_check(0, "") :),
              "check <string'type'>", (: do_check(0, $4[0]) :),
              "check bad", (: do_check(2, "") :),
                "check bad <string'type'>", (: do_check(2, $4[0]) :),
              "check warn", (: do_check(1, "") :),
              "check warn <string'type'>", (: do_check(1, $4[0]) :)
                });
}
