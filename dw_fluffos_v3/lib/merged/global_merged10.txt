# Total Tokens: 14775
# Total Files Merged: 18
# Total Characters: 49297

iler.c
==================================================

#include "virtual.h"
#include "compiler.h"
void    initialize_methods();
string  strip_string( string str );
#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')
mapping o_funcs;
mapping r_funcs;
mapping arm_funcs;
mapping clo_funcs;
mapping sca_funcs;
mapping wep_funcs;
mapping cont_funcs;
mapping food_funcs;
mapping mon_funcs;
mapping clotrans_funcs;
object  return_ob;
int     tmp_file_no;
int     debug_file;
void    create()
{
  seteuid("Root");
  initialize_methods();
  o_funcs = O_FUN;
  r_funcs = O_FUN + R_FUN;
  arm_funcs = ARM_FUN + O_FUN;
  clo_funcs = CLO_FUN + O_FUN;
  sca_funcs = SCA_FUN + O_FUN;
  wep_funcs = WEP_FUN + O_FUN;
  mon_funcs = MON_FUN + O_FUN;
  cont_funcs = CONT_FUN + O_FUN;
  food_funcs = FOOD_FUN + CONT_FUN + O_FUN;
  clotrans_funcs = O_FUN + CLO_FUN + CLOTRANS_FUN;
}
object  query_return_ob()
{
    return return_ob;
}
void    set_return_ob( object ob )
{
    return_ob = ob;
}
void    initialize_methods()
{
    SERVER->add_method( "r", file_name( this_object() ), "compile_r",
                        CLONE|LOAD );
    SERVER->add_method( "ro", file_name( this_object() ), "compile_r",
                        CLONE|LOAD );
    SERVER->add_method( "ob", file_name( this_object() ), "compile_ob" );
    SERVER->add_method( "arm", file_name( this_object() ), "compile_arm" );
    SERVER->add_method( "clo", file_name( this_object() ), "compile_clo" );
    SERVER->add_method( "trans", file_name( this_object() ), "compile_clotrans" );
    SERVER->add_method( "sca", file_name( this_object() ), "compile_sca" );
    SERVER->add_method( "wep", file_name( this_object() ), "compile_wep" );
    SERVER->add_method( "mon", file_name( this_object() ), "compile_mon" );
    SERVER->add_method( "food", file_name( this_object() ), "compile_food" );
    SERVER->add_method( "cont", file_name( this_object() ), "compile_cont" );
    SERVER->add_method( "imp", file_name( this_object() ), "compile_imp" );
}
#define Error(s) write(s); log_file( "VO_COMPILER", s); return 0;
mixed  *extract_arguments( string str );
void    do_clone( object dest, string str )
{
    object  ob;
    ob = clone_object( str );
    if( ob )
        ob->move( dest );
}
object  prop_to_fun( string file, mapping funs, string virt_class,
                    string virt_include, int clone )
{
    string *segments, *ind, data, s1, dir, tmp_name, tmp_val;
    string file_data;
    mixed  *val;
    int     i;
    int pos;
    debug_file = 0;
    file_data = "";
    pos = strsrch(file, "/", -1);
    tmp_name = file[0..pos] + "." + file[pos+1..] + "_virtual_.c";
    if (file_size(tmp_name) <= 0 ||
        stat(file)[1] > stat(tmp_name)[1]) {
       tmp_file_no++;
       if( find_object( tmp_name ) ) {
           tmp_name->dest_me();
       }
       ind = explode( file, "/" );
       dir = implode( ind[ 0..sizeof( ind ) - 2 ], "/" );
       unguarded((: rm, tmp_name :));
       file_data = "#include <"+ virt_include +">\n\n"
                "void dest_me() { destruct( this_object() ); }\n\n"
                "void create()\n{\n"
                "  seteuid( (string)\"/secure/master\"->creator_file( file_name( this_object() ) ) );\n"
                "} \n"
                "\nobject create_virtual_ob() {\n"
                "   object clone;\n\n";
       data = read_file( file );
       if( !data )
       {
           Error( "prop_to_fun() : file " + file + " not found\n" );
       }
       segments = explode( "$\n" + data, "\n#" );
       if( !segments )
       {
           Error( "prop_to_fun() : Nothing but comments?\n" );
       }
       segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
       for( i = 1; i < sizeof( segments ); i++ ) {
           if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
               segments[ i ] = "";
           }
       }
       data = implode( segments, "\n" );
       segments = explode( strip_string( data ), "::" );
       if (sizeof( segments ) % 2) {
         segments += ({""});
       }
       ind = allocate( sizeof( segments ) / 2 );
       val = allocate( sizeof( segments ) / 2 );
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = segments[ i * 2 ];
           val[ i ] = replace( segments[ i * 2 + 1 ], "\n", " " );
           if( ind[ i ][ 0..0 ] == "#" )
           {
               ind[ i ] = lower_case( ind[ i ] );
               if( ind[ i ] == "#debug" )
               {
                   sscanf( val[ i ], "%d", debug_file );
               }
               else
               {
                   if( ind[ i ] == "#class" )
                   {
                       virt_class = replace( val[i], " ", "" );
                   }
                   else
                   {
                       if( ind[ i ] == "#include" )
                       {
                           tmp_val = val[i];
                           file_data += "#include " +
                                       replace( tmp_val, " ", "" ) +
                                       "\n";
                       }
                   }
               }
           }
       }
       file_data += "  clone = (object)SERVER->create_virtual_object( " +
                   virt_class + ", 1 );\n"
                   "  clone->add_property( VIRTUAL_NAME_PROP, \""
                   + file + (clone ? "#1" : "") + "\" );\n";
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = lower_case( ind[ i ] );
           if( ind[ i ][ 0..0 ] == "#" )
           {
               continue;
           }
           val[ i ] = replace( val[ i ], ({"(:", "bind( (:",
                                           ":)", ":), clone )" }) );
           if( ind[ i ][ 0..0 ] == "$" )
           {
               {
                   file_data +="  call_other( clone, \"" +
                               ind[ i ][ 1..100 ] + "\", " + val[ i ] +
                               " );\n";
               }
               continue;
           }
           if( funs[ ind[ i ] ] )
           {
               if( !pointerp( funs[ ind[ i ] ] ) )
               {
                   file_data += "  call_other( clone, \"" +
                               funs[ ind[ i ] ] + "\", " + val[ i ] + " );\n";
               }
               else
               {
                   file_data += "  call_other( " + funs[ ind[ i ] ][ 1 ] +
                               ", " + funs[ ind[ i ] ][ 0 ] + ", " + val[ i ] +
                               " );\n";
               }
           }
           else
           {
               write( "Error: Unknown index " + ind[ i ] + "\n" );
           }
       }
       file_data += "   return clone;\n} \n";
       unguarded((: write_file, tmp_name, file_data :));
   }
   if( data = catch( return_ob = tmp_name->create_virtual_ob() ) )
   {
        write( "Error loading " + file + ", " + data + "\n" );
        if( debug_file )
        {
            write( "File not removed.\n" );
        }
        else
        {
        }
    }
    else
    {
        tmp_name->dest_me();
        return return_ob;
    }
}
string  strip_string( string str )
{
    int     i, j;
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i < j; i++ ) ;
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
    return str[ i..j ];
}
mixed   str_to_var( string str )
{
    int     i;
    str = strip_string( str );
    switch( str[ 0 ] )
    {
        case '{':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return map_array( explode( str, "," ), "str_to_var",
                                  this_object() );
            }
        case '"':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return replace( str, "\n", " " ) + "\n";
            }
        case '0'..'9':
        case '-':
            {
                sscanf( str, "%d", i );
                return i;
            }
    }
    return str;
}
mixed  *extract_arguments( string str )
{
    return map_array( explode( str, "
}
object  compile_r( string name, int clone ) {
    object r;
    r = prop_to_fun( name, r_funcs, "\"/obj/virtual_room.c\"",
                    "virtual_room.h", 1 );
    r->reset();
    return r;
}
object  compile_ob( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/std/object.c\"",
                    "virtual.h", clone );
}
object  compile_arm( string name, int clone ) {
    if (name[0 .. 19] == "/obj/armours/shield/")
        return prop_to_fun(name, arm_funcs, "\"/obj/shield.c\"",
                        "virtual.h", clone );
    return prop_to_fun( name, arm_funcs, "\"/obj/armour.c\"",
                    "virtual.h", clone );
}
object  compile_clo( string name, int clone ) {
    return prop_to_fun( name, clo_funcs, "\"/obj/clothing.c\"",
                    "virtual.h", clone );
}
object compile_sca( string name, int clone ) {
   return prop_to_fun( name, sca_funcs, "\"/obj/scabbard.c\"",
                    "virtual.h", clone );
}
object  compile_wep( string name, int clone ) {
    return prop_to_fun( name, wep_funcs, "\"/obj/weapon.c\"",
                    "virtual.h", clone );
}
object  compile_mon( string name, int clone ) {
    return prop_to_fun( name, mon_funcs, "\"/obj/monster.c\"",
                    "virtual.h", clone );
}
object  compile_food( string name, int clone ) {
    return prop_to_fun( name, food_funcs, "\"/obj/food.c\"",
                    "virtual.h", clone );
}
object  compile_cont( string name, int clone ) {
    return prop_to_fun( name, cont_funcs, "\"/obj/cont_medium.c\"",
                    "virtual.h", clone );
}
object  compile_clotrans( string name, int clone ) {
    return prop_to_fun( name, clotrans_funcs, "\"/obj/clothing_transport.c\"",
                    "virtual.h", clone );
}
object  compile_imp( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/obj/implement.c\"",
                    "virtual.h", clone );
}
int set_debug_status(int d_stat) {
  debug_file=d_stat;
  return debug_file;
}

==================================================
FILE: virtual/compiler.h
==================================================

#define TMP_FILE "/global/virtual/tmp_file.c"
#define O_FUN ([ "item"  : "add_item",\
                 "name"  : "set_name",\
                 "long"  : "set_long",\
                 "light" : "set_light",\
                 "alias" : "add_alias",\
                 "plural" : "add_plural",\
                 "adjective" : "add_adjective",\
                 "plural adjective" : "add_plural_adjective",\
                 "main_plural" : "set_main_plural",\
                 "main plural" : "set_main_plural",\
                 "weight" : "set_weight",\
                 "length" : "set_length",\
                 "width" : "set_width",\
                 "value" : "set_value",\
                 "value info" : "set_value_info", \
                 "material" : "set_material", \
                 "property" : "add_property",\
                 "clone" : ({ "do_clone", file_name(this_object()) }), \
                 "money" : "adjust_money",\
                 "effect" : "add_effect",\
                 "read mess" : "add_read_mess", \
                 "short" : "set_short" ])
#define R_FUN ([ "exit" : "add_exit",\
                 "modify exit" : "modify_exit",\
                 "reset" : "add_reset_item",\
                 "dark mess" :  "set_dark_mess",\
                 "co ord" : "set_co_ord", \
                 "size" : "set_room_size", \
                 "zone" : "set_zone", \
                 "cloned object" : "add_cloned_object", \
                 "alias" : "add_alias", \
                 "sign" : "add_sign" ])
#define ARM_FUN ([ "setup" : "setup_armour",\
                   "no limbs" : "set_no_limbs", \
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "ac" : "add_ac", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "damage chance" : "set_damage_chance" ])
#define CLO_FUN ([ "setup" : "setup_clothing",\
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "pocket mess" : "set_pocket_mess", \
                   "pocket" : "add_pocket", \
                   "stuck" : "set_stuck", \
                   "key" : "set_key", \
                   "damage chance" : "set_damage_chance", \
                   "pair" : "set_is_pair" ])
#define CLOTRANS_FUN ([ \
                   "race" : "set_worn_by_race", \
                   "mount modifier" : "set_mount_difficulty_modifier", \
                   "direction modifier" : "set_direction_difficulty_modifier", \
                 ])
#define SCA_FUN ([ "setup" : "setup_scabbard",\
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "types" : "set_types", \
                   "damage chance" : "set_damage_chance" ])
#define CONT_FUN ([ \
                    "amount" : "set_amount", \
                    "continuous" : "set_continuous", \
                    "weight unit" : "set_weight_unit", \
                    "medium alias" : "set_medium_alias", \
                    "pile name" : "set_pile_name", \
                    "amount types" : "set_amount_types", \
                    "pile types" : "set_pile_types", \
                  ])
#define FOOD_FUN ([ \
                    "bites gone" : "set_bites_gone", \
                    "weight per bite" : "set_weight_per_bite", \
                    "eat mess" : "set_eat_mess", \
                    "eat effects" : "add_eat_effect", \
                    "piece description" : "set_piece_description", \
                  ])
#define WEP_FUN ([ "setup" : "new_weapon",\
                   "condition" : "set_condition", \
                   "enchant" : "set_enchant", \
                   "attack" : "add_attack", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune", \
                   "no limbs" : "set_no_limbs", \
                   "attack message" : "add_attack_message", \
                   "damage chance" : "set_damage_chance" ])
#define MON_FUN ([ "move after" : "set_move_after", \
                   "move zone" : "add_move_zone", \
                   "race" : "set_race", \
                   "class" : "set_class", \
                   "guild" : "set_guild", \
                   "level" : "set_level", \
                   "attack" : "add_attack", \
                   "attack message" : "add_attack_message", \
                   "ac" : "add_ac", \
                   "skill" : "add_skill_level", \
                   "equip" : "init_equip", \
                   "remove ac" : "remove_ac", \
                   "remove attack" : "remove_attack", \
                   "attack everyone" : "set_attack_everyone", \
                   "random stats" : "set_random_stats", \
                   "money" : "give_money", \
                   "chat" : "add_chat_string", \
                   "chat chance" : "set_chat_chance", \
                   "achat" : "add_achat_string", \
                   "achat chance" : "set_achat_chance", \
                   "talk string" : "add_talk_string", \
                   "join fights" : "set_join_fights", \
                   "alignment" : "set_al", \
                   "follow speed" : "set_follow_speed", \
                   "aggressive" : "set_aggressive", \
                   "str" : "set_str", \
                   "con" : "set_con", \
                   "dex" : "set_dex", \
                   "wis" : "set_wis", \
                   "bonus int" : "set_bonus_int", \
                   "bonus str" : "set_bonus_str", \
                   "bonus con" : "set_bonus_con", \
                   "bonus dex" : "set_bonus_dex", \
                   "bonus wis" : "set_bonus_wis", \
                   "int" : "set_int", \
                   "gender" : "set_gender", \
                   "command" : "add_known_command", \
                   "concentrate" : "set_concentrate", \
                   "protect" : "do_protect", \
                   "follow" : "do_follow", \
                   "throw out" : "set_throw_out", \
                   "basic setup" : "basic_setup" ])

==================================================
FILE: virtual/data_compiler.c
==================================================

#include "virtual.h"
#include <soul.h>
#include <random_names.h>
void initialize_methods();
void create() {
  initialize_methods();
  seteuid(getuid());
}
void initialize_methods() {
  SERVER->add_method("s",  file_name(this_object()), "compile_soul", 1);
  SERVER->add_method("r_n",  file_name(this_object()), "compile_random_name", 1);
}
object compile_soul(string name, int) {
  object ob;
  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(SOUL_DIR)-1] != SOUL_DIR) {
    return 0;
  }
  name = name[strlen(SOUL_DIR)..];
  SOUL_COMPILER->compile_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
}
object compile_random_name(string name, int clone) {
  object ob;
  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(RANDOM_NAME_DATA_DIR)-1] != RANDOM_NAME_DATA_DIR) {
    return 0;
  }
  name = name[strlen(RANDOM_NAME_DATA_DIR)..];
  RANDOM_NAME_GENERATOR->open_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
}

==================================================
FILE: virtual/efuns.c
==================================================

#define HANDLER "/global/virtual/handler"
object clone_object(string name) {
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
}
void destruct(mixed name) {
  object obj;
  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
}
string file_name(object obj) {
  string name, number, file;
  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
}
object find_object(string str) {
  object obj;
  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
}

==================================================
FILE: virtual/handler.c
==================================================

mapping cloned_objects;
create() {
  seteuid("Room");
  cloned_objects = ([ ]);
  unguarded((: restore_object, "/global/virtual/handler" :));
}
self_dest() {
  unguarded((: save_object, "/global/virtual/handler" :));
  destruct(this_object());
}
mapping query_cloned_objects() { return cloned_objects; }
destruct_virtual_object(object obj) {
  string name, trash;
  name = file_name(obj);
  if(sscanf(name, "%s#%s", name, trash) == 2)
    name = trash;
  if(cloned_objects[name])
    map_delete(cloned_objects, name);
}
object find_virtual_object(string name) {
  string trash;
  if(sscanf(name, "%s#%s", name, trash) == 2)
    name = trash;
  if(cloned_objects[name])
    return (object)cloned_objects[name];
  return (object)0;
}
int error(string str) {
  write(str+"\n");
  return 1;
}
int str_to_int(string str) {
  int i, j, k;
  for(i=strlen(str)-1,j=1;i>-1;k+=(str[i--]-48)*j,j*=10) ;
  return k;
}
mixed *sort_arguments(mixed *args) {
  int i;
  for(i=0;i<sizeof(args);i++) {
    if(pointerp(args[i]))
      args[i] = sort_arguments(args[i]);
    else if(args[i][0..0] != "\"")
      args[i] = str_to_int(args[i]);
    else {
      args[i] = args[i][1..strlen(args[i])-2];
      if(args[i][strlen(args[i])-2..strlen(args[i])-1] == "\\n")
        args[i] = args[i][0..strlen(args[i])-3] + "\n";
    }
  }
  return args;
}
mixed *add_item(mixed *args, int m, string str) {
  if(m == 0)
    args += ({ str });
  else
    args[sizeof(args)-1] = add_item(args[sizeof(args)-1], m-1, str);
  return args;
}
mixed *add_level(mixed *args, int m) {
  if(m == 0) {
    args += ({ "" });
    args[sizeof(args)-1] = ({ });
  } else
    args[sizeof(args)-1] = add_level(args[sizeof(args)-1], m-1);
  return args;
}
object use_efun_clone(string file) {
  log_file("NON_VIRTUAL", file +"\n");
  return efun::clone_object(file);
}
object clone_virtual_object(string file) {
  int i, j, k, l, m, len;
  string data, *line, file_to_inherit, start, comment, rest;
  object obj;
  mixed *args;
  if(file_size(file) > 5000)
    return use_efun_clone(file);
  data = read_file(file);
  line = explode(file, "/");
  file_to_inherit = "/" + implode(line[0..sizeof(line)-2], "/") + "/";
  line = ({ (string)0 });
  while(sscanf(data, "%s#include \"%s\"%s", start, comment, rest) == 3) {
    if(!(line[0] = read_file(file_to_inherit + comment)))
      line[0] = read_file("/include/" + comment);
    if(line[0])
      data = start + line[0] + rest;
    else {
      error("Include file not found.");
      return (object)0;
    }
  }
  while(sscanf(data, "%s%s", start, comment, rest) == 3)
    data = start + rest;
  i = 0;
  file_to_inherit = data;
  while(sscanf(file_to_inherit, "%sinherit%s", start, file_to_inherit) == 2) {
    i++;
  }
  if(i != 1)
    return use_efun_clone(file);
  i = 0;
  file_to_inherit = data;
  while(sscanf(file_to_inherit, "%s({%s", start, rest)  == 2)
    file_to_inherit = start + rest;
  while(sscanf(file_to_inherit, "%s{%s", start, file_to_inherit)  == 2)
    i++;
  if(i != 1)
    return use_efun_clone(file);
  if(!(sscanf(data, "%ssetup()%s", start, rest) == 2))
    return use_efun_clone(file);
  line = explode(data, "\n");
  line -= ({ "" });
  for(i=0;i<sizeof(line);i++) {
    len = strlen(line[i]);
    for(j=0;j<len;j++) {
      if((line[i][j..j] == " " || line[i][j..j] == "\t") && j == 0) {
        line[i] = line[i][1..len];
        j--;
      }
    }
    for(j=len-1;j>-1;j--) {
      if((line[i][j..j] == " " || line[i][j] == 0) && j == (len-1)) {
        line[i] = line[i][0..len-2];
        len--;
      }
    }
  }
  for(i=0;i<sizeof(line);i++)
    if((line[i][0..3] == "int ") ||
       (line[i][0..5] == "mixed ") ||
       (line[i][0..6] == "object ") ||
       (line[i][0..6] == "string ") ||
       (line[i][0..7] == "mapping "))
      return use_efun_clone(file);
  for(i=0;i<sizeof(line);i++)
    if(line[i][0..7] == "#define ") {
      len = strlen(line[i]);
      for(j=8;j<len && line[i][j..j] != " ";j++);
      comment = line[i][8..j-1];
      file_to_inherit = line[i][j+1..len];
      line = delete(line, i--, 1);
      if(j < len)
        for(k=0;k<sizeof(line);k++)
          if(sscanf(line[k], "%s"+comment+"%s", start, rest) == 2)
            line[k] = start + file_to_inherit + rest;
    }
  for(i=0;i<sizeof(line);i++) {
    for(j=0,k=0,l=0;j<strlen(line[i]);j++) {
      switch(line[i][j..j]) {
        case "\"" :
          if(!k) {
            k = 1;
            if(l && l+1 == j)
              if(l+2 < strlen(line[i]))
                line[i] = line[i][0..l-2] + line[i][l+2..strlen(line[i])];
              else {
                line[i] = line[i][0..l-2] + line[i+1];
                line = delete(line,i+1,1);
              }
          }
          else
            k = 0;
          break;
        case " " :
          if(!k)
            if(j)
              line[i] = line[i][0..--j] + line[i][j+2..strlen(line[i])];
            else
              line[i] = line[i][1..strlen(line[i])];
          break;
        case ";" :
          if(!k && j != strlen(line[i])-1) {
            line = line[0..i] + line[i][j+1..1000] + line[i+1..1000];
            line[i] = line[i][0..j];
            j=0;
          }
          break;
        case "+" :
          if(!k && j && line[i][j-1..j-1] == "\"")
            l = j;
          break;
      }
    }
    if((k)) {
      line[i] = line[i--] + line[i+2];
      line = delete(line,i+2,1);
    }
  }
  for(i=0;i<sizeof(line);i++) {
    len = strlen(line[i]);
    if(line[i][len-1..len-1] != ";")
      if(line[i][len-2..len-1] == "\"+") {
        if(line[i+1][0..0] == "\"")
          line[i] = line[i--][0..len-3] + line[i+2][1..1000];
        else
          line[i] = line[i--] + line[i+2];
        line = delete(line,i+2,1);
      }
  }
  for(i=0;i<sizeof(line);i++)
    if(line[i][0..6] == "inherit")
      file_to_inherit = line[i][8..sizeof(line[i])-3];
  if(file_to_inherit[0..8] == "/std/room")
    return use_efun_clone(file);
  obj = clone_object(file_to_inherit);
  obj->add_property("file_name", file);
  start = file_name(obj);
  if(sscanf(start, "%s#%s", start, rest) == 2)
    cloned_objects[rest] = obj;
  else
    cloned_objects[start] = obj;
  for(i=0;i<sizeof(line);i++)
    if(line[i] == "setup(){" || line[i] == "voidsetup(){")
      break;
  for(i++;i<sizeof(line);i++) {
    if(line[i] != "}") {
      sscanf(line[i], "%s(%s", start, comment);
      for(j=0,l=0,args=({});j<strlen(comment);j++) {
        if(comment[j..j] == "(") {
          if(comment[j+1..j+1] == "{" || comment[j+1..j+1] == "[") {
            args = add_level(args, l++);
            comment = comment[j+2..1000];
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == ")") {
          if(comment[j-1..j-1] == "}" || comment[j-1..j-1] == "]") {
            if(j-1)
              args = add_item(args, l--, comment[0..j-2]);
            comment = comment[j+1..1000];
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == "\"") {
          if(k)
            k = 0;
          else
            k = 1;
        }
        if(comment[j..j] == "," && k == 0) {
          if(!l) {
            if(j)
              args = add_item(args, l, comment[0..j-1]);
            comment = comment[j+1..1000];
            j = -1;
            continue;
          } else {
            if(comment[j+1..j+1] == "}" || comment[j+1..j+1] == "]") {
              if(!j)
                comment = comment[j+1..1000];
              else
                comment = comment[0..j-1] + comment[j+1..1000];
            } else {
              if(j)
                args = add_item(args, l, comment[0..j-1]);
              comment = comment[j+1..1000];
            }
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == ")" && k == 0 && l == 0) {
          if(comment[j-1..j-1] != "}" && comment[j-1..j-1] != "]") {
            args = add_item(args, l, comment[0..j-1]);
            comment = comment[j+1..1000];
            j = -1;
          }
        }
      }
      args = sort_arguments(args);
      switch(sizeof(args)) {
        case 1 :
          call_other(obj, start, args[0]);
          break;
        case 2 :
          call_other(obj, start, args[0], args[1]);
          break;
        case 3 :
          call_other(obj, start, args[0], args[1], args[2]);
          break;
        case 4 :
          call_other(obj, start, args[0], args[1], args[2], args[3]);
          break;
        case 5 :
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4]);
          break;
        case 6 :
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4], args[5]);
          break;
        case 7 :
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          break;
      }
    }
  }
  log_file("VIRTUAL", file +"\n");
  return obj;
}

==================================================
FILE: virtual/modified_efuns.c
==================================================

#define MAX_SIZE 50000
varargs void say(string str, mixed avoid)
{
  if (!pointerp(avoid))
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  else
    avoid += ({ this_player(), previous_object() });
  if (!environment(previous_object()))
    if(this_player() && environment(this_player()))
      event(environment(this_player()), "say", str, avoid);
    else
      event(previous_object(), "say", str, avoid);
  else
  {
    if (environment(environment(previous_object())))
      event(environment(environment(previous_object())), "say", str, avoid);
    else
      event(environment(previous_object()), "say", str, avoid);
  }
}
varargs void tell_room(object ob, string str, mixed avoid) {
  if (!ob || !objectp(ob))
    return ;
  event(ob, "say", str, avoid);
}
void tell_object(object ob, string str) {
  if (objectp(ob))
    ob->event_write(previous_object(), str);
}
object find_living(string str) {
  string nick;
  object ob;
  if (this_player() && (nick = (string)this_player()->expand_nickname(str)))
    str = nick;
  if ((ob = efun::find_living(str)))
    if ((int)ob->query_invis() == 2) {
      if (member_array(this_player()->query_name(),
                       (object *)ob->query_allowed()) == -1)
        return 0;
    }
  return ob;
}
object find_player(string str) {
  object ob;
  if ((ob = efun::find_player(str)))
    if ((int)ob->query_invis() == 2)
      if (member_array(this_player()->query_name(),
                       (object *)ob->query_allowed()) == -1)
        return 0;
  return ob;
}
void log_file(string name, string mess) {
  if (file_size("/log/"+name) > MAX_SIZE) {
    seteuid("Root");
    rm("/log/"+name+".old");
    rename("/log/"+name, "/log/"+name+".old");
  }
  seteuid("Root");
  write_file("/log/"+name, mess);
  seteuid(0);
}
#ifdef MUD_NAME
string mud_name() {
  return capitalize(MUD_NAME);
}
#endif
void cat(string file, int start_line, int number) {
  string bing;
  seteuid(geteuid(previous_object()));
  bing = read_file(file, start_line, number);
  seteuid(0);
  if (bing)
    printf("%s", bing[0..5000]);
}
#define HANDLER "/global/virtual/handler"
object clone_object(string name) {
  seteuid(geteuid(previous_object()));
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
}
void destruct(mixed name) {
  object obj;
  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
}
string file_name(object obj) {
  string name, number, file;
  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
}
object find_object(string str) {
  object obj;
  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
}

==================================================
FILE: virtual/new_c_compiler.c
==================================================

object clone_virtual_object(string name) {
  return efun::clone_object(name);
}

==================================================
FILE: virtual/server.c
==================================================

#include "virtual.h"
void add_method(string suffix, mixed ob, string fun, int type);
mapping methods;
#define OB   0
#define FUN  1
#define TYPE 2
nosave mapping cache;
void create() {
  seteuid(getuid());
  methods = ([ ]);
  add_method("c", "/global/virtual/c_compiler.c", "compile_c",
                        CLONE|LOAD);
  add_method("C", "/global/virtual/c_compiler.c", "compile_c",
                        CLONE|LOAD);
  cache = ([ ]);
}
object create_virtual_object(string name, int clone);
void add_method(string suffix, mixed ob, string fun, int type) {
  if (!type)
    type = CLONE;
  if (!methods[suffix]) {
    methods[suffix] = ({ ob, fun, type });
  }
}
#define Error(s) write(s); log_file("VO_HANDLER", s); return 0;
string get_mod_time(string name) {
  if(cache[name])
    return cache[name];
  if(file_size(name) <= 0)
    cache[name] = "";
  else
    cache[name] = stat(name)[1];
  return cache[name];
}
object create_virtual_object(string name, int clone) {
  string *split;
  mixed  *method;
  object ob;
  split = explode(name, ".");
  method = methods[split[sizeof(split) - 1]];
  if (method) {
    if (clone ||
        (method[TYPE]&LOAD)) {
      ob =  (object) call_other(method[OB], method[FUN], name, clone);
      if (ob)  {
      ob->add_property(VIRTUAL_NAME_PROP, name);
        if (get_mod_time(name) != "")
          ob->add_property("virtual time", get_mod_time(name));
      }
      return ob;
    }
    return 0;
  }
  Error("create_virtual_object() : unknown suffix to " + name + "\n");
}
void reset() {
  cache = ([ ]);
}

==================================================
FILE: virtual/server2.c
==================================================

#include "virtual.h"
void add_method(string suffix, object ob, string fun, int type);
mapping methods;
#define OB   0
#define FUN  1
#define TYPE 2
#define LOAD   1
#define CLONE  2
void create() {
  seteuid(getuid());
  methods = ([ ]);
  add_method("C", "/global/virtual/c_compiler.c", "compile_c",
                        CLONE|LOAD);
}
object create_virtual_object(string name, int clone);
void add_method(string suffix, object ob, string fun, int type) {
  if (!type)
    type = CLONE;
  if (!methods[suffix]) {
    methods[suffix] = ({ ob, fun, type });
  }
}
#define Error(s) write(s); log_file("VO_HANDLER", s); return 0;
object create_virtual_object(string name, int clone) {
  string *split;
  mixed  *method;
  object ob;
  split = explode(name, ".");
  method = methods[split[sizeof(split) - 1]];
  if (method) {
    if (clone ||
        (method[TYPE]&LOAD)) {
      ob =  (object) call_other(method[OB], method[FUN], name, clone);
      ob->add_property("virtual name", name);
      return ob;
    }
    return 0;
  }
  Error("create_virtual_object() : unknown suffix to " + name + "\n");
}

==================================================
FILE: virtual/virtual.h
==================================================

#include <virtual.h>
#define SERVER "/global/virtual/server"
#define LOAD   1
#define CLONE  2

==================================================
FILE: virtual/vr_hand.c
==================================================

object compile_virtual_room(string filename);
void parse_object(object room, string command);
void create()
{
  seteuid(getuid(this_object()));
}
object compile_virtual_room(string filen)
{
  string tmp, tmp2;
  object new_room;
  int i;
  i=3;
  tmp=read_file(filen, 2, 1);
  tmp2=tmp[1..strlen(tmp)-2];
  new_room=clone_object("/"+tmp2);
  while (read_file(filen, i, 1))
  {
    tmp=read_file(filen, i, 1);
    if(tmp=="") break;
    parse_object(new_room, tmp);
    i++;
  }
  return new_room;
}
void parse_object(object room, string command)
{
  string *func_call,s1,s2,s3;
  int i1,i2,i3,i4;
  if(!command) return;
  func_call=explode(command, "#");
  if((string)func_call[0][0]==";") return;
  switch (func_call[0])
  {
    case "SHORT" :
      room->set_short(func_call[1]);
      break;
    case "LONG" :
      room->set_long(func_call[1]);
      break;
    case "EXIT" :
      room->add_exit(func_call[1], func_call[2]);
      break;
    case "LIGHT" :
      i1=sscanf(func_call[1], "%d", i2);
      room->set_light(i2);
      break;
    case "ITEM" :
      room->add_item(explode(func_call[1], ","), explode(func_call[2], ","));
      break;
    case "TASTE" :
      room->add_taste(func_call[1], func_call[2]);
      break;
    case "SMELL" :
      room->add_smell(func_call[1], func_call[2]);
      break;
    case "SOUND" :
      room->add_sound(func_call[1], func_call[2]);
      break;
    case "TOUCH" :
      room->add_feel(func_call[1], func_call[2]);
      break;
    case "OBJECT" :
      room->add_object(func_call[1]);
      break;
    case "ACTION" :
      i2=0;
      catch(i1=sscanf(func_call[3], "%d", i2));
      room->action_add(func_call[1], func_call[2], i2);
      break;
    case "CODE" :
      room->set_code_module(func_call[1]);
      break;
    case "PROP" :
      room->add_property(func_call[1], func_call[2]);
      break;
    case "COORD" :
      i1=sscanf(func_call[1], "%d,%d,%d", i2,i3,i4);
      room->set_co_ord(({i2,i3,i4}));
      break;
  }
  return;
}

==================================================
FILE: virtual/setup_compiler/Outside.c
==================================================

inherit "/std/outside.c";
#include "Room.inc"

==================================================
FILE: virtual/setup_compiler/Room.c
==================================================

inherit "/std/room.c";
#include "Room.inc"

==================================================
FILE: virtual/setup_compiler/SetupCompiler.c
==================================================

#include "SetupCompiler.h"
void initialize_methods();
object return_ob;
int tmp_file_no;
void create() {
  seteuid(getuid(this_object()));
  initialize_methods();
}
object query_return_ob() { return return_ob; }
void set_return_ob(object ob) { return_ob = ob; }
void initialize_methods() {
    SERVER->add_method("vrm",  file_name(this_object()), "compile_vrm");
    SERVER->add_method("vro",  file_name(this_object()), "compile_vro");
    SERVER->add_method("vrw",  file_name(this_object()), "compile_vrw");
    SERVER->add_method("vra",  file_name(this_object()), "compile_vra");
    SERVER->add_method("vrc",  file_name(this_object()), "compile_vrc");
}
#define Error(s) write(s); log_file("VO_COMPILER", s); return 0;
object prop_to_fun(string file, int clone, string incfile ) {
    string  data, data2, s1, *ind, dir, tmp_name;
    int      i;
    tmp_name = file+"-"+(tmp_file_no++)+".c";
    if (find_object(tmp_name))
      tmp_name->dest_me();
    ind = explode(file, "/");
    dir = implode(ind[0..sizeof(ind)-2], "/");
    unguarded((: rm, tmp_name :));
    unguarded((: write_file, tmp_name,
               "object MyRoom;\n"
               "#include \""+incfile+"\"\n\n"
               "object this_room() { return MyRoom; }\n" :));
    data = read_file(file);
    if (!data) {
        Error("prop_to_fun() : file " + file + " not found\n");
    }
    unguarded((: write_file, tmp_name, data :));
    unguarded((: write_file, tmp_name, "\n\n"
               "void dest_me() { destruct(this_object()); }\n\n"
               "void setup();\n\n"
               "void create() {\n"
               "  seteuid((string)\"/secure/master\"->"
               "creator_file(this_object()));\n"
               "  MyRoom = (object)\""+SERVER+
               "\"->create_virtual_object(CLONEFILE, 1);\n"
               "  MyRoom->add_property(\"virtual name\", \""+
               file+(clone?"#1":"")+"\");\n"
               "\n  setup();\n"+
               "\n MyRoom->reset(); \n"
               "  \""+file_name(this_object())+"\"->"
               "set_return_ob(MyRoom);\n} \n" :));
    if (data = catch(tmp_name->bing())) {
      write("Error loading "+file+", "+data+"\n");
      write("File could not be loaded.\n");
    } else {
      tmp_name->dest_me();
      unguarded((: rm, tmp_name :));
      return return_ob;
    }
}
object compile_vrc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+ROOMFUNCS );
}
object compile_vmc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+MON_FUNCS );
}
object compile_vac(string name, int clone) {
    return prop_to_fun(name, clone, PATH+ARM_FUNCS );
}
object compile_vwc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+WEP_FUNCS );
}
object compile_voc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+OBJ_FUNCS );
}

==================================================
FILE: virtual/setup_compiler/SetupCompiler.h
==================================================

#define TMP_FILE "/global/virtual/tmp_file.c"
#define SERVER "/global/virtual/server"
#define PATH  "/global/virtual/setup_compiler/"
#define ROOMFUNCS  "VirtualRoom.h"
#define WEP_FUNCS  "VirtualWeapon.h"
#define OBJ_FUNCS  "VirtualObject.h"
#define ARM_FUNCS  "VirtualArmour.h"
#define MON_FUNCS  "VritualMonster.h"

==================================================
FILE: virtual/setup_compiler/UWater.c
==================================================

inherit "/std/uwater.c";
#include "Room.inc"

==================================================
FILE: virtual/setup_compiler/VirtualRoom.h
==================================================

#define CLONEFILE "/global/virtual/setup_compiler/Room.c"
mixed add_item(mixed a1, mixed a2)
 { MyRoom->add_item(a1,a2); }
mixed set_name(mixed a1)
 { MyRoom->set_name(a1); }
mixed set_long(mixed a1)
 { MyRoom->set_long(a1); }
mixed set_light(mixed a1)
 { MyRoom->set_light(a1); }
mixed add_property(mixed a1, mixed a2)
 { MyRoom->add_property(a1,a2); }
mixed set_short(mixed a1)
 { MyRoom->set_short(a1); }
mixed add_exit(string a1, string a2, string a3)
{
	if( file_size(a2) > 0 )
		{ MyRoom->add_exit(a1,a2,a3); return; }
	if( file_size(a2+".c") > 0 )
		{ MyRoom->add_exit(a1,a2+".c",a3); return ; }
	if( file_size(a2+".vrc") > 0 )
		{ MyRoom->add_exit(a1,a2+".vrc",a3); return; }
	if( file_size(a2+".r") > 0 )
		{ MyRoom->add_exit(a1,a2+".r",a3); return; }
	write("Error: Bad arg 2 to add_exit in virtual room");
	return;
}
mixed modify_exit(string m1, mixed *m2)
 { MyRoom->modify_exit(m1,m2); }
mixed set_dark_mess(mixed a1)
 { MyRoom->set_dark_mess(a1); }
mixed set_co_ord(mixed a1)
 { MyRoom->set_co_ord(a1); }
mixed set_zone(mixed a1)
 { MyRoom->set_zone(a1); }
void add_reset_func( mixed ob, string func )
{
  MyRoom->add_reset_func( ob, func );
}
void add_dest_func( mixed ob, string func )
{
  MyRoom->add_dest_func( ob, func );
}
void add_enter_func( mixed ob, string func )
{
  MyRoom->add_enter_func( ob, func );
}
void add_exit_func( mixed ob, string func )
{
  MyRoom->add_exit_func( ob, func );
}
void add_death_func( mixed ob, string func )
{
  MyRoom->add_death_func( ob, func );
}
void add_clone_on_reset( string fname )
{
  MyRoom->add_clone_on_reset( fname );
}
#include "/w/mithal/UTIL/use_comments.h"

==================================================
FILE: handlers/more_string.c
==================================================

#define COLS (int)this_object()->query_cols()
#define ROWS ( (int)this_object()->query_rows() - 1 )
class more_string_info {
   int fsize;
   int topl;
   int botl;
   string last_search;
   string *the_bit;
   string finish_func;
   string more_bit;
   string stat_line;
   object finish_ob;
}
nosave mixed *_pending_more;
class more_string_info _current_info;
int internal_more_string();
void create() {
   add_command("Internal_More_String", "<string>", (:internal_more_string:));
}
void string_display_file(class more_string_info info) {
  int i;
  string stuff;
  info->botl = info->topl + ROWS;
  stuff = "";
  for ( i = info->topl; ( i < info->botl ) && ( i < info->fsize ); i++ ) {
    stuff += info->the_bit[ i ] +"\n";
  }
  efun::tell_object( this_object(), stuff );
}
void more_string_status_line(class more_string_info info) {
   string *frog;
   string s;
   int i;
   int percentage;
   if (!info->stat_line) {
      info->stat_line = "$N From $T to $B of $S ($%%) - h for help. ";
   }
   s = "";
   frog = explode(info->stat_line, "$");
   for (i=0;i<sizeof(frog);i++) {
      if (frog[i] == "") {
         s += "$";
         i ++;
      } else switch (frog[i][0]) {
         case 'N' :
            s += info->more_bit+frog[i][1..];
            break;
         case 'T' :
            s += ( info->topl + 1 ) + frog[ i ][ 1 .. ];
            break;
         case 'B' :
            if (info->botl > info->fsize)
               s += info->fsize+frog[i][1..];
            else
               s += info->botl+frog[i][1..];
            break;
         case '%' :
            percentage = (info->botl*100)/info->fsize;
            if (percentage > 100) {
               percentage = 100;
            }
            s += percentage + frog[i][1..];
            break;
         case 'S' :
            s += info->fsize + frog[i][1..];
            break;
      }
   }
   efun::tell_object( this_object(), (string)this_object()->fix_string( s ) );
   return;
}
void string_next_page(string str, class more_string_info info) {
   int num;
   int noargs;
   int i;
   int redraw;
   string s1;
   if (!str) {
     str = "";
   }
   if (sscanf(str,"%d%s", num, str) != 2) {
     noargs = 1;
   }
   s1 = str[1..];
   if (str == "") {
      str = "f";
   }
   switch(str[0]) {
      case 'h' :
         cat("/doc/helpdir/more");
         break;
      case 'q' :
         if (info->finish_func) {
            if (functionp(info->finish_func)) {
               evaluate(info->finish_func);
            } else {
               call_other(info->finish_ob, info->finish_func);
            }
         }
         info->finish_func = 0;
         _current_info = 0;
         return;
      case 'f' :
      case 'F' :
         info->topl += ROWS;
         redraw = 1;
         break;
      case 'b' :
      case 'B' :
         info->topl -= ROWS;
         redraw = 1;
         break;
      case '/' :
         i = info->topl + 4;
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 4; i < info->fsize; i++) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == info->fsize) {
            tell_object( this_object(), "Sorry "+ s1 +" not found.\n" );
         } else {
            tell_object( this_object(), "Found " + s1 + " on line "+ i +".\n");
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case '?' :
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 2; i > 0; i--) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == 0) {
            tell_object(this_object(), "Sorry " + s1 + " not found.\n");
         } else {
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case 'b' :
         if (info->topl > 0) {
            info->topl -= ROWS;
            redraw = 1;
            if (info->topl < 0) {
               info->topl = 0;
            }
         }
         break;
      case 'g' :
         info->topl = num;
         if (info->topl >= info->fsize)
            info->topl = info->fsize - 2;
         redraw = 1;
         break;
      case 'G' :
         redraw = 1;
         if (noargs)
            info->topl = info->fsize - ROWS;
         else
            info->topl = num;
         if (info->topl > info->fsize)
            info->topl = info->fsize - 2;
         break;
   }
   if (redraw) {
      string_display_file(info);
      if ( info->botl < info->fsize ) {
         more_string_status_line(info);
         input_to("string_next_page", 0, info);
      } else {
         if (info->finish_func) {
            if ( info->finish_ob ) {
               call_other(info->finish_ob, info->finish_func);
            }
            info->finish_func = 0;
         }
         _current_info = 0;
      }
   } else {
      more_string_status_line(info);
      input_to("string_next_page", 0, info);
   }
}
varargs int more_string( string text, string bity, int noreline ) {
  int i, ncols;
  string *bits;
  class more_string_info info;
  if ( this_player() != this_object() ){
     if ( !_pending_more ) {
        _pending_more = ({ ({ text, bity, noreline }) });
     } else {
        _pending_more += ({ ({ text, bity, noreline }) });
     }
     this_object()->ignore_from_history("Internal_More_String something");
     command( "Internal_More_String something" );
     return 1;
  }
  _current_info = info = new(class more_string_info);
  if ( bity ) {
    info->more_bit = bity;
  } else {
    info->more_bit = "--- MORE";
  }
  info->last_search = "";
  if ( !stringp( text ) || !strlen( text ) ) {
    return notify_fail( "Empty string.\n" );
  }
  if ( noreline ) {
    info->the_bit = explode( this_object()->fix_string( text ), "\n" );
  } else {
    info->the_bit = ({ });
    ncols = COLS;
    bits = explode( text, "\n" );
    for ( i = 0; i < sizeof( bits ); i++ ) {
      reset_eval_cost();
      if ( bits[ i ] == "" ) {
        info->the_bit += ({ "" });
      } else {
        info->the_bit +=
          explode( this_object()->fix_string( bits[ i ], ncols ), "\n" );
      }
    }
  }
  info->fsize = sizeof( info->the_bit );
  info->topl = 0;
  string_display_file(info);
  if ( info->botl < info->fsize ) {
    more_string_status_line(info);
    input_to( "string_next_page", 0, info );
  } else {
      if ( info->finish_func ) {
         if ( !info->finish_ob ) {
            info->finish_func = 0;
            return 1;
         }
         call_other( info->finish_ob, info->finish_func );
         info->finish_func = 0;
      }
      _current_info = 0;
  }
  return 1;
}
varargs void set_finish_func(string str, object ob) {
  _current_info->finish_func = str;
  if (!ob) {
    _current_info->finish_ob = previous_object();
  } else {
    _current_info->finish_ob = ob;
  }
}
int internal_more_string() {
   string text, bity;
   int noreline;
   if ( sizeof( _pending_more ) ) {
      text = _pending_more[ 0 ][ 0 ];
      bity = _pending_more[ 0 ][ 1 ];
      noreline = _pending_more[ 0 ][ 2 ];
      _pending_more = _pending_more[ 1 .. <1 ];
      more_string( text, bity, noreline );
   }
   return 1;
}
