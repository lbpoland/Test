# Total Tokens: 25350
# Total Files Merged: 27
# Total Characters: 84572

m/furniture/inherit/furniture_base.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <housing.h>
#include <room/placement.h>
void add_property(string name, mixed type);
mixed query_property(string name);
string one_short();
int query_light_needs_inform();
void inform_of_light_level_change(object ob);
private nosave mapping _allowed_room_verbs;
private nosave string *_allowed_positions;
private nosave string _bonded;
void create() {
  _allowed_positions = ({ });
  if (base_name(this_object()) + ".c" != __FILE__) {
    if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
    }
    this_object()->set_max_cond(100000);
    this_object()->set_cond(100000);
  }
  if(clonep(this_object()) &&
     base_name(this_object())[0..14] != "/obj/furnitures" &&
     base_name(this_object())[0..2] != "/w/" &&
     strsrch (base_name(this_object()), "_dev") == -1 &&
     strsrch (base_name(this_object()), "_pt") == -1) {
    call_out("move", 2, "/room/void");
  }
}
int query_furniture() {
   return 1;
}
void set_allowed_positions(string *positions) {
   _allowed_positions = positions;
}
void remove_allowed_positions( string *positions ){
  _allowed_positions -= positions;
}
string* query_allowed_positions() {
   return _allowed_positions;
}
void set_allowed_room_verbs( mapping allowed ) {
  _allowed_room_verbs = allowed;
}
mapping query_allowed_room_verbs() {
   return _allowed_room_verbs;
}
string query_position_string(string position_type) {
  if(member_array(position_type, _allowed_positions) != -1) {
    return one_short();
  }
  return 0;
}
void set_bonded(string person) {
   _bonded = person;
}
string query_bonded() {
   return _bonded;
}
string query_owner() {
   return _bonded;
}
int is_allowed_to_mess(object player) {
  mixed *stuff;
  string occupier;
  if(environment() && !function_exists("query_owner", environment()))
    return 1;
  if(player->query_creator())
    return 1;
  if(player->query_caster())
    player = find_player(player->query_caster());
  if(player->query_owner())
    player = player->query_owner();
  if (player && player->query_name() == _bonded)
    return 1;
  stuff = this_object()->query_property("dropped");
  if(player && sizeof(stuff) && stuff[0] == player->query_name())
    return 1;
  if(player && environment()) {
    if(environment()->test_occupier(player->query_name()))
      return 1;
    if(environment()->query_owner() == "For Sale" ||
       environment()->query_owner() == "Under Offer")
      return 1;
    occupier = HOUSING->query_owner(base_name(environment()));
    if(pk_check(player, occupier, 1))
      return 0;
  }
  return (!_bonded);
}
int move_check(object dest) {
  if (living(dest)) {
    if (!is_allowed_to_mess(dest)) {
       return 0;
    }
  } else if (this_player() && environment()) {
    if (!(living(environment()) && dest == environment(environment()))) {
       if (!is_allowed_to_mess(this_player())) {
          return 0;
       }
    }
  }
  return 1;
}
string query_placement_verb() {
   return query_property(PLACEMENT_CURRENT_ROOM_VERB);
}
string query_placement_other() {
   return query_property(PLACEMENT_CURRENT_ROOM_OTHER);
}
string query_placement_position() {
   return query_property(PLACEMENT_CURRENT_ROOM_POSITION);
}
int query_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}
int is_placed() {
   return query_placement_position() &&
     stringp(query_placement_verb()) &&
     stringp(query_placement_other());
}
void set_placement_verb(string verb) {
   add_property(PLACEMENT_CURRENT_ROOM_VERB, verb);
}
void set_placement_other(string other) {
   add_property(PLACEMENT_CURRENT_ROOM_OTHER, other);
}
void set_placement_position(string position) {
   add_property(PLACEMENT_CURRENT_ROOM_POSITION, position);
}
int set_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}

==================================================
FILE: /lib/std/room/furniture/inherit/one_armed_bandit_inherit.c
==================================================

#include <money.h>
int do_slot();
int do_pull_lever();
int do_read_dial();
int set_coin_type( string coin );
int set_chances( int c1, int c2, int c3, int c4, int c5 );
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot );
int* query_prizes();
int* query_chances();
string query_coin_type();
void rollem( object player );
string my_short();
private string *animal = ({"albatross", "frog", "hippo", "turtle", "cabbage"});
private string *adject = ({"A crazy", "A dancing", "A sad", "A floopy", "A bemused",
    "A sarcastic", "A quizzical", "A startled", "A friendly", "A mindless"});
private string _coin = "Ankh-Morpork pence", _coin_short = "pence",
    _coin_pl = "Ankh-Morpork pence";
private int _busy = 0;
private int* _chances = ({1,1,1,1,1});
private int* _prizes = ({2,2,2,2,2,3});
void init(){
    this_player()->add_command( "slot", this_object(),
        _coin_short + " into <direct:object>", (: do_slot() :) );
    this_player()->add_command( "pull", this_object(),
        "lever on <direct:object>", (: do_pull_lever() :) );
    this_player()->add_command( "read", this_object(),
        "dial on <direct:object>", (: do_read_dial() :) );
}
int set_coin_type( string coin ) {
    if( member_array( coin, MONEY_HAND->query_valid_types() ) == -1 )
        return 0;
    _coin = coin;
    _coin_short = MONEY_HAND->query_aliases_for( coin )[0];
    _coin_pl = MONEY_HAND->query_main_plural_for( coin );
    return 1;
}
int set_chances( int c1, int c2, int c3, int c4, int c5 ) {
    if( !( c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c5 > 0 ) )
        return 0;
    _chances = ({ c1, ( c1 + c2 ), ( c1 + c2 + c3 ), ( c1 + c2 + c3 + c4 ),
        ( c1 + c2 + c3 + c4 + c5 ) });
    return 1;
}
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot ) {
    if( !( p1 > 1 && p2 > 1 && p3 > 1 && p4 > 1 && p5 > 1 && jackpot > 1 ) ||
        ( jackpot <= p1 || jackpot <= p2 || jackpot <= p3 ||
        jackpot <= p4 || jackpot <= p5 ) )
        return 0;
    _prizes = ({p1, p2, p3, p4, p5, jackpot});
    return 1;
}
int do_slot() {
    if( member_array( _coin, this_player()->query_money_array() ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
            "You need " + add_a( _coin ) + " to play.\n", ({ }) );
        return 0;
    }
    if( _busy == 1 ) {
        this_player()->add_failed_mess( this_object(),
            "There is already a coin inserted.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are still spinning.\n", ({ }) );
        return 0;
    }
    this_player()->adjust_money( -1, _coin );
    this_object()->adjust_money( 1 );
    _busy = 1;
    this_player()->add_succeeded_mess( this_object(),
        "$N insert$s " + add_a( _coin_short ) + " into $D.\n", ({ }) );
    return 1;
}
int do_pull_lever() {
    if( _busy == 0 ) {
        this_player()->add_failed_mess( this_object(),
            "You must put a coin in the slot before you can play.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are already spinning.\n", ({ }) );
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(),
        ({"You pull the lever.  The pictures behind the windows blur... one by "
             "one they are replaced by a new picture that appears with a sharp "
             "click.\n",
        "$N pull$s the lever on $D and the machine whirs softly.  The sound is "
        "cut short by three sharp clicks.\n"
        }), ({ }) );
    call_out( "rollem", 0, this_player() );
    _busy = 2;
    return 1;
}
void rollem( object player ) {
    int a1, a2, a3, c;
    int adj1 = random( 10 ),
        adj2 = random( 10 ),
        adj3 = random( 10 );
    c = random( _chances[4] );
    if( c < _chances[0] )
        a1 = 0;
    else if( c < _chances[1] )
        a1 = 1;
    else if( c < _chances[2] )
        a1 = 2;
    else if( c < _chances[3] )
        a1 = 3;
    else
        a1 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a2 = 0;
    else if( c < _chances[1] )
        a2 = 1;
    else if( c < _chances[2] )
        a2 = 2;
    else if( c < _chances[3] )
        a2 = 3;
    else
        a2 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a3 = 0;
    else if( c < _chances[1] )
        a3 = 1;
    else if( c < _chances[2] )
        a3 = 2;
    else if( c < _chances[3] )
        a3 = 3;
    else
        a3 = 4;
    tell_object( player,
        "The windows now show these pictures :\n\n"
         "        " + adject[ adj1 ] + " " + animal[ a1 ] +
         "    " + adject[ adj2 ] + " " + animal[ a2 ] +
         "    " + adject[ adj3 ] + " "+animal[ a3 ] + "\n\n" );
    if( a1 == a2 && a1 == a3 ) {
        if( adj1 == adj2 && adj1 == adj3 ) {
            tell_object( player,
                "WOW!!  A triple " + adject[ adj1 ] + " " + animal[ a1 ] +
                "!!  You really hit the jackpot this time!\n\n"
                "Whistles and bells start sounding like crazy, the whole " +
                this_object()->short() +  " glows with flashing lights.  There "
                "is a loud tingling as " + _prizes[5] + " " +
                MONEY_HAND->query_plural_for( _coin ) + " drop into the tray "
                "of " + my_short() + ".  Slightly stunned you quickly scoop "
                "it up and cackle with delight.\n" );
            tell_room( environment( this_object() ),
                "Whistles and bells start sounding and " + my_short() +
                " starts to flash with coloured lights.  Someone must have "
                "won the jackpot...lucky buggers.  As you watch some coins "
                "drop into the tray at the bottom of " + my_short() + ", " +
                player->one_short() + " snatches it up and cackles with "
                "delight.\n", ({player}) );
            player->adjust_money( _prizes[5] ,_coin );
            this_object()->adjust_money( -(_prizes[ 5 ]) );
            _busy = 0;
            return;
        }
        tell_object( player,
            "Congratulations!  You scored a triple " + animal[ a1 ] + "!\n" );
        player->adjust_money( _prizes[ a1 ], _coin );
        tell_object( player,
            _prizes[ a1 ]+ " " + MONEY_HAND->query_plural_for( _coin ) +
            " fall into the tray at the bottom of " + my_short() + ".  You "
            "quickly scoop them up before anyone else can snaffle them.\n" );
        tell_room( environment( this_object() ),
            player->one_short() + " deftly scoops some coins from the tray at "
            "the bottom of " + my_short() + ".\n", ({player}) );
        this_object()->adjust_money( -(_prizes[ a1 ]) );
        _busy = 0;
        return;
    }
    tell_object( player,
        "You didn't win.  Why not have another go and attempt to recoup your "
        "losses?\n" );
    _busy = 0;
}
int* query_chances() {
    int* tmp = ({ });
    tmp += ({ _chances[0] });
    tmp += ({ _chances[1] - _chances[0] });
    tmp += ({ _chances[2] - _chances[1] });
    tmp += ({ _chances[3] - _chances[2] });
    tmp += ({ _chances[4] - _chances[3] });
    return tmp;
}
int* query_prizes() {
    return _prizes;
}
string query_coin_type() {
    return _coin;
}
string my_short() {
    return this_object()->the_short();
}
int do_read_dial() {
    string tmp =
        "Stake        : 1 " + _coin_pl + "\n"
        "3x Albatross : " + _prizes[0] + " " + _coin_pl + "\n"
        "3x Frog      : " + _prizes[1] + " " + _coin_pl + "\n"
        "3x Hippo     : " + _prizes[2] + " " + _coin_pl + "\n"
        "3x Turtle    : " + _prizes[3] + " " + _coin_pl + "\n"
        "3x Cabbage   : " + _prizes[4] + " " + _coin_pl + "\n"
        "JACKPOT      : " + _prizes[5] + " " + _coin_pl + "\n";
    this_player()->add_succeeded_mess( this_object(),
        ({tmp, "$N read$s the dial on $D.\n"}), ({ }) );
    return 1;
}

==================================================
FILE: /lib/std/room/furniture/games/card_base.c
==================================================

#include <room/card_base.h>
#define CARD_NUM_MAX CARD_NUMBER_KING
int is_card_red(class playing_card card);
class playing_card* make_deck(int number_of_decks,
                              int number_of_jokers) {
   class playing_card* deck;
   class playing_card card;
   int i;
   int suit;
   int num;
   deck = ({ });
   for (i = 0; i < number_of_decks; i++) {
      for (suit = CARD_SUIT_HEARTS; suit <= CARD_SUIT_SPADES; suit++) {
         for (num = 1; num <= CARD_NUM_MAX; num++) {
            card = new(class playing_card);
            card->suit = suit;
            card->number = num;
            deck += ({ card });
         }
      }
   }
   for (i = 0; i < number_of_jokers; i++) {
      card = new(class playing_card);
      card->suit = CARD_SUIT_JOKER;
      deck += ({ card });
   }
   return deck;
}
class playing_card* shuffle_deck(class playing_card* deck) {
   class playing_card* new_deck;
   int pos;
   int i;
   for (i = 0; i < 2; i++) {
      new_deck = ({ });
      while (sizeof(deck)) {
         pos = random(sizeof(deck));
         new_deck += deck[pos..pos];
         deck = deck[0..pos - 1] + deck[pos+1..];
      }
      deck = new_deck;
   }
   return deck;
}
string query_suit_letter(int suit) {
   switch (suit) {
   case CARD_SUIT_SPADES :
      return "S";
      break;
   case CARD_SUIT_HEARTS :
      return "H";
      break;
   case CARD_SUIT_DIAMONDS :
      return "D";
      break;
   case CARD_SUIT_CLUBS :
      return "C";
      break;
   case CARD_SUIT_JOKER :
      return "J";
   }
}
string query_card_string(class playing_card card) {
   string ret;
   string colour;
   if (card->suit == CARD_SUIT_JOKER) {
      return "*J*";
   }
   ret = query_suit_letter(card->suit) + "%^RESET%^";
   if (is_card_red(card)) {
      colour = "%^BOLD%^%^RED%^";
   } else {
      colour = "%^BOLD%^";
   }
   if (card->number > 10 || card->number == CARD_NUMBER_ACE) {
      switch (card->number) {
      case CARD_NUMBER_JACK :
         ret = colour + "J " + ret;
         break;
      case CARD_NUMBER_QUEEN :
         ret = colour + "Q " + ret;
         break;
      case CARD_NUMBER_KING :
         ret = colour + "K " + ret;
         break;
      case CARD_NUMBER_ACE :
         ret = colour + "A " + ret;
         break;
      }
   } else {
      ret = sprintf("%s%-2d%s", colour, card->number, ret);
   }
   return ret + "%^RESET%^";
}
int is_card_red(class playing_card card) {
   return card->suit == CARD_SUIT_HEARTS || card->suit == CARD_SUIT_DIAMONDS;
}
int is_card_black(class playing_card card) {
   return card->suit == CARD_SUIT_SPADES || card->suit == CARD_SUIT_CLUBS;
}
int is_card_joker(class playing_card card) {
   return card->suit == CARD_SUIT_JOKER;
}
string* query_card_three(class playing_card card) {
   string* lines;
   if (is_card_red(card)) {
      lines = allocate(3, "%^BOLD%^%^RED%^");
   } else {
      lines = allocate(3, "%^BOLD%^");
   }
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] += "H  %^RESET%^";
      lines[2] += "  H%^RESET%^";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] += "D  %^RESET%^";
      lines[2] += "  D%^RESET%^";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] += "C  %^RESET%^";
      lines[2] += "  C%^RESET%^";
      break;
   case CARD_SUIT_SPADES :
      lines[0] += "S  %^RESET%^";
      lines[2] += "  S%^RESET%^";
      break;
   case CARD_SUIT_JOKER :
      lines[0] += "J *%^RESET%^";
      lines[1] += " O %^RESET%^";
      lines[2] += "* K%^RESET%^";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      if (card->number == 10) {
         lines[1] += " 10%^RESET%^";
      } else {
         lines[1] += " " + card->number + " %^RESET%^";
      }
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] += " K %^RESET%^";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] += " Q %^RESET%^";
         break;
      case CARD_NUMBER_JACK :
         lines[1] += " J %^RESET%^";
         break;
      case CARD_NUMBER_ACE :
         lines[1] += " A %^RESET%^";
         break;
      }
   }
   return lines;
}
string* query_card_two(class playing_card card) {
   string* lines;
   lines = allocate(2);
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] = "H ";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] = "D ";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] = "C ";
      break;
   case CARD_SUIT_SPADES :
      lines[0] = "S ";
      break;
   case CARD_SUIT_JOKER :
      lines[0] = "J*";
      lines[1] = "*O";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      lines[1] = sprintf("%2d", card->number);
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] = " K";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] = " Q";
         break;
      case CARD_NUMBER_JACK :
         lines[1] = " J";
         break;
      case CARD_NUMBER_ACE :
         lines[1] = " A";
         break;
      }
   }
   return lines;
}
string query_hand_string(class playing_card* hand, int flags, int cols) {
   string hand_str;
   int i;
   int j;
   int width;
   int start_pos;
   string top;
   string line;
   string start;
   string end;
   string start_space;
   string end_space;
   mixed card_str;
   if (!sizeof(hand)) {
      return "No cards\n";
   }
   hand_str = "";
   if (!(flags & CARD_HAND_NO_ADORNMENTS)) {
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         top = "+---+";
         width = 5;
      } else {
         top = "+--+";
         width = 4;
      }
      start = "|";
      end = "|";
      start_space = " ";
      end_space = " ";
   } else {
      top = 0;
      line = "";
      start = " ";
      end = " ";
      start_space = " ";
      end_space = " ";
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         width = 3;
      } else {
         width = 2;
      }
   }
   start_pos = 0;
   if (flags & CARD_HAND_THREE) {
      card_str = map(hand, (: query_card_three :));
   } else if (flags & CARD_HAND_SINGLE) {
      card_str = map(hand, (: ({ query_card_string($1) }) :));
   } else {
      card_str = map(hand, (: query_card_two :));
   }
   while (start_pos < sizeof(hand)) {
      if (top) {
         line = "";
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            line += top;
         }
         line += "\n";
      }
      if (flags & CARD_HAND_LETTERS) {
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            if (flags & CARD_HAND_THREE) {
               hand_str += start_space + sprintf(" %c ", 'A' + i + start_pos) + end_space;
            } else {
               hand_str += start_space + sprintf("%c ", 'A' + i + start_pos) + end_space;
            }
         }
      }
      hand_str += "\n" + line;
      for (j = 0; j < sizeof(card_str[0]); j++) {
         for (i = 0; i + start_pos < sizeof(card_str) && (i + 1) * width < cols; i++) {
            hand_str += start + (card_str[i + start_pos][j]) + end;
         }
         hand_str += "\n";
      }
      hand_str += line;
      start_pos += cols / width;
   }
   return hand_str;
}
private int compare_cards(class playing_card card1, class playing_card card2,
                          int flags) {
   if (card1->suit == card2->suit ||
       (flags & 2)) {
      if (!(flags & 1)) {
         return card1->number - card2->number;
      }
      if (card1->number == CARD_NUMBER_ACE) {
         return 1;
      }
      if (card2->number == CARD_NUMBER_ACE) {
         return -1;
      }
      return card1->number - card2->number;
   }
   return card1->suit - card2->suit;
}
class playing_card* sort_cards(class playing_card* deck, int flags) {
   return sort_array(deck,
                (: compare_cards($1, $2, $(flags)) :));
}

==================================================
FILE: /lib/std/room/furniture/games/multiplayer_base.c
==================================================

private inherit "/std/basic/auto_load";
#define LOAD_TAG "multiplayer base"
class player_info {
   int number;
   string cap_name;
   string name;
   mixed data;
}
private mapping _players;
private string _winner;
private string* _ids_when_started;
private string _current_player;
private int _minimum_needed;
private int _maximum_allowed;
private int _can_join_as_new;
private int _game_started;
string* query_currently_playing_ids();
void delete_gone_players();
string find_player_id_of_person(object person);
void create() {
   _players = ([ ]);
   _ids_when_started = ({ });
}
void reset_game() {
}
int start_game() {
   delete_gone_players();
   if (sizeof(query_currently_playing_ids()) < _minimum_needed) {
      return 0;
   }
   _winner = 0;
   _game_started = 1;
   _ids_when_started = query_currently_playing_ids();
   _current_player = _ids_when_started[random(sizeof(_ids_when_started))];
   return 1;
}
void finish_game(string winner) {
   _winner = winner;
   _game_started = 0;
}
string query_winner() {
   return _winner;
}
int is_game_started() {
   return _game_started;
}
int can_join_as_new_player() {
   return _can_join_as_new;
}
void set_can_join_as_new_player(int join) {
   _can_join_as_new = join;
}
int is_person_playing(string id) {
   if (_players[id]->name) {
      if (find_player(_players[id]->name) &&
          is_in_me_or_environment(this_object(),
                                  find_player(_players[id]->name)) &&
          interactive(find_player(_players[id]->name))) {
         return 1;
      }
   }
   return 0;
}
int is_playing(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id != 0;
}
int is_current_player(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id == _current_player;
}
int add_person_to_game(string id, object person) {
   class player_info info;
   if (is_person_playing(id)) {
      return 0;
   }
   info = _players[id];
   info->name = person->query_name();
   info->cap_name = person->query_cap_name();
   return 1;
}
int remove_person_object_from_game(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         info->name = 0;
         info->cap_name = 0;
         return 1;
      }
   }
   return 0;
}
int remove_person_id_from_game(string id) {
   if (_players[id]->name) {
      _players[id]->name = 0;
      return 1;
   }
   return 0;
}
void randomise_player_numbers() {
   string* ids;
   int num;
   int pos;
   ids = keys(_players);
   num = 0;
   while (sizeof(ids)) {
      pos = random(sizeof(ids));
      _players[ids[pos]]->number = num;
      ids = ids[0..pos-1] + ids[pos+1..];
      num++;
   }
}
void add_player_id_type(string id, int number) {
   _players[id] = new(class player_info);
   _players[id]->number = number;
}
void remove_player_id_type(string id) {
   map_delete(_players, id);
}
class player_info find_player_info_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return info;
      }
   }
   return 0;
}
string find_player_id_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return id;
      }
   }
   return 0;
}
string* query_player_ids() {
   return keys(_players);
}
string* query_currently_playing_ids() {
   return filter(keys(_players), (: is_person_playing($1) :));
}
string* query_started_player_ids() {
   return _ids_when_started;
}
string query_player_cap_name(string id) {
   if (_players[id] && _players[id]->name) {
      return _players[id]->cap_name;
   }
   return "No one";
}
object query_player_object(string id) {
   return find_player(_players[id]->name);
}
string query_player_the_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->the_short();
      }
   }
   return "No one";
}
string query_player_poss_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->poss_short();
      }
   }
   return "No one";
}
void delete_gone_players() {
   string id;
   class player_info info;
   foreach (id, info in _players) {
      if (info->name) {
         if (!find_player(info->name) ||
             !is_in_me_or_environment(this_object(), find_player(info->name))) {
            info->name = 0;
         }
      }
   }
}
void set_minimum_needed(int minimun) {
   _minimum_needed = minimun;
}
int can_start_game() {
   if (sizeof(query_currently_playing_ids()) > _minimum_needed) {
      return 1;
   }
   return 0;
}
string find_next_player(string id) {
   class player_info info;
   int start;
   int cur;
   string new_id;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur + 1) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
                member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
string find_previous_player(string id) {
   class player_info info;
   int start;
   string new_id;
   int cur;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur - 1 + sizeof(_players)) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
               member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
void increment_current_player() {
   _current_player = find_next_player(_current_player);
}
string find_player_id_of_person(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         return id;
      }
   }
   return 0;
}
string query_current_player() {
   if (!_current_player) {
      _current_player = find_player_id_from_number(0);
   }
   return _current_player;
}
string set_current_player(string id) {
   _current_player = id;
}
void tell_player(string id, string message) {
   object player;
   player = find_player(_players[id]->name);
   if (player && (environment(player) == environment() ||
                  player == environment())) {
      tell_object(player, message);
   }
}
void tell_current_player(string message) {
   tell_player(_current_player, message);
}
varargs void tell_all_players(string message, string* exclude) {
   class player_info info;
   string id;
   if (!exclude) {
      exclude = ({ });
   }
   foreach (id, info in _players) {
      if (member_array(id, exclude) == -1) {
         tell_player(id, message);
      }
   }
}
mixed query_player_data(string id) {
   return _players[id]->data;
}
void set_player_data(string id, mixed data) {
   _players[id]->data = data;
}
void multiplayer_someone_joins(string id) {
}
void multiplayer_someone_resigns(string id, string name) {
}
mixed* shuffle_array(mixed *arr) {
   int i;
   int pos;
   mixed* new_arr;
   for (i = 0; i < 2; i++) {
      new_arr = ({ });
      while (sizeof(arr)) {
         pos = random(sizeof(arr));
         new_arr += arr[pos..pos];
         arr = arr[0..pos - 1] + arr[pos + 1..];
      }
      arr = new_arr;
   }
   return arr;
}
int do_join(string id) {
   if (is_person_playing(id)) {
      add_failed_mess("Someone is already playing " + id + " on $D.\n");
      return 0;
   }
   if (is_playing(this_player())) {
      add_failed_mess("You are already playing on $D.\n");
      return 0;
   }
   if (is_game_started() &&
       !can_join_as_new_player() &&
       member_array(id, query_started_player_ids()) == -1) {
      add_failed_mess("You can only take over one of the spots vacated by "
                      "someone else.\n");
      return 0;
   }
   if (add_person_to_game(id, this_player())) {
      add_succeeded_mess("$N $V as " + id + " on $D.\n");
      multiplayer_someone_joins(id);
      return 1;
   }
   add_failed_mess("Some weird error joining game on $D.\n");
   return 0;
}
int do_resign() {
   string id;
   id = find_player_id_of_person(this_player());
   if (remove_person_object_from_game(this_player())) {
      add_succeeded_mess("$N $V from the game on $D.\n");
      multiplayer_someone_resigns(id, this_player()->query_cap_name());
      if (id == query_current_player()) {
         increment_current_player();
      }
      return 1;
   }
   add_failed_mess("You are not playing on $D to resign.\n");
   return 0;
}
void init() {
   string ids;
   ids = implode(keys(_players), "|");
   add_command("join", "[game] [as] {" + ids + "} on <direct:object>",
                (: do_join($4[0]) :));
   add_command("resign", "[from] [game] on <direct:object>",
               (: do_resign() :));
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      return 0;
   }
   add_auto_load_value(map, LOAD_TAG, "players", _players);
   add_auto_load_value(map, LOAD_TAG, "current player", _current_player);
   add_auto_load_value(map, LOAD_TAG, "started ids", _ids_when_started);
   add_auto_load_value(map, LOAD_TAG, "winner", _winner);
   add_auto_load_value(map, LOAD_TAG, "game started", _game_started);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   if (!map) {
      return ;
   }
   _players = query_auto_load_value(map, LOAD_TAG, "players");
   _current_player = query_auto_load_value(map, LOAD_TAG, "current player");
   _ids_when_started = query_auto_load_value(map, LOAD_TAG, "started ids");
   _winner = query_auto_load_value(map, LOAD_TAG, "winner");
   _game_started = query_auto_load_value(map, LOAD_TAG, "game started");
}

==================================================
FILE: /lib/std/liquids/ink.c
==================================================

int splash_func(object ob) {
  ob->add_extra_look(this_object());
  ob->add_property("splashed with", previous_object()->query_liquid_name());
  return 1;
}
int query_ink() { return 1; }
string extra_look() {
  return capitalize((string)previous_object()->query_name())+
         " has been splashed with "+
         previous_object()->query_property("splashed with");
}

==================================================
FILE: /lib/std/shadows/peace_shadow.c
==================================================

inherit "/std/effect_shadow";
#define GCR peacenpc->get_combat_reason()
#define GER peacenpc->get_escape_reason()
#define GFR peacenpc->get_fighting_reason()
#define GMR peacenpc->get_magic_reason()
#define GOR peacenpc->get_other_reason()
#define GRR peacenpc->get_ritual_reason()
#define GSR peacenpc->get_stealth_reason()
#define TO this_object()
#define TP this_player()
object peacenpc;
void setup_shadow(object person, object thing) {
    shadow( person, 1 );
    peacenpc=thing;
}
void dest_peace_shadow() { destruct(TO); }
void event_exit(object ob, string message, object to) {
    if (ob==peacenpc)
        dest_peace_shadow();
}
void event_move_object(mixed from, mixed to) {
    dest_peace_shadow();
}
int command_shadowed( string verb, string args ) {
    switch(verb) {
        case "attack":
        case "behead":
        case "berserk":
        case "bob":
        case "crush":
        case "disarm":
        case "fire":
        case "guard":
        case "hack":
        case "hurl":
        case "iai":
        case "impale":
        case "kill":
        case "punch":
        case "riposte":
        case "slash":
        case "throw":
        case "warcry":
            tell_object(TP, GFR);
            return 1;
        case "cast":
        case "circle":
        case "educe":
        case "forget":
        case "invoke":
        case "remember":
        case "scribe":
        case "scry":
        case "spellcheck":
        case "twist":
        case "use":
        case "zap":
            tell_object(TP, GMR);
            return 1;
        case "bodyguard":
        case "bury":
        case "drag":
        case "eye":
        case "fuel":
        case "hedgehog":
        case "judge":
        case "leatherwork":
        case "mock":
        case "tempt":
        case "scathe":
        case "vurdere":
            tell_object(TP, GOR);
            return 1;
        case "conflagrate":
        case "consecrate":
        case "decompose":
        case "ensumpf":
        case "envalise":
        case "imbue":
        case "perform":
        case "pray":
        case "pyroscipate":
        case "shroud":
        case "suffuse":
        case "ventisepelate":
            tell_object(TP, GRR);
            return 1;
        case "abscond":
        case "ambush":
        case "case":
        case "conceal":
        case "crack":
        case "disable":
        case "filch":
        case "hide":
        case "inhume":
        case "lpick":
        case "palm":
        case "peek":
        case "plant":
        case "probe":
        case "scope":
        case "shoplift":
        case "slip":
        case "snatch":
        case "sneak":
        case "steal":
        case "unhide":
            tell_object(TP, GSR);
            return 1;
        default:
            return 0;
    }
}
int run_away() {
    tell_object(TO, GER);
}

==================================================
FILE: /lib/std/shadows/object/basic_trap.c
==================================================

inherit "/std/effect_shadow";
int trap_lock(string type) {
  if(type != "pick")
    return 0;
  tell_object(this_player(), "Trap triggered.\n");
  return 0;
}

==================================================
FILE: /lib/std/shadows/object/death_ward.c
==================================================

inherit "/std/effect_shadow";
void event_death( object thing, object *killers, object killer,
      string room_mess, string killer_mess ) {
   int damage;
   object twit;
   player->event_death( thing, killers, killer, room_mess, killer_mess );
   if ( thing != (object)player->query_worn_by() )
      return;
   tell_room( environment( thing ), (string)player->the_short() +
         " explodes in a ball of flame!\n" );
   thing->remove_armour( player );
   player->move( "/room/rubbish" );
   foreach ( twit in killers ) {
      if ( environment( twit ) != environment( thing ) )
         continue;
      damage = arg();
      if ( twit == killer )
         damage *= 2;
      damage -= (int)twit->query_ac( "fire", damage );
      if ( damage > 0 )
         twit->adjust_hp( -damage );
      if ( (int)twit->query_hp() < 0 )
         twit->attack_by( player );
   }
   remove_this_effect();
}

==================================================
FILE: /lib/std/shadows/object/identity_hold.c
==================================================

inherit "/std/effect_shadow";
#include <move_failures.h>
private int _keep;
private string _identifier;
private string* _adjs;
private object _owner;
int query_keep() { return _keep; }
void set_keep_value(int keep) { _keep = keep; }
void set_keep() { _keep = 1; }
void reset_keep() {
   _keep = 0;
   if (!_identifier)
      remove_this_effect();
}
string query_identifier() { return _identifier; }
string query_full_identifier() {
    string tmp;
    tmp = "";
    if ( sizeof( _adjs ) ) {
        tmp += implode( _adjs, " " ) + " ";
    }
    if ( _identifier ) {
       tmp += _identifier;
    }
    if ( strlen( tmp ) > 0 ) {
       return tmp;
    }
    return 0;
}
void set_identifier( string word ) {
   string* bits;
   if (word) {
      bits = explode(word, " ");
      _identifier = bits[<1];
      _adjs = bits[0..<2];
   } else {
      _identifier = 0;
      _adjs = ({ });
      if (!_keep)
         remove_this_effect();
   }
}
void set_identity_hold_owner(object ob) {
   _owner = ob;
}
object query_identity_hold_owner() {
   return _owner;
}
string *parse_command_id_list() {
   string *words;
   words = (string *)player->parse_command_id_list();
   if ( ( this_player() == _owner ) && stringp( _identifier ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1 && $1->ignore_identifier() :) ) ) ) {
      words += ({ _identifier });
   }
   return words;
}
string *parse_command_adjectiv_id_list() {
   string *words;
   words = (string *)player->parse_command_adjectiv_id_list();
   if ( ( this_player() == _owner ) && pointerp( _adjs ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1->ignore_identifier() :) ) ) ) {
      words += _adjs;
   }
   return words;
}
private void check_move_stuff() {
   object ob;
   ob = environment(player);
   while (ob &&
          ob != _owner) {
      ob = environment(ob);
   }
   if (ob != _owner) {
      remove_this_effect();
   }
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = player->move( dest, messin, messout );
   if ( flag == MOVE_OK &&
        objectp( dest ) ) {
      call_out((: check_move_stuff :), 2);
   }
   return flag;
}

==================================================
FILE: /lib/std/shadows/object/newbie_shoes.c
==================================================

#include <move_failures.h>
#include "path.h"
inherit "/std/effect_shadow";
int query_orthopaedic_shoes() { return 1; }
string query_msgin()
{
return "$N stagger$s clumsily from $F.";
}
string query_msgout()
{
return "$N stagger$s $T clumsily.";
}
int move(mixed dest, string inmsg, string outmsg)
{
  int ret;
  ret = player->move(dest, inmsg, outmsg);
  if (ret == MOVE_OK) {
    tell_object( player, "You wince as spikes seem to drive themselves "
      "into the balls of your feet, but you get there eventually.\n" );
  }
  return ret;
}
int test_for_effect( object thing ) {
   return member_array( EFFECTS +"newbie_shoes",
      (string *)thing->query_wear_effects() ) != -1;
}
void taken_off(object what, string eff)
{
  if (eff != EFFECTS + "newbie_shoes")
    player->taken_off(what, eff);
  else {
    remove_this_effect();
  }
}

==================================================
FILE: /lib/std/shadows/object/no_save.c
==================================================

inherit "/std/effect_shadow";
mixed query_auto_load() {
   return 0;
}
mixed query_dynamic_auto_load() {
   return 0;
}
mixed query_static_auto_load() {
   return 0;
}

==================================================
FILE: /lib/std/shadows/object/owned_weapon.c
==================================================

inherit "/std/effect_shadow";
mixed set_holder( object thing, int pos ) {
   this_object()->remove_hide_invis( "concealed" );
   if ( objectp( thing ) )
      if ( !thing->query_corpse() &&
            ( (string)thing->query_name() != arg() ) )
         return 0;
   return (mixed)player->set_holder( thing, pos );
}
string query_owner(){
   return (string) arg();
}

==================================================
FILE: /lib/std/shadows/object/swim_fins.c
==================================================

inherit "/std/effect_shadow";
int query_skill_bonus(string skill, int true) {
  if ((skill != "other.movement.swimming") || true)
    return player->query_skill_bonus(skill);
  return player->query_skill_bonus(skill)+50;
}

==================================================
FILE: /lib/std/shadows/object/talker.c
==================================================

#include "path.h"
#include <talker.h>
#include <network.h>
#include <term.h>
#include <playtesters.h>
#include <language.h>
#include <cmds/options.h>
#define EMOTE_ENABLED 1
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)
inherit "/std/effect_shadow";
int do_talker_control(mixed *args, string pattern);
int do_chat(string message, string pattern, string verb);
int handle_status_command(string mode, class talker_args args);
int handle_verbose_command(string mode, class talker_args args);
int handle_history_command(string channel, class talker_args args);
int handle_colour_list(mixed *colour_args, class talker_args args);
int handle_colour_command(string channel, string new_colour, class talker_args args);
int handle_colour_on_off_command( string str_status, class talker_args args);
int handle_colour_toggle_command( class talker_args args);
int handle_echo_command( string mode, class talker_args args);
void init() {
  mixed args;
  object where;
  string channel;
  where = environment(player);
#ifdef DEBUG
  tell_creator("taffyd", "%O, %O, %O.\n", player, this_player(), where);
#endif
  if( !where )
    return;
  if (!living(where)) {
    player->init();
    return;
  }
  args = arg();
  if (!classp(args)) {
    args = new(class talker_args, status : 0, channels : ({ "one" }),
               verbose : 1, local_echo : 0, colour : 0 );
    set_arg(args);
  }
  where->add_command("talker", player,
                     ({ON_PATTERN,
                         VERBOSE_PATTERN,
                         CHANNEL_PATTERN,
                         DELETE_CHANNEL_PATTERN,
                         HISTORY_PATTERN,
                         HISTORY_CHANNEL_PATTERN,
                         LIST_PATTERN,
                         LIST_CHANNEL_PATTERN,
                         LIST_CHANNEL_PATTERN_BRIEF,
                         SET_COLOUR_PATTERN,
                         COLOUR_ON_OFF_PATTERN,
                         COLOUR_LIST,
                         TOGGLE_COLOUR_PATTERN,
                         NEW_CHANNEL_PATTERN,
                         ECHO_PATTERN,
                         "delete <string'channel'> from <direct:object'talker'>",
                         "help" }),
                     (: do_talker_control($4, $5) :) );
  where->add_command("chat", player,
                     ({ "<string'message'>" }),
                     (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
  where->add_command("chat:", player,
                     ({ "<string'message'>" }),
                     (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  if ( !( EFFECTS + "talker" )->valid( args->channels, where ) ) {
    args->channels = ({ "one" });
    set_arg(args);
  }
  foreach (channel in args->channels) {
#ifdef DEBUG
    tell_creator("taffyd", "Adding channel. %O.\n", channel);
#endif
    where->add_command(lower_case(channel), player,
                       "<string'message'>", (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
    where->add_command( lower_case(channel) + ":", player,
                        "<string'message'>",
                        (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  }
  player->init();
}
object query_player() {
  if(player && environment(player) && living(environment(player)))
    return environment(player);
  return 0;
}
int do_talker_control(mixed *args, string pattern) {
  class talker_args t_args;
  int position;
  string full_name;
#ifdef DEBUG
  tell_creator("taffyd", "Args to talker control is %O. Pattern is %O.\n",
               args, pattern);
#endif
  t_args = arg();
  switch (pattern) {
  case ON_PATTERN:
    return handle_status_command(args[0], t_args);
  case VERBOSE_PATTERN:
    return handle_verbose_command(args[0], t_args);
  case CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(), "The eyes are asleep.\n");
      return 1;
    }
    tell_object(this_player(), "You may use the following channels:\n" +
                (string)( EFFECTS +"talker" )->channels() +
                "You are on channel(s) " +
                query_multiple_short( t_args->channels ) + ".\n" );
    return 1;
    break;
  case ECHO_PATTERN:
    return handle_echo_command( args[0], t_args );
  case "delete <string'channel'> from <direct:object'talker'>":
    add_succeeded_mess( ({ "", "" }) );
  case DELETE_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
    if ( !(EFFECTS +"talker")->valid( full_name ) ) {
      tell_object(this_player(), "The eyes are not aware of that "
                  "channel.\n");
      return 1;
    }
    position = member_array(full_name, t_args->channels);
    if (position == -1) {
      tell_object(this_player(), "The eyes are not listening to "
                  "that channel.\n");
      return 1;
    }
    if (sizeof(t_args->channels) > 1) {
      t_args->channels = t_args->channels[0..position-1] +
        t_args->channels[position+1..];
      tell_object(this_player(), "The eyes sigh with relief as they "
                  "can now ignore what happens on "
                  "channel \"" + full_name + "\".\n");
    }
    else {
      tell_object(this_player(), "The eyes are bored with not listening "
                  "to any channel at all, and add channel \"one\" to their "
                  "list again.\n");
      t_args->channels = ({ "one" });
    }
    set_arg(t_args);
    break;
  case NEW_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
    (EFFECTS+"talker")->clear_cache(this_player()->query_name());
    if ( ( EFFECTS +"talker" )->valid( full_name ) ) {
      if ( member_array( full_name, t_args->channels ) != -1 ) {
        tell_object(this_player(), "The eyes frown at you; they are "
                    "already listening to that channel.\n");
        return 1;
      }
      tell_object(this_player(),  "You whisper to " +
                  player->the_short() + " and the eyes add "
                  "channel \""+ full_name +"\" to the list.\n");
      t_args->channels += ({ full_name });
      set_arg(t_args);
      this_object()->init();
    } else {
      tell_object(this_player(), "You whisper to " +
                  player->the_short() + ", but the eyes "
                  "refuse to give you that channel.\n");
      return 1;
    }
    break;
  case SET_COLOUR_PATTERN:
  case SET_COLOUR_FULL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_colour_command( args[0], args[1], t_args );
  case COLOUR_ON_OFF_PATTERN:
    return handle_colour_on_off_command( args[0], t_args );
  case TOGGLE_COLOUR_PATTERN:
    return handle_colour_toggle_command(t_args);
  case COLOUR_LIST:
    return handle_colour_list( args, t_args );
    break;
  case HISTORY_CHANNEL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_history_command(args[0], t_args);
  case HISTORY_PATTERN:
    return handle_history_command("one", t_args);
  case LIST_PATTERN:
  case LIST_CHANNEL_PATTERN:
  case LIST_CHANNEL_PATTERN_BRIEF:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    if (sizeof(args) == 1) {
      args[ 0 ] = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
      tell_object(this_player(), "The following people are using "
                  "channel \""+ args[0] + "\":\n" +
                  ( EFFECTS +"talker" )->list( args[0],
                                 pattern == LIST_CHANNEL_PATTERN_BRIEF) );
    } else
      tell_object(this_player(), "The following people are using "
                  "talkers:\n" + (string)( EFFECTS +"talker" )->list() );
    return 1;
    break;
  case "help":
  default:
    write( "Talker commands:\n\n"
           "help               : give this help file\n"
           "on|off             : switch talker on or off\n"
           "brief              : make talker use shorter messages\n"
           "verbose            : make talker use longer messages\n"
           "channels           : list valid channels\n"
           "<channel>          : switch to <channel> if valid\n"
           "delete <channel>   : switch <channel> off if valid\n"
           "list [channel]     : list users of the talker\n"
           "history [channel]  : show chat history of <channel>\n"
           "Prefix commands with \"talker\" to use, e.g. "
           "\"talker help\".  For a more detailed description type "
           "\"help talker\".\n" );
    break;
  }
  return 1;
}
int handle_history_command(string channel, class talker_args args) {
  mixed *history;
  string result;
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  if (!channel)
    channel = "one";
  if ( !( EFFECTS +"talker" )->valid( channel ) ) {
    tell_object(this_player(), "The eyes are not aware of that "
                "channel.\n");
    return 1;
  }
  tell_object(this_player(), "You whisper to " + player->the_short() +
              ", asking for the last few chats on channel " + channel + ".\n");
  history = HIST->query_chat_history(lower_case( channel ) );
  if ( !arrayp( history ) || !sizeof( history ) ) {
    tell_object(this_player(), "The eyes mutter that nothing has "
                "been said on this channel, or it is not being remembered.\n");
    return 1;
  }
  result = "$P$Channel " + channel + "$P$The eyes mutter about your bad "
    "memory.\n";
  result += implode(map(history, (: "$I$5=$C$" + $1[0] + ($1[1] ? $1[1] : "") +
                                  "%^RESET%^" :)), "\n");
  tell_object(this_player(), result);
  return 1;
}
string query_colour_status( class talker_args args ) {
  if ( !mapp( args->colour ) ) {
    return "off";
  }
  return args->colour[ "status" ];
}
int set_colour_status( class talker_args args, string status ) {
  if ( !args->colour ) {
    args->colour = DEFAULT_COLOUR_SETTINGS;
  } else {
    if ( stringp( args->colour ) ) {
      args->colour = DEFAULT_COLOUR_WITH( args->colour );
    }
  }
  args->colour[ "status" ] = status;
  set_arg( args );
  return 1;
}
int set_channel_colour(class talker_args args, string channel, string colour) {
  if ( !channel || !colour )
    return 0;
  if ( !mapp( args->colour ) ) {
    args->colour = DEFAULT_COLOUR_WITH(colour);
  }
  args->colour[ channel ] = colour;
  set_arg( args );
  return 1;
}
varargs string query_channel_colour( class talker_args args, string channel ) {
  string colour;
  if ( !mapp( args ) ) {
    return DEFAULT_COLOUR;
  }
  if ( colour = args->colour[ channel ] ) {
    return colour;
  } else {
    if ( colour = args->colour[ "default" ] ) {
      return colour;
    }
  }
  return DEFAULT_COLOUR;
}
int handle_colour_toggle_command( class talker_args args ) {
  if ( query_colour_status( args ) == "on" ) {
    return handle_colour_on_off_command( "off", args );
  }
  return handle_colour_on_off_command( "on", args );
}
int handle_colour_on_off_command( string str_status, class talker_args args ) {
  string status;
  status = query_colour_status( args );
  switch( str_status ) {
  case "on":
    if ( status == "on" ) {
      add_failed_mess( "Talker colours for $D are already on!\n" );
      return -1;
    }
    set_colour_status( args, "on" );
    add_succeeded_mess( ({ "The eyes on $D flash with " +
                             query_channel_colour( args, "default" ) +
                             "colour%^RESET%^.\n", "" }) );
    break;
  case "off":
    if ( status == "off" ) {
      add_failed_mess("Talker colours for $D have already been turned off!\n");
      return -1;
    }
    set_colour_status( args, "off" );
    add_succeeded_mess( ({ "The eyes on $D blink sadly.\n", "" }) );
    break;
  default:
    args->colour = DEFAULT_COLOUR_SETTINGS;
    set_arg( args );
    add_succeeded_mess( ({ "Talker colour settings for $D have been reset.\n",
                             "" }) );
  }
  return 1;
}
mapping create_valid_colours( string my_colours ) {
  string *colours;
  string *valid_colours = TERM_HANDLER->query_colour_codes();
  colours = map( explode( my_colours, " " ),
                 (: upper_case( $1 ) :) );
  return unique_mapping( colours,
                         (: member_array( $1, $(valid_colours) ) > -1 :) );
}
int handle_colour_command(string channel, string new_colour,
                          class talker_args args) {
  mapping colours;
  string valid_colour;
  if ( !(EFFECTS + "talker")->valid( channel ) && channel != "default" ) {
    tell_object( this_player(), "You cannot set that "
                 "channel! Use the channel name \"default\" to set "
                 "the default channel colour.\n" );
    return 1;
  }
  colours = create_valid_colours( new_colour );
  switch( sizeof( colours[ 0 ] ) ) {
  case 0:
    valid_colour = implode( map( colours[ 1 ], (: "%^" + $1 + "%^" :) ), "" );
    set_channel_colour( args, channel, valid_colour );
    add_succeeded_mess( ({ "The eyes flash with" + valid_colour +
                             " colour.%^RESET%^\n", "" }) );
    return 1;
  case 1:
    add_failed_mess( "The colour $I is invalid.\n", colours[ 0 ] );
    return -1;
  default:
    add_failed_mess( "The colours $I are invalid.\n", colours[ 0 ] );
    return -1;
  }
}
int handle_status_command(string mode, class talker_args args) {
  switch (mode) {
  case "on" :
    if ( args->status ) {
      tell_object(this_player(),  "The eyes are already alert "
                  "and listening to your every word.\n");
    } else {
      tell_object(this_player(), "The eyes open and light up "
                  "eagerly, then dim to a dull glow.\n");
      args->status = 1;
    }
    break;
  case "off" :
    if ( !args->status ) {
      tell_object(this_player(), "You notice that the eyes are "
                  "already closed, so you wake them up again "
                  "in order to tell them to go to sleep.\n");
    } else {
      tell_object(this_player(), "The eyes slowly lose their "
                  "glow as they close.\n");
      args->status = 0;
    }
    break;
  }
  set_arg(args);
  return 1;
}
int handle_verbose_command(string mode, class talker_args args) {
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  switch (mode) {
  case "brief":
    if ( !args->verbose ) {
      tell_object(this_player(), "The eyes ignore you completely.\n");
    } else {
      tell_object(this_player(), "The eyes seem sad as they dim "
                  "slightly.\n");
      args->verbose = 0;
    }
    break;
  case "verbose":
    if ( args->verbose ) {
      tell_object(this_player(),  "The eyes glitter at you "
                  "angrily.  They already know that they are to "
                  "be verbose.\n");
    } else {
      tell_object(this_player(), "The eyes light up happily for "
                  "a moment.\n");
      args->verbose = 1;
    }
    break;
  }
  set_arg(args);
  return 1;
}
void receive(string channel, string sender, string text, object *receivers) {
  class talker_args args;
  string *ignoring;
  object where;
  string colour;
  string txt;
  if(!player || !environment(player) )
    return;
  where = environment(player);
  args = arg();
  if (args && !classp(args))
    return;
  if (!args || !args->status || !living(where) || !interactive(where))
    return;
  if(member_array(channel, map(args->channels, (: lower_case($1) :)) ) == -1) {
    return;
   }
  if ( channel == "intermud" && where->query_creator() ) {
    return;
  }
  if ( file_name( previous_object( 1 ) ) == "/secure/cmds/creator/exe_c" ||
       file_name( previous_object( 1 ) ) == "/secure/cmds/creator/ca_ll" ) {
    if ( this_player(1) && this_player(1)->query_creator() &&
         !this_player(1)->query_property( "talker cheat" ) ) {
      txt = this_player(1)->query_name() +
        " made " + sender + " chat \"" + text + "\" on "
        "channel " + channel;
      user_event( "inform", txt, "cheat" );
      log_file( "/d/admin/log/TALKER", txt + "\n" );
      this_player(1)->add_property( "talker cheat", 1, 3 );
    }
  }
  ignoring = where->query_property("ignoring");
  if (ignoring && member_array(lower_case(sender), ignoring) != -1 ) {
    return;
  }
  if(player->query_property(SHORTHAND_OUTPUT_PROP))
    text = LANGUAGES->fix_shorthand(text);
  if ( args->verbose ) {
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying: " + text;
#ifdef EMOTE_ENABLED
    }
#endif
  } else {
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps: " +text;
#ifdef EMOTE_ENABLED
    }
#endif
  }
  if ( stringp( args->colour ) ) {
    colour = args->colour;
  }
  if(mapp(args->colour) && query_colour_status( args ) == "on") {
    if (!( colour = args->colour[ channel ] ) ) {
      if(!(colour = args->colour[(EFFECTS + "talker")->
                                normalise_name(channel)])) {
        colour = args->colour[ "default" ];
        if ( !colour ) {
          colour = DEFAULT_COLOUR;
        }
      }
    }
  } else {
    colour = "";
  }
  tell_object(where, colour +  "$I$5=$C$"+ text + "%^RESET%^\n" );
#ifdef NOISY
  if(receivers && sizeof(receivers) && !where->query_invis() &&
     environment(where) && base_name(environment(where)) != "/room/rubbish") {
    receivers = map(receivers, (: $1->query_player() :));
    receivers += ({ this_player() });
    tell_room(environment(where),
              "A wispy voice comes from " + player->poss_short(1) + ".\n",
              receivers);
  }
#endif
}
int do_chat(string message, string pattern, string verb) {
  class talker_args args;
  object *things, *receivers;
  string sender;
#ifdef DEBUG
  tell_creator("taffyd", "Message is %s, pattern is %s, verb is "
               "%s.\n", message, pattern, verb);
#endif
#ifdef EMOTE_ENABLED
  if ( verb[ <1 ] == ':' ) {
    verb = verb[0..<2];
  }
#endif
  if (pattern == "into <direct:object>") {
    add_succeeded_mess("$N whisper$s lovingly to $D.\n");
    return 1;
  }
  args = arg();
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  while (strsrch(message, "%^") != -1) {
    message = replace(message, ({ "%^", "" }) );
  }
  if(member_array( verb, map(args->channels, (: lower_case($1) :)) ) == -1 &&
     verb != "chat") {
    return 0;
  }
  if(this_player()->query_property("no talker")) {
    add_failed_mess("Sorry, you are not allowed to use a talker.\n");
    return 0;
  }
  if(environment(this_player()) &&
     environment(this_player())->query_property("no talker")) {
    if(stringp(environment(this_player())->query_property("no talker")))
      add_failed_mess(environment(this_player())->query_property("no talker"));
    else
      add_failed_mess("Your talker doesn't seem to work here.\n");
    return 0;
  }
  if (this_player()->query_property("gagged")) {
    add_failed_mess("You have been gagged!  You cannot chat until "
                    "your gag is removed.  Perhaps you should talk to a "
                    "creator about this.\n");
    return 0;
  }
  if (environment(player) != this_player()) {
    add_failed_mess("You're too far away from $D to whisper into it.\n");
    return 0;
  }
  if (verb == "chat") {
    if (member_array("one", args->channels) == -1) {
      verb = args->channels[0];
    }
    else {
      verb = "one";
    }
  }
  sender = this_player()->query_cap_name();
  message = replace(message,
                    ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                         "[D", "", "%^", " " }));
  if(this_player()->query_property(SHORTHAND_PROP))
    message = LANGUAGES->fix_shorthand(message);
  things = children( PATH + "talker" );
  if ( args->local_echo ) {
    things -= ({ find_object( PATH + "talker" ) });
  } else {
    things -= ({ this_object(), find_object( PATH + "talker" ) });
  }
  tell_object(this_player(), "You whisper into " + player->the_short() +
              ".\n");
  if(!this_player()->query_invis() &&
     base_name(environment(this_player())) != "/room/rubbish" ) {
    receivers = map(things, (: $1->query_player() :));
    receivers += ({ this_player() });
    tell_room(environment(this_player()), this_player()->one_short(1) +
              " whispers into " + this_player()->query_possessive() +
              " " + player->short() + ".\n", receivers);
  }
  things->receive(verb, sender, message, things);
  if( verb == "intermud" ) {
    if (message[0] == '@' || message[0] == ':') {
      user_event( "intermud_tell", sender + " ", message[1..], "dwchat" );
      message = "$N " + message[1..];
      SERVICES_D->eventSendChannel(sender, "discworld-chat", message, 1);
    } else {
      SERVICES_D->eventSendChannel( sender, "discworld-chat", message, 0 );
      user_event( "intermud_tell", sender +": ", message, "dwchat" );
    }
  }
  if ( verb == "playtesters" ) {
    if ( !this_player()->query_creator() &&
         !PLAYTESTER_HAND->query_playtester(this_player()->query_name()) ) {
      args->channels -= ({ "playtesters" });
      set_arg(args);
      add_failed_mess("You're no longer a playtester!\n");
      return 0;
    }
  }
#ifdef EMOTE_ENABLED
  if ( message[0] == '@' || message[0] == ':' ) {
    HIST->add_chat_history( verb , sender +" wisped that " +
                            this_player()->query_pronoun() + " ",
                            message[1..] );
  } else {
#endif
    HIST->add_chat_history( verb , sender +" wisped: ", message );
#ifdef EMOTE_ENABLED
  }
#endif
  return 1;
}
void remove_effect_shadow( int i ) {
  if ( i == id ) {
    if ( player && environment( player ) ) {
      environment( player )->remove_object( player, 1 );
      init();
    }
  }
  ::remove_effect_shadow( i );
}
protected string format_channel_colour( string colour ) {
  return colour +
    lower_case( replace_string( implode( explode( colour, "%^%^" ), " " ),
                                "%^", "" ) ) + "%^RESET%^";
}
int handle_colour_list(mixed *colour_args, class talker_args args) {
  string channel;
  if (!mapp(args->colour) || query_colour_status( args ) == "off" ) {
    add_failed_mess( "You currently have talker colours disabled.  Use "
                     "\"talker colour on\" to turn them on.\n" );
    return 0;
  }
  foreach( channel in args->channels ) {
    if ( args->colour[ channel ] ) {
      tell_object( this_player(),
                   "Channel " + channel + " is " +
                   format_channel_colour( args->colour[ channel ] ) + ".\n");
    }
  }
  if ( args->colour[ "default" ] ) {
    tell_object( this_player(),
                 "The default talker colour is " +
                 format_channel_colour( args->colour[ "default" ] ) + ".\n");
  }
  return 1;
}
int handle_echo_command( string mode, class talker_args args) {
  int current;
  current = args->local_echo;
  if ( current ) {
    if ( mode == "on" ) {
      add_failed_mess( "Talker echo is already on for $D!\n" );
      return -1;
    }
    args->local_echo = 0;
    add_succeeded_mess( ({ "The eyes on $D flash slowly.\n", "" }) );
  } else {
    if ( mode == "off" ) {
      add_failed_mess( "Talker echo is already off for $D!\n" );
      return -1;
    }
    args->local_echo = 1;
    add_succeeded_mess( ({ "The eyes on $D flash twice rapidly.\n",
                             "" }) );
  }
  set_arg( args );
  return 1;
}

==================================================
FILE: /lib/std/shadows/disease/flu_shadow.c
==================================================

inherit "/std/effect_shadow";
string *soulverb;
string *souladverb;
int query_flu(){ return 1; }
string flusoul(){
   string flu;
   soulverb = ({"sneeze",
                "cough"
   });
   souladverb = ({"violently",
                "loudly",
                "suddenly"
   });
this_player()->force_soul_command(soulverb[random(sizeof(soulverb))]+" "+souladverb[random(sizeof(souladverb))]);
   return flu;
}
int look_me(string arg){
   if(!arg){
      if (random(100) > 30){
         tell_object(player, "You feel dizzy and bleary eyed.\n");
      }
      else{
         player->look_me();
      }
      return 1;
   }
   return 1;
}
int attack_ob(object obj){
   object *contents;
   object target;
   if(random(100) > 30){
      tell_object(player, "You feel too ill, and can't be bothered to attack.\n");
      return 1;
   }
   player->attack_ob(target);
   return 1;
}
int cast(string str){
   if(random(100) > 50){
      tell_object(player, "You lose your concentration as you feel a "+
                          "sneeze coming on.\n");
      this_player()->force_soul_command("sneeze");
      return 1;
   }
   player->cast(str);
   return 1;
}

==================================================
FILE: /lib/std/shadows/disease/headache_shadow.c
==================================================

inherit "/std/effect_shadow";
int query_special_manoeuvre() {
   tell_object(player, "Your head hurts too much to try anything.\n");
   return 0;
}
int command_shadowed(string verb, string arg){
   if(verb=="cast"){
     write("Your head hurts too much to muster your might.\n");
     return 1;
   }
   return player->command_shadowed(verb, arg);
}

==================================================
FILE: /lib/std/shadows/curses/alone.c
==================================================

inherit "/std/effect_shadow";
int query_blinded() {
   return 1;
}

==================================================
FILE: /lib/std/shadows/curses/antisqeal.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix =  ({
"kewl", "cool",
"l33t", "elite",
" ur ", "your",
" r ", " are ",
" u ", " you ",
" y ", " why ",
"2", "two",
"4", "for",
"sum", "some",
"wut", "what",
"z", "s",
"Z", "s",
"k", "c",
"K", "c",
"wif", "with",
"werk", "work" });
#ifdef 0
string mangle_speech( string s ) {
    string s1;
    s1 = player->mangle_speech( s ); return replace( " " + (stringp(s1)?s1:s),
    replace_matrix)[1..10000]; }
#endif
string mangle_chat( string s ) {
  return replace(s, replace_matrix);
}

==================================================
FILE: /lib/std/shadows/curses/chef_curse.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
string mangle_speech( string s ) {
    string s1;
    s1 = player->mangle_speech( s );
    return replace( " " + (stringp(s1)?s1:s), replace_matrix)[1..10000];
}

==================================================
FILE: /lib/std/shadows/curses/deaf_shadow.c
==================================================

inherit "/std/effect_shadow";
#include "effect.h"
void event_whisper(object ob, string start, string mess, object *d, string lang) {
   int i;
   i = (int)arg() / 2;
   if (random(100) < i) {
      player->event_whisper(ob, start, mess, d, lang);
   } else {
      player->add_message(ob, "$N %hiss% something at you, but you just "+
"can't make it out.\n", 1);
   }
}
void event_person_say(object ob, string start, string mess, string lang) {
   string dum1, dum2;
   if (sscanf(start, "%sloud%s", dum1, dum2)) {
      if (random(100) > (100 - (int)arg()) / 2) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something loudly, but "+
"you fail to hear it properly.\n", 1);
      }
   } else {
      if (random(100) < arg()) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something, but you just can't "+
   "hear it properly.\n", 1);
      }
   }
}
void event_person_say_new(object ob, string start, string mess, string lang,
  mixed avoid) {
   tell_object(player, sprintf("New Say: %O %O %O %O %O\n", ob, start, mess, lang, avoid));
}

==================================================
FILE: /lib/std/shadows/curses/ensmurfed.c
==================================================

inherit "/std/effect_shadow";
varargs string short(int dark) {
   if (player)
     return player->short(dark)+"smurf";
   return "Smurf curse shadow";
}
mixed query_short() { return player->query_short()+"smurf"; }
mixed query_long() { return "This is a small blue humanoid.\n"; }
int query_female() { return 0; }
int query_gender() { return 0; }
int query_male() { return 0; }
int query_neuter() { return 1; }
string query_gender_string() { return "smurf"; }
string query_gender_title() { return "smurf"; }
string query_objective() { return "it"; }
string query_possessive() { return "its"; }
string query_pronoun() { return "it"; }
string long(string str, int dark) {
   string s, guild_ob;
   s = "You see "+ query_short();
   guild_ob = player->query_guild_ob();
   if (guild_ob)
      s += " "+ (string)guild_ob->query_title( this_object() ) +".\n";
   else
      s += ".\n";
   s += "It is a small blue humanoid wearing white trousers.\n";
   s += capitalize(query_pronoun())+" "+player->health_string()+".\n";
   s += player->calc_extra_look();
   s += player->weather_extra_look();
   s += player->query_living_contents(0);
   return s;
}
string smurf( string str ) {
   string str1;
   if ( sscanf( str, "%s,", str ) ) str1 = ",";
   else if ( sscanf( str, "%s.", str ) ) str1 = ".";
   else if ( sscanf( str, "%s!", str ) ) str1 = "!";
   else if ( sscanf( str, "%s;", str ) ) str1 = ";";
   else str1 = "";
   if ( sscanf( str, "%sing", str ) ) str = "smurfing";
   else if ( sscanf( str, "%sd", str ) ) str = "smurfed";
   else if ( sscanf( str, "%ss", str ) ) str = "smurfs";
   else str = "smurf";
   return str + str1;
}
string mangle_speech( string str ) {
   string tmp, *bits;
   int i;
   tmp = player->mangle_speech( str );
   if( !tmp ) tmp = str;
   bits = explode(tmp, " ");
   for (i=1;i<sizeof(bits);i+=3) {
      bits[i] = smurf( bits[i] );
   }
   tmp = implode(bits, " ");
   return tmp;
}

==================================================
FILE: /lib/std/shadows/curses/ken_curse.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix;
mapping trans;
void create() {
  replace_matrix = ({
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });
  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
}
string mangle_speech(string str) {
  string tmp, *bits;
  mixed erp;
  int i;
  tmp = player->mangle_speech( str );
  tmp = replace(" "+(stringp(tmp)?tmp:str)+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
}

==================================================
FILE: /lib/std/shadows/curses/no_player_title.c
==================================================

#include <effect.h>
inherit "/std/effect_shadow";
varargs int add_property(string var, mixed val, int tim) {
    if ( var == "player_title" ) {
        tell_object( player, "You are not allowed to have a player title.\n" );
        return 0;
    }
    return player->add_property( var, val, tim );
}
mixed query_property( string prop ) {
    if ( prop == "player_title" ) {
        return 0;
    }
    return player->query_property( prop );
}
void bing() {
player->submit_ee2( player->sid_to_enum( id ), "spam", 5, EE_CONTINUOUS );
}

==================================================
FILE: /lib/std/shadows/room/hat_tent.c
==================================================

inherit "/std/effect_shadow";
int query_keep_room_loaded() {
   return 1;
}
int dont_free() {
   return 1;
}
int clean_up() {
   return 1;
}
void tent_collapsed() {
   remove_this_effect();
}

==================================================
FILE: /lib/std/shadows/room/terrain_dont_unload.c
==================================================

inherit "/std/effect_shadow";
#define BP tell_object( find_player("gerbil"), "BP.\n");
int i;
int dont_free() {return 1;}
void setup_shad() {
    i++;
}
string test_my_effect() {return "Yup!";}
void ditch_room() {
    if( !--i ) {
        remove_this_effect();
    }
}

==================================================
FILE: /lib/std/shadows/npc/basilisk_stare.c
==================================================

#include <move_failures.h>
inherit "/std/effect_shadow";
int query_basil_stare_shad(){ return 1; }
string query_passed_out_message()
{
  string *msgs = ({
    "The eyes!  They're burning!  Can't think!\n",
    "Your concentration is too fragmented.\n",
    "Why do that when you can just sit here and fall into those eyes?\n",
    "Arrrrgghhhh!  Too much pain!\n"
    }) ;
  return msgs[random(sizeof(msgs))];
}
int move_with_look(object dest, string messin, string messout)
{
   tell_object(player, "Your mind is not here to help you control "+
                       "your movement.\n");
   return MOVE_NO_DROP;
}
int attack_by(object obj)
{
   if( !obj || ( !obj->one_short() ) ) {
      tell_room( environment( player ), player->one_short() + " is totally "
         "helpless.\n", player );
   }
   else {
      tell_room(environment(player), player->one_short()+
        " is totally helpless against "+obj->one_short()+"'s attack.\n",
        player);
   }
   tell_object(player, "Oh dear! How do I defend myself? I forgot!\n") ;
   return 1;
}
int query_special_manoeuvre() { return 0; }

==================================================
FILE: /lib/std/shadows/npc/controlled_monster.c
==================================================

inherit "/std/effect_shadow";
int turn_chance;
object my_owner;
object my_enemy;
string leave_msg;
string enter_msg;
int summoned;
int set_enemy( object enemy );
object query_owner() { return my_owner; }
object query_enemy() { return my_enemy; }
void set_leave_msg( string mess ) { leave_msg = mess; }
void set_enter_msg( string mess ) { enter_msg = mess; }
void set_summoned( int summ ) { summoned = summ; }
void init() {
   player->init();
   if( this_player() != my_owner )
      return;
   this_player()->add_command( "help", this_object(), "<direct:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to {kill|attack} <indirect:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to protect <indirect:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to leave" );
}
int do_order( object *indir, string indir_match, string dir_match,
             mixed *args, string pattern ) {
   if( this_player() != my_owner )
      return 0;
   if( pattern == "<direct:living:here> to leave" ) {
      my_owner->add_succeeded_mess( this_object(),
                                   "$D smiles happily.\n", ({ }) );
      tell_object( my_owner,
                  (string)this_object()->the_short() +
		   " tells you: Thank you.\n");
      if ( summoned ) {
         call_out( "go_away", 1 );
      } else {
         my_owner = 0;
         call_out( "run_away", 1 );
      }
   } else if ( pattern == "<direct:living:here> to protect <indirect:living:here>" ) {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D asks you: Who do you want me to protect?\n", ({ }) );
         return 0;
      }
      tell_object( indir[ 0 ], (string)this_object()->the_short() +" tells you:  "+
                  (string)my_owner->the_short()
                  +" has asked me to protect you.\n" );
      tell_object( my_owner, (string)this_object()->the_short()
                  +" tells you: Fine.\n" );
      this_player()->add_succeeded_mess( this_object(),
                                        "$N $V $D to protect $I.\n ", ({ indir[ 0 ] }) );
      this_object()->do_command( "protect "+
				 (string)indir[ 0 ]->query_name() );
   } else {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D asks you: Who do you want me to kill?\n", ({ }) );
         return 0;
      }
      if ( !set_enemy( indir[ 0 ] ) ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D tells you: There is no way you can force me to attack $I.\n",
                                   ({ indir[ 0 ] }));
         return 0;
      };
      tell_object( my_enemy, (string)this_object()->the_short() +
		   " tells you:  "+
                  (string)my_owner->the_short()
                  +" has asked me to kill you.\nPrepare to die!\n" );
      tell_object( my_owner, this_object()->the_short() +
		   " tells you: Fine.\n" );
   }
   return 1;
}
int do_help( object *indir, string indir_match, string dir_match,
            mixed *args, string pattern ) {
   if ( this_player() != my_owner )
     return 0;
   this_player()->add_succeeded_mess( this_object(),
                                     "You can \"order\" "+
				      this_object()->the_short()
                                     +" to kill someone or to leave.\n ", ({ }) );
   return 1;
}
int set_enemy( object enemy ) {
   object *list;
   int i;
   my_enemy = enemy;
   if( my_enemy == my_owner ) {
      my_owner = 0;
      list = this_object()->query_attacker_list();
      for( i = 0; i < sizeof(list); i++ ) {
         this_object()->stop_fight( list[i] );
         (list[ i ])->stop_fight( this_object() );
         if ( !pk_check( list[ i ], my_enemy ) ) {
            (list[ i ])->attack_ob( my_enemy );
            my_enemy->attack_ob( list[ i ] );
            tell_object( list[ i ], (string)this_object()->the_short()
                        +" tells you: I will help you fight "+
                        (string)my_enemy->the_short() +".\n");
         }
      }
   } else {
      if ( pk_check( my_owner, my_enemy ) ) {
         if ( turn_chance )
           call_out( "set_enemy", 1, my_owner );
         else
           call_out( "go_away", 1);
         return 0;
      }
   }
   this_object()->attack_ob( my_enemy );
   call_out( "move_me", 1 );
   return 1;
}
int set_owner( object owner, int time, int turn) {
   if ( !owner ) return 0;
   my_owner = owner;
   turn_chance = turn;
   if ( summoned )
     call_out( "do_leave", time ) ;
   call_out( "move_me", 1 );
   return 1;
}
void event_dest_me( object ob ) {
   if ( ob == my_owner )
     call_out( "go_away", 0 );
   if ( ob == my_enemy ) {
      if ( !my_owner )
        call_out( "go_away", 0 );
      if ( my_enemy )
        tell_object( my_owner, (string)my_enemy->the_short() +" has left DiscWorld\n" );
      my_enemy = 0;
      call_out( "move_me",0);
   }
}
void event_death( object ob ) {
   if ( ob == my_enemy ) {
      if ( !my_owner ) call_out( "go_away", 0 );
      call_out( "do_tell", 0, my_owner, this_object()->query_short() +" tells you: "+
               my_enemy->the_short() +" has been killed!\n");
      my_enemy = 0;
      call_out( "move_me", 0 );
   }
}
void do_tell( object ob, string str ) {
   tell_object( ob, str );
}
void move_me() {
   if ( my_enemy ) {
      if ( environment() == environment( my_enemy ) ) return;
      player->move( environment( my_enemy ), enter_msg, leave_msg );
      tell_object( my_enemy, this_object()->the_short() +" says: You cannot escape me!\n" );
      return;
   }
   if ( my_owner ) {
      if ( environment() == environment( my_owner ) ) return;
      player->move( environment( my_owner ), enter_msg, leave_msg );
      this_object()->do_command( "protect "+ (string)my_owner->query_name() );
      this_object()->do_command( "follow "+ (string)my_owner->query_name() );
      return;
   }
   if ( summoned )
     call_out( "go_away", 0 );
   else
     call_out( "run_away", 1 );
}
int do_leave() {
   if ( my_owner ) {
      tell_object( my_owner, this_object()->the_short()
                  +" tells you:  It is time for me to leave.\n" );
      say( this_object()->the_short() +" smiles happily.\n" );
   }
   call_out( "go_away", 2 );
   return 1;
}
int attack_by( object ob ) {
   if ( summoned && !my_owner ) {
      say( this_object()->the_short()
	   +" says: I will not fight without an owner!\n");
      call_out("go_away",0);
      return 1;
   }
   if ( interactive( my_owner ) ) {
      if ( (string) ob->query_guild_ob() == "/std/guilds/priest" ) {
         tell_object( my_owner, this_object()->the_short() +" tells you: "
                     "I do not wish to kill "+ ob->the_short()+".\n");
         if ( !turn_chance ) {
            call_out( "go_away", 1 );
            return 1;
         }
         if ( random( 100 ) < turn_chance ) {
            set_enemy( my_owner );
            return 1;
         }
      }
      if ( random( 100 ) < ( turn_chance / 5 ) ) {
         set_enemy( my_owner );
         return 1;
      }
   }
   return player->attack_by( ob );
}
void event_exit( object ob ) {
   if( ob != my_owner && ob != my_enemy ) return;
   call_out( "move_me", 1 );
}
void go_away() {
  write( leave_msg );
  player->move( "/room/rubbish" );
}
