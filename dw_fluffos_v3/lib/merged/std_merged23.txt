# Total Tokens: 18949
# Total Files Merged: 7
# Total Characters: 63185

om/inherit/club_discuss.c
==================================================

#include <clubs.h>
#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 30
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"
private void discuss_finish_description(string str, int open);
protected int do_discuss(int open, string type, string club_name);
class memo_item {
   string club_name;
   string subject;
   string description;
   string *choices;
   int timeout;
   int open;
}
void init() {
   add_command("discuss",
               "[open] {description|add position|"
               "change position name|memo|secret|"
               "remove member|no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                (: do_discuss(1, $4[0], $4[1]) :));
   add_command("discuss",
               "committee {description|add position|"
               "change position name|memo|secret|remove member|"
               "no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                     (: do_discuss(0, $4[0], $4[1]) :));
}
protected void discussion_finish_information(string info,
                                             mixed *data) {
   int type;
   string short;
   string name;
   string optional;
   string club_name;
   club_name = data[0];
   short = data[1];
   type = data[2];
   name = data[3];
   optional = data[4];
   write("Discussion item: " + short + ".\n");
   if (!info) {
      write("No description used.\n");
   } else {
      write(info);
   }
   write("\nDo you wish to add this? ");
   input_to("discussion_finish_confirm",
            0,
            club_name,
            short,
            type,
            name,
            info,
            optional);
}
protected void discussion_finish_confirm(string str,
                                         string club_name,
                                         string short,
                                         int type,
                                         string name,
                                         string info,
                                         string optional) {
   str = lower_case(str);
   if (!strlen(str) ||
       str[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         type,
                                         this_player()->query_cap_name(),
                                         name,
                                         info,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         optional)) {
      write("Added in the discussion item: " + short + ".\n");
   } else {
      write("Unable to add in the discussion item: " + short + ".\n");
   }
}
protected int do_discuss_description(int open,
                                     string club_name) {
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_DESCRIPTION,
                                                   0)) {
      add_failed_mess("A description is already being discussed, you can only "
                      "discuss one description at a time.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Please enter the description you wish to have discussed as the "
         "new description of the club '" +
         CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discuss_finish_description :),
                          0,
                          0,
                          ({ open,
                             club_name }));
   return 1;
}
private void discuss_finish_description(string str, mixed *junk) {
   int open;
   string club_name;
   if (!str) {
      write("Description aborted.\n");
      return ;
   }
   open = junk[0];
   club_name = junk[1];
   write("Adding the description:\n" + str +
         "\nIs this the correct description (yes/no/edit)? ");
   input_to("description_confirm", 0, str, open, club_name);
}
protected void description_confirm(string confirm, string str, int open, string club_name) {
   confirm = lower_case(confirm);
   if (strlen(confirm) &&
       confirm[0] == 'e') {
      this_player()->do_edit(str,
                             (: discuss_finish_description :),
                             0,
                             0,
                             ({ open, club_name }));
      return ;
   }
   if (!strlen(confirm) ||
       confirm[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         CLUB_DISCUSS_DESCRIPTION | open,
                                         this_player()->query_name(),
                                         "Change club description",
                                         str,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         0)) {
      write("Successfuly added the item for discussion.\n");
   } else {
      write("Unable to add the item for discussion.\n");
   }
}
protected int do_discuss_add_position(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What committee position do you wish to add to the club '" +
         club_name + "'? ");
   input_to("discussion_add_name", 0, open, club_name);
   return 1;
}
protected void discussion_add_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The position '" + str + "' already exists in the club.  You "
            "cannot add it.\nAborting.\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, it can be a "
            "maximum length of " + CLUB_MAX_POSITION_NAME +
            ".\nAborting.\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What message do you wish display as to why you wish this position "
         "added?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Adding the position " + str,
                                CLUB_DISCUSS_NEW_POSITION | open,
                                str,
                                0 }) );
}
protected int do_discuss_remove_member(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which member to do you wish to try and remove? ");
   input_to("discussion_remove_member_name", 0, open, club_name);
   return 1;
}
protected void discussion_remove_member_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   if (!CLUB_HANDLER->is_member_of(club_name,
                                   str)) {
      write("The person " + str + " is not a member of the club " +
            CLUB_HANDLER->query_club_name(club_name) +
            " and therefor you cannot remove them.\nAborting.\n");
      return ;
   }
   write("What do you want to say about removing " + str + "?\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Removing the member " + str,
                                CLUB_DISCUSS_MEMBER_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_secret(int open, string club_name) {
   string short;
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_SECRET_TYPE)) {
      notify_fail("There is already a discussion item to change this club's "
                  "secret status.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   if (CLUB_HANDLER->query_club_secret(club_name)) {
      write("What description to wish to use to make the club open?\n");
      short = "make the club open";
   } else {
      write("What description to wish to use to make the club secret?\n");
      short = "make the club secret";
   }
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                short,
                                CLUB_DISCUSS_SECRET_TYPE | open,
                                "Change to be secret",
                                0 }) );
   return 1;
}
protected int do_discuss_remove_position(int open, string club_name) {
   string *choices;
   string *ok;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   ok = filter(choices, (: !CLUB_HANDLER->is_basic_position($(club_name),
                                                            $1) :));
   if (!sizeof(ok)) {
      add_failed_mess("You cannot remove the basic positions of " +
                      query_multiple_short(choices) + ".\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to remove?\n");
   foreach (bing in ok) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("remove_position", 0, open, club_name, ok);
   return 1;
}
protected void remove_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (CLUB_HANDLER->is_basic_position(club_name,
                                       str)) {
      write("Unable to remove the basic positions from the club.\n");
      return ;
   }
   write("What description do you wish to associate with removing the "
         "position " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Remove the positon " + str,
                                CLUB_DISCUSS_POSITION_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_change_position_name(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to change?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("change_position", 0, open, club_name);
   return 1;
}
protected void change_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   write("What name do you wish to change '" + str + "' to? ");
   input_to("change_position_new_name", 0, str, open, club_name);
}
protected void change_position_new_name(string str,
                                        string position,
                                        int open, string club_name) {
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The name '" + str + "' already exists in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, the maximum is " +
            CLUB_MAX_POSITION_NAME + ".\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What description to you wish to give for changing the position " +
         position + " to " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "change the position " + position + " to " + str,
                                CLUB_DISCUSS_POSITION_NAME | open,
                                position,
                                str }) );
}
protected int do_discuss_no_confidence(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to add a no confidence "
         "vote in?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("   " + CLUB_ALL_POSITIONS + "\n");
   write("Choice? ");
   input_to("no_confidence", 0, open, club_name);
   return 1;
}
protected void no_confidence(string str,
                             int open, string club_name) {
   string bing;
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name, str) &&
       str != CLUB_ALL_POSITIONS) {
      write("Sorry, '" + str + "' is not a valid position in " +
            CLUB_HANDLER->query_club_name(club_name) +
            ".\n");
      return ;
   }
   if (str == CLUB_ALL_POSITIONS) {
      bing = 0;
   } else {
      bing = str;
   }
   write("What description do you wish to give for a vote of no confidence "
         "in " + str + "?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "no confidence in " + str,
                                CLUB_DISCUSS_NO_CONFIDENCE | open,
                                bing,
                                0 }) );
}
protected int do_discuss_remove_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to close? ");
   input_to("remove_account", 0, open, club_name);
   return 1;
}
protected void remove_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot remove an account that doesn't exist.\n");
      return ;
   }
   if (str == CLUB_DEFAULT_ACCOUNT_NAME) {
      write("You cannot remove the default account name.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_REMOVE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected int do_discuss_create_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to open? ");
   input_to("create_account", 0, open, club_name);
   return 1;
}
protected void create_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot create an account that already exists.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_CREATE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected void discuss_memo_show(class memo_item memo) {
   write("The memo in club " +
         CLUB_HANDLER->query_club_name(memo->club_name) +
         " will complete in " + memo->timeout + " days.\n");
   if (memo->subject) {
      write("Subject: " + memo->subject + "\n");
   } else {
      write("No subject set.\n");
   }
   if (sizeof(memo->choices)) {
      write("Choices: " + query_multiple_short(memo->choices) + "\n");
   } else {
      write("No choices set.\n");
   }
   if (memo->description) {
      write("Description:\n" + memo->description + "\n");
   } else {
      write("No description set.\n");
   }
}
protected void discuss_memo_menu(class memo_item memo) {
   discuss_memo_show(memo);
   write("\n");
   write("a) Set subject\n");
   write("b) Make a yes/no memo item\n");
   write("c) Add new choice\n");
   write("d) Remove choice\n");
   write("e) Set completion time\n");
   if (memo->description) {
      write("f) Change description\n");
      write("g) Zap description\n");
   } else {
      write("f) Add description\n");
   }
   write("m) Redisplay this menu\n");
   write("s) Save and Quit\n");
   write("q) Quit\n\n");
   write("Choice: ");
   input_to("discuss_memo_menu_choice", 0, memo);
}
protected void discuss_memo_subject(class memo_item memo) {
   write("What do you wish the new subject to be? ");
   input_to("discuss_memo_subject_name", 0, memo);
}
protected void discuss_memo_subject_name(string name,
                                         class memo_item memo) {
   if (!strlen(name)) {
      write("Not changing the subject.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(name) > MAX_SUBJECT_LEN) {
      write("The subject name is too long, the maximum "
            "length is " + MAX_SUBJECT_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->subject = name;
   discuss_memo_menu(memo);
}
protected void discuss_memo_add_choice(class memo_item memo) {
   write("What is the name of the choice you wish to add? ");
   input_to("discuss_memo_add_choice_response", 0, memo);
}
protected void discuss_memo_add_choice_response(string response,
                                                class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   response = strip_colours(response);
   if (!strlen(response)) {
      write("Not adding any choices.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(response) > MAX_CHOICE_LEN) {
      write("The choice name " + response + " is too long, maximum "
            "length is " + MAX_CHOICE_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (member_array(response, memo->choices) != -1) {
      write("The choice name " + response + " is already in the list of "
            "choices.  Current choices are " +
            query_multiple_short(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices += ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_remove_choice(class memo_item memo) {
   write("What is the name of the choice you wish to remove? ");
   input_to("discuss_memo_remove_choice_response", 0, memo);
}
protected void discuss_memo_remove_choice_response(string response,
                                                   class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   if (member_array(response, memo->choices) == -1) {
      write("The choice '" + response + "' is not in current memo.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices -= ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_timeout(class memo_item memo) {
   write("What do you wish to change the length of the item to (in days)? ");
   input_to("discuss_memo_timeout_response", 0, memo);
}
protected void discuss_memo_timeout_response(string str,
                                             class memo_item memo) {
   int tim;
   if (sscanf(str, "%d", tim) != 1) {
      write("Must specify a number.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim < MIN_TIMEOUT) {
      write("The timeout " + tim + " is lower than the minimum allowed "
            "length of " + MIN_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim > MAX_TIMEOUT) {
      write("The timeout " + tim + " is higher than the maximum allowed "
            "length of " + MAX_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->timeout = tim;
   discuss_memo_menu(memo);
}
protected void discuss_memo_finish_description(string desc,
                                               class memo_item memo) {
   if (!desc) {
      write("Not changing the description.\n");
   } else {
      memo->description = desc;
   }
   discuss_memo_menu(memo);
}
protected void discuss_memo_description(class memo_item memo) {
   if (memo->description) {
      write("Edit your description.\n");
   } else {
      write("Add your description.\n");
   }
   this_player()->do_edit(memo->description,
                          (: discuss_memo_finish_description :),
                          0,
                          0,
                          memo);
}
protected void discuss_memo_save(class memo_item memo) {
   if (!memo->subject) {
      write("The memo must have a subject to save it!\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (sizeof(memo->choices) < 2) {
      write("The memo must have at least two choices!  Currently you have " +
            sizeof(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(memo->club_name,
                                         CLUB_DISCUSS_MEMO | memo->open,
                                         this_player()->query_name(),
                                         memo->subject,
                                         memo->description,
                                         memo->choices,
                                         memo->timeout * 24 * 60 * 60,
                                         0)) {
      write("Successfuly added the memo item.\n");
   } else {
      write("Unable to add the memo item for some reason.\n");
   }
}
protected void discuss_memo_menu_choice(string str, class memo_item memo) {
   str = lower_case(str);
   if (!strlen(str)) {
      write("Invalid choice\nChoice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   switch (str[0]) {
      case 'a' :
         discuss_memo_subject(memo);
         break;
      case 'b' :
         memo->choices = ({ "yes", "no", "abstain" });
         discuss_memo_menu(memo);
         break;
      case 'c' :
         discuss_memo_add_choice(memo);
         break;
      case 'd' :
         discuss_memo_remove_choice(memo);
         break;
      case 'e' :
         discuss_memo_timeout(memo);
         break;
      case 'f' :
         discuss_memo_description(memo);
         break;
      case 'g' :
         memo->description = 0;
         write("Description zapped.\n");
         discuss_memo_menu(memo);
         break;
      case 'q' :
         write("Quiting memo addition!\n");
         break;
      case 's' :
         discuss_memo_save(memo);
         break;
      case 'm' :
         discuss_memo_menu(memo);
         break;
      default :
         write("Invalid choice\nChoice: ");
         input_to("discuss_memo_menu_choice", 0, memo);
         break;
   }
}
protected int do_discuss_memo(int op, string club_name) {
   discuss_memo_menu(new(class memo_item, choices : ({ }),
                                          timeout : 14,
                                          club_name : club_name,
                                          open : op));
   return 1;
}
int do_discuss(int open, string type, string club_name) {
   if (open) {
      open = CLUB_DISCUSS_OPEN;
   }
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("No such club '" + club_name + "'.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_elected_club(club_name)) {
      add_failed_mess("The club " + CLUB_HANDLER->query_club_name(club_name) +
                      " is not an elected club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->holds_any_position_of(club_name, this_player()->query_name())) {
      if (type != "no confidence" &&
          type != "remove member") {
         add_failed_mess("Non elected officals can only add discussion items "
                         "of 'no confidence' and 'remove member'.\n");
         return 0;
      }
   }
   switch (type) {
      case "description" :
         return do_discuss_description(open, club_name);
      case "add position" :
         return do_discuss_add_position(open, club_name);
      case "change position name" :
         return do_discuss_change_position_name(open, club_name);
      case "memo" :
         return do_discuss_memo(open, club_name);
      case "remove member" :
         return do_discuss_remove_member(open, club_name);
      case "secret" :
         return do_discuss_secret(open, club_name);
      case "remove position" :
         return do_discuss_remove_position(open, club_name);
      case "no confidence" :
         return do_discuss_no_confidence(open, club_name);
      case "create account" :
         return do_discuss_create_account(open, club_name);
      case "remove account" :
         return do_discuss_remove_account(open, club_name);
      default :
         add_failed_mess("Horrible, horrible error.  The worms!  "
                         "The worms!\n");
         return 0;
   }
}

==================================================
FILE: /lib/std/room/inherit/club_owned_room.c
==================================================

inherit "/std/room/inherit/owned_room";
private nosave string _club_controller;
private nosave string _club_owned_id;
string query_owner() {
   return _club_controller->query_owner_of(_club_owned_id);
}
void set_club_controller(string club_controller) {
   _club_controller = club_controller;
}
string query_club_controller() {
   return _club_controller;
}
void set_owned_id(string id) {
   _club_owned_id = id;
}
string query_owned_id() {
   return _club_owned_id;
}

==================================================
FILE: /lib/std/room/inherit/complaints_room.c
==================================================

#include <complaints_handler.h>
#include <board.h>
void init() {
    add_command( "complain", "" );
}
int do_complain() {
    if ( this_player()->query_property( "guest" ) )
        return add_failed_mess( "Guest characters cannot lodge "
                                "complaints.\n" );
    tell_object( this_player(), "You are lodging an official complaint about "
                 "something or someone.\n"
                 "Do not take this action lightly.\n"
                 "Complaints should be about serious Disc-related matters.  "
                 "Please note that this complaint is submitted anonymously.  "
                 "If you wish to receive a reply, make sure you place your "
                 "character name in the complaint so we know who to respond "
                 "to.\n"
                 "Feedback for the general populous also often appears on "
                 "various bulletin boards.\n" );
    this_player()->do_edit( 0, "finish_complaint", this_object() );
    return 1;
}
void finish_complaint( string str ) {
    if ( !str ) {
        tell_object( this_player(), "Complaint aborted.\n" );
    } else {
        if ( COMPLAINTS_HANDLER->do_submit_complaint( str ) ) {
            tell_object( this_player(), "Complaint posted.  Thank you for "
                         "your complaint.  If you submitted your name in "
                         "your complaint, you should receive a response in "
                         "the near future.  Please be patient, as there may "
                         "be in-depth discussions as a result of your "
                         "complaint.\n" );
        } else {
            tell_object( this_player(), "There has been a problem posting "
                         "your complaint.  As a result it has NOT been "
                         "submitted.  You should contact a liaison or other "
                         "creator to get this rectified immediately.\n" );
        }
    }
}
int board_access_check( int type, string, object previous, string name ) {
    tell_creator("arienne",file_name(previous)+"\n");
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
    case B_ACCESS_DELETE :
        return 0;
    }
}

==================================================
FILE: /lib/std/room/inherit/council_base.c
==================================================

#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
private nosave string _council_area;
string query_council_area() {
   return _council_area;
}
void set_council_area(string area) {
   _council_area = area;
}
void send_council_inform(int magistrate_only, string message) {
   NOMIC_HANDLER->send_council_inform(query_council_area(),
                                       magistrate_only, message);
}

==================================================
FILE: /lib/std/room/inherit/guild.c
==================================================

#include <money.h>
#include <skills.h>
#include <tune.h>
#include <config.h>
private int cost_div;
private int cost_mult;
private string our_guild;
private string start_pos;
private mapping spells;
private mapping commands;
private object teaching_person;
void check_spells_commands(string *sk, int lvl);
int do_cost_primaries();
int do_cost_all(int brief);
int do_cost_to(string skill, int level);
int do_cost_by(string skill, int level);
int do_cost(string skill);
int do_advance(string skill);
int do_advance_to(string skill, int num);
int do_advance_by(string skill, int num);
void create()
{
   cost_div = COST_DIV;
   cost_mult = 100;
   spells = ([ ]);
   commands = ([ ]);
   this_object()->add_help_file("guild");
}
void init()
{
   this_player()->add_command("advance", this_object(),
                              "<string>", (: do_advance($4[0]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> to <number>",
                              (: do_advance_to($4[0], $4[1]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> by <number>",
                              (: do_advance_by($4[0], $4[1]) :));
   this_player()->add_command("join", this_object(), "");
   this_player()->add_command("info", this_object(), "");
   this_player()->add_command("cost", this_object(),
                              "primaries", (: do_cost_primaries() :));
   this_player()->add_command("cost", this_object(),
                              "all", (: do_cost_all(0) :));
   this_player()->add_command("cost", this_object(),
                              "all brief", (: do_cost_all(1) :));
   this_player()->add_command("cost", this_object(),
                              "<string>", (: do_cost($4[0]) :));
   this_player()->add_command("cost", this_object(),
                              "<string> to <number>",
                              (: do_cost_to($4[0], $4[1]) :));
   this_player()->add_command("cost", this_object(), "<string> by <number>",
                              (: do_cost_by($4[0], $4[1]) :));
   if ((string) this_player()->query_guild_ob() == our_guild) {
      if (stringp(start_pos) && !clonep(this_object())) {
         this_player()->add_start(file_name(this_object()), start_pos);
      }
   }
}
varargs void set_guild(string word1, string word2)
{
   our_guild = word1;
   start_pos = word2;
}
void set_cost_div(int number)
{
   cost_div = number;
   if (!cost_div)
      cost_mult = 1000;
   else
      cost_mult = 10 + (990 * cost_div) / (10 * COST_DIV + cost_div);
}
int query_skill_cost(string skill, int offset)
{
   int i;
   int total;
   string *next;
   next = (string *) SKILL_OB->query_immediate_children(skill);
   if (!sizeof(next)) {
      if (!this_player()->query_guild_ob())
         total = DEFAULT_COST;
      else
         total = (int) our_guild->query_skill_cost(skill);
      total *= (STD_COST * cost_mult) / 500;
      total *= ((int) this_player()->query_skill(skill) + offset) /
         LEVEL_DIV + 1;
      total = to_int(total * exp((this_player()->query_skill(skill) +
                                  offset) / 150.0));
      return total;
   }
   for (i = 0; i < sizeof(next); i++)
      total += query_skill_cost(next[i], offset);
   return total;
}
int do_advance_internal(string skill, int to, int by)
{
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   int lvl;
   int max_lvl;
   int tmp;
   int total_xp;
   int total_cost;
   int tmp_cost;
   int p_val;
   int i, j;
   int round_value;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You cannot advance here!  Go to your own guild.\n");
      return 0;
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("The skill " + skill + " does not exist.\n");
      return 0;
   }
   bits = SKILL_OB->query_inactive_skills();
   for(j=0; j<sizeof(bits); j++)
     if(strsrch(skill, bits[j]) != -1)
       return add_failed_mess("The skill " + skill + " is inactive at "
                              "present and cannot be taught.\n");
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by <= 0) {
      if (by == 0) {
         add_failed_mess("You are already at level " + lvl + " at " +
                         skill_name + ".\n");
      } else {
         add_failed_mess("You cannot regress below your current "
                         "skill level!\n");
      }
      return 0;
   }
   if (SKILL_OB->query_only_leaf(skill_name)) {
      if (sizeof((mixed *)SKILL_OB->query_immediate_children(skill_name))) {
         add_failed_mess("You can only advance the outer skills "
                         "(eg: other.movement.riding.horse), "
                         "not the internal "
                         "skills (eg: other.movement.riding, or other).\n");
         return 0;
      }
   } else {
      bits = explode(skill_name, ".");
      if (sizeof(bits) > 1) {
         outer_name = implode(bits[0..<2], ".");
         if (!SKILL_OB->is_skill_ignored(outer_name) &&
             ((sizeof(bits) - 1) * 5) >
             (int) this_player()->query_skill(outer_name)) {
            add_failed_mess("You are not at a high enough level in " +
                            outer_name +
                            " to advance " + skill_name + " yet.\n");
            return 0;
         }
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("You cannot advance in " + skill_name +
                      " any further here.\n");
      return 0;
   }
   p_val = (int) this_player()->query_value_in(place);
   if (place != "default") {
      p_val += (int) this_player()->query_value_in("default");
   }
   round_value = MONEY_HAND->query_smallest_value_in(place);
   total_cost = 0;
   for (i = 0; i < by; i++) {
      tmp = query_skill_cost(skill_name, i);
      if ((int) this_player()->query_xp() < tmp + total_xp) {
         if (!i) {
            add_failed_mess("Your lack of experience prevents you improving "
                            + skill_name + ".\n");
            return 0;
         } else {
            write("Your lack of experience prevents you taking all the "
                  "advancement you requested in " + skill_name + ".  You are "
                  "only trained up to level " + (i + lvl) + ".\n");
         }
         break;
      }
      if ((lvl + i) >= max_lvl) {
         write("Your guild hasn't the resources to train you as far as " +
               "you requested in " + skill_name +
               ".  It trains you to level " + max_lvl + ".\n");
         break;
      }
      if (cost_div) {
         tmp_cost = ( total_xp + tmp ) / cost_div;
         tmp_cost -= (tmp_cost % round_value);
         if ( tmp_cost > p_val ) {
            if (!i) {
               add_failed_mess
                  ("Due to your lack of money, the guild cannot train " +
                   "you in " + skill_name + ": it would have cost you " +
                   MONEY_HAND->money_value_string( tmp_cost, place ) + ".\n" );
               return 0;
            } else {
               write("Due to your sad lack of money the guild cannot train " +
                     "you in " + skill_name + " to level " + (by + lvl) +
                     ".  It trains you to level " + (i + lvl) + " instead.\n");
            }
            break;
         }
      }
      total_xp += tmp;
      total_cost = tmp_cost;
   }
   if (!total_xp) {
      return add_failed_mess("Oops, something has gone wrong.\n");
   }
   this_player()->adjust_xp(-total_xp);
   if (total_cost) {
      this_player()->pay_money((mixed *) MONEY_HAND->
                               create_money_array(total_cost, place), place);
   }
   this_player()->add_skill_level(skill_name, i, total_xp);
   this_player()->reset_all();
   this_player()->dest_hide_shadow();
   event(this_object(), "guild_advance", bits, lvl, lvl + i);
   check_spells_commands(bits, lvl + i);
   write("You advance your skill in " + skill_name + " from " + lvl + " to " +
         (lvl + i) + " for " + total_xp + " xp" + (total_cost ? " and " +
                                                   (string) MONEY_HAND->
                                                   money_value_string
                                                   (total_cost,
                                                    place) : "") + ".\n");
   say((string) this_player()->one_short() + " $V$0=advances,advance$V$ " +
       "$V$0=" + this_player()->query_possessive() + ",their$V$ skills.\n");
   return 1;
}
int do_advance(string skill)
{
   return do_advance_internal(skill, 0, 1);
}
int do_advance_by(string skill,
                  int num)
{
   return do_advance_internal(skill, 0, num);
}
int do_advance_to(string skill,
                  int num)
{
   return do_advance_internal(skill, num, 0);
}
int do_join(string str)
{
   if ((string) this_player()->query_guild_ob() == our_guild) {
      add_failed_mess("You're already in this guild.\n");
      return 0;
   }
   if (this_player()->query_guild_ob()) {
      add_failed_mess("You cannot join a guild while a member of another.\n");
      return 0;
   }
   write("You will only ever get to join one guild.  Are you sure? ");
   input_to("join2");
   return 1;
}
int join2(string str)
{
   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write("I do not understand.  Yes or no? ");
      input_to("join2");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not joining the " + our_guild->query_name() + " guild.\n");
      return 1;
   }
   this_player()->set_guild_ob(our_guild);
   if (stringp(start_pos) && !clonep(environment(this_player())))
      this_player()->add_start(file_name(environment(this_player())),
                               start_pos);
   this_player()->race_guild_commands();
   write("You are now a member of the " + our_guild->query_name() +
         " guild.\n");
   say(this_player()->one_short() + " joins the " + our_guild->query_name() +
       " guild.\n");
   event(this_object(), "guild_join");
   event(users(), "inform",
         this_player()->query_cap_name() + " is now a member " + "of " +
         our_guild->query_name(), "guild");
   return 1;
}
int do_leave(string str)
{
   if (str != "guild") {
      add_failed_mess("Syntax : leave guild\n");
      return 0;
   }
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("How can you leave a guild if you aren't in it.\n");
      return 0;
   }
   if ((int) this_player()->query_level() > 5) {
      add_failed_mess("You are too high a level to leave this guild.\n");
      return 0;
   }
   write("Are you sure you want to leave the guild (Y/N) : ");
   input_to("confirm_leave");
   return 1;
}
void confirm_leave(string str)
{
   str = lower_case(str);
   if (str != "y") {
      write("You are still in the guild.\n");
      return;
   }
   write("Goodbye.\n");
   call_other(our_guild, "leaving_guild");
   this_player()->set_start_pos(CONFIG_START_LOCATION);
   this_player()->set_guild_ob(0);
   this_player()->set_guild_data(0);
   this_player()->guild_commands();
   this_player()->save_me();
}
int check_primaries(string lpath, string g_o)
{
   int i;
   string dummy,
    *primaries;
   primaries = (string *) g_o->query_skills();
   if (member_array(lpath, primaries) != -1)
      return 1;
   for (i = 0; i < sizeof(primaries); i++)
      if (sscanf(primaries[i], lpath + ".%s", dummy))
         return 1;
   return 0;
}
mixed *filter_primaries(mixed *tmp_skills, string skill_path,
                        string *primaries)
{
   int i;
   string test_skill;
   for (i = 0; i < sizeof(tmp_skills); i += SKILL_ARR_SIZE)  {
      test_skill = skill_path + tmp_skills[i];
      if (sizeof(tmp_skills[i + SKILL_BIT]) != 0)
         tmp_skills[i + SKILL_BIT] =
            filter_primaries(tmp_skills[i + SKILL_BIT], test_skill + ".",
                             primaries);
      if (member_array(test_skill, primaries) == -1  &&
          sizeof(tmp_skills[i + SKILL_BIT]) == 0)
      {
         tmp_skills = tmp_skills[0 .. (i - 1)] +
                      tmp_skills[(i + SKILL_ARR_SIZE) .. ];
         i -= SKILL_ARR_SIZE;
      }
   }
   return tmp_skills;
}
private string rec_cost(mixed *arr, string path, int depth, string guild,
                        int brief)
{
   int i;
   int depth_gap;
   int ndots;
   int lvl;
   int max_lvl;
   int only_leaf;
   int tmp;
   string str;
   string sub_str;
   string lpath;
   str = "";
   depth_gap = (depth - 1) * 2;
   ndots = 19 - depth_gap;
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      lpath = path + arr[i];
      lvl = this_player()->query_skill(lpath);
      if (!guild) {
         max_lvl = 5;
      } else {
         max_lvl = guild->query_skill_max_level(lpath);
      }
      only_leaf = SKILL_OB->query_only_leaf(lpath);
      if (only_leaf  &&  sizeof(arr[i + SKILL_BIT]) > 0)  {
         sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                            guild, brief);
         if (sub_str != "")  {
            str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                           ndots + 18, arr[i]) + sub_str;
            continue;
         }
      }
      else if (SKILL_OB->query_allowed_to_teach(lpath))  {
         if (lvl >= max_lvl)  {
            if (brief)  {
               sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                                  guild, brief);
               if (sub_str != "")  {
                  str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                                 ndots + 18, arr[i]) + sub_str;
                  continue;
               }
            }
            else str += sprintf("%*'| 's%-*'.'s%4d/%3d  mastered\n", depth_gap,
                                "", ndots, arr[i], lvl, max_lvl);
         }
         else if (SKILL_OB->query_allowed_to_teach(lpath))  {
            tmp = query_skill_cost(lpath, 0);
            str += sprintf("%*'| 's%-*'.'s%4d/%3d %6d xp\n", depth_gap, "",
                           ndots, arr[i], lvl, max_lvl, tmp);
         }
      }
      if (lvl >= depth * 5  ||  only_leaf) {
         reset_eval_cost();
         str += rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1, guild,
                         brief);
      }
   }
   return str;
}
int do_cost_all(int brief)
{
   mixed *arr;
   string list;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols(),
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols() + 1,
                   rec_cost(arr, "", 1, our_guild, brief));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols(),
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "All", 1);
   return 1;
}
int do_cost_primaries()
{
   mixed *arr;
   string list;
   string *primaries;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols(),
                   rec_cost(arr, "", 1, our_guild, 0));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "Primaries", 1);
   return 1;
}
int do_cost_internal(string skill, int to, int by)  {
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   string cost_str;
   int lvl;
   int max_lvl;
   int i;
   int tmp;
   int cost;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by == 0) {
      add_failed_mess
         ("It won't cost you anything to stay at the same level!\n");
      return 0;
   }
   if (by < 0) {
      add_failed_mess("We can't give refund xp for regressing skills!\n");
      return 0;
   }
   bits = explode(skill_name, ".");
   if (sizeof(bits) > 1  &&  !SKILL_OB->query_only_leaf(skill_name)) {
      outer_name = implode(bits[0 .. <2], ".");
      if (!SKILL_OB->is_skill_ignored(outer_name) &&
          ((sizeof(bits) - 1) * 5) > this_player()->query_skill(outer_name))
      {
         add_failed_mess("You are not at a high enough level in " +
                         outer_name + " to advance " + skill_name +
                         " yet.\n");
         return 0;
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("Your guild prevents you even considering advancing " +
                      skill_name + " above level " + max_lvl + ".\n");
      return 0;
   }
   for (i = 0; i < by; i++) {
      if ((lvl + i) >= max_lvl) {
         write("Your guild prevents you considering all the advancement you "
               + "requested.  You can only advance up to level " + max_lvl +
               " in " + skill_name + " here.\n");
         break;
      }
      tmp += query_skill_cost(skill_name, i);
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   cost_str = "";
   if (cost_div) {
      cost = tmp / cost_div;
      cost += cost % MONEY_HAND->query_smallest_value_in(place);
      if (cost)
         cost_str = " and " + MONEY_HAND->money_value_string(cost, place);
   }
   printf("It would cost you %d xp%s to raise %s from level %d to %d.\n",
          tmp, cost_str, skill_name, lvl, (lvl + i));
   return 1;
}
int do_cost(string skill)
{
   mixed *arr;
   int i;
   int depth;
   string list;
   string exp_skill;
   string *sub_skills;
   int only_leaf;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   exp_skill =
      SKILL_OB->query_skill(explode(implode(explode(skill, " "), "."), "."));
   if (!exp_skill)  {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   if (SKILL_OB->query_allowed_to_teach(exp_skill))  {
      i = member_array(exp_skill, arr);
      only_leaf = SKILL_OB->query_only_leaf(exp_skill);
      if (only_leaf)  {
         sub_skills = explode(exp_skill, ".");
         foreach (skill in sub_skills[0 .. < 2])  {
            i = member_array(skill, arr);
            arr = arr[i + 3];
         }
         i = member_array(sub_skills[<1], arr);
         depth = sizeof(sub_skills) + 1;
      }
      else depth = 2;
      if (sizeof(arr[i + 3]) > 0)  {
         list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                        "======SKILLS=======Cur/Max==For Next") +
                sprintf("%#*-s\n", (int) this_player()->query_cols(),
                         rec_cost(arr[i + SKILL_BIT], exp_skill + ".", depth,
                         our_guild, 0)) +
                sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                         "> You have " + (int) this_player()->query_xp() +
                         " points to spend <");
         this_player()->more_string(list, capitalize(exp_skill), 1);
         return 1;
      }
   }
   return do_cost_internal(exp_skill, 0, 1);
}
int do_cost_to(string skill, int num)
{
   return do_cost_internal(skill, num, 0);
}
int do_cost_by(string skill, int num)
{
   return do_cost_internal(skill, 0, num);
}
int do_info()
{
   mixed *arr;
   string *primaries;
   write(our_guild->long() +
         "\nThis guild's primary skills and costs are:\n");
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   printf("%-*'='s\n", this_player()->query_cols() - 1,
          "======SKILLS=======Cur/Max==For Next");
   printf("%#*-s\n", this_player()->query_cols(),
          rec_cost(arr, "", 1, our_guild, 0));
   printf("%*'='|s\n", this_player()->query_cols() - 1, "> You have " +
          this_player()->query_xp() + " points to spend <");
   return 1;
}
void set_teaching_person(object ob)
{
   teaching_person = ob;
}
object query_teaching_person()
{
   return teaching_person;
}
void add_spell(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!spells[path])
      spells[path] = ({ name, lvl });
   else
      spells[path] += ({ name, lvl });
}
void add_command(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!commands)
      commands = ([ ]);
   if (!commands[path])
      commands[path] = ({ name, lvl });
   else
      commands[path] += ({ name, lvl });
}
void check_spells_commands(string *sk, int lvl)
{
   string *bits;
   int val;
   int i;
   int j;
   if (!teaching_person)
      return;
   bits = keys(spells);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(spells[bits[i]]); j += 2)
         if ((spells[bits[i]][j + 1] < val) &&
             !(this_player()->query_spell(spells[bits[i]][j])))
            teaching_person->init_command("teach " + spells[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
   bits = keys(commands);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(commands[bits[i]]); j += 2)
         if ((commands[bits[i]][j + 1] < val) &&
             !(this_player()->query_known_command(commands[bits[i]][j])))
            teaching_person->init_command("teach " + commands[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
}
mapping query_spells()
{
   return spells + ([ ]);
}
mapping query_commands()
{
   return commands + ([ ]);
}
string query_start_pos()
{
   return start_pos;
}
string query_our_guild()
{
   return our_guild;
}

==================================================
FILE: /lib/std/room/inherit/honours.c
==================================================

#include <player_handler.h>
#include <player.h>
class honour {
   int time_added;
   string reason;
   string cap_name;
   string added_by;
}
private nosave string* _titles;
mapping _honours;
int is_allowed_to_change(string person);
void save_me();
void create() {
   _honours = ([ ]);
   _titles = ({ });
}
void inform_of_honour_change(string type, string person,
                      string reason, string changed_by) {
}
void set_controlled_titles(string* title) {
   _titles = title;
}
string* query_controlled_titles() {
   return _titles;
}
void add_to_honour_roll(string person, string reason, string added_by) {
   string title;
   if (_honours[person]) {
      return ;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      return ;
   }
   _honours[person] = new(class honour);
   _honours[person]->time_added = time();
   _honours[person]->reason = reason;
   _honours[person]->added_by = added_by;
   _honours[person]->cap_name = PLAYER_HANDLER->query_cap_name(person);
   foreach (title in _titles) {
      PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
   }
   save_me();
}
void remove_from_honour_roll(string person) {
   string title;
   if (!_honours[person]) {
      return ;
   }
   map_delete(_honours, person);
   if (find_player(person)) {
      foreach (title in _titles) {
         find_player(person)->remove_player_title(title);
      }
   }
   save_me();
}
int is_on_honour_roll(string person) {
   return classp(_honours[person]);
}
int do_list_honour() {
   string person;
   class honour roll;
   string ret;
   string* people;
   if (!_honours) {
      _honours = ([ ]);
   }
   if (!sizeof(_honours)) {
      add_failed_mess("There is no one on the honour roll.\n");
      return 0;
   }
   ret = "";
   people = sort_array(keys(_honours), (: _honours[$1]->time_added - _honours[$2]->time_added :));
   foreach (person in people) {
      roll = _honours[person];
      ret += "$I$3=%^YELLOW%^" + roll->cap_name + "%^RESET%^ at " +
             amtime(roll->time_added) +
             " for " + roll->reason + " by " + roll->added_by + "\n";
   }
   write("$P$Honour Roll$P$" + ret);
   return 1;
}
int do_honour_add(string person) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }
   if (is_on_honour_roll(person)) {
      add_failed_mess("They are already on the honour roll.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("The person " + person + " does not exist.\n");
      return 0;
   }
   write("Enter the reason for adding " + person + " to the honour roll:\n");
   this_player()->do_edit("", "end_honour_add", this_object(), 0, person);
   add_succeeded_mess("");
   return 1;
}
void end_honour_add(string reason, string person, string bing) {
   if (reason == "" || !reason) {
      write("Aborting.\n");
      return ;
   }
   write("Adding the person " + person + " to the honour roll with a reason "
         "of:\n" + reason + "\nAre you sure? ");
   input_to("honour_roll_confirm", 0, person, reason);
}
void honour_roll_confirm(string response, string person, string reason) {
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   add_to_honour_roll(person, reason, this_player()->query_cap_name());
   inform_of_honour_change("add", person, reason,
                           this_player()->query_name());
   add_succeeded_mess("$N add$s " + person + " to the honour roll.\n");
   return ;
}
int do_honour_remove(string person, string reason) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }
   if (!is_on_honour_roll(person)) {
      add_failed_mess("They are not on the honour roll.\n");
      return 0;
   }
   remove_from_honour_roll(person);
   inform_of_honour_change("remove", person, reason,
                           this_player()->query_cap_name());
   add_succeeded_mess("$N remove$s " + person + " to the honour roll.\n");
   return 1;
}
void readd_all_titles() {
   string person;
   class honour roll;
   foreach (person, roll in _honours) {
      foreach (string title in _titles) {
         PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
      }
   }
}
void init() {
   if (!sizeof(_titles)) {
      return 0;
   }
   add_command("list", "honour [roll]", (: do_list_honour() :));
   if (is_allowed_to_change(this_player()->query_name())) {
      add_command("add",
                  "<string'person'> to honours",
                  (: do_honour_add($4[0]) :));
      add_command("remove",
                  "<string'person'> from honours because <string'reason'>",
                  (: do_honour_remove($4[0], $4[1]) :));
   }
}

==================================================
FILE: /lib/std/room/inherit/meeting.c
==================================================

private object _floor;
private string _leader;
int do_bang();
int do_recover();
int do_start();
int do_finish();
object create_floor();
void add_property(string name, mixed data);
void create() {
   _floor = create_floor();
   _floor->move(this_object());
}
void init() {
   add_command("bang", "gavel", (: do_bang() :));
   add_command("recover", "floor", (: do_recover() :));
   add_command("start", "meeting", (: do_start() :));
   add_command("finish", "meeting", (: do_finish() :));
}
object create_floor() {
   object floor;
   floor = clone_object("/std/object");
   floor->set_name("floor");
   floor->set_short( "floor" );
   floor->add_property( "determinate", "the " );
   floor->add_property( "no burial", 1);
   floor->set_long("This is the floor of the meeting.  It gives you the "
                   "right to speak during the meeting.  Please give this "
                   "to the next person to speak after you have finished.\n");
   return floor;
}
int do_start() {
   if (_leader &&
       find_player(_leader) &&
       environment(find_player(_leader)) == this_object()) {
      add_failed_mess("There is already a meeting started with " +
                      find_player(_leader)->the_short() +
                      " as the leader.\n");
      return 0;
   }
   _leader = this_player()->query_name();
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
}
int do_bang() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can bang the gavel!\n");
      return 0;
   }
   add_succeeded_mess("$N $V the gavel.\n\nSTOP STOP!\n\n");
   return 1;
}
int do_recover() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can recover the floor.\n");
      return 0;
   }
   _floor->move(this_player());
   add_succeeded_mess("$N recovers the floor.\n");
   return 1;
}
int do_finish() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can stop the meeting!\n");
      return 0;
   }
   _leader = 0;
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
}
void event_exit(object ob,
                string mess,
                object to) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      "'s hands and flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}
void event_dest_me(object ob) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}
void event_quit(object ob) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}
