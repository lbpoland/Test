# Total Tokens: 20519
# Total Files Merged: 19
# Total Characters: 68453

c
==================================================

#include <player.h>
#include <room.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd( object *indirect_obs, string direction) {
  string owner;
  object owner_ob;
  string *words, word;
  if( this_player()->query_property( "dead" ) )
    return add_failed_mess( "You're dead.  You can't drag anything.\n" );
  if( objectp( (object)this_player()->query_dragging() ) )
    return add_failed_mess( "You're already dragging something.\n" );
  if( sizeof( indirect_obs ) > 1 )
    return add_failed_mess( "You can only drag one thing at a time.\n" );
  if( indirect_obs[0] == this_player() )
    return add_failed_mess( "You try and drag yourself away from the keyboard, "
      "but you cannot.  Oh no!\n");
  if( living( indirect_obs[ 0 ] ) ) {
    if( !indirect_obs[ 0 ]->query_property( PASSED_OUT_PROP )
        || pk_check( indirect_obs[ 0 ], this_player() ) )
      return add_failed_mess( (string)indirect_obs[ 0 ]->the_short() +
        " doesn't want to be dragged away, thank you very much.\n" );
  } else
    if( base_name(indirect_obs[0]) == "/obj/corpse" ) {
      owner = indirect_obs[ 0 ]->query_owner();
      words = explode( lower_case( owner ),  " " );
      words = filter( words, (: PLAYER_HANDLER->test_user($1) :) );
      foreach( word in words ) {
          owner_ob = find_player( lower_case( word ) );
          if( owner_ob && userp( owner_ob ) &&
            pk_check( owner_ob, this_player() ) &&
            member_array ( this_player()->query_name(), indirect_obs[0]->
            query_permitted() ) == -1 )
            return add_failed_mess( "For some reason, you can't get hold of "+
              (string)indirect_obs[ 0 ]->the_short() +".\n" );
      }
  }
  if( ( environment( indirect_obs[ 0 ] ) != environment( this_player() ) ) ||
    indirect_obs[ 0 ]->get() )
      return add_failed_mess( "For some reason, you can't get hold of " +
        (string)indirect_obs[ 0 ]->the_short() +".\n" );
  write( "You get hold of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->one_short() + " gets hold of " +
    (string)indirect_obs[ 0 ]->a_short() + ".\n" );
  if( (int)indirect_obs[ 0 ]->query_complete_weight() +
    (int)this_player()->query_loc_weight() > 2 *
    (int)this_player()->query_max_weight() ) {
      write( "You struggle and strain, but you can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
      say( (string)this_player()->one_short() + " struggles and strains, but " +
        (string)this_player()->query_pronoun() + " can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
  } else {
    this_player()->set_dragging( indirect_obs[ 0 ] );
    if( !this_player()->exit_command( direction ) )
      write( "You can't drag " + (string)indirect_obs[ 0 ]->the_short() +
        " that way.\n" );
    else
      if( interactive( this_player() ) )
        indirect_obs[0]->add_property( "dropped",
          ({this_player()->query_name(), query_ip_number( this_player() ),
          time()}), 1800 );
    this_player()->reset_dragging();
  }
  write( "You let go of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->the_short() + " releases " +
    (string)this_player()->query_possessive() + " hold of " +
    (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  return 1;
}
mixed *query_patterns() {
  return
    ({ "<indirect:object:here> [to] <word'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :),
       "<indirect:object:here> [to] <string'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :) });
}

==================================================
FILE: living/draw.c
==================================================

#include <move_failures.h>
#include <obj_parser.h>
#define DEFAULT -1
#define LEFT 0
#define RIGHT 1
inherit "/cmds/base";
int cmd( string weapon_str, object * scabbards, string hand_str ) {
   object scabbard, * weapons, weapon;
   class obj_match match;
   string *limbs;
   string *hands;
   int *what_in;
   int targeted, result;
   int hand;
   match = new( class obj_match );
   targeted = scabbards ? 1 : 0;
   debug_printf( "targeted = %d\nscabbards = %O\n", targeted, scabbards );
   if( !scabbards ) {
      scabbards = filter( all_inventory( this_player() ),
        (: $1->query_scabbard() :) );
      if( !sizeof(scabbards) ) {
         add_failed_mess( "Can't find any scabbards in your inventory.\n" );
         return 0;
      }
      foreach( scabbard in scabbards ) {
         match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
           0, this_player() );
         result = match->result;
         if( result == OBJ_PARSER_SUCCESS ) {
            weapons = match->objects;
            break;
         } else if( result == OBJ_PARSER_AMBIGUOUS ) {
            add_failed_mess( "Ambiguous reference to \"" + weapon_str
              + "\" in at least one scabbard.\n" );
         }
      }
      if( !sizeof(weapons) ) {
         add_failed_mess( "Cannot find " + weapon_str + " in any "
           "scabbard in your inventory.\n" );
         return 0;
      }
   } else {
      if( sizeof(scabbards) > 1 ) {
         add_failed_mess( "You can only draw from one scabbard at a "
           "time.\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not a scabbard.\n" );
         return 0;
      }
      if ( environment(scabbard) != this_player() ) {
         add_failed_mess( "You can only draw from a scabbard in your "
           "inventory.\n" );
         return -1;
      }
      match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
        0, this_player() );
      if( match->result == OBJ_PARSER_SUCCESS ) {
         weapons = match->objects;
      } else {
         add_failed_mess( "Cannot find " + weapon_str + " in " +
           scabbard->the_short() + ".\n" );
         return -1;
      }
   }
   weapon = weapons[0];
   if ( scabbard->query_closed() ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + "; it is closed.\n" );
      return targeted ? -1 : 0;
   }
   if( !scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if ( weapon->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  hand = -1;
   else hand = member_array(hand_str, this_player()->query_limbs());
   if ( !sizeof( weapon->hold_item( this_player(), hand ) ) ) {
      weapon->move( scabbard );
      add_failed_mess( "You cannot hold " + weapon->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  {
      limbs = this_player()->query_limbs();
      what_in = find_member(weapon, this_player()->query_holding());
      hands = allocate(sizeof(what_in));
      for (hand = 0; hand < sizeof(what_in); hand++)
         hands[hand] = limbs[what_in[hand]];
      hand_str = query_multiple_short(hands);
   }
   this_player()->add_succeeded_mess(scabbard, "$N $V $I from $D into $p " +
                                     hand_str + ".\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   string limbs;
   limbs = "{" + implode(this_player()->query_limbs(), "|") + "}";
   return ({
      "<string'weapon'>",
        (: cmd( $4[0], 0, 0 ) :),
      "<string'weapon'> from <indirect:object:me'scabbard'>",
        (: cmd( $4[0], $1, 0 ) :),
      "<string'weapon'> into [my] " + limbs,
        (: cmd($4[0], 0, $4[1]) :),
      "<string'weapon'> from <indirect:object:me'scabbard'> into [my] " + limbs,
        (: cmd( $4[0], $1, $4[2]) :),
   });
}

==================================================
FILE: living/drop.c
==================================================

#include <move_failures.h>
#include <player.h>
#define MAX_DROP_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *obs, string str) {
   int num, max;
   object bing;
   string env_sh;
   object ob;
   object *fail;
   object *too_many;
   object *keep;
   mapping ret;
   object env;
   string drop_mess;
   ret = ([ ]);
   fail = ({ });
   too_many = ({ });
   keep = ({ });
   if (sizeof(obs) > MAX_DROP_NUMBER) {
      too_many = obs[MAX_DROP_NUMBER..];
      obs = obs[0..MAX_DROP_NUMBER-1];
   }
   foreach(ob in obs) {
      if (!ob->short()) {
         continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      env = environment(ob);
      if (function_exists("do_drop", ob) ||
            function_exists("command_control", ob)) {
         if (function_exists("do_drop", ob)) {
            max = (int)call_other(ob, "do_drop", ({ }), str, 0, ({ str }),
                                             "<direct:object:me>");
         } else {
            max = ob->command_control("drop", ({ }), str, 0, ({ str }),
                                                   "<direct:object:me>");
         }
         if (max == 0)  {
            fail += ({ ob });
            continue;
         }
      }
      if (ob->move(environment(TP)) == MOVE_OK) {
         if (ret[env]) {
            ret[env] += ({ ob });
         } else {
            ret[env] = ({ ob });
         }
#ifndef __DISTRUBUTION_LIB__
         if(interactive(TP))
           PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
      } else {
        fail += ({ ob });
      }
   }
   if (sizeof(ret)) {
      foreach (env, bing in ret) {
         if (env != this_player()) {
            env_sh = " from inside " + inside_the_short(env);
         } else {
            env_sh = "";
         }
         if ( drop_mess = this_player()->query_drop_mess() ) {
            add_succeeded_mess( drop_mess, bing );
         }
         else {
            add_succeeded_mess("$N $V $I" + env_sh + ".\n", bing);
         }
      }
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding.\n", "" }));
      }
   } else {
      if (sizeof(keep)) {
         add_failed_mess("You are keeping $I.\n", keep);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot drop $I.\n", fail);
         return 0;
      }
      if (sizeof(too_many)) {
         add_failed_mess("You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding $I.\n", too_many);
         return 0;
      }
   }
   num = sizeof(fail)+sizeof(ret);
   if (!num) {
        return 0;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1, $3) :) });
}

==================================================
FILE: living/dry.c
==================================================

inherit "/cmds/base";
mixed cmd(mixed *things)
{
   int pwet;
   int twet;
   int max;
   int *enums;
   object thing;
   object with;
   thing = things[0][0];
   with = things[1][0];
   if (!with->id("towel") && !with->query_property("dryer")) {
      return notify_fail("You can't dry anyone with " +
                         (string) with->the_short() + ".\n");
   }
   if (environment(with) != this_player())  {
      return notify_fail(with->a_short() + " isn't going to do much good "
         "inside " + environment(with)->a_short() + ".\n");
   }
   if (thing->query_property("dead")) {
      return notify_fail((string) thing->the_short() + " is dead; " +
                         (string) thing->query_pronoun() +
                         " has more immediate problems than being wet.\n");
   }
   max = 200 * (int) with->query_weight();
   enums = (int *) with->effects_matching("object.wet");
   if (sizeof(enums)) {
      twet = (int) with->arg_of(enums[0]);
   }
   if (twet > max / 2) {
      return notify_fail((string) with->the_short() +
                         " is already dripping wet.  You can't dry anybody "
                         "with it.\n");
   }
   enums = (int *) thing->effects_matching("body.wetness");
   if (sizeof(enums)) {
      pwet = (int) thing->arg_of(enums[0]);
   }
   if (pwet < 10) {
      if (thing == this_player()) {
         return notify_fail("You don't need drying.\n");
      } else {
         return notify_fail((string) thing->the_short() +
                            " doesn't need drying.\n");
      }
   }
   if (pwet + twet > max) {
      pwet = max - twet;
   }
   pwet -= random(10);
   if (pwet > 0) {
      thing->add_effect("/std/effects/other/wetness", -pwet);
      with->add_effect("/std/effects/object/wet", pwet);
   }
   if (thing == this_player()) {
      write("You dry yourself with " + with->the_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) this_player()->query_objective() + "self with " +
          (string) with->poss_short() + ".\n");
   } else {
      write("You dry " + (string) thing->the_short() + " with " +
            (string) with->the_short() + ".\n");
      tell_object(thing, (string) this_player()->one_short() +
                  " dries you with " + (string) with->poss_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) thing->the_short() + " with " +
          (string) with->poss_short() + ".\n", thing);
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:living'person'> with <indirect:object:me>",
             (: cmd($1) :),
             "myself with <indirect:object:me>",
             (: cmd(({ ({ this_player() }), $1 })) :) });
}

==================================================
FILE: living/echo.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("echo"))
    return notify_fail(NOT_ALLOWED);
  if (!str || str == "")
    return notify_fail("Syntax : echo <text>\n");
  if (!TP->query_creator() && TP->adjust_sp(-ECHO_COST) < 0)
    return notify_fail(NO_POWER);
  if (TP->query_volume(D_ALCOHOL))
    str = TP->drunk_speech(str);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos: "+
     str+"\n");
  str += "%^RESET%^";
  my_mess("You echo: ", str);
  TP->comm_event(environment(TP), "player_echo", str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/echoto.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string who, what;
  object ob;
  if(!TP->query_creator() && !TP->query_property("echoto"))
    return notify_fail(NOT_ALLOWED);
  if(!str || str == "")
    return notify_fail("Syntax : echoto <player> <text>\n");
  if(sscanf(str, "%s %s", who, what) != 2)
    return notify_fail("Syntax : echoto <player> <text>\n");
  who = lower_case(who);
  who = (string)TP->expand_nickname(who);
  if(!TP->query_creator() && TP->adjust_sp(-ECHOTO_COST) < 0)
    return notify_fail(NO_POWER);
  ob = find_player(who);
  if(!ob)
    return notify_fail("Can't find "+who+".\n");
  if (TP->query_volume(D_ALCOHOL))
    what = TP->drunk_speech(what);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos "+
     "to "+who+": "+what+"\n" );
  what += "%^RESET%^";
  my_mess("You echo to " + who + ": ", what);
  event(ob, "player_echo_to", what + "\n", TP);
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/em_ote.c
==================================================

#include <library.h>
#include <player.h>
inherit "/cmds/base";
mixed cmd( string words ) {
  string pad = " ";
  if(!environment(this_player())) {
    return notify_fail("You are in limbo, you cannot emote.\n");
  }
  if ( userp( this_player() ) && !this_player()->query_creator() ) {
    if ( this_player()->query_property( "emote" ) ) {
      LIBRARY->set_quest( (string)this_player()->query_name(), "emote" );
      this_player()->remove_property( "emote" );
    }
    if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
                                     "emote" ) ) {
      return notify_fail( NOT_ALLOWED );
    }
    if(this_player()->query_property("no emote")) {
      return notify_fail(NOT_ALLOWED);
    }
    if ( (int)this_player()->adjust_sp( -EMOTE_COST ) < 0 ) {
      return notify_fail( NO_POWER );
    }
  }
  if ( !words || ( words == "" ) ) {
    return notify_fail( "Syntax: emote <text>\n" );
  }
  words = strip_colours(words);
  words = replace(words, ({"        ", " ",
                           "       ", " ",
                           "      ", " ",
                           "     ", " ",
                           "    ", " ",
                           "   ", " ",
                            }) );
  this_player()->adjust_time_left( -5 );
  if (words[0..0] == "'") pad = "";
  environment( this_player() )->event_emote( this_player(),
                                             "$C$" + this_player()->one_short() + pad +
                                             words +"\n" );
  all_inventory( environment( this_player() ) )->
    event_emote( this_player(), "$C$" + this_player()->one_short() +
                                pad + words + "%^RESET%^\n" );
  write( "You emote: $C$"+
         (string)this_player()->pretty_short( this_player() ) + pad + words +
         "%^RESET%^\n" );
  return 1;
}

==================================================
FILE: living/emoteall.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
#define BEEP sprintf("%c",7)
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("emoteall")) {
    return notify_fail(NOT_ALLOWED);
  }
  if(!str || str == "") {
    return notify_fail("Syntax : emoteall <string>\n");
  }
  if(!TP->query_creator() &&
     TP->adjust_sp(-EMOTEALL_COST*((strlen(str)/10)+1)+100) < 0) {
    return notify_fail(NO_POWER);
  }
  str = replace(str, BEEP, "");
  if (TP->query_volume(D_ALCOHOL)) {
    str = TP->drunk_speech(str);
  }
  log_file("ECHOS", ctime(time())+" "+TP->query_name()+" emotes "+
           "to all: "+str+"\n");
  str += "%^RESET%^";
  my_mess("You emoteall : ", TP->query_cap_name()+" " + str);
  TP->comm_event(users(), "player_emote_all", "%^BOLD%^%^RED%^" + TP->query_cap_name() + " " + str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/eq_uip.c
==================================================

#define TP this_player()
inherit "/cmds/base";
int cmd() {
   int no_limbs;
   string stuff;
   object thing;
   object *equipped;
   object *things;
   equipped = ({ });
   things = all_inventory( TP ) - TP->query_wearing() -
            TP->query_holding();
   foreach ( thing in things ) {
      no_limbs = thing->query_no_limbs();
      if ( no_limbs > TP->query_free_limbs() ) {
         continue;
      }
      if ( thing->query_wearable() ) {
         if ( !TP->wear_armour( thing, 0 ) ) {
            equipped += ({ thing });
         }
         continue;
      }
      if (thing->query_weapon() && no_limbs) {
         if ( sizeof( TP->set_hold( thing,
               member_array( 0, TP->query_holding() ) ) ) ) {
            equipped += ({ thing });
         }
      }
   }
   if ( !sizeof( equipped ) ) {
      return notify_fail( "You have no equippable items.\n" );
   }
   stuff = query_multiple_short( equipped );
   say( (string)TP->one_short() +" equips "+ stuff +".\n" );
   write( "You equip "+ stuff +".\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: living/facing.c
==================================================

#include <dirs.h>
inherit "/cmds/base";
string find_direction( object who );
int check_reference_point( object where );
int cmd( object *indirect_obs ) {
    mapping details;
    object *oblist;
    string *show, dir;
    if ( !check_reference_point( environment( this_player() ) ) ) {
        add_failed_mess( "You can't make out a point of reference "
            "to use to determine which way you're facing!\n" );
        return 0;
    }
    if ( !indirect_obs || sizeof( indirect_obs ) == 1 &&
        indirect_obs[ 0 ] == this_player()) {
        tell_object( this_player(), "You are facing " +
            find_direction( this_player() ) + ".\n" );
        return 1;
    }
    indirect_obs -= ({ this_player() });
    details = unique_mapping( indirect_obs,
        (: find_direction( $1 ) :) );
    show = ({ });
    foreach(dir, oblist in details)  {
      if (sizeof(oblist) > 1)  {
        show += ({ query_multiple_short(oblist) + " are facing " + dir });
      }
      else  {
        show += ({ oblist[0]->one_short() + " is facing " + dir });
      }
    }
    write(query_multiple_short(show) + ".\n");
    return 1;
}
string find_direction( object who ) {
    int facing;
    mapping directions;
    facing = who->query_facing()[ 0 ];
    directions = filter( ABS_FACING, (: $2 == $(facing) :) );
    if ( !sizeof( directions ) )
        return "north";
    return keys( directions )[ 0 ];
}
int check_reference_point( object where ) {
    string *relatives;
    relatives = map( where->query_direc(),
        (: $(where)->query_relative( $1 ) :) );
    return member_array( 0, relatives ) > -1;
}
mixed *query_patterns() {
    return ({ "", (: cmd( 0 ) :),
        "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: living/flip.c
==================================================

#include <money.h>
#define EFFECTS "/obj/handlers/mag_eff_handler"
inherit "/cmds/base";
mixed cmd( object *things ) {
   int *effect;
   object place;
   mixed *stuff, *details;
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only flip one thing at once.\n");
      return 0;
   }
   stuff = (mixed *)things[ 0 ]->query_money_array();
   if ( !sizeof( stuff ) ) {
      add_failed_mess( "You must have a coin to flip.\n" );
      return 0;
   }
   if ( ( sizeof( stuff ) > 2 ) || ( stuff[ 1 ] != 1 ) ) {
      add_failed_mess( "You can only flip one coin at a time.\n" );
      return 0;
   }
   details = (mixed *)MONEY_HAND->query_details_for( stuff[ 0 ] );
   if ( details[ MONEY_DETAILS_COMPOSITION ] == "paper" ) {
       add_failed_mess( "You cannot flip $I as you would a coin, because "
        "it is made of paper.\n", things );
       return -1;
   }
   write( "You flip "+ (string)things[ 0 ]->the_short() +".\n" );
   say( (string)this_player()->one_short() +" flips "+
         (string)things[ 0 ]->a_short() +".\n" );
   effect = (int *)EFFECTS->choose_effect(
         (int)EFFECTS->ambient_enchantment( things[ 0 ] ) );
   place = environment( this_player() );
   if ( random( 1000 ) < effect[ 0 ] ) {
      switch( effect[ 1 ] ) {
         case 0 :
            things[ 0 ]->move( place );
            tell_room( place, (string)things[ 0 ]->the_short() +
                  " lands on its edge.\n" );
            break;
         default :
            things[ 0 ]->move( "/room/rubbish" );
      }
      EFFECTS->do_effect( effect[ 1 ], (string)things[ 0 ]->the_short(),
            place );
      return 1;
   }
   things[ 0 ]->move( place );
   tell_room( place, (string)things[ 0 ]->the_short() +" falls "+
         (string)place->query_property( "here" ) +", "+
         details[ random( 2 ) ] +" up.\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

==================================================
FILE: living/fo_llow.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   object *ok, ob;
   object *already;
   string s;
   mapping hide_invis;
   int hiding, sneaking;
   ok = ({ });
   already = ({ });
   foreach (ob in obs) {
      if (member_array(TP, ob->query_followers()) == -1) {
         if (ob->add_follower(TP)) {
            ok += ({ ob });
         }
      } else {
         already += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      if (sizeof(already)) {
         add_failed_mess("You are already following $I.\n", already);
      }
      obs -= already;
      if (sizeof(obs)) {
         if(member_array(TP, obs) == -1) {
            add_failed_mess("You cannot follow " + query_multiple_short(obs) +
                                          ".\n");
         } else {
            add_failed_mess("You can't follow " +
                          query_multiple_short(obs - ({TP}) + ({"yourself"})) +
                          ".\n");
         }
      }
      return 0;
   }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
    write("You follow " + ( s = query_multiple_short( ok ) ) + " unseen.\n" );
  else {
   write("You follow "+(s=query_multiple_short(ok))+".\n");
   say(TP->one_short(1)+" follows "+s+".\n", ok);
   foreach (ob in ok)
      tell_object(ob, TP->one_short(1)+
                      " follows "+query_multiple_short((ok + ({"you"})) -
                      ({ ob }))+".\n");
  }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/g_lance.c
==================================================

#include <obj_parser.h>
#include <dirs.h>
#include <player.h>
inherit "/cmds/base";
int check_exists(string file);
string room_glance(object person, object room, int dark);
mixed cmd_direction(string dir);
int check_pre_stuff() {
   int dark;
   object room;
   room = environment(previous_object());
   if (!room) {
      return notify_fail("You are in limbo... sorry you can't look at "+
             "anything.\n");
   }
   if (!previous_object()->query_property("dead")) {
      dark = (int)previous_object()->check_dark((int)room->query_light());
   }
   if( dark < 0 ) {
      write("It's too dark to look at anything.\n");
      return 1;
   } else if( dark > 0 ) {
      write("It's too bright to look at anything.\n");
      return 1;
   }
   return 2;
}
mixed cmd_ob(object* obs) {
   object thing;
   int retval;
   int dark;
   object room;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   foreach (thing in obs) {
      string tmp;
      if(thing == this_player()) {
        write("That's you that is.\n");
      } else {
        tmp = (string)thing->a_short( dark );
        if (tmp) {
          write(capitalize(tmp) + ".\n");
        }
      }
   }
   return 1;
}
mixed cmd_direction(string dir, int from_string) {
   object room;
   int dark;
   int retval;
   string ret;
   string dest;
   mixed *func;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   retval = 0;
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dir = EXPAND_EXIT(dir);
   if ( room->query_relative( dir ) ) {
      add_failed_mess( "You do not think that the "+ dir +" is here.\n" );
      return 0;
   }
   dir = (string)this_player()->find_abs(dir);
   if(room->query_exit(dir)) {
      room->set_destination( dir );
      if ( check_exists( (string)room->query_destination( dir ) ) ) {
         write("You glance " + dir + " and see:\n");
         ret = room->query_look(dir);
         if (ret) {
            write(ret+"\n");
            return 1;
         }
         func = room->query_look_func(dir);
         if(sizeof(func)) {
            call_other(func[0], func[1], 1);
            return 1;
         }
         dest = room->query_destination(dir);
         if(room->query_door_open(dir) != 0) {
            if (!dark && !previous_object()->query_property("dead") &&
                !previous_object()->query_creator()) {
               dark = previous_object()->check_dark(dest->query_light());
            }
            load_object(dest);
            this_player()->set_looked( find_object( dest ) );
            if (dark) {
               write("It's too dark to see that far.\n");
            } else  {
               write( (string)dest->a_short( dark ) +" "+
                     (string)dest->query_short_exit_string()+".\n"+
                     (string)dest->query_contents(""));
            }
            return 1;
         } else if(room->query_door_open(dir) == 0) {
            write("The "+dir+" door is closed.\n");
         }
      }
   }
   if (!retval) {
      add_failed_mess("You do not think that the "+dir+" is here.\n");
   }
   return retval;
}
string room_glance(object person, object room, int dark) {
   string ret;
   string sees;
   object mirror;
   ret = "";
   if (person->query_creator()) {
      ret += " %^CYAN%^" + file_name(room) + "%^RESET%^";
      sees=(string)room->query_property("creator sees");
      if (sees) {
         ret += sees +"\n"+ (string)room->query_contents();
      }
   }
   mirror = room->query_mirror_room();
   if (mirror) {
      room = mirror;
   }
   if(!dark || previous_object()->query_creator()) {
      if (mirror) {
         ret += ".\n" + (string)mirror->query_contents();
      } else {
         ret += (string)room->query_short_exit_string()+".\n"+
           (string)room->query_contents();
      }
   } else if((dark == 2) || (dark == -2)) {
      if (!mirror) {
         ret += (string)room->query_short_exit_string()+"\n";
      } else {
         ret += "\n";
      }
      if((string)room->query_contents("") != "") {
         ret += person->colour_event("inventory", "%^GREEN%^") +
           "Some objects you can't make out are here.%^RESET%^\n";
      }
   } else {
      ret += "\n";
   }
   if (dark == 1 || dark == -1) {
      ret += "You can't see your hand in front of your face.\n";
   } else  {
      ret = "$a_short:"+ file_name(room) + "$"+ ret;
   }
   if (mirror) {
      ret += "Around " + room->the_short() + " is:\n";
      ret += room_glance(person, mirror, dark);
   }
   return ret;
}
int cmd_here() {
   object room;
   int dark;
   int retval;
   string str;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dark = previous_object()->check_dark((int)room->query_light());
   str = room_glance(previous_object(), room, dark);
   write(str);
   return 1;
}
int check_exists(string file) {
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    return 1;
  }
  return 0;
}
mixed* query_patterns() {
   return ({
             "", (: cmd_here() :),
             "exit <string'exit'>", (: cmd_direction($4[0], 1) :),
             "[at] <indirect:object>", (: cmd_ob($1) :),
             "<string'exit'>", (: cmd_direction($4[0], 0) :),
            });
}

==================================================
FILE: living/get.c
==================================================

#include <obj_parser.h>
#include <move_failures.h>
#include <player.h>
#define DROP_H 40
#define PINCH_H 120
#define MAX_GET_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
object* find_matching_obs(string match_str, object dob) {
   class obj_match result;
   result = (class obj_match)match_objects_in_environments(match_str, dob);
   if (result->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(result));
      return 0;
   }
   return result->objects;
}
mixed cmd(object * obs, string dir, string indir, mixed *args) {
   object *dest;
   object ob;
   object dob;
   object *fail_dest;
   object *too_many;
   mixed *fail;
   mixed *ret;
   mixed amt;
   string sh;
   string hand_unit;
   string match_str;
   int i;
   int num;
   int cap;
   int perc;
   int handful;
   int total_num;
   mixed we;
   object env;
   object *bing;
   fail_dest = ({ });
   cap = (int) TP->query_max_weight();
   if (indir && sizeof(obs) > 10) {
      add_failed_mess("Please be more specific as to what you want "
                      "to get from.\n");
      return 0;
   }
   if (indir) {
      match_str = args[0];
      dest = obs;
   } else {
      if (environment(TP)->query_mirror_room()) {
         dest = ({ environment(TP), environment(TP)->query_mirror_room() });
      } else {
         dest = ({ environment(TP) });
      }
   }
   too_many = ({ });
   foreach(dob in dest) {
     if (!is_in_me_or_environment(dob, this_player())) {
         fail_dest += ({ dob });
         continue;
      }
      if (dob->cannot_get_stuff() || dob->query_closed()) {
         fail_dest += ({ dob });
         continue;
      }
      if (living(dob) && !dob->allowed_to_loot(this_player())) {
        fail_dest += ({ dob });
        continue;
      } else if (indir) {
         obs = find_matching_obs(match_str, dob);
      }
      if (!obs) {
         continue;
      }
      if (total_num + sizeof(obs) > MAX_GET_NUMBER) {
         if (total_num > MAX_GET_NUMBER) {
            too_many += obs;
            obs = ({ });
         } else {
            too_many += obs[MAX_GET_NUMBER - total_num..];
            obs = obs[0..MAX_GET_NUMBER - total_num - 1];
         }
      }
      total_num += sizeof(obs);
      ret = ({ ([ ]), ([ ]), ([ ]), ([ ]), ([ ]), });
      fail = ({ });
      foreach(ob in obs) {
        env = environment(ob);
        if(env != dob) {
          if(ob->query_collective())
            ob->move(dob);
          else
            dob = env;
        }
        if ((living(dob) && !dob->allowed_to_loot(this_player(), ob)) ||
            (ob->query_liquid() && ob->query_food_object())) {
          fail += ({ ob });
          num++;
          continue;
        }
         if (ob->query_continuous()) {
            amt = ob->query_amount_types();
            if (amt["handful"]) {
               hand_unit = "handful";
               handful = amt["handful"][0];
            } else if ((amt["drop"]) && (ob->query_liquid())) {
               hand_unit = "drops";
               handful = amt["drop"][0] * DROP_H;
            } else if (amt["pinch"]) {
               hand_unit = "pinches";
               handful = amt["pinch"][0] * PINCH_H;
            } else {
               handful = ob->query_amount();
            }
            if (ob->query_amount() > handful) {
               if (!match_str) {
                  match_str = ob->query_name();
               }
               if (i = strsrch(match_str, "of") >= 0) {
                  i += 3;
               }
               if (hand_unit == "handful") {
                  handful = 1;
               }
               match_str = handful + " " + hand_unit + " of " +
                  match_str[i..];
               fail += ({ "all of the " + ob->short() });
               ob = ob->query_parse_id(({ handful, match_str }));
               if (!ob) {
                  continue;
               }
               num++;
            }
         }
         if (function_exists("do_get", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_get", ob)) {
               we = (int) call_other(ob, "do_get", dob, 0, match_str,
                                     ({ 0, match_str }),
                                     "<direct:object> from <indirect:object>");
            } else {
               we = ob->command_control("get", dob, 0, match_str,
                                        ({ 0, match_str }),
                                        "<direct:object> from <indirect:object>");
            }
            if (!objectp(we)) {
               if (we) {
                  we = (int) ob->query_weight();
                  perc = (we * 100) / cap;
                  if (perc >= 95) {
                     i = 4;
                  } else {
                     i = perc / 25;
                  }
                  if (!ret[i][env]) {
                     ret[i][env] = ({ ob });
                  } else {
                     ret[i][env] += ({ ob });
                  }
               } else {
                  if (member_array(ob, this_player()->query_succ_mess_indir())
                      == -1 && !query_notify_fail() && !living(ob)) {
                     fail += ({ ob });
                  }
                  num++;
               }
               continue;
            } else {
               ob = we;
            }
         }
#ifndef __DISTRIBUTION_LIB__
         if(interactive(TP) &&
            PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("get", TP, ob)) {
           fail += ({ ob });
           num++;
         } else
#endif
         if ((int) ob->move(TP) == MOVE_OK) {
            we = (int) ob->query_weight();
            perc = (we * 100) / cap;
            if (perc >= 95) {
               i = 4;
            } else {
               i = perc / 25;
            }
            if (!ret[i][env]) {
               ret[i][env] = ({ ob });
            } else {
               ret[i][env] += ({ ob });
            }
         } else {
            fail += ({ ob });
            num++;
         }
      }
      for (i = 0; i < sizeof(ret); i++) {
         if (sizeof(ret[i])) {
            foreach(env, bing in ret[i]) {
               if (this_player()->query_succ_mess_dir()) {
                  bing -= this_player()->query_succ_mess_dir();
               }
               if (sizeof(bing)) {
                  sh = query_multiple_short(bing);
                  write("You " + ({ "get", "get with a bit of difficulty",
                                    "struggle somewhat to get",
                                    "find it very difficult to get",
                                    "use all your strength and just barely manage to get" })
                        [i] + " " + sh + " from " + inside_the_short(dob) +
                        ".\n");
                  say(capitalize((string) TP->one_short()) + " " +
                      ({ "gets", "gets with a bit of difficulty",
                         "struggles somewhat to get",
                         "finds it very difficult to get",
                         "uses all " + TP->query_possessive() +
                         " strength and just barely manages to get" })[i] +
                      " " + sh + " from " + inside_a_short(dob) + ".\n");
               }
            }
         }
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot get $I.\n", fail);
      }
   }
   if (num == total_num) {
      if (query_notify_fail()) {
         return 0;
      }
      if (indir) {
         if (sizeof(fail_dest)) {
            add_failed_mess("You cannot get anything from $I.\n", fail_dest);
         }
      } else {
         add_failed_mess("You cannot get $I.\n", obs);
      }
      return -1;
   } else {
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You cannot pick up more than " +
                               query_num(MAX_GET_NUMBER) +
                               " objects at a time; " "discarding $I.\n",
                               "" }), too_many);
      }
   }
   return 1;
}
mixed *
query_patterns()
{
   return ({ "<indirect:object:here>", (: cmd($1, 0, 0, 0) :),
             "<string> from <indirect:object>", (: cmd($1, $2, $3, $4) :) });
}

==================================================
FILE: living/give.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "cmds/base";
#define TP this_player()
#define SUPPRESS_MESS "suppress give messages"
mixed cmd(mixed *indir, string *indir_match) {
  string sh;
  string s1;
  string failmess;
  int tot;
  int max;
  int ok;
  object *per;
  object *ret;
  object *fail;
  object pobj;
  object ob;
  object *obs;
  object *succ;
  object *keep;
  per = indir[1];
  succ = ({ });
  keep = ({ });
  failmess = "";
  foreach(pobj in per) {
    obs = indir[0];
    obs -= per;
    if (pobj->query_property("player") && !interactive(pobj)) {
      failmess = pobj->the_short()+" seems too chalky to accept your "
        "gift.\n";
      continue;
    }
    if (pobj == TP) {
     failmess = "You nag yourself for a while, but can't convince "
                 "yourself to accept things from yourself.\n";
     continue;
    }
    if (!sizeof(obs)) {
      failmess = "Nothing to give to "+ pobj->short() +".\n";
      continue;
    }
    ret = ({ });
    fail = ({ });
    foreach(ob in obs) {
      if ( member_array( ob, succ ) > -1 ) {
        continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      if (function_exists("do_give", ob) ||
          function_exists("command_control", ob)) {
        if (function_exists("do_give", ob)) {
          max = call_other(ob, "do_give", pobj, indir_match[0],
                                indir_match[1],
                                ({ indir_match[0], indir_match[1] }),
                                "<direct:object:me> to <indirect:living>");
        } else {
          max = ob->command_control("give", pobj, indir_match[0],
                                    indir_match[1],
                                    ({ indir_match[0], indir_match[1] }),
                                    "<direct:object:me> to <indirect:living>");
        }
        if (max == 0)  {
          fail += ({ ob });
          continue;
        }
      }
#ifndef __DISTRIBUTION_LIB__
      PLAYER_MULTIPLAYER_HANDLER->record_object("give", TP, ob);
      if(pobj->query_property("player") && interactive(TP) &&
         "/obj/handlers/multiplayer"->check_multiplayers("give", pobj, ob)) {
        fail += ({ ob });
      } else
#endif
      if (pobj->query_closed()  ||  ob->move(pobj) != MOVE_OK) {
        fail += ({ ob });
      } else  {
        ret += ({ ob });
        tot += ob->query_weight();
      }
    }
    if (sizeof(ret)) {
      ok = 1;
      succ += ret;
      if (pobj->query_clothing()) {
        s1 = pobj->query_pocket_mess();
      } else {
        s1 = "$ob_short$";
      }
      sh = query_multiple_short(ret);
      if ( interactive( pobj ) || !pobj->query_property( SUPPRESS_MESS ) ) {
        tell_object(TP, "You give "+ sh +" to "+
                  replace_string(s1, "$ob_short$", pobj->one_short())+
                  ".\n");
        tell_room(environment(TP), TP->one_short() + " gives " + sh +
               " to " + replace_string(s1, "$ob_short$",
                                      pobj->one_short()) +
               ".\n", ({ TP, pobj }));
        tell_object(pobj, capitalize(TP->one_short() ) + " gives "+
                    sh + " to you.\n" );
      }
      if (living(pobj) && (max = pobj->query_max_weight()))
        if ((max = tot*100/max) > 25)
          if (max >= 95) {
            tell_room(environment(TP),
                      pobj->the_short()+" staggers under a weight "+
                      pobj->query_pronoun()+" can only just carry.\n",
                      ({ pobj }) );
            pobj->event_say(TP, "You stagger under a weight you can only "
                            "just carry.\n");
          } else {
            tell_room(environment(TP), pobj->the_short()+ ({
              " is only mildly discomforted by the additional weight.\n",
              " braces "+pobj->query_objective()+"self to take the load.\n",
              " stumbles as "+pobj->query_pronoun()+" takes the load.\n"
              })[(max/25)-1], ({ pobj }) );
            pobj->event_say(TP, "You"+ ({
              " are only mildly discomforted by the additional weight.\n",
              " brace yourself under the load.\n",
              " stumble as you take the load.\n"
              })[(max/25)-1]);
          }
    }
    if (sizeof(fail)) {
      failmess += "You cannot give "+query_multiple_short(fail)+ " to "+
                  pobj->one_short() +".\n";
    }
  }
  if (!ok) {
    add_failed_mess(failmess);
    if (sizeof(keep)) {
       add_failed_mess("You have $I set to be kept.\n", keep);
    }
  }
  return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me> to <indirect:living>",
            (: cmd($1, $3) :) });
}

==================================================
FILE: living/ho_ld.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object * obs,
        string str)
{
   int num_limbs;
   int avail;
   int old_avail;
   int reqd;
   int i;
   int pos;
   int success;
   int *used;
   int *already_used;
   int *limbs_used;
   object ob;
   object weapon;
   object *using;
   object *fails;
   object *unfails;
   object *holds;
   object *unholds;
   object *already;
   object *no_change;
   string *limbs;
   string *hhands;
   string *uhands;
   limbs = TP->query_limbs();
   num_limbs = sizeof(limbs);
   avail = TP->query_free_limbs();
   no_change = ({ });
   already = filter(obs, (: $1->query_holder() :));
   if (sizeof(already) > 0) {
      using = this_player()->query_holding();
      foreach (ob in already)  {
         limbs_used = find_member(ob, using);
         if (str)  {
            if (sizeof(limbs_used) == 1  &&
                member_array(str, limbs) == limbs_used[0])
            {
               no_change += ({ ob });
            }
            else already -= ({ ob });
         }
         else if (sizeof(limbs_used) != ob->query_no_limbs())
            already -= ({ ob });
      }
      if (sizeof(obs) == sizeof(no_change))  {
         add_failed_mess("You are already holding " +
                         query_multiple_short(obs) +
                         " in your " + str + ".\n");
         return -1;
      }
      else if (sizeof(obs) == sizeof(already)) {
         return notify_fail("You are already holding " +
                            query_multiple_short(obs) + ".\n");
      } else {
         obs -= already;
         if (sizeof(already) > 0)
            write(sprintf("You are already holding %s, you instead try to "
                          "hold %s.\n", query_multiple_short(already),
                          query_multiple_short(obs)));
         already_used = map(already, (: $1->query_my_limb() :));
      }
   } else {
      already_used = ({ });
   }
   fails = holds = unholds = hhands = uhands = unfails = ({ });
   if (str && obs[0]) {
      pos = member_array(str, limbs);
      if (pos == -1) {
         if (!sizeof(limbs)) {
            return
               notify_fail("You seem to have a singular lack of limbs.\n");
         }
         return notify_fail("Incorrect limb type, must be one of " +
                            query_multiple_short(limbs) + ".\n");
      }
      using = TP->query_holding();
      if (sizeof(unfails) == 0  &&  using[pos]) {
         used = TP->set_unhold(using[pos]);
         if (sizeof(used) == 0) {
            unfails += ({ using[pos] });
            uhands += ({ limbs[pos] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ using[pos] });
         }
      }
      if ((i = member_array(obs[0], using - unholds)) != -1)  {
         used = TP->set_unhold(obs[0]);
         if (sizeof(used) == 0) {
            unfails += ({ obs[0] });
            uhands += ({ limbs[i] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ obs[0] });
         }
      }
      if (sizeof(unfails) == 0) {
         used = TP->set_hold(obs[0], pos, 1);
         if (sizeof(used) == 0) {
            fails += ({ obs[0] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               hhands += ({ limbs[used[i]] });
            }
            holds += ({ obs[0] });
            success = 1;
         }
      }
   } else {
      foreach(ob in obs) {
         reqd += ob->query_no_limbs();
      }
      if (reqd > num_limbs) {
         add_failed_mess("You do not have enough limbs to hold $I.\n", obs);
         return 0;
      }
      old_avail = -1;
      while ((avail < reqd) && (avail < num_limbs)) {
         if ((reqd > num_limbs - sizeof(unfails)) || (old_avail == avail)) {
            if (sizeof(unfails)) {
               add_failed_mess
                  ("You do not have enough limbs to hold $I, since " +
                   query_multiple_short(unfails) + " failed " "to unhold.\n",
                   obs);
            } else {
               add_failed_mess
                  ("Not able to free up enough limbs to hold $I.\n", obs);
            }
            return 0;
         }
         old_avail = avail;
         using = TP->query_holding();
         for (i = 0; i < sizeof(using); i++) {
            weapon = using[i];
            if (weapon && member_array(i, already_used) == -1) {
               used = TP->set_unhold(weapon);
               if (sizeof(used)) {
                  for (i = 0; i < sizeof(used) && used[i] < sizeof(limbs);
                       i++) {
                     uhands += ({ limbs[used[i]] });
                  }
                  unholds += ({ weapon });
                  avail = TP->query_free_limbs();
                  break;
               } else {
                  if (member_array(weapon, unfails) == -1) {
                     unfails += ({ weapon });
                  }
                  uhands += ({ limbs[i] });
               }
            }
         }
      }
      if (!sizeof(unfails)) {
         foreach(ob in obs) {
            using = TP->query_holding();
            pos = 0;
            if (!ob->query_no_limbs() || avail < ob->query_no_limbs()) {
               fails += ({ ob });
               break;
            }
            while ((using[pos]) && (pos < num_limbs)) {
               pos++;
            }
            used = TP->set_hold(ob, pos, ob->query_no_limbs());
            if (used == ({ })) {
               fails += ({ ob });
            } else {
               for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
                  hhands += ({ limbs[used[i]] });
               }
               holds += ({ ob });
               success = 1;
               avail = TP->query_free_limbs();
            }
         }
      }
   }
   if (sizeof(unfails)) {
      tell_object(TP,
                  "You fail to put down " + query_multiple_short(unfails) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " fails to put down " +
          query_multiple_short(unholds) + " from " + TP->query_possessive() +
          " " + query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(unholds)) {
      tell_object(TP, "You put down " + query_multiple_short(unholds) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " puts down " + query_multiple_short(unholds) +
          " from " + TP->query_possessive() + " " +
          query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(holds)) {
      tell_object(TP,
                  "You hold " + query_multiple_short(holds) + " in your " +
                  query_multiple_short(hhands) + ".\n");
      say(TP->one_short() + " holds " + query_multiple_short(holds) + " in " +
          TP->query_possessive() + " " + query_multiple_short(hhands) +
          ".\n");
   }
   if (!success && sizeof(fails)) {
      tell_object(TP,
                  "You fail to hold " + query_multiple_short(fails) + ".\n");
      say(TP->one_short() + " fails to hold " + query_multiple_short(fails) +
          ".\n");
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me>", (: cmd($1, 0) :),
             "<indirect:object:me> in [my] {" +
             implode(this_player()->query_limbs(), "|") + "}",
             (: cmd($1, implode($4[1..], " ")) :) });
}

==================================================
FILE: living/kill.c
==================================================

#include <player.h>
inherit "/cmds/base";
int cmd( object* things ) {
   object thing;
   object *fighting;
   if ( !environment( this_player() ) ) {
      add_failed_mess( "You are in limbo...\n" );
      return 0;
   }
   if ( this_player()->no_offense() ) {
      add_failed_mess( "You cannot attack anyone at the moment.\n" );
      return 0;
   }
   things -= ({ this_player() });
   if ( !sizeof( things ) ) {
      add_failed_mess( "You shouldn't beat yourself up so much.\n");
      return 0;
   }
   foreach ( thing in things ) {
      if ( !userp( thing ) ) {
         if ( userp( this_player() ) ||
               !thing->query_property( "no attack" ) ) {
            this_player()->attack_ob( thing );
            thing->attack_by(this_player());
         }
         continue;
      }
      if ( !interactive( thing ) ) {
         write( (string)thing->the_short() +" is net-dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "guest" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +" is a guest.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "dead" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +
                " is already dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_auto_loading() ) {
         write( "Be sporting; "+ (string)thing->the_short() +
               " doesn't have "+ (string)thing->query_possessive() +
               " equipment yet.\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
           !this_player()->query_player_killer() ) {
         write( "You cannot summon the courage to attack "+
               (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
            !thing->query_player_killer() ) {
         write( "Something tells you that it would be wrong "
               "to attack "+ (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      call_out( (: this_player()->attack_ob( $(thing) ) :), 0);
      call_out( (: $(thing)->attack_by(this_player()) :), 0);
   }
    if ( sizeof( things ) ) {
      fighting = ({ });
      foreach(thing in things) {
        object *list;
        list = thing->query_attacker_list();
        if (arrayp(list)) {
           fighting += list;
        }
      }
      if(sizeof(fighting))
        fighting = filter(uniq_array(fighting),
                          (: $1 && environment($1) != environment(this_player()) :));
      if(!sizeof(fighting))
        this_player()->add_succeeded_mess(this_object(),
                                          ({ "You prepare to attack " + query_multiple_short(things) + ".\n", "" }), ({ }) );
      else
        this_player()->add_succeeded_mess(this_object(),
					  ({ "You prepare to attack " + query_multiple_short(things) + " who " + (sizeof(things) > 1 ? "are" : "is") + " already hunting " + query_multiple_short(fighting) + ".\n", "" }), ({ }) );
        return 1;
    } else {
        add_failed_mess("");
        return 0;
    }
}
mixed *query_patterns() {
   return ({ "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: living/kneel.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("kneel", "down", KNEELING);
}

==================================================
FILE: living/l_ook.c
==================================================

#include <player.h>
#include <weather.h>
#include <dirs.h>
#include <error_handler.h>
#include <db.h>
#include <terrain_map.h>
inherit "/cmds/base";
#define TP this_player()
string weather_long(string str);
int check_exists(string file);
string look_around();
mixed cmd_string(string arg);
void finish_bug_summary(object player, int type, mixed data) {
   class error_complete summ;
   class error_complete* errors;
   string str;
   int pos;
   if (type != DB_SUCCESS) {
      return ;
   }
   errors = data;
   if (!sizeof(errors)) {
      tell_object(player, "No errors for this room.\n");
      return ;
   }
   str = "";
   str = sprintf("#<bug id>  ( <date> ) %5-s %4-s %-4s by %11-s %11-s\n",
                 "Status", "Type", "Cat", "Reporter", "Assigned");
   foreach (summ in errors) {
      pos = strsrch(summ->details->report, "\n");
      if (pos < 0 || pos > player->query_cols() - 5) {
         pos = player->query_cols() - 5;
      } else {
         pos --;
      }
      str += sprintf("$I$3=#%d (%s) %5-s %4-s %-4s by %11-s %11-s\n%s\n",
                     summ->details->summary->id,
                     ctime(summ->details->summary->entry_date)[4..15],
                     summ->details->summary->status[0..4],
                     summ->details->summary->type,
                     summ->details->summary->category[0..3],
                     summ->details->summary->reporter,
                     summ->details->summary->assigned_to,
                     summ->details->report[0..pos]);
   }
   tell_object(player, str);
}
void show_error_summary(object player, string* types) {
   class error_query query;
   if (!arrayp(types) || !sizeof(types)) {
      return ;
   }
   query = new(class error_query);
   query->file_name = file_name(environment(player));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   query->type = types;
   query->no_extra_details = 1;
   ERROR_HANDLER->do_query_multiple_bug_details(query, (: finish_bug_summary, player :));
}
int cmd_look_room()
{
   object room;
   int dark;
   string ret;
   int *coords;
   room = environment(TP);
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (TP->query_creator()) {
      coords = room->query_co_ord();
      if (sizeof(coords)) {
         ret = "  (" + coords[0] + "," + coords[1] + "," + coords[2] + ")";
      } else {
         ret = "  (unset)";
      }
      if (virtualp(room)) {
         write("%^CYAN%^" + file_name(room) + " [" +
                room->query_property("base path")  + "]" + ret + "%^RESET%^\n");
      } else {
         write("%^CYAN%^" + file_name(room) + ret + "%^RESET%^\n");
      }
   }
   if ((TP->query_creator() || TP->query_playtester()) &&
       TP->query_property(TERRAIN_MAP_IN_LOOK_PROP)) {
      ret = room->long_test(0, dark);
      if (ret) {
         write("$P$Look$P$" + ret);
      } else {
         write("$P$Look$P$" + (string) room->long(0, dark));
      }
   } else {
      write("$P$Look$P$" + (string) room->long(0, dark));
   }
   if (dark && TP->query_creator()) {
      write("%^YELLOW%^As a creator, you can see:%^RESET%^\n" +
            (string) room->long(0, 0));
   }
   if (TP->query_creator() && TP->query_property(PLAYER_SHOW_ERRORS_PROP)) {
      show_error_summary(this_player(), TP->query_property(PLAYER_SHOW_ERRORS_PROP));
   }
   return 1;
}
string query_look_thing(object thing,
                        object player,
                        int dark,
                        string verb,
                        string arg)
{
   string ret;
   object env;
   string other;
   string replaced;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   ret = "";
   if (living(thing)) {
      if (thing == player) {
         ret += "Looking at yourself again?  What a narcissist!\n";
      } else {
         tell_object(thing, "$one_short:" + file_name(player) +
                     "$ $V$0=looks,look$V$ at you.\n");
      }
   } else {
      env = environment(thing);
      while (env && !living(env)) {
         env = environment(env);
      }
   }
   if (env && env != player) {
      tell_object(env, player->the_short() + " " + verb + " "
                  "at your " + thing->pretty_short() + ".\n");
      other = thing->query_long(arg, dark);
      if (other) {
         replaced = thing->replace_long_dollars(player, other);
         if (replaced) {
            ret += replaced;
         }
         else {
            ret += other;
         }
      }
      other = thing->query_long_details(arg, dark, player);
      if (other) {
         ret += other;
      }
   } else {
      ret += thing->long(arg, dark);
   }
   return ret;
}
mixed cmd_object(object * obs,
                 string arg)
{
   object thing;
   object room;
   int dark;
   int retval;
   string ret;
   room = environment(TP);
   if (LENGTHEN[arg]) {
     arg = LENGTHEN[arg];
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   ret = "";
   foreach(thing in obs) {
      ret += query_look_thing(thing, this_player(), dark, "looks", arg);
   }
   if (ret != "") {
      write("$P$Look$P$" + ret);
      retval = 1;
   }
   if (room->query_exit(arg))
      cmd_string(arg);
   else {
      arg = (string) this_player()->find_abs(arg);
      if (room->query_exit(arg))
         cmd_string(arg);
   }
   return 1;
}
mixed cmd_string(string arg)
{
   object room;
   int dark;
   int retval;
   string ret;
   string other;
   string orig_arg;
   mixed *func;
   room = environment(TP);
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   switch (arg) {
   case "soul":
      write((string) "/obj/handlers/new_soul"->help_list());
      return 1;
   case "sun":
   case "moon":
   case "stars":
   case "weather":
   case "sky":
      write(weather_long(arg));
      return 1;
   case "around":
      write(look_around());
      return 1;
   }
   orig_arg = arg;
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (!room->query_exit(arg)) {
      arg = (string) this_player()->find_abs(arg);
   }
   if (room->query_exit(arg)) {
      int tmp_ret_val;
      room->set_destination(arg);
      other = (string) room->query_destination(arg);
      ret = room->query_look(arg);
      if (ret && ret != "") {
         write(ret + "\n");
         retval = 1;
         tmp_ret_val = 1;
      }
      func = room->query_look_func(arg);
      if (pointerp(func) && sizeof(func) >= 1 && func[0] && func[1]) {
         if (call_other(func[0], func[1], 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      } else if (functionp(func)) {
         if (evaluate(func, 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      }
      if (check_exists(other) && !tmp_ret_val) {
         object door;
         door = room->query_door_control(arg);
         if (room->query_door_open(arg) || door->query_transparent()) {
            other->force_load();
            dark = (int) TP->check_dark((int) other->query_light());
            ret = other->long(0, dark);
            this_player()->set_looked(find_object(other));
            write(ret);
            retval = 1;
         } else {
            add_failed_mess(door->the_short() +
                            " is closed and not transparent.\n");
            retval = 0;
         }
      }
   }
   return retval;
}
int check_exists(string file)
{
   int retval;
   if (objectp(find_object(file))) {
      return 1;
   }
   if (strsrch(file, ":")) {
      return 1;
   }
   if (file_size(file + ".c") > 0) {
      retval = 1;
   } else {
      retval = 0;
   }
   return retval;
}
string weather_long(string str)
{
   object env;
   string temp;
   string whandler;
   env = environment(TP);
   temp = (string) env->query_property("location");
   switch (temp) {
   case ("inside"):
      return "You are not outside.\n";
   }
   whandler = env->query_weather_handler() ;
   if ( ! whandler ) {
       whandler = WEATHER ;
   }
   if (str == "sun") {
      if (whandler->query_day(env)) {
         return "Ouch that hurts.\n";
      } else {
         return "The sun is not up, sorry.\n";
      }
   }
   if (str == "moon") {
      if (whandler->query_day(env)) {
         return "The moon is not up, try at night.\n";
      } else if ( (temp = whandler->query_moon_string(env)) ) {
         return temp;
      } else {
         return "The moon is not up at the moment, try again later.\n";
      }
   }
   if (str == "stars") {
       if (whandler->query_day(env)) {
           return "The stars are not out at the moment - try at night.\n" ;
       } else {
           if ( (temp = whandler->query_star_string(env)) ) {
               return temp ;
           } else {
               return "There aren't any visible stars right now.\n" ;
           }
       }
   }
   return "You look up at the sky.  " + whandler->weather_string(env) + ".\n";
}
string look_around()
{
   int i;
   int j;
   string prep;
   string room;
   string *parts;
   string *rooms;
   object place;
   object thing;
   object *contents;
   mixed *locations;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   place = environment(this_player());
   if (place->query_linked()) {
      rooms = (string *) place->query_rooms();
   } else {
      rooms = ({ });
   }
   locations = ({ });
   say((string) this_player()->one_short() + " $V$0=looks,look$V$ around.\n");
   foreach(room in rooms) {
      if (!find_object(room)) {
         continue;
      }
      if (this_player()->check_dark((int) room->query_light())) {
         continue;
      }
      contents = ({ });
      foreach(thing in all_inventory(find_object(room))) {
         if (living(thing) && thing->query_visible(this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         continue;
      }
      prep = (string) room->query_static_preposition();
      if (prep != "") {
         if (!stringp(prep)) {
            prep = sprintf("%O", prep);
         }
         prep += " ";
      }
      locations += ({ ({ contents, prep +
                         (string) this_player()->
                         convert_message((string) room->the_short())
                      }) });
   }
   if (!sizeof(locations)) {
      contents = ({ });
      if (this_player()->check_dark((int) place->query_light())) {
         return "You can't see well enough to look around here.\n";
      }
      foreach(thing in all_inventory(place)) {
         if (living(thing) && thing->query_visible(this_player()) &&
             (thing != this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         return "You do not see anyone else about.\n";
      }
      return "$C$" + query_multiple_short(contents) +
         " $V$0=is,are$V$ here.\n";
   }
   for (i = 0; i < sizeof(locations) - 1; i++) {
      for (j = i + 1; j < sizeof(locations); j++) {
         if (locations[i][1] == locations[j][1]) {
            locations[i][0] += locations[j][0];
            locations = delete(locations, j, 1);
            j--;
         }
      }
   }
   parts = ({ });
   for (i = 0; i < sizeof(locations); i++) {
      parts += ({ query_multiple_short(locations[i][0]) + " " +
                  locations[i][1] });
   }
   if (sizeof(parts) == 1) {
      return "You can see " + parts[0] + ".\n";
   }
   return "You can see " + query_multiple_short(parts) + ".\n";
}
mixed *query_patterns()
{
   return ({ "", (: cmd_look_room() :),
             "<string'direction'>", (: cmd_string($4[0]) :),
             "<indirect:object>", (: cmd_object($1, $4[0]) :),
             "at <indirect:object>", (: cmd_object($1, $4[0]) :),
             "in <indirect:object>", (: cmd_object($1, $4[0]) :),
             "inside <indirect:object>", (: cmd_object($1, $4[0]) :),
             "around", (: cmd_string("around") :) });
}
