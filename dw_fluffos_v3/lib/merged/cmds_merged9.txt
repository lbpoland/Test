# Total Tokens: 12778
# Total Files Merged: 12
# Total Characters: 42630

ving/teach.c
==================================================

#include <skills.h>
#include <tune.h>
#include <command.h>
#include <cmds/teach.h>
#include <playtesters.h>
#include <player.h>
inherit "/cmds/base";
#define DEBUGGER "ceres"
#undef ENFORCE_MAX_TEACH_LEVEL
int command_teach( object *obs, string comm, object teacher );
int spell_teach(object *obs, string spell, object teacher);
int teach_skill(object *obs, string str, object teacher);
int cmd_int(string str, object *obs, object teacher);
int check_ignoring(object ignorer, object ignoree);
int query_auto_teaching(object teacher, object learner) {
   return teacher->query_property(TEACH_COMMAND_AUTO_PROPERTY);
}
int cmd(string str, object *obs, object player) {
  int ret;
  object ob;
  object* ear;
  if (this_player()->query_property(PASSED_OUT_PROP)) {
     add_failed_mess("You cannot teach while passed out.\n");
     return 0;
  }
  if (this_player()->query_fighting()) {
    add_failed_mess("You cannot teach or learn anything while you are "
                    "fighting!\n");
    return 0;
  }
  if (this_player()->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  if (player) {
    ear = filter(obs, (: userp($1) && !interactive($1) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$C$$I does not have enough responsiveness to teach "
                      "you.\n", ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->check_earmuffs("teach") :));
    if (sizeof(ear)) {
      obs -= ear;
      if (sizeof(ear) == 1) {
        add_failed_mess("$I has " + ear[0]->query_possessive() + " earmuffs "
                        "on.\n", ear);
      } else {
        add_failed_mess("$I have their earmuffs on.\n", ear);
      }
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: check_ignoring($1, this_player()) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is ignoring you, or you are ignoring them.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->query_property(PASSED_OUT_PROP) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is passed out and looks rather worse for wear.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->query_fighting() :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is currently beating stuff up, please wait "
                      "for them to finish.\n", ear);
      if (!obs) {
        return 0;
      }
    }
    obs = filter(obs, (: !$1->query_creator() :) );
    if (!sizeof(obs)) {
      add_failed_mess("None of those people are allowed to teach you.\n");
      return 0;
    }
    obs = filter(obs, (: query_auto_teaching($1, this_player()) :));
    if (!sizeof(obs)) {
      add_failed_mess("None of those people have auto teaching turned "
                      "on.\n");
      return 0;
    }
    obs = filter(obs, (: $1->query_time_left() > 0 :));
    if (!sizeof(obs)) {
      add_failed_mess("All the people you are trying to learn from appear "
                      "to be busy.\n");
      return 0;
    }
    foreach (ob in obs) {
      ret |= cmd_int(str, ({ this_player() }), ob);
    }
    return ret;
  }
  return cmd_int(str, obs, this_player());
}
int cmd_int(string str, object *obs, object teacher) {
  if (teacher->query_property("dead")) {
    add_failed_mess("You wave your arms around, and your lips move but "
                       "they can't hear what you are saying.\n");
    return 0;
  }
  obs = filter(obs,  (: !$1->query_property("dead") :));
  if (!sizeof(obs)) {
    add_failed_mess("You must teach someone, preferably living.\n");
    return 0;
  }
  if (sizeof(obs) > 1) {
    add_failed_mess("You can only teach one person at a time.\n");
    return 0;
  }
  if (!command_teach(obs, str, teacher) &&
      !spell_teach(obs, str, teacher) &&
      !teach_skill(obs, str, teacher))
  {
    return 0;
  }
  return 1;
}
int check_ignoring(object ignorer, object ignoree) {
  return (ignorer->query_property("ignoring") &&
          member_array(ignoree->query_name(),
                       ignorer->query_property("ignoring")) != -1);
}
int command_teach(object *obs, string comm, object teacher) {
  string cmd_ob;
  object *succ;
  object *no_go;
  object *me_low;
  mixed *him_low;
  object *know_already;
  object *ear_muffed;
  object *ignored;
  object *ignoring;
  object ob;
  string *tmp_stuff;
  int i;
  class command cmd = new(class command, verb : comm);
  mixed tmp;
  if (member_array(comm, teacher->query_known_commands()) == -1 ||
      !CMD_D->HandleStars(cmd))
  {
    if (CMD_D->HandleStars(cmd)) {
      if (teacher == this_player()) {
        add_failed_mess("You do not know the command " + comm + ".\n");
      } else {
        add_failed_mess(teacher->the_short(1) +
                        " does not know the command " + comm + ".\n");
      }
    }
    return 0;
  }
  obs -= ({ teacher });
  if (!sizeof(obs)) {
    add_failed_mess("You cannot teach yourself a command.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    if (teacher == this_player()) {
      add_failed_mess("You have teaching earmuffed.\n");
    } else {
      add_failed_mess(teacher->the_short(1) + " has teaching earmuffed.\n");
    }
    return 0;
  }
  cmd_ob = CMD_D->GetPaths(cmd->verb)[0] + "/" + cmd->verb;
  succ = ({ });
  ear_muffed = ({ });
  know_already = ({ });
  no_go = ({ });
  me_low = ({ });
  him_low = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (!living(ob)) {
      continue;
    }
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (member_array(comm, ob->query_known_commands()) != -1) {
      know_already += ({ tmp });
    } else if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
    } else if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
    } else {
      switch (cmd_ob->can_teach_command(teacher, ob)) {
        case 1:
          succ += ({ ob });
          break;
        case 0 :
          no_go += ({ tmp });
          break;
        case -1 :
          me_low += ({ tmp });
          break;
        case -2 :
          him_low += ({ tmp });
          break;
      }
    }
  }
  if (!succ || !sizeof(succ)) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + comm + " from you automatically, "
                  "but failed.\n");
    }
    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() + " cannot teach " + comm +
                      " to $I.\n", no_go);
    }
    if (sizeof(me_low)) {
      if (teacher == this_player()) {
        add_failed_mess(teacher->the_short() +
                        " are too low a level to teach " + comm +
                        " to $I.\n", me_low);
      } else {
        add_failed_mess(teacher->the_short() +
                        " is too low a level to teach " + comm +
                        " to $I.\n", me_low);
      }
    }
    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("$I has teaching events earmuffed, you are unable "
                      "to teach them.\n", ear_muffed);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " +
                      ((sizeof(him_low) == 1  &&
                        him_low[0] != this_player()) ? "is" : "are") +
                      " too low a level to learn " + comm + ".\n", him_low);
    }
    if (sizeof(know_already)) {
      add_failed_mess("$I already know" +
                      (sizeof(know_already) > 1  ||
                       teacher != this_player()? "" : "s") +
                      " the command " + comm + ".\n", know_already);
    }
    if (sizeof(ignoring)) {
      if (this_player() == teacher) {
        add_failed_mess("You are ignoring $I.\n", ignoring);
      } else {
        add_failed_mess(teacher->the_short(1) + " is ignoring $I.\n",
                        ignoring);
      }
    }
    if (sizeof(ignored)) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    return 0;
  }
  write(teacher->the_short() + " offer" +
        (this_player() == teacher ? "" : "s") + " to teach " + comm +
        " to " + query_multiple_short(succ) + ".\n");
  if (teacher == this_player()) {
    if (sizeof(no_go)) {
      write("You cannot teach " + comm + " to " +
            query_multiple_short(no_go, "the", 0, 1 ) + ".\n");
    }
    if (sizeof(ear_muffed) > 0) {
      write(capitalize(query_multiple_short(ear_muffed, "the", 0, 1)) +
            " has teaching events earmuffed, you are unable "
            "to teach them.\n");
    }
    if (sizeof(me_low) > 0) {
      write("You are too low a level to teach " + comm + " to " +
            query_multiple_short(me_low, "the", 0, 1) + ".\n");
    }
    if (sizeof(him_low) > 0) {
      write(capitalize(query_multiple_short(him_low, "the", 0, 1)) +
            ((sizeof(him_low) == 1) ? " is" : " are") +" too low a "
            "level to learn " + comm + ".\n");
    }
  } else {
    tell_object(teacher,
                "You automatically offer to teach " + comm + " to " +
                query_multiple_short(succ) + ".\n");
  }
  say(capitalize((string)teacher->short()) + " teaches something to " +
      query_multiple_short(succ) + ".\n", succ + ({ teacher }));
  for (i = 0; i < sizeof(succ); i++) {
    tell_object(succ[i], capitalize(teacher->the_short()) +
                " offers to teach " +
                query_multiple_short(delete(succ, i, 1) +
                ({ "you" }) ) + " the command \"" + comm + "\".\n"
                "Type \"learn " + comm + " from " +
                teacher->query_name() + "\" to learn the command.\n");
    tmp_stuff = succ[i]->query_respond_command(TEACH_COMMAND_TYPE, teacher);
    if (!tmp_stuff) {
      tmp_stuff = ({ comm });
    } else if (member_array(comm, tmp_stuff) == -1) {
      tmp_stuff += ({ comm });
    }
    succ[i]->add_respond_command(TEACH_COMMAND_TYPE, teacher, tmp_stuff);
  }
  add_succeeded_mess("");
  return 1;
}
int spell_teach(object *obs, string spell, object teacher) {
  object *succ, *no_go, *me_low, *him_low, ob;
  object *ignoring;
  object *ignored;
  object *ear_muffed;
  string ret;
  string is_are;
  mapping spells;
  mixed tmp;
  spells = teacher->query_spells();
  if (!spells[spell]) {
    return 0;
  }
  if (teacher == this_player()) {
    is_are = "are";
  } else {
    is_are = "is";
  }
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  ear_muffed = succ = no_go = me_low = him_low = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (living(ob)) {
      if (ob->check_earmuffs("teach")) {
        ear_muffed += ({ ob });
        continue;
      } else if (check_ignoring(ob, teacher)) {
        ignored += ({ ob });
      } else {
        if (teacher == this_player()) {
          tmp = ob;
        } else {
          tmp = "you";
        }
        switch (spells[spell][0]->teach(ob, spell)) {
          case 1:
            succ += ({ ob });
            break;
          case 0:
            no_go += ({ ob });
            break;
          case -1:
            me_low += ({ ob });
            break;
          case -2:
            him_low += ({ ob });
            break;
        }
      }
    }
  }
  if (sizeof(succ) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + spell +
                  " from you automatically, but failed.\n");
    }
    ret = "";
    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() +
                      " cannot teach " + spell + " to $I.\n", no_go);
    }
    if (sizeof(me_low) > 0) {
      add_failed_mess(teacher->the_short() +
                      " " + is_are +
                      " too low a level to teach $I " + spell + ".\n",
                      me_low);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " + is_are + " too low a level to learn " +
                       spell + ".\n", him_low);
    }
    if (sizeof(ignoring)) {
       add_failed_mess("You are ignoring $I.\n", ignoring);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("$I has teaching earmuffed.\n", ignored);
    }
    return 0;
   }
   if (teacher == this_player()) {
     write(teacher->the_short() +
           " successfuly teach " + query_multiple_short(succ) + " " +
           spell + ".\n");
     if (sizeof(no_go) > 0) {
       write("You cannot teach " + spell + " to " +
             query_multiple_short(no_go, "the", 0, 1) + ".\n");
     }
     if (sizeof(me_low) > 0) {
       write("You are too low a level to teach " +
             query_multiple_short(me_low, "the", 0, 1) + " " + spell +
             ".\n");
     }
     if (sizeof(him_low) > 0) {
       write(capitalize(query_multiple_short(him_low, 0, 1)) +
             (sizeof(him_low) == 1 ? " is " : " are ") +
             "too low a level to learn " + spell + ".\n");
     }
     if (sizeof(ignoring) > 0) {
       add_failed_mess("You are ignoring " +
                       query_multiple_short(ignoring, "the", 0, 1) +
                       ".\n");
     }
     if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by " +
                       query_multiple_short(ignored, "the", 0, 1) + ".\n");
     }
   } else {
     write(teacher->the_short() +
           " successfuly teaches " + query_multiple_short(succ) + " " +
           spell + ".\n");
   }
   return 1;
}
#define CANNOT 0
#define TOO_LOW 1
#define ONLY_LEAF 2
#define TOO_HIGH 3
#define CANNOT_TEACH 4
int teach_skill(object *obs, string str, object teacher) {
  int num;
  int lvl;
  int my_lvl;
  int lvl_up;
  int j;
  int cost;
  int total;
  int total2;
  int sk;
  int depth;
  object *ok;
  object *too_little;
  mixed  *too_low;
  object *cannot_teach;
  object *only_leaf;
  object *ignored;
  object *ignoring;
  object *ear_muffed;
  object *too_high;
  object ob;
  string skill;
  string skill_start;
  mixed *bits;
  class teaching_skill frog;
  float k;
  mixed tmp;
  num = 1;
  if (sscanf(str, "%d levels of %s", num, skill) != 2) {
    if (sscanf(str, "%d level of %s", num, skill) != 2) {
      if (sscanf(str, "%d %s", num, skill) != 2) {
        num = 1;
        skill = str;
      }
    }
  }
  if (num < 1) {
    add_failed_mess("You cannot teach a negative or zero number of "
                    "levels.\n");
    return 0;
  }
  if (num > 50) {
    add_failed_mess("You cannot teach more than 50 levels at a time.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  skill_start = skill;
  bits = explode(implode(explode(skill, " "), "."), ".") - ({ "" });
  if (!bits || !(skill = (string)SKILL_OB->query_skill(bits))) {
    if (member_array(skill_start, teacher->query_known_commands()) != -1) {
      return 0;
    }
    add_failed_mess("The skill " + implode(bits, ".") + " is invalid.\n");
    return 0;
  }
  bits = explode(skill, ".");
  my_lvl = teacher->query_skill_bonus(skill, 1);
  ear_muffed = ({ });
  too_high = ({ });
  only_leaf = ({ });
  too_low = ({ });
  ok = ({ });
  too_little = ({ });
  cannot_teach = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach (ob in obs) {
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (!interactive(ob)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (!SKILL_OB->query_allowed_to_teach(skill)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
      continue;
    }
    if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
      continue;
    }
    if (SKILL_OB->query_only_leaf(skill) &&
        sizeof((mixed *)SKILL_OB->query_immediate_children(skill)))
    {
      only_leaf += ({ tmp });
      continue;
    }
    lvl = (int)ob->query_skill(skill);
    if (ob != teacher) {
      if ((int)ob->calc_bonus(lvl + num, skill, 1) > my_lvl) {
        add_failed_mess(teacher->the_short() +
                        " cannot teach $I, since their bonus is " +
                        (teacher == this_player() ? "higher" : "lower") +
                        " than yours.\n", ({ tmp }));
        continue;
      }
#ifdef ENFORCE_MAX_TEACH_LEVEL
      if (lvl + num > SKILL_MAX_TEACH) {
        too_high += ({ tmp });
        continue;
      }
#endif
    }
    if (sizeof(bits) > 1) {
      lvl_up = ob->query_skill(implode(bits[0 .. sizeof(bits) - 2], "."));
    } else {
      lvl_up = lvl;
    }
    depth = SKILL_OB->query_skill_depth(bits);
    if (!SKILL_OB->query_only_leaf(skill) && depth * 5 > lvl_up) {
      too_low += ({ tmp });
      continue;
    }
    total = 0;
    total2 = 0;
    foreach (sk in SKILL_OB->query_all_children(skill)) {
      if (SKILL_OB->query_immediate_children(sk) != ({ })) {
        continue;
      }
      my_lvl = teacher->query_skill_bonus(sk, 1);
      lvl = (int)ob->query_skill(sk);
      cost = DEFAULT_COST;
      cost *= STD_COST / 5;
      if (!my_lvl) {
        my_lvl = 1;
      }
      for (j = 0; j < num; j++) {
        k = 0.5 * (int)ob->calc_bonus(lvl + j, sk, 1 ) / my_lvl + 1.0;
        total2 += 500 + to_int(cost * (lvl+j) * exp((lvl + j) / 500.0) * k);
        if (total > total2) {
          num = j;
          break;
        } else {
          total = total2;
        }
      }
#ifdef DEBUG
      tell_object(find_player(DEBUGGER),
                  sprintf("%s:%s j:%d, lvl: %d, mylvl: %d, newbonus: %d, "
                          "total: %d\n",
                          this_player()->query_name(),
                          ob->query_name(),
                          j, lvl,
                          my_lvl,
                          (int)ob->calc_bonus(lvl + j, sk, 1),
                          lvl,
                          total2));
#endif
      if (!total) {
        total = cost;
      }
    }
    if (total > (int)ob->query_xp()) {
      if (teacher == this_player()) {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to $I.\n", ({ ob }));
      } else {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to you from " + teacher->the_short() +
                        ".\n");
      }
      too_little += ({ tmp });
      continue;
    }
    if (ob != teacher) {
      if (teacher == this_player()) {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\nUse "
                    "\"learn\" to learn the skill.\n");
        write("You offer to teach $M$$the_short:" + file_name(ob) +
              "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
              skill + " for " + total + " xp.\n");
      } else {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for "+total+" xp.\nUse \"learn\" "
                    "to learn the skill.\n");
        tell_object(teacher,
                    "You offer to teach $M$$the_short:" + file_name(ob) +
                    "$$M$ " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\n");
      }
    } else {
      write("You can teach yourself " + num + " level" +
            (num > 1 ? "s" : "") + " of " + skill + " for " + total +
            " xp.\nUse \"learn\" to learn the skill.\n");
      write("You offer to teach $M$$the_short:" + file_name(ob) +
            "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
            skill + " for " + total + " xp.\n");
    }
    ok += ({ tmp });
    frog = new(class teaching_skill);
    frog->num = num;
    frog->lvl = ob->query_skill(skill);
    frog->skill = skill;
    frog->xp = total;
    frog->room = environment(this_player());
    ob->add_respond_command(TEACH_SKILL_TYPE, teacher, frog);
  }
  if (sizeof(ok) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher,
                  this_player()->the_short() + " tried to learn " + skill +
                  " from you automatically but failed.\n");
    }
    if (sizeof(only_leaf) > 0) {
      add_failed_mess("You cannot teach the skill " + skill +
                      ", as it is only possible to teach leaf skills in "
                      "this skill tree.\n");
    }
    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      " to $I, they have teaching earmuffed and cannot "
                      "hear you.\n", ear_muffed);
    }
    if (sizeof(cannot_teach) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      "; you need to look for alternative methods of "
                      "advancement.\n");
    }
    if (sizeof(too_low) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_low) > 1    ||
                        too_low[0] == teacher  ||
                        teacher != this_player()) ? " are " : " is ") +
                      "not at a high enough level in the outer skills to "
                      "learn " + num + " levels of " + skill + ".   See "
                      "'help skills' for more details.\n");
    }
    if (sizeof(too_high) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_high) > 1     ||
                        teacher != this_player() ||
                        too_low[0] == teacher) ? " are " : " is ") +
                      "too high a level to learn " + num + " levels of " +
                      skill + ", they must be less than " +
                      SKILL_MAX_TEACH + " to learn from someone else.\n");
    }
    if (sizeof(ignoring) > 0) {
      add_failed_mess("You are ignoring $I.\n", ignoring);
    }
    if (sizeof(ignored) > 0) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
  }
  return sizeof(ok);
}
mixed *query_patterns() {
   return ({
      "<string:'skill|n levels of skill|command'> to <indirect:living>",
                   (: cmd($4[0], $1, 0) :),
      "me <string:'skill|n levels of skill|command'> from <indirect:living>",
                   (: cmd($4[0], $1, this_player()) :)});
}

==================================================
FILE: /lib/cmds/living/th_row.c
==================================================

#define CREATOR "Ceres"
#include <player.h>
#include <move_failures.h>
#include <tasks.h>
#define ASKILL "fighting.combat.range.thrown"
#define DSKILL "fighting.combat.dodging.range"
#define PSKILL "fighting.combat.parry.range"
#define COMMAND_GP_COST 5
inherit "/cmds/base";
int valid_target( object target, object thrower, object item );
int cmd( mixed *indirect_obs ) {
    object target, item;
    int dchance, damage;
    if ( sizeof( indirect_obs[ 0 ] ) > 1 ) {
        add_failed_mess( "You can only throw one item at a time!\n" );
        return 0;
    }
    item = indirect_obs[ 0 ][ 0 ];
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You can only throw $I at one target at a time!\n",
            ({ item }) );
        return 0;
    }
    target = indirect_obs[ 1 ][ 0 ];
    if ( item->query_wielded() != this_player() ) {
        add_failed_mess( "You must be holding $I to throw it.\n",
            ({ item }) );
        return 0;
    }
    if ( this_player() == target ) {
        add_failed_mess( "You cannot throw $I at yourself!\n", ({ item }) );
        return 0;
    }
    if ( !living( target ) && !target->query_property( "targetable" ) ) {
        add_failed_mess( "Why do you want to throw $I at " +
            target->the_short() + "?\n", ({ item }) );
        return 0;
    }
    if (this_player()->query_gp() < COMMAND_GP_COST) {
        add_failed_mess( "You need " + COMMAND_GP_COST + " points to "
            "throw " + item->the_short() + " at " + target->the_short() +
            ".\n");
        return 0;
    }
    if ( !valid_target( target, this_player(), item ) ) {
        add_failed_mess( "You decide against throwing $I at " +
            target->the_short() + ".\n", ({ item }) );
        return 0;
    }
    if ( living( target ) ) {
        switch ( (string)target->query_combat_response() ) {
            case "dodge" :
                dchance = target->query_skill_bonus( DSKILL );
            break;
            default:
                dchance = target->query_skill_bonus( PSKILL );
        }
    }
    else {
        dchance = target->query_property( "targetable" );
    }
    dchance += item->query_weight() / ( this_player()->query_str() / 2 );
    if( !this_player()->query_visible( target ) ) {
        dchance /= 2;
    }
    this_player()->adjust_gp(-COMMAND_GP_COST);
    switch( TASKER->perform_task(this_player(), ASKILL, dchance, TM_FREE) ) {
        case AWARD:
            tell_object(this_player(), "%^YELLOW%^You feel that your "
                "skill in throwing weapons has increased.%^RESET%^\n");
        case SUCCEED:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " and hit!\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                    " at " + target->the_short() + " and hits!\n",
                    this_player() );
            if ( living( target ) ) {
                damage = ( item->query_weight() / 4 ) +
                    ( this_player()->query_str() * 2) +
                    ( this_player()->query_skill_bonus( ASKILL ) / 3 );
                damage -= target->query_ac( "blunt", damage );
                target->attack_by( this_player() );
                target->adjust_hp( -damage, this_player() );
                this_player()->attack_ob( target );
                event( item, "thrown", this_player(), target );
                    this_player()->adjust_time_left(-(ROUND_TIME*2));
            }
            target->thrown_at( this_player(), 1, item );
            if ( item->move( target ) != MOVE_OK ) {
                item->move( environment( target ) );
            }
        break;
        default:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " but miss.\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                " at " + target->the_short() + " but misses.\n", this_player() );
            item->move( environment( target ) );
            if( !interactive( target ) && living( target ) ) {
                this_player()->attack_ob( target );
                target->attack_by( this_player() );
            }
            target->thrown_at( this_player(), 0 );
        break;
    }
    return 1;
}
int valid_target( object target, object thrower, object item ) {
    mixed owner;
    if ( target->query_property( "dead" ) || target->query_auto_loading() ) {
        return 0;
    }
    if ( userp( target ) && !interactive( target ) ) {
        return 0;
    }
    if ( pk_check( thrower, target ) )
        return 0;
    if ( ( owner = target->query_owner() ) && pk_check( thrower, owner ) ) {
        return 0;
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me'weapon'> at <indirect:object'target'>",
        (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/und_efend.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  object *defendees;
  object ob;
  object *fail;
  if(!things) {
    things = ({ });
  }
  things -= ({ TP });
  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot undefend yourself!\n");
    return 0;
  }
  defendees = ({ });
  fail = ({ });
  foreach ( ob in things) {
    if ( ob->remove_defender( TP ) ) {
      defendees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not defending " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(defendees)) {
     add_succeeded_mess("$N stop$s defending $I.\n", defendees);
     return 1;
  } else {
     return 0;
  }
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/unf_ollow.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   mapping hide_invis;
   int hiding, sneaking;
  object *ok, ob;
  string s;
  ok = ({ });
  foreach (ob in obs) {
    if (ob->remove_follower(TP)) {
      ok += ({ ob });
    }
  }
  if (!sizeof(ok)) {
    if (member_array(TP, obs) == -1) {
      return notify_fail("You are not following "+query_multiple_short(obs)+
                         ".\n");
    } else {
      return notify_fail("You are not following " +
        query_multiple_short(obs - ({ TP }) + ({ "yourself" })) + ".\n");
    }
  }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
   write("You stop following "+(s=query_multiple_short(ok))+" unseen.\n");
  else {
    write("You stop following "+(s=query_multiple_short(ok))+".\n");
    say(TP->the_short()+" stops following "+s+".\n", ok);
    foreach (ob in ok) {
      tell_object(ob, TP->the_short() +
                  " stops following "+query_multiple_short((ok + ({"you"})) -
                                                           ({ ob }))+".\n");
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/unh_old.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object obs) {
  object *ok, *zip, *failed, ob, *using;
  string s;
  mixed ret;
  using = TP->query_holding();
  failed = ok = zip = ({ });
  foreach (ob in obs) {
    if (member_array(ob, using) != -1) {
      if (!sizeof(ret = TP->set_unhold(ob)) || !ret)
        failed += ({ ob });
      else
        ok += ({ ob });
    }
    else
      zip += ({ ob });
  }
  if (!sizeof(ok)) {
    s = "";
    if (sizeof(failed))
      s += "Could not unhold "+query_multiple_short(failed)+".\n";
    if (sizeof(zip))
      s += capitalize("You are not holding " +
                      query_multiple_short(zip, "the") + ".\n");
    return notify_fail(s);
  }
  tell_object(TP, "You put down "+(s = query_multiple_short(ok))+".\n");
  tell_room(environment(TP), TP->one_short()+" puts down "+s+".\n", TP);
  TP->force_burden_recalculate();
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/unp_rotect.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  object *protectees;
  object ob;
  object *fail;
  if(!things) {
    things = ({ });
  }
  things -= ({ TP });
  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot unprotect yourself!\n");
    return 0;
  }
  protectees = ({ });
  fail = ({ });
  foreach ( ob in things) {
    if ( ob->remove_protector( TP ) ) {
      protectees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not protecting " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(protectees)) {
     add_succeeded_mess("$N stop$s protecting $I.\n", protectees);
     return 1;
  } else {
     return 0;
  }
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/watch.c
==================================================

#define COST 50
inherit "/cmds/base";
mixed cmd() {
   if ( this_player()->query_blinded() ) {
      add_failed_mess( "How can you watch anything?  You're blind.\n" );
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess( "Dead people don't watch. It is rude!\n");
      return 0;
   }
   if ( sizeof( (int *)this_player()->effects_matching( "mind.alertness" ) ) ) {
      add_failed_mess( "You are already alert and watching "
        "your surroundings.\n" );
      return 0;
   }
   if ( this_player()->query_specific_gp( "other" ) < COST ) {
      add_failed_mess( "You can't concentrate enough to watch "
        "your surroundings.\n" );
      return 0;
   }
   this_player()->adjust_gp( -COST );
   this_player()->add_effect( "/std/effects/other/alertness", 60 +
     (int)this_player()->query_skill_bonus( "other.perception" ) / 2 );
   return 1;
}
int stop_watching() {
   int *enums, id;
   enums = this_player()->effects_matching( "mind.alertness" );
   if ( sizeof( enums ) ) {
      foreach( id in enums ) {
         this_player()->delete_effect( id );
      }
   }
   else {
      add_succeeded_mess( ({ "You are not currently watching!\n", "" }) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "stop", (: stop_watching() :),
     "", (: cmd() :) });
}

==================================================
FILE: /lib/cmds/living/wea_r.c
==================================================

#include <clothing.h>
#include <tasks.h>
inherit "/cmds/base";
#define TP this_player()
#define SKILL "covert.manipulation.sleight-of-hand"
mapping add_to_failed(mapping failed, string word, object thing);
int cmd(object *things) {
  int i;
  string result;
  string stuff;
  string *reasons;
  object *okay;
  object *blocking;
  object *total_blocking;
  object ob;
  object tmp;
  mapping failed;
  mapping hide_invis;
  int hiding, sneaking, difficulty, light, my_light;
  okay = ({ });
  failed = ([ ]);
  things = sort_array(things, (: CLOTHING_HANDLER->query_clothing_depth($2->query_type()) -
                                 CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :) );
  total_blocking = ({ });
  foreach (ob in things) {
    if (environment(ob) != this_player())  {
      failed = add_to_failed(failed, "not carrying", ob);
      continue;
    }
    if ( !ob->query_wearable() ) {
      failed = add_to_failed( failed, "cannot wear", ob);
      continue;
    }
    if (member_array(ob, TP->query_wearing()) != -1) {
      failed = add_to_failed(failed, "already wearing", ob);
      continue;
    }
    if (ob->cannot_be_worn()) {
      failed = add_to_failed(failed, "cannot wear", ob);
      continue;
    }
    blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player());
if (this_player() == find_player("presto"))
printf("blocking == %O\n", blocking);
    if (sizeof(blocking)) {
       total_blocking += blocking;
       foreach (tmp in blocking) {
          TP->remove_armour(tmp);
       }
    }
    result = CLOTHING_HANDLER->can_wear_or_remove(ob, this_player());
if (this_player() == find_player("presto"))
printf("ob == %s, result == %s\n", ob->short(), result);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    result = TP->wear_armour(ob, 0);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    okay += ({ ob });
  }
  if (total_blocking) {
    foreach (tmp in total_blocking) {
      TP->wear_armour(tmp);
    }
  }
  result = "";
  if (sizeof(failed)) {
    reasons = keys(failed);
    for (i = 0; i < sizeof(reasons); i++) {
      stuff = query_multiple_short(failed[reasons[i]], "the");
      switch (reasons[i]) {
      case "cannot wear" :
        if (!sizeof(okay)) {
           result += capitalize(stuff) +" cannot be worn.\n";
        }
        break;
      case "already wearing" :
        result += "You are already wearing "+ stuff +".\n";
        break;
      case "already holding" :
        result += "You cannot wear "+ stuff +" as you do not "
          "have enough free limbs.\n";
        break;
      case "oh dear" :
        result += "I'm not sure why you can't wear "+ stuff +
          "; something has probably gone wrong, so please "
          "contact a creator.\n";
        break;
      case "not carrying":
        result += "You aren't carrying " + stuff + ".\n";
        break;
      default :
        result += "You cannot put on "+ stuff +" "+ reasons[i] +".\n";
      }
    }
  }
  if (!sizeof(okay)) {
    return notify_fail(result);
  }
  stuff = query_multiple_short(okay);
  if (sizeof(total_blocking)) {
     tell_room(environment(TP), TP->one_short() + " removes " +
               query_multiple_short(total_blocking) + " so " +
               TP->query_pronoun() + " can wear "+
               stuff +".\n" + TP->one_short() + " wears " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
     write("You remove " +
               query_multiple_short(total_blocking) + " so you can wear "+
               stuff +".\nYou wear " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
  } else {
    hide_invis = ( mapping )this_player()->query_hide_invis();
    hiding = hide_invis[ "hiding" ] ? 1 : 0;
    sneaking = this_player()->query_sneak_level() ? 1 : 0;
    if( hiding || sneaking ) {
      my_light = this_player()->query_light();
      light = environment( this_player() )->query_light();
      difficulty = light + ( 4 * my_light ) / ( light + 1 );
      if( sizeof( total_blocking ) ) {
        difficulty += 50 * sizeof( total_blocking );
      }
      difficulty += okay[0]->query_complete_weight();
      debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                    difficulty, SKILL, this_player()->
                    query_skill_bonus( SKILL ) );
      switch( TASKER->perform_task( this_player(), SKILL, difficulty,
        TM_FREE ) ) {
        case AWARD :
          write( "%^YELLOW%^" + ({
            "You discover something that lets your fingers move more "
              "nimbly.",
            "You find yourself capable of deceiving the eye with greater "
              "ease than before.",
            "You realise how to deceive the eye more effectively."
          })[ random(3) ] + "%^RESET%^\n" );
        case SUCCEED :
          add_succeeded_mess( ({ "$N $V " + stuff + ", managing to stay "
            "unnoticed.\n",
            "" }) );
          break;
        default :
          this_player()->add_succeeded_mess( this_object(), "$N "
            "unsuccessfully tr$y to " + query_verb() + " " + stuff +
            " while staying unnoticed.\n", ({ }) );
          break;
      }
    } else {
      this_player()->add_succeeded_mess( this_object(), "$N $V " + stuff +
        ".\n", ({ }) );
    }
  }
  return 1;
}
mapping add_to_failed(mapping failed, string word, object thing) {
  if (!failed[word]) {
    failed += ([ word : ({ thing }) ]);
  } else {
    failed[word] += ({ thing });
  }
  return failed;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/whi_sper.c
==================================================

inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd( object *others, string last ) {
  class message mess;
  if (sizeof(others) == 1 && others[0] == this_player()) {
     add_failed_mess("Whispering to yourself?  Neat trick.\n");
     return 0;
  }
  mess = build_message(last, others, "whisper");
  mess->type = "whisper";
  return say_it_to(mess, others, 1, "whisper");
}
mixed *query_patterns() {
   return ({ "<string'message'> to <indirect:living>", (: cmd($1, $4[0]) :),
             "<indirect:living> <string'message'>", (: cmd($1, $4[1]) :) });
}

==================================================
FILE: /lib/cmds/living/wi_eld.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  if (!interactive(this_player()))
    return "/cmds/living/ho_ld"->cmd(str);
  return notify_fail("Use hold; see help hold for more details.\n");
}

==================================================
FILE: /lib/cmds/living/withdraw.c
==================================================

#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int withdraw_offer(object *sell_to) {
   object *removed;
   object ob;
   removed = ({ });
   foreach (ob in sell_to) {
      if (ob->query_respond_command("sell", this_player())) {
         ob->remove_respond_command("sell", this_player());
         removed += ({ ob });
      }
   }
   if (sizeof(removed)) {
      add_succeeded_mess("$N withdraw$s $p offer of sale to $I.\n", removed);
      return 1;
   }
   add_failed_mess("You cannot withdraw your offer of sale to $I since "
                   "you have not offered to sell them anything in the "
                   "first place.\n", sell_to);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer {from|to} <indirect:living>",
             (: withdraw_offer($1) :) });
}

==================================================
FILE: /lib/cmds/living/wring.c
==================================================

inherit "/cmds/base";
int cmd(object *things)  {
   object *towels;
   int    *enums;
   int     wetness;
   int     success;
   string  str;
   towels = filter(things,
                   (: $1->id("towel")  ||  $1->query_property("dryer") :));
   things -= towels;
   str = "";
   if (sizeof(towels) == 1)  {
      enums = towels[0]->effects_matching("object.wet");
      if (sizeof(enums)) {
         wetness = towels[0]->arg_of(enums[0]);
      }
      if (wetness < 36 - this_player()->query_str())  {
         str = "You can't wring any more moisture out of " +
               towels[0]->one_short();
         success = 0;
      } else  {
         towels[0]->add_effect("/std/effects/object/wet",
            -wetness / ((36 - this_player()->query_str()) / 4));
         str = "You wring some moisture out of " +
               towels[0]->one_short();
         success = 1;
      }
   } else if (sizeof(towels))  {
      str = "You can only wring out one thing at a time";
      success = 0;
   }
   if (sizeof(things))  {
      if (success) {
         str += ", but you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      } else {
         str += ", and you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      }
   } else {
      str += ".\n";
   }
   write(str);
   return 1;
}
mixed *query_patterns()  {
   return ({ "[out] <indirect:object:me'towel'>", (: cmd($1) :) });
}
