# Total Tokens: 21746
# Total Files Merged: 35
# Total Characters: 72585

mon.c
==================================================

#include <config.h>
#include "path.h"
inherit "/std/room/basic_room";
#define HANDLER (LEARNING +"handlers/request")
object board;
object *chairs;
int do_claim(int);
int do_remove(int);
int do_request(string, string);
int do_sit( string command, object *indir, string dir_match,
           string indir_match, mixed *args, string pattern );
void setup() {
   set_light( 100 );
   set_short( "somewhat boring commonroom of the learning domain" );
   add_property( "determinate", "the " );
   set_long( "This is the common room of the domain of learning, the place "
            "where creators come to learn.  It is a somewhat boring room "
            "except for some chairs strewn around the place which happen to "
            "be an example of having commands defined in add_items, and some "
            "sort of list hanging on the wall which is an example of using "
            "add_command in rooms.\n" );
   add_item( "chair", ({
      "long", "This chair looks comfortable, perhaps you can sit in it.",
      "sit", ({ (: do_sit :), "[in] <direct:object>" })
   }), 1 );
   add_item( "chairs", ({
      "long", "These chairs look comfortable, "
              "perhaps you can sit in one of them.",
      "sit", ({ (: do_sit :),  "[in] <direct:object>" })
   }), 1 );
   add_item( "list",
            "This list has several actions associated with it:\n"
            "\"show list\" will show the current requests.\n"
            "\"request documentation\" will ask for "
            "documentation on something.\n"
            "\"request example\" will ask for an example of "
            "something to be coded.\n"
            "\"claim <number>\" is use to claim a request, thereby attempting "
            "to make sure that only one creator is writing the documentation/"
            "coding the examples." );
   add_exit( "entrance", PATH +"main", "path" );
   add_exit( "drum", CONFIG_START_LOCATION, "path" );
   chairs = ({ });
   add_extra_look( this_object() );
   add_property( "commented functions", ({ "add_extra_look", "extra_look",
      "remove_extra_look", "add_command" }) );
   add_property( "keywords", ({ "room", "add_item", "action" }) );
   board = clone_object( "/obj/misc/board" );
   board->set_datafile( DOMAIN );
   board->move( this_object() );
}
void init() {
   ::init();
   add_command( "show", "list" );
   add_command( "claim", "<number>", (:do_claim( $4[0] ):) );
   add_command( "request", "{documentation|example} <string'subject'>",
                (:do_request( $4[0], $4[1] ):));
   add_command( "remove", "<number>", (:do_remove( $4[0] ):) );
}
int do_show() {
   write( HANDLER->query_list() );
   return 1;
}
int do_claim( int i ) {
  if ( HANDLER->claim_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "Illegal request number.\n" );
  }
  return 1;
}
int do_remove( int i ) {
  if ( HANDLER->remove_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "You can't remove that request.\n" );
  }
  return 1;
}
int do_request( string option, string words ) {
  if ( option == "documentation" ){
      HANDLER->add_request( this_player()->query_name(),
                           "documentation for "+ words );
      write( "You request some documentation.\n");
      say( this_player()->the_short() +" requests some documentation.\n");
      return 1;
   }
  if ( option == "example") {
      HANDLER->add_request( this_player()->query_name(),
                           "examples of "+ words );
      write( "You request some example.\n");
      say( this_player()->the_short() +" requests some example.\n");
      return 1;
   }
   return 0;
}
int do_sit( string command, object *indir, string dir_match,
           string indir_match, mixed *args, string pattern ) {
   if ( dir_match == "chairs" ) {
      this_player()->add_succeeded_mess( previous_object(),
             "How can you sit on more than one chair at the same time?\n",
             ({ }) );
      return 1;
   }
   if ( member_array( this_player(), chairs ) != -1 ) {
      this_player()->add_succeeded_mess( previous_object(),
             "You are already sitting in a chair.\n", ({ }) );
      return 1;
   }
   chairs += ({ this_player() });
   this_player()->add_extra_look( this_object() );
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V in a "+ dir_match +".\n", ({ }) );
   return 1;
}
string extra_look( object thing ) {
   if ( thing == this_object() ) {
      chairs = filter_array( chairs, (: $1 != 0 :) );
      chairs = filter_array( chairs,
                            (: environment( $1 ) == this_object() :) );
      if ( !sizeof( chairs ) ) {
         return "";
      } else {
         if ( sizeof( chairs ) == 1 ) {
            if ( chairs[ 0 ] == this_player() ) {
               return "You are sitting in one of the chairs.\n";
            } else {
               return (string)chairs[ 0 ]->the_short()
                      +" is sitting in one of the chairs.\n";
            }
         } else {
            return query_multiple_short( chairs, "the" )
              +" are sitting in the chairs.\n";
         }
      }
   } else if ( member_array( thing, chairs ) != -1 ) {
      if ( environment( thing ) == this_object() ) {
         if ( thing == this_player() ) {
            return "You are sitting in a chair looking lazy.\n";
         } else {
            return thing->query_pronoun() +" is lazing around in a chair.\n";
         }
      }
   }
   thing->remove_extra_look( this_object() );
   return "";
}

==================================================
FILE: learning/function_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string function_chosen;
void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", PATH +"functions", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return function_chosen;
}
void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s",
                     exit_letter,
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/functions.c
==================================================

#include "path.h"
#include <learning.h>
#define PATH LEARNING
inherit "/std/room/basic_room";
string *functions;
int do_list();
int word();
void setup() {
   string word;
   set_short( "room of function examples" );
   add_property( "determinate", "the " );
   set_long( "This is the room that might lead you to better understanding "
            "of how to use some of the functions we have here.\n"
            "Try \"list functions\" to get a list of the functions known by "
            "the room, "
            "take the exit named by the function to get to a room with exits "
            "to the examples.\n"
            "If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n" );
   set_light( 50 );
   functions = SEARCH->query_functions();
   foreach( word in functions ) {
      add_exit( word, "??", "path" );
      modify_exit( word, ({ "obvious", 0 }) );
   }
   add_exit( "exit", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property", "set_light" }) );
   add_property( "keywords", ({ }) );
}
void init() {
  ::init();
  add_command( "list","functions");
}
int do_list() {
   write( sprintf( "The following functions have examples of use:\n%#-*s\n",
                  75, implode( functions, "\n" ) ) );
   return 1;
}
void set_destination( string word ) {
   if( word != "exit" ) {
      modify_exit( word, ({ "dest", SEARCH->find_function_room( word ) }) );
   }
}

==================================================
FILE: learning/main.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
   set_short( "entrance to learning" );
   add_property( "determinate", "the " );
   set_long( "Welcome to the entrance room of the learning domain.  "
            "The purpose of this domain is to help beginning creators, by "
            "giving examples of the way to use the different functions that "
            "are available, and show ways to solve common problems.\n"
            "To see the code used in a room or an object you can use the "
            "commands \"more here\" and \"more <object name>\" "
            "respectively.  If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n"
            "The search exit will take you to a special room with exits "
            "for each of the keywords defined in the different files in the "
            "domain, this will enable you to search for examples by "
            "selecting keywords, and is also an example of the use of "
            "virtual or cloned rooms.\n"
            "If you want to find examples of how to use specific functions, "
            "use the functions exit.\n"
            );
   set_light( 50 );
   set_co_ord( ({ 30, 0, 40 }) );
   add_exit( "search", PATH + "search", "door" );
   add_exit( "functions", PATH + "functions", "door" );
   add_exit( "common", "/w/common", "door" );
   "/w/common"->add_exit( "learning", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property", "set_light",
                   "add_exit" }) );
   add_property( "keywords", ({ "room" }) );
}

==================================================
FILE: learning/master.c
==================================================

#define LORD "taffyd"
#define DOMAIN "learning"
inherit "/std/dom/base_master";
string info = "";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int copy_with_read(string path, string euid, string func) {
  return 1;
}
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}
int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}
int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
   return LORD;
}
void set_info( string words ) {
  info = words;
  save_me();
}
string query_info() {
  return info;
}

==================================================
FILE: learning/search.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
string *keywords;
void setup() {
   mixed search_result;
   string word;
   set_short( "primary search room" );
   add_property( "determinate", "the " );
   set_long( "Welcome to the first room for doing keyword searches.  "
            "Take an exit to narrow the search to that keyword.  If less than "
            "five rooms or objects fit the keywords there will also be exits "
            "directly to them.\n" );
   set_light( 50 );
   search_result = SEARCH->get_keywords( ({ }) );
   keywords = search_result[ 0 ];
   foreach( word in keywords ) {
      add_exit( word, "??", "path" );
   }
   add_exit( "exit", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "add_exit", "set_destination" }) );
   add_property( "keywords", ({ "virtual", "room" }) );
   add_property( "no map", 1 );
}
void set_destination( string keyword ) {
   if( member_array( keyword, ({ "exit", "back", "a", "b", "c", "d", "e" }) ) != -1 )
      return;
   modify_exit( keyword, ({ "dest", SEARCH->find_room( ({ keyword }) ) }) );
}

==================================================
FILE: learning/search_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string marker, *keywords, *exits;
void setup() {
   set_short( "uninitialised search room" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", LEARNING +"search", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return marker;
}
string *query_keywords() {
   if( !keywords ) {
      return ({ });
   }
   return keywords;
}
void set_marker( string word, string *words ) {
   mixed search_result;
   string description, exit;
   int i;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   marker = word;
   keywords = words;
   description ="You are in one of the search rooms of the learning domain "
                "and you have chosen the word"+
                ({ " \"", "s \"" })[ sizeof( words ) > 1 ] + word +"\" so far.";
   search_result = SEARCH->get_keywords( words );
   exits = search_result[ 0 ];
   if( sizeof( exits ) ) {
      description += "  Take one of the keyword exits to narrow the search to "
                     "include that keyword.";
      foreach( word in exits ) {
         add_exit( word, "/??", "path" );
      }
   }
   description += "\n";
   if( sizeof( search_result[ 1 ] ) < 6 ) {
      description += "$I$5=Take one of the numbered exits to go to that room.";
      for( i = 0; i < sizeof( search_result[ 1 ] ); i++ ) {
         exit = sprintf( "%s: %s", ({ "1", "2", "3", "4", "5" })[ i ],
                        MAP->query_short( search_result[ 1 ][ i ] ) );
         add_exit( ({ "1", "2", "3", "4", "5" })[ i ],
                  search_result[ 1 ][ i ], "path" );
         description += "\n$C$"+ exit +".";
      }
      description += "$I$0=\n";
   }
   set_long( description );
}
void set_destination( string keyword ) {
   if( member_array( keyword, exits ) != -1 ) {
      modify_exit( keyword, ({ "dest",
         SEARCH->find_room( keywords + ({ keyword }) ) }) );
   }
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_room", keywords });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/help_topics/npcs/make_person.c
==================================================

#include "path.h";
inherit "/std/room";
object red_demon;
void setup() {
   set_short( "room telling about adding NPC's" );
   add_property( "determinate", "the " );
   set_long( "This is a room showing how to add a stationary NPC to a room.  "
            "If you try to \"update here\" you will see that it waits a few "
            "seconds after loading the room before adding the NPC and, that "
            "when it appears there are a message notifying the player about "
            "it.\n" );
   set_light( 60 );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property",
                   "set_light", "reset" }) );
   add_property( "keywords", ({ "npc", "clone", "permanent", "make" }) );
}
void reset() {
   if ( !red_demon ) {
      call_out( "make_demon", 5 );
   }
}
void make_demon() {
   red_demon = clone_object( "/obj/monster" );
   red_demon->set_name( "imp" );
   red_demon->set_short( "small red imp" );
   red_demon->add_adjective( ({ "small", "red" }) );
   red_demon->set_long( "This is a small red imp who has agreed to be used "
                       "as an example.\n" );
   red_demon->set_base_weight( 10 );
   red_demon->set_height( 17 );
   red_demon->set_race( "imp" );
   red_demon->set_level( 1 );
   red_demon->move( this_object(), "$N materialize$s with a small *POP*." );
}

==================================================
FILE: learning/help_topics/rooms/terrains/foyer.c
==================================================

#include "path.h"
inherit "/std/room";
object teacher;
object sign;
void setup() {
   set_short( "foyer of the terrain school" );
   add_property( "determinate", "the " );
   set_long( "This is the foyer to the terrain teacher's school.  "
      "The walls here are hung with beautiful landscapes of complex tracts "
      "of land, and beneath each landscape is a map of some kind.  "
      "An intricate chandelier hangs from the ceiling, casting an even "
      "glow on all the landscapes.  "
      "Comfortable benches line the walls here, with small tables "
      "between them.  "
      "The floor is covered with a plush green carpet, which would be nice "
      "if not for the heavy mud stains across it.\n" );
   add_item( "landscape",
      "The landscapes show mountains, jungles, forests, "
      "oceans, rivers... all sorts of different terrains, including a "
      "city and a village." );
   add_item( "map",
      "Beneath each landscape hangs a single topographical "
      "map which appears to be a detailed representation of the landscape "
      "above it." );
   add_item( "chandelier",
      "Crystal teardrops scatter the light of a dozen "
      "candles around the room, casting an easy, comfortable light by which "
      "you can see.", 1 );
   add_item( "crystal teardrop",
      "The candlelight makes it too hard to see "
      "the crystals clearly." );
   add_item( "candle",
      "Nestled into the midst of the chandelier, the twelve "
      "candles provide all the light in this room.");
   add_item( "bench",
     ({ "long", "These wooden benches have comfortable leather cushions "
           "firmly attached.",
        "position", "a wooden bench",
     }) );
   add_item( "table",
     ({ "long", "These tables are covered with magazines talking "
           "about far away places and exotic architecture.",
        "position", "a table",
     }) );
   add_item( "plush green carpet",
      "This deep pile carpet was once a rich evergreen colour, but "
      "years of muddy footprints have stained much of it a deep, "
      "ugly brown." );
   add_item( "mud stains",
      "Someone has b een walking on this formerly beautiful carpet with "
      "muddy boots." );
   add_item( "cushions",
      "Thick leather cushions, stuffed with something very soft, and "
      "affixed quite securely to the benches." );
   add_item( "magazines",
     ({ "long", "Architectural and travel magazines sit on the "
           "various tables around the room.",
        "read", "\"Ruins of The Temple of Offler!\", "
           "\"Beautiful Ankh-Morpork!\", \"Design of the Tower of Art\", "
           "and \"Scenic Ramtops Vacations!\" are just the most visible "
           "of the titles that scream up at you.  Hopefully the "
           "magazines are kept just for their pictures, which seem far "
           "more interesting than their text.",
     }) );
   set_light( 60 );
   add_exit( "grassyfield", PATH "grassystep", "hidden" );
   add_exit( "desert", PATH "sandtent", "hidden" );
   add_exit( "mountaintop", PATH "mountaincabin", "hidden" );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({  }) );
   add_property( "keywords",
                ({ "terrain" }) );
   sign = add_sign(
      "A cardboard sign, with text scrawled messily across the front.\n",
      "Awye FRoM TH OFFICe",
      "cardboard sign",
      "sign",
      "common" );
   if (sign) sign->set_get();
}
void init() {
   if ( !this_player() )
      return;
   if ( !interactive( this_player() ) )
      return;
   if (!teacher) {
      teacher = load_object( CHARS "terrain_teacher" );
   }    if ( teacher ) {
      teacher->pupil_arrived( this_object() );
   }
}

==================================================
FILE: learning/help_topics/rooms/terrains/grassyfield.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain("tutorial_grassy_field");
   set_short("grassy field");
   set_long("This field is covered with nicely mowed grass.\n");
   add_item("grass", "It's grass.  There isn't much to say about it.");
}

==================================================
FILE: learning/help_topics/rooms/terrains/grassystep.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_grassy_field" );
   set_short( "doorstep");
   set_long( "This is the doorstep to a small cottage.  All around "
            "here is a field covered with nicely cut grass.\n" );
   add_item( "grass", "It's grass.  There isn't much to say about it." );
   add_item( "cottage", "A plain, one-room cottage, painted white, "
            "with pink shutters on both the windows.  *hack* *cough*" );
   add_exit( "cottage", PATH "foyer", "corridor" );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountainbedroom.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "mountain cabin attic" );
   set_long( "This is the second floor of a comfortable mountain cabin.  "
            "The bed occupying most of this room would seem to indicate "
            "that this is a bedroom.\n" );
   add_item( "bed", ({
      "long", "A big king-sized bed with a nice, thick, comforter on top.",
      "position", "the bed" }), 0 );
   add_item( "comforter",
      "This thick quilted comforter is made of some "
      "soft cotton fabric sandwiching a thick layer of down.");
   set_light( 50 );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountaincabin.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "rustic mountain cabin" );
   set_long( "This is the ground floor of a comfortable mountain cabin, "
      "complete with walls made of chinked logs, a bearskin rug, "
      "a huge, comfy sofa, and a bare lumber staircase leading "
      "up and down.  Unfortunately, since someone forgot to put a "
      "front door on this place, it's damned cold in here.\n" );
   add_item( ({ "log", "wall" }),
      "Formed of whole logs, sanded to a satin "
      "finish, laid together, and with the gaps chinked with mud." );
   add_item( "bearskin rug", ({
      "long", "Looks like a large blackbear gave his life that you can be "
         "comfortable lying before the fire.",
      "position", "the rug" }), 0 );
   add_item( "comfy sofa", ({
      "long", "Not very sophisticated, but it sure looks comfortable.",
      "position", "the sofa" }), 0 );
   set_light( 50 );
   room_chat( ({ 100, 300,
      ({ "A chill wind blows some snow in through the open doorway.",
         "A sudden shiver runs down your spine.",
         "Maybe you should have packed some cold weather gear?",
         "Oh, a mug of hot cocoa would about hit the spot right now."
      }) }) );
   add_exit( "down", PATH "foyer", "stair" );
}
string query_exit_type( string direc, string dest) {
   if (direc == "up" || direc == "down")
      return "stair";
   else if (direc == "west")
      return "corridor";
   else
      return "none";
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountainsnows.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "the snowy wastes" );
   add_property( "determinate", "" );
   set_long( "This snow covered land is swept by strong winds night and "
            "day.  No trees can stand the harsh climate.\n" );
   add_item( "tree", "No, I said there _weren't_ any trees." );
   add_property( "climate", ({ -40, 50, 40 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountaintree.c
==================================================

#include "path.h"
#include <terrain.h>
inherit "/std/outside";
void setup() {
   set_room_size( 20 );
   set_terrain( "tutorial_mountain" );
   set_short( "tree in the mountains" );
   set_long( "This tree has defied all the odds, and grows straight and "
            "tall in the blustery wastes." );
   add_extra_look( this_object() );
   add_property( "climate", ({ -40, 50, 40 }) );
}
string extra_look() {
   if ( co_ord[ 2 ] < 800200 )
      return "\n";
   else
      return "  You can just make out a cabin in the snows to your "
             "northeast.\n";
}

==================================================
FILE: learning/help_topics/rooms/terrains/sanddunes.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "sandy wasteland" );
   set_long( "This is just one small section of an endless "
            "expanse of sand.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it.");
   add_property( "climate", ({ 40, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/sandoasis.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "desert oasis" );
   set_long( "The trees in this oasis provide welcome relief from the harsh "
            "sunlight of the desert.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it other than "
      "that it's much moister here than elsewhere in the desert." );
   add_item( "tree",
      "The palm trees grow majestically all around you, "
      "providing all the shade you could want." );
   add_property( "climate", ({ 10, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/sandtent.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "outside tent" );
   set_long( "This is just outside the front flap of a canvas tent, set "
      "in the middle of a huge desert waste.  Nothing but sand as far "
      "as the eye can see.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it." );
   add_item( "tent",
      "This is a plain, white canvas tent, that reflects the harsh "
      "glare of the sun harmlessly away from its occupants." );
   add_exit( "tent", PATH "foyer", "corridor" );
   add_property( "climate", ({ 40, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/add_item/action_verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about making verbs do stuff" );
   set_light(100);
   set_long( "This is the room telling about making verbs do stuff.\n"
            "Let's say you have a rat in a room and randomly (let's say one "
            "out of two times) want to let players touch it.\n"
            "Read the ratnote to get an explanation of what happens when "
            "you touch the rat.\n"
            "There is a rat on the floor and a ratnote on the wall.\n");
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }) );
   add_item( "ratnote", ({
      "long", "It can be read.",
      "read", "When the rat is touched, do_touch() is called.  The do_touch() "
         "function must return an integer - If the touch was successful it "
         "returns a 1, if the touch failed the function should return a 0.\n"
         "Note also that a success message is given to all in the room.  But, "
         "if the person fails, the add_item code looks for more matches - "
         "thinking that the function do_touch is the wrong one.  If there is "
         "no other function found that defines touching rats and that returns "
         "a 1, then the game returns the message 'You fail to touch a rat'.\n"
         "The this_object() reference tells the add_item code what object is "
         "the direct object of the verb.  Just trust me, and leave it in your "
         "code without asking why for now.  It is one of those things that "
         "can give you more flexibility later on.\n" }) );
   add_exit( "east", PATH +"verb_failure", "path" );
   add_exit( "west", PATH +"many_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_touch() {
   if( random(2) ) {
      tell_object( this_player(), "\n ****  You feel deathly sick. ****\n"
                  " (this is a tell_object(this_player(),...))\n" );
      tell_object( this_player(),
                  "do_touch is returning a 0, indicating failure!\n" );
      return 0;
   }
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/action_verbs2.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #6, making verbs do stuff, better version ");
   set_light(100);
   set_long("add_item room #6, making verbs do stuff, better version\n"
	    +"There are two ways to call a function if a verb is used.  "
	    +"This room demonstrates the second one.  "
       	    +"Lets say you have a rat in a room and randomly ( one out of "
	    +"two times lets say ) want to let players touch it. "
	    +"This is how you could do it.\n"
	    +"A filthy rat and a can.\nA ratnote and a cannote.\n");
   add_item("ratnote", ({ "long", "It can be read.",
		       "read", "Here is the code for the rat:\n"
     +"   add_item(\"large filthy rat\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"do_touch\" }) }) );  \n"
     +"When the rat is touched, do_touch() is called.  The do_touch() func "
     +"must return an integer - If the touch was successful it returns a 1, "
     +"if the touch failed the function should return a 0.  Note that a "
     +"success message is given to all in the room.  But, if the person fails "
     +"the add_item code looks for more matches - thinking that the func "
     +"do_touch is the wrong one.  If there is no other function found that "
     +"defines touching rats and that returns a 1, then the game returns the "
     +"message 'You fail to touch a rat'.\n"
     +"The this_object() refrence tells the add_item code what object is "
     +"the direct object of the verb.  Just trust me, and leave it in your "
     +"code without asking why for now.  It is one of those things that can "
     +"give you more flexibility later on.\n" }));
   add_item("dirty can", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "always_fail" })
                   }));
   add_item("cannote", ({ "long", "It can be read.",
		          "read", "Here is the code for the can:\n"
     +"   add_item(\"dirty can\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"always_fail\" }) }) );  \n"
     +"When the can is touched, always_fail() is called.  This function "
     +"looks like this:\n int always_fail() { return 0; }\n"
     +"in this way if you want a person to be able to use a verb on an "
     +"object, but want to be lazy - and don't want the action to succeed "
     +"( such as a door that can't be broken down ) this is the way to do "
     +"it.\nPlease read ratnote also, if you havn't.\n" }));
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "do_touch" })
                   }));
   add_exit("east",ROOM+"verb_failure","door");
   add_exit("west",ROOM+"changing_descs","door");
   add_exit("north",MAIN,"door" );
 }
int  do_touch()
{
  if( random(2) ) {
      tell_object(this_player(),"\n ****  You feel deathly sick. ****\n  "
		              "(this is a tell_object(this_player(),...)) \n");
      tell_object(this_player(),
		  "do_touch is returning a 0, indicating failure!\n");
      return 0;
    }
    return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_char.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #12, Getting character arguments ");
   set_light(100);
   set_long("add_item room #12, Getting character arguments\n"
	    +"There is a large stone in the middle of the room.  It looks as "
	    +"if you can engrave your name onto it.\nSource code.\n");
   add_item("large stone", ({
	        "long",
	                   "It can be engraved."
		,"engrave",
			   ({ this_object(), "do_engrave",
				"'into' %D 'the' text' %s"  })
	}));
   add_item("source code", ({ "long",
         "It looks like some source code."
         ,"read",
         "The source code:\n"
+"\n"
+"   add_item(\"large stone\", ({\n"
+"	        \"long\",\n"
+"	                   \"It can be engraved.\"\n"
+"		,\"engrave\",\n"
+"			   ({ this_object(), \"do_engrave\",\n"
+"				\"'into' %D 'the' text' %s\"  })\n"
+"	}));\n"
+"\n\nRead also:  do_engrave\n" }));
   add_item("do_engrave", ({ "long",
         "It looks like some source code."
         ,"read",
         "The source code:\n"
+"int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)\n"
+"{\n"
+"     string mess;\n"
+"        mess =  \"$N $V \"+a5[1]+\" into \"+a3+\".\\n\";\n"
+"        this_player()->add_succeeded_mess(previous_object(),\n"
+"					        mess,\n"
+"					        ({}));\n"
+"        return 1;\n"
+"}\n"
+"\n" }));
   add_exit("east",ROOM+"args_object","door");
   add_exit("west",ROOM+"args_integer","door");
   add_exit("north",MAIN,"door" );
 }
int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
     string mess;
        mess =  "$N $V "+a5[1]+" into "+a3+".\n";
        this_player()->add_succeeded_mess(previous_object(),
					        mess,
					        ({}));
        return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_integer.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about getting integer arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting integer arguments from a "
            "command defined with add_item.  Go east to learn about getting "
            "string arguments, west to learn about the arguments passed "
            "to the function called when you do the command.\n"
            "This room is filled with an uncountable number of rats.  They "
            "all have numbers branded into them.  You can dissolve a rat if "
            "you know its number.\n" );
   add_item( "large filthy rat", ({
      "long", "The rats look vile.",
      "dissolve", ({ this_object(), "do_dissolve",
         "<direct:object> [no|number] <number>" })
   }) );
   add_exit( "east", PATH +"args_string", "path");
   add_exit( "west", PATH +"func_arguments", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_dissolve( string command, object *indir, string dir_match,
                string indir_match, mixed *args, string pattern ) {
   string mess;
   tell_object( this_player(),
               sprintf( "$I$2=do_dissolve called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   mess =  "$N $V "+ dir_match +" number "+ args[ 1 ] +".\n";
   this_player()->add_succeeded_mess( previous_object(),
                                      mess, ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_object.c
==================================================

#include "path.h"
inherit "/std/room";
object key;
void setup() {
   set_short( "'add_item' room telling about getting the object as argument" );
   set_light(100);
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "string arguments, west to see about item conflicts.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can unlock it if you have the correct key.\n" );
   add_item( "large stone", ({
      "long","It can be unlocked.",
      "unlock", ({ this_object(), "do_unlock",
         "<direct:object> [with] <indirect:object>" })
   }) );
   add_exit( "east", PATH +"item_conflicts", "path" );
   add_exit( "west", PATH +"args_string", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_unlock( string command, object *indir, string dir_match,
               string indir_match, mixed *args, string pattern ) {
   object ob;
   tell_object( this_player(),
               sprintf( "$I$2=do_unlock called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   this_player()->add_failed_mess( previous_object(),
                                  "You don't have the correct key.\n", ({ }) );
   ob = indir[ 0 ];
   if( (int) ob->query_property( "Mithal" ) != 1 ) {
      write( "wrong key\n" );
      return 0;
   }
   this_player()->add_succeeded( ob );
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V the stone with $I.\n",
                                     ({ ob }));
   write( "You succeeded!\n" );
   return 1;
}
void reset() {
   call_out( "check_key", 2 );
}
void check_key() {
   if( !key ) {
      key = clone_object( "std/object" );
      key->set_name( "key" );
      key->set_short( "Mithal's key" );
      key->add_property( "Mithal", 1 );
      key->move( this_object(), "Mithal sneaks through the room, "
                "dropping $N in the process." );
   }
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_string.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about getting string arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "object arguments, west to see about integer arguments.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can engrave your name onto it.\n");
   add_item( "large stone",
            ({ "long", "It can be engraved.",
               "engrave", ({ this_object(), "do_engrave",
                  "[the text] <string> [into] [the] <direct:object>" })
            }) );
   add_exit( "east", PATH +"args_object", "path");
   add_exit( "west", PATH +"args_integer", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_engrave( string command, object *indir, string dir_match,
               string indir_match, mixed *args, string pattern ) {
   string mess;
   tell_object( this_player(),
               sprintf( "$I$2=do_engrave called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   mess =  "$N $V \""+ args[ 0 ] +"\" into "+ dir_match +".\n";
   this_player()->add_succeeded_mess( previous_object(), mess, ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/changing_descs.c
==================================================

#include "path.h"
inherit "/std/room";
int open;
void setup() {
   set_short("add_item room #5b, item descriptions that change with time");
   set_light(100);
   set_long("add_item room #5b, item description that change with time\n"
            "*BEEEP* *BEEEP* WARNING! WARNING! *BEEEP* *BEEEP*\n"
            "This room is crap, and uses a non longer valid way of changing "
            "descriptions, if you see anything like this, be sure to bug "
            "report it.\nAlso note that \"I\" is Mithal:)\n"
	    +"There are a few other uses for the pasting function. One of "
	    +"them is to provide descriptions that change depending on "
	    +"certan variables.  In this room there is a chest.  Every other "
	    +"time you look at it, it is open.  In the code there is a "
	    +"global variable 'open' that is switched between 1 and 0 every "
	    +"time 'look_chest' is called.  The function returns 'The chest "
	    +"is open' if open == 1, else 'The chest is closed'. "
	    +"Unfortunately, the exact code cannot be put here... since the "
	    +"pasting function would work as you read the help text. *smile* "
	    +"Thus & is used in place of @ in the example code.\n"
	    +"A chest.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the chest:\n"
       +"   add_item(\"chest\",\"The Chest is \"+\n"
      +"        \"&&look_chest:\"+file_name(this_object())+\"&&\\n\");\n\n"
     +"Again, the & signs are used to represent @ signs.\n"
     +"The code for look_chest:\n\n"
     +"   string do_chest() { \n"
       +"      if( open ) { open = 0; return \"Open.\"; } \n"
       +"      open = 1;  return \"Closed!\";  } \n\n"
     +"  I think this is a much better way to deal with stuff than the famous "
     +" modify_item.\nUse and be happy!\n" }));
      add_item("chest","The chest is "+
               "@@look_chest:"+file_name(this_object())+"@@\n");
   open = 0;
   add_exit("east",PATH+"action_verbs2","path");
   add_exit("west",PATH+"action_verbs","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
string look_chest() {
   if(open) { open = 0; return "Open."; }
   open = 1; return "Closed!";
}

==================================================
FILE: learning/help_topics/rooms/add_item/func_arguments.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about the arguments of the function" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is a room telling about the arguments passed to the "
            "do_<verb>() function.  Go east for examples of using the "
            "arguments, west for something else:).\n"
            "Here goes:\n"
            "  int do_<verb>( string command, object *indir, string dir_match,\n"
            "                 string indir_match, mixed *args, string pattern );\n"
            "$I$12=command     is a string, it is the name of the verb "
             "used.$I$0=\n"
            "$I$12=indir       is an array of objects.  If any indirect "
             "objects are requested for, then they will be in this array."
             "$I$0=\n"
            "$I$12=dir_match   is a string, it is the name of the direct "
             "object.$I$0=\n"
            "$I$12=indir_match is a string, it is the name of the indirect "
             "object.$I$0=\n"
            "$I$12=args        is a mixed array of strings and numbers.  For "
             "each <> thingie you have in the pattern, it has a member.  So "
             "if you have <direct:object>, it has the name of the direct "
             "object, if you have <number> then it will have a number also, "
             "if <indirect:object>, the indirect object's name, and so on.  "
             "They are in the same order as in the pattern.$I$0=\n"
            "$I$12=pattern     is a string containing the pattern. It is "
             "useful to know which pattern has been caught since multiple "
             "patterns are allowed per function.$I$0=\n\n"
            "All do_<verb> functions in the learning domain will write their "
            "arguments, to help you figure out how to use them.\n"
            "A pool you can jump into is here.\n" );
   add_item( "large pool", ({
      "long", "It looks like you can jump into it.",
      "jump", ({ this_object(), "do_jump", "[into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"args_integer", "path" );
   add_exit( "west", PATH +"verb_patterns", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_jump( string command, object *indir, string dir_match,
            string indir_match, mixed *args, string pattern ) {
   tell_object( this_player(),
               sprintf( "$I$2=do_jump called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V into a pool!\n", ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/intro.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about simple items" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the first room about add_item(), covering simple items.\n"
            "Go east to see how to make items that can be refered to in more "
            "complicated ways.\n"
            "In your course of describing a room you often mention quite "
            "a few nouns.  In this mud we try to give every noun mentioned a "
            "description a description.  We do this with the function "
            "add_item.  For more information read the note.\n" );
   add_item( "noun", "Nouns should have descriptions." );
   add_item( "description", "Descriptions should be witty wherever reasonable." );
   add_item( "discworld", "The mud you are learning to code for." );
   add_item( "information", "See the note." );
   add_sign( "This is a note with some information, perhaps you should read "
                "it.\n",
             "For simple items like 'room' the corresponding code "
               "to represent that item is relatively easy:\n\n"
               "   add_item( \"room\", \"It is a big room.\" );  \n\n"
               "Notice that there is no newline in the description.  "
               "The mudlib adds newline when necessary.  Also "
               "notice that this is not true with set_long where a \\n is "
               "necessary at the end of the description.",
             "note", "note" );
   add_item( "room", "It is a big room." );
   add_exit( "east", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/item_conflicts.c
==================================================

#include "path.h"
inherit "/std/room";
object key;
void setup() {
   set_short( "'add_item' room telling about resolving item conflicts" );
   set_light( 100 );
   set_long( "This is the room telling about resolving item conflicts in "
            "items defined with add_item.\n"
            "This room still has some basic problems, and shouldn't be used "
            "as an example.\n"
            "Inside, add_item creates one "
            "object per room for its use and assigns an alias to each item "
            "pointing to this object.  Therefore it is likely that "
            "if you have multiple add_items with verbs that call functions "
            "you can run into problems.  In this room there is a fountain and "
            "a pool.  Both of these define 'toss'.  If the wrong function is "
            "called, then your function must return a 0 in order for the "
            "correct function to be called.  Otherwise you will have a bug!  "
            "Please look at this code and notice how each function checks to "
            "make sure that the appropriate pattern is used.  If this code "
            "were removed, then funny things would start to happen.:)\n" );
   add_item( "small fountain",
            ({ "long",
               "You can see a few platinum coins in the water.",
               "toss", ({ this_object(), "do_throw_fount",
                  "<number> platinum [coins|coin] into <direct:object>" })
            }) );
   add_item( "small pool",
            ({ "long", "You can see some silver coins lying around in the "
                       "pool.",
               "toss", ({  this_object(),"do_throw_pool",
                  "<number> silver [coins|coin] into <direct:object>" })
            }) );
   add_exit( "west", PATH + "args_object", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_success_thing( int pool, int silver, int no ) {
   string coinstr, poolstr, nocoins;
   if( no < 0 ) return 0;
   if( silver ) coinstr = "silver";
   else coinstr = "platinum";
   if( pool ) poolstr = "pool";
   else poolstr = "fountain";
   nocoins = no+" "+coinstr+" coins";
   if( no == 1 ) nocoins = "one "+coinstr+" coin";
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V "+ nocoins +" into a "+ poolstr +".\n", ({ }) );
   return 1;
}
int do_throw_pool( string command, object *indir, string dir_match,
                  string indir_match, mixed *args, string pattern ) {
   string nocoins;
   int no;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_pool called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> silver [coins|coin] into <direct:object>" )
      return do_success_thing( 1, 0, no );
   if( !do_success_thing( 1, 1, no ) ) return 0;
   tell_object( this_player(), "You throw coins!\n");
   return 1;
}
int do_throw_fount( string command, object *indir, string dir_match,
                   string indir_match, mixed *args, string pattern ) {
   int no, stored, ran;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_fount called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> platinum [coins|coin] into <direct:object>" )
      return do_success_thing( 0, 1, no );
   if( !do_success_thing( 0, 0, no ) ) return 0;
   tell_object( this_player(),  "*giggle*\n");
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/item_helper.c
==================================================

#include "path.h"
inherit "/std/room";
string pattern;
string verb;
void setup() {
   set_short("add_item room #15, Testing and creating a form ");
   set_light(100);
   set_long("add_item room #15, Testing and creating a form "
            +"This item is ment to help in the formulation of items."
	    +"it provides a way to use add_item without coding.  I "
	    +"will try to explain it.  *sigh* You can change the pattern and "
	    +"name of the verb construct seperately. And you can add items to "
	    +"this room.  The 'add an object named XXXX' command creates an "
	    +"object with the name XXXX useing the current verb and pattern.  "
	    +"Once you have added the item, you can look at it, and use the "
	    +"defined verb on it.  The verb will spit out all of the "
	    +"arguments to the function, like room 12.  In this way you can "
	    +"test verb patterns - since many of them don't work - without "
	    +"any coding.  It should help you get an idea how it all works.  "
	    +"\nA reference sheet.\nA stupid object.\n");
   add_exit("west",PATH+"item_conflicts","path");
   add_exit("north",MAIN,"path" );
      add_item("reference sheet",
	    "Pattern: Is the add_command pattern( parse_command): \n"
	    +"Example string = \" 'get' / 'take' %i \" \n"
	    +"Syntax:\n"
	    +"  'word'          obligatory text     \n"
	    +"  [word]          optional text       \n"
	    +"  /               Alternative marker  \n"
	    +"  %o              Single item, object \n"
	    +"  %l              Living objects      \n"
	    +"  %s              Any text            \n"
	    +"  %w              Any word            \n"
	    +"  %p              One of a list (prepositions)  \n"
	    +"  %i              Any items                     \n"
	    +"  %d              Number 0- or tx(0-99)         \n"
	    +"Things from add_command                         \n"
	    +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
	    +"Currently %s and %w behave a bit erradically... \n"
	    +"If you put 'text' before and after them it might help.\n"
	    +"Hope this helps!\n" );
   pattern = "%D";
   verb    = "use";
   add_item("stupid object"
      ,({
            "long",       "This object is used to create items in the room!\n"
            +" set object pattern to <pattern> \n"
	    +" name object verb to <verb> \n"
            +" query object  ( returns the current pattern and verb ) \n"
            +" add an object named <item>\n"
            ,"set"      ,({this_object(),"do_set","%D 'pattern' 'to' %s" })
	    ,"name"     ,({this_object(),"do_name","%D 'verb' 'to' %s" })
            ,"query"    ,"@@do_query:"+file_name(this_object())+"@@\n"
            ,"add"      ,({this_object(),"do_add","'an' %D 'named' %s" })
        }));
}
int do_set(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   pattern = (string) a5[1];
   return 1;
}
int do_name(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   verb = (string) a5[1];
   return 1;
}
int do_add(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   object *obs;
  add_item( a5[1]
      ,({
            "long",
	       "This object's name is: "+a5[1]
	        +"\nAnd it can be used with the pattern:"+pattern
		+":\nAnd verb:"+verb+":\n\n"
            ,verb      ,({this_object(),"do_use",pattern })
        }));
   obs = all_inventory(this_object());
   obs->move("/room/void");
    obs->move(this_object());
   this_player()->move(this_object());
   return 1;
}
string do_query()
{ return "\nPattern:"+pattern+":Verb:"+verb+":\n"; }
int  do_use(mixed a1, mixed a2, mixed a3, mixed a4, mixed a5, mixed a6)
{
  printf("\nThe Verb:(A1):  %O\nThe Objects(A2):\n%O\nDirect Object(A3):  %O\nIndirect Object(A4):  %O\nReturn Array(A5):\n%O\nPattern(A6):  %O\n\n",a1,a2,a3,a4,a5,a6);
  tell_object(this_player(),"Hope that worked...\n");
  return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/main.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "primary room for \"add_item\"" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This is the start room for the examples for add_item.  "
            "Essentially boring, since it's only here to start you on your "
            "way:)\n" );
   add_exit( "start", PATH +"intro", "path" );
   add_exit( "failure", PATH +"verb_failure", "path" );
   add_exit( "success", PATH +"verb_success", "path" );
   add_exit( "patterns", PATH +"verb_patterns", "path" );
   add_exit( "arguments", PATH +"func_arguments", "path" );
   add_exit( "args_int", PATH +"args_integer", "path" );
   add_exit( "args_string", PATH +"args_string", "path" );
   add_exit( "args_object", PATH +"args_object", "path" );
   add_exit( "helper", PATH +"item_helper", "path" );
   add_exit( "exit", LEARNING + "search", "path" );
   add_property( "commented functions", ({ "add_item" }) );
   add_property( "keywords", ({ "room", "add_item", "action", "command" }) );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_names.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about simple items with many names" );
   set_light( 100 );
   set_long( "This is the room telling about making simple items with many "
            "names.  To help as examples it's been filled with several items "
            "including a small note, candles and some chairs.  Look at the "
            "note to learn more.  Go east to learn about adding verbs to the "
            "items, and west to go to a simpler example.\n" );
   add_item( "small note",
            "Ok things get more complicated here.\n"
            "First of all, the mudlib adds the plural forms of an "
            "item you add to a room.  Thus, \n"
            "  add_item( \"candle\", \"Very nice.\" );\n"
            "will take care of both \"look at candle\" and \"look at "
            "candles\".\n"
            "Secondly, the code:\n"
            "  add_item( \"small note\", \"Ok things ... \n"
            "will take care of both \"look at note\" and \"look at small "
            "note\"\n"
            "And finally, the code:\n"
            "  add_item( ({ \"corridor\", \"long hallway\" }), "
            "\"It is long.\" );\n"
            "will take care of \"look at corridor\", \"look at hallway\", "
            "\"look at long hallway\" and even \"look at long hallways\".\n"
            "If you look at the hallways you'll see the message you get is "
            "not very good as it refers to a single hallway.  To make a "
            "different description when you look at a single "
            "item and all of them, you can use the optional third parameter "
            "to tell the mudlib it shouldn't try to add the plural form. "
            "Thus:\n"
            "  add_item( \"chair\", \"This chair looks about ready to fall "
            "over.\", 1 );\n"
            "  add_item( \"chairs\", \"The chairs look ready to fall "
            "over.\", 1 );\n"
            "Oh, one last thing when listing things in this manner as a rule "
            "of thumb, put the best description first.\n" );
   add_item( "candle", "Very nice." );
   add_item( ({ "corridor", "long hallway" }), "It is long." );
   add_item( "chair", "This chair looks about ready to fall over", 1 );
   add_item( "chairs", "The chairs look ready to fall over", 1 );
   add_item( "item", "You don't see any since noone coded one yet!" );
   add_item( "reference", "Like one that you would find in a theusaures." );
   add_item( "room", "It is a big room." );
   add_exit( "east", PATH +"verbs", "path");
   add_exit( "west", PATH +"intro", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #4, many verbs ");
   set_light(100);
   set_long( "add_item room #4, many verbs \n"
            "Sometimes you have two or more identical verbs - or at least "
            "identical in how you want to treat them.  Take our oak tree "
            "we can cut it, slice it, saw it, etc...  Now all of these have "
            "the same meaning. How do we do this?\n"
            "A large oak.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the tree:\n"
      "    add_item(\"large oak tree\", ({\n"
      "      \"long\",\n"
      "              \"It looks like it is very well protected.\"\n"
      "      ({\"cut\",\"slice\",\"saw\",\"destroy\",\"kill\" }),\n"
      "              \"It seems to have no effect.\\n\"       }});\n\n"
      "Pretty obvious hunh?  Note that kill probably does not work( I "
      "say probably cuz things might change)  That is beacuse user commands "
      "have precidence over object actions in rooms.  Also be aware that a "
      "add_action on an item that a person is holding will most likely stop "
      "your verbs from being used (unless it's coded right:).  Soul commands "
      "do not have precedence, however.  So verbs like \"pick\" which would "
      "normally say \"You pick your nose\" can be trapped appropriately.\n"
   }) );
   add_item("large oak", ({
      "long", "It looks like it is very well protected.",
      ({ "cut", "slice", "saw", "destroy", "kill" }),
        "It seems to have no effect.\n" }) );
   add_exit( "east", PATH +"action_verbs", "path");
   add_exit( "west", PATH +"verbs", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_failure.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #7, verb failure messages ");
   set_light(100);
   set_long("add_item room #7, verb failure messages\n"
            +"Let us continue with our rat.  Sometimes the general failure "
            +"message just dosn't cut it.  When the player fails to  "
            +"touch our rat, the mud should tell him/her nicely and not "
            +"let them think they messed up.  This rat does just that.  "
            +"Notice that, unlike success messages, failure messages go only "
            +"to the player - not to everyone in the room.  *smile* \n"
            +"A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     +"int  do_touch()\n"
             +"{\n"
	     +"   if(!random(2)) {\n"
	     +"       this_player()->add_failed_mess(previous_object(),\n"
	     +"                       \"You miss the rat!\\n\",\n"
	     +"                       ({})); \n"
	     +"        return 0;\n"
	     +"    }\n"
	     +"    return 1;\n"
	     +"}\n\n"
	     +"The add_failed_mess is a pretty complicated fella.  The first "
	     +"argument I beleve is the object that the verb failed on, ie "
	     +"the rat.  The second argument is the failure message. Since "
	     +"it is going only to the player, it is really simple to "
	     +"understand.  The third argument is the set of indirect "
	     +"that were used in the failing attempt.  I think you can "
	     +"reference there name in the message as %I.  But don't quote "
	     +"me on that.  Similarly %D can be used as a substution for the "
	     +"direct object, ie previous_object().  It is complicated.  "
	     +"If you stick to this form, you shouldn't have any problems.  "
	     +"If all else fails, read the help file on it. *giggle* \n" }));
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }));
   add_exit( "east", PATH +"verb_success", "path" );
   add_exit( "west", PATH +"action_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_touch() {
   if(!random(2)) {
      this_player()->add_failed_mess(previous_object(),
                                     "You miss the rat!\n",
                                     ({}));
      return 0;
   }
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_patterns.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #9, verb patterns ");
   set_light(100);
   set_long("add_item room #9, verb patterns\n"
            +"Outdated! see man add_command for patterns\n "
            +"As you guessed I am still holding out on you.  There is, "
            +"unfortunately, tons more!  Most things take the form: VERB "
            +"DIRECT_OBJECT or $V $D.  Add item has a limited number of "
            +"patterns that it can recognize, the first limitation is that "
            +"the verb must come first.  ie VERB PATTERN.  The default "
            +"pattern we have been using to date is %D.  We can change the "
            +"pattern!\nReference sheet.\nLarge pool.\nNote.\n");
   add_item("reference sheet",
            "Pattern: Is the add_command pattern( parse_command): \n"
            +"Example string = \" 'get' / 'take' %i \" \n"
            +"Syntax:\n"
            +"  'word'          obligatory text     \n"
            +"  [word]          optional text       \n"
            +"  /               Alternative marker  \n"
            +"  %o              Single item, object \n"
            +"  %l              Living objects      \n"
            +"  %s              Any text            \n"
            +"  %w              Any word            \n"
            +"  %p              One of a list (prepositions)  \n"
            +"  %i              Any items                     \n"
            +"  %d              Number 0- or tx(0-99)         \n"
            +"Things from add_command                         \n"
            +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
            +"Currently %s and %w behave a bit erradically... \n"
            +"If you put 'text' before and after them it might help.\n"
            +"Hope this helps!\n" );
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the pool:\n"
      +"  add_item(\"large pool\", ({  \n"
      +"       \"long\",\n"
      +"                   \"It looks like you can jump into it!\"\n"
      +"	,\"jump\",\n"
      +"		   ({ this_object(), \"do_jump\", \n"
      +"			\" 'into' / 'in' %D \"  })  \n"
      +"	 )} );\n\n"
      +"Ok. Not much different, just one more argument.  Look at the "
      +"reference sheet.  Looks complicated hunh?  The most useful ones "
      +"are %D, %I, %d, [text], 'text', and /.  I will demonstrate how to "
      +"use %d and %I in a few rooms.  I have also changed the succeed "
      +"mess, otherwise it would say: \"You jump into / in a large pool.\"  "
      +"Not good huh? *smile* Oh well on to the next room!\n" }));
   add_item( "large pool", ({
      "long", "It looks like you can jump into it!",
      "jump", ({ this_object(), "do_jump", " [into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"func_arguments", "path");
   add_exit( "west", PATH +"verb_success", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_jump() {
   this_player()->add_succeeded_mess(previous_object(),
                                     "$N $V into a pool!\n",  ({}));
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_success.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #8, verb success messages ");
   set_light(100);
   set_long("add_item room #8, verb success messages\n"
	    "Let us continue with our rat.  Suppose now that we want the "
	    "player to succeed - but that the default message is really "
	    "inappropriate.  What we want to do is change the succeed "
	    "message!  Let's say when the player goes to touch the rat "
	    "it tells him - As you touch the rat, it snarls. - "
	    "Unfortunately succeed messages are much more complicated "
	    "beacuse your message is going to two parties, the player and "
	    "other players in the room. So you can't put the words \"You\" and "
	    "\"touch\" directly into code, because \"Fred\" and \"touches\" are the "
	    "appropriate substitutions to be used for the audience.  "
	    "Furthermore, if you are useing "
	    "multiple verbs, how do you know what verb the person used? "
	    "The solution is to use $V for verb and $N for player name.\n"
	    "A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     "int  do_touch()\n"
             "{\n"
             "      this_player()->add_succeeded_mess(previous_object(),\n"
	     "        \"As $N $V $D, it snarls.\\n\",  ({}));\n"
	     "    return 1;\n"
	     "}\n\n"
	     "The only difference between add_failed_mess and this one is "
	     "the message: When the message is processed for the player, "
	     "\"You\" is substituted for $N and \"touch\" for $V.  Likewise, when "
	     "the message is processed for others: \"Fred\" is substituted for $N "
	     "and \"touches\" is substituted for $V.  If you were using multiple "
	     "verbs, the appropriate verb would be used.  There might be "
	     "other $ stuff in the docs( namely $D and $I if you have an "
	     "indirect object list.)  There might be ones for pronouns and "
	     "possessives also.  At last "
	     "resort, you can always make this string a null string! And "
	     "insert tell_other and tell_room call's directly in your code."
	     "Of course add_failed_mess and this one can be used together in "
	     "the same code...\n" }));
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched.",
		"touch",
                           ({ this_object(), "do_touch" }) }));
   add_exit("west",PATH+"verb_failure","path");
   add_exit("east",PATH+"verb_patterns","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int  do_touch()
{
  this_player()->add_succeeded_mess(previous_object(),
	            "As $N $V $D, it snarls.\n",  ({}));
    return 1;
}
