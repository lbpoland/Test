# Total Tokens: 119580
# Total Files Merged: 277

====
FILE: learning/common.c
==================================================

#include <config.h>
#include "path.h"
inherit "/std/room/basic_room";
#define HANDLER (LEARNING +"handlers/request")
object board;
object *chairs;
int do_claim(int);
int do_remove(int);
int do_request(string, string);
int do_sit( string command, object *indir, string dir_match,
           string indir_match, mixed *args, string pattern );
void setup() {
   set_light( 100 );
   set_short( "somewhat boring commonroom of the learning domain" );
   add_property( "determinate", "the " );
   set_long( "This is the common room of the domain of learning, the place "
            "where creators come to learn.  It is a somewhat boring room "
            "except for some chairs strewn around the place which happen to "
            "be an example of having commands defined in add_items, and some "
            "sort of list hanging on the wall which is an example of using "
            "add_command in rooms.\n" );
   add_item( "chair", ({
      "long", "This chair looks comfortable, perhaps you can sit in it.",
      "sit", ({ (: do_sit :), "[in] <direct:object>" })
   }), 1 );
   add_item( "chairs", ({
      "long", "These chairs look comfortable, "
              "perhaps you can sit in one of them.",
      "sit", ({ (: do_sit :),  "[in] <direct:object>" })
   }), 1 );
   add_item( "list",
            "This list has several actions associated with it:\n"
            "\"show list\" will show the current requests.\n"
            "\"request documentation\" will ask for "
            "documentation on something.\n"
            "\"request example\" will ask for an example of "
            "something to be coded.\n"
            "\"claim <number>\" is use to claim a request, thereby attempting "
            "to make sure that only one creator is writing the documentation/"
            "coding the examples." );
   add_exit( "entrance", PATH +"main", "path" );
   add_exit( "drum", CONFIG_START_LOCATION, "path" );
   chairs = ({ });
   add_extra_look( this_object() );
   add_property( "commented functions", ({ "add_extra_look", "extra_look",
      "remove_extra_look", "add_command" }) );
   add_property( "keywords", ({ "room", "add_item", "action" }) );
   board = clone_object( "/obj/misc/board" );
   board->set_datafile( DOMAIN );
   board->move( this_object() );
}
void init() {
   ::init();
   add_command( "show", "list" );
   add_command( "claim", "<number>", (:do_claim( $4[0] ):) );
   add_command( "request", "{documentation|example} <string'subject'>",
                (:do_request( $4[0], $4[1] ):));
   add_command( "remove", "<number>", (:do_remove( $4[0] ):) );
}
int do_show() {
   write( HANDLER->query_list() );
   return 1;
}
int do_claim( int i ) {
  if ( HANDLER->claim_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "Illegal request number.\n" );
  }
  return 1;
}
int do_remove( int i ) {
  if ( HANDLER->remove_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "You can't remove that request.\n" );
  }
  return 1;
}
int do_request( string option, string words ) {
  if ( option == "documentation" ){
      HANDLER->add_request( this_player()->query_name(),
                           "documentation for "+ words );
      write( "You request some documentation.\n");
      say( this_player()->the_short() +" requests some documentation.\n");
      return 1;
   }
  if ( option == "example") {
      HANDLER->add_request( this_player()->query_name(),
                           "examples of "+ words );
      write( "You request some example.\n");
      say( this_player()->the_short() +" requests some example.\n");
      return 1;
   }
   return 0;
}
int do_sit( string command, object *indir, string dir_match,
           string indir_match, mixed *args, string pattern ) {
   if ( dir_match == "chairs" ) {
      this_player()->add_succeeded_mess( previous_object(),
             "How can you sit on more than one chair at the same time?\n",
             ({ }) );
      return 1;
   }
   if ( member_array( this_player(), chairs ) != -1 ) {
      this_player()->add_succeeded_mess( previous_object(),
             "You are already sitting in a chair.\n", ({ }) );
      return 1;
   }
   chairs += ({ this_player() });
   this_player()->add_extra_look( this_object() );
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V in a "+ dir_match +".\n", ({ }) );
   return 1;
}
string extra_look( object thing ) {
   if ( thing == this_object() ) {
      chairs = filter_array( chairs, (: $1 != 0 :) );
      chairs = filter_array( chairs,
                            (: environment( $1 ) == this_object() :) );
      if ( !sizeof( chairs ) ) {
         return "";
      } else {
         if ( sizeof( chairs ) == 1 ) {
            if ( chairs[ 0 ] == this_player() ) {
               return "You are sitting in one of the chairs.\n";
            } else {
               return (string)chairs[ 0 ]->the_short()
                      +" is sitting in one of the chairs.\n";
            }
         } else {
            return query_multiple_short( chairs, "the" )
              +" are sitting in the chairs.\n";
         }
      }
   } else if ( member_array( thing, chairs ) != -1 ) {
      if ( environment( thing ) == this_object() ) {
         if ( thing == this_player() ) {
            return "You are sitting in a chair looking lazy.\n";
         } else {
            return thing->query_pronoun() +" is lazing around in a chair.\n";
         }
      }
   }
   thing->remove_extra_look( this_object() );
   return "";
}

==================================================
FILE: learning/function_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string function_chosen;
void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", PATH +"functions", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return function_chosen;
}
void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s",
                     exit_letter,
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/functions.c
==================================================

#include "path.h"
#include <learning.h>
#define PATH LEARNING
inherit "/std/room/basic_room";
string *functions;
int do_list();
int word();
void setup() {
   string word;
   set_short( "room of function examples" );
   add_property( "determinate", "the " );
   set_long( "This is the room that might lead you to better understanding "
            "of how to use some of the functions we have here.\n"
            "Try \"list functions\" to get a list of the functions known by "
            "the room, "
            "take the exit named by the function to get to a room with exits "
            "to the examples.\n"
            "If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n" );
   set_light( 50 );
   functions = SEARCH->query_functions();
   foreach( word in functions ) {
      add_exit( word, "??", "path" );
      modify_exit( word, ({ "obvious", 0 }) );
   }
   add_exit( "exit", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property", "set_light" }) );
   add_property( "keywords", ({ }) );
}
void init() {
  ::init();
  add_command( "list","functions");
}
int do_list() {
   write( sprintf( "The following functions have examples of use:\n%#-*s\n",
                  75, implode( functions, "\n" ) ) );
   return 1;
}
void set_destination( string word ) {
   if( word != "exit" ) {
      modify_exit( word, ({ "dest", SEARCH->find_function_room( word ) }) );
   }
}

==================================================
FILE: learning/main.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
   set_short( "entrance to learning" );
   add_property( "determinate", "the " );
   set_long( "Welcome to the entrance room of the learning domain.  "
            "The purpose of this domain is to help beginning creators, by "
            "giving examples of the way to use the different functions that "
            "are available, and show ways to solve common problems.\n"
            "To see the code used in a room or an object you can use the "
            "commands \"more here\" and \"more <object name>\" "
            "respectively.  If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n"
            "The search exit will take you to a special room with exits "
            "for each of the keywords defined in the different files in the "
            "domain, this will enable you to search for examples by "
            "selecting keywords, and is also an example of the use of "
            "virtual or cloned rooms.\n"
            "If you want to find examples of how to use specific functions, "
            "use the functions exit.\n"
            );
   set_light( 50 );
   set_co_ord( ({ 30, 0, 40 }) );
   add_exit( "search", PATH + "search", "door" );
   add_exit( "functions", PATH + "functions", "door" );
   add_exit( "common", "/w/common", "door" );
   "/w/common"->add_exit( "learning", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property", "set_light",
                   "add_exit" }) );
   add_property( "keywords", ({ "room" }) );
}

==================================================
FILE: learning/master.c
==================================================

#define LORD "taffyd"
#define DOMAIN "learning"
inherit "/std/dom/base_master";
string info = "";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int copy_with_read(string path, string euid, string func) {
  return 1;
}
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}
int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}
int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
   return LORD;
}
void set_info( string words ) {
  info = words;
  save_me();
}
string query_info() {
  return info;
}

==================================================
FILE: learning/path.h
==================================================

#include <learning.h>
#define PATH LEARNING

==================================================
FILE: learning/search.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
string *keywords;
void setup() {
   mixed search_result;
   string word;
   set_short( "primary search room" );
   add_property( "determinate", "the " );
   set_long( "Welcome to the first room for doing keyword searches.  "
            "Take an exit to narrow the search to that keyword.  If less than "
            "five rooms or objects fit the keywords there will also be exits "
            "directly to them.\n" );
   set_light( 50 );
   search_result = SEARCH->get_keywords( ({ }) );
   keywords = search_result[ 0 ];
   foreach( word in keywords ) {
      add_exit( word, "??", "path" );
   }
   add_exit( "exit", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "add_exit", "set_destination" }) );
   add_property( "keywords", ({ "virtual", "room" }) );
   add_property( "no map", 1 );
}
void set_destination( string keyword ) {
   if( member_array( keyword, ({ "exit", "back", "a", "b", "c", "d", "e" }) ) != -1 )
      return;
   modify_exit( keyword, ({ "dest", SEARCH->find_room( ({ keyword }) ) }) );
}

==================================================
FILE: learning/search_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string marker, *keywords, *exits;
void setup() {
   set_short( "uninitialised search room" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", LEARNING +"search", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return marker;
}
string *query_keywords() {
   if( !keywords ) {
      return ({ });
   }
   return keywords;
}
void set_marker( string word, string *words ) {
   mixed search_result;
   string description, exit;
   int i;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   marker = word;
   keywords = words;
   description ="You are in one of the search rooms of the learning domain "
                "and you have chosen the word"+
                ({ " \"", "s \"" })[ sizeof( words ) > 1 ] + word +"\" so far.";
   search_result = SEARCH->get_keywords( words );
   exits = search_result[ 0 ];
   if( sizeof( exits ) ) {
      description += "  Take one of the keyword exits to narrow the search to "
                     "include that keyword.";
      foreach( word in exits ) {
         add_exit( word, "/??", "path" );
      }
   }
   description += "\n";
   if( sizeof( search_result[ 1 ] ) < 6 ) {
      description += "$I$5=Take one of the numbered exits to go to that room.";
      for( i = 0; i < sizeof( search_result[ 1 ] ); i++ ) {
         exit = sprintf( "%s: %s", ({ "1", "2", "3", "4", "5" })[ i ],
                        MAP->query_short( search_result[ 1 ][ i ] ) );
         add_exit( ({ "1", "2", "3", "4", "5" })[ i ],
                  search_result[ 1 ][ i ], "path" );
         description += "\n$C$"+ exit +".";
      }
      description += "$I$0=\n";
   }
   set_long( description );
}
void set_destination( string keyword ) {
   if( member_array( keyword, exits ) != -1 ) {
      modify_exit( keyword, ({ "dest",
         SEARCH->find_room( keywords + ({ keyword }) ) }) );
   }
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_room", keywords });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/help_topics/error_messages/arg_missing_type.c
==================================================

void bing(int) {
}

==================================================
FILE: learning/help_topics/error_messages/arr_index.c
==================================================

void bing() {
    ({ })[1];
}

==================================================
FILE: learning/help_topics/error_messages/bad_break.c
==================================================

void bing() {
    break;
}

==================================================
FILE: learning/help_topics/error_messages/bad_continue.c
==================================================

void bing() {
    continue;
}

==================================================
FILE: learning/help_topics/error_messages/bad_for_init.c
==================================================

void bing() {
    for (int x += 1; ; ) ;
}

==================================================
FILE: learning/help_topics/error_messages/bad_foreach.c
==================================================

void bing() {
    foreach (x in ({})) ;
}

==================================================
FILE: learning/help_topics/error_messages/bad_init.c
==================================================

int x += 1;

==================================================
FILE: learning/help_topics/error_messages/bad_local_init.c
==================================================

void bing() {
    int x += 1;
}

==================================================
FILE: learning/help_topics/error_messages/bad_local_init2.c
==================================================

void bing() {
    int x = "hi";
}

==================================================
FILE: learning/help_topics/error_messages/bad_param.c
==================================================

void bing() {
    (: $-1 :);
}

==================================================
FILE: learning/help_topics/error_messages/bad_param2.c
==================================================

void bing() {
    (: $1000 :);
}

==================================================
FILE: learning/help_topics/error_messages/bad_return.c
==================================================

void bing() {
    return 1;
}

==================================================
FILE: learning/help_topics/error_messages/bad_return2.c
==================================================

int bing() {
    return "hi";
}

==================================================
FILE: learning/help_topics/error_messages/bad_type_init.c
==================================================

int x = "hi";

==================================================
FILE: learning/help_topics/error_messages/class_redef.c
==================================================

class bing {
}
class bing {
}

==================================================
FILE: learning/help_topics/error_messages/div_zero.c
==================================================

void bing(mixed x) {
    switch(x) {
    case 1 / 0:
    }
}

==================================================
FILE: learning/help_topics/error_messages/div_zero3.c
==================================================

int bing() {
    return 1/0.0;
}

==================================================
FILE: learning/help_topics/error_messages/eof_in_comment.c
==================================================

/* Comments have to stop as well as start

==================================================
FILE: learning/help_topics/error_messages/eof_in_string.c
==================================================

void create() {
    "
}

==================================================
FILE: learning/help_topics/error_messages/local_redef.c
==================================================

void bing(int x) {
    int x;
}

==================================================
FILE: learning/help_topics/error_messages/local_redef2.c
==================================================

void bing() {
    int x;
    {
	int x;
    }
}

==================================================
FILE: learning/help_topics/error_messages/lvar_func.c
==================================================

void bing() {
    int x;
    (: x :);
}

==================================================
FILE: learning/help_topics/error_messages/lvar_func2.c
==================================================

void bing() {
    int x;
    (: x + 1 :);
}

==================================================
FILE: learning/help_topics/error_messages/missing_arg_type.c
==================================================

void bing(x) {
}

==================================================
FILE: learning/help_topics/error_messages/missing_endif.c
==================================================

#if 1

==================================================
FILE: learning/help_topics/error_messages/missing_type.c
==================================================

bing;

==================================================
FILE: learning/help_topics/error_messages/mixed_case.c
==================================================

void bing(mixed x) {
    switch (x) {
    case 1:
    case "hi":
    }
}

==================================================
FILE: learning/help_topics/error_messages/mod_zero.c
==================================================

void bing(mixed x) {
    switch(x) {
    case 1 % 0:
    }
}

==================================================
FILE: learning/help_topics/error_messages/no_member.c
==================================================

class bing {
    int x;
}
void bing() {
    bing y;
    y->z;
}

==================================================
FILE: learning/help_topics/error_messages/no_ret_type.c
==================================================

#pragma strict_types
bing() {
}

==================================================
FILE: learning/help_topics/error_messages/no_such_class.c
==================================================

void bing() {
    new(class bing);
}

==================================================
FILE: learning/help_topics/error_messages/predef.c
==================================================

#undef __VERSION__

==================================================
FILE: learning/help_topics/error_messages/redef_function.c
==================================================

void bing() {
}
void bing() {
}

==================================================
FILE: learning/help_topics/error_messages/static_local.c
==================================================

void main() {
    nosave int x = 5;
}

==================================================
FILE: learning/help_topics/error_messages/string_case.c
==================================================

void bing() {
    switch ("hi") {
    case "bing".."bar":
    }
}

==================================================
FILE: learning/help_topics/error_messages/two_default.c
==================================================

void bing() {
    switch (1) {
    default:
    default:
    }
}

==================================================
FILE: learning/help_topics/error_messages/undef_class.c
==================================================

class bing x;

==================================================
FILE: learning/help_topics/error_messages/var_to_nonvar.c
==================================================

void bing(int x) {
}
void bar() {
    bing( ({ })...);
}

==================================================
FILE: learning/help_topics/error_messages/void_arg.c
==================================================

void bing(void x) {
}

==================================================
FILE: learning/help_topics/error_messages/void_arg2.c
==================================================

void bing(void);

==================================================
FILE: learning/help_topics/error_messages/void_for_var.c
==================================================

void bing() {
    for (void x = 1; ; ) ;
}

==================================================
FILE: learning/help_topics/error_messages/void_global.c
==================================================

void x;

==================================================
FILE: learning/help_topics/error_messages/void_local.c
==================================================

void bing() {
    void x;
}

==================================================
FILE: learning/help_topics/error_messages/void_member.c
==================================================

class bing {
    void x;
}

==================================================
FILE: learning/help_topics/npcs/make_person.c
==================================================

#include "path.h";
inherit "/std/room";
object red_demon;
void setup() {
   set_short( "room telling about adding NPC's" );
   add_property( "determinate", "the " );
   set_long( "This is a room showing how to add a stationary NPC to a room.  "
            "If you try to \"update here\" you will see that it waits a few "
            "seconds after loading the room before adding the NPC and, that "
            "when it appears there are a message notifying the player about "
            "it.\n" );
   set_light( 60 );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property",
                   "set_light", "reset" }) );
   add_property( "keywords", ({ "npc", "clone", "permanent", "make" }) );
}
void reset() {
   if ( !red_demon ) {
      call_out( "make_demon", 5 );
   }
}
void make_demon() {
   red_demon = clone_object( "/obj/monster" );
   red_demon->set_name( "imp" );
   red_demon->set_short( "small red imp" );
   red_demon->add_adjective( ({ "small", "red" }) );
   red_demon->set_long( "This is a small red imp who has agreed to be used "
                       "as an example.\n" );
   red_demon->set_base_weight( 10 );
   red_demon->set_height( 17 );
   red_demon->set_race( "imp" );
   red_demon->set_level( 1 );
   red_demon->move( this_object(), "$N materialize$s with a small *POP*." );
}

==================================================
FILE: learning/help_topics/npcs/path.h
==================================================

#include <learning.h>
#define PATH HELP + "npcs/"

==================================================
FILE: learning/help_topics/rooms/path.h
==================================================

#include <learning.h>
#define PATH HELP + "rooms/"

==================================================
FILE: learning/help_topics/rooms/terrains/foyer.c
==================================================

#include "path.h"
inherit "/std/room";
object teacher;
object sign;
void setup() {
   set_short( "foyer of the terrain school" );
   add_property( "determinate", "the " );
   set_long( "This is the foyer to the terrain teacher's school.  "
      "The walls here are hung with beautiful landscapes of complex tracts "
      "of land, and beneath each landscape is a map of some kind.  "
      "An intricate chandelier hangs from the ceiling, casting an even "
      "glow on all the landscapes.  "
      "Comfortable benches line the walls here, with small tables "
      "between them.  "
      "The floor is covered with a plush green carpet, which would be nice "
      "if not for the heavy mud stains across it.\n" );
   add_item( "landscape",
      "The landscapes show mountains, jungles, forests, "
      "oceans, rivers... all sorts of different terrains, including a "
      "city and a village." );
   add_item( "map",
      "Beneath each landscape hangs a single topographical "
      "map which appears to be a detailed representation of the landscape "
      "above it." );
   add_item( "chandelier",
      "Crystal teardrops scatter the light of a dozen "
      "candles around the room, casting an easy, comfortable light by which "
      "you can see.", 1 );
   add_item( "crystal teardrop",
      "The candlelight makes it too hard to see "
      "the crystals clearly." );
   add_item( "candle",
      "Nestled into the midst of the chandelier, the twelve "
      "candles provide all the light in this room.");
   add_item( "bench",
     ({ "long", "These wooden benches have comfortable leather cushions "
           "firmly attached.",
        "position", "a wooden bench",
     }) );
   add_item( "table",
     ({ "long", "These tables are covered with magazines talking "
           "about far away places and exotic architecture.",
        "position", "a table",
     }) );
   add_item( "plush green carpet",
      "This deep pile carpet was once a rich evergreen colour, but "
      "years of muddy footprints have stained much of it a deep, "
      "ugly brown." );
   add_item( "mud stains",
      "Someone has b een walking on this formerly beautiful carpet with "
      "muddy boots." );
   add_item( "cushions",
      "Thick leather cushions, stuffed with something very soft, and "
      "affixed quite securely to the benches." );
   add_item( "magazines",
     ({ "long", "Architectural and travel magazines sit on the "
           "various tables around the room.",
        "read", "\"Ruins of The Temple of Offler!\", "
           "\"Beautiful Ankh-Morpork!\", \"Design of the Tower of Art\", "
           "and \"Scenic Ramtops Vacations!\" are just the most visible "
           "of the titles that scream up at you.  Hopefully the "
           "magazines are kept just for their pictures, which seem far "
           "more interesting than their text.",
     }) );
   set_light( 60 );
   add_exit( "grassyfield", PATH "grassystep", "hidden" );
   add_exit( "desert", PATH "sandtent", "hidden" );
   add_exit( "mountaintop", PATH "mountaincabin", "hidden" );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({  }) );
   add_property( "keywords",
                ({ "terrain" }) );
   sign = add_sign(
      "A cardboard sign, with text scrawled messily across the front.\n",
      "Awye FRoM TH OFFICe",
      "cardboard sign",
      "sign",
      "common" );
   if (sign) sign->set_get();
}
void init() {
   if ( !this_player() )
      return;
   if ( !interactive( this_player() ) )
      return;
   if (!teacher) {
      teacher = load_object( CHARS "terrain_teacher" );
   }    if ( teacher ) {
      teacher->pupil_arrived( this_object() );
   }
}

==================================================
FILE: learning/help_topics/rooms/terrains/grassyfield.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain("tutorial_grassy_field");
   set_short("grassy field");
   set_long("This field is covered with nicely mowed grass.\n");
   add_item("grass", "It's grass.  There isn't much to say about it.");
}

==================================================
FILE: learning/help_topics/rooms/terrains/grassystep.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_grassy_field" );
   set_short( "doorstep");
   set_long( "This is the doorstep to a small cottage.  All around "
            "here is a field covered with nicely cut grass.\n" );
   add_item( "grass", "It's grass.  There isn't much to say about it." );
   add_item( "cottage", "A plain, one-room cottage, painted white, "
            "with pink shutters on both the windows.  *hack* *cough*" );
   add_exit( "cottage", PATH "foyer", "corridor" );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountainbedroom.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "mountain cabin attic" );
   set_long( "This is the second floor of a comfortable mountain cabin.  "
            "The bed occupying most of this room would seem to indicate "
            "that this is a bedroom.\n" );
   add_item( "bed", ({
      "long", "A big king-sized bed with a nice, thick, comforter on top.",
      "position", "the bed" }), 0 );
   add_item( "comforter",
      "This thick quilted comforter is made of some "
      "soft cotton fabric sandwiching a thick layer of down.");
   set_light( 50 );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountaincabin.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "rustic mountain cabin" );
   set_long( "This is the ground floor of a comfortable mountain cabin, "
      "complete with walls made of chinked logs, a bearskin rug, "
      "a huge, comfy sofa, and a bare lumber staircase leading "
      "up and down.  Unfortunately, since someone forgot to put a "
      "front door on this place, it's damned cold in here.\n" );
   add_item( ({ "log", "wall" }),
      "Formed of whole logs, sanded to a satin "
      "finish, laid together, and with the gaps chinked with mud." );
   add_item( "bearskin rug", ({
      "long", "Looks like a large blackbear gave his life that you can be "
         "comfortable lying before the fire.",
      "position", "the rug" }), 0 );
   add_item( "comfy sofa", ({
      "long", "Not very sophisticated, but it sure looks comfortable.",
      "position", "the sofa" }), 0 );
   set_light( 50 );
   room_chat( ({ 100, 300,
      ({ "A chill wind blows some snow in through the open doorway.",
         "A sudden shiver runs down your spine.",
         "Maybe you should have packed some cold weather gear?",
         "Oh, a mug of hot cocoa would about hit the spot right now."
      }) }) );
   add_exit( "down", PATH "foyer", "stair" );
}
string query_exit_type( string direc, string dest) {
   if (direc == "up" || direc == "down")
      return "stair";
   else if (direc == "west")
      return "corridor";
   else
      return "none";
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountainsnows.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "the snowy wastes" );
   add_property( "determinate", "" );
   set_long( "This snow covered land is swept by strong winds night and "
            "day.  No trees can stand the harsh climate.\n" );
   add_item( "tree", "No, I said there _weren't_ any trees." );
   add_property( "climate", ({ -40, 50, 40 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountaintree.c
==================================================

#include "path.h"
#include <terrain.h>
inherit "/std/outside";
void setup() {
   set_room_size( 20 );
   set_terrain( "tutorial_mountain" );
   set_short( "tree in the mountains" );
   set_long( "This tree has defied all the odds, and grows straight and "
            "tall in the blustery wastes." );
   add_extra_look( this_object() );
   add_property( "climate", ({ -40, 50, 40 }) );
}
string extra_look() {
   if ( co_ord[ 2 ] < 800200 )
      return "\n";
   else
      return "  You can just make out a cabin in the snows to your "
             "northeast.\n";
}

==================================================
FILE: learning/help_topics/rooms/terrains/path.h
==================================================

#include <learning.h>
#define PATH HELP +"rooms/terrains/"
#define MAIN PATH +"main"

==================================================
FILE: learning/help_topics/rooms/terrains/sanddunes.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "sandy wasteland" );
   set_long( "This is just one small section of an endless "
            "expanse of sand.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it.");
   add_property( "climate", ({ 40, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/sandoasis.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "desert oasis" );
   set_long( "The trees in this oasis provide welcome relief from the harsh "
            "sunlight of the desert.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it other than "
      "that it's much moister here than elsewhere in the desert." );
   add_item( "tree",
      "The palm trees grow majestically all around you, "
      "providing all the shade you could want." );
   add_property( "climate", ({ 10, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/sandtent.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "outside tent" );
   set_long( "This is just outside the front flap of a canvas tent, set "
      "in the middle of a huge desert waste.  Nothing but sand as far "
      "as the eye can see.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it." );
   add_item( "tent",
      "This is a plain, white canvas tent, that reflects the harsh "
      "glare of the sun harmlessly away from its occupants." );
   add_exit( "tent", PATH "foyer", "corridor" );
   add_property( "climate", ({ 40, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/add_item/action_verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about making verbs do stuff" );
   set_light(100);
   set_long( "This is the room telling about making verbs do stuff.\n"
            "Let's say you have a rat in a room and randomly (let's say one "
            "out of two times) want to let players touch it.\n"
            "Read the ratnote to get an explanation of what happens when "
            "you touch the rat.\n"
            "There is a rat on the floor and a ratnote on the wall.\n");
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }) );
   add_item( "ratnote", ({
      "long", "It can be read.",
      "read", "When the rat is touched, do_touch() is called.  The do_touch() "
         "function must return an integer - If the touch was successful it "
         "returns a 1, if the touch failed the function should return a 0.\n"
         "Note also that a success message is given to all in the room.  But, "
         "if the person fails, the add_item code looks for more matches - "
         "thinking that the function do_touch is the wrong one.  If there is "
         "no other function found that defines touching rats and that returns "
         "a 1, then the game returns the message 'You fail to touch a rat'.\n"
         "The this_object() reference tells the add_item code what object is "
         "the direct object of the verb.  Just trust me, and leave it in your "
         "code without asking why for now.  It is one of those things that "
         "can give you more flexibility later on.\n" }) );
   add_exit( "east", PATH +"verb_failure", "path" );
   add_exit( "west", PATH +"many_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_touch() {
   if( random(2) ) {
      tell_object( this_player(), "\n ****  You feel deathly sick. ****\n"
                  " (this is a tell_object(this_player(),...))\n" );
      tell_object( this_player(),
                  "do_touch is returning a 0, indicating failure!\n" );
      return 0;
   }
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/action_verbs2.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #6, making verbs do stuff, better version ");
   set_light(100);
   set_long("add_item room #6, making verbs do stuff, better version\n"
	    +"There are two ways to call a function if a verb is used.  "
	    +"This room demonstrates the second one.  "
       	    +"Lets say you have a rat in a room and randomly ( one out of "
	    +"two times lets say ) want to let players touch it. "
	    +"This is how you could do it.\n"
	    +"A filthy rat and a can.\nA ratnote and a cannote.\n");
   add_item("ratnote", ({ "long", "It can be read.",
		       "read", "Here is the code for the rat:\n"
     +"   add_item(\"large filthy rat\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"do_touch\" }) }) );  \n"
     +"When the rat is touched, do_touch() is called.  The do_touch() func "
     +"must return an integer - If the touch was successful it returns a 1, "
     +"if the touch failed the function should return a 0.  Note that a "
     +"success message is given to all in the room.  But, if the person fails "
     +"the add_item code looks for more matches - thinking that the func "
     +"do_touch is the wrong one.  If there is no other function found that "
     +"defines touching rats and that returns a 1, then the game returns the "
     +"message 'You fail to touch a rat'.\n"
     +"The this_object() refrence tells the add_item code what object is "
     +"the direct object of the verb.  Just trust me, and leave it in your "
     +"code without asking why for now.  It is one of those things that can "
     +"give you more flexibility later on.\n" }));
   add_item("dirty can", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "always_fail" })
                   }));
   add_item("cannote", ({ "long", "It can be read.",
		          "read", "Here is the code for the can:\n"
     +"   add_item(\"dirty can\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"always_fail\" }) }) );  \n"
     +"When the can is touched, always_fail() is called.  This function "
     +"looks like this:\n int always_fail() { return 0; }\n"
     +"in this way if you want a person to be able to use a verb on an "
     +"object, but want to be lazy - and don't want the action to succeed "
     +"( such as a door that can't be broken down ) this is the way to do "
     +"it.\nPlease read ratnote also, if you havn't.\n" }));
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "do_touch" })
                   }));
   add_exit("east",ROOM+"verb_failure","door");
   add_exit("west",ROOM+"changing_descs","door");
   add_exit("north",MAIN,"door" );
 }
int  do_touch()
{
  if( random(2) ) {
      tell_object(this_player(),"\n ****  You feel deathly sick. ****\n  "
		              "(this is a tell_object(this_player(),...)) \n");
      tell_object(this_player(),
		  "do_touch is returning a 0, indicating failure!\n");
      return 0;
    }
    return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_char.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #12, Getting character arguments ");
   set_light(100);
   set_long("add_item room #12, Getting character arguments\n"
	    +"There is a large stone in the middle of the room.  It looks as "
	    +"if you can engrave your name onto it.\nSource code.\n");
   add_item("large stone", ({
	        "long",
	                   "It can be engraved."
		,"engrave",
			   ({ this_object(), "do_engrave",
				"'into' %D 'the' text' %s"  })
	}));
   add_item("source code", ({ "long",
         "It looks like some source code."
         ,"read",
         "The source code:\n"
+"\n"
+"   add_item(\"large stone\", ({\n"
+"	        \"long\",\n"
+"	                   \"It can be engraved.\"\n"
+"		,\"engrave\",\n"
+"			   ({ this_object(), \"do_engrave\",\n"
+"				\"'into' %D 'the' text' %s\"  })\n"
+"	}));\n"
+"\n\nRead also:  do_engrave\n" }));
   add_item("do_engrave", ({ "long",
         "It looks like some source code."
         ,"read",
         "The source code:\n"
+"int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)\n"
+"{\n"
+"     string mess;\n"
+"        mess =  \"$N $V \"+a5[1]+\" into \"+a3+\".\\n\";\n"
+"        this_player()->add_succeeded_mess(previous_object(),\n"
+"					        mess,\n"
+"					        ({}));\n"
+"        return 1;\n"
+"}\n"
+"\n" }));
   add_exit("east",ROOM+"args_object","door");
   add_exit("west",ROOM+"args_integer","door");
   add_exit("north",MAIN,"door" );
 }
int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
     string mess;
        mess =  "$N $V "+a5[1]+" into "+a3+".\n";
        this_player()->add_succeeded_mess(previous_object(),
					        mess,
					        ({}));
        return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_integer.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about getting integer arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting integer arguments from a "
            "command defined with add_item.  Go east to learn about getting "
            "string arguments, west to learn about the arguments passed "
            "to the function called when you do the command.\n"
            "This room is filled with an uncountable number of rats.  They "
            "all have numbers branded into them.  You can dissolve a rat if "
            "you know its number.\n" );
   add_item( "large filthy rat", ({
      "long", "The rats look vile.",
      "dissolve", ({ this_object(), "do_dissolve",
         "<direct:object> [no|number] <number>" })
   }) );
   add_exit( "east", PATH +"args_string", "path");
   add_exit( "west", PATH +"func_arguments", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_dissolve( string command, object *indir, string dir_match,
                string indir_match, mixed *args, string pattern ) {
   string mess;
   tell_object( this_player(),
               sprintf( "$I$2=do_dissolve called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   mess =  "$N $V "+ dir_match +" number "+ args[ 1 ] +".\n";
   this_player()->add_succeeded_mess( previous_object(),
                                      mess, ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_object.c
==================================================

#include "path.h"
inherit "/std/room";
object key;
void setup() {
   set_short( "'add_item' room telling about getting the object as argument" );
   set_light(100);
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "string arguments, west to see about item conflicts.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can unlock it if you have the correct key.\n" );
   add_item( "large stone", ({
      "long","It can be unlocked.",
      "unlock", ({ this_object(), "do_unlock",
         "<direct:object> [with] <indirect:object>" })
   }) );
   add_exit( "east", PATH +"item_conflicts", "path" );
   add_exit( "west", PATH +"args_string", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_unlock( string command, object *indir, string dir_match,
               string indir_match, mixed *args, string pattern ) {
   object ob;
   tell_object( this_player(),
               sprintf( "$I$2=do_unlock called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   this_player()->add_failed_mess( previous_object(),
                                  "You don't have the correct key.\n", ({ }) );
   ob = indir[ 0 ];
   if( (int) ob->query_property( "Mithal" ) != 1 ) {
      write( "wrong key\n" );
      return 0;
   }
   this_player()->add_succeeded( ob );
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V the stone with $I.\n",
                                     ({ ob }));
   write( "You succeeded!\n" );
   return 1;
}
void reset() {
   call_out( "check_key", 2 );
}
void check_key() {
   if( !key ) {
      key = clone_object( "std/object" );
      key->set_name( "key" );
      key->set_short( "Mithal's key" );
      key->add_property( "Mithal", 1 );
      key->move( this_object(), "Mithal sneaks through the room, "
                "dropping $N in the process." );
   }
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_string.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about getting string arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "object arguments, west to see about integer arguments.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can engrave your name onto it.\n");
   add_item( "large stone",
            ({ "long", "It can be engraved.",
               "engrave", ({ this_object(), "do_engrave",
                  "[the text] <string> [into] [the] <direct:object>" })
            }) );
   add_exit( "east", PATH +"args_object", "path");
   add_exit( "west", PATH +"args_integer", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_engrave( string command, object *indir, string dir_match,
               string indir_match, mixed *args, string pattern ) {
   string mess;
   tell_object( this_player(),
               sprintf( "$I$2=do_engrave called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   mess =  "$N $V \""+ args[ 0 ] +"\" into "+ dir_match +".\n";
   this_player()->add_succeeded_mess( previous_object(), mess, ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/changing_descs.c
==================================================

#include "path.h"
inherit "/std/room";
int open;
void setup() {
   set_short("add_item room #5b, item descriptions that change with time");
   set_light(100);
   set_long("add_item room #5b, item description that change with time\n"
            "*BEEEP* *BEEEP* WARNING! WARNING! *BEEEP* *BEEEP*\n"
            "This room is crap, and uses a non longer valid way of changing "
            "descriptions, if you see anything like this, be sure to bug "
            "report it.\nAlso note that \"I\" is Mithal:)\n"
	    +"There are a few other uses for the pasting function. One of "
	    +"them is to provide descriptions that change depending on "
	    +"certan variables.  In this room there is a chest.  Every other "
	    +"time you look at it, it is open.  In the code there is a "
	    +"global variable 'open' that is switched between 1 and 0 every "
	    +"time 'look_chest' is called.  The function returns 'The chest "
	    +"is open' if open == 1, else 'The chest is closed'. "
	    +"Unfortunately, the exact code cannot be put here... since the "
	    +"pasting function would work as you read the help text. *smile* "
	    +"Thus & is used in place of @ in the example code.\n"
	    +"A chest.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the chest:\n"
       +"   add_item(\"chest\",\"The Chest is \"+\n"
      +"        \"&&look_chest:\"+file_name(this_object())+\"&&\\n\");\n\n"
     +"Again, the & signs are used to represent @ signs.\n"
     +"The code for look_chest:\n\n"
     +"   string do_chest() { \n"
       +"      if( open ) { open = 0; return \"Open.\"; } \n"
       +"      open = 1;  return \"Closed!\";  } \n\n"
     +"  I think this is a much better way to deal with stuff than the famous "
     +" modify_item.\nUse and be happy!\n" }));
      add_item("chest","The chest is "+
               "@@look_chest:"+file_name(this_object())+"@@\n");
   open = 0;
   add_exit("east",PATH+"action_verbs2","path");
   add_exit("west",PATH+"action_verbs","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
string look_chest() {
   if(open) { open = 0; return "Open."; }
   open = 1; return "Closed!";
}

==================================================
FILE: learning/help_topics/rooms/add_item/func_arguments.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about the arguments of the function" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is a room telling about the arguments passed to the "
            "do_<verb>() function.  Go east for examples of using the "
            "arguments, west for something else:).\n"
            "Here goes:\n"
            "  int do_<verb>( string command, object *indir, string dir_match,\n"
            "                 string indir_match, mixed *args, string pattern );\n"
            "$I$12=command     is a string, it is the name of the verb "
             "used.$I$0=\n"
            "$I$12=indir       is an array of objects.  If any indirect "
             "objects are requested for, then they will be in this array."
             "$I$0=\n"
            "$I$12=dir_match   is a string, it is the name of the direct "
             "object.$I$0=\n"
            "$I$12=indir_match is a string, it is the name of the indirect "
             "object.$I$0=\n"
            "$I$12=args        is a mixed array of strings and numbers.  For "
             "each <> thingie you have in the pattern, it has a member.  So "
             "if you have <direct:object>, it has the name of the direct "
             "object, if you have <number> then it will have a number also, "
             "if <indirect:object>, the indirect object's name, and so on.  "
             "They are in the same order as in the pattern.$I$0=\n"
            "$I$12=pattern     is a string containing the pattern. It is "
             "useful to know which pattern has been caught since multiple "
             "patterns are allowed per function.$I$0=\n\n"
            "All do_<verb> functions in the learning domain will write their "
            "arguments, to help you figure out how to use them.\n"
            "A pool you can jump into is here.\n" );
   add_item( "large pool", ({
      "long", "It looks like you can jump into it.",
      "jump", ({ this_object(), "do_jump", "[into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"args_integer", "path" );
   add_exit( "west", PATH +"verb_patterns", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_jump( string command, object *indir, string dir_match,
            string indir_match, mixed *args, string pattern ) {
   tell_object( this_player(),
               sprintf( "$I$2=do_jump called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V into a pool!\n", ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/intro.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about simple items" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the first room about add_item(), covering simple items.\n"
            "Go east to see how to make items that can be refered to in more "
            "complicated ways.\n"
            "In your course of describing a room you often mention quite "
            "a few nouns.  In this mud we try to give every noun mentioned a "
            "description a description.  We do this with the function "
            "add_item.  For more information read the note.\n" );
   add_item( "noun", "Nouns should have descriptions." );
   add_item( "description", "Descriptions should be witty wherever reasonable." );
   add_item( "discworld", "The mud you are learning to code for." );
   add_item( "information", "See the note." );
   add_sign( "This is a note with some information, perhaps you should read "
                "it.\n",
             "For simple items like 'room' the corresponding code "
               "to represent that item is relatively easy:\n\n"
               "   add_item( \"room\", \"It is a big room.\" );  \n\n"
               "Notice that there is no newline in the description.  "
               "The mudlib adds newline when necessary.  Also "
               "notice that this is not true with set_long where a \\n is "
               "necessary at the end of the description.",
             "note", "note" );
   add_item( "room", "It is a big room." );
   add_exit( "east", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/item_conflicts.c
==================================================

#include "path.h"
inherit "/std/room";
object key;
void setup() {
   set_short( "'add_item' room telling about resolving item conflicts" );
   set_light( 100 );
   set_long( "This is the room telling about resolving item conflicts in "
            "items defined with add_item.\n"
            "This room still has some basic problems, and shouldn't be used "
            "as an example.\n"
            "Inside, add_item creates one "
            "object per room for its use and assigns an alias to each item "
            "pointing to this object.  Therefore it is likely that "
            "if you have multiple add_items with verbs that call functions "
            "you can run into problems.  In this room there is a fountain and "
            "a pool.  Both of these define 'toss'.  If the wrong function is "
            "called, then your function must return a 0 in order for the "
            "correct function to be called.  Otherwise you will have a bug!  "
            "Please look at this code and notice how each function checks to "
            "make sure that the appropriate pattern is used.  If this code "
            "were removed, then funny things would start to happen.:)\n" );
   add_item( "small fountain",
            ({ "long",
               "You can see a few platinum coins in the water.",
               "toss", ({ this_object(), "do_throw_fount",
                  "<number> platinum [coins|coin] into <direct:object>" })
            }) );
   add_item( "small pool",
            ({ "long", "You can see some silver coins lying around in the "
                       "pool.",
               "toss", ({  this_object(),"do_throw_pool",
                  "<number> silver [coins|coin] into <direct:object>" })
            }) );
   add_exit( "west", PATH + "args_object", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_success_thing( int pool, int silver, int no ) {
   string coinstr, poolstr, nocoins;
   if( no < 0 ) return 0;
   if( silver ) coinstr = "silver";
   else coinstr = "platinum";
   if( pool ) poolstr = "pool";
   else poolstr = "fountain";
   nocoins = no+" "+coinstr+" coins";
   if( no == 1 ) nocoins = "one "+coinstr+" coin";
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V "+ nocoins +" into a "+ poolstr +".\n", ({ }) );
   return 1;
}
int do_throw_pool( string command, object *indir, string dir_match,
                  string indir_match, mixed *args, string pattern ) {
   string nocoins;
   int no;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_pool called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> silver [coins|coin] into <direct:object>" )
      return do_success_thing( 1, 0, no );
   if( !do_success_thing( 1, 1, no ) ) return 0;
   tell_object( this_player(), "You throw coins!\n");
   return 1;
}
int do_throw_fount( string command, object *indir, string dir_match,
                   string indir_match, mixed *args, string pattern ) {
   int no, stored, ran;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_fount called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> platinum [coins|coin] into <direct:object>" )
      return do_success_thing( 0, 1, no );
   if( !do_success_thing( 0, 0, no ) ) return 0;
   tell_object( this_player(),  "*giggle*\n");
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/item_helper.c
==================================================

#include "path.h"
inherit "/std/room";
string pattern;
string verb;
void setup() {
   set_short("add_item room #15, Testing and creating a form ");
   set_light(100);
   set_long("add_item room #15, Testing and creating a form "
            +"This item is ment to help in the formulation of items."
	    +"it provides a way to use add_item without coding.  I "
	    +"will try to explain it.  *sigh* You can change the pattern and "
	    +"name of the verb construct seperately. And you can add items to "
	    +"this room.  The 'add an object named XXXX' command creates an "
	    +"object with the name XXXX useing the current verb and pattern.  "
	    +"Once you have added the item, you can look at it, and use the "
	    +"defined verb on it.  The verb will spit out all of the "
	    +"arguments to the function, like room 12.  In this way you can "
	    +"test verb patterns - since many of them don't work - without "
	    +"any coding.  It should help you get an idea how it all works.  "
	    +"\nA reference sheet.\nA stupid object.\n");
   add_exit("west",PATH+"item_conflicts","path");
   add_exit("north",MAIN,"path" );
      add_item("reference sheet",
	    "Pattern: Is the add_command pattern( parse_command): \n"
	    +"Example string = \" 'get' / 'take' %i \" \n"
	    +"Syntax:\n"
	    +"  'word'          obligatory text     \n"
	    +"  [word]          optional text       \n"
	    +"  /               Alternative marker  \n"
	    +"  %o              Single item, object \n"
	    +"  %l              Living objects      \n"
	    +"  %s              Any text            \n"
	    +"  %w              Any word            \n"
	    +"  %p              One of a list (prepositions)  \n"
	    +"  %i              Any items                     \n"
	    +"  %d              Number 0- or tx(0-99)         \n"
	    +"Things from add_command                         \n"
	    +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
	    +"Currently %s and %w behave a bit erradically... \n"
	    +"If you put 'text' before and after them it might help.\n"
	    +"Hope this helps!\n" );
   pattern = "%D";
   verb    = "use";
   add_item("stupid object"
      ,({
            "long",       "This object is used to create items in the room!\n"
            +" set object pattern to <pattern> \n"
	    +" name object verb to <verb> \n"
            +" query object  ( returns the current pattern and verb ) \n"
            +" add an object named <item>\n"
            ,"set"      ,({this_object(),"do_set","%D 'pattern' 'to' %s" })
	    ,"name"     ,({this_object(),"do_name","%D 'verb' 'to' %s" })
            ,"query"    ,"@@do_query:"+file_name(this_object())+"@@\n"
            ,"add"      ,({this_object(),"do_add","'an' %D 'named' %s" })
        }));
}
int do_set(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   pattern = (string) a5[1];
   return 1;
}
int do_name(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   verb = (string) a5[1];
   return 1;
}
int do_add(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   object *obs;
  add_item( a5[1]
      ,({
            "long",
	       "This object's name is: "+a5[1]
	        +"\nAnd it can be used with the pattern:"+pattern
		+":\nAnd verb:"+verb+":\n\n"
            ,verb      ,({this_object(),"do_use",pattern })
        }));
   obs = all_inventory(this_object());
   obs->move("/room/void");
    obs->move(this_object());
   this_player()->move(this_object());
   return 1;
}
string do_query()
{ return "\nPattern:"+pattern+":Verb:"+verb+":\n"; }
int  do_use(mixed a1, mixed a2, mixed a3, mixed a4, mixed a5, mixed a6)
{
  printf("\nThe Verb:(A1):  %O\nThe Objects(A2):\n%O\nDirect Object(A3):  %O\nIndirect Object(A4):  %O\nReturn Array(A5):\n%O\nPattern(A6):  %O\n\n",a1,a2,a3,a4,a5,a6);
  tell_object(this_player(),"Hope that worked...\n");
  return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/main.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "primary room for \"add_item\"" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This is the start room for the examples for add_item.  "
            "Essentially boring, since it's only here to start you on your "
            "way:)\n" );
   add_exit( "start", PATH +"intro", "path" );
   add_exit( "failure", PATH +"verb_failure", "path" );
   add_exit( "success", PATH +"verb_success", "path" );
   add_exit( "patterns", PATH +"verb_patterns", "path" );
   add_exit( "arguments", PATH +"func_arguments", "path" );
   add_exit( "args_int", PATH +"args_integer", "path" );
   add_exit( "args_string", PATH +"args_string", "path" );
   add_exit( "args_object", PATH +"args_object", "path" );
   add_exit( "helper", PATH +"item_helper", "path" );
   add_exit( "exit", LEARNING + "search", "path" );
   add_property( "commented functions", ({ "add_item" }) );
   add_property( "keywords", ({ "room", "add_item", "action", "command" }) );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_names.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about simple items with many names" );
   set_light( 100 );
   set_long( "This is the room telling about making simple items with many "
            "names.  To help as examples it's been filled with several items "
            "including a small note, candles and some chairs.  Look at the "
            "note to learn more.  Go east to learn about adding verbs to the "
            "items, and west to go to a simpler example.\n" );
   add_item( "small note",
            "Ok things get more complicated here.\n"
            "First of all, the mudlib adds the plural forms of an "
            "item you add to a room.  Thus, \n"
            "  add_item( \"candle\", \"Very nice.\" );\n"
            "will take care of both \"look at candle\" and \"look at "
            "candles\".\n"
            "Secondly, the code:\n"
            "  add_item( \"small note\", \"Ok things ... \n"
            "will take care of both \"look at note\" and \"look at small "
            "note\"\n"
            "And finally, the code:\n"
            "  add_item( ({ \"corridor\", \"long hallway\" }), "
            "\"It is long.\" );\n"
            "will take care of \"look at corridor\", \"look at hallway\", "
            "\"look at long hallway\" and even \"look at long hallways\".\n"
            "If you look at the hallways you'll see the message you get is "
            "not very good as it refers to a single hallway.  To make a "
            "different description when you look at a single "
            "item and all of them, you can use the optional third parameter "
            "to tell the mudlib it shouldn't try to add the plural form. "
            "Thus:\n"
            "  add_item( \"chair\", \"This chair looks about ready to fall "
            "over.\", 1 );\n"
            "  add_item( \"chairs\", \"The chairs look ready to fall "
            "over.\", 1 );\n"
            "Oh, one last thing when listing things in this manner as a rule "
            "of thumb, put the best description first.\n" );
   add_item( "candle", "Very nice." );
   add_item( ({ "corridor", "long hallway" }), "It is long." );
   add_item( "chair", "This chair looks about ready to fall over", 1 );
   add_item( "chairs", "The chairs look ready to fall over", 1 );
   add_item( "item", "You don't see any since noone coded one yet!" );
   add_item( "reference", "Like one that you would find in a theusaures." );
   add_item( "room", "It is a big room." );
   add_exit( "east", PATH +"verbs", "path");
   add_exit( "west", PATH +"intro", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #4, many verbs ");
   set_light(100);
   set_long( "add_item room #4, many verbs \n"
            "Sometimes you have two or more identical verbs - or at least "
            "identical in how you want to treat them.  Take our oak tree "
            "we can cut it, slice it, saw it, etc...  Now all of these have "
            "the same meaning. How do we do this?\n"
            "A large oak.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the tree:\n"
      "    add_item(\"large oak tree\", ({\n"
      "      \"long\",\n"
      "              \"It looks like it is very well protected.\"\n"
      "      ({\"cut\",\"slice\",\"saw\",\"destroy\",\"kill\" }),\n"
      "              \"It seems to have no effect.\\n\"       }});\n\n"
      "Pretty obvious hunh?  Note that kill probably does not work( I "
      "say probably cuz things might change)  That is beacuse user commands "
      "have precidence over object actions in rooms.  Also be aware that a "
      "add_action on an item that a person is holding will most likely stop "
      "your verbs from being used (unless it's coded right:).  Soul commands "
      "do not have precedence, however.  So verbs like \"pick\" which would "
      "normally say \"You pick your nose\" can be trapped appropriately.\n"
   }) );
   add_item("large oak", ({
      "long", "It looks like it is very well protected.",
      ({ "cut", "slice", "saw", "destroy", "kill" }),
        "It seems to have no effect.\n" }) );
   add_exit( "east", PATH +"action_verbs", "path");
   add_exit( "west", PATH +"verbs", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/path.h
==================================================

#include <learning.h>
#define PATH HELP +"rooms/add_item/"
#define MAIN PATH +"main"

==================================================
FILE: learning/help_topics/rooms/add_item/verb_failure.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #7, verb failure messages ");
   set_light(100);
   set_long("add_item room #7, verb failure messages\n"
            +"Let us continue with our rat.  Sometimes the general failure "
            +"message just dosn't cut it.  When the player fails to  "
            +"touch our rat, the mud should tell him/her nicely and not "
            +"let them think they messed up.  This rat does just that.  "
            +"Notice that, unlike success messages, failure messages go only "
            +"to the player - not to everyone in the room.  *smile* \n"
            +"A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     +"int  do_touch()\n"
             +"{\n"
	     +"   if(!random(2)) {\n"
	     +"       this_player()->add_failed_mess(previous_object(),\n"
	     +"                       \"You miss the rat!\\n\",\n"
	     +"                       ({})); \n"
	     +"        return 0;\n"
	     +"    }\n"
	     +"    return 1;\n"
	     +"}\n\n"
	     +"The add_failed_mess is a pretty complicated fella.  The first "
	     +"argument I beleve is the object that the verb failed on, ie "
	     +"the rat.  The second argument is the failure message. Since "
	     +"it is going only to the player, it is really simple to "
	     +"understand.  The third argument is the set of indirect "
	     +"that were used in the failing attempt.  I think you can "
	     +"reference there name in the message as %I.  But don't quote "
	     +"me on that.  Similarly %D can be used as a substution for the "
	     +"direct object, ie previous_object().  It is complicated.  "
	     +"If you stick to this form, you shouldn't have any problems.  "
	     +"If all else fails, read the help file on it. *giggle* \n" }));
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }));
   add_exit( "east", PATH +"verb_success", "path" );
   add_exit( "west", PATH +"action_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_touch() {
   if(!random(2)) {
      this_player()->add_failed_mess(previous_object(),
                                     "You miss the rat!\n",
                                     ({}));
      return 0;
   }
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_patterns.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #9, verb patterns ");
   set_light(100);
   set_long("add_item room #9, verb patterns\n"
            +"Outdated! see man add_command for patterns\n "
            +"As you guessed I am still holding out on you.  There is, "
            +"unfortunately, tons more!  Most things take the form: VERB "
            +"DIRECT_OBJECT or $V $D.  Add item has a limited number of "
            +"patterns that it can recognize, the first limitation is that "
            +"the verb must come first.  ie VERB PATTERN.  The default "
            +"pattern we have been using to date is %D.  We can change the "
            +"pattern!\nReference sheet.\nLarge pool.\nNote.\n");
   add_item("reference sheet",
            "Pattern: Is the add_command pattern( parse_command): \n"
            +"Example string = \" 'get' / 'take' %i \" \n"
            +"Syntax:\n"
            +"  'word'          obligatory text     \n"
            +"  [word]          optional text       \n"
            +"  /               Alternative marker  \n"
            +"  %o              Single item, object \n"
            +"  %l              Living objects      \n"
            +"  %s              Any text            \n"
            +"  %w              Any word            \n"
            +"  %p              One of a list (prepositions)  \n"
            +"  %i              Any items                     \n"
            +"  %d              Number 0- or tx(0-99)         \n"
            +"Things from add_command                         \n"
            +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
            +"Currently %s and %w behave a bit erradically... \n"
            +"If you put 'text' before and after them it might help.\n"
            +"Hope this helps!\n" );
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the pool:\n"
      +"  add_item(\"large pool\", ({  \n"
      +"       \"long\",\n"
      +"                   \"It looks like you can jump into it!\"\n"
      +"	,\"jump\",\n"
      +"		   ({ this_object(), \"do_jump\", \n"
      +"			\" 'into' / 'in' %D \"  })  \n"
      +"	 )} );\n\n"
      +"Ok. Not much different, just one more argument.  Look at the "
      +"reference sheet.  Looks complicated hunh?  The most useful ones "
      +"are %D, %I, %d, [text], 'text', and /.  I will demonstrate how to "
      +"use %d and %I in a few rooms.  I have also changed the succeed "
      +"mess, otherwise it would say: \"You jump into / in a large pool.\"  "
      +"Not good huh? *smile* Oh well on to the next room!\n" }));
   add_item( "large pool", ({
      "long", "It looks like you can jump into it!",
      "jump", ({ this_object(), "do_jump", " [into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"func_arguments", "path");
   add_exit( "west", PATH +"verb_success", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_jump() {
   this_player()->add_succeeded_mess(previous_object(),
                                     "$N $V into a pool!\n",  ({}));
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_success.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #8, verb success messages ");
   set_light(100);
   set_long("add_item room #8, verb success messages\n"
	    "Let us continue with our rat.  Suppose now that we want the "
	    "player to succeed - but that the default message is really "
	    "inappropriate.  What we want to do is change the succeed "
	    "message!  Let's say when the player goes to touch the rat "
	    "it tells him - As you touch the rat, it snarls. - "
	    "Unfortunately succeed messages are much more complicated "
	    "beacuse your message is going to two parties, the player and "
	    "other players in the room. So you can't put the words \"You\" and "
	    "\"touch\" directly into code, because \"Fred\" and \"touches\" are the "
	    "appropriate substitutions to be used for the audience.  "
	    "Furthermore, if you are useing "
	    "multiple verbs, how do you know what verb the person used? "
	    "The solution is to use $V for verb and $N for player name.\n"
	    "A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     "int  do_touch()\n"
             "{\n"
             "      this_player()->add_succeeded_mess(previous_object(),\n"
	     "        \"As $N $V $D, it snarls.\\n\",  ({}));\n"
	     "    return 1;\n"
	     "}\n\n"
	     "The only difference between add_failed_mess and this one is "
	     "the message: When the message is processed for the player, "
	     "\"You\" is substituted for $N and \"touch\" for $V.  Likewise, when "
	     "the message is processed for others: \"Fred\" is substituted for $N "
	     "and \"touches\" is substituted for $V.  If you were using multiple "
	     "verbs, the appropriate verb would be used.  There might be "
	     "other $ stuff in the docs( namely $D and $I if you have an "
	     "indirect object list.)  There might be ones for pronouns and "
	     "possessives also.  At last "
	     "resort, you can always make this string a null string! And "
	     "insert tell_other and tell_room call's directly in your code."
	     "Of course add_failed_mess and this one can be used together in "
	     "the same code...\n" }));
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched.",
		"touch",
                           ({ this_object(), "do_touch" }) }));
   add_exit("west",PATH+"verb_failure","path");
   add_exit("east",PATH+"verb_patterns","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int  do_touch()
{
  this_player()->add_succeeded_mess(previous_object(),
	            "As $N $V $D, it snarls.\n",  ({}));
    return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #3, verbs ");
   set_light(100);
   set_long("add_item room #3, verbs \n"
            "As you know, things can be read, kicked, etc... in DiscWorld.  "
            "Therefore we need to make our items respond to actions.  The "
            "old way to do this is through add_action.  Unless you are "
            "experienced, you should not use this function.  add_item "
            "provides many facilities to do this which are much better to "
            "write, easier to understand, and have less chance of 'bugging' "
            "out on you.\nA large oak.\nA note.\n\n");
   add_item("note", ({ "long", "It can be read.",
      "read", "As you can see, this note can be read, "
      "this is our first introduction to verbs.  "
      "The code that does this:\n"
      "      add_item(\"note\", ({ \"long\", \"It can be read.\" \n"
      "                          \"read\", \"As you can see ... \" }) );\n"
      "This uses a mixed variable in the description part of the "
      "add_item.  The members of the mixed variables are strings which "
      "come in pairs.  Notice that \"long\" is not \"look\" this is just "
      "a simple way to specify a whole range of verbs that return this "
      "description, namely:  look, examine, ... \n"
      "After printing out the message the add_item program prints out to "
      "the person reading the note: \"You read a note.\"  More generally:  "
      "\"You <verb> <indefinate artical> <item>.\"  Similarly everyone "
      "else in the room sees:  \"Fred reads a note.\"\n\nA description of "
      "the tree can be found in treenote.\n" }));
   add_item("treenote", ({ "long", "Read it nim wit!",
      "read", "Here is the add_item for the oak:\n"
      " add_item( ({\"large oak tree\",\"large oak\"}) , ({  \n"
      "      \"long\",\"It looks like it can be climbed and cut.\"\n"
      "      \"climb\",\"You get half way up, and climb back down.\\n\"\n"
      "      \"cut\",\"You cannot hurt this tree!\\n\"  })); \n\n"
      "Oh joy.  Notice that it always prints out:\n"
      "   \"You <verb> a large oak.\" \n"
      "It picks the first description of the item from the mixed array.\n"
      "Some times you can interfere with item commands or soul commands "
      "by installing these actions. But, the interference would be more "
      "if you used add_action!.\n" }));
   add_item( ({ "large oak tree", "large oak" }) , ({
      "long", "It looks like it can be climbed and cut.",
      "climb", "You get half way up, and climb back down.\n",
      "cut", "You cannot hurt this tree!\n" }) );
   add_exit( "east", PATH +"many_verbs", "path" );
   add_exit( "west", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/situations/path.h
==================================================

#include <learning.h>
#define SIT "/d/learning/help_topics/rooms/situations/"

==================================================
FILE: learning/help_topics/rooms/situations/sitroom1.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/room";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Basic situation example room");
  set_light(100);
  set_long("This is a very simple situation example.  "
           "To start it \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom2", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "button", "There is a button on the wall you might \"press\".");
  add_situation( "frog",
    new(class situation,
        start_mess: "A little frog appears from nowhere.\n",
        extra_look: "There is a little frog here.",
        add_items: ({ ({ "frog", "The frog is small but happy." }) }),
        chat_rate: ({ 10, 30 }),
        chats: ({"The little frog hops on the spot.",
                 "The little frog says:  Ribbit." }) ,
        end_mess: "The little frog disappears into thin air."
    )
  );
}
int do_press()
{
  tell_object(this_player(),"You press the button.\n");
  tell_object(this_player(),"%^YELLOW%^You just started the frog situation.  "
              "It will go for 60 seconds.  It adds an add_item ( look frog ), "
              "an extra_look to the room ( look ) and some chats.%^RESET%^\n");
  change_situation( "frog", 60 );
  return 1;
}
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom2.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Combination of situations example room");
  set_light(40);
  set_long("This is a combination of situations example.  "
           "It is outside in a dark neighbourhood.  "
           "To start a combination of situations \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom3", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "button", "There is a button on the wall you might \"press\".");
  add_item( "house", "There are old wooden houses here.");
  add_situation( "house",
    new(class situation,
      add_items: ({
        ({ "nearby house", "The wooden house has thin walls so you can "
             "easily hear what goes on inside." }),
        ({ "voice", "There are voices coming from a nearby house here." })
            }),
      end_mess: "You hear running footsteps in the alley on the other side "
             "of the house.\nThe nearby wooden house falls eerily silent."
    )
  );
  add_situation( "argue",
    new(class situation,
      chats:({"A man yells shrilly, something that sounds like an accusation.",
        "A man with a deep voice threatens loudly.",
        "A woman's voice calls for calm." }),
      chat_rate: ({ 10, 30 })
   )
  );
  add_situation( "murder",
    new(class situation,
      start_mess:"There is a loud bang, as if something fell over or "
        "was struck solidly within the wooden house here.",
      chats:({"A man says something in shocked voice.",
              "A woman's voice hisses for silence.",
              "There is the sound of something heavy being moved inside the "
              "wooden house here." }),
      chat_rate: ({ 5, 15 })
    )
  );
}
int do_press()
{
  tell_object(this_player(),"You press the button.\n");
  tell_object(this_player(),"%^YELLOW%^You just started the argue and house "                "situations.  It will go for 80 seconds and then the murder "
              "and house situations will replace it for 40 more seconds.  "
              "As house follows itself immediately it just continues without "
              "being changed and its end message is given only at the very "
              "end.%^RESET%^\n");
  change_situation( ({ "argue,house", "murder,house" }), ({ 80, 40 }) );
  return 1;
}
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom3.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
object warrior;
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Automated situations (with function pointers) example room");
  set_light(40);
  set_long("This is a combination of situations example that is automated "
           "and makes use of function pointers.  "
           "It is outside in a run down neighbourhood.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom4", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "window", "There is window up high with maroon curtains." );
  add_item( "curtain", "That is all you can see, sorry." );
  add_situation( "sew1",
    new(class situation,
      chats: ({"There is a distinct giggle.",
        "A woman's giggle drifts down from an upstairs window.",
        "A man murmurs something upstairs." }),
      chat_rate: ({ 10, 15 })
    )
  );
  add_situation( "sew2",
    new(class situation,
      start_mess: "There is a whump like something landing on a matress "
         "above.",
      chats:({
        "A high-pitched giggle reaches the street from above.",
        "There is the creak of complaining coils from an upstairs window.",
        "You can make out a muffled voice from above." }),
      chat_rate: ({ 10, 15 }),
      end_mess: "The upstairs noises stop.\nYou hear the clink of coinage.",
      end_func: (: call_out("make_warrior",5) :)
    )
  );
  add_situation( "pause", new(class situation) );
  automate_situation( ({ "sew1","sew2","pause" }), ({ 25,35,20 }),
    WHEN_ANY_TIME, 500 );
}
void make_warrior()
{
  if (warrior)
    call_out( (: $1->move( "/room/rubbish",
     "", $1->the_short()+" races off to kill something.") :), 5, warrior );
  warrior = clone_object( "/d/am/chars/am_warrior_human" );
  warrior->move(this_object(),warrior->the_short()+
    " enters the street from a building nearby looking pleased with "
    +warrior->query_objective()+"self.");
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom4.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Exclusion and random words situations example room");
  set_light(100);
  set_long("This is a of situations example that is automated "
           "and makes use of random words and exclusion.  "
           "It is at a pier where one ship may dock at a time.  "
           "Exclusion means one situation (or set of them) "
           "prevents another from happenning at the same time "
           "and vice versa.  "
           "Random words mean that the text changes each time.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "next", SIT+"sitroom5", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "pier", "There is small pier here." );
  add_situation( "boat1",
    new(class situation,
      start_mess: "A little fishing boat comes up to the pier.  "
         "It has the name \"#1\" painted on the side.\n"
         "A fisherman jumps off the boat and ties its painter to a post.",
      chats: ({"The little boat bobs up and down next to the pier.",
               "A fisherman hops off the little boat." }),
      chat_rate: ({ 20, 30 }),
      extra_look: "There is a little boat here.",
      add_items: ({ ({ ({ "#1","little boat" }),
        "There is little fishing boat tied up at the pier here.  "
        "The name \"#1\" is painted on the side."   }) }),
      end_mess: "The fishermen get back on board and "
         "the little boat moves on.",
      random_words: ({ ({ "Honey Toad", "Piker", "Bing" }) })
    )
  );
  add_situation( "boat2",
    new(class situation,
      start_mess: "A fat trading vessel comes up to the pier.  "
         "It has the name \"#1\" painted on the prow.\n"
         "A sailor jumps off and ties the vessel to a post.",
      chats: ({"The trading vessel thumps against the pier.",
               "A sailor comes ashore.",
               "#2 is unloaded from the vessel.",
               "#3 is loaded onto the vessel." }),
      chat_rate: ({ 10, 20 }),
      extra_look: "There is a trading vessel docked here.",
      add_items: ({ ({ ({ "#1","fat vessel","ship" }),
        "There is a trading vessel docked at the pier here.  "
          "The name \"#1\" is painted on the prow." }) }),
      end_mess: "The sailors get back on board and "
         "the trading vessel departs.",
      random_words: ({ ({ "Fat Cat", "Scumbag", "Cap Pig" }),
          ({ "A pair of slaves", "A bale of wool", "A bolt of cloth" }),
          ({ "A stock option", "A cage of frogs", "A wooden crate" }), })
    )
  );
  automate_situation( "boat2", 61, WHEN_ANY_TIME, 300, "boat" );
  automate_situation( "boat1", 50, WHEN_ANY_TIME, 200, "boat" );
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom5.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Situation with a background state example room");
  set_light(100);
  set_long("This is a situations example that is automated "
           "and makes use of a background situation.  "
           "This means that when the automated manager has not "
           "fired up the labelled automated situations you specified "
           "there is another situation that goes by default the rest "
           "of the time.  It is marked in the list by having -1 "
           "for its duration.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_situation( "tramp_sleeping",
    new(class situation,
      chats: ({"The tramp snores." }),
      chat_rate: ({ 60,120 }),
      extra_look: "There is a tramp sleeping here.",
      add_items: ({ ({ "tramp",
        "There is dusty and fairly dirty tramp curled up and sleeping "
        "at one side of the road."   }) })
    )
  );
  add_situation( "tramp_awake",
    new(class situation,
      start_mess: "The tramp leaps to his feet, instantly alert.",
      chats: ({"The tramp produces some brightly coloured balls and juggles "
                 "them.",
               "The tramp does a handstand.",
               "The tramp leaps into the air and touches his toes.",
               "The tramp does a little dance.",
               "Dust billows from the frenetic tramp's clothes."
             }),
      chat_rate: ({ 20,30 }),
      extra_look: "There is a tramp bouncing around here.",
      add_items: ({ ({ "tramp",
        "The dusty tramp is bright eyed and very awake."  }) }),
      end_mess: "The tramp flops to the ground and slowly curls into a ball."
    )
  );
  automate_situation( ({ "tramp_sleeping", "tramp_awake" }),
                      ({ -1, 61 }) , WHEN_ANY_TIME, 300 );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_crippled_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the crippled.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":hobbles around pathetically.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a crippled beggar.  "
     "One of "+query_possessive()+
     " legs has wasted so that it ressembles a gnarled branch.\n" );
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "crippled beggar" );
   set_main_plural( "crippled beggars" );
   add_adjective("crippled");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_diseased_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the diseased.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":picks at some sores.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a diseased beggar.  "
     "Looking at the running sores covering "+query_possessive()+
     " body makes your skin crawl.\n");
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "diseased beggar" );
   set_main_plural( "diseased beggars" );
   add_adjective("diseased");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_poor_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the poor.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":looks down at the ground and sobs.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a poor beggar.  Perhaps you should give "+
            (string)query_objective() +" some money.\n" );
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "poor beggar" );
   set_main_plural( "poor beggars" );
   add_adjective("poor");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/crowd.c
==================================================

#include <parse_command.h>
#include "path.h"
#define MAXATONCE 6
inherit "/std/object";
class member {
  string file;
  string short;
  string *adjectives;
  string *names;
  string *plurals;
  string long;
  int *original_number;
}
int n_alive, n_crowd, n_selection, n_cloned, n_here, n_max=MAXATONCE;
int *crowd,*selection;
mixed *here;
mixed *_m_names;
mixed *_m_plurals;
mixed *_m_adjectives;
mixed store=({});
int cnt=0;
mixed query_store() { return ({ store, cnt }); }
int lookflag=0;
int lastmatch=0;
int i_member=0;
mixed *members = ({
  new(class member,
     file : CROWD+"am_poor_beggar",
     short : "poor beggar",
     long : "This is a poor beggar.  "
     "Perhaps you should give $OBJ$ some money.\n"
     "$PRO$ is in good shape.\n"
     "$PRO$ is standing.\n",
     original_number : ({ 0,13,15 }) ),
  new(class member,
     file : CROWD+"am_diseased_beggar",
     short : "diseased beggar",
     long : "This is a diseased beggar.  "
     "Looking at the running sores covering $POSS$ body makes your skin crawl.\n"
     "$PRO$ is in good shape, considering.\n"
     "$PRO$ is standing.\n",
     original_number : ({ 0,17,2 }) ),
  new(class member,
     file : CROWD+"am_crippled_beggar",
     short : "crippled beggar",
     long : "This is a crippled beggar.  "
     "One of $POSS$ legs has wasted so that it ressembles a gnarled branch.\n"
     "$PRO$ is in good shape.\n"
     "$PRO$ is standing awkwardly.\n",
     original_number : ({ 0,6,11 }) )
});
int *query_crowd() { return ({ selection, crowd }); }
int query_n_crowd() { return n_crowd; }
int query_visible() { return n_crowd; }
int group_object() { return n_crowd-1; }
string include_gender( string long, int gender ) {
  switch ( gender ) {
  case 2:
    return
      replace( long, ({ "$POSS$","her","$OBJ$","her","$PRO$","She" }) );
  default:
    return
      replace( long, ({ "$POSS$","his","$OBJ$","him","$PRO$","He" }) );
  }
}
string long(string word, int dark) {
  int i;
  string ret="";
  if ( !lookflag ) {
    foreach (i in crowd) ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if ( lastmatch ==  0 ) {
    foreach (i in selection )
      ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if ( lastmatch > 0 ) {
    foreach (i in selection[0..(lastmatch-1)] )
      ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if (-lastmatch <= sizeof(selection)) {
    i = selection[-lastmatch-1];
    return include_gender( members[i>>2]->long, i&3 );
  }
  return ret;
}
string a_short() {
  string ret="";
  int i,n_match;
  string prev=file_name(previous_object(1));
  if ( prev == "/cmds/living/glance" ||
       prev == "/cmds/living/l_ook" ) {
    lookflag = 0;
    i_member = 0;
    selection = crowd;
    n_selection = n_crowd;
  }
  else if ( file_name(previous_object()) != "/cmds/living/glance" ) {
    lookflag = 0;
  }
  n_match = n_selection;
  if (lookflag && lastmatch && lastmatch < n_match)
    n_match = (lastmatch > 0 ? lastmatch : 1);
  for (i=i_member;i<n_match;i++) {
    ret+="$a_short:"+ file_name(load_object(members[selection[i]>>2]->file)) +"$";
  }
  if (lookflag) { ret = "$M$" + ret + "$M$"; }
  return ret;
}
string the_short() {
  string ret="";
  int i;
  for (i=0;i<n_crowd;i++)
    ret+="$the_short:"+ file_name( this_object() ) +"$";
  return ret;
}
string one_short() {
  string ret="";
  int i;
  for (i=0;i<n_crowd;i++)
    ret+="$one_short:"+ file_name( this_object() ) +"$";
  return ret;
}
string poss_short() {
  return a_short();
}
varargs string short(int dark) {
  return "crowd";
}
void create() {
  class member p;
  int i,j,k;
  string *tmp;
  string *adjs = ({});
  string *names = ({});
  ::create();
  set_name("beggar");
  set_short("crowd of crowd.");
  set_long("This is a crowd of people.");
  enable_commands();
  crowd = ({ });
  for (j=0; j<sizeof(members);j++) {
    p = members[j];
    tmp = explode(p->short," ");
    p->names = ({ tmp[<1] });
    p->plurals = ({ pluralize(tmp[<1]) });
    names += ({ tmp[<1] });
    p->adjectives = tmp[0..<2];
    adjs += tmp[0..<2];
    for (k=0;k<sizeof(p->original_number);k++)
      for (i=0; i<(p->original_number)[k]; i++) crowd += ({ (j<<2)+k });
  }
  crowd = shuffle(shuffle(crowd));
  n_crowd = sizeof(crowd);
  n_alive = sizeof(crowd);
  n_cloned = 0;
  here = ({ });
  n_here = 0;
  _m_names = ({});
  _m_plurals = ({});
  while(sizeof(names)) {
    _m_names += ({ names[0] });
    _m_plurals += ({ pluralize(names[0]) });
    names-= ({ names[0] });
  }
  _m_adjectives = ({});
  while(sizeof(adjs)) {
    _m_adjectives += ({ adjs[0] });
    adjs-= ({ adjs[0] });
  }
}
void crowd_member_died( ) {
  n_alive--;
  n_cloned--;
  if (!n_alive) dest_me();
}
void merge_crowd_member( object member ) {
  tell_room(environment(),"%^YELLOW%^"+sprintf("%O reabsorbed into %O", member, this_object())+"%^RESET%^\n");
  if (member && environment(member)==environment() ) {
    int i;
    for (i=0;i<sizeof(members);i++) {
      if ( base_name(member) == members[i]->file ) {
        n_cloned--;
        n_crowd++;
        n_here--;
        here -= ({ member->crowd_number() });
        n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
        if ( n_max < 1 ) n_max = 1;
        crowd = ({ (i<<2)+member->query_gender() }) + crowd;
        member->dest_me();
      }
    }
  }
}
object make_member() {
  object frog;
  int i,j;
  if (i_member<0 || i_member>=sizeof(selection)) i_member=0;
  i = selection[i_member];
  j = member_array( i, crowd );
  frog = clone_object(members[i>>2]->file);
  if (frog) {
    n_crowd--;
    n_cloned++;
    n_here++;
    n_max = (n_max+1)>>1;
    n_selection--;
    crowd = crowd[0..j-1] + crowd[j+1..<1];
    selection = selection[0..i_member-1]+selection[i_member+1..<1];
    crowd = crowd[0..j-1] + crowd[j+1..<1];
    here += ({ i });
    tell_room(environment(),"%^YELLOW%^"+sprintf("Cloned %O : %i of %i selected (%i remaining)",frog,i_member+1,sizeof(selection)+1,n_crowd)+"%^RESET%^\n");
    frog->fix_gender( i&3 );
    frog->add_effect( CROWD+"crowd_merge_effect", ({ this_object(), i }) );
    frog->move( environment(this_object()) );
  }
  return frog;
}
string *parse_command_id_list() {
  return _m_names;
}
string *parse_command_plural_id_list() {
  return _m_plurals;
}
string *parse_command_adjectiv_id_list() {
  return _m_adjectives;
}
mixed query_parse_id(mixed *arr) {
   string *bits, bat;
   int i;
   selection = ({ });
   i_member = 0;
   if (!n_crowd) return 0;
   lastmatch=arr[P_THING];
   switch (query_verb()) {
   case 0:
   case "look":
   case "glance":
   case "destruct":
   case "lose":
   case "trans":
     lookflag=1;
     break;
   default:
     lookflag=0;
   }
   bits = explode(arr[P_STR]," ");
   bat = bits[<1];
   selection = copy(crowd);
   if ( member_array( bat, _m_names ) != -1 ) {
     for (i=0;i<sizeof(members);i++) {
       if ( member_array( bat, members[i]->names ) == -1)
         selection -= ({ (i<<2)+1, (i<<2)+2 });
     }
     while (sizeof(bits = bits[0..<2])) {
       bat = bits[<1];
       if ( member_array( bat, _m_adjectives ) != -1 ) {
         for (i=0;i<sizeof(members);i++) {
           if ( member_array( bat, members[i]->adjectives ) == -1)
             selection -= ({ (i<<2)+1, (i<<2)+2 });
         }
       }
     }
   }
   else if ( member_array( bat, _m_plurals ) != -1 ) {
     for (i=0;i<sizeof(members);i++) {
       if ( member_array( bat, members[i]->plurals ) == -1)
         selection-= ({ (i<<2)+1, (i<<2)+2 });
     }
     while (sizeof(bits = bits[0..<2])) {
       bat = bits[<1];
       if ( member_array( bat, _m_adjectives ) != -1 ) {
         for (i=0;i<sizeof(members);i++) {
           if ( member_array( bat, members[i]->adjectives ) == -1)
             selection -= ({ (i<<2)+1, (i<<2)+2 });
         }
       }
     }
   }
   if (!(n_selection = sizeof(selection))) return 0;
   if (lookflag) {
     if (lastmatch < 0) i_member = -lastmatch-1;
     if (arr[P_THING] == 0) return this_object();
     if (arr[P_THING] < 0) {
        arr[P_THING]+=n_selection;
        if (arr[P_THING] <0) {
          return 0;
        }
        arr[P_THING] = -10321;
        return this_object();
     }
     if (arr[P_THING] != 1) {
       i=arr[P_THING];
       if (i>n_selection) i = n_selection;
       arr[P_THING]-=i;
       if (!arr[P_THING]) arr[P_THING] = -10101;
       return this_object();
     }
     arr[P_THING] = -10101;
     return this_object();
   }
   if (arr[P_THING] == 0) {
      object *things=({ });
      i = n_max;
      if (i>n_selection) i = n_selection;
      while (i--) things += ({ make_member() });
      return things;
   }
   if (arr[P_THING] < 0) {
      i_member = -arr[P_THING]-1;
      arr[P_THING]+=n_selection;
      if (arr[P_THING] <0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return make_member();
   }
   if (arr[P_THING] != 1) {
      object *things=({ });
      i=arr[P_THING];
      if (i>n_selection) i = n_selection;
      if (i>n_max) i = n_max;
      while (i--) {
         arr[P_THING]--;
	 things += ({ make_member() });
      }
      if (!arr[P_THING]) arr[P_THING] = -10101;
      return things;
   }
   arr[P_THING] = -10101;
   return make_member();
}
void event_enter( object ob, string message, object from ) {
  if (from) {
    object *things;
    n_here = sizeof( things = filter(all_inventory( environment() ),
      (: $1->crowd_object() == this_object() :) ));
    here = ({ });
    if ( n_here ) here = map( things, (: $1->crowd_number() :) );
    n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
    if ( n_max < 1 ) n_max = 1;
    tell_creator("shaggy","ENTER %O: n_here: %i n_cloned: %i n_alive: %i n_crowd:%i n_max: %i %O\n",from,n_here,n_cloned,n_alive,n_crowd,n_max, here);
  }
}
void event_exit( object ob, string message, object to ) {
  object *things;
  n_here = sizeof( things = filter(all_inventory( environment() ),
     (: $1->crowd_object() == this_object() :) ));
  here = ({ });
  if ( n_here ) here = map( things, (: $1->crowd_number() :) );
  n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
  if ( n_max < 1 ) n_max = 1;
  tell_creator("shaggy","EXIT: n_here: %i n_cloned: %i n_alive: %i n_crowd:%i n_max: %i %O\n",n_here,n_cloned,n_alive,n_crowd,n_max, here);
}

==================================================
FILE: learning/help_topics/rooms/crowd/crowd_merge_effect.c
==================================================

#include <effect.h>
#include "path.h"
#define SHADOWS  CROWD
mixed beginning( object player, mixed arg, int id ) {
  call_out( (: $1->crowd_merge() :), 5, player );
}
mixed merge_effect( object player, mixed oldarg, mixed newarg, int id ) {
   return newarg;
}
string query_classification() { return "npc.crowd.merge"; }
string query_shadow_ob() { return SHADOWS + "crowd_merge_shadow"; }

==================================================
FILE: learning/help_topics/rooms/crowd/crowd_merge_shadow.c
==================================================

#include <move_failures.h>
inherit "/std/effect_shadow";
int actually_attacked=0;
varargs void crowd_merge() {
  object crowd,thing;
  object *list;
  crowd=(arg())[0];
  if (!crowd) {
    int *effs=player->effects_matching("npc.crowd.merge");
    player->delete_effect(effs[0]);
    return;
  }
  if (sizeof(player->query_attacker_list()) ||
     (player->query_hp()<player->query_max_hp())) {
    call_out( "crowd_merge", 60 );
    return;
  }
  if (actually_attacked) {
    foreach( thing in filter(all_inventory(environment(player)),
          (: living($1) :) )) {
      if ( (list = thing->query_attacker_list())
           && member_array(player,list) != -1 ) {
        call_out( "crowd_merge", 60 );
        return;
      }
    }
  }
  if ( environment(player) == environment(crowd) ) {
    crowd->merge_crowd_member( player );
    return;
  }
  player->add_effect( "/std/effects/npc/goto_destination",
    ({ file_name(environment(crowd)),
       ({ this_object(), "crowd_merge" }), 1 }) );
}
int attack_by( object thing ) {
  actually_attacked=1;
  return player->attack_by( thing );
}
object crowd_object( ) { return (arg())[0]; }
object crowd_number() { return (arg())[1]; }
object do_death( object thing) {
   if ((arg())[0]) ((arg())[0])->crowd_member_died();
   return player->do_death( thing );
}

==================================================
FILE: learning/help_topics/rooms/crowd/crowdroom.c
==================================================

#include "path.h"
inherit "/std/room";
object crowd;
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "crowd" }) );
  set_short("crowd demonstration room");
  set_light(100);
  set_long("This is a room to contain a crowd of NPC's.  "
           "It is intend to be a venue to test and try out "
           "the crowd NPC object and related files:\n"
           "%^YELLOW%^/d/am/learning/help_topics/crowd/crowd.c\n"
           "/d/am/learning/help_topics/crowd/crowd_merge_effect.c\n"
           "/d/am/learning/help_topics/crowd/crowd_merge_shadow.c"
           "%^RESET%^\n"
           "You can %^CYAN%^inv here%^RESET%^ to see objects present.  "
           "You can also attack the beggars as NPCs may not use the exits.\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  modify_exit( "back", ({ "function", (: interactive($2) :) }) );
  modify_exit( "exit", ({ "function", (: interactive($2) :) }) );
}
void reset() {
  if (!crowd) {
    crowd=clone_object( CROWD+"crowd" );
    crowd->move( this_object() );
  }
}

==================================================
FILE: learning/help_topics/rooms/crowd/path.h
==================================================

#include <learning.h>
#define CROWD "/d/learning/help_topics/rooms/crowd/"

==================================================
FILE: learning/help_topics/objects/container_save.c
==================================================

#include "path.h"
inherit "/std/room";
object shelf, wardrobe;
void setup() {
   set_short("room of shelf and wardrobe examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of how to make shelves, "
            "wardrobes and such that'll save the content for you.\n"
            "To make a shelf, which is characterized by having a surface "
            "you can put things on, you make a clone of /obj/surf_save, "
            "configure it like all cloned objects, and call set_save_file( "
            "file_name ) do tell what file should be used to save the "
            "objects that are put on it.  If the savefile isn't in /save/ "
            "you should call check_euid() on the shelf before calling "
            "set_save_file().\n"
            "Making a wardrobe, you do the same, except you that it is "
            "/obj/cont_save you should clone.\n"
            "Note that since these are fixed parts of the room, and not "
            "something that is put here, I clone them directly in reset() "
            "instead of doing a call_out() to a function that makes them.\n" );
   set_light( 100 );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "check_euid", "set_save_file" }) );
   add_property( "keywords",
                ({ "shelf", "wardrobe", "save" }) );
}
void reset() {
   if (!shelf) {
      shelf = clone_object("/obj/surf_save");
      shelf->set_name( "shelf" );
      shelf->set_short( "oaken shelf" );
      shelf->add_adjective( "wooden" );
      shelf->add_adjective( "oak" );
      shelf->add_adjective( "oaken" );
      shelf->add_property( "there", "hanging from the wall" );
      shelf->set_long( "This shelf is made from oak and "
                      "varnished to bring out the glow.\n" );
      shelf->set_weight( 2000 );
      shelf->set_max_weight( 2000 );
      shelf->reset_get();
      shelf->check_euid();
      shelf->set_save_file( SAVEPATH+"/oak_shelf" );
      shelf->move( this_object() );
   }
   if (!wardrobe) {
      wardrobe = clone_object("/obj/cont_save");
      wardrobe->set_name( "wardrobe" );
      wardrobe->set_short( "oaken wardrobe" );
      wardrobe->add_adjective( "wooden" );
      wardrobe->add_adjective( "oaken" );
      wardrobe->add_adjective( "oak" );
      wardrobe->set_long( "This wardrobe is made from oak and "
                         "varnished to bring out the glow.\n" );
      wardrobe->set_weight( 2000 );
      wardrobe->set_max_weight( 2000 );
      wardrobe->reset_get();
      wardrobe->check_euid();
      wardrobe->set_save_file( SAVEPATH+"/wardrobe" );
      wardrobe->move( this_object() );
   }
}

==================================================
FILE: learning/help_topics/objects/path.h
==================================================

#include <learning.h>
#define PATH HELP + "objects/"

==================================================
FILE: learning/help_topics/objects/vessel.c
==================================================

#include "path.h"
inherit "/std/room";
object wine_bottle, glass, cup;
void setup() {
   set_short("room of vessel and liquid examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of using vessels.  "
            "There should be a wine bottle, a wine glass, and a "
            "coffee cup in here.  There are also a few usage notes "
            "on the wall (\"read note1\", \"read note2\", etc).\n" );
   set_light( 100 );
   add_item( "note1",
            ({ "long", "This note describes how to use the vessels.",
               "read", "The vessels all have the following commands: "
                   "pour, fill, drink, empty.  There are a few others, "
                  "but they're mainly carry-overs from the old "
                  "container code, and probably don't work correctly.  "
                  "Try pouring from one object to another, drinking, etc.  "
                  "Try mixing equal parts of wine and Klatchian coffee.  "
                  "Use the \"stat\" command to check on the volumes (eg, "
                  "\"stat bottle\", \"stat all in cup\").  If you want "
                  "to start over with a fresh vessel, dest it and "
                  "\"call reset() here\".\n"
            }) );
   add_item( "note2",
            ({ "long", "This is a little note on liquid units of measure.",
               "read", "The base unit for a liquid is the drop.  Four "
                  "drops is roughly 1 cc, and 200 drops of water weighs "
                  "one Discworld weight unit.  Here are some common "
                  "amounts (I believe these are all British measures, "
                  "but I could have made an error):\n"
                  "    1 teaspoon =      20 drops\n"
                  "    1 tablespoon =    60 drops\n"
                  "    1 ounce =        120 drops\n"
                  "    1 cup =          960 drops\n"
                  "    1 pint =        2400 drops\n"
                  "    1 quart =       4800 drops\n"
                  "    1 gallon =     19200 drops\n"
            }) );
   add_item( "note3",
            ({ "long", "This is a note on adding effects to food, "
                  "especially liquids.",
               "read", "To add an effect to food so that it will be "
                  "applied to the player when consumed, use "
                  "add_eat_effect(<effect>, <arg>).  <arg> (which "
                  "should be an integer) is multiplied by the weight "
                  "of the amount consumed; for liquids, this is generally "
                  "200 drops per weight unit.\n\n"
                  "For example, the wine in the wine bottle adds the "
                  "drunk effect; a final <arg> of 3900 for this effect "
                  "will last 10 minutes on a player with constitution 13 "
                  "(trust me on this).  If we want one pint (2400 drops) "
                  "of wine to have this effect, the <arg> to "
                  "add_eat_effect() should be 3900/(2400/200), or "
                  "325.\n"
            }) );
   add_item( "note4",
            ({ "long", "This is a note on using continuous objects.",
               "read", "Continuous objects (those derived from "
                  "/obj/cont_medium, such as /obj/food) are a way "
                  "to have multiple identical instances of an item "
                  "without having to have a clone for each one.  Each "
                  "unique continuous object is identified by its "
                  "\"medium alias\".  The medium alias must be a single "
                  "word without embedded spaces; by convention, it is "
                  "made by concatenating a series of capitalized words "
                  "that describe it, such as \"RedWine\" or "
                  "\"GroundPurpleMushroom\".  All objects with a common "
                  "medium alias in the same environment are combined "
                  "into a single object.  Also, the reaction handler "
                  "uses the medium alias to identify objects that "
                  "react with one another.\n"
            }) );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "make_bottle", "add_eat_effect", "set_medium_alias",
                   "set_max_weight", "set_max_volume" }) );
   add_property( "keywords",
                ({ "bottle", "vessel", "liquid" }) );
}
void reset() {
   call_out( "check_vessels", 3 );
}
void check_vessels() {
   object wine, coffee;
   if ( !wine_bottle || ( environment( wine_bottle ) != this_object() ) ) {
      wine_bottle = clone_object( "/obj/bottle" );
      wine_bottle->make_bottle( "green", 600 );
      wine_bottle->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again." );
      wine = clone_object( "/obj/reagents/generic_liquid.ob" );
      wine->set_name( "wine" );
      wine->set_short( "red wine" );
      wine->set_long( "This is a deep red wine, $amount_size$.\n");
      wine->set_medium_alias( "RedWine" );
      wine->add_adjective( "red" );
      wine->add_eat_effect( "/std/effects/ingested/drunk", 325 );
      wine->set_amount( 2400 );
      wine->move( wine_bottle );
   }
   if ( !glass || ( environment( glass ) != this_object() ) ) {
      glass = clone_object( "/obj/vessel" );
      glass->set_name( "glass" );
      glass->set_short( "wine glass" );
      glass->set_long( "This is a fine crystal wine glass.\n" );
      glass->set_weight( 4 );
      glass->set_max_weight( 8 );
      glass->set_max_volume( 480 );
      glass->add_adjective( ({ "crystal", "wine" }));
      glass->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again.");
   }
   if ( !cup || ( environment( cup ) != this_object() ) ) {
      cup = clone_object( "/obj/vessel" );
      cup->set_name( "cup" );
      cup->set_short( "coffee cup" );
      cup->set_long( "This is a delicate china coffee cup.  The intricate "
                    "artwork on the side depicts some sort of sexual "
                    "orgy.  Why it's on a coffee cup is beyond me.\n" );
      cup->set_weight( 4 );
      cup->set_max_weight( 8 );
      cup->set_max_volume( 960 );
      cup->add_adjective( ({ "china", "coffee" }) );
      cup->move( this_object(), "Jeremy walks into the room and "
                "leaves $N before walking out again." );
      coffee = clone_object( "/obj/reagents/generic_liquid.ob" );
      coffee->set_name( "coffee" );
      coffee->set_short( "coffee" );
      coffee->set_long( "This is some Klatchian coffee, $amount_size$.  "
                       "It is very dark and aromatic.\n" );
      coffee->set_medium_alias( "KlatchianCoffee" );
      coffee->add_adjective( "klatchian" );
      coffee->add_eat_effect( "/std/effects/ingested/knurd", 325 );
      coffee->set_amount( 960 );
      coffee->move( cup );
   }
}

==================================================
FILE: learning/TinyTown/roads/path.h
==================================================

#include <learning.h>
#define PATH TTOWNROADS

==================================================
FILE: learning/TinyTown/roads/womble01.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "southwestern corner of Womble square" );
  set_long("This is the western edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble02", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  add_exit( "north", PATH +"womble03", "road" );
  add_exit( "northeast", PATH +"womble04", "hidden" );
  add_exit( "east", PATH +"womble02", "road" );
  add_exit( "south", TTOWNBUILDINGS +"item-shop", "door" );
  modify_exit( "south", ({
    "exit mess", "$N leave$s through the door to the south.",
      "enter mess", ({
        1,
          "Chimes start playing as $N enters.",
          "Chimes start playing as $N enter." }),
      "move mess", "Chimes start playing as you enter the shop.\n"
      }));
  set_wall( ({ "move", ({ "up", 100, TTOWNBUILDINGS + "shop-ledge",
                            "$N climb$s up from below." }) }) );
}

==================================================
FILE: learning/TinyTown/roads/womble02.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "southeastern corner of Womble square" );
  set_long("This is the eastern edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble01", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  add_exit( "north", PATH +"womble04", "road" );
  add_exit( "northwest", PATH +"womble03", "hidden" );
  add_exit( "west", PATH +"womble01", "road" );
}

==================================================
FILE: learning/TinyTown/roads/womble03.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "northwestern corner of Womble square" );
  set_long("This is the western edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble01", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  add_exit( "south", PATH +"womble01", "road" );
  add_exit( "southeast", PATH +"womble02", "hidden" );
  add_exit( "east", PATH +"womble04", "road" );
}

==================================================
FILE: learning/TinyTown/roads/womble04.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "northeastern corner of Womble square" );
  set_long("This is the eastern edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble03", PATH +"womble01", PATH +"womble02", }),
             "into", "", "Womble Square" );
  add_exit( "south", PATH +"womble02", "road" );
  add_exit( "southwest", PATH +"womble01", "hidden" );
  add_exit( "west", PATH +"womble03", "road" );
}

==================================================
FILE: learning/TinyTown/buildings/item-shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
  add_property( "determinate", "A " );
  set_short( "simple item shop" );
  set_long( "This is a nice looking shop.  Obviously your shop would have "
            "a much more interesting description.\n");
  set_light( 60 );
  set_room_size( 10 );
  set_zone( "Tiny Town");
  add_exit( "north", TTOWNROADS +"womble01", "door" );
  modify_exit( "nouth", ({
    "exit mess", "Chimes start playing as $N "
      "leave$s through the north door.",
      "enter mess", ({
        1,
          "$N enters from the south.",
          "$N enter from the south." }),
      "move mess", "Chimes start playing as you leave the shop.\n"
      }));
  add_exit("up", PATH+"shop-upstairs", "stair");
  modify_exit("up", ({"upgrade", 9 }));
}

==================================================
FILE: learning/TinyTown/buildings/path.h
==================================================

#include <learning.h>
#define PATH TTOWNBUILDINGS

==================================================
FILE: learning/TinyTown/buildings/shop-ledge.c
==================================================

#include "path.h"
inherit "/std/room/rooftop";
void setup() {
  set_short( "small ledge" );
  set_long( "This is a small ledge just outside the upstairs window of "
						"the item shop.\n");
  set_room_size( 10 );
	set_slope(60, "ledge", TTOWNROADS + "womble01");
	set_weak_messages("The ledge crumbles under your weight.\n",
										"$short$ falls from the crumbling ledge.",
										"$short$ comes crashing to the ground.",
                                                                                "The ledge makes a strange sound.");
	set_weak_roof(2500, TTOWNROADS + "womble01");
	add_exit("window", PATH+"shop-upstairs", "window");
	set_wall( ({ "bottom", ({ TTOWNROADS + "womble01", 200 }), }) );
	set_wall( ({ "move", ({ "down", 30, TTOWNROADS + "womble01",
														"$N climb$s down from above." }) }) );
}

==================================================
FILE: learning/TinyTown/buildings/shop-upstairs.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
  set_short( "bedroom" );
  set_long( "This is a small bedroom above the shop.  There is a window "
            "in the north wall.\n");
  set_light( 60 );
  set_room_size( 10 );
  set_zone( "Tiny Town");
  add_exit("window", PATH+"shop-ledge", "window");
  add_exit("down", PATH +"item-shop", "stair" );
  modify_exit("down", ({ "downgrade", 9 }));
}

==================================================
FILE: learning/functions/function_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string function_chosen;
void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", PATH +"functions", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return function_chosen;
}
void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s",
                     exit_letter,
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/functions/path.h
==================================================

#include <learning.h>
#define PATH FUNCTIONS

==================================================
FILE: learning/examples/player_houses/npcs/surface_decorator.c
==================================================

inherit "/std/npc/surface_decorator";
void setup() {
    set_name( "worker" );
    set_short( "construction worker" );
    add_property( "determinate", "a " );
    add_adjective( "construction" );
    add_property( "unique", 1 );
    setup_nationality( "/std/nationality/agatean", "Bes Pelargic" );
    basic_setup( "human", "warrior", 30 );
    set_gender( 1 );
    set_long("This is a construction worker.  You can use him to "
        "decorate surfaces in player housing to the exact specifications "
        "that you will set later in this file.  He is slightly grubby, "
        "is covered in dust and paint, and likes to do wolf whistles.\n");
    add_property( "place", "Counterweight Continent" );
    add_allowed_surface( "floor" );
    add_allowed_surface( "wall" );
    add_fitted_surface( "plush green carpet", "covered with plush "
        "green carpet", 1000 );
    add_fitted_surface( "plush red carpet", "covered with plush "
        "red carpet", 1000 );
    add_fitted_surface( "plush yellow carpet", "covered with plush "
        "yellow carpet", 1000 );
    add_fitted_surface( "plush blue carpet", "covered with plush "
        "blue carpet", 1000 );
    set_under_construction_mess( "covered in dust, plaster and carpet bits" );
    add_allowed_domain( "/w/una" );
    add_allowed_domain( "/d/cwc/Bes_Pelargic" );
    set_responses( ({
        "'I don't fit those kinds of surfaces matey!",
        "'I've never heard of those sort of carpets, arrrrr.",
        "'Arr, you don't own this place, mister!",
        "'I can't be decoratin' these here surfaces, shogun!  You should "
        "take me to a house!",
        "'Arr matey, something went horribly wrong!",
        "'Arrrr matey, all done!",
        "'You don't have enough money to pay for the $decor$!  It "
        "will cost you $amount$, guv!",
        "'I can fit $allowed$ with any of the following:",
        "'Cor blimey mister, I haven't got any stock.",
        "'Okey doke, I'll have it done in a jiffy guv'nor!",
        "'What?  Who sed dat?",
        "'I've already got this great job with $employer$, mate!",
        "'Righty-o, you just take me to the room you want spiffied "
        "up and ask me to fit something!",
        "'Sorry matey, bad karma over that way."
    }) );
}

==================================================
FILE: learning/examples/terrain_map/basic/entrance.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("field entrance");
  set_long("You are at the entrance to a large grassy field.\n");
  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
  add_exit("north", __DIR__ + "path:2:0", "road");
}

==================================================
FILE: learning/examples/terrain_map/basic/field.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("grassy field");
  set_long("This is a large grassy field.\n");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}

==================================================
FILE: learning/examples/terrain_map/basic/field_handler.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_HANDLER_BASE;
string query_map_file() { return __DIR__ + "field"; }
void  setup_handler()
{
   add_obstacle_type("*", "A tall fence blocks your way to the $D.",
                "fence", "A tall, unclimable wooden fence.");
   add_room_type(".", __DIR__ + "field");
   add_road_type(",", __DIR__ + "path",
            "The path meanders $D.",
            "A small path meanders its way across the field to the $D.",
            "path",
            "The path has been trampled down by the hooves of time.");
   add_feature("bigtree", 4, 1, 1, 1, 4,
                ({ "A giant tree towers over you to the $D.",
                   "A little way to the $D, you can see a huge tree.",
                   "You can just make out a large tree, a way off in an "
                   "$Derly direction." }),
                   "tree", "A fairly large, and quite beautiful tree." );
   set_feature_chats("bigtree",
                     ({ "The branches on the tree to the $D "
                        "sway slightly in the breeze." }) );
   add_exit_at(2, 0, "south", __DIR__ + "entrance", "road");
}

==================================================
FILE: learning/examples/terrain_map/basic/path.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("trampled path");
  set_long("This path meanders through a large grassy field.\n");
  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}

==================================================
FILE: learning/examples/npcs/barley.c
==================================================

inherit "/obj/monster";
void setup() {
    set_name( "barley" );
    set_short( "Barley" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Barley is a friendly, talkative NPC.  He chats and emotes."
    "  Also, he will occasionally give out quest hints.  If you try and"
    " kill him, he will become more animated.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  3, "'I say this quite often.",
                  3, ":does this quite often.",
                  3, "Chats can appear without the NPC name in them.",
                  1, "'I only give out quest hints 10% of the time."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
}

==================================================
FILE: learning/examples/npcs/cuthbert.c
==================================================

#include <armoury.h>
#define TO this_object()
inherit "/obj/monster";
object cape, trousers;
void setup() {
    set_name( "cuthbert" );
    set_short( "Cuthbert" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Cuthbert is a fashion victim.  Not content with off the peg "
    "stuff, he wants clothing unique to him.  Fair enough, let's give him"
    " some.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
         ARMOURY->request_item( "short sword",
         70+random(30))->move( TO );
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move( TO );
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move( TO );
   trousers = clone_object( "/obj/clothing" );
   trousers->set_name( "britches" );
   trousers->add_adjective(({"pair", "of"}));
   trousers->set_short( "pair of britches" );
   trousers->add_alias("trousers");
   trousers->set_long( "These are funky purple flaired britches, made of camel"
   "skin with beaver fur lining.\n" );
   trousers->set_value( 100 );
   trousers->set_weight( 7 );
   trousers->set_type( "trousers" );
   trousers->add_pocket( "side", 100 );
   trousers->add_pocket( "side", 100 );
   trousers->set_damage_chance( 10 );
   trousers->set_max_cond( 800 );
   trousers->set_cond( 600 + random( 200 ) );
   trousers->move( TO );
         cape = clone_object( "/obj/clothing" );
   cape->set_name( "cape" );
   cape->set_short( "orange cape" );
   cape->add_adjective("orange");
   cape->set_long( "Orange velvet has been made into a large cape.  It is bright "
   "and garish.\n" );
   cape->set_value( 100 );
   cape->set_weight( 7 );
   cape->set_type( "cape" );
   cape->set_damage_chance( 10 );
   cape->set_max_cond( 800 );
   cape->set_cond( 600 + random( 200 ) );
   cape->move( TO );
      init_equip();
         give_money( 10, 30, "Ankh-Morpork pence" );
}

==================================================
FILE: learning/examples/npcs/macgrew.c
==================================================

#include <armoury.h>
#define TO this_object()
inherit "/obj/monster";
void setup() {
    set_name( "macgrew" );
    set_short( "MacGrew" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("MacGrew is a warm, armed NPC.  He models some of the latest "
    "fashions, but beware of mentioning them in the long() because he may "
    "have them stolen, or broken.  Let players look at him.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
         ARMOURY->request_item( "short sword",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move(this_object());
         init_equip();
         give_money( 10, 30, "Ankh-Morpork pence" );
}

==================================================
FILE: learning/examples/npcs/path.h
==================================================

#define PATH "/d/learning/examples/npcs/"

==================================================
FILE: learning/examples/npcs/pugh2.c
==================================================

inherit "/obj/monster";
void setup() {
    set_name( "pugh" );
    set_short( "Pugh" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("This is Pugh.  He exists in a separate file, so can easily be "
    "loaded in a variety of locations at once.  Essentially, he is identical"
    " to Pugh in the other room.\n");
    basic_setup ("human", "warrior", 10);
    set_gender( 1 );
}

==================================================
FILE: learning/examples/npcs/rat.c
==================================================

inherit "/obj/monster";
void setup() {
    string *name_adjectives = ({ "furry", "manky",
      "flea-ridden", "obnoxious", "sharp-toothed", "stinky", "dirty, stinking",
      "brown", "beady-eyed", "corpse-eating" });
    string adjective;
    adjective = name_adjectives[random(sizeof(name_adjectives))];
    set_name("rat");
    add_alias("rodent");
    set_gender(1 + random(2));
    set_short(adjective + " rat");
    add_adjective(adjective);
    set_long("The learning domain is full of rats.  This one appears "
    "not to have eaten for some hours and has a look"
    " of hunger in " + query_possessive()
      + " eyes.\n");
    basic_setup ("rat", "fighter", 2 + random(5));
}

==================================================
FILE: learning/examples/npcs/room1.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "cloned NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room holds a very simple NPC.  He is a fighter.  His "
    "code is within the room code.  If he's not here, type update, and"
    ", like magic, he should appear.  If he doesn't, panic.\n");
    add_exit("onwards", PATH +"room2", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( "/obj/monster" );
    npc -> set_name("pugh");
    npc -> set_short("Pugh");
    npc -> add_property("determinate", "");
    npc -> add_alias( ({"npc", "warrior", "man"}) );
    npc -> set_long("This is Pugh.  He was cloned here, and "
    "this is his world.  Welcome to it.\n");
    npc -> basic_setup("human", "warrior", 10);
    npc -> set_gender( 1 );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room2.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "seperate file NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here is cloned from another file, and brought here."
    "  This method means the same NPC can easily be loaded into a variety "
    "of locations, without the need to repeat much code.  The npc file is "
    "in /d/learning/examples/npcs/pugh2.c.\n");
    add_exit("backwards", PATH +"room1", "door");
    add_exit("onwards", PATH +"room3", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"pugh2" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room3.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "variable NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room clones an NPC from a single file.  However, the NPC"
    " has built in variety.  Its description changes randomly.  Typing "
    "update will bring a new version of the NPC here, each time it"
    " will be different.\n");
    add_exit("backwards", PATH +"room2", "door");
    add_exit("onwards", PATH +"room4", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"rat" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room4.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "chatting NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here gets to talk a little bit.  He has both random"
    " chats, and chats for use in combat which make him more entertaining.  "
    "Some chats appear more often than others.\n");
    add_exit("backwards", PATH +"room3", "door");
    add_exit("onwards", PATH +"room5", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"barley" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room5.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "room with a non-naked NPC" );
    add_property( "determinate", "the " );
    set_long( "We ought to clothe our NPCs and give them weapons, else how "
    "will the poor darlings survive the winter, and fend off attackers?  "
    "The easiest way is to give them items which already exist on the MUD"
    " via the armoury.\n");
    add_exit("backwards", PATH +"room4", "door");
    add_exit("onwards", PATH +"room6", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"macgrew" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room6.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "room with a fashion-victim NPC" );
    add_property( "determinate", "the " );
    set_long( "The NPC is here is not content with last year's fashion.  "
    "He wants new, exciting clothes, to be unique to him.  He has some "
    "standard stuff, but he has things which are unique to him.\n");
    add_exit("backwards", PATH +"room5", "door");
    add_exit("onwards", PATH +"room7", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"cuthbert" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/handlers/quit.c
==================================================

#include <learning.h>
#define SAVE_FILE SAVEPATH +"search_quit"
inherit "/std/room/basic_room";
mapping locations;
void setup() {
   set_short( "quit handler of the search rooms" );
   set_light( 50 );
   set_long( "You are in the quit_handler of the search rooms of the learning "
            "domain.  In normal use, people only end up in the quit_handler "
            "if something goes wrong, since the event_enter() function will "
            "send them on to the correct place immediately.\n" );
   add_exit( "back", ENTRANCE, "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded( (: restore_object, SAVE_FILE :) );
   call_out( "check_names", 2 );
}
void save_this() { unguarded( (: save_object, SAVE_FILE :) ); }
void check_names() {
   string word;
   foreach ( word in keys( locations ) )
      if ( !"/secure/login"->test_user( word ) )
         locations = m_delete( locations, word );
   save_this();
}
void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         (string *)place->query_keywords();
   if ( !locations[ (string)player->query_name() ] ) {
      locations[ (string)player->query_name() ] =
          (string)place->query_marker();
   }
   save_this();
}
void remove_from_list( object player ) {
   string word;
   word = (string)player->query_name();
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
}
void event_enter( object player, string words, object from ) {
   string location, word;
   if( from ) {
      return;
   }
   word = (string)player->query_name();
   if ( !locations[ word ] ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   if ( pointerp( locations[ word ] ) ) {
      location = (string)SEARCH->find_room( locations[ word ] );
   } else {
      location = (string)SEARCH->find_function_room( locations[ word ] );
   }
   player->move( location, "$N enter$s the game." );
}

==================================================
FILE: learning/handlers/request.c
==================================================

#include <learning.h>
#define SAVE SAVEPATH +"request"
mixed *requests;
void create() {
   seteuid( (string)master()->get_bb_uid() );
   unguarded( (: restore_object, SAVE :) );
   if( !requests ) requests = ({ });
}
void save_me() {
   unguarded( (: save_object, SAVE :) );
}
string query_list() {
   int i;
   string ret;
   mixed request;
   if ( !sizeof( requests ) ) {
      return "There are no requests at the moment.\n";
   }
   ret = "$P$Requests$P$The following requests have been made:\n";
   foreach( request in requests ) {
      if ( !request[ 1 ] ) {
         ret += sprintf( "%4d. $C$%s asked for %s.\n", i,
                        request[ 0 ], request[ 2 ] );
      } else {
         ret += sprintf( "%4d. $C$%s asked for %s.\n       Claimed by $C$%s\n", i,
                        request[ 0 ], request[ 2 ],
                        request[ 1 ]);
      }
   }
   return ret;
}
void add_request( string name, string words ) {
   requests += ({ ({ name, 0, words }) });
   save_me();
}
int claim_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      requests[ number ][ 1 ] = name;
      save_me();
      return 1;
   }
   return 0;
}
int remove_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      if ( requests[ number ][ 0 ] == name || name == CURRENT_LORD ) {
         requests = delete( requests, number, 1 );
         save_me();
         return 1;
      }
   }
   return 0;
}

==================================================
FILE: learning/handlers/search.c
==================================================

#include <learning.h>
#define SAVE SAVEPATH +"search"
mapping rooms,
        objects,
        keywords,
        functions;
string *directories;
nosave string word;
void create() {
   seteuid( (string)master()->get_bb_uid() );
   unguarded( (: restore_object, SAVE :) );
}
mixed get_keywords( string *words ) {
   string *found_words, *found_rooms, *found_objects, key, *value;
   if( sizeof( words ) ) {
      found_objects = keys( keywords );
      foreach( word in words ) {
         if( objects[ word ] ) {
            found_objects = filter_array( found_objects,
                (: member_array( $1, objects[ word ] ) != -1 :) );
         } else {
            found_objects = ({ });
         }
      }
      found_rooms = keys( keywords );
      foreach( word in words ) {
         if( rooms[ word ] ) {
            found_rooms = filter_array( found_rooms,
                (: member_array( $1, rooms[ word ] ) != -1 :) );
         } else {
            found_rooms = ({ });
         }
      }
      found_words = ({ });
      foreach( word in found_rooms ) {
         found_words -= keywords[ word ];
         found_words += keywords[ word ];
      }
      foreach( word in found_objects ) {
         found_words -= keywords[ word ];
         found_words += keywords[ word ];
      }
      found_words -= words;
   } else {
      found_rooms = ({ });
      foreach( key, value in rooms ) {
         found_rooms -= value;
         found_rooms += value;
      }
      found_objects = ({ });
      foreach( key, value in objects ) {
         found_objects -= value;
         found_objects += value;
      }
      found_words = keys( rooms );
      found_words -= keys( objects );
      found_words += keys( objects );
   }
   return ({ found_words, found_rooms, found_objects });
}
void update_info_for( string file ) {
   string *words, word;
   object obj;
   if( !catch( file->force_load() ) ) {
      obj = find_object( file );
      words = obj->query_property( "commented functions" );
      if( words ) {
         functions[ file ] = words;
      }
      words = obj->query_property( "keywords" );
      if( words ) {
         keywords[ file ] = words;
         if( function_exists( "add_exit", obj ) ) {
            foreach ( word in words ) {
               if( rooms[ word ] ) {
                  rooms[ word ] -= ({ file });
                  rooms[ word ] += ({ file });
               } else {
                  rooms[ word ] = ({ file });
               }
            }
         } else {
            foreach ( word in words ) {
               if( objects[ word ] ) {
                  objects[ word ] -= ({ file });
                  objects[ word ] += ({ file });
               } else {
                  objects[ word ] = ({ file });
               }
            }
         }
      }
      if( !directories ) {
         unguarded( (: save_object, SAVE :) );
      }
   }
}
void update_search( string room ) {
   object *obs;
   int i;
   obs = all_inventory( find_object( room ) );
   i = sizeof( obs );
   while( i--  ) {
      if ( userp( obs[ i ] ) ) {
         obs[ i ]->move( "/room/void" );
      } else {
         obs = delete( obs, i, 1 );
      }
   }
   room->dest_me();
   room->force_load();
   obs->move( room );
}
void collect_one() {
   string dir, file, *funcs;
   mixed dirs, file_info;
   dir = directories[ 0 ];
   dirs = get_dir( dir, -1 );
   if( dirs ) {
      foreach ( file_info in dirs ) {
         if( file_info[ 1 ] == -2 ) {
            if( file_info[ 0 ] != "old" ) {
               directories = directories + ({ dir + file_info[ 0 ] +"/" });
            }
         } else {
            if( ( sizeof( file_info[ 0 ] ) > 2 ) &&
                ( file_info[ 0 ][ <2 .. <1 ] == ".c" ) ) {
               update_info_for( dir + file_info[ 0 ][ 0 .. <3 ] );
            }
         }
      }
   }
   directories = directories[ 1 .. <1 ];
   if( find_call_out( "collect_one" ) == -1 && sizeof( directories ) ) {
      call_out( "collect_one", 3 );
   } else if( !sizeof( directories ) ) {
      tell_object( find_living( "olorin" ), "Collect finished.\n" );
      directories = 0;
      unguarded( (: save_object, SAVE :) );
      update_search( LEARNING +"search" );
      update_search( LEARNING +"functions" );
   }
}
void collect() {
   rooms=([ ]);
   objects=([ ]);
   functions=([ ]);
   keywords=([ ]);
   directories=({ "/d/learning/" });
   collect_one();
}
int query_collecting() {
   if( directories ) {
      return 1;
   } else {
      return 0;
   }
}
string find_room( string *words ) {
   object thing, *things;
   string word_mark;
   if( !sizeof( words ) )
     return LEARNING +"search";
   word_mark = implode( sort_array( words, 1 ), ", " );
   things = children( SEARCH_ROOM ) - ({ find_object( SEARCH_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word_mark )
        return file_name( thing );
   }
   thing = clone_object( SEARCH_ROOM );
   thing->set_marker( word_mark, words );
   return file_name( thing );
}
string find_function_room( string word ) {
   object thing, *things;
   if( !word )
     return LEARNING +"functions";
   things = children( FUNCTION_ROOM ) - ({ find_object( FUNCTION_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word )
        return file_name( thing );
   }
   thing = clone_object( FUNCTION_ROOM );
   thing->set_marker( word );
   return file_name( thing );
}
string *query_functions() {
   string *functions_found, key, *value;
   functions_found = ({ });
   foreach ( key, value in functions ) {
      functions_found -= value;
      functions_found += value;
   }
   return sort_array( functions_found, 1 );
}
string *query_rooms_with_function( string word ) {
   string *rooms_found, key, *value;
   rooms_found = ({ });
   foreach ( key, value in functions ) {
      if ( member_array( word, value ) != -1 )
        rooms_found += ({ key });
   }
   return uniq_array(rooms_found);
}

==================================================
FILE: learning/newbie/introduction/examples/.advanced_item_4.food_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/advanced_item_4.food#1" );
  call_other( clone, "set_name", "sandwich"  );
  call_other( clone, "set_short", "monkey sandwich"  );
  call_other( clone, "add_adjective", ({ "monkey" })  );
  call_other( clone, "set_value", 0  );
  call_other( clone, "set_weight", 1  );
  call_other( clone, "set_long", "This is a monkey sandwich.  Made from real monkey.  Mmm!\n"  );
  call_other( clone, "add_eat_effect",  "/std/effects/ingested/poison", 600 );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/.simple_object.clo_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/clothing.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_object.clo#1" );
  call_other( clone, "set_name",  "dungarees"  );
  call_other( clone, "set_short",  "pair of waterproof dungarees"  );
  call_other( clone, "set_long",  "This is a pair of waterproof dungarees.  Luckily they "     "are also ooze proof.\n"  );
  call_other( clone, "add_adjective",  ({"pair of", "waterproof"})  );
  call_other( clone, "set_weight",  45  );
  call_other( clone, "set_value",  4000  );
  call_other( clone, "setup_clothing",  50000  );
  call_other( clone, "set_type",  "robe" );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/.simple_weapon.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_weapon.wep#1" );
  call_other( clone, "set_name",  "mop"  );
  call_other( clone, "set_short",  "dirty mop"  );
  call_other( clone, "set_long",  "This is a dirty mop, dripping with ooze.\n"  );
  call_other( clone, "add_adjective",  "dirty"  );
  call_other( clone, "set_weight",  20  );
  call_other( clone, "set_value",  2000  );
  call_other( clone, "new_weapon", 10000  );
  call_other( clone, "add_attack",  "prod", 50, ({ 5, 6, 6 }), "blunt", "blunt", 0  );
  call_other( clone, "add_attack",  "whack", 50, ({ 10, 10, 5 }), "blunt", "blunt", 0 );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_1.c
==================================================

inherit "/obj/baggage";
void setup() {
    set_name("bag");
    set_short("little green bag");
    set_long("This is a little green bag.\n");
    add_adjective(({"little", "green"}));
    set_weight(5);
    set_max_weight(20);
}
int test_add(object ob, int flag) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    }
    else {
        return ::test_add(ob, flag);
    }
}
int test_remove(object ob, int flag, mixed dest) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    }
    else {
        return ::test_remove(ob, flag, dest);
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_2.c
==================================================

inherit "/obj/clothing";
void setup() {
    set_name("trousers");
    set_short("pair of flourescent pink flared trousers");
    add_adjective(({"pair of", "flourescent", "pink", "flared"}));
    set_long("This is a pair of extremely stylish, extremely "
    "tasteful, flourescent pink flared trousers.\n");
    set_weight(10);
    set_value(0);
    set_type("trousers");
    add_alias("flares");
    set_main_plural("pairs of flourescent pink flared trousers");
    add_plural("trousers");
    setup_clothing(10000);
    add_pocket("left", 20);
    add_pocket("right", 20);
    set_wear_remove_func(base_name(this_object()), "do_wear_stuff");
}
void do_wear_stuff(object ob) {
    if(this_player()->query_name() != "drakkos") {
        if(!ob) {
            tell_object(this_player(), "You heave a sigh of relief as "
                "you remove the ghastly garment.\n");
        }
        else {
            tell_object(this_player(), "Ye gods, are you really going "
            "to wear those hideous things?!\n");
        }
    }
    else {
        if(!ob) {
            tell_object(this_player(), "Awww, why are you taking off your "
                "super-cool slacks?\n");
        }
        else {
            tell_object(this_player(), "You feel Real Cool as you slip "
                "into your fabulous flares!\n");
        }
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_3.c
==================================================

inherit "/obj/weapon";
void setup() {
    set_name("ruler");
    set_short("wooden ruler");
    add_adjective("wooden");
    set_long("This is a thick, wooden ruler, with the inches "
        "inked out in black.\n");
    set_weight(1);
    set_value(0);
    new_weapon(5000);
    add_attack("rap", 50,({ 25, 10, 5 }), "blunt", "blunt", "do_shame");
    add_attack_message( "rap", "blunt",
   ({
    0,({ "You rap $hcname$ smartly across the knuckles with your "
        "ruler.\n",
        "$mcname$ raps you smartly across the knuckles with $mposs$ "
            "ruler.\n",
        "$mcname$ raps $hcname$ smartly across the knuckles with "
            "$mposs$ ruler.\n"})
    }));
    set_wield_func( "test_creator", base_name( this_object() ) );
}
int test_creator(object ob)  {
    if(!ob) {
        return 1;
    }
    if(ob->query_corpse()) {
        return 1;
    }
    if(ob->query_creator()) {
        tell_object(ob, "You have been deemed worthy, leetle creator!\n");
        return 1;
    }
    else {
        tell_object(ob, "You have been deemed unworthy, leetle player!\n");
        return 0;
    }
}
void do_shame( int damage, object attack_ob, object attack_by, string
    type, string name ) {
    tell_object(attack_ob, "Your knuckles %^BOLD%^sting!%^RESET%^\n");
    tell_object(attack_by, "You feel strangely satisfied as " +
        attack_ob->one_short() + " whimpers in pain!\n");
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_npc.c
==================================================

#include <armoury.h>
inherit "/obj/monster";
void do_bunny(object, object);
void do_maintain(object, object);
void setup() {
    set_name("gnome");
    set_short("laughing gnome");
    set_long("This is a little, friendly looking gnome.  Well... "
        "friendly looking aside from the vicious sharp teefs and the "
        "wicked razor-like claws.  He has laughter lines all over "
        "his face, tho', so he can't be all bad.\n");
    add_property("unique", 1);
    basic_setup("gnome", "wizard", 50);
    set_gender("male");
    set_int(23);
    set_str(18);
    set_wis(18);
    add_skill_level("magic", 100);
    add_skill_level("fighting", 50);
    load_chat(20,({
        1, "' Ha ha ha!.",
        1, "' He he he!.",
        2 , "' I'm the laughing gnome, and you can't catch me!",
        1 , "#charm_women",
    }) );
    load_a_chat(20,({
        2, ": bares his teeth.",
        1, "' I'll get my brother Fred onto you!.",
        2 , "' I'll call out the Gnome Guard!",
    }) );
    add_spell("bunnies", "/obj/spells/fire_bunny", "cast_spell");
    add_spell("flowers", "/obj/spells/flowers", "cast_spell");
    add_spell("shield", "/obj/spells/small_shield", "cast_spell");
    add_combat_action(25, "bunny_them",(: do_bunny :));
    add_combat_action(25, "maintain_me",(: do_maintain :));
    add_attack( "claws", 88,({ 10, 8, 20 }), "sharp", "sharp", 0 );
    add_attack( "teeth", 88,({ 5, 5, 25 }), "pierce", "pierce", 0 );
    add_attack_message( "claws", "sharp",
   ({
    100,
       ({ "You slice $hcname$ with your claws.\n",
            "$mcname$ slices you with $mposs$ claws.\n",
            "$mcname$ slices $hcname$ with $mposs$ claws.\n"}),
    200,
       ({ "You rip $hcname$ apart with your claws.\n",
            "$mcname$ rips you apart with $mposs$ claws.\n",
            "$mcname$ rips $hcname$ apart with $mposs$ claws.\n"}),
    0,
       ({ "You scratch $hcname$ viciously with your claws.\n",
            "$mcname$ scratches you viciously with $mposs$ claws.\n",
            "$mcname$ scratches $hcname$ viciously with $mposs$ claws.\n"})
    }));
    add_attack_message( "teeth", "pierce",
   ({
    100,
       ({ "You nibble $hcname$ with your teeth.\n",
            "$mcname$ nibbles you with $mposs$ teeth.\n",
            "$mcname$ nibbles $hcname$ with $mposs$ teeth.\n"}),
    200,
       ({ "You chew on $hcname$ with your teeth.\n",
            "$mcname$ chews on you with $mposs$ teeth.\n",
            "$mcname$ chews on $hcname$ with $mposs$ teeth.\n"}),
    0,
       ({ "You sink your teeth into $hcname$.\n",
            "$mcname$ sinks $mposs$ teeth into you.\n",
            "$mcname$ sinks $mposs$ teeth into $hcname$.\n"})
    }));
}
void charm_women() {
    object player;
    foreach(player in all_inventory(environment(this_object()))) {
        if(interactive(player) && player->query_gender() == 2) {
            queue_command("cast flowers");
            queue_command("give flowers to " + player->query_name());
            queue_command("bow with a flourish");
            return;
        }
    }
}
void do_bunny(object attacker, object target) {
    object carrot,torch;
    if(target != this_object() ) {
        if(!sizeof(match_objects_for_existence("carrot", this_object()))) {
            carrot =ARMOURY->request_item ("carrot");
            carrot->move(this_object());
        }
        if(!sizeof(match_objects_for_existence("torch", this_object()))) {
            torch = ARMOURY->request_item ("torch");
            torch->move(this_object());
        }
        do_command("cast bunnies on " + target->query_name());
    }
}
void do_maintain(object attacker, object target) {
    object temp;
    if(!sizeof(match_objects_for_existence("shields", this_object()))) {
        temp = ARMOURY->request_item("wooden djelian shield", 100);
        temp->move(this_object());
    }
    do_command("cast shield on " + this_object()->query_name());
}
void adjust_hp(int number) {
    return;
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_1.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("market square");
    set_day_long("This is a lovely market square, where people mill about "
        "doing the kind of things you would expect people to do in a lovely "
        "market square.  Brightly coloured stalls stand in the corners of "
        "the market.  They seem to do good business judging by the steady "
        "stream of consumers ducking under the flaps.\n");
    set_night_long("The darkness settles on this market square like a thick "
        "black blanket.  The stalls, undoubtedly merry and brightly coloured "
        "during the day, lie dormant and unusued.  The silence is "
        "deafening.\n");
    add_property("climate",({20, 20, 10}));
    set_light(80);
    add_zone("my rooms");
    set_linker(({PATH + "advanced_room_2", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
    add_day_item(({"people", "consumers"}), "The people mill around happily, "
        "browsing the goods and talking with the stallowners.");
    add_night_item(({"people", "consumers"}), "They're all tucked up in "
        "bed.  Only crazed retrobrates like you are awake at this time of "
        "night.");
    add_day_item("stall", "The stalls are brightly coloured and really "
        "quite merry.");
    add_night_item("stall", "The stalls lie dormant in the night.  Creepy!");
    room_day_chat(({120,240,({
        "People mill around happily.",
        "The brightly coloured stalls attract the eye.",
    })}));
    room_night_chat(({120,240,({
        "The only sound is the chirping of the crickets.",
        "The stalls loom ominously in the darkness.",
    })}));
    add_exit("north", PATH + "advanced_room_3", "road");
    add_exit("south", PATH + "advanced_room_2", "road");
    add_exit("east", "/w/drakkos/workroom", "road");
    add_exit("west", PATH + "simple_room", "road");
    modify_exit("east",({"look", "You get the feeling that peeking into a "
        "creator's workroom is very rude!", "function", "test_creator"}));
}
int do_search(string str) {
    if(!sizeof(str)) {
        return -1;
    }
    if(str == "shards") {
        tell_object(this_player(), "You search through the shards, but "
            "succeed only in cutting your hand slightly.  Ouch!\n");
        this_player()->adjust_hp(-100);
        if(this_player()->query_hp() < 0) {
            this_player()->attack_by(this_object());
        }
    return 1;
    }
    else {
        notify_fail("Try searching something else, perhaps?\n");
        return 0;
    }
}
string query_death_reason() {
    return "a nasty cut in the newbie creator tutorial room";
}
int test_creator(string str, object ob, string special_mess) {
    if(!ob->query_creator()) {
        notify_fail ("");
        tell_object (ob, "You are not a creator!  You may not pass!\n");
        return 0;
    }
    else {
        tell_object(ob, "You feel a tingle down your spine as you take the "
            "exit.\n");
        return 1;
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_2.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");
    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
    set_light(80);
    add_zone("my rooms");
    add_item("road", "I *said*, there's nothing interesting at all here.");
    add_exit("north", PATH + "advanced_room_1", "road");
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_3.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");
    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_2"}),
        "onto", "on", "the newbie creator marketplace");
    set_light(80);
    add_zone("my rooms");
    add_item("road", "I *said*, there's nothing interesting at all here.");
    add_exit("south", PATH + "advanced_room_1", "road");
}

==================================================
FILE: learning/newbie/introduction/examples/path.h
==================================================

#define PATH "/d/learning/newbie/introduction/examples/"

==================================================
FILE: learning/newbie/introduction/examples/simple_npc.c
==================================================

inherit "/obj/monster";
void setup() {
  set_name("blob");
  set_short("grey blob");
  set_long("This is a grey blob.  It is grey.  It is also quite "
      "blobby.\n");
  basic_setup("human", "warrior", 10);
  set_gender("male");
  add_adjective(({"oozing", "grey"}));
  set_main_plural("grey blobses");
  add_alias("porridge");
  add_respond_to_with(({ "@say",({"blob", "grey"}),
      }), "say Yes, I am a grey blob.");
  add_respond_to_with(({ "@say",({"ooze", "blue", "cardboard"}),
     ({"porridge", "bing", "womble"}),
      }), "' Yes, I'm oozing quite nicely, like grey "
          "blobs do.  Like porridge!");
  add_respond_to_with(({ "@thank", ({ "you", "blob" }) }),
      "' Aw, shucks. T'weren't nuthin'.");
  add_respond_to_with(({ ({"@gnaw", "@bite", "@chew"}), ({ "you",
    "blob" }) }),
      ({"' What did you do that for?!",  "scream", "cry", "weep"}));
  load_chat(20,({ 2, ": oozes around.",
      1, "' I'm very grey.",
      2 , "' I'm a blob.",
      2 , "@bing",
  }) );
  load_a_chat(20,({ 2, ": oozes all over you.",
      1, "' Lemme alone!.",
      2 , ": sobs bitter, slimy tears.",
  }) );
}

==================================================
FILE: learning/newbie/introduction/examples/simple_object.c
==================================================

inherit "/obj/clothing";
void setup() {
    set_name("dungarees");
    set_short("pair of waterproof dungarees");
    add_adjective(({"pair of", "waterproof"}));
    set_long("This is a pair of waterproof dungarees.  Luckily they "
        "are also ooze proof.\n");
    add_adjective(({"pair of", "waterproof"}));
    set_weight(45);
    set_value(4000);
    setup_clothing(50000);
    set_type("robe");
}

==================================================
FILE: learning/newbie/introduction/examples/simple_room.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
    set_short("blobby lair");
    set_long("This is where the grey blob lives.  All around lie "
        "frogs, and wombles, and strange oozy things.  It's a "
        "very nice lair, as lairs go.\n");
    add_property("determinate", "a ");
    set_light(50);
    add_item(({"frog", "pinkfish", "toad"}),({"long", "The frogs are very "
        "nice.  Very froggy.", "position", "one of the poor leetle "
        "frogs."}));
    add_item(({"womble", "uncle bulgaria"}),({"long", "It's Uncle "
        "Bulgaria!", "pet", "You pet Uncle Bulgaria.  He growls and "
        "chews the nails off your hand.\n", "snuggle", "Uncle Bulgaria gnaws "
        "on your teeth.\n"}));
    add_item("strange oozy things", "Ewww!");
    add_zone("my rooms");
    add_sign("This is a nice sign.\n", "Do Notte Feed Thee Blob!",
        "nice sign", "sign", "common");
    room_chat(({120,240,({
        "A thick blob of goo oozes over one of the frogs.",
        "The womble bings quietly.",
        "The frogs ribbit in abstract contemplation.",
    })}));
    add_exit("east", PATH + "advanced_room_1", "road");
}
void reset() {
    call_out("after_reset", 3);
}
void after_reset() {
    object ob = find_object
        (PATH + "simple_npc");
    if(!ob) {
        ob=load_object(PATH + "simple_npc");
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
    else if(!environment(ob)) {
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
}

==================================================
FILE: learning/cutnpaste/althea.c
==================================================

#define CREATOR "Ceres"
#include <armoury.h>
inherit "/obj/monster";
#define HEAL_COST 30
object flail;
int dickens_warned;
void do_heal(object);
void check_injured();
void maintain_self(object, object);
void fighting_stuff(object, object);
void ritual_stuff(object, object);
void setup() {
    set_name("althea");
    set_short("Althea of Pishe");
    set_main_plural("Altheas of Pishe");
    set_long("This is Althea, an Archcardinal of Pishe.  She is a beautiful, "
      "middle-aged woman with a kind face.  She almost seems to glow "
      "with a gentle power.\n");
    add_adjective(({"arch", "cardinal", "of", "pishe"}));
    add_alias(({"priestess", "archcardinal", "cardinal"}));
    add_property("determinate","");
    add_property("unique", 1);
    set_gender("female");
    set_race("human");
    set_guild("priest");
    set_deity("pishe");
    set_level(400);
    set_height(140);
    set_weight(1000);
    set_al(-2000 - random(501));
    set_con(15);
    set_dex(13);
    set_int(12);
    set_str(15);
    set_wis(20);
    add_skill_level("fighting", 300, 0);
    add_skill_level("fighting.combat.melee.blunt", 150, 0);
    add_skill_level("faith", 200);
    add_skill_level("faith.rituals.misc.area", 300);
    add_skill_level("other.perception", 400, 0);
    add_skill_level("other.health", 200, 0);
    add_known_command("strike");
    add_known_command("crush");
    add_spell("cure light wounds", "/obj/rituals/curelight", "cast_spell");
    add_spell("cure serious wounds", "/obj/rituals/cureserious", "cast_spell");
    add_spell("cure critical wounds", "/obj/rituals/curecritical", "cast_spell");
    add_spell("minor shield", "/obj/rituals/minorshield", "cast_spell");
    add_spell("dust devil", "/obj/rituals/dustdevil", "cast_spell");
    add_combat_action(100, "maintenance", (: maintain_self :)) ;
    add_combat_action(70, "fighting_stuff", (: fighting_stuff :));
    add_combat_action(50, "ritual_stuff", (: ritual_stuff :));
    ARMOURY->request_item("white cotton tunic", 100)->move(this_object());
    ARMOURY->request_item("rope belt", 100)->move(this_object());
    ARMOURY->request_item("soft leather shoes", 100)->move(this_object());
    clone_object("/obj/faith/pishe_symbol.ob")->move(this_object());
    do_command("tactics response parry");
    do_command("tactics attitude defensive");
    load_chat(20, ({ 2, ":smiles kindly.",
        1, "'May the countenance of Pishe rain upon you.",
        2, ":smiles serenely." }));
    load_a_chat(20, ({ 1, "'Do you know who I am?",
        1, "'May the power of Pishe strike you down.",
        1, "'Die unbeliever!",
        1, "'You fight me, you fight Pishe herself",
        1, "'Pishe! Aid your loyal servant!" }));
    set_virtual_move(1);
    set_move_after(30, 120);
    add_move_zone("Ankh-Morpork");
    add_move_zone("Temple");
    set_wimpy(10);
    add_respond_to_with(({ "@say",
        ({ ({ "heal", "healing" }), "please" }) }), (: do_heal :));
    add_respond_to_with(({ "@say",
        ({ "please", "heal", "me" }) }), (: do_heal :));
    add_respond_to_with(({ "@smile", "althea" }), "smile $hname$");
    add_respond_to_with(({ ({ "@bow", "@curtsey" }), "althea" }),
      "curtsey $hname$");
    add_enter_commands((: check_injured :));
    flail = ARMOURY->request_item("cleric rod", 100);
    flail->set_enchant(flail->query_max_enchant() / 2);
    flail->whichone(7);
    flail->move(this_object());
    call_out((: init_equip :), 2);
    move("/d/guilds/priests/Ankh-Morpork/small-gods/old/PriestGardenStatue", "$N walk$s into the "
      "room, smiling serenely.");
}
void maintain_self(object thing1, object thing2) {
    if (thing2 != this_object())
        return;
    if (member_array(flail, query_holding()) == -1) {
        queue_command("get flail");
        queue_command("hold flail");
    }
    if (query_gp() < 200)
        adjust_gp(200);
    if (query_hp() < query_max_hp() / 2) {
        do_command("cast cure serious wounds on althea");
    }
    if(query_hp() < query_max_hp() - 1000) {
        do_command("cast dust devil on althea");
    }
    if (query_hp() < query_max_hp() - 500) {
        do_command("cast minor shield on althea");
    }
    if (query_hp() < query_max_hp() - 250) {
        do_command("cast cure light wounds on althea");
    }
}
void fighting_stuff(object thing1, object thing2) {
    if (thing2 != this_object())
        return;
    if ( random( 10 ) )
        return;
   do_command("concentrate " + thing1->query_name());
    do_command("tactics attitude offensive" );
    do_command("crush "+ thing1->query_name() + " with flail");
}
void ritual_stuff(object thing1, object thing2) {
    if (thing2 != this_object())
        return;
    switch (random(6)) {
    case 0..1:
        do_command( "cast minor shield on althea" );
        break;
    case 2 .. 4 :
        do_command("cast dust devil on althea");
        do_command("cast dust devil on althea");
        do_command("cast dust devil on althea");
        break;
    case 5 :
        do_command("use flail to cast fear on " + thing1->query_name());
        break;
    }
    do_command("tactics attitude defensive");
}
void do_heal(object victim) {
    if (member_array(victim, query_attacker_list()) != -1) {
        do_command("say I'm not going to heal you!");
        return;
    }
    if (victim->query_hp() > (victim->query_max_hp() / 2)) {
        do_command("say You don't need healing from me, " +
          victim->short()+".");
        return;
    }
    if (victim->query_gp() < HEAL_COST) {
        do_command("say Sorry you're not strong enough for me to "
          "heal at the moment.\n");
        return;
    }
    if (victim->query_guild_ob() == "/std/guilds/wizard") {
        do_command("say I thought wizards didn't believe in gods?");
        do_command("smirk");
        return;
    }
    if (victim->query_al() > random(300)) {
        do_command("say You are far too wicked for Pishe's healing.");
        return;
    }
    do_command("say May the power of Pishe heal you.");
    tell_room(environment(), "Althea places her hands upon " +
      victim->the_short() + " and starts to pray softly.\n");
    tell_room(environment(), "As she does so her hands start to glow with a "
      "gentle silver light.\nThe light gradually intensifies until "
      "everything is bathed in it.\n");
    tell_object(victim, "As Althea prays you feel warmth spreading from her "
      "hands throughout your body.\n");
    tell_room(environment(), "Gradually the light fades.\n");
    tell_object(victim, "You feel much better.\n");
    tell_room(environment(), victim->the_short()+" looks much better.\n",
      victim);
    victim->set_hp(victim->query_max_hp());
    victim->adjust_gp(-HEAL_COST);
}
void check_injured() {
    object *people, person;
    people = filter(all_inventory(environment()), (: living($1) &&
        ($1->query_hp() < ($1->query_max_hp() / 2)) &&
        $1->query_al() < -300 :));
    people -= ({ this_object() });
    if (!sizeof(people))
        return;
    person = people[random(sizeof(people))];
    do_command("say Oh my, " + person->short()+ " you don't look so good.");
    do_command("say Allow me to heal you.");
    call_out((: do_heal($1) :), 1, person);
}
void event_fight_in_progress(object attacker, object victim) {
    if ( attacker != this_object() && victim->query_name() == "dickens" ) {
        if ( !dickens_warned ) {
            do_command( "say Fear not, Dickens, Pishe"
                " shall protect you!" );
            dickens_warned = 1;
            do_command( "protect dickens" );
            attack_ob( attacker );
        }
    }
    ::event_fight_in_progress( attacker, victim );
}
int adjust_hp(int hp, object attacker) {
    int result;
    result = ::adjust_hp(hp, attacker);
    if(hp < -1500)
        call_out("eek", 0);
    return result;
}
void eek() {
    init_command("use flail to cast sanctuary", 1);
    init_command("cast cure critical wounds on althea", 2);
    run_away();
}
void check_fumble( object ob ) {
    if ( environment( ob ) == environment() ) {
        do_command( "say Whoops, I must have dropped my precious flail!" );
        do_command( "get " + file_name( ob ) );
        do_command( "hold " + file_name( ob ) );
    }
}
void event_enter( object ob, string mess, object from ) {
    ::event_enter( ob, mess, from );
    if ( environment( ob ) == environment() &&
        ob->id( "flail" ) && ob->query_cloned_by() == "althea" ) {
        call_out( (: check_fumble :), 1, ob );
    }
}

==================================================
FILE: learning/cutnpaste/kess.c
==================================================

#define CREATOR "Ceres"
#include <armoury.h>
inherit "/obj/monster";
object rod;
void setup() {
  object chain;
  set_name("kess");
  set_short("Kess of Sek");
  set_main_plural("Kesses of Sek");
  set_long( "This is Kess, an Archcardinal of Sek.  She is a young woman, "+
           "and beautiful in a twisted kind of way.  She seems fairly "+
           "innocuous until you notice her eyes and see the vicious look in "+
           "them.\n" );
  add_adjective(({"archcardinal", "of", "sek"}));
  add_alias(({"priestess", "archcardinal", "cardinal"}));
  add_property("determinate","");
  add_property("unique", 1);
  set_gender("female");
  set_race("human");
  set_class("priest");
  set_deity("sek");
  set_level(260);
  set_height(140);
  set_weight(1000);
  set_al(2000);
  adjust_str(2);
  adjust_con(2);
  adjust_wis(5);
  adjust_int(-6);
  adjust_dex(-3);
  add_skill_level( "faith.items.rod", 250, 0 );
  add_skill_level( "fighting.combat.melee.blunt", 200, 0 );
  add_skill_level( "fighting.combat.parry.held", 200, 0 );
  add_known_command("kick");
  add_spell( "paralysis", "/obj/rituals/paralysis",
            "cast_spell" );
  add_spell( "fear", "/obj/rituals/fear",
            "cast_spell" );
  add_spell("cure medium wounds", "/obj/rituals/curemedium",
            "cast_spell" );
  add_spell("calm", "/obj/rituals/calm",
            "cast_spell" );
  add_spell( "rage", "/obj/rituals/rage",
            "cast_spell" );
  set_join_fights( "Blood-lust glows in Kess' eyes as she dives "+
                   "into the melee.\n" );
  set_join_fight_type(1);
  chain = ARMOURY->request_armour("chainmail", 100);
  chain->add_ac("magic", "magic", 60);
  chain->add_ac("fire", "fire" , 60);
  chain->add_ac("cold", "cold", 60);
  chain->move(this_object());
  chain->add_property("holy amulet", "sek");
  chain->add_property("sek", 1);
  ARMOURY->request_armour("blood red cloak", 100)->move(this_object());
  ARMOURY->request_armour("rope belt", 100)->move(this_object());
  ARMOURY->request_armour("soft leather shoes", 100)->move(this_object());
  rod = ARMOURY->request_weapon( "cleric rod", 100 );
  rod->whichone(6);
  rod->set_enchant(8);
  rod->move(this_object());
  clone_object("/obj/faith/sek_symbol.arm")->move(this_object());
  init_equip();
  ((object)ARMOURY->request_weapon("dagger", 100))->move(this_object());
  do_command("tactics response parry");
  do_command("tactics parry both");
  do_command("tactics attitude offensive");
  load_chat(20, ({2, ":smiles viciously.",
                  1, "@glare $lname$",
                  1, "@smirk",
                }));
  load_a_chat(20, ({1, "'Do you know who I am?",
                    1, "'Die unbeliever!",
                    1, "'You fight me, Sek will rip your heart out!"}) );
  set_virtual_move(1);
  set_move_after(30, 120);
  add_move_zone("Ankh-Morpork");
  add_move_zone("sek");
  add_enter_commands("#get_heart");
  add_combat_action(100, "maintenance", ({ "maintain_self" }) );
  add_combat_action(70, "fighting_stuff", ({ "fighting_stuff" }) );
  add_combat_action(50, "reequip", ({ "reequip" }));
}
void reequip(object thing1, object thing2) {
  if(this_object()->query_holding()[0] != rod) {
    do_command( "get yellow rod" );
    do_command( "hold yellow rod" );
  }
}
void fighting_stuff(object thing1, object thing2) {
  if(thing2 != this_object())
    return;
  switch(random(6)) {
  case 5:
    do_command("cast rage on "+thing1->query_name());
    break;
  case 4:
    do_command("cast fear on "+thing1->query_name());
    break;
  case 3:
    do_command("cast paralysis on "+thing1->query_name());
    break;
  case 2:
    do_command("use rod to cast dustdevil");
    break;
  case 1:
    do_command("use rod to cast barrier");
    break;
  default:
    do_command("concentrate on "+thing1->query_name());
    do_command("kick "+thing1->query_name());
    break;
  }
}
void maintain_self( object thing1, object thing2 ) {
   if ( thing2 != this_object() )
      return;
   if ( query_gp() < 200 )
      adjust_gp( 200 );
   if ( query_hp() < query_max_hp() / 4 )
     do_command( "use rod to cast sanctuary" );
   if ( query_hp() < query_max_hp() / 2 )
     do_command( "cast calm on "+thing1->query_name());
   if ( query_hp() < query_max_hp() )
     do_command( "cast cure medium wounds on kess" );
}
void event_death(object thing) {
  if(thing != this_object()) {
    call_out("get_heart", 3);
  }
}
void get_heart() {
  object corpse;
  if(find_match("corpse", environment()) != ({})) {
    do_command("hold dagger");
    do_command("get heart from corpse");
    do_command("eat heart");
    do_command("hold rod");
  }
}
int adjust_hp(int hp, object attacker) {
  ::adjust_hp(hp, attacker);
  if(hp < -300) {
    init_command("cast cure medium wounds on kess");
    if(!random(3))
      call_out("eek", 0);
  }
}
void eek() {
  do_command("lose all");
  run_away();
}

==================================================
FILE: learning/items/matcher.c
==================================================

inherit "/std/object";
#define CMD 0
#define PAT 1
void add_cmds( object player );
int do_add( string command, string pattern );
int do_remove( int i );
int do_match( object *indirect_obs, string dir_match,
    string *indirect_match, mixed args, string pattern );
string read_msg();
string *cmds = ({});
void setup() {
  set_name( "matcher" );
  set_short( "Tannah's pattern matcher" );
  add_property( "determinate", "" );
  add_alias( "pattern matcher" );
  set_long(
    "This is a very handy wossname, useful for testing patterns you "
    "might like to use in an add_command.\n"
  );
  add_adjective( ({ "handy", "patterned" }) );
  set_weight( 1 );
  set_value( 0 );
  add_property( "no recycling", 1 );
}
void init() {
  add_cmds( this_player() );
}
void add_cmds( object player ) {
  set_read_mess( (: read_msg :) );
  player->add_command( "add", this_object(), "command <word'command'> "
      "with pattern <string:quoted'pattern'>",
      (: do_add( $4[0], $4[1] ) :) );
  player->add_command( "remove", this_object(), "command <number>",
      (: do_remove( $4[0] ) :) );
  if( sizeof( cmds ) ) {
    for( int i = 0; i < sizeof( cmds ); i++ )
      player->add_command( cmds[i][CMD], this_object(), cmds[i][PAT],
          (: do_match :) );
  }
}
int do_add( string command, string pattern ) {
  cmds += ({ ({ command, pattern }) });
  this_player()->remove_object( this_object(), 1 );
  add_cmds( this_player() );
  printf( "You add the command \"%s\" with the pattern \"%s\" to the "
      "pattern matcher.\n", command, pattern );
  return 1;
}
int do_remove( int i ) {
  if( i >= sizeof( cmds ) || i < 0 ) {
    printf( "Invalid command number.\n" );
    return 0;
  }
  printf( "You remove the command \"%s\" with the pattern \"%s\" from "
      "the pattern matcher.\n", cmds[i][CMD], cmds[i][PAT] );
  cmds = cmds[0..i-1] + cmds[i+1..];
  this_player()->remove_object( this_object(), 1 );
  add_cmds( this_player() );
  return 1;
}
int do_match( object *indirect_obs, string dir_match,
    string *indirect_match, mixed args, string pattern ) {
  printf( "Indirect objects: %O\n", indirect_obs );
  printf( "Direct match: %s\n", dir_match );
  printf( "Indirect match: %O\n", indirect_match );
  printf( "Args: %O\n", args );
  printf( "Pattern: \"%s\"\n", pattern );
  return 1;
}
string read_msg() {
  int i;
  string msg;
  msg = "The pattern matcher is currently set to test the following "
        "commands and patterns:\n";
  if( !sizeof( cmds ) ) msg += "  None.\n";
  else for( i = 0; i < sizeof( cmds ); i++ ) {
    msg += sprintf( "[%d] \"%s\", \"%s\"\n", i, cmds[i][CMD],
           cmds[i][PAT] );
  }
  msg += "See 'syntax add' and 'syntax remove' to modify the list.";
  return msg;
  msg += "For further [nearly accurate] information on add_command, "
    "see the files in /w/tannah/learning/add_cmd.\n";
}
void list_cmds() {
  printf( "Commands and patterns added:\n%O\n", cmds );
}

==================================================
FILE: learning/chars/npc_example.c
==================================================

inherit "/obj/monster";
#include <armoury.h>
object comb;
void setup() {
   set_name( "ralph" );
   set_short( "Ralph the spotted giraffe" );
   add_property( "determinate", "" );
   add_adjective( "spotted" );
   set_main_plural("Ralph the spotted giraffes");
   add_plural(( { "ralphs", "giraffes" } ));
   add_alias(( { "giraffe", "Ralph" } ));
   set_long( "This is Ralph the spotted giraffe.  He is just an example in "
             "this file so I won't describe him although I should.  Well, "
             "okay then... He's like any normal giraffe except for his cool "
             "black specs and mop fringe.  He is coolnes personified.\n" );
   add_property( "unique", 1 );
   set_race( "horse" );
   set_guild("wizard");
   set_height( 300 );
   set_weight( 1600 );
   set_gender( 1 );
   set_al( -500 );
     set_level( 15 );
   set_con(18);
   set_dex(18);
   set_str(16);
   set_wis(15);
   set_int(15);
   add_move_zone( "Short" );
   add_move_zone( "Filigree" );
   set_move_after( 50, 60 );
   set_virtual_move(1);
   load_chat( 90, ({
      3, "@grin",
      3, "@high5 $lname$",
      2, "@bless $lname$",
      1, "@moonwalk",
      1, "'Far out man.",
      1, ({
         "'Hey, if it isn't $lname$!",
         "'You're looking cool as usual!"
      }),
      1, ":tells you: Hey my man!  Watcha up to?",
      1, "'That's cool.",
      1, "'Chillin' out here, are we?",
      1, "@ruffle $lname$",
      1, "@wink $lname$",
      2, ":does a really complicated tap dance manoeuvre.",
      1, "'Let's do something wild and crazy...",
      1, ({
         "'Yoho, how's it hangin'?",
         "'I'm in a darn good mood today!"
      }),
      1, ":tells you: Ouch man, where the heck did you find those clothes?"
   }) );
   load_a_chat( 100, ({
     1, "'Wait till Hobbes hears about this!",
     1, "'It's SO uncool to fight!",
     1, "@scream",
     1, "You can't believe you're fighting such a nice creature as Ralph.",
     1, ":seems to wish he was somewhere else."
     }) );
   ARMOURY->request_weapon("meat cleaver", 80+random(20))->move(this_object());
   ARMOURY->request_armour("gigantic dog collar", 100)->move(this_object());
   ARMOURY->request_armour("straw hat", 80)->move(this_object());
   comb=clone_object("/d/am/items/comb");
   comb->move( this_object() );
   init_equip();
}

==================================================
FILE: learning/chars/path.h
==================================================

#include <learning.h>
#define TERRAIN_TUTORIAL HELP +"rooms/terrains/"

==================================================
FILE: learning/chars/terrain_teacher.c
==================================================

#include <armoury.h>
#include "path.h"
inherit "/obj/monster";
#define TERRAIN_CONTROL "/d/admin/room/terrain"
#define PROPERTY "terrain lesson stage"
#define CROSS_IMPATIENCE 100
#define TAPS_IMPATIENCE 200
#define MAX_IMPATIENCE 300
#define COSTUME_NORMAL 0
#define COSTUME_DESERT 1
#define COSTUME_WET 2
#define COSTUME_COLD 3
int costume_normal();
int costume_desert();
int costume_wet();
int costume_cold();
protected void to_terrain();
protected void from_terrain(string to);
object hq;
object pupil;
int impatience;
int costume;
int lesson_step;
int speeching;
mixed *lessons =
({
   ({ "grassyfield", COSTUME_NORMAL,
      ({
         "emote sniffs the air.",
         "smile",
         "'This is a very simple terrain.  Take a little time to look around "
            "at it, wander around, read some of the code.  There isn't a whole "
            "lot to it.  When you feel you know what's here, come back and tell "
            "me you're ready.  I'll wait until you say \"ok\" or "
            "\"ready\" where I can hear you.  If you accidentally wander back to "
            "the foyer, type 'grassyfield' to return here.",
         0,
         "'You should have noticed that there are two different rooms in this "
            "area: the room in which we stand now, with this quaint cottage "
            "behind me, and the rooms of the field.",
         "'All the rooms are very simple.  You should have read the code for "
            "them.  If you haven't, do it now.  I'll wait until you're ready.",
         0,
         "'I assume that you have written rooms, both indoors and outdoors, "
            "before.  You should have noticed two strange features to the files "
            "that make up this area: first that they both have a call to a "
            "function called set_terrain(), and second that they both are "
            "remarkably lacking in add_exit() calls!",
         "'In fact, excepting this one 'cottage' exit behind me, the files "
            "have no exits at all.  Nevertheless, you were able to walk around "
            "quite freely.",
         "'That is the primary purpose to the terrain handler: it manages your "
            "exits for you.",
         "'The call to set_terrain(), then is simply the means by which you "
            "can tell the terrain handler that it needs to manage this room.",
         0,
         "'There are two types of rooms that the terrain handler can manage: "
            "fixed rooms and floating rooms.  The code for both looks the same, "
            "but the terrain handler treats them very differently.",
         "'In order for the terrain handler to know how to handle each room, "
            "you have to tell it.  That's done in the terrain handler control "
            "room: /d/admin/room/terrain.  You can get there from the commonroom "
            "by walking one east then one southeast.  Personally, I prefer to "
            "use an alias.",
         "'We'll go to the terrain control room in a moment, so you can see "
            "how to use it.  For the moment, suffice to say that every room "
            "that has a call to set_terrain() also needs to be registered in "
            "the terrain control room.",
         0,
         "'In this terrain, we have the doorstep (a fixed room) and all the "
            "rooms of the field (floating).  The primary difference between "
            "floating and fixed rooms is that you can only have one of each "
            "fixed room in a terrain, but you can have any number of floating "
            "rooms.",
         "'In fact, you probably noticed that this area is a 3x3 grid.  We're "
            "in the center of the southern edge of that grid right now, at the "
            "doorstep.",
         "'When I created this terrain, I just said that the field should "
            "cover the entire 3x3 area.  Then I plopped the fixed room down here, "
            "and it automatically took the place of the field room that would "
            "have been here.",
         "'This is an important concept: floating rooms cover predefined "
            "regions, while fixed rooms are in one place.  When a particular "
            "location is in the region of a floating room _and_ is the location "
            "of a fixed room, the fixed room wins.",
         "'This makes it so you can define huge sweeping areas of the floating "
            "rooms, and just plop down your fixed rooms in strategic areas.",
         0,
         "'Now, when I say 'location', what I'm referring to is the coordinates "
            "of the room.  As a creator, you can look at a room, and the "
            "coordinates (or \"unset\") appear just before the description.  "
            "As you work on terrains, you'll find yourself looking at those "
            "coordinates a lot.",
         "'Walk around a bit, and see how the coordinates change as you move "
            "in the different directions.  You will see the first number "
            "increase when you walk north, and decrease when you walk south.  "
            "The second increases when you walk east, and the third increases "
            "whenever you go up.",
         "'So that's ( north, east, up ).",
         0,
         "'Ok, let's show you the terrain control room now.",
         (: this_object()->to_terrain() :),
         "'Ok, here we are in the terrain control room.",
         "'Feel free to look at the room here before I explain everything "
            "to you.  Well, not quite everything: that green box is an advanced "
            "device for a later lesson.",
         0,
         "'The first thing you need to do before using the terrain room is "
            "always, always, always, set the terrain name.  Do that with the "
            "\"terrain\" command.",
         "'Type \"terrain tutorial_grassy_field\".  Be very careful about "
            "the spelling, you have to get it exactly right.",
         "'If you're worried, just type \"terrain\" and the room will "
            "show you the current terrain",
         0,
         "'Now that you've set the terrain, you can list the rooms that I "
            "have set here.  Use \"list floating\" to see all the floating "
            "rooms, and \"list fixed\" to see all the fixed rooms.",
         "'As I've mentioned before, this terrain only has one fixed and "
            "one floating room.",
         0,
         "'When it lists the floating room, it tells you the name of the "
            "file, the coordinates of two opposite corners of the region, and "
            "one final number.  That last number is a priority.  We'll talk "
            "about that in the second lesson.  For now, ignore it.",
         "'In this terrain, we have the field room in the whole area where "
            "the first coordinate is between -100 and 100 (inclusive), the "
            "second coordinate is between -100 and 100 (inclusive), and "
            "the third coordinate is equal to 800000.",
         "'The only reason for that strange third coordinate was that I wanted "
            "to keep these rooms far away from the player areas.",
         "shrug",
         "'That number before the file name is just an index in the list of "
            "floating rooms.  Since we only have one floating room, it isn't "
            "very useful to us.",
         0,
         "'Both of our rooms inherit /std/room/outside.  That makes the rooms 100 "
            "units wide in each direction.  So in that range of coordinates, we "
            "can have 3 rooms: -100, 0, and 100 for each of the first two "
            "coordinates.  So the whole terrain is a 3x3 block.",
         0,
         "'Now looking at the fixed room, it gives you the name of the file "
            "and _one_ set of coordinates.  That's it.  There's only the one set "
            "of coordinates, because each fixed room can only be in one location.",
         "'If you try to add another fixed room with the same file, the "
            "terrain control room will gripe at you and refuse to do it.  You'll "
            "have to remove the old room first.  You do that with the \"remove\" "
            "command, but we'll get to that later.",
         0,
         "'Notice that the fixed room is at (-100, 0, 800000).  That is inside "
            "the range of coordinates that we have set for the floating rooms: "
            "the first and second coordinates are between -100 and 100, and the "
            "last coordinate is 800000.  But this is a fixed room, so it wins the "
            "fight for that location.",
         "'This is what I was talking about earlier, when I mentioned putting "
            "the doorstep in the middle of the southern edge of the square: -100 "
            "is the southernmost edge of the square, while 0 is in the middle of "
            "that edge.",
         0,
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "grassystep") :),
         "'And here we are back at the field.",
         "'That's it for the basic terrain lesson.  Wander around a bit more "
            "to look at the things I have mentioned, and come back here when "
            "you're ready to finish this lesson up.",
         "'There are more lessons available to you, so if you're up to it, "
            "talk to me when we get back to the foyer, and I'll continue to teach "
            "you.",
         "smile",
         "'You've been an excellent pupil.",
         0,
         "'Good",
      }),
      "cottage"
   }),
   ({ "desert", COSTUME_DESERT,
      ({
         "stretch",
         "emote starts to sweat",
         "'Ah, the desert!",
         "'As in the field, take a moment to wander around here.  Use what you "
            "learned in the first lesson, and look a bit more closely at the rooms "
            "in this area.",
         0,
         "'You should have noticed that there are three different areas in this "
            "terrain: this spot here next to the tent, the desert, and an oasis.  "
            "If you didn't notice, look at it now.",
         0,
         "'Once again, we have a largely square area, this time 6 squares east "
            "and west, and 5 squares north and south.  As you might have guessed, "
            "I created this area by covering the whole square with the desert "
            "room, and then plopped down this room in the corner.  But the oasis "
            "squares are interesting.  Let's go to the terrain control room and "
            "see.",
         (: this_object()->to_terrain() :),
         0,
         "'Ok, set the terrain to \"tutorial_desert\".  If you've forgotten, "
            "that's \"terrain tutorial_desert\".",
         "'When you've done that, list the floating rooms to see some nifty "
            "stuff.",
         0,
         "'Notice how I've got two rooms here: sanddunes and sandoasis.",
         "'Look carefully at the coordinates for the rooms, and you'll see that "
            "the sandoasis rooms overlap the sanddunes rooms.\n",
         "'The important difference is that last number.  Sanddunes says that "
            "it is \"level 0\", while sandoasis says it is \"level 1\".",
         "'The level is a kind of priority: when two or more floating rooms are "
            "at the same coordinates, the one with the highest level wins, and "
            "will be the room that the terrain handler actually puts down.",
         "'So in this terrain, the far northwest corner (that's at "
            "200, 1000, 800000) is in both the sanddunes and the sandoasis "
            "areas.  But since sandoasis has a higher level, that location "
            "is an oasis.",
         0,
         "'This little wrinkle lets you overlay lots of different rooms, "
            "stacking them up, to get very complex shapes without having to "
            "plop down rooms one by one.",
         "'For example, suppose one room covers (-200, -200, 0) to "
            "(200, 200, 0), at level 0.  Then we put a second room from "
            "(-100, -100, 0) to (100, 100, 0) at level 1.  The first room "
            "makes a 5 by 5 ring around the second area, which is 3 by 3.",
         "'We can make that more complex by putting more of the first "
            "room down, from (0, 0, 0) to (0, 100, 0) at level 2.  Now the "
            "center area, instead of being a 3 by 3 square, is a kind of "
            "'C' shape.  It might be helpful to draw that out on a piece "
            "of graph paper, so you can see it better.",
         0,
         "'Using these levels, you can even make it so that a terrain has "
            "holes in it.  That's convenient when you want to force people "
            "to walk around something.  Just add a floating room with a high "
            "level, and use the special file name \"nothing\".",
         0,
         "'Well, that's it for this lesson.",
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "sandtent") :),
         "'Come back again, and we'll talk about some of the pitfalls "
            "involved in designing terrains.",
         0,
      }),
      "tent"
   }),
   ({ "mountaintop", COSTUME_COLD,
      ({ "rub hands",
         "shiver",
         "'Sorry about the cold, I never got around to putting a door on "
            "this cabin.",
         "frown",
         "shrug",
         "'Oh well.",
         "'This time, I don't want you to wander freely around the terrain: "
            "it's much more complex than the others you've explored, and I want "
            "to do this one one step at a time.",
         0,
         "'This room right here is a fixed room.  We have one more fixed room "
            "upstairs, and both are connected by the staircase behind me.  That "
            "exit was added automatically by the terrain handler, just as in "
            "the case of floating rooms, but here we have two fixed rooms whose "
            "exits are being managed.",
         "'We'll go to the terrain control room in a moment, but first I want "
            "to show you a few things.",
         "'Look at the coordinates for this room.  If you didn't see the "
            "coordinates when you came in to this room, 'look' now.",
         0,
         "up",
         "'Now compare the coordinates of this room to the room we were just "
            "in.",
         0,
         "'Previously, whenever you moved from one room to another, the "
            "coordinates changed by 100.  This time, they only changed by 20.",
         "'Previously, all our rooms were 100 units across.  These two "
            "rooms, however, are only 20.  That's because our previous rooms "
            "all inherited /std/room/outside, while these two cabin rooms inherit "
            "/std/room/basic_room.  The code assumes that indoor rooms tend to be smaller "
            "than the great outdoors.",
         "'One side effect of that is that you have to be careful when "
            "lining up rooms in the terrain control room.  Be sure to check "
            "that the positions you give your rooms line up right, so the "
            "terrain handler can generate the correct exits.",
         "'In this case, I had to make sure that I planted this attic "
            "exactly 20 units above the other room.",
         0,
         "'This gets a little bit hairy when you have an indoor room "
            "meeting an outdoor room.  Let's look at that now.",
         "down",
         "'Here's an indoor room",
         0,
         "west",
         "lsay And here's an outdoor room",
         0,
         "lsay This time the coordinates changed by 60.",
         "lsay \"60?!  Where'd 60 come from?\" I bet you ask?",
         "lsay I've already said that outside rooms are 100 units across, and "
            "indoor rooms are 20 units across.  So from the center of an outside "
            "room, the walls are all 50 units from you.  From the center of an "
            "indoor room, the walls are 10 units from you.  Normally, when you go "
            "from the center of one outdoor room to another, that's 50 units in "
            "the first room, and another 50 units in the destination room: 100 "
            "units total",
         "lsay Likewise, in an indoor room, you go 10 units in the first room, "
            "and another 10 units in the second room: 20 units total.",
         "lsay So the 60 units we just moved is 10 units in the indoor room "
            "where we started, plus another 50 units in the outdoor room where "
            "we ended up.",
         "lsay Of course, I had to take that into account in the terrain "
            "control room when I lined up these rooms.",
         0,
         "lsay Now, there's one more thing that I want to show you before "
           "we go to the terrain room.",
         "sw",
         "s",
         "lsay Here's a tree that I planted a few years ago.  We can climb "
            "it.",
         "up",
         0,
         "lsay Did you notice the change in coordinates this time?  70.",
         0,
         "lsay Now this tree that we're hanging from is an outdoor room, as "
            "you can tell by all the weather we're having.  However, it's not "
            "the usual size.",
         "lsay Do 'find -d setup() here', to read the setup function for this "
            "room.  Notice how I have a call to set_room_size() just before "
            "the call to set_terrain().  That set_room_size() controls how far "
            "the walls are from the center of the room.  So this room is twice "
            "that width: 40 units across and 40 units tall.",
         "lsay That should account for the coordinates changing by 70 when "
            "we climbed the tree: 50 as we left the lower room, and 20 coming in "
            "to this room.",
         0,
         "lsay You can change the size of any room you want this way, but "
            "make absolutely sure that you call set_room_size() _before_ "
            "you call set_terrain().  That is critically important, and all "
            "sorts of subtle bugs can happen, generally involving the wrong "
            "exits showing up, if you get that wrong.",
         "lsay Also, set_room_size() can take an array of 3 coordinates to "
            "control the size of the room separately in all three dimensions.",
         "lsay Unfortunately, the terrain handler doesn't understand that "
            "level of complexity, so don't ever do it with rooms you expect to "
            "have managed by the terrain handler.",
         0,
         "lsay ok, let's go to the terrain control room, and you can look "
            "at my work.",
         (: this_object()->to_terrain() :),
         "lsay Here we...",
         "blush",
         "' Heh.  Got so used to yelling over the wind...",
         "smile",
         "'Here we are in the terrain room.  Set the terrain to "
            "tutorial_mountain and list out the fixed rooms.",
         0,
         "'Notice the last coordinates on both.  That's what I mentioned "
            "before, that I had set the two 20 units apart.",
         "'Now list the floating rooms.",
         0,
         "'Here I've done something different.  The mountainsnows room "
            "makes a big square, 5 by 5.  In the very center of that square, "
            "there is a 'nothing' room.  You should remember from the last "
            "lesson, that when the filename of a floating room is 'nothing', "
            "the terrain handler puts no room at that location.  So here we "
            "have the floating terrain with a hole in the middle.",
         "'Inside that hole, I plopped down the cabin.  How it's not "
            "centered in that hole, it's actually to the west of the center.",
         "'That's because I needed to ensure that, with the differente "
            "sizes of the outside vs. inside rooms, things would still line up.",
         "'So when you walk out of the cabin, you walk west.  When you walk "
            "around it, the terrain handler doesn't give you any extra entrances "
            "to the cabin.",
         0,
         "'There's one extra thing I had to do to get the cabin to work right, "
            "and I'll show you that soon, but first notice the mountaintree "
            "rooms.  There shouldn't be any suprises with that, just remember "
            "that the tree rooms are a different size.",
         0,
         "'Ok, back to the cabin.",
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "mountaincabin") :),
         "'Here we are, back in the ground floor of the mountain cabin.",
         "'Notice how we have 3 exits here: up, down, and west.  Obviously, "
            "there's no north, east, or south exits, because we have that "
            "'nothing' room right here.",
         "lsay Wrong!",
         "grin",
         "'That 'nothing' trick only works with floating rooms.  In order to "
            "ensure that this room doesn't have the north, east, and south exits, "
            "I had to add a special function to the room.",
         "'Type 'find -d query_exit_type() here'",
         0,
         "'In any room that is managed by the terrain handler, whether than "
            "room is a floating room or a fixed room, the terrain handler checks "
            "a function called query_exit_type() to see what type of exit it "
            "should create in each direction.",
         "'The arguments are a string for the direction of the exit (north, "
            "west, south, northeast, etc.) and a string containing the file name "
            "of the destination room.  These are both just like you would use "
            "in a call to add_exit().",
         "'The function returns a string for an exit type, just like the "
            "third argument to add_exit().",
         "'There is, of course, a wrinkle: if query_exit_type() returns "
            "\"none\", then that exit isn't created at all.",
         0,
         "'If the room doesn't have a function called query_exit_type(), "
            "then some default values are used.  Those defaults are in an array "
            "at the beginning of /obj/handlers/terrain_handler.  It's real "
            "easy to find.",
         "'There are a lot of things that can be done to modify the exits "
            "that the terrain handler builds, but that'll be the subject for the "
            "next lesson.",
         "'For now, wander around if you feel like it, and come back to me "
            "when you're ready to finish this up.",
         0,
      }),
      "down"
   }),
   ({ "grassyfield", COSTUME_NORMAL,
      ({ "laugh",
         "'In spite of dragging you out here like this, Sin hasn't actually "
            "scripted this lesson yet.  Sorry.  This would've been the fourth "
            "lesson, in which I talk about how you can modify the exits that "
            "the terrain handler makes for you.",
         "shrug",
      }),
      "cottage"
   }),
});
void setup() {
   object obj;
   object backpack;
   set_name("terrain teacher");
   add_alias("teacher");
   set_short("terrain teacher");
   add_property("determinate", "the ");
   add_property("unique", 1);
   set_long("This man is middle aged, and apparently human.  That's about "
            "all you can really see, because he's soaking wet, his hair is caked "
            "with leaves and mud, his clothes are torn, and his boots are caked "
            "with dirt.\n");
   set_race("human");
   set_guild("monk");
   set_level(50);
   set_gender(1);
   add_effect("/std/effects/other/wetness", 10000);
   set_respond_to_with( ({
      ({ "@say", "teach", "please" }), "#new_pupil",
      ({ "@say", "please", "teach" }), "#new_pupil",
      ({ "@say", "teach" }), "#new_rude_pupil",
      ({ "@say", ({ "ok", "ready" }) }), "#next_speech",
   }) );
   backpack = ARMOURY->request_item("large backpack", 80);
   if (!backpack) backpack = ARMOURY->request_item("black leather backpack", 80);
   if (!backpack) backpack = ARMOURY->request_item("small backpack", 80);
   if (backpack) backpack->move(this_object());
   obj = ARMOURY->request_item("large leather boots", 20);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("thermal underwear", 10);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("fawn cotton trousers", 50);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("leather belt", 50);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("black wool socks", 40);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("gaudy shirt", 35);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("brown felt hat", 10);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("white cotton toga", 80);
   if (obj) obj->move(backpack);
   obj = ARMOURY->request_item("yellow raincoat", 60);
   if (obj) obj->move(backpack);
   obj = ARMOURY->request_item("old black cloak", 72);
   if (obj) obj->move(backpack);
   obj = ARMOURY->request_item("amusing earmuffs", 100);
   if (obj) obj->move(backpack);
   init_equip();
   costume = COSTUME_NORMAL;
   hq = find_object(TERRAIN_TUTORIAL "foyer");
   impatience = 0;
   lesson_step = 0;
   speeching = 0;
}
int check_anyone_here() {
   if (pupil) return 1;
   else return ::check_anyone_here();
}
void heart_beat() {
   ::heart_beat();
   if (!pupil) return;
   ++impatience;
   if (impatience == CROSS_IMPATIENCE) {
      init_command("emote is beginning to look a bit impatient.", 1);
   } else if (impatience == TAPS_IMPATIENCE) {
      init_command("emote begins tapping his foot.", 1);
   } else if (impatience == MAX_IMPATIENCE) {
      init_command("'That's it, you clearly don't really want to learn.  "
                   "I give up on you, " + pupil->short(), 1);
      call_out("come", 3 + costume_normal(), hq);
      pupil = 0;
      impatience = 0;
   }
}
int add_follower( object who ) {
   if (who == pupil) {
      int lesson;
      impatience = 0;
      lesson = pupil->query_property(PROPERTY);
      if (lesson < 0 || lesson >= sizeof(lessons)) {
         init_command("think", 1);
         init_command("'Odd, you seem to have done more lessons than I know.", 2);
         init_command("'I'm afraid I have nothing to teach you.", 3);
         pupil->remove_property(PROPERTY);
         pupil = 0;
         return 0;
      } else if (::add_follower(who)) {
         int delay;
         switch (lessons[lesson][1]) {
          case COSTUME_NORMAL: delay = costume_normal(); break;
          case COSTUME_DESERT: delay = costume_desert(); break;
          case COSTUME_WET: delay = costume_wet(); break;
          case COSTUME_COLD: delay = costume_cold(); break;
         }
         init_command(lessons[lesson][0], delay + 2);
         lesson_step = 0;
         call_out("speech", delay + 10);
         return 1;
      } else {
         return 0;
      }
   } else {
      init_command("'For what reason do you want to follow me, " +
                   who->short() + "?  I'm not teaching you.", 0);
      return 0;
   }
}
void coming( object where ) {
   tell_room( where,
      "%^CYAN%^Someone says: One moment!  I'll be right down!%^RESET%^\n",
             ({ this_object() }) );
}
void annoyed_coming( object where ) {
  tell_room( where,
    "%^CYAN%^An annoyed someone says: I said I'm coming!  "
    "Jeez!%^RESET%^\n",
    ({ this_object() }) );
}
void come( object where ) {
   hq = where;
   if (where != environment())
      move( where, this_object()->a_short() + " arrives",
           this_object()->a_short() + " stomps away" );
   init_command( "emote looks around", 1 );
   init_command( "sigh", 4 );
   init_command( "get sign", 7 );
   init_command( "emote looks at the sign", 9 );
   init_command( "sit on bench", 10 );
   init_command( "'What can I do for you?", 12 );
}
void done() {
   int delay = costume_normal();
   int lesson;
   lesson = pupil->query_property(PROPERTY) + 1;
   if (lesson == sizeof(lessons)) {
      init_command("'congratulations, " + pupil->short() + ", you have "
                   "completed all the terrain handler lessons.", ++delay);
      pupil->remove_property(PROPERTY);
   } else
      pupil->add_property(PROPERTY, lesson);
   init_command("emote looks around", delay + 1);
   init_command("sigh", delay + 4);
   init_command("get sign", delay + 7);
   init_command("emote looks at the sign", delay + 9);
   init_command("sit on bench", delay + 10);
   pupil = 0;
   impatience = 0;
   speeching = 0;
}
void speech() {
   int lesson = pupil->query_property(PROPERTY);
   int delay;
   delay = 0;
   speeching = 1;
   if (lesson_step == sizeof(lessons[lesson][2])) {
      init_command(lessons[lesson][3], delay + 3);
      call_out("done", delay + 4);
      call_out( (: speeching = 0 :), delay + 5);
      return;
   }
   do {
      if (functionp(lessons[lesson][2][lesson_step])) {
         call_out(lessons[lesson][2][lesson_step], ++delay);
      } else if (stringp(lessons[lesson][2][lesson_step])) {
         init_command(lessons[lesson][2][lesson_step], ++delay);
      }
      if (++lesson_step == sizeof(lessons[lesson][2])) {
         init_command(lessons[lesson][3], delay + 3);
         call_out("done", delay + 4);
         call_out( (: speeching = 0 :), delay + 5);
         return;
      }
   } while (lessons[lesson][2][lesson_step]);
   lesson_step++;
   init_command("emote waits for " + pupil->a_short(), ++delay);
   call_out( (: speeching = 0 :), ++delay);
}
void pupil_arrived( object where ) {
   if (pupil) return;
   if (!environment()) {
      if (find_call_out("come") != -1)
         call_out("annoyed_coming", 0, where);
      else {
         call_out("come", 10, where);
         if (find_call_out("coming") == -1)
            call_out("coming", 2, where);
      }
   } else if (environment() == where) {
      init_command("'Oh, a pupil!", 2);
   }
}
protected void to_terrain() {
   move(TERRAIN_CONTROL, "The terrain teacher appears",
        "The terrain teacher snaps his fingers and vanishes");
   tell_object(pupil, "Something snags you through space\n");
   pupil->move_with_look(TERRAIN_CONTROL, pupil->short() + " appears",
                         pupil->short() + " looks surprised and disappears.");
}
protected void from_terrain( string to ) {
   move(to, "The terrain teacher appears",
        "The terrain teacher snaps his fingers and vanishes");
   tell_object(pupil, "Something snags you through space\n");
   pupil->move_with_look(to, pupil->short() + " appears",
                         pupil->short() + " looks surprised and disappears.");
}
protected int modesty() {
   int num;
   num = sizeof(filter_array(all_inventory(environment()),
            (: living($1) && $1->query_gender() != 1 :) ));
   if (num) {
      if (num > 1)
         init_command("'Ladies, would you please turn around for a "
                      "moment?", 1);
      else
         init_command("'Ma'am, would you please turn around for a "
                      "moment?", 1);
      return 10;
   } else return 0;
}
int costume_normal() {
   int i;
   if (costume == COSTUME_NORMAL) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, raincoat, cloak, earmuffs", ++i);
   init_command("put toga, raincoat, cloak, earmuffs in backpack", ++i);
   init_command("get trousers, belt, shirt, hat from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_NORMAL;
   return i;
}
int costume_desert() {
   int i;
   if (costume == COSTUME_DESERT) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove raincoat, cloak, earmuffs", ++i);
   init_command("remove belt, hat, shirt", ++i);
   init_command("remove trousers", ++i);
   init_command("put trousers, belt, shirt, hat, raincoat, cloak, "
                "earmuffs in backpack", ++i);
   init_command("get toga from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_DESERT;
   return i;
}
int costume_wet() {
   int i;
   if (costume == COSTUME_WET) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, cloak, earmuffs", ++i);
   init_command("put toga, cloak, earmuffs in backpack", ++i);
   init_command("get trousers, belt, shirt, hat, raincoat from "
                "backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_WET;
   return i;
}
int costume_cold() {
  int i;
   if (costume == COSTUME_COLD) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, raincoat, hat", ++i);
   init_command("put toga, raincoat, hat in backpack", ++i);
   init_command("get trousers, belt, shirt, cloak, earmuffs "
                "from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_COLD;
   return i;
}
void next_speech( object who, string message ) {
   if (who != pupil) return;
   if (speeching) return;
   impatience = 0;
   call_out("speech", 1);
}
void new_pupil( object who, string message ) {
   if ( pupil ) {
      if ( pupil == who ) {
         impatience = 0;
         init_command("pat " + who->short(), 1);
         init_command("'That's alright.  I understand you can get "
                      "excited at times like this.  Be assured that I am going "
                      "to teach you, " + who->short(), 3);
      } else {
         init_command("'sorry, " + who->short() + ", but I am teaching " +
                      pupil->short() + " right now.", 1);
      }
   } else {
      pupil = who;
      set_heart_beat(1);
      init_command("'Yes, " + pupil->short() +
                   ", I would be happy to teach you.", 1);
      init_command("drop sign", 3);
      init_command("stand", 4);
      init_command("'follow me, if you will", 6);
      impatience = 0;
   }
}
void new_rude_pupil( object who, string message ) {
   if (!pupil) {
      init_command("emote hums quietly to himself.", 2);
      init_command("mumble rude pupils", 5);
   }
}
mixed *stats() {
   return ::stats() +
      ({
         ({ "pupil", pupil ? pupil->query_name() : "no pupil" }),
         ({ "impatience", impatience }),
         ({ "costume", (costume == COSTUME_NORMAL) ? "normal" :
            ((costume == COSTUME_DESERT) ? "desert" :
             ((costume == COSTUME_WET) ? "wet" :
              ((costume == COSTUME_COLD) ? "cold" : "???"))) }),
         ({ "lesson step", lesson_step }),
      });
}

==================================================
FILE: dist/common.c
==================================================

#define DOM_TITLE "the domain of dist"
#define LORD "pinkfish"
#define DOMAIN "dist"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", "/d/am/am/mendeddrum", "door");
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs addorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}
void dest_me()
{
  if(board) board->dest_me();
  ::dest_me();
}

==================================================
FILE: dist/loader.c
==================================================

#define DOMAIN "dist"
string *pre_load;
void create() {
  int i;
  seteuid((string)"/secure/master"->creator_file(file_name()));
  unguarded((: restore_object, file_name(this_object()) :));
  if (!pre_load)
    pre_load = ({ });
  for (i=0;i<sizeof(pre_load);i++) {
    printf(DOMAIN+" pre_loading "+pre_load[i]+".\n");
    if (catch(call_other(pre_load[i], "??")))
      call_out("do_load", 0, pre_load[i]);
  }
}
void do_load(string str) {
  call_other(str, "??");
}
int add_pre_load(string str) {
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object(file_name(this_object()));
  return 1;
}
int remove_pre_load(string str) {
  int i;
  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object(file_name(this_object()));
}
string *query_pre_load() { return pre_load; }

==================================================
FILE: dist/master.c
==================================================

#define LORD "pinkfish"
#define DOMAIN "dist"
inherit "/std/dom/base_master";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "";
}

==================================================
FILE: dist/mtf/key_deft.c
==================================================

# "/std/outside"

==================================================
FILE: dist/mtf/mtf.c
==================================================

#include "mtfincl.h";
mapping get_exits(int ypos, int xpos, mixed *map, mapping keys) {
  int x, y;
  mapping exits = ([ ]);
  string *keylist, room;
  keylist = keys(keys);
  room = map[ypos][xpos][0];
  for(y = -1; y < 2; y++) {
    if(y+ypos < 0)
      continue;
    if(y+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if(x+xpos < 0)
        continue;
      if(x+xpos >= sizeof(map[y+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(map[y+ypos][x+xpos] != 0) {
        exits[DIRECTIONS[y+1][x+1]] = upper_case(map[y+ypos][x+xpos][3]) +
          " + \"" + map[y+ypos][x+xpos][0] + "\"";
      }
    }
  }
  return exits;
}
int write_this_file(string istring, string dir, string fname, string sname,
                    mapping exits) {
  string str, tmp, exit;
  int i;
  str = "#include \"path.h\";\n\n";
  str += "inherit " + istring + ";\n";
  str += "\n";
  str += "void setup() {\n";
  str += "  set_short(\"" + sname + "\");\n";
  str += "  set_long(\"This is " + sname + " it hasn't had its long \"\n";
  str += "           \"description set yet.\\n\");\n";
  str += "  set_light( 80 );\n";
  for(i=0; i<sizeof(LIST); i++) {
    if(exits[LIST[i]] &&
       exits[LIST[(i+1) % sizeof(LIST)]] &&
       exits[LIST[(i+2) % sizeof(LIST)]]) {
      map_delete(exits, LIST[(i)]);
      map_delete(exits, LIST[(i+2) % sizeof(LIST)]);
    }
  }
  foreach(exit in keys(exits)) {
    str += sprintf("  add_exit(\"%s\", %s, \"road\");\n",
                   exit, exits[exit]);
  }
  str += "}\n";
  if(file_size(dir) != -2) {
    mkdir(dir);
    tmp = "#include \"../path.h\"\n";
    tmp += "#undef PATH\n";
    tmp += "#define PATH __DIR__\n";
    write_file(dir + "/path.h", tmp, 1);
  }
  return write_file( dir + "/" + fname + ".c", str, 1 );
}
mixed *read_map(string mapfile, mapping keys) {
  int i, j;
  mixed *map;
  string *lines;
  lines = explode(read_file(mapfile), "\n");
  map = allocate(sizeof(lines));
  for(i=0; i<sizeof(lines); i++) {
    map[i] = allocate(strlen(lines[i]));
    for(j=0; j<strlen(lines[i]); j++) {
      if(keys[lines[i][j]]) {
        keys[lines[i][j]][0] = to_int(keys[lines[i][j]][0]) + 1;
        map[i][j] = ({ keys[lines[i][j]][2] + keys[lines[i][j]][0] }) +
                         keys[lines[i][j]];
      } else {
        map[i][j] = 0;
      }
    }
  }
  log_file("/w/ceres/tmp.log", "%O", map);
  return map;
}
mapping read_keys(string keyfile) {
  mapping keys;
  string line, *lines;
  keys = ([ ]);
  lines = explode(read_file(keyfile), "\n");
  foreach(line in lines)
    keys[line[0]] = explode(line[1..], "\t");
  return keys;
}
int map_to_files( string mapfile, string fdir, string keyfile ) {
  int tot;
  string *file_tmp;
  string pstr;
  int x, y;
  mapping keys;
  mixed *temp_map, temp_exits;
  if(!mapfile || mapfile == "")
    return NO_MAP_FILE;
  file_tmp = this_player()->get_files(mapfile);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_MAP_FILE;
  else
    mapfile = file_tmp[0];
  if(!fdir || fdir == "")
    file_tmp = ({ this_player()->query_path() });
  else
    file_tmp = this_player()->get_files(fdir);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) != -2)
    return NO_FILE_DIR;
  else
    fdir = file_tmp[0];
  if(!keyfile || keyfile == "" )
    keyfile = DEFAULT_KEYS;
  file_tmp = this_player()->get_files(keyfile);
  if(sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_KEY_FILE;
  else
    keyfile = file_tmp[0];
  keys = read_keys(keyfile);
  temp_map = read_map(mapfile, keys);
  for(y = 0; y < sizeof(temp_map); y++) {
    reset_eval_cost();
    for(x = 0; x < sizeof(temp_map[ y ]); x++) {
      if(temp_map[y][x] != 0) {
        temp_exits = get_exits(y, x, temp_map, keys);
        if(sizeof(temp_map[y][x]) < 5) {
          return;
        }
        tot += write_this_file(temp_map[y][x][2],
                               fdir + "/" + temp_map[y][x][3],
                               temp_map[y][x][0], temp_map[y][x][4],
                               temp_exits);
      }
    }
  }
  pstr = "\n";
  pstr += "#define CITY \"" + fdir + "/\"\n";
  foreach(x in keys(keys))
    pstr += "#define " + upper_case(keys[x][2]) + " CITY + \"" + keys[x][2] +
      "/\"\n";
  tot += write_file( fdir+ "/path.h", pstr, 1 );
  return tot;
}

==================================================
FILE: dist/mtf/mtf2.c
==================================================

#include "mtfincl.h";
mixed *map;
mapping key_data;
class map_class {
  string filename;
  int counter;
  string inheritname;
  string basename;
  string short;
  string long;
  mapping exits;
}
class exit {
  string dest;
  int ypos;
  int xpos;
}
mapping get_exits(int ypos, int xpos) {
  int x, y;
  class map_class data;
  mapping exits = ([ ]);
  if(!classp(map[ypos][xpos]))
    return ([ ]);
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        if((map[y+ypos][x+xpos] == '*') ||
           (map[y+ypos][x+xpos] == '+' && (y == 0 || x == 0)) ||
           (map[y+ypos][x+xpos] == 'x' && (y != 0 && x != 0)) ||
           (map[y+ypos][x+xpos] == '|' && y != 0 && x == 0) ||
           (map[y+ypos][x+xpos] == '-' && y == 0 && x != 0) ||
           (map[y+ypos][x+xpos] == '\\' && y == -1 && x == -1) ||
           (map[y+ypos][x+xpos] == '\\' && y == 1 && x == 1) ||
           (map[y+ypos][x+xpos] == '/' && y == 1 && x == -1) ||
           (map[y+ypos][x+xpos] == '/' && y == -1 && x == 1)) {
          exits[DIRECTIONS[y+1][x+1]] = new(class exit,
                                            dest : upper_case(data->basename)+
                                            " + \"" + data->filename + "\"",
                                            ypos : y+ypos,
                                            xpos : x+xpos);
        } else if(map[y+ypos][x+xpos] != ' ') {
          debug_printf("Unknown direction char: %O (%c), %d - %d, %d - %d %O %s",
                       map[y+ypos][x+xpos], map[y+ypos][x+xpos], x, xpos, y, ypos,
                       map[ypos][xpos],
                       data->basename);
        }
      }
    }
  }
  return exits;
}
#ifdef 0
mixed *find_nearby(int ypos, int xpos, int distance, int direc) {
  string *dirs;
  int ny, nx;
  class exit tmp;
  if(distance > 4)
    return 0;
  if(!classp(map[ypos][xpos]))
    return 0;
  dirs = keys(map[ypos][xpos]->exits);
  if(direc >= sizeof(dirs))
    return 0;
  tmp = map[ypos][xpos]->exits;
  ny = tmp[]->ypos;
  nx = tmp[]->xpos;
  if(nx == xpos && ny == ypos) {
    if(direc == sizeof(dirs) -1)
      return 0;
    else
      direc++;
  }
  if(!find_nearby(ny, nx, ++distance);
}
#endif
string calc_long(int ypos, int xpos) {
  int x, y, sameroad;
  class map_class data;
  string *exits = ({ });
  string *junctions = ({ });
  string long_str;
  mixed *nearby;
  if(!classp(map[ypos][xpos]))
    return "";
  sameroad = 0;
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        if(map[y+ypos][x+xpos] == '+' &&
           map[ypos][xpos]->basename ==
           map[(y*2)+ypos][(x*2)+xpos]->basename) {
          sameroad++;
          exits += ({ DIRECTIONS[y+1][x+1] });
        }
      }
    }
  }
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        if(((map[y+ypos][x+xpos] == '*') ||
            (map[y+ypos][x+xpos] == '+' && (y == 0 || x == 0)) ||
            (map[y+ypos][x+xpos] == 'x' && (y != 0 && x != 0)) ||
            (map[y+ypos][x+xpos] == '|' && y != 0 && x == 0) ||
            (map[y+ypos][x+xpos] == '-' && y == 0 && x != 0) ||
            (map[y+ypos][x+xpos] == '\\' && y == -1 && x == -1) ||
            (map[y+ypos][x+xpos] == '\\' && y == 1 && x == 1) ||
            (map[y+ypos][x+xpos] == '/' && y == 1 && x == -1) ||
            (map[y+ypos][x+xpos] == '/' && y == -1 && x == 1)) &&
           map[ypos][xpos]->basename !=
           map[(y*2)+ypos][(x*2)+xpos]->basename) {
          if(member_array(map[(y*2)+ypos][(x*2)+xpos]->short, junctions) == -1)
            junctions += ({ map[(y*2)+ypos][(x*2)+xpos]->short });
        }
      }
    }
  }
#ifdef 0
  if(!sizeof(junctions)) {
    nearby = find_nearby(ypos, xpos);
  }
#endif
  long_str = "This is ";
  if(sizeof(junctions)) {
    long_str += map[ypos][xpos]->short + " at the junction with " +
      query_multiple_short(junctions) +
      ".\n";
  } else if(sameroad == 0) {
    long_str += "the end of " + map[ypos][xpos]->short;
  } else if(sameroad == 1) {
    long_str += "a fork in " + map[ypos][xpos]->short +
      " where it splits heading " +
      query_multiple_short(exits);
  } else {
    long_str += map[ypos][xpos]->short;
  }
  return long_str;
}
int write_this_file(string fdir, int ypos, int xpos) {
  class map_class room;
  string str, tmp, exit;
  mapping exits;
  int i;
  room = map[ypos][xpos];
  str = "#include \"path.h\";\n\n";
  str += "inherit " + room->inheritname + ";\n";
  str += "\n";
  str += "void setup() {\n";
  str += "  set_short(\"" + room->short + "\");\n";
  str += "  set_long(\"" + room->long + "\\n\");\n";
  str += "  set_light( 80 );\n";
  exits = room->exits;
  foreach(exit in keys(exits)) {
    i = member_array(exit, DIRECTIONS);
    if(i % 2 == 1 &&
       exits[DIRECTIONS[i-1]] &&
       exits[DIRECTIONS[(i+1) % sizeof(DIRECTIONS)]])
      str += sprintf("  add_exit(\"%s\", %s, \"secret\");\n",
                     exit, exits[exit]->dest);
    else
      str += sprintf("  add_exit(\"%s\", %s, \"road\");\n",
                     exit, exits[exit]->dest);
  }
  str += "}\n";
  if(file_size(fdir + "/" + room->basename) != -2) {
    mkdir(fdir + "/" + room->basename);
    tmp = "#include \"../path.h\"\n";
    tmp += "#undef PATH\n";
    tmp += "#define PATH __DIR__\n";
    write_file(fdir + "/" + room->basename + "/path.h", tmp, 1);
  }
  return write_file( fdir + "/" + room->basename + "/" + room->filename + ".c",
                     str, 1 );
}
mixed *read_map(string mapfile) {
  int i, j;
  mixed *temp_map;
  string *lines;
  lines = explode(read_file(mapfile), "\n");
  temp_map = allocate(sizeof(lines));
  for(i=0; i<sizeof(lines); i++) {
    temp_map[i] = allocate(strlen(lines[i]));
    for(j=0; j<strlen(lines[i]); j++) {
      if(key_data[lines[i][j]]) {
        key_data[lines[i][j]][0] = to_int(key_data[lines[i][j]][0]) + 1;
        if(sizeof(key_data[lines[i][j]]) < 4)
          debug_printf("Key data too small: %O", key_data[lines[i][j]]);
        temp_map[i][j] = new(class map_class,
                             filename : key_data[lines[i][j]][2] +
                             key_data[lines[i][j]][0],
                             counter : key_data[lines[i][j]][0],
                             inheritname : key_data[lines[i][j]][1],
                             basename : key_data[lines[i][j]][2],
                             short : key_data[lines[i][j]][3]);
      } else
        temp_map[i][j] = lines[i][j];
    }
  }
  return temp_map;
}
mapping read_keys(string keyfile) {
  mapping key_data;
  string line, *lines;
  key_data = ([ ]);
  lines = explode(read_file(keyfile), "\n");
  foreach(line in lines) {
    key_data[line[0]] = explode(line[1..], "\t");
  }
  return key_data;
}
int map_to_files( string mapfile, string fdir, string keyfile ) {
  int tot;
  string *file_tmp;
  string pstr;
  int x, y;
  if(!mapfile || mapfile == "")
    return NO_MAP_FILE;
  file_tmp = this_player()->get_files(mapfile);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_MAP_FILE;
  else
    mapfile = file_tmp[0];
  if(!fdir || fdir == "")
    file_tmp = ({ this_player()->query_path() });
  else
    file_tmp = this_player()->get_files(fdir);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) != -2)
    return NO_FILE_DIR;
  else
    fdir = file_tmp[0];
  if(!keyfile || keyfile == "" )
    keyfile = DEFAULT_KEYS;
  file_tmp = this_player()->get_files(keyfile);
  if(sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_KEY_FILE;
  else
    keyfile = file_tmp[0];
  key_data = read_keys(keyfile);
  map = read_map(mapfile);
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x])) {
        map[y][x]->exits = get_exits(y, x);
      }
  reset_eval_cost();
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x]))
        map[y][x]->long = calc_long(y, x);
  reset_eval_cost();
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x]))
        tot += write_this_file(fdir, y, x);
  pstr = "\n";
  pstr += "#define CITYROOM \"/d/am/cityroom\"\n";
  pstr += "#undef CITY\n";
  pstr += "#define CITY \"" + fdir + "/\"\n";
  foreach(x in keys(key_data))
    pstr += "#define " + upper_case(key_data[x][2]) + " CITY + \"" + key_data[x][2] +
      "/\"\n";
  tot += write_file( fdir+ "/path.h", pstr, 1 );
  return tot;
}

==================================================
FILE: dist/mtf/mtfincl.h
==================================================

#define PATH "/w/ceres/mtf-v1.1/"
#define VERSION v1.1
#define NO_MAP_FILE -1
#define NO_FILE_DIR -2
#define NO_KEY_FILE -3
#define DEFAULT_KEYS PATH+"key_dft.c"
#define SPECIALS ({ "*", "+", "x", "-", "|", "\\", "/" })
#define EXITS_NS ({ "north", "", "south" })
#define EXITS_WE ({ "west", "", "east" })
#define DIRECTIONS ({ ({ "northwest", "north", "northeast", }), ({ "west", "", "east", }), ({ "southwest", "south", "southeast" }) })
#define LIST ({"north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest" })

==================================================
FILE: dist/start/entrance.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
void setup() {
   set_short("entrance");
   set_long("You are standing at the entrance to a big wide, well quite small, "
            "area.  Welcome to the Discworld mud distribution lib entrance.\n");
   set_light(70);
   add_exit("pumpkin", CONFIG_START_LOCATION, "road");
}

==================================================
FILE: dist/pumpkin/hospital.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include <living.h>
#include <map.h>
#include <money.h>
#include <move_failures.h>
#include <route.h>
#include <wander.h>
#include "path.h"
#define MAX_HEAVIES 10
#define DAY 8 * 60 * 60
#define INTERVAL 20 * 60
#define MUD_TO_REAL 3
#define BLOCK 5
#define MAX_EMPTIES 12
#define MAX_MOVERS 60
#define SAVE_FILE SAVE +"hospital"
inherit "/std/room/basic_room";
nosave int alchemists, update, *alignments;
mapping uniques;
nosave int *al_data;
nosave string *city;
nosave object *empties;
nosave mapping blockages;
nosave mixed *movers;
nosave int am_npcs, last_check;
int ok_to_clone();
void get_weapon(object ob, string *items);
void get_armour(object ob, string *items);
void get_jewellery(object ob, string *items);
void setup() {
   set_keep_room_loaded(1);
   update = time();
   alignments = allocate( 50 );
   uniques = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
   alchemists++;
   unguarded( (: save_object, SAVE_FILE :) );
   city = ({
      "child", "rodent", "cockroach", "dog"
   });
   empties = ({ });
   blockages = ([ ]);
   movers = allocate( MAX_MOVERS );
   call_out( "check_movers", 10 );
   call_out( "housekeeping", INTERVAL );
}
int *query_al_data() { return al_data; }
mapping query_uniques() { return uniques; }
object *query_empties() { return empties; }
mapping query_blockages() { return blockages; }
int query_blockage( string this, string other, int number ) {
   if ( undefinedp( blockages[ this ] ) ) {
      if ( random( 100 ) >= BLOCK )
         number = -1;
      blockages[ this ] = blockages[ other ] = number;
   }
   return blockages[ this ];
}
mixed *query_movers() { return movers; }
void housekeeping() {
   object thing;
   update = time();
   foreach( thing in users() ) {
      if ( thing->query_creator() )
         continue;
      alignments[ random( sizeof( alignments ) ) ] =
            (int)thing->query_al();
   }
   al_data = 0;
   unguarded( (: save_object, SAVE_FILE :) );
   call_out( "housekeeping", INTERVAL );
}
int pick_al() {
   int one, *stats;
   if ( !al_data ) {
      al_data = allocate( 3 );
      stats = allocate( 4 );
      foreach( one in alignments ) {
         stats[ 0 ] += one;
         stats[ 1 ] += one * one;
         if ( one > stats[ 2 ] )
            stats[ 2 ] = one;
         if ( one < stats[ 3 ] )
            stats[ 3 ] = one;
      }
      stats[ 0 ] /= sizeof( alignments );
      stats[ 1 ] /= sizeof( alignments );
      stats[ 1 ] -= stats[ 0 ] * stats[ 0 ];
      stats[ 1 ] /= 10;
      if ( stats[ 1 ] < 50 )
         stats[ 1 ] = 50;
      stats[ 2 ] -= stats[ 3 ];
      if ( stats[ 2 ] < 2 )
         stats[ 2 ] = 2;
      al_data[ 0 ] = stats[ 0 ] - stats[ 2 ] / 2;
      al_data[ 1 ] = ( stats[ 2 ] * stats[ 2 ] ) / ( 12 * stats[ 1 ] );
      if ( al_data[ 1 ] < 5 )
         al_data[ 1 ] = 5;
      al_data[ 2 ] = ( 12 * stats[ 1 ] ) / stats[ 2 ];
      if ( al_data[ 2 ] < 25 )
         al_data[ 2 ] = 25;
   }
   return al_data[ 0 ] + roll_MdN( al_data[ 1 ], al_data[ 2 ] );
}
int make_unique( string word ) {
   if ( uniques[ word ] > time() )
      return 0;
    uniques[ word ] = time() + 1 * 60 * 60;
   unguarded( (: save_object, SAVE_FILE :) );
   return 1;
}
void add_mover( object thing ) {
   int number;
   number = MAX_MOVERS / 2 + random( MAX_MOVERS / 2 );
   if ( !pointerp( movers[ number ] ) )
      movers[ number ] = ({ thing });
   else
      movers[ number ] += ({ thing });
}
object get_monster( string type ) {
   object thing;
   object ob;
   switch( type ) {
      case "city" :
      case "pumpkin" :
         thing = get_monster( city[ random( sizeof( city ) ) ] );
         thing->add_property( "monster type", type +":"+
               (string)thing->query_property( "monster type" ) );
         thing->add_move_zone( "Pumpkin" );
         add_mover( thing );
         return thing;
      case "dog":
         thing = clone_object( CHARS + "dog" );
         if ( random( 4 ) )
            thing->set_type( "small" );
         else
            thing->set_type( "large" );
         thing->add_effect( "/std/effects/npc/i_died",
               ({ HOSPITAL, "regen_after_death" }));
         thing->add_effect( "/std/effects/npc/eat_edible" );
         thing->add_effect( "/std/effects/npc/savage_corpse" );
         thing->add_property( "monster type", type );
         thing->add_property("animal type", type);
         return thing;
      case "child":
         thing = clone_object( CHARS + "child_human" );
         return thing;
    case "cityguard":
      ob = clone_object(MONSTER);
      ob->add_property("monster type", type);
      ob->set_name("guard");
      ob->add_adjective("city");
      ob->set_main_plural( "city guards" );
      ob->set_short("city guard");
      ob->set_long("This is a city guard. He is supposed to protect the " +
        "city from undesirables. Sadly, Pumpkin isn't very fussy.\n");
      ob->set_race("human");
      ob->set_gender("male");
      ob->set_guild("fighter");
      ob->set_level(8);
      ob->set_al( pick_al() / 5 );
      ob->adjust_money( 5 + random( 10 ), "Pumpkin pence" );
      ob->load_chat(10, ({
          3, "@grumble bitterly",
          1, "@daydream",
          1, "@sigh heavily"
          }) );
      ob->load_a_chat(50, ({
          1, "'Ouch!",
          1, "'Come on! I don't need this.",
          1, "'Be on your way!",
          }) );
      ARMOURY->request_weapon("long sword", 40+random(40))->move(ob);
      if(random(2))
        ARMOURY->request_armour("hard leather cap", 70 + random(30))->move(ob);
      ob->init_equip();
      return ob;
    case "mercenary":
      ob = clone_object(MONSTER);
      ob->set_name("mercenary");
      ob->set_main_plural( "mercenaries" );
      ob->add_plural( "mercenaries" );
      ob->add_adjective("tough");
      ob->set_race("human");
      ob->set_class("fighter");
      ob->set_level( 50 + roll_MdN( 5, 50 ) );
      ob->set_al( pick_al() );
      ob->set_gender(random(2) + 1);
      ob->set_long("A tough battle scarred mercenary.  There are better "
                   "ways of filling in an afternoon than messing with the "
                   "likes of "+ob->query_objective()+".\n");
      ob->adjust_money( 5 + random( 50 ), "Ankh-Morpork pence" );
      ob->adjust_money( 1 + random( 5 ), "Ankh-Morpork dollar" );
      ob->load_chat(3, ({
        1, "'Anyone you don't like?",
        1, "'I'll do anything if the price is right?",
        1, "'Don't get me angry.  You won't like me when I'm angry."
      }));
      ob->load_a_chat(30, ({
        1, "'I'll show you who's boss.",
        1, "'You think you're so tough.",
        1, "The crowd runs in terror as the mercenary kills someone by "+
           "accident."
      }));
      get_weapon(ob, ({"bastard sword", "long sword", "morning star",
       "two-handed axe"}));
      get_armour(ob, ({"chainmail", "splintmail", "ringmail"}));
      ob->add_property("monster type", type);
      ob->init_equip();
      return ob;
    case "rodent":
      ob = clone_object(MONSTER);
      ob->set_name("rat");
      ob->set_short("rat");
      ob->set_race("rat");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->add_alias("city rat");
      ob->set_main_plural("rats");
      ob->add_adjective("dirty");
      ob->add_adjective("city");
      ob->set_long("This is a large rat.  It appears to have done well "+
       "living in the city.\n"+
       "The pollution must not affect it too much.\n" );
      ob->load_chat( 5, ({
         1, ":squeaks.",
         1, ":sniffs the air, whiskers twitching.",
         1, ":checks for dwarves."
      }) );
      ob->set_wimpy( 10 );
      ob->load_a_chat( 50, ({
         1, ":squeals in pain.",
         1, ":twitches fearfully."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                     ({ HOSPITAL, "regen_after_death" }));
      ob->add_effect( "/std/effects/npc/eat_edible" );
      ob->add_effect( "/std/effects/npc/savage_corpse" );
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    case "cockroach":
      ob = clone_object(MONSTER);
      ob->set_name("cockroach");
      ob->set_short("cockroach");
      ob->set_race("cockroach");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->set_main_plural("cockroaches");
      ob->add_adjective("dirty");
      ob->add_alias("roach");
      ob->set_long( "This is a huge dirty great big cockroach, the size of "
             "your hand at least.  It waves its feelers at you and looks "
             "horrible and black.  Not only can cockroaches survive fires, "
             "plagues, earthquakes and miscellaneous acts of supernatural "
             "beings, they can survive in Ankh-Morpork!\n" );
      ob->load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
      ob->set_wimpy( 30 );
      ob->load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                      ({ HOSPITAL, "regen_after_death" }));
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    default:
      ob = clone_object(MONSTER);
      ob->set_name("failure");
      ob->set_short("failure");
      ob->set_long( "Please inform a creator about this object.\n"+
          "Type is "+ type +" from "+ file_name( previous_object() ) +".\n" );
      ob->add_property( "monster type", "failure:"+ type );
      return ob;
  }
}
void get_armour(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void get_jewellery(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 20+random(80))->
    move(ob);
}
void get_weapon(object ob, string *items) {
  ARMOURY->request_weapon(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void regen_after_death(object player) {
  object ob, dest;
  string nam;
  if (!player)
    return ;
  nam = (string)player->query_property("monster type");
  dest = (object)player->query_property("start location");
  if ( !nam )
    return;
  if ( !dest )
    return;
  if(!ok_to_clone())
    return;
  ob = get_monster( explode( nam, ":" )[ 0 ] );
  dest->add_monster(player, ob);
  call_out("do_move", 10, ({ ob, dest }) );
}
void do_move(mixed *junk) {
  junk[0]->move(junk[1]);
}
string change_to_name(object ob) {
  return implode((string *)ob->query_adjectives(), " ")+
         (string)ob->query_name();
}
void do_run(object ob) {
  if (ob)
    ob -> run_away();
}
void fight_check(object ob, object ob1) {
  if (ob->query_property(previous_object()->query_name()))
    previous_object()->attack_ob(ob1);
}
void do_grin_laugh(object ob) {
  ob->add_respond_to_with(({ "@grin", ob->query_name() }),
                          "laugh man at $hname$");
}
void add_empty( object thing ) {
   empties -= ({ 0 });
   empties += ({ thing });
   if ( sizeof( empties ) > MAX_EMPTIES )
      empties = shuffle( empties )[ 0 .. MAX_EMPTIES - 1 ];
}
void move_monster( object thing ) {
   int i;
   string dest, direc, zone, *movez, *roomz;
   object place;
   if ( !thing )
      return;
   if ( (int)thing->query_hp() < 0 )
      return;
   if ( thing->query_property( PASSED_OUT ) || thing->query_fighting() ) {
      add_mover( thing );
      return;
   }
   movez = (string *)thing->query_move_zones();
   empties -= ({ 0 });
   if ( sizeof( empties ) && !thing->check_anyone_here() )
      foreach ( place in empties ) {
         roomz = (string *)place->query_zones();
         if ( !sizeof( roomz ) ) {
            empties -= ({ place });
            continue;
         }
         foreach ( zone in roomz ) {
            i = member_array( zone, movez );
            if ( i != -1 )
               break;
         }
         if ( i == -1 )
            continue;
         thing->move( place );
         place->add_monster( 0, thing );
         place->announce_entry( thing );
         empties -= ({ place });
         add_mover( thing );
         return;
      }
   place = environment( thing );
   if ( !place )
      return;
   add_mover( thing );
   foreach ( direc in shuffle( (string *)place->query_direc() ) ) {
      place->set_destination( direc );
      dest = (string)place->query_destination( direc );
      if ( !stringp( dest ) )
         continue;
      if ( !thing->check_anyone_here() && !find_object( dest ) )
         continue;
      if ( find_object( dest ) )
         roomz = (string *)dest->query_zones();
      else
         roomz = (string *)MAP->query_zones( dest );
      if ( !sizeof( roomz ) )
         continue;
      foreach ( zone in roomz ) {
         i = member_array( zone, movez );
         if ( i != -1 )
            break;
      }
      if ( i == -1 )
         continue;
      if ( place->query_relative( direc ) )
         direc = (string)thing->find_rel( direc, 0 );
      if ( thing->do_command( direc ) )
         return;
   }
}
void check_movers() {
   int when;
   object thing, *things;
   things = movers[ 0 ];
   movers[ 0 .. MAX_MOVERS - 2 ] = movers[ 1 .. ];
   movers[ MAX_MOVERS - 1 ] = 0;
   call_out( "check_movers", 10 );
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) ) {
         when += 2;
         call_out( "move_monster", when, thing );
      }
   }
}
int ok_to_clone() {
  if(time() > last_check + 300) {
    last_check = time();
    am_npcs = sizeof( filter( named_livings(),
      (: environment( $1 ) && base_name( environment( $1
       ) )[0..4] == "/d/am" :) ) );
  }
  return ( am_npcs < MAX_AM_LIVING );
}
int *query_npcs() {
  return ({ am_npcs, last_check });
}

==================================================
FILE: dist/pumpkin/money_symboliser.c
==================================================

string symbolise_value( int value ) {
   int dollars;
   int pence;
   string s;
   if (value < 0) {
      s = "-";
      value = - value;
   } else {
      s = "";
   }
   dollars = value / 100;
   pence = ( value % 100 );
   if ( !pence ) {
      return "P$"+ s + dollars;
   }
   if ( !dollars ) {
      return s + pence +"p";
   }
   if ( pence < 10 ) {
      return "P$"+ s + dollars +".0"+ pence;
   }
   return "P$" + s + dollars + "." + pence;
}
int unsymbolise_string( string str ) {
  int dollars;
  int pence;
  if (strlen(str) < 2) {
    return 0;
  }
  if (str[0] == '$' ||
      lower_case(str[0..1]) == "p$") {
     if (str[0] == 'p') {
       str = str[1..];
     }
     if (sscanf(str, "$%d.%d", dollars, pence) == 2) {
        return dollars * 100 + pence;
     } else if (sscanf(str, "$%d", dollars) == 1) {
        return dollars * 100;
     }
  } else if (lower_case(str[<1..<1]) == "p") {
     if (sscanf(str, "%dp", pence) == 1) {
       return pence;
     }
  }
  return 0;
}

==================================================
FILE: dist/pumpkin/path.h
==================================================

#undef CITY
#define CITY "/d/dist/pumpkin/"
#define CITYROOM (CITY "inherit/cityroom")
#define RABBIT CITY + "rabbit/"
#define STABLE CITY + "stable/"
#define PUMPKIN CITY + "pumpkin/"
#define GUMBOOT CITY + "gumboot/"
#define FRUITBAT CITY + "fruitbat/"
#define STABLE CITY + "stable/"
#define CRUMPT CITY + "crumpt/"
#define PLAIN CITY + "plain/"
#define DESERT CITY + "desert/"
#define SQUASH CITY + "squash/"
#define WOODS CITY + "woods/"
#define HOSPITAL (CITY "hospital")
#define HOSPITAL_INC (CITY "handler/hostpial.h")
#define SAVE CITY + "save/"
#define CHARS (CITY + "chars/")
#define TERRAIN_HANDLER (CITY + "terrain/terrain_handler")

==================================================
FILE: dist/pumpkin/path2.h
==================================================

#undef CITY
#define CITY "/d/dist/pumpkin/"
#define CITYROOM (CITY "inherit/cityroom")
#define RABBIT CITY + "rabbit/"
#define STABLE CITY + "stable/"
#define PUMPKIN CITY + "pumpkin/"
#define GUMBOOT CITY + "gumboot/"
#define FRUITBAT CITY + "fruitbat/"
#define STABLE CITY + "stable/"
#define CRUMPT CITY + "crumpt/"
#define PLAIN CITY + "plain/"
#define PLAIN CITY + "plain/"
#define SQUASH CITY + "squash/"
#define PLAIN CITY + "plain/"

==================================================
FILE: dist/pumpkin/crumpt/bank.c
==================================================

#include "path.h"
inherit "/std/shops/bank";
void setup() {
   set_short("Pumpkin's Bank");
   set_long(
"The room is full of pumpkins with little dollar signs carved in the side.  "
"There is a wooden counter running across the room with some telers peering "
"through the wooden grill into the main room.\n");
   add_item("counter", ({ "long", "It is wooden and has a grill on top to "
            "seperate the tellers from the unwashed masses.",
            "position", "the counter" }));
   add_item("teller", "They peer out at through the grill wondering who has "
            "come to give them money.\n");
   add_item("pumpkin", "There are little pumpkins everywhere in the room.");
   set_light(70);
   set_percentage(95);
   set_place("Pumpkin");
   add_exit("south", CRUMPT + "crumpt7", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/club_office.c
==================================================

#include "path.h"
#include <clubs.h>
inherit "/std/room/club_control_room";
void setup() {
   set_light(70);
   set_club_control_type(CLUB_ROOM_CLUB_ONLY);
   set_short("Club control room");
   set_long("This is a small cosy room with a nice comradely atmosphere "
            "about it.  There is a nice sofa and a desk with little club "
            "ornaments all over it.\n");
   add_item("sofa", ({ "long",
                      "The sofa looks nice and comfortable, just the spot "
                      "after a hard days hacking people into small bits.\n",
               "position", "the comfy sofa" }));
   add_item("desk",
            ({ "long",
                   "The brown leather covered desk looks really nice "
                   "and comforable sitting in the middle of the room like "
                   "that.  It is covered in small club shaped ornaments.\n",
               "position", "the large black desk" }));
   add_item("club ordanment",
            "The desk is covered in them, 'Real genuine minature babarian "
            "clubs'.  Looks like someone has a club fetish.\n");
   set_not_replaceable(1);
   clone_object("/obj/misc/top_clubs")->move(this_object());
   add_exit("south", PATH + "crumpt6", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is Crumpet Circle at the junction with Pumpkin Way.
\n");
  set_light( 80 );
  add_exit("northeast", PUMPKIN + "pumpkin1", "road");
  add_exit("southwest", CRUMPT + "crumpt2", "road");
  add_exit("south", CRUMPT + "crumpt3", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt1", "road");
  add_exit("southwest", CRUMPT + "crumpt4", "road");
  add_exit("northwest", CRUMPT + "post_office", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("north", CRUMPT + "crumpt1", "road");
  add_exit("south", CRUMPT + "crumpt5", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt2", "road");
  add_exit("southwest", CRUMPT + "crumpt6", "road");
  add_exit("north", CRUMPT + "family_office", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("southwest", CRUMPT + "crumpt7", "road");
  add_exit("north", CRUMPT + "crumpt3", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt6.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt4", "road");
  add_exit("south", CRUMPT + "crumpt8", "road");
  add_exit("north", PATH + "club_office", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt7.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt5", "road");
  add_exit("southwest", CRUMPT + "crumpt9", "road");
  add_exit("north", CRUMPT + "bank", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt8.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is Crumpet Circle at the junction with Fruitbat Avenue.
\n");
  set_light( 80 );
  add_exit("east", CRUMPT + "crumpt9", "road");
  add_exit("north", CRUMPT + "crumpt6", "road");
  add_exit("south", FRUITBAT + "fruitbat1", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt9.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt7", "road");
  add_exit("west", CRUMPT + "crumpt8", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/family_office.c
==================================================

#include "path.h"
#include <clubs.h>
inherit "/std/room/club_control_room";
int check_playtester(string str, object ob, string special_mess);
void setup() {
   object table;
   set_light(100);
   set_club_control_type(CLUB_ROOM_FAMILY_ONLY);
   set_short("Family control room");
   set_long("White boards cover the walls of the room, in the middle of "
            "the boards is a large black desk.  Scribblings and weird lines "
            "joining squiggly blobs to other squiggly blobs cover the white "
            "boards.\n");
   add_sign("A large imposing 'read me' type sign.\n",
            (: query_club_warning_message() :),
            "sign");
   add_item("white board", "They are everywhere, the drawings all look "
                   "somewhat meaningless, although perhaps they are "
                   "trying to convey some sort of family tree feeling.  "
                   "All the drawings look rather old, odd really.  "
                   "A singular lack of white board markers or erasers "
                   "could be the reason behind it.\n");
   add_item("white board eraser",
                   "There are none of them here, not one, not even...  No "
                   "none at all.\n");
   add_item("white board marker",
                   "Looking around the place, there is a singular lack of "
                   "white board markers.\n");
   add_item("large black desk",
            ({ "long",
                   "The desk looks imposing in its bulk and girth.  It "
                   "looks a bit unused, although there is a register "
                   "sitting on top of the desk which seems to contain the "
                   "list of all the current clubs in Ankh-Morpork.\n",
               "position", "the large black desk" }));
   add_item("squiggly blob",
                   "It appears to be joined to another squiggly blob.\n");
   add_item("weird line",
                   "This line darts across the board at an angle that "
                   "is hard to determine, you guess 16.123678 degrees.\n");
   add_item("scribblings",
                   "They are not recognisably words, they just look like they "
                   "could be words until you take a closer look.\n");
   set_not_replaceable(1);
   add_exit("south", PATH + "crumpt4", "door");
   table = clone_object("/obj/misc/top_families");
   table->move(this_object());
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/parcel_post.c
==================================================

#include "path.h"
inherit "/std/room/parcel_inherit";
void setup() {
   set_short("Parcel Post");
   set_long(
"Livid orange strips criss cross the room contrasting just beautifully "
"against the black background.  The walls almost seem to be pulsing with "
"colour.\n");
   set_light(70);
   add_exit("south", CRUMPT + "post_office", "south");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/crumpt/post_office.c
==================================================

#include "path.h"
#include <mail.h>
inherit "/std/room/basic_room";
int do_mail( string words );
private nosave object _dictionary;
void setup() {
   add_help_file("mail_room");
   set_short("Post Office");
   set_light(70);
   set_long(
"Black and orange colours seem to dominate the room, you can see a counter "
"or something in amongst all the clashing colours.\n");
   add_item("counter", ({ "long",
            "There are some envelopes and bits of paper strewn "
            "about on the counter.",
            "position", "the counter" }));
   add_exit("southeast", CRUMPT + "crumpt2", "door");
   add_exit("north", CRUMPT + "parcel_post", "corridor");
   add_property("place", "Pumpkin");
}
void reset() {
   if ( !_dictionary ) {
      _dictionary = clone_object( "/net/obj/dict" );
      _dictionary->add_property( "there", "attached to the counter" );
      _dictionary->reset_get();
      _dictionary->move( this_object() );
   }
}
void init() {
   ::init();
   add_command("mail", "<string>", (: do_mail($4[0]) :));
   add_command("mail", "", (: do_mail(0) :));
}
int do_mail( string words ) {
   return (int)MAIL_TRACK->mail( words );
}
int send_message( string from, int parcel ) {
#if 0
   object thing;
   thing = clone_object( CHARS +"post_et" );
   thing->set_home( file_name( this_object() ) );
   thing->move( this_object(), "$N pop$s out of the counter and grab$s the mail." );
   if ( find_player( recipient ) ) {
      thing->goto_player( recipient, from );
   } else {
      thing->goto_dest( COMM_ROOM, from );
   }
   return 1;
#endif
}

==================================================
FILE: dist/pumpkin/inherit/cityroom.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include <move_failures.h>
#include <weather.h>
#include "path.h"
#define CREVICE ({ "a crevice", "a pothole", "a gutter" })[ random( 3 ) ]
#define LOG_FILE LOG +"city_log"
inherit "/std/room/outside";
int *crowd;
string type, *froms;
object *monsters;
int last_found;
int query_cityroom() { return 1; }
int *query_crowd() { return crowd; }
object *query_monsters() { return monsters; }
void announce_entry( object thing ) {
  string word;
  if ( !froms ) {
    froms = ({ });
    foreach ( word in query_direc() ) {
      if ( member_array( word, ({ "north", "south", "east", "west",
                                    "northeast", "southwest", "southeast",
                                    "northwest" }) ) == -1 )
        continue;
      if ( call_door( word, "query_closed" ) )
        continue;
      froms += ({ "the "+ word });
    }
  }
  if ( !sizeof( froms ) )
    tell_room( this_object(), "$a_short:"+ file_name( thing ) +
               "$ $V$0=arrives,arrive$V$ from elsewhere.\n" );
  else
    tell_room( this_object(), "$a_short:"+ file_name( thing ) +
               "$ $V$0=arrives,arrive$V$ from "+
               froms[ random( sizeof( froms ) ) ] +".\n" );
}
void make_citymonster( int number ) {
  if(!(int)HOSPITAL->ok_to_clone()) {
    HOSPITAL->add_empty( this_object() );
    return;
  }
  if ( !monsters[ number ] ) {
    monsters[ number ] = (object)( HOSPITAL )->get_monster( type );
    monsters[ number ]->add_property( "start location", this_object() );
    this_object()->do_zoning( monsters[ number ] );
    monsters[ number ]->move( this_object() );
    announce_entry( monsters[ number ] );
  }
  number++;
  if ( number >= sizeof( monsters ) )
    return;
  if((int)HOSPITAL->ok_to_clone())
    call_out( "make_citymonster", 5 + random( 5 ), number );
}
void set_monster( mixed number, string word ) {
  if ( intp( number ) ) {
    crowd = ({ number });
  } else {
    crowd = number;
  }
  number = crowd[ 0 ];
  crowd += ({ number });
  if ( number > 3 ) {
    number = 3;
  }
  monsters = allocate( random( 1 + number ) );
  type = word;
}
void create() {
  crowd = ({ 0, 0 });
  type = "unknown";
  monsters = ({ });
  do_setup++;
  ::create();
  do_setup--;
  add_property( "room size", 20 );
  add_property( "room zone", ({ "Pumpkin" }) );
  add_extra_look( this_object() );
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void reset() {
  if ( sizeof( monsters ) ) {
    call_out( "make_citymonster", 5 + random( 5 ), 0 );
  }
}
void dest_me() {
  ::dest_me();
}
int clean_up( int parent ) {
  if ( base_name( this_object() )[0..<3] == __FILE__) {
    return 0;
  }
  return ::clean_up( 0 );
}
mixed *stats() {
  return ::stats() + ({
    ({ "crowd", array_to_string( crowd[ 0 .. <2 ] ) }),
      });
}
int do_search( string words ) {
  object found;
  if ( query_property( "no scavenging" ) ) {
    return -1;
  }
  if ( this_player()->query_property( "dead" ) ) {
    return -1;
  }
  if ( words ) {
    if ( ( strsrch( words, "ground" ) == -1 ) &&
         ( strsrch( words, "crevice" ) == -1 ) &&
         ( strsrch( words, "pothole" ) == -1 ) &&
         ( strsrch( words, "gutter" ) == -1 ) &&
         ( strsrch( words, "cobble" ) == -1 ) ) {
      return -1;
    }
  }
  switch ( random( 21 ) ) {
  case 0 .. 6 :
    found = clone_object( "/obj/money" );
    if ( random( 80 ) ) {
      found->adjust_money( 1, "Pumpkin cent" );
    } else {
      if ( random( 80 ) ) {
        found->adjust_money( 1, "Pumpkin dollar" );
      } else {
        found->adjust_money( 10, "Pumpkin dollar" );
      }
    }
    break;
  case 7 .. 16 :
    if((time() - last_found) > random(360)) {
      found = (object)ARMOURY->choose_small_item();
      if(objectp(found)) {
        found->set_percentage(5 + random(30));
      } else {
        found = 0;
      }
      last_found = time();
    }
    break;
  case 17 .. 18 :
    if(sizeof(match_objects_for_existence("cockroach", this_object())) > 3) {
      return -1;
    }
    found = (object)HOSPITAL->get_monster( "cockroach" );
    found->move( this_object(), "$N scuttle$s out of "+
                 CREVICE +"." );
    return -1;
  case 19 :
    if(sizeof(match_objects_for_existence("rodent", this_object())) > 3) {
      return -1;
    }
    found = (object)HOSPITAL->get_monster( "rodent" );
    found->move( this_object(), "$N slink$s out of "+
                 CREVICE +"." );
    return -1;
  default :
    write( "You have a good look at the ground and spotting "
           "something, pick it up.  It's only a lump of rotting "
           "rubbish, though, which you throw away quickly.\n" );
    say( (string)this_player()->a_short() +" looks closely at "
         "the ground.  Seeing something, "+
         (string)this_player()->query_pronoun() +" picks it up, "
         "but finds that it's only a lump of rotting rubbish, so "+
         (string)this_player()->query_pronoun() +" throws it away.\n" );
    this_player()->add_effect( "/std/effects/other/rubbish_smell",
                               roll_MdN( 5, 60 ) );
    return 1;
  }
  if ( !found ) {
    return -1;
  }
  write( "You have a good look at the ground and scavenge "+
         (string)found->a_short() +" from "+ CREVICE +".\n" );
  say( (string)this_player()->a_short() +" looks closely at the ground.\n" );
  if ( (int)found->move( this_player() ) == MOVE_OK ) {
    write( "You pick it up.\n" );
    say( (string)this_player()->query_pronoun() +" picks something up.\n" );
  } else {
    write("Unfortunately you cannot pick it up and it disappears down "+
          CREVICE+".\n");
  }
  return 1;
}
void add_monster( object old_thing, object new_thing ) {
  int i;
  i = member_array( old_thing, monsters );
  if ( i != -1 ) {
    monsters[ i ] = new_thing;
    return;
  }
  i = member_array( 0, monsters );
  if ( i != -1 ) {
    monsters[ i ] = new_thing;
    return;
  }
  monsters += ({ new_thing });
}
void event_dest_me() {
  if ( find_call_out( "check_stuff" ) == -1 ) {
    call_out( "check_stuff", 30 );
  }
}
void check_stuff() {
  object thing, *things;
  things = all_inventory( this_object() );
  foreach( thing in things ) {
    if ( userp( thing ) ) {
      call_out( "check_stuff", 30 );
      return;
    }
    if ( living( thing ) || thing->query_corpse() ) {
      things -= ({ thing });
      continue;
    }
    if ( thing->do_not_sell() || !thing->query_value() ) {
      thing->move( "/room/rubbish" );
      things -= ({ thing });
      continue;
    }
  }
  if ( sizeof( things ) ) {
    things->move( "/d/am/filigree/general_store" );
  }
}
int query_crowd_now() {
  return crowd[ ( (int)WEATHER->minute_number() *
                  sizeof( crowd ) - 720 ) / 1440 ];
}
string extra_look( object thing ) {
  switch ( query_crowd_now() ) {
  case 0 :
    return "";
  case 1 :
    return "With few people about, this seems to be a quiet "
      "part of the city, perfect for getting mugged.\n";
  case 2 :
    return "A number of people pass by as they go about their "
      "lives (or in some cases, existences).\n";
  case 3 :
    return "Quite a few people, some in small groups, walk, "
      "trot and lurch along the street.\n";
  case 4 :
    return "This seems to be a busy part of the city, with "
      "many people hurrying to various destinations.\n";
  case 5 :
    return "All around you, crowds teem as Pumpkin moves "
      "turbulently through its hectic day.\n";
  case 6 :
    return "Crowds of people jostle you constantly, so keep "
      "an eye on your pockets...\n";
  default :
    return "The densely packed crowds make it difficult to "
      "move, and unpleasant to breathe.\n";
  }
}

==================================================
FILE: dist/pumpkin/inherit/hospital.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include "path.h"
#include HOSPITAL_INC
#define CREATE_NPCS 1
#define REGEN_TIME 1 * 60 * 60
#define DEFAULT_LOG_DIRECTORY "/d/cwc/log"
#define DEFAULT_POPULATION 3
#define MINIMUM_DEATH_REGEN 3
inherit "/std/room";
class regenerated_npc {
    string type;
    string load_position;
}
protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);
protected void restore_default_npcs();
protected void set_max_living(int new_living);
protected void set_hospital_type(string new_type);
protected object *make_monster(string type);
public object *get_monster(string type);
public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int query_max_living();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );
private nosave string _save_file, _hospital_type;
private nosave int _max_living;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;
public mapping _unique_npcs;
public mapping _hospital_npcs;
public int _last_npc_check, _zone_npcs;
private nosave mapping _npc_groups;
private nosave mapping _npc_info;
void create() {
    seteuid(master()->creator_file(file_name(this_object())));
    do_setup++;
    ::create();
    do_setup--;
    if (_save_file) {
        load_file();
        if (!_hospital_npcs) {
            restore_default_npcs();
        }
        if (!_unique_npcs) {
            _unique_npcs = ([ ]);
        }
        save_file();
    }
    if (!_npc_groups)
        _npc_groups = ([ ]);
    if (!_npc_groups)
        _npc_info = ([ ]);
    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);
    if (!do_setup) {
        set_short("Counterweight Continent Hospital");
        set_long("All around you NPC's wait in neat little lines, "
            "ready to be sent on a massive journey that will ultimately "
            "lead to their deaths.  Some of them stand by a small window "
            "in the far wall, looking out at freedom.\n");
        add_property("determinate", "the ");
        set_light(60);
    }
}
public int get_item(object destination, string *items) {
    int i;
    object item;
    if (!objectp(destination)) {
        return 0;
    }
    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21));
        if (!objectp(item)) {
            items = items[0..i-1] + items[i+1..];
            continue;
        }
        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the CWC hospital.\n", previous_object()->short());
            break;
        }
    }
    if (objectp(item)) {
        item->move(destination);
        return 1;
    }
    return 0;
}
protected void load_file() {
    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
    }
}
protected void save_file() {
    unguarded((: save_object, _save_file :));
}
protected void set_save_file(string new_save) {
    _save_file = new_save;
}
public string query_save_file() {
    return _save_file;
}
public int make_unique(mixed who) {
    if (!_unique_npcs)
        return 0;
    if (objectp(who))
        who = who->query_name();
    if ( _unique_npcs[who] > time() )
        return 0;
    _unique_npcs[who] = time() + REGEN_TIME;
    save_file();
}
public int query_regen_time(mixed who) {
    if (objectp(who))
        who = who->query_name();
    if (!_unique_npcs)
        return 0;
    return _unique_npcs[who];
}
protected void set_max_living(int new_living) {
    _max_living = new_living;
}
public int query_max_living() {
    return _max_living;
}
protected void restore_default_npcs() {
    _hospital_npcs = ([ ]);
}
public int ok_to_clone(string where) {
    if (time() > _last_npc_check + 300) {
        _last_npc_check = time();
        _zone_npcs = sizeof(filter(named_livings(), (: environment($1) &&
            base_name(environment($1))[0..(sizeof(CWC) + sizeof($(where)) - 1)] ==
                (CWC + $(where)) :)));
    }
    return _zone_npcs < _max_living;
}
public int *query_npcs() {
    return ({ _zone_npcs, _last_npc_check });
}
public void add_npc_type(string type, string *data) {
    if (undefinedp(_hospital_npcs[type])) {
        _hospital_npcs[type] = copy(data);
    }
    else {
        if (arrayp(_hospital_npcs[type])) {
            _hospital_npcs[type] += data;
        }
    }
    save_file();
}
public mapping query_hospital_npcs() {
    return copy(_hospital_npcs);
}
public object *get_monster(string type) {
    object *monsters, monster;
    if (_hospital_npcs[type]) {
        tell_creator("taffyd", "Attempting to create a %s NPC.\n", type);
        monsters = make_monster(_hospital_npcs[type][random(sizeof(_hospital_npcs[type]))]);
        tell_creator("taffyd", "Monsters are now %O.\n", monsters);
    }
    else {
        monsters = make_monster(type);
    }
    foreach (monster in monsters) {
        monster->add_property("monster_type", type);
        monster->add_effect("/std/effects/npc/i_died",
            (: regen_after_death :) );
    }
    return monsters;
}
protected object *make_monster(string type) {
    object monster;
    monster = clone_object("/obj/monster");
    monster->set_name("failure");
    monster->set_short("hospital accident");
    monster->set_race("human");
    monster->set_guild("warrior");
    monster->set_level(1);
    return ({ monster });
}
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;
    if ( !dead_npc )
        return;
    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"),
        load_position : previous_object()->query_property("start location") ) });
    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;
    new_npc = _regenerated_npcs[0];
    if ( !classp( new_npc ) )
        return;
    _regenerated_npcs = _regenerated_npcs[1..];
    if (!new_npc->load_position || !new_npc->type );
        return;
    max = random(5);
    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );
        if ( !objectp( destination ) )
            return;
        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);
        call_out((: $1->announce_entry($2) :), 8 + random(6), destination,
            monsters);
    }
}
protected void set_hospital_type(string new_type) {
    _hospital_type = new_type;
}
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;
    filename = _hospital_log_directory;
    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }
    log_file( _hospital_log_directory + "/" + file, format, args ...);
}
protected void set_log_directory(string new_dir) {
    if (file_size(new_dir) != -2) {
        tell_creator( previous_object( 1 ), "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );
        new_dir = DEFAULT_LOG_DIRECTORY;
    }
    _hospital_log_directory = new_dir;
}
protected void set_npc_groups(mapping x) {
    _npc_groups = x;
}
protected void set_npc_info(mapping x) {
    _npc_info = x;
}
public object data_get_npc(string npc_name) {
    class npc_info info;
    object npc;
    function func;
    if ( undefinedp(_npc_info[npc_name]) )
        return 0;
    info = _npc_info[npc_name];
    if (stringp(info->base))
        npc = clone_object(info->base);
    else
        return 0;
    if (arrayp(info->functions)) {
        foreach (func in info->functions) {
            evaluate(func, npc, previous_object());
        }
    }
    return npc;
}
object *data_get_group(string group_name) {
    class npc_group group;
    function func;
    int population, quantity, i;
    object *npcs, npc;
    if ( undefinedp(_npc_groups[group_name]) )
        return 0;
    group = _npc_groups[group_name];
    if (functionp(group->population))
        population = evaluate(group->population);
    else {
        population = DEFAULT_POPULATION;
    }
    if (!group->storage) {
        group->storage = ({ });
    }
    else {
        group->storage = filter(group->storage, (: objectp($1) :));
        if (sizeof(group->storage) >= population)
            return 0;
    }
    if (functionp(group->quantity)) {
        quantity = evaluate(group->quantity);
    }
    else {
        quantity = 1;
    }
    if (stringp(group->npc)) {
        npcs = allocate(quantity);
        for (i = 0; i < quantity; i++) {
            npcs[i] = data_get_npc(group->npc);
        }
        npcs = filter(npcs, (: objectp($1) :));
        group->storage += npcs;
    }
    foreach (npc in npcs) {
        if (arrayp(group->functions)) {
            foreach (func in group->functions) {
                evaluate(func, npc, previous_object());
            }
        }
    }
    return npcs;
}
mixed accumulate_npc_array( mixed a ) {
    int cum, i;
    mixed choices;
    choices = copy(a);
    cum = 0;
    for (i = 0; i < sizeof(choices); i++) {
        cum += choices[i][0];
        choices[i][0] = cum;
    }
    return choices;
}
varargs mixed get_random_npcs(mixed *choices) {
    int i;
    int chance;
    if (!choices)
        choices = previous_object()->query_npcs();
    if (!arrayp(choices) || !sizeof(choices))
        return 0;
    chance = random(choices[<1][0]);
    for (i = 0; i < sizeof( choices ); i++) {
        if ( choices[ i ][ 0 ] > chance ) {
            return data_get_group( choices[ i ][ 1 ]);
        }
    }
    return 0;
}

==================================================
FILE: dist/pumpkin/inherit/hospital.h
==================================================

class npc_info {
    string base;
    function *functions;
}
class npc_group {
    mixed npc;
    function quantity;
    function population;
    function *functions;
    object *storage;
}

==================================================
FILE: dist/pumpkin/inherit/path.h
==================================================

#include "../path.h"

==================================================
FILE: dist/pumpkin/gumboot/armour_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Smashers Armour Store");
   set_long(
"The room is filled with the smell of leather and oil, you can see racks "
"some suits of armour in various stages of being made around the store.\n");
   set_light(70);
   add_exit("west", PATH + "gumboot3", "door");
   add_object("brigandine armour", 1 + random(4));
   add_object("hardened leather breastplate", 1 + random(4));
   add_object("jazerant armour", 1 + random(2));
   add_object("leather boxer shorts", 1 + random(2));
   add_object("leather hat", 1 + random(2));
   add_object("leather jerkin", 1 + random(2));
   add_object("padded aketon", 1 + random(2));
   add_object("studded leather jerkin", 1 + random(2));
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/gumboot/clothes_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Squiggles Clothing Store");
   set_long(
"You are standing in a veritable forest of clothes, they hang off racks "
"and almost completely hide the floor.  Unfortunately they seem to be "
"reall limited in the type clothes they sell, obviously they belive in "
"volume rather than breadth of stock.\n");
   set_light(70);
   add_exit("east", PATH + "gumboot2", "door");
   add_object("green bathrobe", 1 + random(10));
   add_object("green cloak", 1 + random(10));
   add_object("green pants", 1 + random(10));
   add_object("green peaked hat", 1 + random(10));
   add_object("green silk sash", 1 + random(10));
   add_object("green wool shirt", 1 + random(10));
   add_object("white apron", 1 + random(10));
   add_object("white burnous", 1 + random(10));
   add_object("white cotton bodice", 1 + random(10));
   add_object("white cotton robe", 1 + random(10));
   add_object("white cotton shirt", 1 + random(10));
   add_object("white cotton toga", 1 + random(10));
   add_object("white cotton tunic", 1 + random(10));
   add_object("white linen tunic", 1 + random(10));
   add_object("white linen skirt", 1 + random(10));
   add_object("white short-sleeved shirt", 1 + random(10));
   add_object("white silk lace bodice", 1 + random(10));
   add_object("white silk pinafore", 1 + random(10));
   add_object("white silk sash", 1 + random(10));
   add_object("white socks", 1 + random(10));
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is north end of Gumboot Road at the junction with Squash Square.\n");
  set_light( 80 );
  add_exit("north", SQUASH + "squash8", "road");
  add_exit("south", GUMBOOT + "gumboot2", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot1", "road");
  add_exit("south", GUMBOOT + "gumboot3", "road");
  add_exit("west", PATH + "clothes_shop", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot2", "road");
  add_exit("south", GUMBOOT + "gumboot4", "road");
  add_exit("east", PATH + "armour_shop", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot3", "road");
  add_exit("south", GUMBOOT + "gumboot5", "road");
  add_exit("west", PATH + "weapon_shop", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is end of Gumboot Road at the edge of the city of Pumpkin.\n");
  set_light( 80 );
  add_exit("east", TERRAIN_HANDLER + ":0:1:0", "road");
  add_exit("north", GUMBOOT + "gumboot4", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/gumboot/weapon_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Pointy's Weapon Shop");
   set_long(
"Racks of weapons line the room, don't touch, they look sharp.\n");
   set_light(70);
   add_exit("east", PATH + "gumboot4", "door");
   add_object("morning star", 1 + random(20));
   add_object("black handled ceremonial bronze knife", 1 + random(20));
   add_object("carving knife", 1 + random(20));
   add_object("chisel", 1 + random(20));
   add_object("copper fighting knife", 1 + random(20));
   add_object("dagger", 1 + random(20));
   add_object("howondalandish throwing knife", 1 + random(20));
   add_object("klatchian steel dirk", 1 + random(20));
   add_object("knife", 1 + random(20));
   add_object("letter opener", 1 + random(20));
   add_object("meat cleaver", 1 + random(20));
   add_object("sharp butter knife", 1 + random(20));
   add_object("silver sickle", 1 + random(20));
   add_object("small copper knife", 1 + random(20));
   add_object("small knife", 1 + random(20));
   add_object("stiletto", 1 + random(20));
   add_object("tanto", 1 + random(20));
   add_object("white handled ceremonial bronze knife", 1 + random(20));
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/plain/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/plain/plain1.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is Plains at the junction with Rabbit Lane.
\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain2", "road");
  add_exit("west", RABBIT + "rabbit4", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain10.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Forest");
  set_long("This is the end of Forest\n");
  set_light( 80 );
  add_exit("west", PLAIN + "plain9", "road");
  add_exit("north", PLAIN + "plain5", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain2.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain3", "road");
  add_exit("west", PLAIN + "plain1", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain3.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain4", "road");
  add_exit("west", PLAIN + "plain2", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain4.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain5", "road");
  add_exit("west", PLAIN + "plain3", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain5.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is Plains at the junction with Woods.
\n");
  set_light( 80 );
  add_exit("west", PLAIN + "plain4", "road");
  add_exit("south", WOODS + "woods1", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert1.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is Desert at the junction with Gumboot Road.
\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert2", "road");
  add_exit("west", GUMBOOT + "gumboot5", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert10.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is Desert at the junction with Woods.
\n");
  set_light( 80 );
  add_exit("west", DESERT + "desert9", "road");
  add_exit("north", WOODS + "woods5", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert2.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert3", "road");
  add_exit("west", DESERT + "desert1", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert3.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert4", "road");
  add_exit("west", DESERT + "desert2", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert4.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert5", "road");
  add_exit("west", DESERT + "desert3", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert5.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert6", "road");
  add_exit("west", DESERT + "desert4", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert6.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert7", "road");
  add_exit("west", DESERT + "desert5", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert7.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert8", "road");
  add_exit("west", DESERT + "desert6", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert8.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert9", "road");
  add_exit("west", DESERT + "desert7", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert9.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert10", "road");
  add_exit("west", DESERT + "desert8", "road");
}

==================================================
FILE: dist/pumpkin/desert/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/rabbit/bookshop.c
==================================================

#include "path.h"
inherit "/std/shops/book_shop";
void setup() {
   set_short("Bugs Bookstore");
   set_long(
"The distinctly carroty atmosphere of the store makes you feel like "
"saying 'Whats up doc?'\n");
   add_exit("south", RABBIT + "rabbit2", "door");
   set_light(70);
   set_cut(10);
   set_when_sold_function( (: $1->set_open_page(0) :) );
   set_allowed_to_sell( (: $1->query_book() || $1->query_paper() :) );
   set_minimum_cost(400);
   set_save_dir(SAVE + "bookshop");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/rabbit/potion_shop.c
==================================================

#include "path.h"
inherit "/std/shops/potion_shop";
void setup() {
   set_short("Carrot's Potion Store");
   set_long(
"This is a bright orange room with a green ceiling.\n");
   set_light(70);
   add_exit("south", RABBIT + "rabbit4", "door");
   set_save_dir(SAVE + "potions");
   set_cut(10);
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop.c
==================================================

#include "path.h"
inherit "/std/shops/print_shop";
void setup() {
   set_short("Flopsies Print Shop");
   set_long(
"This place appears to have been made into a shrine for a rabbit, you "
"can see a small altar and carrot covered cloth on the counter.\n");
   add_item("counter", ({ "long", "The counter runs across the "
            "front of the room and there is a small altar set up "
            "on the edge of it.",
            "position", "the counter" }) );
   add_item("altar", ({ "long", "A nice altar with a little sign "
            "under it.",
            "read", "In memory of 'Mopsy'.\n" }) );
   set_light(70);
   add_exit("north", RABBIT + "rabbit3", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_binding.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/std/shops/print_shop";
int is_room_open();
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's binding room");
   add_property("determinate", "the ");
   set_long(
"Several tables are laid out in this room, people sit at the tables "
"placing the pages which come in from the printing press into the "
"final bound editions of the books.  This looks like the place where "
"the completed books are stored until taken away by their owners, judging "
"by the huge piles of books scattered around on the floor.\n");
   add_item("table",
({ "long", "Several tables house the equipment used to bind the books into "
"completed volumes are scattered around the room.  All the space not used by "
"the tables is covered in piles of completed, bound books.",
"position", "a binding table",
"position multiple", 1 }) );
   add_item(({ "edition", "volume", }),
"The uncompleted, or soon to be completed volumes of work are sitting "
"on the tables, when they get put on the ground they suddenly turn "
"into books.");
   add_item("people",
"They are binding the books, placing each page into (hopefully) the "
"correct place and creating a final, probably exact output.");
   add_item("book",
({ "long", "There are books all over the floor, in piles and stacks.  Some "
"of the stacks look a little precarious.",
"position", "a pile of books",
"position multiple", 1 }) );
   add_item("page",
"The pages are stacked up on the tables, somewhat neatly, beside the "
"workers as they place them into the bound copies.");
   add_exit("south", PATH + "print_shop_press", "corridor");
   set_office_room(PATH + "print_shop_office");
   set_open_func((: is_room_open :));
   set_print_shop_name("Goatbergers printing shop, Pumpkin");
   add_property("place", "Pumpkin");
}
int is_room_open() {
   return 1;
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_foyer.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's foyer");
   add_property("determinate", "the ");
   set_long(
"A busy room full of people running around carrying trays full of moving "
"type and ink.  There is a coffee table in the middle of the chaos with "
"a chair sitting beside it.  To the west there is a door with a "
"brass plaque attached to it.\n");
   add_item("coffee table",
({ "long", "The coffee table is old and very coffee and tea stained, you are "
"not sure just how undisturbed you would be sitting at the table, the whole "
"place looks a little busy.",
"position", "the coffee table" }) );
   add_item("rickety chair",
({ "long", "The rickety chair sits beside the coffee table, it looks "
"pretty precarious about its role in life.  Sitting on it might be a "
"dangerous occupation.",
"position", "the rickety chair" }) );
   add_item("moving type",
"Lots of little letters placed in rows on boards, or heaped in buckets.  "
"They don't actually appear to move, but is hard to tell because no one "
"with them ever stops long enough for you to look.");
   add_item("ink",
"Large pots of ink, small pots of ink, ink!  All colours of ink, black, "
"red, green, although mostly black, are being carted around.  You are sure "
"there is a purpose to all the movement even if it is a little unclear.");
   add_item("people",
"They are all in a hurry, they look determined and stressed as if they "
"could never manage to get to whatever their destination is fast enough.  "
"Most of them do not appear to really know where their destination is, "
"they rush in and out of the room carrying the same items, look around "
"wildly and dash out again.");
   add_item("brass plaque",
({ "long", "It is a nice polished brass plaque on a surprisingly nice "
"looking door.\nIt appears to have something written on it.",
"read", "Office.\n" }) );
   add_exit("west", PATH + "print_shop_office", "door");
   add_exit("east", PATH + "print_shop_press", "corridor");
   add_exit("south", PATH + "rabbit3", "door");
   room_chat( ({ 120, 240, ({
       "Someone rushes into the room, looks around wildly and rushes back "
       "out again.",
         "You hear a CLANK, WHAM, HISS from the east",
    }) }) );
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_office.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/std/shops/print_shop";
nosave object goatberger;
int is_office_open(object *obs);
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's office");
   add_property("determinate", "the ");
   set_long(
"A big impressive table dominates the room, contrasting sharply to the "
"bare undecorated walls and single bookcase on the back wall.  "
"The soft squooshy carpet covers the floor "
"in a soft cuddly way, licking up against the walls of the room.  "
"The room gives the impression of opulence by its starkness.\n");
   add_item("impressive table",
({ "long", "The table is almost bare except for a blotting pad and a nice "
"set of gold plated quills.  It is a deep shiny maroon colour "
"and the finish glistens softly in the light.  Nestled in behind the "
"table is a wonderful looking chair.",
"position", "the impressive table" }));
   add_item("chair",
({ "long", "The chair is one of those amazing office executive chairs.  "
"It has bits that wobble, bits that zip around and generally looks "
"pretty exciting.",
"position", "the chair" }) );
   add_item("gold plated quill",
"The gold plated quills rest on a quill holder on the table, slightly "
"askew from the blotting paper.  They look hardly used.");
   add_item("bare undecorated wall",
"The walls are bare and undecorated, but nicely finished with a "
"coat of some sort of timber varnish.\n");
   add_item( ({ "blotting paper", "blotting pad" }),
"The blotting paper is bright white, it looks like it has never seen "
"anything remotely resembling ink.  Scribbled just on the corner of "
"the wonderful white paper is a small note saying, 'Please note we can "
"\"print\" books and allow you to \"claim\" copyright here.'");
   add_item("quill holder",
"Resting on the hand engraved silver quill holder are two gold plated "
"quills.");
   add_item("soft squooshy carpet",
"The light brown carpet decorates the room perfectly, running from "
"wall to wall, gently fading into the floor and not being too obtrusive.");
   add_item("bookcase",
"It is sparsely populated with a couple of new looking leather bound "
"books.  They are titled 'Two nights in a closet', 'The Joye of Snacks' "
"and 'A few bedtime poems'.\n");
   add_item(({ "two nights in a closet", "book" }),
({ "long", "The red leather cover looks posh and gorgeous in your "
"hands.  You can see the title 'Two nights in a closet' etched "
"into the cover.\n"
"It appears to have something written on it.",
"read",
"This is a long winding book about a monster having to temporarily "
"relocate from a nice cellar in which it used to live.  The cellar "
"is undergoing refurbishment and is unavailable for monster "
"habitation, so it moved to a closet in a childs bedroom.  The "
"mother of the child refuses to believe that there is a monster "
"in the closet despite the loud protestations of the child.  The "
"monster peers out at the child every night, when it leaves it "
"eats the childs favorite toy and the mother eventually agrees "
"to look in the closet.  But it is empty.\n" }));
   add_item(({ "the joye of snacks", "book" }),
({ "long", "Wonderful bright red alluring cover with an interesting "
"picture of two people, naked, embracing in a shower with a "
"coffee table lurking in the foreground.  The caption 'Joye of "
"snacks' can be seen on the binder.\n"
"It appears to have something written on it.",
"read", "The first page has 'Demo copy only' written on it in "
"big black letters.  Sounds like a really interesting book though.\n" }) );
   add_item(({ "a few bedtime poems", "book" }),
({ "long", "The mate black cover of this book hardly even gleams at "
"all, the straight time Roman lettering saying 'A few bedtime poems "
"by a small colourful fish'.\n"
"It appears to have something written on it.",
"read",
"Strawberries\n"
"------------\n"
"\n"
"Starting from a above,\n"
"Working slowly down under.\n"
"Sliding up the sides\n"
"Eating a meal, fresh cream and syrup.\n"
"\n"
"Round and round, and round again\n"
"Grinning mischeviously\n"
"One tongue at play\n"
"Firm and hard, fresh strawberries today.\n"
"\n"
"\n"
"Flirting\n"
"--------\n"
"\n"
"A sidelong glance,\n"
"A funny remark!\n"
"Glittering eyes\n"
"Meeting in the dark.\n"
"\n"
"Fear of whats to come\n"
"Glad of what is here.\n"
"Hoping, wishing, believing\n"
"We will be as one.\n"
"\n"
"\n"
"Bewitched by the highlands\n"
"--------------------------\n"
 "\n"
"Scotland reminds me\n"
"Of heather and song\n"
"Of bagpipes and dancing\n"
"Never a witch\n"
 "\n"
"Then she bewitched me\n"
"Her eyes were brown\n"
"Her hair was like satin\n"
"Skin of pure honey\n"
 "\n"
"We talked for hours\n"
"Talking of the times\n"
"Strawberries and cream\n"
"Staring at her eyes\n"
 "\n"
"We laughed and sighed\n"
"Talked far and wide\n"
"Feeling a glow inside\n"
"Hands touching in my mind\n"
 "\n"
"Many more times we met\n"
"Laughed and had fun\n"
"Flirting with abandon\n"
"More happy than ever before\n"
 "\n"
"Now Scotland and witches\n"
"Are inextricably linked\n"
"With joy and happiness\n"
"In my dreams at night\n"
 }) );
   set_no_collection(1);
   set_open_func((: is_office_open($1) :));
   set_default_language("common");
   add_translation_cost("djelian", 130);
   set_save_dir("/d/am/save/printing/");
   add_exit("east", PATH + "print_shop_foyer", "door");
   add_property("place", "Pumpkin");
}
void reset() {
   if (!goatberger) {
      goatberger = clone_object("/obj/monster");
      goatberger->set_name("goatberger");
      goatberger->set_short("Mr. Goatberger");
      goatberger->set_long(
"He is smartly dressed in an expensive looking imported suit, a slight smile "
"just playing on his lips.  A gold fob watch peeks out of the lapels "
"of his suit.\n");
      goatberger->set_race("human");
      goatberger->set_level(10);
      goatberger->set_gender("male");
      goatberger->add_property("determinate", "");
      ARMOURY->request_item("white linen tunic", 90)->move(goatberger);
      ARMOURY->request_item("green pants", 90)->move(goatberger);
      goatberger->set_default_position( (: goatberger->do_command("sit on chair") :) );
      goatberger->do_command("equip");
      goatberger->move(this_object(), "$N arrives from the west.\n");
      goatberger->return_to_default_position(0);
   }
}
int is_office_open(object *obs) {
   if (!goatberger) {
      add_failed_mess("There is no one here to serve you.\n", obs);
      return 0;
   }
   return 1;
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_press.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's machinery room");
   add_property("determinate", "the ");
   set_long(
"Big huge black machines, belching steam and exciting noises, completely cover "
"the floor of the room.  People scurry back and forth, carrying single "
"pages, bound books and trays of moving type.  The floor is covered in "
"spilled ink, both new and old, and little bits of metal, forgotten "
"bits of moving type and the odd rat.\n");
   add_item(({ "big huge black machine", "press", "machines" }),
"The machines are big presses that squish the moving type down onto "
"bits of paper which are then shuffled off to the binding department.  Steam "
"and unnecessary noise appear to be vital components of the printing "
"process.");
   add_item(({ "metal bit", "metal" }),
"There are a number of small bits of metal scattered over the floor, they "
"appear to be broken bits of moving type and things shaved off the "
"industriously working machines.");
   add_item("floor",
"The floor is covered in spilled ink, both new and old, and little bits of "
"metal,  forgotten bits of moving type and the odd rat.");
   add_item("people",
"There are people scurrying around in a hurry, moving pages from the "
"press into the binding room and swapping the moving type.  In a corner "
"there are a group of people arranging the type onto the trays from an "
"original book.");
   add_item("bound book",
"You have no idea why people would be walking around with bound books here, "
"especially since they seem to be reading the books and then blushing bright "
"red.  The title of the books appears to be 'The Joye of Snacks'.");
   add_item("spilled ink",
"The ink is all over the floor in a thick layer, caking everything in a "
"fine dust.");
   add_item("rat",
"The rat looks kind of, well very, covered in ink.  It sniffs around the "
"place industriously, perhaps it is a spy rat?");
   add_item("single page",
"The pages are single pages from books, they are not particularly ordered "
"from what you can tell.  You wonder how the books make it out alive.");
   add_item(({ "tray", "tray of moving type" }),
"Trays of moveable type to be inserted into the machines, they then print "
"the pages which get placed into the final book.");
   add_exit("west", PATH + "print_shop_foyer", "corridor");
   add_exit("north", PATH + "print_shop_binding", "corridor");
   room_chat( ({ 120, 240, ({
      "Someone reading a book blushes bright red and drops a tray of "
      "moving type.",
      "WHUMP!",
      "HISS!",
      "A machine clanks alarmingly.",
      "Someone wanders off with a bunch of pages to be bound to the binding "
      "room."
    }) }) );
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is Rabbit Lane at the junction with Squash Square.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit2", "road");
  add_exit("west", SQUASH + "squash6", "road");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is the middle of Rabbit Lane where a bunch of "
           "books and things seem to be.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit3", "road");
  add_exit("west", RABBIT + "rabbit1", "road");
  add_exit("north", RABBIT + "bookshop", "door");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is the middle of Rabbit Lane\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit4", "road");
  add_exit("west", RABBIT + "rabbit2", "road");
  add_exit("north", RABBIT + "print_shop_foyer", "door");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is end of Rabbit Lane at the exit of the city of Pumpkin.\n");
  set_light( 80 );
  add_exit("east", TERRAIN_HANDLER + ":0:18:0", "road");
  add_exit("west", RABBIT + "rabbit3", "road");
  add_exit("north", RABBIT + "potion_shop", "door");
}

==================================================
FILE: dist/pumpkin/woods/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/woods/woods1.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is Woods at the junction with Plains.
\n");
  set_light( 80 );
  add_exit("north", PLAIN + "plain5", "road");
  add_exit("south", WOODS + "woods2", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods2.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods1", "road");
  add_exit("south", WOODS + "woods3", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods3.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods2", "road");
  add_exit("south", WOODS + "woods4", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods4.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods3", "road");
  add_exit("south", WOODS + "woods5", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods5.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is Woods at the junction with Desert.
\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods4", "road");
  add_exit("south", DESERT + "desert10", "road");
}

==================================================
FILE: dist/pumpkin/hospital/hospital.c
==================================================

#include "path.h"
inherit CITY "inherit/hospital";
void create() {
   set_hospital_type("Pumpkin");
   set_save_file("/d/dist/dist/pumpkin_hospital");
   set_max_living(100);
   set_log_directory("/d/dist/log");
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup) {
      set_short("Pumpkin Hospital");
      set_light(60);
   }
   set_npc_groups(DATA->compile_data( ({ HOSPITAL_DIR "bes_pelargic_group" }) ));
   set_npc_info(DATA->compile_data( ({ HOSPITAL_DIR "bes_pelargic_info" }) ));
}

==================================================
FILE: dist/pumpkin/squash/beer_bar.c
==================================================

#include "path.h"
#include <armoury.h>
#include <shops/pub_shop.h>
inherit "/std/shops/pub_shop";
object *drunkards;
object bartender, barmaid;
int do_sit(string str);
int ref_to_serve(object player, int type);
void setup() {
   set_short("beer room");
   set_room_size(5);
   add_property( "place", "Pumpkin");
   set_light(60);
   set_theft_handler( HOSPITAL );
   set_zone("Flaming Cabbage");
   set_open_function( (: ref_to_serve :) );
   set_long("This is a beer bar.  Hence, all the bottles, signs and glasses "
      "are related to beer.  Maybe it could be possible to get something "
      "else, but most likely, beer (and of course the sort of healthy, "
      "nutritious food that goes along with beer) is all they sell here.  "
      "The customers, sitting on chairs around the tables, are all drinking "
      "beer and chatting merrily.  At one of the more secluded tables, "
      "some seedy-looking characters are whispering less merrily.  Of course, "
      "they too are enjoying a tasty beer.  A menu is tacked to the "
      "wall behind the counter.\n");
   add_item("floor", "The floor is sticky, and it seems like it'd be hard "
      "to walk out of here.  That could explain why some of the clientele "
      "here seem to have been drinking for days.");
   add_item("sign","There are a number of signs in this bar.  Most of "
      "them are tacky, sticky old cardboard signs pointing out the "
      "special benefits of drinking beer X or ale Y.");
   add_item("bottle","There are a vast amount of bottles on the wall "
      "behind the counter.  They all seem to be the same sort, and quite "
      "a few of them seem to be empty.  At least they catch the seedy "
      "light in a very pretty way.");
   add_item("glass","Beer glasses (the empty kind which are not overly dirty "
      "on the inside) are flooding the bar behind the counter.  Considering "
      "how empty, used glasses seem to disappear altogether, it is probably "
      "necessary to have quite a few glasses around.");
   add_item(({"customer","clientele"}), "The people in here seem to be "
      "mainly concerned with the intake of beer.  They all look rather red "
      "around their noses and, for some reason, they all look rather "
      "happy.  All except those who wouldn't be caught dead doing something "
      "as silly as looking happy, of course.");
   add_item(({"seedy-looking character","character","corner"}), "In a "
      "corner of the bar, some people (who seem to melt in extraordinarily "
      "well into the dark shadows) are quietly drinking some beer, keeping "
      "a watchful eye on everything that happens");
   add_item(({"bar","counter"}), "The counter runs along one wall of the "
      "room.  All empty glasses put on it seem to disappear to some other "
      "dimension.  Only Dogbolter, the God of Empty Beer Pints, knows "
      "where that is.");
   add_item("wall", "The walls are sticky with dried in beer.  Somehow it "
      "has ended up on the walls, but there is nothing here to explain how.  "
      "On one of the walls there's a sign - it appears to be stuck there "
      "without the aid of a pin or anything...");
   add_item("ceiling", "The ceiling is sticky.  They must have had quite a "
      "party here recently.  Or maybe they had a party a long time ago and "
      "just haven't washed the ceiling since?");
   add_item( "wooden table", ({"long", "This is a rather nice wooden "
      "table.  At least it could be, somewhere underneath all that "
      "sticky beer.",
      "position","the wooden table"}));
   add_item( "small table", ({"long", "This table is made of wood, but a "
      "lot smaller than the other tables here.",
      "position","the small table"}));
   add_item( "sticky table", ({"long", "This large table is a lot stickier "
      "than anything else in here, and that means it's pretty darn sticky!",
      "position","the sticky table"}));
   add_item( "old chair",
         ({ "long", "The chairs around the wooden table are old and worn.",
            "position","the wooden table"
         }) );
   add_item( "small chair",
         ({ "long", "The chairs around the wooden table are old and worn.",
            "position","a chair at the wooden table"
         }) );
   add_item("sticky beer", "It's just about everywhere.");
   add_menu_item("Spicy sausage", PUB_APPETISER, 396, "spicy sausage");
   add_menu_alias("sausage", "Spicy sausage");
   add_menu_item("Salad", PUB_MAINCOURSE, 796, "salad",
                 PUB_STD_SIDEPLATE);
   add_menu_item("Fish'n'chips", PUB_MAINCOURSE, 1196, "fish'n'chips",
                 PUB_STD_DINNERPLATE);
   add_menu_item("Ribs", PUB_MAINCOURSE, 1304, "ribs",
                 PUB_STD_DINNERPLATE);
   add_menu_item("Hot chicken sandwich", PUB_MAINCOURSE, 796,
      "chicken sandwich");
   add_menu_alias("chicken sandwich", "Hot chicken sandwich");
   add_menu_item("Ham'n'cheese sandwich", PUB_MAINCOURSE, 796, "ham sandwich");
   add_menu_alias("ham sandwich", "Ham'n'cheese sandwich");
   add_menu_item("Unnameable liquid", PUB_ALCOHOL, 1704, "unnameable",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("unnameable", "Unnameable liquid");
   add_menu_item("CMOTD's Finest Brew", PUB_ALCOHOL, 1704, "finest brew",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("brew", "CMOTD's Finest Brew");
   add_menu_alias("cmotd", "CMOTD's Finest Brew");
   add_menu_item("Pumpkine Ale", PUB_ALCOHOL, 1838, "/obj/food/ale.food",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("ale", "Pumpkine Ale");
   add_menu_item("Troll Beer", PUB_ALCOHOL, 1838, "troll beer",
                 PUB_STD_PINT, 0, 3);
   add_menu_alias("beer", "Troll Beer");
   add_menu_item("Schlorg Beer", PUB_ALCOHOL, 1838, "schlorg beer",
                 "schlorg bottle", 0, 2);
   add_menu_alias("schlorg", "Schlorg Beer");
   add_exit("west", PATH + "squash9", "corridor");
}
object create_item( string word ) {
   object thing, thang;
   switch ( word ) {
   case "spicy sausage" :
      thing = clone_object( "/obj/food" );
      thing->set_weight_per_bite(1);
      thing->set_name("sausage");
      thing->set_short("spicy sausage");
      thing->set_long( "The sausage, of a very questionable origin, seems "
         "to be designed to increase the thirst of whomever eats it.\n" );
      thing->set_value( 396 );
      thing->set_weight(5);
      return thing;
   case "unnameable liquid" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_medium_alias("beer");
      thang->set_name("unnameable");
      thang->set_short( "unnameable liquid" );
      thang->set_long( "This sludge is definitely better off without a "
           "name.  If someone was to try to give it a name, it'd have to be "
           "something along the lines of \"Stinking Mud\", \"Utterly "
           "Disgusting and Undrinkable Slush\" or maybe just \"Yuck!\".\n" );
      thang->add_eat_effect( "/std/effects/ingested/drunk", 40 );
      thang->add_eat_effect("/std/effects/ingested/nausea", 100);
      thang->set_amount( 2000 );
      return thang;
   case "finest brew" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_name("brew");
      thang->set_medium_alias("beer");
      thang->set_short( "CMOTD's Finest Brew" );
      thang->add_alias(({"finest brew","CMOTD's finest","CMOTD's brew"}));
      thang->set_long( "CMOT Dibbler has produced an amazing beer from "
           "Pumpkin, weird spices and possibly some more things.  Being "
           "Dibbler, he has of course made sure that the pint is rather "
           "a small one.\n" );
      thang->add_eat_effect( "/std/effects/ingested/drunk", 50 );
      thang->set_amount( 980 );
      return thang;
   case "troll beer" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->add_alias("beer");
      thang->set_name("beer");
      thang->set_short("troll beer");
      thang->add_adjective("pint");
      thang->set_long("This is trollish beer.  You suspect a human "
            "shouldn't really be drinking this stuff.\n" );
      thang->add_alias( "trollbeer" );
      thang->add_adjective("troll");
      thang->add_eat_effect("/std/effects/ingested/drunk", 70);
      thang->set_amount( 2000 );
      return thang;
   case "schlorg" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_name("schlorg");
      thang->set_short("Schlorg");
      thang->set_medium_alias("beer");
      thang->set_long("This beer must be \"forn\".  It has none of the "
           "characteristic muddiness that all beer brewed from Pumpkin water "
           "possesses.\n" );
      thang->add_eat_effect("/std/effects/ingested/drunk", 180);
      thang->set_amount(3900);
      thang->move(thing);
      thing->do_close();
      return thing;
      break;
   case "salad" :
      thing = clone_object( "/obj/food" );
      thing->set_name("salad");
      thing->add_property("food", 1);
      thing->set_short( "green salad" );
      thing->set_long( "This green salad is at least partially green, "
         "with interesting bits and thingies in it.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 10);
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   case "fish'n'chips" :
      thing = clone_object( "/obj/food" );
      thing->add_alias(({"fish","chips"}));
      thing->add_property("food", 1);
      thing->set_name("cod");
      thing->set_short( "fish'n'chips" );
      thing->set_long( "It's hard to tell what is the fish and which of "
         "the small, sloppy pieces that are supposed to be the chips.  "
         "They all taste the same anyway.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 10);
      thing->set_value( 1196 );
      thing->set_amount( 2000 );
      return thing;
   case "ribs" :
      thing = clone_object( "/obj/food" );
      thing->set_name("ribs");
      thing->add_property("food", 1);
      thing->set_short( "ribs" );
      thing->set_main_plural("ribs");
      thing->set_long( "These are ribs.  What animal(s) they come from is "
         "not of any interest, rest assured...  They are quite a lot smaller "
         "than the Real Pork Ribs that you can get in the posh restaurants "
         "in any case.\n" );
      thing->set_value( 1304 );
      thing->set_amount( 2000 );
      return thing;
   case "chicken sandwich" :
      thing = clone_object( "/obj/food" );
      thing->add_alias("sandwich");
      thing->add_property("food", 1);
      thing->set_name("chicken");
      thing->set_short( "hot chicken sandwich" );
      thing->set_long( "The chicken on this sandwich is of the green sort.  "
         "It smells funny, moves funny and even sounds a bit funny.  The "
         "only nice thing to say about this sandwich is that it is indeed "
         "hot.  It should probably be eaten with caution, though.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 40);
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   case "ham sandwich" :
      thing = clone_object( "/obj/food" );
      thing->add_alias("sandwich");
      thing->add_property("food", 1);
      thing->set_name("ham");
      thing->set_short( "ham'n'cheese sandwich" );
      thing->set_long( "This sandwich has some ham and some cheese on it, "
         "which is why it is called a ham and cheese sandwich.  It has been "
         "baked in an oven.  A long time ago.  It is rather cold an clammy "
         "now.\n" );
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   }
}
object create_container(string name) {
   object thing;
   switch (name) {
   case "schlorg" :
      thing = clone_object( "/obj/bottle" );
      thing->make_bottle("green", 1000);
      thing->set_value(1596);
      thing->set_long( (string)thing->query_long() + "This bottle has a "
               "slightly odd-looking porcelain cap, and no label at all, "
               "in the ordinary fashion of Schlorg-bottles discwide.\n");
      return thing;
   }
}
void reset() {
   int i, j, x, y, z;
   string *kinds = ({"jolly","burly","fat","happy","drunk","very drunk",
      "silly"});
   j = 5 + random(2);
   if (sizeof(drunkards) < 3) {
      drunkards = allocate(j);
   }
   for (i=0;i<(sizeof(drunkards));i++) {
      if (!drunkards[i]) {
         x = random(sizeof(kinds));
         y = random(4);
         drunkards[i] = clone_object("/obj/monster");
         drunkards[i]->set_name("drunkard");
         drunkards[i]->add_alias(kinds[x]+"drunkard");
         drunkards[i]->add_alias(kinds[x]+" drunkard");
         drunkards[i]->add_property("emote",1);
         drunkards[i]->add_move_zone("Flaming Cabbage");
         drunkards[i]->set_short(kinds[x]+" drunkard");
         drunkards[i]->set_main_plural(kinds[x]+" drunkards");
         drunkards[i]->add_plural("drunkards");
         drunkards[i]->add_plural(kinds[x]+" drunkards");
         drunkards[i]->set_gender(1+random(1));
         drunkards[i]->set_long("This "+kinds[x]+" drunkard seems very "
            "content with sitting here, chugging down beer after beer.  Who "
            "can blame " + drunkards[i]->query_objective() + ", really?\n");
         drunkards[i]->set_race("human");
         drunkards[i]->set_al(-300 + random(600));
         drunkards[i]->set_guild("fighters");
         drunkards[i]->set_class("fighter");
         drunkards[i]->adjust_con(10);
         drunkards[i]->adjust_str(5);
         drunkards[i]->adjust_dex(-1);
         drunkards[i]->set_level(75 + random(25));
         drunkards[i]->add_skill_level( "other.health", 50 );
         drunkards[i]->add_skill_level("fighting.combat.melee",
                                       20+random(20));
         drunkards[i]->add_skill_level("fighting.combat.special",30);
         drunkards[i]->adjust_money(0 + random(1),"Pumpkin dollar");
         drunkards[i]->adjust_money(10+ random(20),"Pumpkin pence");
         switch(y) {
            case 0:
            ((object)ARMOURY->request_item("dagger",30 +
                    random(30)))->move(drunkards[i]);
            drunkards[i]->init_equip();
            drunkards[i]->do_command("tactics response parry");
            drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                          50+random(100));
            break;
            case 1:
               ((object)ARMOURY->request_item("knife",70 +
                                              random(20)))->move(drunkards[i]);
               ((object)ARMOURY->request_item("green pants",70 +
                                              random(20)))->move(drunkards[i]);
               drunkards[i]->init_equip();
               drunkards[i]->do_command("tactics response parry");
               drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                             50+random(20));
               break;
            default:
               ((object)ARMOURY->request_item("knife",30 +
                                           random(30)))->move(drunkards[i]);
               ((object)ARMOURY->request_item("green pants",70 +
                                              random(20)))->move(drunkards[i]);
               drunkards[i]->init_equip();
               drunkards[i]->add_property("emote", 1);
               drunkards[i]->do_command("tactics response parry");
               drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                             20+random(20));
               drunkards[i]->load_chat(2,({
                  1, "'I need another beer.",
                  1, "'Bring me some beer, will you?",
                  1, "'I jolly well need beer!  Hurry up!"
                    }));
         }
         drunkards[i]->move("/room/void");
         y = random(4);
         z = 40 + random(90);
         call_out("make_drunk", z, drunkards[i], y, kinds[x]);
      }
   }
   if (!bartender) {
      bartender = clone_object( "/obj/monster" );
      bartender->set_name("bartender");
      bartender->set_short("sympathetic bartender");
      bartender->add_property("determinate","a ");
      bartender->set_long("This bartender looks just like you would "
         "expect in a place like this.  He has a huge red beard and seems "
         "to be laughing and smiling in a friendly manner at everyone all "
         "the time.\n");
      bartender->set_race("human");
      bartender->set_gender( 1 );
      bartender->set_al( -350 );
      bartender->set_class("fighter");
      bartender->set_level(100);
      bartender->do_command("tactics attitude offensive");
      bartender->do_command("tactics response parry");
      bartender->adjust_con(6);
      bartender->adjust_str(6);
      bartender->adjust_dex(3);
      bartender->add_skill_level( "other.health",55);
      bartender->add_skill_level("fighting.combat.melee.sharp",100);
      bartender->add_skill_level("fighting.combat.special",50);
      ((object)ARMOURY->request_item("dagger",100))->move(bartender);
      ((object)ARMOURY->request_item("dagger",85))->move(bartender);
      ((object)ARMOURY->request_item("leather undershirt",80))->
         move(bartender);
      ((object)ARMOURY->request_item("leather breeches",80))->move(bartender);
      ((object)ARMOURY->request_item("white apron",80))->move(bartender);
      bartender->add_respond_to_with( ({({"@spank"}),"bartender"}),
         "thank $hname$ profusely");
      bartender->load_chat(25,({
                  1, ":brings some beer out to his thirsty customers.",
                  1, "@wink barmaid",
                  1, "@beam brightly",
                  1, "@hum",
                  1, "@laugh",
                  1, ":laughs pleasantly.",
                  1, "'Well, well - what have we here?",
                  1, "'Bring you another beer, shall I?"
                    }));
      bartender->init_equip();
      barmaid = clone_object( "/obj/monster" );
      barmaid->set_name("barmaid");
      barmaid->set_short("lovely barmaid");
      barmaid->set_long("This barmaid looks happy with her work.  She smiles "
         "a lot and has a noticeable tendency to flutter her eye-lashes at "
         "the bartender.\n");
      barmaid->set_race("human");
      barmaid->set_class("fighter");
      barmaid->set_level(50);
      barmaid->set_gender(2);
      ((object)ARMOURY->request_item("white linen skirt",80))->move(barmaid);
      ((object)ARMOURY->request_item("white apron",80))->move(barmaid);
      barmaid->init_equip();
      call_out("make_bart", 20, bartender, barmaid);
   }
}
void make_drunk(object ob, int y, string str) {
   int a = random(2);
   string adj, adv;
   adv = ({ "not at all", "very", "quite", "extremely", "rather" })
     [ random(5) ];
   ob->move(this_object(), "A "+  str + " drunkard comes in, looking " + adv +
          " thirsty.");
   switch (y) {
   case 0:
      adj = "small";
      break;
   case 1:
   case 2:
      adj = "wooden";
      break;
   case 3:
      adj = "sticky";
      break;
   }
   if (a)
      ob->do_command("sit at "+adj+" table");
   y = 5 + random(50);
   call_out("buy_new", y, ob);
}
void make_bart(object ob, object obette) {
   ob->move(this_object(), "The bartender pops up from behind the counter "
          "with a wide grin on his face.");
   call_out("make_barm", 5, obette);
}
void make_barm(object ob) {
   ob->move(this_object(), "The barmaid appears from behind the counter and "
          "tries to look innocent.  She desperately tries to sort out her "
          "hair which is a bit unordered.");
}
void buy_new(object ob) {
   int tim;
   if (!undefinedp(ob)) {
      if (environment(ob) == this_object()) {
         int z;
         string beer;
         beer = ({ "troll beer", "brew", "brew",
                      "unnameable liquid" })[ random(4) ];
         ob->adjust_money(5, "Pumpkin dollar");
         ob->do_command("buy " + beer );
         ob->do_command("hold glass in left hand");
         z = 120 + random(120);
         tim = 20 + random(20);
         while (tim < z) {
            call_out("sip_beer", tim, ob);
            tim += 30 + random(20);
         }
         call_out("drink_beer", z, ob);
      }
   }
}
void sip_beer(object ob) {
   if (ob &&
       environment(ob) == this_object()) {
      ob->do_command("drink 1/3rd of glass");
   }
}
void drink_beer(object ob) {
   if (!undefinedp(ob)) {
      ob->do_command("drink glass");
      ob->do_command("'Ha!  Nice beer, this.");
      call_out("no_litter",3,ob);
   }
}
void no_litter(object ob) {
   object pint, *obinv;
   int z;
   int a = random(2);
   if (!ob) {
      return ;
   }
   obinv = deep_inventory(ob);
   if (sizeof(obinv)) {
      foreach( pint in obinv ) {
	 if (pint->query_max_volume()) {
            switch (a) {
            case 0:
               ob->do_command("'Ah.  An empty pint.  Now what would I "
                       "want that for?");
               break;
            case 1:
               ob->do_command("'Bugger.  It's all empty.  Now I'm sad.");
               break;
            case 2:
               ob->do_command("'No more beer.  What has the world come to?");
               break;
	    }
            ob->do_command("put " + pint->query_name() + " on counter");
         }
      }
   }
   if (a) {
      z = 120 + random(240);
      call_out("buy_new", z, ob);
   } else {
      ob->do_command("north");
   }
}
int ref_to_serve(object player, int type) {
   int clock, servtime;
   clock = (time()%(3600*24));
   servtime = ((clock > 35000) && (clock < 60000));
   if((!servtime) && (type == PUB_MAINCOURSE)) {
      add_failed_mess("Unfortunately, this pub doesn't serve food at the "
         "moment.  Try to change your order, please.\n");
      return 2;
   }
}
void event_enter(object ob, string str, object from) {
   if (ob->query_name() == "drunkard") {
      if( sizeof( match_objects_for_existence( "pint", ob ))) {
         ob->do_command("'Time for another beer for me.");
         call_out("buy_new",5 + random(50),ob);
      }
   }
}

==================================================
FILE: dist/pumpkin/squash/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/squash/squash1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("northwest corner of Squash Square");
  set_long("This is the north west corner of Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash4", "road");
  add_exit("southeast", SQUASH + "squash5", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash2", PATH + "squash4", PATH + "squash5" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("north edge of Squash Square");
  set_long("This is the north of Squash Square at the "
           "junction with Pumpkin Way.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash3", "road");
  add_exit("west", SQUASH + "squash1", "road");
  add_exit("north", PUMPKIN + "pumpkin6", "road");
  add_exit("south", SQUASH + "squash5", "road");
  add_exit("southwest", SQUASH + "squash4", "hidden");
  add_exit("southeast", SQUASH + "squash6", "hidden");
  set_linker(({ PATH + "squash3", PATH + "squash1", PATH + "squash5",
                PATH + "squash4", PATH + "squash6" }),
             "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("north east corner of Squash Square");
  set_long("This is the north east corner of Squash Square\n");
  set_light( 80 );
  add_exit("west", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash6", "road");
  add_exit("southwest", SQUASH + "squash5", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash2", PATH + "squash6", PATH + "squash5" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("west edge of Squash Square");
  set_long("This is the west side of Squash Square at the junction "
           "with Fruitbat Avenue.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash5", "road");
  add_exit("west", FRUITBAT + "fruitbat4", "road");
  add_exit("north", SQUASH + "squash1", "road");
  add_exit("south", SQUASH + "squash7", "road");
  add_exit("northeast", SQUASH + "squash2", "hidden");
  add_exit("southeast", SQUASH + "squash8", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash5", PATH + "squash1", PATH + "squash7",
                 PATH + "squash2", PATH + "squash8" }),
              "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("in the middle of Squash Square");
  set_long("This is the middle of Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash6", "road");
  add_exit("west", SQUASH + "squash4", "road");
  add_exit("north", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash8", "road");
  add_exit("northeast", SQUASH + "squash3", "hidden");
  add_exit("northwest", SQUASH + "squash1", "hidden");
  add_exit("southeast", SQUASH + "squash9", "hidden");
  add_exit("northwest", SQUASH + "squash7", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash6", PATH + "squash4", PATH + "squash2",
                PATH + "squash8", PATH + "squash3", PATH + "squash1",
                PATH + "squash9", PATH + "squash7" }),
             "to a point", "", "Squash Square");
  set_monster(1, "city");
  set_zone("pumpkin");
  set_co_ord(({ 0, 0, 0 }));
}

==================================================
FILE: dist/pumpkin/squash/squash6.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("east edge of Squash Square");
  set_long("This is east side of Squash Square at the junction "
           "with Rabbit Lane.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit1", "road");
  add_exit("west", SQUASH + "squash5", "road");
  add_exit("north", SQUASH + "squash3", "road");
  add_exit("south", SQUASH + "squash9", "road");
  add_exit("northwest", SQUASH + "squash2", "hidden");
  add_exit("southwest", SQUASH + "squash8", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash5", PATH + "squash3", PATH + "squash9",
                PATH + "squash2", PATH + "squahs8" }),
             "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash7.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("south west corner of Squash Square");
  set_long("This is the south west corner Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash8", "road");
  add_exit("north", SQUASH + "squash4", "road");
  add_exit("northeast", SQUASH + "squash3", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash8", PATH + "squash4", PATH + "squash3" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash8.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("south edge of Squash Square");
  set_long("This is south side of Squash Square at the "
           "junction with Gumboot Road.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash9", "road");
  add_exit("west", SQUASH + "squash7", "road");
  add_exit("north", SQUASH + "squash5", "road");
  add_exit("south", GUMBOOT + "gumboot1", "road");
  add_exit("northwest", SQUASH + "squash4", "hidden");
  add_exit("northeast", SQUASH + "squash6", "hidden");
  add_property( "los", "open" );
  set_linker( ({ PATH + "squash9", PATH + "squash7", PATH + "squash5",
                 PATH + "squash4", PATH + "squash6" }),
             "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash9.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("south east corner of Squash Square");
  set_long("This is the south east corner Squash Square.\n");
  set_light( 80 );
  add_exit("west", SQUASH + "squash8", "road");
  add_exit("north", SQUASH + "squash6", "road");
  add_exit("northwest", SQUASH + "squash5", "hidden");
  add_exit("east", PATH + "beer_bar", "door");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash8", PATH + "squash6", PATH + "squash5" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/terrain/desert.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("A bunch of sand.");
  set_light( 80 );
}

==================================================
FILE: dist/pumpkin/terrain/desertpath.c
==================================================

inherit "/std/outsides/road";
void setup() {
   set_short("Road through desert");
   set_long("A road through the desert.");
   set_light(80);
}

==================================================
FILE: dist/pumpkin/terrain/path.h
==================================================

#include "../path.h"

==================================================
FILE: dist/pumpkin/terrain/plainpath.c
==================================================

inherit "/std/outsides/road";
void setup() {
   set_short("Road through plain");
   set_long("A road through the plain.");
   set_light(80);
}

==================================================
FILE: dist/pumpkin/terrain/plains.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("A bunch of plains.");
  set_light( 80 );
}

==================================================
FILE: dist/pumpkin/terrain/terrain_handler.c
==================================================

#include <terrain_map.h>
#include "path.h"
inherit TERRAIN_MAP_HANDLER_BASE;
string query_map_file() {
    return __DIR__ + "terrain";
}
void setup_handler() {
    set_newline_mode(0);
   set_visible_distance(5);
   add_obstacle_type("H", "a lush, thick hedge surrounds the small garden",
     "hedge", "The hedge surrounds the garden, stretching thick and "
     "impenetrable towards the sky, protecting anyone in the garden from the "
     "gawking eyes of passers-by.");
   add_obstacle_type("*", "s big high lump that you cannot avoid looking at",
     "lump", "The lump is very lumpy.");
   add_feature("lump",
               16, 3,
               1, 1,
               15,
               ({
                  "a lump towers above you to the $D",
                }),
               "lump", "A lumpy thing that lumps around.",
               ({
                  "a lump at night to the $D",
                }),
               "It looks just like a lump, even though it is dark.");
   add_road_type("=", __DIR__ "plainpath",
     "", "a nice sandy path leads through the plains.");
   add_road_type("+", __DIR__ "woodpath",
     "", "a nice sandy path leads through the woods.");
   add_road_special_type("-", __DIR__ "desertpath",
     3,
     1,
     0,
     "", "a nice sandy path leads through the woods.");
   add_room_type("L", __DIR__ "plains");
   add_room_type("W", __DIR__ "woods");
   add_room_type("d", __DIR__ "desert");
   add_exit_at(0, 1, "west", GUMBOOT + "gumboot5", "road");
   add_exit_at(0, 18, "west", RABBIT + "rabbit4", "road");
}

==================================================
FILE: dist/pumpkin/terrain/woods.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woodlands");
  set_long("A bunch of trees.");
  set_light( 80 );
}

==================================================
FILE: dist/pumpkin/terrain/woodspath.c
==================================================

inherit "/std/outsides/road";
void setup() {
   set_short("Road through woods");
   set_long("A road through the woods.");
   set_light(80);
}

==================================================
FILE: dist/pumpkin/pumpkin/hospital.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include <living.h>
#include <map.h>
#include <money.h>
#include <move_failures.h>
#include <route.h>
#include <wander.h>
#include "path.h"
#define MAX_HEAVIES 10
#define DAY 8 * 60 * 60
#define INTERVAL 20 * 60
#define MUD_TO_REAL 3
#define BLOCK 5
#define MAX_EMPTIES 12
#define MAX_MOVERS 60
#define SAVE_FILE SAVE +"hospital"
inherit "/std/room/basic_room";
nosave int alchemists, update, *alignments;
mapping uniques;
nosave int *al_data;
nosave string *city;
nosave object *empties;
nosave mapping blockages;
nosave mixed *movers;
nosave int am_npcs, last_check;
int ok_to_clone();
void get_weapon(object ob, string *items);
void get_armour(object ob, string *items);
void get_jewellery(object ob, string *items);
void setup() {
   set_keep_room_loaded(1);
   update = time();
   alignments = allocate( 50 );
   uniques = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
   alchemists++;
   unguarded( (: save_object, SAVE_FILE :) );
   city = ({
      "child", "rodent", "cockroach", "dog"
   });
   empties = ({ });
   blockages = ([ ]);
   movers = allocate( MAX_MOVERS );
   call_out( "check_movers", 10 );
   call_out( "housekeeping", INTERVAL );
}
int *query_al_data() { return al_data; }
mapping query_uniques() { return uniques; }
object *query_empties() { return empties; }
mapping query_blockages() { return blockages; }
int query_blockage( string this, string other, int number ) {
   if ( undefinedp( blockages[ this ] ) ) {
      if ( random( 100 ) >= BLOCK )
         number = -1;
      blockages[ this ] = blockages[ other ] = number;
   }
   return blockages[ this ];
}
mixed *query_movers() { return movers; }
void housekeeping() {
   object thing;
   update = time();
   foreach( thing in users() ) {
      if ( thing->query_creator() )
         continue;
      alignments[ random( sizeof( alignments ) ) ] =
            (int)thing->query_al();
   }
   al_data = 0;
   unguarded( (: save_object, SAVE_FILE :) );
   call_out( "housekeeping", INTERVAL );
}
int pick_al() {
   int one, *stats;
   if ( !al_data ) {
      al_data = allocate( 3 );
      stats = allocate( 4 );
      foreach( one in alignments ) {
         stats[ 0 ] += one;
         stats[ 1 ] += one * one;
         if ( one > stats[ 2 ] )
            stats[ 2 ] = one;
         if ( one < stats[ 3 ] )
            stats[ 3 ] = one;
      }
      stats[ 0 ] /= sizeof( alignments );
      stats[ 1 ] /= sizeof( alignments );
      stats[ 1 ] -= stats[ 0 ] * stats[ 0 ];
      stats[ 1 ] /= 10;
      if ( stats[ 1 ] < 50 )
         stats[ 1 ] = 50;
      stats[ 2 ] -= stats[ 3 ];
      if ( stats[ 2 ] < 2 )
         stats[ 2 ] = 2;
      al_data[ 0 ] = stats[ 0 ] - stats[ 2 ] / 2;
      al_data[ 1 ] = ( stats[ 2 ] * stats[ 2 ] ) / ( 12 * stats[ 1 ] );
      if ( al_data[ 1 ] < 5 )
         al_data[ 1 ] = 5;
      al_data[ 2 ] = ( 12 * stats[ 1 ] ) / stats[ 2 ];
      if ( al_data[ 2 ] < 25 )
         al_data[ 2 ] = 25;
   }
   return al_data[ 0 ] + roll_MdN( al_data[ 1 ], al_data[ 2 ] );
}
int make_unique( string word ) {
   if ( uniques[ word ] > time() )
      return 0;
    uniques[ word ] = time() + 1 * 60 * 60;
   unguarded( (: save_object, SAVE_FILE :) );
   return 1;
}
void add_mover( object thing ) {
   int number;
   number = MAX_MOVERS / 2 + random( MAX_MOVERS / 2 );
   if ( !pointerp( movers[ number ] ) )
      movers[ number ] = ({ thing });
   else
      movers[ number ] += ({ thing });
}
object get_monster( string type ) {
   object thing;
   object ob;
   switch( type ) {
      case "city" :
      case "pumpkin" :
         thing = get_monster( city[ random( sizeof( city ) ) ] );
         thing->add_property( "monster type", type +":"+
               (string)thing->query_property( "monster type" ) );
         thing->add_move_zone( "Pumpkin" );
         add_mover( thing );
         return thing;
      case "dog":
         thing = clone_object( CHARS + "dog" );
         if ( random( 4 ) )
            thing->set_type( "small" );
         else
            thing->set_type( "large" );
         thing->add_effect( "/std/effects/npc/i_died",
               ({ HOSPITAL, "regen_after_death" }));
         thing->add_effect( "/std/effects/npc/eat_edible" );
         thing->add_effect( "/std/effects/npc/savage_corpse" );
         thing->add_property( "monster type", type );
         thing->add_property("animal type", type);
         return thing;
      case "child":
         thing = clone_object( CHARS + "child_human" );
         return thing;
    case "cityguard":
      ob = clone_object(MONSTER);
      ob->add_property("monster type", type);
      ob->set_name("guard");
      ob->add_adjective("city");
      ob->set_main_plural( "city guards" );
      ob->set_short("city guard");
      ob->set_long("This is a city guard. He is supposed to protect the " +
        "city from undesirables. Sadly, Pumpkin isn't very fussy.\n");
      ob->set_race("human");
      ob->set_gender("male");
      ob->set_guild("fighter");
      ob->set_level(8);
      ob->set_al( pick_al() / 5 );
      ob->adjust_money( 5 + random( 10 ), "Pumpkin pence" );
      ob->load_chat(10, ({
          3, "@grumble bitterly",
          1, "@daydream",
          1, "@sigh heavily"
          }) );
      ob->load_a_chat(50, ({
          1, "'Ouch!",
          1, "'Come on! I don't need this.",
          1, "'Be on your way!",
          }) );
      ARMOURY->request_weapon("long sword", 40+random(40))->move(ob);
      if(random(2))
        ARMOURY->request_armour("hard leather cap", 70 + random(30))->move(ob);
      ob->init_equip();
      return ob;
    case "mercenary":
      ob = clone_object(MONSTER);
      ob->set_name("mercenary");
      ob->set_main_plural( "mercenaries" );
      ob->add_plural( "mercenaries" );
      ob->add_adjective("tough");
      ob->set_race("human");
      ob->set_class("fighter");
      ob->set_level( 50 + roll_MdN( 5, 50 ) );
      ob->set_al( pick_al() );
      ob->set_gender(random(2) + 1);
      ob->set_long("A tough battle scarred mercenary.  There are better "
                   "ways of filling in an afternoon than messing with the "
                   "likes of "+ob->query_objective()+".\n");
      ob->adjust_money( 5 + random( 50 ), "Ankh-Morpork pence" );
      ob->adjust_money( 1 + random( 5 ), "Ankh-Morpork dollar" );
      ob->load_chat(3, ({
        1, "'Anyone you don't like?",
        1, "'I'll do anything if the price is right?",
        1, "'Don't get me angry.  You won't like me when I'm angry."
      }));
      ob->load_a_chat(30, ({
        1, "'I'll show you who's boss.",
        1, "'You think you're so tough.",
        1, "The crowd runs in terror as the mercenary kills someone by "+
           "accident."
      }));
      get_weapon(ob, ({"bastard sword", "long sword", "morning star",
       "two-handed axe"}));
      get_armour(ob, ({"chainmail", "splintmail", "ringmail"}));
      ob->add_property("monster type", type);
      ob->init_equip();
      return ob;
    case "rodent":
      ob = clone_object(MONSTER);
      ob->set_name("rat");
      ob->set_short("rat");
      ob->set_race("rat");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->add_alias("city rat");
      ob->set_main_plural("rats");
      ob->add_adjective("dirty");
      ob->add_adjective("city");
      ob->set_long("This is a large rat.  It appears to have done well "+
       "living in the city.\n"+
       "The pollution must not affect it too much.\n" );
      ob->load_chat( 5, ({
         1, ":squeaks.",
         1, ":sniffs the air, whiskers twitching.",
         1, ":checks for dwarves."
      }) );
      ob->set_wimpy( 10 );
      ob->load_a_chat( 50, ({
         1, ":squeals in pain.",
         1, ":twitches fearfully."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                     ({ HOSPITAL, "regen_after_death" }));
      ob->add_effect( "/std/effects/npc/eat_edible" );
      ob->add_effect( "/std/effects/npc/savage_corpse" );
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    case "cockroach":
      ob = clone_object(MONSTER);
      ob->set_name("cockroach");
      ob->set_short("cockroach");
      ob->set_race("cockroach");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->set_main_plural("cockroaches");
      ob->add_adjective("dirty");
      ob->add_alias("roach");
      ob->set_long( "This is a huge dirty great big cockroach, the size of "
             "your hand at least.  It waves its feelers at you and looks "
             "horrible and black.  Not only can cockroaches survive fires, "
             "plagues, earthquakes and miscellaneous acts of supernatural "
             "beings, they can survive in Ankh-Morpork!\n" );
      ob->load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
      ob->set_wimpy( 30 );
      ob->load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                      ({ HOSPITAL, "regen_after_death" }));
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    default:
      ob = clone_object(MONSTER);
      ob->set_name("failure");
      ob->set_short("failure");
      ob->set_long( "Please inform a creator about this object.\n"+
          "Type is "+ type +" from "+ file_name( previous_object() ) +".\n" );
      ob->add_property( "monster type", "failure:"+ type );
      return ob;
  }
}
void get_armour(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void get_jewellery(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 20+random(80))->
    move(ob);
}
void get_weapon(object ob, string *items) {
  ARMOURY->request_weapon(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void regen_after_death(object player) {
  object ob, dest;
  string nam;
  if (!player)
    return ;
  nam = (string)player->query_property("monster type");
  dest = (object)player->query_property("start location");
  if ( !nam )
    return;
  if ( !dest )
    return;
  if(!ok_to_clone())
    return;
  ob = get_monster( explode( nam, ":" )[ 0 ] );
  dest->add_monster(player, ob);
  call_out("do_move", 10, ({ ob, dest }) );
}
void do_move(mixed *junk) {
  junk[0]->move(junk[1]);
}
string change_to_name(object ob) {
  return implode((string *)ob->query_adjectives(), " ")+
         (string)ob->query_name();
}
void do_run(object ob) {
  if (ob)
    ob -> run_away();
}
void fight_check(object ob, object ob1) {
  if (ob->query_property(previous_object()->query_name()))
    previous_object()->attack_ob(ob1);
}
void do_grin_laugh(object ob) {
  ob->add_respond_to_with(({ "@grin", ob->query_name() }),
                          "laugh man at $hname$");
}
void add_empty( object thing ) {
   empties -= ({ 0 });
   empties += ({ thing });
   if ( sizeof( empties ) > MAX_EMPTIES )
      empties = shuffle( empties )[ 0 .. MAX_EMPTIES - 1 ];
}
void move_monster( object thing ) {
   int i;
   string dest, direc, zone, *movez, *roomz;
   object place;
   if ( !thing )
      return;
   if ( (int)thing->query_hp() < 0 )
      return;
   if ( thing->query_property( PASSED_OUT ) || thing->query_fighting() ) {
      add_mover( thing );
      return;
   }
   movez = (string *)thing->query_move_zones();
   empties -= ({ 0 });
   if ( sizeof( empties ) && !thing->check_anyone_here() )
      foreach ( place in empties ) {
         roomz = (string *)place->query_zones();
         if ( !sizeof( roomz ) ) {
            empties -= ({ place });
            continue;
         }
         foreach ( zone in roomz ) {
            i = member_array( zone, movez );
            if ( i != -1 )
               break;
         }
         if ( i == -1 )
            continue;
         thing->move( place );
         place->add_monster( 0, thing );
         place->announce_entry( thing );
         empties -= ({ place });
         add_mover( thing );
         return;
      }
   place = environment( thing );
   if ( !place )
      return;
   add_mover( thing );
   foreach ( direc in shuffle( (string *)place->query_direc() ) ) {
      place->set_destination( direc );
      dest = (string)place->query_destination( direc );
      if ( !stringp( dest ) )
         continue;
      if ( !thing->check_anyone_here() && !find_object( dest ) )
         continue;
      if ( find_object( dest ) )
         roomz = (string *)dest->query_zones();
      else
         roomz = (string *)MAP->query_zones( dest );
      if ( !sizeof( roomz ) )
         continue;
      foreach ( zone in roomz ) {
         i = member_array( zone, movez );
         if ( i != -1 )
            break;
      }
      if ( i == -1 )
         continue;
      if ( place->query_relative( direc ) )
         direc = (string)thing->find_rel( direc, 0 );
      if ( thing->do_command( direc ) )
         return;
   }
}
void check_movers() {
   int when;
   object thing, *things;
   things = movers[ 0 ];
   movers[ 0 .. MAX_MOVERS - 2 ] = movers[ 1 .. ];
   movers[ MAX_MOVERS - 1 ] = 0;
   call_out( "check_movers", 10 );
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) ) {
         when += 2;
         call_out( "move_monster", when, thing );
      }
   }
}
int ok_to_clone() {
  if(time() > last_check + 300) {
    last_check = time();
    am_npcs = sizeof( filter( named_livings(),
      (: environment( $1 ) && base_name( environment( $1
       ) )[0..4] == "/d/am" :) ) );
  }
  return ( am_npcs < MAX_AM_LIVING );
}
int *query_npcs() {
  return ({ am_npcs, last_check });
}

==================================================
FILE: dist/pumpkin/pumpkin/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is end of Pumpkin Way at the junction with Crumpet Circle.\n");
  set_light( 80 );
  add_exit("east", PUMPKIN + "pumpkin2", "road");
  add_exit("southwest", CRUMPT + "crumpt1", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is middle of Pumpkin Way just north of Crumpt Circle.\n");
  set_light( 80 );
  add_exit("west", PUMPKIN + "pumpkin1", "road");
  add_exit("south", PUMPKIN + "pumpkin3", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way north of Squash Square.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin2", "road");
  add_exit("south", PUMPKIN + "pumpkin4", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way you can just see Squash Square "
           "to the south.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin3", "road");
  add_exit("south", PUMPKIN + "pumpkin5", "road");
  add_exit("west", PATH + "stable_entry", "gate");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way, quite close to the junction "
           "with Squash Square to the south.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin4", "road");
  add_exit("south", PUMPKIN + "pumpkin6", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin6.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the end of Pumpkin Way at the junction with "
           "Squash Square.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin5", "road");
  add_exit("south", SQUASH + "squash2", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/stable_entry.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/std/room/stable";
void setup() {
   set_light(60);
   set_theft_handler( HOSPITAL );
   set_short( "stables" );
   add_property("determinate", "the ");
   set_long( "These are the Pumpkin Street stables, an ornate gate to the "+
      "north opening onto the street.  There are many stalls here, "+
           "and some of them even have horses in them. Against one wall "+
           "is a pile of hay and hanging on the walls are saddles and "+
           "other horse riding equipment.\n");
   add_exit( "east", PATH +"pumpkin4", "gate" );
   add_item(({"horse", "horses"}), "There are a few horses here, but "+
              "most of them seem to be in the carthorse mold, rather "+
              "than being fine chargers.\n");
   add_item(({"hay", "pile"}), "A big pile of hay (that's dead grass to you and me).\n");
   add_item(({"saddle", "saddles", "riding equipment", "equipment"}),
              "Hanging on one wall are saddles, bridles, bits and other "+
              "things that help you ride a horse.\n");
   add_item("stalls", "Boxes where horses live!\n");
   add_item("gate", "A large gate, made of wrought iron bent into intricate "+
                    "shapes. On the other side you can see Filigree Street.\n");
   add_item(({"shape", "shapes"}), "There are many shapes and patterns "+
              "to be found in the twists and turns of the iron gates, "+
              "but you can't find any meaning in them. Maybe it's "+
              "meant to be abstract?\n");
   room_chat( ({ 50, 50, ({
 		  "A horseman rides through the gates and dismounts. "+
             "A stable boy rushes forward and leads the horse to a stall "+
             "while the rider leaves.",
             "One of the horses rears up in its stall, but can't "+
             "force the door open."
   }) }) );
   set_zone("pumpkin stables");
   set_save_directory("/d/dist/pumpkin/save/stables/");
   add_stable_type("horse");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/stable_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Stable shop");
   set_long(
"You are in the stable shop, it is completely full of various weird things "
"like bits, bridles and other obscure looking bits of leather.\n");
   add_exit("west", PATH + "pumpkin5", "gate");
   set_light(70);
   add_object("pale grey horse");
   add_object("painted grey horse");
   add_object("plaid horse");
   add_object("dappled brown horse");
   add_object("light brown horse");
   add_object("dark brown horse");
   add_object("dark red horse");
   add_object("black warhorse");
   add_property("place", "Pumpkin");
}
object create_object(string thing) {
   object horse;
   object bing;
   if (strlen(thing) > 8 && thing[<8..] == "warhorse") {
      horse = clone_object("/obj/monster/transport/warhorse");
      horse->set_colour(thing[0..<10]);
      horse->set_value(8);
      horse->add_property("cost here", 8);
      return horse;
   } else if (strlen(thing) > 5 && thing[<5..] == "horse") {
      horse = clone_object("/obj/monster/transport/horse");
      horse->set_colour(thing[0..<7]);
      horse->set_value(8);
      horse->add_property("cost here", 8);
      return horse;
   } else {
      bing = clone_object(thing);
      bing->setup_clothing(1000);
      bing->set_value(8);
      return bing;
   }
}

==================================================
FILE: dist/pumpkin/chars/child_human.c
==================================================

#include "path.h"
inherit "/obj/monster";
void respond_to_soul(object play);
void setup() {
   int i;
   string *types = ({ "playful", "quiet", "thin", "fat", "noisy",
         "thoughtful", "happy", "sad", "boring", "interesting" });
   set_name( "child" );
   i = random( sizeof( types ) );
   set_short( types[ i ] +" child" );
   add_adjective( types[ i ] );
   set_main_plural( types[ i ] +" children" );
   set_race( "human" );
   set_gender( 1 + random( 2 ) );
   i = (int)"/std/races/human"->query_weight();
   i += (int)"/std/races/human"->modifier( weight );
   set_base_weight( ( 3 * i ) / ( 4 + random( 6 ) ) );
   i = (int)"/std/races/human"->query_height();
   i += (int)"/std/races/human"->modifier( height );
   set_height( ( 2 * i ) / ( 3 + random( 4 ) ) );
   set_con( ( 2 * query_con() ) / ( 3 + random( 4 ) ) );
   set_dex( ( 2 * query_dex() ) / ( 3 + random( 4 ) ) );
   set_str( ( 2 * query_str() ) / ( 3 + random( 4 ) ) );
   set_al( -50 + (int)HOSPITAL->pick_al() / 10 );
   set_level( random( 5 ) );
   set_wimpy( 90 );
   set_long( "This is one of the inhabitants of Pumpkin.\n" );
   add_effect( "/std/effects/npc/gossip", 5);
   load_chat(40, ({ 1, "#do_gossip_say:$mess$" }));
   add_respond_to_with(({ ({ "@skick", "@spunch", "@jump", "@push",
                             "@shove", "@knee" }) }),
                       (: respond_to_soul :));
}
void respond_to_soul(object play) {
   switch (random(6)) {
   case 0:
      do_command("'Thats not very nice!");
      break;
   case 1:
      do_command("'Pick on someone your own size.");
      do_command("glare " + player->query_name());
      break;
   case 2:
      do_command("cry");
      do_command("accuse " + player->query_name() + " of child abuse");
      break;
   case 3:
      do_command("spunch " + player->query_name());
      do_command("'Take that!  and that!");
      do_command("skick " + player->query_name());
      break;
   case 4:
      do_command("accuse " + player->query_name() + " of child abuse");
      break;
   case 5:
      do_command("'I will tell my brother!");
      break;
   }
   call_out("run_away", 2);
}

==================================================
FILE: dist/pumpkin/chars/dog.c
==================================================

inherit "/obj/monster";
#include "path.h"
string colour, type;
void check_for_hidden();
void test_rabid_attack();
void test_urinate();
void pat_me( object per );
void sic_em( object per, string mess );
string query_colour() { return colour; }
void setup() {
   colour = ({ "light brown", "black", "grey", "mottled", "white", "patched",
         "dark brown", "black and white", "fluorescent yellow" })[ random( 9 ) ];
  set_name("dog");
  set_race("dog");
  set_gender(1 + random(2));
  set_level( 1 + random( 1 + random( 3 ) ) );
  add_adjective("hairy");
  add_adjective(explode(colour, " "));
}
void set_type(string type) {
   set_short( type +" "+ colour +" dog" );
   set_main_plural( type +" "+ colour +" dogs" );
   add_adjective( type );
   if ( type == "small" ) {
      set_long("The small "+colour+" dog is very hairy.  It looks a "
                 "bit sad and lost in the streets of Pumpkin.  "
                 "You are sure it would prefer a cat flap and a nice "
                 "hot meal every night, or is that you?\n");
   } else {
      add_skill_level( "fighting", random( 10 + random( 30 ) ) );
      add_skill_level( "other.health", random( 10 + random( 30 ) ) );
      set_main_plural("large "+colour+" dogs");
      add_adjective("large");
      set_long("The large "+colour+" dog confidently walks the streets, "
                 "insolently not moving aside for the warriors and heroes "
                 "stalking the streets.\n");
   }
   add_enter_commands( "#check_for_hidden" );
   if ( !random( 3 ) )
     add_effect( "/std/effects/disease/flea_infestation", 10000 );
  if (!random(6)) {
    set_wimpy(10);
    load_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl",
       1, "#test_rabid_attack",
    }) );
    load_a_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl" }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                             query_name() }), "bite $hname$");
  } else {
    set_wimpy( 70 );
    load_chat( 5, ({
       1, (type=="small"?":whines pathetically.":"@growl"),
       1, (type=="small"?"@stare hungrily at $lname":
                             "@stare int at $lname"),
       1, (type=="small"?"@bite $lname ankles":"@stare rud at $lname"),
       1, "#test_urinate",
    }) );
    load_a_chat( 50, ({
       1, "@bite $aname ?",
       1, "@growl",
       1, "@bark",
    }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                                query_name() }), "#pat_me" );
    add_respond_to_with( ({ "@say", ({ "get", "sic" }), }), "#sic_em" );
  }
  add_effect("/std/effects/npc/eat_edible", 0);
  add_effect("/std/effects/npc/i_died", ({ HOSPITAL, "regen_after_death" }));
  add_property("monster_type", type);
  add_property("animal type", type);
}
void bark_at_hidden(object per) {
  mapping hide_invis;
  if (per) {
    hide_invis = per->query_hide_invis();
    if (environment(per) == environment() &&
        hide_invis["hiding"]) {
      do_command("bark loudly");
      if (!random(4))
        do_command("bark loudly at "+
                 per->query_name());
      else
        do_command("bark loudly");
      call_out("bark_at_hidden", 2, per);
    }
  }
}
void check_for_hidden() {
  object *obs, mine;
  int i;
  mapping hide_invis;
  function fun;
  mine = query_property("following");
  obs = all_inventory(environment(this_object()));
  for (i=0;i<sizeof(obs);i++) {
    hide_invis = query_hide_invis();
    if (living(obs[i]) && hide_invis["hiding"] &&
        obs[i] != mine && obs[i]->query_visible(this_object())) {
      call_out("bark_at_hidden", 0, obs[i]);
      break;
    }
  }
}
void test_rabid_attack() {
  int i;
  object *obs;
  obs = filter_array(all_inventory(environment()),
                     (: living($1) && $1 != $2 &&
                        (!$1->query_property("player") ||
                         $1->query_level() > 5) :),
                      this_object());
  if (sizeof(obs))
    attack_ob(obs[0]);
}
void test_urinate() {
  object *obs, *liv, blue, mine;
  int i;
  liv = ({ });
  mine = query_property("following");
  obs = all_inventory(environment());
  check_for_hidden();
  for (i=0;i<sizeof(obs);i++) {
    if (living(obs[i]) && obs[i] != mine &&
        obs[i] != this_object()) {
      liv += obs[i..i];
    }
  }
  if (sizeof(liv)) {
    blue = liv[random(sizeof(liv))];
    tell_room(environment(),
              the_short() + " urinates on " + blue->the_short() + "'s leg.\n",
              ({ blue }));
    tell_object(blue, capitalize(the_short()) + " urinates on your leg.\n");
    blue->add_effect("/std/effects/other/dog_urinate", 120);
  }
}
void i_like_them(object them) {
  if(!them || environment() != environment(them))
    return ;
  call_out("i_like_them", 60+random(240), them);
  if (query_property("excited")) {
    do_command("bounce excit");
  } else switch (random(5)) {
    case 0 :
      do_command("nuzzle "+them->query_name());
      break;
    case 1 :
      do_command("stare pitifully at "+them->query_name());
      break;
    case 2 :
      do_command("smile "+them->query_name());
      break;
    case 3 :
      do_command("eye "+them->query_name());
      break;
    case 4 :
      do_command("drool "+them->query_name());
      break;
  }
}
void pat_me(object per) {
  object ob;
  ob = query_property("following");
  if (objectp(ob) &&
      environment(ob) == environment()) {
    init_command("nuzzle "+per->query_name());
  } else if (environment() == environment(per) &&
   (query_property("monster type") == "small dog" ||
   !random(5))) {
    init_command("follow "+per->query_name());
    init_command("protect "+per->query_name());
    add_property("following", per);
    call_out("i_like_them", 60+random(240), per);
  } else {
    init_command("ignore "+per->query_name());
  }
}
void periodic_excited() {
  if (query_property("excited")) {
    if (query_property("excited") > 1) {
      switch (random(4)) {
        case 0 :
          do_command("growl");
          break;
        case 1 :
          do_command("bark");
          break;
        case 2 :
          do_command("caper");
          break;
        case 3 :
          do_command("bounce excit");
          break;
      }
    } else if (!random(2))
      do_command("bounce excit");
    else
      do_command("caper");
    call_out("periodic_excited", 10+random(10));
  }
}
void sic_em(object per, string mess) {
   string *bing;
   object mine;
   object *obs;
   int lvl;
   bing = explode(replace(mess, "!", ""), " ");
   mine = query_property("following");
   if (bing[0] == "get" && per == mine) {
      obs = match_objects_for_existence(bing[1], environment());
      obs = filter_array(obs, (: living($1) :));
      if ( sizeof( obs ) ) {
	 lvl = query_property( "excited" );
	 add_property( "excited", lvl+1 );
	 call_out( function( object npc ) {
	    int lvl;
	    lvl = npc->query_property("excited");
	    if (lvl > 0)
	       npc->add_property("excited", lvl - 1);
	    else
	       npc->remove_property("excited");
	 }, 120, this_object());
	 if (!lvl) {
	    call_out("periodic_excited", 10+random(10));
	 }
	 switch (lvl) {
	  case 0 :
	    init_command("bounce excit");
	    break;
	  case 1 :
	    init_command("growl "+obs[0]->query_name());
	    break;
	  default :
	    call_out((: attack_ob($2) :), 0, obs[0]);
	    break;
	 }
      }
   }
}

==================================================
FILE: dist/pumpkin/chars/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is Fruitbat Avenue at the junction with Crumpet Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat2", "road");
  add_exit("north", CRUMPT + "crumpt8", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just west of "
           "Crumpt Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat3", "road");
  add_exit("west", FRUITBAT + "fruitbat1", "road");
  add_exit("south", FRUITBAT + "general_store", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just south of the "
           "vault.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat4", "road");
  add_exit("west", FRUITBAT + "fruitbat2", "road");
  add_exit("north", FRUITBAT + "walrus_vault_entry", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is east end of Fruitbat Avenue at the junction "
           "with Squash Square.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash4", "road");
  add_exit("west", FRUITBAT + "fruitbat3", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/general_store.c
==================================================

#include "path.h"
inherit "/std/shops/general_shop";
void setup() {
   set_short("Elephant's Stamp");
   set_long(
"A huge picture of an elephant covers tha back room of the shop.  You can "
"see the elephant guarding a huge pile of goods.\n");
   add_exit("north", FRUITBAT + "fruitbat2", "door");
   set_light(70);
   set_store_room(FRUITBAT + "storeroom");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/fruitbat/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/fruitbat/storeroom.c
==================================================

inherit "/std/shops/storeroom";
void setup() {
   set_short("Elephant's Storeroom");
   set_light(70);
   set_long("Lots of stored stuff.\n");
 }

==================================================
FILE: dist/pumpkin/fruitbat/walrus_vault.c
==================================================

#include "path.h"
inherit "/std/shops/vault";
void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");
   set_light(70);
   set_vault_name("walrus");
   set_vault_exit("south", FRUITBAT + "walrus_vault_entry", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/fruitbat/walrus_vault_entry.c
==================================================

#include "path.h"
inherit "/std/shops/vault_entry";
object _npc;
void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");
   set_light(70);
   set_vault_name("walrus");
   set_visit_cost(400);
   set_open_cost(4000);
   add_exit("south", FRUITBAT + "fruitbat3", "door");
   set_vault_exit("north", FRUITBAT + "walrus_vault", "door");
   add_property("place", "Pumpkin");
}
void reset() {
   set_proprietor(_npc);
}

==================================================
FILE: admin/common.c
==================================================

#include <config.h>
#define DOM_TITLE "the domain of admin"
#define LORD "pinkfish"
#define DOMAIN "admin"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", CONFIG_START_ROOM, "door");
  modify_exit( "drum", ({ "one way", 1 }) );
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs adorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}

==================================================
FILE: admin/master.c
==================================================

#define LORD "pinkfish"
#define DOMAIN "admin"
#define LOGS "/d/admin/log/"
#define BACKUP_COUNT 9
inherit "/std/dom/base_master";
void create() {
   string file;
   int i;
   ::create();
   foreach ( file in unguarded( (: get_dir, LOGS +"*.log" :) ) ) {
     if( ( unguarded( (: file_size, LOGS + file :) ) > 1024000) ||
         ( file != "ENTER.log" &&
           unguarded( (: file_size, LOGS + file :) ) > 64000 ) ) {
       file = explode( file, "." )[ 0 ];
       if(file_size(LOGS+file+"."+BACKUP_COUNT) > 0)
         unguarded( (: rm, LOGS + file +"."+ BACKUP_COUNT :) );
       for(i=(BACKUP_COUNT-1); i>0; i--)
         if(file_size(LOGS+file+"."+i) > 0)
           unguarded( (: rename, LOGS+file+"."+i, LOGS+file+"."+(i+1) :) );
       unguarded( (: rename, LOGS+file+".log", LOGS+file+"."+"1" :) );
     }
   }
}
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}
int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}
int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "\nThe admin domain is made up of the active Trustees of "
    "Discworld.  Their role is to ensure the smooth running of the game.  "
    "They carry the ultimate responsibility for Discworld, how it operates "
    "and its policies and rules.\n\n";
}

==================================================
FILE: admin/room/access_control.c
==================================================

#include <access.h>
#include "path.h"
inherit "/std/room/basic_room";
#define LOGIN "/secure/login"
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8
int do_read(string euid, string path);
int do_write(string euid, string path);
int do_grant(string euid, string path);
int do_lock(string path);
int do_noread(string euid, string path);
int do_nowrite(string euid, string path);
int do_nogrant(string euid, string path);
int do_unlock(string path);
int do_summary(string str);
int do_tidy();
void setup() {
  set_light(100);
  set_short("file-access control room");
  add_property("determinate", "the ");
  set_long(
    "You are in a room full of filing cabinets.  There are filing "
    "cabinets everywhere, they are all packed full of papers and look "
    "in a horrible mess.\n"
"Available commands:\n"
"  read    <euid> <path>     : add read permission to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n" );
  add_exit("east", ROOM+"domain_control", "corridor");
}
void init() {
  ::init();
  this_player()->add_command("read",    this_object(),
    "<string'euid'> <string'path'>", (: do_read($4[0], $4[1]) :) );
  this_player()->add_command("write",   this_object(),
    "<string'euid'> <string'path'>", (: do_write($4[0], $4[1]) :) );
  this_player()->add_command("grant",   this_object(),
    "<string'euid'> <string'path'>", (: do_grant($4[0], $4[1]) :) );
  this_player()->add_command("lock",    this_object(),
    "<string'path'>",                (: do_lock($4[0]) :) );
  this_player()->add_command("noread",  this_object(),
    "<string'euid'> <string'path'>", (: do_noread($4[0], $4[1]) :) );
  this_player()->add_command("nowrite", this_object(),
    "<string'euid'> <string'path'>", (: do_nowrite($4[0], $4[1]) :) );
  this_player()->add_command("nogrant", this_object(),
    "<string'euid'> <string'path'>", (: do_nogrant($4[0], $4[1]) :) );
  this_player()->add_command("unlock",  this_object(),
    "<string'path'>",                (: do_unlock($4[0]) :) );
  this_player()->add_command("summary", this_object(),
    "<string'path or euid'>",        (: do_summary($4[0]) :) );
  this_player()->add_command("tidy",    this_object(),
    "",                              (: do_tidy() :) );
}
int do_read(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_read("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_read("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to add read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_read_permission(euid, path);
}
int do_write(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_write("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_write("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to add write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_write_permission(euid, path);
}
int do_grant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_grant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_grant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to add grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_grant_permission(euid, path);
}
int do_lock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_lock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_lock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->lock_path(path);
}
int do_noread(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_noread("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_noread("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to remove read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_read_permission(euid, path);
}
int do_nowrite(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nowrite("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_nowrite("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to remove write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_write_permission(euid, path);
}
int do_nogrant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nogrant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_nogrant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to remove grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_grant_permission(euid, path);
}
int do_unlock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_unlock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_unlock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->unlock_path(path);
}
int list_before( string first, string second ) {
   if ( first < second )
      return -1;
   if ( first > second )
      return 1;
   return 0;
}
int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!LOGIN->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str;
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  paths = sort_array( m_indices( perms ), "list_before", this_object() );
  if (!sizeof(paths))
    ret = "No permissions set.\n";
  else
    ret = sprintf("%11-s    Path\n", "Euid");
  for (i=0;i<sizeof(paths);i++) {
    euids = m_indices(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
}
int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;
   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !LOGIN->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
}

==================================================
FILE: admin/room/cloner_control.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
#define CLONER "/global/cloner"
int do_add(string from, string to);
int do_remove(string from);
int do_list(string matching);
void setup() {
  set_light(100);
  set_short("Cloner Room");
  set_long("This room is used to look at or add filename mappings for the "+
     "cloner object.  It's a very, very, very, very boring room.\n\n"+
     "  add <from> <to> - adds a mapping.\n"+
     "  remove <from> - removes a mapping.\n"+
     "  list [str] - lists mappings which contain the optional string "+
     "str.\n");
  add_exit("southwest" , ROOM+"development" , "door");
}
void init() {
  ::init();
  if (!this_player()) return;
  this_player()->add_command("add", this_object(),
    "<string:small'from object'> <string:small'to object'>",
    (: do_add($4[0], $4[1]) :)
    );
  this_player()->add_command("remove", this_object(),
    "<string:small'from object'>",
    (: do_remove($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "<string:small'matching'>",
    (: do_list($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "",
    (: do_list("") :)
    );
}
int do_add(string from, string to) {
  CLONER->add_mapping(from, to);
  return 1;
}
int do_remove(string str) {
  CLONER->remove_mapping(str);
  return 1;
}
int do_list(string from) {
  this_player()->more_string(CLONER->list_mappings(from));
  return 1;
}

==================================================
FILE: admin/room/development.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
object board;
void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("development");
    board->move(this_object());
  }
}
void setup() {
  set_light(80);
  set_short("Mud Development Office");
  set_long(
    "You are in the Development Office of the mud. Maps and charts of the "+
    "world adorn the panelled walls. Forms sit on a table near the door "+
    "for registration of new projects. A few bored looking clerks rustle "+
    "some papers and try to look busy.\n");
  add_item("clerk", "They seem more interested in coffee than work.\n");
  add_item("map", "Type 'list' to see available maps, and 'read' to look "+
           "at one.\n");
  add_exit("west", "w/common", "door");
  add_exit("east", ROOM+"quest_room", "door");
  add_exit("north", ROOM+"mail_room", "door");
  add_exit("south", ROOM+"domain_control", "corridor");
  add_exit("northeast", ROOM+"cloner_control", "door");
   add_exit( "southeast", ROOM +"terrain", "door" );
}
void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}

==================================================
FILE: admin/room/domain_control.c
==================================================

#include "access.h"
#include "path.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"
int do_list(string arg);
int do_create(string dom, string lord);
int do_list_all();
int do_deputy(string cre, string dom);
int do_undeputy(string cre, string dom);
int do_create(string dom, string lord);
int do_project(string cre, string dom, string project);
int do_add(string cre, string dom);
int do_delete(string cre, string dom);
void setup() {
  set_light(100);
  set_short("domain-control room");
  add_property("determinate", "the ");
  set_long("You float in nothingness, before a vast turtle, its shell pocked "
    "by asteroid craters. In all directions stars twinkle in the black "
    "curtain of space.\n"
"Available commands:\n"
"  list                         : list all domains.\n"
"  list <domain>                : list members of a domain.\n"
"  create <domain>              : create a domain (you are lord).\n"
"  create <domain> <lord>       : create a domain for someone else.\n"
"  add <creator> <domain>       : add a creator to a domain you own.\n"
"  delete <creator> <domain>    : remove a creator from a domain you own.\n"
"  project <cre> <dom> <proj>   : Set the creators project.\n"
"  deputy <cre> <dom>           : Appoint creator as a deputy.\n"
"  undeputy <cre> <dom>         : Remove creator as a deputy.\n"
);
  add_item("turtle", "On its back you can see four elephants, and they bear " +
    "the weight of the disc upon their wide backs.\n");
  add_item("elephants", "The four great elephants labour endlessly in the " +
    "task of turning the disc upon their backs.\n");
  add_item("disc", "The whole discworld, from hub to rim, rides upon the " +
    "elephant's backs.\n");
  add_alias("elephant", "elephants");
  add_exit("north", ROOM+"development", "corridor");
  add_exit("south", ROOM+"site_control", "corridor");
  add_exit("west", ROOM+"access_control", "corridor");
  seteuid("Admin");
}
void init() {
  ::init();
  add_command("list", "", (: do_list_all() :) );
  add_command("list", "<word>", (: do_list($4[0]) :) );
  add_command("create", "<word>", (: do_create($4[0], 0) :) );
  add_command("create", "<word> <word>", (: do_create($4[0], $4[1]) :) );
  add_command("add", "<word> <word>", (: do_add($4[0], $4[1]) :) );
  add_command("delete", "<word> <word>", (: do_delete($4[0], $4[1]) :) );
  add_command("project", "<word> <word> <string>",
                         (: do_project($4[0], $4[1], $4[2]) :) );
  add_command("deputy", "<word> <word>", (: do_deputy($4[0], $4[1]) :) );
  add_command("undeputy", "<word> <word>", (: do_undeputy($4[0], $4[1]) :) );
}
int do_list_all() {
  int i, num;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  write("Current domains:\n");
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    members = (string *)mast->query_members();
    printf( "%15s has %2d %-7s and is owned by %s.\n", domains[ i ],
      num = sizeof( (string *)mast->query_members() ),
      ( ( num == 1 ) ? "member" : "members" ),
      capitalize( (string)mast->query_lord() ) );
  }
  return 1;
}
int do_list(string arg) {
  int i, cols;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  if(member_array(arg, domains) == -1) {
    notify_fail("No such domain as " + arg + ".\n");
    return 0;
  } else {
    mast = "/d/" + arg + "/master";
    write(capitalize((string)mast->query_lord()) + " is the lord of " +
      arg + ".\nMembers         Project\n");
    members = (string *)mast->query_members();
    cols = (int)this_player()->query_cols();
    for (i=0;i<sizeof(members);i++)
      printf("%-15s %*-=s\n", members[i], cols-16,
                             mast->query_project(members[i]) +
             (mast->query_deputy(members[i])?" (deputy)":""));
  }
  return 1;
}
int do_create(string dom, string lord) {
  if (this_player() != this_player(1))
    return 0;
  if(!MASTER->high_programmer(geteuid(previous_object()))) {
    notify_fail("You lack the Power of Change on this scale!\n");
    return 0;
  }
  if (!lord) {
    lord = (string)this_player()->query_name();
  }
  if (!MASTER->create_domain(dom, lord)) {
    notify_fail("Failed to create domain " + dom + " with the lord " + lord
                + ".\n");
    return 0;
  }
  write("You create the domain " + dom + " with " + capitalize(lord) +
    " as its lord.\n");
  return 1;
}
int do_add(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if (!mast->add_member(cre)) {
    notify_fail("Failed to add " + capitalize(cre) + " to domain " +
      dom + ".\n");
    return 0;
  }
  write("Creator " + capitalize(cre) + " now added to domain " + dom + ".\n");
  return 1;
}
int do_delete(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->remove_member(cre)) {
    notify_fail("Failed to remove " + capitalize(cre) + " from domain " +
       dom + "\n");
    return 0;
  }
  write("Member " + capitalize(cre) + " removed from domain " + dom + ".\n");
  return 1;
}
int do_project(string cre, string dom, string project) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if (!mast->set_project(cre, project)) {
    notify_fail("Failed to set the project " + project + " for " +
                capitalize(cre) + " in the domain " + dom + "\n");
    return 0;
  }
  write("Project for " + capitalize(cre) + " set to " + project +
        " in the domain " + dom + ".\n");
  return 1;
}
int do_deputy(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->add_deputy(cre)) {
    notify_fail("Failed to add the deputy " +
                capitalize(cre) + " to the domain " + dom + "\n");
    return 0;
  }
  write("Deputy " + capitalize(cre) + " added to "
        "the domain " + dom + ".\n");
  return 1;
}
int do_undeputy(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->remove_deputy(cre)) {
    notify_fail("Failed to remove the deputy " +
                capitalize(cre) + " from the domain " + dom + "\n");
    return 0;
  }
  write("Deputy " + capitalize(cre) + " removed from "
        "the domain " + dom + ".\n");
  return 1;
}
