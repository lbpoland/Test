# Total Tokens: 17361
# Total Files Merged: 17
# Total Characters: 57918


==================================================

#include "potion_attrs.h"
#include "library.h"
inherit "/std/object";
#define MY_ROOM "/d/sur/Sto_Plains/n_caravan/picnic_area"
object *demons, cauldron, coin;
void setup() {
  set_weight(10);
  set_value(5);
  set_name("shell");
  add_adjective("sea");
  add_alias("seashell");
  set_short("sea shell");
  set_long("A large conch shell.  It looks like it has been hollowed "+
           "out so that it can be played.  Perhaps if you blew into "+
           "it it might work.\n");
}
void init() {
  this_player()->add_command("blow", this_object());
}
int finish_quest();
int do_blow(object *indir, string s1, string s2, string prep) {
  if (sizeof(indir)) {
    write("Blow "+short(0)+" "+prep+" "+indir->short(0)+"????\n");
    return 0;
  }
  if (file_name(environment(this_player())) == MY_ROOM)
    return finish_quest();
  add_succeeded_mess("$N $V $D and make$s a horrible noise.\n");
  return 1;
}
int finish_quest() {
  object *obs, *obs2, *obs3, ob, fish, frisbee, ladle;
  mixed *attrs;
  string failure;
  int i, j;
  write("The "+short(0)+" blows amazing loudly.\n");
  say(this_player()->one_short()+" blows the "+short(0)+
      " amazingly loudly.\n");
  if (demons) {
    write("Demons glare at you.\n");
    say("Demons glare at "+this_player()->one_short()+".\n");
    return 1;
  }
  obs = all_inventory(environment(this_player()));
  obs3 = obs;
  obs = map_array(obs, "bingle_bit", this_object());
  if ((i=member_array("ladle", obs)) == -1) {
    failure = "no ladle";
  } else {
    ladle = obs3[i];
  }
  if ((i=member_array("frisbee", obs)) == -1) {
    failure = "no frisbee";
  } else {
    frisbee = obs3[i];
  }
  if ((i=member_array("cauldron", obs)) == -1) {
    failure = "no caldron";
  } else {
    cauldron = obs3[i];
      obs2 = match_objects_for_existence("cauldrons", environment(this_player()));
    for (i=0;i<sizeof(obs2);i++) {
      if ((int)obs2[i]->query_volume() < 100 ||
          (int)obs2[i]->query_volume() < (int)obs2[i]->query_max_volume() / 2) continue;
      attrs = (mixed *)obs2[i]->query_misc_attrs();
      if (pointerp(attrs)) attrs = attrs[POTION_NAMES];
      if (pointerp(attrs) && sizeof(attrs) && attrs[0][0] == "yucky ankh water") {
        j++;
      }
    }
    if (!j) {
      failure = "no cauldron full of anhk river water";
    }
  }
  if ((i = member_array("coin", obs)) == -1) {
    failure = "no coin";
  } else {
    coin = obs3[i];
  }
  if ((i=member_array("fish", obs)) == -1) {
    failure = "no fish";
  } else {
    fish = obs3[i];
  }
      obs2 = match_objects_for_existence("toadstools", environment(this_player()));
  obs2 = filter_array(obs2, "bongle_array", this_object());
  if (sizeof(obs2) < 4) {
    failure = "not enough toadstools to sit on";
  }
  if (failure) {
    write("A bunch of hungry looking demons show up.\n");
    write("They look around the clearing.\n");
    write("Mutter to themselves about there being "+failure+".\n");
    write("Demon glares at you.\n");
    say("A bunch of hungry looking demons show up.\n");
    say("They look around the clearing.\n");
    say("Mutter to themselves about there being "+failure+".\n");
    say("Demon glares at "+this_player()->one_short()+".\n");
    return 1;
  }
  demons = allocate(4);
  for (i=0;i<sizeof(demons);i++) {
    demons[i] = clone_object("/std/container");
    demons[i]->set_name("demon");
    demons[i]->reset_get();
    demons[i]->set_long("A small demon with a manic look in his eyes "+
                        "cooking soup.\n");
    demons[i]->move(environment(this_player()));
    obs2[i]->move(demons[i]);
  }
  coin->reset_get();
  cauldron->reset_get();
  fish->dest_me();
  ladle->move(demons[2]);
  frisbee->move(demons[1]);
  say("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  call_out("do_finish_it", 10);
  write("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  return 1;
}
void do_finish_it() {
  object *obs;
  int i, j;
  say("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily.  You hear one of the say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  write("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily and leave.  You hear one of the "+
        "demons say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  cauldron->dest_me();
  coin->dest_me();
  obs = all_inventory(environment(demons[0]));
  for (i=0;i<sizeof(obs);i++)
    if (interactive(obs[i])) {
      if (!LIBRARY->set_quest(obs[i]->query_name(), "feeding frenzy"))
        continue;
      obs[i]->adjust_xp(5000);
    }
  for (i=0;i<sizeof(demons);i++) {
    obs = all_inventory(demons[i]);
    for (j=0;j<sizeof(obs);j++)
      obs[j]->dest_me();
    demons[i]->dest_me();
  }
  demons = 0;
}
mixed bingle_bit(object ob) {
  return (mixed)ob->query_property("feeding_frenzy");
}
int bongle_array(object ob) {
  return (int)ob->query_property("feeding_frenzy") != 0;
}

==================================================
FILE: misc/shop_owners_guide.c
==================================================

inherit "/std/book_dir";
void setup() {
  set_name("book");
  set_short("brilliant vermillion book");
  add_adjective(({"brilliant", "vermillion"}));
  add_alias("guide");
  set_long("This is a brilliant vermillion coloured book with lots of "
           "pictures of money on the front cover.\n");
  set_read_mess("                   DIY\n\n"
                "          A guide for shop owners.\n");
  set_main_plural("brilliant vermillion books");
  set_weight(10);
  set_value(10);
  set_book_language( "general");
  set_book_dir("/save/books/shop_owner/page");
  set_open_page(0);
  set_ignore_saved_pages(1);
}
int do_tear() {
  return 0;
}
int query_binding_force() {
  return 100;
}

==================================================
FILE: misc/suggestion_box.c
==================================================

inherit "/std/object";
int do_fill();
string _savedir, _savefile;
void setup() {
  set_short( "suggestion box" );
  set_long( "This is a suggestion box.  It is sitting on a pole which puts"
	    " the box at a convienient height for writing.  It has a pile "
	    "of small papers on it on which you can write suggestions.  "
	    "There is a slot in the top for stuffing the suggestion in "
	    "when you're done.\n" );
  set_name( "box" );
  set_main_plural( "boxes" );
  set_read_mess( "\nPlease fill in a suggestion form", "common" );
  add_property( "there", "sitting in the middle of the floor" );
  set_weight( 1000 );
  reset_get();
}
void init() {
  add_command( "fill", "in a suggestion form", (: do_fill() :) );
}
void set_save_file ( string file ) {
  _savefile = file;
  return;
}
void set_save_dir ( string dir ) {
  _savedir = dir;
  return;
}
string query_save_file () {
  return _savefile;
}
string query_save_dir () {
  return _savedir;
}
int do_fill() {
  tell_object( this_player(), "Please fill in your suggestion below.\n" );
  this_player()->do_edit( 0, "end_suggestion", this_object() );
  add_succeeded_mess( ({"", "$N fill$s in a suggestion form and stuff$s "
			  "it in the box.\n" }) );
  return 1;
}
void end_suggestion( string text ) {
  string player, file;
  if( _savefile ) {
    file = _savefile;
  } else if( _savedir ) {
    player = previous_object()->query_name();
    file = sprintf( query_save_dir() + "/%s-%d.txt", player, time() );
  }
  debug_printf( "File: %s", file );
  if( !(unguarded( (: write_file, file, text :) ) ) ) {
    tell_object( previous_object(), "Sorry, your suggestion was not recorded."
		 "  Please use the 'bug object' command to bug report the "
		 "suggestion box.\n" );
    return;
  }
  tell_object( previous_object(), "You fill in a suggestion form and stuff "
	       "it in the box.\n" );
}

==================================================
FILE: misc/teddy.c
==================================================

#define TP this_player()
#define TPCAP this_player()->one_short()
#define TO this_object()
inherit "std/object";
void setup(){
   set_name("bear");
   set_short("teddy bear");
   add_alias("teddy");
   add_adjective("teddy");
   set_long("This is a cute and cuddly teddy bear.  Just the sort to give "
     +"someone you love to remind them of you.  It looks very soft and "
     +"huggable.\n");
   set_weight(10);
   set_value(25);
   set_main_plural("teddy bears");
   add_plural(({"bears", "teddys"}));
}
void init() {
   TP->add_command("hug", TO);
   TP->add_command("cuddle", TO);
}
int do_hug() {
   write("You hug the teddy bear close to you and feel all warm and fuzzy "
     "inside.\n");
   say(TP->one_short()+ " hugs the teddy bear close and smiles happily.\n");
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}
int do_cuddle() {
  do_hug();
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}

==================================================
FILE: misc/terrain_shovel.c
==================================================

#include <dirs.h>
#include <terrain.h>
inherit "/std/object";
void setup() {
   set_name( "shovel" );
   set_short( "ceremonial shovel" );
   add_adjective( "ceremonial" );
   set_long( "This is a small ceremonial shovel, carried by those "+
         "responsible for the care, upkeep and expansion of "+
         "dungeons.\n" );
}
void init() {
   if ( this_player()->query_creator() ) {
      add_action( "do_add", "add" );
      add_action( "do_remove", "remove" );
      add_action( "do_visit", "visit" );
   }
}
int do_add( string words ) {
   int i, distance, level, *new_co_ord, *old_co_ord, *vector;
   string direc, file, terrain, type;
   object room, *things;
   if ( !words )
      return notify_fail( "Add what?\n" );
   if ( sscanf( words, "%s %s %s", type, file, direc ) != 3 )
      return notify_fail( "Syntax: add fixed|floating <file> <direction>\n" );
   i = member_array( direc, STD_ORDERS );
   if ( i == -1 )
      return notify_fail( capitalize( direc ) +" is not a valid "+
            "direction.\n" );
   room = environment( this_player() );
   if ( room->query_exit( direc ) )
      return notify_fail( "There is already an exit to the "+
            direc +".\n" );
   vector = STD_ORDERS[ i + 1 ];
   if ( file_size( file +".c" ) < 0 )
      return notify_fail( capitalize( file ) +" does not exist.\n" );
   file->force_load();
   if ( !find_object( file ) )
      return notify_fail( capitalize( file ) +" will not load.\n" );
   distance = (int)file->query_room_size() +
         (int)room->query_room_size();
   old_co_ord = (int *)room->query_co_ord();
   if ( sizeof( old_co_ord ) != 3 )
      return notify_fail( "Environment does not have coordinates.\n" );
   new_co_ord = allocate( 3 );
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = old_co_ord[ i ] - distance * vector[ i ];
   terrain = (string)room->query_property( "terrain name" );
   if ( !terrain )
      return notify_fail( "Environment is not in the terrain "+
            "handling system.\n" );
   switch( type ) {
      case "fixed" :
         i = (int)TERRAIN_MAP->add_fixed_location( terrain,
               file, new_co_ord );
         break;
      case "floating" :
         i = (int)TERRAIN_MAP->add_floating_location( terrain,
               file, new_co_ord, level );
         break;
      default :
         return notify_fail( "Type must be fixed or floating.\n" );
   }
   if ( !i )
      return notify_fail( "Failed to add "+ file +" ("+ type +
            ") to "+ terrain +" at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
   write( "Added "+ file +" ("+ type +") to "+ terrain +" at "+
         new_co_ord[ 0 ] +", "+ new_co_ord[ 1 ] +", "+
         new_co_ord[ 2 ] +".\n" );
   if ( type == "fixed" )
      file->dest_me();
   TERRAIN_MAP->clear_connections( terrain );
   TERRAIN_MAP->delete_cloned_location( terrain, file_name( room ) );
   things = all_inventory( room );
   things->move( "/room/void" );
   room->dest_me();
   room = (object)TERRAIN_MAP->find_location( terrain, old_co_ord );
   things->move( room );
   return 1;
}
int do_remove() {
   write( "This function has not been written yet.\n" );
   return 1;
}
int do_visit( string words ) {
   int x, y, z;
   string terrain;
   object room;
   if ( !words )
      return notify_fail( "Visit where?\n" );
   if ( sscanf( words, "%s %d %d %d", terrain, x, y, z ) != 4 )
      return notify_fail( "Syntax: visit <terrain> <x co-ord> "+
            "<y co-ord> <z co-ord>\n" );
   room = (object)TERRAIN_MAP->find_location( terrain, ({ x, y, z }) );
   if ( !objectp( room ) )
      return notify_fail( "There is no location at ("+ x +","+ y +","+ z +
            ") in \""+ terrain +"\".\n" );
   this_player()->move_with_look( room, "There is a strange smell, like "+
         "freshly broken earth, and $N appear$s.", "With a squelch, "+
         "$N vanish$s." );
   return 1;
}

==================================================
FILE: misc/tin_of_paint.c
==================================================

inherit "/obj/vessel";
#define VOLUME 5000
private nosave string _colour;
varargs int do_paint(string, object);
void setup() {
  set_name( "tin" );
  set_short( "tin of paint" );
  set_main_plural( "tins of paint");
  add_adjective( ({ "tin", "of"}));
  add_alias(({"paint"}));
  set_long( "A tin of paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
  set_leak_rate( 0 );
  set_max_volume( VOLUME );
  set_value( 30 );
  set_weight( 10 );
  set_max_weight( 30 );
}
void setup_attribs() {
  set_short( "tin of " + _colour + " paint" );
  set_main_plural( "tins of " + _colour + " paint");
  add_adjective( ({ _colour}));
  set_long( "A tin of " + _colour + " paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
}
void make_tin( string colour ) {
  object liquid;
  liquid = clone_object( "/obj/reagents/generic_liquid.ob" );
  liquid->set_name( "paint" );
  liquid->set_short( colour + " paint" );
  liquid->add_adjective(({colour }));
  liquid->set_amount( VOLUME );
  liquid->set_continuous();
  liquid->set_long( "This is " + colour + " paint, it's thick and gloopy.\n");
  liquid->set_pile_name( "puddle" );
  liquid->add_eat_effect( "/std/effects/ingested/poison", 10 );
  liquid->move( this_object() );
  set_closed();
  _colour = colour;
  setup_attribs();
}
void init() {
  ::init();
  this_player()->add_command("paint", this_object(),
           "<indirect:object:here'cardinal direction'> with <direct:object'paint'>",
                        (: do_paint( $4[0] ) :));
  this_player()->add_command("paint", this_object(),
                        "<string'part'> on <indirect:object:here> with <direct:object'paint'>",
                        (: do_paint( $4[0], $1[0] ) :));
  this_player()->add_command("paint", this_object(),
            "<indirect:object:here> help",
            (: do_paint( 0, $1[0] ) :));
}
varargs int do_paint(string indirect, object target) {
  object *obs;
  if(!indirect && target) {
      if(function_exists("what_to_paint", target))
          printf(target->what_to_paint());
      else
          printf("Help: paint " + target->short() + " with paint\n");
      return 1;
  }
  obs = match_objects_for_existence("paint", this_object());
  if(!query_volume() || !sizeof(obs)) {
    this_player()->add_failed_mess(this_object(), "$D appears to be empty.\n",
                                   ({ }));
    return 0;
  }
  if(query_closed()) {
    this_player()->add_failed_mess(this_object(), "$D is closed.\n", ({ }));
    return 0;
  }
  if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
                    (: $1->id("paint brush") :)))) {
    this_player()->add_failed_mess(this_object(), "You must be holding a "
                                   "paint brush to paint the walls.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->test_occupier(this_player()->query_name())) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  if(target) {
      if(!target->query_short()) return 0;
          if(!function_exists("decorate_part", target)) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                indirect + " on the " + target->query_short() + "!\n", ({ }));
                  return 0;
          }
          if(!target->decorate_part( indirect, obs[0]->query_short() )) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                                                        indirect + ".\n", ({ }));
                  return 0;
          }
          this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " on the " + target->query_short() +
                                                                        " with the brush using light, smooth strokes.\n", ({ }));
          return 1;
  }
  if(!function_exists("decorate_surface", environment(this_player()))) {
    this_player()->add_failed_mess(this_object(), "You can't $V the walls "
                                   "here.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->
     decorate_surface(indirect, "covered with " + obs[0]->query_short())) {
    this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                   indirect + ".\n", ({ }));
    return 0;
  }
  remove_volume(query_volume());
  this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " with $D using "
                                    "broad, smooth strokes.\n", ({ }));
  return 1;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
          "colour" : _colour,
          ]);
}
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["colour"]))
    _colour = args["colour"];
  if(_colour)
    setup_attribs();
}

==================================================
FILE: misc/top_clubs.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top club table" );
   set_long("This is a table listing those clubs that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "club", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   string *g_sorted;
   mapping g_info;
   stuff = TOP_TEN_HANDLER->query_club_info();
   str = "The club with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         ;
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the club must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_families.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top family table" );
   set_long("This is a table listing those families that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "family", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   mapping g_info;
   string *g_sorted;
   stuff = TOP_TEN_HANDLER->query_family_info();
   str = "The family with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         "Most average relationships: " +
         club_name(stuff[TOP_TEN_MOST_RELATIONSHIPS]) + "\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the family must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_ten_tables.c
==================================================

#include <top_ten_tables.h>
inherit "/std/object";
string generate_list( mixed *args );
string generate_table_message();
nosave string table_name;
nosave string language = "morporkian";
void setup() {
   table_name = 0;
   set_name( "table" );
   set_short( "top ten table" );
   set_long( "This is a perfectly rectangular wooden board, "
     "nailed to another piece of wood.\n" );
   add_adjective( ({ "top", "ten", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out( "setup_read_mess", 5 );
   call_out("dest_me", 30);
}
string query_table_name() { return table_name; }
void set_table_name( string word ) { table_name = word; }
void set_language( string lang ) {
  language = lang;
}
void setup_read_mess() {
   add_read_mess((: generate_table_message() :), 0, language, 0);
}
string generate_table_message() {
   string long;
   mixed *args;
   long = "\nHigh Score Table: ";
   args = (mixed *)TOP_TEN_HANDLER->query_ordered_table( table_name );
   if ( !table_name ) {
      long += "All Players";
      if ( !sizeof( args ) )
         return long +": There is no overall top ten at present.\n";
   } else {
      if ( file_size( "/std/guilds/"+ table_name +".c" ) < 0 )
         return "*Barf!* Can't find /std/guilds/"+ table_name +".\n";
      long += capitalize( (string)( "/std/guilds/"+ table_name )->
                     query_name() ) + "' Guild";
      if ( !sizeof( args ) )
         return long +": There is no top ten for this guild at present.\n";
   }
   return sprintf( "%|*s\n", table_name ? 40 : 50, long ) +
          sprintf( "%|*s\n", table_name ? 40 : 50, "Sorted by rating" ) +
          sprintf( "%|*s\n\n", table_name ? 40 : 50,
                   "-=- " + ctime(time()) + " -=-" ) +
          generate_list(args) + "\n";
}
string convert_age( int number ) {
   if ( number > 86400 )
      return ( number / 86400 ) +"D";
   if ( number > 3600 )
      return ( number / 3600 ) +"h";
   if ( number > 60 )
      return ( number / 60 ) +"m";
   return number +"s";
}
string generate_list( mixed *args ) {
   int i, number, sum;
   string format, list;
   if ( table_name )
      format = "  %2d. %-13s: level %4d  %5s";
   else
      format = "  %2d. %-23s: level %4d  %5s";
   format += "\n";
   list = "";
   number = sizeof( args );
   sum = 0;
   for ( i = 0; i < number; i++ )  {
      list += sprintf( format, i + 1, capitalize( args[ i ][ TOP_TEN_NAME ] ),
            args[ i ][ TOP_TEN_LEVEL ],
            convert_age( args[ i ][ TOP_TEN_AGE ] ) );
      if ( i > 0  &&  i < number - 1 )  {
         sum += args[i][TOP_TEN_RATING];
      }
   }
   return list;
}

==================================================
FILE: misc/torch.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
#define BRIGHTNESS 30
#define MAX_FUEL 2000
#define FUEL_PER_TICK ( FUEL_TIME * 2 )
private int amount_of_fuel;
private int is_lit;
int finish_it();
void setup_shorts();
void create() {
   object::create();
   holdable::create();
}
void setup() {
   amount_of_fuel = MAX_FUEL;
   set_name( "torch" );
   add_plural( "torches" );
   setup_shorts();
   add_help_file("torch");
   set_long( function() {
      string str;
      if ( is_lit && amount_of_fuel) {
         call_out( (: setup_shorts() :), 2 );
         str = "This is a fire burning out of control on the end "
            "of a stick of wood.  There is a lot of smoke coming "
            "off the fire, of the kind that, no matter which "
            "way you turn, will go up your nose.";
         switch ( amount_of_fuel / ( MAX_FUEL / 10 ) ) {
          case 10 :
          case 9  :
            return str+"  The torch looks brand new, it will burn for "
               "ages yet.\n";
          case 8 :
          case 7 :
          case 6 :
            return str+"  Not yet burning for very long, this torch is "
               "pretty happy with itself.  It doesn't seem "
               "to care about its short life span.\n";
          case 5 :
          case 4 :
            return str+"  The torch is happily burning.  It is in the "
               "prime of its life.\n";
          case 3 :
            return str+"  The torch has a little way to go yet, as it is "
               "now burning the light wood.\n";
          case 2 :
            return str+"  It looks like this torch won't "
               "last much longer.  Buying a new one would "
               "probably be a good investment.\n";
          case 1 :
          case 0 :
            return str+"  The torch is spluttering, there are huge "
               "amounts of smoke coming off it.  It looks like "
               "it is about to go out.\n";
         }
      }
      if ( amount_of_fuel >= MAX_FUEL )
         return "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end of it, and it looks as "
         "though it might be possible to light them.  The dirty rags "
         "have some sort of stuff covering them, probably "
         "to make them burn better.\n";
      if ( amount_of_fuel > MAX_FUEL / 2 )
         return "Someone has cut down a tree, chopped it up into smaller "
         "chunks and then wrapped the end in some rags.  "
         "The rags are blackened and it looks like someone set "
         "fire to them.  Perhaps you can too?\n";
      str = "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end.  ";
      if ( !amount_of_fuel )
         return str +"The end is completely blackened.  You would "
         "have to be extremely clever to get this torch "
         "going again.\n";
      switch (amount_of_fuel/(MAX_FUEL/10)) {
       case 5 :
       case 4 :
         return str +"The end has been blackened quite a bit, "
            "but it looks like there is a fair bit of "
            "go still left in it.\n";
       case 3 :
       case 2 :
         return str +"A few rags here and there cling to a meager "
            "existence.  You could set fire to them and "
            "make their life hell for a little while, but "
            "not for very long.\n";
       case 1 :
       case 0 :
         return str +"You can just see the remains of some rags "
            "attached to the blackened and burnt end of "
            "the torch.  It will last only for a short while "
            "longer.\n";
      }
      return "Whoops.  Tell a creator if you see this.\n";
   }
            );
   is_lit = 0;
   set_weight( 6 );
   set_value( 50 );
}
void set_fuel(int f) {
   amount_of_fuel = f;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   setup_shorts();
}
void init() {
  this_player()->add_command( "light", this_object() );
  this_player()->add_command( "extinguish", this_object() );
  this_player()->add_command( "dowse", this_object() );
}
void setup_shorts() {
   if ( is_lit && amount_of_fuel) {
      set_short( "lit torch" );
      set_main_plural( "lit torches" );
      remove_adjective( ({ "lightable", "burnt", "out" }) );
      add_adjective( "lit" );
   } else if ( amount_of_fuel > 0 ) {
      set_short( "lightable torch" );
      set_main_plural( "lightable torches" );
      remove_adjective( ({ "lit", "burnt", "out" }) );
      add_adjective( "lightable" );
   } else {
      set_short( "burnt torch" );
      set_main_plural( "burnt torches" );
      remove_adjective( ({ "lit", "lightable" }) );
      add_adjective( ({ "burnt", "out" }) );
   }
}
int do_light() {
   if (environment(this_object()) != this_player()) {
      this_player()->add_failed_mess( this_object(),
                                     "You are not carrying $D.\n", ({ }) );
      return 0;
   }
   if (amount_of_fuel <= 0) {
      this_player()->add_failed_mess( this_object(), "$D is burnt out.\n",
                                     ({ }) );
      return 0;
   }
   if (is_lit) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if (!query_holder() &&
       !sizeof( this_object()->hold_item( this_player(), -1 ) ) ) {
     this_player()->add_failed_mess( this_object(), "Unable to hold $D, "
         "your arms are probably full.\n", ({ }) );
      return 0;
   }
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( "setup_shorts", 2);
   return 1;
}
void out_of_fuel() {
   is_lit = amount_of_fuel = 0;
   set_light( 0 );
   set_value( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   tell_room( environment(), one_short() +" splutters violently "
     "for the last time before it crumbles to dust.\n" );
   call_out( "finish_it", 2 );
}
void do_warning() {
   tell_room( environment(), poss_short() +" starts to sputter and smoke a "
             "lot as it is now burning the light wood.  It is on its last "
             "legs.\n");
   return;
}
void consume_fuel() {
   amount_of_fuel -= FUEL_PER_TICK;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   switch ( amount_of_fuel ) {
    case (200-FUEL_PER_TICK) .. 200:
      do_warning();
      break;
    case 0:
      out_of_fuel();
      break;
    default:
   }
}
int do_extinguish(object *, string, string, string) {
   if ( !is_lit && objectp( this_player() ) ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }) );
      return 0;
   } else if ( !is_lit ) {
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   call_out( "setup_shorts", 2);
   return 1;
}
int do_dowse() {
   return do_extinguish(({ }), 0, 0, 0);
}
void dest_me() {
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   holdable::dest_me();
   object::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , amount_of_fuel, }),
    ({ "is lit", is_lit, }),
   });
}
mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "amount of fuel" : amount_of_fuel,
            "hold" : holdable::query_dynamic_auto_load(),
            "is lit" : is_lit,
          ]);
}
int held_this_item(int type, object holder, mixed arg) {
   if (!type) {
      if (holder && is_lit) {
         tell_object( holder,
                     "You extinguish the "+ short() +" as you put it down.\n");
         tell_room( environment(holder ),
                   holder->short() +" extinguishes the "+
                   short() +" as "+ holder->query_pronoun()
                   +" puts it down.\n", ({ holder }));
      }
      do_extinguish( ({ }), "", "", "");
   } else if (type == 2) {
      if (arg && holder && amount_of_fuel > 0) {
         set_light( BRIGHTNESS );
         FUEL_HANDLER->add_burner( this_object() );
         is_lit = 1;
      } else {
         is_lit = 0;
      }
      setup_shorts();
   }
   return 1;
}
void init_dynamic_arg( mapping arg ) {
   amount_of_fuel = arg["amount of fuel"];
   is_lit = arg["is lit"];
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
}
void init_static_arg(mapping arg) {
}
mapping query_static_auto_load() {
   return 0;
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}
void self_light() {
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( (: setup_shorts() :), 2);
   return;
}
  int finish_it () {
    this_object()->move( "/room/rubbish" );
    return 1;
}
int query_torch() {
  return 1;
}
int query_lit() {
  return is_lit;
}
int query_fuel() {
  return amount_of_fuel;
}

==================================================
FILE: misc/trap.c
==================================================

#include <move_failures.h>
#include <tasks.h>
inherit "/std/object";
int difficulty;
string trigger;
string description;
mixed message;
mixed effect;
void create() {
  add_help_file("door_trap");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void make_trap(int diff, string trig, string desc, mixed mess, mixed eff) {
  difficulty = diff;
  trigger = trig;
  description = desc;
  message = mess;
  effect = eff;
}
void init() {
  this_player()->add_command("rig", this_object(),
           "<indirect:object:here> with <direct:object:me>");
}
int do_rig(mixed *in_dir, string direct, string indirect, mixed *args,
             string) {
  object ob;
  object other;
  if(sizeof(in_dir) > 1) {
    this_player()->add_failed_mess(this_object(), "A trap can only be rigged "
                                   "on a single item.\n");
    return 0;
  }
  if(!difficulty) {
    this_player()->add_failed_mess(this_object(), "$D appears to be "
                                   "broken.\n");
    return 0;
  }
  ob = in_dir[0];
  if(ob->query_trap_difficulty() && ob->query_trap_armed()) {
    this_player()->add_failed_mess(this_object(),
                                   "$I already has an armed trap on it.\n",
                                   ({ in_dir[0] }));
    return 0;
  }
  if(!function_exists("setup_trap", ob, 0)) {
    this_player()->add_failed_mess(this_object(), "$I cannot be $Ved with "
                                   "$D.\n", ({ ob }));
    return 0;
  }
  if((trigger == "pick" || trigger == "unlock") &&
     (!ob->query_key() || ob->query_key() == "generic_key")) {
    this_player()->add_failed_mess(this_object(), "$I doesn't have a lock "
                                   "so $Vging it with $D which is triggered "
                                   "by " + trigger + "ing makes no sense.\n",
                                   ({ ob }));
    return 0;
  }
  switch(TASKER->perform_task(this_player(), "covert.items.traps", difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about rigging "
          "traps.%^RESET%^\n");
  case SUCCEED:
    difficulty +=
      random(this_player()->query_skill_bonus("covert.items.traps") / 10);
    break;
  default:
    if(random(difficulty) >
       this_player()->query_skill_bonus("covert.items.traps") ||
       difficulty >
       this_player()->query_skill_bonus("covert.items.traps") * 2) {
      if(arrayp(message)) {
        write(message[0]);
        say(message[1], this_player());
      } else
        write(message);
      if(intp(effect)) {
        if(effect > this_player()->query_hp())
          this_player()->do_death();
        else
          this_player()->adjust_hp(-(effect));
      } else if(arrayp(effect)) {
        switch(sizeof(effect)) {
        case 1:
          this_player()->add_effect(effect[0]);
          break;
        case 2:
          this_player()->add_effect(effect[0], effect[1]);
          break;
        default:
          this_player()->add_effect(effect[0], effect[1..]);
        }
      } else
        this_player()->add_effect(effect);
      this_object()->move("/room/rubbish");
      this_player()->add_succeeded_mess(this_object(), "As $N attempt$s to "
                                        "$V $D it goes off!\n");
      return 1;
    } else {
      difficulty -= random(difficulty -
                    this_player()->query_skill_bonus("covert.items.traps"));
    }
  }
  ob->setup_trap(difficulty, trigger, description, message, effect);
  if(function_exists("query_my_room", ob)) {
    other = load_object( (string)( ob->query_dest() ) );
    other = other->query_door_control( (string)( ob->query_other_id() ) );
    other->setup_trap(difficulty, trigger, description, message, effect);
    environment(this_player())->update_doors();
  }
  this_player()->add_succeeded_mess(this_object(), "$N carefully $V $I "
                                    "with $D.\n",
                                    ({ ob }));
  call_out("break_me", 1);
  return 1;
}
void break_me() {
  object ob;
  ob = clone_object("/std/object");
  ob->set_name("trap");
  ob->set_short("busted trap");
  ob->set_long("A broken trap.\n");
  ob->set_value(0);
  ob->set_weight(this_object()->query_weight());
  ob->move(environment());
  if(this_object()->move("/room/rubbish") != MOVE_OK)
    this_object()->dest_me();
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
            "difficulty" : difficulty,
            "trigger" : trigger,
            "description" : description,
            "message" : message,
            "effect" : effect
            ]);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping map) {
  if(!mapp(map))
    return;
  if(!undefinedp(map["::"]))
    ::init_static_arg(map["::"]);
  if(!undefinedp(map["difficulty"]))
    difficulty = map["difficulty"];
  if(!undefinedp(map["trigger"]))
    trigger = map["trigger"];
  if(!undefinedp(map["description"]))
    description = map["description"];
  if(!undefinedp(map["message"]))
    message = map["message"];
  if(!undefinedp(map["effect"]))
    effect = map["effect"];
}

==================================================
FILE: misc/tray.c
==================================================

#include <move_failures.h>
inherit "/std/surface";
inherit "/std/basic/holdable";
inherit "/std/basic/wearable";
void create() {
  wearable::create();
  holdable::create();
  surface::create();
}
void setup() {
  set_name( "tray" );
  set_short( "wooden tray" );
  set_long( "This is a small wooden tray, similar in style to the ones used by "
    "many vendors and travelling salespeople. Only a small quantity of items will "
    "fit on top of it.\n" );
  add_adjective(({ "small", "wooden" }));
  set_material("wood");
  set_weight(5);
  set_max_weight(40);
  set_no_limbs(2);
  set_type("sash");
  set_cond(1000);
  set_max_cond(1000);
  add_wear_effect( "/std/effects/attached/single_shoulder" );
}
string long( string word, int dark ) {
  return surface::long() + wearable::long();
}
varargs int move( mixed dir, string messin, string messout ) {
  if ( holdable::move( dir, messin, messout ) == MOVE_OK ) {
	  return surface::move( dir, messin, messout );
  }
  return MOVE_NO_UNHOLD;
}
mapping query_static_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_static_auto_load();
  map["surface"] = surface::query_static_auto_load();
  map["wearable"] = wearable::query_static_auto_load();
  return map;
}
void init_static_arg( mapping map ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_static_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_static_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_static_arg( map["wearable"] );
}
void dest_me() {
  holdable::dest_me();
  surface::dest_me();
}
mapping query_dynamic_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_dynamic_auto_load();
  map["surface"] = surface::query_dynamic_auto_load();
  map["wearable"] = wearable::query_dynamic_auto_load();
  return map;
}
varargs void init_dynamic_arg( mapping map, mixed new_arg ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_dynamic_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_dynamic_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_dynamic_arg( map["wearable"] );
}
mixed stats() {
	return surface::stats() + wearable::stats();
}

==================================================
FILE: misc/wallpaper.c
==================================================

inherit "/std/object";
private nosave string _design;
varargs int do_paper(string indirect, object pot);
void setup() {
    set_name( "wallpaper" );
    set_short( "roll of wallpaper" );
    set_main_plural( "rolls of wallpaper");
    add_adjective( ({ "roll", "of"}));
    add_plural_adjective("rolls");
    add_alias(({"paper"}));
    set_long( "This is a large roll of wallpaper, probably enough to "
        "cover a single wall completely.\n");
    set_value( 480 );
    set_weight( 10 );
}
void make_roll( string design ) {
    _design = design;
    set_short( "roll of " + _design + " wallpaper" );
    set_main_plural( "rolls of " + _design + " wallpaper");
    add_adjective( ({ _design })) ;
    set_long( "This is a large roll of " + _design + " wallpaper.  It "
        "looks like there's just enough of it to cover a single wall "
        "completely.  If you had some wallpaper glue you could probably "
        "paste it to the wall.\n");
}
void init() {
    this_player()->add_command("paste", this_object(),
       "<direct:object> to <indirect:object:here'cardinal direction'> using <indirect:object'pot'>", (: do_paper( $4[1], $1[1][0] ) :));
}
string query_paper_mess() {
    if( _design ) {
        return _design + " wallpaper";
    }
    else {
        return "strangely featureless wallpaper";
    }
}
varargs int do_paper(string indirect, object pot) {
    object *obs;
    if(!indirect && pot) {
        if(function_exists("what_to_paint", pot))
            printf(pot->what_to_paint());
        else
            printf("Help: paste " + pot->short() + " with wallpaper\n");
            return 1;
    }
    obs = match_objects_for_existence("glue", pot);
    if(pot->query_closed()) {
        this_player()->add_failed_mess(this_object(), "$I is "
            "closed.\n", ({ pot }));
        return 0;
    }
    if(!pot->query_volume(obs) || !sizeof(obs)) {
        this_player()->add_failed_mess(this_object(), "$I appears to "
            "be empty.\n", ({ pot }));
        return 0;
    }
    if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
        (: $1->id("brush") :)))) {
        this_player()->add_failed_mess(this_object(), "You must be holding a "
            "paint brush to paint the walls with glue.\n", ({ }));
        return 0;
    }
    if(!environment( this_player() )->test_occupier( this_player()->
        query_name() ) ) {
        this_player()->add_failed_mess(this_object(), "You don't own this "
            "house.\n", ({ }));
        return 0;
    }
    if(!function_exists("decorate_surface", environment(this_player()))) {
        this_player()->add_failed_mess(this_object(), "You can't $V the "
            "walls here.\n", ({ }));
        return 0;
    }
    if(!environment(this_player())->decorate_surface(indirect,
        "papered with " + query_paper_mess())) {
        this_player()->add_failed_mess(this_object(), "You can't $V the $D"
            " to the " + indirect + " using $I for some reason.\n",
            ({ pot }));
        return 0;
    }
    pot->remove_volume(pot->query_volume());
    this_object()->move("/room/rubbish");
    this_player()->add_succeeded_mess(this_object(), "$N $V $D to the " +
        indirect + ", dawbing it with paste from $I and pressing it firmly "
        "against the surface.\n", ({ pot }) );
    return 1;
}
mapping int_query_static_auto_load() {
    mapping tmp;
    tmp = ::int_query_static_auto_load();
    return ([ "::" : tmp,
              "design" : _design,
            ]);
}
mapping query_static_auto_load() {
    if ( base_name(this_object()) + ".c" == __FILE__ )
        return int_query_static_auto_load();
    return ([ ]);
}
void init_static_arg(mapping args) {
    if (args["::"])
    ::init_static_arg(args["::"]);
    if(!undefinedp(args["design"]))
        _design = args["design"];
    if(_design)
        make_roll(_design);
}

==================================================
FILE: misc/wallpaper_glue.c
==================================================

inherit "/obj/vessel";
#define VOLUME 5000
object add_glue();
void setup() {
    set_name("glue");
    set_short("pot of wallpapering glue");
    add_adjective( ({ "pot", "of", "wallpapering", "wallpaper" }) );
    add_alias("pot");
    add_plural("pots");
    set_max_volume(VOLUME);
    set_long("This is a small pot of wallpapering glue, essential "
        "for anybody who's going to be doing anything involving "
        "sticking paper to walls or playing mean tricks on their "
        "friends.\n");
    set_value(480);
    set_closed();
}
object add_glue() {
    object glue;
    glue = clone_object( "/obj/reagents/generic_liquid.ob" );
    glue->set_name( "glue" );
    glue->set_short( "sticky white wallpapering glue" );
    glue->add_adjective( ({ "sticky", "white", "wallpapering",
        "wallpaper"  }));
    glue->set_amount( VOLUME );
    glue->set_continuous();
    glue->set_long( "This is some thick and gloopy wallpapering glue.  "
        "Along with some wallpaper and a brush, you could probably "
        "do some fine home decorating.\n");
    glue->set_pile_name( "puddle" );
    glue->add_eat_effect( "/std/effects/ingested/poison", 10 );
    glue->move( this_object() );
    return glue;
}

==================================================
FILE: misc/watch.c
==================================================

inherit "/obj/clock";
int our_offset,
    their_offset,
    last_time,
    cur_alarm,
    offset_alarm,
    alarm;
mixed *alarms;
string *alarm_write,
       alarm_name;
object our_player;
varargs int get_text(string line);
void setup() {
  set_name("watch");
  add_adjective("demonic");
  add_alias("watch");
  set_main_plural("demonic watches");
  set_short("demonic watch");
  set_long("A small wrist attackable living quaters for a demon "+
           "the demon looks pretty harried about giveing out the "+
           "time all the time, and the pay is lousy..\n");
  set_value(20000);
  our_offset = 0;
  their_offset = 8;
  last_time = time();
  call_out("check_alarm",60);
  alarms = ({ });
}
void init() {
  add_command("time", "");
  add_command("gmt", "<word'offset'>", (:this_object()->set_gmt($4[0]):));
  add_command("use", "<direct:object>", (:this_object()->use():));
  this_player()->add_command("read", this_object());
}
int use(string arg) {
  if (!alarms)
    alarms = ({ });
  printf("%-=80s","You look into the watch and fiddle with several buttons, "+
                  "Finally a light lights up in the top corner say you have "+
                  "the security clearance to modify the settings.\n"+
                  "You can \"set\" an alarm \"remove\" an alarm \"list\" the "+
                  "set alarms. You can \"quit\" also.\n");
  write("What do you wish to do ? ");
  input_to("the_command");
  return 1;
}
int the_command(string arg) {
  string s1;
  int i;
  if (arg == "quit") {
    write("Thank you for using this wonderful watch.\n");
    return 1;
  }
  if (sscanf(arg,"set%s",s1)) {
    int hour, min;
    string name;
    if (sscanf(s1," %s %d:%d%s",name,hour,min,s1)!=4)
      write("Usage: set <name> <hour>:<min> [+]\n");
    else {
      if ((i=member_array(name,alarms))<0)
        alarms += ({ name, hour, min, 0 });
      else
        if (i%4)
          write("Oooooopps, you cannot use that name as an alarm\n");
        else {
          alarms[i+1] = hour;
          alarms[i+2] = min;
        }
      if (s1 == " +") {
        if (i==-1)
          i = sizeof(alarms)-4;
        cur_alarm = i;
        get_text();
        return 1;
      }
    }
  }
  if (sscanf(arg,"remove%s",s1)) {
    string frog;
    if (sscanf(s1," %s",frog)!=1)
      write("Usage: remove <name>\n");
    else
      if ((i=member_array(frog,alarms))<0)
        write("You must remove an existing alarm\n");
      else
        if (i%4)
          write("Ohhh dear.\n");
        else {
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
        }
  }
  if (sscanf(arg,"list%s",s1)) {
    string chicken;
    if (sscanf(s1," %s",chicken)!=1) {
      for (i=0;i<sizeof(alarms);i+=4) {
        write("Alarm "+alarms[i]+" is set for "+alarms[i+1]+":"+alarms[i+2]+"\n");
      }
    } else {
      if ((i=member_array(chicken,alarms))<0)
        write("That alarm does not exist.\n");
      else
        if (i%4)
          write("Bing basicly");
        else
          write("You have set alarm "+chicken+" to go off at "+alarms[i+1]+":"+
                 alarms[i+2]+"\n");
    }
  }
  return 1;
}
varargs int get_text(string line) {
   string text;
  if (!line) {
    text = "";
    write(sprintf("%-=80s","Please enter the text you wish to be displayed "+
          "when the alarm goes off (. to finish)"));
  } else if (line==".") {
    alarms[cur_alarm+3] = text+"\n";
    write("What do you wish to do ? ");
    input_to("the_command");
    return 1;
  } else
    text += line+"\n";
  write("] ");
  input_to("get_text");
  return 1;
}
mixed query_auto_load() {
  mixed ret;
  if (!alarms)
    alarms = ({ });
  ret = ({ their_offset, alarms });
  return ret;
}
void init_arg(mixed *arg) {
  their_offset = arg[0];
  alarms = arg[1];
  if (!alarms)
    alarms = ({ });
}
void check_alarm() {
   int the_time, offset, i;
   int tmp;
   the_time = time();
   offset = (the_time/(3600*24))*3600*24 - our_offset*3600;
   for (i=0;i<sizeof(alarms);i+=4) {
      tmp = offset + (alarms[i+1]-our_offset+their_offset)*3600 + alarms[i+2]*60;
      if (the_time>tmp && tmp>last_time) {
         alarm = 6;
         alarm_name = alarms[i];
         if (alarms[i+3])
         alarm_write = explode(alarms[i+3],"\n");
      else
         alarm_write = ({
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
         });
         offset_alarm = 0;
         set_heart_beat(1);
      }
   }
   last_time = the_time;
   call_out("check_alarm",60);
}
void heart_beat() {
   if (our_player)
     our_player->event_say(this_object(), "The watch goes: "+
                           alarm_write[offset_alarm++]+"\n");
   if (offset_alarm>sizeof(alarm_write))
     set_heart_beat(0);
}
int move(object ob) {
  int i;
  i = ::move(ob);
  our_player = environment();
  return i;
}

==================================================
FILE: misc/wearable_corpse.c
==================================================

inherit "/obj/corpse";
inherit "/std/basic/wearable";
void create() {
  corpse::create();
  wearable::create();
}
string long( string word, int dark ) {
  return corpse::long( word, dark ) + wearable::long( word, dark );
}
void init_static_arg( mapping map ) {
   if ( map[ "corpse" ] )
      corpse::init_static_arg( map[ "corpse" ] );
   if ( map[ "wearable" ] )
      corpse::init_static_arg( map[ "wearable" ] );
}
void init_dynamic_arg( mapping map ) {
 if ( !undefinedp( map[ "corpse" ] ) )
      corpse::init_dynamic_arg( map[ "corpse" ] );
 if ( !undefinedp( map[ "wearable" ] ) )
      wearable::init_dynamic_arg( map[ "wearable" ] );
}
mapping query_static_auto_load() {
   return ([
      "corpse" : corpse::query_static_auto_load(),
      "wearable" : wearable::query_static_auto_load(),
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "corpse" : corpse::query_dynamic_auto_load(),
      "wearable" : wearable::query_dynamic_auto_load()
   ]);
}
mixed *stats() {
	return corpse::stats() + wearable::stats();
}

==================================================
FILE: misc/wearable_pet.c
==================================================

#include <gossip.h>
#include <armoury.h>
#define CHAT_FREQ 200
inherit "/obj/monster";
inherit "/std/basic/wearable";
varargs int wear_remove_function(object);
void expand_mon_string( mixed str ) {
    object room;
    string *args, *stuff;
    if ( functionp( str ) ) {
        evaluate( str, this_object() );
    }
    if(strsrch(str, "$name$") > 0) {
        stuff = GOSSIP_HANDLER->query_random_gossip();
        str = replace(str, ({ "$name$", stuff[0],
            "$mess$", stuff[1] }));
    }
    str = expand_string(str, 0);
    switch( str[0] ) {
    case '#':
        args = explode(str[ 1..], ":");
        switch (sizeof(args)) {
        case 1 :
            call_other( this_object(), args[0] );
            return;
        case 2 :
            call_other( this_object(), args[0], args[1] );
            return;
        case 3 :
            call_other( this_object(), args[0], args[1], args[2] );
            return;
        case 4 :
            call_other( this_object(), args[0], args[1], args[2],
              args[3] );
            return;
        default :
            call_other( this_object(), args[0], args[1], args[2],
              args[3], args[4] );
            return;
        }
    case ':' :
        str = str[1..];
        break;
    case '\'' :
        str = "says " + str;
        break;
    case '"' :
        str = "says loudly " + str;
        break;
    }
    if(living(environment())) {
        room = environment(environment());
        str = capitalize(environment()->poss_short()) +" "
        + this_object()->query_short()  + " " + str;
        tell_room( room,  str +"\n" );
    } else {
        room = environment();
        str = "The " + this_object()->query_short() + " " + str;
        tell_room( room, expand_string( str, 0 ) +"\n" );
    }
}
int check_anyone_here() {
object holder, *people;
    if(!(::check_anyone_here()))
        if ( living(holder = environment(this_object())) ) {
            if(environment(holder) &&
                    sizeof(people = all_inventory(environment(holder))))
            if(sizeof(filter(people, (: userp($1) :))))
                return 1;
            else
                return 0;
    }
    return ::check_anyone_here();
}
varargs int wear_remove_function(object pet, object thing) {
    object *wearing;
    object worn;
    if(pet && thing) {
        wearing = this_player()->query_wearing();
        foreach(worn in wearing) {
            if( (worn != previous_object())
                && inherits("/obj/misc/wearable_pet", worn)) {
                previous_object()->init_command(sprintf("kill %O",worn));
            }
        }
    }
}
void create() {
    wearable::create();
    monster::create();
}
string long(string str, int dark) {
    return monster::long(str, dark);
}
void init_dynamic_arg(mapping map) {
    wearable::init_dynamic_arg(map);
    monster::init_dynamic_arg(map);
}
mapping query_dynamic_auto_load() {
    return
    wearable::query_dynamic_auto_load() +
    monster::query_dynamic_auto_load();
}
void init_static_arg(mapping map) {
    wearable::init_static_arg(map);
    monster::init_static_arg(map);
}
mixed query_static_auto_load() {
    wearable::query_static_auto_load() +
    monster::query_static_auto_load();
}
int query_value() {
    return query_base_value();
}
mixed stats() {
    return wearable::stats() + monster::stats();
}
void break_me() {
    do_death();
}
string cond_string() {
   health_string();
}
int adjust_cond( int i ) {
    adjust_hp( i );
}
varargs int adjust_hp( int number, object attacker, object weapon,
    string attack ) {
    if(::adjust_cond( number ))
      return ::adjust_hp( number, attacker, weapon, attack);
}
int set_max_hp( int number ) {
    set_max_cond(number);
    set_cond(number);
    set_damage_chance( 15 );
    set_lowest_cond(1);
    return ::set_max_hp(number);
}
