# Total Tokens: 99424
# Total Files Merged: 50
# Total Characters: 331569

_inherit.c
==================================================

#include <player_handler.h>
#include <mail.h>
#define LORD capitalize (load_object ("/d/" + query_domain() + "/master")->query_lord())
#define SECURE "/d/" + query_domain() + "/secure/"
#define SAVE query_interview_dir() + "candidate_list"
#define LOG query_interview_dir() + "candidate_log.txt"
#define EVENTS "/global/events"
#define DEBUG 1
inherit "/std/room";
int add_creator (string);
int do_add (string);
int do_confirm (string);
int do_flag (string, string);
varargs int do_interview (object, string);
int do_query_text(string);
int do_list();
int do_read (string);
int flush();
int query_allowed_creators();
int query_interview();
int remove_candidate (string);
int remove_creator (string);
int remove_interviewed (string);
int set_interview_dir (string);
int set_part_two (string);
int query_part_two_required();
void set_acceptance(string);
void set_confirmation(string);
void set_rejection(string);
void set_interview (int);
void set_subject (string);
void set_interviewer(mixed);
void set_cc (string*);
string query_acceptance();
string query_applicants_text();
string query_cc();
string query_confirmation();
string query_domain();
string query_interview_dir();
string query_part_two();
string query_rejection();
string query_subject();
private nosave int _interview;
private nosave int _pt_two = 1;
private nosave string _acceptance_text;
private nosave string _confirmation_text;
private nosave string _domain;
private nosave string _filename;
private nosave string _interview_dir;
private nosave string _rejection_text;
private nosave string _subject;
private nosave string *_int;
private string *_allowed_creators = ({ });
private string *candidates = ({ });
private string *_cc = ({ });
private string *interviewed = ({ });
private string *submitted = ({ });
private string *accepted = ({ });
private string *rejected = ({ });
nosave string *movie = ({
  "First of all, I'd like to congratulate you for getting this far with the "
  "application process.  The second part of the application, in addition to "
  "testing descriptive and coding skills, is also designed to help weed out "
  "those who aren't really serious about becoming creators.  :-)",
  "I should make it clear at this point that getting this far doesn't mean "
  "that you're guaranteed a promotion.  We just want to get a fuller "
  "appreciation of applicants before we reach a decision on whether you are "
  "to be promoted or not.  :-)",
  "Being a creator, regardless of the rumours or jokes to the contrary, is "
  "not an easy option.  Unlike many MUDs, being a creator on " + mud_name() + " is "
  "not the same as early retirement.  You'll be expected to spend time "
  "coming to terms with the mudlib (the body of code that is used to "
  "create the MUD) and your domain (the areas you actually adventure "
  "in).  As a creator, you have considerable power over large segments of "
  "the MUD.  The important thing is learning how to use that power "
  "responsibly.",
  "We have a number of strict rules on " + mud_name() + " .. rules you should be "
  "aware of before you make any decisions as to whether the role is for "
  "you.  Creators aren't allowed to affect the game in any measurable "
  "way.  Chatting is fine... killing NPCs at random or indiscriminately "
  "cloning cash for players is not.",
  "Being a creator is also not about policing the " + mud_name() + "   That falls "
  "under the jurisdiction of Admin and the Liaison domain.  As a coding "
  "creator your responsibilities lie in dealing with the code that "
  "makes up the MUD.  It is quite common that you will be approached by "
  "players with questions, particularly when they are no liaisons "
  "online.  In cases such as this, you are expected to refer them to "
  "a liaison or a Director.  If none are online, you are expected to ask "
  "them to wait until one is.",
  "In rare cases, it will be necessary for immediate action to be "
  "taken... in such cases, it may be acceptable for you to deal with a "
  "player problem yourself.  Always keep in mind however that you are "
  "here to code.  If it is liaising and player interaction that you think "
  "you would enjoy most, it would be best to consider an application "
  "instead to the Liaison domain.",
  "There is also a stern security policy on " + mud_name() + "   As a creator, you "
  "are expected not to violate this policy.  This means:  No passing "
  "creator information on to players, and no revealing what is posted on "
  "creator boards.   As a creator you have access to a lot of information "
  "players do not... this information should be treated as confidential "
  "unless you have Express Permission from your Leader that you may reveal "
  "it.  In short, we have to be able to trust you with sensitive "
  "information.",
  "The most important thing to remember is that you are expected to "
  "create.  If all you're really interested in is coding toys, then this "
  "role is not for you.  " + mud_name() + " is not strict in the sense of 'You have "
  "to code X rooms per day!', but you are expected to make a measurable "
  "and consistent contribution to your domain.  Your Leader and the "
  "deputy immediately supervising you will check up on this on a "
  "regular basis.",
  "It may sound like an awful lot of work to be a creator... and it is.  "
  "But at the same time, it's an awful lot of fun, and provides you with "
  "the means of giving something back to a MUD that has hopefully provided "
  "you with many hours of entertainment.  :-)",
  "Now that the movie is over, are you still willing to continue your "
  "application to be a creator?  If not, then the exit 'drum' will "
  "return you to the " + mud_name() + "   If you are, hang around a while.  :-)"
  });
void save() {
  unguarded ((: save_object (SAVE) :));
}
void load() {
  unguarded ((: restore_object (SAVE) :));
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/interview_help");
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  this_player()->add_command ("show", this_object(), "movie");
  this_player()->add_command ("stop", this_object(), "movie");
  this_player()->add_command ("interview", this_object(),
      "<indirect:living>", (: do_interview ($1[0]) :));
  this_player()->add_command ("interview", this_object(),
      "<indirect:living> with <string>", (: do_interview ($1[0], $4[1]) :));
  this_player()->add_command ("end", this_object(), "interview");
  this_player()->add_command ("add", this_object(), "<string> [as "
      "candidate]", (: do_add ($4[0]) :));
  this_player()->add_command ("query", this_object(), "applicants");
  this_player()->add_command ("query", this_object(), "permitted "
    "[creators]", (: query_allowed_creators () :));
  this_player()->add_command ("query", this_object(),
    "{confirmation|acceptance|rejection} [text]",
    (: do_query_text ($4[0]) :));
  this_player()->add_command ("delete", this_object(), "<string> [from "
      "candidates]", (: remove_candidate ($4[0]) :));
  this_player()->add_command ("clear", this_object(), "[all] candidates",
      (: flush() :));
  this_player()->add_command ("confirm", this_object(), "<string>",
      (: do_confirm ($4[0]) :));
  this_player()->add_command ("grant", this_object(), "[access to] "
    "<string>", (: add_creator ($4[0]) :));
  this_player()->add_command ("remove", this_object(), "<string> "
    "[as allowed]", (: remove_creator ($4[0]) :));
  this_player()->add_command ("flag", this_object(), "<string> as "
    "{accepted|rejected}", (: do_flag ($4[0], $4[1]) :));
  this_player()->add_command ("read", this_object(),
    "interview for <string>",
    (: do_read ($4[0]) :));
  this_player()->add_command ("list", this_object(), "interviews");
}
void set_movie (string *m) {
  movie = m;
}
int query_permitted(string name) {
  object ob = load_object("/d/" + query_domain() + "/master");
  if (!ob) {
    printf ("Erk, this room is horribly borken!!  Please set the domain "
      "correctly.\n");
    return 0;
  }
  if (member_array (ob, previous_object (-1)) != -1) {
    return 2;
  }
  if (master()->high_programmer (name)) {
    return 1;
  }
#ifdef DEBUG
  if (name == "drakkos") {
    return 1;
  }
#endif
  if ((ob->query_lord() != name) &&
    !(ob->query_deputy (name)) && (member_array (name, _allowed_creators)
    == -1)) {
        return 0;
    }
  return 1;
}
private void write_to_file (string text) {
  unguarded ((: write_file (query_interview_dir()
        +query_subject() +".txt",
        sprintf ("%-=*s", 79, $(text) + "\n")) :));
}
void event_person_say(object ob, string start, string mess, string lang) {
  if (query_subject()) {
      write_to_file (sprintf ("%s says: %s\n", ob->short(),
          mess));
  }
}
void event_emote(object ob, string mess) {
  if (query_subject()) {
      write_to_file (replace (EVENTS->convert_message (mess), ({"$C$", ""})));
  }
}
int do_show() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot show a "
        "movie!\n", ({ }));
      return 0;
  }
  else {
    call_out ("play_movie", 5, 0);
  }
  this_player()->add_succeeded_mess (this_object(), "$N dim$s the light "
          "before pulling out a grubby looking movie projector and pointing "
          "it at an empty wall.  After flicking a switch, a thin ray of "
          "light shoots at the wall.\n", ({ }));
  return 1;
}
int do_stop() {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot stop a "
        "movie!\n", ({ }));
      return 0;
  }
  do {
    i = remove_call_out ("play_movie");
  } while (i != -1);
  this_player()->add_succeeded_mess (this_object(), "$N stop$s the movie.\n",
    ({ }));
  return 1;
}
void play_movie (int i) {
  if (movie[i][0] == '#') {
    tell_room (this_object(), "The movie shows " +
      movie[i][1..sizeof(movie[i])] + "\n");
  }
  else {
    event (this_object(), "person_say", "The voice from the movie says: ",
      movie[i], "general");
  }
  if (i < sizeof (movie)) {
    call_out ("play_movie", 15, ++i);
  }
}
varargs int do_interview (object ob, string names) {
  string *inter = ({ });
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot start an "
        "interview!\n", ({ }));
      return 0;
  }
  if (query_subject()) {
      this_player()->add_failed_mess (this_object(), "You'll have to end "
          "the interview with " + query_subject() + " first.\n", ({ }));
      return 0;
  }
  else {
      if (sizeof (names)) {
        names = replace (names, ({" ", ""}));
        inter = explode (names, ",");
        tell_creator ("drakkos", "%O.\n", inter);
        inter = filter (inter, (: find_player ($1)
          && find_player ($1)->query_playtester() :));
        tell_creator ("drakkos", "%O.\n", inter);
      }
      inter += ({ this_player()->query_name() });
      set_subject (ob->query_name());
      set_interviewer (inter);
      write_to_file (sprintf ("Interview with %s, started %s.  Interview "
        "conducted by %s.\n\n", ob->short(), ctime (time()),
        query_multiple_short (inter)));
  }
  this_player()->add_succeeded_mess (this_object(), "$N press$es a button "
      "on $p tape recorder, indicating the interview is now being "
      "recorded.\n", ({ }));
  return 1;
}
int do_end() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot end an "
        "interview!\n", ({ }));
      return 0;
  }
  if (!query_subject()) {
      this_player()->add_failed_mess (this_object(), "You are not currently "
          "interviewing anyone!\n", ({ }));
      return 0;
  }
  else {
      if (member_array (query_subject(), candidates) != -1) {
          candidates -= ({query_subject()});
      }
      if (member_array (query_subject(), submitted) != -1) {
          submitted -= ({query_subject()});
      }
      interviewed += ({query_subject()});
      interviewed = uniq_array (interviewed);
      save();
      write_to_file (sprintf ("Interview with %s, ended %s.\n", query_subject(),
        ctime (time())));
      set_subject (0);
      set_interviewer (0);
      this_player()->add_succeeded_mess (this_object(), "$N switch$es off "
          "$p tape recorder, indicating the interview is at an end.\n", ({ }));
      return 1;
  }
}
void event_soul(object ob, string str, mixed avoid) {
  if (environment (this_player()) != this_object()) {
    return;
  }
  if (query_subject()) {
    write_to_file (EVENTS->convert_message (str));
  }
}
int *query_co_ord() {
  return 0;
}
int do_query() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot query "
        "creator candidates!\n",
          ({ }));
      return 0;
  }
  if (!sizeof (query_applicants_text())) {
    this_player()->add_failed_mess (this_object(), "No information.\n");
  }
  else {
    tell_object (this_player(), this_object()->query_applicants_text());
  }
  return 1;
}
int do_add (string candidate) {
  int i = query_permitted (this_player()->query_name());
  if (!i) {
      this_player()->add_failed_mess (this_object(), "You cannot add a "
        "candidate!\n", ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (query_part_two_required()) {
    if (member_array (candidate, candidates) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        candidates += ({candidate});
    }
    else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
    }
  }
  else if (member_array (candidate, submitted) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        submitted += ({candidate});
  }
  else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
  }
    AUTO_MAILER->auto_mail( candidate, capitalize
      (this_player()->query_name()), "Your application to "
        + capitalize (query_domain()) + ".", query_cc(),
        query_part_two(), 0, 0);
    save();
    this_player()->add_succeeded_mess (this_object(), "$N add$s a "
      "name to the candidate list.\n", ({ }));
    return 1;
}
string* query_submitted() {
  return submitted;
}
string query_applicants_text() {
  string ret = "", *temp = allocate (sizeof (submitted));
  int i;
  if (sizeof (submitted)) {
      for (i = 0; i < sizeof (submitted); i++) {
          if (find_player (submitted[i])) {
              temp [i] = "%^BOLD%^"+submitted[i] + "%^RESET%^";
          }
          else {
              temp [i] = submitted [i];
          }
      }
    }
  if (query_part_two_required()) {
    if (sizeof (candidates)) {
      ret += sprintf ("The candidates for %s still to submit answers to "
          "part two of the application process are: %s.\n",
            capitalize (query_domain()), query_multiple_short (candidates));
    }
  }
  else {
    if (query_interview()) {
      if (sizeof (temp)) {
        ret += sprintf ("The following candidates for %s " +
        (query_part_two_required()? "have submitted "
          "answers to part two of the test and " :  "")
          + "are awaiting an interview.  "
          "Names in bold are currently online: %s.\n",
          capitalize (query_domain()), query_multiple_short (temp));
      }
    }
    else {
      ret += sprintf ("The following candidates for %s have submitted "
        "answers to part two of the test and are awaiting a response.  "
        "Names in bold are currently online: %s.\n",
        capitalize (query_domain()), query_multiple_short (temp));
    }
  }
  if (query_interview()) {
    if (sizeof (interviewed)) {
        ret += sprintf ("The following candidates have been interviewed "
            "for %s, and are awaiting a response: %s.\n",
            capitalize (query_domain()), query_multiple_short (interviewed));
    }
  }
  if (sizeof (accepted)) {
    ret += sprintf ("The following candidates have been accepted "
            "for %s: %s.\n",
            capitalize (query_domain()), query_multiple_short (accepted));
  }
  if (sizeof (rejected)) {
    ret += sprintf ("The following candidates have been rejected from "
            "%s: %s.\n",
            capitalize (query_domain()), query_multiple_short (rejected));
  }
  if (!sizeof (ret)) {
      ret += "There are no outstanding candidates, and no-one has been "
          "interviewed recently.\n";
  }
  return ret;
}
int clear_interviewed() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  interviewed = ({ });
  return 1;
}
int clear_candidates() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  return 1;
}
int flush() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  interviewed = ({ });
  submitted = ({ });
  accepted = ({ });
  rejected = ({ });
  return 1;
}
int remove_candidate(string candidate) {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, candidates) != -1) {
      candidates -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, submitted) != -1) {
      submitted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, accepted) != -1) {
      accepted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, rejected) != -1) {
      rejected -= ({candidate});
      i = 1;
  }
  if (i == 1) {
    this_player()->add_succeeded_mess (this_object(), "$N delete$s a "
      "name from the candidate list.\n", ({ }));
    save();
    return 1;
  }
  this_player()->add_failed_mess (this_object(), "No candidate by that "
    "name is on the list.\n", ({ }));
  return 0;
}
int add_candidate(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, candidates) == -1) {
      candidates += ({name});
      return 1;
  }
  return 0;
}
int add_interviewed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, interviewed) == -1) {
      interviewed += ({name});
      return 1;
  }
  return 0;
}
int add_confirmed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, submitted) == -1) {
      submitted += ({name});
      return 1;
  }
  return 0;
}
int remove_interviewed(string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      return 1;
  }
  return 0;
}
int do_confirm (string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (candidate, submitted) != -1) {
    this_player()->add_failed_mess (this_object(), "You have already "
      "confirmed receipt of this candidate's submission.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
    this_player()->add_failed_mess (this_object(), "This candidate "
      "has already been interviewed.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, candidates) != -1) {
    candidates -= ({candidate});
  }
    submitted += ({candidate});
    AUTO_MAILER->auto_mail( candidate, capitalize
        (this_player()->query_name()), "Thank you for your submission.",
        query_cc(), query_confirmation(), 0, 0);
    save();
  this_player()->add_succeeded_mess (this_object(), "$N confirm$s "
    "receipt of a candidate's application.\n", ({ }));
  return 1;
}
void set_domain(string dom) {
  _domain = dom;
}
string query_domain () {
  if (!_domain) {
    return "unset";
  }
  else {
    return _domain;
  }
}
void set_confirmation(string text) {
  _confirmation_text = text;
}
string query_confirmation() {
  if (!sizeof (_confirmation_text)) {
    if (query_interview()) {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "The next part of the application process will be an interview "
        "to discuss your application to the %s domain.  "
        "This interview is likely to take around an hour of your time, "
        "so if you could mail me with a list of your "
        "common online times, hopefully we'll be able to make an "
        "appointment that is mutually convenient.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
    else {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "Your application to the %s domain is now being considered, and "
        "you should expect to hear back within a week or two with an "
        "answer.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
  }
  else {
    return _confirmation_text;
  }
}
string query_lord() {
  return LORD;
}
void set_part_two_required (int i) {
  _pt_two = i;
}
int query_part_two_required () {
  return _pt_two;
}
void set_interview(int i) {
  _interview = i;
}
int query_interview() {
  return _interview;
}
string query_subject(){
  if (_subject) {
    return _subject;
  }
  return 0;
}
private void set_subject (string name) {
    _subject  = name;
}
private void set_interviewer (mixed name) {
  if (arrayp (name)) {
    _int  = name;
  }
  else {
    _int = ({ name });
  }
}
string *query_interviewer() {
  return _int;
}
int query_is_interviewer (string name) {
  if (!sizeof (_int)) {
    return 0;
  }
  if (member_array (name, _int) != -1) {
    return 1;
  }
  return 0;
}
string* query_permitted_creators() {
  return copy (_allowed_creators);
}
private void add_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) == -1) {
    _allowed_creators += ({ name });
  }
}
private void remove_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) != -1) {
    _allowed_creators -= ({ name });
  }
}
int add_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator (name)) {
      this_player()->add_failed_mess (this_object(), "Only creators "
        "may be permitted to use the interview room.\n", ({ }));
      return 0;
  }
  add_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N add$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int remove_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  remove_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N remove$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int query_allowed_creators() {
  if (!sizeof (query_permitted_creators())) {
    this_player()->add_failed_mess (this_object(), "Only the domain lord and "
      "the domain deputies are currently permitted to use this room.\n",
      ({ }));
    return 0;
  }
  tell_object (this_player(), sprintf ("In addition to the domain Lord and "
    "the domain deputies, the following creators are permitted "
    "to make use of this room: %s.\n", query_multiple_short
    (query_permitted_creators())));
  return 1;
}
string query_part_two(){
  string temp;
  if (_filename) {
    temp = unguarded ((: read_file (_filename) :));
    if (sizeof (temp)) {
      return temp;
    }
  }
  return sprintf ("Bing!\n\nThank you for your application to the %s domain. "
    "\n\nYour application has been received and is awaiting processing.\n\n"
    "Regards,\n%s.", query_domain(), LORD);
}
int set_part_two(string file) {
  if (!sizeof (file)) {
    printf ("No file given for part two of application.  Aborting.\n");
    return 0;
  }
  if (file_size(file) == -1) {
    printf ("File given for set_part_two() does not exist.  No file set.\n");
    return 0;
  }
  _filename = file;
  return 1;
}
string query_interview_dir(){
  if (sizeof (_interview_dir)) {
    return _interview_dir;
  }
  else {
    return SECURE;
  }
}
int set_interview_dir(string dir) {
  if (!sizeof (dir)) {
    printf ("No directory given for interviews.  Aborting.\n");
    return 0;
  }
  if (file_size(dir) != -2) {
    printf ("Directory given for set_interview_dir does not exist.  "
      "Aborting.\n");
    return 0;
  }
  _interview_dir = dir;
  return 1;
}
int do_query_text(string flag) {
  string temp;
  switch (flag) {
    case "confirmation":
      temp = query_confirmation();
    break;
    case "acceptance":
      temp = query_acceptance();
    break;
    case "rejection":
      temp = query_rejection();
    break;
    default:
      temp = "I'm sorry, there has been an error.\n";
    break;
  }
  tell_object (this_player(), temp);
  return 1;
}
int do_flag(string name, string flag) {
  if (member_array (name, candidates) != -1) {
        candidates -= ({name});
  }
  if (member_array (name, submitted) != -1) {
      submitted -= ({name});
  }
  if (member_array (name, interviewed) != -1) {
      interviewed -= ({name});
  }
  if (flag == "accepted") {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), "Congratulations!",
          query_cc(), query_acceptance(), 0, 0);
    if (member_array (name, accepted) == -1) {
      accepted += ({name});
    }
  }
  else {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), sprintf ("Your application to the %s "
        "domain.", query_domain()), query_cc(), query_rejection(), 0, 0);
    if (member_array (name, rejected) == -1) {
      rejected += ({name});
    }
  }
  this_player()->add_succeeded_mess (this_object(), sprintf ("$N flag$s a "
    "player as %s.\n", flag), ({ }));
  save();
  unguarded ((: write_file (LOG, sprintf ("%s flagged %s as %s "
          "on %s.\n", this_player()->query_name(),
          $(name), $(flag), ctime(time()))) :));
  return 1;
}
void set_rejection(string text) {
  _rejection_text = text;
}
void set_acceptance(string text) {
  _acceptance_text = text;
}
string query_rejection() {
  if (!sizeof (_rejection_text)) {
    return sprintf ("Hello.\n\n"
      "I'm sorry to say that your application to the %s domain has been "
      "unsuccessful.  My apologies that I cannot hire you at this time.  "
      "I will of course keep your details on file should you wish to "
      "apply again in the future.\n\nRegards,\n%s.",
          query_domain(), LORD);
  }
  else {
    return _rejection_text;
  }
}
string query_acceptance() {
  if (!sizeof (_acceptance_text)) {
    return sprintf ("Bing!\n\n"
      "It is my great pleasure to inform you that your application to the %s "
        "domain has been successful.  Congratulations!\n\nBefore being promoted, "
        "you will need to ensure you repay any debts you have.  If you wish "
        "to bequeath your inventory on a fellow player, this must also be "
        "done before you are employed - you won't get a chance once you're "
        "a creator.\n\nPlease send me a mail letting me know when you will "
        "be available for promotion and your orientation lecture.\n\n"
        "Congratulations,\n%s.",query_domain(), LORD);
  }
  else {
    return _acceptance_text;
  }
}
int do_read (string name) {
  string path;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
        ({ }));
    return 0;
  }
  path = query_interview_dir() + name + ".txt";
  if (!file_size (path)) {
    this_player()->add_failed_mess (this_object(), "This document does "
      "not exist.\n", ({ }));
    return 0;
  }
  this_player()->more_string (unguarded ((: read_file ($(path)) :)));
  return 1;
}
string query_cc() {
  if (sizeof (_cc)) {
    return implode (_cc, ",");
  }
  return 0;
}
void set_cc (string *i) {
  _cc = i;
}
int do_list() {
  string *list, text;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You are not permitted "
      "to do this.\n", ({ }));
    return 0;
  }
  else {
    list = get_dir (query_interview_dir());
    list -= ({"candidate_list.o", "candidate_log.txt"});
  }
  list = map (list, (: capitalize ($1) :));
  text = replace (query_multiple_short (list), ({".txt", ""}));
  tell_object (this_player(), sprintf ("The following interviews have been "
    "conducted for the %s domain: %s.\n", query_domain(),
      text));
  this_player()->add_succeeded_mess (this_object(), "$N list$s the completed "
    "interviews.\n", ({ }));
  return 1;
}
string* query_all_applicants() {
  return uniq_array (candidates + interviewed + submitted + accepted + rejected);
}
string* query_interviewed() {
  return interviewed;
}

==================================================
FILE: dom/loader.c
==================================================

string *pre_load;
void create() {
  int i;
  string domain;
  foreach(domain in "/secure/master"->query_domains()) {
    unguarded((: restore_object, "/d/"+ domain + "/loader" :));
    if (!pre_load)
      pre_load = ({ });
    for (i=0;i<sizeof(pre_load);i++) {
      if(pre_load && explode(pre_load[i], "/")[1] != domain)
        printf("invalid " + domain + " preload: " + pre_load[i] +
               "\n");
      else {
        printf(domain +" pre_loading "+pre_load[i]+".\n");
        if (catch(call_other(pre_load[i], "??")))
          call_out("do_load", 0, pre_load[i]);
      }
    }
  }
}
void do_load(string str) {
  call_other(str, "??");
}
int add_pre_load(string domain, string str) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object("/d/" + domain + "/loader");
  return 1;
}
int remove_pre_load(string domain, string str) {
  int i;
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object("/d/" + domain + "/loader");
}
string *query_pre_load(string domain) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return ({ });
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  return pre_load;
}

==================================================
FILE: dom/master.c
==================================================

inherit "/std/dom/base_master";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "";
}

==================================================
FILE: environ/snowball.c
==================================================

#include <tasks.h>
inherit "std/object";
int strength;
void set_strength( int number );
void setup() {
   set_name( "snowball" );
   add_alias( "ball" );
   add_adjective( "snow" );
   set_strength( 99 );
   set_heart_beat( 1 );
}
int query_strength() { return strength; }
void set_strength( int number ) { strength = number; }
string long( string word, int dark ) {
   return "This is a "+ ({
      "very small lump of slush",
      "small and rather soggy lump of snow",
      "small snowball",
      "smallish snowball",
      "vaguely small snowball",
      "decent sized snowball",
      "reasonably sized snowball",
      "snowball for throwing at someone",
      "good snowball for throwing at someone",
      "nice, big snowball, just right for throwing at someone"
   })[ strength / 10 ] +".\n";
}
void init() {
    add_command( "throw", "<direct:object> {at|to} <indirect:object>" );
}
void heart_beat() {
   strength--;
   if ( strength < 1 ) {
      set_heart_beat( 0 );
      move( "/room/rubbish" );
   }
}
private object find_person(object ob) {
   if (living(ob)) {
      return ob;
   } else {
      while (ob && !living(ob)) {
         ob = environment(ob);
      }
      if (ob) {
         return ob;
      }
   }
   return 0;
}
int do_throw( object *obs ) {
   object per;
   int chance;
   per = find_person(obs[0]);
   if (per) {
      if (per != obs[0]) {
         chance = 0;
      } else {
         chance = 30;
      }
      if (per == this_player()) {
         per->add_effect( "/std/effects/external/snowball", strength );
      } else {
         switch (TASKER->compare_skills(this_player(),
                                        "fighting.combat.range.thrown",
                                        per,
                                        "fighting.combat.dodging.range",
                                        chance,
                                        TM_FREE,
                                        TM_FREE)) {
         case OFFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to throw "
                                       "snowballs at people.\n%^YELLOW%^");
         case OFFWIN :
            per->add_effect( "/std/effects/external/snowball", strength );
            add_succeeded_mess( ({ "$N throw$s $D at $I and hit$s!\n",
                "$N throw$s $D at $I and hits!\n" }),  ({ obs[0] }) );
            break;
         case DEFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to dodge "
                                       "snowball thrown by people.\n%^YELLOW%^");
         case DEFWIN :
            add_succeeded_mess( "$N throw$s $D at $I and miss$es!\n",
                                   ({ obs[0] }) );
            break;
         }
      }
   } else {
      add_succeeded_mess( "$N throw$s $D at $I.\n", ({ obs[ 0 ] }) );
   }
   move( "/room/rubbish" );
   return 1;
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "strength" : strength
   ]);
}
void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   strength = map[ "strength" ];
}

==================================================
FILE: environ/snowball.h
==================================================

#define SNOW_THING "The snow ball thing"
#define SNOW_EXTRA "/std/environ/snowball_look"

==================================================
FILE: environ/snowman.c
==================================================

#include <move_failures.h>
inherit "/std/object";
private int _call_out_handle;
void setup() {
    reset_get();
    if ( clonep() ) {
        _call_out_handle = call_out("die",400);
    }
}
void set_type(string type) {
    set_name(type);
    set_short(type);
    set_long("A wonderful " + type + " with glowing eyes made of coal and twigs "
      "for ears.\n");
    add_extra_look( this_object() );
}
string extra_look( object ob ) {
    int time_left;
    if ( !_call_out_handle ) {
        return "";
    }
    time_left = find_call_out( _call_out_handle );
    debug_printf( "time left is %d\n", time_left );
    if ( time_left > 300 || time_left < 0 ) {
        return "";
    }
    return "It is " + ({ "mostly", "half", "slightly" })[time_left/100] +
        " melted.\n";
}
void die() {
    string noun;
    switch( environment( this_object() )->query_property( "location" ) ) {
    case "inside":
        noun = "floor";
        break;
    case "outside":
        noun = "ground";
        break;
    case "underwater":
        noun = "seabed";
        break;
    default:
        noun = "floor";
        break;
    }
    tell_room( environment( this_object() ),
      the_short() + " $V$0=melts,melt$V$ into the " + noun + ".\n");
    if ( this_object()->move( "/room/rubbish" ) != MOVE_OK ) {
        dest_me();
    }
}

==================================================
FILE: environ/weather.c
==================================================

#include <config.h>
inherit "std/object";
#include "climate.h"
#define FILE_NAME "/save/environ/weather"
#define HOME "/obj/handlers/weather_room"
#define MAX_DIST 100
#define YEAR 60
#define DAY 60
#define SPEED 40
mixed *coldarr,
      *cloudarr,
      *rainarr;
int timeofyear,
    mooncycle,
    moonoff,
    timeofday,
    intensity;
int distance(mixed *co_ord1,mixed *co_ord);
int cloud_index(object env);
int rain_index(object env);
int temperature_index(object env);
string cloud_string(object env);
string rain_string(object env);
string temperature_string(object env);
void setup() {
  set_name("weather");
  set_short("weather controller extrodinare");
  set_long("The weather controller, at least this one is always right!\n");
  cloudarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  rainarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  coldarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  intensity = 100;
  restore_object(FILE_NAME);
  call_out("update_low",SPEED);
  move("bing");
}
move(arg) {
  ::move(HOME);
}
mixed *query_cold() { return coldarr; }
mixed *query_rain() { return rainarr; }
mixed *query_cloud() { return cloudarr; }
int query_moon() { return mooncycle; }
string query_moon_string(object env) {
  int bing;
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 0;
  return ({ "full moon",
            "waning three quarter moon",
            "waning half moon",
            "waning quarter moon",
            "waning cresent moon",
            "new moon",
            "waxing cresent moon",
            "waxing quarter moon",
            "waxing half moon",
            "waxing three quarter moon" })[mooncycle];
}
int distance(mixed *co_ord1, mixed *co_ord2) {
  int off;
  if (!pointerp(co_ord1) || !pointerp(co_ord2))
    return 0;
  if (co_ord1[0]>co_ord2[0])
    off = co_ord1[0] - co_ord2[0];
  else
    off = co_ord2[0] - co_ord1[0];
  if (co_ord1[1]>co_ord2[1])
    off += co_ord1[1] - co_ord2[1];
  else
    off += co_ord2[1] - co_ord1[1];
  return off;
}
int query_season() { return timeofyear/15; }
int query_time_of_year() { return timeofyear; }
int query_time_of_day() { return timeofday; }
int query_day(object env) {
  int bing, bit;
  if (!env) {
    load_object(CONFIG_START_LOCATION);
    env = find_object(CONFIG_START_LOCATION);
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  bit = (DAY/2)-(timeofyear-(YEAR/2))/(YEAR/10);
  if (bing>bit)
    return 0;
  if (bit < 10)
    return bit;
  return -(bing - bit);
}
int query_darkness(object env) {
  int bing, per, i;
  per = -cloud_index(env);
  if (per <-100)
    per = -100;
  if (per > 100)
    per = 100;
  if ((i=query_day(env))) {
    i *= 20;
    if (i>100)
      i = 100;
    return 50+(per+100)*150*i/20000;
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 15+(per+100)*30/200;
  if (timeofday<0) timeofday += DAY;
  i = mooncycle -5;
  if (i<0)
    i = -i;
  return 30+(per+100)*14*i/200;
}
string weather_string(object env) {
  return temperature_string(env)+" with "+cloud_string(env)+
         rain_string(env);
}
int query_raining(object env) {
  int cloud,rain;
  if (temperature_index(env)/(100/7)<2) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_hailing(object env) {
  int cloud, rain;
  if (temperature_index(env)/(100/7)==2) {
    cloud = cloud_index(env);
    if (cloud <=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain <=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_snowing(object env) {
  int cloud,rain;
  if ((temperature_index(env)/(100/7))>=3) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = cloud_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
string rain_string(object env) {
  int cloud, rain, temp;
  string tempstr1,tempstr2;
  cloud = cloud_index(env);
  rain = rain_index(env);
  if (cloud<=0) return "";
  if (cloud-rain<=0) return "";
  temp = temperature_index(env)/(100/7);
  if (temp>3) temp = 3;
  if (temp<-3) temp = -3;
  tempstr1 = ({ "very hot ",
                "hot ",
                "warm ",
                "nice ",
                "cold ",
                "",
                "" })[temp+3];
  tempstr2 = ({ " rain",
                " rain",
                " rain",
                " rain",
                " rain",
                " hail",
                " snow" })[temp+3];
  cloud = (cloud-rain) / 20;
  if (cloud>5) cloud = 5;
  return "\n"+capitalize(tempstr1 + ({ "very light",
                      "light",
                      "medium",
                      "heavy",
                      "very heavy" }) [cloud]+tempstr2);
}
string temperature_string(object env) {
  int inten;
  inten = temperature_index(env);
  inten /= 10;
  if (inten>10)
    inten = 10;
  if (inten<-10)
    inten = -10;
  return ({ "Its one of those baking eggs on the pavement days",
            "So hot that the sun feels like its right next door",
            "Damn hot",
            "Very hot",
            "Hot",
            "Hot",
            "Reasonably hot",
            "Very warm",
            "Warm",
            "Pleasantly warm",
            "Average temerature",
            "A little chilly",
            "A slight nip in the air",
            "Chilly",
            "Very chilly",
            "Cold",
            "Cold",
            "Very cold",
            "Damn cold",
            "Incredibly cold",
            "Freezing cold" })[inten+10];
}
string cloud_string(object env) {
  int off;
  off = cloud_index(env) / 20;
  if (off>5) off = 5;
  if (off<-5) off = -5;
  return ({ "a beatifully clear sky",
            "a few high level sirius clouds",
            "scattered puffy clouds",
            "very thin complete cloud cover",
            "light cloud cover",
            "medium cloud cover",
            "dense cloud cover",
            "packed cloud cover",
            "packed cloud cover",
            "heavy black clouds",
            "thick heavy clouds",
         })[off+5];
}
int temperature_index(object env) {
  int off,i;
  mixed clim, *co_ord;
  for (i=0;i<sizeof(coldarr);i++)
    off += (distance((mixed *)env->query_co_ord(), coldarr[i]) % (MAX_DIST*2));
  off = off / sizeof(coldarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_TEMP];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0 - off;
  co_ord = (mixed *)env->query_co_ord();
  if (!co_ord)
    co_ord = ({ 0, 0, 0 });
  return (off + (timeofyear - (YEAR/2)) + (timeofday - (DAY/2)) + co_ord[2]);
}
int cloud_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(cloudarr);i++)
    off += (distance((mixed *)env->query_co_ord(), cloudarr[i]) % (MAX_DIST*2));
  off = off / sizeof(cloudarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_CLOUD];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0-off;
  return (off + (timeofyear - (YEAR/2)));
}
int rain_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(rainarr);i++)
    off += (distance((mixed *)env->query_co_ord(), rainarr[i]) % (MAX_DIST*2));
  off = off / sizeof(rainarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_RAIN];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= MAX_DIST/2;
  off = 0-off;
  return off;
}
void update_low() {
  int i;
  timeofday++;
  if (timeofday>DAY) {
    timeofday = 0;
    timeofyear++;
    mooncycle++;
    if (mooncycle %2) {
      moonoff += 1;
      moonoff = moonoff % (DAY/2);
    }
    timeofyear = timeofyear % YEAR;
    mooncycle = mooncycle % 10;
    save_object(FILE_NAME);
  }
  for (i=0;i<sizeof(rainarr);i++) {
    rainarr[i][0] += random(3)-1;
    rainarr[i][0] = rainarr[i][0] % (MAX_DIST*2);
    rainarr[i][1] += random(3)-1;
    rainarr[i][1] = rainarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(cloudarr);i++) {
    cloudarr[i][0] += random(3)-1;
    cloudarr[i][0] = cloudarr[i][0] % (MAX_DIST*2);
    cloudarr[i][1] += random(3)-1;
    cloudarr[i][1] = cloudarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(coldarr);i++) {
    coldarr[i][0] += random(3)-1;
    coldarr[i][0] = coldarr[i][0] % (MAX_DIST*2);
    coldarr[i][1] += random(3)-1;
    coldarr[i][1] = coldarr[i][1] % (MAX_DIST*2);
  }
  intensity += random(3)-1;
  if (intensity<50)
    intensity=50;
  if (intensity>300)
    intensity=300;
  call_out("update_low",SPEED);
}
void dest_me() {
  save_object(FILE_NAME);
  ::dest_me();
}

==================================================
FILE: environ/weather_room.c
==================================================

inherit "std/room";
mixed leverarr;
reset (arg) {
  if (arg) return;
  set_short("The weather room");
  set_long("The weather control center for the entire mud. On the floor should\n"+
           "be the controller itself, scattered around the room are hundred of impresive\n"+
           "flashing lights, dials and levers. You get the feeling however that they dont\n"+
           "actually do anything.\n");
  set_light(1);
  seteuid("pinkfish");
  add_property("inside");
  add_exit("pinkfish","d/Fish/pinkfish/workroom");
  add_item("lights","What did I say? there are lots of them and they are insesantly\n"+
           "flashing.\n");
  add_item("dials","Large dials with all sort of things on them. One you can see says\n"+
           "'Colour of spring', it is currently pointing at purple.\n");
  add_item("levers",
           "The levers are large multicolour protuberances which are scattered around the\n"+
           "room in random profusion.\n");
  leverarr = ({ ({ "blue",
       "The rooms spins and a small bit of printed paper falls from the\n"+
       "Weather controller saying:\n#query_rain" }),
                ({ "white",
       "The ground heaves in a major convulsion and a mound of paper falls onto\n"+
       "You from the ceiling saying:\n#query_cloud" }) });
}
init() {
  ::init();
  add_action("pull","pull");
  add_action("push","push");
}
pull(str) {
  int i;
  string type,rand;
  object lever, weather;
  if (str == "lever" || str == "levers")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,rand)) {
      notify_fail("You have to pull a lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++) {
      if (leverarr[i][0] == type) {
        lever = leverarr[i];
        break;
      }
    }
  }
  if (!lever) {
    notify_fail("You need to choose and existing lever");
    return ;
  }
  weather = present("weather",this_object());
  if (!weather) {
    notify_fail("Opps the weather controller does not exist.\n");
    return 0;
  }
  sscanf(lever[1],"%s#%s",type,rand);
  write(type);
  this_player()->print_object(call_other(weather,rand));
  return 1;
}
push(str) {
  object lever;
  int i;
  string type,bing;
  if (str == "levers" && str == "lever")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,bing)) {
      notify_fail("You must push an existing lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++)
      if (type == leverarr[i][0]) {
        lever = leverarr[i];
        break;
      }
  }
  if (!lever) {
    notify_fail("An existing lever could be usefull...\n");
    return 0;
  }
  write("You huff and you puff, but you just cant push that lever.\n");
}

==================================================
FILE: living/armour.c
==================================================

#include <clothing.h>
#include <function.h>
#include <race.h>
#include <armour.h>
inherit "/std/armour_logic";
#undef INFORM 1
nosave string skin;
nosave object *wearing;
nosave mixed stopped;
nosave mixed *_armour_callbacks;
nosave int *_cids;
void create() {
   skin = "morphological field";
   wearing = ({ });
   if(!_armour_callbacks)
     _armour_callbacks = ({ ({ }), ({ }), ({ }) });
   if(!_cids)
     _cids = ({ 0, 0, 0 });
   ::create();
}
int register_armour_callback(int level, mixed callback, mixed data) {
  _armour_callbacks[level] += ({ new(class armour_callback,
                                     id : ++(_cids[level]),
                                     callback: callback,
                                     data : data) });
  return _cids[level];
}
int remove_armour_callback(int level, int id) {
  int i;
  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level] -= ({ _armour_callbacks[level][i] });
      return 1;
    }
  }
  return 0;
}
int update_armour_callback(int level, int id, mixed data) {
  int i;
  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level][i]->data = data;
      return 1;
    }
  }
  return 0;
}
mixed *query_armour_callbacks() { return copy(_armour_callbacks); }
string query_skin() { return skin; }
void set_skin( string word ) { skin = word; }
object *query_wearing() {
   wearing = filter(wearing, (: $1 && environment($1) == this_object() :));
   return copy( wearing );
}
object *query_armours() {
   return query_wearing();
}
void clear_armours() {
   wearing->set_worn_by( 0 );
   wearing = ({ });
}
mixed query_stopped() {
   return stopped;
}
void set_stopped( mixed arg ) { stopped = arg; }
protected int equivalent_armour_types( mixed comp, string type ) {
   string word;
   if ( stringp( comp ) ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( comp ) ) {
         return CLOTHING_HANDLER->query_equivilant_type( comp ) == type;
      }
      return comp == type;
   }
   foreach ( word in comp ) {
      if ( equivalent_armour_types( word, type ) )
         return 1;
   }
   return 0;
}
string wear_armour( object armour, int doing_hold ) {
   int no_limbs;
   string type, word, fail_mess;
   mixed types;
   object thing;
   mapping things;
   if (environment(armour) != this_object()) {
      return "must be in your inventory";
   }
   wearing -= ({ 0 });
   if (member_array(armour, wearing) > -1)
     return "since you already have " + armour->query_objective() + " on";
   types = armour->query_type();
   word = this_object()->not_allowed_to_wear( types );
   if ( word ) {
      return word;
   }
   things = ([ ]);
   if ( stringp( types ) ) {
      types = ({ types });
   }
   if ( !pointerp( types ) ) {
      return "oh dear";
   }
   foreach ( type in types ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( type ) ) {
         type = CLOTHING_HANDLER->query_equivilant_type( type );
      }
      things[ type ] = ({ });
      foreach ( thing in wearing ) {
         if ( equivalent_armour_types( (mixed)thing->query_type(), type ) )  {
            things[ type ] += ({ thing });
         }
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( !word )
     return "no race object";
   foreach ( type in keys( things ) ) {
      if ( (int)word->query_number_worn( type ) <= sizeof( things[ type ] ) ) {
         return "since you are already wearing "+
               query_multiple_short( things[ type ] );
      }
   }
   no_limbs = (int)armour->query_no_limbs();
   if ( no_limbs && !doing_hold ) {
      if ( member_array( armour,
            (object *)this_object()->query_holding() ) != -1 ) {
         return "already wearing";
      }
      if( sizeof( (int *)armour->hold_item( this_object(), -1 ) ) ) {
         return 0;
      } else {
         return "already holding";
      }
   }
   if ( !armour->set_worn_by( this_object() ) ) {
      if( fail_mess = armour->query_wear_failure_mess() )
         return fail_mess;
      else
         return "oh dear";
   }
   wearing += ({ armour });
   this_object()->do_burden_call();
   return 0;
}
int remove_armour( object thing ) {
   int i;
   wearing -= ({ 0 });
   i = member_array( thing, wearing );
   if ( i == -1 ) {
      return 1;
   }
   if ( !thing->set_worn_by( 0 ) ) {
      return 1;
   }
   if ( member_array( thing, (object *)this_object()->query_holding() ) != -1 ) {
      if ( !sizeof( (int *)this_object()->set_unhold( thing ) ) ) {
         return 1;
      }
   }
   wearing = delete( wearing, i, 1 );
   this_object()->do_burden_call();
   return 0;
}
varargs int query_ac( string type, int amount, string zone ) {
  int part, total, i, max;
  string word, *types;
  mixed most;
  object thing;
  object *defenses;
  stopped = 0;
#ifdef INFORM
  event( environment(), "inform", "zone "+ zone, "combat" );
#endif
  if ( !zone ) {
    switch(random(21)) {
    case 0..1: zone = "head"; break;
    case 2: zone = "neck"; break;
    case 3..6: zone="chest"; break;
    case 7..9: zone="abdomen"; break;
    case 10..12: zone = "arms"; break;
    case 13..14:
      zone = "hands"; break;
    case 15..18: zone = "legs"; break;
    case 19: zone = "feet"; break;
    case 20: zone = "back"; break;
    }
#ifdef INFORM
    event( environment(), "inform", "picked zone "+ zone,
           "combat" );
#endif
  }
  if(sizeof(_armour_callbacks[ARM_OUTER]) && amount) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_OUTER]); i++) {
      if(!_armour_callbacks[ARM_OUTER][i]->callback[0])
        remove_armour_callback(ARM_OUTER,
                               _armour_callbacks[ARM_OUTER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_OUTER][i]->callback[0],
                          _armour_callbacks[ARM_OUTER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_OUTER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }
  if(zone != "self" && amount > 0) {
    types = CLOTHING_HANDLER->query_clothing_zone( zone );
    if(!types) {
      log_file("ARMOUR_DEBUG", "No types for zone: %s", zone);
      return 0;
    }
    foreach ( word in  types) {
      wearing -= ({ 0 });
      defenses = wearing + filter_array(this_object()->query_holding(),
                                        (: $1 && $1->query_armour() :));
      foreach ( thing in defenses )
        if ( equivalent_armour_types( (mixed)thing->query_type(), word ) ) {
#ifdef INFORM
          event( environment(), "inform", "testing object "+
                 thing->short(), "combat" );
#endif
          part = (int)thing->query_ac( type, amount, zone );
          if (!stopped && part)
            stopped = thing;
          if(part > max) {
            max = part;
            most = stopped;
          }
          total += part;
          amount -= part;
        }
      if (amount < 1)
        break;
    }
  }
  if(sizeof(_armour_callbacks[ARM_INNER]) && amount > 0) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_INNER]); i++) {
      if(!_armour_callbacks[ARM_INNER][i]->callback[0])
        remove_armour_callback(ARM_INNER,
                               _armour_callbacks[ARM_INNER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_INNER][i]->callback[0],
                          _armour_callbacks[ARM_INNER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_INNER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }
  if(amount > 0 && this_object()->query_race_ob() &&
     function_exists("query_ac", load_object(this_object()->query_race_ob()))){
    part = (this_object()->query_race_ob())->query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }
  if(amount > 0) {
    if(!stopped && type != "skin")
      stopped = skin;
    if(type == "fire") {
      if(this_object()->effects_matching("body.wetness") &&
         sizeof((int *)this_object()->effects_matching("body.wetness"))) {
        this_object()->add_effect("/std/effects/other/wetness", -amount );
      }
    }
    part = ::query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }
  if(amount > 0 && most) {
    stopped = most;
  }
  return total;
}
mixed *stats() {
   return ::stats() + ({
      ({ "skin", skin }),
   });
}

==================================================
FILE: living/carrying.c
==================================================

#include <clothing.h>
#include <money.h>
object* query_wearing();
protected varargs string *query_types_worn( object *things ) {
   int i;
   string *types;
   mixed *stuff;
   types = ({ });
   if ( !things ) {
      things = (object *)this_object()->query_wearing();
   }
   stuff = (mixed *)things->query_type();
   for ( i = sizeof( stuff ) - 1; i > -1; i-- ) {
      if ( stringp( stuff[ i ] ) ) {
         stuff[ i ] = ({ stuff[ i ] });
      }
      if ( !pointerp( stuff[ i ] ) ) {
         printf( "%O (%s) has an invalid type.  Please bug report it.\n",
                 things[ i ], (string)things[ i ]->query_short() );
         stuff[ i ] = ({ "broken" });
      }
      types += stuff[ i ];
   }
   return ({ types, stuff });
}
object* query_wearing_hidden(object looker, object *things) {
   mixed* bing;
   string* types;
   mixed* obj_types;
   object* worn;
   object* ret;
   int i;
   int found_under;
   string fluff;
   string under_type;
   string* under;
   if (!things) {
      worn = query_wearing();
   } else {
      worn = things;
   }
   bing = query_types_worn( worn );
   types = bing[0];
   obj_types = bing[1];
   ret = ({ });
   for (i = 0; i < sizeof(worn); i++) {
      if (worn[i]->query_visible(looker)) {
         found_under = 0;
         foreach (fluff in obj_types[i]) {
            under = CLOTHING_HANDLER->query_clothing_hiding( fluff );
            if ( under && sizeof(under)) {
               foreach (under_type in under) {
                  if (member_array(under_type, types) != -1) {
                     ret += ({ worn[i] });
                     found_under = 1;
                     break;
                  }
               }
            }
            if (found_under) {
               break;
            }
         }
      } else {
         ret += ({ worn[i] });
      }
   }
   return ret;
}
protected string armour_list( object *things, int hidden_only, int self) {
   string word;
   object* hidden;
   hidden = query_wearing_hidden( this_player(), things);
   if (hidden_only) {
      things = filter(hidden, (: $1->query_visible( this_player() ) :));
   } else {
      things = things - hidden;
   }
   if ( !sizeof( things ) ) {
      return 0;
   }
   if (!self) {
      things = sort_array(things,
               (: CLOTHING_HANDLER->query_clothing_depth($2->query_type())  -
                  CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :));
   }
   word = query_multiple_short( things );
   return word;
}
string query_living_contents( int self ) {
   string s;
   string fish;
   string *limbs;
   string *bits;
   string *strs;
   object *holding;
   object *arms;
   object *carry;
   object *conts;
   object money;
   object ob;
   int i;
   int coins;
   int pos;
   s = "";
   strs = ({ });
   conts = ({ });
   limbs = this_object()->query_limbs();
   if (!limbs) {
      limbs = ( this_object()->query_race_ob() )->query_limbs();
   }
   conts = filter(all_inventory(), (: $1->short(0) :) );
   if(!limbs || !sizeof(limbs))
     holding = ({ });
   else
     holding = (object *)this_object()->query_holding() + ({ });
   arms = (object *)this_object()->query_armours() - holding;
   money = present(MONEY_ALIAS, this_object());
   if(!arms) {
      arms = ({ });
   }
   carry = conts - arms - holding - ({ money });
   for (i = 0; i < sizeof(holding); i++) {
     if (holding[i] && environment(holding[i]) == this_object()) {
       bits = ({ limbs[i] });
       ob = holding[i];
       holding[i] = 0;
       while ((pos = member_array(ob, holding)) != -1) {
         bits += ({ limbs[pos] });
         holding[pos] = 0;
       }
       strs += ({  ob->a_short() + " (" +
                     query_multiple_short(bits, "a", 1)+")" });
     }
   }
   if (sizeof(strs)) {
      s += "$I$+10,+0=%^RED%^Holding%^RESET%^ : " +
         query_multiple_short( strs ) +
         ".\n$I$-10,-0=";
   }
   if ( sizeof( arms ) ) {
      if ( fish = armour_list( arms, 0, self) ) {
         s += "$I$+10,+0=%^YELLOW%^Wearing%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
      if ( self && (fish = armour_list(arms, 1, self) ) ) {
         s += "$I$+10,+0=%^YELLOW%^(under)%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
   }
   if ( sizeof( carry ) ) {
      fish = this_object()->query_contents(0, carry, 1);
      if ( fish ) {
         if (pointerp(fish)) {
            s += "$I$+10,+0=%^GREEN%^" + fish[1] + "%^RESET%^: " + fish[0] +
               "$I$-10,-0=";
         } else {
            s += "$I$+10,+0=%^GREEN%^Carrying%^RESET%^: " + fish +
               "$I$-10,-0=";
         }
      }
   }
   if ( self && environment() &&
        this_object()->check_dark(environment()->query_light()) > -1) {
      if ( money ) {
         fish = query_multiple_short( (string *)money->half_short( 1 ) );
      } else {
         fish = 0;
      }
      if ( s == "" ) {
         s = "You are empty handed.\n";
      }
      s += "Your purse contains " + (fish?fish:"only moths") + ".\n";
   } else if(money) {
      coins = (int)money->query_number_coins();
      if (self) {
         s += "Your purse is ";
      } else {
         s += capitalize( (string)this_object()->query_possessive() ) +
              " purse is ";
      }
      switch(coins) {
      case 0..10:
         s += "home to only moths!\n";
         break;
      case 11..100:
         s += "tinkling with coins.\n";
         break;
      case 101..300:
         s += "bulging with coins.\n";
         break;
      default:
         s += "fit to burst!\n";
         break;
      }
   }
   return s;
}

==================================================
FILE: living/combat.c
==================================================

inherit "/std/living/corpse";
inherit "/std/weapon_logic";
#include <attack_messages.h>
#include <tasks.h>
#include <player.h>
#include <living.h>
#include <weapon.h>
#ifdef COMBAT_SPEED
#undef COMBAT_SPEED
#endif
#include <combat.h>
#ifdef ABS
#undef ABS
#endif
#define ABS(n) (n) < 0 ? -(n) : (n)
#define DEBUG 1
#undef USE_SURRENDER
class tactics _tactics;
#ifdef USE_SURRENDER
class surrender_information _surrender;
#endif
nosave class combat_information _combat;
nosave string tmpzone;
nosave int _callout;
object *query_attacker_list();
void stop_all_fight();
int query_distance(object);
int set_distance(object, int);
void adjust_action_defecit(int amount);
private void init_tactics();
#ifdef USE_SURRENDER
object *query_surrenderers();
#endif
void create() {
  ::create();
  init_tactics();
  _combat = new(class combat_information,
                in_combat : 0,
                protectors : ({ }),
                defenders : ({ }),
                attacker_list : ([ ]),
                hunting_list : ([ ]),
                specials : ({ })
                );
#ifdef USE_SURRENDER
  _surrender = new(class surrender_information,
                   to : ({ }),
                   from : ({ }),
                   refusers : ({ }));
#endif
}
private void init_tactics() {
  if(!classp(_tactics) || sizeof(_tactics) != 8) {
    _tactics = new(class tactics,
                   attitude : "neutral",
                   response : "neutral",
                   parry : "both",
                   attack : "both",
                   parry_unarmed : 0,
                   mercy : "ask",
                   focus_zone : 0,
                   ideal_distance : 0);
  }
}
#ifdef DEBUG
class combat_information query_combat() { return _combat; }
#ifdef USE_SURRENDER
class surrender_information query_surrender() { return _surrender; }
#endif
#endif
void combat_debug(string fmt, mixed args ...) {
  if(userp(this_object()))
    this_object()->event_inform(this_object(),
                                sprintf("%s " + fmt,
                                        this_object()->query_name(), args ...),
                                      "combat-debug", this_object());
  event(environment(this_object()), "inform",
        sprintf("%s " + fmt, this_object()->query_name(), args ...),
        "combat-debug", this_object());
}
int query_can_attack() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     this_object()->query_casting_spell() ||
     (userp(this_object()) && !interactive(this_object())) ||
     this_object()->query_property("cannot attack"))
    return 0;
  return 1;
}
int query_can_defend() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     this_object()->query_casting_spell() ||
     (userp(this_object()) && !interactive(this_object())) ||
     this_object()->query_property("cannot defend"))
    return 0;
  return 1;
}
protected class attack choose_opponent(class attack att) {
  mixed *opponents, opponent;
  int i;
#ifdef USE_DISTANCE
  mixed tmp;
#endif
  opponents = map(keys(_combat->attacker_list),
                  (: $1 && objectp($1) ? $1 : find_player($1) :));
  opponents = filter(opponents, (: $1 && environment($1) == environment($2) &&
                                 $1->query_attackable() :), att->attacker);
#ifdef USE_SURRENDER
  foreach(opponent in query_surrenderers()) {
    if(userp(opponent))
      opponent = opponent->query_name();
    opponents -= ({ opponent });
  }
#endif
  if(!sizeof(opponents))
    return att;
  if(interactive(this_object()) &&
     objectp(att->attacker_concentrating) &&
     member_array(att->attacker_concentrating, opponents) != -1)
    opponent = att->attacker_concentrating;
  else {
#ifdef USE_DISTANCE
    opponent = opponents[0];
    foreach(tmp in opponents)
      if(_combat->attacker_list[tmp] < _combat->attacker_list[opponent])
        opponent = tmp;
#endif
    switch(random(3)) {
    case 2:
      opponent = opponents[0];
      for(i=0; i<sizeof(opponents); i++)
        if((opponent->query_hp() / 10 + random(100)) >
           (opponents[i]->query_hp() / 10 + random(100)))
          opponent = opponents[i];
      break;
    case 1:
      opponent = opponents[0];
      for(i=0; i<sizeof(opponents); i++)
        if((opponent->query_hp() / 10 + random(100)) <
           (opponents[i]->query_hp() / 10 + random(100)))
          opponent = opponents[i];
      break;
    default:
      opponent = opponents[random(sizeof(opponents))];
    }
  }
#ifdef USE_DISTANCE
  att->distance = _combat->attacker_list[opponent];
#endif
  if(stringp(opponent))
    att->opponent = find_player(opponent);
  else
    att->opponent = opponent;
  if(environment(att->opponent) != environment(this_object()))
    return att;
  if(sizeof(opponents) == 1)
    _combat->concentrating = att->opponent;
  return att;
}
void clear_protection(object attacker, object protector) {
  if(attacker->remove_protector(protector))
    protector->event_combat(protector,
                            "You stop protecting "+ attacker->the_short() +
                            " as "+ attacker->query_pronoun() +
                            " moves to attack "+
                            "you!\n", ({ }), 0);
  if(attacker->remove_defender(protector))
    protector->event_combat(protector, "You stop defending "+
                            attacker->the_short() + " as "+
                            attacker->query_pronoun() +" moves to attack "+
                            "you!\n", ({ }), 0);
}
class attack choose_defender(class attack att) {
  object *protectors, *defenders;
  if(!att->person_hit) {
    protectors = filter((att->opponent)->query_protectors(),
                        (: $1 && environment($1) == environment($2) &&
                         $1->query_protect() && !pk_check($1, $2) :),
                        att->attacker);
    if(sizeof(protectors)) {
      protectors->attack_by(att->attacker);
      att->person_hit = protectors[random(sizeof(protectors))];
#if DEBUG == 1
      combat_debug("picked %s to protect", (att->person_hit)->query_name());
#endif
    }
  }
  if(!att->defender) {
    defenders = filter((att->opponent)->query_defenders(),
                       (: $1 && environment($1) == environment($2) &&
                        !pk_check($1, $2) :), att->attacker);
    if(sizeof(defenders)) {
      defenders->attack_by(att->attacker);
      defenders = filter(defenders, (: $1->query_defend() :));
    }
    if(sizeof(defenders)) {
      att->defender = defenders[random(sizeof(defenders))];
#if DEBUG == 1
      combat_debug("picked %s to defend", (att->defender)->query_name());
#endif
    }
  }
  if(!att->person_hit)
    att->person_hit = att->opponent;
  if(!att->defender)
    att->defender = att->opponent;
  return att;
}
int query_attackable() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->dont_attack_me() ||
     this_object()->attack_inhibit() ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     (userp(this_object()) && !interactive(this_object())))
    return 0;
  return 1;
}
int query_defend() {
  if(!query_attackable() || this_object()->query_casting_spell() ||
     this_object()->query_specific_gp("fighting") < 1)
    return 0;
  return ((_tactics->response == "parry" || _tactics->response == "both") &&
          _combat->action_defecit < (COMBAT_ACTION_TIME * 4));
}
int query_protect() {
  if(!query_attackable() || this_object()->query_casting_spell() ||
     this_object()->query_specific_gp("fighting") < 1)
    return 0;
  return (_combat->action_defecit < (COMBAT_ACTION_TIME * 4));
}
protected class attack choose_attack(class attack att) {
  object weapon, *weapons;
  string hand, *tmp;
  int perc, which_attack, i;
  class tactics tactics;
  mixed *attacks;
  string zone;
  float sz;
  tactics = att->attacker_tactics;
  if(!this_object()->query_can_attack())
    return att;
  if(!OFFENSIVE_DEFECITS[tactics->attitude])
    tactics->attitude = "neutral";
  if(att->attacker_defecit > OFFENSIVE_DEFECITS[tactics->attitude])
    return att;
  weapons = (att->attacker)->query_holding();
  tmp = (att->attacker)->query_limbs();
  hand = (att->attacker_tactics)->attack;
  if(hand && hand != "both") {
    for(i=0; i<sizeof(tmp); i++)
      if(tmp[i] == hand + " hand")
        break;
    if(!weapons[i])
      weapons = ({ });
    else if(weapons[i]->query_weapon())
      weapons = ({ weapons[i] });
  }
  if(sizeof(weapons) > 1)
    weapons = uniq_array(filter(weapons, (: $1 && $1->query_weapon() :)));
  switch(sizeof(weapons)) {
  case 0:
    weapon = att->attacker;
    break;
  case 1:
    weapon = weapons[0];
    break;
  default:
#ifdef USE_DISTANCE
    weapon = weapons[0];
    foreach(wtmp in weapons)
      if(ABS(REACH + weapon->query_length() - att->distance) >
         ABS(REACH + wtmp->query_length() - att->distance))
        weapon = wtmp;
#else
    weapon = weapons[random(sizeof(weapons))];
#endif
  }
  att->attack_weapon = weapon;
  perc = 75 + (att->attacker)->query_str() + (att->attacker)->query_dex();
  if(weapon != att->attacker)
    perc -= weapon->query_weight() / 2;
  if(perc < 25)
    perc = 25;
  attacks = weapon->weapon_attacks(perc, att->defender);
  if(!sizeof(attacks)) {
#if DEBUG == 2
    combat_debug("No attacks with %O, terminating [%d, %O].", weapon,
                 perc, att->defender);
#endif
    return att;
  }
  which_attack = random(sizeof(attacks) / AT_ARRAY_SIZE);
  attacks = attacks[(which_attack * AT_ARRAY_SIZE)..];
  if(attacks[AT_NAME] == "hands" && !(att->attacker)->query_free_limbs())
    return att;
  att->attack_data = attacks;
  att->attack_skill = ATTACK_SKILL + attacks[AT_SKILL];
  if((att->attacker_tactics)->focus_zone == "upper body") {
    tmp = ((att->opponent)->query_race_ob())->query_target_zones();
    zone = tmp[random(sizeof(tmp) / 2)];
  } else  if((att->attacker_tactics)->focus_zone == "lower body") {
    zone = tmp[random(sizeof(tmp) / 2) + sizeof(tmp)/2];
  } else if((att->attacker_tactics)->focus_zone &&
     (att->attacker_tactics)->focus_zone != "none") {
    zone = (att->attacker_tactics)->focus_zone;
    zone = ((att->opponent)->query_race_ob())->map_target_zone(zone);
    att->target_zone = zone;
  } else {
    if(att->attack_data[AT_SKILL] == "unarmed") {
      if(att->attack_data[AT_NAME] == "hands")
        sz = ((att->attacker)->query_height() * 2) /
          (att->opponent)->query_height();
      else if(att->attack_data[AT_NAME] == "feet")
        sz = ((att->attacker)->query_height() / 2) /
          (att->opponent)->query_height();
    } else
      sz = to_float((att->attacker)->query_height()) /
        to_float((att->opponent)->query_height());
    tmp = ((att->opponent)->query_race_ob())->query_target_zones();
    if(sizeof(tmp)) {
      if(sz > 1.5)
        zone = tmp[random(random(sizeof(tmp)))];
      if(sz < 0.75) {
        i = random(sizeof(tmp) + 10);
        if(i > sizeof(tmp)-1)
          i = sizeof(tmp) - 1;
        zone = tmp[i];
      } else {
        zone = tmp[random(sizeof(tmp))];
      }
    }
  }
  att->target_zone = zone;
  return att;
}
class attack choose_defense(class attack att) {
  object defender;
  string response, *hands, hand;
  object *weapons;
  class tactics tactics;
  int i, which;
#ifdef USE_DISTANCE
  int move_cost;
#endif
  defender = att->defender;
  att->defense_action = "none";
  att->defense_skill = DODGE;
  att->defense_weapon = 0;
  tactics = att->defender_tactics;
  if(defender == att->opponent) {
    if(!defender->query_can_defend())
      return att;
    if(!DEFENSIVE_DEFECITS[tactics->attitude])
      tactics->attitude = "neutral";
    if(att->defender_defecit > DEFENSIVE_DEFECITS[tactics->attitude])
      return att;
  }
#ifdef USE_DISTANCE
  else if(att->distance != defender->query_distance(att->attacker) &&
            ABS(defender->query_distance(att->attacker)) >
            MOVE_DISTANCE[tactics->attitude]) {
    defender->set_distance(att->attacker, att->distance);
    move_cost = MOVE_COST;
    move_cost -= defender->query_skill_bonus(MOVE_SKILL) / 50;
    if(move_cost < 0)
      move_cost = 0;
    (att->opponent)->event_combat(att->opponent, defender->one_short() +
                                  " moves to " +
                                  (att->person_hit == defender ?
                                   "protect" : "defend" ) + " you.\n",
                                  ({ }), 0);
    defender->event_combat(defender, "You move to " +
                           (att->person_hit == defender ?
                            "protect" : "defend") + " " +
                           (att->opponent)->one_short() + ".\n",
                           ({ }), 0);
    event(environment(att->opponent), "combat", defender->one_short() +
          " moves to " + (att->person_hit == defender ? "protect" : "defend") +
          " " + (att->opponent)->one_short() + ".\n",
          ({ att->opponent, defender, att->person_hit }), 1);
  }
#endif
  response = tactics->response;
  if(defender != att->opponent) {
    if(response == "dodge")
      return att;
    response = "parry";
  } else if(!response || response == "neutral")
    response = ({"parry", "dodge"})[random(2)];
  if(response == "parry") {
    weapons = (object *)defender->query_holding();
    hand = (att->defender_tactics)->parry;
    which = -1;
    hands = (att->defender)->query_limbs();
    for(i=0; i<sizeof(hands); i++)
      if(hands[i][0..sizeof(hand)-1] == hand)
        which = i;
    if(which != -1) {
      if(weapons[which]) {
        att->defense_action = "parry";
        att->defense_skill = WEAPON_PARRY;
        att->defense_weapon = weapons[which];
      } else if((att->defender_tactics)->parry_unarmed) {
        att->defense_action = "parry";
        att->defense_skill = UNARMED_PARRY;
        att->defense_weapon = att->defender;
        att->defense_limb = (att->defender)->query_limbs()[which];
      }
    } else {
      weapons -= ({ 0 });
      if(!sizeof(weapons)) {
        if((att->defender_tactics)->parry_unarmed) {
          att->defense_action = "parry";
          att->defense_skill = UNARMED_PARRY;
          att->defense_weapon = att->defender;
        }
      } else {
        att->defense_action = "parry";
        att->defense_skill = WEAPON_PARRY;
        att->defense_weapon = weapons[random(sizeof(weapons))];
      }
    }
  } else {
    att->defense_action = "dodge";
    att->defense_skill = DODGE;
    att->defense_weapon = 0;
  }
  return att;
}
protected class attack calc_attack_modifier(class attack att) {
  object attacker, attack_weapon, *holding;
  int mod, wep, hld, lght, mntd, hlth, brdn, dist, tact, targ, oth;
  int tmp, tmp2, limbs, dex, num, actions;
  string zone, *attackers;
  attacker = att->attacker;
  dex = attacker->query_dex();
  attack_weapon = att->attack_weapon;
  mod = wep = hld = lght = mntd = hlth = brdn = dist = tact = 0;
  if(attack_weapon != attacker) {
    holding = attacker->query_holding();
    limbs = tmp2 = 0;
    for(num = 0; num < sizeof(holding); num++) {
      if(holding[num] == attack_weapon)
        limbs++;
      else if(holding[num]) {
        if((holding[num])->id("shield"))
          tmp2 += (holding[num])->query_weight() / 5;
        else
          tmp2 += (holding[num])->query_weight();
      }
    }
    switch((att->attacker_tactics)->response) {
    case "both":
      tmp2 = (tmp2 * 3) / 2;
      break;
    case "dodge":
      if(tmp2 < dex)
        tmp2 /= 2;
    }
    wep = attack_weapon->query_weight() + (tmp2 / 2);
    wep /= (limbs + 1);
    wep -= (att->attacker)->query_str();
    if(wep > 0 ) {
      wep = - to_int(pow(wep, 1.4));
    } else
      wep = 0;
    if(dex < 14 && sizeof(holding) && holding[0] != attack_weapon)
      hld = dex - 14;
  } else {
    wep =  (dex * 2) - attacker->query_burden();
  }
  switch(attacker->check_dark(environment(attacker)->query_light())) {
  case -2:
  case 2:
    lght = -50;
    break;
  case -1:
  case 1:
    lght = -25;
    break;
  }
  mntd = 0;
  hlth -= (50 - (attacker->query_hp() * 50) / attacker->query_max_hp());
  tmp = attacker->query_specific_gp("fighting");
  if(tmp < -50)
    hlth += -25;
  else if(tmp < 0)
    hlth += (tmp / 2);
  brdn -= (attacker->query_burden() / 3);
#ifdef USE_DISTANCE
  if(att->attack_weapon == att->attacker)
    dist = -3 * ABS(REACH - att->distance);
  else
    dist = -3 * ABS(REACH + (att->attack_weapon)->query_length() -
                    att->distance);
#endif
  switch((att->attacker_tactics)->attitude) {
  case "insane":
    tact = 25;
    break;
  case "offensive":
    tact = 15;
    break;
  case "defensive":
    tact = -25;
    break;
  case "wimp":
    tact = -50;
    break;
  }
  switch(att->attacker_tactics->focus_zone) {
  case 0:
  case "none":
    targ = 0;
    break;
  case "upper body":
  case "lower body":
    targ -= 25;
    break;
  default:
    tmp = 0;
    foreach(zone in ((att->opponent)->query_race_ob())->query_target_zones())
      if(zone == att->target_zone)
        tmp++;
    num = sizeof(((att->opponent)->query_race_ob())->query_target_zones());
    targ -= ((num - tmp) * 25 / num);
  }
  if(targ < -25) {
    debug_printf("Targ too small (%s) %d. num: %d, tmp: %d\n",
                 (att->attacker_tactics)->focus_zone, targ, num,tmp);
    targ = -25;
  }
  attackers = filter((att->opponent)->query_attacker_list(),
                     (: $1 && environment($1) == environment(this_object()):));
  num = member_array(this_object(), attackers);
  if(num > 1)
    num += -25 * num;
  if((att->attacker_tactics)->attack == "both")
    oth += 5;
  mod = wep + hld + lght + mntd + hlth + brdn + dist + tact + targ + oth + num;
  att->attack_modifier += mod;
  actions += ATTACK_COST;
  if(attack_weapon != att->attacker)
    actions += (sqrt(attack_weapon->query_weight()) * 3) / (limbs + 1);
  if(sizeof((att->attacker)->query_weapons()) > 1)
    actions -= ATTACK_COST / 4;
  actions -= ((att->attacker)->query_skill_bonus(att->attack_skill) +
              (att->attacker)->query_skill_bonus(TACTICAL_SKILL)) / 50;
  if(actions < ATTACK_COST / 5)
    actions = ATTACK_COST / 5;
  else if(actions > ATTACK_COST * 2)
    actions = ATTACK_COST * 2;
  att->attack_cost = actions;
#if DEBUG == 1
  combat_debug("Attack %s (%s): wep: %d hld: %d lght: %d mntd: %d "
               "hlth: %d brdn: %d dist: %d tact: %d targ: %d oth: %d "
               "num: %d = %d [%d] (actions: %d %d)",
               att->attack_data[AT_NAME],
               (att->attack_weapon)->query_name(),
               wep, hld, lght, mntd, hlth, brdn, dist, tact, targ, oth, num,
               mod, att->attack_modifier, actions, att->attacker_defecit);
#endif
  return att;
}
class attack calc_defense_modifier(class attack att) {
  object defender, attacker, attack_weapon, defense_weapon, *holding;
  int mod, wep, wght, dist, brdn, hnd, lght, hlth, tact, prot, oth;
  int tmp, num, dex, limbs, actions;
  mod = wep = wght = dist = brdn = hnd = lght = hlth = tact = prot = oth = 0;
  defender = att->defender;
  defense_weapon = att->defense_weapon;
  dex = defender->query_dex();
  attacker = att->attacker;
  attack_weapon = att->attack_weapon;
  switch(att->defense_action) {
  case "parry":
    if(defense_weapon != defender && defense_weapon) {
      holding = defender->query_holding();
      if(defense_weapon->id("shield"))
        wep = defense_weapon->query_weight() / 5;
      else
        wep = defense_weapon->query_weight() * 2;
      limbs = 0;
      for(num = 0; num < sizeof(holding); num++)
        if(holding[num] && holding[num] == defense_weapon)
          limbs++;
      wep /= (limbs + 2);
      if(wep > defender->query_str())
        wep = - to_int(pow(wep - defender->query_str(), 1.3));
      if(attack_weapon != attacker)
        wght = 2 * (defense_weapon->query_weight() -
                    attack_weapon->query_weight());
      else
        wght = defense_weapon->query_weight() / 2;
      if(wght > 5)
        wght = 5;
#ifdef USE_DISTANCE
      dist = - ABS(REACH + defense_weapon->query_length() - att->distance);
#endif
    } else {
#ifdef USE_DISTANCE
      dist = - ABS(REACH - att->distance);
#endif
    }
    brdn = -(defender->query_burden() / 3);
    if(sizeof(holding)) {
      if(dex < 14 && holding[0] != defense_weapon)
        hnd = dex - 14;
      holding = uniq_array(filter(holding, (: $1 :)));
      if(dex  < 16 && sizeof(holding) == 1)
        hnd += dex - 16;
    }
    break;
  case "dodge":
    brdn = -(defender->query_burden() / 3);
    if(dex < (defender->query_burden() / 2))
      brdn -= dex - (defender->query_burden() / 2);
    if(att->attack_weapon != att->attacker)
      wght = ((att->attack_weapon)->query_weight() / 10);
    break;
  }
  if(!(att->attacker)->query_visible(defender))
    lght = -100;
  else {
    switch(defender->check_dark(environment(defender)->query_light())) {
    case -2:
    case 2:
      lght = -50;
      break;
    case -1:
    case 1:
      lght = -25;
      break;
    }
  }
  hlth = - (25 - (defender->query_hp() * 25) / defender->query_max_hp());
  tmp = defender->query_specific_gp("fighting");
  if(tmp < -50)
    hlth += -25;
  else if(tmp < 0)
    hlth += (tmp / 2);
  switch((att->defender_tactics)->attitude) {
  case "insane":
    tact = -50;
    break;
  case "offensive":
    tact = -25;
    break;
  case "defensive":
    tact = 15;
    break;
  case "wimp":
    tact = 25;
    break;
  }
  prot = 0;
  if(defender != att->opponent) {
    if(defender != att->person_hit) {
      if(defense_weapon->id("shield"))
        prot -= 15;
      prot -= 15;
    }
    prot -= 15;
  }
  if((att->defender_tactics)->response == "both")
    oth += 5;
  if(defender->query_casting_spell())
    oth -= 25;
  mod = wep + wght + dist + brdn + hnd + lght + hlth + tact + prot + oth;
  att->defense_modifier += mod;
  if(att->defense_action != "none") {
    actions = DEFENSE_COST;
    actions -= ((att->defender)->query_skill_bonus(att->defense_skill) +
      (att->attacker)->query_skill_bonus(TACTICAL_SKILL)) / 50;
    if(att->defense_weapon && att->defense_weapon != att->defender) {
      if((att->defense_weapon)->id("shield"))
        actions += sqrt(att->defense_weapon->query_weight() / 4);
      else {
        actions += sqrt((att->defense_weapon->query_weight() * 2) /
                        (limbs + 1));
        if(sizeof((att->defender)->query_weapons()) > 1)
          actions -= DEFENSE_COST / 4;
      }
    } else if(att->defense_action == "dodge")
      actions += sqrt(defender->query_burden());
    if(actions < DEFENSE_COST / 5)
      actions = DEFENSE_COST / 5;
    else if(actions > DEFENSE_COST * 2)
      actions = DEFENSE_COST * 2;
    att->defense_cost = actions;
  }
#if DEBUG == 1
  combat_debug("Defense %s (%s): wep: %d wght: %d dist: %d "
               "brdn: %d hnd: %d lght: %d hlth: %d tact: %d prot: %d "
               "oth: %d = %d [%d] (actions: %d %d)",
               att->defense_action,
               att->defense_weapon ? (att->defense_weapon)->query_name() : "",
               wep, wght, dist, brdn, hnd, lght, hlth, tact, prot, oth,
               mod, att->defense_modifier, actions, att->defender_defecit);
#endif
  return att;
}
protected class attack calc_damage(class attack att) {
  int damage, weapon_damage;
  object attacker;
  attacker = att->attacker;
  damage = att->attack_data[AT_DAMAGE];
  weapon_damage = damage;
  if(att->attack_weapon != attacker)
    damage = sqrt(damage * attacker->query_skill_bonus(att->attack_skill));
  if(damage > 3 * weapon_damage)
    damage = 3 * weapon_damage;
  damage *= COMBAT_SPEED;
  att->damage = damage;
  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    switch(att->degree) {
    case TASKER_CRITICAL:
      att->damage *= 2;
      break;
    case TASKER_EXCEPTIONAL:
      att->damage = (att->damage * 3) / 2;
    case TASKER_MARGINAL:
      att->damage /= 2;
      break;
    }
    break;
  case DEFAWARD:
  case DEFWIN:
    switch(att->degree) {
    case TASKER_CRITICAL:
      att->defense_cost = 0;
      break;
    case TASKER_EXCEPTIONAL:
      att->defense_cost /= 2;
      break;
    case TASKER_MARGINAL:
      att->defense_cost *= 2;
      break;
    }
    att->damage = 0;
  }
  combat_debug("Damage: %d %d",
               att->damage,
               attacker->query_skill_bonus(att->attack_skill));
  return att;
}
class attack calc_armour_protection(class attack att) {
  object person_hit;
  string armour_zone, damage_type;
  if(!att->damage || (att->result != OFFWIN && att->result != OFFAWARD))
    return att;
  person_hit = att->person_hit;
  armour_zone = (person_hit->query_race_ob())->
    map_armour_zone(att->target_zone);
  damage_type = att->attack_data[AT_TYPE];
  if(damage_type == "unarmed")
    damage_type = "blunt";
  att->armour_stopped = (int)person_hit->query_ac(damage_type, att->damage,
                                                  armour_zone);
  if(att->armour_stopped < 0) {
    debug_printf("armour stopped %d for %s %d %s",
                 att->armour_stopped, damage_type, att->damage, armour_zone);
    att->armour_stopped = 0;
  }
  return att;
}
protected class attack damage_weapon(class attack att) {
  int off_damage, def_damage;
  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    if(att->armour_stopped && att->degree)
      off_damage = att->armour_stopped / att->degree;
    break;
  case DEFWIN:
  case DEFAWARD:
    if(att->defense_action == "parry" && att->damage && att->degree) {
      off_damage = att->damage * (att->degree - 1);
      def_damage = att->damage / att->degree;
    }
    break;
  }
  if(off_damage) {
    if(att->attack_weapon == att->attacker)
      if((att->attack_weapon)->query_hp() > (off_damage / 10))
        (att->attack_weapon)->adjust_hp(- (off_damage / 10), att->defender,
                                        att->defense_weapon,
                                        "hitting someone.");
    else if(function_exists("hit_weapon", att->attack_weapon))
      (att->attack_weapon)->hit_weapon(off_damage, att->attack_data[AT_SKILL]);
    else
      (att->attack_weapon)->do_damage(att->attack_data[AT_SKILL], off_damage);
  }
  if(def_damage) {
    if(att->defense_weapon == att->defender)
      (att->defense_weapon)->adjust_hp(- def_damage, att->attacker,
                                       att->attack_weapon,
                                       "parrying an attack with a limb.");
    else if(function_exists("hit_weapon", att->defense_weapon))
      (att->defense_weapon)->hit_weapon(def_damage,
                                        att->attack_data[AT_SKILL]);
    else
      (att->defense_weapon)->do_damage(att->attack_data[AT_SKILL], def_damage);
  }
  return att;
}
protected class attack prepare_messages(class attack att) {
  object attacker, opponent, defender, person_hit;
  string *verb, def_short, margin;
  string *def_mess, *att_mess;
  int damage, armour_stopped;
  attacker = att->attacker;
  opponent = att->opponent;
  defender = att->defender;
  person_hit = att->person_hit;
  damage = att->damage;
  armour_stopped = att->armour_stopped;
  switch(att->result) {
  case OFFAWARD:
    tell_object(att->attacker,
                "%^YELLOW%^"+ replace(({ "You feel "
                "that your skill with $weapon$ has increased.", "You "
                "feel more able to use $weapon$.", "You seem to be a "
                "step closer to mastering $weapon$." })[random(3)],
                "$weapon$", (att->attack_weapon == att->attacker ?
                "unarmed combat" : (string)(att->attack_weapon)->a_short())) +
                "%^RESET%^\n" );
  case OFFWIN:
    if(person_hit == opponent) {
      att_mess = ATTACK_MESSAGE->query_message(damage - armour_stopped,
                                               att->attack_data[AT_SKILL],
                                               opponent, attacker,
                                               att->attack_data[AT_NAME],
                                               att->attack_weapon,
                                               att->target_zone);
      if(sizeof(att_mess) != 3) {
        att_mess = ({"You hit "+opponent->the_short()+"",
                       attacker->the_short()+" hits you",
                       attacker->the_short()+" hits "+opponent->the_short()});
      }
      att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
    } else {
      att_mess = ATTACK_MESSAGE->query_message(damage - armour_stopped,
                                               att->attack_data[AT_SKILL],
                                               opponent, attacker,
                                               att->attack_data[AT_NAME],
                                               att->attack_weapon,
                                               att->target_zone);
      if(sizeof(att_mess) != 3) {
        att_mess = ({"You almost hit "+opponent->the_short()+"",
                       attacker->the_short()+" almost hits you",
                       attacker->the_short()+" almost hits "+
                       opponent->the_short()});
      }
      att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
      att_mess[M_ATTACKER] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects " +
        opponent->query_objective();
      att_mess[M_OPPONENT] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects you";
      att_mess[M_SPECTATORS] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects " +
        opponent->query_objective();
      if(defender == person_hit)
        att_mess[M_DEFENDER] += " but at the last second " +
          person_hit->the_short() + " leap in and protect " +
          opponent->query_objective();
      else
        att_mess[M_DEFENDER] += " but at the last second " +
          person_hit->the_short() + " leaps in and protects " +
          opponent->query_objective();
      att_mess[M_PERSON_HIT] += " but at the last second you leap in and "
        "protect " + opponent->query_objective();
    }
    break;
  case DEFAWARD:
  case DEFWIN:
    att_mess = ATTACK_MESSAGE->query_message(0,
                                             att->attack_data[AT_SKILL],
                                             opponent, attacker,
                                             att->attack_data[AT_NAME],
                                             att->attack_weapon,
                                             att->target_zone);
    if(sizeof(att_mess) != 3) {
      att_mess = ({"You try to hit "+opponent->the_short()+"",
                     attacker->the_short()+" tries to hit you",
                     attacker->the_short()+" tries to hit "+
                     opponent->the_short()});
    }
    att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
    break;
  }
  def_mess = allocate(5);
  def_mess[M_ATTACKER] = def_mess[M_OPPONENT] = def_mess[M_SPECTATORS] =
    def_mess[M_DEFENDER] = def_mess[M_PERSON_HIT] = "";
  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    if(armour_stopped && armour_stopped > damage / 3) {
      if(objectp(att->stopped_by)) {
        def_mess[M_ATTACKER] = " but " + (att->stopped_by)->poss_short();
        def_mess[M_OPPONENT] = def_mess[M_ATTACKER];
        def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
        def_mess[M_DEFENDER] = def_mess[M_ATTACKER];
        def_mess[M_PERSON_HIT] = def_mess[M_ATTACKER];
      } else if(att->stopped_by) {
        def_mess[M_ATTACKER] = " but " + person_hit->query_possessive() +
          " " + att->stopped_by;
        if(person_hit == opponent)
          def_mess[M_OPPONENT] = " but your " + att->stopped_by;
        else
          def_mess[M_OPPONENT] = def_mess[M_ATTACKER];
        def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
        if(person_hit == defender)
          def_mess[M_DEFENDER] = " but your " + att->stopped_by;
        else
          def_mess[M_DEFENDER] = def_mess[M_ATTACKER];
        def_mess[M_PERSON_HIT] = " but your " + att->stopped_by;
      }
      if(!damage || armour_stopped >= damage) {
        def_mess[M_ATTACKER] += " absorbs all of";
        def_mess[M_OPPONENT] += " absorbs all of";
        def_mess[M_SPECTATORS] += " absorbs all of";
        def_mess[M_DEFENDER] += " absorbs all of";
        def_mess[M_PERSON_HIT] += " absorbs all of";
      } else if(armour_stopped > (damage * 2 / 3)) {
        def_mess[M_ATTACKER] += " absorbs most of";
        def_mess[M_OPPONENT] += " absorbs most of";
        def_mess[M_SPECTATORS] += " absorbs most of";
        def_mess[M_DEFENDER] += " absorbs most of";
        def_mess[M_PERSON_HIT] += " absorbs most of";
      } else {
        def_mess[M_ATTACKER] += " absorbs some of";
        def_mess[M_OPPONENT] += " absorbs some of";
        def_mess[M_SPECTATORS] += " absorbs some of";
        def_mess[M_DEFENDER] += " absorbs some of";
        def_mess[M_PERSON_HIT] += " absorbs some of";
      }
      def_mess[M_ATTACKER] += " the blow";
      def_mess[M_OPPONENT] += " the blow";
      def_mess[M_SPECTATORS] += " the blow";
      def_mess[M_DEFENDER] += " the blow";
      def_mess[M_PERSON_HIT] += " the blow";
    }
    break;
  case DEFAWARD:
    if(att->defense_action == "parry") {
      if(att->defense_weapon && (att->defense_weapon)->query_weapon())
        verb = ({ "parry", "parries", "parrying" });
      else
        verb = ({ "block", "blocks", "blocking" });
      tell_object(att->defender,
                  "%^YELLOW%^"+ replace( ({ "You move more surely "
               "than you thought you could in $verbing$ $attacker$'s attack",
               "You just manage to $verb$ $attacker$'s attack, but you'll "
               "know better next time", "You feel better at $verbing$ as "
               "you $verb$ $attacker$'s attack" })[ random( 3 ) ],
               ({ "$verb$", verb[ 0 ], "$verbing$", verb[ 2 ], "$attacker$",
               (string)(att->attacker)->the_short() }) ) +".%^RESET%^\n" );
    } else if(att->defense_action == "dodge") {
      tell_object(att->defender,
                   "%^YELLOW%^"+ replace( ({ "You move more nimbly "
               "than you thought you could in dodging $attacker$", "You "
               "managed to predict $attacker$'s attack, letting you dodge it "
               "more easily", "You feel better at dodging as you avoid "
               "$attacker$'s attack" })[ random( 3 ) ], "$attacker$",
               (string)(att->attacker)->the_short() ) +".%^RESET%^\n" );
    }
  case DEFWIN:
    def_mess = allocate(5);
    def_mess[M_ATTACKER] = "";
    def_mess[M_OPPONENT] = "";
    def_mess[M_SPECTATORS] = "";
    def_mess[M_DEFENDER] = "";
    def_mess[M_PERSON_HIT] = "";
    switch(att->degree) {
    case TASKER_MARGINAL:
      margin = "just ";
      break;
    case TASKER_EXCEPTIONAL:
      margin = "deftly ";
      break;
    case TASKER_MARGINAL:
      margin = "easily ";
      break;
    default:
      margin = "";
      break;
    }
    if(att->defense_action == "parry" && att->defense_weapon) {
      if(defender == opponent)
        def_mess[M_ATTACKER] = " but " + defender->query_pronoun() + " " +
          margin;
      else
        def_mess[M_ATTACKER] = " but " + defender->the_short() + " " + margin;
      if(defender == opponent)
        def_mess[M_OPPONENT] = " but you " + margin;
      else
        def_mess[M_OPPONENT] = def_mess[M_ATTACKER];
      def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
      def_mess[M_DEFENDER] = " but you " + margin;
      def_mess[M_PERSON_HIT] = def_mess[M_ATTACKER];
      if(att->defense_weapon != defender &&
         !(att->defense_weapon)->id("shield")) {
        def_mess[M_ATTACKER] += "parries";
        if(defender == opponent)
          def_mess[M_OPPONENT] += "parry";
        else
          def_mess[M_OPPONENT] += "parries";
        def_mess[M_SPECTATORS] += "parries";
        def_mess[M_DEFENDER] += "parry";
        if(att->person_hit == att->defender)
          def_mess[M_PERSON_HIT] += "parry";
        else
          def_mess[M_PERSON_HIT] += "parries";
      } else {
        def_mess[M_ATTACKER] += "blocks";
        if(defender == opponent)
          def_mess[M_OPPONENT] += "block";
        else
          def_mess[M_OPPONENT] += "blocks";
        def_mess[M_SPECTATORS] += "blocks";
        def_mess[M_DEFENDER] += "block";
        if(att->person_hit == att->defender)
          def_mess[M_PERSON_HIT] += "block";
        else
          def_mess[M_PERSON_HIT] += "blocks";
      }
      if(att->defense_weapon != defender) {
        def_short = (att->defense_weapon)->short();
      } else if(att->defense_limb) {
        def_short = att->defense_limb;
      } else
        def_short = (defender->query_race_ob())->map_target_zone("hands");
      def_mess[M_ATTACKER] += " the blow with " +
        defender->query_possessive() + " " + def_short;
      if(defender == opponent)
        def_mess[M_OPPONENT] += " the blow with your " + def_short;
      else
        def_mess[M_OPPONENT] += " the blow with " +
          defender->query_possessive() + " " + def_short;
      def_mess[M_SPECTATORS] += " the blow with " +
        defender->query_possessive() + " " + def_short;
      def_mess[M_DEFENDER] += " the blow with your " + def_short;
      if(defender == person_hit)
        def_mess[M_PERSON_HIT] += " the blow with your " + def_short;
            else
        def_mess[M_PERSON_HIT] += " the blow with " +
          defender->query_possessive() + " " + def_short;
    } else if(att->defense_action == "dodge") {
      def_mess[M_ATTACKER] = " but " + defender->query_pronoun() + " " +
        margin + "dodges out of the way";
      def_mess[M_OPPONENT] = " but you " + margin + "dodge out of the way";
      def_mess[M_SPECTATORS] = " but " + defender->query_pronoun() + " " +
        margin + "dodges out of the way";
    } else {
      def_mess[M_ATTACKER] = " but, although unable to defend, " +
        defender->query_pronoun() + " somehow avoids the attack";
      def_mess[M_OPPONENT] = " but, although unable to defend, you somehow "
        "avoid the attack";
      def_mess[M_SPECTATORS] = " but, although unable to defend, " +
        defender->query_pronoun() + " somehow avoids the attack";
    }
  }
  att->attack_messages = att_mess;
  att->defense_messages = def_mess;
  if(att->result == DEFAWARD || att->result == DEFWIN || !damage ||
     armour_stopped >= damage)
    att->verbose = 1;
  return att;
}
protected class attack write_messages(class attack att) {
  int verbose;
  verbose = att->verbose;
  (att->attacker)->event_combat(att->attacker,
                                att->attack_messages[M_ATTACKER] +
                                att->defense_messages[M_ATTACKER] + ".\n",
                                ({ }), verbose);
  (att->opponent)->event_combat(att->opponent,
                                att->attack_messages[M_OPPONENT] +
                                att->defense_messages[M_OPPONENT] + ".\n",
                                ({ }), verbose);
  if(att->defender != att->opponent &&
     sizeof(att->attack_messages) > M_DEFENDER)
    (att->defender)->event_combat(att->defender,
                                  att->attack_messages[M_DEFENDER] +
                                  att->defense_messages[M_DEFENDER] + ".\n",
                                  ({ }), verbose);
  if(att->person_hit != att->opponent && att->person_hit != att->defender &&
     sizeof(att->attack_messages) > M_PERSON_HIT)
    (att->person_hit)->event_combat(att->person_hit,
                                    att->attack_messages[M_PERSON_HIT] +
                                    att->defense_messages[M_PERSON_HIT] +
                                    ".\n", ({ }), verbose);
  event(environment(att->attacker), "combat",
        att->attack_messages[M_SPECTATORS] +
        att->defense_messages[M_SPECTATORS] + ".\n",
        ({ att->attacker, att->opponent, att->defender, att->person_hit }),
        verbose);
  return att;
}
protected void adjust_actions(class attack att) {
  int tmp;
  if((att->attacker)->query_time_left() > 0)
    (att->attacker)->adjust_time_left(-DEFAULT_TIME);
  (att->attacker)->adjust_action_defecit(att->attack_cost);
  (att->opponent)->adjust_action_defecit(att->defense_cost);
  if(att->defender != att->opponent)
    (att->defender)->adjust_action_defecit(DEFENSE_COST);
  if(att->person_hit != att->opponent)
    (att->person_hit)->adjust_action_defecit(DEFENSE_COST);
  tmp = ATTACK_GP[(att->attacker_tactics)->attitude];
  (att->attacker)->adjust_gp(-tmp);
  if(att->defender != att->opponent) {
    tmp = DEFENDER_GP[(att->defender_tactics)->attitude];
    (att->defender)->adjust_gp(-tmp);
  } else if(att->defense_action != "none") {
    tmp = DEFENSE_GP[(att->defender_tactics)->attitude];
    (att->opponent)->adjust_gp(-tmp);
  }
  if(att->person_hit != att->opponent) {
    tmp = DEFENDER_GP[(att->person_hit)->query_combat_attitude()];
    (att->person_hit)->adjust_gp(-tmp);
  }
}
protected class attack perform_movement(class attack att) {
  int ideal, move_cost, closer;
  ideal = DISTANCES[(att->attacker_tactics)->ideal_distance];
  if(ABS(ideal - att->distance) >
     MOVE_DISTANCE[(att->attacker_tactics)->attitude]) {
    if(att->distance > ideal)
      closer = 1;
    move_cost = MOVE_COST;
    move_cost -= (att->attacker)->query_skill_bonus(MOVE_SKILL) / 30;
    if(move_cost > 0)
      att->attack_cost += MOVE_COST;
    switch(TASKER->compare_skills(att->attacker, MOVE_SKILL,
                                  att->defender, MOVE_SKILL,
                                  att->attack_modifier -
                                  att->defense_modifier,
                                  TM_CONTINUOUS, TM_CONTINUOUS, 0)) {
    case OFFAWARD:
      tell_object(att->attacker,
                  "%^YELLOW%^You feel that your tactical skill has increased."
                  "%^RESET%^\n");
    case OFFWIN:
      if(closer) {
        (att->attacker)->event_combat(att->attacker, "You move in closer to " +
                                      (att->opponent)->one_short() + ".\n",
                                      ({ }), 0);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " moves in closer to you.\n", ({ }), 0);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() +
              " moves in closer to " + (att->opponent)->one_short() + ".\n",
              ({ att->attacker, att->opponent }), 1);
        set_distance(att->opponent, query_distance(att->opponent) -
                     DISTANCE_STEP);
        (att->opponent)->set_distance(att->attacker,
                                      query_distance(att->opponent));
      } else {
        (att->attacker)->event_combat(att->attacker,
                                      "You move further away from " +
                                      (att->opponent)->one_short() + ".\n",
                                      ({ }), 0);
        (att->opponent)->event_combat(att->opponent,
                                     (att->attacker)->one_short() +
                                     " moves further away from you.\n",
                                     ({ }), 0);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() + " moves further away from " +
              (att->opponent)->one_short() + ".\n",
              ({ att->attacker, att->opponent }), 1);
        set_distance(att->opponent, query_distance(att->opponent) +
                     DISTANCE_STEP);
        (att->opponent)->set_distance(att->attacker,
                                      query_distance(att->opponent));
      }
      break;
    case DEFAWARD:
      tell_object(att->opponent,
                  "%^YELOW%^You feel that your tactical skill has increased."
                  "%^RESET%^\n");
    case DEFWIN:
      if(closer) {
        (att->attacker)->event_combat(att->attacker,
                                      "You try to move in closer to " +
                                      (att->opponent)->one_short() +
                                      " but cannot find "
                                      "an opportunity.\n", ({ }), 1);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " tries to move in closer to you "
                                      "but you don't give " +
                                      (att->attacker)->query_objective() +
                                      " an opporunity.\n", ({ }), 1);
        event(environment(att->attacker), (att->attacker)->one_short() +
              " tries to move in closer to " +
              (att->opponent)->one_short() + " but " +
              (att->opponent)->query_pronoun() + " doesn't give " +
              (att->attacker)->query_objective() + " an opportunity.\n",
              ({ att->attacker, att->opponent }), 1);
      } else {
        (att->attacker)->event_combat(att->attacker,
                                      "You try to move further away from  " +
                                      (att->opponent)->one_short() +
                                      " but cannot find an opportunity.\n",
                                      ({ }), 1);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " tries to move further away from you "
                                      "but you don't give " +
                                      (att->attacker)->query_objective() +
                                      " an opporunity.\n", ({ }) , 1);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() +
              " tries to move further away from " +
              (att->opponent)->one_short() + " but " +
              (att->opponent)->query_pronoun() + " doesn't give " +
              (att->attacker)->query_objective() + " an opportunity.\n",
              ({ att->attacker, att->opponent }), 1);
      }
    }
  }
  return att;
}
protected class attack after_attack(class attack att) {
  string *locations;
  int total, count, lperc, hperc;
#ifdef USE_DISTANCE
  if((att->result == OFFWIN || att->result == OFFAWARD) &&
     (att->attacker_tactics)->ideal_distance &&
     environment(att->attacker) == environment(att->opponent))
    att = perform_movement(att);
#endif
  adjust_actions(att);
  if((att->damage - att->armour_stopped) <= 0)
    return att;
  if((environment(att->person_hit) == environment(att->attacker)) &&
     (att->result == OFFWIN || att->result == OFFAWARD)) {
    (att->attack_weapon)->attack_function(att->attack_data[AT_NAME],
                                          att->damage - att->armour_stopped,
                                          att->person_hit, att->attacker);
  }
  locations = (att->defender->query_race_ob())->query_target_zones();
  total = sizeof(locations);
  tmpzone = att->target_zone;
  locations = filter(locations, (: $1 == tmpzone :));
  count = sizeof(locations);
  lperc = (count * 100) / total;
  if(att->degree == TASKER_CRITICAL) {
    hperc = ((att->damage - att->armour_stopped) * 100) /
      (att->opponent)->query_max_hp();
    if(lperc < hperc) {
      switch(att->target_zone) {
      case "head":
        break;
      case "chest":
      case "stomach":
        break;
      case "arm":
        break;
      case "leg":
        break;
      }
    }
  }
  return att;
}
protected mixed *call_special(int stage, class attack att) {
  class combat_special *tmp;
  mixed *result;
  int i;
  if(!this_object()->query_no_specials()) {
    tmp = att->attacker_specials;
    for(i=0; i<sizeof(tmp); i++) {
      if((tmp[i]->type & T_OFFENSIVE) && (tmp[i]->events & stage)) {
        if(functionp(tmp[i]->callback))
          result = evaluate(tmp[i]->callback, stage, att, tmp[i]->data);
        else if(arrayp(tmp[i]->callback)) {
          if(!tmp[i]->callback[0] || !tmp[i]->callback[1]) {
            (att->attacker)->remove_special(tmp[i]->id);
          } else
            result = call_other(tmp[i]->callback[0], tmp[i]->callback[1],
                                stage, att, tmp[i]->data);
        }
        if(sizeof(result)) {
          if(!classp(result[1])) {
            debug_printf("Error, call_special received invalid return "
                         "data. %O when calling %O stage %d\n", result,
                         tmp[i]->callback, stage);
            result[0] = R_REMOVE_ME | R_ABORT;
          }
          if(result[0] & R_REMOVE_ME) {
            (att->attacker)->remove_special(tmp[i]->id);
          } else {
            tmp[i]->data = result[2];
            (att->attacker)->set_special_data(tmp[i]->id, result[2]);
          }
          if(result[0] & R_ABORT)
            return result;
          if((result[0] & R_DONE) || (result[0] & R_CONTINUE))
            break;
        }
      }
    }
  }
  if(att->defender && !(att->defender)->query_no_specials()) {
    tmp = att->defender_specials;
    for(i=0; i<sizeof(tmp); i++) {
      if((tmp[i]->type & T_DEFENSIVE) && (tmp[i]->events & stage)) {
        if(functionp(tmp[i]->callback))
          result = evaluate(tmp[i]->callback, stage, att, tmp[i]->data);
        else if(arrayp(tmp[i]->callback)) {
          if(!tmp[i]->callback[0] || !tmp[i]->callback[1]) {
            (att->defender)->remove_special(tmp[i]->id);
          } else
            result = call_other(tmp[i]->callback[0], tmp[i]->callback[1],
                                stage, att, tmp[i]->data);
        }
        if(sizeof(result)) {
          if(!classp(result[1])) {
            debug_printf("Error, call_special received invalid return "
                         "data. %O when calling %O stage %d", result,
                         tmp[i]->callback, stage);
            result[0] = R_REMOVE_ME | R_ABORT;
          }
          if(result[0] & R_REMOVE_ME) {
            (att->defender)->remove_special(tmp[i]->id);
          } else {
            (att->defender)->set_special_data(tmp[i]->id, result[2]);
          }
          if(result[0] & R_ABORT)
            return result;
          if((result[0] & R_DONE) || (result[0] & R_CONTINUE))
            break;
        }
      }
    }
  }
  return result;
}
void do_attack() {
  class tasker_result result;
  class attack att;
  mixed *sp_result;
  int modifier, tmp;
  init_tactics();
  if(_callout)
    _callout = remove_call_out("announce_intent");
  att = new(class attack,
            attacker : this_object(),
            attacker_tactics : this_object()->query_tactics(),
            attacker_specials : this_object()->query_specials(),
            attacker_concentrating : this_object()->query_concentrating(),
            attacker_defecit : this_object()->query_action_defecit(),
            attacker_last_opponent : this_object()->query_last_opponent(),
            attacker_last_weapon : this_object()->query_last_weapon(),
            attacker_last_action : this_object()->query_last_action(),
            attacker_last_result : this_object()->query_last_result(),
            repeat : 0
            );
  sp_result = call_special(E_OPPONENT_SELECTION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->choose_opponent(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  if(!(att->opponent) || !(att->opponent)->attack_by(att->attacker)) {
    combat_debug("No opponent chosen, aborting attack");
    return;
  }
  event(environment(att->attacker), "fight_in_progress", att->opponent);
  clear_protection(att->attacker, att->opponent);
  _combat->last_opponent = att->opponent;
  do {
    sp_result = call_special(E_DEFENDER_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = (att->opponent)->choose_defender(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;
    att->defender_tactics = (att->defender)->query_tactics();
    att->defender_concentrating = (att->defender)->query_concentrating();
    att->defender_last_opponent = (att->defender)->query_last_opponent();
    att->defender_last_action = (att->defender)->query_last_action();
    att->defender_last_result = (att->defender)->query_last_result();
    att->defender_defecit = (att->defender)->query_action_defecit();
    att->defender_specials = (att->defender)->query_specials();
    clear_protection(att->attacker, att->defender);
    sp_result = call_special(E_ATTACK_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = this_object()->choose_attack(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;
    if(!att->attack_weapon || !sizeof(att->attack_data) || !att->attack_skill){
      combat_debug("Missing attack weapon, attack data or attack skill, "
                   "aborting attack.");
      return;
    }
    _combat->last_action = att->attack_data[AT_NAME];
    _combat->last_weapon = att->attack_weapon;
    sp_result = call_special(E_DEFENSE_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = (att->defender)->choose_defense(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;
    (att->opponent)->set_last_opponent(att->attacker);
    if(att->opponent != att->defender)
      (att->defender)->set_last_opponent(att->attacker);
    (att->defender)->set_last_action(att->defense_action);
    (att->defender)->set_last_weapon(att->defense_weapon);
    if(att->person_hit != att->opponent && att->person_hit != att->defender)
      (att->person_hit)->set_last_opponent(att->attacker);
    sp_result = call_special(E_ATTACK_MODIFIER, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU) {
      att = this_object()->calc_attack_modifier(att);
    } else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1])) {
      att = (class attack)sp_result[1];
    } else
      return;
    if(!att->defense_action || att->defense_action == "none")
      att->defense_modifier += -1000;
    else {
      sp_result = call_special(E_DEFENSE_MODIFIER, att);
      if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
        att = (att->defender)->calc_defense_modifier(att);
      else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
        att = (class attack)sp_result[1];
      else
        return;
    }
    tmp = att->attack_modifier - att->defense_modifier + BALANCE_MOD;
    modifier = tmp;
    if(modifier > 25)
      modifier = sqrt(modifier * 25);
    else if(modifier < -25)
      modifier = -sqrt(-modifier * 25);
    result = TASKER->compare_skills(att->attacker, att->attack_skill,
                                    att->defender, att->defense_skill,
                                    modifier,
                                    TM_CONTINUOUS, TM_CONTINUOUS, 1);
    att->result = result->result;
    att->degree = result->degree;
    _combat->last_result = att->result;
    (att->defender)->set_last_result(att->result);
    if((att->result == OFFWIN || att->result == OFFAWARD) &&
       att->defender != att->opponent && !att->repeat) {
      (att->defender)->adjust_action_defecit(att->defense_cost);
      (att->defender)->adjust_gp(-(DEFENSE_GP[att->defender_tactics->attitude]));
      att->defender = att->opponent;
      att->repeat = 1;
    } else
      att->repeat = 0;
  } while(att->repeat);
  sp_result = call_special(E_DAMAGE_CALCULATION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->calc_damage(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  sp_result = call_special(E_ARMOUR_CALCULATION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = (att->opponent)->calc_armour_protection(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
#if DEBUG == 1
  combat_debug("Outcome: mod: %d, res: %d, deg: %d dam: %d arm: %d",
               att->attack_modifier - att->defense_modifier + BALANCE_MOD,
               att->result, att->degree, att->damage, att->armour_stopped);
#endif
  if(att->result == OFFWIN || att->result == OFFAWARD) {
    att->stopped_by = (att->person_hit)->query_stopped();
#if DEBUG == 2
    combat_debug("hit: %s, weapon: %s damage: %d, armour: %d, reducing hp by "
                 "%d to %d",
                 (att->person_hit)->query_name(),
                 (att->attack_weapon)->query_name(),
                 att->damage,
                 att->armour_stopped,
                 (att->damage - att->armour_stopped),
                 (att->person_hit)->query_hp());
#endif
  }
  att = this_object()->prepare_messages(att);
  if(sizeof(att->attack_messages) != 5 || sizeof(att->defense_messages) != 5) {
    debug_printf("No attack or defense messages.\n");
    return;
  }
  sp_result = call_special(E_WRITE_MESSAGES, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->write_messages(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  if(att->damage - att->armour_stopped > 0)
    (att->person_hit)->adjust_hp(-(att->damage - att->armour_stopped),
                                 att->attacker, att->attack_weapon,
                                 _combat->last_action);
  sp_result = call_special(E_WEAPON_DAMAGE, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->damage_weapon(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  sp_result = call_special(E_AFTER_ATTACK, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->after_attack(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
}
void recalc_hunting_list() {
  mixed ob;
  object tmp;
  tmp = 0;
  foreach(ob in keys(_combat->attacker_list)) {
    if(stringp(ob) && find_player(ob))
      tmp = find_player(ob);
    else if(ob && objectp(ob))
      tmp = ob;
    if(!tmp) {
      _combat->attacker_list = filter_mapping(_combat->attacker_list,(: $1 :));
    } else if(tmp->query_property("dead") ||
              !environment(tmp) ||
               base_name(environment(tmp)) == "/room/rubbish") {
      map_delete(_combat->attacker_list, ob);
    } else if(environment(tmp) != environment() ||
              !tmp->query_visible(this_object())) {
      _combat->hunting_list[ob] = time();
      map_delete(_combat->attacker_list, ob);
    }
  }
  tmp = 0;
  foreach(ob in keys(_combat->hunting_list)) {
    if(stringp(ob) && find_player(ob))
      tmp = find_player(ob);
    else if(ob && objectp(ob))
      tmp = ob;
    if(!tmp) {
      _combat->hunting_list = filter_mapping(_combat->hunting_list, (: $1 :));
      map_delete(_combat->hunting_list, ob);
    } else if(tmp->query_property("dead") ||
              base_name(environment(tmp)) == "/room/rubbish") {
      map_delete(_combat->hunting_list, ob);
    } else if(environment(tmp) == environment() &&
              tmp->query_visible(this_object())) {
      _combat->attacker_list[ob] = INITIAL_DISTANCE;
      map_delete(_combat->hunting_list, ob);
    } else if(_combat->hunting_list[ob] < time() - HUNTING_TIME) {
      this_object()->event_combat(this_object(), "You stop hunting " +
                                  tmp->one_short() + ".\n", ({ }), 1);
      map_delete(_combat->hunting_list, ob);
    }
  }
}
void monitor_points() {
   int hp;
   int max;
   string colour;
#ifdef UNUSED
   this_object()->clear_gp_info();
   if ( (int)this_object()->adjust_gp( -1 ) < 0 )
     return;
#endif
   hp = (int)this_object()->query_hp();
   if(hp < 0)
     hp = 0;
   max = (int)this_object()->query_max_hp();
   switch ( ( hp * 100 ) / max) {
      case 50 .. 100 :
         colour = "%^GREEN%^";
         break;
      case 20 .. 49 :
         colour = "%^YELLOW%^";
         break;
      default :
         colour = "%^RED%^";
   }
   tell_object( this_object(), colour +"Hp: "+ hp +" (" + max + ") Gp: "+
         (int)this_object()->query_gp() +" (" + this_object()->query_max_gp() +
         ") Xp: " + this_object()->query_xp() + "%^RESET%^\n" );
}
void announce_intent(object opponent) {
  int difficulty = 50;
  object *things, ob;
  if(environment(opponent) != environment(this_object()))
    return;
  switch(this_object()->check_dark((int)environment(this_object())->query_light())) {
   case -2:
   case 2:
     difficulty *= 4;
     break;
   case -1:
   case 1:
     difficulty *= 2;
   }
   things = ({ });
   foreach(ob in filter(all_inventory(environment(this_object())),
                        (: $1 &&living($1) :))) {
     switch(TASKER->perform_task(ob, "other.perception", difficulty, TM_FREE)){
     case AWARD:
       tell_object(ob, "%^YELLOW%^You feel very perceptive."
                   "%^RESET%^\n");
     case SUCCEED:
       if(interactive(ob) && !ob->query_verbose("combat"))
         things += ({ ob });
       break;
     case FAIL:
       things += ({ ob });
     }
   }
   opponent->add_message((string)this_object()->one_short() +
                      " $V$0=moves,move$V$ aggressively towards you!\n",
                      ({ }));
   event(environment(opponent), "see", (string)this_object()->one_short() +
          " $V$0=moves,move$V$ aggressively towards "+
          (string)opponent->one_short() +"!\n", this_object(),
          ({ opponent, this_object() }) + things);
}
void start_combat(object opponent) { return; }
void end_combat() { return; }
void heart_beat() {
  int i;
  if(!_combat->in_combat)
    return;
  recalc_hunting_list();
  if(!sizeof(keys(_combat->attacker_list)) &&
     !sizeof(keys(_combat->hunting_list))) {
    for(i=0; i<sizeof(_combat->specials); i++)
      if(!((_combat->specials[i])->type & T_CONTINUOUS))
        _combat->specials -= ({ (_combat->specials)[i] });
    _combat->in_combat = 0;
    adjust_action_defecit(-MAX_ACTION_DEFECIT);
    end_combat();
    return;
  }
  if(!query_attackable() || !sizeof(keys(_combat->attacker_list)))
    return;
  if((!userp(this_object()) ||
     this_object()->query_time_left() == ROUND_TIME) &&
     !this_object()->query_casting_spell()) {
    adjust_action_defecit(-(ACTIONS_PER_HB / (COMBAT_SPEED + 1)));
  }
  if(_combat->hbc++ % COMBAT_SPEED)
    return;
  _combat->hbc = 0;
  if(this_object()->query_monitor() &&
     this_object()->query_monitor() <= ++(_combat->mbc)) {
    monitor_points();
    _combat->mbc = 0;
  }
  do_attack();
  if(!this_object()->query_casting_spell()) {
    adjust_action_defecit(-(ACTIONS_PER_HB / (COMBAT_SPEED + 1)));
    if(_combat->action_defecit < (OFFENSIVE_DEFECITS[_tactics->attitude] / 2)) {
#if DEBUG == 1
      combat_debug("Adding bonus attack for %s", this_object()->query_name());
      debug_printf("Bonus attack for %s [%d, %d]",
                   this_object()->query_name(), _combat->action_defecit,
                   OFFENSIVE_DEFECITS[_tactics->attitude]);
#endif
      call_out("do_attack", 1);
    }
  }
}
int register_special(int type, int events, mixed callback, mixed data) {
  _combat->specials += ({ new(class combat_special,
                              id : ++(_combat->special_id),
                              type : type,
                              events : events,
                              callback : callback,
                              data : data) });
  return _combat->special_id;
}
int remove_special(int id) {
  int i;
  for(i=0; i<sizeof(_combat->specials); i++) {
    if((_combat->specials[i])->id == id) {
      _combat->specials -= ({ (_combat->specials)[i] });
      return 1;
    }
  }
  debug_printf("Failed to remove special %d", id);
  return 0;
}
class combat_special *query_specials() {
  return copy(_combat->specials);
}
void set_specials(class combat_special *specials) {
  _combat->specials = specials;
}
int set_special_data(int id, mixed data) {
  int i;
  for(i=0; i<sizeof(_combat->specials); i++) {
    if((_combat->specials[i])->id == id) {
      _combat->specials[i]->data = data;
      return 1;
    }
  }
  return 0;
}
void adjust_action_defecit(int amount) {
  _combat->action_defecit += amount;
  if(_combat->action_defecit > MAX_ACTION_DEFECIT)
    _combat->action_defecit = MAX_ACTION_DEFECIT;
  else if(_combat->action_defecit < MIN_ACTION_DEFECIT)
    _combat->action_defecit = MIN_ACTION_DEFECIT;
}
int query_action_defecit() { return _combat->action_defecit; }
class tactics query_tactics() {
  init_tactics();
  return copy(_tactics);
}
void set_tactics(class tactics new_tactics) { _tactics = new_tactics; }
string query_combat_attitude() { return _tactics->attitude; }
void set_combat_attitude(string attitude) { _tactics->attitude = attitude; }
string query_combat_response() { return _tactics->response; }
void set_combat_response(string response) { _tactics->response = response; }
string query_combat_attack() { return _tactics->attack; }
void set_combat_attack(string attack) { _tactics->attack = attack; }
string query_combat_parry() { return _tactics->parry; }
void set_combat_parry(string parry) { _tactics->parry = parry; }
int query_unarmed_parry() { return _tactics->parry_unarmed; }
void set_unarmed_parry(int parry) {  _tactics->parry_unarmed = parry; }
string query_combat_mercy() { return _tactics->mercy; }
void set_combat_mercy(string mercy) { _tactics->mercy = mercy; }
string query_combat_focus() { return _tactics->focus_zone; }
void set_combat_focus(string focus) { _tactics->focus_zone = focus; }
string query_combat_distance() { return _tactics->ideal_distance; }
void set_combat_distance(string distance) { _tactics->ideal_distance = distance; }
object *query_protectors() {
  _combat->protectors -= ({ 0 });
   return copy(_combat->protectors + ({ }));
}
int add_protector( object thing ) {
  if(thing == this_object() ||
     thing->query_property("dead") ||
     member_array(this_object(), thing->query_protectors() +
                  thing->query_defenders()) != -1 ||
     member_array(thing, query_attacker_list())  != -1)
    return 0;
  if(member_array(thing, _combat->protectors) == -1)
    _combat->protectors += ({ thing });
  return 1;
}
int remove_protector(object protector) {
  if(member_array(protector, _combat->protectors) == -1)
    return 0;
  _combat->protectors -= ({ protector });
  return 1;
}
void reset_protectors() {
  _combat->protectors = ({ });
}
object *query_defenders() {
  _combat->defenders -= ({ 0 });
   return copy(_combat->defenders + ({ }));
}
int add_defender( object thing ) {
  if(thing == this_object() ||
     thing->query_property("dead") ||
     member_array(this_object(), thing->query_defenders() +
                  thing->query_protectors()) != -1 ||
     member_array(thing, query_attacker_list())  != -1)
    return 0;
  if(member_array(thing, _combat->defenders) == -1)
    _combat->defenders += ({ thing });
  return 1;
}
int remove_defender(object defender) {
  if(member_array(defender, _combat->defenders) == -1)
    return 0;
  _combat->defenders -= ({ defender });
  return 1;
}
void reset_defenders() {
  _combat->defenders = ({ });
}
#ifdef USE_DISTANCE
int set_distance(object opponent, int distance) {
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      return 0;
    _combat->attacker_list[opponent->query_name()] = distance;
  } else {
    if(!_combat->attacker_list[opponent])
      return 0;
    _combat->attacker_list[opponent] = distance;
  }
  return 1;
}
int query_distance(object opponent) {
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      return 0;
    return _combat->attacker_list[opponent->query_name()];
  } else {
    if(!_combat->attacker_list[opponent])
      return 0;
    return _combat->attacker_list[opponent];
  }
}
#endif
object *query_attacker_list() {
  return uniq_array(map(keys(_combat->attacker_list) +
                        keys(_combat->hunting_list),
                        (: $1 && objectp($1) ? $1 : find_player($1) :)) -
                    ({ 0 }));
}
void remove_attacker_list(object ob) {
  if(userp(ob)) {
    map_delete(_combat->attacker_list, ob->query_name());
    map_delete(_combat->hunting_list, ob->query_name());
  } else {
    map_delete(_combat->attacker_list, ob);
    map_delete(_combat->hunting_list, ob);
  }
}
int attack_by(object opponent) {
  int starting;
  if(!objectp(opponent) ||
     opponent == this_object() ||
     !this_object()->query_attackable() ||
     pk_check(this_object(), opponent))
    return 0;
  if(member_array(opponent, _combat->protectors) != -1)
    _combat->protectors -= ({ opponent });
  if(member_array(opponent, _combat->defenders) != -1)
    _combat->defenders -= ({ opponent });
  if(!sizeof(query_attacker_list()))
    starting = 1;
#ifdef USE_DISTANCE
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] =
        opponent->query_distance(this_object());
  } else if(!_combat->attacker_list[opponent])
    _combat->attacker_list[opponent] = opponent->query_distance(this_object());
#else
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = 1;
  } else if(!_combat->attacker_list[opponent])
    _combat->attacker_list[opponent] = 1;
#endif
  if(starting) {
    _combat->action_defecit = (MAX_ACTION_DEFECIT - MIN_ACTION_DEFECIT) / 3;
    start_combat(opponent);
  }
  _combat->in_combat = 1;
  return 1;
}
int attack_ob(object opponent) {
  int starting, new_opponent;
  if(!objectp(opponent) ||
     opponent == this_object() ||
     !opponent->query_attackable() ||
     !this_object()->query_attackable() ||
     pk_check(this_object(), opponent))
    return 0;
  if(member_array(opponent, _combat->protectors) != -1)
    _combat->protectors -= ({ opponent });
  if(member_array(opponent, _combat->defenders) != -1)
    _combat->defenders -= ({ opponent });
  if(!sizeof(query_attacker_list()))
    starting = 1;
  else if(member_array(opponent, query_attacker_list()) == -1)
    new_opponent = 1;
#ifdef USE_DISTANCE
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = INITIAL_DISTANCE;
  } else {
    if(!_combat->attacker_list[opponent])
      _combat->attacker_list[opponent] = INITIAL_DISTANCE;
  }
#else
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = 1;
  } else {
    if(!_combat->attacker_list[opponent])
      _combat->attacker_list[opponent] = 1;
  }
#endif
  if((new_opponent || starting) &&
     opponent->query_visible(this_object()))
    _callout = call_out("announce_intent", 0, opponent);
  this_object()->remove_hide_invis("hiding");
  if(starting) {
    _combat->action_defecit = (MAX_ACTION_DEFECIT - MIN_ACTION_DEFECIT) / 3;
    start_combat(opponent);
  }
  _combat->in_combat = 1;
  return 1;
}
void stop_fight(object opponent) {
  class combat_special tmp;
#if DEBUG == 2
  combat_debug("stop_fight called against %s", opponent->query_name());
#endif
  if(!objectp(opponent))
    return;
  if(userp(opponent)) {
    map_delete(_combat->attacker_list, opponent->query_name());
    map_delete(_combat->hunting_list, opponent->query_name());
  } else {
    map_delete(_combat->attacker_list, opponent);
    map_delete(_combat->hunting_list, opponent);
  }
#ifdef USE_SURRENDER
  _surrender->from -= ({ 0, opponent });
  _surrender->refusers -= ({ 0, opponent });
  _surrender->to -= ({ 0, opponent });
#endif
  if(!sizeof(query_attacker_list())) {
    foreach(tmp in _combat->specials)
      if(!(tmp->type & T_CONTINUOUS))
        remove_special(tmp->id);
    end_combat();
  }
}
void stop_all_fight() {
  class combat_special tmp;
#if DEBUG == 2
  combat_debug("stop_all_fight called");
#endif
  _combat->attacker_list = ([ ]);
  _combat->hunting_list = ([ ]);
  _combat->in_combat = 0;
#ifdef USE_SURRENDER  _surrender->from = ({ });
  _surrender->refusers = ({ });
  _surrender->to = ({ });
#endif
  foreach(tmp in _combat->specials)
    if(!(tmp->type & T_CONTINUOUS))
      remove_special(tmp->id);
  end_combat();
}
void stop_hunting(object opponent) {
  if(userp(opponent))
    map_delete(_combat->hunting_list, opponent->query_name());
  else
    map_delete(_combat->hunting_list, opponent);
  if(!sizeof(query_attacker_list()))
    end_combat();
}
#ifdef USE_SURRENDER
object do_surrender(object thing) {
   mixed *attackers;
   mixed att;
   if(this_object()->query_property("dead"))
      return 0;
   death_helper(thing, 0);
   catch(DEATH->someone_surrendered(this_object()));
   attackers = query_attacker_list();
   foreach(att in attackers) {
     att->stop_fight(this_object());
   }
   stop_all_fight();
   return 0;
}
int dont_attack_me() {
  if(sizeof(_surrender->to))
    return 1;
  else
    return 0;
}
void event_surrender(object victim, object *attackers) {
  object *offer;
  offer = ({ });
  if (this_object() == victim) {
    _surrender->refusers -= ({ 0 });
    _surrender->to -= ({ 0 });
    offer = filter(attackers, (: member_array($1, _surrender->refusers +
                                              _surrender->to) == -1 :));
    if(sizeof(offer)) {
      event(environment(), "combat",
            sprintf("%s kneels down and surrenders to %s.\n",
                    this_object()->one_short(), query_multiple_short(offer)),
            ({ this_object() }) + _surrender->to + _surrender->refusers, 0);
      this_object()->event_combat(this_object(),
                                sprintf("%s kneel down and surrender to %s.\n",
                                        this_object()->one_short(),
                                        query_multiple_short(offer)), ({ }), 0);
      offer->offered_surrender(victim);
      _surrender->to += offer;
    }
  }
}
object *query_surrenderers() {
  _surrender->from -= ({ 0 });
  return copy(_surrender->from);
}
void remove_surrenderer(object victim) {
  _surrender->from -= ({ 0, victim });
  return;
}
void offered_surrender(object victim) {
  string mercy = this_object()->query_combat_mercy();
  switch(mercy) {
  case "ask":
    if (interactive(this_object())) {
      _surrender->from -= ({ 0, victim });
      _surrender->from += ({ victim });
      this_object()->event_combat(this_object(),
                                  victim->one_short() + " has surrendered to "
                                  "you.  Either \"accept " +
                                  victim->query_name() + "\" or \"reject " +
                                  victim->query_name() + ".\n", ({ }), 0);
    } else {
      if (this_object()->query_accept_surrender(victim))
        victim->accepted_surrender(this_object());
      else
        victim->refused_surrender(this_object());
    }
    break;
  case "always":
    this_object()->event_combat(this_object(),
                                "You accept the surrender of " +
                                victim->one_short() + ".\n", ({ }), 0);
    victim->accepted_surrender(this_object());
    break;
  default:
    this_object()->event_combat(this_object(),
                                sprintf("You refuse the surrender of %s.\n",
                                        victim->one_short()), ({ }), 0);
    victim->refused_surrender(this_object());
  }
}
void refused_surrender(object attacker) {
  _surrender->to -= ({ 0 });
  if (member_array(attacker, _surrender->to) == -1)
    return;
  _surrender->to -= ({ attacker });
  _surrender->refusers -= ({ 0 });
  _surrender->refusers += ({ attacker });
  this_object()->event_combat(this_object(), attacker->one_short() +
                              " refused your surrender\n", ({ }), 0);
}
void accepted_surrender(object attacker) {
  _surrender->to -= ({ 0 });
  if(member_array(attacker, _surrender->to) == -1) {
    return;
  }
  _surrender->to -= ({ attacker });
  this_object()->event_combat(this_object(), attacker->one_short() +
                              " accepts your surrender.\n", ({ }));
  this_object()->do_surrender(attacker);
}
#endif
void stopped_fighting(object thing) {
  event( environment(), "stopped_fighting", thing );
}
void fight_in_progress(object thing) {
  event(environment(), "fight_in_progress", thing );
}
int set_concentrating(object thing) {
  if(userp(thing)) {
    if(!_combat->attacker_list[thing->query_name()])
      return 0;
#ifdef USE_DISTANCE
    _combat->attacker_list[thing->query_name()] =
      thing->query_distance(this_object());
#else
    _combat->attacker_list[thing->query_name()] = 1;
#endif
  } else {
    if(!_combat->attacker_list[thing])
      return 0;
#ifdef USE_DISTANCE
    _combat->attacker_list[thing] = thing->query_distance(this_object());
#else
    _combat->attacker_list[thing] = 1;
#endif
  }
  _combat->concentrating = thing;
  return 1;
}
object query_concentrating() {
  object thing;
  thing = _combat->concentrating;
  if(!thing || !objectp(thing))
    return 0;
  if(userp(thing) && !_combat->attacker_list[thing->query_name()])
    return 0;
  else if(!_combat->attacker_list[thing])
    return 0;
  return thing;
}
object query_attacker() {
  return _combat->last_opponent;
}
object query_last_opponent() {
  return _combat->last_opponent;
}
void set_last_opponent(object last) { _combat->last_opponent = last; }
object query_last_weapon() {
  return _combat->last_weapon;
}
void set_last_weapon(object last) { _combat->last_weapon = last; }
string query_last_action() { return _combat->last_action; }
void set_last_action(string last) { _combat->last_action = last; }
int query_last_result() { return _combat->last_result; }
void set_last_result(int last) { _combat->last_result = last; }
varargs int is_fighting(object ob, int actively) {
  if(!objectp(ob))
    return 0;
  if(actively)
    return userp(ob) ? _combat->attacker_list[ob->query_name()] :
      _combat->attacker_list[ob];
  return userp(ob) ? _combat->attacker_list[ob->query_name()] ||
    _combat->hunting_list[ob->query_name()] :
    _combat->attacker_list[ob] || _combat->hunting_list[ob];
}
int query_fighting() {
  if(!environment() || base_name(environment()) == "/room/rubbish")
    return 0;
  if(sizeof(filter(query_attacker_list(),
                   (: environment($1) == environment(this_object()) :))))
    return 1;
  if(sizeof(filter(all_inventory(environment(this_object())),
                   (: $1 && living($1) && $1->is_fighting(this_object(), 1) :))))
    return 1;
  return 0;
}
mixed stats() {
  int i;
  int j;
  object *weapons;
  mixed ret;
  init_tactics();
  ret = ({
    ({ "attitude", _tactics->attitude }),
      ({ "response", _tactics->response }),
      ({ "mercy", _tactics->mercy }),
      ({ "parry", _tactics->parry }),
      ({ "attack", _tactics->attack }),
      ({ "unarmed parry", ({ "no", "yes" })[ _tactics->parry_unarmed ] }),
      ({ "attack zone", _tactics->focus_zone ? _tactics->focus_zone :
        "none" }),
      ({ "distance", _tactics->ideal_distance ? _tactics->ideal_distance :
        "none" }),
      });
  weapons = (object *)this_object()->query_weapons();
  if(!sizeof(weapons))
    return ret + weapon_logic::stats();
  for ( i = 0; i < sizeof( weapons ); i++ )
    ret += ({ ({ "weapon #"+ i, weapons[ i ]->short() }) }) +
      (mixed)weapons[ j ]->weapon_stats();
  return ret + weapon_logic::stats();
}

==================================================
FILE: living/corpse.c
==================================================

#include <player.h>
int alter_corpse( object corpse, object weapon, string attack ) {
  object head;
  string *heads;
  string behead_message = "";
  if (!attack) attack = "attack";
  switch (attack) {
    case "behead" :
      heads =
        this_object()->query_race_ob( this_object() )->query_possible_bits( "head" );
      if (sizeof(heads) == 0)
        break;
      head = corpse->make_bit(heads[random(sizeof(heads))] );
      head->move( environment( corpse ) );
      switch(random(6)) {
        case 0 : behead_message = head->a_short() +
          " drops onto the ground and rolls head over, well, head "
          "for a bit before coming to a rest.\n";
           break;
        case 1 : behead_message = head->a_short() +
          " sails through the air in a graceful arc before landing "
          "with a very soggy *squish*.\n";
          break;
        case 2 : behead_message = head->a_short() +
          " quivers a bit as it remains in place, perched atop its owner's "
          "corpse for a moment, then falls to pieces.\n";
          break;
        case 3 : behead_message = head->a_short() +
          " tips off to the left to hang by a small bit of flesh, before "
          "gravity has something to say about the matter and pulls it "
          "completely off the corpse, landing with a small bounce.\n";
          break;
        case 4 : behead_message = head->a_short() +
          " slides off its owner's corpse, upends, and lands upside "
          "down, helping to keep some of the blood from spilling.\n";
          break;
        case 5 : behead_message = head->a_short() +
          " drops onto the ground like a ball, *bouncy* *bouncy*.\n";
          break;
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        default : behead_message = "oops, the mushrooms have turned.\n";
      }
      tell_room( environment( corpse ), behead_message );
      break;
    default :
      break;
  }
  return 1;
}
object make_corpse() {
   int i;
   object corpse, *armour, *weapons, race;
   race = find_object(this_object()->query_race_ob());
   if(race && function_exists("make_corpse", race))
     return race->make_corpse();
   corpse = clone_object( "/obj/corpse" );
   corpse->set_owner( 0, this_object() );
   corpse->set_ownership( (string)this_object()->query_name() );
   if ( this_object()->query_property( "player" ) ) {
      corpse->add_property( "player", 1 );
   }
   corpse->set_race_name( (string)this_object()->query_race() );
   if ( !this_object()->query_race_ob() ) {
      corpse->set_race_ob( "/std/races/unknown" );
   } else {
      corpse->set_race_ob( (string)this_object()->query_race_ob() );
   }
   corpse->add_adjective( (string *)this_object()->query_adjectives() );
   corpse->add_adjective("dead");
   corpse->remove_adjective("living");
   corpse->start_decay();
   corpse->set_max_weight(this_object()->query_max_weight());
   corpse->set_length(this_object()->query_height() / 2);
   armour = (object *)this_object()->query_armours();
   this_object()->clear_armours();
   weapons = (object *)this_object()->query_weapons();
   all_inventory( this_object() )->set_tracked_item_status_reason( "DIED" );
   all_inventory( this_object() )->move( corpse );
   armour -= ({ 0 });
   for ( i = 0; i < sizeof( armour ); i++ ) {
      if ( environment( armour[ i ] ) != corpse ) {
         armour = delete( armour, i, 1 );
         i--;
      }
   }
   corpse->set_armours( armour );
   armour->set_worn_by( corpse );
   weapons -= ({ 0 });
   for ( i = 0; i < sizeof( weapons ); i++ ) {
      if ( environment( weapons[ i ] ) != corpse ) {
         weapons = delete( weapons, i, 1 );
         i--;
      }
   }
   corpse->set_holding( weapons );
   weapons->set_holder( corpse );
   return corpse;
}
mixed *death_helper(object thing, int death) {
   int shift, my_level, att_wimpy, att_level, xp, txp;
   string *messages;
   object *things, tmp;
   mixed *retval;
   retval = ({ });
   this_object()->remove_property(PASSED_OUT_PROP);
   this_object()->remove_hide_invis( "hiding" );
#ifdef USE_SURRENDER
   _surrender->refusers = ({ });
   _surrender->to = ({ });
#endif
   things = filter(this_object()->query_attacker_list(),
                   (:  living($1) && !$1->query_property("dead") :));
   if(environment()) {
     if (death) {
       messages = this_object()->query_property("death messages");
       if(!messages)
         messages = ({ "$K dealt the death blow to $D.\n",
                         "You killed $D.\n", "$D dies.\n" });
     } else {
       messages = this_object()->query_property( "surrender messages" );
       if (!messages)
         messages = ({ "$K accepted the surrender of $D.\n",
                         "You subdued $D.\n", "$D surrenders.\n" });
     }
     event( ({ environment() }) + deep_inventory( environment() ), "death",
            things, thing, (thing ? messages[0] : messages[2]), messages[1]);
   }
   if(sizeof(things)) {
     foreach(tmp in things) {
#if DEBUG == 2
       int x, y;
       x = tmp->query_al();
#endif
       shift = (int)this_object()->query_al() ;
       if (!death)
         shift -= (shift / 2);
       tmp->adjust_alignment(shift);
#if DEBUG == 2
       y = tmp->query_al();
       if(interactive(tmp))
         log_file("DEATH_ALIGN", "%s %s adjusted from %d to %d by %s [%d]\n",
                  ctime(time()), tmp->query_name(), x, y,
                  this_object()->query_name(), shift);
#endif
     }
     xp = this_object()->query_death_xp();
     if(xp > 0) {
       shift = 50 + xp / sizeof( things );
       debug_printf("%O Death XP: %O", this_object(), xp);
       my_level = this_object()->query_level();
       foreach(tmp in things) {
         att_wimpy = tmp->query_wimpy();
         att_level = tmp->query_level();
         if(att_level <= my_level)
           txp = shift / 2;
         else
           txp = ((shift/2) * my_level) / att_level;
         if(att_wimpy > 0)
           txp -= (txp * att_wimpy) / 100;
         tmp->adjust_xp(txp, 1);
       }
       return ({ ({ things }), shift/2 });
     }
   }
   return ({ });
}
varargs object do_death(object thing, object weapon, string attack) {
  object corpse, ob;
  mixed xp_leftover, sec_life;
#if DEBUG == 2
  combat_debug("Do death called.");
#endif
  this_object()->reset_callingdeath();
  if ( this_object()->query_property( "dead" ) ) {
    if ( !userp( this_object() ) ) {
      if(file_name(environment()) != "/room/rubbish") {
        this_object()->move("/room/rubbish");
      }
      return 0;
    }
    else
      return 0;
  }
  this_object()->end_combat();
  this_object()->add_property("xp before death", this_object()->query_xp());
  xp_leftover = death_helper(thing, 1);
  catch(sec_life = this_object()->second_life());
  if(sec_life) {
    if(xp_leftover && sizeof(xp_leftover) == 2 && xp_leftover[1] > 0) {
      foreach(ob in xp_leftover[0]) {
        ob->adjust_xp(xp_leftover[1], 1);
      }
    }
    this_object()->stop_all_fight();
    if( objectp( sec_life ) ) {
      return sec_life;
    } else {
      return 0;
    }
  }
  this_object()->add_property( "dead", time() );
  catch(DEATH->someone_died( this_object() ) );
  catch(this_object()->effects_thru_death() );
  this_object()->reset_protectors();
  if ( environment() ) {
    corpse = this_object()->make_corpse();
    if (corpse) {
      corpse->move(environment());
      corpse->add_property("XP", xp_leftover, 300);
      debug_printf("Command: %O", this_object()->query_last_action());
      if (!(alter_corpse( corpse, weapon, attack ))) {
      }
    }
  }
  this_object()->move( "/room/rubbish" );
  this_object()->stop_all_fight();
  return corpse;
}

==================================================
FILE: living/crafts.c
==================================================

private mixed _processes;
void create() {
   _processes = ([ ]);
}
mapping query_processes() {
   return _processes;
}
mapping query_processes_nocase() {
  mapping lc_processes = ([]);
  filter( this_object()->query_processes(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_processes );
  return lc_processes;
}
int add_process(string name, string ob) {
   _processes[name] = ob;
   return 1;
}
int remove_process(string name) {
  string process, name_lc;
  name_lc = lower_case(name);
  foreach (process in keys(_processes)) {
     if (lower_case(process) == name_lc) {
        map_delete(_processes, process);
     }
  }
  return 1;
}
string query_process( string word ) {
   return _processes[word];
}
protected void reset_processes() {
   _processes = ([ ]);
}

==================================================
FILE: living/effects.c
==================================================

#include <effect.h>
inherit "/std/basic/effects";

==================================================
FILE: living/force.c
==================================================

#include <player.h>
#define FORCE_COST 1
#define ILLEGAL_FORCE ({ "alias", "unalias", "mv", "mkdir", "call", "rm", \
                         "force", "kill", "gauge", "exec", "promote", \
                         "new_domain", "rmdir", "cd", "history", "echoall", \
                         "shout" })
nosave string fname;
nosave int no_force_me;
protected int no_force(string str);
protected int do_force(object *obs, string str);
void force_commands() {
  fname = base_name(this_object());
  if ((!this_object()->query_property("npc") &&
      master()->query_senior( geteuid(this_object()) ) ) || fname == LORD_OB) {
    add_command("force", "<indirect:distant-living> <string'command'>",
                (: do_force($1, $4[1]) :));
 }
  if (fname == LORD_OB) {
    add_command("noforce", "{on|off}", (: no_force($4[0]) :));
    add_command("noforce", "", (: no_force(0) :));
  }
}
protected int no_force(string str) {
  if (str == "on") {
    no_force_me = 1;
    write("Ok, forcing you disabled.\n");
    return 1;
  }
  if (str == "off") {
    no_force_me = 0;
    write("Ok, forcing you enabled.\n");
    return 1;
  }
  write("Forcing you is currently ");
  if (no_force_me) {
    write("disabled.\n");
  }
  else {
    write("enabled.\n");
  }
  return 1;
}
protected int do_force(object *obs, string str) {
  object ob;
#ifdef PLAYERS_CAN_FORCE
  if (fname == PLAYER_OB && !this_player()->query_property("force")) {
    notify_fail("You do not have the ability to do that yet.\n");
    return 0;
  }
  if (this_player()->adjust_social_points(-FORCE_COST) < 0) {
    notify_fail("Insufficient social points.\n");
    return 0;
  }
#endif
  foreach( ob in obs ) {
    if(!ob->do_force_on_me( str )) {
      write(capitalize( ob->query_name() ) + " didn't want to do that.\n");
    }
  }
  write("Ok.\n");
  return 1;
}
nomask int do_force_on_me(string str) {
  string temp1, temp2;
  object forcer;
  forcer = this_player(1);
  if (!forcer || (this_player() != previous_object())) {
    if (interactive(previous_object())) {
      forcer = previous_object();
    } else {
      log_file("FORCE", "Attempted illegal force from "+
               file_name(previous_object())+"\n");
      return 0;
    }
  }
  log_file("FORCE", ctime(time()) + " " + forcer->query_name() + " " +
                    this_object()->query_name() + " : " + str);
  tell_object(this_object(), forcer->query_cap_name() +
        " tries to force you to " + str + "\n");
  if (no_force_me || (string)this_object()->query_name() == "pinkfish") {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (sscanf(str, "%s %s", temp1, temp2) != 2) {
    temp1 = str;
  }
  if (member_array(temp1, ILLEGAL_FORCE) != -1 &&
      !master()->high_programmer(geteuid(forcer))) {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (function_exists("eventForce", this_object())) {
    command(str);
  } else {
    this_object()->eventForce(str);
  }
  event(users(), "inform", forcer->query_cap_name()+" forces "+
        this_object()->query_name()+" to "+str, "force");
  log_file("FORCE", " (succeeded)\n");
  return 1;
}

==================================================
FILE: living/gender.c
==================================================

int gender;
nosave int womens_day;
int query_female() { return (gender == 2) || womens_day; }
int query_gender() { return (womens_day?2:gender); }
int query_male() { return gender == 1 && !womens_day; }
int query_neuter() { return !gender && !womens_day; }
string query_gender_string() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "male";
    else return "female";
}
string query_gender_title() {
    if (!gender && !womens_day) return "creature";
    else if (gender == 1 && !womens_day) return "sir";
    else return "madam";
}
string query_gender_name() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "man";
    else return "woman";
}
string query_objective() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "him";
    else return "her";
}
string query_possessive() {
    if (!gender && !womens_day)
        return "its";
    else if (gender == 1 && !womens_day)
        return "his";
    else return "her";
}
string query_pronoun() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "he";
    else return "she";
}
void set_gender(mixed arg) {
  if(stringp(arg)) {
    if(arg == "male")
      gender = 1;
    else if(arg == "female")
      gender = 2;
    else
      gender = 0;
  } else {
    gender = arg;
  }
}
void set_womens_day(int bing) {
  womens_day = bing;
}
int query_womens_day() {
    return womens_day;
}
nomask int query_real_gender() {
   return gender;
}

==================================================
FILE: living/health.c
==================================================

#include <drinks.h>
#include <living.h>
#undef POINTS_LOG
#ifdef USE_SURRENDER
#define SURRENDER_SHADOW "/std/shadows/misc/surrender_shadow"
#endif
varargs int adjust_xp( int number, int shared );
int hp, max_hp, gp, max_gp, xp, wimpy, *drink_info;
#ifdef USE_SURENDER
int surrender;
#endif
nosave int max;
nosave int* runaway_callout_handles;
nosave string which;
nosave mapping counts;
mapping verbs;
nosave int callingdeath;
void create() {
   max_hp = 1;
   max_gp = 1;
#ifdef USE_SURRENDER
   surrender = -1;
#endif
   drink_info = allocate( D_SIZEOF );
   counts = ([ ]);
   verbs = ([ ]);
   callingdeath = 0;
   runaway_callout_handles = ({ });
}
int query_hp() { return hp; }
varargs int set_hp( int number, object attacker ) {
   if ( number > max_hp )
      number = max_hp;
   hp = number;
   if ( ( hp < 0 ) && ( find_call_out( "do_death" ) == -1 ) )
      call_out( "do_death", 0, attacker );
   return hp;
}
protected int check_wimpy() {
    int hp;
    hp = this_object()->query_hp();
    if ( hp < 1 )
        return 0;
    if( 100 * hp < this_object()->query_wimpy() *
        this_object()->query_max_hp()) {
        if(find_call_out("run_away") == -1) {
            runaway_callout_handles += ({ call_out("run_away", 0) });
        }
        return 1;
    }
    return 0;
}
#ifdef USE_SURRENDER
protected int check_surrender() {
   int hp;
   object *attackers, *all, shad;
   hp = this_object()->query_hp();
   if (hp < 1)
      return 0;
   if (hp * 100 < this_object()->query_surrender() *
       this_object()->query_max_hp()) {
     attackers = filter(this_object()->query_attacker_list(),
                        (: $1 && !$1->query_property("dead") &&
                         environment($1) == environment($2) :),
                        this_object());
     all = attackers + ({ this_object() });
     all->event_surrender(this_object(), attackers);
     shad = clone_object(SURRENDER_SHADOW);
     if (shad) {
       shad->setup_shadow(this_object(), attackers);
     }
     return 1;
   }
   return 0;
}
#endif
void reset_callingdeath() {
  callingdeath = 0;
}
int query_callingdeath() {
    return callingdeath;
}
varargs int adjust_hp(int number, object attacker, object weapon,
                      string attack) {
    int i;
    hp += number;
    if ( hp > max_hp )
        hp = max_hp;
    if (hp <= 0 && !callingdeath) {
        callingdeath = time();
        call_out("do_death", 0, attacker, weapon, attack);
        for( i=0; i<sizeof(runaway_callout_handles); i++ ) {
            remove_call_out( runaway_callout_handles[i] );
        }
        runaway_callout_handles = ({ });
    }
    if (hp > 0 && number < 0 && attacker && attacker != this_object()) {
#ifdef USE_SURRENDER
        if(this_object()->query_surrender() >= this_object()->query_wimpy()) {
            if (!check_surrender())
                check_wimpy();
        }
        else {
            if (!check_wimpy())
                check_surrender();
        }
#else
        check_wimpy();
#endif
    }
    return hp;
}
varargs string health_string(int flag, int ref health_level) {
   int level;
   string ret;
   if ( this_object()->query_property( "dead" ) )  {
      ret = "appears to be dead";
      level = 0;
   }
   else if ( hp < max_hp / 10 )  {
      ret = "is in very bad shape";
      level = 1;
   }
   else if ( hp < max_hp / 5 )  {
      ret = "is in bad shape";
      level = 2;
   }
   else if ( hp < max_hp / 2 )  {
      ret = "is not in good shape";
      level = 3;
   }
   else if ( hp < ( max_hp - 200 ) )  {
      ret = "is slightly hurt";
      level = 4;
   }
   else  {
      ret = "is in good shape";
      level = 5;
   }
   if (!undefinedp(flag))   health_level = level;
   return ret;
}
int query_max_hp() { return max_hp; }
int set_max_hp( int number ) {
  int old_hp;
  old_hp = hp;
  if ( max_hp == hp )
    hp = number;
  else
    if ( max_hp )
      hp = ( hp * number ) / max_hp;
    else
      hp = number;
  max_hp = number;
  if ( hp > max_hp )
    hp = max_hp;
  if ( ( hp < 0 ) && ( old_hp > 0 ) )
    hp = max_hp;
  return max_hp;
}
int query_gp() { return gp; }
int query_specific_gp( string gp_type ) {
   int now;
   if ( !gp_type )
      return 0;
   max = (int)this_object()->query_skill_bonus( gp_type
         +".points" ) + 50;
   if ( max >= max_gp )
      max = max_gp;
   now = gp + max - max_gp;
   which = gp_type;
   if ( find_call_out( "clear_gp_info" ) == -1 )
      call_out( "clear_gp_info", 1 );
   return now;
}
void clear_gp_info() { which = 0; }
int set_gp( int number ) {
   gp = number;
   if ( gp > max_gp )
      gp = max_gp;
   return gp;
}
int adjust_gp( int number ) {
  int tmp, diff;
  string guild_ob, current_verb;
  mixed *bits;
  if ( gp + number < 0 )
    return -1;
  gp += number;
  if ( gp > max_gp )
    gp = max_gp;
  tmp = number;
  if((number < 0) && stringp(which)) {
    if (number > ( GP_ADVANCE_MOD * max ) / MIN_TIMES)
      number = (GP_ADVANCE_MOD * max) / MIN_TIMES;
    counts[ which ] -= number;
    if (counts[ which ] > GP_ADVANCE_MOD * max) {
      counts[ which ] = 0;
      number = this_object()->query_skill(which +".points");
      if(!random(to_int(exp(number/150.0))) &&
         this_object()->add_skill_level( which +".points", 1,
                                         this_object())) {
        tell_object( this_object(), "%^YELLOW%^You find yourself "
                     "more able to concentrate on this task than you "
                     "thought.%^RESET%^\n" );
      }
#ifdef POINTS_LOG
      log_file( "POINTS", time() +" "+
                (string)this_object()->query_name() +" gets "+
                which +" ("+ max +")\n" );
#endif
    }
    number = tmp;
    guild_ob = this_object()->query_guild_ob();
    if(guild_ob && member_array(query_verb(), guild_ob->query_commands()) != -1)
      number *= -10;
    else
      number *= -4;
    if(query_verb() == "pray" || query_verb() == "berserk" ||
       query_verb() == "spellcheck" || query_verb() == "octograve")
      number /= 2;
    current_verb = query_verb();
    if(current_verb == "cast" || current_verb == "perform") {
      current_verb = this_object()->query_current_cmd();
    }
    if(verbs[current_verb]) {
      bits = verbs[current_verb];
      diff = time() - bits[0];
      if(diff > 300)
        bits[1] /= 2;
      if(bits[1] < 1)
        bits[1] = 1;
      if(bits[1] > 1 && bits[2] == environment())
        bits[1] += 1;
      if(bits[1] < 10)
         number /= (random(bits[1]) + 1);
      else
        number = 0;
      verbs[current_verb] = ({ time(), bits[1]+1, environment() });
    } else {
      verbs[current_verb] = ({ time(), 1, environment() });
    }
    if(number)
      adjust_xp(number, 1);
#ifdef GUILD_XP
    log_file("GUILD_XP", "%s Gave %s %d points for %s [%s, %d]\n",
             ctime(time()), this_object()->query_name(), number,
             current_verb, verbs[current_verb][0], verbs[current_verb][1]);
#endif
  }
  return gp;
}
int query_max_gp() { return max_gp; }
int set_max_gp( int number ) {
  if ( max_gp ) gp = ( gp * number ) / max_gp;
  else gp = number;
  max_gp = number;
  if ( gp > max_gp ) gp = max_gp;
  return max_gp;
}
int query_xp() { return xp; }
varargs int adjust_xp( int number, int shared ) {
  if(number > 0 && (xp > 10000000 || xp + number > 10000000))
    return xp;
  if(number > 10000 && previous_object() &&
     explode(file_name(previous_object()), "/")[0] == "w")
    log_file("/d/admin/log/CHEAT", ctime(time()) + " " +
             file_name(previous_object()) +
             " gave " + number + " Xp for " + this_object()->query_name() +
             "\n");
   xp += number;
   return xp;
}
int query_wimpy() { return wimpy < 30 ? wimpy : 30; }
int set_wimpy( int number ) {
  if ( ( number < 0 ) || ( number > 30 ) ) return -1;
  return wimpy = number;
}
#ifdef USE_SURRENDER
int query_surrender() {
  if (surrender == -1) {
    if (wimpy > 94)
      return 100;
    else
      return wimpy + 5;
  } else
    return surrender;
}
int set_surrender( int number ) {
  if ( ( number < 0 ) || ( number > 100 ) ) return -1;
  return surrender = number;
}
#endif
int *query_drink_info() { return drink_info; }
int query_volume( int type ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ];
}
int adjust_volume( int type, int amount ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ] += amount;
}
void update_volumes() {
  int i, delta;
  delta = (int)this_object()->query_con();
  for ( i = 0; i < sizeof( drink_info ); i++ ) {
    if ( drink_info[ i ] > delta ) {
      drink_info[ i ] -= delta;
      if(this_object()->query_personal_temp() >  0 && i == D_DRINK)
  this_object()->adjust_personal_temp(-(delta/3));
      else if(this_object()->query_personal_temp() <  0 && i == D_FOOD)
  this_object()->adjust_personal_temp(delta/3);
    } else
      if ( drink_info[ i ] < -delta )
        drink_info[ i ] += delta;
      else
        drink_info[ i ] = 0;
  }
}
mapping query_counts() { return counts; }

==================================================
FILE: living/holding.c
==================================================

nosave mixed *_using;
nosave mixed *_weapons;
#define START_VALUE "1"
int *set_hold(object ob, int location, int limbs);
int *set_unhold(object ob);
private int sub_hold(object ob, int pos, int first);
void create()
{
   _weapons = ({ });
}
string *query_limbs()
{
   string race_ob;
   string *limbs;
   race_ob = this_object()->query_race_ob();
   if (!race_ob) {
      _using = ({ });
      return ({ });
   }
   limbs = race_ob->query_limbs();
   if (!_using) {
      _using = allocate(sizeof(limbs));
   }
   return limbs;
}
string* query_using_array() {
   return copy(_using);
}
object *query_holding()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   _using =
      map(_using, (: $1 ? (environment($1) == this_object()? $1 : 0) : 0 :));
   return copy(_using);
}
string* query_holding_limbs(object ob) {
   string* ret;
   int i;
   object* holding;
   string* limbs;
   ret = ({ });
   holding = query_holding();
   limbs = query_limbs();
   for (i = 0; i < sizeof(holding); i++) {
      if (holding[i] == ob) {
         ret += ({ limbs[i] });
      }
   }
   return ret;
}
int query_free_limbs()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   return
      sizeof(filter(_using, (: !$1 || environment($1) != this_object() :)));
}
object *query_weapons()
{
   return filter(_weapons, (: $1 :));
}
int *set_unhold(object ob)
{
   int *pos;
   if (!objectp(ob)) {
      return ({ });
   }
   if (member_array(ob, _using) == -1) {
      return ({ });
   }
   if (!ob->set_holder(0)) {
      return ({ });
   }
   pos = find_member(ob, _using);
   if (ob->query_weapon()) {
      _weapons = filter(_weapons, (: $1 != $(ob) :));
   }
   if (ob->query_armour()) {
      this_object()->remove_armour(ob);
   }
   _using = map(_using, (: $1 == $(ob) ? 0 : $1 :));
   this_object()->do_burden_call();
   return pos;
}
int *set_hold(object ob, int pos, int limbs)
{
   int limb_count;
   int *free = ({ });
   int *used = ({ });
   int total = 0;
   int temp = 0;
   int ok;
   int failed;
   if (environment(ob) != this_object()) {
      debug_printf("Bad environment");
      return ({ });
   }
   limb_count = sizeof(this_player()->query_limbs());
   if (!arrayp(_using)) {
      query_limbs();
   }
   if (pos == -1) {
      total = ob->query_no_limbs();
      if (total > this_object()->query_free_limbs()) {
         debug_printf("Too many limbs");
         return ({ });
      }
      free = find_member(0, _using);
      if (!sizeof (free)) {
        return ({ });
      }
      pos = free[0];
   }
   if (objectp(_using[pos]) && environment(_using[pos]) == this_object()) {
      return ({ });
   }
   ok = sub_hold(ob, pos, 1);
   if (ok) {
      used += ({ pos });
   } else {
      return ({ });
   }
   if(limbs)
     total = limbs - 1;
   else
     total = ob->query_no_limbs() - 1;
   free = find_member(0, _using);
   temp = 0;
   while (temp < total && temp < sizeof(free)) {
      if (temp > limb_count) {
         set_unhold(ob);
         return ({ });
      }
      sub_hold(ob, free[temp], 0);
      if (ok) {
         used += ({ free[temp] });
         temp++;
      } else {
         failed = 1;
      }
   }
   if (failed) {
      set_unhold(ob);
      return ({ });
   } else {
     this_object()->do_burden_call();
      return used;
   }
}
private int sub_hold(object ob,
                     int pos,
                     int first)
{
   int success;
   if (environment(ob) != this_object()) {
      return 0;
   }
   if (first) {
      success = ob->set_holder(this_object(), pos);
      if (!success) {
         return 0;
      }
   }
   _using[pos] = ob;
   if (ob->query_weapon()) {
      if (member_array(ob, _weapons) == -1) {
         _weapons += ({ ob });
      }
   }
   return 1;
}

==================================================
FILE: living/living.c
==================================================

#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger", "errors", "quit"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }

==================================================
FILE: living/living.eff_shad.c
==================================================

#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/effects";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   effects::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void add_effect( string eff, mixed arg ) { effects::add_effect( eff, arg ); }
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats() + (mixed *)effects::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }

==================================================
FILE: living/living.no_eff_shad.c
==================================================

#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }

==================================================
FILE: living/mon-shadow.c
==================================================

object npc;
void setup_shadow(object ob) {
  shadow(ob,1);
  npc = ob;
}
void death_shadow() { destruct( this_object() ); }
object query_npc() { return npc; }

==================================================
FILE: living/mon_actions.c
==================================================

#include "monster.h"
#undef DEBUG
mixed *mon_actions;
void create() {
  mon_actions = ({ });
}
void do_shadow() {
  int i;
  object ob;
  string fname;
  this_object()->shadow_death();
  fname = (string)MONSTER_HAND->query_shadow_name();
  rm(fname+".c");
  for (i=0;i<sizeof(mon_actions);i+=2)
    write_file(fname+".c",
               "inherit \"/std/trigger/"+mon_actions[i]+"\";\n");
  write_file(fname+".c", read_file("/std/living/mon-shadow.c"));
  ob = clone_object(fname);
  ob->setup_shadow(this_object());
  rm(fname+".c");
}
int add_triggered_action(string name, string trigger, mixed ob,
                         string func) {
  int i, j;
#ifdef DEBUG
  log_file("TRIGGERED", ctime(time())+": "+
           file_name(this_object())+"  prev: "+
      implode( map_array( previous_object( -1 ), (: file_name( $1 ) :) ),
      ", " ) +"\n" );
#endif
  if ((i=member_array(trigger, mon_actions)) == -1) {
    mon_actions += ({ trigger, ({ name, ({ ob, func }) }) });
    do_shadow();
  } else if ((j=member_array(name, mon_actions[i+1])) == -1)
    mon_actions[i+1] += ({ name, ({ ob, func }) });
  else
    mon_actions[i+1][j+1] = ({ ob, func });
}
int remove_trigger(string name) {
  int i;
  if ((i=member_array(name, mon_actions)) == -1)
    return 0;
  mon_actions = delete(mon_actions, i, 2);
  if (!sizeof(mon_actions))
    this_object()->shadow_death();
  else
    do_shadow();
  return 1;
}
int remove_triggered_action(string trigger, string name) {
  int i, j;
  if ((i=member_array(trigger, mon_actions)) == -1)
    return 0;
  if ((j=member_array(name, mon_actions[i+1])) == -1)
    return 0;
  mon_actions[i+1] = delete(mon_actions[i+1], i, 2);
  if (!sizeof(mon_actions[i+1]))
    remove_trigger(trigger);
  return 1;
}
mixed *query_actions(string trigger) {
  int i;
  if ((i=member_array(trigger, mon_actions)) == -1)
    return ({ });
  return mon_actions[i+1];
}
mixed *query_mon_actions() { return mon_actions; }

==================================================
FILE: living/money.c
==================================================

#include "money.h"
object query_money_object(int force) {
   object money;
   money = present( MONEY_ALIAS, this_object() );
   if (!money && force) {
      money = MONEY_VAULT->get_money_ob();
      money->move( this_object() );
   }
   return money;
}
varargs void adjust_money( mixed amount, string type ) {
   if (!amount) return;
   query_money_object( 1 )->adjust_money( amount, type );
   this_object()->do_burden_call();
}
mixed *query_money_array() {
   return query_money_object(1)->query_money_array();
}
void set_money_array( mixed *new_array ) {
   query_money_object(1)->set_money_array( new_array );
}
int query_value() {
   object money;
   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return money->query_value();
}
int query_value_in( string where ) {
   object money;
   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return (int)money->query_value_in( where );
}
int query_money( string type ) {
   object money;
   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return (int)money->query_money( type );
}
varargs void pay_money( mixed m_array, string where ) {
   int i, j;
   object money;
   mixed *p_array;
   money = query_money_object(0);
   if ( !money ) {
      return;
   }
   for ( i = 0; i < sizeof( m_array ); i += 2 ) {
      p_array = (mixed *)MONEY_HAND->make_payment( m_array[ i ],
         m_array[ i + 1 ], money, where );
      if ( !pointerp( p_array ) ) {
         continue;
      }
      if ( sizeof( p_array[ 1 ] ) ) {
         money->adjust_money( p_array[ 1 ] );
      }
      for ( j = 0; j < sizeof( p_array[ 0 ] ); j += 2 ) {
         money->adjust_money( - p_array[ 0 ][ j + 1 ], p_array[ 0 ][ j ] );
      }
   }
}

==================================================
FILE: living/nationality.c
==================================================

#include <living.h>
#include <config.h>
private class living_nationality _nationality_data;
string query_nationality() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality;
   }
   return 0;
}
string query_nationality_region() {
   if (_nationality_data && _nationality_data->region) {
      return _nationality_data->region;
   }
   return 0;
}
mixed query_nationality_data() {
   if (_nationality_data && _nationality_data->data) {
      return _nationality_data->data;
   }
   return 0;
}
void set_nationality(string nationality) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->nationality = nationality;
}
void set_nationality_region(string region) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->region = region;
}
void set_nationality_data(mixed data) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->data = data;
}
string query_nationality_name() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_name();
   }
   return 0;
}
string query_nationality_description(object looker) {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_look_description(this_object(), looker);
   }
   return 0;
}
string query_nationality_accent_ob() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_region_accent_ob(_nationality_data->region);
   }
}
string query_nationality_start_location() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_start_location(_nationality_data->region);
   }
   return CONFIG_START_LOCATION;
}

==================================================
FILE: living/respond_cmd.c
==================================================

private nosave mapping _respond_cmd;
class respond_data {
   object ob;
   mixed data;
}
void remove_respond_command(string type, object ob);
mapping query_respond_cmd_data() { return _respond_cmd; }
void create() {
   _respond_cmd = ([ ]);
}
void add_respond_command(string type, object ob, mixed data) {
   class respond_data frog;
   remove_respond_command(type, ob);
   frog = new (class respond_data);
   frog->ob = ob;
   frog->data = data;
   if (!_respond_cmd[type]) {
      _respond_cmd[type] = ({ });
   }
   _respond_cmd[type] += ({ frog });
}
mixed query_respond_command(string type, object ob) {
   class respond_data frog;
   if (_respond_cmd[type]) {
      foreach (frog in _respond_cmd[type]) {
         if (frog->ob == ob) {
            return frog->data;
         }
      }
   }
   return 0;
}
void remove_respond_command(string type, object ob) {
   class respond_data frog;
   int i;
   if (_respond_cmd[type]) {
      for (i = 0; i < sizeof(_respond_cmd[type]); i++) {
         frog = _respond_cmd[type][i];
         if (frog->ob == ob) {
            _respond_cmd[type] = _respond_cmd[type][0..i - 1] +
                                 _respond_cmd[type][i+1..];
            i--;
         }
      }
   }
}
void clear_respond_commands() {
   _respond_cmd = ([ ]);
}

==================================================
FILE: living/response_mon.c
==================================================

#include <soul.h>
#include <language.h>
#define SPECIAL_DAY "/obj/handlers/special_day"
class response_data {
   object last_ob;
   string last_mess;
   int stop_responding;
   int use_regexp;
   int last_count;
   int last_time;
   int understand_anything;
   object* only_respond_to;
}
mixed *_respond_to_with;
nosave class response_data _response_data;
int match(string str, mixed str2);
void event_soul(object per, string mess, object *avoid, string verb,
                string last, mixed at) ;
void create() {
  _respond_to_with = ({ });
  _response_data = new(class response_data);
  _response_data->only_respond_to = ({ });
}
void set_response_mon_understand_anything(int flag) {
   _response_data->understand_anything = flag;
}
void set_response_mon_regexp(int flag) { _response_data->use_regexp = flag; }
int query_response_mon_regexp() { return _response_data->use_regexp; }
int query_response_mon_debug_mode() {
  return this_object()->query_property("respon mon debug");
}
void set_response_mon_debug_mode(int flag) {
  this_object()->add_property("respon mon debug", flag);
}
void set_stop_responding(int i) { _response_data->stop_responding = i; }
int query_stop_responding() { return _response_data->stop_responding; }
int query_response_allowed(object ob,
                           string *response) {
  if (!this_object()->query_visible(ob)) {
    return 0;
  }
  return 1;
}
void set_respond_to_with( mixed map ) {
  mixed *old_keys;
  int i;
  if ( mapp( map ) ) {
#ifdef DEBUG
    log_file("BAD_RESPONSE", "set_respond_to_with() called by %O (%s)\n",
             previous_object(), previous_object()->query_name());
#endif
    old_keys = keys(map);
    _respond_to_with = allocate(sizeof(old_keys) * 2);
    for (i = sizeof(old_keys); i--; ) {
      _respond_to_with[2*i] = old_keys[i];
      _respond_to_with[2*i+1] = map[old_keys[i]];
    }
    return;
  }
  _respond_to_with = map;
}
mixed *query_respond_to_with() { return _respond_to_with; }
void add_respond_to_with( mixed *trigger, mixed response ) {
  _respond_to_with += ({ trigger, response });
}
void add_only_respond_to(object person) {
  _response_data->only_respond_to += ({ person });
}
void remove_only_respond_to(object person) {
   _response_data->only_respond_to -= ({ person });
}
object* query_only_respond_to() {
   return _response_data->only_respond_to;
}
protected mixed *check_sub_sequence( mixed *words ) {
  int word_index;
  int format_index;
  int format_size;
  int word_size;
  int match_counter;
  int cu_format_size;
  string word_str;
  mixed data;
  string *patterns;
  string pattern;
  string extra;
  format_index = 0;
  word_size = sizeof( words );
  word_str = implode(words, " ");
  format_size = sizeof( _respond_to_with );
  while (format_index < format_size) {
    if ( _response_data->use_regexp ) {
        data = _respond_to_with[ format_index ];
        if ( arrayp( data ) && sizeof( data ) > 1 ) {
            if ( arrayp( data[0] ) ) {
                extra = "(" + implode( data, "|" ) + ")+";
            }
            else {
                extra = data[0];
            }
            patterns = map( data[1], (: $(extra) + " " + $1 :) );
        }
        else {
            patterns = ({ data });
        }
        foreach( pattern in patterns ) {
            if ( regexp( word_str, pattern ) ) {
                return _respond_to_with[ format_index + 1 ];
            }
        }
    }
    else {
        word_index = 0;
        match_counter = 0;
        cu_format_size = sizeof(_respond_to_with[format_index]);
        while ((word_index < word_size) && (match_counter < cu_format_size)) {
          match_counter += match(words[word_index],
                                 _respond_to_with[format_index][match_counter]);
          word_index++;
        }
        if (match_counter == (cu_format_size)) {
          return _respond_to_with[format_index + 1];
        }
    }
    format_index += 2;
  }
  return 0;
}
protected int match(string str, mixed format) {
  if (pointerp(format)) {
    return (member_array(str, format) != -1);
  }
  if (str == format) {
    return 1;
  }
  return 0;
}
protected string remove_read_marks(string str) {
  int blij;
  string result;
  int size;
  string temp;
  size = strlen(str);
  blij = 0;
  result = "";
  while (blij < size) {
    temp = str[blij..blij];
    if (((temp >= "a") && (temp <= "z")) ||
        ((temp >= "0") && (temp <= "9")) ||
        (temp == " ")) {
      result += temp;
    } else {
      result += " ";
    }
    blij++;
  }
  return result;
}
protected void senddstr(string str, object per) {
  if ( environment( this_object() ) ) {
    if ( per ) {
      command(replace(str, ({ "$hname$", per->query_name(), "$hcname$",
                                per->query_short(),
                              "$hshort$", per->query_short() })));
    } else {
      command( str );
    }
  }
}
protected void exec_response(mixed rep, object per, string mess) {
  string *rabbit;
  if (pointerp(rep)) {
    return exec_response(rep[random(sizeof(rep))], per, mess);
  }
  if (functionp(rep)) {
    evaluate(rep, per, mess);
  } else if (stringp(rep)) {
    if (rep[0..0] == "#") {
      rabbit = explode(rep[1..], "#");
      if (sizeof(rabbit) > 1) {
        call_out((: call_other($1, $2, $3, $4) :), 0,
                 rabbit[0], rabbit[1], per, mess);
      } else {
        call_out(rabbit[0], 0, per, mess);
      }
    } else {
      call_out("senddstr", 0, rep, per);
    }
  }
}
private void do_delay_thingy(string *extra, string mess, object per) {
  mixed *response;
  mess = lower_case(mess);
  if (!_response_data->use_regexp) {
    mess = remove_read_marks(mess);
  }
  if (query_response_mon_debug_mode()) {
    tell_object(per, "Parsing the text: " + implode(extra, " ") + " " + mess + "\n");
  }
  response = check_sub_sequence(extra + explode(mess, " "));
  if (query_response_mon_debug_mode()) {
    tell_object(per, sprintf("Responding with %O\n", response));
  }
  if (response) {
    if (query_response_allowed(per, response)) {
      exec_response(response, per, mess);
    }
  }
}
int check_loop(object per, string mess) {
  if(interactive(per)) {
    return 0;
  }
  if (_response_data->last_ob == per &&
      (_response_data->last_mess = mess) &&
      _response_data->last_time > time() - 10)
  {
    if(_response_data->last_count > 1) {
      return 1;
    } else {
      _response_data->last_count++;
    }
    _response_data->last_time = time();
  } else {
    _response_data->last_ob = per;
    _response_data->last_mess = mess;
    _response_data->last_count = 1;
    _response_data->last_time = time();
  }
  return 0;
}
private void do_response(string *extra, string mess, object per) {
  if (sizeof(_response_data->only_respond_to)) {
     _response_data->only_respond_to -= ({ 0 });
     if (sizeof(_response_data->only_respond_to) &&
         member_array(per, _response_data->only_respond_to) == -1) {
        return ;
     }
  }
  call_out((: do_delay_thingy($1, $2, $3) :), 2, extra, mess, per);
}
void event_person_sayto(object per, string mess, string lang, object* targets) {
  string skill;
  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }
  if(check_loop(per, mess)) {
    return;
  }
  skill = LANGUAGES->query_language_spoken_skill(lang);
  if (this_object()->query_skill(skill) < 90 ||
      per->query_skill(skill) < 60) {
    return;
  }
  do_response(({ "@sayto" }), mess, per);
}
void event_person_say(object per, string start, string mess, string lang) {
  string skill;
  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }
  if(check_loop(per, mess))
    return;
  if (!_response_data->understand_anything) {
     skill = LANGUAGES->query_language_spoken_skill(lang);
     if (this_object()->query_skill(skill) < 90 ||
         per->query_skill(skill) < 60) {
       return;
     }
  }
  do_response(({ "@say" }), mess, per);
}
varargs void event_soul(object per, string mess, object *avoid, string verb,
                        string last, mixed at) {
  if (per == find_object(SOUL_OBJECT))
    per = previous_object(2);
  if(!interactive(per) ||
     _response_data->stop_responding ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
      member_array(this_object(), avoid) != -1 ||
     !sizeof(_respond_to_with)) {
    return ;
  }
  if((!objectp(at) || (objectp(at) && at != this_object())) &&
     environment(per) != environment() ) {
    return;
  }
  mess = this_object()->convert_message( mess );
  if(check_loop(per, mess))
    return;
  if (objectp(at)) {
    do_response(({ "@" + verb, "#" + last, at->query_name() }), mess, per);
  } else {
    do_response(({ "@" + verb, "#" + last }), mess, per);
  }
}
varargs void event_whisper(object per, string mess, object *obs, string lang,
                           object me) {
  string skill;
  if (!interactive(per) || _response_data->stop_responding ||
      environment() == find_object( "/room/rubbish" ) ||
      !sizeof(_respond_to_with)) {
    return ;
  }
  if(check_loop(per, mess)) {
    return;
  }
  if (!_response_data->understand_anything) {
    skill = LANGUAGES->query_language_spoken_skill(lang);
    if (this_object()->query_skill(skill) < 90 ||
        per->query_skill(skill) < 60) {
      return;
    }
  }
  if (member_array(this_object(), obs) == -1) {
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                "", per);
  } else {
    mess = this_object()->convert_message( mess );
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                mess, per);
  }
}

==================================================
FILE: living/skills.c
==================================================

#include <skills.h>
#include <tasks.h>
#include <tune.h>
#undef LOGGING
varargs int calc_bonus( int lvl, string skill, int use_base_stats );
varargs int stat_modify( int bonus, string skill, int use_base_stats );
mixed recursive_skill_add(mixed skil, string *path, int avr, int lvl, int exp,
                           mixed standard);
private void convert_skills(mixed *skills, string path);
int query_skill(string skill);
mapping new_skills;
nosave mapping _bonus_cache,
               _stat_cache,
               _teach_offer;
mapping _last_info;
mapping query_skills() { return copy( new_skills ); }
void set_skills( mapping map ) { new_skills = map; }
int calc_level(string *path);
void create() {
  _bonus_cache = ([ ]);
  _teach_offer = ([ ]);
  _stat_cache = ([ ]);
  new_skills = ([ ]);
  if(!_last_info)
    _last_info = ([ "time" : time() ]);
}
int not_there( string skill ) {
   return undefinedp(new_skills[skill]);
}
mapping query_bonus_cache() { return copy(_bonus_cache); }
mapping query_stat_cache() { return copy(_stat_cache); }
void zap_stat_cache() {
   int i;
   string word, *list, stat;
   stat = this_object()->stats_to_zap();
   if ( !stat ) {
      return;
   }
   if ( find_call_out( "reset_all2" ) == -1 ) {
      call_out( "reset_all2", 1 );
   }
   foreach( i in stat ) {
      list = _stat_cache[ i ];
      if ( !list )
         continue;
      foreach( word in list ) {
         map_delete( _stat_cache, word );
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( word ) {
      word->set_unarmed_attacks( this_object() );
   }
}
void totaly_zap_bonus_cache() {
   _bonus_cache = ([ ]);
}
protected void totaly_zap_stat_cache() {
   _stat_cache = ([ ]);
}
varargs int query_skill_bonus( string skill, int use_base_stats ) {
#ifdef 0
   int tmp, lvl;
   string *path;
   object guild, race;
#endif
  if (!stringp(skill) || !strlen(skill)) {
    return 0;
  }
  if (!new_skills) {
    new_skills = ([ ]);
  }
  if (skill[0] == '.') {
    skill = skill[1..];
  }
  TASKER->set_control( ({ this_object(), skill }) );
  if ( _bonus_cache[ skill ] )
     return stat_modify( _bonus_cache[ skill ], skill, use_base_stats );
  return calc_bonus( query_skill(skill), skill, use_base_stats );
#ifdef 0
  lvl = query_skill(skill);
  guild = (object)this_object()->query_guild_ob();
  race = (object)this_object()->query_race_ob();
  if (race) {
    tmp = (int)race->query_skill_bonus(lvl, skill);
  }
  if (guild) {
    tmp += (int)guild->query_skill_bonus(lvl, skill);
  }
  return calc_bonus( lvl + tmp, skill, use_base_stats );
#endif
}
int query_skill(string skill) {
   string *path;
   if (!new_skills) {
      new_skills = ([ ]);
   }
   if (!stringp(skill)) {
      return 0;
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   TASKER->set_control( ({ this_object(), skill }) );
   if ( not_there( skill ) ) {
      int i;
      path = (string *)SKILL_OB->query_skill_tree(skill);
      if (path) {
         for (i=0;i<sizeof(path);i++) {
            if ( !not_there( path[ i ] ) ) {
               return new_skills[path[i]];
            }
         }
      }
   } else {
      return new_skills[skill];
   }
   return 0;
}
mapping query_complete_skill_branch( string branch ) {
  string *skills = SKILL_OB->query_all_children( branch );
  if ( !arrayp( skills ) || !sizeof( skills ) )
    return ([ ]);
  return allocate_mapping( skills, (: query_skill( $1 ) :) );
}
protected void flatten_it(string skill) {
   int value;
   int i;
   string *same;
   reset_eval_cost();
   value = new_skills[skill];
   same = (mixed *)SKILL_OB->query_immediate_children(skill);
   for (i=0;i<sizeof(same);i++) {
      if ( not_there( same[ i ] ) ) {
         new_skills[same[i]] = value;
      }
      flatten_it(same[i]);
   }
   if (sizeof(same)) {
      map_delete(new_skills, skill);
   }
}
int tm_check_ok(string skill, object exp) {
  string *history, *bits, *abits;
  int i, j, last, delay;
  if ( !_last_info ) {
    _last_info = ([ "time" : time() ]);
  }
#ifdef LOGGING
  if(base_name(previous_object()) != "/obj/handlers/taskmaster" &&
     base_name(previous_object()) != "/std/effects/fighting/combat" &&
     base_name(previous_object()) != "/std/shadows/misc/team" &&
     base_name(previous_object()) != "/std/shadows/other/group" &&
     base_name(previous_object()) != "/global/player" &&
     base_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "Object %s gave skill increase without using "
              "the taskmaster.\n", base_name(previous_object()));
   }
#endif
  history = this_object()->get_history();
  if(sizeof(history)) {
    for(i=0; i<sizeof(history) && history[i]; i++)
      ;
    last = i - 1;
    if(!this_object()->is_alias(history[last]))
      last -= this_object()->query_queued_commands();
    if(last > 0 && sizeof(history[last]) > 1 && skill[<7..] != ".points") {
      for(i=0; i<sizeof(history) && history[i]; i++) {
        if(history[last] == history[i]) {
          j++;
        }
      }
      if(j > 5 || j * 100 / i > 30) {
#ifdef BAD_TM
        log_file(BAD_TM, "%s %s in %s by %O too many attempts at %s [%s]\n",
                 ctime(time())[4..18], this_object()->query_name(), skill,
                 exp, history[last], history[i-1]);
#endif
        if(!_last_info["skill"] || _last_info["skill"][0] != skill)
          _last_info["skill"] = ({ skill, 2 });
        else
          _last_info["skill"][1] += 1;
        _last_info["time"] = time();
        if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
          _last_info["object"] = ({ base_name(exp), 2 });
        else
          _last_info["object"][1] += 1;
        if(!_last_info["env"] || _last_info["env"][0] != environment())
          _last_info["env"] = ({ environment(), 2 });
        else
          _last_info["env"][1] += 1;
        return 0;
      }
    }
  }
  delay = 30 + random(this_object()->query_level()) +
    random(this_object()->query_skill(skill));
  if(_last_info["object"] && base_name(exp) == _last_info["object"][0])
    delay *= _last_info["object"][1];
  if(this_object()->query_level() * 2 < this_object()->query_skill(skill))
    delay *= 2;
  if(_last_info["env"] && environment(this_object()) == _last_info["env"][0]) {
    delay *= _last_info["env"][1];
  }
  bits = explode(skill, ".");
  if(_last_info["skill"])
    abits = explode(_last_info["skill"][0], ".");
  else
    abits = ({ });
  for(i=0; i<sizeof(bits) && i<sizeof(abits) && bits[i] == abits[i]; i++)
    ;
  if(i && _last_info["skill"])
    delay *= (i * _last_info["skill"][1]);
  else
    delay = 60;
  if(_last_info["time"] > (time() - delay)) {
#ifdef BAD_TM
    log_file(BAD_TM, "%s %s in %s by %O last %d secs ago, delay %d.\n",
             ctime(time())[4..18], this_object()->query_name(), skill,
             exp, (time() - _last_info["time"]), delay);
#endif
    if(!_last_info["skill"] || _last_info["skill"][0] != skill)
      _last_info["skill"] = ({ skill, 2 });
    else
      _last_info["skill"][1] += 1;
    _last_info["time"] = time();
    if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
      _last_info["object"] = ({ base_name(exp), 2 });
    else
      _last_info["object"][1] += 1;
    if(!_last_info["env"] || _last_info["env"][0] != environment())
      _last_info["env"] = ({ environment(), 2 });
    else
      _last_info["env"][1] += 1;
    return 0;
  }
  if(!_last_info["skill"] || _last_info["skill"][0] != skill)
    _last_info["skill"] = ({ skill, 2 });
  else
    _last_info["skill"][1] += 1;
  _last_info["time"] = time();
  if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
    _last_info["object"] = ({ base_name(exp), 2 });
  else
    _last_info["object"][1] += 1;
  if(!_last_info["env"] || _last_info["env"][0] != environment())
    _last_info["env"] = ({ environment(), 2 });
  else
    _last_info["env"][1] += 1;
  return 1;
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string guild, *recursive_skills, *same_level, *bits, *tree;
   int i;
   reset_eval_cost();
   if (!stringp(skill) || !intp(lvl) || lvl > 1000) {
      return 0;
   }
   if (!new_skills || (!mapp(new_skills))) {
      new_skills = ([ ]);
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   recursive_skills = (string *)SKILL_OB->query_related_skills(skill);
   if (!recursive_skills) {
      return 0;
   }
   bits = explode(skill, ".");
   if ( not_there( skill ) && !SKILL_OB->query_only_leaf(skill)) {
      int tmp_lvl, j;
      if (sizeof(bits) > 1) {
         tmp_lvl = 0;
         for (i=sizeof(bits)-1;!tmp_lvl && i>=0;i--) {
            if ( !not_there( implode( bits[ 0 .. i ], "." ) ) ) {
               tmp_lvl = new_skills[implode(bits[0..i], ".")];
               break;
            }
         }
         if (i>=0) {
            for (;i<sizeof(bits);i++) {
               same_level = (string *)
                 SKILL_OB->query_immediate_children(implode(bits[0..i], "."));
               for ( j = 0; j < sizeof( same_level ); j++ ) {
                  new_skills[ same_level[ j ] ] = tmp_lvl;
                  map_delete( _bonus_cache, same_level[ j ] );
               }
            }
         } else {
            tmp_lvl = 0;
         }
      }
   }
   for (i=0;i<sizeof(recursive_skills);i++) {
      if ( !not_there( recursive_skills[ i ] ) ) {
         new_skills[recursive_skills[i]] += lvl;
         if (new_skills[recursive_skills[i]] < 0) {
            new_skills[recursive_skills[i]] = 0;
         }
      }
      map_delete(_bonus_cache, recursive_skills[i]);
   }
   if ( not_there( skill ) ) {
      new_skills[skill] = lvl;
   }
   tree = (string *)SKILL_OB->query_skill_tree(skill);
   for (i=1;i<sizeof(tree);i++) {
      int total, j;
      same_level = (string *)SKILL_OB->query_immediate_children(tree[i]);
      if (sizeof(same_level)) {
         total = 0;
         for (j=0;j<sizeof(same_level);j++) {
            if ( not_there( same_level[ j ] ) ) {
               new_skills[ same_level[ j ] ] = new_skills[ tree[ i ] ];
               map_delete( _bonus_cache, same_level[ j ] );
            }
            total += new_skills[same_level[j]];
         }
         new_skills[tree[i]] = total/sizeof(same_level);
         map_delete( _bonus_cache, tree[ i ] );
      }
   }
   if ( interactive( this_object() ) &&
         ( guild = (string)this_object()->query_guild_ob() ) ) {
      if ( stringp( guild ) ) {
         guild->skills_advanced( this_object(), skill, new_skills[ skill ] );
      }
  }
  if((lvl == 1) && userp(this_object()) && (!exp || objectp(exp))) {
    if(!exp)
      exp = previous_object();
    if(!tm_check_ok(skill, exp)) {
      new_skills[skill] -= 1;
      return 0;
    } else {
      TASKER->award_made( (string)this_object()->query_name(),
                          base_name( exp ), skill, new_skills[ skill ] );
    }
  }
  if ( find_call_out( "reset_all" ) == -1 ) {
    call_out( "reset_all", 1 );
  }
  if(interactive(this_object()) && !this_object()->query_auto_loading())
     this_object()->save();
  return 1;
}
varargs int stat_modify( int lvl, string skill, int use_base_stats ) {
   int i, stat;
   string stat_bonus;
   float bonus;
   bonus = 0.0;
   if ( !_stat_cache[ skill ] || use_base_stats ) {
      stat_bonus = (string)SKILL_OB->query_skill_stat(skill);
      foreach ( i in stat_bonus ) {
         switch( i ) {
            case 'C' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_con();
               else
                  stat = (int)this_object()->query_con();
               break;
            case 'D' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_dex();
               else
                  stat = (int)this_object()->query_dex();
               break;
            case 'I' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_int();
               else
                  stat = (int)this_object()->query_int();
               break;
            case 'S' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_str();
               else
                  stat = (int)this_object()->query_str();
               break;
            case 'W' :
            default :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_wis();
               else
                  stat = (int)this_object()->query_wis();
         }
         if (stat > 0) {
            bonus += (log(stat) / 9.8) - 0.25;
         } else if (stat < 0) {
            bonus -= (log(-stat) / 9.8) + 0.25;
         } else {
            bonus -= 0.25;
         }
         if ( !_stat_cache[ i ] ) {
            _stat_cache[ i ] = ({ skill });
         } else {
            _stat_cache[ i ] |= ({ skill });
         }
      }
      if ( !use_base_stats ) {
         _stat_cache[ skill ] = ({ bonus, stat_bonus });
      }
   } else {
      bonus = _stat_cache[ skill ][ 0 ];
      stat_bonus = _stat_cache[ skill ][ 1 ];
   }
   i = strlen( stat_bonus );
   if ( i ) {
      stat = to_int(lvl + ( lvl * bonus ));
      if (stat < 0) {
         return 0;
      }
      return stat;
   }
   return lvl;
}
varargs int calc_bonus( int lvl, string skill, int use_base_stats ) {
   if (lvl > 60) {
      lvl = 170 + ((lvl-60) >> 1);
   } else if (lvl > 40) {
      lvl = 150 + (lvl-40);
   } else if (lvl > 20) {
      lvl = 100 + ( ((lvl-20)*5) >> 1);
   } else {
      lvl = lvl * 5;
   }
   if ( !use_base_stats ) {
      _bonus_cache[ skill ] = lvl;
   }
   return stat_modify( lvl, skill, use_base_stats );
}
int query_skill_successful(string str, int mod) {
  return (query_skill_bonus(str, 0) + mod >= random(200));
}
void add_teach_offer(object ob, string skill, int num, int lvl, int xp) {
  _teach_offer[ob] = ({ skill, num, lvl, xp });
}
mapping query_teach_offer() { return copy(_teach_offer); }
void stop_teaching_skills(int left, mixed bing) {
   object ob;
   if (left > 0) {
      if (bing[O_OTHER_PER] == this_object()) {
         say(this_object()->short() + " stops teaching themselves some "
             "skills.\n");
      } else if (previous_object() == this_object()) {
         ob = bing[O_OTHER_PER];
         tell_object(ob, this_object()->short() + " interupts your "
                         "training.\n");
      } else {
         ob = this_object();
         tell_object(ob, bing[O_OTHER_PER]->short() + " interupts your "
                         "training.\n");
      }
      say(bing[O_OTHER_PER]->short() + " stops teaching some skills to " +
          this_object()->short() + ".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
      this_object()->adjust_time_left(-((int)this_object()->query_time_left()));
      this_object()->set_interupt_command(0);
      return ;
   }
   if (previous_object() != this_object()) {
      return ;
   }
   if(this_object()->query_xp() < bing[O_XP]) {
      write("Something has gone wrong. :(\n");
      return;
   }
   if (this_object() != bing[O_OTHER_PER]) {
      bing[O_OTHER_PER]->adjust_xp(bing[O_XP]/10);
   }
   this_object()->adjust_xp(-bing[O_XP]);
   add_skill_level(bing[O_SKILL], bing[O_NUM], bing[O_XP]);
   if (this_object() != bing[O_OTHER_PER]) {
      tell_object(this_object(), "You finish learning " + bing[O_NUM] +
                  " levels of "
                  + bing[O_SKILL] + " from " + bing[O_OTHER_PER]->short() +
                  ".\n");
      tell_object(bing[O_OTHER_PER], this_object()->short() + " finishes " +
                  "learning " + bing[O_NUM] + " levels of "
                  +bing[O_SKILL] + " from you.\n");
      say(this_object()->short() + " finishes learning some skills "+
          "from "+bing[O_OTHER_PER]->short()+".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   } else {
      tell_object(this_object(), "You finish teaching yourself " + bing[O_NUM] +
                  " levels of " + bing[O_SKILL] + ".\n");
      say(this_object()->short() + " finishes learning some skills "
          "from " + this_object()->query_objective() + "self.\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   }
}

==================================================
FILE: living/spells.c
==================================================

#include <spells.h>
class spell_process {
   mapping spells;
   mapping process;
}
private mixed spells;
void create() {
   spells = ([ ]);
}
string help_spell(string str) {
   if (!mapp(spells)) {
     spells = ([ ]);
   }
   if (!m_sizeof(spells)) {
      return 0;
   }
   if (!spells[str]) {
      return 0;
   }
   return (string)spells[str][S_OBJECT]->help(str);
}
mapping query_spells() {
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   return spells;
}
mapping query_spells_nocase() {
  mapping lc_spells = ([]);
  filter( this_object()->query_spells(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_spells );
  return lc_spells;
}
int add_spell(string name, mixed ob, mixed func) {
   int i;
   mapping tmp;
   if (pointerp(spells)) {
      tmp = ([ ]);
      for (i=0;i<sizeof(spells);i+=2)
         tmp[spells[i]] = spells[i+1];
      spells = tmp;
   }
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   spells[name] = ({ ob, func });
   return 1;
}
int remove_spell(string name) {
  string spell, name_lc;
  if ( !name ) {
      map_delete( spells, 0 );
      return 1;
  }
  name_lc = lower_case(name);
  foreach (spell in keys(spells)) {
     if (lower_case(spell) == name_lc) {
        map_delete(spells, spell);
     }
  }
  return 1;
}
mixed query_spell( string word ) {
   mapping tmp_spells;
   string test_spell;
   if ( !mapp( spells ) ) {
      return 0;
   }
   tmp_spells = query_spells_nocase();
   test_spell = lower_case(this_object()->expand_nickname(word));
   return tmp_spells[test_spell];
}
protected void reset_spells() {
   spells = ([ ]);
}

==================================================
FILE: living/stats.c
==================================================

#include <move_failures.h>
#include <skills.h>
#include <living.h>
#include <config.h>
#define BASE 20
#define ORD1T 1
#define ORD1B 1
#define ORD2T 1
#define ORD2B 5
#define SCALING_DATA ({ 650, 150, 10, 5 })
#define DIVISOR 700
#define DEATH_WAIT_TIME 5
#define INIT_GP_INC -20
int Con, Dex, Int, Str, Wis,
    contmp, dextmp, inttmp, strtmp, wistmp,
    height, base_weight;
nosave int conbon, dexbon, intbon, strbon, wisbon, no_check;
nosave string to_zap;
nosave int gp_inc = INIT_GP_INC, hp_inc;
mixed query_property(string name);
string stats_to_zap() {
   string temp;
   temp = to_zap;
   to_zap = 0;
   return temp;
}
void zap_stat( string word ) {
   string dummy;
   if ( !to_zap ) {
      to_zap = word;
      if ( find_call_out( "zap_stat_cache" ) == -1 )
         call_out( "zap_stat_cache", 1 );
   }
   if ( sscanf( to_zap, "%s"+ word +"%s", dummy, dummy ) != 2 )
      to_zap += word;
}
int query_no_check() { return no_check; }
void set_no_check( int i ) { no_check = i; }
int hp_base() {
  int base;
  base = 150 + 10 * (int)this_object()->query_con();
  if ( base < 5 ) base = 5;
  return base;
}
int hp_gradient() { return 4; }
int scaled_weight() {
  int i, actual, scaled;
  actual = (int)this_object()->query_weight(1);
  if ( actual < SCALING_DATA[ 0 ] )
    return actual;
  scaled += SCALING_DATA[ 0 ];
  actual -= SCALING_DATA[ 0 ];
  i = 1;
  while ( actual && ( ( i * SCALING_DATA[ 2 ] ) < 100 ) ) {
    if ( actual >= SCALING_DATA[ 1 ] ) {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * SCALING_DATA[ 1 ] )
          / 100;
      scaled += ( SCALING_DATA[ 3 ] * SCALING_DATA[ 1 ] ) / 1000;
      actual -= SCALING_DATA[ 1 ];
    } else {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * actual ) / 100;
      scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
      actual = 0;
    }
    i += 1;
  }
  if ( actual )
    scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
  return scaled;
}
void reset_hp() {
  int new_max, skill_bon;
  string report;
  if ( no_check )
    return;
  skill_bon = (int)this_object()->query_skill_bonus( "other.health" );
  new_max = hp_base() + skill_bon * hp_gradient();
  if ( !base_weight ) {
    if ( (string)this_object()->query_name() == "object" )
      return;
    report = file_name( this_object() ) +" ("+
        (string)this_object()->query_name() +"): race object is "+
        (string)this_object()->query_race_ob();
    if ( environment() ) {
      if ( file_name( environment() ) == "/room/void" )
        return;
      report += "; in "+ file_name( environment() );
      this_object()->move( "/room/void", "$N gets booted into the void for "+
          "being a bad NPC." );
    }
    report += ".\n";
    log_file( "BAD_NPC", ctime(time()) + " " + report );
    return;
  }
   new_max = ( new_max * scaled_weight() ) / DIVISOR;
   if ( new_max < 1 )
      this_object()->set_max_hp( 1 );
   else
      this_object()->set_max_hp( new_max );
}
void reset_gp() {
   string guild_ob;
   if ( no_check )
      return;
   guild_ob = (string)this_object()->query_guild_ob();
   if (!guild_ob) {
      guild_ob = query_property("backup guild");
   }
   if ( !guild_ob ) {
      this_object()->set_max_gp( 50 +
            (int)this_object()->query_skill_bonus( "other.points" ) );
   } else {
      guild_ob->set_gp( this_object() );
   }
}
void calc_inc_rates() {
   string guild_ob;
   hp_inc = sqrt((int)this_object()->stat_modify(100, "other.health")) - 7;
   guild_ob = (string)this_object()->query_guild_ob();
   if ( !guild_ob ) {
     guild_ob = query_property("backup guild");
     if (!guild_ob) {
       guild_ob = CONFIG_DEFAULT_GUILD;
     }
   }
   gp_inc = sqrt((int)this_object()->stat_modify(100,
         (string)guild_ob->query_gp_skill())) - 7;
   if(hp_inc < 0) {
     hp_inc = 0;
   }
   if(gp_inc < 0) {
     gp_inc = 0;
   }
}
int *query_inc_rates() { return ({ gp_inc, hp_inc }); }
void heart_beat() {
   int hp;
   int calling_death;
   hp = this_object()->query_hp();
   if ( hp < 0 ) {
       calling_death = this_object()->query_callingdeath();
        if ( calling_death ) {
           if ( time() > calling_death + DEATH_WAIT_TIME ) {
                this_object()->do_death();
            }
        } else {
            this_object()->do_death();
        }
   }
   else {
      if ( gp_inc == INIT_GP_INC ) {
         calc_inc_rates();
      }
      this_object()->adjust_gp( gp_inc );
      this_object()->adjust_hp( hp_inc );
   }
}
void reset_carry_cap() {
   int i, hst_num, hst_wei, new_cap, old_loc, tot_str;
   object *contents, *dropped;
   if ( no_check ) return;
   old_loc = (int)this_object()->query_loc_weight();
   tot_str = Str + strtmp + strbon;
   new_cap = BASE;
   new_cap += ( ORD1T * tot_str ) / ORD1B;
   new_cap += ( ORD2T * tot_str * tot_str ) / ORD2B;
   new_cap = ( new_cap * (int)this_object()->query_weight(1) ) / 100;
   if ( !new_cap )
      new_cap = 1;
   this_object()->set_max_weight( new_cap );
   if ( new_cap >= old_loc ) return;
   this_object()->dest_hide_shadow();
   contents = all_inventory( this_object() ) -
      (object *)this_object()->query_armours();
   dropped = ({ });
   while ( ( old_loc > new_cap ) && sizeof( contents ) ) {
      hst_num = 0;
      hst_wei = 0;
      for ( i = 0; i < sizeof( contents ); i++ )
         if ( (int)contents[ i ]->query_complete_weight() > hst_wei ) {
            hst_wei = (int)contents[ i ]->query_complete_weight();
            hst_num = i;
         }
      if ( (int)contents[ hst_num ]->move( environment() ) == MOVE_OK ) {
         dropped += ({ contents[ hst_num ] });
         old_loc -= hst_wei;
      }
      contents = delete( contents, hst_num, 1 );
   }
   if ( sizeof( dropped ) ) {
      tell_room( environment(), capitalize( (string)this_object()->short() ) +
                " drops "+ query_multiple_short( dropped ) +" under strain.\n",
                this_object() );
      tell_object( this_object(), "Your fading strength makes you drop "+
                  query_multiple_short( dropped ) +".\n" );
   }
   this_object()->update_loc_weight();
   this_object()->calc_burden();
   if ( new_cap >= old_loc ) return;
   return;
}
void check_stats_zero() {
   if ( Int + inttmp + intbon <= 0 ||
        Wis + wistmp + wisbon <= 0 ) {
      this_object()->add_property( PASSED_OUT, 1, 500 );
      tell_object( this_object(), "You fall asleep.\n" );
   }
}
void reset_all() { zap_stat( "CDISW" ); }
void reset_all2() {
   no_check = 0;
   reset_hp();
   reset_gp();
   reset_carry_cap();
   calc_inc_rates();
   check_stats_zero();
   this_object()->do_burden_call();
}
int query_con() { return Con + contmp + conbon; }
int query_dex() { return Dex + dextmp + dexbon; }
int query_int() { return Int + inttmp + intbon; }
int query_str() { return Str + strtmp + strbon; }
int query_wis() { return Wis + wistmp + wisbon; }
int query_real_con() { return Con; }
int query_real_dex() { return Dex; }
int query_real_int() { return Int; }
int query_real_str() { return Str; }
int query_real_wis() { return Wis; }
int check( int number ) { return ( number <= 28 ); }
int set_con( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Con != number )
    zap_stat( "C" );
  Con = number;
  return Con;
}
int set_dex( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Dex != number )
    zap_stat( "D" );
  Dex = number;
  return Dex;
}
int set_int( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Int != number )
    zap_stat( "I" );
  Int = number;
  return Int;
}
int set_str( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Str != number )
    zap_stat( "S" );
  Str = number;
  return Str;
}
int set_wis( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Wis != number )
    zap_stat( "W" );
  Wis = number;
  return Wis;
}
int adjust_con( int number ) {
  if ( check( number + Con ) ) {
    Con += number;
    if ( number )
      zap_stat( "C" );
  }
  return Con;
}
int adjust_dex( int number ) {
  if ( check( number + Dex ) ) {
    Dex += number;
    if ( number )
      zap_stat( "D" );
  }
  return Dex;
}
int adjust_int( int number ) {
  if ( check( number + Int ) ) {
    Int += number;
    if ( number )
      zap_stat( "I" );
  }
  return Int;
}
int adjust_str( int number ) {
  if ( check( number + Str ) ) {
    Str += number;
    if ( number )
      zap_stat( "S" );
  }
  return Str;
}
int adjust_wis( int number ) {
  if ( check( number + Wis ) ) {
    Wis += number;
    if ( number )
      zap_stat( "W" );
  }
  return Wis;
}
int query_tmp_con() { return contmp; }
int query_tmp_dex() { return dextmp; }
int query_tmp_int() { return inttmp; }
int query_tmp_str() { return strtmp; }
int query_tmp_wis() { return wistmp; }
int adjust_tmp_con( int number ) {
  contmp += number;
  if ( number )
    zap_stat( "C" );
   if ( contmp && !dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return contmp;
}
int adjust_tmp_dex( int number ) {
  dextmp += number;
  if ( number )
    zap_stat( "D" );
   if ( !contmp && dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return dextmp;
}
int adjust_tmp_int( int number ) {
  inttmp += number;
  if ( number )
    zap_stat( "I" );
   if ( !contmp && !dextmp && inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return inttmp;
}
int adjust_tmp_str( int number ) {
  strtmp += number;
  if ( number )
    zap_stat( "S" );
   if ( !contmp && !dextmp && !inttmp && strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return strtmp;
}
int adjust_tmp_wis( int number ) {
  wistmp += number;
  if ( number )
    zap_stat( "W" );
   if ( !contmp && !dextmp && !inttmp && !strtmp && wistmp )
      call_out( "update_tmps", 900 );
  return wistmp;
}
int query_bonus_con() { return conbon; }
int query_bonus_dex() { return dexbon; }
int query_bonus_int() { return intbon; }
int query_bonus_str() { return strbon; }
int query_bonus_wis() { return wisbon; }
int adjust_bonus_con( int number ) {
  conbon += number;
  if ( number )
    zap_stat( "C" );
  return conbon;
}
int adjust_bonus_dex( int number ) {
  dexbon += number;
  if ( number )
    zap_stat( "D" );
  return dexbon;
}
int adjust_bonus_int( int number ) {
  intbon += number;
  if ( number )
    zap_stat( "I" );
  return intbon;
}
int adjust_bonus_str( int number ) {
  strbon += number;
  if ( number )
    zap_stat( "S" );
  return strbon;
}
int adjust_bonus_wis( int number ) {
  wisbon += number;
  if ( number )
    zap_stat( "W" );
  return wisbon;
}
void update_tmps() {
  if ( contmp ) {
    zap_stat( "C" );
    contmp = contmp / 2;
  }
  if ( dextmp ) {
    zap_stat( "D" );
    dextmp = dextmp / 2;
  }
  if ( inttmp ) {
    zap_stat( "I" );
    inttmp = inttmp / 2;
  }
  if ( strtmp ) {
    zap_stat( "S" );
    strtmp = strtmp / 2;
  }
  if ( wistmp ) {
    zap_stat( "W" );
    wistmp = wistmp / 2;
  }
   if ( contmp || dextmp || inttmp || strtmp || wistmp )
      call_out( "update_tmps", 900 );
}
int query_height() { return height; }
void set_height( int number ) {
  if ( number > 0 ) height = number;
}
int query_base_weight() { return base_weight; }
void set_base_weight( int number ) {
   if ( number > 0 )
      base_weight = number;
}
int query_weight(int) {
  int adjust_weight;
  adjust_weight = ( ( ( Con + 3 * Str ) / 4 ) - 13 ) * ( base_weight / 30 );
  return base_weight + adjust_weight;
}
mixed *stats() {
  return ({
    ({ "Con", Con + conbon + contmp }),
    ({ "Dex", Dex + dexbon + dextmp }),
    ({ "Int", Int + intbon + inttmp }),
    ({ "Str", Str + strbon + strtmp }),
    ({ "Wis", Wis + wisbon + wistmp }),
    ({ "tmp Con", contmp }),
    ({ "tmp Dex", dextmp }),
    ({ "tmp Int", inttmp }),
    ({ "tmp Str", strtmp }),
    ({ "tmp Wis", wistmp }),
    ({ "bonus Con", conbon }),
    ({ "bonus Dex", dexbon }),
    ({ "bonus Int", intbon }),
    ({ "bonus Str", strbon }),
    ({ "bonus Wis", wisbon }),
    ({ "hp rate", hp_inc }),
    ({ "gp rate", gp_inc }),
    ({ "height", height }),
  });
}

==================================================
FILE: outsides/basic.c
==================================================

#include <terrain_map.h>
#define CREATOR "Ceres"
inherit TERRAIN_MAP_OUTSIDE_BASE;
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}

==================================================
FILE: outsides/desert.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <move_failures.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  ::create();
  set_climate("Bw");
  add_item("sand", "There is a lot of sand here, tons of it just lying "
     "about the place.");
  add_item("rock", "There are small rocks here and there in the sand.");
  room_chat(({120, 240, ({"Grains of sand are blown about in the slight "
          "breeze."})}));
  add_property("rock size", 2+random(5));
  add_property("track type", "desert");
  add_property("sand object", "/obj/media/sand");
}
string query_terrain_map_colour() { return "%^ORANGE%^"; }
int do_get_rock(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    rock = clone_object(query_property("rock object"));
  else {
    if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
      rock_size = 3;
    if ( !rock_size ) return 0;
    rock = clone_object( "/obj/mineral" );
    if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
      rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                     "slate" })[ random( 6 ) ];
    rock->make_mineral(rock_type, 1 + random(rock_size));
  }
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
int do_get_sand(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  object sand;
  sand = clone_object(query_property("sand object"));
  if (!sand) return 0;
  if (sand->move(this_player()) == MOVE_OK) {
    this_player()->add_succeeded_mess(sand, "$N $V $D.\n", ({ }) );
    return 1;
  }
  sand->dest_me();
  return 0;
}

==================================================
FILE: outsides/mountain.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  ::create();
  add_property("climate", ({-10, 0, 0 }) );
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Very occasionally there are beautiful "+
                           "snowdrops nestled in the shadow of a boulder.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There are only a few stunted trees here clinging "+
             "to life on the steep slopes.  New leaves poke cautiously "+
             "from their gnarled branches");
    add_item(({"floor", "ground", "earth"}), "The ground is mostly covered "+
             "by hardy grass interspersed by small shrubs, however there "+
             "are large patches of bare rock or gravel.  "+
             "Here and there larger rocks protrude from the ground.");
    room_chat(({120, 240, ({"A bird of prey swoops overhead.",
                            "A small insect flies past your face."})}));
    add_property("flower type", "snowdrop");
    break;
  case "summer":
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is largely "+
             "covered with a hardy grass interspersed with small shrubs, "+
             "however there are large patches of bare rock and gravel.  Here "+
             "and there larger rocks protrude from the ground.");
    add_item("tree", "There are a few small trees clinging to life in this "+
             "harsh environment.");
    room_chat(({120, 240, ({"The wind whistles through the mountain passes.",
                            "A bird of prey swoops overhead.",
                            "An insect brushes against your face."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("tree", "There are a few trees dotted around their bare "+
             "branches making them look like ghouhlish skeletons.");
    room_chat(({120, 240, ({"The cold wind whistles over the mountains."
                            })}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_item("shrub", "Dotted here and there these hardy plants struggle "+
           "to survive on the thin soil.");
  add_item("grass", "A particularly wiry kind of grass obviously suited "+
           "to the harsh conditions and thins soil.");
  add_property("rock size", 5+random(20));
  add_property("track type", "mountain");
}
mixed do_get_rock(string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral(rock_type, 1 + random(rock_size));
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  printf("Verb: %s\n", verb);
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->add_plural( capitalize( flower_type ) );
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}

==================================================
FILE: outsides/plain.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  set_climate("Aw");
  add_zone("plain");
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There is the occasional tree here and there covered "
             "with new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}),
             "The ground is mostly grassy "
             "with the occasional clump of wild flowers.");
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                              "Bees buzz busily from flower to flower.",
                              "A butterfly alights on a nearby flower.",
                              "A bird takes off from a tree and flies low "
                              "across the fields."})}));
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.  "
               "The grass is long and sways gently in the breeze.  Here and "
               "there amongst the grass are wild flowers and other plants.");
    add_item("tree", "There are a few trees which are in their full "
             "foliage right now.");
    add_item(({"flower", "plant"}),
             ({"long", "Some pretty flowers.",
                 "get", ({this_object(), "do_get_flower"}),
                 "pick", ({this_object(), "do_get_flower"}),
                   "smell", "The flowers smell wonderful."
                     }));
    room_chat(({120, 240,
                  ({"The wind stirs the grass which sways reminding "
                      "you of waves on an ocean.",
                      "A small animal rustles in the long grass.",
                      "A butterfly alights on a nearby flower.",
                      "A bee buzzes around looking for nectar."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.");
    add_item("tree", "The occasional trees are gold and brown as their "
             "leaves die before winter.");
    room_chat(({120, 240, ({"A squirrel rushes up a nearby tree trunk.",
                              "A bird of prey soars high overhead looking "
                              "for something to eat."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy "+
               "apart from the occasional hardy shrub.");
    add_item("tree", "Dotted here and there are skeletal trees bare of "
             "leaves waiting for spring.");
    room_chat(({120, 240, ({"Somewhere a small animal forages in the "
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                        "get",  ({ this_object(), "do_get_rock" }) }) );
  if (!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "buttercup", "daisy"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "
                         "time.");
  flower->add_plural( pluralize( flower_type ) );
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}

==================================================
FILE: outsides/road.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property("track type", "road");
  add_zone("road");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
string query_terrain_map_colour() { return "%^RED%^"; }
string query_terrain_map_character() { return "#"; }

==================================================
FILE: outsides/woodland.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  add_zone("woodland");
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful.\n"
                         }));
    add_item("tree", "There are trees everywhere here, you have "+
             "to pick your way between them.  They are budding with "+
             "new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}), "The ground is covered "+
             "by a beautiful carpet of flowers interspersed with small "+
             "shrubs.");
    add_item("shrub", "Dotted here and there among the carpet of flowers "+
             "are small shrubs, some thorny, all green.");
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                            "Bees buzz busily from flower to flower.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_property("flower type", "bluebell");
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "You can barely see the "+
             "ground because of the waist-high ferns.  Dotted among the "+
             "ferns are small shrubs.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs, some thorny, all green.");
    add_item("fern", "Everywhere you look there are ferns growing "+
                         "almost waist high between the trees.");
    add_item("tree", "The trees are in their full foliage right now.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees making "+
                              "a sound like falling rain.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is littered "+
             "with dead leaves and the stems of dying ferns.");
    add_item("tree", "You are surrounded by trees, they are resplendent "+
             "with their autumn colours of red, gold and brown.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs many with brightly coloured berries.");
    add_item(({"berry", "berries"}),
               ({"long", "There are a variety of berries hanging from the "+
                   "shrubs here.",
                 "get", ({this_object(), "do_get_berry"}),
                 "pick", ({this_object(), "do_get_berry"})}));
    add_item(({"leaf", "leaves"}),
             ({"long", "The ground is littered with dead leaves.",
               "get", ({this_object(), "do_get_leaf"})}));
    add_item("fern", "Here and there are the stems of ferns which have "+
             "died back and will survive the coming winter underground.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees causing "+
                              "some to fall gently to earth.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_extra_look(this_object());
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("shrub", "Dotted here and there among the trees are small "+
             "shrubs trying to survive the winter.");
    add_item("tree", "There are bare trees everywhere here waiting for the "+
             "coming of spring.");
    room_chat(({120, 240, ({"The wind stirs the dry branches of the trees "+
                              "causing them to rustle eerily.",
                            "Somewhere a small animal forages in the "+
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_property("track type", "woodland");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
string query_terrain_map_colour() { return "%^GREEN%^"; }
string extra_look() {
  string extra;
  extra = ::extra_look();
  switch((string)WEATHER->query_season()) {
  case "spring":
    return extra + "Spring flowers are everywhere you look.\n";
  case "autumn":
    return extra + "The ground is littered with fallen leaves.\n";
    break;
  default:
    return extra;
  }
}
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->set_main_plural(flower_type + "s");
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}
mixed do_get_berry( string verb, object *dest ) {
  object berry;
  string berry_type;
  if ((int)query_property("noflowers"))
    return 0;
  berry_type = ({"blackberry", "raspberry", "blueberry", "strawberry",
                 "blackcurrant"})[random(5)];
   berry = clone_object( "/obj/food" );
  berry->set_name(berry_type);
  berry->set_short(berry_type);
  berry->set_long("This is a lovely, plump "+berry_type+" it looks good "+
                  "enough to eat.\n");
  berry->add_alias("berry");
  if (!(berry->move(this_player()))) return 1;
  berry->dest_me();
  return 0;
}
mixed do_get_leaf( string verb, object *dest ) {
  object leaf;
  string leaf_type;
  if ((int)query_property("noflowers"))
    return 0;
  leaf_type = ({"maple", "oak", "sycamore", "ash", "silver birch"})[random(5)];
  leaf = clone_object("/std/object");
  leaf->set_name("leaf");
  leaf->set_short(leaf_type+" leaf");
  leaf->set_long("This is a dead "+leaf_type+" leaf.  Its natural green "+
                 "has turned to shades of gold, red and brown.\n");
  leaf->add_adjective(leaf_type);
  if (!(leaf->move(this_player()))) return 1;
  leaf->dest_me();
  return 0;
}

==================================================
FILE: creator/workroom.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
object button, bookcase, board;
void setup() {
  set_short("workroom of "+ CREATOR);
  add_property( "determinate", "the ");
  set_light(100);
  set_long("This is the workroom of "+CREATOR+".  You can see a small "
     "wooden desk sulking in the corner of the room, it has a "
     "beautifully carved wooden rolly chair in front of it.  It "
     "looks like this was just newly created, there is a smell "
     "of paint and leather in the air.\n");
  add_item("chair",
        ({ "long", "The teak rolly chair has amazing carvings of dragons "
                   "and ... other things on it.  They almost seem alive, "
                   "you especially don't note the way the dragon "
                   "blinks at you.",
                   "position",
                   "the teak rolly chair" }) );
  add_item("desk", "The desk is made of mahogany with a touch of "
     "mountain ash.  The top has two little basket things "
     "on it labelled \"in\" and \"out\".  The in basket "
     "is rather small." );
  add_item( "dragon", "I told you, you don't notice it winking at you." );
  add_item("in basket", "The in basket is full of small yellow forms "
     "with large red letters on them saying "
     "\"Important read me first\" and then not "
     "appearing to actually have any thing else on "
     "them." );
  add_item( "out basket", "The out basket is completely empty." );
  add_item("basket", "There are two baskets sitting on top of the desk.  "
     "They have the words \"in\" and \"out\" written "
     "on them." );
  add_item("paint", "You look around to see the source of the paint "
     "smell and you can't find it.  The walls? of the room "
     "ummm seem to be well shall we just twisting in a "
     "confused mish mash of shapes, you are sure they are "
     "not threatening." );
  add_item("wall", "The walls are made up of a cloudy substance, white "
     "in nature that is roiling around the place where "
     "you are standing.  Great magic must be holding it "
     "back, every now and then you see a demonic head "
     "push its way out of the cloud roll its eyes and fade "
     "back into the cloud." );
  add_item("cloud", "The cloud is white coloured with a few flashes "
     "of light bursting in it." );
  add_item("demon", "The demonic heads that pop out are pretty nasty "
     "looking, they disapear with a snarl of strain." );
  add_exit("common", "/w/common", "door");
  add_exit("drum", CONFIG_START_LOCATION, "path");
  add_exit("learning", "/d/learning/main", "path");
  modify_exit( ({ "common", "drum", "learning" }),
      ({ "function", "check_player" }) );
  add_alias("north", "drum");
  add_alias("south", "common");
  "/w/common"->add_exit(CREATOR, "/w/"+CREATOR+"/workroom", "door");
}
void reset() {
  if (!button) {
    button = clone_object("/obj/misc/button");
    button->move(this_object());
  }
  if (!board) {
    board = clone_object("/obj/misc/board_mas");
    board->move(this_object() );
  }
  if (!bookcase) {
    bookcase = clone_object("/obj/cont_save");
    bookcase->set_name( "bookcase" );
    bookcase->set_short( "oaken bookcase" );
    bookcase->add_adjective( "wooden" );
    bookcase->add_adjective( "oak" );
    bookcase->add_adjective( "oaken" );
    bookcase->add_property( "there", "standing against the wall" );
    bookcase->set_long( "This bookcase is made from oak and "
      "varnished to bring out the glow.  It has 2 "
      "shelves, upon which you can see some books, and "
      "other objects.\n" );
    bookcase->set_weight( 2000 );
    bookcase->set_max_weight( 4000 );
    bookcase->reset_get();
    bookcase->check_euid();
    bookcase->set_save_file( "/w/"+CREATOR+"/creator_kit" );
    bookcase->move( this_object() );
  }
}
object *query_non_destable()  {
  return ({ bookcase, board });
}
int check_player( string verb, object player, string special ) {
    if ( interactive( player ) ) {
        return 1;
    }
    notify_fail( "" );
    return 0;
}

==================================================
FILE: races/amphibian.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard amphibian" );
   set_height( 40 );
   set_weight( 600 );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "skull", "left eye", "right eye" }),
      "skull", "skull", ({ "head", 15, 0, "brain" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "brain", "brain", ({ "skull", 5, 0 }),
      "torso", "guts", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 10, 0 }),
      "liver", "liver", ({ "guts", 5, 0 }),
      "left kidney", "kidney", ({ "guts", 5, 0 }),
      "right kidney", "kidney", ({ "guts", 5, 0 }),
      "spleen", "spleen", ({ "guts", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "right front leg", "leg", ({ 0, 200, 0 }),
      "left front leg", "leg", ({ 0, 200, 0 }),
      "right back leg", "leg", ({ 0, 200, 0 }),
      "left back leg", "leg", ({ 0, 200, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull" });
   unrottable = ({ "skull" });
   set_skin( "skin" );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
   if( !do_setup )
      this_object()->setup();
}
int lives_in_water() { return 1; }

==================================================
FILE: races/ape.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "ape" );
   set_long( "The apes are any members of the family Pongidae of large "
      "semi-erect primates, including the chimpanzee, gorilla, orangutan "
      "and gibbon.\n" );
   set_weight( 2500 );
   set_height( 175 );
   set_stats( ({ 4, 4, 0, 4, 0 }) );
}
int query_eat( string type ) { return 1; }
string query_desc( object thing ) {
   if( (int)thing->query_gender() == 1 )
      return "He is your average hairy young male ape.\n";
   return "She is your average hairy young female ape.\n";
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", 15 + level / 10 );
   thing->add_ac( "sharp", "sharp", 10 + level / 15 );
   thing->add_ac( "pierce", "pierce", 12 + level / 12 );
   thing->reset_all();
}
int query_dark( int light ) {
   if( light < 10 ) return 1;
   if( light > 200 ) return 2;
   return 0;
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 10 + ( 3 * sqrt( number ) ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->add_attack( "hands", 75, ({ 2 * number, 8, number }),
      "blunt", "unarmed", "unarmed_hands" );
   thing->add_attack( "feet", 25, ({ 3 * number, 10, number }),
      "blunt", "unarmed", 0 );
}

==================================================
FILE: races/arachnid.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "A creature like scorpion, spider, daddy longlegs, mite, "
      "tick, and certain other invertebrate animals.  This file should "
      "be inherited by a more specialised race object." );
   bits = ({
      "cephalothorax", "head", ({ 0, 200, 0,
         "middle right upper eye", "middle right lower eye",
         "middle left upper eye", "middle left lower eye",
         "right upper eye", "right lower eye",
         "left upper eye", "left lower eye", "brain", "ganglion",
         "left fang", "right fang", "stomach", "mandible" }),
      "middle right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "brain", "brain", ({ "cephalothorax", 25, 0 }),
      "ganglion", "ganglion", ({ "cephalothorax", 50, 0 }),
      "left fang", "fang", ({ "cephalothorax", 25, 0 }),
      "right fang", "fang", ({ "cephalothorax", 25, 0 }),
      "stomach", "stomach", ({ "cephalothorax", 50, 0 }),
      "mandible", "mandible", ({ "cephalothorax", 25, 0 }),
      "abdomen", "abdomen", ({ 0, 500, 0, "lung", "stomach",
         "heart", "right front leg", "right middle front leg",
         "left front leg", "left middle front leg", "right back leg",
         "right middle back leg", "left back leg", "left middle back leg" }),
      "left middle back leg", "leg", ({ "abdomen", 25, 0 }),
      "left back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle back leg", "leg", ({ "addomen", 25, 0 }),
      "right back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "right front leg", "leg", ({ "abdomen", 25, 0 }),
      "left middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "left front leg", "leg", ({ "abdomen", 25, 0 }),
      "lung", "lung", ({ "abdomen", 100, 0 }),
      "stomach", "stomach", ({ "abdomen", 100, 0 }),
      "heart", "heart", ({ "abdomen", 100, 0 }),
      "pedicel", "pedicel", ({ 0, 100, 0 })
   });
   inedible = ({ "left fang", "right fang", "mandible" });
   unrottable = ({ "left fang", "right fang", "mandible" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
   if( !do_setup )
      this_object()->setup();
}

==================================================
FILE: races/badger.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "badger" );
   set_long( "A big black white and grey burowing animal.\n" );
   set_height( 30 );
   set_weight( 500 );
   set_desc( "small brown meateater" );
   set_stats( ({ 2, -2, -2, 2, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 3 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "chew" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number )/2 }),
      "chew", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/base.c
==================================================

#define QUEST_AVE 140
#define QUEST_MAX 570
#define BASE 50
#define SCALE 10
#define NORM 15
#define EXPERT 20
#define A_TYPES ([ \
      "claws" : "sharp", \
      "chew" : "sharp", \
      "beak" : "pierce", \
      "bite" : "pierce", \
      "horn" : "pierce", \
      "hands" : "blunt", \
      "feet" : "blunt", \
      "tail" : "blunt", \
      "hoof" : "blunt", \
      "wrestle" : "blunt", \
   ])
inherit "/std/object";
private int height;
private int *sight;
private int *stats;
private string desc;
private string skin;
string *inedible;
string *unrottable;
string *pluckable;
private string *limbs;
private mixed *acs;
private mixed *attacks;
private mapping _fixed_bits;
mixed *bits;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   sight = ({ 5, 20, 200, 300 });
   stats = allocate( 5 );
   desc = "a small non-descript thing";
   inedible = ({  });
   unrottable = ({  });
   pluckable = ({  });
   acs = ({ });
   attacks = ({ });
   bits = ({ });
   if ( !do_setup )
      this_object()->setup();
}
int query_height() { return height; }
void set_height( int number ) { height = number; }
int *query_sight() { return copy(sight); }
void set_sight( int *numbers ) { sight = numbers; }
int query_dark( int light ) {
   if ( light < sight[ 0 ] ) {
      return -2;
   }
   if ( light < sight[ 1 ] ) {
      return -1;
   }
   if ( light > sight[ 3 ] ) {
      return 2;
   }
   if ( light > sight[ 2 ] ) {
      return 1;
   }
   return 0;
}
int *query_stats() { return copy(stats); }
void set_stats( int *numbers ) { stats = numbers; }
string query_skin() { return skin; }
void set_skin( string word ) { skin = word; }
string query_desc( object thing ) {
   return capitalize( (string)thing->query_pronoun() ) +" is "+ desc +".\n";
}
void set_desc( string words ) { desc = words; }
string *query_limbs() {
   if ( !limbs ) {
      this_object()->find_limbs();
   }
   return copy(limbs);
}
void find_limbs() {
   int i;
   string limb;
   limbs = ({ });
   for ( i = 0; i < sizeof( bits ); i += 3 ) {
     if ( sscanf( bits[ i ], "%s hand", limb ) == 1 ) {
       limbs += ({ bits[ i ] });
     }
   }
}
mixed *query_acs() { return copy(acs); }
void add_ac( string ac_name, string ac_type, mixed ac_amount ) {
   acs += ({ ac_name, ac_type, ac_amount });
}
mixed *query_attacks() { return copy(attacks); }
void add_attack( string attack_name, int attack_chance, int *attack_data ) {
   attacks += ({ attack_name, attack_chance, attack_data });
}
mixed *query_bits() { return bits; }
mixed *query_bit( string word ) {
   int i;
   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return ({ });
   }
   return bits[ i .. i + 2 ];
}
private void fixup_bits() {
   string* str_bits;
   string pl;
   int i;
   if (_fixed_bits) {
      return ;
   }
   _fixed_bits = ([ ]);
   for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
      str_bits = explode(bits[i], " ");
      pl = pluralize(str_bits[<1]);
      if (!_fixed_bits[str_bits[<1]]) {
         _fixed_bits[str_bits[<1]] = ({ });
      }
      _fixed_bits[str_bits[<1]] += ({ ({ str_bits[0..<2], i, 0 }) });
      if (!_fixed_bits[pl]) {
         _fixed_bits[pl] = ({ });
      }
      _fixed_bits[pl] += ({ ({ str_bits[0..<2], i, 1 }) });
   }
}
private string *query_old_possible_bits( string word ) {
   int i;
  int j;
  string *possibles;
  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if ( ( bits[ i ] == word ) ||
          ( bits[ i + 1 ] == word ) ||
          !word) {
       if (arrayp( bits[i+2][2] )) {
         for ( j = 0; j < bits[i + 2][2][1]; j++) {
           possibles += ({ bits[ i ] });
         }
       } else {
         possibles += ({ bits[ i ] });
       }
     }
   }
   return possibles;
}
string *query_possible_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;
  if(!word) {
    return query_old_possible_bits( word );
  }
  fixup_bits();
  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (!bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
}
string *query_possible_plural_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;
  fixup_bits();
  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
}
void add_bit( string bit_short, string bit_name, mixed *bit_array ) {
   int i;
   i = member_array( bit_short, bits );
   if ( !( i % 3 ) ) {
      bits[ i ] = bit_short;
      bits[ i + 1 ] = bit_name;
      bits[ i + 2 ] = bit_array;
      return;
   }
   bits += ({ bit_short, bit_name, bit_array });
}
void remove_bit( string word ) {
   int i;
   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return;
   }
   bits = delete( bits, i, 3 );
}
int modifier( int number ) {
   return ( number * ( roll_MdN( 20, 21 ) - 220 ) ) / 2000;
}
void start_player( object thing ) {
   if ( !thing->query_base_weight() ) {
      thing->set_base_weight( 1 + weight + modifier( weight ) );
   }
   if ( !thing->query_height() ) {
      thing->set_height( 1 + height + modifier( height ) );
   }
   thing->adjust_bonus_con( stats[ 0 ] );
   thing->adjust_bonus_dex( stats[ 1 ] );
   thing->adjust_bonus_int( stats[ 2 ] );
   thing->adjust_bonus_str( stats[ 3 ] );
   thing->adjust_bonus_wis( stats[ 4 ] );
   thing->reset_all();
   if ( skin ) {
      thing->set_skin( skin );
   }
}
int query_number_worn( string type ) {
   switch ( type ) {
      case "armband" :
         return 2;
      case "badge" :
         return 15;
      case "bracelet" :
         return 4;
      case "earring" :
        return 2;
      case "garter" :
         return 2;
      case "shoulder" :
         return 2;
      case "necklace" :
         return 5;
      case "ring" :
         return 8;
      case "sash" :
         return 2;
      case "shirt" :
         return 2;
      case "belt scabbard" :
         return 2;
      case "small scabbard" :
         return 2;
      case "bandaid" :
         return 5;
      default :
         return 1;
   }
}
int query_number_wielded( string type ) { return 1; }
int query_skill_bonus( int number, string word ) { return 0; }
int player_start( object thing ) { return 1; }
int player_quit( object thing ) { return 1; }
void set_level( object thing, int level ) {
   int i;
   if ( !thing ) {
      return;
   }
   for ( i = sizeof( acs ) - 3; i > -1; i -= 3 ) {
      thing->add_ac( acs[ i ], acs[ i + 1 ], acs[ i + 2 ] );
   }
}
int *calc_attack( int *data, int number ) {
   int base;
   int num;
   int rand;
   int rating;
   int scale;
   base =  data[ 0 ] * ( BASE + SCALE * number );
   num = data[ 1 ];
   rand = data[ 2 ] * ( BASE + SCALE * number );
   rating = QUEST_AVE * ( base + num * rand ) +
         QUEST_MAX * ( base + ( num * ( 1 + rand ) ) / 2 );
   scale = BASE + SCALE * NORM;
   rating /= scale;
   rating = ( ( BASE + SCALE * EXPERT ) * rating + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
   if ( rating > scale ) {
      scale = ( rating + scale ) / 2;
   }
   return ({ base / scale, num, rand / scale });
}
void set_unarmed_attacks( object thing ) {
   int i, number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   for ( i = sizeof( attacks ) - 3; i > -1; i -= 3 ) {
      thing->remove_attack( attacks[ i ] );
      thing->add_attack( attacks[ i ], attacks[ i + 1 ],
            calc_attack( attacks[ i + 2 ], number ), A_TYPES[ attacks[ i ] ],
            "unarmed", "unarmed_"+ attacks[ i ] );
   }
}
int query_eat( string bit ) {
  if (member_array( bit, inedible) == -1) {
    return 1;
  }
  return 0;
}
int query_unrottable( string bit ) {
  if (member_array( bit, unrottable) == -1) {
    return 0;
  }
  return 1;
}
int query_pluckable( string bit ) {
  if (member_array( bit, pluckable) == -1) {
    return 0;
  }
  return 1;
}
string *query_all_inedible() {
   return inedible;
}
string *query_all_unrottable() {
   return unrottable;
}
string *query_all_pluckable() {
   return pluckable;
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg",
              "stomach", "stomach",
              "right front leg", "right front leg",
              "left rear leg", "left rear leg",
              "right rear leg", "right rear leg",});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "feet":
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  default:
    return zone;
  }
}
string map_armour_zone(string zone) {
  switch(zone) {
  case "thorax":
  case "body":
  case "breast":
  case "trunk":
    return "chest";
  case "tail":
    return "back";
  case "stomach":
    return "abdomen";
  case "left arm":
  case "right arm":
  case "left front leg":
  case "right front leg":
  case "left petral fin":
  case "right petral fin":
  case "left wing":
  case "right wing":
  case "branches":
    return "arms";
  case "left hand":
  case "right hand":
  case "left middle leg":
  case "right middle leg":
  case "left front paw":
  case "right front paw":
    return "hands";
  case "left leg":
  case "right leg":
  case "left back leg":
  case "right back leg":
  case "left rear leg":
  case "right rear leg":
  case "dorsal fin":
    return "legs";
  case "left foot":
  case "right foot":
  case "left rear paw":
  case "left rear paw":
  case "left rear foot":
  case "left rear foot":
  case "left claw":
  case "right claw":
  case "root":
    return "feet";
  default:
    return zone;
  }
}

==================================================
FILE: races/bat.c
==================================================

inherit "/std/races/rodent_base";
void setup() {
   set_name( "bat" );
   set_long( "This is a small flying rodent." );
   set_desc( "a small, flying rodent" );
   set_height( 20 );
   set_weight( 40 );
   remove_bit( "torso" );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );
   add_bit( "torso", "torso", ({ 0, 20, 0,
      "heart", "liver", "left kidney", "right kidney", "spleen",
      "right lung", "left lung", "right wing", "left wing" }) );
   add_bit( "right wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left leg", "leg", ({ 0, 5, 0 }) );
   add_bit( "right leg", "leg", ({ 0, 5, 0 }) );
   set_sight( ({ -20, 0, 80, 120 }) );
   set_stats( ({ 0, 14, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 4;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 75, ({ 0, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 0, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/bear.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "bear" );
   set_desc( "a furry bear" );
   set_height( 200 );
   set_weight( 8000 );
   set_stats( ({ 6, 4, -2, 8, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ 2 * number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 8, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/beetle.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_name( "beetle" );
   set_desc( "a hard-carapaced insect that scuttles along the ground" );
   set_height( 5 );
   set_weight( 2 );
   add_bit( "left wing cover", "cover", ({ "thorax", 1, 0 }) );
   add_bit( "right wing cover", "cover", ({ "thorax", 1, 0 }) );
   inedible += ({ "left wing cover", "right wing cover" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/bird.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "bird" );
   set_long( "A general, unspecified bird.\n" );
   set_height( 15 );
   set_weight( 60 );
   set_stats( ({ 0, 14, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int weight;
   object thing;
   thing = args[ 1 ];
   if ( !thing )
     return;
   weight = (thing->query_weight() / 20);
   thing->add_ac( "blunt", "blunt", weight / 2 );
   thing->add_ac( "pierce", "pierce", weight );
   thing->add_ac( "sharp", "sharp", weight );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/bird_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "a general, unspecified bird.  This should not be used since "
      "it is a base race" );
   bits = ({
      "head", 0, ({ 0, 150, 0,
         "left eye", "right eye", "beak", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({"head", 1, 0 }),
      "beak", 0, ({ "head", 20, 0 }),
      "skull", "cranium", ({ "head", 30, 0, "brain" }),
      "brain", 0, ({ "skull", 10, 0 }),
      "neck", 0, ({ 0, 25, 0, "gizzard" }),
      "gizzard", "gullet", ({ "neck", 5, 0 }),
      "torso", "body", ({ 0, 500, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas", "wishbone",
         "body feather" }),
      "heart", 0, ({ "torso", 50, 0 }),
      "liver", 0, ({ "torso", 25, 0 }),
      "left kidney", "kidney", ({ "torso", 15, 0 }),
      "right kidney", "kidney", ({ "torso", 15, 0 }),
      "left lung", "lung", ({ "torso", 25, 0 }),
      "right lung", "lung", ({ "torso", 25, 0 }),
      "spleen", 0, ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "pancreas", 0, ({ "torso", 15, 0 }),
      "wishbone", 0, ({ "torso", 5, 0 }),
      "body feather", "feather", ({ "torso", 1, ({"/std/bit", 6}) }),
      "tail", 0, ({ 0, 50, 0, "tail feather" }),
      "tail feather", "feather", ({ "tail", 1, ({"/std/bit", 4}) }),
      "left wing", "wing", ({ 0, 150, 0,
         "left wing feather" }),
      "left wing feather", "feather", ({ "left wing", 1,
         ({"/std/bit", 5}) }),
      "right wing", "wing", ({ 0, 150, 0,
         "right wing feather" }),
      "right wing feather", "feather", ({ "right wing", 1,
         ({"/std/bit", 5}) }),
      "left leg", "leg", ({ 0, 100, 0, "left claw" }),
      "left claw", "claw", ({ "left leg", 25, 0 }),
      "right leg", "leg", ({ 0, 100, 0, "right claw" }),
      "right claw", "claw", ({ "right leg", 25, 0 })
   });
   inedible = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   unrottable = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   pluckable = ({ "body feather", "left wing feather", "right wing feather",
      "tail feather" });
   set_skin( "feathers" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "breast", "breast", "breast", "breast", "back",
              "left wing", "left wing", "left wing", "left wing",
              "right wing", "right wing", "right wing", "right wing",
              "stomach", "stomach", "stomach",
              "left leg", "left leg", "left claw",
              "right leg", "right leg", "right claw" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return "breast";
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "wing";
  case "feet":
    return (random(2) ? "left " : "right ") + "claw";
  default:
    return zone;
  }
}

==================================================
FILE: races/bufonid.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "bufonid" );
   set_long( "The bufonids are rare species of humanoid toad-like beings.  "
      "It is rumoured that they were created by wizards as part of a "
      "heinous series of experiments of unknown intent and subsequently "
      "escaped from their creators.  Little is known of them, except that "
      "they keep themselves well hidden from humans.\n" );
   set_height( 150 );
   set_weight( 1800 );
   set_desc( "a strange creature, with webbed feet and warty green skin, "
      "that gives you the impression of being a humanoid toad" );
   remove_bit( "left ear" );
   remove_bit( "right ear" );
   remove_bit( "nose" );
   remove_bit( "scalp" );
   remove_bit( "teeth" );
   add_ac( "blunt", "blunt", 15 );
   add_ac( "pierce", "pierce", 12 );
   add_ac( "sharp", "sharp", 10 );
   add_attack( "hands", 75, ({ 40, 5, 10 }) );
   add_attack( "feet", 25, ({ 30, 5, 20 }) );
   set_stats( ({ 2, 2, 0, 2, 0 }) );
}

==================================================
FILE: races/cabbage.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "cabbage" );
   set_long("A green, leafy vegetable.  Probably full of vitamins and "+
      "minerals, and plenty of roughage.\n" );
   set_height( 20 );
   set_weight( 40 );
   set_desc( "a cute little green-fronded cabbage.  Awww" );
   set_skin( "fronds" );
   bits = ({
      "frond", "frond", ({ 0, 100, ({"/std/bit", 10}) }),
      "stalk", "stalk", ({ 0, 500, 0 })
   });
   inedible = ({ });
   unrottable = ({ });
   set_stats( ({ -4, -4, -6, -4, -6 }) );
}
void player_heart_beat( string word, object brassica ) {
   object *caterpillars;
   if( !environment( brassica ) ) {
      return;
   }
   caterpillars = match_objects_for_existence( "caterpillar",
      environment( brassica ) );
   if( !sizeof( caterpillars ) ) {
      return;
   }
   if( brassica->caterpillars_here( caterpillars ) ) {
      return;
   }
   brassica->do_command( "gibber" );
   brassica->run_away();
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "fronds" );
   thing->add_attack( "fronds", 160, ({ 4 * number, 5, 3 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack_message( "fronds", "sharp", ({
      50, "$N scratch$es $P $z with a frond.\n",
      100, "$N jab$s a sharp frond into $P $z.\n",
      140, "$N chew$s on $P $z.\n",
      180, "$N slash$es $P $z with $p fronds.\n",
      230, "$N climb$s onto %I and cuts $P $z with a sharp frond.\n",
      0, "$N bite$s $P $z off!\n" }) );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/camel.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "camel" );
   set_long( "The camel is an animal living in desert regions.  It has two "
      "humps, a mean temper and a good eye for numbers.  They are usually "
      "named things like \"You Bastard\", \"Evil-smelling Bugger\" and so "
      "on, something that might seem strange to anyone who hasn't "
      "actually met one of the beasts.\n" );
   set_height( 170 );
   set_weight( 12000 );
   set_desc( "a camel that looks less interested in you than in sand" );
   add_bit( "tail", "tail", ({ 0, 18, 0 }) );
   add_bit( "fore hump", "hump", ({ 0, 75, 0 }) );
   add_bit( "aft hump", "hump", ({ 0, 50, 0 }) );
   inedible += ({ "tail" });
   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );
   add_attack( "bite", 50, ({ 40, 8, 10 }) );
   add_attack( "feet", 50, ({ 60, 10, 40 }) );
   set_stats( ({ 4, 2, 10, 6, 8 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
}
