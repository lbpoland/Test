




==================================================
FILE: /lib/std/shops/inherit/expression_util.c
==================================================

inherit "/std/basic/expressions";
#include <expressions.h>
#include <shops/craft_shop.h>
#include <nroff.h>
int is_allowed(string person);
void event_save(object ob);
private nosave string _type;
void set_expression_type(string type) {
   _type = type;
}
string query_expression_type() {
   return _type;
}
int do_user_function_add(string def, string expr) {
   string name;
if (this_player()->query_name() != "presto")
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add functions to this store.\n");
      return 0;
   }
   name = parse_user_expression(def, expr);
   if (name) {
      if (strlen(query_last_expression_warning())) {
         write("WARNING!!! Any changes of types could cause expressions "
               "currently using the functions to fail.\n" +
               query_last_expression_warning());
      }
      write("You successfully add:\n" + query_user_function_string(name));
      add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
      event_save(this_object());
      return 1;
   }
   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
}
int do_user_function_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove functions from this store.\n");
      return 0;
   }
   if (query_user_function_return_type(name) != EXPRESSION_TYPE_ERROR) {
      if (remove_user_expression(name)) {
         add_succeeded_mess(({ "You remove the function " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
         return 1;
      }
   }
   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
}
int do_approve_status_internal_functions() {
   string* names;
   string name;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   names = query_function_names();
   ret = "Functions:\n";
   foreach (name in names) {
      ret += query_type_name(query_function_type(name)) + " " + name +
             "(" + implode(map(query_function_args_types(name),
                               (: query_type_name($1) :)), ", ") +
             ")\n";
   }
   ret += "\nVariables:\n";
   names = query_variable_names();
   foreach (name in names) {
      ret += query_type_name(query_variable_type(name)) + " " + name +
             "\n";
   }
   write("$P$Internal functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_function_help(string name) {
   string nroff_fn;
   string str;
   string fname;
   fname = CRAFT_SHOP_EXPRESSION_HELP_DIR + name;
   if (file_size(fname) <= 0) {
      add_failed_mess("There is no help for the function '" + name + "'.\n");
      return 0;
   }
   nroff_fn = NROFF_DIR + replace(fname, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(fname, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   write("$P$function: " + name + "$P$" + str);
   return 1;
}
int do_function_help_list() {
   string *names;
   names = get_dir(CRAFT_SHOP_EXPRESSION_HELP_DIR);
   if (!sizeof(names)) {
      add_failed_mess("There is no help on any functions.\n");
      return 0;
   }
   names -= ({ ".", "..", "RCS" });
   write(sprintf("%-#*s\n", this_player()->query_cols(), implode(names, "\n")));
   return 1;
}
int do_approve_status_functions(int hints) {
   string* names;
   string name;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   names = query_user_function_names();
   if (!sizeof(names)) {
      add_failed_mess("Could not find any user defined expressions.\n");
      return 0;
   }
   ret = "";
   foreach (name in names) {
      ret += query_user_function_string(name) + "\n";
   }
   if (hints) {
      ret += "$I$0=       Hint: add function <function> as <expression>";
      ret += "$I$0=       Hint: remove function <function>";
   }
   write("$P$User functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
void init() {
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }
   add_command("add",
               _type + " function <string'function'> as <string'expression'>",
               (: do_user_function_add($4[0], $4[1]) :));
   add_command("remove",
               _type + " function <string'function'>",
               (: do_user_function_remove($4[0]) :));
   add_command("functions", _type + " internal",
               (: do_approve_status_internal_functions() :));
   add_command("functions", _type,
               (: do_approve_status_functions(0) :));
   add_command("functions", _type +" help list",
               (: do_function_help_list() :));
   add_command("functions", _type + " help <string'function name'>",
               (: do_function_help($4[0]) :));
   add_command("functions", _type + " hints",
               (: do_approve_status_functions(1) :));
}

==================================================
FILE: /lib/std/shops/inherit/item_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shops/item_shop.h>
#define INFINITE_LEFT 10000
#define TYPE "item shop type"
#define DISPLAY "display in shop"
#define SHOP_INHERIT "/std/shops/inherit/"
inherit SHOP_INHERIT + "clone_on_demand";
inherit SHOP_INHERIT + "open_shop";
inherit SHOP_INHERIT + "shop_event";
private nosave int _no_steal;
private nosave int _steal_difficulty;
private nosave string _shoplift_handler;
private nosave function _list_func;
private nosave function _browse_func;
private nosave function _buy_func;
private nosave function _sort_func;
void setup_safe();
void do_banking();
int do_word_buy(string str);
int do_word_browse(string str);
int do_buy( object *things );
int do_browse( object *things );
void remove_property(string name);
mixed query_property(string name);
void set_max_float( int );
int query_max_float();
private nosave object _safe;
private nosave int _hidden_safe;
private nosave int _max_float;
void create() {
  shop_event::create();
  clone_on_demand::create();
  this_object()->add_help_file("item_shop");
  setup_safe();
  set_max_float( 20000 + random( 50000 ) );
}
object query_safe() {
  return _safe;
}
void setup_safe() {
  if( !_safe ) {
    _safe = clone_object( ITEM_SHOP_ITEMS + "item_shop_safe" );
    _safe->set_difficulty( 2 + random( 7 ) );
    _safe->set_ownership( "shop" );
    if ( this_object()->query_hidden_safe( _safe ) ) {
        this_object()->add_hidden_object( _safe );
    } else {
        _safe->move( this_object() );
    }
  }
}
void set_safe(object safe) {
    _safe = safe;
    if ( _safe ) {
        _safe->set_ownership( "shop" );
        if ( this_object()->query_hidden_safe( _safe ) ) {
            this_object()->add_hidden_object( _safe );
        } else {
            _safe->move( this_object() );
        }
    }
}
void reset() {
  ::reset();
  if(!random(3)) {
    remove_property("inventory_loss");
  }
  do_banking();
}
mixed *switch_extra_properties(){
  return ({ TYPE, DISPLAY });
}
int query_shop() {
   return 1;
}
object *query_shop_lift_items(string str, object player) {
   return filter(match_objects_for_existence(str, ({ query_cont() })),
     (: query_num_items_left($1) > 0 :));
}
object shoplift_success(object ob) {
   object real_ob;
   real_ob = create_real_object(ob);
   return real_ob;
}
string query_shoplift_response_handler() { return _shoplift_handler; }
void set_shoplift_response_handler( string word ) { _shoplift_handler = word; }
void set_open_func(function func) {
   ::set_open_function(func);
}
void set_open_condition(function func) {
   ::set_open_function(func);
}
void set_buy_function(function func) {
  _buy_func = func;
}
function query_buy_function() {
   return _buy_func;
}
void set_browse_function(function func) {
  _browse_func = func;
}
function query_browse_function() {
   return _browse_func;
}
void set_list_function(function func) {
  _list_func = func;
}
function query_list_function() {
   return _list_func;
}
void set_sort_function(function func) {
   _sort_func = func;
}
function query_sort_function() {
   return _sort_func;
}
void set_no_steal(int i) { _no_steal = i; }
int query_no_steal() { return _no_steal; }
void set_steal_difficulty(int i) { _steal_difficulty = i; }
int query_steal_difficulty(int i) { return _steal_difficulty; }
void init() {
   if (query_cont()) {
      add_command( "list", "[all]" );
      add_command( "browse", "<indirect:object:"+file_name(query_cont())+">" );
      add_command( "browse", "<word>", (: do_word_browse($4[0]) :) );
      add_command( "buy", "<indirect:object:"+file_name(query_cont())+">" );
      add_command( "buy", "<word>", (: do_word_buy($4[0]) :) );
   }
}
private object find_object_from_number(int number) {
   object *things;
   things = all_inventory( query_cont() );
   if ( number >= sizeof( things ) ) {
      add_failed_mess( "There is no item with that label.\n" );
      return 0;
   }
   if (_sort_func) {
      things = sort_array(things, _sort_func);
   }
   return things[number];
}
private string letter_name(int letter,
                           object* things) {
   string bing;
   if (sizeof(things) > 26) {
      bing = "AA";
      bing[0] = 'A' + (letter / 26);
      bing[1] = 'A' + (letter % 26);
      return bing;
   }
   bing = "A";
   bing[0] = 'A' + letter;
   return bing;
}
private string start_letter() {
   object *things;
   things = all_inventory( query_cont() );
   return letter_name(0, things);
}
private string end_letter() {
   object *things;
   things = all_inventory( query_cont() );
   return letter_name(sizeof(things) - 1, things);
}
private int query_number_from_string(string name) {
   object *things;
   int pos;
   things = all_inventory( query_cont() );
   if (sizeof(things) > 26) {
      if (strlen(name) != 2) {
         return -1;
      }
      name = lower_case(name);
      if (name[0] < 'a' || name[0] > 'z') {
         return -1;
      }
      if (name[1] < 'a' || name[1] > 'z') {
         return -1;
      }
      pos = (name[0] - 'a') * 26 + name[1] - 'a';
      if (pos >= sizeof(things)) {
         return -1;
      }
      return pos;
   }
   if (strlen(name) != 1) {
      return -1;
   }
   name = lower_case(name);
   if (name[0] < 'a' || name[0] > 'z') {
      return -1;
   }
   pos = name[0] - 'a';
   if (pos >= sizeof(things)) {
      return -1;
   }
   return pos;
}
int query_cost( object thing ) {
   int cost;
   string place;
   if (!thing) {
      return 0;
   }
   if ( environment( thing ) == query_cont() ) {
      cost = (int)thing->query_property( "cost here" );
      if ( cost ) {
         return cost;
      }
   }
   cost = (int)thing->query_value_at( this_object() );
   place = query_property( "place" );
   if ( !place ) {
      return cost;
   }
   cost = (int)MONEY_HAND->query_total_value(
         (mixed *)MONEY_HAND->create_money_array( cost, place ), place );
   if ( environment( thing ) == query_cont() ) {
      thing->add_property( "cost here", cost );
   }
   return cost;
}
int do_list( string str ) {
   int i;
   int left;
   string list;
   string place;
   string display;
   object thing;
   object *listed;
   object *things;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   listed = ({ });
   list = "";
   place = query_property( "place" );
   if ( !place || ( place == "" ) )  {
      place = "default";
   }
   if ( !query_cont() ) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_NOTHING, this_player())) {
         add_failed_mess( "There is nothing to buy here.\n" );
      }
      return 0;
   }
   things = all_inventory( query_cont() );
   if (_sort_func) {
      things = sort_array(things, _sort_func);
   }
   foreach ( thing in things ) {
      left = query_num_items_left(thing);
      if (!left) {
         i++;
         continue;
      }
      display = (string)thing->query_property( DISPLAY );
      if ( !stringp( display )  && thing->short()) {
         display = (string)thing->a_short();
      }
      if (display) {
         list += "$I$6=   "+ letter_name(i, things) +": "+ display +" for "+
               (string)MONEY_HAND->money_value_string(
               (int)this_object()->query_cost( thing ), place );
         if ( left == INFINITE_LEFT ) {
            list += " (plenty left).$I$0=\n";
         } else {
            list += " (" + query_num( left, 0 ) +" left).\n";
         }
         listed += ({ thing });
      }
      i++;
   }
   if ( list == "" ) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_NOTHING, this_player())) {
         add_failed_mess( "There is nothing to buy here.\n" );
      }
      return 0;
   }
   if (!broadcast_shop_event(ITEM_SHOP_EVENT_LIST, this_player(), list)) {
      list = "/global/events"->convert_message(list);
      write("$P$item list$P$" +
         "The following items are for sale:\n" + list);
      add_succeeded_mess(({ "", "$N list$s the inventory.\n" }), ({ }));
   }
   if (_list_func) {
      evaluate(_list_func, this_player(), listed);
   }
   return 1;
}
int do_word_buy(string str) {
   object thing;
   int i;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   if ( strlen( str ) <= 2 ) {
      i = query_number_from_string( str );
      if ( i == -1) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BAD_LABEL, this_player(), str)) {
            add_failed_mess( "The item label must be from " +
                             start_letter() + " to " + end_letter() + ".\n" );
         }
         return 0;
      }
      thing = find_object_from_number(i);
      if ( !thing) {
         return 0;
      }
      return do_buy( ({ thing }) );
   }
   return 0;
}
int do_buy( object *things ) {
   int i, cost, value, ret, money_in_safe;
   string place;
   object thing, money, *sold, ob, *obs;
   mixed *money_arr, temp;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   sold = ({ });
   for (i = 0; i < sizeof(things); i++) {
      if (query_num_items_left(things[i]) <= 0) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_SOLD_OUT, this_player(), things[i..i])) {
            add_failed_mess( "The shop is sold out of "+
                  (string)things[ i ]->query_plural() +".\n" );
         }
         return 0;
      }
      place = query_property( "place" );
      if ( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)this_player()->query_value_in( place );
      cost = (int)this_object()->query_cost( things[i] );
      if ( cost > value ) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_TOO_EXPENSIVE, this_player(), things[i], cost, value)) {
            add_failed_mess("You cannot afford to buy $I.\n", ({ things[i] }));
         }
      } else {
        thing = create_real_object(things[i]);
        if (!thing){
          add_failed_mess( "Something is hosed.  Please file a bug "
                           "report.  Thank you.\n" );
          return 0;
        }
         ret = 1;
         this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
         if( _safe ) {
           money_arr = MONEY_HAND->create_money_array( cost, place );
           money = clone_object( "/obj/money" );
           money->set_money_array( money_arr );
           money->move( _safe );
           _safe->set_closed();
           _safe->set_locked();
           obs = all_inventory( _safe );
           money_in_safe = 0;
           foreach( ob in obs ) {
             if( ob->query_property( "money" ) ) {
               temp = ob->query_money_array();
               money_in_safe += MONEY_HAND->query_total_value( temp, place );
             }
           }
           if( money_in_safe >= query_max_float() )
            do_banking();
         }
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BUY_THING, this_player(), thing)) {
            add_succeeded_mess("$N $V $I.\n", ({ thing }) );
         }
         this_object()->something_bought( thing, this_player(), cost );
         if ( query_property( "package items" ) ) {
            thing = (object)this_object()->package_item( thing );
         }
         if ( (int)thing->move( this_player() ) != MOVE_OK ) {
            thing->move( this_object() );
            write( "You cannot pick "+ (string)thing->a_short() +
                  " up.  It's left on the floor for you.\n" );
         }
         sold += ({ thing });
      }
   }
   if (_buy_func) {
      evaluate(_buy_func, this_player(), sold);
   }
   return ret;
}
int do_word_browse( string words ) {
   int i;
   object thing;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   if ( strlen( words ) <= 2 ) {
      i = query_number_from_string( words );
      if ( i == -1) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BAD_LABEL, this_player(), words)) {
            add_failed_mess( "The item label must be from " +
                          start_letter() + " to " + end_letter() + ".\n" );
         }
         return 0;
      }
      thing = find_object_from_number(i);
      if ( !thing) {
         return 0;
      }
      return do_browse( ({ thing }) );
   }
   return 0;
}
int do_browse( object *things ) {
   int i;
   int num;
   string place;
   string mess;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   mess = "";
   for (i = 0; i < sizeof(things); i++) {
      if (query_num_items_left(things[i])) {
         mess += things[i]->the_short() +
                 " is priced at " + MONEY_HAND->money_value_string(
                 this_object()->query_cost( things[ i ] ), place ) +
                 " and looks like:\n" + things[ i ]->long();
         num++;
      }
   }
   if (!num) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_SOLD_OUT, this_player(), things)) {
         add_failed_mess("The shop is sold out of $I.\n", things);
      }
      return 0;
   }
   if (!broadcast_shop_event(ITEM_SHOP_EVENT_BROWSE, this_player(), things, mess)) {
      write("$P$Browse things$P$" + mess);
      add_succeeded_mess(({ "", "$N $V $I.\n", }), things);
   }
   if (_browse_func) {
      evaluate(_browse_func, this_player(), things);
   }
   return 1;
}
void dest_me() {
  ::dest_me();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
  int stolen_from, difficulty;
  if( _safe ) {
    if( victim == _safe ) {
      stolen_from = _safe->query_property( "stolen from" );
      if( !stolen_from )
        _safe->add_property( "stolen from", 1 );
      else
        _safe->add_property( "stolen from", stolen_from + 1 );
      difficulty = _safe->query_difficulty();
      if( difficulty + 1 <= 10 )
        _safe->set_difficulty( difficulty + 2 );
      else
        if( difficulty <= 10 )
          _safe->set_difficulty( difficulty + 1 );
    }
  }
}
void event_shoplift(object command_ob, object thief, object victim) {
   if (stringp(_shoplift_handler)) {
     if(_shoplift_handler != "none" ) {
       _shoplift_handler->handle_shoplift(thief, victim);
     }
   } else {
     "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
   }
}
void do_banking() {
  object ob, *obs;
  debug_printf( "Doing banking.\n" );
  if( _safe ) {
    obs = all_inventory( _safe );
     foreach( ob in obs ) {
       if( ob->query_property( "money" ) ) {
         ob->move( "/room/rubbish" );
       }
     }
   }
}
void set_max_float( int f ) {
  _max_float = f;
}
int query_max_float() {
  return _max_float;
}

==================================================
FILE: /lib/std/shops/inherit/newspaper_archive.c
==================================================

inherit "/std/shops/inherit/shop_event";
#include <room/newspaper.h>
#include <shops/newspaper_archive.h>
#include <money.h>
#include <move_failures.h>
private nosave string _area;
private nosave string _paper;
mixed query_property(string name);
void create() {
   shop_event::create();
}
void set_paper_area(string area) {
   _area = area;
}
string query_paper_area() {
   return _area;
}
void set_paper(string paper) {
   _paper = paper;
}
string query_paper() {
   return _paper;
}
int do_list_papers() {
   string paper;
   string* papers;
   string str;
   int cost;
   string place;
   place = query_property("place");
   if (_paper) {
      papers = ({ _paper });
   } else {
      papers = NEWSPAPER_HANDLER->query_papers_in_area(_area);
   }
   if (!sizeof(papers)) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_NO_PAPERS, this_player())) {
         add_failed_mess("There do appear to be any newspapers to get "
                         "back issues of.\n");
      }
      return 0;
   }
   str = "Back issues of the following papers:\n";
   foreach (paper in papers) {
      cost = NEWSPAPER_HANDLER->query_paper_cost(paper) * 10;
      if (NEWSPAPER_HANDLER->query_last_edition_num(paper)) {
         if (NEWSPAPER_HANDLER->query_last_edition_num(paper) > 1) {
            str += "$I$5=" + paper + " issues, 1 to " +
                   NEWSPAPER_HANDLER->query_last_edition_num(paper);
         } else {
            str += "$I$5=" + paper + " issue, 1";
         }
         str += " for " + MONEY_HAND->money_value_string(cost, place);
      } else {
         str += "$I$5=" + paper + " has no back issues.\n";
      }
      str += ".\n";
   }
   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_LIST, this_player(),
                             str, papers)) {
      write("$P$Archives$P$" + str);
   }
   return 1;
}
int do_buy(string paper, int edition) {
   string found_paper;
   int pos;
   object ob;
   string place;
   string* papers;
   int cost;
   int* editions;
   place = query_property("place");
   if (_paper) {
      papers = ({ _paper });
   } else {
      papers = NEWSPAPER_HANDLER->query_papers_in_area(_area);
   }
   if (strlen(paper) == 1) {
      pos = lower_case(paper)[0] - 'a';
      if (pos < 0 || pos >= sizeof(papers)) {
         found_paper = papers[pos];
      }
   } else {
      for (pos = 0; pos < sizeof(papers); pos++) {
         if (lower_case(paper) == lower_case(papers[pos])) {
            found_paper = papers[pos];
         }
      }
   }
   if (!found_paper) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_INVALID_PAPER,
                                this_player(), paper)) {
         add_failed_mess("There is no paper called " + paper + ".\n");
      }
      return 0;
   }
   if (edition < 0 ||
       edition > NEWSPAPER_HANDLER->query_last_edition_num(found_paper)) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_INVALID_EDITION,
                                this_player(), paper, edition)) {
         add_failed_mess("There is no edition " + edition + " of the "
                         "paper " + found_paper + ".\n");
      }
      return 0;
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(found_paper) * 10;
   if (this_player()->query_value_in(place) < cost) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_TOO_POOR,
                                this_player(), paper, edition, cost)) {
         add_failed_mess("You need " +
                         MONEY_HAND->money_value_string(cost, place) +
                         " to buy a back issue of " + found_paper + ".\n");
      }
      return 0;
   }
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(found_paper);
   ob->set_edition(edition);
   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_MOVE_PAPER,
                             this_player(), paper, edition, cost, ob)) {
      if (ob->move(this_player()) != MOVE_OK) {
         ob->move(this_object());
         write("Unable to move the paper into your inventory, putting it "
               "on the floor.\n");
      }
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_BOUGHT,
                             this_player(), paper, edition, cost, ob)) {
      add_succeeded_mess("$N buy$s edition " + edition + " of " +
                         found_paper + " for " +
                         MONEY_HAND->money_value_string(cost, place) + ".\n");
   }
   editions = this_player()->query_property("Paper " + found_paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + found_paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        cost);
   }
   return 1;
}
void init() {
   add_command("list", "[papers]", (: do_list_papers() :));
   add_command("buy", "<number'edition number'> of <string'paper name'>",
                (: do_buy($4[1], $4[0]) :));
}

==================================================
FILE: /lib/std/shops/inherit/object_expressions.c
==================================================

#include <expressions.h>
#include <player_handler.h>
#define CHARGE_MULT 10
string query_owner();
string* query_allowed();
void add_allowed_function(string name, int type, int* args, function value);
void add_allowed_variable(string name, int type, function value);
private int function_object_base_value(object* obs) {
   int value;
   object ob;
   int tmp;
   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_base_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
}
private int function_object_value(object* obs) {
   int value;
   object ob;
   int tmp;
   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
}
private int function_object_condition(object* obs) {
   int cond;
   object ob;
   int tmp;
   int max;
   cond = 100;
   foreach (ob in obs) {
      tmp = ob->query_cond();
      max = ob->query_max_cond();
      if (max) {
         tmp = tmp * 100 / max;
         if (tmp < cond) {
            cond = tmp;
         }
      }
   }
   return cond;
}
private int function_object_enchant(object*obs) {
   int enchant;
   object ob;
   int tmp;
   int max;
   string bing;
   if (!sizeof(obs)) {
      return 0;
   }
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_octarine()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_octarine()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }
   enchant = 100;
   foreach (ob in obs) {
      tmp = ob->query_enchant();
      max = ob->query_max_enchant();
      tmp = tmp * 100 / max;
      if (tmp < enchant) {
         enchant = tmp;
      }
   }
   return enchant;
}
private string function_object_type(object* obs) {
   string type;
   string old_type;
   object ob;
   if (!sizeof(obs)) {
      return 0;
   }
   foreach (ob in obs) {
      if (ob->query_weapon()) {
         type = "weapon";
      } else if (ob->query_armour()) {
         type = "armour";
      } else if (ob->query_clothing()) {
         type = "clothing";
      } else {
         type = "misc";
      }
      if (old_type && old_type != type) {
         type = "mixed";
      }
      old_type = type;
   }
   return type;
}
private object* function_object_stolen(object* obs) {
   obs = filter(obs, (: $1->query_property("stolen") :));
   return obs;
}
private object* function_object_warded(object* obs) {
   string classification;
   classification = "/std/effects/object/ward"->query_classification();
   obs = filter(obs, (: sizeof($1->effects_matching($2)) :), classification);
   return obs;
}
private object* function_object_contains_spell(object* obs, string spell_name) {
   string bing;
   int tmp;
   if (!sizeof(obs)) {
      return 0;
   }
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_spells()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_spells()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }
   obs = filter(obs, (: $1->query_magic_scroll() &&
           ($2 == "any" || lower_case($1->query_spell_name()) == lower_case($2)) :), spell_name);
   return obs;
}
private object* function_object_contains_imbue(object* obs, string ritual_name) {
   if (!sizeof(obs)) {
      return ({ });
   }
   obs = filter(obs, (: $1->query_faith_imbue() &&
      ($2 == "any" ||
       lower_case($1->query_ritual_name()) == lower_case($2)) :), ritual_name );
   return obs;
}
private int function_object_percentage_liquid(object* obs, string liquid_name) {
   object ob;
   object* liquids;
   object liq;
   int volume;
   int found;
   int tmp;
   if (!sizeof(obs)) {
      return 0;
   }
   volume = 100;
   foreach (ob in obs) {
      liquids = filter(all_inventory(ob), (: $1->query_liquid() :));
      if (sizeof(liquids))  {
         foreach (liq in liquids) {
            if (liq->query_short() &&
                lower_case(liq->query_short()) == lower_case(liquid_name)) {
               tmp = liq->query_weight() * 100 / ob->query_max_weight();
               if (tmp < volume) {
                  volume = tmp;
                  found = 1;
               }
            }
         }
      }
      else if (ob->query_liquid_short() &&
               lower_case(ob->query_liquid_short()) ==
               lower_case(liquid_name))
      {
         tmp = ob->query_water_volume() * 100 / ob->query_max_volume();
         if (tmp < volume)  {
            volume = tmp;
            found = 1;
         }
      }
   }
   if (found) {
      return volume;
   }
   return 0;
}
private int function_object_charges(object* obs) {
   int total = 0;
   int possible = 0;
   int charges;
   mixed info;
   object ob;
   foreach (ob in obs)  {
      charges = ob->query_charges();
      if (charges)  {
         info = ob->query_static_auto_load();
         if (pointerp(info)  &&  sizeof(info) == 2  &&  info[0] == charges)  {
            possible += info[1] * CHARGE_MULT;
            total += charges;
         }
      }
   }
   if (possible)
      return 100 * total / possible;
   else
      return 0;
}
private object* function_object_matching(object* obs, string match) {
   object ob;
   string *bits;
   string bit;
   object* ret;
   bits = explode(match, ",");
   ret = ({ });
   foreach (ob in obs)  {
      foreach(bit in bits)   {
         if (ob && ob->full_id(bit)) {
            ret += ({ ob });
         }
      }
   }
   return ret;
}
private object* function_object_short(object* obs, string match) {
   string* bits;
   object* result;
   bits = explode(match, ",");
   result = filter(obs, (: member_array(strip_colours($1->query_short()), $2) != -1 :),
                   bits);
   return result;
}
private object* function_contents(object ob) {
   if (!ob) {
      return ({ });
   }
   return all_inventory(ob);
}
void create() {
   if (!function_exists("add_allowed_function", this_object())) {
      return ;
   }
   add_allowed_function("objectenchant", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_enchant :) );
   add_allowed_function("objectvalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_value :) );
   add_allowed_function("objectbasevalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_base_value :) );
   add_allowed_function("objectcondition", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_condition :) );
   add_allowed_function("objecttype", EXPRESSION_TYPE_STRING,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_type :) );
   add_allowed_function("objectwarded", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_warded :) );
   add_allowed_function("objectstolen", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_stolen :) );
   add_allowed_function("charges", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_charges :) );
   add_allowed_function("containsspell", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_spell :) );
   add_allowed_function("containsimbue", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_imbue :) );
   add_allowed_function("percentageliquid", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_percentage_liquid :) );
   add_allowed_function("objectmatch", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_matching :) );
   add_allowed_function("objectshort", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_short :) );
   add_allowed_function("contents", EXPRESSION_TYPE_OBJECT +
                                    EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT }),
                        (: function_contents :) );
}

==================================================
FILE: /lib/std/shops/inherit/open_shop.c
==================================================

private nosave function _open_func;
void set_open_function(function func) {
   _open_func = func;
}
function query_open_function() {
   return _open_func;
}
int is_open(object player, int type) {
   if (_open_func) {
      return evaluate(_open_func, player, type);
   }
   return 1;
}
int test_open() {
    return is_open( this_player(), 0 );
}

==================================================
FILE: /lib/std/shops/inherit/pawn_shop.c
==================================================

#include <money.h>
#include <move_failures.h>
#define RECEIPT "/obj/misc/pawn_receipt"
#define TO this_object()
#define TP this_player()
inherit "/std/shop" ;
private int    _pawn_ttl ;
private mixed  _pawn_mess ;
private int    _pawn_markup ;
private string _shop_language;
void set_language( string lang ) {
    _shop_language = lang;
}
string query_language() {
    return _shop_language;
}
void set_pawn_markup( int percent ) {
    _pawn_markup = percent ;
}
int query_pawn_markup() {
    return _pawn_markup ;
}
void set_pawn_ttl( int ttl ) {
    _pawn_ttl = ttl ;
}
int query_pawn_ttl() {
    return _pawn_ttl ;
}
void set_pawn_mess( mixed mess ) {
    _pawn_mess = mess ;
}
string query_pawn_mess() {
    return _pawn_mess ;
}
void create() {
    do_setup++ ;
    ::create() ;
    do_setup-- ;
    add_help_file( "pawn_shop" ) ;
    remove_help_file( "shop" );
    _pawn_mess = ({
        "You pawn $ob$ for $money$.\n",
        "$client$ pawns $ob$.\n"
    }) ;
    _pawn_markup = 20 ;
    _pawn_ttl = 7 * 24 * 60 * 60 ;
    _shop_language = "morporkian" ;
    set_min_amount( 400 ) ;
    add_property( "no steal", 1 ) ;
    if ( ! do_setup ) {
        TO->setup() ;
        TO->reset() ;
    }
}
void init() {
    ::init() ;
    add_command( "pawn", "<indirect:object:me'items'>" ) ;
}
int do_pawn( object *in_obs ) {
    int value, total ;
    mixed *m_array ;
    object ob, money, receipt ;
    object *cheap, *cre, *expensive, *kept, *nobuy, *stolen, *worn ;
    string place, fn ;
    string *text = ({ }) ;
    if ( ! is_open( TP, 0 ) ) {
        return 0 ;
    }
    in_obs = uniq_array( in_obs ) ;
    cre = filter( in_obs, (: creator_object($1) :) ) ;
    if ( sizeof(cre) ) {
        if ( ! TP->query_creator() ) {
            tell_object( TP,
                "Oh dear, you shouldn't have " + query_multiple_short( cre ) +
                "!  "
                + ( sizeof(cre) > 1 ? "They disappear" : "It disappears" ) +
                " with a flash of octarine light.\n" ) ;
            cre->move( "/room/rubbish" ) ;
        } else {
            tell_object( TP,
                "You decide not to pawn " + query_multiple_short( cre ) +
                ", as " + ( sizeof(cre) > 1 ? "they are creator-only items"
                : "it is a creator-only item" ) + ".\n" ) ;
        }
        foreach( ob in cre ) {
            if ( fn = ob->query_property( "virtual name" ) ) {
                fn = ob->query_property( "virtual name" ) ;
            } else {
                fn = base_name( ob ) ;
            }
            text += ({ fn }) ;
        }
        log_file( "ILLEGAL_OBJECT", "%s: %s tried to pawn %s at %s.\n\n",
            ctime(time()), TP->query_name(), query_multiple_short( text ),
            file_name( TO ) ) ;
        in_obs -= cre ;
    }
    kept = filter_array( in_obs, (: $1->query_keep() :) ) ;
    if ( sizeof(kept) ) {
        tell_object( TP,
            "You decide not to pawn " + query_multiple_short( kept ) +
            ", as you are keeping " + ( sizeof(kept) > 1 ? "them" : "it" )
            + ".\n" ) ;
        in_obs -= kept ;
    }
    worn = filter( in_obs, (: $1->query_holder() || $1->query_worn_by() :) ) ;
    if ( sizeof(worn) ) {
        tell_object( TP, "You decide not to pawn "
            + query_multiple_short( worn ) + ", because you are wearing or "
            "holding " + ( sizeof(worn) > 1 ? "them" : "it" ) + ".\n" ) ;
        in_obs -= worn ;
    }
    stolen = filter( in_obs, (: $1->query_property( "stolen" ) :) ) ;
    if ( sizeof(stolen) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( stolen ) +
            " because " + ( sizeof(stolen) > 1 ? "they're" : "it's" ) +
            " stolen!\n" ) ;
        in_obs -= stolen ;
    }
    nobuy = filter( in_obs, (: $1->do_not_sell() || TO->do_not_buy($1) :) ) ;
    if ( sizeof( nobuy ) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( nobuy ) + ".\n" ) ;
        in_obs -= nobuy ;
    }
    cheap = filter( in_obs, (: $1->query_value() < TO->query_min_amount() :) ) ;
    if ( sizeof(cheap) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( cheap ) +
            " as " + ( sizeof(cheap) > 1 ? "they are" : "it is" ) +
            " not expensive enough.\n" ) ;
        in_obs -= cheap ;
    }
    expensive = filter( in_obs,
        (: $1->query_value() > TO->query_max_amount() :) ) ;
    if ( sizeof(expensive) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( expensive ) +
            " as " + ( sizeof(expensive) > 1 ? "they are" : "it is" ) +
            " too expensive.\n" ) ;
        in_obs -= expensive ;
    }
    if ( ! sizeof( in_obs ) ) {
        add_failed_mess( "You have nothing to pawn.\n" ) ;
        return 0 ;
    }
    foreach( ob in in_obs ) {
        value = scaled_value( ob->query_value() ) ;
        value = ( value * 90 ) / 100;
        total += value ;
        receipt = clone_object( RECEIPT ) ;
        if ( ! receipt ) {
            add_failed_mess(
                "Oh dear, something went very wrong (can't clone receipt object).  "
                "Please bugrep this room.\n" ) ;
            return 0 ;
        }
        receipt->setup_receipt( ob ) ;
        receipt->set_shop_path( TO ) ;
        receipt->set_item_value( value ) ;
        receipt->set_expiry_time( time() + query_pawn_ttl() ) ;
        receipt->setup_read_mess( _shop_language );
        receipt->move( TP ) ;
        ob->move( "/room/rubbish" ) ;
    }
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }
    m_array = MONEY_HAND->create_money_array(total, place);
    money = clone_object(MONEY_OBJECT);
    if ( ! money ) {
        add_failed_mess(
            "Oh dear, something went very wrong (can't clone money object).  "
            "Please bugrep this room.\n" ) ;
        return 0 ;
    }
    money->set_money_array(m_array);
    if ( money->move( TP ) != MOVE_OK ) {
        tell_object( TP,
            "You're too heavily burdened to accept all that money, so the "
            "shopkeeper puts it on the floor.\n" ) ;
        money->move( TO ) ;
    }
    do_parse( _pawn_mess, in_obs, TP,
        MONEY_HAND->money_string( m_array ), "" ) ;
    return 1 ;
}
int do_sell( object *in_obs ) {
    add_failed_mess(
        "If you just want to sell items, you'll need to find a general "
        "store.  Pawn shops are for pawning in.\n" ) ;
    return 0 ;
}

==================================================
FILE: /lib/std/shops/inherit/person_expressions.c
==================================================

#include <expressions.h>
#include <player_handler.h>
#include <clubs.h>
#include <nomic_system.h>
void add_allowed_function(string name, int type, int* args, function value);
void add_allowed_variable(string name, int type, function value);
private int variable_player_level(string seller) {
   return PLAYER_HANDLER->test_level(seller);
}
private string variable_player_guild(string seller) {
   string guild;
   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      return guild->query_name();
   }
   return "";
}
private string variable_player_order(string seller) {
   string guild;
   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      guild = guild->query_wizard_order();
      if (guild) {
         return replace_string(lower_case(guild), "_", " ");
      }
   }
   return "";
}
private string variable_player_name(string seller) {
   return lower_case(seller);
}
private string variable_player_deity(string seller) {
   string deity;
   deity = PLAYER_HANDLER->test_deity(seller);
   if (deity) {
      return deity;
   }
   return "";
}
private string variable_player_family(string seller) {
   string family;
   family = PLAYER_HANDLER->test_family(seller);
   if (family) {
      return family;
   }
   return "";
}
private int function_club_member(string club, string seller) {
   return CLUB_HANDLER->is_member_of(club, seller);
}
private int function_citizen_of(string region, string seller) {
   return NOMIC_HANDLER->is_citizen_of(region, seller);
}
void create() {
   if (!function_exists("add_allowed_variable", this_object())) {
      return ;
   }
   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_player_level :) );
   add_allowed_variable("guild", EXPRESSION_TYPE_STRING,
                        (: variable_player_guild :) );
   add_allowed_variable("deity", EXPRESSION_TYPE_STRING,
                        (: variable_player_deity :) );
   add_allowed_variable("family", EXPRESSION_TYPE_STRING,
                        (: variable_player_family :) );
   add_allowed_variable("order", EXPRESSION_TYPE_STRING,
                        (: variable_player_order :) );
   add_allowed_variable("playername", EXPRESSION_TYPE_STRING,
                        (: variable_player_name :) );
   add_allowed_function("clubmember", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
   add_allowed_function("citizenof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
}
# Total Tokens: 13305
# Total Files Merged: 7
# Total Characters: 44372

