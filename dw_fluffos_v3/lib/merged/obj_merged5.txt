# Total Tokens: 12326
# Total Files Merged: 11
# Total Characters: 41120

=============================================

#include <artifacts.h>
#include <tasks.h>
inherit "/obj/armour";
inherit "/std/basic/artifact";
int query_magic_ring() { return 1; }
void create() {
   ::create();
   set_type( "ring" );
   set_damage_chance( 8 );
   set_artifact_type( "ring" );
   add_property( "shop type", "jewellers" );
   add_alias( "jewellery" );
   add_plural("jewellery");
}
void set_weight( int number ) {
   armour::set_weight( number );
   setup_armour( 250 * number );
   add_ac( "blunt", "blunt", 5 * weight );
   add_ac( "sharp", "sharp", 2 * weight );
}
string long( int word, int dark ) {
  return artifact::long( word, dark ) + armour::long( word, dark );
}
void init() {
  this_player()->add_command( "twist", this_object() );
}
int do_twist() {
  int outcome;
  if ( query_worn_by() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be "+
        "wearing $D to $V it.\n", ({ }) );
    return 0;
  }
  outcome = (int)TASKER->perform_task(this_player(), RING_SKILL,
                                      level, TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to use $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
  if ( outcome == AWARD ) {
    write( "%^YELLOW%^" +
          ({ "A piece of lore concerning rings becomes clearer for "+
        "you.\n", "You manage to grasp one of the principles of magic "+
        "rings more firmly.\n", "A sudden flash of insight allows you "+
        "to understand the ring a little better.\n" })[ random( 3 ) ] +
          "%^RESET%^");
  }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( 0, this_player(), this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D but "+
          "nothing happens!\n", ({ }) );
    return 1;
  }
  zapper->zap( 0, this_player(), this_object() );
  return 1;
}
mixed *stats() {
  return armour::stats() + artifact::stats();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : armour::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/ring" )
    return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    armour::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    armour::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
}

==================================================
FILE: roommak.c
==================================================

inherit "/std/object";
mixed *exits,
      *items;
string de_long,
       de_short;
int de_light;
void setup() {
  set_name("maker");
  add_adjective("room");
  set_short("Room maker");
  set_long("It is a small wooden rod about 30 centimeters long with deep "+
           "burn marks along the sides.  It has what looks like a small "+
           "lens stuck in the end and three buttons along its length.\n");
}
void init() {
  if (this_player()->query_creator()) {
    add_action("do_new", "new");
    add_action("do_set", "set");
    add_action("do_add", "add");
    add_action("do_setup", "setup");
    add_action("do_modify", "modify");
    add_action("do_map", "map");
  }
}
int do_new(string str) {
  if (!str) {
    notify_fail("Syntax: new <name>\n");
    return 0;
  }
}

==================================================
FILE: salve.c
==================================================

#include <drinks.h>
inherit "/obj/food";
mapping apply_effects;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  apply_effects = ([ ]);
  if ( !do_setup )
    this_object()->setup();
}
void init() {
  this_player()->add_command( "apply", this_object(), "<direct:object> to <indirect:object>");
}
mapping query_apply_effects() { return apply_effects; }
void set_apply_effects( mapping map ) { apply_effects = map; }
int add_apply_effect( string word, int number ) {
  if ( apply_effects[ word ] )
    apply_effects[ word ] += number;
  else
    apply_effects[ word ] = number;
  return apply_effects[ word ];
}
void remove_apply_effect( string word ) {
  if ( !undefinedp( apply_effects[ word ] ) )
    apply_effects = m_delete( apply_effects, word );
}
void being_joined_by( object thing ) {
  int i, that, this;
  string *words;
  mapping new_effects;
  that = (int)thing->query_amount();
  this = query_amount();
  if ( !( this + that ) )
    return;
  new_effects = (mapping)thing->query_apply_effects();
  words = m_indices( apply_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    if ( new_effects[ words[ i ] ] ) {
      new_effects[ words[ i ] ] *= that;
      new_effects[ words[ i ] ] += this * apply_effects[ words[ i ] ];
    } else
      new_effects[ words[ i ] ] = this * apply_effects[ words[ i ] ];
  words = m_indices( new_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    new_effects[ words[ i ] ] /= this + that;
  apply_effects = new_effects;
}
int do_apply(object *indir, string dir_s, string indir_s, mixed *args) {
    string *words;
    int i;
    if (environment(this_object()) != this_player()) {
        write("You aren't holding the " + dir_s + ".\n");
        return 0;
    }
    if (sizeof(indir) != 1) {
        write("You can only " + query_verb() + " to one thing at a time.\n");
        return 0;
    }
    if (living(indir[0])) {
        words = m_indices( apply_effects );
        for (i = 0; i < sizeof(words); i++) {
            indir[0]->add_effect(words[i], apply_effects[words[i]] * query_amount());
        }
    }
    this_player()->add_succeeded(indir[0]);
    move("/room/rubbish");
    return 1;
}
mapping query_static_auto_load() {
  if ( ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/salve" )
      && !query_continuous() )
    return 0;
return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "apply_effects" : apply_effects + ([ ]),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  apply_effects = map[ "apply_effects" ];
}
mixed *stats() {
  int i;
  string *words;
  mixed *args;
  args = ::stats();
  words = m_indices( apply_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    args += ({ ({ "apply effect#"+ i, words[ i ] +" ("+
        apply_effects[ words[ i ] ] +")" }) });
  return args;
}

==================================================
FILE: scabbard.c
==================================================

#include <move_failures.h>
#include <virtual.h>
inherit "/std/container";
inherit "/std/basic/wearable";
string sheath;
string * types;
int _no_types_in_long;
void create() {
   do_setup++;
   container::create();
   wearable::create();
   do_setup--;
   sheath = "";
   types = ({ });
   _no_types_in_long = 0;
   add_alias( "scabbard" );
   add_plural( "scabbards" );
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   if ( !do_setup )
      this_object()->setup();
}
int query_scabbard() { return 1; }
string *query_types() { return types; }
void set_types( string *words ) {
   types = words;
   switch ( sizeof( types ) ) {
      case 0 :
         sheath = "";
         return;
      case 1 :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +".\n";
         return;
      case 2 :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +" or "+
               types[ 1 ] +".\n";
         return;
      default :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +", "+
               implode( types[ 2 .. ], ", " ) +" or "+ types[ 1 ] +
               ".\n";
   }
}
int test_type_ok( object thing, int flag ) {
  foreach( string word in types ) {
    if( thing->full_id( word ) )
      return ::test_add( thing, flag );
  }
  return 0;
}
varargs int test_add( object thing, int flag, int noprint ) {
   int foo;
   if(flag)
      return 0;
   if( !environment( thing ) )
      return ::test_add( thing, flag );
   if( first_inventory( this_object() ) ) {
      if( !noprint )
         write( the_short() + " already holds " +
           first_inventory( this_object() )->a_short() + ".\n" );
      return 0;
   }
   foo = test_type_ok( thing, flag );
   if(foo)
      return foo;
   if( !noprint )
      write( thing->the_short() + " doesn't fit very well in "
        + the_short() + ".  " + sheath );
   return 0;
}
string long( string word, int dark ) {
   string foo = _no_types_in_long ? "" : sheath;
   if ( dark == 2 || dark == -2) {
      return container::long( word, dark );
   }
   return container::long( word, dark ) + foo +
         query_contents( "$C$"+ the_short() +" contains: " ) +
         wearable::long( word, dark );
}
int query_ac( string type, int amount ) {
   do_damage( type, amount );
}
void setup_scabbard( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
}
int query_value() {
   return modify_value( container::query_value() );
}
int query_full_value() { return container::query_value(); }
int drop(mixed dest) {
   if ( worn_by )
      if ( living( worn_by ) )
         return 1;
   return container::drop(dest);
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = container::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
}
void dest_me() {
   set_worn_by( 0 );
   container::dest_me();
}
void break_me() {
   if ( worn_by )
      all_inventory()->move( environment( worn_by ), "$N fall$s from "+
            a_short() +"." );
   else
      all_inventory()->move( environment(), "$N fall$s out of "+
            a_short() +"." );
   ::break_me();
}
mixed *stats() {
   return container::stats() + wearable::stats();
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/scabbard" )
      return ([ ]);
   return ([
      "::" : container::int_query_static_auto_load(),
      "wear" : wearable::query_static_auto_load(),
      "types" : types,
      "_no_types_in_long" : _no_types_in_long,
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : container::query_dynamic_auto_load(),
      "wear" : wearable::query_dynamic_auto_load()
   ]);
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      container::init_static_arg( map[ "::" ] );
   if ( map[ "wear" ] )
      wearable::init_static_arg( map[ "wear" ] );
   if ( pointerp( map[ "types" ] ) )
      set_types( map[ "types" ] );
   if ( map[ "_no_types_in_long" ] )
      _no_types_in_long = map[ "_no_types_in_long" ];
}
void init_dynamic_arg( mapping map, object ob ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] )
      container::init_dynamic_arg( map[ "::" ], ob );
   if ( map[ "wear" ] )
      wearable::init_dynamic_arg( map[ "wear" ], ob );
   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
}
int no_types_in_long() {
   return _no_types_in_long;
}
int set_no_types_in_long( int val ) {
   _no_types_in_long = val ? 1 : 0;
   return _no_types_in_long;
}

==================================================
FILE: service_provider.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/obj/monster";
#define SERVICE  0
#define BROWSE   1
#define FUNCTION 2
#define COST     3
#define ALIASES  4
private int parsing_function( mixed *array , string words );
int _busy;
mixed *_service_array = ({ });
void set_busy()   { _busy = 1; }
void reset_busy() { _busy = 0; }
varargs int check_busy( object player )
{
    if( _busy || sizeof( query_queued_commands() ) )
    {
        if( player ) {
            tell_object( player, query_short() +" is busy at the moment."+
            "  " + capitalize( query_pronoun() )+ " will be with you " +
            "shortly.\n" );
        }
    return 1;
    } else
        return 0;
}
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) this_object()->setup();
}
void init()
{
    ::init();
    this_player()->add_command( "inquire", this_object(),
        "[a] <string> {from|of} <direct:living:here>", "do_browse" );
    this_player()->add_command( "browse", this_object(),
        "[a] <string> {from|of} <direct:living:here>" );
    this_player()->add_command( "request", this_object(),
        "[a] <string> from <direct:living:here>" );
    this_player()->add_command( "list", this_object(),
        "services [available] {from|of} <direct:living:here>" );
}
varargs int add_service( string service , string browse_info ,
    string func, int cost, string *aliases )
{
    string *alias_array;
    if( !service || !browse_info || !func ||
        !function_exists( func , this_object() , 1 ) )
            return 0;
    alias_array = !sizeof(aliases) ? ({ }) : aliases ;
    _service_array += ({ ({ service , browse_info , func , cost ,
        alias_array }) });
    return 1;
}
int remove_service( string service )
{
    mixed *things;
    things = filter( _service_array, (: $1[SERVICE]==$(service) :) );
    switch( sizeof(things) ) {
        case 1: _service_array -= things; return 0; break;
        default: return 0; break;
    }
    return 0;
}
int do_browse( mixed indirect_obs, string dir_match, string indir_match,
    string *words )
{
    string place;
    mixed *things;
    object player;
    player = this_player();
    if ( check_busy( player ) ) return 0;
    place = query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";
    things =
        filter( _service_array ,(:parsing_function( $1, $(words)[0]):) );
    if( !sizeof( things ) ) {
        init_command( "say I'm afraid I don't offer that service.", 2 );
    } else {
        init_command("say A " + things[0][SERVICE] + " costs " +
            MONEY_HAND->money_value_string( things[0][COST], place ) +
            ".  " + things[0][1], 2 );
    }
    player->add_succeeded_mess( this_object(), "$N ask$s $D "+
          "about "+ words[ 0 ] +".\n", ({ }) );
    return 1;
}
int do_request( mixed indirect_obs, string dir_match, string indir_match,
      string *words )
{
    mixed *things;
    object player;
    int value;
    string place;
    player = this_player();
    place = query_property("place");
    if ( !place || place == "" )
        place = "default";
    if ( check_busy( player ) ) return 0;
    things =
        filter( _service_array , (: parsing_function($1,$(words)[0]) :));
    if ( !sizeof( things ) )
        init_command( "say I'm afraid I don't offer that service.", 2 );
    else {
        value = player->query_value_in("default") +
            ( place == "default" ? 0 : player->query_value_in( place ) );
        if( things[0][COST] > value )
            init_command("say And just how do you propose to pay "+
                "for a "+things[0][SERVICE]+"?" , 2 );
        else {
            init_command("say Certainly, "+
                ( player->query_gender() == 1 ? "Sir" : "Ma'am" )+
                "!");
            tell_object( player , "You hand "+query_short()+" the "+
                "necessary money.\n");
            player->pay_money( MONEY_HAND->
                create_money_array(things[0][COST], place ), place );
            call_out( things[0][FUNCTION] , 4 , player, things[0] );
        }
    }
    player->add_succeeded_mess( this_object(), "$N ask$s $D "+
        "about having a "+ words[ 0 ] +".\n", ({ }) );
   return 1;
}
int do_list()
{
    string place, list;
    int i,number;
    number = sizeof( _service_array );
    place = query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";
    list = "I am currently offering the following: ";
    if( number > 3 ) {
        for( i=0 ; i < (number-2) ; i++ ) {
            list += ( "a "+_service_array[i][SERVICE]+" for "+
                MONEY_HAND->money_value_string(
                    _service_array[i][COST], place )+", " );
        }
    }
    if( number > 1 ) {
        list += ( "a " + _service_array[<2][SERVICE] + " for " +
            MONEY_HAND->money_value_string(
                _service_array[<2][COST], place ) +" and " );
    }
    if( number > 0 ) {
        list += ( _service_array[<1][SERVICE] + " for " +
            MONEY_HAND->money_value_string(
                _service_array[<1][COST], place ) +"." );
    }
    if( number == 0 )
        list = "I am not currently offering any services.";
    init_command("say "+ list, 2);
    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D what "+
         "services "+ (string)this_object()->query_pronoun() +" has "+
         "on offer.\n", ({ }) );
   return 1;
}
private int parsing_function( mixed *array , string word )
{
    if ( array[SERVICE] == word ) return 1;
    if ( member_array( word, array[ALIASES] ) != -1 ) return 1;
    return 0;
}

==================================================
FILE: shield.c
==================================================

#include <move_failures.h>
#include <virtual.h>
#define AC_LIMIT 100
#undef INFORM
inherit "/obj/armour";
inherit "/std/basic/holdable";
int no_limbs;
nosave int held_in;
void create() {
   do_setup++;
   armour::create();
   add_alias( ({ "armour", "shield" }) );
   add_plural( ({ "armours", "shields" }) );
   add_help_file("armour");
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   do_setup--;
   if ( !do_setup )
      this_object()->setup();
}
int query_no_limbs() { return no_limbs; }
void set_no_limbs( int number ) { no_limbs = number; }
mixed set_holder( object thing, int number ) {
   if (!::set_holder(thing, number))  return 0;
   if(!thing) {
     worn_by = 0;
     held_in = 0;
   } else {
     worn_by = thing;
     held_in = number;
   }
   return 1;
}
int query_wearable() { return 0; }
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   if ( worn_by && ( worn_by != dest ) )
      if ( !sizeof( (int *)worn_by->set_unhold( this_object() ) ) )
         return MOVE_NO_UNHOLD;
   flag = armour::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
}
void dest_me() {
   set_worn_by( 0 );
   armour::dest_me();
}
mixed *stats() {
   return armour::stats() + ({ ({ "no_limbs", no_limbs }) });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : armour::int_query_static_auto_load(),
      "no limbs" : no_limbs,
   ]);
}
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([
      "::" : armour::query_dynamic_auto_load(),
   ]);
   return map;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      armour::init_static_arg( map[ "::" ] );
   if ( map[ "no limbs" ] )
      no_limbs = map[ "no limbs" ];
}
void replace_me(){
  object receipt;
  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}
void init_dynamic_arg( mapping map, object ) {
   if ( map[ "::" ] )
      armour::init_dynamic_arg( map[ "::" ] );
}

==================================================
FILE: shovel.c
==================================================

inherit "/obj/weapon";
string *patterns = ({
  "with <direct:object> in <string>",
  "with <direct:object> in <indirect:object>",
  "with <direct:object>",
  "[in] <string> with <direct:object>",
  "[in] <indirect:object> with <direct:object>"
});
void init(){
  this_player()->add_command("dig", this_object(), patterns);
}
int do_dig( object *things, string dir_match, string
            indir_match, mixed *args, string pattern) {
  object *obj, indir;
  string indir_s;
  if (!objectp(environment(this_player()))) {
    return 0;
  }
  obj=this_player()->query_holding();
  if(member_array(this_object(), obj) == -1){
    this_player()->add_failed_mess(this_object(), "You must hold the $D to "
                                   "dig with it.\n", ({}));
    return 0;
  }
  if (pattern == patterns[4]) {
    if (!objectp(indir = things[0])) {
      return 0;
    }
    indir_s = args[0];
  } else if (pattern == patterns[3]) {
    indir_s = args[0];
    indir = 0;
  } else if (pattern == patterns[2]) {
    indir_s = 0;
    indir = 0;
  } else if (pattern == patterns[1]) {
    if (!objectp(indir = things[0])) {
      return 0;
    }
    indir_s = args[1];
  } else if (pattern == patterns[0]) {
    indir_s = args[1];
    indir = 0;
  } else {
    return 0;
  }
  return environment(this_player())->dig(indir, indir_s);
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/shovel" )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: shut.c
==================================================

#include <network.h>
#define OFFLER_SHADOW "/std/shadows/misc/offler_shadow"
#undef CONVERTER
#undef AUTO_RESURRECT
inherit "/std/container";
int time_of_crash, time_of_last_shout;
void setup() {
  if (file_name(this_object()) != "/obj/shut") {
    write("This object can't be cloned.\n");
    dest_me();
    return;
    }
  set_name("offler");
  set_living_name("offler");
  add_adjective( ({ "offler", "the", "crocodile" }));
  add_alias("god");
  enable_commands();
  set_short( "Offler" );
  add_property( "determinate", "" );
  set_long("The Crocodile God.  He looks big, green, and, well "+
           "like this really.\n");
  add_alias("shut");
  reset_get();
}
#define ishout(str) user_event("say", "%^BOLD%^%^RED%^Offler the Crocodile God shouts: "+str+"%^RESET%^\n", 0)
void heart_beat() {
   int time_to_crash;
   if (!time_of_crash) return;
   time_to_crash = time_of_crash - time();
   if (time_to_crash < 1) {
      call_out("end_it_all",0);
      set_heart_beat(0);
      return;
   }
   if (time_to_crash < 10)  {
      ishout( "Game weboot in "+ time_to_crash +" thecondth." );
      return;
   }
   if (time_to_crash < 60 && time_to_crash % 10 < 2) {
      ishout( "Game ith webooting in "+ time_to_crash +
            " thecondth.  Go away!" );
      return;
   }
   if (time_to_crash % 60 > 5)
      return;
   time_to_crash /= 60;
   if (time_to_crash == time_of_last_shout)
      return;
   time_of_last_shout = time_to_crash;
   if (time_to_crash > 30) {
      return ;
   }
   if(time_to_crash == 1) {
      ishout( "Game ith webooting in one minute.  Quit now!" );
      return;
   }
   if (time_to_crash < 10 || !(time_to_crash % 10)) {
      ishout( "Game ith webooting in "+ time_to_crash +" minuteth." );
      return;
   }
}
void shut(int minutes, string reason) {
   object *players;
   int i;
   string fname;
   if (!intp(minutes)) {
      write("Bad argument\n");
      return;
   }
   fname = file_name(previous_object());
   if (minutes <= 0) {
      write("No time given\n");
      return;
   }
#ifdef CONVERTER
   if (!CONVERTER->ok_to_shut()) {
      dest_me();
      return;
   }
#endif
   players = users();
   for (i=0;i<sizeof(players);i++) {
     if ( !players[ i ] )
       continue;
     if (players[i]->query_creator())
     tell_object(players[i], "%^BOLD%^%^RED%^Offler the Crocodile God wishes "
                 "you to know:  The mud is rebooting in "+
                 number_as_string( minutes ) + " minutes.%^RESET%^\n" );
   }
   set_long("He is firmly concentrating on counting.\n");
   if (time_of_crash)
     write( "There was already a reboot scheduled, set for "+
           (time_of_crash - time()) + " seconds.\n");
   move("/d/am/buildings/drum/mendeddrum",
      "Offler the Crocodile God appears in a puff of smoke.",
      "Offler the Crocodile God appears in a puff of smoke.");
   time_of_crash = time() + minutes*60;
   time_of_last_shout = minutes;
   set_heart_beat(1);
#ifdef AUTO_RESURRECT
   call_out( "check_ghosts", 60 );
#endif
   if(file_name(previous_object()) == "/obj/handlers/garbage")
     log_file("REBOOT", "Shutdown requested automatically at "+ctime(time())+
              "\n");
   else if(this_player())
     log_file("REBOOT", "Shutdown at "+ctime(time())+" requested by " +
              this_player()->query_cap_name()+" for " + reason + "\n");
   else
     log_file("REBOOT", "Shutdown at "+ctime(time())+" requested by " +
              file_name(previous_object()) + " for " + reason + "\n");
}
string long(string str, int dark) {
  ::long(str, dark);
  if ( time_of_crash && this_player() && this_player()->query_creator() )
     return ::long(str,dark)+
            "Game reboot will be in " + ( time_of_crash - time() ) +
            " seconds.\n";
  return ::long(str,dark);
}
void end_it_all() {
   int i;
   object *obs;
   ishout( "Thutdown now!" );
   obs = users();
   for (i=0;i<sizeof(obs);i++) {
      call_out("force_quit", i, obs[i]);
   }
   call_out("blue", 10);
}
void force_quit( object ob ) {
   if ( !objectp( ob ) )
      return;
   ob->stop_all_fight();
   if(ob->query_login_ob()) {
     ob->dest_me();
     return;
   }
   if ( !environment( ob ) )
     ob->move( "/d/am/buildings/drum/mendeddrum" );
   if(environment(ob) &&
      file_name( environment( ob ) ) != "/room/departures" ) {
     ob->quit_alt();
   }
   if (environment(ob) &&
       file_name( environment( ob ) ) != "/room/departures" ) {
     ob->quit();
   }
}
void blue() {
  if (sizeof(users()) > 0 &&
      time() - time_of_crash < 240)
    call_out("blue", 10);
  else {
    SERVICES_D->eventShutdown(1);
    shutdown(0);
  }
}
int query_time_to_crash() {
   if ( !time_of_crash ) {
      call_out( "dest_me", 1 );
      return 9999;
   }
   set_heart_beat( 1 );
   return time_of_crash - time();
}
int query_unambushable() { return 1; }
void do_ambushed() {
   write( "Bad mistake...\n" );
   this_player()->run_away();
}
#ifdef AUTO_RESURRECT
void person_died( string word, int number ) {
   object thing;
   thing = find_player( word );
   if ( !thing )
      return;
   switch ( number ) {
      case 0 :
         break;
      case 1 :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Well, "+
               "weally!  Thilly mortal, of all the timeth to die!\n" );
         break;
      case 2 :
         tell_object( thing, "$I$5=Offler tells you: Don't wowwy, I'll "+
               "welieve the chap with the thythe of you thith time.\n" );
         break;
      case 3 :
         thing->remove_ghost();
         clone_object( OFFLER_SHADOW )->setup_shadow( thing );
         break;
      default :
         tell_object( thing, "$I$5=Offler tells you exclaiming: And behave "+
               "yourthelf until I'm done, for goodneth' thake!\n" );
         return;
   }
   call_out( "person_died", 3, word, number + 1 );
}
void person_dead( object thing, int number ) {
   if ( !thing )
      return;
   if ( thing->query_property( "noregen" ) ) {
      call_out( "person_dead", 3, thing, number );
      return;
   }
   switch ( number ) {
      case 0 :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Well, "+
               "weally!  Can't have you wunning awound detheathed!\n" );
         break;
      case 1 :
         thing->remove_ghost();
         clone_object( OFFLER_SHADOW )->setup_shadow( thing );
         break;
      default :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Now behave "+
               "yourthelf until I'm done, for goodneth' thake!\n" );
         return;
   }
   call_out( "person_dead", 3, thing, number + 1 );
}
void check_ghosts() {
   object thing;
   foreach( thing in users() ) {
      if ( !thing ) {
          continue;
      }
      if ( !thing->query_property( "dead" ) ) {
         continue;
      }
      if ( (int)thing->query_deaths() > (int)thing->query_max_deaths() ) {
         continue;
      }
      call_out( "person_dead", 3, thing, 0 );
   }
}
#endif

==================================================
FILE: staff.c
==================================================

#include <artifacts.h>
#include <tasks.h>
inherit "/obj/weapon";
inherit "/std/basic/artifact";
int query_magic_staff() { return 1; }
void create() {
  weapon::create();
  set_artifact_type( "staff" );
  set_no_limbs( 2 );
}
void set_weight( int number ) {
  weapon::set_weight( number );
  new_weapon( 80 * number );
    add_attack( "thwack", 50, ({ weight / 3, 4, weight }), "blunt",
         "blunt", 0 );
    add_attack( "prod", 50, ({ weight / 2, 4, weight / 2 }), "blunt",
         "blunt", 0 );
}
string long( int word, int dark ) {
  return artifact::long( word, dark ) + weapon::long( word, dark );
}
void init() {
  this_player()->add_command( "invoke", this_object() );
}
int do_invoke() {
  int outcome;
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to $V it.\n", ({ }) );
    return 0;
  }
  outcome = (int)TASKER->perform_task(this_player(), STAFF_SKILL, level,
                                      TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to $V $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
  if ( outcome == AWARD ) {
    write("%^YELLOW%^"+
          ({ "A piece of lore concerning staves becomes clearer for "+
             "you.\n", "You manage to grasp one of the principles of magic "+
             "staves more firmly.\n", "A sudden flash of insight allows you "+
             "to understand the staff a little better.\n" })[ random( 3 ) ] +
          "%^RESET%^");
  }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( environment( this_player() ), this_player(),
        this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D but "+
          "nothing happens!\n", ({ }) );
    return 1;
  }
  zapper->zap( environment( this_player() ), this_player(), this_object() );
  return 1;
}
mixed *stats() {
  return weapon::stats() + artifact::stats();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : weapon::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/staff" )
      return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
  if ( map[ "::" ] )
    weapon::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
}

==================================================
FILE: state_changer.c
==================================================

#include <tasks.h>
#include <effect.h>
#define STATE_CHANGE "/obj/handlers/state_change"
inherit "/obj/vessel";
object *add_list = ({ });
int query_busy();
int do_action( object *obs );
string parse_message( string message );
string query_classification();
string command;
string process;
string start_mess;
string interim_mess;
string end_mess;
int duration;
int base_bonus;
string skill;
string fail_process;
string end_mess_fail;
string end_mess_abort;
string command_mess;
function start_func;
function end_func;
function fail_func;
int gp_cost;
string gp_type = "other";
string running_inv_mess;
void create() {
    ::create();
    set_stuck( 1 );
    set_leak_rate( 0 );
    set_weight( 100 );
    set_max_weight( 5000 );
    set_max_volume( 5000 );
    set_hide_cond( 1 );
    this_object()->add_extra_look(this_object());
}
void set_command( string _command ) { command = _command; }
void set_process( string _process ) { process = _process; }
void set_fail_process( string _process ) { fail_process = _process; }
void set_start_message( string message ) { start_mess = message; }
void set_interim_message( string message ) { interim_mess = message; }
void set_end_message( string message ) { end_mess = message; }
void set_fail_message( string message ) { end_mess_fail = message; }
void set_abort_message( string message ) { end_mess_abort = message; }
void set_duration( int _duration ) { duration = _duration; }
void set_command_mess( string message ) { command_mess = message; }
void set_start_func( function f ) { start_func = f; }
void set_end_func( function f ) { start_func = f; }
void set_fail_func( function f) { fail_func = f; }
void set_skill( string _skill, int _base_bonus ) {
    skill = _skill;
    base_bonus = _base_bonus;
}
void set_gp_cost( int gp ) { gp_cost = gp; }
void set_gp_type( string type ) { gp_type = type; }
void set_running_inv_mess( string mess ) { running_inv_mess = mess; }
void init() {
  ::init();
  if ( command ) {
    add_command( command, "all in <direct:object>", (: do_action( $1 ) :) );
  }
}
int do_action( object *obs ) {
int *tmp;
  if ( gp_cost ) {
      if ( this_player()->query_specific_gp( gp_type ) < gp_cost )
          return notify_fail( "You are too tired to "+ command +" with the "+ this_object()->the_short() + ".\n" );
      this_player()->adjust_gp( -gp_cost );
  }
  if ( sizeof( tmp = this_object()->effects_matching( query_classification() ) ) )
    return notify_fail( this_object()->the_short() + " is already being used by "+
      this_object()->arg_of( tmp[0] )->query_short() +"!\n" );
  if ( !sizeof( all_inventory( this_object() ) ) )
    return notify_fail( "There is nothing to "+ command + ".\n" );
  if ( functionp( start_func ) ) {
    if ( !evaluate( start_func ) ) {
        debug_printf( "Stopped at start_func\n" );
        return notify_fail( "" );
    }
  }
  this_object()->add_effect( file_name( this_object() ), this_player() );
  if ( stringp( start_mess ) )
      tell_room( environment(), parse_message(start_mess) );
  if ( stringp( command_mess ) ) {
      this_player()->add_succeeded_mess( this_object(), parse_message( command_mess ),
          all_inventory( this_object() ) );
    debug_printf( "Setting asm to %s.\n", parse_message( command_mess ) );
  }
  else
      this_player()->add_succeeded_mess( this_object(), "$N "+ command +"$s $I "
        "in $D.\n", all_inventory( this_object() ) );
  return 1;
}
object beginning(object apparatus, object tp, int id) {
    apparatus->submit_ee(0, duration, EE_REMOVE);
    apparatus->submit_ee("show_message", ({ 30, 30 }), EE_CONTINUOUS);
    return tp;
}
object show_message(object apparatus, object tp, int id) {
  if ( stringp( interim_mess ) )
      tell_room(environment(), parse_message(interim_mess) );
  if ( !sizeof( all_inventory() ) )
    submit_ee( 0, 0, EE_REMOVE );
  return tp;
}
object end(object apparatus, object tp, int id) {
 object ob;
 int temp;
 int l_bonus = base_bonus;
  if ( functionp( end_func ) ) {
    if ( !evaluate( end_func ) ) {
        debug_printf( "Stopped at start_func\n" );
        return tp;
    }
  }
  if ( !sizeof( all_inventory() ) ) {
    debug_printf( "Aborted due to lack of inventory!\n" );
    if ( stringp( end_mess_abort ) )
      tell_room( environment(), parse_message(end_mess_abort) );
    return tp;
  }
  foreach( object i in all_inventory() ) {
      if ( temp = i->query_property( process + " modifier" ) ) {
          l_bonus += temp;
          debug_printf( "%s difficulty will be modified by %d (%O).\n",
             process, temp, ob );
      }
  }
  if ( skill ) {
      switch( TASKER->perform_task( tp, skill, l_bonus, TM_COMMAND ) ) {
        case AWARD:
          tell_object( tp, "%^YELLOW%^You learn something new about "+ process +"ing!%^RESET%^\n" );
        case SUCCEED:
          tell_room( environment(), parse_message(end_mess) );
          foreach( object i in all_inventory() ) {
            if (!i)
              continue;
              ob = STATE_CHANGE->transform( i, process, tp );
              debug_printf( "Transforming: %O to %O.\n", i, ob );
              if ( ob ) {
                add_list += ({ ob });
                i->move( "/room/rubbish" );
                ob->move( this_object() );
              }
           }
           break;
        default:
            if ( stringp( end_mess ) )
                tell_room( environment(), parse_message(end_mess_fail) );
            if ( functionp( fail_func ) )
                evaluate( fail_func );
            foreach( object i in all_inventory() ) {
              if (!i)
                continue;
              ob = STATE_CHANGE->transform( i, fail_process, tp );
              debug_printf( "Transforming: %O to %O.\n", i, ob );
              if ( ob ) {
                add_list += ({ ob });
                i->move( "/room/rubbish" );
                ob->move( this_object() );
              }
           }
           break;
      }
  }
  else {
    if ( stringp( end_mess ) )
        tell_room( environment(), parse_message(end_mess) );
    foreach( object i in all_inventory() ) {
      if (!i)
        continue;
      ob = STATE_CHANGE->transform( i, process, tp );
      debug_printf( "Transforming: %O to %O.\n", i, ob );
      if ( ob ) {
        add_list += ({ ob });
        i->move( "/room/rubbish" );
      }
      add_list->move( this_object() );
      add_list = ({ });
    }
  }
  return tp;
}
string query_classification() { return "state.changing."+ process; }
string extra_look( object ob ) {
  return "";
}
string parse_message( string message ) {
  message = replace( message, "$inventory$", query_multiple_short( all_inventory() ) );
  debug_printf( "message is: %s.\n" , message );
  return message;
}
int test_add(object ob, int flag) {
    debug_printf( "Testing add of: %O (%O) in state changer.\n", ob, environment( ob ) );
    if ( member_array( ob, add_list ) != -1 ) {
       return ::test_add( ob, flag );
    }
    if ( query_busy() ) {
        tell_object( this_player(), "It might not be wise to add anything to "+
            this_object()->the_short() + " while it is in use!\n" );
        return 0;
    }
    return ::test_add( ob, flag );
}
int test_remove( object ob, int flag, mixed dest ) {
    if ( dest && base_name( dest ) == "/room/rubbish" )
        ::test_remove( ob, flag, dest );
    debug_printf( "Testing remove of: %O (%O) in state changer.\n", ob, environment( ob ) );
    if ( query_busy() ) {
        tell_object( this_player(), "It might not be wise to take anything from "+
            this_object()->the_short() + " while it is in use!\n" );
        return 0;
    }
    return ::test_remove( ob, flag, dest );
}
string long( string word, int dark ) {
  if ( query_busy() ) {
    if ( stringp( running_inv_mess ) )
      return query_long() + parse_message( running_inv_mess );
    else
      return ::long( word, dark );
  }
  return ::long( word, dark );
}
int do_empty(object *dest, string me, string him, string prep) {
  if ( query_busy() ) {
    add_failed_mess( "You can't empty "+ this_object()->short() +" while it is being used.\n" );
    return 0;
  }
  return ::do_empty( dest, me, him, prep );
}
int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {
  if ( query_busy() ) {
    add_failed_mess( "You can't fill anything from "+ this_object()->short()
      +" while it is being used.\n" );
    return 0;
  }
  return  ::do_fill( to, args_b, args_a, args );
}
int query_busy() { return !!sizeof( this_object()->effects_matching( query_classification() ) ); }

==================================================
FILE: surf_save.c
==================================================

inherit "/std/surface";
mapping details;
nosave string save_file;
void do_load() {
   if ( save_file ) {
      all_inventory( this_object() ) -> dest_me();
      if ( file_size( save_file + ".o" ) > 0 ) {
	 unguarded((: restore_object, save_file :));
	 if ( sizeof( details ) ) init_dynamic_arg( details );
      }
   }
}
void create() {
   save_file = "";
   details = ([ ]);
   ::create();
}
int test_remove( object ob, int flag) {
   if ( find_call_out( "do_save" ) == -1 )
      call_out( "do_save", 0 );
   return 1;
}
int test_add( object ob, int flag) {
   if ( find_call_out( "do_save" ) == -1 )
      call_out( "do_save", 0 );
   return 1;
}
void do_save() {
   if ( save_file ) {
      details = ([ ]);
      details = query_dynamic_auto_load();
      unguarded((: save_object, save_file :));
   }
}
void check_euid() {
   if ( previous_object() )
     seteuid( geteuid( previous_object() ) );
}
void set_save_file( string file ) {
   save_file = file;
   do_load();
}
