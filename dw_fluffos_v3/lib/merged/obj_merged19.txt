




==================================================
FILE: /lib/obj/handlers/weather.c
==================================================

#include <climate.h>
#include <am_time.h>
#include <weather.h>
#define FILE_NAME "/save/nweather"
#define UPDATE_SPEED 300
#define CYCLE_SPEED  3600
#define DIY 400
#define DIF(x, y) (x > y) ? (x-y) : (y-x)
private mapping _pattern;
private mapping _current;
private int *_variance;
private nosave mapping _rooms;
private nosave int _lastupdate;
private nosave int _day;
private nosave int _sunrise;
private nosave int _sunset;
private nosave int _toy;
private int mooncycle;
private int moonupdate;
void set_day();
void update_pattern();
int calc_actual(object env, int type);
int cloud_index(object env);
int query_day(object env);
int query_rain_type(int temp, int rain);
string sun_direction(int which);
int temperature_index(object env);
int rain_index(object env);
void create() {
  string str;
  _rooms = ([ ]);
  unguarded((: restore_object, FILE_NAME :));
  if(!_pattern)
    _pattern = ([ ]);
  if(!_current)
    _current = ([ ]);
  if(!_variance)
    _variance = ({ 10, 75, 20 });
  foreach(str in CLIMATES) {
    if(!_pattern[str])
      _pattern[str] =  ({ 0, 0, 0 });
    if(!_current[str])
      _current[str] =  ({ 0, 0, 0 });
  }
  call_out("update_weather", UPDATE_SPEED);
  set_day();
  update_pattern();
}
int weather_notify( object which_room, int notifications ) {
  if(notifications < 0 || notifications >
     (NOTIFY_TEMPERATURE | NOTIFY_CLOUD | NOTIFY_RAIN | NOTIFY_DAY)) {
    return 0;
  }
  _rooms[which_room] = notifications;
  return 1;
}
void test_notifications() {
  object room;
  string w;
  foreach( room in keys(_rooms)) {
    w = sprintf("%O notified of %s%s%s%s\n", room,
    ((_rooms[room] & NOTIFY_TEMPERATURE) ? "Temperature " : ""),
                ((_rooms[room] & NOTIFY_CLOUD) ? "Clouds " : ""),
                ((_rooms[room] & NOTIFY_RAIN) ? "Rain " : ""),
                ((_rooms[room] & NOTIFY_DAY) ? "Day" : ""));
    write( w );
  }
  write("test_notifications() done\n");
}
int day_number() {
  return ( time() % AM_SECONDS_PER_HALF_YEAR ) / AM_SECONDS_PER_DAY;
}
int minute_number() {
  return (( time() % AM_SECONDS_PER_DAY ) / AM_SECONDS_PER_MINUTE);
}
string query_moon_string(object env) {
  string str;
  if(mooncycle > 10)
    return "It is night and there is no moon.\n";
  if(calc_actual(env, CLOUD) > 70)
    str = "It is night and the %s is hidden by the clouds.\n";
  else if(env && env->query_water())
    str = "The water is lit up by the eerie light of the %s.\n";
  else
    str = "The land is lit up by the eerie light of the %s.\n";
  return sprintf(str, ({"waxing crescent moon",
                        "waxing quarter moon",
                        "waxing half moon",
                        "waxing three quarter moon",
                        "waxing gibbous moon",
                        "full moon",
                        "waning gibbous moon",
                        "waning three quarter moon",
                        "waning half moon",
                        "waning quarter moon",
                        "waning crescent moon",
                        "no moon",
                        "no moon",
                        "no moon",
                      })[mooncycle]);
}
int query_moon_state() {
  if(mooncycle < 6)
    return mooncycle+1;
  if(mooncycle < 11)
    return (11 - mooncycle);
  return 0;
}
string query_moon_phase() {
  return ({"crescent",
           "quarter",
           "half",
           "three quarter",
           "gibbous",
           "full",
           "gibbous",
           "three quarter",
           "half",
           "quarter",
           "crescent",
           "",
           "",
           "",
         })[mooncycle];
}
int query_stars( object env ) {
    int clouds, stars ;
    clouds = cloud_index(env) ;
    if ( query_day(env) || clouds > 70 ) {
        return 0 ;
    }
    switch( clouds ) {
        case 0:
            stars = 100 ;
            break ;
        case 1..39:
            stars = 80 ;
            break ;
        case 40..59:
            stars = 40 ;
            break ;
        case 60..69:
            stars = 20 ;
            break ;
        default:
            stars = 10 ;
            break ;
    }
    return stars ;
}
string query_star_string( object env ) {
    string str ;
    if ( query_day(env) ) {
        return "There are no stars visible during the day.\n" ;
    }
    switch( query_stars(env) ) {
        case 1..20:
            str = "one or two bright stars" ;
            break ;
        case 21..40:
            str = "a few stars" ;
            break ;
        case 41..60:
            str = "quite a few stars" ;
            break ;
        case 61..80:
            str = "lots of stars" ;
            break ;
        case 81..100:
            str = "countless stars" ;
            break ;
        default:
            str = "no stars" ;
            break ;
    }
    return "Tonight, there are " + str + " visible.\n" ;
}
string query_season() {
  switch(day_number()) {
  case 0..50: return "winter";
  case 51..150: return "spring";
  case 151..250: return "summer";
  case 251..350: return "autumn";
  case 351..400: return "winter";
  }
}
string query_tod() {
  if((minute_number() < _sunrise) || (minute_number() > _sunset))
    return "night";
  switch(minute_number()) {
  case 0..700:
    return "morning";
  case 701..740:
    return "midday";
    break;
  case 741..1080:
    return "afternoon";
    break;
  default:
    return "evening";
  }
}
int query_day(object env) {
  return _day;
}
int query_darkness(object env) {
  int result, cloud, day;
  result = 10;
  day = query_day(env);
  if(day == 10)
    return 100;
  if(mooncycle <= 10) {
    if(mooncycle < 6)
      result += mooncycle * 10;
    else
      result += (5 - (mooncycle % 6)) * 10;
    }
  if((cloud = cloud_index(env)) > 0)
    result -= (cloud_index(env) / 15);
  if(result < 0)
    result = 0;
  if(day > 0)
    result += (100 - result) / (10 - day);
  return result;
}
int query_visibility(object env) {
  int result;
  int temp;
  int rain;
  int rt;
  result = 100;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt ==  WEATHER_SNOW_TYPE) {
     rain += 50;
  } else if (rt == WEATHER_SLEET_TYPE) {
     rain += 20;
  }
  if (rain > 0) {
     if (rain > 100) {
        result = 0;
     } else {
        result = (result * (100 - rain)) / 100;
     }
  }
  return result;
}
int calc_actual(object env, int type) {
  int *clim;
  string climate;
  if(env) {
    climate = env->query_climate();
    clim = (int *)env->query_property("climate");
  }
  if(!climate)
    climate = DEFAULT_CLIMATE;
  if(!clim)
    return _current[climate][type];
  return _current[climate][type] + clim[type];
}
int temperature_index(object env) {
  int temp, tod, j, diurnal;
  string climate;
  temp = calc_actual(env, TEMP);
  if(env)
    climate = env->query_climate();
  if(!climate)
    climate = DEFAULT_CLIMATE;
  tod = 10 - query_day(env);
  if(tod) {
    switch(climate) {
    case "Af":
    case "Am":
    case "Aw":
      diurnal = 10;
      break;
    case "Bw":
    case "Bs":
      diurnal = 15 + (_pattern[climate][0] / 2);
      break;
    case "Cfa":
    case "Cs":
    case "Cfb":
    case "Dw":
    case "Ds":
    case "Df":
      diurnal = 15;
      break;
    case "Et":
    case "Ef":
    case "H":
      diurnal = 20;
      break;
    }
    temp -= (diurnal * tod) / 10;
  }
  j = sqrt(_current[climate][CLOUD]);
  if(j < 0)
    j = 0;
  if(temp < 10 && tod == 10)
    temp += j;
  else if(temp > 30 && !tod)
    temp -= j;
  temp -= sqrt(_current[climate][WINDSP]);
  return temp;
}
int cloud_index(object env) {
  int cloud;
  cloud = calc_actual(env, CLOUD);
  if(cloud < 0)
    cloud = 0;
  return cloud;
}
int rain_index(object env) {
  int rain;
  rain = calc_actual(env, CLOUD) - (calc_actual(env, TEMP) / 2) - 100;
  return (rain > 0)? rain : 0;
}
string temp_string(int temp) {
  switch(temp) {
    case 51..1000: return "incredibly, unbelievably hot"; break;
    case 46..50: return "amazingly hot"; break;
    case 41..45: return "damn hot"; break;
    case 36..40: return "very hot"; break;
    case 31..35: return "hot"; break;
    case 26..30: return "reasonably hot"; break;
    case 23..25: return "very warm"; break;
    case 20..22: return "warm"; break;
    case 16..19: return "pleasantly warm"; break;
    case 13..15: return "cool"; break;
    case 10..12: return "slightly chilly"; break;
    case 7..9: return "chilly"; break;
    case 4..6: return "very chilly"; break;
    case 1..3: return "cold"; break;
    case -3..0: return "very cold"; break;
    case -10..-4: return "freezing cold"; break;
    case -20..-11: return "damn cold"; break;
    case -30..-21: return "dangerously cold"; break;
    case -50..-31: return "incredibly, unbelievably cold"; break;
  }
}
private string precipitation_string(int rain, int rt, int wind) {
  switch(rain) {
  case -1000..20:
    return "lightly";
    break;
  case 21..40:
    if(wind < 20) {
      return "steadily";
    } else {
      return "hard";
    }
    break;
  case 41..60:
    return "heavily";
    break;
  case 61..500:
    if(rt == WEATHER_RAIN_TYPE) {
      return "torrentially";
    } else {
      return "very heavily";
    }
    break;
  }
}
string rain_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_RAIN_TYPE) {
    return "There is no rain";
  }
  return "It is raining " + precipitation_string(rain, rt, wind);
}
string snow_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SNOW_TYPE) {
    return "There is no snow";
  }
  return "It is snowing " + precipitation_string(rain, rt, wind);
}
string sleet_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SLEET_TYPE) {
    return "There is no sleet";
  }
  return "It is sleeting " + precipitation_string(rain, rt, wind);
}
string cloud_string(object env) {
  int cloud;
  string str;
  cloud = cloud_index(env);
  switch(cloud) {
    case -1000..5:
       str = "a beautifully clear sky";
       break;
    case 6..10:
       str = "a few high level cirrus clouds";
       break;
    case 11..25:
       str = "scattered puffy clouds";
       break;
    case 26..40:
       str = "some puffy clouds";
       break;
    case 41..60:
       str = "many puffy clouds";
       break;
    case 61..80:
       str = "medium cloud cover";
       break;
    case 81..110:
       str = "dense cloud cover";
       break;
    case 111..130:
       str = "packed cloud cover";
       break;
    case 131..160:
       str = "thick black clouds";
       break;
    case 161..1000:
       str = "thick heavy storm clouds";
       break;
  }
  return str;
}
varargs string weather_string(object env, string obscured) {
  int temp, cloud, wind, rain, rt;
  int *warray;
  string str, tstr;
   if ( !env )
     return 0;
  temp = temperature_index(env);
  cloud = cloud_index(env);
  wind = calc_actual(env, WINDSP);
  rain = rain_index(env);
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temp, cloud, wind, rain))) {
    temp = warray[0];
    cloud = warray[1];
    wind = warray[2];
    rain = warray[3];
  }
  rt = query_rain_type(temp, rain);
  str = "It is ";
  tstr = temp_string(temp);
  switch(tstr[0]) {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
    str += "an ";
    break;
  default:
    str += "a ";
  }
  str += tstr + " ";
  switch((time() % (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 51..150:
    str += "spring prime";
    break;
  case 151..250:
    str += "summer prime";
    break;
  case 251..350:
    str += "autumn prime";
    break;
  case 351..450:
    str += "spindlewinter";
    break;
  case 451..550:
    str += "secundus spring";
    break;
  case 551..650:
    str += "secundus summer";
    break;
  case 651..750:
    str += "secundus autumn";
    break;
  default:
    str += "backspindlewinter";
  }
  str += "'s "+ query_tod() +" with ";
  switch(wind) {
    case -1000..5: str += "almost no wind"; break;
    case 6..10: str += "a gentle breeze"; break;
    case 11..15: str += "a steady breeze"; break;
    case 16..20: str += "a strong breeze"; break;
    case 21..30: str += "a steady wind"; break;
    case 31..40: str += "gusty winds"; break;
    case 41..50: str += "strong winds"; break;
    case 51..60: str += "gale-force winds"; break;
    case 61..1000: str += "storm-force winds"; break;
    default: str += "no wind at all"; break;
  }
  if (!obscured) {
    if(rain)
      str += ", ";
    else
      str += " and ";
    switch(cloud) {
      case -1000..5: str += "a beautifully clear sky"; break;
      case 6..10: str += "a few high level cirrus clouds"; break;
      case 11..25: str += "scattered puffy clouds"; break;
      case 26..40: str += "some puffy clouds"; break;
      case 41..60: str += "many puffy clouds"; break;
      case 61..80: str += "medium cloud cover"; break;
      case 81..110: str += "dense cloud cover"; break;
      case 111..130: str += "packed cloud cover"; break;
      case 131..160: str += "thick black clouds"; break;
      case 161..1000: str += "thick heavy storm clouds"; break;
    }
  }
  if(rain) {
    str += " and ";
    switch(rain) {
      case -1000..20: str += "light"; break;
      case 21..40:
        if(wind < 20)
          str += "steady";
        else
          str += "driving";
      break;
      case 41..60: str += "heavy"; break;
      case 61..500:
        if(rt == WEATHER_RAIN_TYPE)
          str += "torrential";
        else
          str += "very heavy";
      break;
    }
    str += " ";
    str += ({"", "snow", "sleet", "rain"})[rt];
  }
  if (obscured) {
    str += ".  " + obscured;
  }
  if((rain > 20) && (wind > 30)) {
    if (obscured)
      str += ".\nPeals of thunder echo overhead";
    else
      str += ".\nPeals of thunder and streaks of lightning rend the sky";
  }
  return str;
}
int next_update() {
  return _lastupdate + UPDATE_SPEED;
}
void dest_me() {
  unguarded((: save_object, FILE_NAME :));
}
int query_rain_type(int temp, int rain) {
  int type;
  if (rain > 0)
    switch(temp) {
    case -1000..-2:
      type = WEATHER_SNOW_TYPE;
      break;
    case -1..3:
      type = WEATHER_SLEET_TYPE;
      break;
    case 4..1000:
      type = WEATHER_RAIN_TYPE;
      break;
    }
  else
    type = WEATHER_NO_RAIN_TYPE;
  return type;
}
int query_snowing(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return (query_rain_type(warray[0], warray[3]) == WEATHER_SNOW_TYPE)? 1 : 0;
  return (query_rain_type(temperature_index(env),
                          rain_index(env)) == WEATHER_SNOW_TYPE) ? 1 : 0;
}
int query_raining(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
  {
    return (query_rain_type(warray[0], warray[3]) > WEATHER_SNOW_TYPE) ? 1 : 0;
  }
  return (query_rain_type(temperature_index(env),
                          rain_index(env)) > WEATHER_SNOW_TYPE) ? 1 : 0;
}
int query_temperature(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[0];
  return temperature_index(env);
}
int query_cloud(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[1];
  return cloud_index(env);
}
int query_windsp(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[2];
  return calc_actual(env, WINDSP);
}
int calc_variance(string climate, int type, int seasonal) {
  int diff, ret;
  diff = seasonal - _pattern[climate][type];
  if(diff < 0)
    ret = - random(diff * 2);
  else
    ret = random(diff * 2);
  if(random(2))
    ret += random(_variance[type]);
  else
    ret -= random(_variance[type]);
  return ret;
}
void set_day() {
  int min;
  _toy = (day_number() < (DIY / 2)) ? day_number() :
  (DIY / 2) - (day_number() % (DIY / 2));
  min = minute_number();
  _sunrise = 6 * AM_MINUTES_PER_HOUR;
  _sunset = 20 * AM_MINUTES_PER_HOUR;
  _sunrise += (100 - _toy);
  _sunset -= (100 - _toy);
  if((min <= _sunrise) || (min >= _sunset))
    _day = 0;
  else {
    if((min > _sunrise) && (min < _sunrise + 30))
      _day = (min-_sunrise) / 3;
    else if((min < _sunset) && (min > _sunset - 30))
      _day = (_sunset-min) / 3;
    else
      _day = 10;
  }
}
void migrate(string climate, int type) {
  int diff;
  diff = _pattern[climate][type] - _current[climate][type];
  if(diff > (_variance[type] / 2))
    diff = _variance[type] / 2;
  if(diff < 0)
    _current[climate][type] -= random(random(-diff));
  else
    _current[climate][type] += random(random(diff));
}
int check_umbrella(object ob) {
  if ( ob )
    return (int)ob->query_property( "umbrella" );
  return 0;
}
void do_inform(object who, int old_temp, int old_cloud, int old_rain,
               int old_day) {
  string str, where;
  int new_temp, new_cloud, new_wind, new_rain;
  int old_rain_type, new_rain_type;
  int *warray;
  new_temp = temperature_index(environment(who));
  new_rain = rain_index(environment(who));
  new_wind = calc_actual(environment(who), WINDSP);
  new_cloud = cloud_index(environment(who));
  if(function_exists("room_weather", environment(who)) &&
     !catch(warray = (int *)environment(who)->room_weather(new_temp, new_cloud,
                                                   new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }
  if(who->query_name() == "ceres")
    tell_object(who, sprintf("%s: ot %d, or: %d, oc: %d, "
                             "nt %d, nr: %d, nc: %d, nw: %d",
                             who->query_name(),
                             old_temp, old_rain, old_cloud, new_temp,
                             new_rain, new_cloud, new_wind));
  old_rain_type = query_rain_type(old_temp, old_rain);
  new_rain_type = query_rain_type(new_temp, new_rain);
  str = "";
  if(_day != old_day) {
    where = sun_direction( 1 );
    if((old_day == 10)  && (_day < 10))
      str += "The sun starts to set slowly on the "+where+" horizon.\n";
    else if((old_day > 0) && (_day == 0))
      str += "The sun disappears from view below the "+where+" horizon.\n";
    else if((old_day > _day) && (_day < 9) && (_day > 0))
      str += "The sun sinks further below the "+where+" horizon.\n";
    where = sun_direction( 0 );
    if((_day > 0) && (old_day == 0))
      str += "The "+where+" sky starts to lighten as the sun peeks over the "+
        "horizon.\n";
    else if((_day == 10) && (old_day < 10))
      str += "The sun rises above the "+where+" horizon and greets you "+
        "for a new day.\n";
    else if((_day > old_day) && (_day < 9) && (_day > 0))
      str += "The sun rises further above the "+where+" horizon lightening "+
        "the sky as morning arrives.\n";
  }
  if(_day && (old_cloud != new_cloud)) {
    if((old_cloud < 60) && (new_cloud > 20) && (!(new_cloud % 2)))
      str += "The " + query_tod()+ " sun disappears behind a cloud.\n";
    else if((old_cloud > 20) && (new_cloud < 60) && (new_cloud % 2))
      str += "The " + query_tod() + " sun peeks out from behind a cloud.\n";
  }
  if(old_rain_type != new_rain_type) {
    str += ({"", "It has stopped snowing", "It has stopped sleeting",
             "It has stopped raining"})[old_rain_type];
    if(old_rain_type && new_rain_type)
      str += " and started ";
    else if(new_rain_type)
      str += "It has started ";
    str += ({"", "snowing", "sleeting", "raining"})[new_rain_type];
    str += ".\n";
  } else if(new_rain_type > 0)
    str += "The "+({"", "snow", "sleet", "rain"})[new_rain_type]+
      " continues to fall.\n";
  if(new_rain_type)
    if((!sizeof(filter_array(who->query_holding(), "check_umbrella",
                            this_object())) &&
       !sizeof(filter_array(who->query_wearing(), "check_umbrella",
                          this_object()))) || !random(50))
    {
      who->add_effect("/std/effects/other/wetness",
                      ((new_rain * new_rain_type) / 2) * (UPDATE_SPEED/60));
    }
  if(str != "")
    tell_object(who, who->colour_event("weather", "%^ORANGE%^")+str+
                "%^RESET%^");
}
string sun_direction(int which) {
  switch(((time()+(AM_SECONDS_PER_HALF_YEAR * which)) %
          (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 0..174:
    return "widdershins";
  case 175..225:
    return "hubwards";
  case 226..574:
    return "turnwise";
  case 575..625:
    return "rimward";
  default:
    return "widdershins";
  }
}
void do_room_inform(object what, int old_temp, int old_cloud, int old_rain,
        int old_day, int notifications) {
  int new_cloud, new_rain, new_wind, new_temp;
  int *warray;
  int has_changed = 0;
  new_temp = temperature_index(what);
  new_cloud = cloud_index(what);
  new_wind = calc_actual(what, WINDSP);
  new_rain = rain_index(what);
  if(function_exists("room_weather", what) &&
     !catch(warray = (int *)what->room_weather(new_temp, new_cloud,
                                       new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }
  if(_day != old_day && (notifications & NOTIFY_DAY))
    has_changed += NOTIFY_DAY;
  if(old_temp != new_temp && (notifications & NOTIFY_TEMPERATURE))
    has_changed += NOTIFY_TEMPERATURE;
  if(old_cloud != new_cloud && (notifications & NOTIFY_CLOUD))
    has_changed += NOTIFY_CLOUD;
  if(old_rain != new_rain && (notifications & NOTIFY_RAIN))
    has_changed += NOTIFY_RAIN;
  if(has_changed) {
    call_out( "notify_room", 1, what, has_changed,
      _day, new_temp, new_cloud, new_rain );
  }
}
void notify_room( object what, int has_changed,
  int day, int temp, int cloud, int rain)
{
  if(what)
    what->event_weather( has_changed, day, temp, cloud, rain);
}
int query_sunrise(int doy) {
  int toy;
  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (6 * AM_MINUTES_PER_HOUR) + (100 - toy);
}
int query_sunset(int doy) {
  int toy;
  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (20 * AM_MINUTES_PER_HOUR) - (100 - toy);
}
void update_pattern() {
  int toy, temp, wind, cloud, tvar, wvar, cvar;
  string climate;
  call_out("update_pattern", CYCLE_SPEED);
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));
  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af":
      temp = 30 + (toy / 40);
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am":
      temp = 30 + (toy / 20);
      cloud = -25 + sqrt(toy) * 10;
      wind = random(10);
      break;
    case "Aw":
      temp = 20 + (toy / 10);
      cloud = toy - 50;
      wind = random(10);
      break;
    case "Bw":
      temp = 30 + (toy / 20);
      cloud = (100 - toy/2) - 50;
      wind = random(10);
      break;
    case "Bs":
      temp = 25 + (toy / 20);
      cloud = ((200 - toy) / 2) - 12;
      wind = random(10);
      break;
    case "Cfa":
      temp = (toy / 8) + 15;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Cs":
      temp = (toy / 12) + 10;
      cloud = ((225 - toy) / 2) - 50;
      wind = 10 - (toy / 8);
      break;
    case "Cfb":
      temp = (toy / 6) - 5;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Dw":
      temp = (toy / 5) - 10;
      cloud = toy / 2;
      wind = 15 - (toy / 8);
      break;
    case "Ds":
      temp = (toy / 5) - 10;
      cloud = (200 - toy) / 2;
      wind = 15 - (toy / 8);
      break;
    case "Df":
      temp = (toy / 5) - 10;
      cloud = ((200 - toy) / 4) + 50;
      wind = 15 - (toy / 8);
      break;
    case "Et":
      temp = (toy / 20) - 10;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "Ef":
      temp = (toy / 10) - 30;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "H":
      temp = (toy / 10) - 10;
      cloud = ((225 - toy) / 2);
      wind = 35 - (toy / 8);
      break;
    }
    tvar = calc_variance(climate, TEMP, temp);
    cvar = calc_variance(climate, CLOUD, cloud);
    wvar = calc_variance(climate, WINDSP, wind);
    _pattern[climate] =  ({ temp + tvar, cloud + cvar, wind + wvar });
  }
  unguarded((: save_object, FILE_NAME :));
}
void update_weather() {
  int *warray, notifications;
  mapping list, roomlist, newrooms;
  object user, room;
  string climate;
  _lastupdate = time();
  call_out("update_weather", UPDATE_SPEED);
  list = ([ ]);
  roomlist = ([ ]);
  foreach(user in filter(users(),
                         (: $1 && environment($1) &&
                          environment($1)->query_property("location") ==
                          "outside" :))) {
    if(function_exists("room_weather", environment(user)) &&
       !catch(warray = (int *)environment(user)->room_weather(
                                 (int)temperature_index(environment(user)),
                                 (int)cloud_index(environment(user)),
                                 (int)calc_actual(environment(user), WINDSP),
                                 (int)rain_index(environment(user))))) {
      list[user] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      list[user] = ({ (int)temperature_index(environment(user)),
                        (int)cloud_index(environment(user)),
                        (int)rain_index(environment(user)),
                        _day});
    }
  }
  newrooms = ([ ]);
  foreach (room, notifications in _rooms)  {
    if (room)
      newrooms[room] = notifications;
  }
  _rooms = copy(newrooms);
  foreach(room, notifications in _rooms) {
    if(function_exists("room_weather", room) &&
       !catch(warray = (int *)room->room_weather((int)temperature_index(room),
                                                 (int)cloud_index(room),
                                               (int)calc_actual(room, WINDSP),
                                                 (int)rain_index(room) ))) {
      roomlist[room] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      roomlist[room] = ({ (int)temperature_index(room),
                            (int)cloud_index(room),
                            (int)rain_index(room),
                            _day });
    }
  }
  if((moonupdate + (AM_SECONDS_PER_DAY * 2)) < time()) {
    mooncycle++;
    mooncycle %= 14;
    moonupdate = time();
  }
  foreach(climate in CLIMATES) {
    migrate(climate, TEMP);
    migrate(climate, CLOUD);
    migrate(climate, WINDSP);
  }
  set_day();
  unguarded((: save_object, FILE_NAME :));
  foreach(user, warray in list) {
    do_inform(user, warray[0], warray[1], warray[2], warray[3]);
  }
  foreach(room, notifications in _rooms) {
      do_room_inform(room, roomlist[room][0], roomlist[room][1],
                     roomlist[room][2], roomlist[room][3], notifications);
      map_delete(_rooms, room);
  }
}
void print_stats(object here) {
  string climate, *weather;
  if(here)
    climate = here->query_climate();
  weather = ({ temperature_index(here), cloud_index(here),
                 calc_actual(here, WINDSP) });
  printf("Climate: %s toy: %d tod: %s [%d]\n"
         "here: %O\ncurrent: %O\npattern: %O\nvariance: %O\n",
         climate, _toy, query_tod(), 10 - query_day(here), weather,
         _current[climate], _pattern[climate], _variance);
  printf("Sunrise at: %d:%02d, sunset at: %d:%02d\n",
         _sunrise/60, _sunrise%60, _sunset/60, _sunset%60);
}
int *query_mooncycle() {
  return ({ mooncycle, 0});
}
void set_variance(int temp, int cloud, int wind) {
  _variance = ({temp, cloud, wind});
  unguarded((: save_object, FILE_NAME :));
}
void reset_weather() {
  int toy, temp, wind, cloud;
  string climate;
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));
  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af":
      temp = 25 + (toy / 40);
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am":
      temp = 20 + (toy / 20);
      cloud = -25 + sqrt(toy) * 10;
      wind = random(10);
      break;
    case "Aw":
      temp = 20 + (toy / 20);
      cloud = toy - 50;
      wind = random(10);
      break;
    case "Bw":
      temp = 30 + (toy / 20);
      cloud = (100 - toy/2) - 50;
      wind = random(10);
      break;
    case "Bs":
      temp = 25 + (toy / 20);
      cloud = ((200 - toy) / 2) - 12;
      wind = random(10);
      break;
    case "Cfa":
      temp = (toy / 8) + 15;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Cs":
      temp = (toy / 12) + 10;
      cloud = ((225 - toy) / 2) - 50;
      wind = 10 - (toy / 8);
      break;
    case "Cfb":
      temp = (toy / 6) - 5;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Dw":
      temp = (toy / 5) - 10;
      cloud = toy / 2;
      wind = 15 - (toy / 8);
      break;
    case "Ds":
      temp = (toy / 5) - 10;
      cloud = (200 - toy) / 2;
      wind = 15 - (toy / 8);
      break;
    case "Df":
      temp = (toy / 5) - 10;
      cloud = ((200 - toy) / 4) + 50;
      wind = 15 - (toy / 8);
      break;
    case "Et":
      temp = (toy / 20) - 10;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "Ef":
      temp = (toy / 10) - 30;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "H":
      temp = (toy / 10) - 10;
      cloud = ((225 - toy) / 2);
      wind = 35 - (toy / 8);
      break;
    }
    _pattern[climate] =  ({ temp, cloud, wind });
    _current[climate] = ({ temp, cloud, wind });
  }
  unguarded((: save_object, FILE_NAME :));
}
mapping query_dynamic_auto_load() {
   return ([ "rooms" : _rooms ]);
}
void init_dynamic_arg(mapping map, object) {
   _rooms = map["rooms"];
   if (!_rooms) {
      _rooms = ([ ]);
   }
}

==================================================
FILE: /lib/obj/handlers/world_map.c
==================================================

#include <terrain_map.h>
class region {
   mixed* terrains;
   string* features;
   int last_touched;
}
#define SAVE_DIR "/save/world_map/"
#define BOUNDARY TERRAIN_MAP_WORLD_BOUNDARY
#define REGION_SIZE TERRAIN_MAP_WORLD_REGION_SIZE
#define REGION_BOUNDARY TERRAIN_MAP_WORLD_REGION_BOUNDARY
#define OFFSET TERRAIN_MAP_WORLD_OFFSET
#define REGION_WIDTH TERRAIN_MAP_WORLD_REGION_WIDTH
void load_me();
private void generate_main_templates();
private void generate_blocking_templates();
private nosave mixed* _regions;
private nosave mixed* _templates;
private nosave mixed* _blocking_templates;
void create() {
   _regions = allocate(REGION_WIDTH, (: allocate(REGION_WIDTH) :));
   seteuid(getuid());
   generate_main_templates();
   generate_blocking_templates();
}
private void generate_main_templates() {
   int size;
   mixed* last;
   int x;
   int y;
   int u;
   int v;
   int e;
   int i;
   _templates = allocate(12);
   last = ({ ({ 1 }) });
   for (size = 0; size < sizeof(_templates); size++) {
      for (i = 0; i < sizeof(last); i++) {
         last[i] = ({ 0 }) + last[i] + ({ 0 });
      }
      _templates[size] = ({ allocate((size + 1) * 2 + 1) }) + last +
                         ({ allocate((size + 1) * 2 + 1) });
      x = 0;
      y = size + 1;
      u = 1;
      v = 2 * (size + 1) - 1;
      e = 0;
      while (x <= y) {
         _templates[size][size + 1 + x][size + 1 + y] = 1;
         _templates[size][size + 1 + x][size + 1 - y] = 1;
         _templates[size][size + 1 - x][size + 1 + y] = 1;
         _templates[size][size + 1 - x][size + 1 - y] = 1;
         _templates[size][size + 1 + y][size + 1 + x] = 1;
         _templates[size][size + 1 + y][size + 1 - x] = 1;
         _templates[size][size + 1 - y][size + 1 + x] = 1;
         _templates[size][size + 1 - y][size + 1 - x] = 1;
         if (size > 0) {
            _templates[size][size + 1 + x - 1][size + 1 + y] = 1;
            _templates[size][size + 1 + x - 1][size + 1 - y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 + y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 - y] = 1;
            _templates[size][size + 1 + y - 1][size + 1 + x] = 1;
            _templates[size][size + 1 + y - 1][size + 1 - x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 + x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 - x] = 1;
         }
         x++;
         e += u;
         u += 2;
         if (v < 2 * e) {
            y--;
            e -= v;
            v -= 2;
         }
         if (x > y) {
            break;
         }
      }
      last = copy(_templates[size]);
   }
}
mixed* generate_blocking(int x, int y, string* start,
                          string* straight, string* diagonal) {
   int i;
   int dx;
   int ex;
   int dy;
   int balance;
   int sx;
   int sy;
   int blocked;
   int blocked_straight;
   int blocked_diagonal;
   int first_block;
   first_block = -1;
   for (i = 0; i <= sizeof(start); i++) {
      sx = 0;
      sy = 0;
      ex = sizeof(start);
      dx = sizeof(start);
      dy = i;
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      blocked_straight = blocked_diagonal = blocked = 0;
      while (sx != ex) {
         if (blocked) {
            if (first_block == -1) {
               first_block = i;
            }
            start[sy] = start[sy][0..sx-1] + "*" + start[sy][sx+1..];
         } else {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
         }
         if (blocked_straight) {
            straight[sy] = straight[sy][0..sx-1] + "*" + straight[sy][sx+1..];
         } else {
            straight[sy] = straight[sy][0..sx-1] + " " + straight[sy][sx+1..];
         }
         if (blocked_diagonal) {
            diagonal[sy] = diagonal[sy][0..sx-1] + "*" + diagonal[sy][sx+1..];
         } else {
            diagonal[sy] = diagonal[sy][0..sx-1] + " " + diagonal[sy][sx+1..];
         }
         if (sx == x && sy == y) {
            blocked_diagonal = blocked_straight = blocked = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "@" + diagonal[sy][sx+1..];
            start[sy] = start[sy][0..sx-1] + "@" + start[sy][sx+1..];
            straight[sy] = straight[sy][0..sx-1] + "@" + straight[sy][sx+1..];
         }
         if (sx == x && sy == y + 1) {
            blocked_straight = 1;
            straight[sy] = straight[sy][0..sx-1] + "|" + straight[sy][sx+1..];
         }
         if (sx == x + 1 && sy == y + 1) {
            blocked_diagonal = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "\\" + diagonal[sy][sx+1..];
         }
         if (balance >= 0) {
            sy++;
            balance -= dx;
         }
         balance += dy;
         sx++;
      }
   }
   if (first_block >= (sizeof(start) / 2)) {
      for (i = sizeof(start); i >= 6; i--) {
         sx = 0;
         sy = 0;
         ex = sizeof(start);
         dx = sizeof(start);
         dy = i;
         dy <<= 1;
         balance = dy - dx;
         dx <<= 1;
         blocked = 0;
         while (sx != ex) {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
            if (sx == x && sy == y) {
               break;
            }
            if (balance >= 0) {
               sy++;
               balance -= dx;
            }
            balance += dy;
            sx++;
         }
      }
   }
   return ({ start, straight, diagonal });
}
private void generate_blocking_templates() {
   int x;
   int y;
   int size;
   mixed* basic;
   string* start;
   string line;
   basic = _templates[<1];
   size = sizeof(_templates);
   line = "";
   for (x = 0; x < size + 1; x++) {
      line += " ";
   }
   start = allocate(size + 1, line);
   _blocking_templates = allocate(size + 1, ({ }));
   for (x = 0; x < size + 1; x++) {
      _blocking_templates[x] = allocate(size + 1);
   }
   for (x = 0; x < size + 1; x++) {
      for (y = x; y < size + 1; y++) {
         if (basic[x + size][y + size] && (x != 0 || y != 0)) {
            _blocking_templates[x][y] = generate_blocking(y, x, copy(start), copy(start), copy(start));
         }
      }
   }
}
string *query_blocking_template(int x, int y, int type) {
   if (arrayp(_blocking_templates[x][y])) {
      return copy(_blocking_templates[x][y][type]);
   }
   return 0;
}
mixed* query_map_template(int size) {
   return copy(_templates[size - 1]);
}
void load_region(int x, int y) {
   class region region;
   string fname;
   if (_regions[x][y]) {
      _regions[x][y]->last_touched = time();
      return ;
   }
   fname = SAVE_DIR + "region_" + x + "_" + y;
   if (unguarded((: file_size($(fname)) :)) > 0) {
      region = unguarded( (: restore_variable(read_file($(fname), 1)) :));
   } else {
      region = new(class region,
                   terrains : allocate(REGION_SIZE, (: allocate(REGION_SIZE) :)),
                   features : ({ }));
   }
   _regions[x][y] = region;
   _regions[x][y]->last_touched = time();
}
void save_region(int x, int y) {
   string fname;
   class region region;
   if (_regions[x][y]) {
      region = _regions[x][y];
      fname = SAVE_DIR + "region_" + x + "_" + y;
      unguarded( (: write_file($(fname), save_variable($(region)), 1) :));
   }
}
int add_terrain(string path, int x1, int y1, int x2, int y2) {
   int tmp;
   int region_x;
   int region_y;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   if (x2 - x1 != BOUNDARY ||
       y2 - y1 != BOUNDARY) {
      debug_printf("Incorrect terrain size (%d x %d): %s\n",
                  x2 - x1, y2 - y1, path);
      return 0;
   }
   if (x1 % BOUNDARY ||
       y1 % BOUNDARY) {
      debug_printf("Incorrect boundary (%d - %d): %s\n",
                  x1 % BOUNDARY, y1 % BOUNDARY, path);
      return 0;
   }
   x1 = ((x1 + OFFSET) / BOUNDARY);
   y1 = ((y1 + OFFSET) / BOUNDARY);
   region_x = x1 / REGION_SIZE;
   region_y = y1 / REGION_SIZE;
   load_region(region_x, region_y);
   x2 = x1 % REGION_SIZE;
   y2 = y1 % REGION_SIZE;
   _regions[region_x][region_y]->terrains[x2][y2] = path;
   save_region(region_x, region_y);
   debug_printf("Added terrain (%d {%d}, %d {%d}) [%d,  %d]: %s\n",
                 x1, x2, y1, y2, region_x, region_y, path);
   return 1;
}
string find_terrain_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_SIZE;
   region_y = y / REGION_SIZE;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->terrains[x % REGION_SIZE][y % REGION_SIZE];
}
string find_room_at(int x, int y) {
   string path;
   path = find_terrain_at(x, y);
   if (path) {
      return path->find_room_at_real_coord(x, y);
   }
   return 0;
}
void add_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         if (feature->is_inside_region(
                                (x * REGION_WIDTH) * BOUNDARY - OFFSET,
                                (y * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((x + 1) * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((y + 1) * REGION_WIDTH) * BOUNDARY - OFFSET)) {
            load_region(x, y);
            _regions[x][y]->features |= ({ feature });
            save_region(x, y);
            debug_printf("Added feature to region %d, %d\n", x, y);
         }
      }
   }
}
void remove_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         load_region(x, y);
         if (member_array(feature, _regions[x][y]->features) != -1) {
            _regions[x][y]->features -= ({ feature });
            save_region(x, y);
         }
      }
   }
}
string* query_features_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_WIDTH;
   region_y = y / REGION_WIDTH;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->features;
}
string* query_features_in_region(int x1_orig, int y1_orig, int x2_orig, int y2_orig) {
   int region_x;
   int region_y;
   int x1;
   int y1;
   int x2;
   int y2;
   int tmp;
   string* features;
   string feat;
   x1 = ((x1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y1 = ((y1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   x2 = ((x2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y2 = ((y2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   features = ({ });
   if (x1 < 0) {
      x1 = 0;
   }
   if (y1 < 0) {
      y1 = 0;
   }
   if (x2 >= REGION_WIDTH) {
      x2 = REGION_WIDTH - 1;
   }
   if (y2 >= REGION_WIDTH) {
      y2 = REGION_WIDTH - 1;
   }
   for (region_x = x1; region_x <= x2; region_x++) {
      for (region_y = y1; region_y <= y2; region_y++) {
         load_region(region_x, region_y);
         foreach (feat in _regions[region_x][region_y]->features) {
            if (feat->is_inside_region(x1_orig, y1_orig, x2_orig, y2_orig)) {
               features |= ({ feat });
            }
         }
      }
   }
   return features;
}

==================================================
FILE: /lib/obj/handlers/inherit/case_control.c
==================================================

#define NOMIC_SYSTEM_NO_CLASSES
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
private mapping _open_cases;
private mapping _recently_closed_cases;
private mapping _closed_cases;
private int _next_case_id;
private int _next_note_id;
void save_me();
void send_council_inform(string area, int only_magistrates,
                         string mess);
void create() {
   _open_cases = ([ ]);
   _closed_cases = ([ ]);
   _recently_closed_cases = ([ ]);
   _next_case_id = 1;
   _next_note_id = 1;
}
void create_area(string area) {
   if (_open_cases[area]) {
      return ;
   }
   _open_cases[area] = ({ });
   _closed_cases[area] = ({ });
   _recently_closed_cases[area] = ({ });
}
int* query_open_cases(string area) {
   return _open_cases[area];
}
int* query_closed_cases(string area) {
   return _closed_cases[area];
}
int* query_recently_closed_cases(string area) {
   return _recently_closed_cases[area];
}
string query_case_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("cases/%02d/%d_case", id % 20, id);
}
int query_next_case_id() {
   int next;
   do {
      next = _next_case_id++;
   } while (sizeof(stat(query_case_file_name(next))));
   return next;
}
private void save_case(class nomic_case stuff) {
   string fname;
   string tmp;
   fname = query_case_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp), 1) :));
}
string query_note_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("notes/%02d/%d_note", id % 20, id);
}
int query_next_note_id() {
   int next;
   do {
      next = _next_note_id++;
   } while (sizeof(stat(query_note_file_name(next))));
   return next;
}
private void save_note(class nomic_case_note stuff) {
   string fname;
   string tmp;
   fname = query_note_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp) ) :));
}
private int create_case(string opener, string short, string* people) {
   class nomic_case new_case;
   new_case = new(class nomic_case);
   new_case->id = query_next_case_id();
   new_case->opener = opener;
   new_case->short = short;
   new_case->people = people;
   new_case->notes = ({ });
   new_case->events = ({ });
   new_case->time_opened = time();
   save_case(new_case);
   return new_case->id;
}
private int create_note(string person, string text) {
   class nomic_case_note new_note;
   new_note = new(class nomic_case_note);
   new_note->id = query_next_note_id();
   new_note->person = person;
   new_note->text = text;
   new_note->time_created = time();
   save_note(new_note);
   return new_note->id;
}
private class nomic_case_event create_event(int type, string person,
                                            string mess, mixed data) {
   class nomic_case_event event;
   event = new(class nomic_case_event);
   event->type = type;
   event->mess = mess;
   event->person = person;
   event->event_time = time();
   event->data = data;
   return event;
}
string query_event_name(int type) {
   switch (type) {
   case NOMIC_CASE_EVENT_CLOSE :
      return "closed case";
   case NOMIC_CASE_EVENT_APPEAL :
      return "appealed case";
   case NOMIC_CASE_EVENT_ADD_PERSON :
      return "add person";
   case NOMIC_CASE_EVENT_REMOVE_PERSON :
      return "remove person";
   default :
      return "unknown";
   }
}
class nomic_case query_open_case(string area, int id) {
   string fname;
   string tmp;
   if (!_open_cases[area]) {
      return 0;
   }
   if (member_array(id, _open_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_recently_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_recently_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _recently_closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case_note query_note(int note_num) {
   string fname;
   string tmp;
   fname = query_note_file_name(note_num);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
int add_new_case(string area, string opener, string short, string* people) {
   int case_id;
   if (!_open_cases[area]) {
      return 0;
   }
   case_id = create_case(opener, short, people);
   _open_cases[area] += ({ case_id });
   save_me();
   send_council_inform(area, 1, opener + " opened a case with " +
                      query_multiple_short(people));
   return case_id;
}
int close_case(string area, int id, string closer, string result,
               mixed data) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(result)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_CLOSE, closer, result, data);
   the_case->events += ({ event });
   save_case(the_case);
   _open_cases[area] -= ({ the_case->id });
   _recently_closed_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, closer + " closed a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int appeal_case(string area, int id, string appealer, string reason) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_recently_closed_case(area, id);
   if (!the_case || !stringp(reason)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_APPEAL, appealer, reason, 0);
   the_case->events += ({ event });
   save_case(the_case);
   _recently_closed_cases[area] -= ({ the_case->id });
   _open_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, appealer + " appeals a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int add_note_to_case(string area, int id, string person, string text) {
   class nomic_case the_case;
   int note_id;
   the_case = query_open_case(area, id);
   if (!the_case) {
      return 0;
   }
   note_id = create_note(person, text);
   the_case->notes += ({ note_id });
   save_case(the_case);
   save_me();
   return 1;
}
int add_person_to_case(string area, int id, string adder,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) != -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_ADD_PERSON, adder, text, 0);
   the_case->events += ({ event });
   the_case->people += ({ person });
   save_case(the_case);
   return 1;
}
int remove_person_from_case(string area, int id, string remover,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) == -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_REMOVE_PERSON, remover, text, 0);
   the_case->events += ({ event });
   the_case->people -= ({ person });
   save_case(the_case);
   return 1;
}
void update_recently_closed_cases() {
   string area;
   int* stuff;
   int id;
   class nomic_case the_case;
   class nomic_case_event event;
   int last_close;
   foreach (area, stuff in _recently_closed_cases) {
      foreach (id in stuff) {
         the_case = query_recently_closed_case(area, id);
         last_close = 0;
         foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
               last_close = event->event_time;
            }
         }
         if (last_close < time() - NOMIC_CASE_APPEAL_TIME) {
            _closed_cases[area] += ({ id });
            _recently_closed_cases[area] -= ({ id });
         }
      }
   }
}

==================================================
FILE: /lib/obj/handlers/inherit/citizen_elections.c
==================================================

inherit "/obj/handlers/inherit/citizens";
#include <player_handler.h>
#include <player.h>
#include <board.h>
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
#define CITIZEN_ELECTION_PHASE_NONE       0
#define CITIZEN_ELECTION_PHASE_NOMINATION 1
#define CITIZEN_ELECTION_PHASE_ELECTION   2
#define CITIZEN_ELECTION_PHASE_GRACE      3
#define CITIZEN_ELECTION_PHASE_DISABLED 4
#define CITIZEN_ELECTION_TIME   (20 * (7 * 24 * 60 * 60))
#define CITIZEN_ELECTION_PHASE_TIME      (10 * 24 * 60 * 60)
#define CITIZEN_PHASE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_GRACE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_ELECTION_DISABLED_TIME (14 * 24 * 60 * 60)
class election_data {
   int last_election;
   int phase;
   int phase_start;
   mapping nominations;
   mapping votes;
   string* voted;
}
protected void finish_election_phase(string area);
int post_citizen_message(string area, string subject, string message);
private mapping _elections;
private mapping _boards;
void create() {
   _elections = ([ ]);
   _boards = ([ ]);
   citizens::create();
   call_out("do_next_event", 10);
}
void create_area(string area) {
   _elections[area] = new(class election_data);
   _elections[area]->phase = CITIZEN_ELECTION_PHASE_GRACE;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   ::create_area(area);
}
int query_next_election_time(string area) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      return _elections[area]->phase_start + CITIZEN_GRACE_TIME;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return _elections[area]->last_election + CITIZEN_ELECTION_TIME;
   }
   return 0;
}
int query_end_of_phase_time(string area) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return _elections[area]->phase_start + CITIZEN_ELECTION_PHASE_TIME;
   }
   return _elections[area]->phase_start + CITIZEN_PHASE_TIME;
}
protected int query_election_phase(string area) {
   if (!_elections[area]) {
      return CITIZEN_ELECTION_PHASE_NONE;
   }
   return _elections[area]->phase;
}
int is_nomination_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_NOMINATION;
}
int is_election_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_ELECTION;
}
int is_grace_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_GRACE;
}
int nominate_magistrate(string area, string person, string nominator) {
   if (!_elections[area] ||
       !is_citizen_of(area, person) ||
       !is_citizen_of(area, nominator)) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (!_elections[area]->nominations[person]) {
         _elections[area]->nominations[person] = ({ });
      } else if (member_array(nominator,
                              _elections[area]->nominations[person]) != -1) {
         return 0;
      }
      _elections[area]->nominations[person] += ({ nominator });
      save_me();
      return 1;
   }
   return 0;
}
string* query_nominated_by(string area, string person) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (_elections[area]->nominations[person]) {
         return copy(_elections[area]->nominations[person]);
      }
   }
   return ({ });
}
string* query_people_nominated(string area) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      return keys(_elections[area]->nominations);
   }
   return ({ });
}
int is_nomination_accepted(string area, string person) {
   string* nominations;
   nominations = query_nominated_by(area, person);
   if (sizeof(nominations) >= 2 &&
       member_array(person, nominations) != -1) {
      return 1;
   }
   return 0;
}
int has_voted(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, _elections[area]->voted) != -1;
   }
   return 0;
}
int is_eligible_to_vote_for(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, keys(_elections[area]->votes)) != -1;
   }
   return 0;
}
int vote_for_people(string area, string* people, string voter) {
   string person;
   if (!_elections[area] ||
       !is_citizen_of(area, voter)) {
      return 0;
   }
   foreach (person in people) {
      if (!is_citizen_of(area, person)) {
         return 0;
      }
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (has_voted(area, voter)) {
         return 0;
      }
      foreach (person in people) {
         if (is_eligible_to_vote_for(area, person)) {
            _elections[area]->votes[person]++;
         }
      }
      _elections[area]->voted += ({ voter });
      save_me();
      return 1;
   }
   return 0;
}
string* query_can_vote_for(string area) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return keys(_elections[area]->votes);
   }
   return ({ });
}
protected void start_election(string area) {
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE ||
       _elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->nominations = ([ ]);
      _elections[area]->phase_start = time();
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NOMINATION;
      save_me();
      post_citizen_message(area, "Nomination phase has started.",
                           "Please go to your council offices and "
                           "nominate\nthe magistrates for office.\n");
   }
}
protected void finish_nomination_phase(string area) {
   string person;
   string* nominators;
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      foreach (person, nominators in _elections[area]->nominations) {
         if (is_citizen_of(area, person) &&
             is_nomination_accepted(area, person) &&
             !PLAYER_HANDLER->test_creator(person)) {
            _elections[area]->votes[person] = 0;
         }
      }
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_ELECTION;
      _elections[area]->phase_start = time();
      _elections[area]->nominations = ([ ]);
      save_me();
      post_citizen_message(area, "Nomination phase finished.",
                           "The people nominated for election are:\n" +
                           implode(map(keys(_elections[area]->votes),
                                       (: "   " + $1 :)), "\n"));
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
          finish_election_phase(area);
      }
   }
}
protected void finish_election_phase(string area) {
   string* voted;
   string* sorted_voted;
   string high_pk;
   string high_non_pk;
   string person;
   string results;
   int needed;
   int num;
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;
      } else {
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;
         needed = query_number_of_magistrates(area);
         foreach (person in voted) {
            if (PLAYER_HANDLER->test_player_killer(person)) {
               if (!high_pk) {
                  needed--;
                  high_pk = person;
               }
            } else {
               if (!high_non_pk) {
                  needed--;
                  high_non_pk = person;
               }
            }
            if (high_pk && high_non_pk) {
               break;
            }
         }
         voted -= ({ high_pk, high_non_pk });
         voted = voted[0..needed - 1];
         voted += ({ high_pk, high_non_pk });
         voted -= ({ 0 });
      }
      results = "Votes:\n";
      foreach (person in sorted_voted) {
         results += sprintf("%20s %d\n", capitalize(person),
                            _elections[area]->votes[person]);
      }
      results += "\nElected officals are " + query_multiple_short(voted) + "\n";
      results += "\nNumber of people who voted " +
                 sizeof(_elections[area]->voted);
      num = query_number_of_citizens(area);
      if (num == 0) {
         results += " (100% of the citizens)\n";
      } else {
         results += " (" + (sizeof(_elections[area]->voted) * 100 / num) +
                    "% of the citizens)\n";
      }
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NONE;
      _elections[area]->phase_start = time();
      _elections[area]->last_election = time();
      _elections[area]->nominations = ([ ]);
      post_citizen_message(area, "Election results", results);
      setup_magistrates(area, voted);
      save_me();
   }
}
protected void do_next_event() {
   int next_event;
   int time_to_next_event;
   string area;
   class election_data data;
   foreach (area, data in _elections) {
      switch (data->phase) {
      case CITIZEN_ELECTION_PHASE_NONE :
         next_event = (data->last_election - time()) + CITIZEN_ELECTION_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_NOMINATION :
         next_event = (data->phase_start - time()) + CITIZEN_PHASE_TIME;
         if (next_event <= 0) {
            finish_nomination_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_ELECTION :
         next_event = (data->phase_start - time()) + CITIZEN_ELECTION_PHASE_TIME;
         if (next_event <= 0) {
            finish_election_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_GRACE :
         next_event = (data->phase_start - time()) + CITIZEN_GRACE_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_DISABLED :
         next_event = (data->phase_start - time()) +
            CITIZEN_ELECTION_DISABLED_TIME;
         if (next_event <= 0) {
             next_event = next_event;
         }
         break;
      }
      if (next_event > 0 &&
          (next_event < time_to_next_event || !time_to_next_event)) {
         time_to_next_event = next_event;
      }
   }
   if(time_to_next_event) {
     call_out("do_next_event", time_to_next_event);
   }
}
void set_citizen_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][0] = name;
   save_me();
}
string query_magistrate_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][1];
   }
   return 0;
}
void set_magistrate_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][1] = name;
   save_me();
}
string query_citizen_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][0];
   }
   return 0;
}
int post_citizen_message(string area, string subject, string message) {
   string board;
   board = query_citizen_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
}
int post_magistrate_message(string area, string subject, string message) {
   string board;
   board = query_magistrate_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
}
int disable_citizen_election(string area) {
    if (!_elections[area]) {
      return 0;
    }
   _elections[area]->phase = CITIZEN_ELECTION_PHASE_DISABLED;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   save_me();
   return 1;
}

==================================================
FILE: /lib/obj/handlers/inherit/citizens.c
==================================================

#include <player_handler.h>
#include <playtesters.h>
#include <player.h>
private mapping _magistrates;
private mapping _citizens;
int is_citizen_of(string area, string citizen);
void save_me();
void create() {
   _citizens = ([ ]);
   _magistrates = ([ ]);
}
int create_area(string area, int num_magistrates) {
   _citizens[area] = ({ });
   _magistrates[area] = allocate(num_magistrates);
   save_me();
}
string* query_citizenship_areas() {
   return keys(_citizens);
}
int remove_citizen(string area, string citizen) {
   int pos;
   if (!_citizens[area]) {
      return 0;
   }
   if (member_array(citizen, _citizens[area]) != -1) {
      _citizens[area] -= ({ citizen });
      if (citizen) {
         pos = member_array(citizen, _magistrates[area]);
         if (pos != -1) {
            _magistrates[area][pos] = 0;
         }
      }
      save_me();
      return 1;
   }
   return 0;
}
int add_magistrate(string area, string magistrate) {
   int pos;
   if (!is_citizen_of(area, magistrate)) {
      return 0;
   }
   pos = member_array(0, _magistrates[area]);
   if (pos == -1) {
      return 0;
   }
   _magistrates[area][pos] = magistrate;
   save_me();
   PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   return 1;
}
protected void setup_magistrates(string area, string* magistrates) {
   int i;
   int num;
   string magistrate;
   if (!_magistrates[area]) {
      return ;
   }
   for (i = 0; i < sizeof(_magistrates[area]); i++) {
      _magistrates[area][i] = 0;
   }
   num = sizeof(_magistrates[area]);
   if (num <= sizeof(magistrates)) {
      magistrates = magistrates[0..num];
   } else {
      magistrates += allocate(num - sizeof(magistrates));
   }
   _magistrates[area] = magistrates;
   save_me();
   foreach (magistrate in magistrates) {
      PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   }
}
int query_number_of_magistrates(string area) {
   if (!_magistrates[area]) {
      return 0;
   }
   return sizeof(_magistrates[area]);
}
string* query_magistrates(string area) {
   if (!_magistrates[area]) {
      return ({ });
   }
   return _magistrates[area] - ({ 0 });
}
int add_citizen(string area, string citizen) {
   if (!PLAYER_HANDLER->test_user(citizen)) {
      return 0;
   }
   if (!_citizens[area]) {
      return 0;
   }
   _citizens[area] += ({ citizen });
   save_me();
   return 1;
}
int is_citizen_of(string area, string citizen) {
   if (!_citizens[area]) {
      return 0;
   }
   if (master()->query_lord(citizen)) {
      return 1;
   }
   return member_array(citizen, _citizens[area]) != -1;
}
int is_magistrate_of(string area, string magistrate) {
   if (!_magistrates[area]) {
      return 0;
   }
   if (master()->query_lord(magistrate)) {
      return 1;
   }
   return member_array(magistrate, _magistrates[area]) != -1;
}
string query_citizen(string citizen) {
   string bing;
   foreach (bing in query_citizenship_areas()) {
      if (is_citizen_of(bing, citizen)) {
         return bing;
      }
   }
   return 0;
}
int is_magistrate_anywhere(string person) {
   string bing;
   foreach (bing in query_citizenship_areas()) {
      if (is_magistrate_of(bing, person)) {
         return 1;
      }
   }
   return 0;
}
int query_number_of_citizens(string area) {
   return sizeof(_citizens[area]);
}

==================================================
FILE: /lib/obj/handlers/inherit/club_basic.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>
class club_info {
   string actual_name;
   string founder;
   string *recruiters;
   string *members;
   int type;
   mapping accounts;
   int last_paid;
   int last_touched;
   mixed extra_data;
   string description;
   string region;
}
#define CLUB_CACHE_SIZE 20
private mapping _club_names;
private string *_observers;
private nosave int _no_cache_hits;
private nosave int _no_cache_requests;
private nosave int _no_cache_miss;
private nosave int _cache_call_out;
private nosave mapping _cache;
private nosave string *_cache_order;
#define SAVE_FILE_NAME "/save/clubs"
#define SAVE_FILE_DIR "/save/clubs/"
protected void save_club(string name);
protected void load_main();
protected void save_main();
int is_club(string club_name);
int remove_recruiter(string name, string recruiter);
int is_recruiter_of(string name, string recruiter);
int query_club_type(string name);
void check_extra_information(string club_name, string member, int login);
int is_family(string name);
int disband_club(string name);
protected void set_club_changed(string name);
protected void send_broadcast_message(string club,
                                      string message);
protected void send_observer_event(string event_name,
                                   string *args ...);
void create() {
    seteuid(master()->creator_file(file_name()));
   _club_names = ([ ]);
   _cache = ([ ]);
   _cache_order = ({ });
   _observers = ({ });
   load_main();
}
string query_cap_name() {
   return "Club controller";
}
protected void load_main() {
   unguarded( (: restore_object(SAVE_FILE_NAME, 1) :) );
}
protected void save_main() {
   unguarded( (: save_object(SAVE_FILE_NAME, 1) :) );
}
string normalise_name(string name) {
   return replace_string(lower_case(name), " ", "_");
}
private void fixup_cache() {
   int i;
   if (sizeof(_cache_order) > CLUB_CACHE_SIZE) {
      for (i = sizeof(_cache_order) - CLUB_CACHE_SIZE; i >= 0; i--) {
         if (_club_names[_cache_order[i]]) {
            save_club(_cache_order[i]);
         }
         map_delete(_cache, _cache_order[i]);
      }
      _cache_order = _cache_order[sizeof(_cache_order) - CLUB_CACHE_SIZE + 1..];
   }
}
protected class club_info query_club_info(string name) {
   class club_info bing;
   name = normalise_name(name);
   _no_cache_requests++;
   if (_cache[name]) {
      _no_cache_hits++;
      return _cache[name];
   }
   if (unguarded( (: file_size(SAVE_FILE_DIR + $(name)) :)) > 0) {
      _cache[name] = unguarded( (: restore_variable(read_file(SAVE_FILE_DIR +
                                                              $(name))) :) );
      _cache_order += ({ name });
      if (intp(_cache[name]->accounts)) {
         _cache[name]->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : _cache[name]->accounts ]);
      }
      if (sizeof(_cache[name]) == 10) {
         bing = new(class club_info);
         bing->actual_name = _cache[name]->actual_name;
         bing->founder = _cache[name]->founder;
         bing->recruiters = _cache[name]->recruiters;
         bing->members = _cache[name]->members;
         bing->type = _cache[name]->type;
         bing->accounts = _cache[name]->accounts;
         bing->last_paid = _cache[name]->last_paid;
         bing->last_touched = _cache[name]->last_touched;
         bing->extra_data = _cache[name]->extra_data;
         bing->description = _cache[name]->description;
         bing->region = "Ankh-Morpork";
         _cache[name] = bing;
         set_club_changed(name);
      }
      fixup_cache();
      return _cache[name];
   }
   _no_cache_miss++;
   return 0;
}
protected void save_club(string name) {
   name = normalise_name(name);
   if (_cache[name]) {
      _club_names[name] = 0;
      unguarded( (: write_file(SAVE_FILE_DIR + $(name),
                               save_variable(_cache[$(name)]),
                               1) :) );
   }
}
protected void save_cache() {
   string name;
   class club_info data;
   foreach (name, data in _cache) {
      if (_club_names[name]) {
         save_club(name);
      }
   }
}
protected void set_club_changed(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      if (find_call_out(_cache_call_out) == -1) {
         _cache_call_out = call_out((: save_cache :), 0);
      }
      _club_names[name] = 1;
   }
}
private void add_club(string name,
                      class club_info data) {
   name = normalise_name(name);
   _cache[name] = data;
   _club_names[name] = 0;
   set_club_changed(name);
}
string the_short() {
   return "Club Control";
}
protected void create_extra_data(string name) {
   class club_info data;
   data = query_club_info(name);
   data->extra_data = 0;
   set_club_changed(name);
}
int create_club(string name, string founder, int type, string region) {
   class club_info info;
   if (!stringp(name) || !stringp(founder)) {
      return 0;
   }
   info = new(class club_info);
   info->actual_name = name;
   if (type != CLUB_FAMILY) {
      info->recruiters = ({ founder });
      info->members = ({ founder });
   } else {
      info->recruiters = ({ });
      info->members = ({ });
   }
   info->founder = founder;
   info->last_touched = time();
   info->type = type;
   info->last_paid = time();
   info->description = 0;
   info->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : 0 ]);
   info->region = region;
   add_club(name, info);
   create_extra_data(name);
   set_club_changed(name);
   add_club(name, info);
   save_main();
   return 1;
}
int change_club_type(string name,
                     int type) {
   int club_type;
   class club_info info;
   if (is_club(name)) {
      club_type = query_club_type(name);
      info = query_club_info(name);
      if (club_type != type) {
         info->type = (club_type & CLUB_FLAGS_MASK) | type;
         set_club_changed(name);
         create_extra_data(name);
         return 1;
      }
   }
   return 0;
}
int query_club_type(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (!data) {
         disband_club(name);
      } else {
         return data->type & CLUB_TYPE_MASK;
      }
   }
}
int set_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->type |= CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
}
int reset_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->type &= ~CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
}
int query_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return (data->type & CLUB_SECRET_FLAG) != 0;
   }
}
string query_club_region(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->region;
   }
   return 0;
}
int disband_club(string name) {
   class club_info data;
   name = normalise_name(name);
   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         log_file("CLUB", ctime(time()) + ": disbanded '" +
                       this_object()->query_club_name(name) + "'; balance = " +
                       this_object()->query_balance(name, CLUB_DEFAULT_ACCOUNT_NAME) + "; fees due = " +
                       ctime(this_object()->query_time_fees_due(name)) +
                       "\n");
      } else {
         log_file("CLUB", ctime(time()) + " disbanded '" + name + "' "
                          "which has a bad data file.\n");
      }
      map_delete(_club_names, name);
      map_delete(_cache, name);
      unguarded( (: rm(SAVE_FILE_DIR + $(name)) :) );
      save_main();
      send_observer_event("club_event_disband_club", name);
      return 1;
   }
   return 0;
}
string *query_clubs() {
   return keys(_club_names);
}
string query_insignia_path(string name) {
   return "/obj/misc/club_badge";
}
void touch_club(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->last_touched = time();
      set_club_changed(name);
   }
}
string *query_recruiters(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->recruiters;
   }
   return ({ });
}
string query_founder(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->founder;
   }
   return 0;
}
string *query_members(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->members;
   }
   return ({ });
}
int add_recruiter(string name, string recruiter) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->members) != -1 &&
          member_array(recruiter, data->recruiters) == -1) {
         data->recruiters += ({ recruiter });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " becomes a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
}
int add_member(string name, string member) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) == -1) {
         data->members += ({ member });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " joins the club.");
         }
         return 1;
      }
   }
   return 0;
}
int remove_member(string name, string member) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) != -1) {
         if (is_recruiter_of(name, member)) {
            remove_recruiter(name, member);
         }
         data->members -= ({ member });
         set_club_changed(name);
         check_extra_information(name, member, 0);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " leaves the club.");
         }
         send_observer_event("club_event_remove_member", name, member);
         return 1;
      }
   }
   return 0;
}
int remove_recruiter(string name, string recruiter) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->recruiters) != -1) {
         data->recruiters -= ({ recruiter });
         set_club_changed(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " stops being a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
}
string query_club_name(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      if (!data) {
         return club_name;
      }
      return data->actual_name;
   }
   return 0;
}
string query_club_description(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->description;
   }
   return 0;
}
int set_club_description(string club_name, string description) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      data->description = description;
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int query_time_fees_due(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->last_paid + CLUB_PAY_PERIOD;
   }
   return 0;
}
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      return CLUB_COST_PER_YEAR +
           sizeof(query_members(club_name)) * CLUB_COST_PER_MEMBER_PER_YEAR;
   }
   return 0;
}
int is_club(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      return 1;
   }
   return 0;
}
int is_elected_club(string name) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_club_type(name) == CLUB_ELECTED;
   }
   return 0;
}
int is_personal_club(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_PERSONAL;
   }
   return 0;
}
int is_family(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_FAMILY;
   }
   return 0;
}
int is_member_of(string name, string member) {
   if (is_club(name)) {
      return member_array(member, query_members(name)) != -1;
   }
   return 0;
}
int is_recruiter_of(string name, string recruiter) {
   if (is_club(name)) {
      return member_array(recruiter, query_recruiters(name)) != -1;
   }
   return 0;
}
int is_founder_of(string name, string founder) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_founder(name) == founder;
   }
   return 0;
}
int create_account(string name,
                   string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      if (undefinedp(data->accounts[account])) {
         data->accounts[account] = 0;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int add_money(string name,
              int amount,
              int type,
              string person,
              string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] += amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int remove_money(string name,
                 int amount,
                 int type,
                 string person,
                 string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] -= amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int query_balance(string name,
                  string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      return data->accounts[account];
   }
   return 0;
}
string* query_account_names(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         return keys(data->accounts);
      }
   }
   return ({ });
}
int is_account_of(string club_name, string account) {
   return member_array(account, query_account_names(club_name)) != -1;
}
int is_creator_club(string club_name) {
   if (is_club(club_name)) {
      if (PLAYER_HANDLER->test_creator(query_founder(club_name))) {
         return 1;
      }
   }
   return 0;
}
int is_observer(string obs) {
   if (member_array(obs, _observers) != -1) {
      return 1;
   }
   return 0;
}
int add_observer(string obs) {
   if (!is_observer(obs) &&
       file_size(obs) > 0) {
      _observers += ({ obs });
      save_main();
      return 1;
   }
   return 0;
}
int remove_observer(string obs) {
   if (is_observer(obs)) {
      _observers -= ({ obs });
      save_main();
      return 1;
   }
   return 0;
}
string *query_observers() {
   return _observers;
}
protected void send_observer_event(string event_name,
                                   string *args ...) {
   string bing;
   foreach (bing in _observers) {
      if (file_size(bing) > 0) {
         call_out((: call_other($1, $2, $3 ...) :),
                  0,
                  event_name,
                  bing,
                  args ...);
      } else {
         remove_observer(bing);
      }
   }
}
protected void send_broadcast_message(string club,
                                      string message) {
   BROADCASTER->broadcast_to_channel(this_object(),
                                     lower_case(query_club_name(club)),
                                     ({ message, 0 }));
}
mixed *stats() {
   return ({
              ({ "cache hits", _no_cache_hits }),
              ({ "cache requests", _no_cache_requests }),
              ({ "cache miss", _no_cache_miss }),
              ({ "percentage", _no_cache_hits * 100 / _no_cache_requests }),
           });
}
# Total Tokens: 24829
# Total Files Merged: 6
# Total Characters: 82775

