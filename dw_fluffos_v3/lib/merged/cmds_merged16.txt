# Total Tokens: 17504
# Total Files Merged: 24
# Total Characters: 58406

are2.c
==================================================

#include <creator.h>
inherit "/cmds/base";
string format_data( object *items, object victim, object target ) {
    int size;
    string vname, tname;
    vname = victim->the_short();
    tname = target->the_short();
    switch( size = sizeof( items ) ) {
    case 0:
        return "No objects in " + vname + " were cloned by " +
        tname;
    case 1:
        return "One object, " + query_multiple_short( items ) +
        " in " + vname + "'s inventory was cloned by " +
        tname;
    default:
        return query_num( size, 100 ) + " objects in " +
        vname + "'s inventory were cloned by " + tname;
    }
}
void describe_objects( object player1, object player2 ) {
    string mess;
    mapping data;
    data = filter( unique_mapping( all_inventory( player1 ),
        (: $1->query_cloned_by() :) ),
      (: $1 == $(player2)->query_name() :) );
    if ( !sizeof( data ) ) {
        data[ player1->query_name() ] = ({ });
    }
    mess = implode( values( map( data,
          (: format_data( $2, $(player1), $(player2) ) :) ) ), "\n" );
    tell_object( this_player(), "$P$compare$P$" + mess + "." );
}
int cmd( object player1, object player2 ) {
    describe_objects( player1, player2 );
    describe_objects( player2, player1 );
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present> {against|with|and} "
      "<indirect:wiz-present>",
      (: cmd( $1[0][0], $1[1][0] ) :) });
}

==================================================
FILE: creator/crea_tor.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ov, ob;
  notify_fail("Creator of what?\n");
  ov = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ov)) return 0;
  foreach (ob in ov) {
    write("Creator of " + WIZ_PRESENT->desc_object(ob) + ": " +
        master()->creator_file (file_name(ob)) + ", uid: " +
        getuid(ob) + ", euid: "+geteuid(ob)+"\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/cst_at.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ob, thing;
  mixed *ob1, *thing1;
  string s, bing;
  string long_fields, temp;
  int long_length;
  bing = "";
  str = (string)this_player()->expand_nickname(str);
  ob = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ob)) {
    write("No such object.\n");
    return 1;
  }
  foreach (thing in ob) {
    ob1 = (mixed *)thing->stats();
    if (!pointerp(ob1))
      continue;
    s = "";
    long_fields = "";
    long_length = ( (int)this_player()->query_cols() / 3 ) - 1;
    foreach (thing1 in (pointerp(ob1[0][0])?ob1[0]:ob1))
      if ( thing1[ 1 ] && !sscanf(thing1[0],"(%s)",temp)) {
        temp = thing1[0] +": "+ thing1[ 1 ] +"\n";
        if (strlen(temp) > long_length) long_fields += temp;
        else s += temp;
      }
    bing += sprintf("%-*#s\n", this_player()->query_cols(), long_fields) +
        sprintf( "%-*#s\n", this_player()->query_cols(), s );
  }
  this_player()->more_string(bing);
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/data.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd(object *obs, string var) {
    object ob;
    foreach (ob in obs) {
        if ( userp(ob) && !master()->query_lord( this_player()->query_name() ) ) {
            write("You cannot dump a player object.\n");
            continue;
        }
        else {
            this_player()->more_string( WIZ_PRESENT->desc_object( ob ) + ":\n" +
              debug_info( 2, ob ) + "\n", "Data" );
        }
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd($1, 0) :) });
}

==================================================
FILE: creator/dbxwhere.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  mapping error;
  object ob;
  if (str) {
    str = this_player()->expand_nickname(str);
    ob = find_player(str);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  } else
    ob = this_player();
  if (error = (mapping)ob->get_last_error()) {
    printf("%s\n", master()->standard_trace(error, 1));
  } else write("No error.\n");
  return 1;
}

==================================================
FILE: creator/debug.c
==================================================

inherit "/cmds/base";
#include <creator.h>
int cmd(object *obs, int detail) {
   object ob;
   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(detail, ob) + "\n");
   }
   return 1;
}
mixed *query_patterns() {
  return ({ "-v <indirect:wiz-present>", (: cmd($1, 2) :),
              "<indirect:wiz-present>", (: cmd($1, 1) :) });
}

==================================================
FILE: creator/define.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   string ret;
   string* bing;
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "No definitions for " + word + ".\n");
      } else {
         ret = "";
         foreach (bing in results) {
            ret += bing[1] + "\n" + bing[2] + "\n\n";
         }
         tell_object(player, "Definitions for " + word + ":\n" + ret);
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->define_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   add_succeeded_mess("$N look$s up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/delalt.c
==================================================

#include <creator.h>
#include <playerinfo.h>
inherit "/cmds/base";
int delete_alt(string s1, string s2) {
  string *alts, alt;
  s1 = this_player()->expand_nickname(lower_case(s1));
  alts =  explode(lower_case(s2)," ") - ({ "" }) - ({ 0 });
  foreach(alt in alts)
    write(PLAYERINFO_HANDLER->delete_alt(this_player(), s1, alt));
  return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <string'alt-name alt-name ...'>",
        (: delete_alt($4[0],$4[1]) :)
    });
}

==================================================
FILE: creator/delevent.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
inherit "/cmds/base";
int delete_event(string s1, string s2, int n)
{
    string  who = lower_case(s1);
    string  event = lower_case(s2);
    if(!PLAYER_HANDLER->test_user(who)) {
        write("No such player: "+who+".  \n");
        return 1;
    }
    if(PLAYERINFO_HANDLER->delete_entry(this_player(),who,event,n))
        write("Entry #" + n + " of " + capitalize(who) +
            "'s dossier deleted.  \n");
    else
        write("Cannot remove entry #" + n + " from " +
            capitalize(who) + "'s dossier.  \n");
    return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <word'event'> <number'entry-number'>",
        (: delete_event($4[0],$4[1],$4[2]) :)
    });
}

==================================================
FILE: creator/denied.c
==================================================

int db;
int cmd(string who){
  mixed rows;
  string ret;
  db = db_connect("localhost", "errors");
  if(who == "all")
    rows = db_exec(db, "select Reporter, count(*) as bing from errors "
		   "where Status = 'DENIED' "
                   "group by Reporter order by bing desc");
  else
    rows = db_exec(db, sprintf("select Reporter, count(*) from errors "
                               "where Reporter = '%s' and Status = 'DENIED' "
			       "group by Reporter",
                               who));
  if(intp(rows)){
    ret = sprintf("%-15s %s\n", "player", "reports");
    ret += implode(allocate(rows, function(int i){
      mixed *tmp = db_fetch(db, i+1);
      return sprintf("%-15s %s", tmp[0], ""+tmp[1]);
    }), "\n");
    ret += "\n";
    db_close(db);
    this_player()->more_string(ret);
  } else printf(rows);
  return 1;
}

==================================================
FILE: creator/dest_ruct.c
==================================================

#include <creator.h>
inherit "/cmds/base";
void main_dest_bit(object *ob);
void ask_dest(object *obs) {
  if (!pointerp(obs) || !sizeof(obs)) {
    write("No more things to dest.\n");
    return;
  }
  write("Dest object " + WIZ_PRESENT->desc_object(obs[0]) + " ? ");
  input_to("dest_answer", 0, 0, obs);
  return;
}
void dest_answer(string s, int majd, object *obs) {
  string err, shrt;
  if (this_player()->affirmative(s)) {
    if (majd) {
      shrt = (string)obs[0]->short();
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
        write("It REALLY doesn't want to be dested.\n");
        err = catch(destruct(obs[0]));
        this_player()->handle_error(err, "destruct()");
      }
      majd = 0;
      if (obs[0]) write("It didn't dest.\n");
      else {
        say((string)this_player()->query_cap_name()+" disintegrates "+
            (shrt ? shrt : "something") +".\n");
        write("Ok.\n");
      }
      ask_dest(obs[1..]);
      return;
    } else {
      obs[0]->move("/room/rubbish");
      err = catch(obs[0]->dest_me());
      this_player()->handle_error(err, "dest_me");
      if (obs[0]) {
        write("This object does NOT want to be dested.  Are you sure? ");
        input_to("dest_answer", 0, 1, obs);
        return;
      }
      write("Ok.\n");
      ask_dest(obs[1..]);
      return;
    }
  } else if (s == "q" || s == "quit") {
    write("Ok.  No more objects will be destd.\n");
    return;
  }
  write("Ok.  Not destd.\n");
  ask_dest(obs[1..]);
  return;
}
mixed cmd(string str) {
  object *ob, *dest_obj;
  string qstr;
  dest_obj = ({ });
  notify_fail("Can't find " + str + " to dest.\n");
  if ( !str || ( str == "" ) )
    return notify_fail( "Destruct what?\n" );
  if (this_player()->query_name() == "simidh") {
     write("Bye bye...\n");
     this_player()->dest_me();
     return 1;
  }
  if (sscanf(str, "query %s", qstr) == 1) {
    dest_obj = WIZ_PRESENT->wiz_present(qstr, this_player());
    if (!sizeof(dest_obj)) return 0;
    ask_dest(dest_obj);
    return 1;
  }
  ob = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ob)) return 0;
  main_dest_bit(ob);
  return 1;
}
void main_dest_bit(object *ob) {
  object thing, *rest, *dest_obj;
  string err, shrt, dobj;
  rest = ({ });
  dest_obj = ({ });
  foreach (thing in ob) {
    if (interactive(thing) && sizeof(ob) != 1) {
      write("You DON'T destruct " + thing->query_name() + ".\n");
      continue;
    }
    catch(shrt = (string)thing->short());
    dobj = WIZ_PRESENT->desc_object(thing);
    thing->move("/room/rubbish");
    err = catch(thing->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (thing)
      dest_obj += ({ thing });
    else {
      write("You destruct " + dobj + ".\n");
      say((string)this_player()->query_cap_name()+" disintegrates "+
          (shrt ? shrt : "something") + ".\n");
    }
  }
  if (sizeof(dest_obj) > 0) {
    ask_dest(dest_obj);
    return;
  }
  return;
}

==================================================
FILE: creator/dir_s.c
==================================================

inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("dir list");
   if (!stuff) {
      stuff = D_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/dist_ribution.c
==================================================

inherit "/cmds/base";
varargs int cmd(string num) {
  object player, *players;
  int division, i, max, slot;
  mapping stuff;
  division = to_int(num);
  if(!division) {
    division = 50;
  }
  stuff = ([ ]);
  players = users();
  max = 0;
  foreach( player in players )  {
    if ( !player->query_creator() )  {
      slot = player->query_level() / division;
      ++stuff[slot];
      if ( slot > max )  max = slot;
    }
    else players -= ({ player });
  }
  write("%^ORANGE%^Player level distribution:%^RESET%^\n");
  for ( i = 0; i < max; i++ )  {
    if ( stuff[i] )  {
      printf( "%5d ..%4d:\t%3d\t%3d%%\n", division * i, division * (i + 1) - 1,
              stuff[i], stuff[i] * 100  / sizeof( players ) );
    }
  }
  return 1;
}

==================================================
FILE: creator/dump.c
==================================================

inherit "/cmds/base";
#include <creator.h>
int cmd(object *obs) {
   object ob;
   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(0, ob) + "\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:wiz-present>", (: cmd($1) :) });
}

==================================================
FILE: creator/dupd_ate.c
==================================================

inherit "/cmds/base";
#include <creator.h>
string other;
int do_it(string str){
  object ob, *obs;
  string *all, *dil, file, fnob ;
  obs = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(obs))
    return 0;
  foreach(ob in obs){
    fnob = file_name(ob);
    all = inherit_list(ob);
    foreach(file in all){
      if (other){
        dil = deep_inherit_list(find_object(file));
        if (!((member_array(other, dil) != -1) || other == file))
          continue;
      }
      do_it(file);
    }
    ob->dest_me();
    if (ob)
      ob->dwep();
    if (ob)
      destruct(ob);
    ob = load_object(fnob);
    printf("Updated %s.\n", WIZ_PRESENT->desc_f_object(ob));
  }
  return 1;
}
int cmd(string str){
  object *tmp;
  other = 0;
  notify_fail("usage: dupdate <object> [<object>]\n");
  if (!str)
    return 0;
  sscanf(str, "%s %s", str, other);
  if (other){
    tmp = WIZ_PRESENT->wiz_present(other, this_player());
    if (sizeof(tmp)){
      other = file_name(tmp[0]);
      other += ".c";
    }
    else
      return 0;
  }
  return do_it(str);
}

==================================================
FILE: creator/eff_ects.c
==================================================

inherit "/cmds/base";
int cmd( object * obs, int brief ) {
   object who;
   int num, * enums;
   mixed arg;
   if( !obs )
      obs = ({ this_player() });
   foreach( who in obs ) {
      write( "%^BOLD%^Effects on " + who->query_short() + ":%^RESET%^\n" );
      enums = who->effects_matching( "" );
      if( !sizeof( enums ) ) {
         write( "No effects.\n" );
         printf( "%s\n",
           "-----------------------------------------------------------" );
         continue;
      }
      foreach( num in enums ) {
         arg = who->arg_of(num);
         if ( brief && ( arrayp(arg) || classp(arg) || mapp(arg) ) ) {
            arg = "COMPLEX";
         }
         if ( !brief ) {
            printf( "%s\n",
              "-----------------------------------------------------------" );
         }
         printf( "[%d]   %s (%O)\n", num,
           find_object( who->eff_of(num) )->query_classification(),
           arg );
      }
      printf( "%s\n",
        "-----------------------------------------------------------" );
   }
   return 1;
}
mixed * query_patterns() {
   return ({
     "<indirect:wiz-present> verbose", (: cmd( $1, 0 ) :),
     "<indirect:wiz-present> [brief]", (: cmd( $1, 1 ) :),
     "[me] verbose", (: cmd( 0, 0 ) :),
     "[me] [brief]", (: cmd( 0, 1 ) :),
   });
}

==================================================
FILE: creator/errors.c
==================================================

inherit "/cmds/base";
#include <error_handler.h>
#include <db.h>
#include <nroff.h>
#include <player_handler.h>
class user_data {
   class error_query query;
   class error_summary* errors;
   int pos;
   int last_touched;
   string direction;
   string report;
}
private mapping _user_query;
void create() {
   _user_query = ([ ]);
}
int find_index(object person, int id) {
   int i;
   class error_summary* errors;
   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   errors = _user_query[person->query_name()]->errors;
   for (i = 0; i < sizeof(errors); i++) {
      if (id == errors[i]->id) {
         return i;
      }
   }
   return 0;
}
int max_index(object person) {
   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   return sizeof(_user_query[person->query_name()]->errors);
}
int id_at(object person, int index) {
   if (!_user_query[person->query_name()] || index < 0 ||
       index >= sizeof(_user_query[person->query_name()]->errors)) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   return _user_query[person->query_name()]->errors[index]->id;
}
string menu_line(object person) {
   string ret;
   ret = "[" + (_user_query[person->query_name()]->pos + 1) + " of " +
          sizeof(_user_query[person->query_name()]->errors) + "] "
         "STFCOLHA-+PNGQ : ";
   return ret;
}
void finish_details(object person, int verbose,
                    int type, mixed data) {
   string ret;
   class error_details details;
   class error_complete complete;
   class error_comment comment;
   class error_forward forward;
   class error_replies reply;
   class user_data user_data;
   if (type != DB_SUCCESS) {
      tell_object(person, "%^BOLD%^%^RED%^Error: " + data + "%^RESET%^\n");
      return ;
   }
   user_data = _user_query[person->query_name()];
   complete = data[0];
   details = complete->details;
   ret = "%^BOLD%^%^CYAN%^Bug #" + details->summary->id + "%^RESET%^ " +
         details->summary->status + " " + details->summary->type + " " +
         details->summary->category + "\n";
   ret += "%^BOLD%^Date Reported%^RESET%^     : " +
             ctime(details->summary->entry_date) + "\n";
   ret += "%^BOLD%^Assigned To%^RESET%^       : " +
          details->summary->assigned_to + "\n";
   ret += "%^BOLD%^Reporter%^RESET%^          : " + details->summary->reporter + "\n";
   ret += "%^BOLD%^File name%^RESET%^         : " + details->summary->filename + "\n";
   if (verbose) {
      ret += "%^BOLD%^Directory%^RESET%^         : " + details->summary->directory + "\n";
   }
   if (details->summary->status == "FIXED" ||
       details->summary->status == "DENIED") {
      ret += "%^BOLD%^Fixed By%^RESET%^          : " + details->fixer +
             " (" + ctime(details->fix_date) + ")\n";
   }
   if (verbose) {
      if (sizeof(complete->forwards)) {
         ret += "%^BOLD%^Forwards%^RESET%^          :\n";
         foreach (forward in complete->forwards) {
            ret += "$I$5=     " + forward->forwarder + " from " +
                   forward->old_directory + " at " +
                   ctime(forward->date)[4..15] + "\n";
         }
      }
   }
   ret += "$I$0=" + details->report;
   if (verbose) {
      ret += details->runtime;
   } else if (details->runtime && details->runtime != "") {
      ret += "[Runtime Available]\n";
   }
   user_data->report = details->report;
   if (verbose) {
      ret += "$I$3=   ";
      foreach (reply in complete->replies) {
         ret += "%^BOLD%^Date Sent%^RESET%^   : " + ctime(reply->senddate)[4..15] +
                "\n%^BOLD%^From%^RESET%^        : " + reply->sender +
                "\n%^BOLD%^To%^RESET%^          : " + reply->recipient +
                "\n%^BOLD%^Subject%^RESET%^     : " + reply->subject + "<br>" +
                reply->message + "\n";
      }
      if (sizeof(complete->replies) && sizeof(complete->comments)) {
         ret += "$I$0=-------------------------------------------------------------\n$I$3=   ";
      }
      foreach (comment in complete->comments) {
         ret += "%^BOLD%^Comment by " + comment->commenter + " at " +
                ctime(comment->date)[4..15] + "%^RESET%^\n" +
                comment->comment + "\n";
      }
   } else {
      if (sizeof(complete->replies) > 0) {
         ret += sizeof(complete->replies) + " error replies.\n";
      }
      if (sizeof(complete->comments) > 0) {
         ret += sizeof(complete->comments) + " comments.\n";
      }
   }
   person->set_finish_func("finish_more_details", this_object());
   tell_object(person, "$P$Bug #" + details->summary->id + "$P$" + ret);
}
int finish_more_details() {
   object ob;
   ob = this_player();
   write(menu_line(ob));
   input_to("menu_response");
}
int finish_forward(object person, int pos, string new_dir, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Unable to forward bug #" +
                          data->errors[data->pos]->id +
                          " to " + new_dir + " (" + mess + ")");
   } else {
      tell_object(person, "Forwarded bug #" +
                          data->errors[data->pos]->id +
                          " from " + data->errors[data->pos]->directory +
                          " to " + new_dir);
      data->errors[data->pos]->directory = new_dir;
   }
}
void finish_change_status(object person, string status, int command,
                          string subject, int no_reply, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Database error: " + mess);
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }
   tell_object(person, "Updated status of bug #" + data->errors[data->pos]->id +
               " to " + status + (no_reply ?  " (no reply) " : "") +"\n");
   if (!command) {
      data = _user_query[person->query_name()];
      tell_object(person, menu_line(person));
      data->errors[data->pos]->status = status;
   }
}
void finish_status_message(object person, string status, int command,
                           string subject, string mess) {
   class user_data data;
   int pos;
   data = _user_query[person->query_name()];
   if (!mess) {
      tell_object(person, "Message aborted.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }
   if (status == "THANKS" || status == "TEMPORARY") {
      status = "FIXED";
   }
   if (status == "NOTREPRODUCIBLE" || status == "NOINFO" ||
       status == "NOTPOSSIBLE") {
      status = "DENIED";
   }
   pos = strsrch("$report$", mess);
   if (pos == -1) {
      mess += "\n\n" + data->report;
   } else {
      mess = replace_string(mess, "$report$", data->report);
   }
   if (!command) {
      input_to("menu_response");
   }
   if (!ERROR_HANDLER->do_change_status(data->errors[data->pos]->id,
                        status, subject == 0, subject, person->query_name(),
                        mess,
                        (: finish_change_status, person, status, command,
                                          subject, subject == 0 :))) {
      tell_object(person, "Unhappily an error occured.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
   }
}
string query_subject_from_type(string type, class error_summary error) {
   switch (type) {
   case "THANKS" :
      return "Thanks for " + error->category + " " + error->type;
   case "NOTPOSSIBLE" :
      return "Not possible to fix " + error->category + " " + error->type;
   case "NOTREPRODUCIBLE" :
      return "Not able to reproduce " + error->category + " " + error->type;
   case "FIXED" :
      return "Fixed bug #" + error->id;
   case "DENIED" :
      return "Denied bug #" + error->id;
   default :
      return "Change status of bug #" + error->id + " to " +
             type;
   }
}
string query_message_from_type(object person, string type,
                               class error_summary error) {
   switch (upper_case(type)) {
   case "THANKS" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "TEMPORARY" :
      return "Your " + lower_case(error->type) +
             " report was a temporary problem in the system and has "
             "since been resolved.  Thanks for reporting it."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTENOUGHINFORMATION" :
      return "Your " + lower_case(error->type) +
             " report did not contain enough information for this " +
             lower_case(error->type) + " to be resolved.  Please report "
             "again with more detailed information."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTREPRODUCIBLE" :
      return "Unable to reproduce your " + lower_case(error->type) +
             " report.  If you can track down exactly the circumstances "
             "which generate this error, please report it again."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTPOSSIBLE" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is not possible to fix, because of code restrictions."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXED" :
   case "DENIED" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " has now been " + lower_case(type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being fixed.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CONSIDERING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being considered for future fixing.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CUSTOM" :
      return "custom";
   case "NONE" :
      return "none";
   case "OPEN" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   }
}
void finish_change_type(object person, string new_type, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new type of " + new_type + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_type;
}
void finish_change_category(object person, string new_category, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new category of " + new_category + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_category;
}
void finish_assign_bug(object person, string assigner, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " is assigned to " + assigner + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->assigned_to = assigner;
}
void finish_adding_comment(object person, int type, mixed mess) {
   if (type != DB_SUCCESS) {
      tell_object(person, "SQL Error: " + mess);
      tell_object(person, menu_line(person));
   }
   tell_object(person, "Added a comment to the bug.\n");
   tell_object(person, menu_line(person));
}
void finish_comment(object person, int id, string comment) {
   if (!comment) {
      write("Aborted adding the comment.\n");
      write(menu_line(person));
      input_to("menu_response");
      return ;
   }
   input_to("menu_response");
   if (!ERROR_HANDLER->do_comment(id, person->query_name(), comment,
                             (: finish_adding_comment, person :))) {
      write("Big bad error.\n");
      write(menu_line(person));
   }
}
int do_bug_details(object person, int id, int verbose) {
   if (!ERROR_HANDLER->do_query_bug_details(id, (: finish_details, person,
                                                   verbose :))) {
      tell_object(person, "Error doing stuff.");
   }
   return 1;
}
int do_forward(object person, string new_dir) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_forward(data->errors[data->pos]->id,
                person->query_name(), new_dir,
                    (: finish_forward, person, data->pos, new_dir :))) {
      write("A horrible error occured.\n");
      return 0;
   }
   return 1;
}
int do_change_status(object person, string status, int command, string subject,
                     string mess) {
   if (mess == "custom") {
      tell_object(person, "User $report$ to place the error report in the "
                  "mail.  If $report$ is not included, the report will be "
                  "added onto the end.\n");
      person->do_edit("", (: finish_status_message, person, status, command,
                                                    subject :));
   } else if (mess == "none") {
      finish_status_message(person, status, command, 0, "");
   } else {
      finish_status_message(person, status, command, subject, mess);
   }
}
int do_change_type(object person, string type) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_type(data->errors[data->pos]->id, type,
       (: finish_change_type, person, type :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_change_category(object person, string category) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_category(data->errors[data->pos]->id, category,
       (: finish_change_category, person, category :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_assign_bug(object person, string assigner) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_assign_bug_to(data->errors[data->pos]->id, assigner,
       (: finish_assign_bug, person, assigner :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_comment(object person) {
   class user_data data;
   data = _user_query[person->query_name()];
   this_player()->do_edit("", (: finish_comment, person,
                                   data->errors[data->pos]->id :));
}
int do_help(object player) {
   string str;
   str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   if (!str) {
      NROFF_HAND->create_nroff("/doc/creator/commands/errors", "/doc/creatornr/errors");
      str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   }
   player->set_finish_func("finish_more_details", this_object());
   tell_object(player, "$P$Error help$P$" + str);
}
int do_list_errors() {
   class user_data data;
   class error_summary error;
   string str;
   int i;
   data = _user_query[this_player()->query_name()];
   str = "";
   i = 1;
   str += sprintf("ndx: #<num> %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                  "Status", "Cat", "Type", "Reporter", "Filename", "Directory");
   foreach (error in data->errors) {
      str += sprintf("$I$3=%3d: #%d %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                     i++, error->id, error->status[0..4], error->category[0..3],
                     error->type, error->reporter, error->filename[<15..],
                     error->directory[<15..]);
   }
   this_player()->set_finish_func("finish_more_details", this_object());
   write("$P$Error list$P$" + str);
}
int show_current_bug(object player, int verbose) {
   class user_data data;
   data = _user_query[player->query_name()];
   if (verbose == -1) {
      verbose = player->query_verbose("errors");
   }
   return do_bug_details(player, data->errors[data->pos]->id, verbose);
}
string expand_short_type(string name) {
   string str;
   str = upper_case(name);
   switch (str) {
   case "F" :
      return ERROR_STATUS_FIXED;
   case "D" :
      return ERROR_STATUS_DENIED;
   case "I" :
      return ERROR_STATUS_FIXING;
   case "C" :
      return ERROR_STATUS_CONSIDERING;
   case "O" :
      return ERROR_STATUS_OPEN;
   case "U" :
      return "CUSTOM";
   case "R" :
      return "NOTREPRODUCIBLE";
   case "R" :
      return "NOTPOSSIBLE";
   case "N" :
      return "NONE";
   case "T" :
      return "THANKS";
   case "M" :
      return "NOTENOUGHINFORMATION";
   case "E" :
      return "TEMPORARY";
   default :
      return str;
   }
}
void finish_change_status_command(object player, int id, string status,
                        string messtype, int type, mixed data) {
   string mess;
   string subject;
   class error_summary error;
   if (type != DB_SUCCESS) {
      tell_object(player, "SQL error: " + data + "\n");
      return ;
   }
   if (!sizeof(data)) {
      tell_object(player, "No bug found with an id of #" + id + "\n");
      return ;
   }
   error = data[0];
   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;
   status = expand_short_type(status);
   if (messtype) {
      messtype = expand_short_type(messtype);
      mess = query_message_from_type(player, messtype, error);
      subject = query_subject_from_type(messtype, error);
      if (!mess) {
         tell_object(player, "The reply type " + messtype + " was not valid.\n");
      } else {
         if (member_array(status, ERROR_TYPE) != -1) {
            tell_object(player, "The error type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
         } else {
            do_change_status(player, status, 1, subject, mess);
            return ;
         }
      }
   } else {
      mess = query_message_from_type(player, status, error);
      subject = query_subject_from_type(status, error);
      if (mess) {
         do_change_status(player, status, 1, subject, mess);
         return ;
      }
   }
   tell_object(player, "Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
   tell_object(player, "The default message is based on the type it is changed to.\n");
   tell_object(player, "The type has some short forms: o -> open, f -> fixed, d ->denied\n");
   tell_object(player, "   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
   tell_object(player, "   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
   tell_object(player, "   t ->temporary.\n");
}
void menu_response(string str) {
   string* bits;
   class user_data data;
   int print_menu_line;
   class error_summary error;
   string mess;
   string subject;
   int id;
   bits = explode(str, " ");
   if (!sizeof(bits)) {
      bits = ({ "n" });
   }
   data = _user_query[this_player()->query_name()];
   switch(lower_case(bits[0])) {
   case "v" :
      if (sizeof(bits) > 1) {
         show_current_bug(this_player(), bits[1] == "verbose");
      } else {
         show_current_bug(this_player(), -1);
      }
      break;
   case "+" :
   case "n" :
      if (data->pos < sizeof(data->errors) - 1) {
         data->pos++;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No next bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "-" :
   case "p" :
      if (data->pos > 0) {
         data->pos--;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No previous bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "f" :
      if (sizeof(bits) == 2) {
         if (do_forward(this_player(), bits[1])) {
            input_to("menu_response");
         } else {
            print_menu_line = 1;
         }
      } else {
         write("Need to specify the destination directory (and nothing else)\n");
         print_menu_line = 1;
      }
      break;
   case "s" :
      if (sizeof(bits) > 1) {
         bits[1] = expand_short_type(bits[1]);
         error = data->errors[data->pos];
         if (sizeof(bits) > 2) {
            bits[2] = expand_short_type(bits[2]);
            mess = query_message_from_type(this_player(), bits[2], error);
            subject = query_subject_from_type(bits[1], error);
            if (!mess) {
               write("The reply type " + bits[2] + " was not valid.\n");
               print_menu_line = 1;
            } else {
               if (member_array(bits[1], ERROR_TYPE) != -1) {
                  write("The error type must be one of " +
                        query_multiple_short(ERROR_TYPE) + ".\n");
                  print_menu_line = 1;
               } else {
                  do_change_status(this_player(), bits[1], 0, subject, mess);
                  input_to("menu_response");
               }
            }
         } else {
            mess = query_message_from_type(this_player(), bits[1], error);
            subject = query_subject_from_type(bits[1], error);
            if (mess) {
               do_change_status(this_player(), bits[1], 0, subject, mess);
               input_to("menu_response");
            }
         }
         if (!mess) {
            write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
            write("The default message is based on the type it is changed to.\n");
            write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
            write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
            write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
            write("   t ->temporary.\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
         write("The default message is based on the type it is changed to.\n");
         write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
         write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
         write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
         write("   t ->temporary.\n");
         print_menu_line = 1;
      }
      break;
   case "t" :
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_TYPE) != -1) {
            do_change_type(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {TYPO|BUG|IDEA}\n");
         print_menu_line = 1;
      }
      break;
   case "o" :
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_CATEGORIES) != -1) {
            do_change_category(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_CATEGORIES) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {ROOM|OBJECT|COMMAND|HELP|RITUAL|SPELL|GENERAL}\n");
         print_menu_line = 1;
      }
      break;
   case "g" :
      if (sizeof(bits) > 0) {
         id = to_int(bits[1]);
         if (id <= sizeof(data->errors)) {
            data->pos = id - 1;
            show_current_bug(this_player(), -1);
         } else {
            id = find_index(this_player(), id);
            if (id == -1) {
               write("Unable to find the bug #" + id + "\n");
               print_menu_line = 1;
            }
         }
      } else {
         write("Syntax: g <num>\nNum can either be the index number or the "
               "bug id.\n");
         print_menu_line = 1;
      }
      break;
   case "c" :
      do_comment(this_player());
      break;
   case "i" :
   case "l" :
      do_list_errors();
      break;
   case "q" :
      write("Bye bye.\n");
      return ;
   case "a" :
      if (sizeof(bits) > 1) {
         if (!PLAYER_HANDLER->test_creator(bits[1])) {
            write("You can only assign a bug to a creator.\n");
            print_menu_line = 1;
         } else {
            do_assign_bug(this_player(), bits[1]);
            input_to("menu_response");
         }
      } else {
         write("You need to specify someone to assign the error to.\n");
         print_menu_line = 1;
      }
      break;
   case "h" :
      do_help(this_player());
      break;
   default :
      write("Bad command.\n");
      print_menu_line = 1;
      break;
   }
   if (print_menu_line) {
      write(menu_line(this_player()));
      input_to("menu_response");
   }
}
void finish_query(object player, int type, mixed data) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error: " + data + "\n");
      return ;
   }
   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;
   if (!sizeof(data)) {
      tell_object(player, "No bugs with that query.\n");
      return ;
   }
   show_current_bug(player, -1);
}
int setup_query(object player, class error_query query) {
   if (!ERROR_HANDLER->do_query_bug_summary(query, (: finish_query, player :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   return 1;
}
int errors_change_status(int id, string status, string messtype) {
   class error_query query;
   query = new (class error_query);
   query->id = id;
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                     (: finish_change_status_command, this_player(), id, status,
                        messtype :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   write("Looking up bug #" + id + " to fix.\n");
   return 1;
}
int errors_this_dir(int recursive) {
   class error_query query;
   query = new (class error_query);
   query->dir = this_player()->query_path();
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_by_person(string person) {
   class error_query query;
   query = new (class error_query);
   query->reporter = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_assigned_to_person(string person) {
   class error_query query;
   query = new (class error_query);
   query->assigned_to = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_assigned_to_me() {
   return errors_assigned_to_person(this_player()->query_name());
}
int errors_in_dir(string str, int recursive) {
   class error_query query;
   string path;
   path = this_player()->get_path(str);
   query = new (class error_query);
   query->dir = path;
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_with_id(int id) {
   class error_query query;
   query = new (class error_query);
   query->id = id;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_for_file(string file) {
   class error_query query;
   query = new (class error_query);
   query->file_name = file;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_in_this_room() {
   class error_query query;
   query = new (class error_query);
   query->file_name = file_name(environment(this_player()));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
mixed* query_patterns() {
   return ({ "", (: errors_this_dir(0) :),
             "status <number'bug id'> <word'status'>",
                   (: errors_change_status($4[0], $4[1], 0) :),
             "status <number'bug id'> <word'status'> <word'reply'>",
                   (: errors_change_status($4[0], $4[1], $4[2]) :),
             "recursive", (: errors_this_dir(1) :),
             "mine", (: errors_assigned_to_me :),
             "here", (: errors_in_this_room :),
             "assigned <string'person'>", (: errors_assigned_to_person($4[0]) :),
             "by <string'person'>", (: errors_by_person($4[0]) :),
             "id <number'bug id'>", (: errors_with_id($4[0]) :),
             "file <string'file'>", (: errors_for_file($4[0]) :),
             "dir <string'dir'>", (: errors_in_dir($4[0], 0) :),
             "dir recursive <string'dir'>", (: errors_in_dir($4[0], 1) :) });
}

==================================================
FILE: creator/family.c
==================================================

#include <clubs.h>
#include <money.h>
inherit "/cmds/base";
inherit "/std/basic/club_listing";
#include <player_handler.h>
#include <playerinfo.h>
mixed family_reverse(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string opp;
  string relation;
  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }
  foreach (relation in relations_from) {
    opp = CLUB_HANDLER->query_opposite_relationship(relation);
    if (!opp) {
      write("Unable to swap " + relation + ".\n");
    } else {
      if (!CLUB_HANDLER->remove_relationship(family_from,
                                             from,
                                             family_to,
                                             to,
                                             relation)) {
        write("Could not remove relationship " + relation + " between " +
              from + " and " + to + ".\n");
      } else {
        CLUB_HANDLER->add_relationship(family_from,
                                       from,
                                       family_to,
                                       to,
                                       opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      from,
                                      "family",
                                      "Changed relationship with " + to + " to " +
                                      opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      to,
                                      "family",
                                      "Changed relationship with " + from + " to " +
                                      relation);
        write("Swapped relationship " + relation + " between " +
              from + " and " + to + ".\n");
      }
    }
  }
  return 1;
}
int family_remove(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string relation;
  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }
  foreach (relation in relations_from) {
    if (!CLUB_HANDLER->remove_relationship(family_from,
                                           from,
                                           family_to,
                                           to,
                                           relation)) {
      write("Could not remove relationship " + relation + " between " +
            from + " and " + to + ".\n");
    } else {
      write("Removed relationship " + relation + " between " +
            from + " and " + to + ".\n");
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    from,
                                    "family",
                                    "Removed relationship with " + to);
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    to,
                                    "family",
                                    "Removed relationship with " + from);
    }
  }
  return 1;
}
private int do_balance(string club_name) {
   int balance;
   string place;
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("There is no family called '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   }
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   balance = CLUB_HANDLER->query_balance(club_name);
   write("The balance of the family '" +
         CLUB_HANDLER->query_club_name(club_name) + "' is " +
         MONEY_HAND->money_value_string(balance, place) + ".\n");
   return 1;
}
private int do_all_balance() {
   string *clubs;
   string club;
   string place;
   mapping bing;
   string ret;
   clubs = CLUB_HANDLER->query_clubs();
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   bing = ([ ]);
   foreach (club in clubs) {
      if (!CLUB_HANDLER->is_family(club)) {
         continue;
      }
      bing[club] = CLUB_HANDLER->query_balance(club);
   }
   clubs = keys(bing);
   clubs = sort_array(clubs, (: $3[$1] - $3[$2] :), bing);
   ret = "";
   foreach (club in clubs) {
      ret += sprintf("Family '%-20s': %s\n",
            CLUB_HANDLER->query_club_name(club),
            MONEY_HAND->money_value_string(bing[club], place));
   }
   write("$P$Club Balances$P$" + ret);
   return 1;
}
mixed *query_patterns() {
  return ({ "info <word'family name'>",
              (: family_info($4[0], this_player()->query_name()) :),
            "reverse relationship <word'player name'> <word'player name'>",
              (: family_reverse($4[0], $4[1]) :),
            "remove relationship <word'player name'> <word'player name'>",
              (: family_remove($4[0], $4[1]) :),
            "balance <string'family name'>", (: do_balance($4[0]) :),
            "balance all", (: do_all_balance() :) });
}

==================================================
FILE: creator/fds.c
==================================================

inherit "/cmds/base";
mixed cmd(string) {
  this_player()->more_string(dump_file_descriptors());
  return 1;
}

==================================================
FILE: creator/fetch.c
==================================================

#include <move_failures.h>
#include <playerinfo.h>
#define BROKEN_ROOM "/room/broken"
inherit "/cmds/base";
int cmd( mixed *indirect_obs ) {
    object *broken_items, *failed, *success;
    object player;
    if ( sizeof( indirect_obs ) != 2 ) {
        return 0;
    }
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You cannot $V an object for more than one "
            "player at once.\n" );
        return 0;
    }
    player = indirect_obs[ 1 ][ 0 ];
    broken_items = indirect_obs[ 0 ];
    failed = filter( broken_items,
        (: $1->move( $(player), "$N appear$s in your inventory." ) != MOVE_OK :) );
    success = broken_items - failed;
    if ( sizeof( failed ) ) {
        tell_object( this_player(), "Warning-- could not move " +
            query_multiple_short( failed ) + " to " +
            player->the_short() + ".\n" );
    }
    if ( sizeof( success ) ) {
        PLAYERINFO_HANDLER->add_entry(
            this_player(), player->query_name(), "replace",
            "Fetched " + implode( success->short(), "," ) + " from /room/broken.");
        add_succeeded_mess( "$N $V $I for " + player->the_short() + " from "
            "the broken room.\n", success );
        return 1;
    }
    add_failed_mess( "No objects could be retrieved for $I.\n",
        ({ player }) );
    return -1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:" + BROKEN_ROOM + "> [for] <indirect:player>",
        (: cmd($1) :) });
}

==================================================
FILE: creator/findc_orpse.c
==================================================

inherit "/cmds/base";
int cmd( string arg ) {
   object *cs, c;
   string r;
   r = "player corpse objects\n";
   cs = filter( children( "/obj/corpse" ), (: $1 && $1->query_property(
      "player" ) :) );
   if( !arg ) {
      foreach( c in cs ) r += file_name( c ) + " - " + c->query_owner() +
         " - " + ( environment( c ) ? file_name( environment( c ) ) :
         "In void" ) + "\n";
      tell_object( this_player(), r );
      tell_object( this_player(), sizeof( cs ) + " player corpses.\n" );
   } else {
      cs = filter( cs, (: $1 && $1->query_ownership() == $( arg ) :) );
      if( sizeof( cs ) ) {
         r = "Corpse objects of " + arg + ": \n";
         foreach( c in cs ) r += file_name( c ) + " in " + (
         environment( c ) ? file_name( environment( c ) ) : "void" ) + "\n";
         tell_object( this_player(), r );
      } else {
         tell_object( this_player(), arg + " has no corpses loaded.\n" );
      }
   }
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/findr_edef.c
==================================================

string *find_stuff(object ob, string varname){
  string *variables = variables(ob);
  string *ret = ({});
  if(member_array(varname, variables) > -1){
    object *inhobs = map(inherit_list(ob), (:find_object:));
    object obj;
    foreach(obj in inhobs){
      ret += find_stuff(obj, varname);
    }
    if(ret == ({})){
      ret = ({file_name(ob)});
    }
  }
  return ret;
}
int cmd(object ob, string var){
  string *files = find_stuff(ob, var);
  if(sizeof(files) > 1)
    printf("%s is defined in %s and %s.\n", var, implode(files[0..<2], ", "),
           files[<1]);
  else
    write("No redefinition found.\n");
  return 1;
}
string *query_patterns(){
  return ({"<indirect:wiz-present> <word'global'>", (:cmd($1[0], $4[1]):)});
}

==================================================
FILE: creator/fixed.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Fixer"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer is not NULL and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   } else {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer = '" + who +
                            "' and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/forwards.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Forwarder"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder is not NULL "
                   "group by Forwarder order by bing desc";
   } else {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder = '" + who + "' "
                   "group by Forwarder order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}
