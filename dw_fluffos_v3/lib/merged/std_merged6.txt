# Total Tokens: 99650
# Total Files Merged: 42
# Total Characters: 332302

affbase.c
==================================================

#include <language.h>
#define GRAFFITI "graffiti"
#define ETP environment(this_player())
#define TO this_object()
object writing_on;
object old;
string olds;
string query_drawingwith();
int do_check();
int done_check();
string query_drawingwith() { return "something"; }
int do_check() { return 0; }
int done_check() { return 0; }
void init() {
 this_player()->add_command( "scrawl", this_object(), "with charcoal on wall");
 this_player()->add_command( "scrawl", this_object(), "on wall with charcoal");
}
int do_scrawl( object *things ) {
    string language;
    if ( !ETP->query_property( GRAFFITI) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "+
          "this wall.\n");
        return 0;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "
           "a wall when you're not using a language that can be used for "
          "scrawling on a wall with.\n",({writing_on}));
        return 0;
    }
    if(( old = present("graffiti",ETP)) && !interactive(old))
    {
        olds = old->query_property("graffiti");
    }
    if ( writing_on ) {
        this_player()->add_failed_mess( this_object(), "The writing "+
          "spot seems to be busy at the moment.\n",
          ({writing_on}));
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(), ({"You start scrawling "+
      "on a wall with some charcoal.\n", "$N starts scrawling on a wall with "
      "some charcoal.\n"}) );
    writing_on = ETP;
    call_out( "begin_writing", 0, this_player() );
    return 1;
}
void begin_writing( object writer ) {
    if ( !writer ) {
        writing_on = 0;
        return;
    }
    writer->do_edit( 0, "end_writing" );
}
void end_writing( string words ) {
    string language;
    string extra;
    if ( !words || ( words == "" ) ) {
        write( "You don't scrawl anything on "+
         "the wall.\n");
        say( (string)this_player()->the_short() +" doesn't "+
          "scrawl anything after all.\n" );
        writing_on = 0;
        return;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        write( "You seem to have changed to using a non-written language.\n" );
        say( (string)this_player()->the_short() +" seems "+
          "linguistically-challenged.\n" );
        writing_on = 0;
        return;
    }
    if ( !writing_on ) {
        write( "You seem to have lost what you were scrawling on.\n" );
        say( (string)this_player()->the_short() +" looks around "+
          "in puzzlement.\n" );
        return;
    }
    if (  writing_on != ETP ) {
        write("The wall seems to have run away from you.\n" );
        say( (string)this_player()->the_short() +" looks like "+
          (string)this_player()->query_pronoun() +"'s lost something.\n" );
        writing_on = 0;
        return;
    }
    if(!stringp(olds)) olds = "";
    words = olds +"\n"+"%^MAGENTA%^Scrawled with rough charcoal, you "
             "read the words:%^RESET%^\n\n"+
    words;
    if(old) old->move("/room/rubbish");
    extra = TO->extra_stuff();
    if(!strlen(extra))extra = "Some disreputable character has scrawled "
        "graffiti over this wall.  You may be able to \"read\" it.\n";
    ETP->add_sign(
      extra,
      words,
      "graffiti",
      ({"graffiti","scrawl"}),
      language
    );
    old = present("graffiti",ETP);
    old->add_property("determinate","some ");
    old->add_property("there","on the wall");
    if(old) old->add_property("graffiti",words);
    write( "As you finish scrawling on the wall, the piece of charcoal "
           "breaks.\n" );
    say( (string)this_player()->the_short() +" finishes scrawling "+
      "on the wall.\n" );
    this_object()->done_check();
    writing_on = 0;
}

==================================================
FILE: room/basic/item.c
==================================================

#define DEBUG 1;
#include <parse_command.h>
#include <obj_parser.h>
#define POSITION_SIZE 2
#define POSITION_DESC 0
#define POSITION_MULT 1
private mixed *_lng;
private string *_shrt;
private string *_adjs;
private string *_plu;
private string *_name;
#ifdef DEBUG
private string _creator_room;
#endif
private mapping _verb;
private mapping _plural;
private mapping _other_things;
private mapping _pattern;
private int *_cur_desc;
private mapping _gather;
private mapping _position_stuff;
private mapping _count;
void init() {
    string name;
    mixed rest;
    foreach (name, rest in _other_things) {
            this_player()->add_command(name, this_object(), _pattern[name]);
    }
}
#ifdef DEBUG
string query_creator_room() { return _creator_room; }
void print_stuff() {
    printf("lng = %O\nshrt = %O\nadjs = %O\nplu = %O\nname = %O\n" +
      "verb = %O\nplural = %O\nother_things = %O\npattern = %O\n" +
      "cur_desc = %O\ngather = %O\n", _lng, _shrt, _adjs, _plu, _name, _verb,
      _plural, _other_things, _pattern, _cur_desc, _gather);
}
#endif
void create() {
#ifdef DEBUG
    _creator_room = file_name(previous_object());
#endif
    _adjs = ({ });
    _lng = ({ "" });
    _shrt = ({ "" });
    _gather = ([ ]);
    _plu = ({ });
    _name = ({ });
    _verb = ([ ]);
    _plural = ([ ]);
    _pattern = ([ ]);
    _cur_desc = ({ });
    _count = ([ ]);
    _other_things = ([ "smell" : 0, "taste" : 0, "read" : 0 ]);
}
int query_visible( object thing ) { return 1; }
string hide_invis_string() { return ""; }
string *query_short_array() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ _shrt[i] });
    }
    return ret;
}
string short() {
    return query_multiple_short(query_short_array());
}
string pretty_short() {
    string *ret;
    ret = query_short_array();
    if (sizeof(ret)) {
        return query_multiple_short(ret);
    } else {
        return "something";
    }
}
string a_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:" + add_a( $1 ) + "$" :)), "");
}
string the_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " +  $1 + "$" :)), "");
}
string one_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string poss_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string query_read_short() {
    return "$name$";
}
string query_plural() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ pluralize(_shrt[i]) });
    }
    return query_multiple_short(ret);
}
string pretty_plural() {
    int i;
    foreach (i in _cur_desc) {
        return pluralize(_shrt[i]);
    }
    return 0;
}
string long( string name, int dark ) {
    int i;
    string *ret;
    ret = ({ });
    foreach (i in _cur_desc) {
        if ( !_lng[ i ] ) {
            continue;
        }
        if (functionp(_lng[ i ])) {
            ret += ({ evaluate(_lng[ i ]) });
        } else {
            ret += ({ _lng[ i ] });
        }
    }
    if ( !sizeof( ret ) ) {
        return "You don't think that the "+name+" is here.\n";
    }
    return implode( evaluate(ret), "\n")+"\n";
}
int *query_cur_desc() { return _cur_desc; }
mapping query_verbs() { return _verb; }
mapping query_plurals() { return _plural; }
string *query_lng() { return _lng; }
string *query_shrt() { return _shrt; }
mixed *query_gather() {
    mixed *g = ({ });
    int i;
    foreach (i in _cur_desc) {
        if (_gather[i]) {
            g += ({ _gather[i] });
        }
    }
    return g;
}
int drop() { return 1; }
int get() { return 1; }
int query_item(string str) { return _verb[str]; }
private void setup_bits_for_item(int index, mixed bits) {
    int i;
    string str;
    mixed pat;
    if (!pointerp(bits)) {
        _lng[index] = bits;
        return ;
    }
    _lng[index] = "You see nothing special.\n";
    for (i = 0; i < sizeof(bits); i += 2) {
        if ((arrayp( bits[i + 1] ) && sizeof( bits[i + 1] ) == 3) ||
          (sizeof( bits[i + 1] ) == 2 && functionp( bits[i + 1][0] ))) {
            pat = bits[i + 1][<1];
            if (!arrayp(pat)) {
                pat = ({ pat });
            }
        }
        else {
            pat = ({ "<direct:object>" });
        }
        if (!pointerp(bits[i])) {
            bits[i] = ({ bits[i] });
        }
        foreach (str in bits[i]) {
            if (str == "long") {
                _lng[index] = bits[i+1];
            } else if (str == "gather") {
                _gather[index] = bits[i+1];
            } else if (str == "item_count")  {
               if (!_count[index])  _count[index] = bits[i + 1];
            } else if (str == "position" ||
              str == "position multiple") {
                if (!_position_stuff)
                    _position_stuff = ([ ]);
                if (!_position_stuff[index]) {
                    _position_stuff[index] = allocate(POSITION_SIZE);
                }
                if (str == "position") {
                    _position_stuff[index][POSITION_DESC] = bits[i + 1];
                } else {
                    _position_stuff[index][POSITION_MULT] = bits[i + 1];
                }
            } else if (!_other_things[str]) {
                _pattern[str] = pat;
                _other_things[str] = ([ index : bits[i+1] ]);
            } else {
                if (member_array(pat, _pattern[str]) == -1) {
                    _pattern[str] += pat - (string *)_pattern[str];
                }
                _other_things[str][index]   = bits[i+1];
            }
        }
    }
}
private void remove_bits_for_item(int index) {
    string str;
    string adj;
    mixed value;
    int frog;
    int bing;
    int i;
    int j;
    map_delete(_gather, index);
    foreach (frog, bing in _gather) {
        if (frog > index) {
            map_delete(_gather, frog);
            _gather[frog - 1] = bing;
        }
    }
    if (_position_stuff) {
        map_delete(_position_stuff, index);
        foreach (frog, bing in _position_stuff) {
            if (frog > index) {
                map_delete(_position_stuff, frog);
                _position_stuff[frog - 1] = bing;
            }
        }
    }
    foreach (str, value in _other_things) {
        if (value) {
            map_delete(value, index);
            if (!sizeof(value)) {
                map_delete(_other_things, str);
                map_delete(_pattern, str);
            } else {
                foreach (frog, bing in value) {
                    if (frog > index) {
                        map_delete(value, frog);
                        value[frog - 1] = bing;
                    }
                }
            }
        }
    }
    foreach (str, value in _verb) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                foreach (adj in value[i]) {
                    j = member_array(adj, _adjs);
                    if (j != -1) {
                        _adjs = _adjs[0..i - 1] + _adjs[i + 1..];
                    }
                }
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
                j = member_array(str, _name);
                if (j != -1) {
                    _name = _name[0..j - 1] + _name[j + 1..];
                }
            }
        }
        _verb[str] = value;
    }
    foreach (str, value in _plural) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
            }
        }
        _plural[str] = value;
    }
}
private void add_name_reference(int index, string name, int no_plural) {
    string *bits;
    string plural;
    string s;
    bits = explode(name, " ");
    s = bits[<1];
    if (member_array(s, _name) == -1) {
        _name += ({ s });
    }
    if (!_verb[s]) {
        _verb[s] = ({ bits[0..<2], index });
    } else {
        _verb[s] += ({ bits[0..<2], index });
    }
    if (!no_plural) {
        plural = pluralize(s);
        if (member_array(plural, _plu) == -1) {
            _plu += ({ plural });
        }
        if (!_plural[plural]) {
            _plural[plural] = ({ bits[0..<2], index });
        } else {
            _plural[plural] += ({ bits[0..<2], index });
        }
    }
    _adjs += bits[0..<2];
}
int setup_item(mixed nam, mixed long, int no_plural) {
    int index;
    string str;
    index = sizeof(_lng);
    if (pointerp(nam)) {
        if (sizeof(nam) > 0) {
            _shrt += ({ nam[0] });
            if (no_plural) {
                _plu += ({ "no plural" });
            } else {
                _plu += ({ pluralize(nam[0]) });
            }
        }
        foreach (str in nam) {
            add_name_reference(index, str, no_plural);
        }
    } else {
        _shrt += ({ nam });
        if (no_plural) {
            _plu += ({ "no plural" });
        } else {
            _plu += ({ pluralize(nam) });
        }
        add_name_reference(index, nam, no_plural);
    }
    _lng += ({ 0 });
    setup_bits_for_item(index, long);
    return index;
}
int modify_item_by_index(int index, mixed long) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    setup_bits_for_item(index, long);
    return 1;
}
int modify_item_by_name(string str, mixed long) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return modify_item_by_index(index, long);
}
int modify_item(mixed str, mixed long) {
    if (stringp(str)) {
        return modify_item_by_name(str, long);
    }
    if (intp(str)) {
        return modify_item_by_index(str, long);
    }
    return 0;
}
int remove_item_by_index(int index) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    _shrt = _shrt[0..index - 1] + _shrt[index + 1..];
    _adjs = _adjs[0..index - 1] + _adjs[index + 1..];
    _lng = _lng[0..index - 1] + _lng[index + 1..];
    _plu = _plu[0..index - 1] + _plu[index + 1..];
    remove_bits_for_item(index);
}
int remove_item_by_name(string str) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return remove_item_by_index(index);
}
int remove_item(mixed str) {
    if (stringp(str)) {
        return remove_item_by_name(str);
    }
    if (intp(str)) {
        return remove_item_by_index(str);
    }
    return 0;
}
string *parse_command_id_list() { return _name; }
string *parse_command_plural_id_list() { return _plu; }
string *parse_command_adjectiv_id_list() { return _adjs; }
object query_parse_id(mixed *arr)
{
    string *bits;
    mixed stuff;
    int i, j, match, all_match;
    bits = explode(arr[P_STR], " ");
    bits -= ({ "a", "an", "the" });
    if (arr[P_THING] == 0)
    {
        stuff = _plural[bits[<1]];
        if (!stuff) {
            stuff = _verb[bits[<1]];
            if (!stuff) {
                return 0;
            }
        }
        _cur_desc = ({ });
        all_match = 0;
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (match) {
                all_match = 1;
                if (member_array(stuff[j+1], _cur_desc) == -1) {
                    _cur_desc += ({ stuff[j+1] });
                }
            }
        }
        if (all_match) {
            return this_object();
        } else {
            return 0;
        }
    }
    if (arr[P_THING] < 0) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (++arr[P_THING] != 0) {
                continue;
            }
            if (match) {
                _cur_desc = ({ stuff[j+1] });
                arr[P_THING] = -10321;
                return this_object();
            }
        }
        return 0;
    }
    stuff = _plural[bits[<1]];
    if (!stuff) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
    }
    _cur_desc = ({ });
    for (j = 0; j < sizeof(stuff); j += 2) {
        match = 1;
        for (i=0;i<sizeof(bits)-1;i++) {
            if ( member_array( bits[ i ], stuff[ j ] ) == -1 ) {
                match = 0;
                break;
            }
        }
        if (match) {
            if (member_array(stuff[j+1], _cur_desc) == -1) {
                _cur_desc += ({ stuff[j+1] });
            }
            arr[P_THING]--;
            if (arr[P_THING] <= 0) {
                arr[P_THING] = -10786;
                return this_object();
            }
        }
    }
    return 0;
}
mixed* parse_match_object(string* input,
                          object player,
                          class obj_match_context context) {
   int *stuff;
   mixed *plural;
   mixed *sing;
   string *its, *thems;
   string item;
   int i;
   int j;
   int match;
   int ret;
   if (input[<1] == "here" && sizeof(input) > 1) {
      input = input[0..<2];
   }
   if ( this_object() == context->it &&
        input[<1] == "it" ) {
      sing = ({ });
      its = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in its ) {
          if ( arrayp( _verb[ item ] ) ) {
             sing += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      plural = ({ });
   } else if( input[<1] == "them" &&
              context->plural &&
              member_array( this_object(), context->plural ) != -1) {
      plural = ({ });
      thems = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in thems ) {
          if ( arrayp( _verb[ item ] ) ) {
             plural += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      sing = ({ });
   } else {
      plural = _plural[input[<1]];
      sing = _verb[input[<1]];
   }
   if (!sizeof(plural) && !sizeof(sing)) {
      return 0;
   }
   stuff = ({ });
   for (i = 0; i < sizeof(sing); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], sing[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(sing[i+1], stuff) == -1) {
            stuff += ({ sing[i+1] });
            ret |= OBJ_PARSER_MATCH_SINGULAR;
         }
      }
   }
   for (i = 0; i < sizeof(plural); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], plural[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(plural[i+1], stuff) == -1) {
            stuff += ({ plural[i+1] });
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }
   if (sizeof(stuff)) {
       if (context->ordinal) {
          if (context->ordinal > sizeof(stuff)) {
             context->ordinal -= sizeof(stuff);
             return 0;
          }
          context->ignore_rest = 1;
          context->ordinal--;
          _cur_desc = stuff[context->ordinal..context->ordinal];
       } else if (context->number_included) {
          _cur_desc = stuff[0..context->number_included];
          context->number_included -= sizeof(stuff);
          if (context->number_included <= 0) {
             context->ignore_rest = 1;
          }
       } else if (ret & OBJ_PARSER_MATCH_PLURAL) {
          _cur_desc = stuff;
       } else {
          _cur_desc = stuff[0..0];
       }
       return ({ ret, ({ this_object() }) });
   } else {
      return 0;
   }
}
void dest_me() {
    destruct(this_object());
    return ;
}
void dwep() {
    destruct(this_object());
    return ;
}
int move() { return 1; }
int command_control(string command, object *indir, string id_arg,
  string ii_arg, string *args, string pattern) {
    int desc, size, num;
    mixed temp;
    if (!_other_things[command]) {
        return 0;
    }
    size = sizeof(_cur_desc);
    foreach (desc in _cur_desc) {
        temp = _other_things[command][desc];
        if (arrayp(temp)) {
            if (sizeof(temp) == 3 || (sizeof(temp) == 2 && !functionp(temp[0]))) {
                num += call_other(temp[0], temp[1], command, indir, id_arg,
                  ii_arg, args, pattern);
            }
            else {
                if (sizeof(temp) == 2 && functionp(temp[0])) {
                        num += evaluate(temp[0], command, indir, id_arg, ii_arg,
                            args, pattern);
                }
            }
        }
        else {
            if (functionp(temp)) {
                temp = evaluate(temp, command, indir, id_arg, ii_arg, args,
                    pattern);
            }
            if (stringp(temp)) {
                write(temp);
                num++;
                add_succeeded_mess(({ "", "$N $V $D.\n" }));
            }
            else {
                if ( intp( temp ) ) {
                    num += temp;
                }
            }
        }
    }
    return num;
}
mapping query_other_things() { return _other_things; }
mapping query_pattern() { return _pattern; }
string query_position_string(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_DESC];
        }
    }
    return 0;
}
int query_position_multiple(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_MULT];
        }
    }
    return 0;
}
mapping query_position_stuff() { return _position_stuff; }
int query_count()  {
   int i;
   int ret = 0;
   foreach (i in _cur_desc)  {
      ret += evaluate(_count[i]);
   }
   return ret;
}

==================================================
FILE: room/basic/linker.c
==================================================

#include <room.h>
nosave int av_flag, ad_flag, rm_flag;
string d_prep, s_prep, r_name, *rooms;
object room;
void setup_shadow(object thing, string *words, string word1,
  string word2, string word3) {
  shadow(thing, 1);
  room = thing;
  rooms = words;
  if(!word1) {
    d_prep = "into";
  } else {
    d_prep = word1;
  }
  if(!word2) {
    s_prep = "in";
  } else {
    s_prep = word2;
  }
  r_name = word3;
}
void destruct_shadow(object thing) {
  if(thing == this_object()) {
    destruct(this_object());
  } else {
    thing->destruct_shadow(thing);
  }
}
string *query_rooms() {
  return rooms;
}
string query_dynamic_preposition() {
  return d_prep;
}
string query_static_preposition() {
  return s_prep;
}
string query_room_name() {
  return r_name;
}
string area_name() {
  string *bits;
  if(r_name) {
    return r_name;
  }
  bits = explode((string)room->query_short(), " of ");
  if(sizeof(bits) > 1) {
    return bits[ sizeof( bits ) - 1];
  }
  return "the area";
}
string compose_start() {
  if(s_prep == "") {
    return capitalize((string)room->the_short());
  }
  return capitalize(s_prep)+" "+(string)room->the_short();
}
void event_person_say( object person, string start, string rest,
      string language, string accent ) {
   int i;
   if ( start[ 0 .. 3 ] == "the " )
      start = explode( (string)person->a_short(), " " )[ 0 ] +
            start[ 3 .. strlen( start ) - 1 ];
   for ( i = 0; i < sizeof( rooms ); i++ )
      if ( find_object( rooms[ i ] ) )
         all_inventory( find_object( rooms[ i ] ) )->event_person_say( person,
                compose_start() +", "+ start, rest, language, accent );
    room->event_person_say( person, start, rest, language, accent );
}
private string conjugate_verbs(string mess) {
  string *words, verb, part;
  int i;
  if(strsrch(mess, "$s") == -1)
    return mess;
  words = explode( mess, " " );
  for ( i = sizeof( words ) - 1; i > -1; i-- ) {
    if ( ( sscanf( words[ i ], "%s$s%s", verb, part ) == 2 ) &&
         ( ( part[ 0 ] < 97 ) || ( part[ 0 ] > 122 ) ) ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
    if ( sscanf( words[ i ], "%%%s%%%s", verb, part ) == 3 ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
  }
  return implode( words, " " );
}
void event_exit(object person, string message, object to) {
  int ad_flag, rm_flag, i;
  string arrive, direc, *exits, link_mess, *link_array;
  room->event_exit(person, message, to);
  if(!message) {
    return;
  }
  arrive = "";
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(to == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(arrayp(room->query_dest_other())) {
    if(member_array(direc, room->query_dest_other()) != -1) {
      i = member_array(direc, room->query_dest_other());
      link_array = room->query_dest_other()[i + 1][11];
    }
  }
  if(arrayp(link_array)) {
    link_mess = link_array[0];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));
    link_mess = conjugate_verbs(link_mess);
  }
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      if(to != find_object(rooms[i])) {
        tell_room(find_object(rooms[i]), link_mess);
      }
    }
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to == find_object(rooms[i])) {
      arrive = (string)to->query_dynamic_preposition()+" "+
        (string)to->the_short();
      rm_flag = 1;
    }
  }
  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ "+direc;
    message += " "+arrive;
    if(rm_flag) {
      message += ".\n";
    } else {
      message += "and $V$0=leaves,leave$V$ "+ area_name() +".\n";
    }
  } else {
    message = (string)person->a_short() +" $V$0=teleports,teleport$V$";
    if(rm_flag) {
      message += " "+ arrive +".\n";
    } else {
      message += " out of "+area_name()+".\n";
    }
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to != find_object(rooms[i])) {
      tell_room(find_object(rooms[i]), message);
    }
  }
}
void event_enter( object person, string message, object from ) {
  int ad_flag, rm_flag, i;
  string direc, *exits, link_mess, *link_array;
  room->event_enter(person, message, from);
  if(!message || !from) {
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(from == find_object(rooms[i])) {
      rm_flag = 1;
    }
  }
  if(rm_flag) {
    return;
  }
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(from == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(member_array(direc, room->query_dest_other()) != -1) {
    i = member_array(direc, room->query_dest_other());
    link_array = room->query_dest_other()[i + 1][11];
  }
  if(arrayp(link_array)) {
    link_mess = link_array[1];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));
    link_mess = conjugate_verbs(link_mess);
  }
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      tell_room(find_object(rooms[i]), link_mess);
    }
    return;
  }
  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ into "+
      area_name()+" from the "+direc+".\n";
  } else {
    message = (string)person->a_short()+
      " $V$0=teleports,teleport$V$ into "+area_name() +".\n";
  }
  for(i = 0; i < sizeof(rooms); i++) {
    tell_room(find_object(rooms[i] ), message);
  }
}
int query_linked() { return 1; }

==================================================
FILE: room/basic/multichatter.c
==================================================

#include <room.h>
nosave int off;
nosave object room;
nosave mixed *chats;
void set_chat_min_max( int min,int  max ) {
  if (chats) {
    chats[0]=min;
    chats[1]=max;
  }
}
void setup_chatter( object my_room,  mixed *chat_args ) {
   off = 1;
   room = my_room;
   if (sizeof(chats)) chats += chat_args + ({0,0});
   else chats = chat_args + ({0,0});
}
void dest_me() {
  destruct( this_object() );
}
int query_multichatter() { return 1; }
int check_interactive( object thing ) { return interactive( thing ); }
void make_chat() {
  int saying;
  string stuff;
  int set,nextt,t;
  if (!sizeof( filter_array( all_inventory( room ), "check_interactive",
        this_object() ) ) ) {
    off = 1;
    return;
  }
  nextt=2147483647;
  t=time();
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) {
      if (t>=chats[set+4]) {
        saying = random( sizeof( chats[ set+2 ] ) );
        if ( saying == chats[ set+3 ] )
        saying = ( saying + 1 ) % sizeof( chats[ set+2 ] );
        chats[ set+3 ] = saying;
        stuff = chats[ set+2 ][ saying ];
        if ( stuff[ 0 ] == '#' )
          call_other( room, stuff[ 1 .. 99 ] );
        else
          tell_room( room, chats[ set+2 ][ saying ] +"\n" );
        chats[ set+4 ]=time()+chats[ set ]
            +random(chats[ set+1 ] - chats[ set ] + 1)-4;
      }
      if (chats[ set+4 ]<nextt) nextt=chats[ set+4 ];
    }
  }
  if (nextt!=2147483647) {
    if ((nextt+=4-t)<5) nextt=5;
    ROOM_HANDLER->add_chatter( this_object(), nextt );
  }
}
void check_chat() {
  int set,t,nextt;
  if ( !off || !pointerp( chats ) )
      return;
  off = 0;
  t=time();
  nextt=2147483647;
  for (set=0; set<sizeof(chats); set+=5) {
    if (t>=chats[set+4]+chats[set]) chats[set+4]=t+random(chats[set+1]);
    if (chats[set+4]<nextt) nextt=chats[set+4];
  }
  if ((nextt+=4-t)<5) nextt=5;
  ROOM_HANDLER->add_chatter( this_object(), nextt );
}
void add_room_chats( string *new_chats ) {
   if (sizeof(new_chats)) {
     if (sizeof(chats[2])) chats[2] = chats[2] + new_chats;
     else chats[2]= new_chats;
   }
}
void remove_room_chats( string *dead_chats ) {
  int set;
  mixed *new_chats;
  new_chats=({ });
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) chats[set+2] = chats[set+2] - dead_chats;
    if (set==0 || sizeof(chats[set+2]))
       new_chats=new_chats+chats[(set)..(set+4)];
  }
  chats=new_chats;
}
mixed *query_room_chats() { return chats; }
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (!room) dest_me();
}

==================================================
FILE: room/basic/multiroom_situation_changer.c
==================================================

#include <am_time.h>
#include <situations.h>
#define RANDOM(a,b) ("/obj/handlers/random_num.c"->random(a,b))
#define MIN_DURATION  1
#define SECTOCHECK    15
#define INSTALLDELAY  15
#define MAXROOMS      30
nosave mapping roominfo;
nosave mixed *rooms;
nosave mapping sitdata;
int query_status() { return 1; }
int *query_current_situations(object room)
{
  if (!roominfo[file_name(room)]) return 0;
  return (roominfo[file_name(room)])[0];
}
void dest_me() {
  destruct(this_object());
}
void add_situation(int num, function *func, string startmess, string endmess,
                   string extralookstring, string *chats, mixed *add_items ) {
  if (!sizeof(sitdata))
    sitdata= ([ num :
              ({ startmess, endmess, extralookstring, chats, add_items, func }) ]);
  else
    sitdata+= ([ num :
               ({ startmess, endmess, extralookstring, chats, add_items, func }) ]);
}
void start_situation(int num, int do_start_mess, object room) {
  mixed *sdata;
  string *chats;
  mixed item,*items;
  int *currentsits;
  string *els;
  object chatter;
  if (!(sdata=sitdata[num]) || !room) return;
  if (!roominfo[file_name(room)]) roominfo[file_name(room)]=
                 ({ 0,0,0,0,60,120,1 });
  currentsits=(roominfo[file_name(room)])[0];
  els=(roominfo[file_name(room)])[1];
  if (!currentsits) currentsits=({ num });
  else currentsits=currentsits+({ num });
  if (sizeof(sdata[2])) {
    if (els && sizeof(els)) els+=({ sdata[2] });
    else {
      els=({ sdata[2] });
      room->add_extra_look(this_object());
    }
  }
  if (do_start_mess && sizeof(sdata[0]))
    tell_room(room, sdata[0]+"\n");
  chats=sdata[3];
  if (chats && sizeof(chats)) {
    if (!(chatter=room->query_chatter())) {
      room->room_chat( ({ (roominfo[file_name(room)])[4],(roominfo[file_name(room)])[5], chats }) );
      chatter=room->query_chatter();
      chatter->check_chat();
    }
    else chatter->add_room_chats(chats);
  }
  items=sdata[4];
  if (sizeof(items)) {
    foreach(item in items) room->add_item(item[0],item[1]);
  }
  if (sdata[5]) {
    if (functionp(sdata[5])) (*(sdata[5]))(num,do_start_mess);
    else if (arrayp(sdata[5]) && functionp((sdata[5])[0]))
      (*((sdata[5])[0]))(num,do_start_mess);
  }
  (roominfo[file_name(room)])[0]=currentsits;
  (roominfo[file_name(room)])[1]=els;
}
void end_situation(int num, object room) {
  mixed *sdata;
  string *chats;
  mixed item,*items;
  int *currentsits;
  string *els;
  object chatter;
  if (!(sdata=sitdata[num]) || !room) return;
  if (!roominfo[file_name(room)]) return;
  currentsits=(roominfo[file_name(room)])[0];
  els=(roominfo[file_name(room)])[1];
  if (currentsits) currentsits=currentsits-({ num });
  if (els && sizeof(sdata[2])) {
    els-=({ sdata[2] });
    if (!sizeof(els)) room->remove_extra_look(this_object());
  }
  chats=sdata[3];
  if (chats && sizeof(chats) && (chatter=room->query_chatter())) {
    chatter->remove_room_chats(chats);
  }
  items=sdata[4];
  if (sizeof(items)) {
    foreach(item in items) room->remove_item(item[0],item[1]);
  }
  if (sizeof(sdata[1]))
    tell_room(room,sdata[1]+"\n");
  if (sdata[5]) {
    if (arrayp(sdata[5]) && functionp((sdata[5])[1]))
      (*((sdata[5])[1]))(num);
  }
  (roominfo[file_name(room)])[0]=currentsits;
  (roominfo[file_name(room)])[1]=els;
}
void manage_situations(object room) {
  mixed *sit;
  int num,t,it,cnt,possible;
  int *currentsits,*newsits,*changes;
  int ttmp,tstep,offset,awake;
  mixed data;
  if (!room || !(data=roominfo[file_name(room)])) return;
  if (!sizeof(filter_array( all_inventory( room ),(: interactive($1) :)))) {
    (roominfo[file_name(room)])[6]=0;
    return;
  }
  currentsits=data[0];
  offset=data[2];
  awake=data[6];
  t=time()+offset;
  newsits=({});
  tstep=2147483647;
  cnt=0;
  foreach(sit in data[3]) {
    cnt++;
    ttmp=sit[1];
    it=t/ttmp;
    possible=0;
    if (sit[2]) {
      if (functionp(sit[2])) possible=(*(sit[2]))();
      else possible=sit[2];
      possible=
	(possible&(1<<((AM_TIME_HANDLER)->query_am_hour(it*ttmp-offset))))
	&&
	(RANDOM(1000,it*1147483647+cnt*2047483243) < sit[3]);
    }
    if (possible) {
      if (arrayp(sit[0])) {
	num=(sit[0]) [((t % ttmp)*sizeof(sit[0]))/ttmp];
	ttmp=ttmp/sizeof(sit[0]);
      }
      else num=sit[0];
      if (member_array(num,newsits)==-1) newsits=newsits+({ num });
    }
    if (ttmp<tstep) tstep=ttmp;
  }
  if (currentsits && sizeof(currentsits)) {
    changes=currentsits-newsits;
    if (sizeof(changes)) foreach(num in changes) {
      if (awake) call_out("end_situation",random(INSTALLDELAY),
        num,room);
      else end_situation(num,room);
    }
    changes=newsits-currentsits;
    }
  else changes=newsits;
  if (sizeof(changes)) foreach(num in changes) {
    if (awake) call_out("start_situation",random(INSTALLDELAY),
       num,awake,room);
    else start_situation(num,awake,room);
  }
  if ((tstep/=SECTOCHECK)>=MAXROOMS) tstep=MAXROOMS-1;
  if (!rooms[tstep]) rooms[tstep]=({ room });
  else rooms[tstep]=rooms[tstep]+({ room });
  (roominfo[file_name(room)])[6]=1;
}
void manage_rooms_situations() {
  object room,*current_rooms;
  current_rooms = rooms[ 0 ];
  rooms[ 0 .. <2 ] = rooms[ 1 .. <1 ];
  rooms[ <1 ] = 0;
  call_out("manage_rooms_situations",SECTOCHECK);
  if ( !pointerp( current_rooms ) ) return;
  foreach ( room in current_rooms ) manage_situations(room);
}
void check_situations(object room) {
  if (room && roominfo[file_name(room)]
    && !((roominfo[file_name(room)])[6])
    && interactive(this_player())) manage_situations(room);
}
void automate_situations(mixed *chatargs, int xval, int yval, mixed *edata,
  object room) {
  mixed sit;
  mixed *sittiming;
  int offset;
  offset=xval*38547+yval*1232444311;
  if ( pointerp(chatargs[2]) && sizeof(chatargs[2])) {
    room->room_chat( chatargs );
  }
  if (sizeof(edata)) {
    foreach(sit in edata) {
      if (sit[1]<MIN_DURATION) {
        write("Invalid situation duration: "+sit[1]+"\n");
        return;
      }
      sit[1]*=60;
      if (!sittiming) sittiming=({ sit });
      else sittiming=sittiming+({ sit });
    }
  }
  roominfo[file_name(room)]=({  0,0, offset, sittiming,
       chatargs[0], chatargs[1], 0 });
  manage_situations(room);
}
void shutdown_situations(object room) {
  int num, *currentsits;
  currentsits=(roominfo[file_name(room)])[0];
  if (currentsits && sizeof(currentsits)) {
    foreach(num in currentsits) end_situation(num, room);
  }
}
string extra_look(object room) {
  string *els;
  if (!roominfo[file_name(room)]) return "";
  els=(roominfo[file_name(room)])[1];
  if (!els || !sizeof(els)) {
    return "";
  }
  return implode(els,"  ")+"\n";
}
void create() {
   rooms = allocate( MAXROOMS );
   manage_rooms_situations();
   roominfo= ([ ]);
}
object *query_rooms() { return rooms; }

==================================================
FILE: room/basic/npcroom.c
==================================================

#define FLAG 0
#define DELAY 1
#define CLONE 2
#define MESS 3
#define REMOVABLE 0
#define FIXED 1
#define UNIQUE 2
nosave mixed  *reset_definitions;
nosave object *reset_objects;
void add_cloned_object( int flag, int delay, mixed clone_info,
                       string entry_mess ) {
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
}
mixed *query_cloned_objects() {
   return reset_objects + ({ });
}
mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
}
private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
}
private void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
}
void reset() {
   int i;
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] ||
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
      }
   }
}

==================================================
FILE: room/basic/situation_changer.c
==================================================

#include <am_time.h>
#include <situations.h>
#define RANDOM(a,b) ("/obj/handlers/random_num.c"->random(a,b))
class situation_timing {
  mixed label;
  mixed duration;
  mixed when;
  int chance;
  int *endat;
  mixed background;
  mixed category;
  int it;
  mapping it_data;
}
nosave int offset;
nosave string *els;
nosave mixed *currentsits,*autosits;
nosave mapping sitdata;
nosave mapping sitwords;
nosave class situation_timing *sittiming;
nosave int chatmin=60,chatmax=120;
nosave object ownerroom;
nosave int automate=0;
nosave mixed cco;
varargs mixed change_situation( mixed label, mixed duration,
  mixed words, mixed handle );
object set_room(object room_o) {
  ownerroom=room_o;
  return this_object();
}
object query_room() { return ownerroom; }
void choose_words( mixed label, mixed choice )
{
  int i;
  class situation sit;
  string *wc;
  sit = sitdata[ label ];
  if (sizeof(sit->random_words)) {
    if (!sitwords) sitwords= ([ ]);
    if (intp(choice)) {
      wc=({ });
      for (i=0;i<sizeof(sit->random_words);i++) {
        wc+=({ "#"+(i+1),
          ((sit->random_words)[i])[
          RANDOM(sizeof((sit->random_words)[i]),choice+i*3347483647)] });
      }
      sitwords[label] = wc;
    }
    else
      sitwords[label] = choice;
  }
}
string *insert_words_chats(class situation sit, string *words) {
  string *outarray=({ });
  string s1;
  if (!sizeof(sit->chats)) return ({ });
  foreach (s1 in sit->chats) outarray+= ({ replace(s1,words) });
  return outarray;
}
mixed *insert_words_items(class situation sit, string *words) {
  mixed *outarray=({ });
  mixed ai,e0,e1;
  if (!sizeof(sit->add_items)) return ({ });
  foreach (ai in sit->add_items) {
    if (sizeof(ai)>=2) {
      e0=ai[0];
      if (arrayp(e0)) e0=explode(lower_case(replace(implode(e0,"|"),words)),"|");
      else e0=lower_case(replace(e0,words));
      e1=ai[1];
      if (arrayp(e1)) e1=explode(replace(implode(e1,"|"),words),"|");
      else e1=replace(e1,words);
      ai = ({ e0,e1 })+ai[2..];
    }
    outarray+= ({ ai });
  }
  return outarray;
}
int query_status() { return automate; }
int *query_current_situations() { return ({ currentsits, autosits }); }
mixed *query_sittiming() { return sittiming; }
mapping query_situations() { return sitdata; }
void dest_me() {
  destruct(this_object());
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  return 1;
}
void add_situation( mixed label, class situation sit ) {
  if (!sizeof(sitdata)) {
    sitdata= ([ label : sit ]);
    sitwords= ([ ]);
  }
  else {
    sitdata+= ([ label : sit ]);
  }
}
void start_situation(mixed label, int do_start_mess) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;
  sdata=sitdata[ label ];
  words=sitwords[ label ];
  if (!currentsits) currentsits=({ label });
  else currentsits=currentsits+({ label });
  if (sizeof(sdata->extra_look)) {
    if (els && sizeof(els))
      els+=({ replace(sdata->extra_look,words) });
    else {
      els=({ replace(sdata->extra_look,words) });
      ownerroom->add_extra_look(this_object());
    }
  }
  if (do_start_mess && sizeof(sdata->start_mess))
    tell_room(ownerroom, replace(sdata->start_mess,words)+"\n");
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats)) {
    if (!(chatter=ownerroom->query_chatter())) {
      if (sdata->chat_rate) {
        ownerroom->room_chat( ({ chatmin,chatmax, ({ }) }),
                      clone_object("/std/room/basic/multichatter")  );
        chatter=ownerroom->query_chatter();
        chatter->setup_chatter( ownerroom,
        ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
      } else {
        ownerroom->room_chat( ({ chatmin,chatmax, chats }) );
        chatter=ownerroom->query_chatter();
      }
      chatter->check_chat();
    } else {
      if (sdata->chat_rate) {
        if (!(chatter->query_multichatter())) {
          mixed *args;
          args=(chatter->query_room_chats())[0..2];
          chatter->dest_me();
          ownerroom->room_chat( args,
                        clone_object("/std/room/basic/multichatter")  );
          chatter = ownerroom->query_chatter();
        }
        chatter->setup_chatter( ownerroom,
          ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
        chatter->check_chat();
      }
      else chatter->add_room_chats(chats);
    }
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) {
      ownerroom->add_item(item[0],item[1]);
    }
  }
  if (sdata->start_func) {
    (*(sdata->start_func))(label,do_start_mess,ownerroom);
  }
}
void end_situation(mixed label) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;
  sdata=sitdata[ label ];
  words=sitwords[ label ];
  if (currentsits) currentsits=currentsits-({ label });
  if (els && sizeof(sdata->extra_look)) {
    els-=({ replace(sdata->extra_look,words) });
    if (!sizeof(els)) ownerroom->remove_extra_look(this_object());
  }
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats) && (chatter=ownerroom->query_chatter())) {
    chatter->remove_room_chats(chats);
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) {
      if (arrayp(item[0]))
        ownerroom->remove_item((item[0])[0]);
      else
        ownerroom->remove_item(item[0]);
    }
  }
  if (sizeof(sdata->end_mess))
    tell_room(ownerroom,replace(sdata->end_mess,words)+"\n");
  if (sdata->end_func) {
    (*(sdata->end_func))(label,ownerroom);
  }
}
varargs mixed change_situation( mixed label, mixed duration,
     mixed words, mixed handle  ) {
  mixed frog,bing;
  mixed ending;
  if (!cco) cco=({ 1, 0 });
  if (!handle) {
    handle=member_array(0,cco[1..<1])+1;
    if (!handle) {
      cco+=({ 0 });
      handle=sizeof(cco)-1;
    }
  }
  cco[0]=handle;
  if (!duration) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    foreach(bing in frog) end_situation(bing);
    cco[handle]=0;
    return 0;
  }
  if (!arrayp(duration)) {
    if (arrayp(label)) {
      bing=duration/sizeof(label);
      duration=({ });
      foreach (frog in label) duration+=({ bing });
    }
    else duration=({ duration });
  }
  if (arrayp(label) && sizeof(label)>1 && sizeof(label)>sizeof(duration)) {
    frog=label[0];
    if (stringp(frog)) ending=explode(frog,",");
    else ending=({ frog });
    label=label[1..<1];
  }
  if (sizeof(duration)==1) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    if (ending) {
      ending-=frog;
      foreach(bing in ending) end_situation(bing);
    }
    if (currentsits) frog=frog-currentsits;
    foreach(bing in frog) {
      if (!sizeof(words)) choose_words( bing, time()*335423611 );
      else choose_words( bing, words );
      start_situation(bing,1);
    }
    if (duration[0]!=-1)
      cco[handle]=call_out("change_situation",duration[0],
                           label,0,words,handle);
    return handle;
  }
  if (arrayp(label)) frog=label[0];
  else frog=label;
  if (stringp(frog)) frog=explode(frog,",");
  else frog=({ frog });
  if (ending) {
    ending-=frog;
    foreach(bing in ending) end_situation(bing);
  }
  if (currentsits) frog=frog-currentsits;
  foreach(bing in frog) start_situation(bing,1);
  if (duration[0]!=-1)
    cco[handle]=
    call_out("change_situation",duration[0],
             label,duration[1..<1],words,handle);
  return handle;
}
int query_possible(class situation_timing sit, int it, int tod, int cnt)
{
  int possible;
  class situation_timing sit2;
  int cnt2,it2,tod2,possible2;
  if (functionp(sit->when)) possible=(*(sit->when))(tod);
  else possible=sit->when;
  possible=
    (possible&(1<<((AM_TIME_HANDLER)->query_am_hour(tod))))
    &&
    (RANDOM(1000,it*1147483647+cnt*2047483243) < sit->chance);
  if (possible && sit->category) {
    cnt2=0;
    foreach (sit2 in sittiming) {
      cnt2++;
      if (cnt2!=cnt && sit2->category == sit->category) {
	it2=(tod+offset+(cnt2*234231))/sit2->duration;
	tod2=it2*sit2->duration-offset-(cnt2*234231);
	if (functionp(sit2->when)) possible2=(*(sit2->when))(tod2);
	else possible2=sit2->when;
	possible2=
	  (possible2&(1<<((AM_TIME_HANDLER)->query_am_hour(tod2))))
	  &&
	  (RANDOM(1000,it2*1147483647+cnt2*2047483243) < sit2->chance);
	if (possible2 && (tod2<tod || (tod==tod2 && cnt2<cnt))) {
	  possible=0;
	  break;
	}
      }
    }
  }
  return possible;
}
void manage_situations() {
  class situation_timing sit;
  int t,t0,it,tod,cnt,possible,dt,tc,i;
  mixed label,lb;
  mixed *newsits;
  mixed *changes;
  mixed *background_on,*background_off;
  int ttmp,tstep;
  if (!automate) return;
  if (!sizeof(filter_array( all_inventory( ownerroom ),(: interactive($1) :)))) {
    automate=2;
    return;
  }
  t0=time()+offset;
  newsits=({});
  tstep=2147483648;
  background_on=({ });
  background_off=({ });
  cnt=0;
  foreach (sit in sittiming) {
    cnt++;
    t=t0+(cnt*234231);
    ttmp=sit->duration;
    it=t/ttmp;
    tod=it*ttmp-offset-(cnt*234231);
    possible=sit->it_data[ it ];
    if (undefinedp(possible)) {
      possible=query_possible(sit, it, tod, cnt);
      sit->it_data[ it ]=possible;
      if (!undefinedp(sit->it_data[ it-1 ]))
	map_delete(sit->it_data,it-1);
    } else {
    }
    if (possible) {
      if (sit->background) background_off+=explode(sit->background,",");
      if (arrayp(sit->label)) {
	dt=(t % ttmp);
	i=0;
	foreach (tc in sit->endat) {
	  if (tc>dt) break;
	  i++;
	}
	label=(sit->label)[i];
	ttmp=tc-dt;
      }
      else label=sit->label;
      if (stringp(label)) {
	label=explode(label,",");
	newsits=newsits+label;
	foreach(lb in label) choose_words(lb,it*1147483647+cnt*2047555777);
      }
      else {
	newsits=newsits+({ label });
	choose_words(label,it*1147483647+cnt*2047555777);
      }
    }
    else {
      if (sit->background) background_on+=explode(sit->background,",");
      possible=sit->it_data[ it+1 ];
      if (undefinedp(possible)) {
	possible=query_possible(sit, it+1, tod+sit->duration, cnt);
	sit->it_data[ it+1 ]=possible;
	if (!undefinedp(sit->it_data[ it-1 ]))
	  map_delete(sit->it_data,it-1);
      }
      if (possible)
	ttmp=ttmp-(t % ttmp);
      else
	ttmp=2*ttmp-(t % ttmp);
    }
    if (ttmp<tstep) tstep=ttmp;
  }
  call_out("manage_situations",tstep+1);
  newsits = newsits+(background_on-background_off);
  if (autosits && sizeof(autosits)) {
    changes=autosits-newsits;
    if (sizeof(changes)) {
      foreach(label in changes) end_situation(label);
      autosits=autosits-changes;
    }
    changes=newsits-autosits;
  }
  else changes=newsits;
  if (sizeof(changes)) {
    foreach(label in changes) start_situation(label,2-automate);
    if (autosits) autosits=autosits+changes;
    else autosits=changes;
  }
  automate=1;
}
void check_situations() {
  if (automate==2 && interactive(this_player())) manage_situations();
}
void make_seed(int xval, int yval) {
  offset=(xval*38547+yval*1232444311)>>2;
}
void automate_situation( mixed label, mixed duration, mixed when, mixed chance,
     mixed category ) {
  mixed chatargs,endat,background,labels;
  int i,d;
  string ook;
  if (!offset) {
    ook=file_name(ownerroom);
    if (!ook || ook=="") {
      write( "Bad file name" );
      return;
    }
    offset=1;
    foreach (i in ook) offset*=i;
    offset=(offset>>2)+1;
  }
  if (ownerroom->query_chatter()) {
    chatargs=(ownerroom->query_chatter())->query_room_chats();
    if (sizeof(chatargs)==3) {
      chatmin=chatargs[0];
      chatmax=chatargs[1];
    }
  }
  endat=({ });
  if (arrayp(duration)) {
    if (!arrayp(label) || sizeof(duration)!=sizeof(label)) {
      write("Duration must be an array of the same length as label");
      return;
    }
    d=0;
    labels=({ });
    for (i=0;i<sizeof(duration);i++) {
      if (duration[i]!=-1) {
	d+=duration[i];
        endat+=({ d });
	labels=labels+({ label[i] });
      }
      else {
	if (background) background=implode(explode(background,",")+({ label[i] }),",");
        else background=label[i];
      }
    }
  } else {
    labels=label;
    d=duration;
    if (arrayp(label)) {
      for (i=0;i<sizeof(label);i++) {
        endat+=({ ((i+1)*duration)/sizeof(label) });
      }
    } else {
      endat=({ duration });
    }
  }
  if (!sittiming)
    sittiming=
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  else
    sittiming=sittiming+
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  automate=2;
}
void shutdown_all_situations() {
  int label;
  mixed h;
  if (sizeof(cco)>1) {
    foreach (h in cco[1..<1]) {
       if (h) remove_call_out(h);
    }
  }
  cco=({ 0 });
  if (currentsits && sizeof(currentsits)) {
    foreach(label in currentsits) end_situation(label);
  }
  autosits=0;
  automate=0;
}
void shutdown_situation(int handle, mixed label) {
  mixed frog,bing;
  if (sizeof(cco)) {
    if (!handle) handle=cco[0];
    if (handle && cco[handle]) remove_call_out(cco[handle]);
    cco[handle]=0;
  }
  if (arrayp(label)) {
    frog=({ });
    foreach(bing in label) {
      if (stringp(bing)) frog+=explode(bing,",");
      else frog+=({ bing });
    }
  }
  else if (stringp(label)) label=explode(label,",");
  else label=({ label });
}
string extra_look() {
  if (!els || !sizeof(els)) {
    return "";
  }
  return implode(els,"  ")+"\n";
}

==================================================
FILE: room/basic/situation_changer_handler.c
==================================================

#include <situations.h>
inherit "/std/room/basic/situation_changer";
void add_situation( mixed label, class situation sit ) {
  if (!clonep()) ::add_situation( label, sit );
  else write("You can't add situations to a clone of this object.");
}
object set_room(object room_o) {
  if (clonep() ) {
    object base;
    base = find_object(base_name(this_object()));
    if (!base) {
      (base_name(this_object()))->parp();
      base = find_object(base_name(this_object()));
    }
    if (!(base->query_room())) {
      call_out( "dest_me", 2 );
      return room_o->set_situation_changer( base );
    }
    sitdata = base->query_situations();
  }
  return ::set_room( room_o );
}
void dest_me() {
  if (clonep()) ::dest_me();
  else if (sizeof(children(base_name(this_object())))==1) ::dest_me();
  return;
}
void create() {
  if (!clonep()) this_object()->setup_situations();
}

==================================================
FILE: room/basic/terrain.c
==================================================

#include <dirs.h>
#include <terrain.h>
string terrain_name;
object room;
void setup_shadow(object thing, string word) {
  shadow(thing, 1);
  TERRAIN_MAP->setup_location(thing, word);
  thing->add_property("terrain name", word);
  terrain_name = word;
  room = thing;
}
void destruct_shadow(object thing) {
  if (thing == this_object()) {
    TERRAIN_MAP->delete_cloned_location(terrain_name, file_name(room));
    destruct(this_object());
  } else {
    thing->destruct_shadow( thing );
  }
}
void event_exit(object thing, string message, object to) {
  if (!objectp(room)) {
    room = query_shadowing(this_object());
  }
  if (clonep(room)) {
    if (find_call_out("free_location") == -1) {
      call_out("free_location", 10);
    }
  }
  room->event_exit(thing, message, to);
}
void free_location() {
  if (sizeof(all_inventory(room)) || (int)this_object()->dont_free())
    return;
  TERRAIN_MAP->delete_cloned_location(terrain_name, file_name(room));
  room->dest_me();
}
void set_destination(string direc) {
  int i, j, delta, *co_ords, *new_co_ords = allocate(3);
  string dest_name;
  object destination;
  if ((i = member_array(direc, STD_ORDERS)) == -1) {
    return;
  }
  if (!objectp(room)) {
    room = query_shadowing(this_object());
  }
  dest_name = (string)room->query_destination(direc);
  delta = (int)room->query_room_size() + TERRAIN_MAP->get_room_size(dest_name);
  co_ords = room->query_co_ord();
  for (j = 0; j < 3; j++) {
    new_co_ords[j] = co_ords[j] - delta * STD_ORDERS[i+1][j];
  }
  destination = TERRAIN_MAP->find_location(terrain_name, new_co_ords);
  if (!destination) {
    return;
  }
  room->modify_exit(direc, ({ "dest", file_name(destination) }));
}
string query_quit_handler() { return TERRAIN_LOG; }
mixed *query_cloning_info() {
  return ({ TERRAIN_MAP, "find_location",
            terrain_name, (int *)room->query_co_ord() });
}

==================================================
FILE: room/basic/twilight.c
==================================================

#include <twilight.h>
#include <climate.h>
int last_updated;
mixed roomitems;
string *roomlong;
mixed roomchats;
object shadowed_obj;
void set_current_long();
string return_long( mixed desc );
void do_change();
void change( int time_now );
void create() {
  seteuid( (string)"/secure/master"->creator_file( file_name(
    this_object() ) ) );
}
void destruct_shadow( object thing ) {
  if( thing == this_object() )
    destruct( thing );
  else
    thing->destruct_shadow( thing );
}
void setup_shadow( object this_room ) {
  shadow( this_room, 1 );
  shadowed_obj = this_room;
  if( WEATHER_HANDLER->query_day() ) {
    call_out( "changing_to_day", 0, 1 );
    last_updated = DAY;
  } else {
    call_out( "changing_to_night", 0, 1 );
    last_updated = NIGHT;
  }
  roomitems = ({ ({ }), ({ }) });
  roomlong = allocate( 2 );
  roomlong = ({ 0, 0 });
  roomchats = allocate( 2 );
  WEATHER_HANDLER->weather_notify( this_room, NOTIFY_DAY );
}
void event_weather(int whats_changed) {
  if (WEATHER_HANDLER->query_day()) {
    if (last_updated == NIGHT)
      change( DAY );
  } else if (last_updated == DAY)
    change( NIGHT );
  shadowed_obj->event_weather( whats_changed );
}
void change( int time_now ) {
  int i;
  last_updated = time_now;
  set_current_long();
  for ( i = 0; i < sizeof( roomitems[ last_updated ] ); i += 2 )  {
    shadowed_obj->modify_item( roomitems[ last_updated ][ i ],
                               roomitems[ last_updated ][ i + 1 ] );
  }
  for ( i = 0; i < sizeof( roomitems[ 1 - last_updated ] ); i += 2 )  {
    if ( member_array( roomitems[ 1 - last_updated ][ i ],
                       roomitems[ last_updated ] ) == -1 )  {
      shadowed_obj->modify_item( roomitems[ 1 - last_updated ][ i ],
                                 "You can't see that now.\n" );
    }
  }
  shadowed_obj->stop_room_chats();
  if( sizeof(roomchats[last_updated]) )
    shadowed_obj->room_chat( roomchats[last_updated] );
  if( last_updated == DAY )
    shadowed_obj->changing_to_day( 0 );
  else
    shadowed_obj->changing_to_night( 0 );
}
void set_day_long( string str ) {
  roomlong[DAY] = str;
  set_current_long();
}
void set_night_long( string str ) {
  roomlong[NIGHT] = str;
  set_current_long();
}
void set_current_long() {
  if (roomlong[last_updated] != 0 && roomlong[last_updated] != "")
    shadowed_obj->set_long( roomlong[last_updated] );
}
varargs int add_day_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;
  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;
  roomitems[DAY] += ({ the_item, return_long( desc ) });
  if( last_updated == DAY )
    return this_object()->add_item( shorts, desc, no_plural );
  return 1;
}
varargs int add_night_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;
  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;
  roomitems[NIGHT] += ({ the_item, return_long( desc ) });
  if( last_updated == NIGHT )
    return shadowed_obj->add_item( shorts, desc, no_plural );
  return 1;
}
void room_day_chat( mixed *args ) {
  roomchats[DAY] = args;
  if( last_updated == DAY )
    shadowed_obj->room_chat( args );
}
void room_night_chat( mixed *args ) {
  roomchats[NIGHT] = args;
  if( last_updated == NIGHT )
    shadowed_obj->room_chat( args );
}
string return_long( mixed desc ) {
  int ma;
  if( !pointerp( desc ) )
    return (string)desc;
  ma = member_array( "long", desc );
  if( ma < 0 )
    return "Error: No long found.";
  return (string)desc[ma+1];
}
int query_time() { return last_updated; }
mixed query_roomitems() { return roomitems; }
string *query_roomlong() { return roomlong; }
mixed query_roomchats() { return roomchats; }

==================================================
FILE: room/basic/wall.c
==================================================

string *belows, death_mess, old_here;
mixed *bottom, *moves;
mixed ghost_action;
int no_drop;
object room;
void create() {
   belows = ({ });
   bottom = 0;
   ghost_action = 0;
   moves = ({ });
   no_drop = 0;
   death_mess = 0;
}
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   room = thing;
}
void destruct_shadow( object thing ) {
   if ( thing == this_object() )
      destruct( this_object() );
   else
      thing->destruct_shadow( thing );
}
string *query_belows() { return copy( belows ); }
mixed *query_bottom() { return copy( bottom ); }
mixed query_ghost_action() { return copy( ghost_action ); }
mixed *query_moves() { return copy( moves ); }
int query_no_drop() { return copy( no_drop ); }
string query_death_mess() { return death_mess; }
int query_at_bottom() { return !bottom; }
mixed *query_move( string word ) {
   int i;
   i = member_array( word, moves );
   if ( i == -1 )
      return 0;
   return moves[ i + 1 .. i + 3 ];
}
void calc_co_ord() {
   int i, delta, *co_ord;
   string word, other;
   room->calc_co_ord();
   if ( co_ord )
      return;
   foreach ( word in ({ "down", "up" }) ) {
      i = member_array( word, moves );
      if ( i == -1 )
         continue;
      other = moves[ i + 2 ];
      if ( !find_object( other ) )
         continue;
      co_ord = copy( (int *)other->query_co_ord() );
      if ( !co_ord )
         continue;
      delta = (int)room->query_room_size_array()[2] +
         (int)other->query_room_size_array()[2];
      if ( word == "down" )
         co_ord[ 2 ] += delta;
      else
         co_ord[ 2 ] -= delta;
      room->set_co_ord( co_ord );
      return;
   }
}
void set_wall( mixed *args ) {
   int i, j;
   mixed arg;
   for ( i = sizeof( args ) - 2; i > -1; i -= 2 ) {
      arg = args[ i + 1 ];
      switch ( args[ i ] ) {
         case "bottom" :
            bottom = arg;
            if ( ! no_drop ) {
                old_here = room->query_property( "here" );
                room->add_property( "here", "falling past you" );
            }
            break;
         case "below" :
            belows += arg;
            break;
         case "move" :
            j = member_array( arg[ 0 ], moves );
            if ( j == -1 )
               moves += arg;
            else
               moves[ j + 1 .. j + 3 ] = arg[ 1 .. 3 ];
            break;
         case "death mess" :
         case "death_mess" :
            death_mess = arg;
            break;
         case "ghost action" :
         case "ghost_action" :
             ghost_action = arg;
             break;
         case "no drop" :
         case "no_drop" :
             no_drop = arg;
             if ( bottom ) {
                 if ( old_here )
                     room->add_property( "here", old_here );
                 else
                     room->remove_property( "here" );
             }
             break;
      }
   }
}
void event_enter( object thing, string mess, object from ) {
   room->event_enter( thing, mess, from );
   if ( !living( thing ) && bottom && ( ! no_drop ) )
      call_out( "fall_down", 0, thing );
}
void fall_down( object thing ) {
   int damage;
   string word;
   if ( !thing )
      return;
   if ( environment( thing ) != room )
      return;
   damage = (int)room->query_room_size_array()[2];
   if ( sizeof( belows ) )
      foreach ( word in belows ) {
         tell_room( find_object( word ), (string)thing->a_short() +
               " $V$0=falls,fall$V$ past you and $V$0=is,are$V$ gone.\n" );
         damage += 2 * (int)word->query_room_size_array()[2];
      }
   if ( stringp( bottom ) ) {
      if ( living( thing ) )
         thing->move_with_look( bottom,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
      else
         thing->move( bottom,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
      return;
   }
   word = bottom[ 0 ];
   damage += (int)word->query_room_size_array()[2];
   if ( sizeof( bottom ) > 1 && stringp( bottom[ 1 ] ) )
      if ( living( thing ) )
         thing->move_with_look( word, call_other( word, bottom[ 1 ], thing,
               room ), "$N drop$s downwards out of sight." );
      else
         thing->move( word, call_other( word, bottom[ 1 ], thing, room ),
               "$N drop$s downwards out of sight." );
   else
      if ( living( thing ) ) {
         thing->move_with_look( word,
               "$N fall$s from above with a loud crunch.",
               "$N drop$s downwards out of sight." );
         damage *= bottom[ 1 ] * (int)thing->query_complete_weight();
         damage /= 10000;
         damage -= (int)thing->query_ac( "blunt", damage );
         if ( damage > 0 ) {
            if ( damage > thing->query_hp() ) {
               tell_object( thing, !death_mess ? "You hit the ground "
                  "with a sickening crunch.\n" : death_mess );
               thing->attack_by( room );
               thing->adjust_hp(-damage, room);
            } else {
               thing->adjust_hp(-damage, room);
               tell_object( thing, "Ouch, that hurt!\n" );
            }
         }
      } else
         thing->move( word,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
}

==================================================
FILE: room/basic/water.c
==================================================

#include <armoury.h>
#include <position.h>
#include <room.h>
#include <tasks.h>
#define ANCHOR_PROP "anchor"
#define GILLS_PROP "gills"
#define FLOATING_PROP "floating"
#define LIVES_IN_WATER_PROP "lives in water"
#define SWIMMING_SKILL "other.movement.swimming"
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define LIVING_WET_EFFECT "/std/effects/other/wetness"
#define SWIM_EFFECT "/std/effects/other/water_effect"
mixed query_property(string);
varargs mixed *query_dest_other(string);
varargs int add_property(string, mixed, int);
int modify_exit(mixed, mixed*);
string query_destination(string);
string *query_exits();
int set_water_light(int);
int query_my_light();
varargs string *query_dest_dir(object);
int lives_in_water( object ob );
varargs void soak(object, int);
object get_water();
int water_override(string);
int do_float();
int do_drift();
int do_swim();
int get_swim_enum(object);
int query_bottom();
int query_surface();
string get_exit_mess(object, string);
string get_enter_mess(object, string);
object query_above_room();
void update_water_light();
private string on_bottom = "lying on the bottom",
        non_float = "drifting nearby",
        floating = "floating nearby",
        sinking = "sinking nearby",
        s_in_mess = "$N sink$s $down$ from $F.",
        s_out_mess = "$N sink$s $down$.",
        f_in_mess = "$N float$s $up$ from $F.",
        f_out_mess = "$N float$s $up$.",
        c_in_mess = "$N $V$0=is,are$V$ swept in from $F by the current.",
        c_out_mess = "$N $V$0=is,are$V$ swept $T by the current.",
        up_dir = "up", down_dir = "down";
private int bottom = -1, surface = -1, clarity = 90, salinity = 0,
        turbulence = 100, update_light = 1, light_first_queried = 0,
        last_speech_volume = 0;
private mapping flows = ([ ]), exit_messes = ([ ]), enter_messes = ([ ]),
        origins = ([ ]);
string* query_default_search_description() {
   return ({
       "Funnily enough there is nothing interesting in the water.\n",
       "You search around and discover a whole bunch of water.\n",
       "You look up and down, left and right, then up and down again but "
       "all you can find is water.\n"
           });
}
mixed *query_default_position(object ob) {
  return ({SWIMMING, "%^BOLD%^You start to swim.%^RESET%^\n",
           "$C$"+ob->one_short()+" "
           "$V$0=starts,start$V$ to swim.\n"});
}
int is_allowed_position(string poss) {
  if (poss == SWIMMING) {
    return 1;
  }
  return 0;
}
void set_bottom_mess(string mess) {
  on_bottom = mess;
}
string query_bottom_mess() {
  return on_bottom;
}
void set_nonfloat_mess(string mess) {
   non_float = mess;
}
string query_nonfloat_mess() {
  return non_float;
}
void set_float_mess(string mess) {
  floating = mess;
}
string query_float_mess() {
  return floating;
}
void set_sinking_mess(string mess) {
  sinking = mess;
}
string query_sinking_mess() {
  return sinking;
}
void set_sink_in_mess(string mess) {
  s_in_mess = mess;
}
string query_sink_in_mess() {
  return replace(s_in_mess, ({"$down$", down_dir}));
}
void set_sink_out_mess(string mess) {
  s_out_mess = mess;
}
string query_sink_out_mess() {
  return replace(s_out_mess, ({"$down$", down_dir}));;
}
void set_float_in_mess(string mess) {
  f_in_mess = mess;
}
string query_float_in_mess() {
  return replace(f_in_mess, ({"$up$", up_dir}));
}
void set_float_out_mess(string mess) {
  f_out_mess = mess;
}
string query_float_out_mess() {
  return replace(f_out_mess, ({"$up$", up_dir}));
}
void set_sweep_in_mess(string mess) {
  c_in_mess = mess;
}
string query_sweep_in_mess() {
  return c_in_mess;
}
void set_sweep_out_mess(string mess) {
  c_out_mess = mess;
}
string query_sweep_out_mess() {
  return c_out_mess;
}
void set_up_dir(string dir) {
  up_dir = dir;
}
string query_up_dir() {
  return up_dir;
}
void set_down_dir(string dir) {
  down_dir = dir;
}
string query_down_dir() {
  return down_dir;
}
void set_bottom(int val) {
  bottom = val;
  if (bottom > 1 || bottom < -1) {
    bottom = 1;
  }
}
void set_surface(int val) {
  surface = val;
  if (surface > 1 || surface < -1) {
    surface = 1;
  }
}
void set_clarity(int how_clear) {
  clarity = how_clear;
  if (clarity > 100) {
    clarity = 100;
  }
  else if (clarity < 0) {
    clarity = 0;
  }
  if (!query_property("dark mess")) {
    if (clarity < 20) {
      add_property("dark mess", "The water here is very murky.");
    }
    else if (clarity < 50) {
      add_property("dark mess", "The water here is quite murky.");
    }
    else if (clarity < 80) {
      add_property("dark mess", "The water here is slightly murky.");
    }
  }
}
int query_clarity() {
  return clarity;
}
void set_turbidity(int how_murky) {
  set_clarity(100 - how_murky);
}
int query_turbidity() {
  return 100 - query_clarity();
}
void set_salinity(int how_salty) {
  salinity = how_salty;
  if (salinity > 100) {
    salinity = 100;
  }
  else if (salinity < 0) {
    salinity = 0;
  }
}
int query_salinity() {
  return salinity;
}
void set_turbulence(int how_turbulent) {
  turbulence = how_turbulent;
  if (turbulence < 0) {
    turbulence = 0;
  }
}
int query_turbulence() {
  return turbulence;
}
void set_use_surface_light(int val) {
  int surface_light;
  object above;
  update_light = 0;
  if (!val) {
    return;
  }
  above = query_above_room();
  if (!above) {
    set_water_light(0);
    return;
  }
  if (function_exists("query_day_light", above) ||
           above->water_surface_light_varies()) {
    update_light = 1;
    return;
  }
  if (function_exists("query_water_surface_light", above)) {
    surface_light = above->query_water_surface_light();
  }
  else {
    surface_light = above->query_my_light();
  }
  set_water_light(surface_light);
}
int query_water_surface_light() {
  update_water_light();
  return query_my_light()*query_clarity()/100;
}
int get_water_surface_light() {
  object above = query_above_room();
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    return above->query_water_surface_light();
  }
  return above->query_my_light();
}
void update_water_light() {
  if (!update_light) {
    return;
  }
  if (!light_first_queried) {
    set_use_surface_light(1);
    light_first_queried = 1;
    update_water_light();
    return;
  }
  set_water_light(get_water_surface_light());
}
void add_flow(string dir, int rate) {
  flows[dir] = rate;
}
void delete_flow(string dir) {
  map_delete(flows, dir);
}
mapping query_flows() {
  return copy(flows);
}
int query_flow(string dir) {
  return flows[dir];
}
int query_water_traction_bonus(object thing, int buoyancy) {
  if (buoyancy < 0) {
    buoyancy = -buoyancy;
    return buoyancy/3 + random(buoyancy/3);
  }
  return 0;
}
object query_above_room() {
  string destination = query_destination(up_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}
object query_below_room() {
  string destination = query_destination(down_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}
object query_surface_room() {
  object next;
  if (query_surface()) {
    return this_object();
  }
  next = query_above_room();
  if (next && next->query_water()) {
    return next->query_surface_room();
  }
  return 0;
}
object query_bottom_room() {
  object next;
  if (query_bottom()) {
    return this_object();
  }
  next = query_below_room();
  if (next && next->query_water()) {
    return next->query_bottom_room();
  }
  return 0;
}
void event_enter(object ob, string mess, object from)  {
  int effnum, buoyancy, *effects, *args;
  effects = ob->effects_matching(SWIM_EFFECT->query_classification());
  if (!effects || !sizeof(effects)) {
    if (from && !from->query_water() ) {
      if( !lives_in_water( ob ) )
        ob->add_effect(SWIM_EFFECT, 2);
    }
  }
  if ( !lives_in_water( ob ) ) {
      effnum = get_swim_enum(ob);
      args = ob->arg_of(effnum);
      if (living(ob) && query_surface() && !ob->query_property("dead") && from &&
               from->query_water() && !from->query_surface()) {
        if (args[1] < 150 || ob->query_property(GILLS_PROP)) {
          tell_object(ob, "You break the surface.\n");
        }
        else {
          tell_object(ob, "You break the surface and take a deep breath.\n");
        }
        if (args[1] != 0) {
          ob->set_arg_of(effnum, ({args[0], 0}));
        }
      }
  }
  if (!living(ob)) {
    buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
    if (buoyancy < 0 && query_bottom()) {
      ob->add_property("there", on_bottom);
    }
    else if (buoyancy >= 0 && (buoyancy > ob->query_property(ANCHOR_PROP)
           || query_surface())) {
      ob->add_property("there", floating);
    }
    else if (buoyancy < 0 && buoyancy < -ob->query_property(ANCHOR_PROP)) {
      ob->add_property("there", sinking);
    }
    else {
      ob->add_property("there", non_float);
    }
  } else {
    ob->return_to_default_position();
  }
}
varargs void soak(object ob, int ignore_location) {
  int wetness = 0, *effects;
  object env, water, *things;
  env = ob;
  if (!ignore_location) {
    while (env && env = environment(env)) {
      if (env == this_object()) {
        break;
      }
      if ((env->query_closed() && env->query_waterproof()) ||
           env->query_dry_cargo()) {
        env = 0;
        break;
      }
    }
  }
  if (!env) {
    return;
  }
  if (ob->query_property(FLOATING_PROP) && query_surface()) {
    return;
  }
  if (living(ob)) {
    if (ob->query_property("dead") || lives_in_water( ob ) ) {
      return;
    }
    effects = ob->effects_matching(LIVING_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(LIVING_WET_EFFECT, wetness);
    }
  }
  else if (ob->id("towel")) {
    effects = ob->effects_matching(OBJECT_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = 200*ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(OBJECT_WET_EFFECT, wetness);
    }
  }
  if (ob->query_max_volume() && !ob->query_closed() &&
           ob->query_max_volume() - ob->query_volume() > 0) {
    water = get_water();
    water->set_amount(ob->query_max_volume() - ob->query_volume());
    water->move(ob);
  }
  if (!(ob->query_closed() && ob->query_waterproof()) &&
           !ob->query_dry_cargo()) {
    things = all_inventory(ob);
    if (things && sizeof(things)) {
      map(things, (: soak($1, 1) :));
    }
  }
}
object get_water() {
  object water = ARMOURY->request_item("water");
  switch (query_clarity()) {
  case 0..20:
    water->set_short("very muddy water");
    water->add_adjective(({"very", "muddy"}));
    water->set_long("This is $amount_size$ of very muddy water.\n");
    return water;
  case 21..50:
    water->set_short("muddy water");
    water->add_adjective("muddy");
    water->set_long("This is $amount_size$ of muddy water.\n");
    return water;
  case 51..80:
    water->set_short("slightly muddy water");
    water->add_adjective(({"slightly", "muddy"}));
    water->set_long("This is $amount_size$ of slightly muddy water.\n");
  }
  switch (query_salinity()) {
  case 51..100:
    water->set_short("brine");
    water->add_alias("brine");
    water->set_long("This is $amount_size$ of very salty water.\n");
    return water;
  case 11..50:
    water->set_short("salty water");
    water->add_adjective("salty");
    water->set_long("This is $amount_size$ of salty water.\n");
  }
  return water;
}
int swim_exit(string dir, object ob, string mess) {
  int difficulty, buoyancy = 0, place, this_turb, gp_cost, effnum, *arg;
  string *places_to_go, *tm_messes;
  object destination;
  if (!living(ob) || ob->query_property("dead") || lives_in_water( ob ) ) {
    return 1;
  }
  effnum = get_swim_enum(ob);
  arg = ob->arg_of(effnum);
  if (-2 == arg[0]) {
    return 1;
  }
  difficulty = -flows[dir];
  buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
  if (ob->query_weight()) {
    buoyancy /= ob->query_weight();
  }
  places_to_go = query_dest_dir();
  place = member_array(dir, places_to_go);
  if (-1 == place || !(destination = load_object(places_to_go[place+1]))) {
    return 0;
  }
  if (dir == up_dir) {
    difficulty -= buoyancy + 50;
  } else if (dir == down_dir) {
    difficulty += buoyancy - 50;
  } else if (buoyancy < 0) {
    difficulty -= buoyancy/5;
  } else {
    difficulty += buoyancy/5;
  }
  if (query_bottom() && (!destination->query_water() ||
           destination->query_bottom())) {
    difficulty -= query_water_traction_bonus(ob, buoyancy);
  }
  this_turb = random(query_turbulence());
  difficulty += this_turb;
  if (arg[0] == -1) {
    difficulty -= 50;
  }
  if (!destination->query_water()) {
    difficulty -= 50;
  }
  difficulty *= SWIM_EFFECT->swim_difficulty(ob);
  difficulty /= 100;
  if (difficulty <= 0) {
    return 1;
  }
  if (arg[0] != -1) {
    gp_cost = difficulty/20;
    if (gp_cost > 50) {
      gp_cost = 50;
    }
    else if (gp_cost < 1) {
      gp_cost = 1;
    }
    if (ob->query_specific_gp("other") < gp_cost) {
      tell_object(ob, "You're too "+({"fatigued", "tired", "weary",
           "exhausted"})[random(4)]+" to swim "+dir+" at the moment.\n");
      notify_fail("");
      return 0;
    }
  }
  ob->adjust_gp(-gp_cost);
  switch (TASKER->perform_task(ob, SWIMMING_SKILL, difficulty,
           TM_CONTINUOUS)) {
  case AWARD:
    tm_messes = ({"You move more surely as you glide through the water.",
                  "You discover a more efficient stroke.",
                  "You find a better way to streamline your body.",
                  "You find a more efficient swimming rhythm.",
                  "You begin to move more confidently through the water."});
    tell_object(ob, "%^YELLOW%^"+tm_messes[random(sizeof(tm_messes))]+
           "%^RESET%^\n");
  case SUCCEED:
    return 1;
  }
  notify_fail("");
  if (dir == up_dir && buoyancy < -50) {
    tell_object(ob, "You struggle to leave "+up_dir+" but, with the load "
           "you're carrying, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+up_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (dir == down_dir && buoyancy > 50) {
    tell_object(ob, "You struggle to leave "+down_dir+" but, with your "
           "buoyancy, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+down_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (flows[dir] < 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway against the current.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway against the current.\n", ob);
    return 0;
  }
  if (this_turb > 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway in the turbulent waters.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway.\n", ob);
    return 0;
  }
  tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway.\n");
  tell_room(this_object(), "$C$"+ob->one_short()+" $V$0=struggles,struggle$V$ "
           "to leave "+dir+", but can't make any headway.\n", ob);
  return 0;
}
string query_death_reason() {
  return "drowning";
}
int add_exit(string direc, mixed dest, string type) {
    mixed *messy = query_dest_other(direc);
    if (messy && arrayp(messy[ROOM_ENTER]) && sizeof(messy[ROOM_ENTER]) == 2){
        origins[direc] = messy[ROOM_ENTER][1];
    }
    modify_exit(direc, ({"function", "swim_exit",
                       "exit mess", (: get_exit_mess($1, $(direc)) :),
                       "enter mess", (: get_enter_mess($1, $(direc)) :)}));
    if( direc == "down" ) {
        add_property("no burial", 1);
    }
}
string query_origin(string dir) {
  if (origins[dir]) {
    return origins[dir];
  }
  return "elsewhere";
}
void add_exit_mess(object ob, string mess) {
  exit_messes[file_name(ob)] = mess;
}
void add_enter_mess(object ob, string mess) {
  enter_messes[file_name(ob)] = mess;
}
string get_exit_mess(object ob, string direc) {
  string retval;
  if (retval = exit_messes[file_name(ob)]) {
    map_delete(exit_messes, file_name(ob));
    return retval;
  }
  return "$N $V$0=swims,swim$V$ $T.";
}
string get_enter_mess(object ob, string direc) {
  string retval;
  if (retval = enter_messes[file_name(ob)]) {
    map_delete(enter_messes, file_name(ob));
  }
  else if (direc == up_dir) {
    retval = "$N $V$0=swims,swim$V$ up from $F.";
  }
  else if (direc == down_dir) {
    retval = "$N $V$0=swims,swim$V$ down from $F.";
  }
  else {
    retval = "$N $V$0=swims,swim$V$ in from $F.";
  }
  retval = replace(retval, "$F", query_origin(direc));
  return retval;
}
void init()  {
  add_command("float", "", (: do_float() :));
  add_command("drift", "", (: do_drift() :));
  add_command("swim", "", (: do_swim() :));
}
string mangle_speech(string type, string words, mixed target) {
  int drown;
  string garbled = "";
  if (query_surface() || !this_player() ||
           this_player()->query_property("dead")) {
    return words;
  }
  switch (type) {
  case "whisper":
    drown = 20 + random(20);
    break;
  case "lsay":
  case "mock":
    drown = 80 + random(80);
    break;
  case "shout":
    drown = 120 + random(120);
    break;
  default:
    drown = 40 + random(40);
  }
  for (int inc = (strlen(words) / 10) + 1;inc > 0;--inc) {
    garbled += ({"blub", "glub", "gloog", "arrrble"})[random(4)]+" ... ";
  }
  if (drown > 70) {
    garbled = garbled[0..(strlen(garbled) - 6)]+"!";
  } else {
    garbled = garbled[0..(strlen(garbled) - 2)];
  }
  garbled = capitalize(garbled);
  last_speech_volume = drown;
  return garbled;
}
void event_person_say(object ob, string start, string mess, string lang,
           string accent) {
  int effnum, *args;
  if (!ob || ob->query_property("dead") || ob->query_property(GILLS_PROP) ||
      lives_in_water( ob ) || environment(ob) != this_object() || query_surface()) {
    last_speech_volume = 0;
    return;
  }
  if (!last_speech_volume) {
    last_speech_volume = 40 + random(40);
  }
  effnum = get_swim_enum(ob);
  args = ob->arg_of(effnum);
  args[1] += last_speech_volume;
  ob->set_arg_of(effnum, args);
  ob->adjust_tmp_con(-random((last_speech_volume / 50) + 1));
  switch (last_speech_volume) {
  case 0..30:
    tell_object(ob, "You inhale a bit of water.\n");
    break;
  case 31..80:
    tell_object(ob, "You inhale some water.\n");
    break;
  case 81..150:
    tell_object(ob, "You inhale a fair amount of water.\n");
    break;
  default:
    tell_object(ob, "You inhale about a lungful of water.\n");
  }
  last_speech_volume = 0;
}
int do_float()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already floating on the current.\n");
    }
    else {
      add_failed_mess("You are already floating freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to float freely on the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to float freely.\n", ""}));
  }
  return 1;
}
int do_drift()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already drifting with the current.\n");
    }
    else {
      add_failed_mess("You are already drifting freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to drift freely with the current.\n",
           ""}));
  }
  else {
    add_succeeded_mess(({"You begin to drift freely.\n", ""}));
  }
  return 1;
}
int do_swim()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already swimming against the current.\n");
    }
    else {
      add_failed_mess("You are already swimming.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({1, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to swim against the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to swim.\n", ""}));
  }
  return 1;
}
int get_swim_enum(object thing) {
  int *effects = thing->effects_matching(SWIM_EFFECT->query_classification());
  if (!effects || !sizeof(effects)) {
    thing->add_effect(SWIM_EFFECT, 1);
    effects = thing->effects_matching(SWIM_EFFECT->query_classification());
    call_out("soak", 1, thing);
  } else if (!random(50)) {
    call_out("soak", 1, thing);
  }
  return effects[0];
}
int query_bottom()  {
  if (bottom == -1) {
    return member_array(down_dir, query_exits()) == -1;
  }
  return bottom;
}
int query_surface() {
    if (surface == -1) {
        return member_array(up_dir, query_exits()) == -1;
    }
    return surface;
}
int query_underwater() {
  return !query_surface();
}
int query_water()  {
  return 1;
}
int lives_in_water( object ob ) {
  string race_ob = ob->query_race_ob();
  if ( !living( ob ) ) {
    return 0;
  }
  if(ob->query_property(LIVES_IN_WATER_PROP) ||
     ob->lives_in_water() ||
     (race_ob && race_ob->lives_in_water()))
    return 1;
  return 0;
}
string query_terrain_map_colour() { return "%^CYAN%^"; }

==================================================
FILE: room/basic/topography/fixed_shadow.c
==================================================

#include <dirs.h>
#include <room.h>
string topo_handler;
object fixed_room;
mapping topo_barriers = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
void set_area_handler(string s) { topo_handler = s; }
void set_topo_handler(string s) { topo_handler = s; }
string query_area_handler() { return topo_handler; }
string query_topo_handler() { return topo_handler; }
void add_topo_barriers(mapping m) { topo_barriers += m; }
mapping query_topo_barriers() { return topo_barriers; }
mixed query_topo_barrier(string direc) { return topo_barriers[direc]; }
int query_fixed_room() { return 1; }
varargs mixed *query_dest_other( string direc ) {
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return fixed_room->query_dest_other(direc);
  }
  ret = fixed_room->query_dest_other(direc);
  if (!sizeof(ret)) {
    return 0;
  }
  if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
  (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
    room = (topo_handler)->find_room_at_exit(this_object(),
                           dirs[direc], direc);
    if (!objectp(room)) {
      return 0;
    }
    ret[ROOM_DEST] = file_name(room);
  }
  return ret;
}
void attach(object ob) {
  shadow(ob);
  fixed_room = ob;
}
void add_topo_exits(string *other_exits, string other_types) {
  string s;
  foreach (s in other_exits) {
    if ((s == "compass4") || (s == "compass8")) {
      if (!this_object()->query_exit("north"))
        this_object()->add_exit("north", "/topography", other_types);
      if (!this_object()->query_exit("south"))
        this_object()->add_exit("south", "/topography", other_types);
      if (!this_object()->query_exit("east"))
        this_object()->add_exit("east", "/topography", other_types);
      if (!this_object()->query_exit("west"))
        this_object()->add_exit("west", "/topography", other_types);
      if (s == "compass8") {
        if (!this_object()->query_exit("northeast"))
          this_object()->add_exit("northeast", "/topography", other_types);
        if (!this_object()->query_exit("northwest"))
          this_object()->add_exit("northwest", "/topography", other_types);
        if (!this_object()->query_exit("southeast"))
          this_object()->add_exit("southeast", "/topography", other_types);
        if (!this_object()->query_exit("southwest"))
          this_object()->add_exit("southwest", "/topography", other_types);
      }
    } else {
      this_object()->add_exit(s, "/topography", other_types);
    }
  }
}

==================================================
FILE: room/topography/area/mountain.c
==================================================

inherit "/std/outsides/mountain";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, mountain::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, mountain::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "^";
}

==================================================
FILE: room/topography/area/outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, outside::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, outside::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return ".";
}

==================================================
FILE: room/topography/area/plain.c
==================================================

inherit "/std/outsides/plain";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, plain::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, plain::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return ".";
}

==================================================
FILE: room/topography/area/room.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, basic_room::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, basic_room::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "b";
}

==================================================
FILE: room/topography/area/water_inside.c
==================================================

inherit "/std/room/water_inside";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   mixed*fluff;
   fluff =  water_inside::query_dest_other(direc);
printf("%O\n", fluff);
   return aroom::query_dest_other(direc, fluff);
}
string query_look(string direc) {
   return aroom::query_look(direc, water_inside::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "~";
}

==================================================
FILE: room/topography/area/water_outside.c
==================================================

inherit "/std/room/water_outside";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   mixed*fluff;
   fluff =  water_outside::query_dest_other(direc);
printf("%O\n", fluff);
   return aroom::query_dest_other(direc, fluff);
}
string query_look(string direc) {
   return aroom::query_look(direc, water_outside::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "~";
}

==================================================
FILE: room/topography/area/woodland.c
==================================================

inherit "/std/outsides/woodland";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, woodland::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, woodland::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "%";
}

==================================================
FILE: room/topography/iroom/mountain.c
==================================================

inherit "/std/outsides/mountain";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/outside.c
==================================================

inherit "/std/outside";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/plain.c
==================================================

inherit "/std/outsides/plain";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/room.c
==================================================

inherit "/std/room";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/woodland.c
==================================================

inherit "/std/outsides/woodland";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/milestone/mountain.c
==================================================

inherit "/std/outsides/mountain";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/outside.c
==================================================

inherit "/std/outside";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/plain.c
==================================================

inherit "/std/outsides/plain";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/room.c
==================================================

inherit "/std/room";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/woodland.c
==================================================

inherit "/std/outsides/woodland";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/inherit/bath_house.c
==================================================

#include <effect.h>
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
#define WET_EFFECT "/std/effects/other/wetness"
protected int add_wash_effect( string classification, function func );
protected int add_finished_func( function func );
protected void advanced_antiseptic( object ob, string classification, mixed arg, int effect_enum, object effect_ob );
protected void basic_cleaning( object ob, int effect_enum, string message );
protected void apply_soap( object ob, string *applied_effects );
protected void wet_person( object ob, string *applied_effects );
private mapping _wash;
private function *_finished_funcs;
void create() {
    _wash = ([ ]);
    _finished_funcs = ({ });
    add_wash_effect( "body.smell", (: advanced_antiseptic :) );
    add_wash_effect( "misc.ketchup", (: basic_cleaning( $1, $3,
        "The soap rinses the ketchup off your face." ) :) );
    add_wash_effect( "object.label", (: basic_cleaning( $1, $3,
        "The labels stuck to your body peel off in the water." ) :) );
    add_wash_effect( "body.frog-adhesive", (: basic_cleaning( $1, $3,
        "The frantic ribbiting fades away as the frog adhesive washes "
        "off." ) :) );
    add_finished_func( (: apply_soap :) );
    add_finished_func( (: wet_person :) );
    this_object()->add_setup_wash_command();
}
void init() {
    this_object()->add_init_wash_command();
}
protected int add_wash_effect( string classification, function func ) {
    if ( !_wash[ classification ] ) {
        _wash[ classification ] = func;
        return 1;
    }
    return 0;
}
protected int add_finished_func( function func ) {
    _finished_funcs += ({ func });
    return 1;
}
public string *query_wash_classifications() {
    return keys( _wash );
}
protected int remove_wash_effect( string classification ) {
    if ( _wash && _wash[ classification ] ) {
        map_delete( _wash, classification );
        return 1;
    }
    return 0;
}
protected void advanced_antiseptic( object ob, string classification, int effect_enum, mixed arg, object effect_ob ) {
    tell_object( ob,
        "The antiseptic power of the soap defeats " +
        effect_ob->smell_string( ob, arg ) + ".\n" );
    ob->delete_effect( effect_enum );
}
protected void basic_cleaning( object ob, int effect_enum, string message ) {
    tell_object( ob, message + "\n" );
    ob->delete_effect( effect_enum );
}
protected void apply_soap( object ob, string *applied_effects ) {
    ob->add_effect( SOAP_EFFECT, 10000 );
}
protected void wet_person( object ob, string *applied_effects ) {
    ob->add_effect( WET_EFFECT, 250 );
}
public int wash_player( object ob ) {
    function func;
    string eff;
    string *cleaned;
    int *enums, eff_enum;
    cleaned = ({ });
    if ( !objectp( ob ) ) {
        return 0;
    }
    foreach( eff, func in _wash ) {
        enums = ob->effects_matching( eff );
        if ( sizeof( enums ) ) {
            foreach( eff_enum in enums ) {
                evaluate( func, ob, eff, eff_enum, ob->arg_of( eff_enum ),
                    ob->eff_of( eff_enum ) );
            }
            cleaned += ({ eff });
        }
    }
    foreach( func in _finished_funcs ) {
        evaluate( func, ob, cleaned );
    }
    return 1;
}
int query_baths() {
    return 1;
}

==================================================
FILE: room/inherit/club_control_room.c
==================================================

#include <clubs.h>
#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
inherit "/std/basic/club_listing";
inherit "/std/room/inherit/club_discuss";
private int _percentage_cut;
private int _room_type;
private string _region;
protected int do_create(string name);
protected int do_create_family(string name);
protected int do_replace(string name);
protected int do_vote(string name, string position, string club);
protected int do_nominate(string name, string position, string club);
protected int do_balance(string name);
protected int do_deposit(string mon, string name, string account, string reason);
protected int do_change(string name, string type);
protected int do_change_option(string name, string type);
protected int do_disband(string name);
protected int do_insignia(string number, int num);
protected int do_recruiter_add(string name, string recruit);
protected int do_recruiter_remove(string name, string recruit);
protected int do_financials(string name, string account);
protected int do_describe(string name);
protected int do_club_list_member(string name);
protected int do_withdrawl(string money, string club, string account, string reason);
protected int do_transfer(string money, string club, string from_account,
                          string to_account, string reason);
protected int do_force_election(string name);
protected void finish_description(string describe, string name);
protected int do_announcement(string name);
private int check_member_func(string club, string person, string mem);
mixed query_property(string name);
void add_help_file(string name);
void create() {
   _percentage_cut = 5;
   _room_type = CLUB_ROOM_CLUB_OR_FAMILY;
}
private int club_commands_allowed() {
   return _room_type != CLUB_ROOM_FAMILY_ONLY;
}
private int family_commands_allowed() {
   return _room_type != CLUB_ROOM_CLUB_ONLY;
}
void init() {
   string bit;
   if (club_commands_allowed()) {
      add_help_file("club_control_room");
      bit = "club name";
      add_command("create", "club called <string'club name'>",
                  (: do_create($4[0]) :));
      add_command("list", "clubs",
                  (: club_list(this_player()->query_name(), 0, 0) :) );
      add_command("list", "clubs [with member] <string'member name'>",
                  (: do_club_list_member($4[0]) :));
      add_command("list", "club <string'club name'>",
                  (: club_info($4[0], 1, this_player()->query_name()) :) );
      add_command("vote",
                  "<word'person'> for <string:small'position'> in <string'club name'>",
                  (: do_vote($4[0], $4[1], $4[2]) :));
      add_command("nominate",
                  "<word'person'> for <string:small'position'> in <string'club name'>",
                  (: do_nominate($4[0], $4[1], $4[2]) :));
      add_command("disband", "<string'club name'>", (: do_disband($4[0]) :));
      add_command("change", "<string'club name'> to {elected}",
                   (: do_change($4[0], "elected") :) );
      add_command("change", "<string'club name'> option {secret|open}",
                      (: do_change_option($4[0], $4[1]) :) );
      add_command("replace", "<number> insignia for <string'club name'>",
                      (: do_insignia($4[1], $4[0]) :));
      add_command("replace", "insignia for <string'club name'>",
                      (: do_insignia($4[0], 1) :));
      add_command("recruiter", "add <string'member'> for <string'club'>",
                      (: do_recruiter_add($4[1], $4[0]) :));
      add_command("recruiter", "remove <string'member'> for <string'club'>",
                      (: do_recruiter_remove($4[1], $4[0]) :));
      add_command("financials", "<string'club'>",
                      (: do_financials($4[0], CLUB_DEFAULT_ACCOUNT_NAME) :));
      add_command("financials", "<string'club'> account <string'account name'>",
                      (: do_financials($4[0], $4[1]) :));
      add_command("description", "of club <string'club name'>",
                   (: do_describe($4[0]) :));
      add_command("announce", "for club <string'club name'>",
                  (: do_announcement($4[0]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> for <string:small'reason'>",
                  (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> for <string:quoted'reason'>",
                  (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:small'reason'>",
                  (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:quoted'reason'>",
                  (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :));
      add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:small'reason'>",
                  (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :));
      add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:quoted'reason'>",
                  (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :));
      add_command("election", "force in <string'club'>",
                  (: do_force_election($4[0]) :));
      club_discuss::init();
   }
   if (family_commands_allowed()) {
      add_help_file("family_control_room");
      if (bit) {
         bit += "|family name";
      } else {
         bit = "family name";
      }
      add_command("create", "family called <string'family name'>",
                  (: do_create_family($4[0]) :));
      add_command("list", "families",
                  (: club_list(this_player()->query_name(), 1, 0) :) );
      add_command("list", "family <string'family name'>",
                  (: family_info($4[0], this_player()->query_name()) :) );
   }
   add_command("description", "of <string'" + bit + "'>",
                (: do_describe($4[0]) :));
   add_command("balance", "[of] <string'" + bit  +"'>",
               (: do_balance($4[0]) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'>",
               (: do_deposit($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, 0) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> for <string:small'reason'>",
               (: do_deposit($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> account <string'account name'>",
               (: do_deposit($4[0], $4[1], $4[2], 0) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> account <string'account name'> for <string:small'reason'>",
               (: do_deposit($4[0], $4[1], $4[2], $4[3]) :));
}
int is_valid_club_name(string name) {
   int i;
   if (strlen(name) > CLUB_MAX_NAME_LEN) {
      return 0;
   }
   for (i = 0; i < strlen(name); i++) {
      if (!((name[i] >= 'a' && name[i] <= 'z') ||
            (name[i] >= 'A' && name[i] <= 'Z') ||
            name[i] == '\'' ||
            name[i] == ' ' ||
            name[i] == '_')) {
          return 0;
       }
   }
   return 1;
}
void set_club_control_type(int room_type) {
   _room_type = room_type;
}
int query_club_control_type() {
   return _room_type;
}
void set_club_region(string region) {
   _region = region;
}
string query_club_region() {
   return _region;
}
protected int do_create(string name) {
   string place;
   if (CLUB_HANDLER->is_club(name)) {
      add_failed_mess("Cannot create '" + name + "' as the name already "
                      "exists.\n");
      return 0;
   }
   if (!is_valid_club_name(name)) {
      add_failed_mess("The club name '" + name + "' has invalid characters in "
                      "it.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (this_player()->query_value_in(place) < CLUB_STARTUP_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
                      " to start a club.\n");
      return 0;
   }
   write("It will cost you " +
         MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
         " to create a club.  Double check the capitalization of " +
         name + ", you cannot change it after it is created.  "
         "Do you wish to continue? ");
   input_to("confirm_create", 0, name);
   return 1;
}
protected void confirm_create(string str, string name) {
   object badge;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   str = lower_case(str);
   if (strlen(str) < 1 ||
       (str[0] != 'n' && str[0] != 'y' && str[0] != 'q')) {
      write("Please answer yes or no.\nDo you wish to continue creating "
            "the club " + name + " for " +
            MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
            "? ");
      input_to("confirm_create", 0, name);
      return ;
   }
   if (str[0] == 'n' || str[0] == 'q') {
      write("Aborted.\n");
      return ;
   }
   if (this_player()->query_value_in(place) < CLUB_STARTUP_COST) {
      write("Your money appears to have evaporated.  You need " +
                      MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
                      " to start a club.\nAborting club creation.\n");
      return 0;
   }
   if (CLUB_HANDLER->create_club(name,
                                 this_player()->query_name(),
                                 CLUB_PERSONAL,
                                 query_club_region())) {
      this_player()->pay_money(MONEY_HAND->create_money_array(CLUB_STARTUP_COST,
                                                           place), place);
      write("Created the club called '" + name + "'.\n");
      badge = clone_object(CLUB_BADGE);
      badge->set_club(name);
      if (badge->move(this_player()) == MOVE_OK) {
         if (!this_player()->wear_armour(badge)) {
            write("You notice a badge turn up and wear itself, this is your "
                  "membership badge.\n");
         } else {
            write("You notice a badge turn up and attempt to wear itself, "
                  "this is your membership badge.\n");
         }
      } else {
         badge->move(environment(this_player()));
         badge->set_worn_by(this_player());
         write("You notice a badge turn up and wear itself, this is your "
               "membership badge.\n");
      }
      event(users(), "inform", this_player()->query_cap_name() +
                     " created the club " + name, "club");
   }
}
int is_valid_family_name(string name) {
  if (PLAYER_HANDLER->test_user(lower_case(name))) {
    add_failed_mess("Cannot use the family name '" + name + "' since "
        "a player is already using it.\n");
    return 0;
  }
  if(!PLAYER_HANDLER->test_valid(name)) {
    add_failed_mess("The family name '" + name + "' is invalid.\n");
    return 0;
  }
  if (!is_valid_club_name(name)) {
    if (this_player()->query_creator()) {
      add_failed_mess("invalid.\n");
    }
    add_failed_mess("The family name '" + name + "' has invalid characters "
                    "in it.\n");
    return 0;
  }
  if (strlen(name) > MAX_FAMILY_NAME_LEN) {
    if (this_player()->query_creator()) {
      add_failed_mess("too long!\n");
    }
    add_failed_mess("The maximum length of a family name is " +
                    MAX_FAMILY_NAME_LEN + ".\n");
    return 0;
  }
  return 1;
}
protected int do_create_family(string name) {
   string place;
   if (CLUB_HANDLER->is_club(name)) {
      if (this_player()->query_creator()) {
         write("exist\n");
      }
      add_failed_mess("Cannot create '" + name + "' as the name already "
                      "exists.\n");
      return 0;
   }
   if(!is_valid_family_name(name))
     return 0;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (this_player()->query_value_in(place) < FAMILY_STARTUP_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(FAMILY_STARTUP_COST,
                                                     place) +
                      " to start a family.\n");
      return 0;
   }
   write("It will cost you " +
         MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
         " to create a family.  Do you wish to continue? ");
   input_to("confirm_create_family", 0, name);
   return 1;
}
protected void confirm_create_family(string str, string name) {
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   str = lower_case(str);
   if (strlen(str) < 1 ||
       (str[0] != 'n' && str[0] != 'y' && str[0] != 'q')) {
      write("Please answer yes or no.\nDo you wish to continue creating "
            "the family " + name + " for " +
            MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
            "? ");
      input_to("confirm_create_family", 0, name);
      return ;
   }
   if (str[0] == 'n' || str[0] == 'q') {
      write("Aborted.\n");
      return ;
   }
   if (this_player()->query_value_in(place) < FAMILY_STARTUP_COST) {
      write("Your money appears to have evaporated.  You need " +
            MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
            " to start a family.\nAborting family creation.\n");
      return 0;
   }
   if (CLUB_HANDLER->create_club(name,
                                 this_player()->query_name(),
                                 CLUB_FAMILY,
                                 query_club_region())) {
      if (this_player()->query_family_name()) {
         CLUB_HANDLER->move_family_member(this_player()->query_family_name(),
                                          this_player()->query_name(),
                                          name);
      } else {
         CLUB_HANDLER->add_member(name, this_player()->query_name());
      }
      this_player()->pay_money(MONEY_HAND->create_money_array(FAMILY_STARTUP_COST,
                                                              place), place);
      write("Created the family called '" + name + "'.\n");
      this_player()->set_family_name(name);
      event(users(), "inform", this_player()->query_cap_name() +
                     " created the family " + name, "club");
   }
}
protected int do_nominate(string person, string position, string club_name) {
   string our_name;
   our_name = this_player()->query_name();
   if (!CLUB_HANDLER->is_member_of(club_name, our_name)) {
      add_failed_mess("You can only nominate people in a club your a "
                      "member of.\n");
      return 0;
   }
   person = lower_case(person);
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      person = this_player()->expand_nickname(person);
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      add_failed_mess("You can only nominate people in the club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_election_in_progress(club_name)) {
      add_failed_mess("This club is not having an election right now.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_voting_in_progress(club_name)) {
      add_failed_mess("This club is not accepting nominations right now, "
                      "it is past the nomination phase.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club not in the nomination phase of "
                      "voting.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_valid_position(club_name, position)) {
      add_failed_mess("You must nominate them in a valid position.\n"
                      "Valid positions are " +
                      sort_and_capitalise(CLUB_HANDLER->query_valid_positions(club_name)) +
                      ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club is not accepting nominations for positions "
                      "right now.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_creator_club(club_name) &&
       PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You cannot nominate a creator to a position in a "
                      "non-creator club.\n");
      return 0;
   }
   if (CLUB_HANDLER->has_nominated_person(club_name,
                                           position,
                                           person,
                                           our_name)) {
      add_failed_mess("You have already nominated " + capitalize(person) +
                      " for the position " + capitalize(position) + " in '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
      return 0;
   }
   if (CLUB_HANDLER->nominate_person(club_name,
                                     position,
                                     person,
                                     our_name)) {
      add_succeeded_mess( ({
                      "$N nominated " + capitalize(person) + " to " +
            capitalize(position) + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n",
                      "$N nominated " + capitalize(person) + " to " +
            capitalize(position) + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n" }) );
      if (find_player(lower_case(person)) &&
          environment(find_player(lower_case(person))) != this_object()) {
         tell_object(find_player(lower_case(person)),
                     "You have a weird feeling that " +
                     this_player()->the_short() +
                     " just nominated you for " + capitalize(position) +
                     ".\n");
      }
      return 1;
   }
   add_failed_mess("Unable to nominate " + person + " to " +
                   position + " in '" +
                   CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   return 0;
}
protected int do_vote(string person, string position, string club_name) {
   string our_name;
   string *stuff;
   our_name = this_player()->query_name();
   if (!CLUB_HANDLER->is_member_of(club_name, our_name)) {
      add_failed_mess("You can only vote for people in a club you're a "
                      "member of.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      person = this_player()->expand_nickname(person);
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      add_failed_mess("You can only vote for people in the club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_election_in_progress(club_name)) {
      add_failed_mess("This club is not having an election at the moment.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club is accepting nominations right now, "
                      "it is not ready for votes.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_voting_in_progress(club_name)) {
      add_failed_mess("This club is not accepting votes right now.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_valid_position(club_name, position)) {
      add_failed_mess("You must vote for them in a valid position.\n"
                      "Valid positions are " +
                      sort_and_capitalise(CLUB_HANDLER->query_valid_positions(club_name)) +
                      ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_nominated_for(club_name, position, person)) {
      stuff =  CLUB_HANDLER->query_nominated_for(club_name, position);
      if (sizeof(stuff)) {
         add_failed_mess("You must vote for a person that has been "
                         "nominated for the position.\n" +
                         sort_and_capitalise(stuff) +
                         " have been nominated for " + position + " in " +
                         club_name + ".\n");
      } else {
         add_failed_mess("No one has been nominated for the position "
                         + position + " in " + club_name + ".\n");
      }
      return 0;
   }
   if (CLUB_HANDLER->has_person_voted(club_name, position, our_name)) {
      add_failed_mess("You can only vote for each position once.\n");
      return 0;
   }
   if (CLUB_HANDLER->vote_for_person(club_name,
                                     position,
                                     person,
                                     our_name)) {
      add_succeeded_mess(({
                      "$N vote for $C$" + person + " to " + position + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n",
                      "$N voted for " + position + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n" }));
      return 1;
   }
   add_failed_mess("Unable vote for " + person + " to " +
                   position + " in " + club_name +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
   return 0;
}
protected int do_balance(string name) {
   string place;
   int amount;
   string bit;
   string *accounts;
   string account;
   string account_name;
   string ret;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must get a balance of an existing " + bit + ".\n");
      return 0;
   }
   if (CLUB_HANDLER->is_family(name)) {
      bit = "family";
   } else {
      bit = "club";
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to get the balance.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   accounts = CLUB_HANDLER->query_account_names(name);
   ret = "";
   foreach (account in accounts) {
      if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
         account_name = "main " + bit + " account";
      } else {
         account_name = "special " + bit + " account " + account;
      }
      amount = CLUB_HANDLER->query_balance(name, account);
      if (amount < 0) {
         ret += "The balance of the " + account_name + " in '" +
                CLUB_HANDLER->query_club_name(name) +
                "' is in remission by " +
                MONEY_HAND->money_value_string(-amount, place) + ".\n";
      } else {
         ret += "The balance of the " + account_name + " in '" +
                CLUB_HANDLER->query_club_name(name) + "' is " +
                MONEY_HAND->money_value_string(amount, place) + ".\n";
      }
   }
   ret += "The next pay period ends at " +
          ctime(CLUB_HANDLER->query_time_fees_due(name)) +
          ", which will cost " +
          MONEY_HAND->money_value_string(CLUB_HANDLER->query_club_cost_per_period(name), place) + " from the main " + bit + " account.\n",
   add_succeeded_mess(({ ret,
                      "$N checks the balance of '" +
                      CLUB_HANDLER->query_club_name(name) + "'.\n" }));
   return 1;
}
protected int do_deposit(string mon, string name, string account, string reason) {
   int amt;
   int after;
   int total;
   string place;
   mixed money;
   string bit;
   string account_name;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must deposit into an existing " + bit + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to deposit into the clubs coffers.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_creator_club(name) &&
       this_player()->query_creator()) {
      add_failed_mess("Creators can only deposit to creator " + bit + "s.\n");
      return 0;
   }
   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main " + bit + " account";
   } else {
      account_name = "special " + bit + " account " + account;
   }
   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   money = MONEY_HAND->parse_money(mon, this_player(), place);
   if (intp(money)) {
      switch (money) {
         case NO_MATCH :
            add_failed_mess("You do not have '" + mon + "'.\n");
            return 0;
         case NO_MONEY :
            add_failed_mess("You can only deposit money.\n");
            return 0;
         default :
            add_failed_mess("You can only deposit legal tender.\n");
            return 0;
      }
   }
   amt = money->query_value_in(place);
   if (place != "default") {
      amt += money->query_value_in("default");
   }
   after = amt - ((amt * _percentage_cut) / 100);
   CLUB_HANDLER->add_money(name,
                           after,
                           CLUB_TRANSACTION_DEPOSIT,
                           this_player()->query_name(),
                           account,
                           reason);
   total = CLUB_HANDLER->query_balance(name, account);
   money->move("/room/rubbish");
   add_succeeded_mess(({ "$N deposit " +
                         MONEY_HAND->money_value_string(amt, place) +
                         ", which after expenses is " +
                         MONEY_HAND->money_value_string(after, place) +
                         ", to the " +
                         (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                         " '" +
                         CLUB_HANDLER->query_club_name(name) +
                         "' for a total of " +
                         MONEY_HAND->money_value_string(total, place) + ".\n",
                         "$N deposits some money to the " +
                         (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                         " '" +
                         CLUB_HANDLER->query_club_name(name) +
                         "'.\n" }));
   return 1;
}
protected int do_withdrawl(string money,
                           string name,
                           string account,
                           string reason) {
   string place;
   int value;
   string bit;
   object obj;
   string account_name;
   string* stuff;
   string ret;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must withdraw from an existing " + bit + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to withdraw money from the club.\n");
      return 0;
   }
   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main " + bit + " account";
   } else {
      account_name = "special " + bit + " account " + account;
   }
   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }
    if(!CLUB_HANDLER->is_elected_club(name)) {
        add_failed_mess("You may only withdraw funds from an elected "
            "club.\n");
        return 0;
    }
   if (!CLUB_HANDLER->is_allowed_to_modify_account(name,
                                                   account,
                                                   this_player()->query_name())) {
      stuff = CLUB_HANDLER->query_account_allowed_positions(name, account);
      ret = "Only the positions " + query_multiple_short(stuff);
      stuff = CLUB_HANDLER->query_account_allowed_people(name, account);
      if (sizeof(stuff)) {
         ret += " and the people " + query_multiple_short(stuff);
      }
      add_failed_mess(ret + " can withdraw from this account.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = MONEY_HAND->value_from_string(money, place);
   if (value > CLUB_HANDLER->query_balance(name, account)) {
      add_failed_mess("The " + account_name +
                      " does not have that much money!\n");
      return 0;
   }
   obj = MONEY_HAND->make_new_amount(value, place);
   if (!obj) {
      add_failed_mess("Unable to create the money object.\n");
      return 0;
   }
   if (CLUB_HANDLER->remove_money(name,
                              value,
                              CLUB_TRANSACTION_WITHDRAWL,
                              this_player()->query_name(),
                              account,
                              reason)) {
      obj->move(this_player());
      add_succeeded_mess(({ "$N withdraw " +
                            MONEY_HAND->money_value_string(value, place) +
                            " from the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n",
                            "$N withdraws some money from the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n" }));
      return 1;
   } else {
      obj->dest_me();
      add_failed_mess("Unable to remove the money from the account.\n");
      return 0;
   }
}
protected int do_transfer(string money,
                           string name,
                           string from_account,
                           string to_account,
                           string reason) {
   string place;
   int value;
   string bit;
   object obj;
   string from_account_name;
   string to_account_name;
   string* stuff;
   string ret;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must transfer money in an existing " + bit + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to transfer money.\n");
      return 0;
   }
   if (from_account == CLUB_DEFAULT_ACCOUNT_NAME) {
      from_account_name = "main " + bit + " account";
   } else {
      from_account_name = "special " + bit + " account " + from_account;
   }
   if (to_account == CLUB_DEFAULT_ACCOUNT_NAME) {
      to_account_name = "main " + bit + " account";
   } else {
      to_account_name = "special " + bit + " account " + to_account;
   }
   if (!CLUB_HANDLER->is_account_of(name, from_account)) {
      add_failed_mess("The account " + from_account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_account_of(name, to_account)) {
      add_failed_mess("The account " + to_account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_allowed_to_modify_account(name,
                                                   from_account,
                                                   this_player()->query_name())) {
      stuff = CLUB_HANDLER->query_account_allowed_positions(name, from_account);
      ret = "Only the positions " + query_multiple_short(stuff);
      stuff = CLUB_HANDLER->query_account_allowed_people(name, from_account);
      if (sizeof(stuff)) {
         ret += " and the people " + query_multiple_short(stuff);
      }
      add_failed_mess(ret + " can withdraw from this account.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = MONEY_HAND->value_from_string(money, place);
   if (value > CLUB_HANDLER->query_balance(name, from_account)) {
      add_failed_mess("The " + from_account_name +
                      " does not have that much money!\n");
      return 0;
   }
   if (CLUB_HANDLER->remove_money(name,
                              value,
                              CLUB_TRANSACTION_TRANSFER,
                              this_player()->query_name(),
                              from_account,
                              "to " + to_account_name + ": " + reason)) {
      CLUB_HANDLER->add_money(name,
                              value,
                              CLUB_TRANSACTION_TRANSFER,
                              this_player()->query_name(),
                              to_account,
                              "from " + from_account_name + ": " + reason);
      add_succeeded_mess(({ "$N transfer " +
                            MONEY_HAND->money_value_string(value, place) +
                            " between the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "' accounts " + from_account_name + " and " +
                            to_account_name + ".\n",
                            "$N transfers some money between accounts in the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n" }));
      return 1;
   } else {
      obj->dest_me();
      add_failed_mess("Unable to remove the money from the account.\n");
      return 0;
   }
}
private void do_change_inform(string club_name) {
   object *people;
   object person;
   people = map(CLUB_HANDLER->query_members(club_name), (: find_player :));
   people -= ({ 0 });
   foreach (person in people) {
      all_inventory(person)->event_club_change(this_player(), club_name);
   }
}
protected int do_change(string name, string type) {
   int ret;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must change a club that exists.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a founder type before you can change "
                      "it to another type.\n");
      return 0;
   }
   switch (type) {
      case "elected" :
         if (CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
            if (sizeof(CLUB_HANDLER->query_members(name)) <
                CLUB_MINIMUM_ELECTED_MEMBERS) {
               add_failed_mess("You must have at least " +
                               query_num(CLUB_MINIMUM_ELECTED_MEMBERS) +
                               " members to change to an elected club.\n");
            } else if (CLUB_HANDLER->change_club_type(name, CLUB_ELECTED)) {
               ret = 1;
               add_succeeded_mess("$N change$s the type of '" +
                                  CLUB_HANDLER->query_club_name(name) +
                                  "' to elected.\n");
               call_out((: do_change_inform :), 0, name);
            } else {
               add_failed_mess("You are unable to change the club type.\n");
            }
         } else {
            add_failed_mess("You must be the founder to change the "
                            "club type.\n");
         }
         break;
   }
   return ret;
}
protected int do_change_option(string name, string option) {
   int ret;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must change a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You must change options through discussion items.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to change the "
                      "options of the club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a personal club before the options "
                      "can be changed in this way.\n");
      return 0;
   }
   switch (option) {
      case "secret" :
         if (CLUB_HANDLER->set_club_secret(name)) {
            add_succeeded_mess("$N wipe$s the records on the club '" +
                            CLUB_HANDLER->query_club_name(name) + "'.\n");
            ret = 1;
         } else {
            add_failed_mess("Unable to change the club to a secret type.\n");
         }
         break;
      case "open" :
         if (CLUB_HANDLER->reset_club_secret(name)) {
            add_succeeded_mess("$N replace$s the records of the club '" +
                            CLUB_HANDLER->query_club_name(name) + "'.\n");
            ret = 1;
         } else {
            add_failed_mess("Unable to change the club to an open type.\n");
         }
         break;
   }
   return ret;
}
protected int do_disband(string name) {
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must disband a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You cannot disband an elected club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a personal club type for you to "
                      "be able to disband it.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to disband it.\n");
      return 0;
   }
   write("Are you sure you wish to disband the club '" +
         CLUB_HANDLER->query_club_name(name) +
         "'? ");
   input_to("disband_confirm", 0, name);
   add_succeeded_mess("");
   return 1;
}
protected void disband_confirm(string str, string name) {
   string club_name;
   str = lower_case(str);
   if (str == "" ||
       str[0] == 'n' ||
       str[0] == 'q') {
      write("Canceling disbanding of the club '" + name + "'.\n");
      return ;
   }
   if (str[0] == 'y') {
      if (!CLUB_HANDLER->is_club(name)) {
         write("The club appears to have been disbanded already.\n");
         return 0;
      }
      if (CLUB_HANDLER->is_elected_club(name)) {
         write("The club has changed to an elected club and you cannot "
               "disband it.\n");
         return 0;
      }
      if (!CLUB_HANDLER->is_personal_club(name)) {
         write("The club must be a personal club for you to be able to "
                         "disband it.\n");
         return 0;
      }
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         write("You must be the founder of the club to disband it.\n");
         return 0;
      }
      club_name = CLUB_HANDLER->query_club_name(name);
      CLUB_HANDLER->disband_club(name);
      write("You disband the club '" + club_name + "'.\n");
      say(this_player()->the_short() + " disbands the club '" +
                      club_name + "'.\n");
   } else {
      write("You must answer yes or no.\n");
      write("Are you sure you wish to disband the club '" +
            CLUB_HANDLER->query_club_name(name) +
            "'? ");
      input_to("disband_confirm", 0, name);
   }
}
protected int do_insignia(string name, int num) {
   int i;
   object *insignias;
   object ob;
   string place;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must create the insignia for a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_family(name)) {
      add_failed_mess("You cannot create insignia for a family.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the club to create the "
                      "insignia for it.\n");
      return 0;
   }
   if (num > 1 &&
       !CLUB_HANDLER->is_recruiter_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a recruiter to ask for more than one "
                      "insignia.\n");
      return 0;
   }
   if (num > 20) {
      add_failed_mess("You cannot ask for more than 20 insignia.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (this_player()->query_value_in(place) < (num * CLUB_COST_INSIGNIA)) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(CLUB_COST_INSIGNIA * num, place) +
                      " to pay for " +
                      query_num(num) + " insignia.\n");
      return 0;
   }
   insignias = ({ });
   for (i = 0; i < num; i++) {
      ob = clone_object(CLUB_HANDLER->query_insignia_path(name));
      ob->set_cond(ob->query_max_cond());
      ob->set_club(name);
      if (ob->move(this_player()) == MOVE_OK) {
         insignias += ({ ob });
         this_player()->pay_money(MONEY_HAND->create_money_array(CLUB_COST_INSIGNIA,
                                                           place), place);
      } else {
         ob->dest_me();
      }
   }
   if (!sizeof(insignias)) {
      add_failed_mess("Unable to move the insignia into your inventory, "
                      "insignia not created.\n");
      return 0;
   } else {
      add_succeeded_mess("$N create$s " + query_num(sizeof(insignias)) +
                         " club '" + CLUB_HANDLER->query_club_name(name) +
                         "' insignia.\n");
      return 1;
   }
}
protected int do_recruiter_remove(string name,
                                  string recruit) {
   string *all_names;
   string one_name;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must remove a recruiter to a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name)) {
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         add_failed_mess("Only the founder can remove recruiters.\n");
         return 0;
      }
   } else if (CLUB_HANDLER->is_elected_club(name)) {
      if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(name, this_player()->query_name())) {
         add_failed_mess("Only the president and vice president can remove "
                         "recruiters.\n");
         return 0;
      }
   } else {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }
   all_names = map(explode(recruit, ","),
                   (: this_player()->expand_nickname($1) :));
   if (recruit == "all") {
      all_names = CLUB_HANDLER->query_recruiters(name);
   }
   foreach (one_name in all_names) {
      if (!CLUB_HANDLER->is_recruiter_of(name, one_name)) {
         add_failed_mess("The person(s) you are removeing must be a recruiter "
                         " of the club.\n");
         all_names -= ({ name });
         continue;
      }
      CLUB_HANDLER->remove_recruiter(name, one_name);
      one_name = lower_case(one_name);
      if (find_player(one_name) &&
          environment(find_player(one_name)) != this_object()) {
         tell_object(find_player(one_name), "You feel suddenly feel like "
                     "you are unable to "
                     "recruit people into the club '" +
                     CLUB_HANDLER->query_club_name(name) +
                     "'.\n");
      }
   }
   if (!sizeof(all_names)) {
      return 0;
   }
   add_succeeded_mess("$N remove$s " + query_multiple_short(all_names) +
                      " as " +
                      (sizeof(all_names) > 1 ? "recruiters " : "a recruiter ") +
                      "to the club '" + CLUB_HANDLER->query_club_name(name) +
                      "'.\n");
   return 1;
}
protected int do_recruiter_add(string name, string recruit) {
   string *all_names;
   string one_name;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must add a recruiter to a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name)) {
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         add_failed_mess("Only the founder can add recruiters.\n");
         return 0;
      }
   } else if (CLUB_HANDLER->is_elected_club(name)) {
      if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(name, this_player()->query_name())) {
         add_failed_mess("Only the president and vice president can add "
                         "recruiters.\n");
         return 0;
      }
   } else {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }
   all_names = map(explode(recruit, ","),
                   (: this_player()->expand_nickname($1) :));
   if (recruit == "all") {
      all_names = CLUB_HANDLER->query_members(name);
   }
   foreach (one_name in all_names) {
      if (!CLUB_HANDLER->is_member_of(name, one_name)) {
         add_failed_mess("The person you are making a recruiter must be a "
                         "member of the club.\n");
         all_names -= ({ one_name });
         continue;
      }
      if (CLUB_HANDLER->is_recruiter_of(name, one_name)) {
         add_failed_mess("The person you are making a recruiter is already a "
                         "recruiter of the club.\n");
         all_names -= ({ one_name });
         continue;
      }
      CLUB_HANDLER->add_recruiter(name, one_name);
      one_name = lower_case(one_name);
      if (find_player(one_name) &&
          environment(find_player(one_name)) != this_object()) {
         tell_object(find_player(one_name), "You feel suddenly empowered to "
                     "recruit people into the club '" +
                     CLUB_HANDLER->query_club_name(name) +
                     "'.\n");
      }
   }
   if (!sizeof(all_names)) {
      return 0;
   }
   add_succeeded_mess("$N add$s " + query_multiple_short(all_names) +
                      (sizeof(all_names) == 1? " as a recruiter " : " as recruiters ") +
                      "to the club '" + CLUB_HANDLER->query_club_name(name) +
                      "'.\n");
   return 1;
}
protected int do_financials(string name, string account) {
   string place;
   class club_transaction* transactions;
   int i;
   int deposit_total;
   int withdrawl_total;
   string ret;
   string account_name;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("The club '" + name + "' does not exist.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of a club to see its "
                      "financials.\n");
      return 0;
   }
   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main club account";
   } else {
      account_name = "special club account " + account;
   }
   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the "
                      "club '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "The club '" + CLUB_HANDLER->query_club_name(name) +
         "' " + account_name + " has a current balance of " +
         MONEY_HAND->money_value_string(CLUB_HANDLER->query_balance(name, account), place) +
         " and the next pay period ends at " +
         ctime(CLUB_HANDLER->query_time_fees_due(name)) +
         ", which will cost " +
         MONEY_HAND->money_value_string(CLUB_HANDLER->query_club_cost_per_period(name), place) +
         ".\n";
   transactions =  CLUB_HANDLER->query_transactions(name, account);
   for (i = 0; i < sizeof(transactions); i++) {
      if (transactions[i]->amount > 0) {
         ret += i + ": DEPOSIT " +
               MONEY_HAND->money_value_string(transactions[i]->amount, place) +
               " from " + transactions[i]->who +
               " at " + ctime(transactions[i]->date) + " (" +
               CLUB_HANDLER->query_transaction_type_name(transactions[i]->transaction_type) +
               ")\n";
         if (transactions[i]->information) {
            ret += "   - " + transactions[i]->information + "\n";
         }
         deposit_total += transactions[i]->amount;
      } else {
         ret += i + ": WITHDRAWL " +
               MONEY_HAND->money_value_string(-transactions[i]->amount, place) +
               " from " + transactions[i]->who +
               " at " + ctime(transactions[i]->date) + " (" +
               CLUB_HANDLER->query_transaction_type_name(transactions[i]->transaction_type) +
               ")\n";
         if (transactions[i]->information) {
            ret += "   - " + transactions[i]->information + "\n";
         }
         withdrawl_total += -transactions[i]->amount;
      }
   }
   ret += "\nTotal withdrawals: " +
         MONEY_HAND->money_value_string(withdrawl_total, place) + "\n";
   ret += "Total deposits  : " +
         MONEY_HAND->money_value_string(deposit_total, place) + "\n";
   write("$P$Club Financials$P$" + ret);
   return 1;
}
protected int do_describe(string name) {
   string bit;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("The " + bit + " '" + name +
                      "' must exist for you to describe it.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You cannot change the description of an elected club, "
                      "it must be done as a discussion item.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of a personal club to "
                      "change the description.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_family(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("Only the founder of the family can set the "
                      "description of the family.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_family(name)) {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }
   write("What do you wish to change the description of '" +
         CLUB_HANDLER->query_club_name(name) + "' to?\n");
   this_player()->do_edit("", (: finish_description($1, $(name)) :));
   add_succeeded_mess("");
   return 1;
}
protected void finish_description(string describe, string name) {
   if (!describe ||
       describe == "") {
      write("Aborting setting the description.\n");
      return ;
   }
   CLUB_HANDLER->set_club_description(name, describe);
   if (CLUB_HANDLER->is_family(name)) {
      write("Set the description of the family '" +
             CLUB_HANDLER->query_club_name(name) + "' to:\n" +
             CLUB_HANDLER->query_club_description(name) + "\n");
   } else {
      write("Set the description of the club '" +
             CLUB_HANDLER->query_club_name(name) + "' to:\n" +
             CLUB_HANDLER->query_club_description(name) + "\n");
   }
}
void set_percentage_cut(int value) {
   _percentage_cut = value;
}
int query_percentage_cut() {
   return _percentage_cut;
}
string query_club_warning_message() {
   string place;
   string ret;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   if (club_commands_allowed()) {
      ret += "Clubs have a few rules and regulations associated with "
         "them.  They cost " +
         MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
         " to start.  Every quarter of a " + mud_name() + " year the club "
         "costs " +
         MONEY_HAND->money_value_string(CLUB_COST_PER_YEAR, place) +
         " plus " +
         MONEY_HAND->
            money_value_string(CLUB_COST_PER_MEMBER_PER_YEAR, place) +
         " per member.  Each insignia will cost " +
         MONEY_HAND->money_value_string(CLUB_COST_INSIGNIA, place) +
         " to be made, and the cost an insignia is taken from the "
         "person requesting the insignia, not the club.\n\n"
         "If the club goes into remission for 2 pay periods then the "
         "club will be disbanded.  If the club is not touched for 8 "
         "real weeks then the club will be disbanded.  A club is "
         "considered touched if a member is added or removed, if an "
         "election is held or nominations are added or if money is "
         "deposited into the account.\n\n"
         "Clubs default to being founder controlled clubs, meaning "
         "that the founder has all the control of the club.  Once a "
         "club gets over " +
         CLUB_MINIMUM_ELECTED_MEMBERS +
         " members it can change to an elected club.  In this mode "
         "the committee members of the club are elected to their "
         "positions.  Once a club gets over " +
         CLUB_MAXIMUM_ELECTED_MEMBERS + " it must become an elected "
         "club.  A new election is held every " + mud_name() + " year for all "
         "the positions.  If the founder of a founder base club leaves "
         "the mud or is idle is for 8 real weeks then the club will be "
         "disbanded.\n\n"
         "In this room, clubs can be created and disbanded.  Money can "
         "be deposited into a club, or withdrawn from a club.  It is "
         "possible to see the balance of a given club, and also to see "
         "various lists of clubs.  It is also possible to nominate "
         "someone for position, vote for someone and to force an "
         "election in a particular club.  Furthermore, announcements "
         "and discussion items for clubs can be added here.  Club "
         "insignias can be replaced, and types and options of a club "
         "can be changed.  Finding out more about a club's financials "
         "is also possible, as well as changing the description of a "
         "club.  Last, but not least, a recruiter can be added to a "
         "club.\n";
   }
   if (family_commands_allowed()) {
      ret += "Families have a few rules and regulations associated "
        "with them.  They cost " +
       MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
       " to start and cost " +
       MONEY_HAND->money_value_string(FAMILY_COST_PER_YEAR, place) +
       " in upkeep every quarter of a " + mud_name() + " year, plus " +
       MONEY_HAND->
         money_value_string(FAMILY_COST_PER_MEMBER_PER_YEAR, place) +
       " per member.\n\n"
       "You can create relationships between people, and also create "
       "families.  It is possible to list families, or details about "
       "any particular "
       "family.  On a family of yours, you can set the description, "
       "see its bank balance and deposit more money into its account.  "
       "If your family balance is less than the required amount when "
       "it is time for your family to pay for its fees, the family "
       "will be disbanded.\n\n"
       "You cannot choose a family name from the books for "
       "your families.\n";
   }
   return ret;
}
protected int do_club_list_member(string name) {
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess(name + " does not play " + mud_name() + ".\n");
      return 0;
   }
   if (club_list(this_player()->query_name(),
                 0,
                 (: check_member_func($1, $2, $(name)) :))) {
      return 1;
   }
   add_failed_mess("Could not find any clubs with " + name +
                   " as a member.\n");
   return 0;
}
private void finish_announcement(string str, string name) {
   if (!str) {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->set_announcement(name,
                                      str)) {
      write("Added the announcement to the club " +
            CLUB_HANDLER->query_club_name(name) +
            ".\n");
   } else {
      write("Unable to add the announcement to the club " +
            CLUB_HANDLER->query_club_name(name) +
            " for some reason.\n");
   }
}
protected int do_announcement(string name) {
   if (!CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("The club must be an elected club for an announcement "
                      "to be set.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
       !CLUB_HANDLER->is_secretary_of(name, this_player()->query_name())) {
      add_failed_mess("Only the president and secretary can set an "
                      "announcement.\n");
      return 0;
   }
   write("What announcement do you wish to set?\n");
   this_player()->do_edit(0,
                          (: finish_announcement :),
                          0,
                          0,
                          name);
   return 1;
}
private int check_member_func(string club,
                              string person,
                              string mem) {
   if (!CLUB_HANDLER->is_member_of(club, mem)) {
      return 0;
   }
   if (CLUB_HANDLER->query_club_secret(club) &&
       !CLUB_HANDLER->is_member_of(club, person)) {
      return 0;
   }
   return 1;
}
protected int do_force_election(string name) {
   if (!CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("The club must be elected for you to force an "
                      "election in it.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the president of the club to force an "
                      "election.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_election_in_progress(name) > time()) {
      add_failed_mess("There is already an election in progress, you cannot "
                      "start another one!\n");
      return 0;
   }
   if (CLUB_HANDLER->query_minimum_next_election(name) > time()) {
      add_failed_mess("It is too soon to force an election, that cannot "
                      "be done until " +
                       ctime(CLUB_HANDLER->query_minimum_next_election(name)) +
                       ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->start_election(name)) {
      add_failed_mess("Could not start the election for some reason.\n");
      return 0;
   }
   add_succeeded_mess("$N start$s an election in " +
                      CLUB_HANDLER->query_club_name(name) + ".\n");
   return 1;
}

==================================================
FILE: room/inherit/club_discuss.c
==================================================

#include <clubs.h>
#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 30
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"
private void discuss_finish_description(string str, int open);
protected int do_discuss(int open, string type, string club_name);
class memo_item {
   string club_name;
   string subject;
   string description;
   string *choices;
   int timeout;
   int open;
}
void init() {
   add_command("discuss",
               "[open] {description|add position|"
               "change position name|memo|secret|"
               "remove member|no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                (: do_discuss(1, $4[0], $4[1]) :));
   add_command("discuss",
               "committee {description|add position|"
               "change position name|memo|secret|remove member|"
               "no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                     (: do_discuss(0, $4[0], $4[1]) :));
}
protected void discussion_finish_information(string info,
                                             mixed *data) {
   int type;
   string short;
   string name;
   string optional;
   string club_name;
   club_name = data[0];
   short = data[1];
   type = data[2];
   name = data[3];
   optional = data[4];
   write("Discussion item: " + short + ".\n");
   if (!info) {
      write("No description used.\n");
   } else {
      write(info);
   }
   write("\nDo you wish to add this? ");
   input_to("discussion_finish_confirm",
            0,
            club_name,
            short,
            type,
            name,
            info,
            optional);
}
protected void discussion_finish_confirm(string str,
                                         string club_name,
                                         string short,
                                         int type,
                                         string name,
                                         string info,
                                         string optional) {
   str = lower_case(str);
   if (!strlen(str) ||
       str[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         type,
                                         this_player()->query_cap_name(),
                                         name,
                                         info,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         optional)) {
      write("Added in the discussion item: " + short + ".\n");
   } else {
      write("Unable to add in the discussion item: " + short + ".\n");
   }
}
protected int do_discuss_description(int open,
                                     string club_name) {
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_DESCRIPTION,
                                                   0)) {
      add_failed_mess("A description is already being discussed, you can only "
                      "discuss one description at a time.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Please enter the description you wish to have discussed as the "
         "new description of the club '" +
         CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discuss_finish_description :),
                          0,
                          0,
                          ({ open,
                             club_name }));
   return 1;
}
private void discuss_finish_description(string str, mixed *junk) {
   int open;
   string club_name;
   if (!str) {
      write("Description aborted.\n");
      return ;
   }
   open = junk[0];
   club_name = junk[1];
   write("Adding the description:\n" + str +
         "\nIs this the correct description (yes/no/edit)? ");
   input_to("description_confirm", 0, str, open, club_name);
}
protected void description_confirm(string confirm, string str, int open, string club_name) {
   confirm = lower_case(confirm);
   if (strlen(confirm) &&
       confirm[0] == 'e') {
      this_player()->do_edit(str,
                             (: discuss_finish_description :),
                             0,
                             0,
                             ({ open, club_name }));
      return ;
   }
   if (!strlen(confirm) ||
       confirm[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         CLUB_DISCUSS_DESCRIPTION | open,
                                         this_player()->query_name(),
                                         "Change club description",
                                         str,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         0)) {
      write("Successfuly added the item for discussion.\n");
   } else {
      write("Unable to add the item for discussion.\n");
   }
}
protected int do_discuss_add_position(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What committee position do you wish to add to the club '" +
         club_name + "'? ");
   input_to("discussion_add_name", 0, open, club_name);
   return 1;
}
protected void discussion_add_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The position '" + str + "' already exists in the club.  You "
            "cannot add it.\nAborting.\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, it can be a "
            "maximum length of " + CLUB_MAX_POSITION_NAME +
            ".\nAborting.\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What message do you wish display as to why you wish this position "
         "added?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Adding the position " + str,
                                CLUB_DISCUSS_NEW_POSITION | open,
                                str,
                                0 }) );
}
protected int do_discuss_remove_member(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which member to do you wish to try and remove? ");
   input_to("discussion_remove_member_name", 0, open, club_name);
   return 1;
}
protected void discussion_remove_member_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   if (!CLUB_HANDLER->is_member_of(club_name,
                                   str)) {
      write("The person " + str + " is not a member of the club " +
            CLUB_HANDLER->query_club_name(club_name) +
            " and therefor you cannot remove them.\nAborting.\n");
      return ;
   }
   write("What do you want to say about removing " + str + "?\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Removing the member " + str,
                                CLUB_DISCUSS_MEMBER_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_secret(int open, string club_name) {
   string short;
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_SECRET_TYPE)) {
      notify_fail("There is already a discussion item to change this club's "
                  "secret status.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   if (CLUB_HANDLER->query_club_secret(club_name)) {
      write("What description to wish to use to make the club open?\n");
      short = "make the club open";
   } else {
      write("What description to wish to use to make the club secret?\n");
      short = "make the club secret";
   }
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                short,
                                CLUB_DISCUSS_SECRET_TYPE | open,
                                "Change to be secret",
                                0 }) );
   return 1;
}
protected int do_discuss_remove_position(int open, string club_name) {
   string *choices;
   string *ok;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   ok = filter(choices, (: !CLUB_HANDLER->is_basic_position($(club_name),
                                                            $1) :));
   if (!sizeof(ok)) {
      add_failed_mess("You cannot remove the basic positions of " +
                      query_multiple_short(choices) + ".\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to remove?\n");
   foreach (bing in ok) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("remove_position", 0, open, club_name, ok);
   return 1;
}
protected void remove_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (CLUB_HANDLER->is_basic_position(club_name,
                                       str)) {
      write("Unable to remove the basic positions from the club.\n");
      return ;
   }
   write("What description do you wish to associate with removing the "
         "position " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Remove the positon " + str,
                                CLUB_DISCUSS_POSITION_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_change_position_name(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to change?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("change_position", 0, open, club_name);
   return 1;
}
protected void change_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   write("What name do you wish to change '" + str + "' to? ");
   input_to("change_position_new_name", 0, str, open, club_name);
}
protected void change_position_new_name(string str,
                                        string position,
                                        int open, string club_name) {
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The name '" + str + "' already exists in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, the maximum is " +
            CLUB_MAX_POSITION_NAME + ".\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What description to you wish to give for changing the position " +
         position + " to " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "change the position " + position + " to " + str,
                                CLUB_DISCUSS_POSITION_NAME | open,
                                position,
                                str }) );
}
protected int do_discuss_no_confidence(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to add a no confidence "
         "vote in?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("   " + CLUB_ALL_POSITIONS + "\n");
   write("Choice? ");
   input_to("no_confidence", 0, open, club_name);
   return 1;
}
protected void no_confidence(string str,
                             int open, string club_name) {
   string bing;
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name, str) &&
       str != CLUB_ALL_POSITIONS) {
      write("Sorry, '" + str + "' is not a valid position in " +
            CLUB_HANDLER->query_club_name(club_name) +
            ".\n");
      return ;
   }
   if (str == CLUB_ALL_POSITIONS) {
      bing = 0;
   } else {
      bing = str;
   }
   write("What description do you wish to give for a vote of no confidence "
         "in " + str + "?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "no confidence in " + str,
                                CLUB_DISCUSS_NO_CONFIDENCE | open,
                                bing,
                                0 }) );
}
protected int do_discuss_remove_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to close? ");
   input_to("remove_account", 0, open, club_name);
   return 1;
}
protected void remove_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot remove an account that doesn't exist.\n");
      return ;
   }
   if (str == CLUB_DEFAULT_ACCOUNT_NAME) {
      write("You cannot remove the default account name.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_REMOVE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected int do_discuss_create_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to open? ");
   input_to("create_account", 0, open, club_name);
   return 1;
}
protected void create_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot create an account that already exists.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_CREATE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected void discuss_memo_show(class memo_item memo) {
   write("The memo in club " +
         CLUB_HANDLER->query_club_name(memo->club_name) +
         " will complete in " + memo->timeout + " days.\n");
   if (memo->subject) {
      write("Subject: " + memo->subject + "\n");
   } else {
      write("No subject set.\n");
   }
   if (sizeof(memo->choices)) {
      write("Choices: " + query_multiple_short(memo->choices) + "\n");
   } else {
      write("No choices set.\n");
   }
   if (memo->description) {
      write("Description:\n" + memo->description + "\n");
   } else {
      write("No description set.\n");
   }
}
protected void discuss_memo_menu(class memo_item memo) {
   discuss_memo_show(memo);
   write("\n");
   write("a) Set subject\n");
   write("b) Make a yes/no memo item\n");
   write("c) Add new choice\n");
   write("d) Remove choice\n");
   write("e) Set completion time\n");
   if (memo->description) {
      write("f) Change description\n");
      write("g) Zap description\n");
   } else {
      write("f) Add description\n");
   }
   write("m) Redisplay this menu\n");
   write("s) Save and Quit\n");
   write("q) Quit\n\n");
   write("Choice: ");
   input_to("discuss_memo_menu_choice", 0, memo);
}
protected void discuss_memo_subject(class memo_item memo) {
   write("What do you wish the new subject to be? ");
   input_to("discuss_memo_subject_name", 0, memo);
}
protected void discuss_memo_subject_name(string name,
                                         class memo_item memo) {
   if (!strlen(name)) {
      write("Not changing the subject.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(name) > MAX_SUBJECT_LEN) {
      write("The subject name is too long, the maximum "
            "length is " + MAX_SUBJECT_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->subject = name;
   discuss_memo_menu(memo);
}
protected void discuss_memo_add_choice(class memo_item memo) {
   write("What is the name of the choice you wish to add? ");
   input_to("discuss_memo_add_choice_response", 0, memo);
}
protected void discuss_memo_add_choice_response(string response,
                                                class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   response = strip_colours(response);
   if (!strlen(response)) {
      write("Not adding any choices.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(response) > MAX_CHOICE_LEN) {
      write("The choice name " + response + " is too long, maximum "
            "length is " + MAX_CHOICE_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (member_array(response, memo->choices) != -1) {
      write("The choice name " + response + " is already in the list of "
            "choices.  Current choices are " +
            query_multiple_short(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices += ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_remove_choice(class memo_item memo) {
   write("What is the name of the choice you wish to remove? ");
   input_to("discuss_memo_remove_choice_response", 0, memo);
}
protected void discuss_memo_remove_choice_response(string response,
                                                   class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   if (member_array(response, memo->choices) == -1) {
      write("The choice '" + response + "' is not in current memo.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices -= ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_timeout(class memo_item memo) {
   write("What do you wish to change the length of the item to (in days)? ");
   input_to("discuss_memo_timeout_response", 0, memo);
}
protected void discuss_memo_timeout_response(string str,
                                             class memo_item memo) {
   int tim;
   if (sscanf(str, "%d", tim) != 1) {
      write("Must specify a number.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim < MIN_TIMEOUT) {
      write("The timeout " + tim + " is lower than the minimum allowed "
            "length of " + MIN_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim > MAX_TIMEOUT) {
      write("The timeout " + tim + " is higher than the maximum allowed "
            "length of " + MAX_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->timeout = tim;
   discuss_memo_menu(memo);
}
protected void discuss_memo_finish_description(string desc,
                                               class memo_item memo) {
   if (!desc) {
      write("Not changing the description.\n");
   } else {
      memo->description = desc;
   }
   discuss_memo_menu(memo);
}
protected void discuss_memo_description(class memo_item memo) {
   if (memo->description) {
      write("Edit your description.\n");
   } else {
      write("Add your description.\n");
   }
   this_player()->do_edit(memo->description,
                          (: discuss_memo_finish_description :),
                          0,
                          0,
                          memo);
}
protected void discuss_memo_save(class memo_item memo) {
   if (!memo->subject) {
      write("The memo must have a subject to save it!\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (sizeof(memo->choices) < 2) {
      write("The memo must have at least two choices!  Currently you have " +
            sizeof(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(memo->club_name,
                                         CLUB_DISCUSS_MEMO | memo->open,
                                         this_player()->query_name(),
                                         memo->subject,
                                         memo->description,
                                         memo->choices,
                                         memo->timeout * 24 * 60 * 60,
                                         0)) {
      write("Successfuly added the memo item.\n");
   } else {
      write("Unable to add the memo item for some reason.\n");
   }
}
protected void discuss_memo_menu_choice(string str, class memo_item memo) {
   str = lower_case(str);
   if (!strlen(str)) {
      write("Invalid choice\nChoice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   switch (str[0]) {
      case 'a' :
         discuss_memo_subject(memo);
         break;
      case 'b' :
         memo->choices = ({ "yes", "no", "abstain" });
         discuss_memo_menu(memo);
         break;
      case 'c' :
         discuss_memo_add_choice(memo);
         break;
      case 'd' :
         discuss_memo_remove_choice(memo);
         break;
      case 'e' :
         discuss_memo_timeout(memo);
         break;
      case 'f' :
         discuss_memo_description(memo);
         break;
      case 'g' :
         memo->description = 0;
         write("Description zapped.\n");
         discuss_memo_menu(memo);
         break;
      case 'q' :
         write("Quiting memo addition!\n");
         break;
      case 's' :
         discuss_memo_save(memo);
         break;
      case 'm' :
         discuss_memo_menu(memo);
         break;
      default :
         write("Invalid choice\nChoice: ");
         input_to("discuss_memo_menu_choice", 0, memo);
         break;
   }
}
protected int do_discuss_memo(int op, string club_name) {
   discuss_memo_menu(new(class memo_item, choices : ({ }),
                                          timeout : 14,
                                          club_name : club_name,
                                          open : op));
   return 1;
}
int do_discuss(int open, string type, string club_name) {
   if (open) {
      open = CLUB_DISCUSS_OPEN;
   }
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("No such club '" + club_name + "'.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_elected_club(club_name)) {
      add_failed_mess("The club " + CLUB_HANDLER->query_club_name(club_name) +
                      " is not an elected club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->holds_any_position_of(club_name, this_player()->query_name())) {
      if (type != "no confidence" &&
          type != "remove member") {
         add_failed_mess("Non elected officals can only add discussion items "
                         "of 'no confidence' and 'remove member'.\n");
         return 0;
      }
   }
   switch (type) {
      case "description" :
         return do_discuss_description(open, club_name);
      case "add position" :
         return do_discuss_add_position(open, club_name);
      case "change position name" :
         return do_discuss_change_position_name(open, club_name);
      case "memo" :
         return do_discuss_memo(open, club_name);
      case "remove member" :
         return do_discuss_remove_member(open, club_name);
      case "secret" :
         return do_discuss_secret(open, club_name);
      case "remove position" :
         return do_discuss_remove_position(open, club_name);
      case "no confidence" :
         return do_discuss_no_confidence(open, club_name);
      case "create account" :
         return do_discuss_create_account(open, club_name);
      case "remove account" :
         return do_discuss_remove_account(open, club_name);
      default :
         add_failed_mess("Horrible, horrible error.  The worms!  "
                         "The worms!\n");
         return 0;
   }
}

==================================================
FILE: room/inherit/club_owned_room.c
==================================================

inherit "/std/room/inherit/owned_room";
private nosave string _club_controller;
private nosave string _club_owned_id;
string query_owner() {
   return _club_controller->query_owner_of(_club_owned_id);
}
void set_club_controller(string club_controller) {
   _club_controller = club_controller;
}
string query_club_controller() {
   return _club_controller;
}
void set_owned_id(string id) {
   _club_owned_id = id;
}
string query_owned_id() {
   return _club_owned_id;
}

==================================================
FILE: room/inherit/complaints_room.c
==================================================

#include <complaints_handler.h>
#include <board.h>
void init() {
    add_command( "complain", "" );
}
int do_complain() {
    if ( this_player()->query_property( "guest" ) )
        return add_failed_mess( "Guest characters cannot lodge "
                                "complaints.\n" );
    tell_object( this_player(), "You are lodging an official complaint about "
                 "something or someone.\n"
                 "Do not take this action lightly.\n"
                 "Complaints should be about serious Disc-related matters.  "
                 "Please note that this complaint is submitted anonymously.  "
                 "If you wish to receive a reply, make sure you place your "
                 "character name in the complaint so we know who to respond "
                 "to.\n"
                 "Feedback for the general populous also often appears on "
                 "various bulletin boards.\n" );
    this_player()->do_edit( 0, "finish_complaint", this_object() );
    return 1;
}
void finish_complaint( string str ) {
    if ( !str ) {
        tell_object( this_player(), "Complaint aborted.\n" );
    } else {
        if ( COMPLAINTS_HANDLER->do_submit_complaint( str ) ) {
            tell_object( this_player(), "Complaint posted.  Thank you for "
                         "your complaint.  If you submitted your name in "
                         "your complaint, you should receive a response in "
                         "the near future.  Please be patient, as there may "
                         "be in-depth discussions as a result of your "
                         "complaint.\n" );
        } else {
            tell_object( this_player(), "There has been a problem posting "
                         "your complaint.  As a result it has NOT been "
                         "submitted.  You should contact a liaison or other "
                         "creator to get this rectified immediately.\n" );
        }
    }
}
int board_access_check( int type, string, object previous, string name ) {
    tell_creator("arienne",file_name(previous)+"\n");
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
    case B_ACCESS_DELETE :
        return 0;
    }
}

==================================================
FILE: room/inherit/council_base.c
==================================================

#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
private nosave string _council_area;
string query_council_area() {
   return _council_area;
}
void set_council_area(string area) {
   _council_area = area;
}
void send_council_inform(int magistrate_only, string message) {
   NOMIC_HANDLER->send_council_inform(query_council_area(),
                                       magistrate_only, message);
}

==================================================
FILE: room/inherit/guild.c
==================================================

#include <money.h>
#include <skills.h>
#include <tune.h>
#include <config.h>
private int cost_div;
private int cost_mult;
private string our_guild;
private string start_pos;
private mapping spells;
private mapping commands;
private object teaching_person;
void check_spells_commands(string *sk, int lvl);
int do_cost_primaries();
int do_cost_all(int brief);
int do_cost_to(string skill, int level);
int do_cost_by(string skill, int level);
int do_cost(string skill);
int do_advance(string skill);
int do_advance_to(string skill, int num);
int do_advance_by(string skill, int num);
void create()
{
   cost_div = COST_DIV;
   cost_mult = 100;
   spells = ([ ]);
   commands = ([ ]);
   this_object()->add_help_file("guild");
}
void init()
{
   this_player()->add_command("advance", this_object(),
                              "<string>", (: do_advance($4[0]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> to <number>",
                              (: do_advance_to($4[0], $4[1]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> by <number>",
                              (: do_advance_by($4[0], $4[1]) :));
   this_player()->add_command("join", this_object(), "");
   this_player()->add_command("info", this_object(), "");
   this_player()->add_command("cost", this_object(),
                              "primaries", (: do_cost_primaries() :));
   this_player()->add_command("cost", this_object(),
                              "all", (: do_cost_all(0) :));
   this_player()->add_command("cost", this_object(),
                              "all brief", (: do_cost_all(1) :));
   this_player()->add_command("cost", this_object(),
                              "<string>", (: do_cost($4[0]) :));
   this_player()->add_command("cost", this_object(),
                              "<string> to <number>",
                              (: do_cost_to($4[0], $4[1]) :));
   this_player()->add_command("cost", this_object(), "<string> by <number>",
                              (: do_cost_by($4[0], $4[1]) :));
   if ((string) this_player()->query_guild_ob() == our_guild) {
      if (stringp(start_pos) && !clonep(this_object())) {
         this_player()->add_start(file_name(this_object()), start_pos);
      }
   }
}
varargs void set_guild(string word1, string word2)
{
   our_guild = word1;
   start_pos = word2;
}
void set_cost_div(int number)
{
   cost_div = number;
   if (!cost_div)
      cost_mult = 1000;
   else
      cost_mult = 10 + (990 * cost_div) / (10 * COST_DIV + cost_div);
}
int query_skill_cost(string skill, int offset)
{
   int i;
   int total;
   string *next;
   next = (string *) SKILL_OB->query_immediate_children(skill);
   if (!sizeof(next)) {
      if (!this_player()->query_guild_ob())
         total = DEFAULT_COST;
      else
         total = (int) our_guild->query_skill_cost(skill);
      total *= (STD_COST * cost_mult) / 500;
      total *= ((int) this_player()->query_skill(skill) + offset) /
         LEVEL_DIV + 1;
      total = to_int(total * exp((this_player()->query_skill(skill) +
                                  offset) / 150.0));
      return total;
   }
   for (i = 0; i < sizeof(next); i++)
      total += query_skill_cost(next[i], offset);
   return total;
}
int do_advance_internal(string skill, int to, int by)
{
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   int lvl;
   int max_lvl;
   int tmp;
   int total_xp;
   int total_cost;
   int tmp_cost;
   int p_val;
   int i, j;
   int round_value;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You cannot advance here!  Go to your own guild.\n");
      return 0;
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("The skill " + skill + " does not exist.\n");
      return 0;
   }
   bits = SKILL_OB->query_inactive_skills();
   for(j=0; j<sizeof(bits); j++)
     if(strsrch(skill, bits[j]) != -1)
       return add_failed_mess("The skill " + skill + " is inactive at "
                              "present and cannot be taught.\n");
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by <= 0) {
      if (by == 0) {
         add_failed_mess("You are already at level " + lvl + " at " +
                         skill_name + ".\n");
      } else {
         add_failed_mess("You cannot regress below your current "
                         "skill level!\n");
      }
      return 0;
   }
   if (SKILL_OB->query_only_leaf(skill_name)) {
      if (sizeof((mixed *)SKILL_OB->query_immediate_children(skill_name))) {
         add_failed_mess("You can only advance the outer skills "
                         "(eg: other.movement.riding.horse), "
                         "not the internal "
                         "skills (eg: other.movement.riding, or other).\n");
         return 0;
      }
   } else {
      bits = explode(skill_name, ".");
      if (sizeof(bits) > 1) {
         outer_name = implode(bits[0..<2], ".");
         if (!SKILL_OB->is_skill_ignored(outer_name) &&
             ((sizeof(bits) - 1) * 5) >
             (int) this_player()->query_skill(outer_name)) {
            add_failed_mess("You are not at a high enough level in " +
                            outer_name +
                            " to advance " + skill_name + " yet.\n");
            return 0;
         }
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("You cannot advance in " + skill_name +
                      " any further here.\n");
      return 0;
   }
   p_val = (int) this_player()->query_value_in(place);
   if (place != "default") {
      p_val += (int) this_player()->query_value_in("default");
   }
   round_value = MONEY_HAND->query_smallest_value_in(place);
   total_cost = 0;
   for (i = 0; i < by; i++) {
      tmp = query_skill_cost(skill_name, i);
      if ((int) this_player()->query_xp() < tmp + total_xp) {
         if (!i) {
            add_failed_mess("Your lack of experience prevents you improving "
                            + skill_name + ".\n");
            return 0;
         } else {
            write("Your lack of experience prevents you taking all the "
                  "advancement you requested in " + skill_name + ".  You are "
                  "only trained up to level " + (i + lvl) + ".\n");
         }
         break;
      }
      if ((lvl + i) >= max_lvl) {
         write("Your guild hasn't the resources to train you as far as " +
               "you requested in " + skill_name +
               ".  It trains you to level " + max_lvl + ".\n");
         break;
      }
      if (cost_div) {
         tmp_cost = ( total_xp + tmp ) / cost_div;
         tmp_cost -= (tmp_cost % round_value);
         if ( tmp_cost > p_val ) {
            if (!i) {
               add_failed_mess
                  ("Due to your lack of money, the guild cannot train " +
                   "you in " + skill_name + ": it would have cost you " +
                   MONEY_HAND->money_value_string( tmp_cost, place ) + ".\n" );
               return 0;
            } else {
               write("Due to your sad lack of money the guild cannot train " +
                     "you in " + skill_name + " to level " + (by + lvl) +
                     ".  It trains you to level " + (i + lvl) + " instead.\n");
            }
            break;
         }
      }
      total_xp += tmp;
      total_cost = tmp_cost;
   }
   if (!total_xp) {
      return add_failed_mess("Oops, something has gone wrong.\n");
   }
   this_player()->adjust_xp(-total_xp);
   if (total_cost) {
      this_player()->pay_money((mixed *) MONEY_HAND->
                               create_money_array(total_cost, place), place);
   }
   this_player()->add_skill_level(skill_name, i, total_xp);
   this_player()->reset_all();
   this_player()->dest_hide_shadow();
   event(this_object(), "guild_advance", bits, lvl, lvl + i);
   check_spells_commands(bits, lvl + i);
   write("You advance your skill in " + skill_name + " from " + lvl + " to " +
         (lvl + i) + " for " + total_xp + " xp" + (total_cost ? " and " +
                                                   (string) MONEY_HAND->
                                                   money_value_string
                                                   (total_cost,
                                                    place) : "") + ".\n");
   say((string) this_player()->one_short() + " $V$0=advances,advance$V$ " +
       "$V$0=" + this_player()->query_possessive() + ",their$V$ skills.\n");
   return 1;
}
int do_advance(string skill)
{
   return do_advance_internal(skill, 0, 1);
}
int do_advance_by(string skill,
                  int num)
{
   return do_advance_internal(skill, 0, num);
}
int do_advance_to(string skill,
                  int num)
{
   return do_advance_internal(skill, num, 0);
}
int do_join(string str)
{
   if ((string) this_player()->query_guild_ob() == our_guild) {
      add_failed_mess("You're already in this guild.\n");
      return 0;
   }
   if (this_player()->query_guild_ob()) {
      add_failed_mess("You cannot join a guild while a member of another.\n");
      return 0;
   }
   write("You will only ever get to join one guild.  Are you sure? ");
   input_to("join2");
   return 1;
}
int join2(string str)
{
   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write("I do not understand.  Yes or no? ");
      input_to("join2");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not joining the " + our_guild->query_name() + " guild.\n");
      return 1;
   }
   this_player()->set_guild_ob(our_guild);
   if (stringp(start_pos) && !clonep(environment(this_player())))
      this_player()->add_start(file_name(environment(this_player())),
                               start_pos);
   this_player()->race_guild_commands();
   write("You are now a member of the " + our_guild->query_name() +
         " guild.\n");
   say(this_player()->one_short() + " joins the " + our_guild->query_name() +
       " guild.\n");
   event(this_object(), "guild_join");
   event(users(), "inform",
         this_player()->query_cap_name() + " is now a member " + "of " +
         our_guild->query_name(), "guild");
   return 1;
}
int do_leave(string str)
{
   if (str != "guild") {
      add_failed_mess("Syntax : leave guild\n");
      return 0;
   }
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("How can you leave a guild if you aren't in it.\n");
      return 0;
   }
   if ((int) this_player()->query_level() > 5) {
      add_failed_mess("You are too high a level to leave this guild.\n");
      return 0;
   }
   write("Are you sure you want to leave the guild (Y/N) : ");
   input_to("confirm_leave");
   return 1;
}
void confirm_leave(string str)
{
   str = lower_case(str);
   if (str != "y") {
      write("You are still in the guild.\n");
      return;
   }
   write("Goodbye.\n");
   call_other(our_guild, "leaving_guild");
   this_player()->set_start_pos(CONFIG_START_LOCATION);
   this_player()->set_guild_ob(0);
   this_player()->set_guild_data(0);
   this_player()->guild_commands();
   this_player()->save_me();
}
int check_primaries(string lpath, string g_o)
{
   int i;
   string dummy,
    *primaries;
   primaries = (string *) g_o->query_skills();
   if (member_array(lpath, primaries) != -1)
      return 1;
   for (i = 0; i < sizeof(primaries); i++)
      if (sscanf(primaries[i], lpath + ".%s", dummy))
         return 1;
   return 0;
}
mixed *filter_primaries(mixed *tmp_skills, string skill_path,
                        string *primaries)
{
   int i;
   string test_skill;
   for (i = 0; i < sizeof(tmp_skills); i += SKILL_ARR_SIZE)  {
      test_skill = skill_path + tmp_skills[i];
      if (sizeof(tmp_skills[i + SKILL_BIT]) != 0)
         tmp_skills[i + SKILL_BIT] =
            filter_primaries(tmp_skills[i + SKILL_BIT], test_skill + ".",
                             primaries);
      if (member_array(test_skill, primaries) == -1  &&
          sizeof(tmp_skills[i + SKILL_BIT]) == 0)
      {
         tmp_skills = tmp_skills[0 .. (i - 1)] +
                      tmp_skills[(i + SKILL_ARR_SIZE) .. ];
         i -= SKILL_ARR_SIZE;
      }
   }
   return tmp_skills;
}
private string rec_cost(mixed *arr, string path, int depth, string guild,
                        int brief)
{
   int i;
   int depth_gap;
   int ndots;
   int lvl;
   int max_lvl;
   int only_leaf;
   int tmp;
   string str;
   string sub_str;
   string lpath;
   str = "";
   depth_gap = (depth - 1) * 2;
   ndots = 19 - depth_gap;
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      lpath = path + arr[i];
      lvl = this_player()->query_skill(lpath);
      if (!guild) {
         max_lvl = 5;
      } else {
         max_lvl = guild->query_skill_max_level(lpath);
      }
      only_leaf = SKILL_OB->query_only_leaf(lpath);
      if (only_leaf  &&  sizeof(arr[i + SKILL_BIT]) > 0)  {
         sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                            guild, brief);
         if (sub_str != "")  {
            str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                           ndots + 18, arr[i]) + sub_str;
            continue;
         }
      }
      else if (SKILL_OB->query_allowed_to_teach(lpath))  {
         if (lvl >= max_lvl)  {
            if (brief)  {
               sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                                  guild, brief);
               if (sub_str != "")  {
                  str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                                 ndots + 18, arr[i]) + sub_str;
                  continue;
               }
            }
            else str += sprintf("%*'| 's%-*'.'s%4d/%3d  mastered\n", depth_gap,
                                "", ndots, arr[i], lvl, max_lvl);
         }
         else if (SKILL_OB->query_allowed_to_teach(lpath))  {
            tmp = query_skill_cost(lpath, 0);
            str += sprintf("%*'| 's%-*'.'s%4d/%3d %6d xp\n", depth_gap, "",
                           ndots, arr[i], lvl, max_lvl, tmp);
         }
      }
      if (lvl >= depth * 5  ||  only_leaf) {
         reset_eval_cost();
         str += rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1, guild,
                         brief);
      }
   }
   return str;
}
int do_cost_all(int brief)
{
   mixed *arr;
   string list;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols(),
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols() + 1,
                   rec_cost(arr, "", 1, our_guild, brief));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols(),
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "All", 1);
   return 1;
}
int do_cost_primaries()
{
   mixed *arr;
   string list;
   string *primaries;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols(),
                   rec_cost(arr, "", 1, our_guild, 0));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "Primaries", 1);
   return 1;
}
int do_cost_internal(string skill, int to, int by)  {
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   string cost_str;
   int lvl;
   int max_lvl;
   int i;
   int tmp;
   int cost;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by == 0) {
      add_failed_mess
         ("It won't cost you anything to stay at the same level!\n");
      return 0;
   }
   if (by < 0) {
      add_failed_mess("We can't give refund xp for regressing skills!\n");
      return 0;
   }
   bits = explode(skill_name, ".");
   if (sizeof(bits) > 1  &&  !SKILL_OB->query_only_leaf(skill_name)) {
      outer_name = implode(bits[0 .. <2], ".");
      if (!SKILL_OB->is_skill_ignored(outer_name) &&
          ((sizeof(bits) - 1) * 5) > this_player()->query_skill(outer_name))
      {
         add_failed_mess("You are not at a high enough level in " +
                         outer_name + " to advance " + skill_name +
                         " yet.\n");
         return 0;
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("Your guild prevents you even considering advancing " +
                      skill_name + " above level " + max_lvl + ".\n");
      return 0;
   }
   for (i = 0; i < by; i++) {
      if ((lvl + i) >= max_lvl) {
         write("Your guild prevents you considering all the advancement you "
               + "requested.  You can only advance up to level " + max_lvl +
               " in " + skill_name + " here.\n");
         break;
      }
      tmp += query_skill_cost(skill_name, i);
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   cost_str = "";
   if (cost_div) {
      cost = tmp / cost_div;
      cost += cost % MONEY_HAND->query_smallest_value_in(place);
      if (cost)
         cost_str = " and " + MONEY_HAND->money_value_string(cost, place);
   }
   printf("It would cost you %d xp%s to raise %s from level %d to %d.\n",
          tmp, cost_str, skill_name, lvl, (lvl + i));
   return 1;
}
int do_cost(string skill)
{
   mixed *arr;
   int i;
   int depth;
   string list;
   string exp_skill;
   string *sub_skills;
   int only_leaf;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   exp_skill =
      SKILL_OB->query_skill(explode(implode(explode(skill, " "), "."), "."));
   if (!exp_skill)  {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   if (SKILL_OB->query_allowed_to_teach(exp_skill))  {
      i = member_array(exp_skill, arr);
      only_leaf = SKILL_OB->query_only_leaf(exp_skill);
      if (only_leaf)  {
         sub_skills = explode(exp_skill, ".");
         foreach (skill in sub_skills[0 .. < 2])  {
            i = member_array(skill, arr);
            arr = arr[i + 3];
         }
         i = member_array(sub_skills[<1], arr);
         depth = sizeof(sub_skills) + 1;
      }
      else depth = 2;
      if (sizeof(arr[i + 3]) > 0)  {
         list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                        "======SKILLS=======Cur/Max==For Next") +
                sprintf("%#*-s\n", (int) this_player()->query_cols(),
                         rec_cost(arr[i + SKILL_BIT], exp_skill + ".", depth,
                         our_guild, 0)) +
                sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                         "> You have " + (int) this_player()->query_xp() +
                         " points to spend <");
         this_player()->more_string(list, capitalize(exp_skill), 1);
         return 1;
      }
   }
   return do_cost_internal(exp_skill, 0, 1);
}
int do_cost_to(string skill, int num)
{
   return do_cost_internal(skill, num, 0);
}
int do_cost_by(string skill, int num)
{
   return do_cost_internal(skill, 0, num);
}
int do_info()
{
   mixed *arr;
   string *primaries;
   write(our_guild->long() +
         "\nThis guild's primary skills and costs are:\n");
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   printf("%-*'='s\n", this_player()->query_cols() - 1,
          "======SKILLS=======Cur/Max==For Next");
   printf("%#*-s\n", this_player()->query_cols(),
          rec_cost(arr, "", 1, our_guild, 0));
   printf("%*'='|s\n", this_player()->query_cols() - 1, "> You have " +
          this_player()->query_xp() + " points to spend <");
   return 1;
}
void set_teaching_person(object ob)
{
   teaching_person = ob;
}
object query_teaching_person()
{
   return teaching_person;
}
void add_spell(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!spells[path])
      spells[path] = ({ name, lvl });
   else
      spells[path] += ({ name, lvl });
}
void add_command(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!commands)
      commands = ([ ]);
   if (!commands[path])
      commands[path] = ({ name, lvl });
   else
      commands[path] += ({ name, lvl });
}
void check_spells_commands(string *sk, int lvl)
{
   string *bits;
   int val;
   int i;
   int j;
   if (!teaching_person)
      return;
   bits = keys(spells);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(spells[bits[i]]); j += 2)
         if ((spells[bits[i]][j + 1] < val) &&
             !(this_player()->query_spell(spells[bits[i]][j])))
            teaching_person->init_command("teach " + spells[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
   bits = keys(commands);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(commands[bits[i]]); j += 2)
         if ((commands[bits[i]][j + 1] < val) &&
             !(this_player()->query_known_command(commands[bits[i]][j])))
            teaching_person->init_command("teach " + commands[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
}
mapping query_spells()
{
   return spells + ([ ]);
}
mapping query_commands()
{
   return commands + ([ ]);
}
string query_start_pos()
{
   return start_pos;
}
string query_our_guild()
{
   return our_guild;
}

==================================================
FILE: room/inherit/honours.c
==================================================

#include <player_handler.h>
#include <player.h>
class honour {
   int time_added;
   string reason;
   string cap_name;
   string added_by;
}
private nosave string* _titles;
mapping _honours;
int is_allowed_to_change(string person);
void save_me();
void create() {
   _honours = ([ ]);
   _titles = ({ });
}
void inform_of_honour_change(string type, string person,
                      string reason, string changed_by) {
}
void set_controlled_titles(string* title) {
   _titles = title;
}
string* query_controlled_titles() {
   return _titles;
}
void add_to_honour_roll(string person, string reason, string added_by) {
   string title;
   if (_honours[person]) {
      return ;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      return ;
   }
   _honours[person] = new(class honour);
   _honours[person]->time_added = time();
   _honours[person]->reason = reason;
   _honours[person]->added_by = added_by;
   _honours[person]->cap_name = PLAYER_HANDLER->query_cap_name(person);
   foreach (title in _titles) {
      PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
   }
   save_me();
}
void remove_from_honour_roll(string person) {
   string title;
   if (!_honours[person]) {
      return ;
   }
   map_delete(_honours, person);
   if (find_player(person)) {
      foreach (title in _titles) {
         find_player(person)->remove_player_title(title);
      }
   }
   save_me();
}
int is_on_honour_roll(string person) {
   return classp(_honours[person]);
}
int do_list_honour() {
   string person;
   class honour roll;
   string ret;
   string* people;
   if (!_honours) {
      _honours = ([ ]);
   }
   if (!sizeof(_honours)) {
      add_failed_mess("There is no one on the honour roll.\n");
      return 0;
   }
   ret = "";
   people = sort_array(keys(_honours), (: _honours[$1]->time_added - _honours[$2]->time_added :));
   foreach (person in people) {
      roll = _honours[person];
      ret += "$I$3=%^YELLOW%^" + roll->cap_name + "%^RESET%^ at " +
             amtime(roll->time_added) +
             " for " + roll->reason + " by " + roll->added_by + "\n";
   }
   write("$P$Honour Roll$P$" + ret);
   return 1;
}
int do_honour_add(string person) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }
   if (is_on_honour_roll(person)) {
      add_failed_mess("They are already on the honour roll.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("The person " + person + " does not exist.\n");
      return 0;
   }
   write("Enter the reason for adding " + person + " to the honour roll:\n");
   this_player()->do_edit("", "end_honour_add", this_object(), 0, person);
   add_succeeded_mess("");
   return 1;
}
void end_honour_add(string reason, string person, string bing) {
   if (reason == "" || !reason) {
      write("Aborting.\n");
      return ;
   }
   write("Adding the person " + person + " to the honour roll with a reason "
         "of:\n" + reason + "\nAre you sure? ");
   input_to("honour_roll_confirm", 0, person, reason);
}
void honour_roll_confirm(string response, string person, string reason) {
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   add_to_honour_roll(person, reason, this_player()->query_cap_name());
   inform_of_honour_change("add", person, reason,
                           this_player()->query_name());
   add_succeeded_mess("$N add$s " + person + " to the honour roll.\n");
   return ;
}
int do_honour_remove(string person, string reason) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }
   if (!is_on_honour_roll(person)) {
      add_failed_mess("They are not on the honour roll.\n");
      return 0;
   }
   remove_from_honour_roll(person);
   inform_of_honour_change("remove", person, reason,
                           this_player()->query_cap_name());
   add_succeeded_mess("$N remove$s " + person + " to the honour roll.\n");
   return 1;
}
void readd_all_titles() {
   string person;
   class honour roll;
   foreach (person, roll in _honours) {
      foreach (string title in _titles) {
         PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
      }
   }
}
void init() {
   if (!sizeof(_titles)) {
      return 0;
   }
   add_command("list", "honour [roll]", (: do_list_honour() :));
   if (is_allowed_to_change(this_player()->query_name())) {
      add_command("add",
                  "<string'person'> to honours",
                  (: do_honour_add($4[0]) :));
      add_command("remove",
                  "<string'person'> from honours because <string'reason'>",
                  (: do_honour_remove($4[0], $4[1]) :));
   }
}

==================================================
FILE: room/inherit/meeting.c
==================================================

private object _floor;
private string _leader;
int do_bang();
int do_recover();
int do_start();
int do_finish();
object create_floor();
void add_property(string name, mixed data);
void create() {
   _floor = create_floor();
   _floor->move(this_object());
}
void init() {
   add_command("bang", "gavel", (: do_bang() :));
   add_command("recover", "floor", (: do_recover() :));
   add_command("start", "meeting", (: do_start() :));
   add_command("finish", "meeting", (: do_finish() :));
}
object create_floor() {
   object floor;
   floor = clone_object("/std/object");
   floor->set_name("floor");
   floor->set_short( "floor" );
   floor->add_property( "determinate", "the " );
   floor->add_property( "no burial", 1);
   floor->set_long("This is the floor of the meeting.  It gives you the "
                   "right to speak during the meeting.  Please give this "
                   "to the next person to speak after you have finished.\n");
   return floor;
}
int do_start() {
   if (_leader &&
       find_player(_leader) &&
       environment(find_player(_leader)) == this_object()) {
      add_failed_mess("There is already a meeting started with " +
                      find_player(_leader)->the_short() +
                      " as the leader.\n");
      return 0;
   }
   _leader = this_player()->query_name();
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
}
int do_bang() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can bang the gavel!\n");
      return 0;
   }
   add_succeeded_mess("$N $V the gavel.\n\nSTOP STOP!\n\n");
   return 1;
}
int do_recover() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can recover the floor.\n");
      return 0;
   }
   _floor->move(this_player());
   add_succeeded_mess("$N recovers the floor.\n");
   return 1;
}
int do_finish() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can stop the meeting!\n");
      return 0;
   }
   _leader = 0;
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
}
void event_exit(object ob,
                string mess,
                object to) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      "'s hands and flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}
void event_dest_me(object ob) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}
void event_quit(object ob) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}

==================================================
FILE: room/inherit/newspaper_office.c
==================================================

#include <mail.h>
#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
#include <room/newspaper.h>
#include <nroff.h>
#include <board.h>
#include <housing.h>
#define NEWSPAPER_POSTPONE_FLAG 1
#define NEWSPAPER_LOCK_FLAG 2
class our_article {
   class article art;
   int flags;
   int length;
   int suggested_payment;
}
class reporter {
   int date_added;
   int num_articles;
   int total_payed;
}
class category_data {
   int cost_per_add;
   int cost_per_ten_chars;
   int open;
}
class payee_data {
   int paid;
   string message;
}
private mapping _reporters;
private string* _editors;
private string* _setters;
private string* _sponsors;
private string _owner;
private mapping _payees;
private int _published_time;
private class our_article* _articles;
private class advert* _adverts;
private int _next_article_num;
private int _edition_number;
private int _locked;
private int _owner_extra_cash;
private mapping _category;
private nosave string _save_dir;
private nosave string _paper_name;
private string _bank_branch;
private nosave string _proxy;
int show_article(class our_article art, int source);
string* query_all_reporters();
string* query_all_setters();
string* query_all_editors();
string* query_all_sponsors();
mapping query_all_payees();
int is_reporter(string word);
int is_setter(string word);
int is_editor(string word);
int is_sponsor(string word);
void add_reporter(string word);
void add_setter(string word);
void add_editor(string word);
void add_sponsor(string word);
void remove_reporter(string word);
void remove_setter(string word);
void remove_editor(string word);
void remove_sponsor(string word);
void update_commands(string word);
string query_log_file_name();
string query_article_log_file_name();
int query_current_edition();
string query_paper_name();
string query_next_article_file_name();
string query_bank_branch();
mixed query_property(string);
string query_owner();
int is_owner(string word);
void create()
{
   _reporters = ([ ]);
   _editors = ({ });
   _payees = ([ ]);
   _articles = ({ });
   _category = ([ ]);
   _adverts = ({ });
   _setters = ({ });
   _sponsors = ({ });
   _next_article_num = 2;
}
protected void save_me()
{
   if (_save_dir && !_proxy) {
      unguarded( (: save_object(_save_dir + "main") :) );
   }
}
protected void load_me()
{
   class article fluff;
   int i;
printf("%O %O\n", _save_dir, _proxy);
   if (_save_dir && !_proxy) {
      unguarded( (: restore_object(_save_dir + "main", 1) :) );
printf("%O %O\n", _save_dir, _proxy);
      if (!_articles) {
         _articles = ({ });
      }
      if (!_setters) {
         _setters = ({ });
      }
      if (!_sponsors) {
         _sponsors = ({ });
      }
      if (!_adverts) {
         _adverts = ({ });
      }
      for (i = 0; i < sizeof(_articles); i++) {
         if (sizeof(_articles[i]->art) == 6) {
            fluff = new(class article);
            fluff->file_name = _articles[i]->art->file_name;
            fluff->title = _articles[i]->art->title;
            fluff->author = _articles[i]->art->author;
            fluff->date_written = _articles[i]->art->date_written;
            fluff->type = _articles[i]->art->type;
            fluff->shown_name = _articles[i]->art->shown_name;
            fluff->colour = 0;
            _articles[i]->art = fluff;
         }
      }
   }
}
private int a_type(int data) {
   return data & NEWSPAPER_ARTICLE_TYPE_MASK;
}
private int a_flags(int data) {
   return data & ~NEWSPAPER_ARTICLE_TYPE_MASK;
}
void set_save_directory(string dir) {
   if (dir[<1] != '/') {
      dir += "/";
   }
   _save_dir = dir;
   load_me();
}
void save_article_text(class our_article art, string text) {
   if (a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_HTML &&
       a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_PLAIN) {
      return ;
   }
   unguarded( (:
       write_file(_save_dir + $(art->art->file_name), save_variable(({ $(art), $(text) })), 1) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".nroff.o" ) :) );
}
private void update_article_info(class our_article art, string text) {
   int fsize;
   fsize = strlen(text);
   art->length = fsize;
   if (fsize < 0) {
      fsize = 0;
   }
   if (fsize > 4000) {
      fsize = 4000;
   }
   fsize = fsize / 100;
   art->suggested_payment = fsize;
}
string load_article_text(class our_article art) {
   mixed* bits;
   string str;
   str = unguarded( (: read_file(_save_dir + $(art->art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      return bits[1];
   }
   return "Error loading the article.";
}
string load_article_text_by_file(string fname) {
   int i;
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         return load_article_text(_articles[i]);
      }
   }
   return "Lost the article.\n";
}
void save_article_text_by_file(string fname, string text) {
   int i;
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         update_article_info(_articles[i], text);
         return save_article_text(_articles[i], text);
      }
   }
    return ;
}
void set_article_title_by_file(string fname, string title) {
   int i;
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         _articles[i]->art->title = title;
         save_me();
         return ;
      }
   }
    return ;
}
void delete_article(class our_article article) {
   unguarded( (: rm(_save_dir + $(article->art->file_name)) :) );
   unguarded( (: rm(_save_dir + $(article->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(article->art->file_name) + ".nroff.o" ) :) );
}
int query_article_index(string match) {
   int index;
   match = lower_case(match);
   if (strlen(match) && (match[0] >= '0' && match[0] <= '9')) {
      sscanf(match, "%d", index);
      index--;
      if (index < 0 || index >= sizeof(_articles)) {
         return -1;
      }
      return index;
   }
   if (strlen(match) == 1) {
      index = match[0] - 'a';
      if (index < 0 || index >= sizeof(_articles)) {
         return -1;
      }
      return index;
   }
   return -1;
}
class our_article* query_articles() {
   return _articles;
}
class our_article query_article(string match) {
   int index;
   index = query_article_index(match);
   if (index == -1) {
      return 0;
   }
   return _articles[index];
}
string query_category(string category) {
   string name;
   category = lower_case(category);
   foreach (name in keys(_category)) {
      if (lower_case(name) == category ||
          lower_case(name)[0..strlen(category) - 1] == category) {
         return name;
      }
   }
   return 0;
}
string query_log_file_name() {
   return _save_dir + "event.log";
}
string query_article_log_file_name() {
   return _save_dir + "aritcle.log";
}
int query_current_edition()
{
   return NEWSPAPER_HANDLER->query_current_edition_num(query_paper_name());
}
string query_paper_name()
{
   return _paper_name;
}
string query_the_paper_name()
{
   if (lower_case(_paper_name[0..3]) == "the") {
      return _paper_name;
   }
   return "the " + _paper_name;
}
string set_paper_name(string name)
{
   _paper_name = name;
}
string query_next_article_file_name()
{
   while (file_size(_save_dir + _next_article_num + ".txt") != -1) {
      _next_article_num++;
   }
   return (_next_article_num++) + ".txt";
}
string query_bank_branch()
{
   return _bank_branch;
}
void set_bank_branch(string bank) {
   _bank_branch = bank;
}
int do_apply()
{
   if (_proxy) {
      return _proxy->do_apply();
   }
   tell_object(this_player(), "To apply for a job at " + query_the_paper_name() + ", please write "
               "us a letter outlining your areas of interest and what you think you "
               "would be able to contribute to the newspaper.  It will be sent to the "
               "editors of " + query_the_paper_name() +
               ", who will get back to you with an answer "
               "within a few days.\n");
   this_player()->do_edit(0, "mail_application");
   add_succeeded_mess(({ "", "$N start$s writing an application.\n" }));
   return 1;
}
int mail_application(string text)
{
   string word;
   string *eds;
   if (!text) {
      tell_object(this_player(), "You decide not to apply just yet.\n");
      return 0;
   }
   eds = ({ });
   foreach(word in query_all_editors()) {
      if (PLAYER_HANDLER->test_user(word)) {
         eds += ({ word });
      }
   }
   if (!sizeof(eds)) {
      eds = ({ "pinkfish" });
   }
   AUTO_MAILER->auto_mail(implode(eds, ","), this_player()->query_name(),
                          "" + query_paper_name() + " application", "", text, 0, 0);
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " applied for a job at " + query_the_paper_name() + ".\n");
   tell_object(this_player(), "Your application has been submitted.  Thanks!\n");
   tell_room(this_object(),
             this_player()->the_short() + " finishes " + this_player()->query_possessive() +
             " application for a job at " + query_the_paper_name() + ".\n", this_player());
   return 1;
}
int part_two(string str, string author, int html)
{
   if (!sizeof(str)) {
      tell_object(this_player(), "The article must have a name!\n");
      tell_room(this_object(), this_player()->the_short() +
                " stops writing to think of a name.\n",
                this_player());
      return 0;
   }
   if (!html) {
      tell_object(this_player(), "Please enter the text of your story.  It will make "
               "everyone's life much easier if it is less than 75 characters per "
               "line!\n\n"
               "%^BOLD%^<--------+10-------+20-------+30-------+40-------+50-------+60-"
               "------+70-->%^RESET%^\n");
   }
   this_player()->do_edit(0, "write_it", this_object(), 0, ({ str, author, html }));
   return 1;
}
int do_submit(string str, string author, int html)
{
   if (_proxy) {
      return _proxy->do_submit(str, author, html);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked for "
                      "submissions.\n");
      return 0;
   }
   if (!str) {
      add_failed_mess("Please enter the name of the article you wish "
                       "to submit.  A short but descriptive name would be good, and it will "
                       "automagically have your name appended to the end of it.\n");
      return 0;
   }
   if (!author) {
      author = this_player()->query_cap_name();
   }
   add_succeeded_mess(({ "", "$N start$s writing an article.\n" }));
   part_two(str, author, html);
   return 1;
}
varargs int write_it(string article,
                     mixed *stuff,
                     class our_article cur_art)
{
   int fsize;
   string person;
   string title;
   string author;
   int html;
   title = stuff[0];
   author = stuff[1];
   html = stuff[2];
   if (!article) {
      tell_object(this_player(), "You decide not to submit your story after all.\n");
      tell_room(this_object(), this_player()->the_short() +
                    " stops writing the article.\n", this_player());
      return 0;
   }
   person = this_player()->query_cap_name();
   if (!cur_art) {
      cur_art = new(class our_article);
      cur_art->art = new(class article);
      cur_art->art->title = title;
      cur_art->art->shown_name = author;
      cur_art->art->file_name = query_next_article_file_name();
      cur_art->art->author = person;
      cur_art->art->date_written = time();
      if (html) {
         cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_HTML;
      } else {
         cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_PLAIN;
      }
      update_article_info(cur_art, article);
      cur_art->flags = 0;
   }
   _articles += ({ cur_art });
   save_article_text(cur_art, article);
   save_me();
   log_file(query_article_log_file_name(),
                 "On " + ctime(time()) + " " + person +
                 " submitted the story " + title + ".\n");
   log_file(query_article_log_file_name(), "Recommended payment for above "
                           "article: $" + fsize + ".\n");
   tell_object(this_player(), "Article submitted!\n");
   tell_room(this_object(), this_player()->the_short() +
              " submits an article to the newspaper.\n",
             this_player());
}
int do_retrieve(string edn, int source)
{
   class our_article article;
   if (_proxy) {
      return _proxy->do_retrieve(edn, source);
   }
   add_succeeded_mess("");
   if (!sizeof(_articles)) {
      add_failed_mess("There do not seem to have be any articles "
                      "submitted for this edition yet.\n");
      return 0;
   }
   article = query_article(edn);
   if (!article) {
      add_failed_mess("Sorry, " + edn + " is an incorrect article "
                      "reference.\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(article->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only read your own articles.\n");
      return 0;
   }
   show_article(article, source);
   return 1;
}
int show_article(class our_article article, int source)
{
   string text;
   mixed* bits;
   int i;
   mixed* stuff;
   class advert data;
   switch (a_type(article->art->type)) {
   case NEWSPAPER_ARTICLE_TYPE_SECTION :
      text = "%^BOLD%^" + article->art->title + "%^RESET%^\n\n";
      for (i = 0; i < sizeof(_articles); i++) {
         if (_articles[i] == article) {
            i++;
            break;
         }
      }
      for (; i < sizeof(_articles); i++) {
         if (a_type(_articles[i]->art->type) != NEWSPAPER_ARTICLE_TYPE_SECTION) {
            text += sprintf("%2d .... %70-=s\n", i + 1,
                            _articles[i]->art->title);
         }
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
      text = "%^BOLD%^" + article->art->title + "%^RESET%^\n";
      stuff = unique_array(_adverts, (: $1->category :));
      foreach (bits in stuff) {
         text += "\n$I$0=" + bits[0]->category + "\n$I$3=   ";
         foreach (data in bits) {
            text += data->text + "\n-- " + data->author + "\n\n";
         }
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_HTML :
      if (!source) {
         text = unguarded( (: NROFF_HAND->cat_file(_save_dir +
                              $(article->art->file_name) + ".nroff", 1) :) );
         if (!text) {
            text = unguarded( (: read_file(_save_dir +
                                           $(article->art->file_name)) :) );
            if (text) {
               bits = restore_variable(text);
               bits[1] = NEWSPAPER_HANDLER->convert_html(bits[1]);
               unguarded( (: write_file(_save_dir + $(article->art->file_name) +
                              ".proc", $(bits[1]), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff(_save_dir +
                               $(article->art->file_name) + ".proc",
                           _save_dir + $(article->art->file_name) + ".nroff") :) )) {
                  text = unguarded( (: NROFF_HAND->cat_file(_save_dir +
                                   $(article->art->file_name) + ".nroff") :) );
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the article.  Opps.\n";
            }
         }
         break;
      }
   case NEWSPAPER_ARTICLE_TYPE_PLAIN :
      text = load_article_text(article);
      break;
   }
   this_player()->more_string("The article you requested reads as follows:\n" +
                   text + "\n");
   return 1;
}
int do_logs(int article_log)
{
   string logfile;
   if (_proxy) {
      return _proxy->do_logs(article_log);
   }
   if (article_log) {
      logfile = read_file(query_article_log_file_name());
   } else {
      logfile = read_file(query_log_file_name());
   }
   if (!logfile) {
      add_failed_mess("There don't appear to be any logs.\n");
      return 0;
   }
   this_player()->more_string("The log contains:\n" + logfile + "\n");
   add_succeeded_mess("");
   return 1;
}
int do_articles(int scroll)
{
   string str;
   class our_article article;
   int pos;
   int editor;
   if (_proxy) {
      return _proxy->do_articles(scroll);
   }
   str = "";
   editor = is_editor(this_player()->query_name());
   if (sizeof(_articles)) {
      str = "The articles for edition " + query_current_edition() + " are:\n";
      pos = 1;
      foreach(article in _articles) {
         if (article->art->colour) {
            str += "%^" + article->art->colour + "%^";
         }
         switch (a_type(article->art->type)) {
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            str += sprintf("$I$5=Page %2d) %s by %s (shown author %s) submitted at %s; length %d%s%s%s\n",
               pos, article->art->title,
               (editor || article->art->author == this_player()->query_name()?article->art->author:article->art->shown_name),
               article->art->shown_name,
               ctime(article->art->date_written),
               article->length,
               (editor?" suggested payment $" + article->suggested_payment:""),
               (article->flags & NEWSPAPER_POSTPONE_FLAG?" (postponed)":""),
               (article->flags & NEWSPAPER_LOCK_FLAG?" (locked)":""),
               (a_flags(article->art->type) & NEWSPAPER_ARTICLE_NO_XP_FLAG?" (no xp)":"") );
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            str += sprintf("$I$5=Page %2d) Section Header '%s'\n",
                           pos,
                           article->art->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            str += sprintf("$I$5=Page %2d) Adverts\n", pos);
            break;
         }
         if (article->art->colour) {
            str += "%^RESET%^";
         }
         pos++;
      }
   } else {
      str = "There are no articles in this edition yet.\n";
   }
   if (!scroll) {
      write("$P$Articles$P$" + str);
   } else {
      write(str);
   }
   return 1;
}
int do_resign()
{
   object *inv;
   object ob;
   string person;
   if (_proxy) {
      return _proxy->do_resign();
   }
   person = this_player()->query_name();
   remove_reporter(person);
   if (is_editor(person)) {
      remove_editor(person);
   }
   if (is_setter(person)) {
      remove_setter(person);
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " resigned from " + query_the_paper_name() + ".\n");
   inv = match_objects_for_existence("press credentials", ({ this_player() }),
                                     this_player());
   foreach (ob in inv) {
      if (ob->query_paper_name() == query_paper_name()) {
         ob->dest_me();
      }
   }
   add_succeeded_mess(({ "You hand in your badge, and tender your "
                         "resignation from " + query_the_paper_name() +
                         ".  You can't help but feel a little "
                         "saddened as a result.\n",
                         "$N $V from " + query_the_paper_name() + ".\n" }));
   return 1;
}
int do_delete(string str)
{
   class our_article article;
   int i;
   if (_proxy) {
      return _proxy->do_delete(str);
   }
   article = query_article(str);
   if (!article) {
      add_failed_mess("There is no article referenced by " + str + ".\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       this_player()->query_name() != lower_case(article->art->author)) {
      add_failed_mess("You cannot delete this article.\n");
      return 0;
   }
   delete_article(article);
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i] == article) {
         _articles = _articles[0..i - 1] + _articles[i+1..];
      }
   }
   save_me();
   log_file(query_article_log_file_name(),
                    "On " + ctime(time()) + " " + this_player()->query_short() +
                    " deleted the article " + article->art->title + ".\n");
   add_succeeded_mess(({ "Article deleted!\n",
                         "$N $V an article from "
                         "the current edition.\n" }));
   return 1;
}
int do_hire(string person, int setter)
{
   string bing;
   object thatguy;
   if (_proxy) {
      return _proxy->do_hire(person, setter);
   }
   person = lower_case(person);
   if (setter) {
      if (is_setter(person)) {
         add_failed_mess("That person is already employed as a setter by " +
                         query_the_paper_name() + "!\n");
         return 0;
      }
      bing = "setter";
   } else {
      if (is_reporter(person)) {
         add_failed_mess("That person is already employed by " +
                         query_the_paper_name() + "!\n");
         return 0;
      }
      bing = "reporter";
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("There is nobody called " + capitalize(person) + "!\n");
      return 0;
   }
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "just been hired by " + this_player()->the_short() +
                  " as a " + bing + " for " +
                  query_the_paper_name() + ".\n");
   }
   if (setter) {
      add_setter(person);
   } else {
      add_reporter(person);
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " employed " + capitalize(person) + " as a " + bing + ".\n");
   add_succeeded_mess(capitalize(person) +
                      " is now employed by " +
                      query_the_paper_name() + " as a " + bing + ".\n");
   return 1;
}
int do_dismiss(string person)
{
   object thatguy;
   if (_proxy) {
      return _proxy->do_dismiss(person);
   }
   if (!is_reporter(person)) {
      add_failed_mess("That person is not employed by " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   remove_reporter(person);
   remove_editor(person);
   remove_setter(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "been fired from " + query_the_paper_name() + " by " + this_player()->the_short() +
                  "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " fired " + capitalize(person) + ".\n");
   add_succeeded_mess(capitalize(person) +
                      " is no longer employed by " +
                      query_the_paper_name() + ".\n");
   return 1;
}
int do_sponsor_add(string person)
{
   if (_proxy) {
      return _proxy->do_sponsor_add(person);
   }
   person = lower_case(person);
   if (is_sponsor(person)) {
      add_failed_mess(person + " is already a sponsor of " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("I am sorry, but " + person + " does not exist.\n");
      return 0;
   }
   add_sponsor(person);
   add_succeeded_mess(capitalize(person) +
                      " is now a sponsor of " + query_the_paper_name() + ".\n");
   return 1;
}
int do_sponsor_remove(string person)
{
   if (_proxy) {
      return _proxy->do_sponsor_remove(person);
   }
   person = lower_case(person);
   if (!is_sponsor(person)) {
      add_failed_mess(person + " is not a sponsor of " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   remove_sponsor(person);
   add_succeeded_mess(capitalize(person) +
                      " is not a sponsor of " +
                      query_the_paper_name() + " anymore.\n");
   return 1;
}
int do_promote(string person)
{
   object thatguy;
   if (_proxy) {
      return _proxy->do_promote(person);
   }
   person = lower_case(person);
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   if (is_editor(person)) {
      add_failed_mess(capitalize(person) + " is already an editor!\n");
      return 0;
   }
   add_editor(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "been promoted to editor of " + query_the_paper_name() + " by " +
                  this_player()->the_short() + "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " promoted " + capitalize(person) + " to " +
                 "editor.\n");
   add_succeeded_mess(capitalize(person) +
                      " is now an editor of " + query_the_paper_name() + ".\n");
   return 1;
}
int do_demote(string person, int editor)
{
   object thatguy;
   if (_proxy) {
      return _proxy->do_demote(person, editor);
   }
   person = lower_case(person);
   if (editor) {
      if (!is_editor(person)) {
         add_failed_mess
            ("There is nobody by that name currently employed as an "
             "editor at " + query_the_paper_name() + "!\n");
         return 0;
      }
      remove_editor(person);
   } else {
      if (!is_setter(person)) {
         add_failed_mess
            ("There is nobody by that name currently employed as a "
             "setter at " + query_the_paper_name() + "!\n");
         return 0;
      }
      remove_setter(person);
   }
   add_reporter(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy,
                  this_player()->the_short() +
                  " just demoted you as an editor of " + query_the_paper_name() + "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " demoted " + capitalize(person) +
                 " to reporter.\n");
   add_succeeded_mess(capitalize(person) +
                      " is no longer an editor of " + query_the_paper_name() + ".\n");
   return 1;
}
int do_everyone_status() {
   string ret;
   if (_proxy) {
      return _proxy->do_everyone_status();
   }
   ret = query_the_paper_name() + " has the following employees:\n";
   ret += "$I$3=Owner: " +
          query_owner() +
          "\n";
   ret += "$I$3=Reporters: " +
          query_multiple_short(sort_array(query_all_reporters(), 0)) +
          "\n";
   ret += "$I$3=Setters  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_setters(), 0)):"no one") +
          "\n";
   ret += "$I$3=Editors  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_editors() - ({ query_owner() }), 0)):"no one") +
          "\n";
   write("$P$Status$P$" + ret);
   return 1;
}
int do_status()
{
   string ret;
   int i;
   int last_num;
   if (_proxy) {
      return _proxy->do_status();
   }
   ret = query_the_paper_name() + " has the following employees:\n";
   ret += "$I$3=Owner: " +
          query_owner() +
          "\n";
   ret += "$I$3=Reporters: " +
          query_multiple_short(sort_array(query_all_reporters(), 0)) +
          "\n";
   ret += "$I$3=Setters  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_setters(), 0)):"no one") +
          "\n";
   ret += "$I$3=Editors  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_editors() - ({ query_owner() }), 0)):"no one") +
          "\n";
   ret += "$I$3=Sponsors : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_sponsors(), 0)):"no one") +
          "\n";
   ret += "\n$I$0=Sale Statistics:\n";
   last_num = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   for (i = last_num - 5; i <= last_num; i++) {
      if (i >= 1) {
         ret += "Edition " + i + " sold to " +
             NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, i) +
             " people.\n";
      }
   }
   ret += "\n";
   ret += "Using Bank  : " + _bank_branch + "\n";
   write("$P$Status$P$" + ret);
   return 1;
}
int do_claim()
{
   object badge;
   object *deepinv;
   object *inv;
   if (_proxy) {
      return _proxy->do_claim();
   }
   deepinv = deep_inventory(this_player()) + ({ this_player() });
   inv = filter(deepinv, (: $1->query_paper_name() == query_paper_name() :));
   if (sizeof(inv)) {
      add_failed_mess
         ("You already have a set of credentials!  Why would you "
          "want another?\n");
      return 0;
   }
   badge = clone_object(NEWSPAPER_PRESS_CREDITIALS);
   badge->set_drop();
   badge->set_paper_name(query_paper_name());
   if (badge->move(this_player()) != MOVE_OK) {
      badge->move(this_object());
      tell_object(this_player(),
                  "The credentials are too heavy for you, so they fall "
                  "to the floor.\n");
   }
   badge->reset_drop();
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " claimed some new credentials.\n");
   add_succeeded_mess(({ "A new set of credentials appear from thin air, as "
                         "if by magic!\n",
                         "$N $V a set of credentials.\n" }));
   return 1;
}
int do_publish(string headline)
{
   class our_article* bing;
   if (_proxy) {
      return _proxy->do_publish(headline);
   }
   bing = filter(_articles, (: !$1->flags & NEWSPAPER_POSTPONE_FLAG :));
   if (!sizeof(bing)) {
      add_failed_mess("You cannot publish with no articles!\n");
      return 0;
   }
   write("Do you wish to publish this edition with a headline of:\n" +
          headline + "\nResponse [y/n]? ");
   add_succeeded_mess("");
   input_to("really_publish", 0, headline);
   return 1;
}
int query_total_profit(int num_articles) {
   int last_pub;
   int amount;
   int edition;
   int adds;
   class advert data;
   class our_article bing;
   string text;
   if (num_articles == -1) {
      num_articles = 0;
      foreach (bing in _articles) {
         if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
            text = load_article_text(bing);
            if (strlen(text) > 500) {
               num_articles++;
            }
         }
      }
   }
   foreach (data in _adverts) {
      adds += data->value;
   }
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   last_pub = NEWSPAPER_HANDLER->query_edition_date(_paper_name, edition);
   amount = NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, edition) * 100;
   amount = amount * 400 + adds;
   if ((time() - last_pub) < 42 * 24 * 60 * 60) {
      return amount;
   }
   last_pub = (time() - last_pub) - 42 * 24 * 60 * 60;
   last_pub = last_pub / (24 * 60 * 60);
   amount = ( amount / 150 ) * (150 - last_pub);
   return amount + _owner_extra_cash;
}
void really_publish(string char, string headline)
{
   int article_count;
   int amount;
   int total;
   string *things;
   string temp;
   class article* to_publish;
   string* text;
   class our_article bing;
   class payee_data data;
   string stuff;
   string place;
   int i;
   int editor_bonus;
   int num_editors;
   place = query_property("place");
   char = lower_case(char);
   things = ({ });
   if (strlen(char) && char[0] == 'y') {
      tell_object(this_player(),
                  "Okay, warm up the frogs, let's see if everything is "
                  "sorted out.\n");
   } else {
      tell_object(this_player(), "Okay, publishing aborted.\n");
      return 0;
   }
   to_publish = ({ });
   text = ({ });
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         to_publish += ({ copy(bing->art) });
         text += ({ load_article_text(bing) });
         if (strlen(text[<1]) > 500) {
            article_count++;
         }
      }
   }
   amount = query_total_profit(article_count);
   foreach (temp, data in _payees) {
      total += data->paid;
   }
   num_editors = sizeof(query_all_editors() - ({ query_owner() }));
   editor_bonus = (amount * 5 / 100) / num_editors;
   total += (amount * 5 / 100) * num_editors;
   if (amount < total) {
      add_failed_mess("You have allocated paying your reporters " + total +
                      " when you only have " + amount + " total profit.\n");
      return 0;
   }
   if (!NEWSPAPER_HANDLER->publish_paper(query_paper_name(),
                                         headline,
                                         to_publish,
                                         text,
                                         _adverts,
                                         query_all_editors())) {
      tell_object(this_player(), "There was an error making the new issue!\n");
      return ;
   }
   _adverts = ({ });
   _owner_extra_cash = 0;
   stuff = "Edition summary.\nArticles posted:\n";
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         stuff += bing->art->title + " by " + bing->art->shown_name + "\n";
         delete_article(bing);
      }
   }
   _articles = filter(_articles, (: $1->flags & NEWSPAPER_POSTPONE_FLAG :));
   stuff += "\nTotal profit " +
            MONEY_HAND->money_value_string(amount, place) +
            ".\n";
   BANK_HANDLER->adjust_account(query_owner(), query_bank_branch(),
                                (amount - total));
   amount = editor_bonus;
   if (sizeof(query_all_editors() - ({ query_owner() })) > 0) {
      stuff += "\nEditors bonus " +
               query_multiple_short(query_all_editors() - ({ query_owner() })) +
               " paid " +
               MONEY_HAND->money_value_string(amount, place) + "each.\n";
      foreach (temp in query_all_editors()) {
         if (temp != query_owner()) {
            BANK_HANDLER->adjust_account(temp, query_bank_branch(),
                                         (amount));
            _reporters[temp]->total_payed += amount;
         }
      }
   }
   stuff += "\nReporters paid:\n";
   foreach (temp, data in _payees) {
      BANK_HANDLER->adjust_account(temp, query_bank_branch(), data->paid);
      if (is_reporter(temp)) {
         _reporters[temp]->total_payed += data->paid;
         stuff += temp + " " +
               MONEY_HAND->money_value_string(data->paid, place) + ".\n";
         i++;
         call_out((: AUTO_MAILER->auto_mail($1, $2, $3, $4, $5) :), i * 4,
                   temp,
                                this_object()->query_short(),
                                "Payment for new edition.",
                                "",
                                "A new edition has been released and "
                                "you have been paid!\n\n"
                                "For your work on the newspaper you "
                                "have been paid " +
                                MONEY_HAND->money_value_string(data->paid, place) +
                                ".\n\n" +
                                (data->message?data->message:"") );
      }
   }
   call_out((: AUTO_MAILER->auto_mail($1, $2, $3, $4, $5) :), i * 4,
                          implode(query_all_editors(), ","),
                          this_object()->query_short(),
                          "Published new edition.",
                          implode(query_all_editors(), ","),
                          stuff);
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " published an edition of " + query_the_paper_name() + ".\n");
   _published_time = time();
   _payees = ([ ]);
   rename(query_article_log_file_name(),
             _save_dir + "article" + query_current_edition() + ".log");
   save_me();
   write("$P$Summary$P$" +
               "The pages have been sent to the printery, and another "
               "edition of " + query_the_paper_name() +
               " is about to hit the streets!  You feel rather "
               "impressed with your efforts.\n\n" + stuff);
   return;
}
int do_summary() {
   int amount;
   int adds;
   string person;
   int total;
   class our_article bing;
   class payee_data payee_data;
   string text;
   string ret;
   int article_count;
   string place;
   class advert data;
   int i;
   int last_num;
   int num_editors;
   int editor_bonus;
   if (_proxy) {
      return _proxy->do_summary();
   }
   ret = "";
   last_num = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   for (i = last_num - 5; i <= last_num; i++) {
      if (i >= 1) {
         ret += "Edition " + i + " sold to " +
             NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, i) +
             " people.\n";
      }
   }
   ret += "\n";
   place = query_property("place");
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         text = load_article_text(bing);
         if (strlen(text) > 500) {
            article_count++;
         }
      }
   }
   ret += "Article count of " + article_count + "\n";
   if (!_adverts) {
      _adverts = ({ });
   }
   foreach (data in _adverts) {
      adds += data->value;
   }
   amount = query_total_profit(article_count);
   foreach (person, payee_data in _payees) {
      total += payee_data->paid;
   }
   num_editors = sizeof(query_all_editors() - ({ query_owner() }));
   editor_bonus = (amount * 5 / 100) / num_editors;
   total += editor_bonus * num_editors;
   ret += "Using Bank  : " + _bank_branch + "\n";
   ret += "Total Profit: " +
         MONEY_HAND->money_value_string(amount, place) +
         ", total editor bonus " +
         MONEY_HAND->money_value_string(editor_bonus * num_editors, place) +
         ", total paid to reporters " +
         MONEY_HAND->money_value_string(total, place) +
         ", profit from adverts " +
         MONEY_HAND->money_value_string(adds, place) +
         (_owner_extra_cash > 0 ?
         ", " + MONEY_HAND->money_value_string(_owner_extra_cash, place) +
            " extra added by the owner":"") +
         ".\n\n";
   ret += "Owner/Editors:\n";
   ret += "   " + query_owner() + " " +
          MONEY_HAND->money_value_string((amount - total), place) +
          " (owner)\n";
   ret += "Reporters:\n";
   foreach (person, payee_data in _payees) {
      if (!is_editor(person)) {
         ret += "$I$6=   " + person + " " +
                MONEY_HAND->money_value_string(payee_data->paid, place) +
                (payee_data->message?" " + payee_data->message:"") + ".\n";
      }
   }
   ret += "$I$0=Editor Bonuses:\n";
   foreach (person in query_all_editors()) {
      if (person != query_owner()) {
         if (!_payees[person]) {
            _payees[person] = new(class payee_data);
         }
         ret += "   " + person  + " " +
                MONEY_HAND->money_value_string(editor_bonus, place) +
                " Total " +
                MONEY_HAND->money_value_string((editor_bonus + _payees[person]->paid), place) +
                "\n";
      }
   }
   write("$P$Profits$P$" + ret);
   return 1;
}
int do_deposit(string amt) {
   int amt_int;
   string place;
   if (_proxy) {
      return _proxy->do_deposit(amt);
   }
   if (this_player()->query_name() != query_owner()) {
      add_failed_mess("Only the owner can do this.\n");
      return 0;
   }
   place = query_property("place");
   amt_int = MONEY_HAND->value_from_string(amt, place);
   if (amt_int <= 0) {
      add_failed_mess("The amount " + amt + " is invalid.\n");
      return 0;
   }
   if (BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       amt_int) {
      add_failed_mess("You do not have " +
                      MONEY_HAND->money_value_string(amt_int, place) +
                      " in " + query_bank_branch() + ".\n");
      return 0;
   }
   _owner_extra_cash += amt_int;
   save_me();
   BANK_HANDLER->adjust_account(this_player()->query_name(), _bank_branch, -amt_int);
   add_succeeded_mess(({ "$N deposit " +
                      MONEY_HAND->money_value_string(amt_int, place) +
                      " for extra cash to pay reporters.\n",
                      "$N deposits some extra cash for reporters.\n" }));
   return 1;
}
int do_set_bank_branch(string branch)
{
   string* accounts;
   if (_proxy) {
      return _proxy->do_set_bank_branch(branch);
   }
   accounts = BANK_HANDLER->query_accounts(this_player()->query_name());
   if (member_array(branch, accounts) == -1) {
      add_failed_mess("You need to specify a bank you have an account "
                      "with: " + query_multiple_short(accounts) +
                      ".\n");
      return 0;
   }
   _bank_branch = branch;
   save_me();
   add_succeeded_mess("$N set$s the bank branch to " + branch + ".\n");
   return 1;
}
int do_pay(string person,
           string amt)
{
   string place;
   string fluff;
   int amount;
   int profit;
   int total;
   class payee_data data;
   if (_proxy) {
      return _proxy->do_pay(person, amt);
   }
   place = query_property("place");
   if (amt == "none" || amt == "0") {
      amount = 0;
   } else {
      amount = MONEY_HAND->value_from_string(amt, place);
      if (amount <= 0) {
         add_failed_mess("Sorry, you must pay reporters a "
                         "positive amount.\n");
         return 0;
      }
   }
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                       query_the_paper_name() + "!\n");
      return 0;
   }
   if (person == query_owner()) {
      add_failed_mess("The owner gets paid anyway.\n");
      return 0;
   }
   profit = query_total_profit(-1);
   profit = profit * 95 / 100;
   foreach (fluff, data in _payees) {
      total += data->paid;
   }
   if (profit - total - amount < 0) {
      add_failed_mess("You are not making enough money to pay " +
                      person + " " +
                      MONEY_HAND->money_value_string(amount, place) +
                      ".\n");
      return 0;
   }
   if (!_payees[person]) {
      _payees[person] = new(class payee_data);
   }
   _payees[person]->paid = amount;
   if (_payees[person]->paid < 0) {
      add_succeeded_mess(({ "You can't pay anybody less than nothing!  "
                            "Amount owing reset to nothing.\n", "" }));
      map_delete(_payees, person);
      save_me();
      return 1;
   }
   if (!_payees[person]->paid) {
      add_succeeded_mess(({ "Ok, amount owing set to nothing.\n", "" }));
      map_delete(_payees, person);
      save_me();
      return 1;
   }
   add_succeeded_mess(({ "Ok, " + capitalize(person) + " will be paid a "
                         "total of " +
                     MONEY_HAND->money_value_string(_payees[person]->paid, place) +
                         " for this edition.\n", "" }));
   save_me();
   return 1;
}
int do_pay_tag(string person,
               string tag)
{
   if (_proxy) {
      return _proxy->do_pay_tag(person, tag);
   }
   if (tag == "none") {
      tag = 0;
   }
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                       query_the_paper_name() + "!\n");
      return 0;
   }
   if (person == query_owner()) {
      add_failed_mess("The owner gets paid anyway.\n");
      return 0;
   }
   if (!_payees[person]) {
      add_failed_mess("You can only set a reason for someone who is "
                      "being paid.\n");
      return 0;
   }
   _payees[person]->message = tag;
   if (!tag) {
      add_succeeded_mess(({ "You remove the message from " +
                            capitalize(person) + ".\n", "" }));
   } else {
      add_succeeded_mess(({ "You set a message to " + capitalize(person) +
                            " of " + tag + ".\n", "" }));
   }
   save_me();
   return 1;
}
int do_title(string id, string title)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_title(id, title);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   art->art->title = title;
   save_me();
   add_succeeded_mess(({ "You set the title to " + title + ".\n",
                         "$N sets the title of an article.\n" }));
   return 1;
}
int do_author(string id, string author)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_author(id, author);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   art->art->shown_name = author;
   save_me();
   add_succeeded_mess(({ "You set the author to " + author + ".\n",
                         "$N sets the author of an article.\n" }));
   return 1;
}
int do_change(string id, string type)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_change(id, type);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   if (type == "html") {
      art->art->type = NEWSPAPER_ARTICLE_TYPE_HTML | a_flags(art->art->type);
   } else {
      art->art->type = NEWSPAPER_ARTICLE_TYPE_PLAIN | a_flags(art->art->type);
   }
   save_me();
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".nroff.o" ) :) );
   add_succeeded_mess(({ "You set the article type to " + type + ".\n",
                         "$N sets the type of an article.\n" }));
   return 1;
}
int do_change_xp(string id, string type)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_change_xp(id, type);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name())) {
      add_failed_mess("Only the editors can do this.\n");
      return 0;
   }
   if (type == "none") {
      art->art->type |= NEWSPAPER_ARTICLE_NO_XP_FLAG;
   } else {
      art->art->type &= ~NEWSPAPER_ARTICLE_NO_XP_FLAG;
   }
   save_me();
   add_succeeded_mess(({ "You set the article xp return to " + type + ".\n",
                         "$N sets the xp return of an article.\n" }));
   return 1;
}
int do_change_colour(string id, string colour)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_change_colour(id, colour);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   if (colour != "none") {
      art->art->colour = upper_case(colour);
   } else {
      art->art->colour = 0;
   }
   save_me();
   add_succeeded_mess(({ "You set the article colour to " + colour + ".\n",
                         "$N sets the colour of an article.\n" }));
   return 1;
}
int do_editing(string id)
{
   class our_article art;
   string contents;
   if (_proxy) {
      return _proxy->do_editing(id);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked for "
                      "submissions.\n");
      return 0;
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   if (art->flags & NEWSPAPER_LOCK_FLAG) {
      add_failed_mess("This article is locked.\n");
      return 0;
   }
   contents = load_article_text(art);
   add_succeeded_mess("");
   this_player()->do_edit(contents, "finish_editing", this_object(), 0, art);
   return 1;
}
int move_article(int index, string up_down) {
   class our_article womble;
   if (index == -1) {
      return 0;
   }
   womble = _articles[index];
   if (up_down == "up") {
      if (index > 0) {
         _articles = _articles[0..index - 1] + _articles[index+1..];
         _articles = _articles[0..index - 2] + ({ womble }) +
                     _articles[index - 1..];
         save_me();
      } else {
         return 0;
      }
   } else {
      if (index < sizeof(_articles) - 1) {
         _articles = _articles[0..index - 1] + _articles[index+1..];
         _articles = _articles[0..index] + ({ womble }) +
                     _articles[index + 1..];
         save_me();
      } else {
         return 0;
      }
   }
   return 1;
}
int do_move(string article, string up_down) {
   int index;
   class our_article womble;
   if (_proxy) {
      return _proxy->do_move(article, up_down);
   }
   index = query_article_index(article);
   if (index == -1) {
      add_failed_mess("Article reference " + index + " is out of bounds.\n");
      return 0;
   }
   womble = _articles[index];
   if (!move_article(index, up_down)) {
      add_failed_mess("Unable to move the article.\n");
      return 0;
   }
   add_succeeded_mess(({ "You moved the article " + womble->art->title + " " +
                         up_down + ".\n", "" }));
   return 1;
}
int do_move_pos(string article, string pos) {
   int index;
   int to_index;
   class our_article womble;
   if (_proxy) {
      return _proxy->do_move_pos(article, pos);
   }
   index = query_article_index(article);
   if (index == -1) {
      add_failed_mess("Article reference " + index + " is out of bounds.\n");
      return 0;
   }
   to_index = query_article_index(pos);
   if (to_index == -1) {
      add_failed_mess("Article reference " + pos + " is out of bounds.\n");
      return 0;
   }
   if (to_index == index) {
      add_failed_mess("You cannot move the article there, it is already "
                      "there.\n");
      return 0;
   }
   womble = _articles[index];
   if (index < to_index) {
      _articles = _articles[0..index - 1] + _articles[index + 1..to_index] +
                  ({ _articles[index] }) + _articles[to_index+1..];
   } else {
      _articles = _articles[0..to_index - 1] +
                  ({ _articles[index] }) +
                  _articles[to_index..index - 1] +
                  _articles[index+1..];
   }
   save_me();
   add_succeeded_mess(({ "You moved the article " + womble->art->title +
                         " to " + pos + ".\n", "" }));
   return 1;
}
int do_postpone(string id, string on_off) {
   class our_article art;
   if (_proxy) {
      return _proxy->do_postpone(id, on_off);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article reference " + id + " does not exist.\n");
      return 0;
   }
   if (on_off == "on") {
      art->flags |= NEWSPAPER_POSTPONE_FLAG;
      add_succeeded_mess(({ "You postpone the article " + art->art->title +
                            " to a later issue.\n",
                            "" }));
   } else {
      art->flags &= ~NEWSPAPER_POSTPONE_FLAG;
      add_succeeded_mess(({ "You unpostpone the article " + art->art->title +
                            " so it will be in this issue.\n",
                            "" }));
   }
   save_me();
   return 1;
}
int do_lock_article(string id, string on_off) {
   class our_article art;
   if (_proxy) {
      return _proxy->do_lock_article(id, on_off);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article reference " + id + " does not exist.\n");
      return 0;
   }
   if (on_off == "on") {
      art->flags |= NEWSPAPER_LOCK_FLAG;
      add_succeeded_mess(({ "You lock the article " + art->art->title +
                            ".\n",
                            "" }));
   } else {
      art->flags &= ~NEWSPAPER_LOCK_FLAG;
      add_succeeded_mess(({ "You unlock the article " + art->art->title +
                            ".\n",
                            "" }));
   }
   save_me();
   return 1;
}
int do_category_list() {
   string ret;
   string place;
   string name;
   class category_data data;
   if (_proxy) {
      return _proxy->do_category_list();
   }
   if (!sizeof(_category)) {
      add_failed_mess("There are no categories.\n");
      return 0;
   }
   ret = "";
   place = query_property("place");
   foreach (name, data in _category) {
      ret += "$I$5=" + name + " costs ";
      if (data->cost_per_add) {
         ret += MONEY_HAND->money_value_string(data->cost_per_add, place);
      } else {
         ret += "nothing";
      }
      ret += " per add and ";
      if (data->cost_per_ten_chars) {
         ret += MONEY_HAND->money_value_string(data->cost_per_ten_chars,
                                               place);
      } else {
         ret += "nothing";
      }
      ret += " for every ten characters.";
      if (!data->open) {
         ret += "  The category is currently closed.\n";
      } else {
         ret += "\n";
      }
   }
   write("$P$Category$P$" + ret);
   return 1;
}
int do_advert_list() {
   string ret;
   string place;
   class advert data;
   int editor;
   int found;
   int pos;
   if (_proxy) {
      return _proxy->do_advert_list();
   }
   if (!sizeof(_adverts)) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }
   ret = "";
   place = query_property("place");
   editor = is_editor(this_player()->query_name());
   pos = 1;
   foreach (data in _adverts) {
      if (editor ||
          lower_case(data->author) == this_player()->query_name()) {
         if (editor) {
            ret += "$I$5=" + pos + ") ";
         } else {
            ret += "$I$5=";
         }
         ret += data->author + " cost " +
                MONEY_HAND->money_value_string(data->value, place) +
                " written at " + ctime(data->date_written) + ":\n" +
                data->text + "\n";
         found = 1;
      }
      pos++;
   }
   if (!found) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }
   write("$P$Category$P$" + ret);
   return 1;
}
int do_advert_remove(int id) {
   class advert fluff;
   if (_proxy) {
      return _proxy->do_advert_remove(id);
   }
   if (!sizeof(_adverts)) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name())) {
      add_failed_mess("You must be an editor to remove adverts.\n");
      return 0;
   }
   if (id < 1 || id > sizeof(_adverts)) {
      add_failed_mess("The id " + id + " is invalid.\n");
      return 0;
   }
   fluff = _adverts[id - 1];
   _adverts = _adverts[0..id-2] + _adverts[id..];
   add_succeeded_mess("$N remove$s an advert by " + fluff->author + ".\n");
   return 1;
}
int do_category_remove(string category) {
   if (_proxy) {
      return _proxy->do_category_remove(category);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }
   if (sizeof(filter(_adverts, (: $1->category == $2 :), category))) {
      add_failed_mess("You have adverts in that category, you cannot "
                      "remove it.\n");
      return 0;
   }
   map_delete(_category, category);
   save_me();
   add_succeeded_mess(({ "You delete the category " + category + ".\n",
                          "" }));
   return 1;
}
int do_category_add(string category) {
   string new_category;
   if (_proxy) {
      return _proxy->do_category_add(category);
   }
   new_category = query_category(category);
   if (new_category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }
   _category[category] = new(class category_data,
                             open : 0,
                             cost_per_add : 40,
                             cost_per_ten_chars : 40);
   save_me();
   add_succeeded_mess(({ "You add the category " + category + ".\n",
                          "" }));
   return 1;
}
int do_category_open(string category, string open) {
   if (_proxy) {
      return _proxy->do_category_open(category, open);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }
   _category[category]->open = open == "open";
   save_me();
   add_succeeded_mess(({ "You " + open + " the category " + category + ".\n",
                          "" }));
   return 1;
}
int do_category_cost(string category, string cost) {
   int value;
   string place;
   if (_proxy) {
      return _proxy->do_category_cost(category, cost);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must change a cost for a category.\n");
      return 0;
   }
   place = query_property("place");
   if (lower_case(cost) == "none") {
      value = 0;
   } else {
      value = MONEY_HAND->value_from_string(cost, place);
      if (!value) {
         add_failed_mess("The value " + cost + " is not a valid money "
                         "value.\n");
         return 0;
      }
   }
   _category[category]->cost_per_add = value;
   save_me();
   add_succeeded_mess(({ "You set the cost per add in category " +
                         category + " to " +
                         MONEY_HAND->money_value_string(value, place) +
                         ".\n",
                          "" }));
   return 1;
}
int do_category_cost_per_ten_chars(string category, string cost) {
   int value;
   string place;
   if (_proxy) {
      return _proxy->do_category_cost_per_ten_chars(category, cost);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must change a cost for a category.\n");
      return 0;
   }
   place = query_property("place");
   if (lower_case(cost) == "none") {
      value = 0;
   } else {
      value = MONEY_HAND->value_from_string(cost, place);
      if (!value) {
         add_failed_mess("The value " + cost + " is not a valid money "
                         "value.\n");
         return 0;
      }
   }
   _category[category]->cost_per_ten_chars = value;
   save_me();
   add_succeeded_mess(({ "You set the cost per ten characters in category " +
                         category + " to " +
                         MONEY_HAND->money_value_string(value, place) +
                         ".\n",
                          "" }));
   return 1;
}
int do_submit_section(string name) {
   class our_article cur_art;
   if (_proxy) {
      return _proxy->do_submit_section(name);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked.\n");
      return 0;
   }
   cur_art = new(class our_article);
   cur_art->art = new(class article);
   cur_art->art->title = name;
   cur_art->art->shown_name = this_player()->query_name();
   cur_art->art->author = this_player()->query_name();
   cur_art->art->date_written = time();
   cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_SECTION;
   _articles += ({ cur_art });
   save_me();
   add_succeeded_mess("$N $V a section.\n");
   return 1;
}
int do_submit_add(string category) {
   if (_proxy) {
      return _proxy->do_submit_add(category);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked.\n");
      return 0;
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must specify an existing category to "
                      "submit an add in.\n");
      return 0;
   }
   if (!_category[category]->open) {
      add_failed_mess("The category must be open to submit an add "
                      "for it.\n");
      return 0;
   }
   add_succeeded_mess(({ "", "$N starts submiting an add to " +
                 this_object()->the_short() +
                      ".\n" }));
   write("Please submit the text of your add:\n");
   this_player()->do_edit(0, "finish_add", this_object(), 0, category);
   return 1;
}
int do_lock(int locked) {
   if (_proxy) {
      return _proxy->do_lock(locked);
   }
   _locked = locked;
   if (_locked) {
      add_succeeded_mess("$N lock$s " + this_object()->the_short() + ".\n");
   } else {
      add_succeeded_mess("$N unlock$s " + this_object()->the_short() + ".\n");
   }
   return 1;
}
void finish_add(string str, string category) {
   int value;
   string place;
   if (!str || !strlen(str)) {
      write("Ok, Aborted writing an add.\n");
      return ;
   }
   if (is_sponsor(this_player()->query_name())) {
      write("You add in the category " + category + " with a text of:\n" +
             str + "\n\nThis will cost you nothing since you are a sponsor.\n"
               ", do you want to do this? ");
      input_to("confirm_add", 0, str, category, 0);
   } else {
      place = query_property("place");
      value = _category[category]->cost_per_add +
              _category[category]->cost_per_ten_chars * strlen(str) / 10;
      if (this_player()->query_value_in(place) < value) {
         write("You add in the category " + category + " with a text of:\n" +
               str + "\n\nThis will cost you " +
               MONEY_HAND->money_value_string(value, place) +
               ", but you do not have enough money!  Sorry.\n");
      } else {
         write("You add in the category " + category + " with a text of:\n" +
               str + "\n\nThis will cost you " +
               MONEY_HAND->money_value_string(value, place) +
               ", do you want to do this? ");
         input_to("confirm_add", 0, str, category, value);
      }
   }
}
void confirm_add(string str, string text, string category, int value) {
   class advert add;
   string place;
   int found;
   class our_article bing;
   if (!str || !strlen(str)) {
      return 0;
   }
   if (lower_case(str)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   if (!is_sponsor(this_player()->query_name())) {
      place = query_property("place");
      if (this_player()->query_value_in(place) < value) {
         add_failed_mess("You do not have " +
            MONEY_HAND->money_value_string(value, place) +
            " to pay for the add.\n");
         return ;
      }
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place),
                               place);
   }
   add = new(class advert);
   add->author = this_player()->query_cap_name();
   add->text = text;
   add->category = category;
   add->value = value;
   add->date_written = time();
   _adverts += ({ add });
   foreach (bing in _articles) {
      if (a_type(bing->art->type) == NEWSPAPER_ARTICLE_TYPE_ADVERTS) {
         found = 1;
         break;
      }
   }
   if (!found) {
      _articles += ({ new(class our_article,
                          art : new(class article,
                                    title : "Adverts",
                                    author : query_owner(),
                                    shown_name : query_owner(),
                                    date_written : time(),
                                    type : NEWSPAPER_ARTICLE_TYPE_ADVERTS
                                   )
                          ) });
   }
   save_me();
   write("Ok, your advertisement is added.\n");
}
int finish_editing(string story, class our_article art)
{
   if (!story) {
      tell_object(this_player(), "Ok, no editing saved.\n");
      return 0;
   }
   save_article_text(art, story);
   log_file(query_article_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " edited the story " + art->art->title + ".\n");
}
int do_transfer_ownership(string new_owner) {
   int value;
   string place;
   if (!is_owner(this_player()->query_name())) {
      add_failed_mess("You must be the owner to transfer the ownership.\n");
      return 0;
   }
   if (_proxy) {
      add_failed_mess("You must be in the main office to transfer ownership.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(new_owner)) {
      add_failed_mess("You must transfer ownership to someone that exists.\n");
      return 0;
   }
   place = query_property("place");
   value = HOUSING->query_value(base_name(this_object()));
   if (this_player()->query_value_in(place) < value &&
       BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       value) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(value, place)  +
                      " to transfer the ownership, in hand or in the bank.\n");
      return 0;
   }
   write("It will cost you " + MONEY_HAND->money_value_string(value, place)  +
         " in fees to transfer ownership to " +
         new_owner + ".\nDo you want to do this? ");
   input_to("check_transfer", 0, new_owner, value);
   add_succeeded_mess("");
   return 1;
}
void check_transfer(string test, string new_owner, int value) {
   string place;
   test = lower_case(test);
   if (!strlen(test) || test[0] != 'y') {
      write("Aborted.\n");
      return 0;
   }
   place = query_property("place");
   if (this_player()->query_value_in(place) < value  &&
       BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       value) {
      write("You need at least " +
                      MONEY_HAND->money_value_string(value, place)  +
                      " to transfer the ownership.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) >= value ) {
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place), place);
   } else {
       BANK_HANDLER->adjust_account(this_player()->query_name(), query_bank_branch(), -value);
   }
   write("Transfering the ownership from " +
         query_owner() + " to " + new_owner + ".\n");
   HOUSING->set_owner(base_name(this_object()), new_owner);
}
string* query_all_reporters()
{
   return keys(_reporters);
}
string* query_all_setters()
{
   return copy(_setters);
}
string* query_all_sponsors()
{
   return copy(_sponsors);
}
string* query_all_editors()
{
   return _editors + ({ query_owner() });
}
mapping query_all_payees()
{
   return copy(_payees);
}
class article* query_all_articles() {
   return map(_articles, (: copy($1->art) :) );
}
int is_postponed(class article art) {
   class our_article rabbit;
   foreach (rabbit in _articles) {
      if (rabbit->art->file_name == art->file_name) {
         return rabbit->flags & NEWSPAPER_POSTPONE_FLAG;
      }
   }
   return 0;
}
int is_locked(class article art) {
   class our_article rabbit;
   foreach (rabbit in _articles) {
      if (rabbit->art->file_name == art->file_name) {
         return rabbit->flags & NEWSPAPER_LOCK_FLAG;
      }
   }
   return 0;
}
int is_reporter(string word)
{
   if (_proxy) {
      return _proxy->is_reporter(word);
   }
   return classp(_reporters[word]);
}
int is_setter(string word)
{
   if (_proxy) {
      return _proxy->is_setter(word);
   }
   return member_array(word, _setters) != -1;
}
int is_sponsor(string word)
{
   if (_proxy) {
      return _proxy->is_sponsor(word);
   }
   return member_array(word, _sponsors) != -1;
}
int is_editor(string word)
{
   if (_proxy) {
      return _proxy->is_editor(word);
   }
   if (master()->query_administrator(word)) {
      return 1;
   }
   if (word == query_owner()) {
      return 1;
   }
   return member_array(word, _editors) != -1;
}
int is_owner(string word)
{
   if (_proxy) {
      return _proxy->is_owner(word);
   }
   if (master()->query_administrator(word)) {
      return 1;
   }
   if (word == query_owner()) {
      return 1;
   }
   return 0;
}
void add_reporter(string word)
{
   if (!_reporters[word]) {
      _reporters[word] = new(class reporter);
      _reporters[word]->date_added = time();
      update_commands(word);
      save_me();
   }
}
void add_sponsor(string word)
{
   if (!is_sponsor(word)) {
      _sponsors += ({ word });
      update_commands(word);
      save_me();
   }
}
void add_setter(string word)
{
   if (!is_setter(word)) {
      if (!is_reporter(word)) {
         add_reporter(word);
      }
      _setters += ({ word });
      update_commands(word);
      save_me();
   }
}
void add_editor(string word)
{
   if (!is_editor(word)) {
      if (!is_reporter(word)) {
         add_reporter(word);
      }
      _editors += ({ word });
      update_commands(word);
      save_me();
   }
}
void remove_reporter(string word)
{
   if (!is_reporter(word)) {
      return;
   }
   map_delete(_reporters, word);
   update_commands(word);
   save_me();
}
void remove_editor(string word)
{
   if (!is_editor(word)) {
      return;
   }
   _editors -= ({ word });
   update_commands(word);
   save_me();
}
void remove_setter(string word)
{
   if (!is_setter(word)) {
      return;
   }
   _setters -= ({ word });
   update_commands(word);
   save_me();
}
void remove_sponsor(string word)
{
   if (!is_sponsor(word)) {
      return;
   }
   _sponsors -= ({ word });
   save_me();
}
void update_commands(string word)
{
   object player;
   player = find_player(word);
   if (player && environment(player) == this_object()) {
      player->move("/room/void");
      player->move(file_name(this_object()));
   }
}
string query_owner() {
   if (_proxy) {
      return _proxy->query_owner();
   }
   return _owner;
}
void set_owner(string person) {
   _owner = person;
   save_me();
}
void ownership_change(string old_owner, string new_owner) {
   set_owner(new_owner);
}
void set_proxy(string proxy) {
   _proxy = proxy;
}
string query_proxy() {
   return _proxy;
}
int board_access_check(int type, string board, object previous, string name) {
   switch (type) {
   case B_ACCESS_READ :
      return is_reporter(lower_case(name));
   case B_ACCESS_WRITE :
      return is_reporter(lower_case(name));
   case B_ACCESS_DELETE :
      return is_editor(name);
   }
}
void init()
{
   string person;
   person = this_player()->query_name();
   add_command("advert", "categories", (: do_category_list() :));
   add_command("advert", "list", (: do_advert_list() :));
   add_command("category", "list", (: do_category_list() :));
   add_command("submit", "advert {in|to|into} <string'category'>",
               (: do_submit_add($4[1]) :));
   add_command("submit", "advert <string'category'>",
               (: do_submit_add($4[0]) :));
   if (!is_editor(person) && !is_reporter(person) && !is_setter(person)) {
      add_command("apply", "", (: do_apply() :));
      add_command("status", "", (: do_everyone_status() :));
      return;
   }
   add_command("submit", "text <string:quoted'article name'> as <string'author'>",
               (: do_submit($4[0], $4[1], 0) :));
   add_command("submit", "html <string:quoted'article name'> as <string'author'>",
               (: do_submit($4[0], $4[1], 1) :));
   add_command("submit", "text <string'article name'>",
               (: do_submit($4[0], 0, 0) :));
   add_command("submit", "html <string'article name'>",
               (: do_submit($4[0], 0, 1) :));
   add_command("retrieve", "<string'article'>", (: do_retrieve($4[0], 0) :));
   add_command("retrieve", "source <string'article'>",
               (: do_retrieve($4[0], 1) :));
   add_command("resign", "", (: do_resign() :));
   add_command("status", "", (: do_status() :));
   add_command("status", "room", (: do_status() :));
   add_command("claim", "", (: do_claim() :));
   add_command("articles", "", (: do_articles(0) :));
   add_command("articles", "scroll", (: do_articles(1) :));
   add_command("edit", "<string'article'>", (: do_editing($4[0]) :));
   add_command("delete", "<string'article'>", (: do_delete($4[0]) :));
   add_command("title", "<string'article'> <string'new title'>",
               (: do_title($4[0], $4[1]) :));
   add_command("author", "<string'article'> <string'new author name'>",
               (: do_author($4[0], $4[1]) :));
   add_command("change", "type of <string'article'> to {html|plain}",
               (: do_change($4[0], $4[1]) :));
   if (!is_setter(person) && !is_editor(person)) {
      return;
   }
   add_command("change", "colour of <string'article'> to {red|blue|green|cyan|magenta|yellow|brown|none}",
               (: do_change_colour($4[0], $4[1]) :));
   add_command("move", "<string'article'> {up|down}",
               (: do_move($4[0], $4[1]) :));
   add_command("move", "<string'article'> to <string'position'>",
               (: do_move_pos($4[0], $4[1]) :));
   if (!is_editor(person)) {
      return;
   }
   add_command("change", "xp [return] of <string'article'> to {none|normal}",
               (: do_change_xp($4[0], $4[1]) :));
   add_command("submit", "section <string'section name'>",
               (: do_submit_section($4[0]) :));
   add_command("add", "reporter <string'person'>", (: do_hire($4[0], 0) :));
   add_command("add", "setter <string'person'>", (: do_hire($4[0], 1) :));
   add_command("add", "editor <string'person'>", (: do_promote($4[0]) :));
   add_command("add", "sponsor <string'person'>", (: do_sponsor_add($4[0]) :));
   add_command("remove", "editor <string'person'>", (: do_demote($4[0], 1) :));
   add_command("remove", "setter <string'person'>", (: do_demote($4[0], 0) :));
   add_command("remove", "reporter <string'person'>", (: do_dismiss($4[0]) :));
   add_command("remove", "sponsor <string'person'>", (: do_sponsor_remove($4[0]) :));
   add_command("log", "", (: do_logs(0) :));
   add_command("log", "article", (: do_logs(1) :));
   add_command("pay", "bank branch <string'bank name'>",
               (: do_set_bank_branch($4[0]) :));
   add_command("pay", "<word'person'> <string'amount|none'>",
               (: do_pay($4[0], $4[1]) :));
   add_command("pay", "<word'person'> message <string'message|none'>",
               (: do_pay_tag($4[0], $4[1]) :));
   add_command("profit", "", (: do_summary() :));
   add_command("profit", "deposit extra <string'cash'>",
               (: do_deposit($4[0]) :));
   add_command("postpone", "<string'article'> {on|off}",
               (: do_postpone($4[0], $4[1]) :));
   add_command("lock", "articles {on|off}", (: do_lock($4[0] == "on") :));
   add_command("lock", "article <string'article'> {on|off}",
               (: do_lock_article($4[0], $4[1]) :));
   add_command("publish", "with headline <string'headline'>",
               (: do_publish($4[0]) :));
   add_command("category", "{open|close} <string'catgory'>",
               (: do_category_open($4[1], $4[0]) :));
   add_command("category", "add <string'catgory'>",
               (: do_category_add($4[0]) :));
   add_command("category", "remove <string'catgory'>",
               (: do_category_remove($4[0]) :));
   add_command("category", "cost <string'category'> per add <string'cost|none'>",
               (: do_category_cost($4[0], $4[1]) :));
   add_command("category", "cost <string'category'> per ten characters <string'cost|none'>",
               (: do_category_cost_per_ten_chars($4[0], $4[1]) :));
   add_command("advert", "remove <number'id'>", (: do_advert_remove($4[0]) :));
   if (!is_owner(this_player()->query_name())) {
      return ;
   }
   add_command("transfer", "paper ownership to <string'name'>",
               (: do_transfer_ownership($4[0]) :));
}
class advert* query_ads() { return _adverts; }

==================================================
FILE: room/inherit/owned_room.c
==================================================

#include <room.h>
private string _owner;
private string* _allowed;
private nosave string _save_file;
private nosave string _front_door;
protected int do_allow(string name);
protected int do_throwout(string name);
protected int do_disallow(string name);
void load_room();
varargs mixed call_door( string direc,
                         string func,
                         mixed arg1,
                         mixed arg2,
                         mixed arg3);
string query_owner();
void create() {
   _allowed = ({ });
   load_room();
}
void init() {
   if (this_player()->query_name() == query_owner()) {
      add_command("room",
                  "allow <string'person'>",
                  (: do_allow($4[0]) :));
      add_command("room",
                  "disallow <string'person'>",
                  (: do_disallow($4[0]) :));
      add_command("room",
                  "throwout <indirect:living'person'>",
                  (: do_throwout($4[0]) :));
   }
}
void set_save_file(string name) {
   _save_file = name;
}
string query_save_file() {
   return _save_file;
}
string *query_allowed() {
   return _allowed;
}
protected void set_allowed(string *allowed) {
   _allowed = allowed;
}
string query_owner() {
   return _owner;
}
void set_owner(string owner) {
   _owner = owner;
}
protected int do_allow(string name) {
   name = lower_case(name);
   if (member_array(name, _allowed) != -1) {
      add_failed_mess("The person " + name + " is already allowed.\n");
      return 0;
   }
   _allowed += ({ name });
   write("Ok, you have allowed " + name + " to enter your room.\n");
   return 1;
}
protected int do_disallow(string name) {
   name = lower_case(name);
   if (member_array(name, _allowed) == -1) {
      add_failed_mess("The person " + name + " is not allowed to disallow.\n");
      return 0;
   }
   _allowed -= ({ name });
   write("Ok, you have disallowed " + name + " from entering your room.\n");
   return 1;
}
protected int do_throwout(object *people) {
   object per;
   object *moved;
   moved = ({ });
   foreach (per in people) {
      if ( ROOM_HANDLER->exit_move( _front_door, 0, 0, per) ) {
         moved += ({ per });
      }
   }
   if (!sizeof(moved)) {
      add_failed_mess("Unable to move $I for some reason.\n", people);
      return 0;
   }
   add_succeeded_mess("$N throw$s $I out of the room.\n", moved);
   return 1;
}
void set_front_door(string exit) {
   _front_door = exit;
}
string query_front_door() {
   return _front_door;
}
int is_allowed_in(string person) {
   person = lower_case(person);
   if (person != query_owner()) {
      if (call_door(_front_door,
                    "query_locked")) {
         if (member_array(person, _allowed) != -1) {
            return 0;
         }
      }
   }
   return 1;
}
int is_allowed(string person) {
   if (person == query_owner() ||
       member_array(person, query_allowed()) != -1) {
      return 1;
   }
   return 0;
}
void load_room() {
   if (_save_file) {
      restore_object(_save_file);
      call_door(_front_door,
                "set_locked",
                1);
   }
}
void save_room() {
   if (_save_file) {
      save_object(_save_file);
   }
}

==================================================
FILE: room/inherit/p_library.c
==================================================

#include <book_handler.h>
#include <money.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#include <am_time.h>
#define BASE_PATHS ({ "/std/book", "/std/book_dir", "/std/leaflet", \
                      "/obj/misc/paper", "/obj/misc/nroff_paper" })
#define TITLE_PROP          "title"
#define AUTHOR_PROP         "author"
#define FROM_LIBRARY_PROP   "from library"
#define BORROWED_BY_PROP    "borrowed by"
#define DUE_BACK_PROP       "due back"
#define REFERENCE_ONLY_PROP "reference only"
#define USER_ACCESS      1
#define LIBRARIAN_ACCESS 2
inherit "/std/room/basic_room";
nosave int       _player_contributable;
nosave string    _library_name;
nosave string    _save_file;
nosave function  _borrow_func;
nosave function  _test_allowed;
int       _loan_length;
int       _fine_per_day;
int       _lost_damaged_fine;
int       _max_loans;
mapping _catalog;
mapping _accounts;
mapping _fines;
mapping _access;
nosave mapping _catalog_by_title;
nosave mapping _catalog_by_author;
class _book {
    string     path;
    string     auto_load;
    string     cap_title;
    string     cap_author;
    mapping    loaned;
    int        borrowable;
    int        copies;
    int        total_borrowed;
}
class _loan {
    int       id;
    int       due_back;
}
class _account {
    int           total_fines_paid;
    int           lost_damaged;
    class _loan   *loans;
}
int do_add( object *obs, string title, string author );
int do_remove_book( int id );
int do_borrow( mixed arg );
int do_return( object *obs );
int do_list( string arg, string to, string from, string specific );
int do_status( string player );
int do_book_status( int id );
int do_set( string player, string type );
int do_mark( int id, int flag );
int do_set_fine( int i );
int do_set_loan_length( int days );
int do_set_max_loans( int i );
int do_lost_damaged_fine( int i );
int do_report( int id, string arg, string player );
mapping query_loans( string name );
mapping query_borrowed_by( int id );
int query_fine( string name );
void clear_loan( mixed player, int id, int calc_fines );
varargs int add_book_to_library( mixed thing, int copies, string cap_title,
                                 string cap_author, int borrowable );
void set_access( string player, int access );
int query_access( mixed player );
int do_set( string player, string type );
void save_me();
protected string make_pretty_catalog( string arg, string from, string to, string specific );
protected int compare_widgets( object new_ob, int existing_id );
protected void build_catalogs(){
  int id;
  class _book book;
  foreach( id, book in _catalog ){
    if( _catalog_by_author[ lower_case(book->cap_author) ] )
      _catalog_by_author[ lower_case(book->cap_author) ] += ({ id });
    else
      _catalog_by_author[ lower_case(book->cap_author) ] = ({ id });
    if( _catalog_by_title[ lower_case(book->cap_title) ] )
      _catalog_by_title[ lower_case(book->cap_title) ] += ({ id });
    else
      _catalog_by_title[ lower_case(book->cap_title) ] = ({ id });
  }
}
void create(){
  object sign;
  ::create();
  _catalog_by_author = ([ ]);
  _catalog_by_title = ([ ]);
  _player_contributable = 1;
  _library_name = "The illustrious library of fluff";
  _save_file = base_name( this_object() ) + ".o";
  if( master()->file_exists(_save_file) ){
    unguarded( (: restore_object, _save_file :) );
  } else {
    _catalog = ([ ]);
    _accounts = ([ ]);
    _fines = ([ ]);
    _access = ([ ]);
    _loan_length = 3 * 24 * 60 * 60;
    _fine_per_day = 400;
    _lost_damaged_fine = 1050;
    _max_loans = 5;
  }
  build_catalogs();
  add_help_file("p_library_user");
  add_help_file("p_library_librarian");
  sign = add_sign(
      "The plaque is a traditional brass plate, set on top a piece "
      "of cherry oak. It looks very formal.\n",
      "For some reason, reading this sign doesn't give you as much "
      "information as looking at it would.\n",
      "brass plaque", "plaque", "common" );
  sign->add_extra_look( this_object() );
  sign->set_read_mess( 0, 0, 0 );
}
int query_library(){  return 1;  }
void init(){
  if( _player_contributable ){
    add_command( "add", "<indirect:object:me'book'> with "
        "title <string'title'> by author <word'author'>",
        (: do_add( $1, $4[1], $4[2] ) :) );
    add_command( "remove", "<number'book id'>",
        (: do_remove_book( $4[0] ) :));
  }
  add_command( "borrow", "<number'book id'>", (: do_borrow( $4[0] ) :) );
  add_command( "return", "<indirect:object:me-here>" );
  add_command( "pay", "[fine]"  );
  add_command( "view", "catalogue by {author|title}", (: do_list( $4[0], "a", "z", 0 ) :) );
  add_command( "view", "catalogue by {author|title} from "
      "<word'letter'> to <word'letter'>", (: do_list( $4[0], $4[1], $4[2], 0 ) :) );
  add_command( "view", "works by <string'author'>",
      (: do_list( "author", 0, 0, $4[0] ) :) );
  add_command( "view", "works titled <string'title'>",
      (: do_list( "title", 0, 0, $4[0] ) :) );
  add_command( "status", "", (: do_status(0) :) );
  add_command( "status", "book <number'book id'>",
               (: do_book_status( $4[0] ) :) );
  add_command( "report", "<number'book id'> as {damaged|lost}",
               (: do_report( $4[0], $4[1], 0 ) :) );
  add_command( "set", "access for <word'player'> to {allowed|disallowed}",
               (: do_set( $4[0], $4[1] ) :) );
  add_command( "set", "fine per day to <number'amount'>",
               (: do_set_fine( $4[0] ) :) );
  add_command( "set", "loan length to <number'number of days'>",
               (: do_set_loan_length( $4[0] ) :) );
  add_command( "set", "maximum number of loans to <number'number'>",
               (: do_set_max_loans( $4[0] ) :) );
  add_command( "set", "lost or damaged fine to <number'amount'>",
               (: do_lost_damaged_fine( $4[0] ) :) );
  add_command( "mark", "<number'book id'> as reference only",
    (: do_mark( $4[0], 1) :) );
  add_command( "mark", "<number'book id'> as not reference only",
    (: do_mark( $4[0], 0) :) );
  add_command( "status", "<word'player'>", (: do_status($4[0]) :) );
  add_command( "report", "<number'book id'> as {damaged|lost} for <word'player'>",
               (: do_report( $4[0], $4[1], $4[2] ) :) );
}
protected string id_to_name( int id ){
  if( !_catalog[id] )
    return 0;
  return "'" +_catalog[id]->cap_title+ "' by " + _catalog[id]->cap_author;
}
protected int valid_media( object ob ){
  if( ob->query_book() || ob->query_paper() || ob->query_leaflet() )
    return 1;
}
int do_add( object *obs, string title, string author ){
  object t_p, t_o;
  int num, id, *ids;
  t_p = this_player();
  t_o = this_object();
  debug_printf( "Obs: %O\n", obs );
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("Only librians can do this.\n");
    return 0;
  }
  if( strlen(author) > 14 ){
    add_failed_mess("The author's name is too long. It has to be less than 13 characters.\n");
    return 0;
  }
  if( strlen(title) > 26 ){
    add_failed_mess("The title is too long. It can only use less than 27 characters.\n");
    return 0;
  }
  if( sizeof(obs) > 1 ){
    add_failed_mess("You can only add one item at a time.\n");
    return 0;
  }
  if( !t_o->valid_media(obs[0]) ){
    add_failed_mess( "The library does not lend items like $I.\n", obs);
    return 0;
  }
  if( obs[0]->query_magic_scroll() || obs[0]->query_spell_book() ){
    add_failed_mess( "This library does not deal in magical works.\n" );
    return 0;
  }
  if( obs[0]->query_property(FROM_LIBRARY_PROP) ){
    add_failed_mess( "This item belongs to a library and cannot be added.\n" );
    return 0;
  }
  if( (num = obs[0]->query_book_num()) ){
    if( lower_case(author) != BOOK_HANDLER->query_book_owner(num) ){
      add_failed_mess( "The book has been authored by " +
        capitalize(BOOK_HANDLER->query_book_owner(num)) + " and not " +
        author + ".\n");
      return 0;
    }
  }
  if( (ids = _catalog_by_title[ lower_case(title) ]) ){
    foreach( id in ids ){
      if( lower_case(_catalog[id]->cap_author) == lower_case(author) ){
        if( compare_widgets( obs[0], id ) ){
          add_book_to_library( id, 1 );
          add_succeeded_mess( "$N add$s another copy of "
              +id_to_name(id)+ " to the library.\n" );
          obs[0]->move( "/room/rubbish" );
          return 1;
        } else {
          add_failed_mess("$I doesn't seem to be the same as the copy held "
            "in the library. Catalogue it under a different title or author.\n", obs );
          return 0;
        }
      }
    }
  }
  if( member_array(base_name(obs[0]), BASE_PATHS) == -1 )
    add_book_to_library( base_name(obs[0]), 1, title, author, 1 );
  else
    add_book_to_library( obs[0], 1, title, author, 1 );
  add_succeeded_mess( "$N $V an item to the library.\n" );
  obs[0]->move( "/room/rubbish" );
  return 1;
}
void remove_book( int id ){
  object ob;
  class _book book;
  int i;
  if( !_catalog[id] )
    return;
  book = _catalog[id];
  for( i = 0; i < (book->copies - sizeof(book->loaned)); i++ ){
    if( book->path )
      ob = clone_object( book->path );
    if( book->auto_load )
      ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];
    ob->move( this_object() );
  }
  _catalog_by_title[lower_case(book->cap_title)] -= ({ id });
  _catalog_by_author[lower_case(book->cap_author)] -= ({ id });
  if( !sizeof( _catalog_by_title[lower_case(book->cap_title)] ) )
    map_delete( _catalog_by_title, lower_case(book->cap_title) );
  if( !sizeof( _catalog_by_author[lower_case(book->cap_author)] ) )
    map_delete( _catalog_by_author, lower_case(book->cap_author) );
  map_delete( _catalog, id );
  save_me();
}
int do_remove_book( int id ){
  int out;
  string player, bit;
  class _account account;
  class _loan loan;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("Only librians can do this.\n");
    return 0;
  }
  id = to_int(id);
  if( !_catalog[id] ){
    add_failed_mess("There is no item with that id.\n");
    return 0;
  }
  foreach( player, account in _accounts ){
    foreach( loan in account->loans ){
      if( loan->id == id )
        out++;
    }
  }
  if( out ){
    if( out > 1 )
      bit = "are " +query_num(out)+ " ";
    else
      bit = "is one"+" ";
    add_failed_mess( "There " +bit+ id_to_name(id) +
        ", out on loan already. You can only remove a book if all "
        "copies are in the library.\n" );
    return 0;
  } else {
    add_succeeded_mess("$N $V " +id_to_name(id) + " from the library.\n" );
    remove_book(id);
    tell_object( this_player(), "Any remaining copies will be placed on the floor.\n");
    return 1;
  }
}
int do_borrow( mixed arg ){
  int id, ret, t;
  object ob;
  class _book book;
  class _loan loan;
  string name;
  name = this_player()->query_name();
  id = to_int(arg);
  if( query_access(this_player()) < USER_ACCESS ){
    add_failed_mess("You do not have access to this library.\n");
    return 0;
  }
  if( _borrow_func ){
    ret = evaluate( _borrow_func, this_player(), id );
    if( ret != 1 )
      return ret;
  }
  if( _fines[name] ){
    add_failed_mess("You can't borrow a book whilst having outstanding fines.\n" );
    return 0;
  }
  if( !_catalog[id] ){
    add_failed_mess("There is no book with an id of " +id+ ".\n" );
    return 0;
  } else {
    book = _catalog[id];
  }
  if( _accounts[name] && sizeof(_accounts[name]->loans) >= _max_loans ){
    add_failed_mess("You have already borrowed the maximum number of books.\n");
    return 0;
  }
  if( (book->copies - sizeof(book->loaned)) < 1 ){
    add_failed_mess("Unfortunately, all copies of " +
        id_to_name(id) + " are out on loan.\n");
    return 0;
  }
  if( _accounts[name] && sizeof( _accounts[name]->loans ) ){
    foreach( loan in _accounts[name]->loans ){
      if( loan->id == id ){
        add_failed_mess("You have already borrowed a copy of " +
            id_to_name(id) + ".\n");
        return 0;
      }
    }
  }
  if( book->path )
    ob = clone_object( book->path );
  if( book->auto_load )
    ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];
  if( !ob ){
    add_failed_mess("Uh oh, something buggered with book id: " + id +
      ". Please tell a creator.\n" );
    return 0;
  }
  t = time() + _loan_length;
  ob->add_property( TITLE_PROP, book->cap_title );
  ob->add_property( AUTHOR_PROP, book->cap_author );
  ob->add_property( FROM_LIBRARY_PROP, _library_name );
  ob->add_property( BORROWED_BY_PROP, name );
  ob->add_property( DUE_BACK_PROP, t );
  book->loaned[name] = t;
  book->total_borrowed++;
  _catalog[id] = book;
  loan = new( class _loan, id : id, due_back : t );
  if( _accounts[name] )
    _accounts[name]->loans += ({ loan });
  else {
    _accounts[name] = new( class _account, total_fines_paid : 0,
                           lost_damaged : 0,
                           loans : ({ loan }) );
  }
  if( !book->borrowable ){
    tell_object( this_player(), id_to_name(id)+ " is a reference only book. "
      "It will be placed on "
      "a lecturn for you to read and cannot be removed from the library. Please return it "
      "in the normal way after use.\n");
    ob->move( this_object() );
    ob->reset_get();
    ob->add_property( "there", "sitting on a lecturn" );
    ob->add_property( REFERENCE_ONLY_PROP, 1 );
  } else {
    tell_object( this_player(), "You have until "+ am_time(t) +
        " to return it.\n");
    ob->move( this_player() );
  }
  save_me();
  add_succeeded_mess( "$N $V " +id_to_name(id)+ ".\n");
  return 1;
}
int do_return( object *obs ){
  string name, bit;
  int id, *owed, i, *ours, due;
  class _loan loan;
  class _book book;
  object ob, *not_ours, *wrong_player, *returned;
  name = this_player()->query_name();
  owed = ({ });
  ours = not_ours = wrong_player = returned = ({ });
  if( !sizeof(_accounts[name]->loans) ){
    add_failed_mess( "You don't have any books out on loan.\n" );
    return 0;
  }
  foreach( loan in _accounts[name]->loans ){
    owed += ({ loan->id });
  }
  foreach( ob in obs ){
    if( ob->query_property( FROM_LIBRARY_PROP ) == _library_name ){
      if( ob->query_property( BORROWED_BY_PROP ) == name ){
        foreach( id in owed ){
          if( (book = _catalog[id]) ){
            if( ob->query_property( TITLE_PROP ) == book->cap_title &&
                ob->query_property( AUTHOR_PROP ) == book->cap_author ){
              map_delete( _catalog[id]->loaned, name );
              ob->move("/room/rubbish");
              returned += ({ ob });
              ours += ({ id });
            }
          } else {
            ob->move("/room/rubbish");
            returned += ({ ob });
          }
        }
      } else {
        wrong_player += ({ ob });
      }
    } else {
      not_ours += ({ ob });
    }
  }
  if( sizeof(returned) ){
    foreach( i in ours )
      clear_loan( this_player(), i, 1 );
    if( _fines[name] )
      tell_object(this_player(), "Note: You have fines that are due.\n");
    add_succeeded_mess( "$N $V $I.\n", returned );
    return 1;
  }
  if( (i=sizeof(not_ours)) ){
    if( i > 1 ) bit = "do not"; else bit = "does not";
    add_failed_mess( "$I " +bit+ " belong to this library.\n", not_ours );
    return 0;
  }
  if( (i=sizeof(wrong_player)) ){
    if( i > 1 ) bit = "were not"; else bit = "was not";
    add_failed_mess( "$I " +bit+ " were not loaned to you. Only the borrower may "
        "return items.\n", wrong_player );
    return 0;
  }
}
int do_list( string arg, string from, string to, string specific ){
  if( (to && !stringp(to)) || (from && !stringp(from)) ){
    add_failed_mess( "The ranges must be letters.\n");
    return 0;
  }
  if( specific ){
    tell_object( this_player(), make_pretty_catalog( arg, 0, 0, lower_case(specific) ) );
    return 1;
  } else {
    tell_object( this_player(), make_pretty_catalog( arg, from, to, 0 ) );
    return 1;
  }
}
int do_pay(){
  int cash, fine;
  string place, str;
  place = query_property( "place" );
  if ( !place || ( place == "" ) )
    place = "default";
  cash = this_player()->query_value_in( place );
  if ( place != "default" )
    cash += this_player()->query_value_in( "default" );
  if( !cash ){
    add_failed_mess("You have money!.\n");
    return 0;
  }
  fine = _fines[this_player()->query_name()];
  if( fine <= 0 ){
    add_failed_mess("You have no outstanding fines to pay.\n");
    return 0;
  }
  if( cash >= fine )
    cash = fine;
  this_player()->pay_money( MONEY_HAND->create_money_array(cash, place), place );
  _fines[this_player()->query_name()] -= cash;
  _accounts[this_player()->query_name()]->total_fines_paid += cash;
  if( _fines[this_player()->query_name()] <= 0 ){
    str = MONEY_HAND->money_value_string( cash, place );
    add_succeeded_mess("$N pay$s all $p fines ("+str+").\n");
    map_delete( _fines, this_player()->query_name() );
    save_me();
    return 1;
  } else {
    str = MONEY_HAND->money_value_string( fine - cash, place );
    add_succeeded_mess("$N pay$s some of $p fine, but sill owe$s ("+str+").\n");
    save_me();
    return 1;
  }
}
int do_status( string player ){
  int fine;
  string place, str, bit;
  class _loan loan;
  if( !player )
    player = this_player()->query_name();
  player = lower_case(player);
  if( player != this_player()->query_name() &&
      query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have access to see other accounts.\n");
    return 0;
  }
  str = "Account status for " + PLAYER_HANDLER->query_cap_name(player) +".\n";
  if( _accounts[player] && sizeof(_accounts[player]->loans)  ){
    str += "Loaned items:\n";
    str += sprintf( "%|4s%|=30s%|=20s%|9s\n", "Id", "Item", "Due back", "Overdue" );
    foreach( loan in _accounts[player]->loans ){
      if( loan->due_back - time() > 0 )
        bit = "";
      else
        bit = "*Yes*";
      str += sprintf( "%|4d%|=30s%|=20s%|9s\n", loan->id,
          id_to_name(loan->id), am_time( loan->due_back ), bit );
    }
  } else {
    str += "No items currently on loan.\n";
  }
  place = query_property( "place" );
  if ( !place || ( place == "" ) )
    place = "default";
  fine = _fines[player];
  if( fine >= 0 ){
    str += sprintf( "%-15s%-6s\n", "Fines Due:",
           MONEY_HAND->money_value_string( fine, place ) );
  } else {
    str += "No fines due.\n";
  }
  if( _accounts[player] ){
    str += "Total previously paid fines: " +
      MONEY_HAND->money_value_string( _accounts[player]->total_fines_paid, place );
    str += ".\nBooks lost or damaged: " + _accounts[player]->lost_damaged + ".\n";
  }
  tell_object( this_player(), str );
  add_succeeded_mess("");
  return 1;
}
int do_book_status( int id ){
  string str, name, date;
  class _book book;
  id = to_int(id);
  if( !_catalog[id] ){
    add_failed_mess("The id " +id+ ", does not point to an item.\n");
    return 0;
  }
  book = _catalog[id];
  str = "Status for id: " +id+ " - " + id_to_name(id) + ".\n";
  if( sizeof(book->loaned) ){
    str += sprintf( "%|=14s%|=30s\n", "On loan to", "Date Due Back " );
    foreach( name, date in book->loaned ){
      str += sprintf( "%|=12s%|=30s\n",
             PLAYER_HANDLER->query_cap_name(name), am_time(date) );
    }
  } else {
    str += "Currently, no copies of the item are on loan.";
  }
  str += "The library holds " + (string)book->copies;
  if( book->copies == 1 ) str += " copy "; else str += " copies ";
  str += "in total, " + (string)( book->copies - sizeof(book->loaned) ) +
         " of which are available.\n";
  str += "It has been borrowed a total of " + book->total_borrowed;
  if( book->total_borrowed == 1 ) str += " time.\n"; else str += " times.\n";
  if( !book->borrowable )
    str += "It is a reference only item.\n";
  tell_object( this_player(), str);
  add_succeeded_mess("$N look$s at the status of a library item.\n");
  return 1;
}
int do_set( string player, string type ){
  player = lower_case(player);
  if( query_access(this_object()) <= query_access(player) ){
    add_failed_mess( "You do not have permission to do this.\n");
    return -1;
  }
  if( type == "allowed" ){
    if( query_access(player) < USER_ACCESS ){
      set_access( player, USER_ACCESS );
      add_succeeded_mess("$N allow$s " + PLAYER_HANDLER->query_cap_name(player) +
        " to use the library.\n");
      save_me();
      return 1;
    }
  }
  if( type == "disallowed" ){
    if( query_access(player) == USER_ACCESS ){
      set_access( player, 0 );
      add_succeeded_mess("$N disallow$s " + PLAYER_HANDLER->query_cap_name(player) +
        " from using the library.\n");
      save_me();
      return 1;
    }
  }
}
int do_mark( int id, int flag ){
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  if( !_catalog[id] ){
    add_failed_mess("There is no item with that id.\n");
    return 0;
  }
  if( flag ){
    add_succeeded_mess("$N $V " + id_to_name(id) + " to reference only.\n");
    _catalog[id]->borrowable = 0;
    return 1;
  } else {
    add_succeeded_mess("$N $V " + id_to_name(id) + " to not reference only.\n");
    _catalog[id]->borrowable = 1;
    return 1;
  }
  save_me();
}
int do_set_fine( int i ){
  string place;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  place = query_property( "place" );
  if( !place || ( place == "" ) )
    place = "default";
  i = to_int(i);
  if( i < 0 ){
    add_failed_mess("Don't be silly, thats a negative value!\n");
    return 0;
  }
  if( i > 4000 ){
    add_failed_mess("The maximum fine you can set per day is 4000 units (" +
        MONEY_HAND->money_value_string( 4000, place ) + ").\n" );
    return 0;
  }
  add_succeeded_mess("$N set$s the fine per day to " + i +
    " ("+ MONEY_HAND->money_value_string( i, place ) + ").\n" );
  _fine_per_day = i;
  save_me();
  return 1;
}
int do_set_loan_length( int days ){
  string str;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  days = to_int(days);
  if( days > 10 ){
    add_failed_mess("The maximum loan length is 10 days.\n");
    return 0;
  }
  if( days < 1 ){
    add_failed_mess("The minimum loan length is 1 day.\n");
    return 0;
  }
  if( days == 1 )  str = " day"; else str = " days";
  add_succeeded_mess("$N set$s the loan length to "
     + query_num(days) + str + ".\n" );
  _loan_length = days * AM_SECONDS_PER_DAY;
  save_me();
  return 1;
}
int do_set_max_loans( int i ){
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  i = to_int(i);
  if( i < 1 ){
    add_failed_mess("The minimum amount of loans is one.\n");
    return 0;
  }
  if( i > 10 ){
    add_failed_mess("The maximum amount of loans a player can have is ten.\n");
    return 0;
  }
  add_succeeded_mess("$N set$s the maximum number of loans to "
     + query_num(i) + " items.\n" );
  _max_loans = i;
  save_me();
  return 1;
}
int do_lost_damaged_fine( int i ){
  string place;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  i = to_int(i);
  place = query_property( "place" );
  if( !place || ( place == "" ) )
    place = "default";
  if( i < 0 ){
    add_failed_mess("Don't be silly, thats a negative value!\n");
    return 0;
  }
  if( i > 20000 ){
    add_failed_mess("The maximum fine you can set per day is 20000 units (" +
        MONEY_HAND->money_value_string( 20000, place ) + ").\n" );
    return 0;
  }
  add_succeeded_mess("$N set$s the lost or damaged fine to " + i +
    " ("+ MONEY_HAND->money_value_string( i, place ) + ").\n" );
  _lost_damaged_fine = i;
  save_me();
  return 1;
}
int do_report( int id, string arg, string player ){
  string str;
  class _loan loan, match;
  if( player && query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You can only report your damaged or lost books.\n");
    return 0;
  }
  if( player ){
    str = PLAYER_HANDLER->query_cap_name(player)+ " does";
    player = lower_case(player);
  } else {
    str = "You do";
    player = this_player()->query_name();
  }
  if( !_accounts[player] ){
    add_failed_mess(str + " not have any items on loan.\n");
    return 0;
  }
  if( !_catalog[id] ){
    add_failed_mess("The id " + id + " does not exist.\n");
    return 0;
  }
  foreach( loan in _accounts[player]->loans ){
    if( loan->id == id ){
      match = loan;
    }
  }
  if( !match ){
    add_failed_mess(str + " not have " + id_to_name(id) + " out on loan.\n");
    return 0;
  }
  _accounts[player]->loans -= ({ match });
  map_delete( _catalog[id]->loaned, player );
  _catalog[id]->copies--;
  if( player == this_player()->query_name() )
    str = "";
  else
    str = " for " + PLAYER_HANDLER->query_cap_name(player);
  if( _fines[player] )
    _fines[player] += _lost_damaged_fine;
  else
    _fines[player] = _lost_damaged_fine;
  if( arg == "lost" ){
    add_succeeded_mess("You report the loss of " + id_to_name(id) + str + ".\n");
    _accounts[player]->lost_damaged++;
    save_me();
    return 1;
  }
  if( arg == "damaged" ){
    add_succeeded_mess("You report the damaging of " +id_to_name(id) + str + ".\n");
    _accounts[player]->lost_damaged++;
    save_me();
    return 1;
  }
}
protected string make_pretty_catalog( string arg, string from, string to, string specific ){
  string widget, c_widget, str, *list;
  int id, *ids;
  if( !from )
    from = "a";
  else
    from = lower_case(from);
  if( !to )
    to = "z";
  else
    to = lower_case(to);
  if( from > to ){
    widget = to;
    to = from;
    from = widget;
  }
  if( specific ){
    if( _catalog_by_title[specific] || _catalog_by_author[specific] )
      list = ({ specific });
    else
      list = ({ });
  }
  if( arg == "title" ){
    str = sprintf( "%|=4s%|=26s%|=12s%|=9s%|=8s\n",
            "Id", "Title", "Author", "Copies", "On Loan" );
    if( !list )
      list = sort_array( keys(_catalog_by_title), 0 );
    foreach( widget in list ){
      ids = _catalog_by_title[ widget ];
      if( widget && sizeof(ids) && (widget[0..0] >= from) && (widget[0..0] <= to) ){
        foreach( id in ids ){
          c_widget = _catalog[ id ]->cap_title;
          str += sprintf( "%|=4d%|=26s%|=12s%|=9d%|=8d\n",
                   id, c_widget, _catalog[id]->cap_author,
                   _catalog[id]->copies, sizeof(_catalog[id]->loaned) );
        }
      }
    }
    return str;
  }
  if( arg == "author" ){
    str = sprintf( "%|=4s%|=12s%|=26s%|=9s%|=8s\n",
            "Id", "Author", "Title", "Copies", "On Loan" );
    if( !list )
      list = sort_array( keys(_catalog_by_author), 0 );
    foreach( widget in list ){
      ids = _catalog_by_author[ widget ];
      if( widget && sizeof(ids) && (widget[0..0] >= from) && (widget[0..0] <= to) ){
        foreach( id in ids ){
          c_widget = _catalog[ id ]->cap_title;
          str += sprintf( "%|=4d%|=12s%|=26s%|=9d%|=8d\n",
                   id, _catalog[id]->cap_author, c_widget,
                   _catalog[id]->copies, sizeof(_catalog[id]->loaned) );
        }
      }
    }
    return str;
  }
}
void clear_loan( mixed player, int id, int calc_fines ){
  int fine;
  class _loan loan;
  if( objectp(player) && userp(player) )
    player = player->query_name();
  if( !stringp(player) )  return;
  if( !_accounts[player] || !sizeof(_accounts[player]->loans) )  return;
  foreach( loan in _accounts[player]->loans ){
    if( loan->id == id ){
      if( calc_fines && (loan->due_back - time() < 0) ){
        fine = (((time() - loan->due_back) / AM_SECONDS_PER_DAY) + 1) * _fine_per_day;
        if( _fines[player] )
          _fines[player] += fine;
        else
          _fines[player] = fine;
      }
      _accounts[player]->loans -= ({ loan });
    }
  }
  save_me();
}
protected int find_blank_id(){
  int *ids;
  int unused_id, i;
  ids = sort_array( keys(_catalog), -1 );
  if( !sizeof(ids) ){
    unused_id = 1;
  } else {
    if( ids[0] > sizeof(ids) ){
      for( i = 0; i < sizeof(ids); i++ ){
        if( undefinedp(_catalog[i]) ){
          unused_id = i;
          break;
        }
      }
    } else {
      unused_id = sizeof(ids) + 1;
    }
  }
  if( unused_id == 0 )
    unused_id = 1;
  return unused_id;
}
protected void add_book_to_catalogs( class _book new_book, int id ){
  _catalog[id] = new_book;
  save_me();
  if( _catalog_by_author[lower_case(new_book->cap_author)] )
    _catalog_by_author[lower_case(new_book->cap_author)] += ({ id });
  else
    _catalog_by_author[lower_case(new_book->cap_author)] = ({ id });
  if( _catalog_by_title[lower_case(new_book->cap_title)] )
    _catalog_by_title[lower_case(new_book->cap_title)] += ({ id });
  else
    _catalog_by_title[lower_case(new_book->cap_title)] = ({ id });
}
varargs int add_book_to_library( mixed thing, int copies, string cap_title,
                                 string cap_author, int borrowable ){
  class _book book;
  int id, *ids;
  if( intp(thing) ){
    if( _catalog[thing] ){
      _catalog[thing]->copies += copies;
      return 1;
    } else {
      return 0;
    }
  }
  if( !cap_title || !cap_author || cap_title == "" || cap_author == "" )
    return 0;
  if( (ids = _catalog_by_title[ lower_case(cap_title) ]) ){
    foreach( id in ids ){
      if( lower_case(_catalog[id]->cap_author) == lower_case(cap_author) )
          return add_book_to_library( id, 1 );
    }
  }
  if( stringp(thing) ){
    book = new( class _book );
    book->path = thing;
    book->cap_author = cap_author;
    book->cap_title = cap_title;
    book->borrowable = 1;
    book->copies = copies;
    book->loaned = ([ ]);
    book->total_borrowed = 0;
    id = find_blank_id();
    add_book_to_catalogs( book, id );
    return 1;
  }
  if( objectp(thing) ){
    book = new( class _book );
    book->auto_load = AUTO_LOAD_OB->create_auto_load( ({ thing }) );
    book->cap_author = cap_author;
    book->cap_title = cap_title;
    book->borrowable = 1;
    book->copies = copies;
    book->loaned = ([ ]);
    book->total_borrowed = 0;
    id = find_blank_id();
    add_book_to_catalogs( book, id );
    return 1;
  }
}
protected int compare_widgets( object new_ob, int existing_id ){
  class _book book;
  object ob;
  mixed info;
  int perc;
  book = _catalog[existing_id];
  if( !book )  return 0;
  if( book->path )
    ob = clone_object( book->path );
  if( book->auto_load )
    ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];
  if( !ob ){
    return 0;
  }
  if( base_name(ob) != base_name(new_ob) )
    return 0;
  if( inherits("/std/book.c", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
             BOOK_HANDLER->query_pages( new_ob ),
             BOOK_HANDLER->query_pages( ob )
           );
  }
  if( inherits("/std/leaflet.c", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
             map( new_ob->query_pages(), (: $1[0][0] :) ),
             map( ob->query_pages(), (: $1[0][0] :) )
           );
  }
  if( inherits("/obj/misc/paper", new_ob) ||
      inherits("/obj/misc/nroff_paper", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
      map( new_ob->query_read_mess(), (: $1[0] :) ),
      map( ob->query_read_mess(), (: $1[0] :) )
    );
  }
  ob->move( "/room/rubbish" );
  if( perc > 97 )
    return 1;
  else
    return 0;
}
string extra_look( object ob ){
  string *libs, str, place;
  str = "Welcome to " + _library_name + ".\n";
  libs = filter( keys(_access), (: _access[$1] == LIBRARIAN_ACCESS :) );
  if( !sizeof(libs) )
    str += "Currently there are no caretakers of the books.\n";
  if( sizeof(libs) == 1 )
    str += PLAYER_HANDLER->query_cap_name(libs[0]) + " is the sole caretaker "
          " of the books.\n";
  if( sizeof(libs) > 1 ){
    libs = map( libs, (: PLAYER_HANDLER->query_cap_name($1) :) );
    str += query_multiple_short(libs) + " are caretakers of the books.\n";
  }
  place = query_property("place");
  if( !place || place == "" )
    place = "default";
  str += "Books may be borrowed for a maximum of " +
         (_loan_length / AM_SECONDS_PER_DAY) +
         " Disc days, before fines are levied.\n";
  str += "Fines currently stand at " +
         MONEY_HAND->money_value_string( _fine_per_day, place ) +
         " per day the book is overdue.\n";
  str += "A charge of " + MONEY_HAND->money_value_string( _lost_damaged_fine, place ) +
         " will be incurred if you lose or damage a book.\n";
  str += "The maximum number of items you can borrow at one time currently stands at "+
         query_num(_max_loans) + ".\n";
  return str;
}
protected void save_it(){
  unguarded( (: save_object, _save_file :) );
}
void save_me(){
  if( find_call_out("save_it") == -1 )
    call_out( "save_it", 2 );
}
mapping query_loans( string name ){
  class _loan loan;
  mapping m = ([ ]);
  if( !_accounts[name] )
    return ([ ]);
  foreach( loan in _accounts[name]->loans ){
    m[ loan->id ] = loan->due_back;
  }
  return m;
}
mapping query_borrowed_by( int id ){
  if( _catalog[id] )
    return _catalog[id]->loaned;
  else
    return ([ ]);
}
int query_fine( string name ){  return _fines[name];  }
mapping query_catalog(){
  return _catalog;
}
mapping query_catalog_by_title(){
  return _catalog_by_title;
}
mapping query_catalog_by_author(){
  return _catalog_by_author;
}
mapping query_all_accounts(){
  return _accounts;
}
void set_library_name( string str ){  _library_name = str;  }
string query_library_name(){  return _library_name;  }
void set_player_contributable( int i ){  _player_contributable = i;  }
int query_player_contributable(){  return _player_contributable;  }
void set_max_loans( int i ){  _max_loans = i;  }
int query_max_loans(){  return _max_loans;  }
void set_loan_length( int i ){  _loan_length = i;  }
int query_loan_length(){  return _loan_length;  }
void set_fine_per_day( int i ){  _fine_per_day = i;  }
int query_fine_per_day(){  return _fine_per_day;  }
void set_lost_damaged_fine( int i ){ _lost_damaged_fine = i;  }
int query_lost_damaged_fine(){ return _lost_damaged_fine;  }
void set_save_file( string s ){  _save_file = s;  }
string query_save_file(){  return _save_file;  }
void set_borrow_func( function f ){  _borrow_func = f;  }
function query_borrow_func(){  return _borrow_func;  }
void set_access( string player, int access ){
  if( !access ){
    map_delete( _access, player );
  } else {
    _access[player] = access;
  }
  save_me();
}
int query_access( mixed player ){
  return LIBRARIAN_ACCESS;
}
