# Total Tokens: 116234
# Total Files Merged: 64

=====
FILE: room/inherit/terrain_map/handler_base.c
==================================================

#include <weather.h>
#include <terrain_map.h>
#include <player.h>
#define   AREA_OBSTACLE    0
#define   AREA_ROOM        1
#define   AREA_ROAD        2
#define   AREA_WORLD       3
#define   RANDOM_HANDLER   "/obj/handlers/random_num"
inherit "/std/room/inherit/terrain_map/distance_str";
#define X_DIFF 1
#define Y_DIFF 0
#define XY_DIFF 2
class char_map_data {
   string char;
   string colour;
   string path;
   string room_desc;
   mixed items;
   mixed item_desc;
   mixed chats;
   int type;
   int height;
   mapping height_rooms;
   int whole_sentance;
   string adjacent_desc;
   int room_jump;
   int room_jump_matching;
}
class feature_data {
   int range;
   string* descs;
   string* night_descs;
   mixed f_items;
   mixed f_item_desc;
   mixed f_item_night_desc;
   int whole_sentance;
   mixed chats;
   mixed night_chats;
   object feature_ob;
}
class sign_data {
   string long;
   string read_mess;
   string short;
   string name;
   string language;
}
class real_coords {
   int x1;
   int y1;
   int x2;
   int y2;
   int xdiff;
   int ydiff;
   int xydiff;
   int zdiff;
   int in_world_map;
}
private mixed     *_room_map = 0;
private mixed     *_area_map = 0;
private mixed     *_zone_map = 0;
private int       _visible_distance;
private int       _width = 0;
private int       _height = 0;
private int       _normal_skip_size = 1;
private int       _random_desc_limit = 2;
private int       _random_chat_limit = 4;
private int       _newline_mode = 1;
private mapping   _room_zones = ([ ]);
private mapping   _feature_rooms = ([ ]);
private mapping   _char_map = ([ ]);
private mapping   _zone_types = ([ ]);
private mapping   _features = ([ ]);
private mapping   _signposts = ([ ]);
private mapping   _standard_exits = ([ ]);
private mapping   _adjacent_terrains = ([ ]);
private mapping   _random_descs = ([ ]);
private mapping   _random_chats = ([ ]);
private class real_coords _real_coords;
private mapping _key = ([ ]);
private mapping   _direcs = ([ "north":     ({ 0, 1, "south", Y_DIFF, 0 }),
                       "northeast": ({ 1, 1, "southwest", XY_DIFF, ({ "obvious", 0 }) }),
                       "east":      ({ 1, 0, "west", X_DIFF, 0 }),
                       "southeast": ({ 1, -1, "northwest", XY_DIFF, ({ "obvious", 0 }) }),
                       "south":     ({ 0, -1, "north", Y_DIFF, 0 }),
                       "southwest": ({ -1, -1, "northeast", XY_DIFF, ({ "obvious", 0 }) }),
                       "west":      ({ -1, 0, "east", X_DIFF, 0 }),
                       "northwest": ({ -1, 1, "southeast", XY_DIFF, ({ "obvious", 0 }) }) ]);
private string* _direc_order = ({
                        "north", "east", "south", "west",
                        "northeast", "southeast", "southwest", "northwest" });
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
void load_area_map();
void load_zone_map();
class char_map_data query_char_map(int x, int y);
void setup_area_map();
void setup_room(object room, string base_path);
string find_adjacent_terrain(int x, int y);
mixed   *query_room_map() { return _room_map; }
mixed   *query_area_map() { return _area_map; }
mixed   *query_zone_map() { return _zone_map; }
mapping query_zone_types() { return _zone_types; }
mapping query_feature_rooms() { return _feature_rooms; }
mapping query_features() { return _features; }
mapping query_room_zones() { return _room_zones; }
mapping query_char_maps() { return _char_map; }
mapping query_signposts() { return _signposts; }
mapping query_random_descs() { return _random_descs; }
mapping query_random_chats() { return _random_chats; }
mapping query_standard_exits() { return _standard_exits; }
mapping query_adjacent_terrains() { return _adjacent_terrains; }
class real_coords query_debug_real_coord() { return _real_coords; }
mixed* query_real_coords() { return ({ ({ _real_coords->x1, _real_coords->y1 }), ({ _real_coords->x2, _real_coords->y2 }) }); }
int     *query_dimensions() { return ({ _width, _height }); }
void    setup_handler() { }
string  query_map_file() { return ""; }
void set_real_coordinates_no_inform(int x1, int y1, int x2, int y2) {
   int tmp;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   _real_coords = new(class real_coords, x1:x1, y1:y1, x2:x2, y2:y2);
   _real_coords->xdiff = (x2 - x1) / _width;
   _real_coords->ydiff = (y2 - y1) / _height;
   _real_coords->zdiff = 15;
   _real_coords->xydiff = to_int(sqrt(to_float(_real_coords->xdiff) * to_float(_real_coords->xdiff)+
                               to_float(_real_coords->ydiff) * to_float(_real_coords->ydiff)));
}
void set_real_coordinates(int x1, int y1, int x2, int y2) {
   set_real_coordinates_no_inform(x1, y1, x2, y2);
   _real_coords->in_world_map = TERRAIN_MAP_WORLD_MAP->add_terrain(base_name(this_object()),
                                      _real_coords->x1, _real_coords->y1,
                                      _real_coords->x2, _real_coords->y2);
}
void set_real_offsets(int xoff, int yoff, int zoff) {
   _real_coords = new(class real_coords);
   _real_coords->xdiff = xoff;
   _real_coords->ydiff = yoff;
   _real_coords->xydiff = to_int(sqrt(to_float(_real_coords->xdiff) * to_float(_real_coords->xdiff)+
                               to_float(_real_coords->ydiff) * to_float(_real_coords->ydiff)));
}
class coord query_terrain_from_real_coord(int x, int y, int z) {
   return new(class coord,
       x: (x - _real_coords->x1)  / _real_coords->xdiff,
       y: (y - _real_coords->y1) / _real_coords->ydiff,
       z: z / _real_coords->zdiff
        );
}
class coord query_real_from_terrain_coord(int x, int y, int z) {
   if (!_real_coords) {
      return new(class coord, x : 0, y : 0);
   }
   return new(class coord,
      x: _real_coords->x1 + x * _real_coords->xdiff,
      y: _real_coords->y1 + y * _real_coords->ydiff,
      z: z * _real_coords->zdiff
     );
}
int query_newline_mode() { return _newline_mode; }
void set_newline_mode(int mode)
{
  _newline_mode = mode;
}
void set_visible_distance(int distance) {
   _visible_distance = distance;
}
int query_visible_distance() {
   return _visible_distance;
}
void create()
{
   setup_area_map();
   setup_handler();
}
void setup_area_map()
{
   int   index;
   load_area_map();
   load_zone_map();
   if (!arrayp(_room_map)) {
      _room_map = ({ });
      for (index = 0; index < _width; index++)
         _room_map += ({ allocate(_width) });
   }
}
object query_feature_ob(string name) {
   return _features[name]->feature_ob;
}
mapping calc_features(object room)
{
   class feature_data    feature;
   string     title;
   int        *room_coords = room->query_terrain_coords();
   int        x = room_coords[0];
   int        y = room_coords[1];
   int        z = room_coords[2];
   mapping    data;
   string direc;
   int range;
   mapping block_feature;
   mixed* features;
   mixed* tmp;
   block_feature = ([ ]);
   features = ({ });
   foreach(title, feature in _features) {
      if (!room->can_view_feature(title)) {
         continue;
      }
      if (!feature || !feature->feature_ob) {
         debug_printf("Unable to find feature object for %O\n", title);
         continue;
      }
      data = feature->feature_ob->query_feature_desc_from(x, y, z);
      if (!data || !sizeof(data)) {
         continue;
      }
      if (feature->feature_ob->query_blocking()) {
         foreach (direc, range in data) {
            if (!block_feature[direc]) {
               if (block_feature[direc] > range) {
                  block_feature[direc] = range;
               } else {
                  map_delete(data, direc);
               }
            }
         }
      }
      if (sizeof(data)) {
         features += ({ ({ title, feature, data }) });
      }
   }
   foreach (tmp in features) {
      data = tmp[2];
      if (sizeof(block_feature)) {
         foreach (direc, range in data) {
            if (block_feature[direc] && block_feature[direc] < range) {
               map_delete(data, direc);
            }
         }
      }
      if (sizeof(data)) {
         feature = tmp[1];
         title = tmp[0];
         room->add_feature(title, data, feature->f_items, feature->whole_sentance);
         if (!_feature_rooms[title]) {
            _feature_rooms[title] = ({ });
         } else {
            _feature_rooms[title] = filter(_feature_rooms[title], (: $1 && objectp($1) :));
         }
         _feature_rooms[title] |= ({ room });
      }
   }
}
void add_signposts(object room)
{
   class sign_data sign;
   int     *coords = room->query_terrain_coords();
   int     x = coords[0];
   int     y = coords[1];
   string  title = sprintf("%d:%d", x, y);
   object  sign_ob;
   sign = _signposts[title];
   if (!sign) {
      return;
   }
   sign_ob = room->add_sign(sign->long, sign->read_mess,
                  sign->short, sign->name,
                  sign->language);
   sign_ob->move(room);
}
void setup_zones(object room)
{
   string  *zones;
   int     *coords = room->query_terrain_coords();
   int     x = coords[0];
   int     y = coords[1];
   string  type;
   string  zone;
   if (!sizeof(_zone_map)) {
      return;
   }
   type = _zone_map[y][x..x];
   zones = _zone_types[type];
   if (!zones) {
      return;
   }
   foreach (zone in zones) {
      room->add_zone(zone);
   }
}
void calc_random_descs(object room, string key)
{
   int      limit = _random_desc_limit;
   int      *indices = ({ });
   int      *coords = room->query_terrain_coords();
   int      seed = (coords[0] * 2) + coords[1];
   mapping  desc;
   mixed    *descs = _random_descs[key];
   int      index;
   if (limit > sizeof(descs)) {
      limit = sizeof(descs);
   }
   if (!limit) {
      return;
   }
   while (sizeof(indices) < limit) {
      index = RANDOM_HANDLER->random(sizeof(descs), seed++);
      if (member_array(index, indices) >= 0) {
         continue;
      }
      indices += ({ index });
   }
   for (index = 0; index < limit; index++) {
      desc = descs[indices[index]];
      room->add_random_desc(desc["desc"]);
      room->add_item(desc["items"], desc["item_desc"]);
   }
}
void calc_random_chats(object room, string key)
{
}
string query_dest_coordinate_string(int x, int y, int z, string direc, string key) {
   class char_map_data  room_setup;
   room_setup = query_char_map(x, y);
   if (room_setup->type == AREA_WORLD) {
      return room_setup->path->query_dest_coordinate_string(x, y, z, direc, key);
   }
   return 0;
}
int* query_ground_room_co_ords(int x, int y) {
   class char_map_data  room_setup;
   room_setup = query_char_map(x, y);
   return ({ x, y, room_setup->height });
}
string query_ground_room(int x, int y) {
   int* co_ords;
   co_ords = query_ground_room_co_ords(x, y);
   return base_name(this_object()) + ":" + co_ords[0] + ":" + co_ords[1] + ":" + co_ords[2];
}
string query_climb_base_room(int x, int y, int z, int map_room, string ref base) {
   class char_map_data  room_setup;
   string *tmp;
   room_setup = query_char_map(x, y);
   if (!room_setup) {
      return 0;
   }
   if (room_setup->type == AREA_WORLD) {
     if(file_size(room_setup->path + ".c") == -1) {
       tmp = explode(room_setup->path, "_edge");
       if(sizeof(tmp) && file_size(tmp[0] + ".c") > 0)
         room_setup->path = tmp[0];
     }
     return room_setup->path->find_base_terrain_room(x, y, z, room_setup->path, map_room, ref base);
   } else if (room_setup->height_rooms) {
      if (z > room_setup->height) {
         if (map_room == TERRAIN_MAP_ROOM_MAP) {
            return room_setup->path;
         }
         if (map_room != TERRAIN_MAP_ROOM_CLIMB) {
            return TERRAIN_MAP_DEFAULT_AIR_ROOM;
         }
         return 0;
      }
      if (z == room_setup->height) {
         return room_setup->path;
      }
      if (room_setup->height_rooms[z]) {
         return room_setup->height_rooms[z];
      }
      if (room_setup->height_rooms["minimum"] > z) {
         return 0;
      }
      return room_setup->height_rooms["default"];
   } else if (z == room_setup->height) {
      return room_setup->path;
   } else if (map_room && z > room_setup->height) {
      return room_setup->path;
   } else if (z > room_setup->height) {
      if (map_room != TERRAIN_MAP_ROOM_CLIMB) {
         return TERRAIN_MAP_DEFAULT_AIR_ROOM;
      }
   }
   return 0;
}
string query_base_room(int x, int y, int z, int map_room) {
   string dest;
   dest = "bing";
   return query_climb_base_room(x, y, z, map_room, ref dest);
}
void setup_room(object room, string base_path)
{
   string main_base;
   string base;
   int      *room_coords = room->query_terrain_coords();
   mixed    *coords;
   int      x;
   int      y;
   string   direc;
   class char_map_data  room_setup;
   string*  dirs;
   mapping  adjacent_descs = ([ ]);
   mapping  adjacent_sent = ([ ]);
   mapping  distant;
   string   adjacent;
   string   key;
   string   room_long = "";
   string   key_here;
   mixed    *exit_mods;
   object   new_room;
   string   outside_types = "";
   mixed    *exits;
   mapping  exit;
   string   *sentances;
   mixed   tmp;
   int z;
   int road_jump;
   class coord fluff;
   string* miss_road;
   mapping ignore_exits;
   string  walk_pre;
   string  walk_full;
   string  journey_pre;
   string  new_base_path;
   if (!arrayp(room_coords)) {
      debug_printf("Unable to find room coordinates from %O\n", file_name(room));
      return ;
   }
   room_setup = query_char_map(room_coords[0], room_coords[1]);
   key_here = room_setup->char;
   if (room_setup->room_desc) {
      adjacent_descs[room_setup->room_desc] = ({ "here" });
      adjacent_sent[room_setup->char] = 1;
      if( room_setup->items ) {
          if( stringp( room_setup->items ) &&
              stringp( room_setup->item_desc ) ) {
              room->add_item( room_setup->items, room_setup->item_desc );
          } else if( arrayp( room_setup->items ) &&
              arrayp( room_setup->item_desc ) && sizeof( room_setup->items ) ) {
              if( sizeof( room_setup->items ) !=
                  sizeof( room_setup->item_desc ) ) {
                  debug_printf( "Error, unequal arrays.  Item not set." );
              } else {
                  int i;
                  for( i = 0; i < sizeof( room_setup->items ); i++ ) {
                      room->add_item( room_setup->items[i],
                          room_setup->item_desc[i] );
                  }
              }
          }
      }
   }
   if (room_setup->room_jump_matching) {
      road_jump = room_setup->room_jump;
   }
   walk_pre = room->query_terrain_map_walk_exit();
   journey_pre = room->query_terrain_map_journey_exit();
   exits = _standard_exits[sprintf("%d:%d:%d", room_coords[0], room_coords[1], room_coords[2])];
   ignore_exits = ([ ]);
   if (exits) {
      foreach(exit in exits) {
         room->add_exit(exit["direc"], exit["dest"], exit["type"]);
         if (exit["modifiers"]) {
            room->modify_exit(exit["direc"], exit["modifiers"]);
         }
         ignore_exits[exit["direc"]] = 1;
      }
   }
   main_base = base_name(this_object());
   if (room_setup->height_rooms ||
       room_setup->type == AREA_WORLD) {
      int i;
      x = room_coords[0];
      y = room_coords[1];
      for (i = 0; i < 2; i++) {
         z = room_coords[2];
         if (!i) {
            direc = "up";
            tmp = "down";
            z++;
         } else {
            direc = "down";
            tmp = "up";
            z--;
         }
         base = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
         if (base) {
            new_room = load_object(base);
            new_base_path = base;
            if (!new_room) {
               continue;
            }
            if (new_room->can_enter_from(key_here, direc, base_path) &&
                room->can_exit_to(key_here, direc, new_base_path)) {
               room->add_exit(direc, main_base + ":" + x + ":" + y + ":" + z, "path");
               exit_mods = room->get_to_same(tmp, direc, key, new_base_path);
               if (exit_mods) {
                   room->modify_exit(direc, exit_mods);
               }
            }
         }
      }
   }
   miss_road = allocate(3 * 3);
   foreach(direc in _direc_order) {
      coords = _direcs[direc];
      x = coords[0] + room_coords[0];
      y = coords[1] + room_coords[1];
      z = room_coords[2];
      if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
         base = find_adjacent_terrain(x, y);
         if (!base) {
            continue;
         }
         fluff = query_real_from_terrain_coord(x, y, z);
         fluff = base->query_terrain_from_real_coord(fluff->x, fluff->y, fluff->z);
         room_setup = base->query_char_map(fluff->x, fluff->y);
         if (room_setup && room_setup->type != AREA_OBSTACLE) {
            tmp = base->query_base_room(fluff->x, fluff->y, z, TERRAIN_MAP_ROOM_EXACT);
            if (tmp) {
               new_base_path = tmp;
               new_room = load_object(tmp);
               base += ":" + fluff->x + ":" + fluff->y + ":" + z;
            } else {
               new_room = 0;
               new_base_path = 0;
            }
         }
      } else {
         room_setup = query_char_map(x, y);
         if (room_setup && room_setup->type != AREA_OBSTACLE) {
            tmp = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
            new_base_path = tmp;
            if (tmp) {
               new_room = load_object(tmp);
               base = main_base + ":" + x + ":" + y + ":" + z;
            } else {
               new_room = 0;
            }
         }
      }
      if (!room_setup || !new_room) {
         continue;
      }
      key = room_setup->char;
      if (!coords[0] || !coords[1]) {
         miss_road[(coords[0] + 1) * 3 + coords[1] + 1] = new_base_path;
      } else {
         if ((miss_road[(coords[0] + 1) * 3 + 1] != new_base_path ||
              miss_road[coords[1] + 4] != new_base_path) &&
             miss_road[coords[1] + 4] &&
             miss_road[(coords[0] + 1) * 3 + 1] &&
             !miss_road[coords[1] + 4]->can_move_between(key, direc,
                                    miss_road[(coords[0] + 1) * 3 + 1],
                                    miss_road[coords[1] + 4], new_base_path)) {
            continue;
         }
      }
      switch(room_setup->type) {
         case AREA_OBSTACLE   :
            break;
         case AREA_ROAD       :
         case AREA_ROOM       :
         case AREA_WORLD      :
           if (ignore_exits[direc]) {
              break;
           }
           if (new_room->can_enter_from(key_here, direc, base_path) &&
                room->can_exit_to(key, direc, new_base_path)) {
              tmp = new_room->query_enter_exit_direction(key, key_here, direc, room, base_path);
              if (tmp) {
                 room->add_exit(tmp, base, "road");
                 walk_full = tmp;
              } else {
                 room->add_exit(direc, base, "road");
                 room->add_exit(walk_pre + direc, base, "road");
                 room->add_default_exit(direc, base);
                 walk_full = walk_pre + direc;
              }
              if (coords[4]) {
                 room->modify_exit(walk_full, coords[4]);
                 room->modify_exit(direc, coords[4]);
              }
              if (key_here == key ||
                  (road_jump &&
                   room_setup->room_jump_matching &&
                   room_setup->room_jump == road_jump)) {
                 exit_mods = room->get_to_same(_direcs[direc][2], direc, key, new_base_path);
                 if (exit_mods) {
                    room->modify_exit(direc, exit_mods);
                    room->modify_exit(walk_full, exit_mods);
                 }
                 if (room_setup->room_jump > 1) {
                    room->modify_exit(walk_full, ({ "obvious", 0 }));
                    room->add_variable_exit(journey_pre + direc);
                    room->add_exit(journey_pre + direc, base, "road");
                    exit_mods = room->get_to_same(walk_full, journey_pre + direc, key, new_base_path);
                    if (coords[4]) {
                       room->modify_exit(journey_pre + direc, coords[4]);
                    }
                    if (exit_mods) {
                        room->modify_exit(journey_pre + direc, exit_mods);
                    }
                 }
              } else {
                 exit_mods = room->get_to_other(_direcs[direc][2], direc, key, new_base_path);
                 if (exit_mods) {
                     room->modify_exit(walk_full, exit_mods);
                 }
                 exit_mods = new_room->
                             get_from_other(_direcs[direc][2], direc, key_here, base_path);
                 if (exit_mods) {
                     room->modify_exit(walk_full, exit_mods);
                 }
              }
              room->modify_exit(direc, ({ "obvious", 0 }));
           }
           break;
      }
      if ((key_here != key) && (member_array(key[0], outside_types) < 0)) {
         outside_types += key;
      }
      adjacent = room_setup->adjacent_desc;
      if (adjacent && strlen(adjacent) > 1) {
         if (room->can_view_adjacent_desc(room_setup->char,
                                          key_here,
                                          room_setup->path,
                                          z,
                                          direc)) {
            if (!room_setup->whole_sentance) {
               adjacent_sent[adjacent] = 1;
            }
            if (!adjacent_descs[adjacent]) {
               adjacent_descs[adjacent] = ({ });
               if( room_setup->items ) {
                   if (!adjacent_sent[room_setup->char]) {
                      adjacent_sent[room_setup->char] = 1;
                      if( stringp( room_setup->items ) &&
                          stringp( room_setup->item_desc ) ) {
                          room->add_item( room_setup->items,
                              room_setup->item_desc );
                      } else if( arrayp( room_setup->items ) &&
                          arrayp( room_setup->item_desc ) &&
                          sizeof( room_setup->items ) ) {
                          if( sizeof( room_setup->items ) !=
                              sizeof( room_setup->item_desc ) ) {
                              debug_printf( "Error, unequal arrays.  Item not "
                                  "set." );
                          } else {
                              int i;
                              for( i = 0; i < sizeof( room_setup->items ); i++) {
                                  room->add_item( room_setup->items[i],
                                      room_setup->item_desc[i] );
                              }
                          }
                      }
                   }
               }
            }
            adjacent_descs[adjacent] += ({ direc });
         }
      }
   }
   sentances = ({ });
   foreach(adjacent, dirs in adjacent_descs) {
      tmp = replace_string(adjacent,
                "$D", query_multiple_short(dirs, "the", 1));
      if (adjacent_sent[adjacent]) {
         if (strlen(tmp) > 1) {
            sentances += ({ tmp });
         }
      } else if (tmp != "") {
         if (query_newline_mode()) {
            room_long += tmp + "\n";
         } else {
            room_long += "  " + tmp;
         }
      }
   }
   if (sizeof(sentances)) {
      if (!query_newline_mode()) {
         room_long += "  ";
      }
      room_long += capitalize(query_multiple_short(sentances, "the", 1)) + ".";
      if (query_newline_mode()) {
         room_long += "\n";
      }
   }
   room->set_outside_types(outside_types);
   add_signposts(room);
   setup_zones(room);
   exit = calc_features(room);
   if (_real_coords && (_real_coords->x1 || _real_coords->x2)) {
      fluff = query_real_from_terrain_coord(room_coords[0], room_coords[1], 0);
      foreach (string title in TERRAIN_MAP_WORLD_MAP->query_features_at(fluff->x, fluff->y)) {
         if (!room->can_view_feature(title)) {
            continue;
         }
         distant = title->query_feature_desc_from(fluff->x, fluff->y, fluff->z);
         if (sizeof(distant)) {
            if (sizeof(exit)) {
               foreach (direc, int range in distant) {
                  if (exit[direc] && exit[direc] < range) {
                     map_delete(distant, direc);
                  }
               }
            }
            if (sizeof(distant)) {
               room->add_distant_feature(title, distant);
            }
         }
      }
   }
   calc_random_descs(room, key_here);
   calc_random_chats(room, key_here);
   room->set_extra_long(room_long);
   room->set_installed(1);
   room->calc_exits();
}
string find_adjacent_terrain(int x, int y)
{
   string index;
   class coord real;
   if (!_real_coords || !_real_coords->in_world_map) {
      return 0;
   }
   index = x + ":" + y;
   if (!undefinedp(_adjacent_terrains[index])) {
      return _adjacent_terrains[index];
   }
   real = query_real_from_terrain_coord(x, y, 0);
   _adjacent_terrains[index] = TERRAIN_MAP_WORLD_MAP->find_terrain_at(real->x, real->y);
   return _adjacent_terrains[index];
}
void find_all_adjacent_terrains() {
   find_adjacent_terrain(-1,-1);
   find_adjacent_terrain(-1,0);
   find_adjacent_terrain(-1,40);
   find_adjacent_terrain(0,40);
   find_adjacent_terrain(40,40);
   find_adjacent_terrain(40,0);
   find_adjacent_terrain(40,-1);
   find_adjacent_terrain(0,-1);
}
string* debug_adjacent_terrains() {
   return ({ find_adjacent_terrain(-1, 0),
             find_adjacent_terrain(0, -1),
             find_adjacent_terrain(0, _height),
             find_adjacent_terrain(_width, 0) });
}
mixed* query_rooms_to(int x, int y, int z, string direc, int len,
                       string main_key, int jump_len, int road_type ) {
   class char_map_data  room_setup;
   class coord real;
   string new_direc;
   string found_direc;
   string terr;
   string bit;
   int num;
   int found;
   int old_x;
   int old_y;
   int new_x;
   int new_y;
   mixed* ret;
   mixed* data;
   ret = ({ ({ }), ({ }) });
   do {
      data = _direcs[direc];
      if (!data) {
         debug_printf("Bad direction %O\n", direc);
         continue;
      }
      old_x = x;
      old_y = y;
      x += data[0];
      y += data[1];
      if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
         terr = find_adjacent_terrain(x, y);
         if (!terr) {
            return ret;
         }
         real = query_real_from_terrain_coord(x, y, 0);
         data = terr->query_more_terrains_rooms_from(real->x, real->y, real->z, direc,
                                 len - num, jump_len,
                                 main_key, road_type);
         if (sizeof(data)) {
            ret[0] += data[0];
            ret[1] += data[1];
         }
         return ret;
      }
      ret[0] += ({ direc });
      bit = sprintf("%d:%d:%d", x, y, z);
      ret[1] += ({ sprintf("%s:%s", base_name(this_object()), bit) });
      if (_standard_exits[bit]) {
         break;
      }
      if (road_type) {
         found = 0;
         foreach (new_direc, data in _direcs) {
            new_x = x + data[0];
            new_y = y + data[1];
            if (new_x != old_x || new_y != old_y) {
               if ((new_x < 0) || (new_x >= _width) || (new_y < 0) || (new_y >= _height)) {
                  terr = find_adjacent_terrain(new_x, new_y);
                  if (terr) {
                     real = query_real_from_terrain_coord(new_x, new_y, z);
                     real = terr->query_terrain_from_real_coord(real->x, real->y, z);
                     room_setup = terr->query_char_map(real->x, real->y);
                  } else {
                     room_setup = 0;
                  }
               } else {
                  room_setup = query_char_map(new_x, new_y);
               }
               if (room_setup && room_setup->room_jump == jump_len) {
                  found_direc = new_direc;
                  found++;
               }
            }
         }
         if (found == 1) {
            direc = found_direc;
         } else {
            break;
         }
      } else {
         room_setup = query_char_map(x + data[0], y + data[1]);
         if (!room_setup || room_setup->char != main_key) {
            break;
         }
      }
   } while (num++ < len);
   return ret;
}
mixed* query_more_terrains_rooms_from(int x, int y, int z, string direc,
                                       int moves_left, int jump,
                                       string main_key, int road_jump) {
   class coord bing;
   class char_map_data  room_setup;
   int found;
   string found_direc;
   string new_direc;
   mixed* data;
   int new_x;
   int new_y;
   bing = query_terrain_from_real_coord(x, y, 0);
   room_setup = query_char_map(bing->x, bing->y);
   if (road_jump) {
      if (room_setup->room_jump != jump) {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
         foreach (new_direc, data in _direcs) {
            new_x = bing->x + data[0];
            new_y = bing->y + data[1];
            room_setup = query_char_map(new_x, new_y);
            if (room_setup && room_setup->room_jump == jump) {
               found = 1;
               found_direc = new_direc;
               break;
            }
         }
         if (!found) {
            return ({ });
         }
         direc = found_direc;
      } else {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
      }
      return query_rooms_to(bing->x, bing->y, bing->z, direc, moves_left,
                            main_key, jump, road_jump);
   } else {
      if (room_setup->char == main_key) {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
         return query_rooms_to(bing->x, bing->y, bing->z, direc, moves_left,
                            main_key, jump, road_jump);
      }
      return ({ });
   }
}
string* find_next_room_from(int x, int y, int z, string direc) {
   class char_map_data  room_setup;
   string test;
   object ob;
   object* obs;
   mixed* stuff;
   int pos;
   room_setup = query_char_map(x, y);
   stuff = query_rooms_to(x, y, z, direc, room_setup->room_jump,
                          room_setup->char, room_setup->room_jump,
                          room_setup->room_jump_matching);
   foreach (test in stuff[0]) {
      ob = find_object(test);
      if (ob) {
         obs = filter(all_inventory(ob), (: living($1) :));
         if (sizeof(obs) > 0) {
            return ({ test }) + stuff[0..pos];
         }
      }
      pos++;
   }
   if (sizeof(stuff[1])) {
      return ({ stuff[1][<1] }) + stuff[0];
   }
   return 0;
}
void add_room_to_zone(object room, string zone)
{
   object *zones = _room_zones[zone];
   if (!zones)
      zones = ({ room });
   else if (member_array(room, zones) == -1)
      zones += ({ room });
   _room_zones[zone] = zones - ({ 0 });
}
mixed query_room(int x, int y, int z)
{
   class char_map_data room_map = query_char_map(x, y);
   string base_path;
   object room;
   class coord real;
   base_path = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
   if (!base_path) {
      return 0;
   }
   room = clone_object(base_path);
   if (!room) {
      debug_printf("Unable to create room from %O at %O %O %O\n", base_path, x, y, z);
   } else {
      room->create_terrain_room();
      room->set_terrain_coords(x, y, z);
      real = query_real_from_terrain_coord(x, y, z);
      room->set_co_ord(({ real->x, real->y, real->z }));
      if (classp(_real_coords)) {
         room->set_room_size(({ _real_coords->xdiff, _real_coords->ydiff, _real_coords->zdiff }));
      }
      room->set_terrain_handler(base_name(this_object()));
      room->terrain_setup();
      room->add_property("base path", base_path);
      _room_map[y][x] = room;
      setup_room(room, base_path);
      if (room_map->type == AREA_WORLD && base_path != room_map->path) {
         room_map->path->setup_in_terrain(room, x, y, z);
      }
   }
   return room;
}
object query_room_at(int x, int y, int z)
{
   if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height))
      return 0;
   return find_object(sprintf("%s:%d:%d:%d", base_name(this_object()), x, y, z));
}
object *query_rooms_in_block(int x, int y, int z, int width, int height)
{
   int      h, v;
   mixed    *result = ({ });
   object   room;
   for (h = x; h < (x + width); h++) {
      for (v = y; v < (y + height); v++) {
         room = query_room_at(h, v, z);
         if (room)
            result = result + ({ room });
      }
   }
   return result;
}
varargs object *query_rooms_in_range(int x, int y, int z, int max, int min)
{
   int      h, v;
   mixed    *result = ({ });
   object   room;
   int    dist;
   for (h = x - max; h <= (x + max); h++) {
      for (v = y - max; v <= (y + max); v++) {
        dist = to_int(sqrt(pow(x - h, 2) + pow(y - v, 2)) + 0.4999);
        if ((dist > max) || (dist < min))
           continue;
         room = query_room_at(h, v, z);
         if (room)
            result = result + ({ room });
      }
   }
   return result;
}
object load_room_at(int x, int y, int z)
{
   class char_map_data room_map = query_char_map(x, y);
   if (!room_map) {
      debug_printf("Unable to load room at %d %d\n", x, y);
      return 0;
   }
   if (room_map->type == AREA_OBSTACLE) {
      return 0;
   }
   return load_object(sprintf("%s:%d:%d:%d", base_name(this_object()), x, y, z));
}
class char_map_data query_char_map(int x, int y)
{
   string   type;
   class char_map_data  room_map;
   if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
      return 0;
   }
   if (x >= sizeof(_area_map[y])) {
      debug_printf("The x value is out of range: %d > %d", x, sizeof(_area_map[y]));
      return 0;
   }
   type = _area_map[y][x..x];
   room_map = copy(_char_map[type]);
   if (!room_map) {
      debug_printf("There is no char type for '%s'", type);
      return 0;
   }
   room_map->char = type;
   return room_map;
}
string query_debug_map(int x, int y, int width, int showx, int showy) {
   int i;
   int j;
   int sx;
   int sy;
   int ny;
   string ret;
   string base;
   string new_base;
   string colour;
   ret = "";
   sx = x - width / 2;
   sy = y + width / 2;
   for (j = 0; j < width; j++) {
      if (sy - j >= 0 && sy - j < _height) {
         for (i = 0; i < width; i++) {
            if (sx + i >= 0 && sx + i < _width) {
               if (sx +i == showx && sy - j == showy) {
                  ret += "%^YELLOW%^" + _area_map[sy - j][sx + i..sx + i] +
                         "%^RESET%^";
                  colour = 0;
               } else {
                  if (colour) {
                     ret += "%^RESET%^";
                     colour = 0;
                  }
                  ret += _area_map[sy - j][sx + i..sx + i];
               }
            } else {
               if (sx + i >= _width) {
                  base = find_adjacent_terrain(_width + 1, sy - j);
               } else {
                  base = find_adjacent_terrain(-1, sy - j);
               }
               if (base) {
                  if (colour != "%^CYAN%^") {
                     ret += "%^BOLD%^%^CYAN%^";
                     colour = "%^CYAN%^";
                  }
                  if (sx + i >= _width) {
                     ret += base->query_debug_map_char(sx + i - _width, sy - j);
                  } else {
                     ret += base->query_debug_map_char(sx + i + _width, sy - j);
                  }
               } else {
                  ret += " ";
               }
            }
         }
         if (colour) {
            ret += "%^RESET%^";
            colour = 0;
         }
         ret += "\n";
      } else {
         base = find_adjacent_terrain(sx + i, sy - j);
         if (base) {
            if (sy - j < 0) {
               ny = sy - j + _height;
            } else {
               ny = sy - j - _height;
            }
            for (i = 0; i < width; i++) {
               if (sx + i >= 0 && sx + i < _width) {
                  if (colour != "%^MAGENTA%^") {
                     ret += "%^BOLD%^%^MAGENTA%^";
                     colour = "%^MAGENTA%^";
                  }
                  ret += base->query_debug_map_char(sx + i, ny);
               } else {
                  new_base = find_adjacent_terrain(sx + i, sy - j);
                  if (new_base) {
                     if (colour != "%^RED%^") {
                        ret += "%^BOLD%^%^RED%^";
                        colour = "%^RED%^";
                     }
                     if (sx + i >= _width) {
                        ret += new_base->query_debug_map_char(sx + i - _width, ny);
                     } else {
                        ret += new_base->query_debug_map_char(sx + i + _width, ny);
                     }
                  } else {
                     ret += " ";
                  }
               }
            }
            ret += "%^RESET%^\n";
            colour = 0;
         }
      }
   }
   return ret;
}
string query_debug_map_char(int x, int y) {
   return _area_map[y][x..x];
}
string query_debug_map_feature(string name) {
   int x;
   int y;
   class feature_data feature;
   mixed data;
   string ret;
   int colour;
   int found;
   feature = _features[name];
   ret = "";
   colour = 0;
   for (y = _height - 1; y >= 0; y--) {
      for (x = 0; x < _width; x++) {
         data = feature->feature_ob->query_feature_desc_from(x, y, 0, 1);
         found = sizeof(data);
         if (found) {
            if (!colour) {
               ret += "%^YELLOW%^";
               colour = 1;
            }
         } else {
            if (colour) {
               ret += "%^RESET%^";
               colour = 0;
            }
         }
         ret += _area_map[y][x..x];
      }
      ret += "%^RESET%^\n";
      colour = 0;
   }
   return ret;
}
string query_debug_map_feature_distant(string feature) {
   int x;
   int y;
   mixed data;
   string ret;
   int colour;
   class coord fluff;
   ret = "";
   colour = 0;
   for (y = _height - 1; y >= 0; y--) {
      for (x = 0; x < _width; x++) {
         fluff = query_real_from_terrain_coord(x, y, 0);
         data = feature->query_feature_desc_from(fluff->x, fluff->y, fluff->z);
         if (data && sizeof(data)) {
            if (!colour) {
               ret += "%^YELLOW%^";
               colour = 1;
            }
         } else {
            if (colour) {
               ret += "%^RESET%^";
               colour = 0;
            }
         }
         ret += _area_map[y][x..x];
      }
      ret += "%^RESET%^\n";
      colour = 0;
   }
   return ret;
}
private void add_key(mapping key, string char, string str) {
  if(strsrch(str, "intersection") != -1)
    return;
  if(!key[char])
    key[char] = str;
  else if(strsrch(key[char], str) == -1 ) {
    key[char] += ", " + str;
  }
}
private int update_map(mapping data, mixed* map, mapping key, mixed *colours,
                       int x, int y, int z, int offx, int offy) {
   class char_map_data info;
   string char, colour, tmp;
   string room;
   int block;
   object ob;
   if (x < 0) {
      if (y < 0) {
         data["-y-x"] = 1;
      } else if (y >= _height) {
         data["+y-x"] = 1;
      } else {
         data["-x"] = 1;
      }
      return 0;
   } else if (x >= _width) {
      if (y < 0) {
         data["-y+x"] = 1;
      } else if (y >= _height) {
         data["+y+x"] = 1;
      } else {
         data["+x"] = 1;
      }
      return 0;
   } else if (y < 0) {
      data["-y"] = 1;
      return 0;
   } else if (y >= _height) {
      data["+y"] = 1;
      return 0;
   }
   info = query_char_map(x, y);
   if (!info) {
      return 1;
   }
   if (info->type == AREA_OBSTACLE) {
      map[y - offy][x - offx] = info->char;
      colours[y - offy][x - offx] = info->colour;
      if(!info->colour) {
        colours[y - offy][x - offx] = "%^BLUE%^";
      }
      if (info->room_desc == "Obstacle" && stringp(info->items)) {
        add_key(key, info->char, info->items);
      } else if (info->room_desc != "") {
        add_key(key, info->char, info->room_desc);
      } else {
         map[y - offy][x - offx] = " ";
      }
      data["block" + info->char] = 1;
      return 1;
   } else {
      char = data[info->char];
      colour = data[info->colour];
      if (!char || !colour) {
         room = query_base_room(x, y, z, TERRAIN_MAP_ROOM_MAP);
         if (room) {
            ob = load_object(room);
            if (ob) {
               char = ob->query_terrain_map_character();
               colour = ob->query_terrain_map_colour();
               block = ob->query_terrain_map_block();
               if(char && ob) {
                  tmp = ob->query_key_desc();
                  if(!tmp) {
                     tmp = ob->query_short();
                  }
                  if(!tmp) {
                     debug_printf("Room %s has no short.", base_name(ob));
                  } else {
                     add_key(key, char, tmp);
                  }
               }
               if (block || info->height > z) {
                  data["block" + info->char] = 1;
               }
            } else {
               debug_printf("Unable to find %O\n", room);
            }
         }
         if (!char) {
            char = info->char;
         }
         if(!colour) {
            colour = info->colour;
         }
         data[info->char] = char;
      }
      map[y - offy][x - offx] = char;
      colours[y - offy][x - offx] = colour;
   }
   if(char && !key[char] && !data["nokey"+info->char]) {
      data["nokey" + info->char] = 1;
      debug_printf("No key for %s", char);
   }
   return data["block" + info->char];
}
private string line_in_map(mapping data, mixed* map, mapping key,
                           mixed *colours, int offx, int offy,
                           int sx, int sy, int ex, int ey, int z) {
   int x;
   int y;
   int dx;
   int dy;
   int incx;
   int incy;
   int balance;
   if (ex >= sx) {
      dx = ex - sx;
      incx = 1;
   } else {
      dx = sx - ex;
      incx = -1;
   }
   if (ey >= sy) {
      dy = ey - sy;
      incy = 1;
   } else {
      dy = sy - ey;
      incy = -1;
   }
   x = sx;
   y = sy;
   if (dx >= dy) {
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      while (x != ex) {
         if (update_map(data, map, key, colours, x, y, z, offx, offy)) {
            break;
         }
         if (balance >= 0) {
            y += incy;
            balance -= dx;
         }
         balance += dy;
         x += incx;
      }
   } else {
      dx <<= 1;
      balance = dx - dy;
      dy <<= 1;
      while (y != ey) {
         if (update_map(data, map, key, colours, x, y, z, offx, offy)) {
            break;
         }
         if (balance >= 0) {
            x += incx;
            balance -= dy;
         }
         balance += dx;
         y += incy;
      }
   }
   update_map(data, map, key, colours, x, y, z, offx, offy);
}
private void update_blocking(mapping data,
                             mixed* map, mixed* colours, int x, int y,
                             int distance) {
   int dx;
   int dy;
   int adx;
   int ady;
   int dist;
   int nx;
   int ny;
   int tx;
   int ty;
   int incx;
   int incy;
   string* template;
   string str;
   dx = (x - distance);
   dy = (y - distance);
   str = " ";
   if (dx < 0) {
      adx = - dx;
      incx = -1;
   } else {
      adx = dx;
      incx = 1;
   }
   if (dy < 0) {
      ady = - dy;
      incy = -1;
   } else {
      ady = dy;
      incy = 1;
   }
   if (incx != incy) {
      incx = -incx;
      incy = - incy;
   }
   if (adx > ady) {
      template = TERRAIN_MAP_WORLD_MAP->query_blocking_template(ady, adx, 0);
   } else {
      template = TERRAIN_MAP_WORLD_MAP->query_blocking_template(adx, ady, 0);
   }
   if (!template) {
      debug_printf("Error with the template");
      return ;
   }
   dist = distance + 1;
   for (tx = 0; tx < dist; tx++) {
      for (ty = 0; ty < dist; ty++) {
         if (template[tx][ty] == '*') {
            if (adx > ady) {
               nx = distance + tx * incx;
               ny = distance + ty * incy;
            } else {
               nx = distance + ty * incx;
               ny = distance + tx * incy;
            }
            if (nx < sizeof(map) && ny < sizeof(map[nx]) &&
                nx >= 0 && ny >= 0) {
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            }
            if (adx == ady) {
               nx = distance + tx * incx;
               ny = distance + ty * incy;
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            } else if (adx == 0) {
               nx = distance + ty * incx;
               ny = distance - tx * incy;
               map[nx][ny] = str;
            } else if (ady == 0) {
               nx = distance - tx * incx;
               ny = distance + ty * incy;
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            }
         }
      }
   }
}
mapping query_player_map_internal_template(mixed* map, mapping key,
                                  mixed *colours, int x_c, int y_c, int z_c,
                                  int distance) {
   int offx;
   int offy;
   int x;
   int y;
   mapping data;
   data = ([ ]);
   offx = x_c - distance;
   offy = y_c - distance;
   for (x = 0; x < sizeof(map); x++) {
      for (y = 0; y < sizeof(map[x]); y++) {
         if (map[y][x] == 1) {
            if (update_map(data, map, key, colours, x + offx, y + offy, z_c, offx, offy)) {
               if (x > 0) {
                  if (y > 0 && data["block" + map[y-1][x-1]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x, y-1, distance);
                  } else if (y < sizeof(map) - 1 && data["block" + map[y+1][x-1]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x, y + 1, distance);
                  } else if (y > 0 && data["block" + map[y-1][x]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x - 1, y - 1, distance);
                  } else {
                     update_blocking(data, map, colours, x, y, distance);
                  }
               } else {
                  update_blocking(data, map, colours, x, y, distance);
               }
            }
         }
      }
   }
   return data;
}
string query_player_map_template(int x_c, int y_c, int z_c, int visibility,
             int max_size) {
   string ret, item, base, current, *keys;
   mixed *map, *colours;
   mapping data, key;
   int i, j;
   int distance;
   distance = _visible_distance * visibility / 100;
   if (!distance) {
      distance = 1;
   }
   data = ([ ]);
   key = ([ ]);
   map = ({ });
   colours = ({ });
   map = TERRAIN_MAP_WORLD_MAP->query_map_template(distance);
   colours = TERRAIN_MAP_WORLD_MAP->query_map_template(distance);
   if (max_size && (max_size % 2) != 1) {
      max_size--;
   }
   if (max_size && sizeof(map) > max_size) {
      j = (max_size - 1) / 2;
      map = map[distance - j..distance + j];
      colours = colours[distance - j..distance + j];
      for (i = 0; i < sizeof(map); i++) {
         map[i] = map[i][distance - j..distance + j];
         colours[i] = colours[i][distance - j..distance + j];
      }
      x_c += (distance - j);
      y_c += (distance - j);
   }
   data = query_player_map_internal_template(map, key, colours, x_c, y_c, z_c,
                                    distance);
   if (data["-y"]) {
     base = find_adjacent_terrain(x_c, -1);
     if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c,
                                            y_c + _height, z_c, distance);
         }
      }
   }
   if (data["+y"]) {
      base = find_adjacent_terrain(x_c, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c,
                                            y_c - _height, z_c, distance);
         }
      }
   }
   if (data["-x"]) {
      base = find_adjacent_terrain(-1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["+x"]) {
      base = find_adjacent_terrain(_width + 1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["-y+x"]) {
      base = find_adjacent_terrain(_width + 1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y+x"]) {
      base = find_adjacent_terrain(_width + 1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y-x"]) {
      base = find_adjacent_terrain(-1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["-y-x"]) {
      base = find_adjacent_terrain(-1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   map[sizeof(map) / 2][sizeof(map) / 2] = "@";
   if(!this_player()->query_property(PLAYER_PLAIN_MAPS)) {
     colours[sizeof(map) / 2][sizeof(map) / 2] = "%^YELLOW%^";
     for(i=0; i<sizeof(map); i++) {
       current = "";
       for(j=0; j<sizeof(map); j++) {
         if(map[i][j] == "\r" || !stringp(map[i][j])) {
           map[i][j] = " ";
         }
         if (!current || current == " ") {
           current = "";
         }
         if(!colours[i][j] || colours[i][j] == " ") {
           colours[i][j] = "";
         }
         if(colours[i][j] != current) {
           if (colours[i][j] == "" || !stringp(colours[i][j])) {
             if(current != "" && current != " ") {
               map[i][j] = "%^RESET%^" + map[i][j];
               current = "";
             }
           } else if (colours[i][j] != "\r") {
             map[i][j] = colours[i][j] + map[i][j];
             current = colours[i][j];
           }
         }
         if(i == x_c && j == y_c && current != "") {
           map[i][j] += current;
         }
       }
       if(current) {
         map[i][j-1] += "%^RESET%^";
       }
     }
   }
   if(_key && !max_size) {
     keys = ({ });
     foreach(item in keys(key)) {
       keys += map(explode(sprintf("%s %-=40s", item, key[item]), "\n"),
                   (: "     " + $1 :));
     }
   }
   ret = "";
   for(i = sizeof(map) - 1; i >= 0; i--) {
     ret += implode(map(map[i], (: stringp($1) ? $1 : " " :)), "");
     if(!max_size && sizeof(map)-2-i>= 0 && sizeof(map)-2-i < sizeof(keys)) {
       ret += keys[sizeof(map)-2-i];
     }
     ret += "\n";
   }
   return ret;
}
mapping query_player_map_internal(mixed* map, mapping key, mixed *colours,
                                  int x_c, int y_c, int z_c, int distance) {
   int x, y, e, u, v;
   int endx, endy, offx, offy;
   mapping data;
   data = ([ ]);
   offx = x_c - distance;
   offy = y_c - distance;
   x = 0;
   y = distance;
   u = 1;
   v = 2 * distance - 1;
   e = 0;
   while (x < y) {
      endx = x_c + x;
      endy = y_c + y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c + y;
      endy = y_c - x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - x;
      endy = y_c - y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - y;
      endy = y_c + x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      x++;
      e += u;
      u += 2;
      if (v < 2 * e) {
         y--;
         e -= v;
         v -= 2;
      }
      if (x > y) {
         break;
      }
      endx = x_c + y;
      endy = y_c + x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c + x;
      endy = y_c - y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - y;
      endy = y_c - x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - x;
      endy = y_c + y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
   }
   for(y=0; y<sizeof(map); y++)
     for(x=1; x<sizeof(map[y])-1; x++)
       if(map[y][x] == "\r" && map[y][x-1] != "\r" && map[y][x+1] != "\r") {
         update_map(data, map, key, colours, x + offx, y + offy, z_c, offx,
                    offy);
       }
   return data;
}
string query_player_map(int x_c, int y_c, int z_c, int visibility) {
   string ret, item, base, current, *keys;
   mixed *map, *colours;
   mapping data, key, colour_key;
   int i, j;
   int distance;
   distance = _visible_distance * visibility / 100;
   if (!distance) {
      distance = 1;
   }
   data = ([ ]);
   key = ([ ]);
   map = ({ });
   colours = ({ });
   for (i = 0; i < distance * 2 + 1; i++) {
      map += ({ allocate(distance * 2 + 1, "\r") });
      colours += ({ allocate(distance * 2 + 1, "\r") });
   }
   data = query_player_map_internal(map, key, colours, x_c, y_c, z_c,
                                    distance);
   if (data["-y"]) {
     base = find_adjacent_terrain(x_c, -1);
     if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c,
                                            y_c + _height, z_c, distance);
         }
      }
   }
   if (data["+y"]) {
      base = find_adjacent_terrain(x_c, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c,
                                            y_c - _height, z_c, distance);
         }
      }
   }
   if (data["-x"]) {
      base = find_adjacent_terrain(-1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["+x"]) {
      base = find_adjacent_terrain(_width + 1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["-y+x"]) {
      base = find_adjacent_terrain(_width + 1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y+x"]) {
      base = find_adjacent_terrain(_width + 1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y-x"]) {
      base = find_adjacent_terrain(-1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["-y-x"]) {
      base = find_adjacent_terrain(-1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   y_c -= y_c - distance;
   x_c -= x_c - distance;
   if(!this_player()->query_property(PLAYER_PLAIN_MAPS)) {
     colour_key = ([ ]);
     map[y_c][x_c] = "%^YELLOW%^@%^RESET%^";
     for(i=0; i<sizeof(map); i++) {
       current = "";
       for(j=0; j<sizeof(map); j++) {
         if(map[i][j] == "\r")
           map[i][j] = " ";
         if(!current || current == " ") current = "";
         if(!colours[i][j] || colours[i][j] == " ") colours[i][j] = "";
         if(key[map[i][j]])
           colour_key[colours[i][j] + map[i][j] + "%^RESET%^"] =
             key[map[i][j]];
         if(colours[i][j] != current) {
           if(colours[i][j] == "") {
             if(current != "" && current != " ") {
               map[i][j] = "%^RESET%^" + map[i][j];
               current = "";
             }
           } else if(colours[i][j] != "\r") {
             map[i][j] = colours[i][j] + map[i][j];
             current = colours[i][j];
           }
         }
         if(i == x_c && j == y_c && current != "")
           map[i][j] += current;
       }
       if(current)
         map[i][j-1] += "%^RESET%^";
     }
   } else {
     map[y_c][x_c] = "@";
     colour_key = key;
   }
   if(_key) {
     keys = ({ });
     foreach(item in keys(colour_key)) {
       keys += map(explode(sprintf("%s %-=40s", item, colour_key[item]), "\n"),
                           (: "     " + $1 :));
     }
   }
   ret = "";
   for(i = sizeof(map) - 1; i >= 0; i--) {
     ret += implode(map[i], "");
     if(sizeof(map)-2-i>= 0 && sizeof(map)-2-i < sizeof(keys))
       ret += keys[sizeof(map)-2-i];
     ret += "\n";
   }
   if(this_player()->query_property(PLAYER_PLAIN_MAPS))
     ret = replace_string(ret, "\r", " ");
   return ret;
}
class char_map_data query_char_map_real_coord(int x, int y)
{
   class coord our;
   our = query_terrain_from_real_coord(x, y, 0);
   return query_char_map(our->x, our->y);
}
object *query_rooms_in_zone(string zone)
{
   if (_room_zones[zone]) {
      _room_zones[zone] -= ({ 0 });
      return _room_zones[zone];
   }
   return ({ });
}
varargs void tell_zones(mixed zones, string message, mixed mess_class)
{
   object  *rooms = ({ });
   string  zone;
   if (!mess_class)
      mess_class = "zone_shout";
   if (stringp(zones))
      zones = ({ zones });
   foreach (zone in zones)
      rooms += query_rooms_in_zone(zone);
   if (sizeof(rooms))
      message(mess_class, message, rooms);
}
varargs void tell_feature(string title, mixed message)
{
   int     index;
   string  mess_class = sprintf("feature:%s", title);
   if (!_feature_rooms[title]) {
      return;
   }
   _feature_rooms[title] -= ({ 0 });
   if (!sizeof(_feature_rooms[title])) {
      return;
   }
   if (stringp(message)) {
      message(mess_class, message, _feature_rooms[title]);
   }
   if (arrayp(message)) {
      for (index = 0; index < sizeof(message); index++) {
         message(sprintf("%s:%d", mess_class, index), message[index],
         _feature_rooms[title]);
      }
   }
}
varargs string* query_distant_feature_desc(string title, mapping direcs,
                                           int visibility) {
   int       night = (WEATHER->query_tod() == "night");
   string str;
   str = title->calc_feature_desc(direcs, night, visibility);
   if (str) {
      return ({ str });
   }
   return ({ });
}
varargs string* query_feature_desc(string title, mapping direcs,
                                   int visibility) {
   class feature_data   feature;
   string*   item_desc;
   string*   dirs;
   int       night = (WEATHER->query_tod() == "night");
   string    direc;
   int       range;
   mapping   bits;
   int       index;
   string    str;
   int       new_range;
   if (!feature) {
      feature = _features[title];
   }
   if (!feature) {
      return ({ });
   }
   if( visibility == 0 ) {
      return ({ });
   }
   if (!sizeof(feature->descs)) {
      str = feature->feature_ob->calc_feature_desc(direcs, night,
                                                       visibility);
      if (str) {
         return ({ str });
      }
      return ({ });
   }
   bits = ([ ]);
   foreach (direc, range in direcs) {
      if (night) {
         item_desc = feature->night_descs;
      } else {
         item_desc = feature->descs;
      }
      if (!item_desc) {
         debug_printf("Bad night description for %O", title);
         continue;
      }
      new_range = range * 100 / visibility;
      if (feature->range > new_range && sizeof(item_desc)) {
         index = sizeof(item_desc) * new_range / feature->range;
         str = item_desc[index];
         if (str && str != "") {
            if (!bits[str]) {
               bits[str] = ({ });
            }
            bits[str] += ({ direc });
         }
      }
   }
   item_desc = ({ });
   foreach (str, dirs in bits) {
      item_desc += ({ replace_string(str, "$D", query_multiple_short(dirs)) });
   }
   return item_desc;
}
varargs string query_feature_item_desc(string title) {
   class feature_data   feature;
   mixed   item_desc;
   int       night = (WEATHER->query_tod() == "night");
   if (!feature) {
      feature = _features[title];
   }
   if (!feature) {
      return "";
   }
   if (night) {
      item_desc = feature->f_item_night_desc;
   } else {
      item_desc = feature->f_item_desc;
   }
   if (!pointerp(item_desc)) {
      return item_desc;
   }
   return item_desc[0];
}
varargs string get_a_feature_chat(string title, int range, string direc)
{
   class feature_data   feature;
   mixed     chat;
   int       night = (WEATHER->query_tod() == "night");
   if (!feature) {
      feature = _features[title];
   }
   if (!feature) {
      return "";
   }
   if (night) {
      chat = feature->night_chats;
   } else {
      chat = feature->chats;
   }
   if (!chat) {
      return "";
   }
   if (arrayp(chat)) {
      chat = chat[random(sizeof(chat))];
   }
   if (arrayp(chat)) {
      if ((range < 0) || (range >= sizeof(chat))) {
         return "";
      }
      chat = chat[range];
   }
   if (!stringp(chat)) {
      return "";
   }
   if (direc) {
      chat = replace(chat, ({ "$D", direc }));
   }
   return chat;
}
string get_an_outside_chat(string types)
{
   class char_map_data   item;
   string    *chats = ({ });
   int       index;
   mixed     *item_chats;
   for (index = 0; index < sizeof(types); index++) {
      item = _char_map[types[index..index]];
      if (!item) {
         continue;
      }
      item_chats = item->chats;
      if (!item_chats) {
         continue;
      }
      if (stringp(item_chats))
         chats += ({ item_chats });
      else if (arrayp(item_chats))
         chats += item_chats;
   }
   if (!sizeof(chats))
      return "";
   return chats[random(sizeof(chats))];
}
varargs void add_obstacle_type(string type, string description, mixed items, mixed item_desc, string room_desc)
{
   if (!type) {
      throw("Bad type");
   }
   if (!items) {
      items = ({ });
      item_desc = ({ });
   }
   if (!room_desc) {
      room_desc = "Obstacle";
   }
   _char_map[type] = new(class char_map_data,
                         type: AREA_OBSTACLE, adjacent_desc:description,
                         room_desc : room_desc,
                         items:items, item_desc:item_desc);
}
void add_special_type(string type, string base_path, int size, int road_skip, int height,
                      mapping height_rooms)
{
   _char_map[type] = new(class char_map_data,
                         type: AREA_ROOM, path:base_path,
                         room_jump : size,
                         room_jump_matching : road_skip,
                         height : height,
                         height_rooms : height_rooms);
}
void add_room_type(string type, string base_path)
{
   _char_map[type] = new(class char_map_data,
                         type: AREA_ROOM, path:base_path);
}
varargs void add_road_type(string type, string base_path, string room_desc,
              string description, mixed items, mixed item_desc)
{
   _char_map[type] = new(class char_map_data,
                        type: AREA_ROAD, adjacent_desc:description,
                        items:items, item_desc:item_desc,
                        room_desc:room_desc, path:base_path);
}
varargs void add_world_room_type(string type, string base_path) {
   mapping bits;
   string *tmp;
   if(file_size(base_path + ".c") == -1) {
     tmp = explode(base_path, "_edge");
     if(sizeof(tmp) && file_size(tmp[0] + ".c") > 0) {
       debug_printf("%s doesn't exist, using %s",
                    base_path, tmp[0]);
       base_path = tmp[0];
     }
   }
   if (file_size(base_path + ".c") > 0) {
      bits = base_path->query_adjacent_items();
      if (!mapp(bits)) {
         debug_printf("Incorrect room type %O", type);
      } else {
         _char_map[type] = new(class char_map_data,
                        type: AREA_WORLD,
                        path: base_path,
                        adjacent_desc:base_path->query_adjacent_description(),
                        items:keys(bits),
                        item_desc:values(bits),
                         room_jump : base_path->query_room_jump_size(),
                         height : base_path->query_default_height(),
                         room_jump_matching : base_path->query_follow_road());
      }
   } else {
      debug_printf("Unable to add %O since %O doesn't exist.", type, base_path);
   }
}
varargs void add_road_special_type(string type, string base_path,
              int size, int road_skip, int height,
              string room_desc,
              string description, mixed items, mixed item_desc,
              mapping height_rooms)
{
   _char_map[type] = new(class char_map_data,
                        type: AREA_ROAD, adjacent_desc:description,
                        items:items, item_desc:item_desc,
                        room_desc:room_desc, path:base_path,
                         room_jump : size,
                         height : height,
                         height_rooms : height_rooms,
                         room_jump_matching : road_skip);
}
varargs void add_exit_at(int x, int y, string direc, string dest,
                         string type, mixed modifiers)
{
   string   title = sprintf("%d:%d:%d", x, y, 0);
   if (!dest)
      return;
   if (!type)
      type = "road";
   if (!_standard_exits[title])
      _standard_exits[title] = ({ });
   _standard_exits[title] += ({ ([ "direc":direc, "dest":dest,
                                   "type":type, "modifiers":modifiers ]) });
}
varargs void add_z_exit_at(int x, int y, int z, string direc, string dest,
                         string type, mixed modifiers)
{
   string   title = sprintf("%d:%d:%d", x, y, z);
   if (!dest)
      return;
   if (!type)
      type = "road";
   if (!_standard_exits[title])
      _standard_exits[title] = ({ });
   _standard_exits[title] += ({ ([ "direc":direc, "dest":dest,
                                   "type":type, "modifiers":modifiers ]) });
}
void set_random_desc_limit(int new_limit)
{
   _random_desc_limit = new_limit;
}
void set_random_chat_limit(int new_limit)
{
   _random_chat_limit = new_limit;
}
void add_random_desc(string types, string description, mixed items, mixed item_desc)
{
   int   index;
   for (index = 0; index < sizeof(types); index++) {
      if (!_random_descs[types[index..index]])
         _random_descs[types[index..index]] = ({ });
      _random_descs[types[index..index]] += ({ ([ "desc": description,
                               "items":items, "item_desc":item_desc ]) });
   }
}
void add_random_chat(string types, string *chats)
{
   int   index;
   for (index = 0; index < sizeof(types); index++) {
      if (!_random_chats[types[index..index]])
         _random_chats[types[index..index]] = ({ });
      _random_chats[types[index..index]] += chats;
   }
}
void set_external_chats(string type, mixed chats)
{
   if (!_char_map[type]) {
      return;
   }
   ((class char_map_data)_char_map[type])->chats = chats;
}
void add_feature(string title, int x, int y, int width, int height,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs,
                 mixed night_items)
{
   object region;
   object feature;
   region = clone_object(TERRAIN_MAP_REGION_RECTANGULAR);
   region->add_feature_position(x, y, width, height);
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         f_item_night_desc : night_items,
                         whole_sentance:1,
                         feature_ob : feature,
                         night_descs : night_descs);
}
void add_feature_sentance(string title, int x, int y, int width, int height,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs, mixed night_items)
{
   object region;
   object feature;
   region = clone_object(TERRAIN_MAP_REGION_RECTANGULAR);
   region->add_feature_position(x, y, width, height);
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         feature_ob : feature,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         f_item_night_desc : night_items,
                         whole_sentance:0,
                         night_descs : night_descs);
}
void add_feature_region(string title, object region,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs,
                 mixed night_items,
                 int whole_sentance)
{
   object feature;
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         whole_sentance:whole_sentance,
                         f_item_night_desc : night_items,
                         feature_ob : feature,
                         night_descs : night_descs);
}
void add_feature_ob(string title, object feature) {
   if (_real_coords && _real_coords->xdiff) {
      feature->set_distance_multiplier(_real_coords->xdiff);
   }
   _features[title] = new(class feature_data,
                          f_items : feature->query_items(),
                          f_item_desc : feature->query_day_items(),
                          f_item_night_desc : feature->query_night_items(),
                          feature_ob : feature);
}
varargs void modify_feature(string title, string *descs, mixed item_desc)
{
   if (!_features[title]) {
      return;
   }
   if (descs) {
      _features[title]->descs = descs;
   }
   if (item_desc) {
      _features[title]->f_item_desc = item_desc;
   }
}
void set_feature_chats(string title, mixed *chats, mixed* night_chats)
{
   if (!_features[title]) {
      return;
   }
   ((class feature_data)_features[title])->chats = chats;
   ((class feature_data)_features[title])->night_chats = night_chats;
}
void remove_feature(string title)
{
   object room;
   if (!_features[title]) {
      return;
   }
   map_delete(_features, title);
   if (!_feature_rooms[title]) {
      return;
   }
   _feature_rooms[title] -= ({ 0 });
   foreach(room in _feature_rooms[title]) {
      room->remove_feature(title);
   }
   map_delete(_feature_rooms, title);
}
void add_sign(int x, int y, string sign_long, mixed sign_read_mess,
              string sign_short, mixed sign_name, string sign_language)
{
   string   title = sprintf("%d:%d", x, y);
   _signposts[title] = new(class sign_data,
                         long:sign_long, read_mess:sign_read_mess,
                         short:sign_short, name:sign_name,
                         language:sign_language);
}
void add_zones(string type, string *zone_names)
{
   _zone_types[type] = zone_names;
}
void reset_handler()
{
   mixed *rooms;
   if (arrayp(_room_map)) {
      foreach(rooms in _room_map) {
         rooms->dest_me();
      }
   }
   _room_map = 0;
   _area_map = 0;
   setup_area_map();
}
void load_zone_map()
{
   string   map_path = query_map_file() + ".zones";
   int      index = 1;
   string   line;
   int      width;
   int      height;
   _zone_map = ({ });
   while (line = read_file(map_path, index++, 1)) {
      if (width < sizeof(line))
         width = sizeof(line);
      _zone_map += ({ line });
   }
   height = index - 1;
   if ((width != _width) || (height != _height))
      _zone_map = ({ });
}
void load_area_map()
{
   string   map_path = query_map_file() + ".map";
   int      index = 1;
   int      height;
   string   line;
   _area_map = ({ });
   while (line = read_file(map_path, index++, 1)) {
      if (sizeof(line)) {
         line = line[0..<2];
         if (_width < sizeof(line)) {
            _width = sizeof(line);
         }
         _area_map = ({ line }) + _area_map;
         height++;
      }
   }
   _height = height;
   if (!height) {
      printf("Unable to open %O\n", map_path);
   }
}
object create_virtual_object(string x_str, string y_str, string z_str)
{
   int x = to_int(x_str);
   int y = to_int(y_str);
   int z = to_int(z_str);
   if (!stringp(x_str) || !stringp(y_str) || !stringp(z_str)) {
      return 0;
   }
   return query_room(x, y, z);
}
string find_room_at_real_coord(int x, int y, int z) {
   class char_map_data room_map;
   class coord our;
   our = query_terrain_from_real_coord(x, y, z);
   if (!our) {
      return 0;
   }
   room_map = query_char_map(our->x, our->y);
   if (!room_map) {
      debug_printf("Unable to load room at %d %d (%d %d)\n", our->x, our->y, x, y);
      return 0;
   }
   if (room_map->type == AREA_OBSTACLE) {
      return 0;
   }
   return sprintf("%s:%d:%d:%d", base_name(this_object()), our->x, our->y, our->z);
}
int query_direction_distance(string dir) {
  switch (_direcs[dir][3]) {
   case X_DIFF :
      return _real_coords->xdiff;
   case Y_DIFF :
      return _real_coords->ydiff;
   case XY_DIFF :
      return _real_coords->xydiff;
   }
   return 0;
}
void dest_me() {
   class feature_data womble;
   string name;
   foreach (name, womble in _features) {
      if (womble->feature_ob) {
         womble->feature_ob->dest_me();
      }
   }
   destruct(this_object());
}

==================================================
FILE: room/inherit/terrain_map/inside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/basic_room";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   basic_room::create();
}
void init() {
   terrain_room::init();
   basic_room::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = basic_room::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = basic_room::query_dest_dir(thing);
   return terrain_room::query_dest_dir();
}
mixed stats() {
   return basic_room::stats() + terrain_room::stats();
}

==================================================
FILE: room/inherit/terrain_map/outside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   do_setup++;
   terrain_room::create();
   outside::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
     this_object()->reset();
   }
}
void init() {
   terrain_room::init();
   outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return outside::stats() + terrain_room::stats();
}
void dest_me() {
  terrain_room::dest_me();
  outside::dest_me();
}

==================================================
FILE: room/inherit/terrain_map/region_line.c
==================================================

inherit "/std/room/inherit/terrain_map/geometry";
class vertex {
   int x;
   int y;
}
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
private class vertex* _vertexes = ({ });
void add_vertex(int x, int y) {
   class vertex vertex;
   vertex = new(class vertex, x : x, y : y);
   _vertexes += ({ vertex });
}
mapping query_feature_desc_from(int x, int y, int z) {
   class vertex vert1;
   class vertex vert2;
   int i;
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float vm_x;
   float vm_y;
   float b;
   float dot1;
   float dot2;
   float min_distance;
   float distance;
   float xmod;
   float ymod;
   int xd;
   int yd;
   string direc;
   mapping dirs;
   class point p;
   dirs = ([ ]);
   for (i = 0; i < sizeof(_vertexes) - 1; i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      v1_x = to_float(vert1->x - vert2->x);
      v1_y = to_float(vert1->y - vert2->y);
      v2_x = to_float(x - vert2->x);
      v2_y = to_float(y - vert2->y);
      dot1 = v1_x * v2_x + v1_y * v2_y;
      if (dot1 <= 0.0) {
         distance = sqrt(pow(vert2->x - x, 2) + pow(vert2->y - y, 2));
         if ((!min_distance || distance < min_distance) && distance > 0.0001) {
            xmod = ((vert2->x - x) < 0) ? -0.5 : 0.5;
            ymod = ((vert2->y - y) < 0) ? -0.5 : 0.5;
            xd = to_int(xmod + to_float(vert2->x - x) / distance) + 1;
            yd = to_int(ymod + to_float(vert2->y - y) / distance) + 1;
            direc = _feature_direcs[yd][xd];
            min_distance = distance;
         }
      } else {
         dot2 = v1_x * v1_x + v1_y * v1_y;
         if (dot2 <= dot1) {
            distance = sqrt(pow(vert1->x - x, 2) + pow(vert1->y - y, 2));
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vert1->x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vert1->y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vert1->x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vert1->y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         } else {
            b = dot1 / dot2;
            vm_x = to_float(vert2->x) + b * v1_x;
            vm_y = to_float(vert2->y) + b * v1_y;
            distance = sqrt(pow(vm_x - x, 2) + pow(vm_y - y, 2));
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vm_x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vm_y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vm_x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vm_y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,0, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->x > x) {
            if (dirs["east"] && dirs["east"] > p->x) {
               dirs["east"] = p->x;
            }
         } else {
            if (dirs["west"] && dirs["west"] > p->x) {
               dirs["west"] = p->x;
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 0,1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->y > y) {
            if (dirs["north"] && dirs["north"] > p->y) {
               dirs["north"] = to_int(p->y);
            }
         } else {
            if (dirs["south"] && dirs["south"] > p->y) {
               dirs["south"] = to_int(p->y);
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->x > x) {
            if (dirs["northeast"] && dirs["northeast"] > p->x) {
               dirs["northeast"] = to_int(p->x);
            }
         } else {
            if (dirs["southwest"] && dirs["southwest"] > p->x) {
               dirs["southwest"] = to_int(p->x);
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,-1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->y > y) {
            if (dirs["northwest"] && dirs["northwest"] > p->y) {
               dirs["northwest"] = p->y;
            }
         } else {
            if (dirs["southeast"] && dirs["southeast"] > p->y) {
               dirs["southeast"] = p->y;
            }
         }
      }
   }
   dirs[direc] = to_int(min_distance);
   return dirs;
}
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class vertex vertex;
   class vertex vert1;
   class vertex vert2;
   int i;
   foreach (vertex in _vertexes) {
      if (vertex->x >= x1 && vertex->x <= x2 &&
          vertex->y >= y1 && vertex->y <= y2) {
         return 1;
      }
   }
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      if (distance_between_two_line_segments(x1, y1, x1, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y1, x2, y1,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x2, y1, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y2, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
   }
   return 0;
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: room/inherit/terrain_map/region_poly.c
==================================================

inherit "/std/room/inherit/terrain_map/geometry";
class vertex {
   int x;
   int y;
}
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
private class vertex* _vertexes = ({ });
private int _inside;
void set_inside(int flag) {
   _inside = flag;
}
void add_vertex(int x, int y) {
   class vertex vertex;
   vertex = new(class vertex, x : x, y : y);
   _vertexes += ({ vertex });
}
mapping query_feature_desc_from(int x, int y, int z, int only_shortest) {
   class vertex vert1;
   class vertex vert2;
   int i;
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float vm_x;
   float vm_y;
   float b;
   float dot1;
   float dot2;
   float min_distance;
   float distance;
   float xmod;
   float ymod;
   int xd;
   int yd;
   string direc;
   int counter;
   mapping dirs;
   class point p;
   dirs = ([ ]);
   if (_vertexes[0]->y == y && _vertexes[0]->x == x) {
      return 0;
   }
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      v1_x = to_float(vert1->x - vert2->x);
      v1_y = to_float(vert1->y - vert2->y);
      v2_x = to_float(x - vert2->x);
      v2_y = to_float(y - vert2->y);
      if (vert2->y == y && vert2->x == x) {
         return 0;
      }
      if (vert1->y == vert2->y) {
         if (y == vert1->y &&
             ((vert1->x <= x && x <= vert2->x) ||
              (vert1->x >= x && x >= vert2->x))) {
            return 0;
         }
      }
      if ((((vert1->y < y) && (y <= vert2->y)) ||
           ((vert2->y < y) && (y <= vert1->y))) &&
          (x < (vert2->x - vert1->x) * (y - vert1->y) / (vert2->y - vert1->y) + vert1->x)) {
         counter = !counter;
      }
      dot1 = v1_x * v2_x + v1_y * v2_y;
      if (dot1 <= 0.0) {
         distance = sqrt(pow(vert2->x - x, 2) + pow(vert2->y - y, 2));
         if (distance <= 0.0001) {
            return 0;
         }
         if ((!min_distance || distance < min_distance) && distance > 0.0001) {
            xmod = ((vert2->x - x) < 0) ? -0.5 : 0.5;
            ymod = ((vert2->y - y) < 0) ? -0.5 : 0.5;
            xd = to_int(xmod + to_float(vert2->x - x) / distance) + 1;
            yd = to_int(ymod + to_float(vert2->y - y) / distance) + 1;
            direc = _feature_direcs[yd][xd];
            min_distance = distance;
         }
      } else {
         dot2 = v1_x * v1_x + v1_y * v1_y;
         if (dot2 <= dot1) {
            distance = sqrt(pow(vert1->x - x, 2) + pow(vert1->y - y, 2));
            if (distance <= 0.0001) {
               return 0;
            }
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vert1->x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vert1->y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vert1->x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vert1->y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         } else {
            b = dot1 / dot2;
            vm_x = to_float(vert2->x) + b * v1_x;
            vm_y = to_float(vert2->y) + b * v1_y;
            distance = sqrt(pow(vm_x - x, 2) + pow(vm_y - y, 2));
            if (distance <= 0.0001) {
               return 0;
            }
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vm_x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vm_y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vm_x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vm_y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         }
      }
      if (!only_shortest) {
         p = intersection_of_line_and_segment(0,0, 1,0, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->x > x) {
               if (dirs["east"] && dirs["east"] > p->x) {
                  dirs["east"] = p->x;
               }
            } else {
               if (dirs["west"] && dirs["west"] > p->x) {
                  dirs["west"] = p->x;
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 0,1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->y > y) {
               if (dirs["north"] && dirs["north"] > p->y) {
                  dirs["north"] = to_int(p->y);
               }
            } else {
               if (dirs["south"] && dirs["south"] > p->y) {
                  dirs["south"] = to_int(p->y);
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 1,1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->x > x) {
               if (dirs["northeast"] && dirs["northeast"] > p->x) {
                  dirs["northeast"] = to_int(p->x);
               }
            } else {
               if (dirs["southwest"] && dirs["southwest"] > p->x) {
                  dirs["southwest"] = to_int(p->x);
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 1,-1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->y > y) {
               if (dirs["northwest"] && dirs["northwest"] > p->y) {
                  dirs["northwest"] = p->y;
               }
            } else {
               if (dirs["southeast"] && dirs["southeast"] > p->y) {
                  dirs["southeast"] = p->y;
               }
            }
         }
      }
   }
   if (counter != _inside) {
      return 0;
   }
   dirs[direc] = to_int(min_distance);
   return dirs;
}
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class vertex vertex;
   class vertex vert1;
   class vertex vert2;
   int i;
   foreach (vertex in _vertexes) {
      if (vertex->x >= x1 && vertex->x <= x2 &&
          vertex->y >= y1 && vertex->y <= y2) {
         return 1;
      }
   }
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      if (distance_between_two_line_segments(x1, y1, x1, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y1, x2, y1,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x2, y1, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y2, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
   }
   return 0;
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: room/inherit/terrain_map/region_rect.c
==================================================

inherit "/std/room/inherit/terrain_map/geometry";
class feature_pos {
   int xstart;
   int ystart;
   int width;
   int height;
}
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
private class feature_pos* _positions = ({ });
void add_feature_position(int x, int y, int width, int height) {
   class feature_pos pos;
   pos = new(class feature_pos, xstart : x, ystart : y,
                                width : width, height : height);
   _positions += ({ pos });
}
mapping query_feature_desc_from(int x, int y, int z) {
   int h;
   int v;
   int width;
   int height;
   float distance;
   float min_distance;
   string direc;
   class feature_pos pos;
   float xmod;
   float ymod;
   int xd;
   int yd;
   foreach (pos in _positions) {
      h = pos->xstart;
      v = pos->ystart;
      width = pos->width;
      height = pos->height;
      if (x >= (h + width)) {
         h = h + width - 1;
      } else if (x >= h) {
         h = x;
      }
      if (y >= (v + height)) {
         v = v + height - 1;
      } else if (y >= v) {
         v = y;
      }
      distance = sqrt(pow(x - h, 2) + pow(y - v, 2));
      if (distance > 0.0000001 && (distance < min_distance || !min_distance)) {
         xmod = ((h - x) < 0) ? -0.5 : 0.5;
         ymod = ((v - y) < 0) ? -0.5 : 0.5;
         xd = to_int(xmod + to_float(h - x) / distance) + 1;
         yd = to_int(ymod + to_float(v - y) / distance) + 1;
         direc = _feature_direcs[yd][xd];
         min_distance = distance;
      }
   }
   if (!direc) {
      return ([ ]);
   }
   return ([ direc : to_int(min_distance) ]);
}
void dest_me() {
   destruct(this_object());
}
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class feature_pos position;
   int height;
   int width;
   foreach (position in _positions) {
      height = position->height;
      width = position->width;
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }
   }
   return 0;
}

==================================================
FILE: room/inherit/terrain_map/simple_feature.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_FEATURE_BASE;
private string _base_desc;
private int _very_close_distance;
private int _distance_multiplier = 1;
void set_very_close_distance(int close) {
   _very_close_distance = close;
}
string query_base_description() {
   return _base_desc;
}
void set_base_description(string desc) {
   _base_desc = desc;
}
void set_distance_multiplier(int mult) {
   _distance_multiplier = mult;
}
string calc_feature_desc(mapping direcs, int night, int visibility) {
   string direc;
   int dist;
   int new_dist;
   string* bits;
   bits = ({ });
   if(visibility < 1 && visibility != -1)
     visibility = 1;
   foreach (direc, dist in direcs) {
      dist += query_range_offset() ;
      new_dist = dist * 100 / visibility;
      if (visibility == -1 ||
          (new_dist < query_max_range() && dist > query_min_range())) {
         if (dist < _very_close_distance) {
            bits += ({ "very close to the " + direc });
         } else {
            bits += ({ query_distance_str(dist * _distance_multiplier) + " to the " + direc });
         }
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}
string calc_map_feature_desc(mapping direcs, int fudge) {
   string direc;
   int dist;
   string* bits;
   bits = ({ });
   foreach (direc, dist in direcs) {
      dist += query_range_offset();
      if (dist < _very_close_distance * 5) {
        bits += ({ "very close to the " + direc });
      } else {
        bits += ({ ({"approximately ", "about ", "roughly "})[random(3)] +
                     query_distance_str(dist * _distance_multiplier) +
                     " to the " + direc });
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}

==================================================
FILE: room/inherit/terrain_map/terrain_room.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_FACTORY_BASE;
#define BLOCKING_FLAG 2
#define INSTALLED_FLAG 1
private nosave int     _x_coord = -1;
private nosave int     _y_coord = -1;
private nosave int     _z_coord = -1;
private nosave int     _flag = 0;
private nosave string  _extra_long = "";
private nosave object  _map_handler;
private nosave mapping _dist_features = ([ ]);
private nosave mapping _features = ([ ]);
private nosave string  _outside_types;
private nosave string  _random_desc = 0;
private nosave object  _terrain_chatter = 0;
private nosave string* _variable_exits;
private nosave mapping _default_exits;
private nosave string  _terrain_handler;
private nosave string  _terrain_char;
varargs int add_property(string var, mixed val, int tim);
string  query_feature_item_desc(string title);
string  query_handler_path();
varargs void terrain_chat( mixed *args, object chatobj );
int do_outside_chats();
void add_zone(string zone);
void add_extra_look(object ob);
int remove_item(string word);
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int* query_co_ord();
int query_visibility();
string long(string str, int dark);
string query_terrain_handler();
class feature {
   mapping direcs;
   mixed items;
   int sentance;
   int index;
   int visible;
}
void create() {
   _variable_exits = ({ });
   _default_exits = ([ ]);
   this_object()->add_help_file("terrain_room");
   ::create();
}
string long_test(string str, int dark) {
   string ret;
   string map;
   string* map_lines;
   ret = long(str, dark);
   map = query_terrain_handler()->query_player_map_template(_x_coord,
             _y_coord, _z_coord, query_visibility(), 9);
   map_lines = map(explode(map, "\n"), (: $1 + "   " :));
   ret = "$COLUMN$12=" + implode(map_lines, "\n") + "$COLUMN$" +
         ret;
   return ret;
}
int hash(int mod) {
   mixed* my_coord;
   int x;
   int y;
   int z;
   int grid;
   int val;
   string str;
   my_coord = query_co_ord();
   if (!my_coord) {
      return 0;
   }
   grid = TERRAIN_MAP_GRID_SIZE / 10;
   x = (my_coord[0]) / grid;
   y = (my_coord[1]) / grid;
   z = (my_coord[2]) / grid;
   str = "" + x + ":" + y + ":" + z;
   val = crc32(str) % mod;
   if (val < 0) {
      return - val;
   }
   return val;
}
int hash_time(int mod, int period) {
   mixed* my_coord;
   int x;
   int y;
   int z;
   int grid;
   int val;
   string str;
   my_coord = query_co_ord();
   if (!my_coord) {
      return 0;
   }
   grid = TERRAIN_MAP_GRID_SIZE / 10;
   x = (my_coord[0]) / grid;
   y = (my_coord[1]) / grid;
   z = (my_coord[2]) / grid;
   str = x + ":" + y + ":" + z + ":" + (time() /period);
   val = crc32(str) % mod;
   if (val < 0) {
      return - val;
   }
   return val;
}
string query_terrain_handler() {
   return _terrain_handler;
}
void set_terrain_handler(string handler) {
   _terrain_handler = handler;
}
mixed *query_terrain_coords() { return ({ _x_coord, _y_coord, _z_coord }); }
void create_terrain_room()
{
   _x_coord = -1;
   _y_coord = -1;
   _z_coord = -1;
   add_property("terrain_map", 1);
   add_extra_look(this_object());
   if (do_outside_chats())
      terrain_chat(({ 60, 120, ({ "#do_a_feature_chat",
                             "#do_an_outside_chat" }) }) );
}
void terrain_setup()
{
}
void set_terrain_coords(int x, int y, int z)
{
   _x_coord = x;
   _y_coord = y;
   _z_coord = z;
}
object query_map_handler()
{
   return load_object(query_terrain_handler());
}
void reset_handler()
{
   if (query_map_handler())
      query_map_handler()->reset_handler();
}
void receive_message(string mess_class, string message, string title)
{
   class    feature feature;
   if (mess_class == "feature") {
      feature = _features[title];
      if (!feature) {
         return;
      }
   } else if (mess_class == "direction") {
   }
   tell_room(this_object(), message);
}
void do_a_feature_chat()
{
   string   *chats = ({ });
   string   feature_chat;
   string   title;
   class  feature feature;
   if ((_x_coord < 0) || (_y_coord < 0)) {
      return;
   }
   foreach(title, feature in _features) {
      if (feature_chat) {
         chats += ({ feature_chat });
      }
   }
   if (sizeof(chats)) {
      tell_room(this_object(), chats[random(sizeof(chats))] + "\n");
   }
}
void do_an_outside_chat()
{
   string chat = query_map_handler()->get_an_outside_chat(_outside_types);
   if (chat && strlen(chat)) {
      tell_room(this_object(), chat + "\n");
   }
}
int can_view_adjacent_desc(string char, string key_here, string path,
                           int z, string direc) {
   return char != key_here;
}
int can_view_feature(string name)
{
   return 1;
}
int can_view_feature_from(string name, string direc, int distance)
{
   return 1;
}
int can_exit_to(string type, string direc, string base_path)
{
   return 1;
}
int can_enter_from(string type, string direc, string base_path)
{
   return 1;
}
int can_move_between(string my_type, string direc,
                     string first_type, string second_type,
                     string new_base_path)
{
   return 1;
}
string query_enter_exit_direction(string key, string key_here,
                                  string direc, object room, string base_path) {
   return 0;
}
int do_outside_chats()
{
   return 1;
}
varargs void terrain_chat( mixed *args, object chatobj ) {
   if (!args)  {
      return;
   }
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
  if ( _terrain_chatter ) {
    _terrain_chatter->setup_chatter( this_object(), args );
    return;
  }
  if (objectp(chatobj)) {
    _terrain_chatter = chatobj;
    log_file("CHATTER", "%s cloned set terrain chatter: %O\n",
             file_name(this_object()), chatobj);
  } else {
    _terrain_chatter = clone_object( CHATTER_OBJECT );
    log_file("CHATTER", "%s cloned terrain chatter: %O\n",
             file_name(this_object()), _terrain_chatter);
  }
  _terrain_chatter->setup_chatter( this_object(), args );
}
void add_random_desc(string desc)
{
   if (!_random_desc) {
      _random_desc = "";
   }
   _random_desc += desc + " ";
}
void terrain_add_zone(string zone)
{
   add_zone(zone);
   query_map_handler()->add_room_to_zone(this_object(), zone);
}
string query_dest_coordinate_string(int x, int y, int z,
                                    string direc, string key) {
   return ":" + x + ":" + y + ":" + z;
}
varargs mixed *query_to_same(string type, string to_direc, string from_direc, string path_to) {
   return 0;
}
varargs mixed *query_to_other(string type, string to_direc, string from_direc, string path_to) {
   return 0;
}
varargs mixed *query_from_other(string type, string to_direc, string from_direc, string path_from) {
   return 0;
}
mixed *get_to_same(string from, string to, string type, string path_to)
{
   mixed *result = query_to_same(type, to, from);
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   return 0;
}
mixed *get_to_other(string from, string to, string type, string path_to)
{
   mixed *result = query_to_other(type, to, from);
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   return 0;
}
mixed *get_from_other(string from, string to, string type, string path_from)
{
   mixed *result = query_from_other(type, to, from);
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   return 0;
}
void set_extra_long(string extra)
{
   _extra_long = extra;
}
void set_outside_types(string types)
{
   _outside_types = types;
}
string query_my_real_file_name() {
   return __FILE__;
}
string extra_look() {
   string   result = _extra_long;
   string   title;
   string*   tmp;
   class  feature feature;
   int new_line;
   string* descs;
   int visibility;
   new_line = query_map_handler()->query_newline_mode();
   descs = ({ });
   visibility = query_visibility();
   foreach (title, feature in _features) {
      tmp = query_map_handler()->query_feature_desc(title,
                                          feature->direcs, visibility);
      if (sizeof(tmp)) {
         feature->visible = 1;
         descs += tmp;
      }
   }
   foreach (title, feature in _dist_features) {
      tmp = query_map_handler()->query_distant_feature_desc(title,
                                        feature, visibility);
      if (sizeof(tmp)) {
         descs += tmp;
      }
   }
   if (sizeof(descs)) {
      result += "  " + capitalize(query_multiple_short(descs)) + ".";
   }
   if (_random_desc) {
      result = result + _random_desc;
   }
   if (new_line) {
      return result;
   } else {
      return result + "\n";
   }
}
void add_feature(string title, mapping bits, mixed items, int sentance)
{
   _features[title] = new(class feature,
                          items : items, direcs : bits);
   if (items) {
      add_item(items, (: query_feature_item_desc($(title)) :));
   }
}
void add_distant_feature(string title, mapping bits) {
   _dist_features[title] = bits;
}
void remove_feature(string title)
{
   class feature  feature = _features[title];
   mixed    items;
   if (!feature) {
      return;
   }
   map_delete(_features, title);
   items = feature->items;
   if (stringp(items)) {
      remove_item(items);
   } else {
      remove_item(items[0]);
   }
}
string query_feature_item_desc(string title)
{
   if (_features[title]->visible) {
      return query_map_handler()->query_feature_item_desc(title);
   }
   return 0;
}
mapping query_features() { return _features; }
int query_installed() { return _flag & INSTALLED_FLAG; }
void set_installed() { _flag |= INSTALLED_FLAG; }
void set_terrain_map_block(int blocking) {
   if (blocking) {
      _flag |= BLOCKING_FLAG;
   } else {
      _flag &= ~BLOCKING_FLAG;
   }
}
int query_terrain_map_block() {
   return _flag & BLOCKING_FLAG;
}
void set_terrain_map_character(string terr) {
   _terrain_char = terr;
}
string query_terrain_map_character() {
   return _terrain_char;
}
string query_cloning_info()
{
  return file_name(this_object());
}
object create_virtual_object(string x_str, string y_str)
{
   int x = to_int(x_str);
   int y = to_int(y_str);
   return query_map_handler()->load_room_at(x, y);
}
void add_variable_exit(string exit) {
   _variable_exits += ({ exit });
}
void add_default_exit(string exit, string location) {
   _default_exits[exit] = location;
}
mapping query_default_exits() {
   return _default_exits;
}
string query_terrain_map_walk_exit() {
   return TERRAIN_MAP_WALK_EXIT;
}
string query_terrain_map_journey_exit() {
   return TERRAIN_MAP_JOURNEY_EXIT;
}
string query_room_path(int x, int y, int z) {
   return sprintf("%s:%d:%d:%d", query_terrain_handler(), x, y, z);
}
string query_direction_distance_str(int num, string dir) {
   int dist;
   string dist_mess;
   dist = query_map_handler()->query_direction_distance(dir);
   switch (dist) {
   case 0..2 :
      if (dist > 1) {
         dist_mess = query_num(dist) + " foot section";
      } else {
         dist_mess = "foot";
      }
      break;
   case 3..TERRAIN_MAP_ONE_MILE / 2 - 1 :
      dist /= 3;
      if (dist > 1) {
         dist_mess = query_num(dist) + " yard section";
      } else {
         dist_mess = "yard";
      }
      break;
   case TERRAIN_MAP_ONE_MILE / 2..TERRAIN_MAP_ONE_MILE - 1 :
      dist /= TERRAIN_MAP_ONE_MILE / 2;
      if (dist > 1) {
         dist_mess = query_num(dist) + " miles section";
      } else {
         dist_mess = "mile";
      }
      break;
   default:
      dist /= TERRAIN_MAP_ONE_MILE;
      if (dist > 1) {
         dist_mess = query_num(dist) + " miles section";
      } else {
         dist_mess = "mile";
      }
      break;
   }
   switch(num) {
   case 0:
      return dist_mess + " " + dir;
   case 1:
      return query_num(num) + " " + dist_mess + " " +dir;
   default:
      return query_num(num) + " " + dist_mess + "s " + dir;
   }
}
mixed* query_dest_other(string exit, mixed* data) {
   mixed* bing;
   string cur;
   string dir;
   int num;
   string* bits;
   int dist;
   if(!stringp(exit) || !_default_exits) {
     return data;
   }
   if (_default_exits[exit]) {
      if (this_player() &&
          this_player()->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY) &&
          member_array(query_terrain_map_journey_exit() + exit, _variable_exits) != -1) {
         exit = query_terrain_map_journey_exit() + exit;
      } else {
         data[ROOM_DEST] = _default_exits[exit];
         return data;
      }
   }
   if (member_array(exit, _variable_exits) != -1) {
      bing = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, exit[strlen(query_terrain_map_journey_exit())..]);
      if (bing) {
         if (data[ROOM_DEST] != bing[0]) {
            data[ROOM_DEST] = bing[0];
            bits = ({ });
            foreach (dir in bing[1..]) {
               if (dir == cur) {
                  num++;
               } else {
                  if (cur) {
                     bits += ({ query_direction_distance_str(num, cur) });
                  }
                  cur = dir;
                  num = 1;
               }
            }
            dist = query_map_handler()->query_direction_distance(dir);
            bits += ({ query_direction_distance_str(num, dir) });
            if (sizeof(bits) > 1) {
               data[ROOM_MESS] = "You arrive after having journeyed " +
                                 implode(bits[0..<2], ", ") +
                                 " and " + bits[<1] +
                                 ".\n";
            } else {
               data[ROOM_MESS] = "You arrive after having journeyed " +
                                 bits[0] +
                                 ".\n";
            }
            if (!arrayp(data[ROOM_ENTER]) ||
                !data[ROOM_ENTER][0]) {
               data[ROOM_ENTER] = "$N journey$s in from " +
                        ROOM_HANDLER->query_opposite_direction(bing[<1]) + ".\n";
            }
            if (!data[ROOM_EXIT]) {
               data[ROOM_EXIT] = "$N journey$s to the " + bing[1] + ".\n";
            }
         }
      }
   }
   return data;
}
mixed* query_dest_dir(mixed* data) {
   int i;
   int jump;
   mixed* bits;
   if (this_player() &&
       this_player()->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)) {
      jump = 1;
   }
   if (sizeof(_variable_exits)) {
      for (i = 0; i < sizeof(data); i += 2) {
         if (_default_exits[data[i]]) {
            if (jump) {
               bits = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, data[i]);
               if (bits) {
                  data[i+1] = bits[0];
               }
            } else {
               data[i+1] = _default_exits[data[i]];
            }
         } else if (member_array(data[i], _variable_exits) != -1) {
            bits = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, data[i][strlen(query_terrain_map_journey_exit())..]);
            if (bits) {
               data[i+1] = bits[0];
            }
         }
      }
   }
   return data;
}
int do_map() {
   string map;
   map = query_map_handler()->query_debug_map(_x_coord, _y_coord, 13, _x_coord, _y_coord);
   write(map);
   add_succeeded_mess("");
   return 1;
}
int do_map_terrain() {
   string map;
   map = query_map_handler()->query_debug_map(20, 20, 40, _x_coord, _y_coord);
   write(map);
   add_succeeded_mess("");
   return 1;
}
void init()
{
   tell_creator(this_player(), "Coords: (%d, %d, %d)\n", _x_coord, _y_coord, _z_coord);
   if (this_player()->query_creator()) {
      add_command("cremap", "", (: do_map :));
      add_command("cremap", "all", (: do_map_terrain :));
   }
}
mixed stats() {
   return ::stats() +
          ({ ({ "file", query_my_real_file_name() }),
             ({ "blocking", query_terrain_map_block() }) });
}
void dest_me() {
  if(_terrain_chatter) {
    log_file("CHATTER", "%s dested terrain chatter: %O\n",
             file_name(this_object()), _terrain_chatter);
    _terrain_chatter->dest_me();
  }
}

==================================================
FILE: room/inherit/terrain_map/water_inside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/water_inside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_inside::create();
}
void init() {
   terrain_room::init();
   water_inside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = water_inside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = water_inside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return water_inside::stats() + terrain_room::stats();
}
string query_terrain_map_walk_exit() {
   return "swim ";
}
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}

==================================================
FILE: room/inherit/terrain_map/water_outside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/water_outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_outside::create();
}
void init() {
   terrain_room::init();
   water_outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = water_outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = water_outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return water_outside::stats() + terrain_room::stats();
}
string query_terrain_map_walk_exit() {
   return "swim ";
}
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}
string query_enter_exit_direction(string key, string key_here, string direct,
                                  object room, string base_path) {
   if (!room->query_water()) {
      return "wade " + direct;
   }
   return 0;
}
int can_move_between(string my_type, string direc,
                     string first_type, string second_type, string new_base_path)
{
   return first_type->query_water() && second_type->query_water() &&
          new_base_path->query_water() ||
          (!new_base_path->query_water() &&
           (!first_type->query_water() || !second_type->query_water()));
}

==================================================
FILE: room/inherit/carriage/carriage.c
==================================================

#include <room/carriage.h>
#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45
inherit "/std/room/basic_room";
private class route_details _route_info;
private string _carriage_name;
private string _exit_name;
private int _current_stop;
private int _next_stop;
private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;
private string _n_name;
private string _p_name;
int do_ring();
string query_environ_long();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );
    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);
   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );
   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );
}
object create_carriage_driver() {
   return 0;
}
string query_carriage_name() { return _carriage_name; }
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }
object query_outside() { return _outside; }
class route_details query_route_map() { return _route_info; }
int *query_stop_info() { return ({ _current_stop, _next_stop }); }
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{
    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;
    _current_stop = 0;
    _next_stop = 1;
  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }
  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }
  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }
  return 1;
}
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;
   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);
   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);
   _outside = load_object(path);
   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }
   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }
   if (!_fake_carriage) {
     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }
   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");
   add_exit("leave carriage", path, "corridor");
   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));
   add_alias("out", "leave carriage");
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n"
      "The driver opens the carriage door.\n");
   if(objectp(_car_driver)) {
     _car_driver->do_command("leave carriage");
     if( environment(_car_driver) != _outside ) {
       _car_driver->move(_outside, "The " + _carriage_name +
                         " carriage driver hops out of the carriage.",
                         "The driver opens the door and leaps out.");
     }
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name
               + ".\n");
   }
   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";
   _outside->add_exit(_exit_name, this_object(), "corridor");
   name_parts = explode(lower_case(_carriage_name), " ");
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name);
      _outside->add_alias("enter " + np + "s carriage", _exit_name);
   }
   _outside->add_alias("enter carriage", _exit_name);
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop, $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );
      linked_rooms = ( _outside->query_linker() )->query_rooms()
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }
   stop_room_chats();
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
}
int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
}
void give_warning(string this_stop_name, string next_stop_name) {
  if(objectp(_outside) && objectp(_car_driver) &&
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave for " +
                             next_stop_name + ".\n");
  }
}
void move_on() {
  string np;
  string* name_parts;
  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->do_command("enter " + lower_case(_carriage_name) +
                            " carriage");
    if( environment(_car_driver) != this_object() ) {
      debug_printf("Driver: Tried to \"enter " +
                   lower_case(_carriage_name) + " carriage\" and "
                   "failed.");
      _car_driver->move(this_object(), "The driver hops back in to the "
                        "carriage and gets ready to drive again.",
                        "The " + _carriage_name + " driver hops back "
                        "onto " + _car_driver->query_possessive() +
                        " carriage.");
    }
    _car_driver->next_stop_from_carriage(_n_name);
    tell_room(this_object(), "The carriage starts moving again.\n");
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }
  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");
  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }
  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  _outside = 0;
  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );
  this_object()->check_chat();
  call_out("make_stop", 30 );
}
void dest_me() {
  string path;
  object ob;
  string np;
  string* name_parts;
  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }
  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  ::dest_me();
}
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
}
mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}
int do_ring() {
  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));
    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->bell_ring(_n_name);
    } else {
      tell_room(this_object(), "Nothing much happens.\n");
    }
    return 1;
  }
  call_out("move_on",2);
  if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
    _car_driver->do_command(":wakes with a start.");
  }
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;
}
string query_environ_long() {
  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to "
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
}

==================================================
FILE: room/inherit/carriage/carriage_note.c
==================================================

inherit "/std/object";
void setup_route(string* a, string b, string c, string d);
void setup() {
  set_name( "note" );
  set_short(  "Test note" ) ;
  set_long( "This note is probably broken, please contact a "
    "creator. :)\n" );
  reset_get();
  add_alias( "table" );
}
void setup_route(string* stops, string colour, string route, string language) {
  string prettystops = "";
  int i;
  set_short(route + " table");
  add_adjective(map(explode(route, " "), (: lower_case($1) :)));
  add_adjective(colour);
  add_alias("table");
  add_alias("cardboard");
  add_adjective(({"piece", "of", colour}));
  set_long("This is the table for the " + route + " route.  It is "
    "printed on a piece of sturdy " + colour + " cardboard, and stuck "
    "firmly to the pole.\n");
  for(i = 0; i < sizeof(stops) - 1; i++) {
    prettystops += capitalize(stops[i]) + "\n";
  }
  prettystops += "and back to " + stops[sizeof(stops) - 1];
  add_read_mess("\nThe " + route + " route:\n" +
    prettystops + ".\n",
    "bold letters", language);
}

==================================================
FILE: room/inherit/carriage/carriage_pole.c
==================================================

inherit "/std/object";
void setup_route(string *ss, string c, string r);
string *notes = ({});
void setup() {
  set_name( "pole" );
  set_short("wooden pole");
  add_adjective( "wooden" );
  set_long("This is a wooden pole.  It's fairly unexciting.\n");
  set_weight( 10000 );
  add_property( "there", ( ({"casually placed in a corner",
                             "here",
                             "standing on the side of the road",
                             "trying to be noticed"})
                          [random(4)]));
  add_extra_look(this_object());
  reset_get();
}
void setup_route( string *stops, string colour, string route) {
  object note;
  string language;
  string pathofhere;
  if(member_array(colour + " note", notes) != -1) {
    return;
  }
  notes += ({ colour + " note" });
  pathofhere = file_name(environment(this_object()));
  if(strsrch(pathofhere, "/d/am/") != -1)
    language = "morporkian";
  if(strsrch(pathofhere, "/d/cwc/") != -1)
    language = "agatean";
  if(strsrch(pathofhere, "/d/klatch/") != -1)
    language = "djelian";
  if(strsrch(pathofhere, "/d/ram/") != -1)
    language = "morporkian";
  if(strsrch(pathofhere, "/d/ram/Uberwald/") != -1)
    language = "uberwaldean";
  if(strsrch(pathofhere, "/d/sur/") != -1)
    language = "morporkian";
  note = clone_object(__DIR__ + "carriage_note");
  note->setup_route(stops, colour, route, language);
  environment(this_object())->add_hidden_object(note);
  environment(this_object())->add_property("carriage pole",
    this_object());
  if(sizeof(notes)) {
    set_short("wooden pole with " + (query_multiple_short(map( notes,
    (: add_a($1) :)))) + " attached to it") ;
  }
}
string extra_look() {
  if(sizeof(notes)) {
    return capitalize((query_multiple_short(map( notes, (: add_a($1) :)))) +
      ((sizeof(notes) > 1) ? " are" : " is") + " attached to the pole.\n") ;
  }
  return "";
}

==================================================
FILE: room/inherit/carriage/handler.c
==================================================

#include <room.h>
#include <data.h>
#include <room/carriage.h>
#define CARRIAGE ITEMS "carriage"
private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;
private void load_data();
private void map_carriages();
private void save_file() {
   unguarded((: save_object(_save_file) :));
}
void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}
mapping query_route_details() { return _routedetails; }
mapping query_route_actual() { return _routesactual; }
string* query_route_names() { return keys(_routesactual); }
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
}
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
}
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
}
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
}
object query_carriage_on_route(string route) {
   return _carriages[route];
}
private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;
   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }
   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
}
private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;
   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }
   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];
   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }
   _routesactual[data["name"]] = info;
   save_file();
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;
   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
}
private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void load_data() {
   scan_for_new_data();
}
private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;
  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }
    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }
    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("carriage pole")) {
          pole = room->query_property("carriage pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j],
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }
    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else {
       new_rods = rods;
    }
    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
}
mixed* stats() {
   mixed* ret;
   string route;
   object ob;
   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
}

==================================================
FILE: room/inherit/carriage/testcar.c
==================================================

#include <room/carriage.h>
#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45
inherit "/std/room/basic_room";
private class route_details _route_info;
private string _carriage_name;
private string _exit_name;
private int _current_stop;
private int _next_stop;
private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;
private string _n_name;
private string _p_name;
int do_ring();
string query_environ_long();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );
    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);
   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );
   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );
}
object create_carriage_driver() {
   return 0;
}
string query_carriage_name() { return _carriage_name; }
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }
object query_outside() { return _outside; }
class route_details query_route_map() { return _route_info; }
int *query_stop_info() { return ({ _current_stop, _next_stop }); }
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{
    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;
    _current_stop = 0;
    _next_stop = 1;
  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }
  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }
  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }
  return 1;
}
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;
   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);
   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);
   _outside = load_object(path);
   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }
   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }
   if (!_fake_carriage) {
     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }
   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");
   add_exit("leave carriage", path, "corridor");
   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));
   add_alias("out", "leave carriage");
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n"
      "The driver opens the carriage door.\n");
   if(objectp(_car_driver)) {
     _car_driver->move(_outside, "The " + _carriage_name + " carriage "
       "driver hops out of the carriage.", "The driver opens the door "
       "and leaps out.");
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name + ".\n");
   }
   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";
   _outside->add_exit(_exit_name, this_object(), "corridor");
   name_parts = explode(lower_case(_carriage_name), " ");
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name);
      _outside->add_alias("enter " + np + "s carriage", _exit_name);
   }
   _outside->add_alias("enter carriage", _exit_name);
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );
      linked_rooms = ( _outside->query_linker() )->query_rooms()
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }
   stop_room_chats();
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
}
int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
}
void give_warning(string this_stop_name, string next_stop_name) {
  if(objectp(_outside) && objectp(_car_driver) &&
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave to " +
                             next_stop_name + ".\n");
  }
}
void move_on() {
  string* name_parts;
  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->move(this_object(), "The driver hops back in to the carriage "
      "and gets ready to drive again.", "The " + _carriage_name +
      " driver hops back onto " + _car_driver->query_possessive() +
      " carriage.");
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }
  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");
  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }
  if (objectp(_car_driver)) {
     _car_driver->next_stop_from_carriage(_n_name);
  }
  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  _outside = 0;
  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );
  this_object()->check_chat();
  call_out("make_stop", 30 );
}
void dest_me() {
  string path;
  object ob;
  string* name_parts;
  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }
  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  ::dest_me();
}
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
}
mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}
int do_ring() {
  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));
    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->do_command("scowl");
      _car_driver->do_command("'We won't reach " + _n_name + " any faster just "
        "cause you ring that danged bell!");
    }
    return 1;
  }
  call_out("move_on",2);
  _car_driver->do_command(":wakes with a start.");
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;
}
string query_environ_long() {
  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to "
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
}

==================================================
FILE: room/inherit/carriage/testhandler.c
==================================================

#include <room.h>
#include <data.h>
#include <room/carriage.h>
#define CARRIAGE ITEMS "carriage"
private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;
private void load_data();
private void map_carriages();
private void save_file() {
   unguarded((: save_object(_save_file) :));
}
void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}
mapping query_route_details() { return _routedetails; }
mapping query_route_actual() { return _routesactual; }
string* query_route_names() { return keys(_routesactual); }
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
}
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
}
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
}
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
}
object query_carriage_on_route(string route) {
   return _carriages[route];
}
private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;
   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }
   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
}
private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;
   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }
   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];
   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }
   _routesactual[data["name"]] = info;
   save_file();
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;
   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
}
private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void load_data() {
   scan_for_new_data();
}
private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;
  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }
    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }
    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("test pole")) {
          pole = room->query_property("test pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j],
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }
    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else {
       new_rods = rods;
    }
    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
}
mixed* stats() {
   mixed* ret;
   string route;
   object ob;
   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
}

==================================================
FILE: room/controller/club_room_controller.c
==================================================

inherit "/std/basic/setup";
#include <clubs.h>
#include <room/club_room.h>
private nosave string _save_directory;
private mapping _options;
private string _club;
private mapping _ownership;
private nosave mapping _default_ownership;
private int _board_contained;
class ownership {
   string name;
   int type;
   int control_type;
}
private void setup_discussions();
void save_me();
void load_me();
void create() {
   _options = ([ ]);
   _ownership = ([ ]);
   _default_ownership = ([ ]);
   do_setup();
   call_out((: load_me() :), 0);
}
private void add_board_to(string club) {
   int board_count;
   board_count = CLUB_HANDLER->query_elected_option(club,
                                                    CLUB_ROOM_BOARD_COUNT);
   board_count++;
   if (board_count == 1) {
      CLUB_HANDLER->create_club_board(club);
   }
   CLUB_HANDLER->set_elected_option(club,
                                    CLUB_ROOM_BOARD_COUNT,
                                    board_count);
}
private void remove_board_from(string club) {
   int board_count;
   board_count = CLUB_HANDLER->query_elected_option(club,
                                                    CLUB_ROOM_BOARD_COUNT);
   board_count--;
   if (board_count == 0 &&
       CLUB_HANDLER->query_club_board(club)) {
      CLUB_HANDLER->remove_club_board(club);
   }
   if (board_count <= 0) {
      CLUB_HANDLER->remove_elected_option(club,
                                          CLUB_ROOM_BOARD_COUNT);
   } else {
      CLUB_HANDLER->set_elected_option(club,
                                       CLUB_ROOM_BOARD_COUNT,
                                       board_count);
   }
}
int set_club(string club) {
   class ownership bing;
   class ownership fluff;
   string name;
   if (!CLUB_HANDLER->is_elected_club(club)) {
      return 0;
   }
   if (_club &&
       CLUB_HANDLER->query_club_name(club) ==
       CLUB_HANDLER->query_club_name(_club)) {
      return 1;
   }
   if (_board_contained) {
      if (_club) {
         remove_board_from(_club);
      }
      add_board_to(club);
   }
   _club = club;
   foreach (name, bing in _ownership) {
      if (bing->control_type != CLUB_ROOM_CONTROLLED_FIXED) {
         if (_default_ownership[name]) {
            fluff = _default_ownership[name];
            bing->type = fluff->type;
            if (functionp(fluff->name)) {
               bing->name = evaluate(fluff->name,
                                     name,
                                     club);
            } else {
               bing->name = fluff->name;
            }
         }
      }
   }
   call_out((: setup_discussions :), 1);
   save_me();
   return 1;
}
string query_club() {
   return _club;
}
void set_board_associated(int board_associated) {
   board_associated = board_associated != 0;
   if (_club) {
      if (_board_contained != board_associated) {
         if (board_associated) {
            add_board_to(_club);
         } else {
            remove_board_from(_club);
         }
      }
   }
   _board_contained = board_associated;
}
int query_board_associated() {
   return _board_contained;
}
int is_option(string name) {
   return !undefinedp(_options[name]);
}
mixed query_option(string name) {
   return _options[name];
}
int remove_option(string name) {
   if (is_option(name)) {
      map_delete(_options, name);
      return 1;
   }
   return 0;
}
int set_option(string name, mixed value) {
   _options[name] = value;
}
int add_controlled_ownership(string name,
                             int type,
                             int default_type,
                             mixed default_name) {
   class ownership bing;
   if (!_ownership[name]) {
      bing = new(class ownership);
      bing->name = CLUB_UNKNOWN_MEMBER;
      bing->type = CLUB_ROOM_OWNED_PERSON;
      bing->control_type = type;
      _ownership[name] = bing;
      bing = new(class ownership);
      bing->name = default_name;
      bing->type = default_type;
      bing->control_type = type;
      _default_ownership[name] = bing;
      return 1;
   }
   return 0;
}
int set_controlled_ownership_owner(string controlled,
                                   string owner,
                                   int type) {
   class ownership bing;
   if (!_ownership[controlled]) {
      return 0;
   }
   bing = _ownership[controlled];
   bing->type = type;
   bing->name = owner;
   save_me();
   return 1;
}
mixed discuss_nominate_ownership(string message,
                                 string club_name,
                                 class discussion_idea frog,
                                 string arg1,
                                 string arg2) {
   string *nominated;
   string body;
   string *nom;
   string name;
   int ret;
   switch (message) {
   case CLUB_DISCUSS_MESSAGE_VERIFY :
      if (CLUB_HANDLER->query_club_name(club_name) !=
          CLUB_HANDLER->query_club_name(_club)) {
         return 0;
      }
      if (!_ownership[frog->information]) {
         return 0;
      }
      return 1;
   case CLUB_DISCUSS_MESSAGE_COMPLETE :
      body = "Hello!\n\nThe discussion item "
         "added at " + ctime(frog->time_added) + ", finished at " +
         ctime(time()) + " and added by " + frog->added_by +
         " has finished.";
      body += "  The vote for nominations for the ownership of " +
         frog->information + " in the club " +
         CLUB_HANDLER->query_club_name(club_name) +
         " has been completed and the "
         "results are:\n";
      nominated = ({ });
      foreach (name, nom in frog->choices) {
         body += name + ": " + query_multiple_short(nom);
         if ((member_array(name, nom) != -1 ||
              name[0..strlen(CLUB_ROOM_POSITION_START)] == CLUB_ROOM_POSITION_START) &&
              sizeof(nom) >= 2) {
            body += " (accepted)\n";
            nominated += ({ name });
         } else {
            body += "\n";
         }
      }
      if (frog->information) {
         body += frog->information;
      }
      if (sizeof(nominated)) {
         if (_ownership[frog->information]) {
            if (sizeof(nominated) != 1) {
               body += "Therefor we had added an election with " +
                  query_multiple_short(nominated) +
                  " for the ownership of " +
                  frog->information + ".\n";
               CLUB_HANDLER->add_discussion_item(club_name,
                                   CLUB_DISCUSS_FUNCTION,
                                   frog->added_by,
                                   ({ file_name(this_object()),
                                      "discuss_elect_ownership" }),
                                   frog->information,
                                   nominated,
                                   7 * (24 * 60 * 60),
                                   0);
            } else {
               body += "Only " + nominated[0] +
                  " was nominated, so they are given ownership immediately.\n";
               if (name[0..strlen(CLUB_ROOM_POSITION_START)] == CLUB_ROOM_POSITION_START) {
                  set_controlled_ownership_owner(frog->information,
                                                 nominated[0][strlen(CLUB_ROOM_POSITION_START)..],
                                                 CLUB_ROOM_OWNED_POSITION);
               } else {
                  set_controlled_ownership_owner(frog->information,
                                                 nominated[0],
                                                 CLUB_ROOM_OWNED_PERSON);
               }
            }
         } else {
            body += "The ownership item appears to have vanished!\n";
         }
      } else {
         if (_ownership[frog->information]) {
            body += "No one accepted their nomination, so nothing "
               "happened.\n";
            CLUB_HANDLER->add_discussion_item(club_name,
                                CLUB_DISCUSS_FUNCTION,
                                frog->added_by,
                                frog->name,
                                frog->information,
                                ({ }),
                                7 * (24 * 60 * 60),
                                frog->optional_data);
         } else {
            body += "The position in the club appears to have vanished!\n";
         }
      }
      return body;
   case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
      return "Nominations for ownership of " + frog->information;
   case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
      body = "Nominations for the ownership of " + frog->information +
         ", positions or people can be nominated to have ownership.  "
         "Positions are nominated by putting the word 'position' in front "
         "ie: 'position president'.\n"
         "Currently nominated are:\n";
      foreach (name, nom in frog->choices) {
         body += name + ": " + query_multiple_short(nom);
         if ((member_array(name, nom) != -1 ||
              name[0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START) &&
              sizeof(nom) >= 2) {
            body += " (accepted)\n";
         } else {
            body += "\n";
         }
      }
      return body;
   case CLUB_DISCUSS_MESSAGE_NOMINATION :
      if (CLUB_HANDLER->is_member_of(_club, arg1)) {
         if (CLUB_HANDLER->is_member_of(_club, arg2) ||
             (name[0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START &&
              CLUB_HANDLER->is_valid_position(_club,
                                              name[strlen(CLUB_ROOM_POSITION_START)..]))) {
            if (!frog->choices[arg2]) {
               frog->choices[arg2] = ({ arg1 });
               return 1;
            } else if (member_array(arg1,
                                    frog->choices[arg2]) == -1) {
               frog->choices[arg2] += ({ arg1 });
               return 1;
            }
         }
      }
      return 0;
   case CLUB_DISCUSS_MESSAGE_TYPE :
      return CLUB_DISCUSS_MESSAGE_TYPE_NOMINATE;
   case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
      if (frog->choices[arg1]) {
         map_delete(frog->choices, arg1);
         ret = 1;
      }
      foreach (name, nom in frog->choices) {
         if (member_array(arg1, nom) != -1) {
            frog->choices[name] = nom - ({ arg1 });
            if (!sizeof(frog->choices[name])) {
               map_delete(frog->choices, name);
            }
            ret = 1;
         }
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         frog->choices[CLUB_ROOM_POSITION_START + arg2] = frog->choices[CLUB_ROOM_POSITION_START + arg1];
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_NOMINATION_QUERY :
      return frog->choices;
   }
}
mixed discuss_elect_ownership(string message,
                              string club_name,
                              class discussion_idea frog,
                              string arg1,
                              string arg2) {
   string body;
   string name;
   int votes;
   int ret;
   int max_votes;
   string *names;
   switch (message) {
   case CLUB_DISCUSS_MESSAGE_VERIFY :
      if (CLUB_HANDLER->query_club_name(club_name) !=
          CLUB_HANDLER->query_club_name(_club)) {
         return 0;
      }
      if (!_ownership[frog->information]) {
         return 0;
      }
      return 1;
   case CLUB_DISCUSS_MESSAGE_COMPLETE :
      body = "Hello!\n\nThe discussion item "
         "added at " + ctime(frog->time_added) + ", finished at " +
         ctime(time()) + " and added by " + frog->added_by +
         " has finished.";
      body += "  The vote for elections of the ownership of " +
              frog->information +
         " in the club " +
         CLUB_HANDLER->query_club_name(club_name) +
         " has been completed and the "
         "results are:\n";
      names = ({ });
      max_votes = 0;
      foreach (name, votes in frog->choices) {
         body += name + ": " + votes + "\n";
         if (votes > max_votes) {
            max_votes = votes;
            names = ({ name });
         } else if (votes == max_votes) {
            names += ({ name });
         }
      }
      if (_ownership[frog->information]) {
         if (sizeof(names) == 1) {
            body += "Therefor we set " + names[0] +
                  " as owning " + frog->information + ".\n";
            if (names[0][0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START) {
               set_controlled_ownership_owner(frog->information,
                                              names[0][strlen(CLUB_ROOM_POSITION_START)..],
                                              CLUB_ROOM_OWNED_POSITION);
             } else {
               set_controlled_ownership_owner(frog->information,
                                              names[0],
                                              CLUB_ROOM_OWNED_PERSON);
             }
         } else {
            body += "There was a tie for the results of the position, readding "
                    "a discussion with the tied members: " +
                    query_multiple_short(names) + ".\n";
            CLUB_HANDLER->add_discussion_item(club_name,
                                   CLUB_DISCUSS_FUNCTION,
                                   frog->added_by,
                                   ({ file_name(this_object()),
                                      "discuss_elect_ownership" }),
                                   frog->information,
                                   names,
                                   7 * (24 * 60 * 60),
                                   frog->optional_data);
         }
      } else {
         body += "The ownership item appears to have vanished!\n";
      }
      return body;
   case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
      return "Election for ownership of " + frog->information;
   case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
      body = "Election for the ownership of " + frog->information +
         ".\n";
      return body;
   case CLUB_DISCUSS_MESSAGE_TYPE :
      return CLUB_DISCUSS_MESSAGE_TYPE_VOTE;
   case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
      if (frog->choices[arg1]) {
         map_delete(frog->choices, arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         frog->choices[CLUB_ROOM_POSITION_START + arg2] = frog->choices[CLUB_ROOM_POSITION_START + arg1];
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   }
}
private void setup_discussions() {
   string name;
   class ownership bing;
   foreach (name, bing in _ownership) {
      if (bing->control_type != CLUB_ROOM_CONTROLLED_FIXED) {
         CLUB_HANDLER->add_discussion_item(_club,
                                           CLUB_DISCUSS_FUNCTION,
                                           ({ file_name(this_object()),
                                              "discuss_nominate_ownership" }),
                                           name,
                                           ({ }),
                                           7 * 24 * 60 * 60,
                                           0);
      }
   }
}
void load_me() {
   if (_save_directory) {
      unguarded( (: restore_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) );
   }
}
void save_me() {
   if (_save_directory) {
      unguarded( (: save_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) );
   }
}
void set_save_directory(string save_directory) {
   while (save_directory[<1] == '/') {
      save_directory = save_directory[0..<2];
   }
   _save_directory = save_directory;
}
string query_save_directory() {
   return _save_directory;
}
string query_room_save_file_name(mixed fname) {
   if (objectp(fname)) {
      fname = file_name(fname);
   }
   fname = fname[strsrch(fname, '/', -1)..];
   return _save_directory + fname;
}

==================================================
FILE: room/controller/topography/area.c
==================================================

#include <dirs.h>
#include <image.h>
inherit "/std/room";
mapping direction_bits = ([
    "north": 1,
    "northeast": 2,
    "east": 4,
    "southeast": 8,
    "south": 16,
    "southwest": 32,
    "west": 64,
    "northwest": 128,
    "up": 256,
    "down": 512,
]);
class AREA_INFO {
  string base;
  int *origin;
  int *size;
  mixed *bbox;
  mixed *vertices;
  class IMAGE_INFO height;
  class IMAGE_INFO exits;
}
private int dbg_lvl = 0;
private string debugger = "jeremy";
private string _handler;
private class AREA_INFO *areas = ({ });
private mapping room_cache = ([ ]);
private mapping area_cache = ([ ]);
void set_handler(string handler) {
   _handler = handler;
}
string query_handler() {
   return _handler;
}
void set_debugger(string s) { debugger = s; }
string query_debugger() { return debugger; }
void set_debug_level(int l) { dbg_lvl = l; }
int query_debug_level() { return dbg_lvl; }
mixed query(string s) { return fetch_variable(s); }
void set_base(int i, string s) { areas[i]->base = s; }
string query_base(int i) { return areas[i]->base; }
void set_origin(int i, int *o) { areas[i]->origin = copy(o); }
int *query_origin(int i) { return copy(areas[i]->origin); }
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_keep_room_loaded(1);
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int *quantize_to_origin(int *coord_r, int a) {
  int size2, i, *coord_q;
  coord_q = allocate(3);
  for (i = 0; i < 3; i++) {
    size2 = areas[a]->size[i] * 2;
    if (coord_r[i] < areas[a]->origin[i]) {
      coord_q[i] = coord_r[i] - areas[a]->size[i];
    } else {
      coord_q[i] = coord_r[i] + areas[a]->size[i];
    }
    coord_q[i] = ((coord_q[i] - areas[a]->origin[i]) / size2) * size2
      + areas[a]->origin[i];
  }
  return coord_q;
}
void set_size(int i, mixed s) {
  if (intp(s)) {
    areas[i]->size = ({ s, s, s });
  } else if (arrayp(s) && (sizeof(s) == 3)) {
    areas[i]->size = copy(s);
  } else {
    error("Illegal size; must be int or 3-element array.\n");
  }
}
varargs void set_height_map(int i, string map_file, int rle) {
  int *nw;
  areas[i]->height = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->height->nw_coord = quantize_to_origin(nw, i);
  }
}
varargs void set_exits_map(int i, string map_file, int rle) {
  int *nw;
  areas[i]->exits = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->exits->nw_coord = quantize_to_origin(nw, i);
  }
}
int new_area() {
  areas += ({ new(class AREA_INFO) });
}
void set_vertices(int a, mixed *vs) {
  int v, i;
  if (!arrayp(areas[a]->origin)) {
    error("Origin unset - setting to (0,0,0).\n");
    areas[a]->origin = ({ 0, 0, 0 });
  }
  areas[a]->vertices = copy(vs);
  areas[a]->bbox = ({ copy(vs[0]), copy(vs[0]) });
  for (i = 0; i < 3; i++) {
    areas[a]->bbox[0][i] += areas[a]->origin[i];
    areas[a]->bbox[1][i] += areas[a]->origin[i];
  }
  for (v = 0; v < sizeof(areas[a]->vertices); v++) {
    for (i = 0; i < 3; i++) {
      areas[a]->vertices[v][i] += areas[a]->origin[i];
      if (areas[a]->vertices[v][i] < areas[a]->bbox[0][i]) {
        areas[a]->bbox[0][i] = areas[a]->vertices[v][i];
      } else if (areas[a]->vertices[v][i] > areas[a]->bbox[1][i]) {
        areas[a]->bbox[1][i] = areas[a]->vertices[v][i];
      }
    }
  }
}
int in_bbox(int *coord, mixed *bbox) {
  if ((coord[0] < bbox[0][0]) || (coord[0] > bbox[1][0])) {
    return 0;
  }
  if ((coord[1] < bbox[0][1]) || (coord[1] > bbox[1][1])) {
    return 0;
  }
  if ((coord[2] < bbox[0][2]) || (coord[2] > bbox[1][2])) {
    return 0;
  }
  return 1;
}
int in_area(int a, int *v) {
  int crossings, i, i0, i1, de, int_n, below_vertex;
  mixed *vs;
  if (!in_bbox(v, areas[a]->bbox)) {
    return 0;
  }
  vs = allocate(2);
  for (i = 0; i < sizeof(areas[a]->vertices); i++) {
    below_vertex = 0;
    vs[0] = areas[a]->vertices[i];
    if (i < sizeof(areas[a]->vertices)-1) {
      vs[1] = areas[a]->vertices[i+1];
    } else {
      vs[1] = areas[a]->vertices[0];
    }
    if ((v[1] < vs[0][1]) && (v[1] < vs[1][1])) {
      continue;
    }
    if ((v[1] > vs[0][1]) && (v[1] > vs[1][1])) {
      continue;
    }
    if ((v[0] > vs[0][0]) && (v[0] > vs[1][0])) {
      continue;
    }
    if ((v[0] < vs[0][0]) && (v[0] < vs[1][0])) {
      if (v[1] != vs[0][1]) {
        if (v[1] != vs[1][1]) {
          crossings++;
        }
        continue;
      } else {
        below_vertex = 1;
      }
    }
    if (vs[0][1] == vs[1][1]) {
      if (!below_vertex) {
        return 1;
      }
      continue;
    }
    if ((v[0] == vs[0][0]) && (v[1] == vs[0][1])) {
      return 1;
    }
    if ((vs[0][0] == vs[1][0]) && !below_vertex) {
      return 1;
    }
    if (v[1] == vs[1][1]) {
      continue;
    }
    if (v[1] == vs[0][1]) {
      if (v[0] > vs[0][0]) {
        continue;
      }
      i0 = i;
      while (areas[a]->vertices[i0][1] == v[1]) {
        i0--;
        if (i0 < 0) i0 = sizeof(areas[a]->vertices) - 1;
      }
      i1 = i;
      while (areas[a]->vertices[i1][1] == v[1]) {
        i1++;
        if (i1 >= sizeof(areas[a]->vertices)) i1 = 0;
      }
      crossings++;
      if (((areas[a]->vertices[i0][1] > v[1]) &&
           (areas[a]->vertices[i1][1] > v[1])) ||
          ((areas[a]->vertices[i0][1] < v[1]) &&
           (areas[a]->vertices[i1][1] < v[1]))) {
        crossings++;
      }
      continue;
    }
    de = vs[1][1] - vs[0][1];
    int_n = ceil(to_float(vs[1][0] - vs[0][0])*(v[1] - vs[0][1])/de
                 + vs[0][0] + 0.5);
    if (int_n > v[0]) {
      crossings++;
    }
  }
  return (crossings & 1);
}
object clone_room(int a, int *coord_q, string coord_s) {
  int i, j, e, bit;
  string dir;
  object room;
  room = clone_object(areas[a]->base);
  room_cache[coord_s] = room;
  area_cache[coord_s] = a;
  room->set_room_size(areas[a]->size);
  room->set_co_ord(coord_q);
  if (areas[a]->exits) {
    i = (areas[a]->origin[0] - coord_q[0])/(2*areas[a]->size[0]);
    j = (coord_q[1] - areas[a]->origin[1])/(2*areas[a]->size[1]);
    if ((i < areas[a]->exits->size[0]) && (j < areas[a]->exits->size[1])
        && (i >= 0) && (j >= 0)) {
      e = areas[a]->exits->image[i][j];
      foreach (dir, bit in direction_bits) {
        if (e & bit) {
          room->add_exit(dir, "", "path");
        }
      }
      room->add_property("image_cell", ({ i, j }));
    }
  }
  return room;
}
object find_room_at_coord(int *coord) {
  int a, ac, *coord_q;
  string coord_s;
  object room;
  coord_s = sprintf("%d:%d:%d", coord[0], coord[1], coord[2]);
  if (objectp(room = room_cache[coord_s])) {
    return room;
  }
  if (!undefinedp(ac = area_cache[coord_s])) {
    return clone_room(ac, coord, coord_s);
  }
  for (a = 0; a < sizeof(areas); a++) {
    coord_q = quantize_to_origin(coord, a);
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
  }
  return 0;
}
object find_room_at_exit(object r, int *d, string direc) {
  int a, ac, i, *coord, *coord_r, *coord_q;
  string coord_s;
  object room;
  mixed size_r;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (a = 0; a < sizeof(areas); a++) {
    for (i = 0; i < 3; i++) {
      coord_r[i] = coord[i] + (size_r[i] + areas[a]->size[i]) * d[i];
    }
    coord_s = sprintf("%d:%d:%d", coord_r[0], coord_r[1], coord_r[2]);
    return load_object(_handler + ":" + coord_s);
#if 0
    if (objectp(room = room_cache[coord_s])) {
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found room %O cached at %s...\n",
                 file_name(this_object()), room, coord_s);
      }
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found area %O cached at %s...\n",
                 file_name(this_object()), ac, coord_s);
      }
      return clone_room(ac, coord_r, coord_s);
    }
    coord_q = quantize_to_origin(coord_r, a);
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
#endif
  }
  return 0;
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
int goto_room_at_exit(int *d, string direc) {
  return this_player()->move_with_look(find_room_at_exit(
                        environment(this_player()), d, direc));
}
void print_images(int a) {
  if (areas[a]->height) {
    printf("-------- Height:\n");
    IMAGE_HANDLER->print_image(areas[a]->height);
  }
  if (areas[a]->exits) {
    printf("-------- Exits:\n");
    IMAGE_HANDLER->print_image(areas[a]->exits);
  }
}
void print_map(int a) {
  int s, e;
  string l = "";
  class IMAGE_INFO exits;
  if (areas[a]->exits) {
    exits = areas[a]->exits;
    for (s = 0; s < exits->size[1]; s++) {
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 128)?"\\":" ";
        l += (exits->image[s][e] & 1)  ?"|":" ";
        l += (exits->image[s][e] & 2)  ?"/":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 64) ?"-":" ";
        l += "*";
        l += (exits->image[s][e] & 4)  ?"-":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 32) ?"/":" ";
        l += (exits->image[s][e] & 16) ?"|":" ";
        l += (exits->image[s][e] & 8)  ?"\\":" ";
      }
      l += "\n";
    }
    write(l);
  }
}

==================================================
FILE: room/controller/topography/interroom.c
==================================================

#include <map.h>
inherit "/std/room";
class IROOM_INFO {
  string base;
  int *size;
  mixed *bbox;
  int sgn_n;
  int sgn_e;
  string *exits;
}
int closed;
nosave int dbg_lvl = 0;
mixed *irooms;
string *milestones;
mixed *milestone_coords;
mapping milestone_idx = ([ ]);
class IROOM_INFO *iroom_info;
mixed *overall_bbox;
string save_file;
nosave string debugger = "jeremy";
mixed *bbox(int *coord_a, int *coord_b);
int in_bbox(int *coord_a, mixed bbox);
void set_debugger(string s) { debugger = s; }
string query_debugger() { return debugger; }
void set_debug_level(int l) { dbg_lvl = l; }
int query_debug_level() { return dbg_lvl; }
mixed query(string s) { return fetch_variable(s); }
int abs(int i) {
  return (i<0)?-i:i;
}
float fabs(float i) {
  return (i<0)?-i:i;
}
void set_save_file(string s) { save_file = s; }
string query_save_file() { return save_file; }
void set_milestones(string *s) {
  int i;
  milestones = copy(s);
  if (milestones[0] == milestones[<1]) {
    closed = 1;
  }
  for (i = 0; i < sizeof(milestones) - closed; i++) {
    milestone_idx[s[i]] = i;
  }
  milestone_coords = allocate(sizeof(milestones));
  irooms = allocate(sizeof(milestones)-1);
  iroom_info = allocate(sizeof(milestones)-1);
  for (i = 0; i < sizeof(iroom_info); i++) {
    iroom_info[i] = new(class IROOM_INFO);
    iroom_info[i]->exits = allocate(2);
  }
  overall_bbox = 0;
}
string *query_milestones() { return milestones; }
string query_milestone(int i) { return milestones[i]; }
void set_milestone_coords(int i, int *c) {
  if (!arrayp(c) || (sizeof(c) != 3)) {
    return;
  }
  if (!arrayp(milestone_coords[i]) || (milestone_coords[i][0] != c[0])
  || (milestone_coords[i][1] != c[1]) || (milestone_coords[i][2] != c[2])) {
    milestone_coords[i] = copy(c);
    if ((i > 0) && arrayp(milestone_coords[i-1])) {
      iroom_info[i-1]->bbox = bbox(milestone_coords[i-1], milestone_coords[i]);
      if (milestone_coords[i-1][0] < milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = 1;
      } else if (milestone_coords[i-1][0] > milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = -1;
      } else {
        iroom_info[i-1]->sgn_n = 0;
      }
      if (milestone_coords[i-1][1] < milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = 1;
      } else if (milestone_coords[i-1][1] > milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = -1;
      } else {
        iroom_info[i-1]->sgn_e = 0;
      }
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i-1]->bbox);
      } else {
        if (iroom_info[i-1]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i-1]->bbox[0][0];
        }
        if (iroom_info[i-1]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i-1]->bbox[0][1];
        }
        if (iroom_info[i-1]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i-1]->bbox[1][0];
        }
        if (iroom_info[i-1]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i-1]->bbox[1][1];
        }
      }
    }
    if ((i < sizeof(iroom_info)) && arrayp(milestone_coords[i+1])) {
      iroom_info[i]->bbox = bbox(milestone_coords[i], milestone_coords[i+1]);
      if (milestone_coords[i][0] < milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = 1;
      } else if (milestone_coords[i][0] > milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = -1;
      } else {
        iroom_info[i]->sgn_n = 0;
      }
      if (milestone_coords[i][1] < milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = 1;
      } else if (milestone_coords[i][1] > milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = -1;
      } else {
        iroom_info[i]->sgn_e = 0;
      }
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i]->bbox);
      } else {
        if (iroom_info[i]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i]->bbox[0][0];
        }
        if (iroom_info[i]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i]->bbox[0][1];
        }
        if (iroom_info[i]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i]->bbox[1][0];
        }
        if (iroom_info[i]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i]->bbox[1][1];
        }
      }
    }
  }
}
mixed query_milestone_coords() { return milestone_coords; }
void set_bases(string *s) {
  int i;
  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of bases (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->base = s[i];
  }
}
void set_sizes(mixed *s) {
  int i;
  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of sizes (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->size = allocate(3);
    if (intp(s[i])) {
      iroom_info[i]->size[0] = s[i];
      iroom_info[i]->size[1] = s[i];
      iroom_info[i]->size[2] = s[i];
    } else if (arrayp(s[i])) {
      iroom_info[i]->size[0] = s[i][0];
      iroom_info[i]->size[1] = s[i][1];
      iroom_info[i]->size[2] = s[i][2];
    } else {
      error("Illegal room size given (" + i + ").\n");
      continue;
    }
  }
}
class IROOM_INFO *query_iroom_info() { return iroom_info; }
int query_endpoint(int i, int j, int dir) {
  if ((dir && (j == sizeof(irooms[i])-1)) || (!dir && (j == 0))) {
    return 1;
  }
  return 0;
}
object *query_irooms_inv(int i, int j, int dir) {
  int k;
  object *invs;
  invs = ({ });
  if (dir) {
    if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j+1; k < sizeof(irooms[i]); k++) {
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  } else {
    if (j == -1) {
      if (closed) {
        i = sizeof(milestones) - 2;
      } else {
        i--;
      }
      if (!arrayp(irooms[i])) {
        return invs;
      } else {
        j = sizeof(irooms[i]);
      }
    } else if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j-1; k >= 0; k--) {
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  }
  return invs;
}
mixed *bbox(int *coord_a, int *coord_b) {
  int c;
  mixed *bbox;
  bbox = allocate(2);
  bbox[0] = allocate(3);
  bbox[1] = allocate(3);
  for (c = 0; c < 3; c++) {
    if (coord_a[c] < coord_b[c]) {
      bbox[0][c] = coord_a[c];
      bbox[1][c] = coord_b[c];
    } else {
      bbox[0][c] = coord_b[c];
      bbox[1][c] = coord_a[c];
    }
  }
  return bbox;
}
int in_bbox(int *coord_a, mixed bbox) {
  if ((coord_a[0] < bbox[0][0]) || (coord_a[0] > bbox[1][0])
  || (coord_a[1] < bbox[0][1]) || (coord_a[1] > bbox[1][1]))
    return 0;
  return 1;
}
int number_of_irooms(int i) {
  int n;
  mixed bbox;
  class IROOM_INFO ir;
  ir = iroom_info[i];
  bbox = ir->bbox;
  if (ir->sgn_n == 0) {
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
  } else if (ir->sgn_e == 0) {
    n = (bbox[1][0] - bbox[0][0])/(ir->size[0]*2);
  } else {
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
    if (n != (bbox[1][0] - bbox[0][0])/(ir->size[0]*2)) {
      error("Interroom sizes don't match diagonal.\n");
      return 0;
    }
  }
  return n-1;
}
object clone_iroom(int i, int idx, int *icoord) {
  object iroom;
  iroom = clone_object(iroom_info[i]->base);
  iroom->set_room_size(iroom_info[i]->size);
  iroom->set_co_ord(icoord);
  iroom->set_milestone_index( ({ i, idx }) );
  iroom->add_exit(iroom_info[i]->exits[0], milestones[i], "road");
  iroom->add_exit(iroom_info[i]->exits[1], milestones[i+1], "road");
  iroom->add_milestone_dir(iroom_info[i]->exits[0]);
  iroom->add_milestone_dir(iroom_info[i]->exits[1]);
  iroom->add_topo_exits_int();
  return iroom;
}
void setup_milestone(object ms) {
  int *coord, i, j, idir;
  string *dir;
  if (undefinedp(i = milestone_idx[file_name(ms)])) {
    error("This room (" + file_name(ms) + ") is not a milestone.\n");
    return;
  }
  ms->set_milestone_index(file_name(this_object()), i);
  coord = ms->query_co_ord();
  if (arrayp(coord)) {
    set_milestone_coords(i, coord);
  } else {
    if (arrayp(milestone_coords[i])) {
      coord = milestone_coords[i];
    } else {
      coord = MAP->static_query_co_ord(file_name(ms));
      set_milestone_coords(i, coord);
    }
    ms->set_co_ord(coord);
  }
  if (closed && (i == 0)) {
    milestone_coords[<1] = milestone_coords[0];
  }
  dir = ms->query_dest_dir();
  if ((i > 0) || closed) {
    if (closed && i == 0) {
      j = sizeof(milestones) - 2;
    } else {
      j = i - 1;
    }
    if ((idir = member_array(milestones[j], dir)) < 0) {
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[j]->exits[0] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  } else {
    ms->add_milestone_dir(file_name(this_object()), 0);
  }
  if (i < sizeof(irooms)) {
    j = i + 1;
    if ((idir = member_array(milestones[j], dir)) < 0) {
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[i]->exits[1] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  }
}
varargs object find_room_at_coord(int *coord_a, int hint_idx) {
  int i, idx, in_bbox;
  int start_i, stop_i;
  int *icoord = ({ 0, 0, 0 });
  mixed bbox;
  float slope;
  class IROOM_INFO ir;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  coord_a: %O\n"
                 "  hint_idx: %s\n",
                 file_name(this_object()), coord_a,
                 undefinedp(hint_idx)?"NULL":hint_idx+"");
  }
  if (!in_bbox(coord_a, overall_bbox)) {
    return 0;
  }
  in_bbox = 0;
  if (undefinedp(hint_idx)) {
    start_i = 0;
    stop_i = sizeof(iroom_info);
  } else {
    start_i = hint_idx;
    stop_i = hint_idx + 1;
  }
  for (i = start_i; i < stop_i; i++) {
    ir = iroom_info[i];
    bbox = ir->bbox;
    if (dbg_lvl > 1) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Checking bbox(%d,%d): %O\n",
                   file_name(this_object()), i, i+1, bbox);
    }
    if (in_bbox(coord_a, bbox)) {
      if (dbg_lvl > 1) {
        tell_creator(debugger, "%s::find_room_at_coord()\n"
                     "  In bbox(%d,%d)...\n",
                     file_name(this_object()), i, i+1);
      }
      if (ir->sgn_e == 0) {
        if (abs(coord_a[1]-milestone_coords[i][1]) < ir->size[1]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On vline between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      } else {
        slope = to_float(milestone_coords[i][0] - milestone_coords[i+1][0])
          / to_float(milestone_coords[i][1] - milestone_coords[i+1][1]);
        if (abs(slope * (coord_a[1] - milestone_coords[i+1][1]) +
            milestone_coords[i+1][0] - coord_a[0]) < ir->size[0]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On line between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      }
    }
  }
  if (i == stop_i) {
    if (dbg_lvl > 2) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Couldn't find a room...\n",
                   file_name(this_object()));
    }
    return 0;
  }
  if (ir->sgn_n == 0) {
    idx = abs(coord_a[1] - milestone_coords[i][1]
              + ir->size[1]*ir->sgn_e)/(ir->size[1]*2);
    icoord[0] = milestone_coords[i][0];
    icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
  } else {
    idx = abs(coord_a[0] - milestone_coords[i][0]
              + ir->size[0]*ir->sgn_n)/(ir->size[0]*2);
    icoord[0] = milestone_coords[i][0] + idx*ir->sgn_n*ir->size[0]*2;
    if (ir->sgn_e == 0) {
      icoord[1] = milestone_coords[i][1];
    } else {
      icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
    }
  }
  if (dbg_lvl > 2) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  idx: %O\n",
                 file_name(this_object()), idx);
  }
  if (idx == 0) {
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])+1) {
    return load_object(milestones[i+1]);
  }
  idx--;
  if (!objectp(irooms[i][idx])) {
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
}
object find_room_at_index(int i, int idx) {
  int *icoord = ({ 0, 0, 0 });
  class IROOM_INFO ir;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_index()\n"
                 "  i: %O, idx: %O\n",
                 file_name(this_object()), i, idx);
  }
  if (closed && (i == -1)) {
    i = sizeof(milestones) - 2;
  }
  if ((i < 0) || (i >= sizeof(irooms))) {
    return 0;
  }
  if (idx == -1) {
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])) {
    return load_object(milestones[i+1]);
  }
  if (idx == -2) {
    idx = sizeof(irooms[i]) - 1;
  }
  if ((idx < 0) || (idx >= sizeof(irooms[i]))) {
    return 0;
  }
  if (!objectp(irooms[i][idx])) {
    ir = iroom_info[i];
    if (ir->sgn_n == 0) {
      icoord[0] = milestone_coords[i][0];
      icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
    } else {
      icoord[0] = milestone_coords[i][0] + (idx+1)*ir->sgn_n*ir->size[0]*2;
      if (ir->sgn_e == 0) {
        icoord[1] = milestone_coords[i][1];
      } else {
        icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
      }
    }
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
}
int query_region(int *coord, mixed bbox) {
  int ret;
  if (coord[0] < bbox[0][0]) {
    ret += 1;
  } else if (coord[0] > bbox[1][0]) {
    ret += 2;
  }
  if (coord[1] < bbox[0][1]) {
    ret += 4;
  } else if (coord[1] > bbox[1][1]) {
    ret += 8;
  }
  return ret;
}
object find_room_at_crossing(int *coord_a, int *coord_b) {
  int i, a, b, c, d, dist2, ret_dist2;
  float e, f, det;
  int *isect;
  object ret;
  mixed bbox, road_a, road_b;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_crossing()\n"
                 "  coord_a: %O\n"
                 "  coord_b: %O\n",
                 file_name(this_object()), coord_a, coord_b);
  }
  if (query_region(coord_a, overall_bbox)
      & query_region(coord_b, overall_bbox)) {
    return 0;
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    bbox = iroom_info[i]->bbox;
    if (query_region(coord_a, iroom_info[i]->bbox)
        & query_region(coord_b, iroom_info[i]->bbox)) {
      continue;
    }
    road_a = allocate(3);
    road_b = allocate(3);
    if (iroom_info[i]->sgn_n > 0) {
      road_a[0] = bbox[0][0];
      road_b[0] = bbox[1][0];
    } else {
      road_a[0] = bbox[1][0];
      road_b[0] = bbox[0][0];
    }
    if (iroom_info[i]->sgn_e > 0) {
      road_a[1] = bbox[0][1];
      road_b[1] = bbox[1][1];
    } else {
      road_a[1] = bbox[1][1];
      road_b[1] = bbox[0][1];
    }
    a = coord_b[0] - coord_a[0];
    b = coord_a[1] - coord_b[1];
    c = road_b[0] - road_a[0];
    d = road_a[1] - road_b[1];
    e = to_float(a)*coord_a[1] + to_float(b)*coord_a[0];
    f = to_float(c)*road_a[1] + to_float(d)*road_a[0];
    det = a*d - b*c;
    if (fabs(det) < 0.0000000000001) {
      continue;
    }
    isect = allocate(3);
    isect[0] = to_int(floor((a*f - e*c)/det + 0.5));
    isect[1] = to_int(floor((e*d - b*f)/det + 0.5));
    if (!in_bbox(isect, bbox) || !in_bbox(isect, bbox(coord_a, coord_b))) {
      continue;
    }
    dist2 = (isect[0]-coord_a[0])*(isect[0]-coord_a[0]) +
      (isect[1]-coord_a[1])*(isect[1]-coord_a[1]);
    if (objectp(ret) && (dist2 >= ret_dist2)) {
      continue;
    }
    ret = find_room_at_coord(isect, i);
    if (dbg_lvl > 0) {
      tell_creator(debugger, "%s::find_room_at_crossing()\n"
                   "  find_room_at_coord() returned %O\n",
                   file_name(this_object()), ret);
    }
    ret_dist2 = dist2;
    if (!objectp(ret)) {
      error("Couldn't find a room where there should be one!\n");
    }
  }
  return ret;
}
void create() {
  string std_euid;
  std_euid = "/secure/master"->creator_file(file_name(this_object()));
  seteuid(std_euid);
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  set_keep_room_loaded(1);
}
void dest_me() {
  if (stringp(save_file)) {
    unguarded( (: save_object, save_file :) );
  }
  ::dest_me();
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
int goto_room_at_index(int i, int j) {
  return this_player()->move_with_look(find_room_at_index(i, j));
}
int goto_room_at_crossing(int *a, int *b) {
  return this_player()->move_with_look(find_room_at_crossing(a, b));
}
void recalc_milestones(int idx, int callouts, object tp) {
  int *c;
  string ms;
  if (callouts > 10) {
    error(sprintf("Too many callouts in %s:recalc_iroom_info(%d, %d)\n",
          file_name(this_object()), idx, callouts));
    return;
  }
  if (!idx && !callouts && !tp) {
    rm(save_file);
    this_object()->setup();
    idx = 0;
    tp = this_player();
  }
  ms = milestones[idx];
  if (!arrayp(c = ms->query_co_ord())) {
    call_out("recalc_milestones", 0, idx, callouts+1, tp);
    tell_object(tp, sprintf("Waiting on %s (%d, %d)...\n",
                          ms, idx, callouts));
    return;
  }
  ms->setup_milestone(ms);
  tell_object(tp, sprintf("Loaded room %s at (%d, %d, %d)...\n",
                          ms, c[0], c[1], c[2]));
  idx++;
  if (idx < sizeof(milestones)) {
    call_out("recalc_milestones", 0, idx, 0, tp);
    return;
  }
  tell_object(tp, "IRoom info successfully recalculated.\n");
}
void clear_map_handler() {
  int i;
  string ms, directory, troom;
  for (i = 0; i < sizeof(milestones); i++) {
    ms = milestones[i];
    directory = implode( explode( ms, "/" )[ 0..<2 ], "/" );
    troom = explode( ms, "/" )[ <1 ];
    if ( troom[ <2.. ] == ".c" ) {
      troom = troom[ 0..<3];
    }
    MAP->del(directory, troom);
    printf("Deleting %s in %s from map handler.\n", directory, troom);
  }
}
int sanity_checks() {
  int i, success = 1;
  for (i = 0; i < sizeof(milestone_coords); i++) {
    if (sizeof(milestone_coords[i]) != 3) {
      printf("Milestone %d (%s) doesn't have proper coordinates: %O\n",
             i, milestones[i], milestone_coords[i]);
      success = 0;
    }
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    if (sizeof(iroom_info[i]->size) != 3) {
      printf("Interroom segment %d has improper size: %O\n",
             i, iroom_info[i]->size);
      success = 0;
    }
    if ((sizeof(iroom_info[i]->bbox) != 2) ||
        (sizeof(iroom_info[i]->bbox[0]) != 3) ||
        (sizeof(iroom_info[i]->bbox[1]) != 3)) {
      printf("Interroom segment %d has improper bounding box: %O\n",
             i, iroom_info[i]->bbox);
      success = 0;
    }
  }
  return success;
}

==================================================
FILE: room/controller/topography/path.h
==================================================

#define FIXED_SHADOW "/std/room/basic/topography/fixed_shadow"

==================================================
FILE: room/controller/topography/topography.c
==================================================

#include <dirs.h>
#include "path.h"
inherit "/std/basic/setup";
class bounding_box {
   int* topleft;
   int* bottomright;
}
class FIXED_INFO {
  string path;
  object ob;
  int *coord;
  mixed bbox;
}
private mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);
private int _dbg_lvl = 0;
private string _debugger;
private object *_area_handlers = ({ });
private object *_iroom_handlers = ({ });
private class FIXED_INFO *_fixed_rooms = ({ });
private mapping _fixed_room_index = ([ ]);
private class bounding_box _topo_box;
void set_debugger(string s) { _debugger = s; }
string query_debugger() { return _debugger; }
void set_debug_level(int l) { _dbg_lvl = l; }
int query_debug_level() { return _dbg_lvl; }
void create() {
  do_setup();
}
class bounding_box query_bounding_box() {
   return _topo_box;
}
int in_bbox(int *coord, class bounding_box bbox) {
  if ((coord[0] < bbox->topleft[0]) || (coord[0] > bbox->bottomright[0])) {
    return 0;
  }
  if ((coord[1] < bbox->topleft[1]) || (coord[1] > bbox->bottomright[1])) {
    return 0;
  }
  return 1;
}
class bounding_box bounding_box(int *coord, mixed s) {
  int *size;
  class bounding_box bbox;
  if (sizeof(coord) != 3) {
    return 0;
  }
  if (arrayp(s)) {
    if (sizeof(s) == 3) {
      size = s;
    } else {
      return 0;
    }
  } else if (intp(s)) {
    size = ({ s, s, s });
  } else {
    return 0;
  }
  bbox = new(class bounding_box);
  bbox->topleft = ({ coord[0]-size[0], coord[1]-size[1], coord[2]-size[2] });
  bbox->bottomright = ({ coord[0]+size[0], coord[1]+size[1], coord[2]+size[2] });
  return bbox;
}
void add_area_handler(mixed h) {
  object oh;
  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _area_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find area handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _area_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find area handler %O.\n", h));
  }
}
void add_iroom_handler(mixed h) {
  object oh;
  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _iroom_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find interroom handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _iroom_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find interroom handler %O.\n", h));
  }
}
private void add_internal_fixed_room(string path,
                                     object ob,
                                     int* coord,
                                     class bounding_box bbox) {
  class FIXED_INFO cf;
  cf = new(class FIXED_INFO);
  cf->path = path;
  cf->ob = ob;
  cf->coord = coord;
  cf->bbox = bbox;
  _fixed_room_index[cf->path] = sizeof(_fixed_rooms);
  _fixed_rooms += ({ cf });
}
void add_fixed_room(string f) {
  object of;
  of = load_object(f);
  if (!objectp(of)) {
    error(sprintf("Couldn't load fixed room %s.\n", f));
    return;
  }
  add_internal_fixed_room(f, of, of->query_co_ord(),
                      bounding_box(of->query_co_ord(), of->query_room_size()));
}
void add_fixed_room_object(object of) {
  add_internal_fixed_room(file_name(of), of, of->query_co_ord(),
                    bounding_box(of->query_co_ord(), of->query_room_size()));
}
void add_fixed_room_coordinate(string f, int* coord, int* size) {
    add_internal_fixed_room(f, 0, coord, bounding_box(coord, size));
}
void setup_fixed_room() {
  object shad, r;
  int i;
  r = previous_object();
  shad = clone_object(FIXED_SHADOW);
  if (!objectp(shad)) {
    error(sprintf("Couldn't create shadow for fixed room %O.\n", r));
    return;
  }
  shad->attach(r);
  shad->set_area_handler(file_name(this_object()));
  if (undefinedp(i = _fixed_room_index[file_name(r)])) {
    error(sprintf("Couldn't find entry for fixed room %O.\n", r));
  }
  r->set_co_ord(_fixed_rooms[i]->coord);
}
object find_room_at_coord(int *coord) {
  int i;
  object ob;
  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_coord()\n"
                 "  coord: %O\n",
                 file_name(this_object()), coord);
  }
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      return _fixed_rooms[i]->ob;
    }
  }
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    if (objectp(ob = _iroom_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  return 0;
}
object create_virtual_object(int x, int y, int z) {
   if (undefinedp(x) || undefinedp(y) || undefinedp(z)) {
      return 0;
   }
   return find_room_at_coord(({ x, y, z }));
}
object find_room_at_exit(object r, int *d, string direc) {
  int i, s, dist, max_dist, max_iroom, *coord, *coord_r, *coord_ob;
  string msg;
  object ob, *irooms = ({ });
  mixed size_r;
  class bounding_box bbox_r;
  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (i = 0; i < 3; i++) {
    coord_r[i] = coord[i] + 2 * size_r[i] * d[i];
  }
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord_r, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      msg = evaluate(_fixed_rooms[i]->ob->query_topo_barrier(direc));
      if (!undefinedp(msg)) {
        if (!stringp(msg)) {
          msg = "You can't go that way.\n";
        }
        notify_fail(msg);
        return 0;
      }
      return _fixed_rooms[i]->ob;
    }
  }
  bbox_r = bounding_box(coord, size_r);
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    ob = _iroom_handlers[i]->find_room_at_crossing(coord, coord_r);
    tell_creator("rhinehold", "ob = %O\n", ob);
    if (objectp(ob )
        && (ob != r)) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_crossing() returned %O\n",
                     file_name(this_object()), _iroom_handlers[i], ob);
      }
      if (!arrayp(ob->query_co_ord())) {
        return ob;
      }
      if (r->query_fixed_room() && in_bbox(ob->query_co_ord(), bbox_r)) {
        continue;
      }
      irooms += ({ ob });
    }
  }
  if ((s = sizeof(irooms)) > 0) {
    if (s == 1) {
      return irooms[0];
    } else {
      max_dist = 0;
      max_iroom = -1;
      for (i = 0; i < s; i++) {
        coord_ob = irooms[i]->query_co_ord();
        dist = (coord[0] - coord_ob[0])*(coord[0] - coord_ob[0]) +
          (coord[1] - coord_ob[1])*(coord[1] - coord_ob[1]);
        if (dist > max_dist) {
          max_dist = dist;
          max_iroom = i;
        }
      }
      if (max_iroom >= 0) {
        return irooms[max_iroom];
      }
    }
  }
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_exit(r, d))) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_exit() returned %O\n",
                     file_name(this_object()), _area_handlers[i], ob);
      }
      return ob;
    }
  }
  return 0;
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
string query_text_map(int width) {
   int x;
   int y;
   int maxy;
   string map;
   object room;
   map = "";
   for (y = 0; y < maxy; y++) {
      for (x = 0; x < width; x++) {
         room = find_room_at_coord( ({ x, y, 0 }) );
         if (!room) {
            map += " ";
         } else if (!room->query_room_letter()) {
            map += "?";
         } else {
            map += room->query_room_letter();
         }
      }
      map += "\n";
   }
   return map;
}

==================================================
FILE: room/punishments/banishment.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
private nosave string _banish_handler;
void create() {
   set_short("banishment");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "banishment");
   ::create();
}
void set_banish_handler(string hand) {
   _banish_handler = hand;
}
string query_banish_handler() {
   return _banish_handler;
}
string query_short(string area, class nomic_case the_case, string type, mixed data) {
   return ::query_short() + " for " + data + " days";
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   if (sizeof(filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area))) {
      write("You cannot banish a magistrate.\n");
      return ;
   }
   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
}
void days_of_banishment(string input,
                        string area,
                        class nomic_case the_case,
                        string type,
                        function finish) {
   int num;
   input = lower_case(input);
   if (input == "" || input[0] == 'q') {
      write("Aborting banishment.\n");
      return ;
   }
   if (input[0] >= '0' && input[0] <= '9') {
      if (sscanf(input, "%d", num) == 1) {
         evaluate(finish, the_case, type, num);
         return ;
      }
   }
   write("Invalid input.\n");
   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      _banish_handler->banish_person(person, data);
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      _banish_handler->banish_person_suspend(person);
   }
   return ;
}

==================================================
FILE: room/punishments/dismissed.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("dismissed");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "dismissed");
}

==================================================
FILE: room/punishments/fine.c
==================================================

#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
inherit "/std/room/inherit/punishment_inherit";
#define TIMEOUT (4 * 7 * 24 * 60 * 60)
private mapping _fines;
private nosave string _money_area;
private nosave string _save_file;
class fine_type {
   int paid;
   int fines;
   int last_touched;
}
void load_me();
void setup() {
   _fines = ([ ]);
   set_short("fine");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "fine");
   seteuid(getuid());
   load_me();
}
void load_me() {
   if (_save_file) {
      unguarded((: restore_object( _save_file ) :));
      call_out("remove_old_fines", 2);
   }
}
void save_me() {
   unguarded((: save_object( _save_file ) :));
}
void remove_old_fines() {
   class fine_type fine;
   string player;
   int changed;
   foreach (player, fine in _fines) {
      if (!PLAYER_HANDLER->test_user(player)) {
         map_delete(_fines, player);
         changed = 1;
      }
      if (sizeof(fine) == 2) {
         fine = new(class fine_type, paid : fine->paid, fines : fine->fines,
                                last_touched : time());
         _fines[player] = fine;
         changed = 1;
      }
      if (fine->fines <= 0 && fine->last_touched + TIMEOUT < time()) {
         map_delete(_fines, player);
         changed = 1;
      }
   }
   if (changed) {
      save_me();
   }
}
void set_money_area(string area) {
   _money_area = area;
}
string query_money_area() {
   return _money_area;
}
void set_save_file(string fname) {
   _save_file = fname;
}
string query_save_file() {
   return _save_file;
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   write("How much do you wish to fine " +
         query_multiple_short(the_case->people) + "? ");
   input_to("fine_amount", 0, area, the_case, type, finish);
}
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "fined " +
          MONEY_HAND->money_value_string(data, _money_area);
}
void fine_amount(string amt, string area, class nomic_case the_case,
                 string type, function finish) {
   int value;
   amt = lower_case(amt);
   if (!strlen(amt) || amt[0] == 'q') {
      write("Aborting the fine.\n");
      return ;
   }
   value = MONEY_HAND->value_from_string(amt, _money_area);
   if (value <= 0) {
      write("You did not specify a positive money value.\n");
      write("How much do you wish to fine " +
            query_multiple_short(the_case->people) + "? ");
      input_to("fine_amount", 0, area, the_case, type, finish);
      return ;
   }
   evaluate(finish, the_case, type, value);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines += data;
      _fines[person]->last_touched = time();
   }
   save_me();
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines -= data;
      _fines[person]->last_touched = time();
   }
   save_me();
   return ;
}
int pay_fine(string person, int amount) {
   if (_fines[person]) {
      _fines[person]->paid += amount;
      _fines[person]->last_touched = time();
      save_me();
      return 1;
   }
   return 0;
}
int query_current_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines - _fines[person]->paid;
   }
   return 0;
}
int query_total_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines;
   }
   return 0;
}
int query_total_payments(string person) {
   if (_fines[person]) {
      return _fines[person]->paid;
   }
   return 0;
}
string* query_people_with_fines() {
   return keys(_fines);
}

==================================================
FILE: room/punishments/lose_citizenship.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("lose citizenship");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "lose_citizenship");
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   string* not_citizens;
   string* magistrates;
   not_citizens = filter(the_case->people,
                     (: !NOMIC_HANDLER->is_citizen_of($2, $1) :), area);
   if (sizeof(not_citizens)) {
      write(query_multiple_short(not_citizens) + " cannot lose "
            "their citizenship since they are not citizens.\n");
      return ;
   }
   magistrates = filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area);
   if (sizeof(magistrates)) {
      write(query_multiple_short(magistrates) + " cannot lose "
            "their citizenship since they are magistrates.\n");
      return ;
   }
   evaluate(finish, the_case, type, 0);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;
   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->remove_citizen(area, citizen);
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;
   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->add_citizen(area, citizen);
   }
   return ;
}

==================================================
FILE: room/punishments/not_guilty.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("not guilty");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "not_guilty");
}

==================================================
FILE: room/punishments/title.c
==================================================

#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
#include <player.h>
inherit "/std/room/inherit/punishment_inherit";
private nosave string* _titles;
void create() {
   _titles = ({ });
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "title");
   set_short("title");
   ::create();
}
void set_titles(string* titles) {
   _titles = titles;
}
string* query_titles() {
   return _titles;
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   int i;
   for (i = 0; i < sizeof(_titles); i++) {
      write(sprintf("%c) %s\n", i + 'A', _titles[i]));
   }
   write("Which title do you wish " +
         query_multiple_short(the_case->people) + " to have? ");
   input_to("choose_title", 0, area, the_case, type, finish);
}
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "set to a title of " + data[0] + " for " + data[1] + " hours";
}
void choose_title(string title, string area, class nomic_case the_case,
                 string type, function finish) {
   int i;
   int pos;
   if (!strlen(title) || title[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }
   title = lower_case(title);
   if (strlen(title) == 1) {
      pos = title[0] = 'a';
      if (pos >= 0 && pos < sizeof(_titles)) {
         title = _titles[pos];
      }
   }
   if (member_array(title, _titles) == -1) {
      write("You did not specify a valid title.\n");
      for (i = 0; i < sizeof(_titles); i++) {
         write(sprintf("%c) %s\n", i + 'A', _titles[i]));
      }
      write("What title do you want to give " +
            query_multiple_short(the_case->people) + "? ");
      input_to("choose_title", 0, area, the_case, type, finish);
      return ;
   }
   write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
         title +
         "(this is in hours and is online time, not real time)? ");
   input_to("choose_timeout", 0, area, the_case, type, finish, title);
}
void choose_timeout(string str, string area, class nomic_case the_case,
                 string type, function finish, string title) {
   int timeout;
   if (!strlen(str) || str[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }
   timeout = to_int(str);
   if (timeout <= 0) {
      write("The timeout must be greator than 0 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }
   if (timeout > 30) {
      write("The timeout must be less than 30 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }
   evaluate(finish, the_case, type, ({ title, timeout }));
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->set_forced_title_on_player(person, data[0], data[1] * (60 * 60));
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->remove_forced_title(person, data[0]);
   }
   return ;
}

==================================================
FILE: room/furniture/bank_franchise.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/bank_franchise";
#include <money.h>
#include <am_time.h>
#define SAVE_TIME 300
#define OBJECT_TAG "bank franchise"
#define MONTH_LENGTH (AM_SECONDS_PER_WEEK * 4)
private nosave int _maximum_total_difference;
private int _last_paid;
void create() {
   _maximum_total_difference = 4000;
   _last_paid = time();
   bank_franchise::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("bank");
   set_commercial_information("A franchise is connected up to a main "
          "bank.  You will pay a monthly fee to the main bank that is "
          "settable by the owner of the main bank.  The maximum balance "
          "of the bank counter is variable, but it is controlled at purchase "
          "time.  The bank balance and the float of the shop are tied "
          "together.");
   add_help_file("bank_franchise");
}
int query_player_bank() {
   return 1;
}
void set_maximum_total_difference(int max) {
   _maximum_total_difference = max;
}
int query_maximum_total_difference() {
   return _maximum_total_difference;
}
void set_last_paid(int paid) {
   _last_paid = paid;
}
int query_last_paid() {
   return _last_paid;
}
void adjust_account(string person, int amount) {
   adjust_float(amount);
}
object find_main_bank() {
   object office;
   object* obs;
   office = load_object(BANK_HANDLER->query_bank_master_office(query_bank_name()));
   if (!office) {
      return 0;
   }
   if (office->query_bank()) {
      return office;
   }
   obs = filter(office->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (!sizeof(obs)) {
      return 0;
   }
   return obs[0];
}
int can_adjust_account(string person, int amount) {
   int amt;
   amt = query_total_difference() + amount;
   if (amt < -query_maximum_total_difference()  ||
       amt > query_maximum_total_difference()) {
      if (amt < 0) {
         add_failed_mess("This bank does not have the funds to handle "
                            "your request.\n");
      } else {
         add_failed_mess("This bank does not have the vault space to handle "
                            "your request.\n");
      }
      return 0;
   }
   return ::can_adjust_account(person, amount);
}
string query_commercial_information() {
   string* bits;
   string bank;
   string place;
   place = previous_object()->query_money_place();
   bits = ({ });
   foreach (bank in BANK_HANDLER->query_banks()) {
      bits += ({ bank + " costs " +
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(bank), place) +
                 " per month and " +
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(bank), place) +
                 " to open" });
   }
   return ::query_commercial_information() +
          "This counter has a fixed maximum bank balance of " +
          MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
          ".  The costs of the franchises are " + query_multiple_short(bits) +
          ".";
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   set_percentage(percent);
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_open_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   return 1;
}
int is_allowed(string name) {
   return commercial::is_allowed(name);
}
void init() {
   bank_franchise::init();
   commercial::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
   }
}
string query_franchise() {
   return file_name(environment());
}
void event_save(object ob) {
   environment()->event_save(ob);
}
mapping query_commercial_options() {
   string bank;
   mapping ret;
   ret = ([ ]);
   foreach (bank in BANK_HANDLER->query_banks()) {
      ret[bank] = BANK_HANDLER->query_bank_default_cost_to_open(bank);
   }
   return ([ "branch" : ret ]);
}
void set_commercial_option(string type, string name, object room) {
   switch (type) {
   case "branch" :
      set_bank_name(name);
      BANK_HANDLER->add_new_franchise(name,
                                      file_name(room->query_main_room()));
      break;
   }
}
int query_monthly_fee() {
   return BANK_HANDLER->query_bank_franchise_cost_per_month(
             query_bank_name(), query_franchise());
}
int is_open_for(string type, string name) {
   if (query_monthly_fee() == -1) {
      return 0;
   }
   return ::is_open_for(type, name);
}
void setup_call_out() {
   int tim;
   if (!_last_paid) {
      _last_paid = time();
   }
   tim = _last_paid + MONTH_LENGTH - time();
   call_out("make_payment", tim);
}
void make_payment() {
   _last_paid += MONTH_LENGTH;
   adjust_float(-query_monthly_fee());
   setup_call_out();
}
string query_main_status(int hints) {
   string ret;
   string place;
   add_help_file("bank_franchise");
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n"
         "$I$6=   Bank Branch                  : " + query_bank_name() + "\n"
         "$I$6=   Revenue                      : " +
             MONEY_HAND->money_value_string(query_revenue(), place) + "\n"
           "$I$6=   Master Address               : " +
             BANK_HANDLER->query_bank_master_office(query_bank_name())->query_address() +
         "\n$I$6=   Maximum allowed bank balance : " +
             MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
         " (fixed)\n$I$6=   Bank Balance                 : " +
             MONEY_HAND->money_value_string(query_total_difference(), place) +
         "\n$I$6=   Credit Notes Outstanding     : " +
             MONEY_HAND->money_value_string(query_outstanding_credit_value(), place) + "\n";
   if (hints) {
      ret += "$I$6=     Hint: list credit notes\n";
      ret += "$I$6=     Hint: create credit note\n";
      ret += "$I$6=     Hint: recind credit note <id>\n";
   }
   ret += "$I$6=   Monthly Fee                  : " +
             MONEY_HAND->money_value_string(query_monthly_fee(), place) +
         " (set by bank owner)\n"
         "$I$6=   Next Pay Day                 : " +
             AM_TIME_HANDLER->query_am_time(_last_paid + MONTH_LENGTH) +
             " (" + ctime(_last_paid + MONTH_LENGTH) + ")\n"
         "$I$6=   Percentage                   : " +
             query_percentage() + "%"
         "\n$I$6=   Open account cost            : " +
             MONEY_HAND->money_value_string(query_account_cost(), place) +
       "\n";
   if (hints) {
      ret += "$I$6=     Hint: set open cost <amount> on <bank>\n";
   }
   return ret;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   add_auto_load_value(map, OBJECT_TAG, "notes", query_credit_notes());
   add_auto_load_value(map, OBJECT_TAG, "credit num", query_credit_num());
   add_auto_load_value(map, OBJECT_TAG, "last paid", query_last_paid());
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
   set_credit_notes(query_auto_load_value(map, OBJECT_TAG, "notes"));
   set_credit_num(query_auto_load_value(map, OBJECT_TAG, "credit num"));
   set_last_paid(query_auto_load_value(map, OBJECT_TAG, "last paid"));
   setup_call_out();
}
mixed* stats() {
   return bank_franchise::stats() + commercial::stats() + ({
          ({ "last paid", ctime(_last_paid) }) });
}

==================================================
FILE: room/furniture/bank_master.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/furniture/commercial";
nosave inherit "/std/shops/inherit/bank_master";
#define OBJECT_TAG "bank master"
private nosave string _place;
void create() {
  add_help_file("bank_master");
  commercial::create();
  bank_master::create();
  set_commercial_name("bank");
}
void event_save(object ob) {
   environment()->event_save(ob);
}
mixed *stats() {
  return commercial::stats() +
         bank_master::stats();
}
object find_bank_object(string franchise) {
   object* obs;
   object room;
   room = load_object(franchise);
   if (room->query_bank()) {
      return room;
   }
   obs = filter(room->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
int do_list_franchises() {
   string franchise;
   int pos;
   object bank_ob;
   string ret;
   string place;
   if (!sizeof(BANK_HANDLER->query_franchises(query_bank_name()))) {
      add_failed_mess("This bank has no franchises.\n");
      return 0;
   }
   place = query_money_place();
   ret = "Franchises:\n";
   foreach (franchise in BANK_HANDLER->query_franchises(query_bank_name())) {
      bank_ob = find_bank_object(franchise);
      ret += sprintf("$I$6=   %c %s Balance %s (cost per month %s)\n",
                      pos + 'A', franchise->the_short(),
                      MONEY_HAND->money_value_string(bank_ob->query_total_difference(), place),
                      MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_franchise_cost_per_month(query_bank_name(), franchise), place));
      pos++;
   }
   write("$P$Franchises$P$" + ret);
   return 1;
}
int do_set_franchise_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_to_open(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_default_monthly_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_per_month(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_main_bank_name(string new_name) {
   string* names;
   string name;
   if (query_bank_name()) {
      add_failed_mess("This bank already has a name.\n");
      return 0;
   }
   names = BANK_HANDLER->query_banks();
   foreach (name in names) {
      if (lower_case(name) == lower_case(new_name)) {
         add_failed_mess("There is already a bank called " +
                         name + ".\n");
         return 0;
      }
   }
   write("Do you really want to set the bank name to " + new_name +
         " (Make sure you have correct capitalisation)? ");
   input_to("check_bank_name", 0, new_name);
   add_succeeded_mess("");
   return 1;
}
void check_bank_name(string response, string new_name) {
   if (!strlen(response) || lower_case(response)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   write("You set the bank name to " + new_name + ".\n");
   BANK_HANDLER->create_new_bank(new_name, file_name(environment()));
   ::set_bank_name(new_name);
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   set_percentage(percent);
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_open_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   return 1;
}
int do_set_franchise_cost_per_month(string id, string amount) {
   string *franchises;
   int id_num;
   int amt;
   id = lower_case(id);
   if (strlen(id) != 1) {
      add_failed_mess("Must be one letter.\n");
      return 0;
   }
   franchises = BANK_HANDLER->query_franchises(query_bank_name());
   id_num = id[0] - 'a';
   if (id_num < 0 || id_num >= sizeof(franchises)) {
      add_failed_mess("The id of the franchises must be between 'A' and '" +
                      sprintf("%c", 'A' + sizeof(franchises) - 1) + ".\n");
      return 0;
   }
   amt = MONEY_HAND->value_from_string(amount, query_money_place());
   if (amt <= 0) {
      add_failed_mess("The amount " + amount + " is invalid.\n");
      return 0;
   }
   BANK_HANDLER->set_bank_franchise_cost_per_month(query_bank_name(),
               franchises[id_num], amt);
   add_succeeded_mess(({ "You set the cost per month for the franchise " +
                         franchises[id_num]->query_address() + " to " +
                         MONEY_HAND->money_value_string(amt, query_money_place()) + ".\n",
                         "" }));
   return 1;
}
string query_main_status(int hints) {
   string ret;
   string place;
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n";
   ret += "$I$6=   Bank Name             : " +
          query_bank_name() + "\n";
   ret += "$I$6=   Revenue               : " +
          MONEY_HAND->money_value_string(query_revenue(), place) + "\n";
   ret += "$I$6=   Cost to buy franchise : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set buy franchise cost <amount> on <object>\n";
   }
   ret += "$I$6=   Franchise cost per month : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set default franchise monthly cost <amount> on <object>\n";
   }
   ret += "$I$6=   Percentage            : " +
             query_percentage() + "%\n";
   if (hints) {
      ret += "$I$9=      Hint: set percentage <number> on <counter>\n";
   }
   ret += "$I$6=   Cost to open account  : " +
          MONEY_HAND->money_value_string(query_account_cost(), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set account cost <amount> on <object>\n";
   }
   ret += "$I$6=   Number of Franchises  : " +
          sizeof(BANK_HANDLER->query_franchises(query_bank_name())) + "\n";
   return ret;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
}
void init() {
   commercial::init();
   bank_master::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "bank name <string'name'> on <direct:object>",
                  (: do_set_main_bank_name($4[0]) :));
      add_command("set", "buy franchise cost <string'cost'> on <direct:object>",
                  (: do_set_franchise_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> on <direct:object>",
                  (: do_set_default_monthly_cost($4[0]) :));
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> for <string'franchise id'> on <direct:object>",
                  (: do_set_franchise_cost_per_month($4[1], $4[0]) :));
      add_command("list", "franchises on <direct:object>",
                  (: do_list_franchises :));
   }
}

==================================================
FILE: room/furniture/basic.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <room/placement.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
void create() {
  do_setup++;
  object::create();
  furniture_base::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  set_no_all(1);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
}

==================================================
FILE: room/furniture/bath.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/surface";
#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
int water = 0;
int dirt = 0;
string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});
void zap_bad_effects( object who );
int do_wash(object *indirect_obs );
void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
    add_help_file("bath");
}
string extra_look() {
    object *stuff;
    string answer = "";
    stuff = all_inventory( this_object() );
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " +
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n";
    }
   return answer;
}
string long_status() {
    return "";
}
void init(){
    ::init();
    add_command( "lie", "in <direct:object>");
    add_command( "sit", "in <direct:object>");
    add_command( "kneel", "in <direct:object>");
    add_command( "stand", "in <direct:object>");
    add_command( "leave", "<direct:object>");
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
}
int can_player_get_in_it() {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to get in it.\n");
      return 0;
    }
    if( environment( this_object() ) == this_player() ){
        this_object()->move(environment(this_player() ));
        tell_object(this_player(), "You drop the "+
            this_object()->short()+".\n");
        tell_room(environment(this_player()), this_player()->short()+" drops "
        "a "+this_object()->short()+".\n", this_player() );
    }
    return 1;
}
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {
            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}
void reset() {
    wet_everyone_in();
}
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}
int do_lie() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "lying") {
            tell_object(player, "You are already lying in the pool.\n" );
            return 1;
        }
        tell_object(player, "You lie in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" lies "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and lie down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and lies down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_sit() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "sitting") {
            tell_object(player, "You are already sitting in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You sit in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" sits "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and sit down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and sits down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "sitting" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_kneel() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player=this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "kneeling") {
            tell_object(player, "You are already kneeling in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You kneel in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" kneels "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and kneel down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and kneel down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "kneeling" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_stand() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player = this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "standing") {
            tell_object(player, "You are already standing in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You stand in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" stands "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + ".\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
void event_exit(object ob, string message, object to) {
  if (ob==this_player() && this_player()->query_position_on() == this_object()) {
    this_player()->return_to_default_position(1);
  }
}
int do_leave(){
    if (this_player()->query_position_on() == "the "+this_object()->short()) {
        this_player()->return_to_default_position(1);
        tell_object(this_player(), "You clamber out of the " + this_object()->short() + ".\n" );
        tell_room(environment(this_object()), this_player()->short()+" clambers "
            "out of the " + this_object()->short() + ".\n", this_player() );
    }
    else {
        tell_object(this_player(), "Umm... You're not in the " + this_object()->short() + " in the "
            "first place.\n" );
    }
    add_succeeded_mess( "", ({ }) );
    return 1;
}
int do_splash( object *indirect_obs ) {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to splash with it.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}
int do_wash( object *indirect_obs ) {
    if (!can_player_get_in_it()) {
        return 0;
    }
    if (this_player() -> query_position_type() != "in" &&
        this_player()->query_position_on() != "the "+this_object()->short()) {
      this_player()->add_failed_mess(this_object(), "You need to get "
                                     "into the " + this_object()->short() +
                                     " first.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
}
int query_baths() {
    return 1;
}
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    dirt++;
    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.writing.soap");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The rest of the words wash off without a single "
            "bubble in sight.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    if (!random(dirt)) {
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
}

==================================================
FILE: room/furniture/chime_inherit.c
==================================================

inherit "/std/object";
inherit "/std/room/furniture/inherit/furniture_base";
#include <weather.h>
#define TIME 120
string chimes_short();
string chimes_long();
void set_chime_type( string type );
string chime_type();
void jingle();
string chime_verb();
void add_chime_verb( string verb );
void remove_chime_verb( string verb );
string *query_chime_verbs();
void set_hung_up( int up );
int hung_up();
void set_hook( object hook );
object hook();
int do_hang( object hook );
int do_unhang();
private string _chime_type = "metal";
private string *_chime_verbs = ({ "jingles", "tinkles" });
private int _hung_up = 0;
private object _hook;
void create() {
   furniture_base::create();
   object::create();
}
void setup() {
  set_name( "chime" );
  set_short( (: chimes_short() :) );
  set_long( (: chimes_long() :) );
  add_adjective( ({ "wind", chime_type() }) );
  set_value( 420 );
}
void init() {
  add_command( "hang", "<direct:object'chime'> {on|from} "
      "<indirect:object'hook'>", (: do_hang( $1[0] ) :) );
  add_command( "unhang", "<direct:object'chime'>" );
}
string chimes_short() {
  return chime_type() + " wind chime";
}
string chimes_long() {
  return "This little wind chime is nothing more than bits of "
             + chime_type() + " dangling from strings tied to a "
             "ring.\n";
}
void set_chime_type( string type ) {
  remove_adjective( _chime_type );
  add_adjective( type );
  _chime_type = type;
}
string chime_type() { return _chime_type; }
void jingle() {
  object env = environment();
  int wind;
  if( !env )
    return;
  if( !hung_up() )
    return;
  if( !inherits( "/std/room", env ) )
    return;
  wind = env->query_wind_speed();
  if( undefinedp( wind ) ) {
    if( env->query_property( "location" ) == "outside" ||
        env->query_property( "windy" ) )
      wind = WEATHER->query_windsp( this_object() );
    else
      return;
  }
  if( random( wind ) )
    tell_room( env, the_short() + chime_verb() + " in the "
        "wind.\n" );
  call_out( "jingle", TIME );
}
string chime_verb() {
  return " " + _chime_verbs[ random( sizeof( _chime_verbs ) ) ];
}
void add_chime_verb( string verb ) {
  _chime_verbs += ({ verb });
}
void remove_chime_verb( string verb ) {
  _chime_verbs -= ({ verb });
}
void set_chime_verbs( string *verbs ) { _chime_verbs = verbs; }
string *query_chime_verbs() { return _chime_verbs; }
void set_hung_up( int up ) {
  remove_call_out( "jingle" );
  if( up )
    call_out( "jingle", 30 );
  _hung_up = up;
}
int hung_up() { return _hung_up; }
void set_hook( object hook ) { _hook = hook; }
object hook() { return _hook; }
int jingling() { return find_call_out( "jingle" ); }
void init_dynamic_arg( mapping arg ) {
  set_chime_type( arg[ "type" ] );
  set_chime_verbs( arg[ "chime verbs" ] );
  set_hook( arg[ "hook" ] );
  set_hung_up( arg[ "hung up" ] );
  if( undefinedp( hook() ) || !hung_up() ||
      !sizeof( match_objects_for_existence( hook(), ({ environment() }) ) ) ) {
    remove_property( "there" );
    set_hung_up( 0 );
  }
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "type" : chime_type(),
            "chime verbs" : query_chime_verbs(),
            "hung up" : hung_up(),
            "hook" : hook() ]);
}
int do_hang( object hook ) {
  string where = hook->a_short();
  if( hung_up() ) {
    add_failed_mess( "The chime is already hanging up.\n" );
    return 0;
  }
  if( !hook->query_hook() && !hook->query_property( "hook" ) )
    return 0;
  if( move( environment( this_player() ) ) )
    return 0;
  if( where )
    where = "on " + where;
  else
    where = "up";
  add_property( "there", "hanging "+ where );
  reset_get();
  set_hung_up( 1 );
  set_hook( hook );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D on "
      "$I.\n", ({ hook }) );
  return 1;
}
int do_unhang() {
  if( !hung_up() ) {
    add_failed_mess( "The chime isn't hanging from anything.\n" );
    return 0;
  }
  remove_property( "there" );
  set_get();
  set_hung_up( 0 );
  move( this_player() );
  return 1;
}

==================================================
FILE: room/furniture/clock.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/obj/clock";
inherit "/std/room/furniture/inherit/furniture_base";
void chime(string mess) {
  int *co_ords;
  if(environment(this_object())) {
    co_ords = (int *)environment(this_object())->query_co_ord();
    "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
                                                 mess, 20, 1, 0 );
    tell_room(environment(this_object()), mess);
  }
}
void create() {
   do_setup++;
   clock::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   furniture_base::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
}
private int do_real_move(mixed dest, string messin, string messout) {
   return clock::move(dest, messin, messout);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}

==================================================
FILE: room/furniture/commercial.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <money.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
string query_main_status(int hints);
private nosave int _commercial_size;
private nosave string _commercial_type;
private nosave string _commercial_name;
private nosave string* _use_types;
private nosave string _info;
private int _revenue;
private int _weekly_revenue;
private int _commercial_id;
private int _weekly_upkeep_cost;
#define OBJECT_TAG "commercial inh"
void create() {
   _commercial_size = 100;
   if (!_use_types) {
      _use_types = ({ });
   }
   do_setup++;
   object::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
   reset_get();
}
void set_weekly_upkeep_cost(int cost) {
   _weekly_upkeep_cost = cost;
}
int query_weekly_upkeep_cost() {
   return _weekly_upkeep_cost;
}
int query_revenue() {
   return _revenue;
}
void set_revenue(int revenue) {
   _revenue = revenue;
}
string query_save_dir() {
   return environment()->query_save_dir();
}
string query_owner() {
  return environment()->query_owner();
}
string query_language() {
  return environment()->query_language();
}
string query_money_place() {
   if (!environment()) {
      return "default";
   }
   return environment()->query_property("place");
}
int is_allowed(string person) {
   return environment()->is_allowed(person);
}
string query_allowed() {
   return environment()->query_allowed();
}
int query_float() {
   return environment()->query_royalty(query_owner());
}
int query_royalty(string person) {
   return environment()->query_royalty(person);
}
int adjust_royalty(string person, int amount) {
   if (person == query_owner()) {
      _revenue += amount;
      _weekly_revenue += amount;
   }
   environment()->adjust_royalty(person, amount);
}
int adjust_float(int amt) {
   adjust_royalty(query_owner(), amt);
}
int is_open_for(string type, string person) {
   if (!environment()->query_commercial_property()) {
      return 0;
   }
   return environment()->is_open_for(type, person);
}
void set_commercial_size(int size) {
   _commercial_size = size;
}
string query_commercial_type() {
   return _commercial_type;
}
void set_commercial_type(string type) {
   _commercial_type = type;
}
void set_commercial_information(string info) {
   _info = info;
}
string query_commercial_information() {
   return _info;
}
void set_commercial_name(string name) {
   _commercial_name = name;
}
string query_commercial_name() {
   return _commercial_name;
}
int query_commercial_size() {
   return _commercial_size;
}
int query_commercial_id() {
   return _commercial_id;
}
void setup_new_commercial_id() {
   _commercial_id = environment()->find_next_commercial_id();
}
void set_commercial_id(int id) {
   _commercial_id = id;
}
string query_parcel_post() {
   return environment()->query_parcel_post();
}
void set_shop_use_types(string* types) {
   _use_types = types;
}
string* query_shop_use_types() {
   return _use_types;
}
void reset_weekly_status() {
   _weekly_revenue = 0;
}
string query_weekly_status_string() {
   string ret;
   string place;
   place = query_money_place();
   if (query_weekly_upkeep_cost()) {
      ret = "Weekly Upkeep : " +
            MONEY_HAND->money_value_string(_weekly_upkeep_cost, place) + "\n" +
            "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n" +
            "Profit        : " +
            MONEY_HAND->money_value_string(_weekly_revenue - _weekly_upkeep_cost, place) + "\n";
   } else {
      ret = "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n";
   }
   return ret;
}
int can_trash_furniture() {
   return 1;
}
int query_commercial_furniture() {
   return 1;
}
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   int t;
   int f;
   object from;
   if(stringp(dest)) {
      dest = find_object(dest);
   }
   if (!move_check(dest)) {
      write(the_short() + " resists being picked up and shocks you slightly.\n");
      return MOVE_INVALID_DEST;
   }
   if(!dest) {
      return MOVE_INVALID_DEST;
   }
   if(living(dest)) {
      t = (int)this_object()->query_complete_weight() * 5;
      if(!(dest->add_weight(t))) {
         return MOVE_TOO_HEAVY;
      }
      debug_printf("Added %d", t);
   }
   from = environment();
   i = ::move(dest, messin, messout);
   if(i != MOVE_OK) {
      dest->add_weight(-t);
      return i;
   }
   if(from && living(from)) {
      f = (int)this_object()->query_complete_weight() * 5;
      from->add_weight(-f);
   }
   if (from) {
      from->remove_commercial_thing(this_object());
   }
   dest->add_commercial_thing(this_object());
   dest->register_use_types(_use_types);
   return i;
}
int get(mixed dest) {
   if(!move_check(dest)) {
      write("You feel it would be wrong to take " + the_short() + ".\n");
      return 2;
   }
   return ::get(dest);
}
int do_status(int hint) {
   string ret;
   ret = query_main_status(hint);
   write("$P$Status$P$" + ret);
   add_succeeded_mess("$N get$s the status of $D.\n");
   return 1;
}
int do_reset() {
   string place;
   int old_revenue;
   place = query_money_place();
   old_revenue = _revenue;
   _revenue = 0;
   add_succeeded_mess("$N clear$s the revenue of " +
                      MONEY_HAND->money_value_string(old_revenue, place) +
                      " on $D.\n");
   return 1;
}
void init() {
   ::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>", (: do_status, 0 :));
      add_command("status", "hints <direct:object>", (: do_status, 1 :));
      add_command("status", "hint <direct:object>", (: do_status, 1 :));
      add_command("reset", "revenue on <direct:object>", (: do_reset :));
   }
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   add_auto_load_value(junk, OBJECT_TAG, "revenue", query_revenue());
   add_auto_load_value(junk, OBJECT_TAG, "commercial id", query_commercial_id());
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   if (map) {
      set_bonded(map["bonded"]);
      set_revenue(query_auto_load_value(map, OBJECT_TAG, "revenue"));
      if (query_auto_load_value(map, OBJECT_TAG, "commercial id")) {
         set_commercial_id(query_auto_load_value(map, OBJECT_TAG, "commercial id"));
      }
   }
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "revenue", query_revenue() }),
             ({ "bonded", query_bonded() }),
             ({ "commercial id", query_commercial_id() }) });
}

==================================================
FILE: room/furniture/curtains.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/std/room/furniture/basic";
private nosave object _window;
private string _window_id;
private string _window_old_long;
void create() {
  do_setup++;
  ::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if ( !query_property( "shop type" ) ) {
    add_property( "shop type", "furniture" );
  }
  set_allowed_room_verbs((["hanging" : "hangs" ]));
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
}
void init() {
  if(!_window_id) {
    this_player()->add_command("hang", this_object(),
        "<direct:object> [on|at] <indirect:object:here>");
  }
  this_player()->add_command("open", this_object(), "<direct:object>");
  this_player()->add_command("close", this_object(), "<direct:object>");
}
int do_open() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already open.\n");
    return 0;
  }
  _window->set_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_close() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(!_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already closed.\n");
    return 0;
  }
  _window->reset_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_hang(mixed *in_dir, string direct, string indirect, mixed *args) {
  if(member_array("window", in_dir[0]->parse_command_id_list()) == -1) {
    this_player()->add_failed_mess(this_object(),
        "You can only $V $D at windows.\n",
        ({ }));
    return 0;
  }
  if(this_object()->move(environment(this_player())) != MOVE_OK) {
    this_player()->add_failed_mess(this_object(),
        "You seem to be unable to $V $D "
        "at $I.\n", ({ in_dir[0] }));
    return 0;
  }
  this_object()->add_property("current room hidden", 1);
  _window_id = in_dir[0]->query_my_id();
  _window_old_long = in_dir[0]->query_long();
  in_dir[0]->set_long(in_dir[0]->query_long()+"It has " +
                      this_object()->query_short() +
                      " hanging round it.\n");
  event(environment(), "save", this_object());
  this_player()->add_succeeded_mess(this_object(),
                                   "$N $V $D at $I.\n", ({ in_dir[0] }));
  return 1;
}
void removed() {
  this_object()->remove_property("current room hidden");
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  _window->set_long(_window_old_long);
  _window->set_transparent();
  _window_id = 0;
}
int query_furniture() { return 1; }
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load() +
      ([ "window" : _window_id,
       "window_old_long" : _window_old_long ]);
  return ([ "window" : _window_id,
          "window_old_long" : _window_old_long ]);
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) {
    return;
  }
  ::init_static_arg(map);
  if ( !undefinedp( map[ "window" ] ) )
    _window_id = map["window"];
  if(!undefinedp(map["window_old_long"]))
    _window_old_long = map["window_old_long"];
}

==================================================
FILE: room/furniture/dividor.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room.h>
#define SIZE_OF_FURNITURE 5
#define TAG "dividor"
#define TEMPLATE_DIVIDOR_ROOM "/mudlib/data/dividor_template.c"
private int _size;
private string _exit_direction;
private string _our_room;
int query_furniture_size() {
   return _size + SIZE_OF_FURNITURE;
}
int query_commercial_id() {
   if (!::query_commercial_id()) {
      setup_new_commercial_id();
   }
   return ::query_commercial_id();
}
string query_exit_direction() {
   return _exit_direction;
}
string query_exit_destination() {
   return _our_room;
}
int create_room() {
   string path;
   string *bits;
   string room_path;
   string stuff;
   path = environment()->query_save_dir();
   path += "/division" + query_commercial_id();
   if (file_size(path) == -2) {
      mkdir(path);
   }
   bits = explode(base_name(environment()), "/");
   room_path = implode(bits[0..<2], "/");
   room_path += "/" + bits[<1] + "_dividor";
   if (file_size(room_path) == -2) {
      mkdir(room_path);
   }
   room_path += "/" + query_commercial_id();
   if (file_size(room_path + ".c") > 0) {
      return 0;
   }
   _our_room = room_path;
   stuff = "inherit \"/std/room/furniture/dividor_room\";\n\n"
           "void setup() {\n"
           "   set_base_desc(\"" + environment()->query_base_desc() + "\");\n"
           "   set_main_room(\"" + base_name(environment()) + "\");\n"
           "   set_save_dir(\"" + path + "\");\n"
           "   set_theft_handler(\"" + environment()->query_theft_handler() + "\");\n"
           "   add_exit(\"" + ROOM_HANDLER->query_opposite_direction(query_exit_direction()) + "\", \"" + base_name(environment() + "\", \"door\");\n"
           "   set_property_size(" + _size + ");\n"
           "   add_property(\"place\", \"" + environment()->query_property("place") + "\");\n"
           "}";
   write_file(room_path + ".c", stuff, 1);
   return 1;
}
void add_exit_to_room() {
   environment()->add_exit(query_exit_direction(), query_exit_destination(), "door");
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, TAG, "exit", _exit_direction);
   add_auto_load_value(map, TAG, "room", _our_room);
   add_auto_load_value(map, TAG, "size", _size);
   return map;
}
void init_dynamic_arg(mapping map) {
   _exit_direction = query_auto_load_value(map, TAG, "exit");
   _our_room = query_auto_load_value(map, TAG, "room");
   _size = query_auto_load_value(map, TAG, "size");
   ::init_dynamic_arg(map);
}

==================================================
FILE: room/furniture/dividor_room.c
==================================================

inherit "/std/shops/commercial";
private string _main_room;
void set_main_room(string room) {
   _main_room = room;
}
string query_main_room() {
   return _main_room;
}
string query_parcel_post() {
   return _main_room->query_parcel_post();
}

==================================================
FILE: room/furniture/document_handler.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/room/furniture/inherit/document_handler";
#include <room/document_handler.h>
void create() {
   document_handler::create();
   commercial::create();
   add_help_file("document_handler");
   set_shop_use_types( ({ "document_view",
                          "document_add",
                          "document_delete" }) );
}
string query_save_dir() {
   return commercial::query_save_dir() + "/" + query_commercial_id();
}
void load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }
   if (unguarded( (: file_size(query_save_dir()) :) ) != -2) {
      unguarded( (: mkdir(query_save_dir()) :));
   }
}
void save_me() {
   environment()->event_save(this_object());
}
void init() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   document_handler::query_dynamic_auto_load(map);
   return map;
}
void init_dynamic_arg(mapping map) {
   document_handler::init_dynamic_arg(map);
   commercial::init_dynamic_arg(map);
}

==================================================
FILE: room/furniture/fireplace.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
#define WIZARD "/std/guilds/wizard"
#define CMD "/cmds/"
#define BURN_PER_TICK   1
#define BRIGHT 30
#define K      1
inherit "/std/room/furniture/surface";
private nosave int _light_produced;
private nosave int _is_lit;
private nosave int _frequency;
private nosave string _lit_mess;
private nosave string _unlit_mess;
private nosave string *_lit_chats;
private nosave string *_dying_chats;
private nosave string _turn_on_mess;
private nosave string _turn_off_mess;
private nosave string _out_of_fuel_mess;
void set_light_produced(int b);
void set_lit_mess(string str);
void set_unlit_mess(string str);
void set_frequency(int i);
void set_lit_chats(string *str);
void add_lit_chat(string str);
string request_lit_chat();
void set_dying_chats(string *str);
void add_dying_chat(string str);
string request_dying_chat();
void set_turn_on_mess(string mess);
void set_turn_off_mess(string mess);
void set_out_of_fuel_mess(string mess);
int do_light(object *obs);
int do_zap();
int turn_on();
int do_dowse(object *obs);
int turn_off();
int calc_fuel();
void create() {
  do_setup++;
  surface::create();
  do_setup--;
  set_name("fireplace");
  add_alias( ({ "fireplace", "furniture", "hearth", "fire" }) );
  add_plural( "fireplaces" );
  add_property( "shop type", "furniture" );
  add_property( "degrees", 0 );
  set_light_produced( BRIGHT );
  set_lit_mess("A fire blazes happily in the hearth, providing "
      "a soft red glow and pleasant warmth. It crackles and spits "
      "occasionally, giving the room that homely feel.\n");
  set_unlit_mess("The hearth is blackened with ashes and old embers.\n");
  set_frequency(5);
  set_lit_chats( ({
      "The fire crackles and spits cheerfully.",
      "The warm fire soothes your weariness.",
      "An enchanting orange glow radiates from the hearth.",
      "Small glowing embers dance over the fire.",
      "The fire blazes in the grate." }) );
  set_dying_chats( ({
      "The fire splutters.",
      "The warm red glow flickers.",
      "A whisp of smoke from the fire trails around the room." }) );
  set_turn_on_mess("Soon a roaring fire is blazing in the grate.\n");
  set_turn_off_mess("The embers smoke slightly and their glow dims.\n");
  set_out_of_fuel_mess("The fire flickers and dies away.\n");
  if ( !do_setup ) {
      this_object()->setup();
  }
  this_object()->add_extra_look( this_object() );
  add_help_file("fireplace");
}
void init() {
  this_player()->add_command("light", this_object(), "<direct:object> with <indirect:object>");
  this_player()->add_command("extinguish", this_object(), "<direct:object>", (: do_dowse :) );
  this_player()->add_command("dowse", this_object(), "<direct:object>");
  if( this_player()->query_guild_ob() == WIZARD ){
    this_player()->add_command("zap", this_object(), "<direct:object>");
    this_player()->add_command("point", this_object(), "[finger] at <direct:object>", (: do_zap :) );
  }
}
int query_fuel_left(){  return calc_fuel();  }
void set_light_produced(int b){  _light_produced = b;  }
int query_light_produced(){  return _light_produced;  }
void set_frequency(int i){  _frequency = i + 1;  }
int query_frequency(){  return _frequency;  }
int do_light(object *obs){
  string q_n;
  q_n = obs[0]->query_name();
  if( _is_lit ){
    this_player()->add_failed_mess( this_object(),
         "$D is already ablaze.\n", ({ }) );
    return 0;
  }
  if( q_n != "flint" && q_n != "match" && q_n != "lighter" ){
    this_player()->add_failed_mess(this_object(),
         "You can't light $D with $I.\n", ({ obs[0] }) );
    return 0;
  }
  if( this_player()->query_dex() < random(18) ){
    this_player()->add_failed_mess(this_object(),
      "You strike $I, but can't quite get the spark to catch.\n", ({ obs[0] }) );
    return 0;
  }
  if ( calc_fuel() <= 0 ) {
    this_player()->add_failed_mess( this_object(),
        "There is nothing in the fireplace to burn.\n", ({ }) );
    return 0;
  }
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D with $I.\n", ({ obs[0] }) );
  return turn_on();
}
int do_zap(){
  object tp;
  tp = this_player();
  if(tp->query_gp() < 10){
    tell_object(tp, "You don't even have the energy for such a small task!\n");
    return 1;
  }
  if(_is_lit){
    tell_object(tp, "There is already a merry fire burning in the fireplace.\n");
    return 1;
  } else {
    tp->add_succeeded_mess(this_object(),
      "$N extend$s an arm towards $D.\nA small fireball leaps from $p "
      "index finger and throws itself onto the hearth.\n", ({ }) );
    tp->adjust_gp( -10 );
    return turn_on();
  }
}
void set_turn_on_mess(string mess){  _turn_on_mess = mess;  }
string query_turn_on_mess(){  return _turn_on_mess;  }
void set_turn_off_mess(string mess){  _turn_off_mess = mess;  }
string query_turn_off_mess(){  return _turn_off_mess;  }
void msg_on(){
  if(_is_lit){
    tell_room(environment( this_object() ), query_turn_on_mess() );
  }
}
int turn_on(){
  int x;
  FUEL_HANDLER->add_burner( this_object() );
  _is_lit = 1;
  adjust_light( query_light_produced() );
    x = query_light_produced() / 4;
    add_property("degrees", query_light_produced() * 4);
    environment( this_object() )->add_property("warmth", x );
  call_out( "msg_on", 7 );
  return 1;
}
int do_dowse(object *obs){
  if( !_is_lit ){
    this_player()->add_failed_mess( this_object(),
         "There is no fire to put out.\n", ({ }) );
    return 0;
  } else {
    this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and the room loses its warm glow.\n", ({ }) );
    return turn_off();
  }
}
void msg_off() {
  if(!_is_lit){
    tell_room(environment( this_object() ), query_turn_off_mess() );
  }
}
int turn_off(){
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
  adjust_light( -query_light_produced() );
  add_property( "degrees", 0 );
  environment( this_object() )->remove_property("warmth");
  call_out( "msg_off", 10 );
  return 1;
}
void set_out_of_fuel_mess(string mess){  _out_of_fuel_mess = mess;  }
string query_out_of_fuel_mess(){  return _out_of_fuel_mess;  }
void out_of_fuel() {
  turn_off();
  tell_room(environment( this_object() ), query_out_of_fuel_mess() );
}
void set_lit_chats(string *str){  _lit_chats = str;  }
void add_lit_chat(string str){
  if( !_lit_chats ){
    _lit_chats = ({ });
  }
  _lit_chats += ({ str });
}
string request_lit_chat(){
  return _lit_chats[random( sizeof(_lit_chats) - 1 )];
}
void set_dying_chats(string *str){  _dying_chats = str;  }
void add_dying_chat(string str){
  if( !_dying_chats ){
    _dying_chats = ({ });
  }
  _dying_chats += ({ str });
}
string request_dying_chat(){
  return _dying_chats[random( sizeof(_dying_chats) - 1 )];
}
void set_lit_mess(string str){  _lit_mess = str;  }
string query_lit_mess(){  return _lit_mess;  }
void set_unlit_mess(string str){  _unlit_mess = str;  }
string query_unlit_mess(){  return _unlit_mess;  }
void consume_fuel() {
  int x;
  int q;
  int z;
  int w;
  int amount;
  string r;
  object *inv;
  object ashes;
  object thing;
  object env;
  inv = filter(all_inventory( this_object() ),
              (:$1->query_property("fuel") :));
  if( !inv || inv == ({ }) || calc_fuel() < 1){
    out_of_fuel();
    return;
  }
  x = sizeof(inv);
  foreach(thing in inv){
      q = thing->query_amount_left();
      w = thing->query_weight();
      z = q - ( ( BURN_PER_TICK * 100 / x ) / w );
      if ( z < 1 ){
          thing->move("/room/rubbish");
          amount = roll_MdN(4, 20);
          ashes = clone_object("/obj/cont_medium");
          ashes->set_name("ash");
          ashes->set_short("fine grey ash");
          ashes->add_property("determinate", "some ");
          ashes->add_adjective(({"some", "fine", "grey", "pinch", "pinches",
           "handful", "handfuls", "bucketful", "bucketfuls", "of"}));
          ashes->add_plural("ash");
          ashes->set_long("This is $pile_size$ of fine grey ash, "
            "$amount_size$. It looks like it was the leftovers "
            "from someone's camp fire.\n");
          ashes->set_weight_unit(({ 1, 50 }));
          ashes->set_medium_alias("FiNeGrEyAsH");
          ashes->set_amount_types((["pinch" : ({1, "pinches"}),
           "handful" : ({50, "handfuls"}),
           "bucketful" : ({1000, "bucketfuls"})]));
          ashes->set_pile_types(({50, "small", 100, "medium",
            200, "large", "huge"}));
          ashes->set_continuous();
          ashes->set_amount(amount);
          ashes->move(this_object());
      } else {
        thing->set_amount_left( z );
      }
  }
  calc_fuel();
  env = environment( this_object() );
  if( random( query_frequency() ) == 1 ){
    if( calc_fuel() > 10 ){
      r = request_lit_chat();
      tell_room( env, r + "\n");
    } else {
      r = request_dying_chat();
      tell_room( env, r + "\n");
    }
  }
}
int calc_fuel(){
  object *inv;
  object thing;
  int tot_fuel = 0;
  int w;
  int amt;
  inv = all_inventory( this_object() );
  if( !inv || inv == ({ }) ) { return 0; }
  foreach(thing in inv){
    if( thing->query_property("fuel") ){
      w =  thing->query_weight();
      amt = thing->query_amount_left();
      tot_fuel += w * amt * K / 100 ;
    }
  }
  return tot_fuel;
}
int test_remove( object thing, int flat, mixed dest){
  object tp;
  object *prev;
  tp = this_player();
  prev = previous_object(-1);
  if(_is_lit && tp && strsrch( file_name(prev[1]), CMD ) != -1 ){
    tell_object(tp, "You reach out towards the fire but "
       "you can't brave the flames and quickly pull away.\n");
    tell_room( environment(tp), tp->query_short() + " tries to take something "
      "from the fire but pulls back sucking " + tp->query_possessive() +
      " fingers.\n", tp);
    tp->adjust_hp( -random(120) );
    return 0;
  }
  return ::test_remove(thing, flat, dest);
}
int test_add( object thing, int flag ) {
  if( !thing->query_property("fuel") && environment(thing) ){
    tell_object(this_player(), "You don't think " + thing->the_short() +
      " would be a suitable fuel.\n");
    return 0;
  }
  if( _is_lit ){
    tell_room(environment( this_object() ),
      ({ "The fire crackles.\n",
         "A shower of glowing embers tumble around the hearth.\n" })[random(2)] );
  }
  call_out("calc_fuel",1);
  return 1;
}
string extra_look( object ob ){
  if( _is_lit ) {
      return query_lit_mess();
  }
  else {
      return query_unlit_mess();
  }
}
void pre_dest_me() {
  int tmp;
  if(_is_lit && environment()) {
    FUEL_HANDLER->remove_burner( this_object() );
    _is_lit = 0;
    adjust_light( -query_light_produced() );
    tmp = environment()->query_property("warmth");
    if(tmp > query_light_produced() / 4)
      environment()->add_property("warmth", tmp -
                            (query_light_produced() / 4));
    else
      environment()->remove_property("warmth");
  }
  return;
}
void dest_me() {
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
   ::dest_me();
}

==================================================
FILE: room/furniture/fireplace_inherit.c
==================================================

inherit "/std/room/furniture/fireplace";

==================================================
FILE: room/furniture/fuel_inherit.c
==================================================

inherit "/std/object";
private nosave int _amount;
private nosave string *_shorts;
private nosave string *_longs;
string fuel_short();
string fuel_long();
void create(){
   ::create();
   if(!_amount){
     _amount = 100;
   }
   set_short( (: fuel_short :) );
   set_long( (: fuel_long :) );
   add_property("no recycling", 1);
   add_property("fuel", 1);
}
void set_amount_left(int i){  _amount = i;  }
void adjust_amount_left(int i){  _amount += i;  }
int query_amount_left(){  return _amount;  }
void set_shorts(string *desc){  _shorts = desc;  }
void set_longs(string *desc){  _longs = desc;  }
string fuel_short(){
   int i;
   int x;
   x = sizeof(_shorts);
   for(i = 1; i <= x; i++){
      if( (_amount + 1) > 100 - ( i * 100 / x ) ){
         return _shorts[(i-1)];
      }
   }
   return "fuel";
}
string fuel_long(){
   int i;
   int x;
   x = sizeof(_longs);
   for(i = 1; i <= x; i++){
      if( ( _amount + 1 ) > ( 100 - ( i * 100 / x )) ){
         return _longs[(i-1)];
      }
   }
   return "fuel";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "amount" : _amount
          ]);
}
void init_dynamic_arg(mapping arg) {
   _amount = arg[ "amount" ];
   ::init_dynamic_arg(arg["::"]);
}

==================================================
FILE: room/furniture/furniture.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
private nosave object *_on_top;
private nosave int _has_surface;
#define DEBUG
void create() {
  do_setup++;
  ::create();
  _drawer_mess = "a drawer in $ob_short$";
  _drawers = ({ });
  _on_top = ({ });
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if (!query_property("shop type"))
    add_property( "shop type", "furniture" );
   do_setup--;
   if(!do_setup)
     this_object()->setup();
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
int query_has_surface() { return _has_surface; }
void set_has_surface(int i) { _has_surface = i; }
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   if(sizeof(_on_top))
     ret += query_contents( "On " + the_short() + " " +
                            (sizeof(_on_top) == 1 ? "is " : "are " ), _on_top);
   return ret;
}
varargs string query_contents( string start, object *things,
  int ignore_living) {
  if(!arrayp(things)) {
    things = this_object()->find_inv_match( "", this_player() );
    things -= ({ this_player() });
    things = filter_array( things, (: environment( $1 ) == this_object() :) );
    things -= _on_top;
  }
  return ::query_contents(start, things, ignore_living);
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  result = ::test_remove(thing, flag, dest);
  if(result) {
    stuff = thing->query_property("dropped");
    if(environment() &&
       dest == this_player() &&
       function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(this_player()->query_name()) &&
       (!sizeof(stuff) || stuff[0] != this_player()->query_name())) {
      event(environment(this_player()), "theft", this_player(), this_object(),
            ({ thing }));
    }
    if(dest) {
      _on_top -= ({ thing });
      thing->remove_property("_on_top");
    }
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  int result;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  result = ::test_add(thing, flag);
  if(!result)
    return 0;
  if("/cmds/living/put"->query_con() == "on" && _has_surface) {
    _on_top += ({ thing });
    thing->add_property("_on_top", 1);
  } else if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  return result;
}
int pick_unlock(object player) {
  mixed owner;
  if(!environment())
    return ::pick_unlock(player);
  if(!environment() || !function_exists("query_owner", environment()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions( map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
void init_dynamic_arg(mapping bing) {
  object item;
  ::init_dynamic_arg(bing);
  foreach(item in all_inventory(this_object())) {
    if(item->query_property("_on_top"))
      _on_top += ({ item });
  }
}
string query_help_file_directory() {
  return "/doc/furniture/";
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  ret += ({ ({ "surface", _has_surface }) });
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}

==================================================
FILE: room/furniture/mirror.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/basic";
int _in_extra;
void create(){
	::create();
	add_extra_look(this_object());
}
string extra_look(object ob) {
	int dark;
	object env;
	env = environment(ob);
	if(living(env))
		return "You can see yourself in the mirror.";
	dark = (int) this_player()->check_dark((int)env->query_light());
	if(dark)
		return "It is too dark to see much in the room.";
	return "Reflected in the mirror is " +
		query_multiple_short(all_inventory(env) - ({ ob }), "a", 0, 1, dark) +
		".";
}

==================================================
FILE: room/furniture/poker.c
==================================================

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";
#include <money.h>
#include <room/card_base.h>
#define HAND_TYPE_HIGH_CARD  1
#define HAND_TYPE_PAIR       2
#define HAND_TYPE_TWO_PAIR   3
#define HAND_TYPE_THREE      4
#define HAND_TYPE_STRAIGHT   5
#define HAND_TYPE_FLUSH      6
#define HAND_TYPE_FULL_HOUSE 7
#define HAND_TYPE_FOUR       8
#define HAND_TYPE_STRAIGHT_FLUSH 9
#define POKER_STATE_ANTE      0
#define POKER_STATE_PAID_ANTE 1
#define POKER_STATE_DEALT     2
#define POKER_STATE_BET       3
#define POKER_STATE_DISCARD   4
#define POKER_STATE_AFTER_DISCARD   5
#define POKER_STATE_FINAL_BET 6
#define POKER_STATE_FOLDED    7
#define POKER_STATE_END       8
#define TIE -1
class hand_type {
   int hand_type;
   class playing_card* kickers;
   class playing_card duplicate_1;
   class playing_card duplicate_2;
   class playing_card high_card;
}
class player_data {
   class playing_card* hand;
   class hand_type hand_type;
   int bet;
   int state;
}
#define BOARD_TAG "poker"
private int _return;
private int _ante_amount;
private int _ante_house;
private int _house_cut;
private int _min_bet;
private int _max_bet;
private int _current_bet;
private int _pot;
private int _finished;
private int _poker_phase;
private int _turn_timeout;
private int _draw_round;
private int _max_draw_rounds;
private class playing_card* _deck;
private class playing_card* _discard;
private mapping _player_stats;
int query_hand_value(class playing_card* cards);
class hand_type query_hand_type(class playing_card* hand);
void create() {
   multiplayer_base::create();
   set_minimum_needed(2);
   add_help_file("poker");
   _ante_house = 400;
   _ante_amount = 400;
   _min_bet = 400;
   _max_bet = 1200;
   _max_draw_rounds = 1;
   _player_stats = ([ ]);
   set_shop_use_types(({ "poker" }));
   commercial::create();
   set_commercial_type("gambling");
   set_commercial_name("poker");
}
string query_hand_type_string(class hand_type bing) {
   string ret;
   switch (bing->hand_type) {
   case HAND_TYPE_FULL_HOUSE :
      ret = "Full house";
      break;
   case HAND_TYPE_THREE :
      ret = "Three of a kind";
      break;
   case HAND_TYPE_FLUSH :
      ret = "Flush";
      break;
   case HAND_TYPE_STRAIGHT :
      ret = "Straight";
      break;
   case HAND_TYPE_STRAIGHT_FLUSH :
      ret = "Straight flush";
      break;
   case HAND_TYPE_PAIR :
      ret = "Pair";
      break;
   case HAND_TYPE_FOUR :
      ret = "Four of a kind";
      break;
   case HAND_TYPE_TWO_PAIR :
      ret = "Two pairs";
      break;
   case HAND_TYPE_HIGH_CARD :
      ret = "High card " + query_card_string(bing->high_card);
      break;
   default :
      ret = "Nothing";
      break;
   }
   return ret;
}
string query_card_status(string id) {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   string* womble;
   string place;
   int left;
   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = query_money_place();
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing)) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->state == POKER_STATE_FOLDED) {
               ret += " Folded!\n";
            } else {
               if (data->state == POKER_STATE_PAID_ANTE) {
                  ret += " (paid ante) ";
               }
               if (data->state == POKER_STATE_AFTER_DISCARD) {
                  ret += " (discarded) ";
               }
               if (data->state == POKER_STATE_BET ||
                   data->state == POKER_STATE_FINAL_BET) {
                  if (id_bing == query_current_player()) {
                     ret += " <-- Their bet ";
                  }
               }
               if (data->bet) {
                  ret += "  Current bet " +
                         MONEY_HAND->money_value_string(data->bet, place);
                  ret += "\n";
               } else {
                  ret += "  No bet yet.\n";
               }
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }
   if (sizeof(not_playing) > 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " are not playing.\n";
   } else if (sizeof(not_playing) == 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " is not playing.\n";
   }
   ret += "The pot is " +
          MONEY_HAND->money_value_string(_pot, place) + ".\n";
   if (is_game_started()) {
      if (_draw_round < _max_draw_rounds) {
         left = _max_draw_rounds - _draw_round;
         ret += left + " draw round" + (left>1?"s":"") + " left.\n";
      }
   }
   ret += "\n";
   if (id) {
      if (!_finished) {
         data = query_player_data(id);
         if (data && sizeof(data->hand)) {
            ret += "Your hand (" +
                   query_hand_type_string(data->hand_type) +
                   (data->state == POKER_STATE_FOLDED?" -- Folded":"") +
                   "):\n";
            if (data->state != POKER_STATE_FOLDED) {
               ret += query_hand_string(data->hand,
                                     CARD_HAND_THREE|CARD_HAND_LETTERS,
                                     this_player()->query_cols());
            }
         }
         if (_finished) {
            tell_all_players(query_player_cap_name(id) + " peeks at their hand on " +
                         the_short() + ".\n", ({ id }));
         }
      } else {
         foreach (id in query_started_player_ids()) {
            data = query_player_data(id);
            if (data && sizeof(data->hand)) {
               ret += query_player_cap_name(id);
               if (data->state == POKER_STATE_FOLDED) {
                  ret += " folded, so the cards are hidden.\n";
               } else {
                  ret += " hand (" +
                         query_hand_type_string(data->hand_type) + ":\n";
                  ret += query_hand_string(data->hand, CARD_HAND_SINGLE,
                                        this_player()->query_cols());
               }
            }
         }
      }
   }
   return ret;
}
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status(find_player_id_of_person(this_player()));
}
int check_end_round() {
   int bet;
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         if (!data->bet) {
            return 0;
         } else if (!bet && data->bet) {
            bet = data->bet;
         } else if (bet != data->bet) {
            return 0;
         }
      }
   }
   if (bet) {
      call_out("complete_round", 2);
      _poker_phase = POKER_STATE_END;
      return 1;
   }
}
void next_person_turn() {
   class player_data data;
   string start_id;
   start_id = query_current_player();
   do {
      increment_current_player();
      data = query_player_data(query_current_player());
   } while (data->state == POKER_STATE_FOLDED &&
            query_current_player() != start_id);
   if (query_current_player() == start_id) {
      printf("Force end of game.\n");
      call_out("complete_round", 2, 1);
      _poker_phase = POKER_STATE_END;
   } else {
      call_out("tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n");
   }
}
void deal_cards() {
   string id;
   class player_data data;
   _deck = make_deck(1, 0);
   _deck = shuffle_deck(_deck);
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      data->hand = sort_cards(_deck[0..4], 3);
      data->bet = 0;
      if (data->state != POKER_STATE_FOLDED) {
         if (!_max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
      data->hand_type = query_hand_type(data->hand);
      _deck = _deck[5..];
      if (query_player_object(id)) {
         tell_player(id, "Your hand:\n" +
                query_hand_string(data->hand, CARD_HAND_THREE|CARD_HAND_LETTERS,
                                  query_player_object(id)->query_cols()) +
            query_hand_type_string(data->hand_type) + ".\n");
      }
   }
   if (!_max_draw_rounds) {
      _poker_phase = POKER_STATE_FINAL_BET;
   } else {
      _poker_phase = POKER_STATE_BET;
   }
   next_person_turn();
   tell_all_players(query_player_cap_name(query_current_player()) +
                    " goes first.\n");
   _current_bet = 0;
}
int start_game() {
   class player_data data;
   string id;
   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->bet = 0;
      data->hand = ({ });
      data->state = POKER_STATE_ANTE;
      set_player_data(id, data);
   }
   _poker_phase = POKER_STATE_ANTE;
   _pot = 0;
   _finished = 0;
   _draw_round = 0;
   _discard = ({ });
   tell_all_players("%^BOLD%^Place your ante to start playing.%^RESET%^\n");
   return 1;
}
void check_for_finish_ante() {
   string id;
   class player_data data;
   object ob;
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      ob = query_player_object(id);
      if (ob && !interactive(ob)) {
         data->state = POKER_STATE_FOLDED;
      }
      if (ob && interactive(ob) && data->state == POKER_STATE_ANTE) {
         return ;
      }
   }
   _poker_phase = POKER_STATE_BET;
   call_out("deal_cards", 2);
}
int is_card_higher(class playing_card card_new, class playing_card card_old) {
   if (card_new->number == card_old->number) {
      return 0;
   }
   if (card_new->number == CARD_NUMBER_ACE) {
      return 1;
   }
   if (card_old->number == CARD_NUMBER_ACE) {
      return 0;
   }
   if (card_new->number > card_old->number) {
      return 1;
   }
   return 0;
}
class hand_type query_hand_type(class playing_card* hand) {
   int high_num;
   int num;
   int id;
   int i;
   int j;
   class playing_card* tmp_hand;
   class hand_type ret_type;
   class playing_card tmp_card;
   ret_type = new(class hand_type);
   high_num = 0;
   for (i = 1; i < sizeof(hand); i++) {
      if (is_card_higher(hand[i], hand[high_num])) {
         high_num = i;
      }
   }
   ret_type->hand_type = HAND_TYPE_HIGH_CARD;
   ret_type->high_card = hand[high_num];
   high_num = 1;
   for (i = 0; i < sizeof(hand) - 1; i++) {
      num = 1;
      for (j = 0; j < sizeof(hand) - i - 1; j++) {
         if (hand[i]->number == hand[i + j + 1]->number) {
            num++;
         }
      }
      if (num > high_num) {
         high_num = num;
         id = hand[i]->number;
      }
   }
   tmp_hand = hand;
   if (high_num > 1) {
      for (i = 0; i < sizeof(tmp_hand); i++) {
         if (tmp_hand[i]->number == id) {
            ret_type->duplicate_1 = tmp_hand[i];
            tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            i--;
         }
      }
   }
   if (high_num == 2) {
      high_num = 1;
      for (i = 0; i < sizeof(tmp_hand) - 1; i++) {
         num = 1;
         for (j = 0; j < sizeof(tmp_hand) - i - 1; j++) {
            if (tmp_hand[i]->number == tmp_hand[i + j + 1]->number) {
               num++;
            }
         }
         if (num > high_num) {
            high_num = num;
            id = tmp_hand[i]->number;
         }
      }
      if (high_num == 2) {
         ret_type->hand_type = HAND_TYPE_TWO_PAIR;
         for (i = 0; i < sizeof(tmp_hand); i++) {
            if (tmp_hand[i]->number == id) {
               ret_type->duplicate_2 = tmp_hand[i];
               tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            }
         }
         if (is_card_higher(ret_type->duplicate_2, ret_type->duplicate_1)) {
            tmp_card = ret_type->duplicate_1;
            ret_type->duplicate_1 = ret_type->duplicate_2;
            ret_type->duplicate_2 = tmp_card;
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      } else {
         ret_type->hand_type = HAND_TYPE_PAIR;
         high_num = 0;
         for (i = 1; i < sizeof(tmp_hand); i++) {
            if (is_card_higher(tmp_hand[i], tmp_hand[high_num])) {
               high_num = i;
            }
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 3) {
      if (tmp_hand[0]->number == tmp_hand[1]->number) {
         ret_type->hand_type = HAND_TYPE_FULL_HOUSE;
         ret_type->duplicate_2 = tmp_hand[0];
         ret_type->kickers = ({ });
      } else {
         ret_type->hand_type = HAND_TYPE_THREE;
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 4) {
      ret_type->hand_type = HAND_TYPE_FOUR;
      ret_type->high_card = tmp_hand[0];
      return ret_type;
   }
   for (i = 0; i < sizeof(hand) - 1; i++) {
      if (hand[i + 1]->suit != hand[0]->suit) {
         break;
      }
   }
   if (i == sizeof(hand) - 1) {
      ret_type->hand_type = HAND_TYPE_FLUSH;
      ret_type->kickers = sort_cards(hand, 3);
      high_num = 0;
      for (i = 1; i < sizeof(hand); i++) {
         if (is_card_higher(hand[i], hand[high_num])) {
            high_num = i;
         }
      }
      ret_type->high_card = hand[high_num];
   }
   tmp_hand = sort_array(hand, (: ((class playing_card)$1)->number -
                                  ((class playing_card)$2)->number :));
   if (tmp_hand[0]->number == CARD_NUMBER_ACE) {
      if (tmp_hand[1]->number == 2) {
         j = 1;
      } else {
         j = 0;
         tmp_hand = tmp_hand[1..] + ({ tmp_hand[0] });
      }
   } else {
      j = 0;
   }
   for (i = j; i < sizeof(tmp_hand) - 1; i++) {
      if (tmp_hand[i]->number + 1 != tmp_hand[i + 1]->number) {
         if (tmp_hand[i + 1]->number != CARD_NUMBER_ACE ||
             tmp_hand[i]->number != CARD_NUMBER_KING) {
            break;
         }
      }
   }
   if (i == sizeof(tmp_hand) - 1) {
      if (ret_type->hand_type == HAND_TYPE_FLUSH) {
         ret_type->hand_type = HAND_TYPE_STRAIGHT_FLUSH;
         ret_type->high_card = tmp_hand[<1];
      } else {
         ret_type->hand_type = HAND_TYPE_STRAIGHT;
         ret_type->high_card = tmp_hand[<1];
      }
   }
   if (ret_type->hand_type == HAND_TYPE_HIGH_CARD) {
      ret_type->kickers = sort_cards(hand, 3);
   }
   return ret_type;
}
int is_greator_hand(class hand_type new_hand,
                    class hand_type old_hand) {
   int i;
   if (new_hand->hand_type > old_hand->hand_type) {
      return 1;
   }
   if (new_hand->hand_type < old_hand->hand_type) {
      return 0;
   }
   if (new_hand->hand_type == old_hand->hand_type) {
      switch (new_hand->hand_type) {
      case HAND_TYPE_HIGH_CARD :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(old_hand->high_card,
                            new_hand->high_card)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FLUSH :
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_TWO_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_THREE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FOUR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_FULL_HOUSE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         break;
      case HAND_TYPE_STRAIGHT :
      case HAND_TYPE_STRAIGHT_FLUSH :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 0;
         }
         break;
      }
   }
   return TIE;
}
void test_hand_type() {
   class playing_card* other_tmp_hand;
   class playing_card* tmp_hand;
   other_tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 12),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13) });
   tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 2),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 3),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 4),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 1),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 5) });
write(query_hand_type_string(query_hand_type(tmp_hand)) + " --\n" +
      query_hand_type_string(query_hand_type(other_tmp_hand)));
printf("%O\n", sizeof(query_hand_type(tmp_hand)->kickers));
printf("%O\n", sizeof(query_hand_type(other_tmp_hand)->kickers));
write("Result: " + is_greator_hand(query_hand_type(tmp_hand),
      query_hand_type(other_tmp_hand)) + "\n");
}
void complete_round(int force_end) {
   string stuff;
   object ob;
   class player_data data;
   string id;
   string place;
   string* winner;
   class hand_type winning_hand_type;
   class playing_card* winning_hand;
   int paid;
   int discard;
   int result;
   int num;
   if (_finished) {
      return 0;
   }
   place = query_money_place();
   stuff = "";
   winner = ({ });
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if ((data->state == POKER_STATE_BET || discard) && !force_end) {
         if (data->state != POKER_STATE_FOLDED) {
            data->state = POKER_STATE_DISCARD;
            data->bet = 0;
         }
         discard = 1;
      } else if (data->state != POKER_STATE_FOLDED) {
         num++;
         if (!winning_hand) {
            winning_hand = data->hand;
            winning_hand_type = data->hand_type;
            winner = ({ id });
         } else {
            data->hand_type = query_hand_type(data->hand);
            result = is_greator_hand(data->hand_type, winning_hand_type);
            if (result == TIE) {
               winner += ({ id });
            } else if (result) {
               winning_hand = data->hand;
               winning_hand_type = data->hand_type;
               winner = ({ id });
            }
         }
         stuff += query_player_cap_name(id) + "'s hand (" +
                  query_hand_type_string(data->hand_type) + "):\n" +
                  query_hand_string(data->hand, CARD_HAND_SINGLE,
                                     this_player()->query_cols()) + "\n";
      }
   }
   if (num == 1) {
      stuff = "All but one person folded so the cards are not revealed.\n";
   }
   if (discard) {
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state == POKER_STATE_FOLDED) {
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "You have folded.\n");
         } else {
            data->bet = 0;
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "Your hand:\n" +
               query_hand_string(data->hand, CARD_HAND_THREE | CARD_HAND_LETTERS,
                                    80));
         }
      }
   } else {
      if (_house_cut) {
         stuff += "House takes " +
            MONEY_HAND->money_value_string((_pot * _house_cut) / 100, place) +
                  ".\n";
        adjust_float((_pot * _house_cut) / 100);
        _pot -= (_pot * _house_cut) / 100;
      }
      if (sizeof(winner) > 1) {
         stuff += "Tie for winning between " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", they each win " +
                  MONEY_HAND->money_value_string(_pot / sizeof(winner), place) +
                  ".\n";
         paid = _pot / sizeof(winner);
         foreach (id in winner) {
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(paid, place), place);
               _player_stats[ob->query_name()] += paid;
            } else {
               stuff += "Unable to find " + id + " to pay them, money "
                               "going to the house.\n";
               adjust_float(paid);
            }
         }
      } else {
         stuff += "Winner is " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", and they win " +
                  MONEY_HAND->money_value_string(_pot, place) +
                  ".\n";
         ob = query_player_object(winner[0]);
         ob->adjust_money(MONEY_HAND->create_money_array(_pot, place), place);
         _player_stats[ob->query_name()] += _pot;
      }
      tell_all_players("The players reveal their cards as:\n" +
                       stuff);
      tell_room(environment(), "The game ends with " + query_multiple_short(winner) +
                               " as the winner.\n");
      finish_game(query_multiple_short(winner));
      _finished = 1;
   }
}
void finish_discard() {
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_AFTER_DISCARD &&
          data->state != POKER_STATE_FOLDED) {
         return 0;
      }
   }
   _draw_round++;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state == POKER_STATE_AFTER_DISCARD) {
         if (_draw_round >= _max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
   }
   _current_bet = 0;
   _poker_phase = POKER_STATE_FINAL_BET;
   call_out("tell_all_players", 0,
            "Discard round completed.  Now onto the " +
            (_draw_round >= _max_draw_rounds?"final ":"") + "betting round.\n");
   next_person_turn();
}
int do_ante() {
   string place;
   string id;
   int amount;
   class player_data data;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != POKER_STATE_ANTE) {
      add_failed_mess("You have already put in your ante.\n");
      return 0;
   }
   place = query_money_place();
   amount = _ante_house + _ante_amount;
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " to meet the ante.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amount;
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);
   adjust_float(_ante_house);
   _pot += _ante_amount;
   data->state = POKER_STATE_PAID_ANTE;
   environment()->event_save(this_object());
   check_for_finish_ante();
   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
}
int do_discard(string throw_away) {
   int i;
   string id;
   class player_data data;
   string* bits;
   int* new_bits;
   throw_away = lower_case(throw_away);
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot discard before you have been dealt "
                      "cards.\n");
      return 0;
   }
   if (data->state != POKER_STATE_DISCARD) {
      add_failed_mess("You are not in the discard phase.\n");
      return 0;
   }
   if (throw_away && throw_away != "none") {
      throw_away = lower_case(replace_string(throw_away, " ", ""));
      bits = explode(throw_away, ",");
      if (sizeof(filter(bits, (: strlen($1) > 1 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      new_bits = map(bits, (: $1[0] - 'a' :));
      if (sizeof(filter(new_bits, (: $1 < 0 || $1 >= 5 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      for (i = 0; i < sizeof(new_bits); i++) {
         if (member_array(new_bits[i],
                          new_bits[0..i-1] + new_bits[i+1..]) != -1) {
            add_failed_mess("You have referenced the card " +
                            sprintf("%c", 'A' + new_bits[i]) + " twice.\n");
            return 0;
         }
      }
      new_bits = sort_array(new_bits, (: $2 - $1 :));
      for (i = 0; i < sizeof(new_bits); i++) {
         _discard += ({ data->hand[new_bits[i]] });
         data->hand = data->hand[0..new_bits[i]-1] +
                      data->hand[new_bits[i]+1..];
      }
      i = 5 - sizeof(data->hand) - 1;
      if (sizeof(_deck) < i) {
         _deck += _discard;
         _deck = shuffle_array(_deck);
         _discard = ({ });
      }
      data->hand += _deck[0..i];
      _deck = _deck[i + 1..];
      data->hand = sort_cards(data->hand, 3);
      data->hand_type = query_hand_type(data->hand);
      add_succeeded_mess(({ "", "$N draw$s " + query_num(sizeof(new_bits)) +
                                " new card" +
                               (sizeof(new_bits) > 1?"s":"") + " on $D.\n" }));
      write("Your new hand (" +
            query_hand_type_string(data->hand_type) +
            "):\n" +
            query_hand_string(data->hand, CARD_HAND_THREE,
                                  this_player()->query_cols()));
      data->state = POKER_STATE_AFTER_DISCARD;
   } else {
      new_bits = ({ });
      data->state = POKER_STATE_AFTER_DISCARD;
      add_succeeded_mess("$N do$es not discard any cards on $D.\n");
   }
   finish_discard();
   return 1;
}
int do_check() {
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (_current_bet) {
      add_failed_mess("You cannot check since betting has started.\n");
      return 0;
   }
   add_succeeded_mess("$N check$s on $D.\n");
   next_person_turn();
   return 1;
}
int do_call() {
   class player_data data;
   int amt;
   string place;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (!_current_bet) {
      add_failed_mess("No one has bet anything for you to call.\n");
      return 0;
   }
   place = query_money_place();
   data = query_player_data(query_current_player());
   if (_current_bet && data->bet == _current_bet) {
      call_out("complete_round", 2);
      if (_poker_phase == POKER_STATE_ANTE) {
         _poker_phase = POKER_STATE_DISCARD;
      } else {
         _poker_phase = POKER_STATE_ANTE;
      }
   } else {
      amt = _current_bet - data->bet;
      if (this_player()->query_value_in(place) < amt) {
         add_failed_mess("You do not have the necessary " +
                         MONEY_HAND->money_value_string(amt, place) +
                         " to call the bet.\n");
         return 0;
      }
      _player_stats[this_player()->query_name()] -= amt;
      this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
      _pot += amt;
      data->bet = _current_bet;
      if (!check_end_round()) {
         next_person_turn();
      }
   }
   add_succeeded_mess("$N call$s the bet by adding " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to the pot for a total bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   return 1;
}
int do_raise(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   raise_amt = amt;
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_bet(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt == _current_bet) {
      return do_call();
   }
   if (amt < _current_bet) {
      add_failed_mess("You have to bet higher than the current bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " money amount.\n");
      return 0;
   }
   amt = amt - _current_bet;
   raise_amt = amt;
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_fold() {
   class player_data data;
   string id;
   int not_folded;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   data->state = POKER_STATE_FOLDED;
   add_succeeded_mess("$N fold$s on $D.\n");
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         not_folded++;
      }
   }
   if (not_folded == 1) {
      call_out("complete_round", 0, 1);
      _poker_phase = POKER_STATE_END;
   } else if (!check_end_round()) {
      next_person_turn();
   }
   return 1;
}
int do_start() {
   int old_pot;
   if (!is_open_for("poker", this_player()->query_name())) {
      add_failed_mess("The poker table is not open.\n");
      return 0;
   }
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }
   old_pot = _pot;
   if (!start_game()) {
      add_failed_mess("You need at least two people to play poker.\n");
      return 0;
   }
   adjust_float(old_pot);
   add_succeeded_mess("$N $V a game on $D.\n");
   return 1;
}
int do_finish() {
   string person;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }
   finish_game(0);
   reset_game();
   return 1;
}
string query_main_status(int hint) {
   string place;
   string ret;
   string name;
   int amt;
   place = query_money_place();
   ret = "$I$0=Poker table:\n"
          "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Ante       : " +
              MONEY_HAND->money_value_string(_ante_amount, place) +
          "\n$I$6=   House Ante : " +
              MONEY_HAND->money_value_string(_ante_house, place) +
          "\n$I$6=   Draw Rounds: " + _max_draw_rounds +
          "\n$I$6=   Cut        : " + _house_cut + "%"
          "\n$I$6=   Revenue    : " +
              MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$0=";
   foreach (name, amt in _player_stats) {
      ret += sprintf(" %-13s: %s\n" , name,
                     MONEY_HAND->money_value_string(amt, place));
   }
   return ret + "\n";
}
int do_set_ante(string str, int ante_game) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (lower_case(str) == "none" && !ante_game) {
      value = 0;
   } else {
      place = query_money_place();
      value = MONEY_HAND->value_from_string(str, place);
      if (!value) {
         add_failed_mess("Unable to parse the string " + str + ".\n");
         return 0;
      }
   }
   if (ante_game) {
      _ante_amount = value;
      add_succeeded_mess("$N set$s the ante amount to play to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _ante_house = value;
      add_succeeded_mess("$N set$s the ante amount for the house to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_bet(string str, int max_bet) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   _house_cut = percent;
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_draw(int draw) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (draw < 0) {
      add_failed_mess("You cannot set the number of draws less than 0.\n");
      return 0;
   }
   if (draw > 5) {
      add_failed_mess("You cannot set the draw to greator than 5.\n");
      return 0;
   }
   _max_draw_rounds = draw;
   add_succeeded_mess("$N set$s the number of draw rounds to " + draw + " on $D.\n");
   return 1;
}
int do_rules() {
   string ret;
   string place;
   place = query_money_place();
   ret = "The rules for this table are:\n";
   ret += "$I$6=   Maximum amount that can be raised " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum amount that can be raised " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Total ante " +
              MONEY_HAND->money_value_string(_ante_amount + _ante_house, place) +
          "\n$I$6=   Cut of the pool : " + _house_cut +
          "\n$I$6=   Draw Rounds     : " + _max_draw_rounds +
          "\n$I$6=   House Ante      : " +
              MONEY_HAND->money_value_string(_ante_house, place);
   write("$P$Rules$P$" + ret);
}
int do_reset() {
   if (::do_reset()) {
      _player_stats = ([ ]);
      add_succeeded_mess("$N clear$s the player stats.\n");
      return 1;
   }
}
void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("discard", "<string'card'> on <direct:object>",
               (: do_discard($4[0]) :));
   add_command("ante", "on <direct:object>",
               (: do_ante() :));
   add_command("check", "on <direct:object>",
               (: do_check() :));
   add_command("call", "on <direct:object>",
               (: do_call() :));
   add_command("bet", "<string'total bet'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("raise", "<string'raise'> on <direct:object>",
               (: do_raise($4[0]) :));
   add_command("fold", "on <direct:object>",
               (: do_fold() :));
   add_command("finish", "game on <direct:object>",
               (: do_finish() :));
   add_command("start", "game on <direct:object>",
               (: do_start() :));
   add_command("rules", "<direct:object>",
               (: do_rules() :));
   add_command("rules", "{for|on|of} <direct:object>",
               (: do_rules() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "draw <number'rounds'> on <direct:object>",
                  (: do_set_draw($4[0]) :));
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "ante house <string'amount|none'> on <direct:object>",
                  (: do_set_ante($4[0], 0) :));
      add_command("set", "ante game <string'amount'> on <direct:object>",
                  (: do_set_ante($4[0], 1) :));
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
   }
}
void resign_person(string id) {
   class player_data data;
   int not_folded;
   data = query_player_data(id);
   if (data && data->state != POKER_STATE_FOLDED) {
      tell_all_players(query_player_cap_name(id) +
                       " resigns and folds.\n");
      data->state = POKER_STATE_FOLDED;
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state != POKER_STATE_FOLDED) {
            not_folded++;
         }
      }
      if (not_folded == 1) {
         call_out("complete_round", 0, 1);
         _poker_phase = POKER_STATE_END;
      }
   } else {
      switch (_poker_phase) {
      case POKER_STATE_ANTE :
         check_for_finish_ante();
         break;
      case POKER_STATE_BET :
         check_end_round();
         break;
      case POKER_STATE_DISCARD :
         finish_discard();
         break;
      }
   }
}
void event_exit(object ob, string mess, object to) {
   string id;
   if (userp(ob) && to != environment()) {
      id = find_player_id_of_person(ob);
      if (id) {
         resign_person(id);
      }
   }
}
void multiplayer_someone_resigns(string id, string name) {
   resign_person(id);
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, BOARD_TAG, "return", _return);
   add_auto_load_value(map, BOARD_TAG, "ante amount", _ante_amount);
   add_auto_load_value(map, BOARD_TAG, "house cut", _house_cut);
   add_auto_load_value(map, BOARD_TAG, "ante house", _ante_house);
   add_auto_load_value(map, BOARD_TAG, "min bet", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "current bet", _current_bet);
   add_auto_load_value(map, BOARD_TAG, "pot", _pot);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "poker phase", _poker_phase);
   add_auto_load_value(map, BOARD_TAG, "draw round", _draw_round);
   add_auto_load_value(map, BOARD_TAG, "max draw rounds", _max_draw_rounds);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "player stats", _player_stats);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);
   _return = query_auto_load_value(map, BOARD_TAG, "return");
   _ante_amount = query_auto_load_value(map, BOARD_TAG, "ante amount");
   _ante_house = query_auto_load_value(map, BOARD_TAG, "ante house");
   _house_cut = query_auto_load_value(map, BOARD_TAG, "house cut");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _current_bet = query_auto_load_value(map, BOARD_TAG, "current bet");
   _pot = query_auto_load_value(map, BOARD_TAG, "pot");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _poker_phase = query_auto_load_value(map, BOARD_TAG, "poker phase");
   _draw_round = query_auto_load_value(map, BOARD_TAG, "draw round");
   _max_draw_rounds = query_auto_load_value(map, BOARD_TAG, "max draw rounds");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _player_stats = query_auto_load_value(map, BOARD_TAG, "player stats");
   if (!_player_stats) {
      _player_stats = ([ ]);
   }
}

==================================================
FILE: room/furniture/shop_base.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/player_craft_shop_base";
#define SAVE_TIME 1
private int _save_call;
private int _last_saved;
private string _counter_short;
#define OBJECT_TAG "shop base"
void create() {
   player_craft_shop_base::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("craft shop");
}
int query_player_craft_shop() {
   return 1;
}
int disallow_sale_here(object room) {
   object* obs;
   obs = room->find_commercial_items(query_commercial_name());
   return sizeof(obs);
}
int query_royalty(string person) {
   return commercial::query_royalty(person);
}
string query_craft_shop_save_dir() {
   return environment()->query_save_dir() + "craft_shop";
}
void adjust_royalty(string person, int amount) {
   commercial::adjust_royalty(person, amount);
}
string query_parcel_post() {
   return commercial::query_parcel_post();
}
void reset_weekly_status() {
   player_craft_shop_base::reset_weekly_status();
}
string query_weekly_status_string() {
   return player_craft_shop_base::query_weekly_status_string();
}
void load_me() {
  string fname, tmp;
#ifdef USE_RAMDISK
  tmp = replace_string(query_save_dir() + "craft_shop_file", "/save/",
                       "/save/ramdisk/");
  if(unguarded((: file_size($(tmp) = ".o.gz") :)) > 0 ||
     unguarded((: file_size($(tmp) = ".o") :)) > 0) {
    fname = tmp;
  }
#endif
  if(!fname) {
    fname = query_save_dir() + "craft_shop_file";
  }
   unguarded( (: restore_object($(fname)) :));
#ifdef USE_RAMDISK
   tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                        "/save/ramdisk/");
   unguarded( (: mkdir($(tmp)) :));
#endif
   unguarded( (: mkdir(query_craft_shop_save_dir()) :));
   reload_shop();
   add_property("place", environment()->query_property("place"));
}
void init() {
   player_craft_shop_base::init();
   commercial::init();
}
void do_save() {
  string fname;
  string dir;
   _save_call = 0;
   if (environment() && query_save_dir()) {
#ifdef USE_RAMDISK
     dir = replace_string(query_save_dir(), "/save/",
                            "/save/ramdisk/");
     if (file_size(dir) == -2) {
        fname = dir + "craft_shop_file";
     }
#endif
     if(!fname) {
       fname = query_save_dir() + "craft_shop_file";
     }
     debug_printf("Saving to %O\n", fname);
     unguarded( (: save_object($(fname), 2) :));
   }
}
void dest_me() {
   do_save();
   player_craft_shop_base::dest_me();
   commercial::dest_me();
}
string query_commercial_information() {
   return "This shop can have a maximum of " + query_maximum_inventory_size() +
          " items for sale.  "
          "You can only have "
          "one shop counter in any room, more than one will not be "
          "able to be bought.";
}
void event_save(object ob) {
   if (!_save_call) {
      if(_last_saved > time() - SAVE_TIME) {
         _save_call = call_out("do_save", SAVE_TIME - (time() - _last_saved));
      } else {
         _save_call = call_out("do_save", SAVE_TIME);
      }
#ifdef DEBUG
      debug_printf("Adding call_out");
#endif
   }
}
mapping query_commercial_options() {
   return ([
    "counter type" : ([
       "polished hardwood counter" : 500000,
       "shiny polished counter" : 150000,
       "unfinished pine counter" : 0,
      ]),
   "stockroom size" : ([
       "50" : 0,
       "100" : 1000000,
       "150" : 2500000,
      ]),
   ]);
}
void set_commercial_option(string type, string name) {
   string* bits;
   int size;
   switch (type) {
   case "counter type" :
      _counter_short = name;
      set_short(_counter_short);
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
      break;
   case "stockroom size" :
      sscanf(name, "%d", size);
      set_maximum_waiting_queue_size(size);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "stocksize", query_maximum_waiting_queue_size());
   add_auto_load_value(map, OBJECT_TAG, "counter short", _counter_short);
}
void init_dynamic_arg(mapping map, object player) {
   string* bits;
   int size;
   commercial::init_dynamic_arg(map, player);
   size = query_auto_load_value(map, OBJECT_TAG, "stocksize");
   _counter_short = query_auto_load_value(map, OBJECT_TAG, "counter short");
   if (size) {
      set_maximum_waiting_queue_size(size);
   }
   if (_counter_short) {
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
   }
}

==================================================
FILE: room/furniture/sink_inherit.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/surface";
#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
int water = 0;
int dirt = 0;
string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});
void zap_bad_effects( object who );
int do_wash(object *indirect_obs );
void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
}
string extra_look() {
    object *stuff;
    string answer = "";
    stuff = all_inventory( this_object() );
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " +
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n";
    }
   return answer;
}
string long_status() {
    return "";
}
void init(){
    ::init();
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
}
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {
            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}
void reset() {
    wet_everyone_in();
}
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}
int do_splash( object *indirect_obs ) {
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() +
            "before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}
int do_wash( object *indirect_obs ) {
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() +
            "before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
}
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    dirt++;
    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    if (!random(dirt)) {
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
}

==================================================
FILE: room/furniture/storage.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
#undef DEBUG
void create() {
   do_setup++;
   furniture_base::create();
   cont_save::create();
   _drawer_mess = "a drawer in $ob_short$";
   _drawers = ({ });
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   return ret;
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  object thief;
  result = ::test_remove(thing, flag, dest);
  if(result && environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    stuff = thing->query_property("dropped");
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  i = ::test_add(thing, flag);
#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put in %s by %s [%d].\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown",
             i);
#endif
  return i;
}
private int pick_ok(object player) {
  mixed owner;
  if(!environment() ||
     !function_exists("query_owner", environment()) ||
     environment()->test_occupier(player->query_name()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
int pick_unlock(object player) {
  if(!pick_ok(player))
    return 0;
  return ::pick_unlock(player);
}
int pick_lock(object player) {
  if(!pick_ok(player))
    return 0;
  return ::pick_lock(player);
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions(map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = cont_save::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map, object) {
   cont_save::init_dynamic_arg(map, 0);
   set_bonded(map["bonded"]);
}

==================================================
FILE: room/furniture/surface.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "/std/object";
inherit "/std/basic/cute_look";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave int _loc_weight, _max_weight;
private nosave string *_shadows;
private nosave object _player;
private nosave string *_aliases;
private nosave int _use_internals;
void create() {
  do_setup++;
  furniture_base::create();
  object::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  set_no_all(1);
}
void init() {
  string alias;
  if(_aliases)
    foreach(alias in _aliases) {
      add_command(alias, "<indirect:object:me> {in|on|into} <indirect:object>",
                  (: "/cmds/living/put"->cmd($1, $3, $4) :) );
    }
  ::init();
}
void set_put_aliases(string *aliases) {
  _aliases = aliases;
}
void set_allow_use_internals(int allow) {
   _use_internals = allow;
}
int query_allow_use_internals() {
   return _use_internals;
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else {
    if (_use_internals) {
      if (from) {
        from->remove_use_internal_object(this_object());
      }
      dest->add_use_internal_object(this_object());
    }
    if (query_light_needs_inform()) {
      if ( from ) {
        inform_of_light_level_change(from);
      }
      inform_of_light_level_change(dest);
    }
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
int test_remove(object thing, int flag, mixed dest) {
  mixed *stuff;
  object thief;
  if(environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    stuff = thing->query_property("dropped");
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  return 1;
}
int test_add( object thing, int flag ) {
  if(environment())
    event(environment(), "save");
#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put on %s by %s.\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown");
#endif
  return 1;
}
void set_max_weight(int arg) { _max_weight = arg; }
int query_max_weight() { return _max_weight; }
int query_loc_weight() { return _loc_weight; }
int query_has_surface() { return 1; }
void update_loc_weight() {
  int i;
  object *contents;
  _loc_weight = 0;
  contents = all_inventory( this_object() );
  for ( i = 0; i < sizeof( contents ); i++ )
    _loc_weight += (int)contents[ i ]->query_complete_weight();
}
int query_complete_weight() {
  return ::query_complete_weight() + query_loc_weight();
}
int add_weight( int n ) {
  if ( !_max_weight ) return 1;
  if ( n + _loc_weight > _max_weight ) return 0;
  if ( !environment() ) {
    _loc_weight += n;
    return 1;
  }
  if ( !( environment()->add_weight( n ) ) ) return 0;
  _loc_weight += n;
  return 1;
}
int transfer_all_to(object dest) {
  object *ob;
  int i;
  ob = all_inventory(this_object());
  for (i=0;i<sizeof(ob);i++)
    ob[i]->move(dest);
  if (first_inventory(this_object())) return 0;
  return 1;
}
string long( string word, int dark ) {
   object *things;
   things = (object *)this_object()->find_inv_match( "all", this_player() );
   if ( !sizeof( things ) )
      return object::long( word, dark ) +"There is nothing on "+
            the_short() +".\n";
   return object::long( word, dark ) + query_contents( "On " +
            the_short() +" "+ ( sizeof( things ) == 1 ? "is " :
            "are " ), things );
}
object *find_inv_match( string words, object looker ) {
   int i;
   object *things;
   things = all_inventory( this_object() );
   for ( i = sizeof( things ) - 1; i > -1; i-- ) {
      if ( !things[ i ]->short( 0 ) ) {
         things = delete( things, i, 1 );
         continue;
      }
      if ( !looker )
         continue;
      if ( !things[ i ]->query_visible( looker ) )
         things = delete( things, i, 1 );
   }
   return things;
}
void set_player( object thing ) { _player = thing; }
object query_player() { return _player; }
mixed stats() {
  return ::stats() + ({
    ({ "loc_weight", query_loc_weight(), }),
    ({ "max_weight", query_max_weight(), }),
  });
}
mapping int_query_static_auto_load() {
  return ([
    "::" : ::int_query_static_auto_load(),
    "max weight" : _max_weight,
    "allowed positions" : query_allowed_positions(),
  ]);
}
mapping query_dynamic_auto_load() {
  mixed inventory;
  if (!inventory) {
    catch(inventory = PLAYER_OB->
        create_auto_load( all_inventory( this_object() ) ) );
  }
  return ([ "::" : ::query_dynamic_auto_load(),
            "inv" : inventory,
            "bonded" : query_bonded()
         ]);
}
int handle_restore_inventory(object ob) {
  return (int)ob->move(this_object());
}
void init_dynamic_arg( mapping bing ) {
  function f;
  if ( bing[ "::" ] ) {
    ::init_dynamic_arg( bing[ "::" ] );
  }
  if ( bing[ "inv" ] ) {
    f = (: handle_restore_inventory($1) :);
    if (_player) {
      _player->load_auto_load_to_inventory( bing["inv"], this_object(),
                                            _player, f);
    } else {
      PLAYER_OB->load_auto_load_to_inventory( bing["inv"], this_object(),
                                              this_player(), f);
    }
  }
  set_bonded(bing["bonded"]);
}
void init_static_arg(mapping bing) {
  if (bing["::"]) {
     ::init_static_arg(bing["::"]);
  }
  if (!undefinedp(bing["max weight"])) {
    _max_weight = bing["max weight"];
  if(!undefinedp(bing["allowed_positions"]))
    set_allowed_positions(bing["allowed_positions"]);
  }
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void dest_me() {
  int i;
  object shadow;
  for ( i = 0; i < sizeof( _shadows ); i++ ) {
    if ( shadow = find_object( _shadows[ i ] ) ) {
      shadow->destruct_shadow( shadow );
    }
  }
  all_inventory()->dest_me();
  object::dest_me();
}
string query_help_file_directory() {
   return "/doc/furniture/";
}

==================================================
FILE: room/furniture/vessel.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/obj/vessel";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
void create() {
   do_setup++;
   vessel::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
}
void init() {
   item_chat::init();
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = vessel::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map) {
   vessel::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
}

==================================================
FILE: room/furniture/inherit/document_handler.c
==================================================

#include <move_failures.h>
#include <nroff.h>
#include <room/newspaper.h>
#include <room/document_handler.h>
#define TAG "document__h"
class document {
   string title;
   string fname;
   string added_by;
   int time_added;
   int type;
}
private mapping _documents;
private int _next_doc_id;
string query_save_dir();
void save_me();
int is_open_for(string type, string name);
void add_auto_load_value(mapping map, string tag, string name, mixed value);
mixed query_auto_load_value(mapping map, string tag, string name);
void create() {
   _documents = ([ ]);
}
string query_document_file_name(string id) {
   if (_documents[id]) {
      return query_save_dir() + "/" + _documents[id]->fname;
   }
   return 0;
}
string query_document_data(string id) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      return unguarded( (: read_file($(fname)) :) );
   }
   return 0;
}
int is_document(string id) {
   return _documents[id] != 0;
}
string query_document_readable(string id) {
   string fname;
   string text;
   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: NROFF_HAND->cat_file($(fname) + ".nroff", 1) :) );
         if (!text) {
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
}
string query_document_html(string id) {
   string fname;
   string text;
   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         text = replace(fname, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;",
                                  " ", "&nbsp;", "\n", "<br>" }) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: read_file($(fname)) :) );
         if (!text) {
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
}
void update_document_text(string id, string text) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: write_file($(fname), $(text), 1) :));
   }
}
void delete_document(string id) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: rm($(fname) + ".proc") :));
      unguarded( (: rm($(fname) + ".nroff.o") :));
      unguarded( (: rm($(fname)) :));
      map_delete(_documents, id);
      save_me();
   }
}
string add_document(string title, string text, string person, int type) {
   class document bing;
   string id;
   id = _next_doc_id + "";
   bing = new(class document);
   bing->title = title;
   bing->added_by = person;
   bing->type = type;
   bing->time_added = time();
   bing->fname = id + ".txt";
   _next_doc_id++;
   _documents[id] = bing;
   update_document_text(id, text);
   save_me();
   return id;
}
int do_list() {
   string ret;
   class document info;
   string id;
   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot list documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   if (!sizeof(_documents)) {
      add_failed_mess("Cannot find any documents to list on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   ret = "";
   foreach (id, info in _documents) {
      ret += "$I$3=" + id + ") " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " +
             ctime(info->time_added)[<4..] + "\n";
   }
   write("$P$Documents$P$" + ret);
   add_succeeded_mess(({ "", "$N lists the documents in $I.\n" }),
                      ({ this_object() }));
   return 1;
}
int do_display(string id) {
   string ret;
   class document info;
   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot view documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   ret = query_document_readable(id);
   if (!ret) {
      add_failed_mess("Cannot find the document " + id + " on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   info = _documents[id];
   ret = "Document #" + id + " " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " +
             ctime(info->time_added)[<4..] + "\n" + ret;
   write("$P$Document " + id + "$P$" + ret);
   add_succeeded_mess(({ "", "$N reads a document from $I.\n" }),
                      ({ this_object() }));
   return 1;
}
int do_add_document(string title, int type) {
   if (!is_open_for("document_add", this_player()->query_name())) {
      add_failed_mess("You cannot add documents to $I.\n",
                      ({ this_object() }));
      return 0;
   }
   this_player()->do_edit("", "finish_edit", this_object(), 0,
                          ({ title, type }));
   return 1;
}
void finish_edit(string str, mixed* args) {
   string title;
   int type;
   title = args[0];
   type = args[1];
   if (!str || str == "") {
      write("Abandoning adding the document.\n");
      return ;
   }
   add_document(title, str, this_player()->query_cap_name(), type);
   write("Added the document into the collection.\n");
}
int do_delete_document(string id) {
   if (!is_open_for("document_delete", this_player()->query_name())) {
      add_failed_mess("You cannot delete documents from $I.\n",
                      ({ this_object() }));
      return 0;
   }
   if (!is_document(id)) {
      add_failed_mess("The document " + id + " does not exist in $I.\n",
                      ({ this_object() }));
      return 0;
   }
   delete_document(id);
   add_succeeded_mess("$N delete$s a document from $I.\n", ({ this_object() }));
   return 1;
}
mapping query_dynamic_auto_load(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      add_auto_load_value(map, TAG, "documents", _documents);
      add_auto_load_value(map, TAG, "doc id", _next_doc_id);
      return map;
   }
}
void init_dynamic_arg(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      _documents = query_auto_load_value(map, TAG, "documents");
      if (!_documents) {
         _documents = ([ ]);
      }
      _next_doc_id = query_auto_load_value(map, TAG, "doc id");
   }
}
void init_object() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
}
void init_room() {
   add_command("list", "[documents]", (: do_list() :));
   add_command("view", "[document] <string'id'>",
                (: do_display($4[0]) :));
   add_command("add", "[document] {html|plain} called <string:quoted'title'>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "[document] <string'id'>",
                (: do_delete_document($4[0]) :));
}

==================================================
FILE: room/furniture/inherit/furniture_base.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <housing.h>
#include <room/placement.h>
void add_property(string name, mixed type);
mixed query_property(string name);
string one_short();
int query_light_needs_inform();
void inform_of_light_level_change(object ob);
private nosave mapping _allowed_room_verbs;
private nosave string *_allowed_positions;
private nosave string _bonded;
void create() {
  _allowed_positions = ({ });
  if (base_name(this_object()) + ".c" != __FILE__) {
    if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
    }
    this_object()->set_max_cond(100000);
    this_object()->set_cond(100000);
  }
  if(clonep(this_object()) &&
     base_name(this_object())[0..14] != "/obj/furnitures" &&
     base_name(this_object())[0..2] != "/w/" &&
     strsrch (base_name(this_object()), "_dev") == -1 &&
     strsrch (base_name(this_object()), "_pt") == -1) {
    call_out("move", 2, "/room/void");
  }
}
int query_furniture() {
   return 1;
}
void set_allowed_positions(string *positions) {
   _allowed_positions = positions;
}
void remove_allowed_positions( string *positions ){
  _allowed_positions -= positions;
}
string* query_allowed_positions() {
   return _allowed_positions;
}
void set_allowed_room_verbs( mapping allowed ) {
  _allowed_room_verbs = allowed;
}
mapping query_allowed_room_verbs() {
   return _allowed_room_verbs;
}
string query_position_string(string position_type) {
  if(member_array(position_type, _allowed_positions) != -1) {
    return one_short();
  }
  return 0;
}
void set_bonded(string person) {
   _bonded = person;
}
string query_bonded() {
   return _bonded;
}
string query_owner() {
   return _bonded;
}
int is_allowed_to_mess(object player) {
  mixed *stuff;
  string occupier;
  if(environment() && !function_exists("query_owner", environment()))
    return 1;
  if(player->query_creator())
    return 1;
  if(player->query_caster())
    player = find_player(player->query_caster());
  if(player->query_owner())
    player = player->query_owner();
  if (player && player->query_name() == _bonded)
    return 1;
  stuff = this_object()->query_property("dropped");
  if(player && sizeof(stuff) && stuff[0] == player->query_name())
    return 1;
  if(player && environment()) {
    if(environment()->test_occupier(player->query_name()))
      return 1;
    if(environment()->query_owner() == "For Sale" ||
       environment()->query_owner() == "Under Offer")
      return 1;
    occupier = HOUSING->query_owner(base_name(environment()));
    if(pk_check(player, occupier, 1))
      return 0;
  }
  return (!_bonded);
}
int move_check(object dest) {
  if (living(dest)) {
    if (!is_allowed_to_mess(dest)) {
       return 0;
    }
  } else if (this_player() && environment()) {
    if (!(living(environment()) && dest == environment(environment()))) {
       if (!is_allowed_to_mess(this_player())) {
          return 0;
       }
    }
  }
  return 1;
}
string query_placement_verb() {
   return query_property(PLACEMENT_CURRENT_ROOM_VERB);
}
string query_placement_other() {
   return query_property(PLACEMENT_CURRENT_ROOM_OTHER);
}
string query_placement_position() {
   return query_property(PLACEMENT_CURRENT_ROOM_POSITION);
}
int query_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}
int is_placed() {
   return query_placement_position() &&
     stringp(query_placement_verb()) &&
     stringp(query_placement_other());
}
void set_placement_verb(string verb) {
   add_property(PLACEMENT_CURRENT_ROOM_VERB, verb);
}
void set_placement_other(string other) {
   add_property(PLACEMENT_CURRENT_ROOM_OTHER, other);
}
void set_placement_position(string position) {
   add_property(PLACEMENT_CURRENT_ROOM_POSITION, position);
}
int set_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}

==================================================
FILE: room/furniture/inherit/one_armed_bandit_inherit.c
==================================================

#include <money.h>
int do_slot();
int do_pull_lever();
int do_read_dial();
int set_coin_type( string coin );
int set_chances( int c1, int c2, int c3, int c4, int c5 );
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot );
int* query_prizes();
int* query_chances();
string query_coin_type();
void rollem( object player );
string my_short();
private string *animal = ({"albatross", "frog", "hippo", "turtle", "cabbage"});
private string *adject = ({"A crazy", "A dancing", "A sad", "A floopy", "A bemused",
    "A sarcastic", "A quizzical", "A startled", "A friendly", "A mindless"});
private string _coin = "Ankh-Morpork pence", _coin_short = "pence",
    _coin_pl = "Ankh-Morpork pence";
private int _busy = 0;
private int* _chances = ({1,1,1,1,1});
private int* _prizes = ({2,2,2,2,2,3});
void init(){
    this_player()->add_command( "slot", this_object(),
        _coin_short + " into <direct:object>", (: do_slot() :) );
    this_player()->add_command( "pull", this_object(),
        "lever on <direct:object>", (: do_pull_lever() :) );
    this_player()->add_command( "read", this_object(),
        "dial on <direct:object>", (: do_read_dial() :) );
}
int set_coin_type( string coin ) {
    if( member_array( coin, MONEY_HAND->query_valid_types() ) == -1 )
        return 0;
    _coin = coin;
    _coin_short = MONEY_HAND->query_aliases_for( coin )[0];
    _coin_pl = MONEY_HAND->query_main_plural_for( coin );
    return 1;
}
int set_chances( int c1, int c2, int c3, int c4, int c5 ) {
    if( !( c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c5 > 0 ) )
        return 0;
    _chances = ({ c1, ( c1 + c2 ), ( c1 + c2 + c3 ), ( c1 + c2 + c3 + c4 ),
        ( c1 + c2 + c3 + c4 + c5 ) });
    return 1;
}
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot ) {
    if( !( p1 > 1 && p2 > 1 && p3 > 1 && p4 > 1 && p5 > 1 && jackpot > 1 ) ||
        ( jackpot <= p1 || jackpot <= p2 || jackpot <= p3 ||
        jackpot <= p4 || jackpot <= p5 ) )
        return 0;
    _prizes = ({p1, p2, p3, p4, p5, jackpot});
    return 1;
}
int do_slot() {
    if( member_array( _coin, this_player()->query_money_array() ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
            "You need " + add_a( _coin ) + " to play.\n", ({ }) );
        return 0;
    }
    if( _busy == 1 ) {
        this_player()->add_failed_mess( this_object(),
            "There is already a coin inserted.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are still spinning.\n", ({ }) );
        return 0;
    }
    this_player()->adjust_money( -1, _coin );
    this_object()->adjust_money( 1 );
    _busy = 1;
    this_player()->add_succeeded_mess( this_object(),
        "$N insert$s " + add_a( _coin_short ) + " into $D.\n", ({ }) );
    return 1;
}
int do_pull_lever() {
    if( _busy == 0 ) {
        this_player()->add_failed_mess( this_object(),
            "You must put a coin in the slot before you can play.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are already spinning.\n", ({ }) );
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(),
        ({"You pull the lever.  The pictures behind the windows blur... one by "
             "one they are replaced by a new picture that appears with a sharp "
             "click.\n",
        "$N pull$s the lever on $D and the machine whirs softly.  The sound is "
        "cut short by three sharp clicks.\n"
        }), ({ }) );
    call_out( "rollem", 0, this_player() );
    _busy = 2;
    return 1;
}
void rollem( object player ) {
    int a1, a2, a3, c;
    int adj1 = random( 10 ),
        adj2 = random( 10 ),
        adj3 = random( 10 );
    c = random( _chances[4] );
    if( c < _chances[0] )
        a1 = 0;
    else if( c < _chances[1] )
        a1 = 1;
    else if( c < _chances[2] )
        a1 = 2;
    else if( c < _chances[3] )
        a1 = 3;
    else
        a1 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a2 = 0;
    else if( c < _chances[1] )
        a2 = 1;
    else if( c < _chances[2] )
        a2 = 2;
    else if( c < _chances[3] )
        a2 = 3;
    else
        a2 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a3 = 0;
    else if( c < _chances[1] )
        a3 = 1;
    else if( c < _chances[2] )
        a3 = 2;
    else if( c < _chances[3] )
        a3 = 3;
    else
        a3 = 4;
    tell_object( player,
        "The windows now show these pictures :\n\n"
         "        " + adject[ adj1 ] + " " + animal[ a1 ] +
         "    " + adject[ adj2 ] + " " + animal[ a2 ] +
         "    " + adject[ adj3 ] + " "+animal[ a3 ] + "\n\n" );
    if( a1 == a2 && a1 == a3 ) {
        if( adj1 == adj2 && adj1 == adj3 ) {
            tell_object( player,
                "WOW!!  A triple " + adject[ adj1 ] + " " + animal[ a1 ] +
                "!!  You really hit the jackpot this time!\n\n"
                "Whistles and bells start sounding like crazy, the whole " +
                this_object()->short() +  " glows with flashing lights.  There "
                "is a loud tingling as " + _prizes[5] + " " +
                MONEY_HAND->query_plural_for( _coin ) + " drop into the tray "
                "of " + my_short() + ".  Slightly stunned you quickly scoop "
                "it up and cackle with delight.\n" );
            tell_room( environment( this_object() ),
                "Whistles and bells start sounding and " + my_short() +
                " starts to flash with coloured lights.  Someone must have "
                "won the jackpot...lucky buggers.  As you watch some coins "
                "drop into the tray at the bottom of " + my_short() + ", " +
                player->one_short() + " snatches it up and cackles with "
                "delight.\n", ({player}) );
            player->adjust_money( _prizes[5] ,_coin );
            this_object()->adjust_money( -(_prizes[ 5 ]) );
            _busy = 0;
            return;
        }
        tell_object( player,
            "Congratulations!  You scored a triple " + animal[ a1 ] + "!\n" );
        player->adjust_money( _prizes[ a1 ], _coin );
        tell_object( player,
            _prizes[ a1 ]+ " " + MONEY_HAND->query_plural_for( _coin ) +
            " fall into the tray at the bottom of " + my_short() + ".  You "
            "quickly scoop them up before anyone else can snaffle them.\n" );
        tell_room( environment( this_object() ),
            player->one_short() + " deftly scoops some coins from the tray at "
            "the bottom of " + my_short() + ".\n", ({player}) );
        this_object()->adjust_money( -(_prizes[ a1 ]) );
        _busy = 0;
        return;
    }
    tell_object( player,
        "You didn't win.  Why not have another go and attempt to recoup your "
        "losses?\n" );
    _busy = 0;
}
int* query_chances() {
    int* tmp = ({ });
    tmp += ({ _chances[0] });
    tmp += ({ _chances[1] - _chances[0] });
    tmp += ({ _chances[2] - _chances[1] });
    tmp += ({ _chances[3] - _chances[2] });
    tmp += ({ _chances[4] - _chances[3] });
    return tmp;
}
int* query_prizes() {
    return _prizes;
}
string query_coin_type() {
    return _coin;
}
string my_short() {
    return this_object()->the_short();
}
int do_read_dial() {
    string tmp =
        "Stake        : 1 " + _coin_pl + "\n"
        "3x Albatross : " + _prizes[0] + " " + _coin_pl + "\n"
        "3x Frog      : " + _prizes[1] + " " + _coin_pl + "\n"
        "3x Hippo     : " + _prizes[2] + " " + _coin_pl + "\n"
        "3x Turtle    : " + _prizes[3] + " " + _coin_pl + "\n"
        "3x Cabbage   : " + _prizes[4] + " " + _coin_pl + "\n"
        "JACKPOT      : " + _prizes[5] + " " + _coin_pl + "\n";
    this_player()->add_succeeded_mess( this_object(),
        ({tmp, "$N read$s the dial on $D.\n"}), ({ }) );
    return 1;
}

==================================================
FILE: room/furniture/games/card_base.c
==================================================

#include <room/card_base.h>
#define CARD_NUM_MAX CARD_NUMBER_KING
int is_card_red(class playing_card card);
class playing_card* make_deck(int number_of_decks,
                              int number_of_jokers) {
   class playing_card* deck;
   class playing_card card;
   int i;
   int suit;
   int num;
   deck = ({ });
   for (i = 0; i < number_of_decks; i++) {
      for (suit = CARD_SUIT_HEARTS; suit <= CARD_SUIT_SPADES; suit++) {
         for (num = 1; num <= CARD_NUM_MAX; num++) {
            card = new(class playing_card);
            card->suit = suit;
            card->number = num;
            deck += ({ card });
         }
      }
   }
   for (i = 0; i < number_of_jokers; i++) {
      card = new(class playing_card);
      card->suit = CARD_SUIT_JOKER;
      deck += ({ card });
   }
   return deck;
}
class playing_card* shuffle_deck(class playing_card* deck) {
   class playing_card* new_deck;
   int pos;
   int i;
   for (i = 0; i < 2; i++) {
      new_deck = ({ });
      while (sizeof(deck)) {
         pos = random(sizeof(deck));
         new_deck += deck[pos..pos];
         deck = deck[0..pos - 1] + deck[pos+1..];
      }
      deck = new_deck;
   }
   return deck;
}
string query_suit_letter(int suit) {
   switch (suit) {
   case CARD_SUIT_SPADES :
      return "S";
      break;
   case CARD_SUIT_HEARTS :
      return "H";
      break;
   case CARD_SUIT_DIAMONDS :
      return "D";
      break;
   case CARD_SUIT_CLUBS :
      return "C";
      break;
   case CARD_SUIT_JOKER :
      return "J";
   }
}
string query_card_string(class playing_card card) {
   string ret;
   string colour;
   if (card->suit == CARD_SUIT_JOKER) {
      return "*J*";
   }
   ret = query_suit_letter(card->suit) + "%^RESET%^";
   if (is_card_red(card)) {
      colour = "%^BOLD%^%^RED%^";
   } else {
      colour = "%^BOLD%^";
   }
   if (card->number > 10 || card->number == CARD_NUMBER_ACE) {
      switch (card->number) {
      case CARD_NUMBER_JACK :
         ret = colour + "J " + ret;
         break;
      case CARD_NUMBER_QUEEN :
         ret = colour + "Q " + ret;
         break;
      case CARD_NUMBER_KING :
         ret = colour + "K " + ret;
         break;
      case CARD_NUMBER_ACE :
         ret = colour + "A " + ret;
         break;
      }
   } else {
      ret = sprintf("%s%-2d%s", colour, card->number, ret);
   }
   return ret + "%^RESET%^";
}
int is_card_red(class playing_card card) {
   return card->suit == CARD_SUIT_HEARTS || card->suit == CARD_SUIT_DIAMONDS;
}
int is_card_black(class playing_card card) {
   return card->suit == CARD_SUIT_SPADES || card->suit == CARD_SUIT_CLUBS;
}
int is_card_joker(class playing_card card) {
   return card->suit == CARD_SUIT_JOKER;
}
string* query_card_three(class playing_card card) {
   string* lines;
   if (is_card_red(card)) {
      lines = allocate(3, "%^BOLD%^%^RED%^");
   } else {
      lines = allocate(3, "%^BOLD%^");
   }
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] += "H  %^RESET%^";
      lines[2] += "  H%^RESET%^";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] += "D  %^RESET%^";
      lines[2] += "  D%^RESET%^";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] += "C  %^RESET%^";
      lines[2] += "  C%^RESET%^";
      break;
   case CARD_SUIT_SPADES :
      lines[0] += "S  %^RESET%^";
      lines[2] += "  S%^RESET%^";
      break;
   case CARD_SUIT_JOKER :
      lines[0] += "J *%^RESET%^";
      lines[1] += " O %^RESET%^";
      lines[2] += "* K%^RESET%^";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      if (card->number == 10) {
         lines[1] += " 10%^RESET%^";
      } else {
         lines[1] += " " + card->number + " %^RESET%^";
      }
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] += " K %^RESET%^";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] += " Q %^RESET%^";
         break;
      case CARD_NUMBER_JACK :
         lines[1] += " J %^RESET%^";
         break;
      case CARD_NUMBER_ACE :
         lines[1] += " A %^RESET%^";
         break;
      }
   }
   return lines;
}
string* query_card_two(class playing_card card) {
   string* lines;
   lines = allocate(2);
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] = "H ";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] = "D ";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] = "C ";
      break;
   case CARD_SUIT_SPADES :
      lines[0] = "S ";
      break;
   case CARD_SUIT_JOKER :
      lines[0] = "J*";
      lines[1] = "*O";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      lines[1] = sprintf("%2d", card->number);
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] = " K";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] = " Q";
         break;
      case CARD_NUMBER_JACK :
         lines[1] = " J";
         break;
      case CARD_NUMBER_ACE :
         lines[1] = " A";
         break;
      }
   }
   return lines;
}
string query_hand_string(class playing_card* hand, int flags, int cols) {
   string hand_str;
   int i;
   int j;
   int width;
   int start_pos;
   string top;
   string line;
   string start;
   string end;
   string start_space;
   string end_space;
   mixed card_str;
   if (!sizeof(hand)) {
      return "No cards\n";
   }
   hand_str = "";
   if (!(flags & CARD_HAND_NO_ADORNMENTS)) {
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         top = "+---+";
         width = 5;
      } else {
         top = "+--+";
         width = 4;
      }
      start = "|";
      end = "|";
      start_space = " ";
      end_space = " ";
   } else {
      top = 0;
      line = "";
      start = " ";
      end = " ";
      start_space = " ";
      end_space = " ";
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         width = 3;
      } else {
         width = 2;
      }
   }
   start_pos = 0;
   if (flags & CARD_HAND_THREE) {
      card_str = map(hand, (: query_card_three :));
   } else if (flags & CARD_HAND_SINGLE) {
      card_str = map(hand, (: ({ query_card_string($1) }) :));
   } else {
      card_str = map(hand, (: query_card_two :));
   }
   while (start_pos < sizeof(hand)) {
      if (top) {
         line = "";
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            line += top;
         }
         line += "\n";
      }
      if (flags & CARD_HAND_LETTERS) {
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            if (flags & CARD_HAND_THREE) {
               hand_str += start_space + sprintf(" %c ", 'A' + i + start_pos) + end_space;
            } else {
               hand_str += start_space + sprintf("%c ", 'A' + i + start_pos) + end_space;
            }
         }
      }
      hand_str += "\n" + line;
      for (j = 0; j < sizeof(card_str[0]); j++) {
         for (i = 0; i + start_pos < sizeof(card_str) && (i + 1) * width < cols; i++) {
            hand_str += start + (card_str[i + start_pos][j]) + end;
         }
         hand_str += "\n";
      }
      hand_str += line;
      start_pos += cols / width;
   }
   return hand_str;
}
private int compare_cards(class playing_card card1, class playing_card card2,
                          int flags) {
   if (card1->suit == card2->suit ||
       (flags & 2)) {
      if (!(flags & 1)) {
         return card1->number - card2->number;
      }
      if (card1->number == CARD_NUMBER_ACE) {
         return 1;
      }
      if (card2->number == CARD_NUMBER_ACE) {
         return -1;
      }
      return card1->number - card2->number;
   }
   return card1->suit - card2->suit;
}
class playing_card* sort_cards(class playing_card* deck, int flags) {
   return sort_array(deck,
                (: compare_cards($1, $2, $(flags)) :));
}

==================================================
FILE: room/furniture/games/multiplayer_base.c
==================================================

private inherit "/std/basic/auto_load";
#define LOAD_TAG "multiplayer base"
class player_info {
   int number;
   string cap_name;
   string name;
   mixed data;
}
private mapping _players;
private string _winner;
private string* _ids_when_started;
private string _current_player;
private int _minimum_needed;
private int _maximum_allowed;
private int _can_join_as_new;
private int _game_started;
string* query_currently_playing_ids();
void delete_gone_players();
string find_player_id_of_person(object person);
void create() {
   _players = ([ ]);
   _ids_when_started = ({ });
}
void reset_game() {
}
int start_game() {
   delete_gone_players();
   if (sizeof(query_currently_playing_ids()) < _minimum_needed) {
      return 0;
   }
   _winner = 0;
   _game_started = 1;
   _ids_when_started = query_currently_playing_ids();
   _current_player = _ids_when_started[random(sizeof(_ids_when_started))];
   return 1;
}
void finish_game(string winner) {
   _winner = winner;
   _game_started = 0;
}
string query_winner() {
   return _winner;
}
int is_game_started() {
   return _game_started;
}
int can_join_as_new_player() {
   return _can_join_as_new;
}
void set_can_join_as_new_player(int join) {
   _can_join_as_new = join;
}
int is_person_playing(string id) {
   if (_players[id]->name) {
      if (find_player(_players[id]->name) &&
          is_in_me_or_environment(this_object(),
                                  find_player(_players[id]->name)) &&
          interactive(find_player(_players[id]->name))) {
         return 1;
      }
   }
   return 0;
}
int is_playing(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id != 0;
}
int is_current_player(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id == _current_player;
}
int add_person_to_game(string id, object person) {
   class player_info info;
   if (is_person_playing(id)) {
      return 0;
   }
   info = _players[id];
   info->name = person->query_name();
   info->cap_name = person->query_cap_name();
   return 1;
}
int remove_person_object_from_game(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         info->name = 0;
         info->cap_name = 0;
         return 1;
      }
   }
   return 0;
}
int remove_person_id_from_game(string id) {
   if (_players[id]->name) {
      _players[id]->name = 0;
      return 1;
   }
   return 0;
}
void randomise_player_numbers() {
   string* ids;
   int num;
   int pos;
   ids = keys(_players);
   num = 0;
   while (sizeof(ids)) {
      pos = random(sizeof(ids));
      _players[ids[pos]]->number = num;
      ids = ids[0..pos-1] + ids[pos+1..];
      num++;
   }
}
void add_player_id_type(string id, int number) {
   _players[id] = new(class player_info);
   _players[id]->number = number;
}
void remove_player_id_type(string id) {
   map_delete(_players, id);
}
class player_info find_player_info_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return info;
      }
   }
   return 0;
}
string find_player_id_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return id;
      }
   }
   return 0;
}
string* query_player_ids() {
   return keys(_players);
}
string* query_currently_playing_ids() {
   return filter(keys(_players), (: is_person_playing($1) :));
}
string* query_started_player_ids() {
   return _ids_when_started;
}
string query_player_cap_name(string id) {
   if (_players[id] && _players[id]->name) {
      return _players[id]->cap_name;
   }
   return "No one";
}
object query_player_object(string id) {
   return find_player(_players[id]->name);
}
string query_player_the_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->the_short();
      }
   }
   return "No one";
}
string query_player_poss_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->poss_short();
      }
   }
   return "No one";
}
void delete_gone_players() {
   string id;
   class player_info info;
   foreach (id, info in _players) {
      if (info->name) {
         if (!find_player(info->name) ||
             !is_in_me_or_environment(this_object(), find_player(info->name))) {
            info->name = 0;
         }
      }
   }
}
void set_minimum_needed(int minimun) {
   _minimum_needed = minimun;
}
int can_start_game() {
   if (sizeof(query_currently_playing_ids()) > _minimum_needed) {
      return 1;
   }
   return 0;
}
string find_next_player(string id) {
   class player_info info;
   int start;
   int cur;
   string new_id;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur + 1) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
                member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
string find_previous_player(string id) {
   class player_info info;
   int start;
   string new_id;
   int cur;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur - 1 + sizeof(_players)) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
               member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
void increment_current_player() {
   _current_player = find_next_player(_current_player);
}
string find_player_id_of_person(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         return id;
      }
   }
   return 0;
}
string query_current_player() {
   if (!_current_player) {
      _current_player = find_player_id_from_number(0);
   }
   return _current_player;
}
string set_current_player(string id) {
   _current_player = id;
}
void tell_player(string id, string message) {
   object player;
   player = find_player(_players[id]->name);
   if (player && (environment(player) == environment() ||
                  player == environment())) {
      tell_object(player, message);
   }
}
void tell_current_player(string message) {
   tell_player(_current_player, message);
}
varargs void tell_all_players(string message, string* exclude) {
   class player_info info;
   string id;
   if (!exclude) {
      exclude = ({ });
   }
   foreach (id, info in _players) {
      if (member_array(id, exclude) == -1) {
         tell_player(id, message);
      }
   }
}
mixed query_player_data(string id) {
   return _players[id]->data;
}
void set_player_data(string id, mixed data) {
   _players[id]->data = data;
}
void multiplayer_someone_joins(string id) {
}
void multiplayer_someone_resigns(string id, string name) {
}
mixed* shuffle_array(mixed *arr) {
   int i;
   int pos;
   mixed* new_arr;
   for (i = 0; i < 2; i++) {
      new_arr = ({ });
      while (sizeof(arr)) {
         pos = random(sizeof(arr));
         new_arr += arr[pos..pos];
         arr = arr[0..pos - 1] + arr[pos + 1..];
      }
      arr = new_arr;
   }
   return arr;
}
int do_join(string id) {
   if (is_person_playing(id)) {
      add_failed_mess("Someone is already playing " + id + " on $D.\n");
      return 0;
   }
   if (is_playing(this_player())) {
      add_failed_mess("You are already playing on $D.\n");
      return 0;
   }
   if (is_game_started() &&
       !can_join_as_new_player() &&
       member_array(id, query_started_player_ids()) == -1) {
      add_failed_mess("You can only take over one of the spots vacated by "
                      "someone else.\n");
      return 0;
   }
   if (add_person_to_game(id, this_player())) {
      add_succeeded_mess("$N $V as " + id + " on $D.\n");
      multiplayer_someone_joins(id);
      return 1;
   }
   add_failed_mess("Some weird error joining game on $D.\n");
   return 0;
}
int do_resign() {
   string id;
   id = find_player_id_of_person(this_player());
   if (remove_person_object_from_game(this_player())) {
      add_succeeded_mess("$N $V from the game on $D.\n");
      multiplayer_someone_resigns(id, this_player()->query_cap_name());
      if (id == query_current_player()) {
         increment_current_player();
      }
      return 1;
   }
   add_failed_mess("You are not playing on $D to resign.\n");
   return 0;
}
void init() {
   string ids;
   ids = implode(keys(_players), "|");
   add_command("join", "[game] [as] {" + ids + "} on <direct:object>",
                (: do_join($4[0]) :));
   add_command("resign", "[from] [game] on <direct:object>",
               (: do_resign() :));
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      return 0;
   }
   add_auto_load_value(map, LOAD_TAG, "players", _players);
   add_auto_load_value(map, LOAD_TAG, "current player", _current_player);
   add_auto_load_value(map, LOAD_TAG, "started ids", _ids_when_started);
   add_auto_load_value(map, LOAD_TAG, "winner", _winner);
   add_auto_load_value(map, LOAD_TAG, "game started", _game_started);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   if (!map) {
      return ;
   }
   _players = query_auto_load_value(map, LOAD_TAG, "players");
   _current_player = query_auto_load_value(map, LOAD_TAG, "current player");
   _ids_when_started = query_auto_load_value(map, LOAD_TAG, "started ids");
   _winner = query_auto_load_value(map, LOAD_TAG, "winner");
   _game_started = query_auto_load_value(map, LOAD_TAG, "game started");
}

==================================================
FILE: liquids/ink.c
==================================================

int splash_func(object ob) {
  ob->add_extra_look(this_object());
  ob->add_property("splashed with", previous_object()->query_liquid_name());
  return 1;
}
int query_ink() { return 1; }
string extra_look() {
  return capitalize((string)previous_object()->query_name())+
         " has been splashed with "+
         previous_object()->query_property("splashed with");
}

==================================================
FILE: shadows/peace_shadow.c
==================================================

inherit "/std/effect_shadow";
#define GCR peacenpc->get_combat_reason()
#define GER peacenpc->get_escape_reason()
#define GFR peacenpc->get_fighting_reason()
#define GMR peacenpc->get_magic_reason()
#define GOR peacenpc->get_other_reason()
#define GRR peacenpc->get_ritual_reason()
#define GSR peacenpc->get_stealth_reason()
#define TO this_object()
#define TP this_player()
object peacenpc;
void setup_shadow(object person, object thing) {
    shadow( person, 1 );
    peacenpc=thing;
}
void dest_peace_shadow() { destruct(TO); }
void event_exit(object ob, string message, object to) {
    if (ob==peacenpc)
        dest_peace_shadow();
}
void event_move_object(mixed from, mixed to) {
    dest_peace_shadow();
}
int command_shadowed( string verb, string args ) {
    switch(verb) {
        case "attack":
        case "behead":
        case "berserk":
        case "bob":
        case "crush":
        case "disarm":
        case "fire":
        case "guard":
        case "hack":
        case "hurl":
        case "iai":
        case "impale":
        case "kill":
        case "punch":
        case "riposte":
        case "slash":
        case "throw":
        case "warcry":
            tell_object(TP, GFR);
            return 1;
        case "cast":
        case "circle":
        case "educe":
        case "forget":
        case "invoke":
        case "remember":
        case "scribe":
        case "scry":
        case "spellcheck":
        case "twist":
        case "use":
        case "zap":
            tell_object(TP, GMR);
            return 1;
        case "bodyguard":
        case "bury":
        case "drag":
        case "eye":
        case "fuel":
        case "hedgehog":
        case "judge":
        case "leatherwork":
        case "mock":
        case "tempt":
        case "scathe":
        case "vurdere":
            tell_object(TP, GOR);
            return 1;
        case "conflagrate":
        case "consecrate":
        case "decompose":
        case "ensumpf":
        case "envalise":
        case "imbue":
        case "perform":
        case "pray":
        case "pyroscipate":
        case "shroud":
        case "suffuse":
        case "ventisepelate":
            tell_object(TP, GRR);
            return 1;
        case "abscond":
        case "ambush":
        case "case":
        case "conceal":
        case "crack":
        case "disable":
        case "filch":
        case "hide":
        case "inhume":
        case "lpick":
        case "palm":
        case "peek":
        case "plant":
        case "probe":
        case "scope":
        case "shoplift":
        case "slip":
        case "snatch":
        case "sneak":
        case "steal":
        case "unhide":
            tell_object(TP, GSR);
            return 1;
        default:
            return 0;
    }
}
int run_away() {
    tell_object(TO, GER);
}

==================================================
FILE: shadows/object/basic_trap.c
==================================================

inherit "/std/effect_shadow";
int trap_lock(string type) {
  if(type != "pick")
    return 0;
  tell_object(this_player(), "Trap triggered.\n");
  return 0;
}

==================================================
FILE: shadows/object/death_ward.c
==================================================

inherit "/std/effect_shadow";
void event_death( object thing, object *killers, object killer,
      string room_mess, string killer_mess ) {
   int damage;
   object twit;
   player->event_death( thing, killers, killer, room_mess, killer_mess );
   if ( thing != (object)player->query_worn_by() )
      return;
   tell_room( environment( thing ), (string)player->the_short() +
         " explodes in a ball of flame!\n" );
   thing->remove_armour( player );
   player->move( "/room/rubbish" );
   foreach ( twit in killers ) {
      if ( environment( twit ) != environment( thing ) )
         continue;
      damage = arg();
      if ( twit == killer )
         damage *= 2;
      damage -= (int)twit->query_ac( "fire", damage );
      if ( damage > 0 )
         twit->adjust_hp( -damage );
      if ( (int)twit->query_hp() < 0 )
         twit->attack_by( player );
   }
   remove_this_effect();
}

==================================================
FILE: shadows/object/identity_hold.c
==================================================

inherit "/std/effect_shadow";
#include <move_failures.h>
private int _keep;
private string _identifier;
private string* _adjs;
private object _owner;
int query_keep() { return _keep; }
void set_keep_value(int keep) { _keep = keep; }
void set_keep() { _keep = 1; }
void reset_keep() {
   _keep = 0;
   if (!_identifier)
      remove_this_effect();
}
string query_identifier() { return _identifier; }
string query_full_identifier() {
    string tmp;
    tmp = "";
    if ( sizeof( _adjs ) ) {
        tmp += implode( _adjs, " " ) + " ";
    }
    if ( _identifier ) {
       tmp += _identifier;
    }
    if ( strlen( tmp ) > 0 ) {
       return tmp;
    }
    return 0;
}
void set_identifier( string word ) {
   string* bits;
   if (word) {
      bits = explode(word, " ");
      _identifier = bits[<1];
      _adjs = bits[0..<2];
   } else {
      _identifier = 0;
      _adjs = ({ });
      if (!_keep)
         remove_this_effect();
   }
}
void set_identity_hold_owner(object ob) {
   _owner = ob;
}
object query_identity_hold_owner() {
   return _owner;
}
string *parse_command_id_list() {
   string *words;
   words = (string *)player->parse_command_id_list();
   if ( ( this_player() == _owner ) && stringp( _identifier ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1 && $1->ignore_identifier() :) ) ) ) {
      words += ({ _identifier });
   }
   return words;
}
string *parse_command_adjectiv_id_list() {
   string *words;
   words = (string *)player->parse_command_adjectiv_id_list();
   if ( ( this_player() == _owner ) && pointerp( _adjs ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1->ignore_identifier() :) ) ) ) {
      words += _adjs;
   }
   return words;
}
private void check_move_stuff() {
   object ob;
   ob = environment(player);
   while (ob &&
          ob != _owner) {
      ob = environment(ob);
   }
   if (ob != _owner) {
      remove_this_effect();
   }
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = player->move( dest, messin, messout );
   if ( flag == MOVE_OK &&
        objectp( dest ) ) {
      call_out((: check_move_stuff :), 2);
   }
   return flag;
}

==================================================
FILE: shadows/object/newbie_shoes.c
==================================================

#include <move_failures.h>
#include "path.h"
inherit "/std/effect_shadow";
int query_orthopaedic_shoes() { return 1; }
string query_msgin()
{
return "$N stagger$s clumsily from $F.";
}
string query_msgout()
{
return "$N stagger$s $T clumsily.";
}
int move(mixed dest, string inmsg, string outmsg)
{
  int ret;
  ret = player->move(dest, inmsg, outmsg);
  if (ret == MOVE_OK) {
    tell_object( player, "You wince as spikes seem to drive themselves "
      "into the balls of your feet, but you get there eventually.\n" );
  }
  return ret;
}
int test_for_effect( object thing ) {
   return member_array( EFFECTS +"newbie_shoes",
      (string *)thing->query_wear_effects() ) != -1;
}
void taken_off(object what, string eff)
{
  if (eff != EFFECTS + "newbie_shoes")
    player->taken_off(what, eff);
  else {
    remove_this_effect();
  }
}

==================================================
FILE: shadows/object/no_save.c
==================================================

inherit "/std/effect_shadow";
mixed query_auto_load() {
   return 0;
}
mixed query_dynamic_auto_load() {
   return 0;
}
mixed query_static_auto_load() {
   return 0;
}

==================================================
FILE: shadows/object/owned_weapon.c
==================================================

inherit "/std/effect_shadow";
mixed set_holder( object thing, int pos ) {
   this_object()->remove_hide_invis( "concealed" );
   if ( objectp( thing ) )
      if ( !thing->query_corpse() &&
            ( (string)thing->query_name() != arg() ) )
         return 0;
   return (mixed)player->set_holder( thing, pos );
}
string query_owner(){
   return (string) arg();
}

==================================================
FILE: shadows/object/path.h
==================================================

#define PATH "/std/shadows/object/"
#undef EFFECTS
#define EFFECTS "/std/effects/object/"

==================================================
FILE: shadows/object/swim_fins.c
==================================================

inherit "/std/effect_shadow";
int query_skill_bonus(string skill, int true) {
  if ((skill != "other.movement.swimming") || true)
    return player->query_skill_bonus(skill);
  return player->query_skill_bonus(skill)+50;
}
