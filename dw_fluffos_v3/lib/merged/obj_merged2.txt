# Total Tokens: 98658
# Total Files Merged: 56
# Total Characters: 329027

==============================================

#define REACTION_HANDLER ("/obj/handlers/reaction")
#define TASTE_AMT 200
#include <tasks.h>
#include <move_failures.h>
#include <volumes.h>
inherit "/obj/baggage";
private int leak_rate;
private int hb_count;
private int sub_query_contents;
private int volume;
private int max_volume;
private int cont_volume;
private int is_liquid;
private nosave int* _fraction;
private nosave object* _liquids;
int drink_amount(int drinking, object player);
private int query_fighting(object player);
void set_leak_rate(int i) { leak_rate = i; }
int query_leak_rate() { return leak_rate; }
void set_max_volume(int v) { max_volume = v; }
int query_max_volume() { return max_volume; }
string *leak_verb = ({ " drips slowly",
                       " drips",
                       " dribbles",
                       " trickles slowly",
                       " trickles",
                       " trickles rapidly",
                       " pours sluggishly",
                       " pours",
                       " streams",
                       " gushes",
                       " fountains"
                     });
string *drink_pat = ({ "[from] <direct:object>",
                       "<fraction> {of|from} <direct:object>"
                   });
string *splash_pat = ({ "[from] <direct:object> {on|to|onto} <indirect:living>",
                       "<fraction> {of|from} <direct:object> {on|to|onto} "
                       "<indirect:living>"
                   });
string *apply_pat = ({ "[from] <direct:object> {on|to} <indirect:living>",
                       "<fraction> {of|from} <direct:object> {on|to} "
                       "<indirect:living>"
                   });
string *pour_pat = ({ "<direct:object> {from|into} <indirect:object>",
                      "<fraction> of <direct:object> {from|into} <indirect:object>"
                  });
string *fill_pat = ({ "<indirect:object> <fraction> full {from|into} <direct:object>",
                      "<indirect:object> <fraction> up {from|into} <direct:object>",
                      "<indirect:object> {from|into} <direct:object>"
                  });
void create() {
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) {
      this_object()->setup();
    }
    add_help_file("vessel");
}
void init() {
    ::init();
    add_command("drink", drink_pat);
    add_command("quaff", drink_pat);
    add_command("splash", splash_pat);
    add_command("rub", apply_pat);
    add_command("apply", apply_pat);
    add_command("pour", pour_pat);
    add_command("taste", "<direct:object>");
    add_command("sip", "<direct:object>");
    add_command("fill", fill_pat);
    add_command("empty", "<direct:object>");
}
string *fullness_adjectives() {
   if (!max_volume) return ({ "totally", "empty" });
   switch (100 * volume / max_volume) {
   case 0..4: return ({ "totally", "empty" });
   case 5..13: return ({ "empty" });
   case 65..94: return ({ "full" });
   case 95..100: return ({ "totally", "full" });
   default: return ({ });
   }
}
mixed stats() {
  return ::stats() + ({
      ({ "leak_rate", leak_rate }),
      ({ "volume", volume }),
      ({ "cont_volume", cont_volume }),
      ({ "liquid", is_liquid }),
      ({ "max_volume", max_volume })
    });
}
int cmp_amount_r(object a, object b) {
    return ((int)b->query_amount() - (int)a->query_amount());
}
int cmp_weight_r(object a, object b) {
    if (a->query_weight() || b->query_weight())
      return ((int)b->query_weight() - (int)a->query_weight());
    return cmp_amount_r(a, b);
}
private void figure_out_liquids() {
   _liquids = filter(all_inventory(this_object()), (: $1->query_liquid() :));
   _liquids = sort_array(_liquids, "cmp_amount_r", this_object());
}
string query_liquid_desc() {
    object *contents, *solids = ({});
    int i;
    string desc, *shorts;
    mixed *others;
    contents = all_inventory(this_object());
    if( !sizeof( contents ) ) {
       return (string) 0;
    }
    figure_out_liquids();
    solids = contents - _liquids;
    if (sizeof(_liquids)) {
       _liquids = sort_array(_liquids, "cmp_amount_r", this_object());
       others = unique_array(_liquids->a_short(),
                          (: "/global/events"->convert_message($1) :));
       shorts = ({ });
       for (i = 0; i < sizeof(others); i++) {
          shorts += ({ others[i][0] });
       }
       desc = shorts[0];
       if (sizeof(shorts) > 1) {
          desc += ", mixed with ";
          if (sizeof(shorts) > 4) {
             desc += "other liquids";
          } else {
             desc += query_multiple_short(shorts[1..]);
          }
       }
    } else {
       desc = "";
    }
    if (!sizeof(solids)) {
        return desc;
    }
    solids = sort_array(solids, "cmp_weight_r", this_object());
    others = unique_array(solids,
                          (: $1->query_continuous()?
                           this_player()->convert_message($1->a_short()) :
                           $1 :) );
    for (i = 0; i < sizeof(others); i++) {
       if( arrayp( others ) ) {
          others[i] = others[i][0];
       } else {
          tell_creator( "gruper", "others is %O.\n", others );
       }
    }
    if (sizeof(_liquids)) {
       desc += ", with ";
    }
    if (sizeof(others) > 10) {
        desc += "various undissolved substances";
    } else {
        desc += query_multiple_short(others);
    }
    if (sizeof(_liquids)) {
       desc += " floating in it";
    }
    return desc;
}
string query_fullness_desc() {
   int full;
   full = (100 * volume) / max_volume;
   if( full < 1 && query_liquid_desc() ) {
      full = 1;
   }
   switch (full) {
      case 0:       return "";
      case 1..12:   return "It is almost empty.";
      case 13..37:  return "It is about one-quarter full.";
      case 38..62:  return "It is about half full.";
      case 63..87:  return "It is about three-quarters full.";
      case 88..95:  return "It is almost full.";
      case 96..100: return "It is completely full.";
      default:      return "Its capacity defies the laws of physics.  "
                           "Please submit a bug report.";
    }
}
varargs string query_contents(string str, object *obs ) {
    string s, c;
    if ( query_liquid_desc() ) {
        c = "\n"+ query_fullness_desc() +"\n";
    } else {
        c = "";
    }
    s = query_liquid_desc();
    if (sub_query_contents) {
        if (s) {
            return str + capitalize(s) + "." + c;
        }
        return ::query_contents(str, obs) + c;
    }
    return ::query_contents(str, obs);
}
string short(int dark) {
  object *inv;
  if(query_opaque())
    return ::short(dark);
  inv = all_inventory(this_object());
  if(!sizeof(inv))
    return ::short(dark);
  return ::short(dark) + " of " +
    "/global/events"->convert_message(query_multiple_short(map(inv,
    (: $1->query_short() :))));
}
string long(string str, int dark) {
    string ret;
    sub_query_contents = 1;
    ret = ::long(str, dark);
    sub_query_contents = 0;
    return ret;
}
int query_cont_volume() { return cont_volume; }
int query_liquid() { return is_liquid; }
void calc_liquid() {
    if (sizeof(filter(all_inventory(), (: $1->query_liquid() :)))) {
      is_liquid = 1;
    } else {
      is_liquid = 0;
    }
}
int query_volume() { return volume; }
int query_volume_left() {
  if (!query_max_weight()) {
    return max_volume - volume;
  }
  return max_volume - volume - (max_volume*query_loc_weight())/query_max_weight();
}
int add_volume(int vol) {
   if ((vol <= 0) || !max_volume || (vol + volume <= max_volume)) {
      volume += vol;
      if (previous_object()->query_continuous()) {
          cont_volume += vol;
      }
      return 1;
    }
    return 0;
}
int add_weight(int n) {
    int v;
    if (this_player() && (this_player()->query_name() == "pinkfish")) {
      tell_creator("pinkfish", "vessel::add_weight(%O)\n", n);
    }
    if (previous_object()->query_continuous()) {
       return (::add_weight(n));
    }
      v = n*200;
    if (max_volume && (v + volume > max_volume)) {
       return 0;
    }
    if (::add_weight(n)) {
        volume += v;
        return 1;
    }
    return 0;
}
int remove_volume(int vol_lost)
{
    int amt_lost, i, orig_cv;
    object *contents;
    if (!cont_volume) {
        return 0;
    }
    orig_cv = cont_volume;
    contents = all_inventory(this_object());
    for (i = 0; i < sizeof(contents); i++) {
        if (contents[i]->query_continuous()) {
            amt_lost = -to_int((int)contents[i]->query_amount()
                               * (to_float(vol_lost) / orig_cv));
            if (!amt_lost) {
                amt_lost++;
            }
            contents[i]->adjust_amount(amt_lost);
        }
    }
    return vol_lost;
}
int xfer_volume(int vol_xferred, object dest) {
    int vol_to_go;
    int i;
    int amt_xferred;
    int tmp;
    int orig_cv;
    object *contents;
    object copy;
    string file_path;
    mapping map;
    vol_to_go = vol_xferred;
    if (!cont_volume) {
        return 0;
    }
    orig_cv = cont_volume;
    contents = filter(all_inventory(this_object()),
                      (: $1->query_continuous() :));
    for (i = 0; i < sizeof(contents) && vol_to_go > 0; i++) {
        if (i == sizeof(contents) - 1) {
            amt_xferred = vol_to_go;
        } else {
            amt_xferred = to_int((int)contents[i]->query_amount()
                                 * (to_float(vol_xferred) / orig_cv));
        }
        if (!amt_xferred) {
            amt_xferred++;
        }
        file_path = explode( file_name(contents[i]), "#" )[ 0 ];
        copy = clone_object(file_path);
        map = (mapping)contents[i]->query_dynamic_auto_load();
        copy->init_dynamic_arg( map );
        map = (mapping)contents[i]->query_static_auto_load();
        if (map) {
            copy->init_static_arg( map );
        }
        copy->set_amount(amt_xferred);
        tmp = copy->move(dest);
        if (tmp == MOVE_OK) {
            vol_to_go -= amt_xferred;
            contents[i]->adjust_amount(-amt_xferred);
        } else {
            copy->dest_me();
        }
    }
    return vol_to_go;
}
void heart_beat() {
    int lost, off;
    if (leak_rate == 0 || !is_liquid) {
        set_heart_beat(0);
        return;
    }
    if (hb_count--) return ;
    hb_count = 10;
    lost = leak_rate;
    if (lost > cont_volume)
      lost = cont_volume;
    off = lost/100;
    if (off > 10)
        off = 10;
    if ( interactive( environment() ) )
        tell_object( environment(), "$C$Some " + query_multiple_short( map( all_inventory(),
        (: $1->query_short() :) ) ) + leak_verb[off] + " out of the "+ short(1) + ".\n" );
    else
      tell_room( environment(), "$C$Some " + query_multiple_short( map( all_inventory(),
        (: $1->query_short() :) ) ) + leak_verb[off] + " out of the "+ short(1) + ".\n" );
  (void)remove_volume(lost);
  if (!cont_volume) {
    set_heart_beat(0);
  }
}
int do_pour(object *to, mixed *args_b, mixed *args_a, mixed *args) {
    int m, n, volume_needed, their_volume, their_max, ovf, xfer_result;
    if (query_fighting(this_player())) {
       add_failed_mess("You cannot attempt to do this while in combat.\n");
       return 0;
    }
    if (environment(this_object()) != this_player()) {
        add_failed_mess("You aren't carrying $D.\n");
        return 0;
    }
    if (sizeof(args) == 5) {
        sscanf(args[0] + " " + args[1], "%d %d", m, n);
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    if (query_locked()) {
        add_failed_mess("$C$$D $V$0=is,are$V$ locked!\n");
        return 0;
    }
    if (query_closed()) {
        if (do_open()) {
            write("You open the " + short(0) + ".\n");
        } else {
            add_failed_mess("You cannot open $D.\n");
            return 0;
        }
    }
    if (cont_volume <= 0) {
        add_failed_mess("$C$$D has nothing to pour!\n");
        return 0;
    }
    if (sizeof(to) > 1) {
        add_failed_mess("You can only pour into one object at a time.\n");
        return 0;
    }
    their_volume = (int)to[0]->query_volume();
    their_max = (int)to[0]->query_max_volume();
    if (their_max <= 0) {
        add_failed_mess("$C$" + to[0]->the_short(0) +
            " doesn't look like it can be filled!\n");
        return 0;
    }
    if (their_volume >= their_max) {
        add_failed_mess("The " + to[0]->short(0)
              + " $V$0=is,are$V$ full to the brim already.\n");
        their_volume = their_max;
    }
    if ((m == 1) && (n == 1)) {
        volume_needed = volume;
    } else {
        volume_needed = max_volume * m / n;
    }
    if (volume < volume_needed) {
        add_failed_mess("$C$$D $V$0=is,are$V$ less than " + m + "/" + n +
              " full.\n");
        return 0;
    }
    if (volume_needed > 120) {
        volume_needed += random(240) - 120;
    }
    if (volume_needed > (their_max - their_volume)) {
        volume_needed = their_max - their_volume;
        ovf = 1;
    }
    if (volume_needed > cont_volume) {
        add_failed_mess("You drain the " + short(0) + " into the "
              + to[0]->short(0) + " but it $V$0=is,are$V$ not enough.\n");
        volume_needed = cont_volume;
        this_player()->add_succeeded(to[0]);
    } else {
        this_player()->add_succeeded(to[0]);
    }
    xfer_result = xfer_volume( volume_needed, to[0] );
    if (xfer_result < volume_needed) {
        this_player()->add_succeeded_mess(this_object(), "$N $V $D into $I.\n", ({to[0]}));
    }
    else {
        add_failed_mess( "You were unable to $V $D into $I.\n", ({to[0]}));
        return 0;
    }
    if (ovf) {
        this_player()->add_succeeded_mess(this_object(), "$N $V $D into $I, " +
            "spilling some in the process.\n", ({to[0]}));
    }
    return 1;
}
int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {
    int m;
    int n;
    int i;
    int run_out;
    int volume_needed;
    int their_volume;
    int their_max;
    int amount_not_poured;
    int ok;
    if (query_fighting(this_player())) {
       add_failed_mess("You cannot attempt to do this while in combat.\n");
       return 0;
    }
    if (sizeof(args) == 4) {
        sscanf(args[1] + " " + args[2], "%d %d", m, n);
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    if (query_closed() &&
        query_locked()) {
        add_failed_mess("$C$$D $V$0=is,are$V$ locked!\n");
        return 0;
    }
    if (query_closed()) {
        if (do_open()) {
            write("You open the " + short(0) + ".\n");
        } else {
            add_failed_mess("You cannot open $D.\n");
            return 0;
        }
    }
    if (cont_volume <= 0) {
        add_failed_mess("$C$$D has nothing to pour!\n");
        return 0;
    }
    run_out = 0;
    for (i = 0; i < sizeof(to) && !run_out; i++) {
        if ((environment(this_object()) != this_player()) &&
            (environment(to[i]) != this_player())) {
            write("You're not carrying " + the_short() + " or " +
                  to[i]->the_short() + ".\n");
            continue;
        }
        if (to[i]->query_closed()) {
            add_failed_mess("$I $V$0=is,are$V$ closed.\n", to[i..i]);
            continue;
        }
        their_volume = (int)to[i]->query_volume();
        their_max = (int)to[i]->query_max_volume();
        if (their_max <= 0) {
            add_failed_mess("$I doesn't look like it can be filled!\n",
                            to[i..i]);
            continue;
        }
        if (their_volume >= their_max) {
            add_failed_mess("$I $V$0=is,are$V$ full to the brim already.\n", to[i..i]);
            continue;
        }
        volume_needed = their_max * m / n;
        if (their_volume >= volume_needed) {
            add_failed_mess("$I $V$0=is,are$V$ more than " + m + "/" + n +
                  " full already.\n", to[i..i]);
            continue;
        }
        if (volume_needed > 120) {
            volume_needed += random(240) - 120;
        }
        if (volume_needed > their_max) {
            volume_needed = their_max;
        }
        ok++;
        volume_needed -= their_volume;
        if (volume_needed > cont_volume) {
            add_failed_mess("You drain " + the_short() + " into "
                  + to[i]->the_short() + " but it $V$0=is,are$V$ not enough.\n");
            volume_needed = cont_volume;
            run_out = 1;
            this_player()->add_succeeded(to[i]);
        } else {
            this_player()->add_succeeded(to[i]);
        }
        amount_not_poured = xfer_volume(volume_needed, to[i]);
        if (amount_not_poured) {
           ok--;
        }
    }
    if (!ok) {
       add_failed_mess("You cannot seem to do anything useful with this "
                       "container, it seems unwilling to accept what you "
                       "offer.\n");
    }
    return ok;
}
private int query_fighting(object player) {
   object ob;
   if (!player || !environment(player)) {
      return 0;
   }
   if (player->query_fighting()) {
      return 1;
   }
   foreach (ob in all_inventory(environment(player))) {
      if (living(ob)) {
         if (ob->query_attacker_list() &&
             member_array(this_player(), ob->query_attacker_list()) != -1) {
            return 1;
         }
      }
   }
   if (environment(ob)->query_mirror_room()) {
      foreach (ob in all_inventory(environment(player)->query_mirror_room())) {
         if (living(ob)) {
            if (member_array(this_player(), ob->query_attacker_list()) != -1) {
               return 1;
            }
         }
      }
   }
}
int is_fighting_bottle_smashed(object player,
                               object me) {
   object* fighting;
   object ob;
   object weapon;
   string skill;
   string my_skill;
   int bonus;
   int stopped;
   stopped = 0;
   if (query_fighting(player)) {
      fighting = filter(player->query_attacker_list(),
                        (: environment($1) == $2 :), environment(player));
      if (query_holder()) {
         bonus = 0;
         bonus += -10 * player->query_free_limbs();
      } else {
         bonus = 20;
      }
      if (sizeof(fighting)) {
         bonus += (sizeof(fighting) - 1) * 20;
      }
      if (player->query_free_limbs() < 2 &&
          !query_holder()) {
         bonus += 50 - player->query_free_limbs() * 25;
      }
      foreach (ob in fighting) {
         if (sizeof(ob->query_holding() - ({ 0 }))) {
            weapon = (ob->query_holding() - ({ 0 }))[0];
            skill = weapon->query_weapon_type();
            if (skill == "mixed" ||
                (skill != "sharp" && skill != "blunt" && skill != "pierce")) {
               skill = ({ "sharp", "blunt", "pierce" })[random(3)];
            }
            skill = "fighting.combat.melee." + skill;
         } else {
            skill = "fighting.combat.melee.unarmed";
         }
         my_skill = "fighting.combat.special.unarmed";
         switch (player->query_combat_response()) {
         case "parry" :
            my_skill = "fighting.combat.parry.melee";
            break;
         case "dodge" :
            my_skill = "fighting.combat.dodging.melee";
            break;
         case "neutral" :
            my_skill = "fighting.combat." +
            (({ "parry", "dodging" })[random(2)]) + ".melee";
         }
         switch (TASKER->compare_skills(player,
                                       my_skill,
                                       ob,
                                       skill,
                                       -bonus,
                                       TM_FREE,
                                       TM_FREE)) {
         case OFFAWARD :
            if (player->query_combat_response() == "dodge") {
               tell_object(player,
                           "%^YELLOW%^You nimbly dodge an attack to avoid "
                           "getting " +
                           me->poss_short() +
                           " smashed out of your hand and feel better about "
                           "attempting it next time.\n%^RESET%^");
            } else {
               tell_object(player,
                           "%^YELLOW%^You nimbly parry an attack to avoid "
                           " getting " +
                           me->poss_short() +
                           " smashed out of your hand and feel better about "
                           "attempting it next time.\n%^RESET%^");
            }
         case OFFWIN :
            tell_room(environment(player),
                      player->the_short() + " avoids getting " +
                      me->poss_short() + " smashed by " +
                      query_multiple_short(({ ob })) + ".\n",
                               ({ player }));
            tell_object(player,
                        "You avoid getting " + me->poss_short() +
                        " smashed by " + query_multiple_short(({ ob })) +
                        ".\n");
            do_damage("crush", 20 + random(50));
            break;
         case DEFAWARD :
            tell_object(ob,
                        "%^YELLOW%^You feel much more able to smash "
                        "bottles out of peoples hands than "
                        "before.\n%^RESET%^");
         case DEFWIN :
            if (!query_holder() &&
                me->move(environment(player)) == MOVE_OK) {
               tell_room(environment(player),
                   ob->the_short() + " smashes " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n",
                   ({ player, me }));
               tell_object(player,
                   ob->the_short() + " smashes " + the_short() + " out of " +
                   "your hands onto the ground "
                   "causing some of the liquid to splash out.\n");
               tell_object(me,
                   ob->the_short() + " smash " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n");
            } else {
               tell_room(environment(player),
                   ob->the_short() + " smashes " + the_short() + " away "
                   "from " + player->the_short() + "'s mouth causing "
                   "some of the liquid to splash out.\n", ({ player, me }));
               tell_object(player,
                   ob->the_short() + " smashes " + the_short() + " away "
                   "from " + "your mouth causing some of the liquid to "
                   "splash out.\n");
               tell_object(me,
                   ob->the_short() + " smash " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n");
            }
            stopped = 1;
            break;
         }
         if (stopped) {
            break;
         }
      }
   }
   return stopped;
}
private string consumed_desc( int consumed_amount ) {
   string amount_desc;
   object* contents;
   string* contents_descs = ({ });
   string contents_desc;
   contents = all_inventory( this_object() );
   if( !consumed_amount || !sizeof( contents ) )
      return "nothing much";
   switch( consumed_amount ) {
   case 1..30:
      amount_desc = "a teaspoon";
      break;
   case 31..80:
      amount_desc = "a tablespoon";
      break;
   case 81..140:
      amount_desc = "an ounce";
      break;
   case 141..800:
      amount_desc = "a few ounces";
      break;
   case 801..1200:
      amount_desc = "a cup";
      break;
   case 1201..2000:
      amount_desc = "a couple of cups";
      break;
   case 2001..3500:
      amount_desc = "a pint";
      break;
   case 3501..7000:
      amount_desc = "a couple of pints";
      break;
   case 7001..15000:
      amount_desc = "several pints";
      break;
   case 15001..25000:
      amount_desc = "about a gallon";
      break;
   default:
      amount_desc = "several gallons";
   }
   contents = filter( contents, (: $1->query_liquid() :) );
   foreach( string* frog in unique_array( contents->short(), (: $1 :) ) ) {
      if( sizeof( frog ) > 1 ) {
         contents_descs += ({ pluralize( frog[0] ) });
      } else {
         contents_descs += ({ frog[0] });
      }
   }
   contents_desc = query_multiple_short( contents_descs );
   return amount_desc +" of "+ contents_desc;
}
int drink_amount(int drinking,
                 object player) {
   int cap_amount;
   int amt_to_drink;
   int amount_can_be_drunk;
   object* contents;
   object ob;
   int orig_cv;
   amt_to_drink = drinking;
   if (amt_to_drink > cont_volume) {
      amt_to_drink = cont_volume;
   }
   if (max_volume / 20 > VOLUME_WINE) {
      cap_amount = max_volume / 20;
   } else {
      cap_amount = VOLUME_WINE;
   }
   if (amt_to_drink < cap_amount) {
      if (query_fighting(player)) {
         amt_to_drink += random(2 * (cap_amount - amt_to_drink)) -
                         cap_amount - amt_to_drink;
         if (amt_to_drink < VOLUME_MINIMUM_DRINKABLE * 2) {
            amt_to_drink = VOLUME_MINIMUM_DRINKABLE * 2;
         }
      } else {
         amt_to_drink += random((cap_amount - amt_to_drink) / 6) -
                         (cap_amount - amt_to_drink) / 12;
      }
   }
   if (amt_to_drink < VOLUME_MINIMUM_DRINKABLE) {
      amt_to_drink = VOLUME_MINIMUM_DRINKABLE;
   }
   if (amt_to_drink < (max_volume / 100)) {
      amt_to_drink = max_volume / 100;
   }
   if( amt_to_drink > cont_volume ) {
      amt_to_drink = cont_volume;
   }
   amount_can_be_drunk = (8000 - (int)this_player()->query_volume(2)) *
     (int)this_player()->query_con() / 12;
   if (amt_to_drink > amount_can_be_drunk) {
       write("You drink some of the liquid, "
             "but simply cannot fit it all in.\n");
       amt_to_drink = amount_can_be_drunk;
   }
   if (is_fighting_bottle_smashed(this_player(), this_object())) {
      amt_to_drink *= (1 + random(15));
      if (amt_to_drink > volume) {
         amt_to_drink = volume;
      }
      orig_cv = cont_volume;
      foreach (ob in all_inventory(this_object())) {
         if (ob->query_continuous()) {
            if (amt_to_drink == cont_volume) {
               ob->adjust_amount(-ob->query_amount());
            } else {
               ob->adjust_amount(-(ob->query_amount() * amt_to_drink / orig_cv));
            }
         }
      }
      add_succeeded_mess("");
      do_damage("crush", 50 + random(300));
      return 1;
   }
   contents = all_inventory(this_object());
   if( sizeof( contents[0]->query_eat_mess() ) ) {
      add_succeeded_mess( contents[0]->query_eat_mess() );
   } else {
      add_succeeded_mess("$N $V "+ consumed_desc( amt_to_drink ) +
                         " from $D.\n");
   }
   if (amt_to_drink - drinking > (max_volume / 40) &&
       amt_to_drink - drinking > VOLUME_MINIMUM_DRINKABLE) {
      add_succeeded_mess(({ "Whoops!  You seemed to have gulped "
                            "too much down.\n",
                            "" }));
   }
   orig_cv = cont_volume;
   foreach (ob in contents) {
       if (ob->query_continuous()) {
           if (amt_to_drink == orig_cv) {
               ob->consume(this_player(), ob->query_amount());
           } else {
               ob->consume(this_player(),
                           ob->query_amount() * amt_to_drink / orig_cv);
           }
       }
   }
   return 1;
}
int do_drink(object *dest, mixed me, mixed him, mixed args, string pattern)
{
    int amt_to_drink;
    int m;
    int n;
    if (sizeof(dest)) {
        add_failed_mess("Drinking is a very simple operation "
              "- please don't complicate matters.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        add_failed_mess("You aren't carrying $D.\n");
        return 0;
    }
    if (!ensure_open()) {
       return 0;
    }
    if (!is_liquid) {
        add_failed_mess("$C$$D $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    if (pattern == drink_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ( n > 100 ) {
          add_failed_mess( "You can't drink with that much precision!\n" );
          return 0;
        }
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    if (_fraction) {
        m = _fraction[0];
        n = _fraction[1];
    }
    if ((m == 1) && (n == 1)) {
        amt_to_drink = cont_volume;
    } else {
        amt_to_drink = (max_volume*m)/n;
        if (amt_to_drink > volume) {
            add_failed_mess("$C$$D $V$0=is,are$V$ less than " + m + "/" + n +
                  " full.\n");
            return 0;
        }
        if (amt_to_drink > cont_volume) {
            amt_to_drink = cont_volume;
        }
    }
    if (!drink_amount(amt_to_drink, this_player())) {
       return 0;
    }
    switch ((this_player()->query_volume(2) + 100) / 200) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        break;
      case 5:
        write("You feel mildly full of liquid.\n");
        break;
      case 6:
        write("You feel very full of liquid.\n");
        break;
      case 7:
        write("You feel all the liquid sloshing around inside you.\n");
        break;
      case 8:
        write("You are awash with liquid.\n");
        break;
      case 9:
        write("You are full to the brim with liquid.\n");
        break;
      default:
        write("You feel you would burst if you drank any more.\n");
        break;
    }
    return 1;
}
int do_quaff(object *dest, mixed me, mixed him, mixed args, string pattern) {
   return do_drink(dest, me, him, args, pattern);
}
int do_empty(object *dest, string me, string him, string prep)
{
   if (environment(this_object()) != this_player()) {
       add_failed_mess("You are not carrying $D.\n");
       return 0;
   }
   if (sizeof(dest)) {
       write("Passing on to pour ... bad move.\n");
   }
   if (!ensure_open()) {
      add_failed_mess("$C$$D $V$0=is,are$V$ not open.\n");
      return 0;
   }
   if (cont_volume == 0 &&
       !sizeof(all_inventory())) {
       add_failed_mess("$C$$D $V$0=is,are$V$ already empty.\n");
       return 0;
   }
   (void)remove_volume(cont_volume);
   all_inventory()->move(environment(this_player()));
   return 1;
}
int check_splashable(object ob, object splasher, object splashee){
  return ob->query_splashable(splasher, splashee);
}
int do_splash(object *dest, mixed me, mixed him, mixed args, string pattern) {
    int amt_to_splash, i, m, n, orig_cv;
    object *contents;
    if (!sizeof(dest)) {
        add_failed_mess("Splash it on who?\n");
        return 0;
    }
    if(sizeof(dest) >1){
        add_failed_mess("You may only splash one person at a time.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) return 0;
    if (!is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    if (pattern == splash_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ((m > n) || (m < 0) || (n <= 0)) {
            notify_fail("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    contents = filter( all_inventory(this_object()), (:check_splashable:),
          this_player(), dest[0]);
    if( !sizeof(contents) ){
       add_failed_mess("You can't splash anything in $D.\n");
       return 0;
    }
    orig_cv = cont_volume;
    if ( m == n ){
        amt_to_splash = cont_volume;
    } else {
        amt_to_splash = (max_volume*m)/n;
        if (amt_to_splash > volume) {
            add_failed_mess("The " + short(0) + " $V$0=is,are$V$ less than "
               + m + "/" + n + " full.\n");
            return 0;
        }
        if (amt_to_splash > cont_volume) {
            amt_to_splash = cont_volume;
        }
    }
    if(this_player() == dest[0]){
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto "+this_player()->query_objective() +
                     "self.\n", ({}));
    }else{
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto $I.\n", dest);
    }
    for (i = 0; i < sizeof(contents); i++) {
        if (amt_to_splash == cont_volume) {
           contents[i]->consume(dest[0],
           contents[i]->query_amount(), "splash");
        } else {
           contents[i]->consume(dest[0],
              (int)contents[i]->query_amount()
              * amt_to_splash / orig_cv, "splash");
        }
    }
    return 1;
}
int check_applicable(object ob, object applier, object appliee){
  return ob->query_applicable(applier, appliee);
}
int do_rub(object *dest, mixed me, mixed him, mixed args, string pattern) {
    int amt_to_apply, i, m, n, orig_cv;
    object *contents;
    if (!sizeof(dest)) {
        add_failed_mess("Rub it on who?\n");
        return 0;
    }
    if(sizeof(dest) >1){
        add_failed_mess("You may only rub stuff on one person at a time.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) return 0;
    if (!is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    if (pattern == apply_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ((m > n) || (m < 0) || (n <= 0)) {
            notify_fail("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    contents = filter( all_inventory(this_object()), (:check_applicable:),
        this_player(), dest[0]);
    if( !sizeof(contents) ){
       add_failed_mess("You can't rub anything in $D on $I.\n",dest);
    }
    orig_cv = cont_volume;
    if ( m == n ){
        amt_to_apply = cont_volume;
    } else {
        amt_to_apply = (max_volume*m)/n;
        if (amt_to_apply > volume) {
            add_failed_mess("The " + short(0) + " $V$0=is,are$V$ less than "
               + m + "/" + n + " full.\n");
            return 0;
        }
        if (amt_to_apply > cont_volume) {
            amt_to_apply = cont_volume;
        }
    }
    if (this_player() == dest[0]){
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto "+this_player()->query_objective()+"self.\n", ({}));
    } else {
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto $I.\n", dest);
    }
    for (i = 0; i < sizeof(contents); i++) {
        if (amt_to_apply == cont_volume) {
           contents[i]->consume(dest[0],
                          contents[i]->query_amount(),"apply");
        } else {
           contents[i]->consume(dest[0],
              (int)contents[i]->query_amount()
              * amt_to_apply / orig_cv, "apply");
        }
    }
    return 1;
}
int do_apply(object *dest, mixed me, mixed him, mixed args, string pattern){
   return do_rub(dest, me, him, args, pattern);
}
int do_taste() {
    int amount_tasted;
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) {
       return 0;
    }
    if (!cont_volume || !is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    amount_tasted = VOLUME_SHOT;
    if (cont_volume < amount_tasted) {
        amount_tasted = cont_volume;
    }
    if (amount_tasted < max_volume / 100) {
       amount_tasted = max_volume / 100;
    }
    return drink_amount(amount_tasted, this_player());
}
int do_sip() {
   int amount_tasted;
   if (environment(this_object()) != this_player()) {
      write("You aren't carrying the " + short(0) + ".\n");
      return 0;
   }
   if (!ensure_open()) {
      return 0;
   }
   if (!cont_volume || !is_liquid) {
      add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
      return 0;
   }
   amount_tasted = VOLUME_SHOT * 2;
   if (cont_volume < amount_tasted) {
      amount_tasted = cont_volume;
   }
   if (amount_tasted < max_volume / 70) {
      amount_tasted = max_volume / 70;
   }
   return drink_amount(amount_tasted, this_player());
}
int do_smell() {
   if (!ensure_open()) {
      return 0;
   }
   write("Smelling isn't implemented yet.  Sorry.\n");
   return 1;
}
protected int handle_restore_inventory(object ob) {
   int ret;
   ret = ::handle_restore_inventory(ob);
   if (ret == MOVE_OK) {
      return MOVE_OK;
   }
   if (ob->query_liquid()) {
      ob->set_amount( query_max_volume() - query_volume() );
      ret = ::handle_restore_inventory(ob);
      if (ret == MOVE_OK) {
         return MOVE_OK;
      }
   }
   return ret;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp, "leak rate" : leak_rate,
           "max volume" : max_volume,
          ]);
}
mapping query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/vessel" ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["leak rate"]))
    leak_rate = args["leak rate"];
  if (!undefinedp(args["max volume"]))
    max_volume = args["max volume"];
}
int test_add(object ob, int flag) {
    int new_vol;
    if ( !::test_add( ob, flag ) ) {
        return 0;
    }
    if (ob->query_continuous()) {
        new_vol = ob->query_amount();
    } else if (ob->query_property("density")) {
        new_vol = (int)ob->query_weight()*(int)ob->query_property("density");
    } else {
        new_vol = 0;
    }
    if ((new_vol + volume) > max_volume) {
        return 0;
    }
    return 1;
}
void event_enter(object ob, string message, object from) {
    int ob_vol, ob_cont;
    if (environment(ob) == this_object()) {
        if (ob->query_continuous() ) {
            ob_vol = ob->query_amount();
            ob_cont = 1;
        } else if (ob->query_property("density")) {
            ob_vol = (int)ob->query_weight()*
              (int)ob->query_property("density");
        } else {
            ob_vol = 0;
        }
        if (ob->query_liquid()) {
           is_liquid = 1;
           _liquids = ({ });
        }
#ifdef DEBUG
        debug_printf("Increasing volume by " + ob_vol + ".\n");
#endif
        volume += ob_vol;
        if (ob_cont) cont_volume += ob_vol;
        REACTION_HANDLER->check_reaction(ob);
        if (leak_rate > 0) {
            set_heart_beat(1);
        }
    }
}
void event_exit(object ob, string mess, object to) {
    int ob_vol, ob_cont;
    if (environment(ob) == this_object()) {
        if (ob->query_continuous()) {
            ob_vol = ob->query_amount();
            ob_cont = 1;
        } else if (ob->query_property("density")) {
            ob_vol = (int)ob->query_weight()*
              (int)ob->query_property("density");
        } else {
            ob_vol = 0;
        }
#ifdef DEBUG
        debug_printf("Decreasing volume by " + ob_vol + ".\n");
#endif
        volume -= ob_vol;
        if (ob_cont) cont_volume -= ob_vol;
        if (volume <= 0) is_liquid = 0;
    }
}
void break_me() {
  object *liquid;
   liquid = filter(all_inventory(), (: $1->query_liquid() :));
   if (sizeof(liquid)) {
      tell_room(environment(),
         query_multiple_short(liquid) + " splashes all over the place "
         "as " + the_short() + " breaks.\n");
       liquid->move("/room/rubbish");
   }
   ::break_me();
}
mixed* parse_match_object(string* input, object player,
                          class obj_match_context context) {
   int result;
   result = ::is_matching_object(input, player, context);
   if (result) {
      _fraction = context->fraction;
      if (update_parse_match_context(context, 1, result)) {
         return ({ result, ({ this_object() }) });
      }
   }
   return 0;
}
string *parse_command_adjectiv_id_list() {
   string *ret;
   ret =  fullness_adjectives() + ::parse_command_adjectiv_id_list();
   if (is_liquid && !query_opaque()) {
      object liquid;
      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_adjectiv_id_list();
      }
      return ret;
   }
   return ret;
}
string* parse_command_id_list() {
   if (is_liquid && !query_opaque()) {
      string* ret;
      object liquid;
      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      ret = ::parse_command_id_list();
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_id_list();
      }
      return ret;
   }
   return ::parse_command_id_list();
}
string* parse_command_plural_id_list() {
   if (is_liquid && !query_opaque()) {
      string* ret;
      object liquid;
      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      ret = ::parse_command_plural_id_list();
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_plural_id_list();
      }
      return ret;
   }
   return ::parse_command_plural_id_list();
}
int query_vessel() { return 1; }

==================================================
FILE: virtual_room.c
==================================================

inherit "/std/room";
#include <virtual_room.h>
nosave mixed  *reset_definitions;
nosave object *reset_objects;
void add_cloned_object( int flag, int delay, mixed clone_info,
                       string entry_mess ) {
   if ( functionp( clone_info ) )
      clone_info = bind( clone_info, this_object() );
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
}
mixed *query_cloned_objects() {
   return reset_objects + ({ });
}
mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
}
private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
}
protected void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
}
void reset() {
   int i;
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] ||
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 ) {
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            } else {
               make_object( i );
            }
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 ) {
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            } else {
               make_object( i );
            }
         }
      }
   }
}

==================================================
FILE: wand.c
==================================================

#include <artifacts.h>
#include <tasks.h>
inherit "/obj/weapon";
inherit "/std/basic/artifact";
int query_magic_wand() { return 1; }
void create() {
  weapon::create();
  set_artifact_type( "wand" );
}
void set_weight( int number ) {
  weapon::set_weight( number );
  new_weapon( 80 * number );
   add_attack( "prod", 90, ({ 0, 5, weight }), "blunt", "blunt", 0 );
}
string long( int word, int dark ) {
  return artifact::long( word, dark ) + weapon::long( word, dark );
}
void init() {
  this_player()->add_command( "zap", this_object(), "<direct:object> at <indirect:object>" );
  this_player()->add_command( "zap", this_object(), "<indirect:object> with <direct:object>" );
}
int do_zap( object *things ) {
  int outcome;
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to $V it.\n", ({ }) );
    return 0;
  }
  if( ( sizeof( things ) > 1 ) ||
      ( sizeof( filter( things, (: $1->query_amount() > 1 :)) ) )
    ){
    this_player()->add_failed_mess( this_object(), "You can only zap $D "+
        "at one object at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot zap $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  outcome = (int)TASKER->perform_task(this_player(), WAND_SKILL, level,
                                      TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to $V $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
   if ( outcome == AWARD ) {
      write( "%^YELLOW%^"+ ({ "A piece of lore concerning wands becomes "
            "clearer for you", "You manage to grasp one of the principles "
            "of magic wands more firmly", "A sudden flash of insight allows "
            "you to understand the wand a little better" })[ random( 3 ) ] +
            ".%^RESET%^\n" );
   }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( things[ 0 ], this_player(), this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D at $I but "+
          "nothing happens!\n", things );
    return 1;
  }
  zapper->zap( things[ 0 ], this_player(), this_object() );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
}
mixed *stats() {
  return weapon::stats() + artifact::stats();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : weapon::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/wand" )
    return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
}

==================================================
FILE: weapon.c
==================================================

inherit "/std/object";
inherit "/std/weapon_logic";
inherit "/std/basic/condition";
inherit "/std/basic/holdable";
#include "weapon.h"
#include "money.h"
#include <move_failures.h>
#include <virtual.h>
string *un_modifyable;
mixed *wield_func;
void create() {
   set_damage_chance( 25 );
   un_modifyable = ({ });
   weapon_logic::create();
   holdable::create();
   condition::create();
   object::create();
   add_alias("weapon");
   add_plural("weapons");
   if (!query_property("shop type")) {
      add_property("shop type", "armoury");
   }
   add_help_file("weapon");
}
string short(int dark) {
   string str;
   str = "";
   return ::short(dark)+str;
}
void set_wield_func(string func, mixed ob) {
   if (!func) {
      wield_func = 0;
   } else {
      wield_func = ({ func, ob });
   }
}
int query_weapon() { return 1; }
string long(string s, int dark) {
   return ::long(s, dark)+cond_string();
}
void new_weapon( int new_condition ) {
   set_cond( new_condition );
   set_max_cond( new_condition );
   set_lowest_cond( new_condition );
}
int held_this_item(int held, object holder, mixed arg) {
  int weight;
  object weapon;
  if(held == 1 && interactive(holder)) {
    weight = this_object()->query_weight();
    foreach(weapon in holder->query_weapons())
      weight += weapon->query_weight();
    weight -= holder->query_str();
    switch(weight) {
    case 76..10000:
      tell_object(holder, "You struggle to hold " +
                  query_multiple_short(holder->query_holding() +
                                       ({ this_object() }) - ({ 0 })) +
                  ".\n");
      break;
    case 50..75:
      tell_object(holder, "You struggle slightly to hold " +
                  query_multiple_short(holder->query_holding() +
                                       ({ this_object() }) - ({ 0 })) +
                  ".\n");
      break;
    default:
    }
  }
  if (wield_func) {
    if (!held) {
      return call_other(wield_func[1], wield_func[0], 0);
    } else if (held == 1) {
      return call_other(wield_func[1], wield_func[0], holder);
    }
  }
  return 1;
}
varargs int move( mixed dest, string messin, string messout ) {
   int ret;
   int limb;
   object holder;
   limb = query_my_limb();
   holder = query_holder();
   ret = holdable::move(dest);
   if (ret != MOVE_OK) {
      return ret;
   }
   ret = object::move( dest, messin, messout );
   if (ret != MOVE_OK && holder) {
      holder->set_hold(this_object(), limb);
   }
   return ret;
}
void dest_me() {
  holdable::dest_me();
  object::dest_me();
}
int modify_damage(int val, string name) {
  int tmp;
  tmp = val + (val * query_enchant()) /
    (query_max_enchant() + query_enchant());
  if(member_array(name, un_modifyable) != -1)
    return tmp;
  tmp = ( tmp * query_cond() ) / query_max_cond();
  if(tmp < val / 10)
    return val / 10;
  return tmp;
}
void hit_weapon( int amount, string type ) {
   if ( member_array( type, un_modifyable) != -1 )
      return;
   do_damage( type, amount );
}
int add_immune(string name) {
   if (member_array(name, un_modifyable) != -1)
      return 0;
   un_modifyable += ({ name });
   return 1;
}
int remove_immune(string name) {
   int i;
   if ((i = member_array(name, un_modifyable)) == -1)
      return 0;
   un_modifyable = delete(un_modifyable, i, 1);
   return 1;
}
int query_value() {
   return ( ::query_value() * ( 10 + ( 90 * query_cond() ) /
                               query_max_cond() ) ) / 100;
}
int query_full_value() { return ::query_value(); }
mixed *query_money_array() {
   return (mixed *)MONEY_HAND->create_money_array(query_value());
}
int query_money(string type) {
   int i;
   mixed *m_a;
   m_a = (mixed *)MONEY_HAND->create_money_array(query_value());
   if ((i=member_array(type, m_a)) == -1)
      return 0;
   return m_a[i+1];
}
mixed *stats() {
   return
      object::stats() +
      condition::stats() +
      weapon_logic::stats();
}
void break_me() {
   if ( query_holder() ) {
      tell_object( query_holder(), "%^RED%^$C$"+ the_short() +" breaks!%^RESET%^\n" );
      tell_room( environment( query_holder() ), poss_short() +
                 " breaks!\n", query_holder() );
      query_holder()->set_unhold( this_object() );
   }
   ::break_me();
}
void player_wield(int pos) {
  if (!environment()) {
    return;
  }
  this_object()->hold_item( environment(), pos );
}
mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/weapon" )
      return int_query_static_auto_load();
   return 0;
}
mapping int_query_static_auto_load() {
   mapping tmp;
   tmp = object::int_query_static_auto_load();
   return ([ "::" : tmp,
      "attack names" : attack_names,
      "attack data" : attack_data,
      "attack types" : attack_types,
      "hold" : holdable::query_static_auto_load(),
      "condition" : condition::query_static_auto_load()
          ]);
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([
      "::" : object::query_dynamic_auto_load(),
      "condition" : condition::query_dynamic_auto_load(),
      "hold" : holdable::query_dynamic_auto_load(),
           ]);
   return map;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) return ;
   if ( map[ "::" ] ) {
      object::init_static_arg( map[ "::" ] );
   }
   if ( map[ "attack names" ] ) {
      attack_names = map[ "attack names" ];
   }
   if ( map[ "attack data" ] ) {
      attack_data = map[ "attack data" ];
   }
   if ( map[ "attack types" ] ) {
      attack_types = map[ "attack types" ];
   }
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_static_arg( map[ "condition" ] );
   }
   if (map["no limbs"]) {
      holdable::init_static_arg(map);
   } else {
      holdable::init_static_arg(map["hold"]);
   }
}
void replace_me(){
  object receipt;
  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}
void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_dynamic_arg( map[ "condition" ] );
   }
   holdable::init_dynamic_arg(map["hold"], 1);
   if( virt_name = query_property( VIRTUAL_NAME_PROP) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
}

==================================================
FILE: potions/potion.c
==================================================

inherit "/std/object";
#include <tasks.h>
#define SKILL_WGT 0
#define SKILL_MAX 1
#define SKILL_LVL 2
#define SKILL_ADV 3
#define REAGENTS "/obj/reagents/"
int min_level, max_level, advance_chance, backfire_chance, rel_strength;
mapping skills = allocate_mapping(1);
string *skill_str, reagent_alias, backfire_alias, potion_verb, recipe;
string chant;
void set_min_level(int l) { min_level = l; }
void set_max_level(int l) { max_level = l; }
int query_min_level() { return min_level; }
int query_max_level() { return max_level; }
void set_advance_chance(int c) { advance_chance = c; }
int query_advance_chance() { return advance_chance; }
void set_backfire_chance(int c) { backfire_chance = c; }
int query_backfire_chance() { return backfire_chance; }
void set_reagent_alias(string s) { reagent_alias = s; }
string query_reagent_alias() { return reagent_alias; }
void set_backfire_alias(string s) { backfire_alias = s; }
string query_backfire_alias() { return backfire_alias; }
void set_rel_strength(int s) { rel_strength = s; }
int query_rel_strength() { return rel_strength; }
void set_potion_verb(string s) { potion_verb = s; }
string query_potion_verb() { return potion_verb; }
void set_recipe(string s) { recipe = s; }
string query_recipe() { return recipe; }
void set_chant(string s) { chant = s; }
string query_chant() { return chant; }
void set_skills(mixed s) {
    int i;
    for (i = 0; i < (sizeof(s)); i++) {
        skills[s[i][0]] = ({s[i][SKILL_WGT+1], s[i][SKILL_MAX+1],
                            s[i][SKILL_LVL+1], 0});
    }
    skill_str = keys(skills);
}
mapping query_skills() { return skills; }
object clone_reagent(string given_verb) {
    int result, i, sum, x;
    string s;
    object ob;
    if (potion_verb != given_verb) return 0;
    for (i = 0; i < sizeof(skill_str); i++) {
        s = skill_str[i];
        skills[s][SKILL_ADV] = 0;
        if (skills[s][SKILL_LVL]) {
            if ((x = (int)this_player()->query_skill(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        } else {
            if ((x = (int)this_player()->query_skill_bonus(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        }
        sum += x * skills[s][SKILL_WGT];
    }
    result = TASKER->attempt_task(min_level, sum, advance_chance,
                          (max_level - min_level));
    if ((result == FAIL) || (result == BARF)) {
        if (random(100) < backfire_chance) {
            ob = clone_object(REAGENTS+"brew_reagent.ob");
            ob->set_medium_alias(backfire_alias);
            ob->set_amount(sum*rel_strength/min_level);
            return ob;
        }
        return 0;
    }
    if (result == AWARD) {
        for (i = 0; i < sizeof(skill_str); i++) {
            s = skill_str[i];
            if (skills[s][SKILL_ADV]) {
                this_player()->add_skill_level(s, 1, 0);
            }
        }
    }
    ob = clone_object(REAGENTS+"brew_reagent.ob");
    ob->set_medium_alias(reagent_alias);
    ob->set_amount(sum*rel_strength/min_level);
    return ob;
}

==================================================
FILE: fungi/blue_nightcap.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "blue capped" );
  set_type( "mushroom" );
  set_extra( "The shape of it reminds you of someone wearing a nightcap." );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/tranquil_sleep", 60 +
        random( 60 ) );
  ::next_stage();
}

==================================================
FILE: fungi/fire_mushroom.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "red stalked" );
  set_type( "mushroom" );
  set_extra( "It seems to be gently smoking." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ swells and suddenly releases a cloud of smoke.\n",
    "There is a flash at the base of the $type$ and with a small roar, it "+
        "rockets into the sky.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/basic_charging", 20 +
        random( 11 ) );
  ::next_stage();
}
int query_charging_power() {
  int denominator, numerator, wholes;
  mapping eat_effects;
  eat_effects = query_eat_effects();
  if ( !query_continuous() )
    return eat_effects[ "/std/effects/ingested/basic_charging" ] *
      (int)this_object()->query_weight();
  denominator = query_weight_unit()[ 1 ];
  numerator = eat_effects[ "/std/effects/ingested/basic_charging" ] *
    query_amount() * query_weight_unit()[ 0 ];
  wholes = numerator / denominator;
  numerator %= denominator;
  if ( random( denominator ) < numerator )
    wholes++;
  return wholes;
}

==================================================
FILE: fungi/glow_toadstool.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "yellow spotted" );
  set_type( "toadstool" );
  set_extra( 0 );
}
void next_stage() {
  if ( stage == 8 ) {
    tell_room( environment(), "The yellow spots on the toadstool begin to "+
        "glow.\n" );
    set_light( 5 );
    set_long( query_long() +"The yellow spots are glowing.\n" );
  }
  ::next_stage();
}

==================================================
FILE: fungi/magic_mushroom.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "checkered" );
  set_type( "mushroom" );
  set_extra( "The checks are nice pastel shades of peach and mauve." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ jumps up and down very quickly, and then burps.\n",
    "You hear a small voice say: Goodbye, cruel world!\nThe $type$ "+
        "falls over and disintegrates.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/hallucination", 150 +
        random( 150 ) );
  ::next_stage();
}

==================================================
FILE: fungi/rust_fungus.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "rust" );
  set_type( "fungus" );
  set_extra( "It looks like a lump of rust, only soft and a bit squishy." );
  set_messages( ({
    "A small $type$ sprouts on the metal.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ silently releases a red dust into the air.\n",
    "The $type$ collapses in on itself and falls apart.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/strength_boost", 2000 +
        random( 1000 ) );
  ::next_stage();
}

==================================================
FILE: reagents/.generic_liquid.ob_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/reagents/generic_liquid.ob#1" );
  call_other( clone, "add_adjective",  "some"  );
  call_other( clone, "add_alias",  "liquid"  );
  call_other( clone, "set_amount_types",  ([ "drop": ({ 1, "drops" }),              "teaspoon": ({ 20, "teaspoons" }),              "tablespoon": ({ 60, "tablespoons" }),              "ounce": ({ 120, "ounces" }),              "cup": ({ 960, "cups" }),              "pint": ({ 2400, "pints" }),                          "quart": ({ 4800, "quarts" }),                          "gallon": ({ 19200, "gallons" }) ])  );
  call_other( clone, "add_adjective",  ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",                "tablespoons", "ounce", "ounces", "cup", "cups", "pint",                "pints", "quart", "quarts", "gallon", "gallons", "of" })  );
  call_other( clone, "set_pile_types",  ({ 50, "small", 100, "medium", "large" })  );
  call_other( clone, "set_continuous",   );
  call_other( clone, "set_liquid",   );
  call_other( clone, "add_property",  "determinate", "" );
   return clone;
}

==================================================
FILE: b_day/card.c
==================================================

#define DEMON "/obj/b_day/demon"
#include <player_handler.h>
inherit "/std/object";
int creator_status, is_open = 0;
int opened_before = 0;
string owner_name, owner_language;
string* colour_array = ({
  "%^RED%^", "%^BOLD%^%^RED%^",
  "%^MAGENTA%^", "%^BOLD%^%^MAGENTA%^",
  "%^ORANGE%^", "%^YELLOW%^",
  "%^GREEN%^", "%^BOLD%^%^GREEN%^",
  "%^WHITE%^", "%^BOLD%^%^WHITE%^",
  "%^CYAN%^", "%^BOLD%^%^CYAN%^"
  });
void setup_card(string name, string language, int status);
mapping init_query_static_auto_load() {
  return ([ "::" : ::int_query_static_auto_load(),
          "owner_name":owner_name,
          "owner_language":owner_language,
          "is_open":is_open,
          "opened_before":opened_before]);
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] ) {
    ::init_static_arg( map[ "::" ] );
  }
  if ( !undefinedp( map[ "owner_name" ] ) ) {
    owner_name = map[ "owner_name" ];
  }
  if ( !undefinedp( map[ "owner_language" ] ) ) {
    owner_language = map[ "owner_language" ];
  }
  if ( !undefinedp( map[ "is_open" ] ) ) {
    is_open = map[ "is_open" ];
  }
  if ( !undefinedp( map[ "opened_before" ] ) ) {
    opened_before = map[ "opened_before" ];
  }
}
mapping query_static_auto_load()
{
  if ( explode( file_name( this_object() ), "#" )[ 0 ] ==
       "/obj/b_day/card" ) {
    return init_query_static_auto_load();
  }
  return 0;
}
mixed *query_read_mess()
{
  if(!is_open) {
    return ({ ({ "The card is addressed to " + owner_name +
                   ".  Maybe you should open it?  Then again, if "
                   "you're not " + owner_name + ", maybe you "
                   "shouldn't.\n",
                   0, owner_language, 1 }) });
  }
  return ::query_read_mess();
}
void set_closed_mesg()
{
    set_long("The closed card has been carefully handmade from pink "
        "cardboard. There is a rather vague illustration of a "
        "non-identifiable piece of flora on the front.\n");
}
void set_open_mesg()
{
    set_long("The open card has been carefully handmade from pink "
        "cardboard.\n");
}
void setup_card(string own_name, string own_language, int cre_status)
{
  string *wizards, list;
  int i;
  owner_name = own_name;
  owner_language = own_language;
  creator_status = cre_status;
  set_short(owner_name + "'s birthday card");
  add_adjective( ({ owner_name, owner_name + "'s"}) );
  wizards = get_dir("/w/");
  if(creator_status) {
    int start = member_array(lower_case(owner_name), wizards);
    wizards = wizards[0..start-1] + wizards[start+1..];
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
      "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += colour_array[random(sizeof(colour_array))] +
          capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += "%^RESET%^.\n\n";
        else if(i == sizeof(wizards)-2) list += "%^RESET%^ and ";
        else list += ",%^RESET%^ ";
      }
    }
    list += "... and thanks for all your work and time, and let's hope "
      "next year will be even more magical and fun, fun, fun!\n";
  } else {
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
        "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += ".\n";
        else if(i == sizeof(wizards)-2) list += " and ";
        else list += ", ";
      }
    }
  }
  add_read_mess(list, "various hands", owner_language, 1);
}
void setup()
{
  set_name("card");
  set_short("birthday card");
  add_adjective("birthday");
  set_main_plural("birthday cards");
  add_property("determinate", "");
  add_property("no recycling", 1);
  set_closed_mesg();
  if(owner_name && owner_language) {
    setup_card(owner_name, owner_language, creator_status);
  }
}
void init()
{
    this_player()->add_command("open", this_object());
    this_player()->add_command("close", this_object());
}
int do_open()
{
    object demon;
    if(is_open) {
        write("It is already open.\n");
        return 1;
    }
    if(lower_case(owner_name) != this_player()->query_name()) {
      add_succeeded_mess( ({
        "*** POP ***\n"
          "An Origami Demon peers out from the card, sees you're not "
          + owner_name + ", mutters about that not being very "
          "low-temperature, and vanishes back into the card.\n",
        "*** POP ***\n"
          "An Origami Demon peers out from " + owner_name + "'s "
          "birthday card at " + this_player()->query_cap_name() +
          ", smirks and crawls back into the card.\n"
      }) );
      return 1;
    }
    is_open = 1;
    set_open_mesg();
    if(opened_before) return 1;
    opened_before = 1;
    demon = clone_object(DEMON);
    demon->move(environment(this_player()));
    demon->set_owner(owner_name);
    demon->add_language(owner_language);
    demon->set_language(owner_language);
    add_succeeded_mess( ({
      "*** POP ***\n"
        "An Origami Demon explodes from your card as you open it!\n",
      "*** POP ***\n"
        "An Origami Demon explodes from " + owner_name + "'s birthday "
        "card as " + owner_name +" opens it!\n"
    }) );
    call_out("start_demon", 2, demon);
    return 1;
}
void start_demon(object thing) {
  thing->do_the_act(0);
}
int do_close()
{
    if(!is_open) {
        write("It is not open for you to close!\n");
        return 1;
    }
    is_open = 0;
    set_closed_mesg();
    return 1;
}
mixed *stats()
{
  return ::stats() + ({ ({ "owner name",owner_name }),
                          ({ "owner language",owner_language }), });
}

==================================================
FILE: b_day/demon.c
==================================================

#define SONG "/obj/b_day/happy"
inherit "/obj/monster";
int line;
object owner;
string owner_name;
string* act_lines = ({
  ":takes a deep breath...",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday, dear $N\"",
  ":pauses for breath...",
  "sing \"Happy Birthday to yoooou.\"",
  "sing \"The End!\"",
  "hug $n in a way that only a tiny paper "
    "demon could",
  ":waves a minute pointed hand.",
  ":frowns, then folds itself into nothingness..."
});
void setup()
{
  set_name("demon");
  set_short("origami demon");
  add_adjective("tiny");
  add_adjective("pink");
  add_adjective("paper");
  add_adjective("origami");
  set_main_plural("origami demons");
  add_plural("demons");
  set_long("This is a tiny, pink, paper demon. Looking closely you see "
           "that it has been made by someone with a black belt in "
           "Origami!\n");
  set_race("demon");
  set_level(1);
  line = 1;
}
void set_owner(string person_name)
{
  owner = find_living(lower_case(person_name));
  owner_name = person_name;
}
void do_the_act(int i)
{
  string line_to_act;
  if(i >= sizeof(act_lines)) {
    dest_me();
    return;
  }
  if(environment(owner) != environment()) {
    tell_room(environment(), "The origami demon rustles after "
              + owner_name + ".\n");
    move(environment(owner));
    tell_room(environment(), "The origami demon rustles in.\n" );
    do_command("'Hey "+owner_name+"! I hadn't finished!\n");
    return;
  }
  line_to_act = act_lines[i];
  line_to_act = replace(line_to_act, ({"$N", owner_name,
                                       "$n", lower_case(owner_name) }));
  if(!strlen(line_to_act)) {
    set_heart_beat(0);
    dest_me();
    return;
  }
  do_command(line_to_act);
  i++;
  if(owner) {
    call_out("do_the_act", 2, i);
  }
  return;
}
void attack_by( object thing ){
  if( !thing) return;
  if( environment( thing ) != environment() ) return;
  this_object()->stop_fight (thing);
  thing->stop_fight (this_object());
  init_command("say Meanie!  Shame on you!  I shall finish what I "
               "started and then I shall be off.  You don't really "
               "deserve this, you know.", 1);
  return;
}

==================================================
FILE: examples/exa1.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("first simple room");
  set_long("This is a simple room, have fun with it. To read the code " +
           "simply type 'more here'. For help with more, type 'h' in it.\n");
  set_light(90);
  add_exit("east", ROOM + "exa2", "door");
  set_zone("examples");
}

==================================================
FILE: examples/exa2.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("second simple room");
  set_long("This is the second example room. It introduces items, and " +
           "aliasing - again use 'more here' to look at it. Over by the " +
           "north wall you can see a table.\n");
  set_light(90);
 add_item("table",
          "The table is one step away from being firewood. Upon it rests " +
          "a blotter.\n");
 add_item( ({ "north wall", "wall" }),
          "It is very flat and is holding up rather a ricketty table.\n");
 add_item("blotter",
          "It is covered in random ink blots.\n");
  add_exit("west", ROOM + "exa1", "door");
  add_exit("east", ROOM + "exa3", "door");
  set_zone("examples");
}

==================================================
FILE: examples/exa3.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("third simple room");
  set_long("This is the third example room. Will you ever get to the end? " +
           "Directly above your head is a plaque, nailed to the wall.\n");
  set_light(90);
  add_sign("The plaque is made of bronze.\n",
           "'Don't read me, I'm only an example sign you know!'\n",
           0,
           "plaque");
  add_exit("west", ROOM + "exa2", "door");
  add_exit("east", ROOM + "exa4", "door");
  set_zone("examples");
}
void reset()
{
  object bar;
  if(sizeof(match_objects_for_existence("copper bar", ({ this_object() }) )))
    return;
  bar = clone_object("/std/object");
  bar->set_name("bar");
  bar->add_adjective("copper");
  bar->set_main_plural("copper bars");
  bar->add_plural("bars");
  bar->set_short("copper bar");
  bar->set_long("This is just a treasure thingie to show you how to use " +
                  "such fun things.\n");
  bar->set_weight(80);
  bar->set_value(2000);
  bar->move(this_object());
}

==================================================
FILE: examples/path.h
==================================================

#define ROOM "/obj/examples/"

==================================================
FILE: examples/response_mon.c
==================================================

inherit "/w/pinkfish/tmp/response_mon";
object weapc;
string *tale;
void setup() {
    set_name("guard");
    add_adjective(({ "big", "gate" }));
    set_short("Big gate guard");
    set_long("This is one of the common guards of Amber.  "+
     "He looks quite big, maybe you shouldn't upset him...\n");
    set_race("human");
    set_class("fighter");
    set_level(45);
    set_al(250);
    set_gender(1);
    tale = ({ "There once was a frog with 5 legs.\n",
              "This frog was very very unhappy.\n",
              "All other frogs made fun of him.\n",
              "And no lady frog wanted to marry him.\n",
              "One day, a womble appeared, and bit one of his legs off.\n",
              "Since then the frog had 4 legs, and lived happily ever after.\n"
            });
    set_respond_to_with(([ ({ "help", "me" }) : "'I can't help you." ,
                         ({ ({ "hi","hello","greetings" }) }) :
                                      ({ "'Hello $hcname$.",
                                         "emote salutes you." }),
                            ({ ({ "remove","unwield","unhold" }),
                               ({ "axe","weapon" }) }) :
                                       "#remov",
                            ({ ({ "wield","hold" }),
                               ({ "axe","weapon" }) }) :
                                       "#wiel",
                            ({ "tell" , "story" }) :
                                      "#story" ]));
  weapc = clone_object("/obj/weapons/axe.wep");
  weapc->move(this_object());
  do_equip();
}
int remov() {
  init_command("unhold axe");
}
int wiel() {
 init_command("hold axe");
}
void story(object tpl) {
  command("'Very well, "+tpl->query_cap_name()+ " I will tell you a story.\n");
  set_stop_responding(1);
  call_out("tell_story",2,0);
}
void tell_story(int arg) {
  remove_call_out("tell_story");
  if (arg == sizeof(tale)) {
    set_stop_responding(0);
    return ;
  }
  command("'"+tale[arg]);
  call_out("tell_story",2,arg+1);
}

==================================================
FILE: scabbards/.belt_loop.sca_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/belt_loop.sca#1" );
  call_other( clone, "set_name", "loop"  );
  call_other( clone, "add_adjective", ({ "belt", "belt loop" })  );
  call_other( clone, "add_alias", "belt loop"  );
  call_other( clone, "set_short", "belt loop"  );
  call_other( clone, "set_long", "This loop is made from the finest leather, designed to "         "hold axes or hammers safely.\n"  );
  call_other( clone, "set_weight", 8  );
  call_other( clone, "set_value", 800  );
  call_other( clone, "set_type", "belt scabbard"  );
  call_other( clone, "add_property", "no recycling", 1  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "axe","hammer" }) );
   return clone;
}

==================================================
FILE: scabbards/.dagger_scabbard.sca_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/dagger_scabbard.sca#1" );
  call_other( clone, "set_name", "scabbard"  );
  call_other( clone, "add_adjective", "dagger"  );
  call_other( clone, "set_short", "dagger scabbard"  );
  call_other( clone, "set_long", "Similar in design to the scabbard made for longer bladed weapons."         "  In fact you could say they were the same, except for the size.\n"  );
  call_other( clone, "set_weight", 3  );
  call_other( clone, "set_value", 30  );
  call_other( clone, "set_type", "small scabbard"  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "dagger", "knife" }) );
   return clone;
}

==================================================
FILE: media/sand.c
==================================================

inherit "/obj/cont_medium";
void setup()
{
  set_name("sand");
  set_short("sand");
  set_main_plural( "sand" );
  add_adjective( ({ "some", "grain", "pinch", "measure", "handful",
    "hatful", "beach", "of" }) );
  set_long("This is some lovely soft sand, the type that you'd find on "
    "a beach.\n");
  add_property("determinate", "some ");
  set_weight_unit( ({ 1, 1000 }) );
  set_value_scale( 0.00001 );
  set_medium_alias("BeachAndDesertSand");
  set_pile_name("pile");
  set_continuous();
  set_amount_types( ([
    "grain": ({ 1, "grains" }),
    "pinch": ({ 40, "pinches" }),
    "measure": ({ 200, "measures" }),
    "handful": ({ 10000, "handfuls" }),
    "hatful": ({ 50000, "hatfuls" }),
    "beach": ({ 1000000, "beaches" }),
    ]) );
  set_pile_types( ({
    40, "tiny",
    10000, "small",
    50000, "medium",
    200000, "large",
    "huge"
    }) );
  set_amount(12000);
}

==================================================
FILE: handlers/applications_handler.c
==================================================

#include <board.h>
#include <mail.h>
#include <player.h>
#include <playerinfo.h>
#include <player_handler.h>
#include <applications.h>
#include <library.h>
int find_application (string, string);
int find_type (string);
void mail_message(int, int);
string post_application (int);
int complete_application (int);
nosave class application_type *types = ({ });
class application *applications = ({ });
mapping domain_lockout = ([
     "liaison"      : 0,
     "am"           : 0,
     "ram"          : 0,
     "sur"          : 0,
     "klatch"       : 0,
     "forn"         : 0,
     "cwc"          : 0,
     "playtesters"  : 0
   ]);
void load_me() {
  unguarded ((: restore_object (APPLY_SAVE_FILE) :));
}
void save_me() {
  unguarded ((: save_object (APPLY_SAVE_FILE) :));
}
mapping query_vouches_for_all (string name) {
  mapping tmp = ([ ]);
  for (int i = 0; i < sizeof (applications); i++) {
    if (!undefinedp(applications[i]->vouches[name])) {
      tmp[applications[i]->name + " (" + applications[i]->type + ")"]
        = applications[i]->vouches[name];
    }
  }
  return tmp;
}
varargs void add_application_type (string t, int v, string b, int g, int q, int a,
  int ti, string *qu, string intro, string responsibility) {
  class application_type tmp;
  tmp = new (class application_type, type: t, vouches_required: v, board: b,
    gl_requirement: g, qp_requirement: q, age_requirement: a, questions: qu,
    intro_text: intro, timeout: ti, responsibility: responsibility);
  types += ({ tmp });
}
int toggle_domain_lock (string dom) {
  object ob = load_object ("/d/" + dom + "/master");
  if (ob->query_lord() != this_player()->query_name()) {
    return -1;
  }
  if (domain_lockout[dom]) {
    domain_lockout[dom] = 0;
  }
  else {
    domain_lockout[dom] = 1;
  }
  save_me();
}
int query_applications_accepted(string dom) {
  return (undefinedp (domain_lockout[dom]) ? -1 : domain_lockout[dom]);
}
string query_responsibility (string type) {
  int i;
  object ob;
  string dom;
  i = find_type (type);
  if (i == -1) {
    dom = type;
    type = "creator";
    i = find_type (type);
  }
  else {
    dom = type;
  }
  if (undefinedp (types[i]->responsibility)) {
    ob = load_object ("/d/" + dom + "/master");
    if (!ob) {
      tell_creator ("drakkos", "%s.\n", dom, type);
      return 0;
    }
    return ob->query_lord();
  }
  else {
    ob = load_object ("/d/" + types[i]->responsibility+ "/master");
    if (!ob) {
      return "No-one";
    }
    return ob->query_lord();
  }
}
mapping query_domain_status() {
  return copy (domain_lockout);
}
int add_application (string t, string n, string te, string dom) {
  class application tmp;
  int i;
  i = find_application (n, t);
  if (i != -1) {
    return 0;
  }
  tmp = new (class application, type: t, name: n, text: te, time: time(),
    domain: dom, vouches: ([ ]));
  applications += ({ tmp });
  i = find_application (n, t);
  complete_application (i);
  save_me();
  return 1;
}
void create() {
  seteuid (geteuid());
  load_me();
  add_application_type ("creator", 2, "applications", 150, 0,  5 * DAY, 14 * DAY,
    ({
      "Why do you want to be a Creator on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if "
        "so what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?",
      "What is your programming experience? Can you code in C or, more "
        "specifically, the variant of C known as LPC which the mud uses?",
      "What are you interested in creating on "
        "" + mud_name() + "?  Do you have any particular ideas or projects on "
        "which you would like to eventually work?",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to recommend "
        "you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
        "To the best of your knowledge, is the information you have "
        "submitted in this application complete and correct?"
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
  add_application_type ("liaison", 2, "applications", 150, 0,  5 * DAY, 14 * DAY,
   ({
      "Why do you want to be a Liaison on " + mud_name() + "?",
      "What experience do you already have from " + mud_name() + " which is relevant "
        "to this position?",
      "What experience do you have from the Roundworld (real life) which is "
        "relevant to this position?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?  Also, please specify the approximate times that you "
        "usually log on and off (in Seattle time).",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to "
        "recommend you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?",
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
  add_application_type ("playtester", 3, "playtesters", 150, 0,  15 * DAY,
    14 * DAY,
    ({
      "Why do you want to be a playtester on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "What qualities do you feel you can bring to the role?",
      "Do you have any experience in a similar position in real life or "
        "on another MUD?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?",
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n",
      "playtesters");
}
int find_application (string name, string type) {
  for (int i = 0; i < sizeof (applications); i++) {
    if (applications[i]->name == name && applications[i]->type == type) {
      return i;
    }
  }
  return -1;
}
int find_type(string type) {
  for (int i = 0; i < sizeof (types); i++) {
    if (types[i]->type == type) {
      return i;
    }
  }
  return -1;
}
void reset() {
  int j;
  class application *tmp = ({ });
  for (int i = 0; i < sizeof (applications); i++) {
    j = find_type (applications[i]->type);
    if (applications[i]->time + types[j]->timeout < time()) {
      tmp += ({ applications[i] });
      mail_message (0, i);
    }
  }
  if (sizeof (tmp)) {
    applications -= tmp;
    save_me();
  }
}
int delete_vouch (string who, string name, string position) {
  int i = find_application (name, position);
  if (i == -1) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[who])) {
    return 0;
  }
  map_delete (applications[i]->vouches, who);
  save_me();
  return 1;
}
int delete_application (string t, string n) {
  int i = find_application (n, t);
  if (i == -1) {
    return 0;
  }
  applications -= ({ applications[i] });
  save_me();
  return 1;
}
private int complete_application (int i) {
  int vouches = sizeof (keys (applications[i]->vouches));
  int j;
  j = find_type (applications[i]->type);
  if (vouches >= types[j]->vouches_required) {
    post_application (i);
    delete_application (applications[i]->type, applications[i]->name);
    save_me();
    return 1;
  }
  return 0;
}
int number_of_vouches (string name, string type) {
  int i = find_application (name, type);
  if (i == -1) {
    return 0;
  }
  return sizeof (keys (applications[i]->vouches));
}
string query_vouch (string t, string p, string n) {
  int i = find_application (p, t);
  if (i == -1) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[n])) {
    return "You have no vouch for this player in this position.\n";
  }
  return applications[i]->vouches[n];
}
int make_vouch (string t, string p, string n, string v) {
  int i = find_application (p, t);
  int newv = 1;
  if (i == -1) {
    return -1;
  }
  if (n == applications[i]->name) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[n])) {
    newv = 2;
  }
  applications[i]->vouches[n] = v;
  complete_application (i);
  save_me();
  return newv;
}
string* query_questions (string type) {
  int i = find_type (type);
  return types[i]->questions;
}
string query_intro_text (string type) {
  int i = find_type (type);
  return types[i]->intro_text;
}
int valid_application (string name, string type) {
  int i = find_type (type);
  object ob = find_player (name);
  if (ob->query_level() < types[i]->gl_requirement) {
    return 0;
  }
  if (-1 * ob->query_time_on() >= types[i]->age_requirement) {
    return 0;
  }
  if (LIBRARY->query_quest_points (name) < types[i]->qp_requirement) {
    return 0;
  }
  return 1;
}
string application_requirements (string type) {
  int i = find_type (type);
  string ret = "";
  if (i == -1) {
    return "Applications of that category are not handled by this "
      "system.";
  }
  ret += "Applications for a " + types[i]->type + " position have the "
    "following requirements:\n\n";
  ret += "You need to be at least " +
      query_time_string (types[i]->age_requirement) + " old.\n";
  ret += "You need to be at least guild level " + types[i]->gl_requirement + ".\n";
  ret += "You need to have at least " + types[i]->qp_requirement + " quest points.\n";
  ret += "You need to have " + types[i]->vouches_required + " vouches.\n";
  ret += "You have " + query_time_string (types[i]->timeout) + " to obtain your "
    "vouches.\n\n";
  ret += "Your application will not be posted for consideration until you have "
    "all your vouches completed.\n";
  return ret;
}
mapping query_application_vouches (string type, string name) {
  int i = find_application (type, name);
  if (i == -1) {
    return 0;
  }
  else {
    return applications[i]->vouches;
  }
}
string format_application (int i) {
  string post;
  post = "%^BOLD%^Application:%^RESET%^\n"
         "=-=-=-=-=-=-\n\n" +
         "Age: " + query_time_string(-1 * PLAYER_HANDLER->test_age
         (applications[i]->name)) + "\n" +
         "Application made: " + ctime (applications[i]->time) + "\n\n"
         + applications[i]->text + "\n\n";
  post += "\n\n%^BOLD%^Vouches:%^RESET%^\n"
          "=-=-=-=-\n";
  foreach (string v, string t in applications[i]->vouches) {
    post += "\n\n%^CYAN%^" + capitalize (v) + " (" + query_time_string (-1 *
      PLAYER_HANDLER->test_age (v)) + "):%^RESET%^\n\n" + t;
  }
  return post;
}
private string post_application (int i) {
  string post = "";
  int j = find_type (applications[i]->type);
  class reply_type rep;
  object ob, player;
  string response;
  post = format_application (i);
  rep= new(class reply_type);
  rep->type = B_REPLY_NAMED;
  rep->data = query_responsibility((applications[i]->domain ? applications[i]->domain :
    applications[i]->type));
  ob = load_object ("/d/" + (applications[i]->domain ?
    applications[i]->domain : types[j]->responsibility) + "/master");
  BOARD_HAND->add_message( types[j]->board, capitalize( applications[i]->name),
    capitalize( applications[i]->name ) + "'s " + (applications[i]->type == "creator" ?
       applications[i]->domain + " domain" : capitalize (applications[i]->type)) +
       " application", post, 0, rep );
  AUTO_MAILER->auto_mail( query_responsibility((applications[i]->domain ?
    applications[i]->domain : applications[i]->type)),
    applications[i]->name,
    "Application to " + capitalize( applications[i]->domain),
    "", post, 0, 0 );
  player = find_player (applications[i]->name);
  if (ob) {
    if (function_exists ("creator_application_callback", ob)) {
        response = call_other (ob, "creator_application_callback",
        applications[i]->name, post);
     }
    if (sizeof (response)) {
      tell_object (player, response);
    }
  }
  if (applications[i]->type == "creator" ||  applications[i]->type ==
    "liaison") {
    PLAYERINFO_HANDLER->add_entry( this_object(),
      applications[i]->name, "misc", "Applied to "
        + applications[i]->domain + " domain." );
  }
  else {
    PLAYERINFO_HANDLER->add_entry( player,
      player->query_name(), "misc", "Applied as a "
        + applications[i]->type+ "." );
  }
  mail_message (1, i);
  save_me();
  return post;
}
private void mail_message(int i, int j) {
  string ret = "";
  string mail;
  mail = "Greetings... this is an automated message from the "
    "" + mud_name() + " applications handler.\n\n$message$\n\n";
  switch (i) {
    case 0:
      ret = "You have not received the required number of vouches for "
        "your application for a " + applications[j]->type + " position "
        "within the specified time-frame.  Your application has been "
        "expired and if you wish to pursue further employment on the MUD "
        "you will need to resubmit an application.\n";
    break;
    case 1:
      ret = "You have received the required number of vouches for your "
        "application for a " + applications[j]->type + " position on the "
        "MUD.  Your application has been posted for consideration.  Thank "
        "you for your interest in pursuing employment within the MUD.\n";
    break;
  }
  mail = replace (mail, ({"$message$", ret}));
  AUTO_MAILER->auto_mail( applications[j]->name, "Applications Procedure",
    "Your " + applications[j]->type + " application", "",
    mail, 0, 0, 1 );
}
string list_applications() {
  string *ret = ({ });
  ret += ({"\n"});
  ret += ({"\n\n/---------------------------------------------------------------------------\\"});
  ret += ({sprintf ("| %|12s | %|12s | %|24s | %|2s  | %|10s |",
  "Type", "Name", "Made At", "V", "Domain") });
  ret += ({"|---------------------------------------------------------------------------|"});
  for (int i = 0; i < sizeof (applications); i++) {
    ret += ({sprintf ("| %|12s | %|12s | %|s | %|2d  | %|10s |",
    capitalize (applications[i]->type),
      capitalize (applications[i]->name), ctime (applications[i]->time),
        sizeof (applications[i]->vouches),
        capitalize ((applications[i]->type == "creator" ? applications[i]->domain :
        ""))) });
  }
  ret += ({"\\---------------------------------------------------------------------------/"});
  return implode (ret, "\n");
}
string *query_types() {
  return map (types, (: $1->type :));
}
int fix_name (string n, string n2) {
  int i;
  int c = 0;
  for (int j =0; j < sizeof (types); j++) {
    i = find_application (n, types[j]->type);
    if (i != -1) {
      applications[i]->name = n2;
      c++;
    }
  }
  return c;
}
string query_name() {
  return "Applications Handler";
}

==================================================
FILE: handlers/armoury.c
==================================================

#include <move_failures.h>
#include <armoury.h>
#define MAX_RECYCLE 6
inherit "/std/room/basic_room";
#define DEFAULT_RECYCLE_AREA "default"
#define SAVE "/save/armoury"
#define TYPES ({"armours", "clothes", "weapons", "plants", "foods", "scabbards", "jewelleries", "misc" })
private nosave int _total_requests;
private mapping _smalls;
private mapping _armour_list;
private mapping _weapon_list;
private mapping _clothing_list;
private mapping _jewellery_list;
private mapping _scabbard_list;
private mapping _food_list;
private mapping _misc_list;
private mapping _plant_list;
private mapping _areas;
private mapping forbidden;
private void rehash_all();
int rehash(string place);
string* walk_directory (string);
void save_me() {
   unguarded( (: save_object(SAVE, 3) :));
}
void load_me() {
   unguarded( (: restore_object(SAVE, 1) :));
}
void setup() {
   set_short( "" + mud_name() + " Armoury" );
   add_property( "determinate", "the " );
   set_light( 50 );
   set_long( "You are in the " + mud_name() + " Armoury.  From here you can list "
         "all of the \"weapons\", \"armour\", \"clothing\", \"jewellery\", "
         "\"food\", \"plants\", \"misc\" "
         "and \"scabbards\" that are available, and \"request\" one of "
         "them.  The armoury stores its list of items in mappings, which "
         "can be updated with \"rehash\".  The list of forbidden items "
         "can be listed out or added to with \"forbid\".\n" );
   _smalls = ([ ]);
   _areas = ([ ]);
   _armour_list = _weapon_list = _clothing_list = _plant_list = _misc_list =
      _jewellery_list = _scabbard_list = _food_list = ([ ]);
   load_me();
   rehash_all();
}
object *query_smalls(string area) {
   if (!area) {
      area = DEFAULT_RECYCLE_AREA;
   }
   return _smalls[area];
}
mapping query_area(string domain) {
  if (_areas[domain]) {
      return _areas[domain];
  }
  return ([ ]);
}
int request(string, int, string);
int forbid(string);
void init() {
   string comm;
   ::init();
   add_command("rehash", "{foods|clothes|weapons|armours|misc|jewelleries|"
                         "scabbards|plants}",
                (:rehash($4[0]) :));
   add_command("rehash", "domain <string'domain'>",
                (:rehash($4[0]) :));
   add_command("request", "<string'item name'> <number'percent'>",
                (:request($4[0], $4[1], 0):));
   add_command("request", "<string'item name'> <number'percent'> in <string'area'>",
               (:request($4[0], $4[1], $4[2]):));
   add_command("forbid", "", (:forbid, "":));
   add_command("forbid", "<string'name'>", (:forbid($4[0]):));
   foreach(comm in ({"weapons", "armour", "clothing", "jewellery", "plant",
                     "misc", "scabbards", "food", })) {
      add_command(comm, "", (:call_other(this_object(), $(comm)):));
   }
}
mapping make_list(string base_dir, string *extensions) {
  string *dirs, dir, extension, file_name;
  mapping list;
  dirs = walk_directory (base_dir);
  list = ([ ]);
  foreach(dir in dirs) {
    foreach(extension in extensions) {
      foreach(file_name in unguarded((: get_dir, dir+"*"+extension :))) {
        if (file_name[0] != '.') {
          list[ replace_string(explode(file_name, ".")[0], "_", " ") ] =
                    dir + "" + file_name;
        }
      }
    }
  }
  return list;
}
int clean_up(int i) { return 0; }
object choose_small_item(string area) {
  object ob;
  if(!area)
    area = DEFAULT_RECYCLE_AREA;
  if(!_smalls || !_smalls[area] || !arrayp(_smalls[area]) || !_smalls[area][0])
    return 0;
  ob = clone_object(_smalls[area][0]);
  _smalls[area] = _smalls[area][1..];
  return ob;
}
object request_item(string word, int percent, string area) {
  int add_area;
  object thing;
  string filename;
  if(!word) {
    return 0;
  }
  if (!area) {
    area = DEFAULT_RECYCLE_AREA;
  }
  if (_areas[area] &&
      _areas[area][word]) {
    filename = _areas[area][word];
    add_area = 1;
  } else if(_weapon_list[word]) {
    filename = _weapon_list[word];
  } else if(_armour_list[word]) {
    filename = _armour_list[word];
  } else if(_clothing_list[word]) {
    filename = _clothing_list[word];
  } else if(_jewellery_list[word]) {
    filename = _jewellery_list[word];
  } else if(_scabbard_list[word]) {
    filename = _scabbard_list[word];
  } else if(_misc_list[word]) {
    filename = _misc_list[word];
  } else if(_plant_list[word]) {
    filename = _plant_list[word];
  } else if(_food_list[word]) {
    filename = _food_list[word];
  } else {
    if(base_name(previous_object()) != "/cmds/creator/req_uest") {
      printf( "No file for item \"%s\".\n", word );
      log_file( "ARMOURY", "%s No file for %s (%s)\n", ctime(time())[4..9],
                word, file_name( previous_object() ) );
    }
    return 0;
  }
  if(file_size( filename ) > 0)
    thing = clone_object(filename);
  if(!thing) {
    printf( "Cannot find item \"%s\".\n", word );
    log_file( "ARMOURY", "Cannot find %s (%s)\n", word,
              file_name( previous_object() ) );
    return 0;
  }
  _total_requests++;
  if(!_smalls[area])
    _smalls[area] = ({ });
  if(sizeof(_smalls[area]) < 20 &&
     thing->query_weight() < roll_MdN(5, 20) &&
     thing->query_value() < random(4000) &&
     !thing->query_liquid() &&
     !sizeof((mapping)thing->query_value_info()) &&
     strsrch(filename, "_pt") == -1 &&
     strsrch(filename, "_dev") == -1 &&
     !thing->query_property("no recycling")) {
    _smalls[area] += ({ filename });
  }
  if (add_area)
    thing->add_property(ARMOURY_RECYCLING_AREA_PROP, area);
  thing->set_percentage( percent );
  return thing;
}
string remap_file_path(string path) {
   string* bits;
   mapping list;
   string new_fname;
   bits = explode(path, "/");
   if (bits[0] != "obj") {
      return path;
   }
   switch (bits[1]) {
   case "armours" :
      list = _armour_list;
      break;
   case "weapons" :
      list = _weapon_list;
      break;
   case "clothes" :
      list = _clothing_list;
      break;
   case "jewellery" :
      list = _jewellery_list;
      break;
   case "scabbards" :
      list = _scabbard_list;
      break;
   case "food" :
      list = _food_list;
      break;
   case "misc" :
      list = _misc_list;
      break;
   case "plants" :
      list = _plant_list;
      break;
   }
   if (list) {
      new_fname = list[replace_string(explode(bits[<1], ".")[0], "_", " ")];
      if (new_fname) {
         return new_fname;
      }
   }
   return path;
}
int rehash(string thing) {
  string special;
  int found;
  switch (thing) {
  case "armours" :
     _armour_list=make_list("/obj/armours/", ({".arm", ".c"}));
     break;
  case "clothes" :
     _clothing_list=make_list("/obj/clothes/", ({".clo", ".c"}));
     break;
  case "weapons" :
     _weapon_list = make_list("/obj/weapons/", ({".wep", ".c"}));
     break;
  case "scabbards" :
     _scabbard_list = make_list( "/obj/scabbards/", ({ ".sca", ".c" }));
     break;
  case "jewellery" :
  case "jewelleries" :
     _jewellery_list = make_list( "/obj/jewellery/", ({ ".arm", ".clo", ".c" }));
     break;
  case "food" :
  case "foods" :
     _food_list = make_list( "/obj/food/", ({ ".ob", ".food", ".c" }));
     break;
  case "misc" :
     _misc_list = make_list( "/obj/misc/", ({ ".ob", ".c" }));
     break;
  case "plants" :
     _plant_list = make_list( "/obj/plants/", ({ ".ob", ".food", ".c" }));
     break;
  default :
    if (file_size("/d/" + thing + "/items") == -2) {
      _areas[thing] = make_list( "/d/" + thing + "/items/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca",
                                     ".ob", ".food" }));
      found = 1;
    }
    if (file_size("/d/" + thing + "/armoury") == -2) {
      foreach (special in get_dir("/d/" + thing + "/armoury")) {
         if (file_size("/d/" + thing + "/armoury/" + special + "/") == -2) {
           _areas[special] = make_list( "/d/" + thing + "/armoury/" + special + "/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca" }));
         }
      }
       return 0;
    }
  }
  save_me();
  write("Rehash of " + thing + " complete.\n");
  return 1;
}
int rehash_specific_dir(string dir) {
   return rehash(explode(dir, "/")[1]);
}
private void rehash_all() {
  string thing;
  int i;
  foreach(thing in TYPES + "/secure/master"->query_domains()) {
    i += 5;
    call_out("rehash", i, thing);
  }
}
string *query_types() { return TYPES + keys(_areas); }
mapping query_items(string type, string filter) {
  mapping items;
  string item;
  switch(type) {
  case "armours":
    items = _armour_list;
    break;
  case "weapons":
    items = _weapon_list;
    break;
  case "clothes":
    items = _clothing_list;
    break;
  case "jewellery":
  case "jewelleries":
    items = _jewellery_list;
    break;
  case "scabbards":
    items = _scabbard_list;
    break;
  case "food":
  case "foods":
    items = _food_list;
    break;
  case "misc":
    items = _misc_list;
    break;
  case "plants":
    items = _plant_list;
    break;
  default:
    if(member_array(type, "/secure/master"->query_domains()) != -1 &&
       _areas[type])
      items = _areas[type];
    else
      return 0;
  }
  items = copy (items);
  if (sizeof (filter)) {
    foreach(item in keys(items))
      if(strsrch(item, filter) == -1)
        map_delete(items, item);
  }
  return items;
}
int request( string word, int percentage, string area ) {
  object thing;
  thing = request_item( word, percentage, area );
  if ( !thing ) {
    add_failed_mess(word + " not found.\n");
    return 0;
  }
  if ( (int)thing->move( this_player() ) != MOVE_OK ) {
    write( (string)thing->a_short() +" has been placed in here.\n" );
    thing->move( this_object() );
  } else
    write( (string)thing->a_short() +
          " has been placed in your inventory.\n" );
  return 1;
}
mixed stats() {
  string tmp;
  mixed *ret;
  ret = ({ });
  foreach(tmp in keys(_areas)) {
    ret += ({ tmp, sizeof(_areas[tmp]) });
  }
  return ::stats() + ({
    ({ "item requests", _total_requests, }),
      ({ "armours", sizeof(_armour_list) }),
      ({ "clothes", sizeof(_clothing_list) }),
      ({ "weapons", sizeof(_weapon_list) }),
      ({ "scabbards", sizeof(_scabbard_list) }),
      ({ "jewellery", sizeof(_jewellery_list) }),
      ({ "food", sizeof(_food_list) }),
      ({ "misc", sizeof(_misc_list) }),
      ({ "plants", sizeof(_plant_list) }),
      ret });
}
string* walk_directory (string dir) {
  string *tmp, *dirs = ({ }), *tmp2;
  mixed *file;
  tmp = get_dir(dir, -1);
  if (sizeof (tmp))
    dirs += ({dir});
  foreach(file in tmp) {
    if(file[1] == -2) {
      tmp2 = walk_directory (dir + file [0] + "/");
      if (sizeof (tmp2))
        dirs += tmp2;
    }
  }
  return dirs;
}

==================================================
FILE: handlers/artifact_handler.c
==================================================

#define SAVE_FILE "/save/artifacts"
#define SAVE_DIR "/save/artifacts/"
mapping artifacts;
void create() {
   seteuid( (string)"/secure/master"->
         creator_file( file_name( this_object() ) ) );
   artifacts = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
mapping query_artifacts() { return artifacts; }
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
int query_artifact( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return 1;
}
void add_artifact( string name, string file, int max, int min, int bonus,
                   int value ) {
  artifacts[ name ] = ({ file, max, min, bonus, value });
  save_me();
}
void remove_artifact( string name ) {
  if ( !artifacts[ name ] )
    return;
  artifacts = m_delete( artifacts, name );
  save_me();
}
string query_artifact_file( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 0 ];
}
int query_artifact_max( string name ) {
  if ( !artifacts[ name ] )    return 0;
  return artifacts[ name ][ 1 ];
}
int query_artifact_min( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 2 ];
}
int query_artifact_bonus( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 3 ];
}
int query_artifact_value_info( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 4 ];
}
int query_artifact_level( string name, int bonus ) {
  int number;
  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 1 ] - artifacts[ name ][ 2 ];
  number *= number;
  number /= bonus - artifacts[ name ][ 3 ] + artifacts[ name ][ 1 ] -
      artifacts[ name ][ 2 ];
  number += artifacts[ name ][ 2 ];
  return number;
}
int query_artifact_value( string name, int bonus ) {
  int number;
  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 4 ] * artifacts[ name ][ 1 ];
  number /= query_artifact_level( name, bonus );
  return number;
}
void diagnose_artifact( object thing, object person, object) {
   int charges;
   string type;
   if ( !thing || !person )
      return;
   type = (string)thing->query_artifact_type();
   if ( !stringp( type ) ) {
      tell_object( person, "There doesn't seem to be anything special about "+
            (string)thing->the_short() +".\n" );
      return;
   }
   charges = (int)thing->query_charges();
   tell_object( person, (string)thing->the_short() +" is a level "+
         (int)thing->query_level() +" magic "+ type +".  It has "+
         ( charges == 1 ? "one charge" : query_num( charges ) +" charges" ) +
         " remaining.\n" );
}
string query_wand_name() { return "wand of artifact probing"; }
void zap( object thing, object person, object wand ) {
  call_out( "diagnose_artifact", 0, thing, person, wand );
}
int query_known( string person, string artifact ) {
  int i;
  string *list;
  if ( !artifacts[ artifact ] )
    return 0;
  if ( unguarded((: file_length, SAVE_DIR + person :)) < 1 )
    return 0;
  list = explode( unguarded((: read_file, SAVE_DIR + person :)), "\n" );
  for ( i = 0; i < sizeof( list ); i++ ) {
    if ( list[ i ] == artifact )
      return 1;
  }
  return 0;
}
void add_known( string person, string artifact ) {
  if ( query_known( person, artifact ) )
    return;
  unguarded((: write_file, SAVE_DIR + person, artifact +"\n" :));
}

==================================================
FILE: handlers/attack_messages.c
==================================================

mapping weapon_mess;
void create() {
  weapon_mess = ([
    "blunt" : ({
      0, "$N swing$s at $I with $D",
        20, "$N tap$s $I in the $z with $D",
        60, "$N hit$s $I in the $z with $D",
        100, "$N bruise$s $P $z with $D",
        140, "$N hit$s $I hard in the $z with $D",
        180, "$N smash$es $I in the $z with $D",
        220, "$N crush$es $P $z with $D",
        5000, "$N mash$es $P $z with $D",
        }),
    "blunt-tail" : ({
      0, "$N swing$s $p tail at $I",
        20, "$N tap$s $I in the $z with $p tail",
        60, "$N slap$s $I in the $z with $p tail",
        100, "$N bruise$s $P $z with $p tail",
        140, "$N hit$s $I hard in the $z with $p tail",
        180, "$N bash$es $I in the $z with $p tail",
        220, "$N smash$es $p tail into $P $z",
        5000, "$N send$s $I reeling with a powerful blow to the $z with $p tail"
        }),
    "blunt-hoof" : ({
      0, "$N kick$s out at $I",
        20, "$N tap$s $I in the $z with $p hoof",
        60, "$N kick$s $I in the $z with $p hoof",
        100, "$N bruise$s $P $z with $p hoof",
        140, "$N hit$s $I hard in the $z with $p hoof",
        180, "$N smash$es $I in the $z with $p hoof",
        220, "$N crush$es $p hoof into $P $z",
        5000, "$N mash$es $P $z with $p hoof"
        }),
    "blunt-wrestle" : ({
      0, "$N grab$s for $I",
        25, "$N grapple$s with $I",
        50, "$N catch$es $I in an arm lock",
        75, "$N grab$s $I around the neck",
        100, "$N poke$s $I in the face",
        125, "$N throw$s $I to the ground",
        150, "$N fling$s $I over $p shoulder",
        175, "$N punch$es $I in the stomach",
        200, "$N twist$s $P arm painfully",
        225, "$N thump$s $P head hard",
        250, "$N kick$s $I in the back",
        275, "$N jump$s up and down on $I",
        5000, "$N slam$s $P head against the ground"
        }),
    "blunt-hands" : ({
      0, "$N punch$es at $I",
        10, "$N poke$s $I in the $z",
        40,"$N tickle$s $I in the $z",
        70, "$N jab$s $I in the $z",
        100, "$N hit$s $I in the $z with an uppercut",
        130, "$N hit$s $I in the $z with a cross",
        160, "$N hit$s $I in the $z with a vicious hook",
        5000, "$N beat$s $P $z to a pulp",
        }),
    "blunt-feet" : ({
      0, "$N kick$s out at $I",
        10, "$N poke$s $I",
        40, "$N tickle$s $I in the $z with $p toes",
        70, "$N kick$s $I in the $z",
        100, "$N viciously boot$s $I in the $z",
        130, "$N kick$s $I in the $z",
        160, "$N viciously kick$s $I in the $z",
        5000, "$N kick$s $P $z into a bloody mess"
        }),
    "blunt-pommel": ({
      0, "$N strike$s at $I with the pommel of $D",
        20, "$N tap$s $I in the $z with the pommel of $D",
        60, "$N knock$s $P $z with the hilt of $D",
        100, "$N bruise$s $P $z with the pommel of $D",
        140, "$N bash$es $I in the $z with the hilt of $D",
        180, "$N beat$s $I in the $z with the pommel of $D",
        220, "$N smash$es the hilt of $D into $P $z",
        5000, "$N smash$es $I in the $z with the pommel of $D",
        }),
    "blunt-cane" : ({
      0, "$N strike$s at $I with $D",
        20, "$N tap$s $P $z with $D",
        60, "$N knock$s $P $z with $D",
        100, "$N strike$s $I lightly in the $z with $D",
        140, "$N strike$s $I in the $z with $D",
        180, "$N strike$s $I hard in the $z with $D",
        220, "$N batter$s $P $z with $D",
        5000, "$N bludgeon$s $P $z with $D",
        }),
    "blunt-self" : ({
      0, "$N swing$s at $I",
        20, "$N tap$s $I in the $z",
        60, "$N hit$s $I in the $z",
        100, "$N bruise$s $P $z",
        140, "$N hit$s $I hard in the $z",
        180, "$N smash$es $I in the $z",
        220, "$N crush$es $P $z",
        5000, "$N mash$es $P $z",
        }),
    "sharp" : ({
      0, "$N slash$es at $I with $D",
        20, "$N snick$s $P $z with $D",
        60, "$N scratch$es $P $z with $D",
        100, "$N nick$s $P $z with $D",
        140, "$N cut$s $P $z with $D",
        180, "$N slice$s $P $z with $D",
        220, "$N hack$s $P $z with $D",
        5000, "$N chop$s up $P $z with $D"
        }),
    "sharp-claws" : ({
      0, "$N rake$s at $I with $p claws",
        10, "$N snick$s $P $z with $p claws",
        40, "$N scratch$es $P $z with $p claws",
        70, "$N nick$s $P $z with $p claws",
        100, "$N claw$s $P $z",
        130, "$N slice$s $P $z up with $p claws",
        160, "$N hack$s $P $z up with $p claws",
        5000, "$N cut$s $P $z into small pieces with $p claws",
        }),
    "sharp-chew" : ({
      0, "$N bite$s at $I",
        10, "$N chew$s on $P $z",
        40, "$N munch$es on $P $z",
        70, "$N gash$es $P $z with $p teeth",
        100, "$N rip$s flesh off $P $z",
        130, "$N tear$s deeply into $P $z",
        160, "$N rip$s $P $z to pieces with $p teeth",
        5000,  "$N rend$s huge chunks of flesh from $P $z",
        }),
    "sharp-slice": ({
      0, "$N slice$s at $I with $D",
        20, "$N just manage$s to slice $P $z with $D",
        60, "$N slice$s $D across $P $z",
        100, "$N shred$s $P $z with $D",
        140, "$N slice$s $D into $P $z",
        180, "$N take$s a sliver off $P $z with $D",
        220, "$N slice$s $D deeply into $P $z",
        5000, "$N neatly fillet$s $P $z with $D",
        }),
    "sharp-chop": ({
      0, "$N swing$s $D at $I",
        20, "$N attempt$s to chop $P $z with $D",
        60, "$N chop$s at $P $z with $D",
        100, "$N chop$s $P $z with $D",
        140, "$N chop$s $D into $P $z",
        180, "$N hack$s into $P $z with $D",
        220, "$N chop$s $D deeply into $P $z",
        5000, "$N chop$s $P $z into pieces with $D",
        }),
    "pierce": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N pierce$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N skewer$s $P $z with $D",
        220, "$N run$s $I through the $z with $D",
        5000, "$N make$s a kebab of $P $z with $D",
        }),
    "pierce-spike": ({
      0, "$N swing$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N spike$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N ventilate$s $P $z with $D",
        220, "$N perforate$s $P $z with $D",
        5000, "$N make$s a mess of $P $z with $D",
        }),
    "pierce-beak" : ({
      0, "$N pecks at $I with $p beak",
        10, "$N snick$s $P $z",
        40, "$N scratch$es $P $z with $p beak",
        70, "$N peck$s $P $z",
        100, "$N viciously peck$s $P $z",
        130, "$N gouge$s a hole in $P $z with $p beak",
        160, "$N slice$s $P $z with $p beak",
        5000, "$N slice$s $P $z into small bits with $p beak",
        }),
    "pierce-stab": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely stab$s $I in the $z with $D",
        60, "$N stab$s $I in the $z with $D",
        100, "$N messily stab$s $I in the $z with $D",
        140, "$N stab$s $I deeply in the $z with $D",
        180, "$N perforate$s $P $z with $D",
        220, "$N pierce$s $P $z with $D",
        5000, "$N stab$s $D right through $P $z",
        }),
    "pierce-horns": ({
      0, "$N attempt$s to gore $I with $p horns",
        20, "$N prod$s $I in the $z with $p horns",
        60, "$N poke$s $I in the $z with $p horns",
        100, "$N butt$s $I in the $z with $p horns",
        140, "$N pierce$s $I deeply in the $z with $p horns",
        180, "$N ram$s $I in the $z with $p horns",
        220, "$N gore$s $P $z with $p horns",
        5000, "$N impale$s $P $z on $p horns",
        }),
    "pierce-tusks": ({
      0, "$N attempt$s to gore $I with $p tusks",
        20, "$N prod$s $P $z with $p tusks",
        60, "$N poke$s $I in the $z with $p tusks",
        100, "$N jab$s $p tusks into $P $z",
        140, "$N pierce$s $P $z with $p tusks",
        180, "$N stab$s $p tusks deeply into $P $z",
        220, "$N gore$s $P $z with $p tusks",
        5000, "$N impale$s $P $z on $p tusks",
        }),
    "pierce-bite" : ({
      0, "$N attempt$s to bite $I",
        10, "$N nip$s $I in the $z",
        40, "$N nibble$s at $P $z",
        70, "$N bite$s $I in the $z",
        100, "$N sink$s $p teeth into $P $z",
        130, "$N bite$s into $P $z",
        160, "$N sink$s $p teeth deep into $P $z",
        5000, "$N bite$s deeply into $P $z, splintering $P bones",
        }),
    "fire" : ({
      20, "$N smoke$s $I",
        60, "$N toast$s $I",
        100, "$N scorch$es $I",
        140, "$N crisp$s $I",
        180, "$N singe$s $I",
        220, "$N fry$s $I",
        260, "$N roast$s $I",
        300, "$N melt$s $I",
        340, "$N char$s $I",
        380, "$N burn$s $I",
        420, "$N incinerate$s $I",
        460, "$N cremate$s $I",
        5000, "$N vapourise$s $I",
        }),
    ]);
}
string parse_string(string mess, object him, object me, object wep,
                    string zone) {
   return replace( replace( mess, ({
      "$mposs$ $D", (string)wep->poss_short() }) ),
         ({ "$hname$", (string)him->query_name(),
            "$mname$", (string)me->query_name(),
            "$hcname$", (string)him->the_short(),
            "$mcname$", (string)me->the_short(),
            "$hposs$", (string)him->query_possessive(),
            "$mposs$", (string)me->query_possessive(),
            "$hpname$", (string)him->poss_short(),
            "$mpname$", (string)me->poss_short(),
            "$hpron$", (string)him->query_pronoun(),
            "$mpron$", (string)me->query_pronoun(),
            "$hobj$", (string)him->query_objective(),
            "$mobj$", (string)me->query_objective(),
            "$wname$", (string)wep->query_name(),
            "$wcname$", (string)wep->short(0),
            "$zname$", zone})
   );
}
mixed query_message( int dam, string type, object him, object me,
                     string name, object wep, string zone) {
  int j;
  mixed ind;
  string tmp;
  if(!zone) {
    zone = "body";
  } else {
    if(zone[sizeof(zone)]-1 == 's')
      zone = zone[0..<2];
  }
  ind = wep->query_attack_message(name, type);
  if (!ind) {
    if(type == "unarmed") {
      switch(name) {
      case "bite":
      case "beak":
      case "stab":
      case "horns":
      case "tusks":
        type = "pierce";
        break;
      case "claws":
      case "chew":
      case "slice":
      case "chop":
        type = "sharp";
        break;
      default:
        type = "blunt";
      }
    }
    ind = weapon_mess[type+"-"+name];
    if(!ind) {
      ind = weapon_mess[type];
      if (!ind) {
        return 0;
      }
    }
  }
  while (j < sizeof(ind) && dam > ind[j]) {
    j += 2;
  }
  if (j >= sizeof(ind)) {
    j = sizeof(ind)-2;
  }
  ind = ind[j+1];
  if (stringp(ind)) {
    tmp = replace(ind,
                  ({ "$N", (string)me->the_short(),
                       "$p ", (string)me->query_possessive() +" ",
                       "$r", (string)me->query_pronoun(),
                       "$o", (string)me->query_objective(),
                       "$z", zone,
                       "$D", wep->poss_short(),
                       "$I", him->the_short(),
                       "$P", (string)him->the_poss_short(),
                       "$O", (string)him->query_objective(),
                       "$es", "es", "$s", "s" }) );
    ind = ({ replace( ind, ({ "$N", "you", "$p ", "your ",
                                "$r", "you", "$o", "you",
                                "$es", "", "$s", "",
                                "$D", wep->poss_short(),
                                "$z", zone,
                                "$I",  him->the_short(),
                                "$P", him->the_poss_short(),
                                "$O", him->query_objective(),
                                }) ),
               tmp,
               tmp });
    return ind;
  }
  return ({
    parse_string(ind[0], him, me, wep, zone),
      parse_string(ind[1], him, me, wep, zone),
      parse_string(ind[2], him, me, wep, zone)});
}

==================================================
FILE: handlers/bank_handler.c
==================================================

#define RESTORE_PATH "/save/bank_accounts/"
#define CHEAT_THRESHOLD 200000
class franchise {
   string office;
   int cost_per_month;
   int cost_per_new_account;
}
class bank_data {
   string master_office;
   class franchise* franchises;
   int cost_to_start;
   int default_cost_per_month;
   int default_cost_per_new_account;
}
private mapping accounts;
private nosave mapping _banks;
void do_cheat_check(string, string, int, string, int);
void create() {
   string str;
   _banks = ([ ]);
   str = unguarded((: read_file, RESTORE_PATH + "bank_data.o" :));
   if (str) {
      _banks = restore_variable(str);
   }
}
private void save_banks() {
   unguarded((: write_file, RESTORE_PATH + "bank_data.o",
                save_variable(_banks), 1 :));
}
private void init_data( string word ) {
  accounts = ([ ]);
}
int get_data_file( string name ) {
  int success;
  success = unguarded((: restore_object, RESTORE_PATH+
           name[0..0]+"/"+name :));
  if(!success) {
    init_data(name);
    return success;
  }
  return 1;
}
private void save_data_file( string name ) {
  if(!unguarded((: save_object, RESTORE_PATH+name[0..0]+"/"+name :)))
    debug_printf("Problem saving " + RESTORE_PATH+name[0..0]+"/"+name);
}
int query_account( string word, string bank_name ) {
  get_data_file( word );
  if ( !accounts ) {
    return -1;
  }
  if ( member_array( bank_name, m_indices( accounts ) ) == -1 ) {
    return -1;
  }
  return accounts[ bank_name ];
}
void adjust_account( string name, string bank_name, int amount ) {
  int before;
  get_data_file( name );
  before = accounts[ bank_name ];
  accounts[bank_name] += amount;
  if ( accounts[ bank_name ] < 0 ) {
    accounts = m_delete( accounts, bank_name );
  }
  do_cheat_check(name, bank_name, amount, "by", before);
  save_data_file( name );
  return;
}
void set_account( string name, string bank_name, int amount ) {
  int before;
  get_data_file( name );
  before = accounts[ bank_name ];
  if ( amount < 0 ) {
    accounts = m_delete( accounts, bank_name );
  } else {
    accounts[ bank_name ] = amount;
  }
  do_cheat_check(name, bank_name, amount, "to", before);
  save_data_file( name );
  return;
}
string *query_accounts(string player) {
  get_data_file(player);
  if(!accounts)
    return ({ });
  return keys(accounts);
}
void create_new_bank(string name, string master) {
   class bank_data data;
   if (_banks[name]) {
      return ;
   }
   data = new(class bank_data);
   data->master_office = master;
   data->franchises = ({ });
   data->cost_to_start = 2600000;
   data->default_cost_per_month = 360000;
   data->default_cost_per_new_account = 400;
   _banks[name] = data;
   save_banks();
}
void remove_bank(string name) {
   map_delete(_banks, name);
   save_banks();
}
class bank_data query_bank_data(string name) {
   return copy(_banks[name]);
}
void add_new_franchise(string name, string franchise_office) {
   class franchise franchise;
   if (!_banks[name]) {
      return ;
   }
   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         return ;
      }
   }
   franchise = new(class franchise);
   franchise->office = franchise_office;
   franchise->cost_per_month = _banks[name]->default_cost_per_month;
   franchise->cost_per_new_account = _banks[name]->default_cost_per_new_account;
   _banks[name]->franchises += ({ franchise });
   save_banks();
   return ;
}
void set_bank_default_cost_to_open(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }
   _banks[name]->cost_to_start = amount;
   save_banks();
   return ;
}
void set_bank_default_cost_per_new_account(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }
   _banks[name]->default_cost_per_new_account = amount;
   save_banks();
   return ;
}
void set_bank_franchise_cost_per_month(string name, string franchise_office,
                                     int amount) {
   class franchise franchise;
   if (!_banks[name]) {
      return ;
   }
   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         franchise->cost_per_month = amount;
         save_banks();
         return ;
      }
   }
   return ;
}
void set_bank_franchise_cost_per_new_account(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }
   _banks[name]->cost_per_new_account = amount;
   save_banks();
   return ;
}
void set_bank_default_cost_per_month(string name, int amount) {
   if (!_banks[name]) {
      return ;
   }
   _banks[name]->default_cost_per_month = amount;
   save_banks();
   return ;
}
int query_bank_default_cost_to_open(string name) {
   if (!_banks[name]) {
      return -1;
   }
   return _banks[name]->cost_to_start;
}
int query_bank_default_cost_per_new_account(string name) {
   if (!_banks[name]) {
      return -1;
   }
   return _banks[name]->default_cost_per_new_account;
}
int query_bank_franchise_cost_per_month(string name, string franchise_office) {
   class franchise franchise;
   if (!_banks[name]) {
      return -1;
   }
   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         return franchise->cost_per_month;
      }
   }
   return -1;
}
int query_bank_franchise_cost_per_new_account(string name,
                                              string franchise_office) {
   class franchise franchise;
   if (!_banks[name]) {
      return -1;
   }
   foreach (franchise in _banks[name]->franchises) {
      if (franchise->office == franchise_office) {
         return franchise->cost_per_new_account;
      }
   }
   return -1;
}
int query_bank_default_cost_per_month(string name) {
   if (!_banks[name]) {
      return -1;
   }
   return _banks[name]->default_cost_per_month;
}
string query_bank_master_office(string name) {
   if (!_banks[name]) {
      return 0;
   }
   return _banks[name]->master_office;
}
void set_bank_master_office(string name, string master) {
   if (!_banks[name]) {
      return 0;
   }
   _banks[name]->master_office = master;
   save_banks();
}
string* query_banks() {
   return keys(_banks);
}
string* query_franchises(string bank) {
   if (!_banks[bank]) {
      return ({ });
   }
   return map(_banks[bank]->franchises, (: $1->office :) );
}
void do_cheat_check(string name, string bank_name, int amount,
                    string str, int after) {
#ifdef LOGGING
  if((amount - after) > CHEAT_THRESHOLD) {
    log_file ("BANK_CHEAT", sprintf ("%s: %s deposited %d into %s.\n",
                                     ctime(time()), name, (amount-after),
                                     bank_name));
  }
#endif
}

==================================================
FILE: handlers/bits_controller.c
==================================================

#include <bits_controller.h>
object *bits;
private void do_update();
void create() {
  bits = ({ });
}
void add_bit(object ob) {
  if (!sizeof(bits))
    call_out( (: do_update() :), TIME_OUT);
  bits += ({ ob });
}
void remove_bit(object ob) {
  int i;
  if ((i = member_array(ob, bits)) == -1)
    return ;
  bits = delete(bits, i, 1);
}
private void do_update() {
  int i;
  bits = bits - ({ 0 });
  if (sizeof(bits))
    call_out((: do_update() :), TIME_OUT);
  for (i = sizeof(bits) - 1; i > -1; i--) {
    reset_eval_cost();
    bits[i]->do_decay();
  }
  bits = bits - ({ 0 });
}
int query_num_bits() { return sizeof(bits); }
object *query_bits() { return bits; }
void kickstart() {
  do_update();
}

==================================================
FILE: handlers/board_handler.c
==================================================

#include <board.h>
#include <mail.h>
#include <clubs.h>
#include <player_handler.h>
#define T_MIN 0
#define T_MAX 1
#define T_TIMEOUT 2
#define DEFAULT_MIN 10
#define DEFAULT_MAX 80
#define DEFAULT_TIMEOUT 14
#define ARCHIVE_DIR "/open/boards/"
#define MAX_ARCHIVE_SIZE 1048576
#define BACKUPS_DIR "/save/board_backups/"
#define NEWSRC_SAVE_DIR "/save/newsrc/"
#define BACKUP_TIME_OUT (7 * 24 * 60 * 60)
#define BOARD_HANDLE_VERSION 1
#ifdef USE_RAMDISK
#define CACHE_SIZE 10
#else
#define CACHE_SIZE 250
#endif
#define CACHE_TIMEOUT 1800
#define NEWSRC_SAVE_DELAY 300
class newsrc {
  int cached;
  int changed;
  mapping newsrc;
  string *kill;
  string *board_order;
}
class read_access_cache {
   int read_time;
   int read_access;
}
private int num;
private int board_version;
private mapping archives;
private mapping boards;
private mapping priv;
private mapping security;
private mapping timeouts;
private nosave string *_allowed_objects;
private nosave mapping message_cache;
private nosave mapping _newsrc_cache;
private nosave int total_reads, cache_hits, ram_hits, clean_out;
private nosave int _ram_exists;
private nosave int _newsrc_reads, _newsrc_cache_hits;
private mapping _idiots;
private nosave mapping _read_access_cache;
string query_archive(string board);
protected int zap_message(string board, int num, string name);
int can_delete_message(string board, int off, string pname);
void save_me();
void create() {
  int number;
  int last;
  string line;
  string *lines;
  seteuid(master()->creator_file(file_name(this_object())));
  num = 1;
  boards = ([ ]);
  security = ([ ]);
  _read_access_cache = ([ ]);
  priv = ([ ]);
  timeouts = ([ ]);
  archives = ([ ]);
  message_cache = ([ ]);
  _newsrc_cache = ([ ]);
  _allowed_objects = ({
    BOARD_HAND,
      "/obj/misc/board",
      "/obj/misc/board_mas",
      "/obj/handlers/applications_handler",
      "/w/ceres/board",
      "/w/ceres/board_mas",
      "/www/boards",
      "/www/secure/nboards",
      "/obj/handlers/club_handler",
      "/obj/handlers/deity_handler",
      "/obj/handlers/folder_handler",
      "/obj/handlers/playtesters",
      "/obj/handlers/error_tracker",
      "/obj/handlers/twiki",
      "/d/forn/utils/error_tracker",
      "/d/forn/handlers/peer_review",
      "/d/sur/utils/error_tracker",
      "/d/cwc/utils/error_tracker",
      "/d/Ankh-Morpork_dev/utils/error_tracker",
      "/d/liaison/utils/error_tracker",
      "/d/am/utils/error_tracker",
      "/d/guilds/priests/items/desk",
      "/d/ram/error_tracker",
      "/d/ram/cool/bank",
      "/d/special/error_tracker",
      "/d/klatch/utils/error_tracker",
      "/d/guilds/error_tracker",
      "/d/special/utils/error_tracker",
      "/d/am/patrician/pat_applications",
      "/d/am/patrician/pat_complaints",
      "/cmds/player/news",
      "/cmds/player/apply",
      "/d/guilds/assassins/Ankh-Morpork/admin/vote_room",
      "/d/special/player_shops/tarnach's_office",
      "/std/shops/player_shop/office",
      "/d/playtesters/handlers/applications",
      "/d/guilds/warriors/Ankh-Morpork/voting_booth",
      "/secure/cmds/creator/errors",
      "/obj/handlers/player_council",
      "/d/guilds/wizards/utils/board_hand",
      "/obj/handlers/complaints_handler",
      "/obj/handlers/project_management",
      "/d/guilds/thieves/Ankh-Morpork/rooms/ground/voting_booth",
      "/d/underworld/utils/error_tracker"
      });
  _idiots = ([ ]);
  if (file_size(BOARD_FILE +".gz") > 0) {
     unguarded((: cp, BOARD_FILE +".gz", BACKUPS_DIR +"boards."+ time() :));
  }
  lines = unguarded((: get_dir, BACKUPS_DIR +"boards.*" :));
  if ( sizeof( lines ) > 6 ) {
    last = time() - BACKUP_TIME_OUT;
    foreach(line in lines) {
      sscanf(line, "boards.%d", number);
      if (number < last)
        unguarded((: rm, BACKUPS_DIR + line :));
    }
  }
  if(!unguarded((: restore_object, BOARD_FILE+".gz" :)))
    unguarded((: restore_object, BOARD_FILE :));
  call_out("expire_boards", 5);
}
private string get_filename(string board, int num) {
   string fixed_board;
   fixed_board = replace(board, ({" ", "_", "'", ""}));
   return BOARD_DIR + fixed_board + "/" + num;
}
private string get_ram_filename(string board, int num) {
   string fixed_board;
   fixed_board = replace(board, ({" ", "_", "'", ""}));
   if(!_ram_exists) {
     _ram_exists = file_size(BOARD_RAM_DIR);
   }
   if(_ram_exists == -2)
     return BOARD_RAM_DIR + fixed_board + "/" + num;
   else
     return BOARD_DIR + fixed_board + "/" + num;
}
string *query_boards() {
   return keys(boards);
}
int is_board(string board) {
   if (boards[board]) {
      return 1;
   }
   return 0;
}
private int query_lord(string str) {
   return (int)master()->query_lord(str);
}
int is_idiot(string name) {
   if (!_idiots) {
      _idiots = ([ ]);
   }
   if (_idiots[name]) {
      if (_idiots[name] > time()) {
         return 1;
      }
      map_delete(_idiots, name);
   }
   return 0;
}
void add_idiot(string idiot, int length) {
   _idiots[idiot] = time() + (60 * 60 * 24 * length);
   save_me();
}
int query_idiot(string idiot) {
   return _idiots[idiot];
}
int test_can_read(string board, object previous,
                      string name) {
   int bit;
   int ret;
   if (member_array(base_name(previous), _allowed_objects) == -1 &&
       board != "announcements") {
#ifdef DEBUG
      log_file("BAD_BOARD", ctime(time()) + " (read): [" + board + "] " +
               base_name(previous) +
               sprintf(" (%O)\n", this_player()->query_name()));
#endif
      return 0;
   }
   bit = priv[board] & B_PRIV_TYPE_MASK;
   if (bit == 0) {
      return 1;
   }
   if (_read_access_cache[board] &&
       !undefinedp(_read_access_cache[board][name])) {
      return _read_access_cache[board][name];
   }
   ret = 1;
   if (bit == B_PRIV_ACCESS_RESTRICTED) {
      ret = query_lord(name) ||
         (member_array(name, security[board]) != -1);
   } else if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
      if (query_lord(name)) {
         ret = 1;
      } else {
         if (sizeof(security[board]) == 2) {
            ret = call_other(security[board][1],
                           security[board][0],
                           B_ACCESS_READ,
                           board, previous, name);
         }
      }
   }
   if (!_read_access_cache[board]) {
      _read_access_cache[board] = ([ ]);
   }
   _read_access_cache[board][name] = ret;
   return ret;
}
int test_can_write(string board, object previous,
                      string name) {
  int bit;
  if (is_idiot(name)) {
     return 0;
  }
  if (member_array(base_name(previous), _allowed_objects) == -1) {
#ifdef DEBUG
    log_file("BAD_BOARD", ctime(time()) + " (write): " + base_name(previous) +
                          sprintf(" (%O)\n", this_player()));
#endif
    return 0;
  }
  bit = priv[board] & B_PRIV_TYPE_MASK;
  if (bit == B_PRIV_ACCESS_RESTRICTED_FILE) {
    return member_array(base_name(previous), security[board]) != -1;
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
    if (query_lord(name)) {
      return 1;
    }
    if (sizeof(security[board]) == 2) {
      return call_other(security[board][1],
                        security[board][0],
                        B_ACCESS_WRITE,
                        board, previous, name);
    }
    return 0;
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED ||
      bit == B_PRIV_READ_ONLY) {
    return query_lord(name) ||
           (member_array(name, security[board]) != -1);
  }
  return 1;
}
int test_can_delete(string board, object previous,
                      string name) {
  int bit;
  if (member_array(base_name(previous), _allowed_objects) == -1) {
#ifdef DEBUG
    log_file("BAD_BOARD", ctime(time()) + " (write): " + base_name(previous) +
                          sprintf(" (%O)\n", this_player()));
#endif
    return 0;
  }
  bit = priv[board] & B_PRIV_TYPE_MASK;
  if (bit == B_PRIV_ACCESS_RESTRICTED_FILE) {
    return query_lord(name) ||
           member_array(base_name(previous), security[board]) != -1;
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED ||
      bit == B_PRIV_READ_ONLY) {
    return query_lord(name) ||
           (member_array(name, security[board]) != -1);
  }
  if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
    if (query_lord(name)) {
      return 1;
    }
    if (sizeof(security[board]) == 2) {
      return call_other(security[board][1],
                        security[board][0],
                        B_ACCESS_DELETE,
                        board, previous, name);
    }
  }
  return query_lord(name);
}
private string query_destination_eaten_note(string  board, object previous,
                                            string name) {
  int bit;
  bit = priv[board] & B_PRIV_TYPE_MASK;
  if (bit == B_PRIV_ACCESS_RESTRICTED_METHOD) {
    if (sizeof(security[board]) == 2) {
      return call_other(security[board][1],
                        security[board][0],
                        B_ACCESS_DELETE,
                        board, previous, name);
    }
  }
  return 0;
}
varargs mixed get_subjects(string name, string person) {
   string pl;
   int bit;
   if (file_name(previous_object()) == BOARD_WEB ||
       file_name(previous_object()) == "/w/ceres/cmds/test") {
      pl = person;
   } else if (this_player()) {
      pl = (string)this_player()->query_name();
   } else {
      pl = "unknown";
   }
   if (!test_can_read(name, previous_object(), pl)) {
      return ({ });
   }
   if (!boards[name] || bit) {
      return ({ });
   }
   return boards[name];
}
string get_message(string board, int num, string person) {
  string name, rname;
  if (file_name(previous_object()) == BOARD_WEB) {
     name = person;
  } else  if (file_name(previous_object())[0..10] !=
              "/obj/misc/board"[0..10]) {
    name = "unknown";
  } else {
    name = (string)this_player()->query_name();
  }
  if(board == "lordboard") {
    catch(log_file("/d/admin/log/LORDBOARD", "%s read by prev %s player %s\n",
                   ctime(time()), base_name(previous_object()),
                   this_player()->query_name()));
  }
  if (!test_can_read(board, previous_object(), name)) {
    return 0;
  }
  if (num < 0 || num >= sizeof(boards[board])) {
    return 0;
  }
  if(!message_cache) {
    message_cache = ([ ]);
  }
  total_reads++;
  if(message_cache[boards[board][num][B_NUM]]) {
    cache_hits++;
    return message_cache[boards[board][num][B_NUM]];
  }
  name = get_filename(board, boards[board][num][B_NUM]);
  if (file_size(name) <= 0) {
    return 0;
  }
  if(!clean_out && sizeof(keys(message_cache)) > CACHE_SIZE)
    clean_out = call_out("clean_cache", 10);
#ifdef USE_RAMDISK
  rname = get_ram_filename(board, boards[board][num][B_NUM]);
  if(rname != name) {
    if(file_size(rname) == -1) {
      unguarded((: cp, name, rname :));
    } else
      ram_hits++;
    name = rname;
  }
#endif
  if(!_ram_exists || _ram_exists == -1) {
    message_cache[boards[board][num][B_NUM]] = unguarded((: read_file, name :));
    return message_cache[boards[board][num][B_NUM]];
  } else {
    return unguarded((: read_file, name :));
  }
}
void clean_cache() {
  int i;
  int count;
  int *list;
  string name;
  count = sizeof(keys(message_cache));
  list = sort_array(keys(message_cache), 0);
  for(i=0; i < (count - CACHE_SIZE); i++) {
    map_delete(message_cache, list[i]);
  }
  foreach(name in keys(_newsrc_cache)) {
    if(!_newsrc_cache[name]->changed &&
       _newsrc_cache[name]->cached < time() - CACHE_TIMEOUT) {
      map_delete(_newsrc_cache, name);
    }
  }
  clean_out = 0;
   foreach (name in keys(_read_access_cache)) {
      _read_access_cache[name] = ([ ]);
   }
}
void save_me() {
  unguarded((: save_object, BOARD_FILE, 2 :));
}
int add_message(string board, string cap_name, string subject, string body,
                int reply_to, class reply_type bing) {
   int test;
   int irp;
   int index;
   string fname;
   string name;
   string from_mess;
   string mail_to;
   class reply_type reply;
   name = lower_case(cap_name);
   if (reply_to) {
      for (index = 0; index < sizeof(boards[board]); index++) {
         if (boards[board][index][B_NUM] == reply_to) {
            if (boards[board][index][B_REPLY_TYPE]) {
               reply = (class reply_type)boards[board][index][B_REPLY_TYPE];
               if (reply->type == B_REPLY_POSTER) {
                  mail_to = boards[board][index][B_NAME];
               } else if (reply->type == B_REPLY_NAMED) {
                  mail_to = reply->data;
               }
               if (mail_to) {
                  MAILER->do_mail_message(mail_to,
                                          name,
                                          subject,
                                          "",
                                          body);
                  return 1;
               }
            }
         }
      }
   }
   if (!test_can_write(board, previous_object(), name)) {
      return 0;
   }
   if (!boards[board] || test) {
      return 0;
   } else {
      boards[board] += ({ ({ subject,
                                cap_name,
                                num++,
                                time(),
                                bing,
                                reply_to }) });
   }
   if (file_name(previous_object())[0..4] == "/www/") {
      from_mess = " [Web post]";
   } else {
      from_mess = "";
   }
   fname = get_filename(board, num-1);
   unguarded((: rm, fname :));
   fname = get_filename(board, num-1);
   unguarded((: write_file, fname, body :));
   save_me();
   message_cache[num-1] = body;
   if (timeouts[board] && timeouts[board][T_MAX] &&
       sizeof(boards[board]) > timeouts[board][T_MAX]) {
      while (sizeof(boards[board]) > timeouts[board][T_MAX]) {
         zap_message(board, 0, 0);
         irp++;
      }
      if ((priv[board] & B_PRIV_TYPE_MASK) ==
          B_PRIV_ACCESS_RESTRICTED_METHOD) {
         if (sizeof(security[board]) == 2) {
            call_other(security[board][1],
                       security[board][0],
                       B_ACCESS_INFORM,
                       board, 0, cap_name, irp);
         }
      }
      if ( !(priv[board] & B_PRIV_NO_INFORM) ) {
         user_event( "inform",
                     sprintf( "%s posts a message to %s and %d message%s in sympathy%s",
                              cap_name, board, irp,
                              ( irp > 1 ? "s explode" : " explodes" ),
                              from_mess ),
                     "message",
                     this_player() );
      }
   } else {
      if ((priv[board] & B_PRIV_TYPE_MASK) ==
          B_PRIV_ACCESS_RESTRICTED_METHOD) {
         if (sizeof(security[board]) == 2) {
            call_other(security[board][1],
                       security[board][0],
                       B_ACCESS_INFORM,
                       board, 0, cap_name, 0);
         }
      }
      if ( !(priv[board] & B_PRIV_NO_INFORM) ) {
         user_event( "inform",
                     sprintf( "%s posts a message to %s%s",
                              cap_name, board, from_mess),
                     "message",
                     this_player() );
      }
   }
   return num-1;
}
int create_board(string board,
                 int priviliges,
                 string person) {
   if (boards[board]) {
      return 0;
   }
   if (!person) {
      person = this_player()->query_name();
   }
   boards[board] = ({ });
   security[board] = ({ person });
   if (priviliges) {
      priv[board] = priviliges;
   }
   save_me();
   return 1;
}
int add_allowed(string board, string name) {
  string nam;
  int board_type;
  board_type = priv[board] & B_PRIV_TYPE_MASK;
  if (sscanf(file_name(previous_object()), "/obj/misc/board%s", nam) != 1) {
    return 0;
  }
  nam = (string)this_player()->query_name();
  if (!test_can_write(board, previous_object(), nam) ||
      (board_type != B_PRIV_ACCESS_RESTRICTED &&
       board_type != B_PRIV_READ_ONLY &&
       board_type != B_PRIV_ACCESS_RESTRICTED_FILE)) {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
    return 0;
  }
  security[board] += ({ name });
  save_me();
  printf("Added %s to the security array for %s.\n",name, board);
  return 1;
}
int remove_allowed(string board, string name) {
  string nam;
  int i;
  int board_type;
  if (sscanf(file_name(previous_object()), "/obj/misc/board%s", nam) != 1) {
    return 0;
  }
  nam = geteuid(previous_object());
  board_type = priv[board] & B_PRIV_TYPE_MASK;
  if (!test_can_write(board, previous_object(), nam) ||
      (board_type != B_PRIV_ACCESS_RESTRICTED &&
       board_type != B_PRIV_READ_ONLY &&
       board_type != B_PRIV_ACCESS_RESTRICTED_FILE)) {
    return 0;
  }
  security[board] = delete(security[board], i, 1);
  save_me();
  printf("Removed %s from the security array for %s.\n", name, board);
  return 1;
}
int set_method_access_call(string board, string method, string name) {
   string pl;
   if (!boards[board] ||
       (priv[board] & B_PRIV_TYPE_MASK) != B_PRIV_ACCESS_RESTRICTED_METHOD) {
      return 0;
   }
   if (this_player()) {
      pl = (string)this_player()->query_name();
   } else {
      pl = "unknown";
   }
   if (query_lord(pl) ||
       file_name(previous_object()) == CLUB_HANDLER) {
      security[board] = ({ method, name });
      save_me();
      return 1;
   }
   return 0;
}
int force_board_method_access_restricted(string board) {
   string pl;
   if (!boards[board]) {
      return 0;
   }
   if (this_player()) {
      pl = (string)this_player()->query_name();
   } else {
      pl = "unknown";
   }
   if (query_lord(pl) ||
       file_name(previous_object()) == CLUB_HANDLER) {
      priv[board] = (priv[board] & ~B_PRIV_TYPE_MASK) |
                    B_PRIV_ACCESS_RESTRICTED_METHOD;
      save_me();
      return 1;
   }
   return 0;
}
protected int zap_message(string board, int off, string name) {
  int num;
  string nam, archive;
  if (off < 0 || off >= sizeof(boards[board])) {
    return 0;
  }
  num = boards[board][off][B_NUM];
  nam = get_filename(board, num);
  archive = query_archive(board);
  if (archive) {
    mixed *stuff;
    stuff = boards[board][off];
    unguarded((: write_file, archive,
               sprintf("\n----\nNote #%d by %s posted at %s\nTitle: '%s'\n\n",
                       off, stuff[B_NAME], ctime(stuff[B_TIME]),
                       stuff[B_SUBJECT])+unguarded((: read_file, nam :)) :));
    if(unguarded( (: file_size, archive :) ) > MAX_ARCHIVE_SIZE)
      unguarded((: rename, archive, archive+"."+time() :));
  }
  boards[board] = delete(boards[board],off,1);
  unguarded((: rm, nam :));
  save_me();
  return 1;
}
int delete_message(string board, int off, string override_name) {
  string nam;
  if (file_name(previous_object()) == "/www/boards") {
    nam = override_name;
  } else {
    nam = this_player()->query_name();
  }
  if (!can_delete_message(board, off, nam)) {
    return 0;
  }
  return zap_message(board, off, nam);
}
int can_delete_message(string board, int off, string pname) {
  if (!boards[board]) {
    return 0;
  }
  if (off >= sizeof(boards[board])) {
    return 0;
  }
  if (!test_can_delete(board, previous_object(), pname) &&
      (lower_case(boards[board][off][B_NAME]) != lower_case(pname))) {
    return 0;
  }
  return 1;
}
string *query_security(string board) {
  string *str;
  str = security[board];
  if (!str) {
    return str;
  }
  return copy(str);
}
int delete_board(string board) {
  string nam;
  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!query_lord(nam) ||
      file_name(previous_object()) == CLUB_HANDLER) {
    return 0;
  }
  while (sizeof(boards[board])) {
    if (!zap_message(board, 0, 0)) {
        return 0;
    }
  }
  map_delete(boards, board);
  map_delete(security, board);
  map_delete(archives, board);
  map_delete(timeouts, board);
  save_me();
  return 1;
}
string *list_of_boards() {
  return keys(boards);
}
int set_timeout(string board, int timeout) {
  string nam;
  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0;
  }
  if (!timeouts[board]) {
    timeouts[board] = ({ DEFAULT_MIN, DEFAULT_MAX, timeout });
    return 1;
  }
  timeouts[board][T_TIMEOUT] = timeout;
  save_me();
  printf("Set the automagic timeout to %d days for %s.\n", timeout, board);
  return 1;
}
int set_minimum(string board, int min) {
  string nam;
  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0;
  }
  if (!timeouts[board]) {
    timeouts[board] = ({ min, DEFAULT_MAX, DEFAULT_TIMEOUT });
    return 1;
  }
  timeouts[board][T_MIN] = min;
  save_me();
  printf("Set the minimum number of messages to %d for %s.\n", min, board);
  return 1;
}
int set_maximum(string board, int max) {
  string nam;
  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0;
  }
  if (!timeouts[board]) {
    timeouts[board] = ({ DEFAULT_MIN, max, DEFAULT_TIMEOUT });
    return 1;
  }
  timeouts[board][T_MAX] = max;
  save_me();
  printf("Set the maximum number of messages to %d for %s.\n", max, board);
  return 1;
}
int set_archive(string board, string file) {
  string nam;
  if (!boards[board]) {
    return 0;
  }
  nam = geteuid(previous_object());
  if (!test_can_write(board, previous_object(), nam)) {
    return 0;
  }
  archives[board] = file;
  save_me();
  printf("Set the archive file to %s for %s.\n", file, board);
  return 1;
}
int query_timeout(string board) {
  if (!timeouts[board]) {
    return 0;
  }
  return timeouts[board][T_TIMEOUT];
}
int query_minimum(string board) {
  if (!timeouts[board]) {
    return 0;
  }
  return timeouts[board][T_MIN];
}
int query_maximum(string board) {
  if (!timeouts[board]) {
    return 0;
  }
  return timeouts[board][T_MAX];
}
string query_archive(string board) {
  if (!boards[board]) {
    return 0;
  }
  if (undefinedp(archives[board])) {
    return ARCHIVE_DIR+board;
  }
  return archives[board];
}
int query_restricted_access(string board) {
   return (priv[board] & B_PRIV_TYPE_MASK) == B_PRIV_ACCESS_RESTRICTED;
}
int query_restricted_access_file(string board) {
   return (priv[board] & B_PRIV_TYPE_MASK) == B_PRIV_ACCESS_RESTRICTED_FILE;
}
int query_read_only(string board) {
  return (priv[board] & B_PRIV_TYPE_MASK) == B_PRIV_READ_ONLY;
}
int query_no_inform(string board) {
  return priv[board] & B_PRIV_NO_INFORM;
}
int query_privilage(string board) {
   return priv[board];
}
void expire_boards() {
  string nam;
  int tim, num, *val;
  foreach (nam, val in timeouts) {
    num = 0;
    if ((tim = val[T_TIMEOUT]) &&
        (sizeof(boards[nam]) > val[T_MIN]) &&
        ((boards[nam][0][B_TIME]+(tim*(24*60*60))) < time())) {
      while (sizeof(boards[nam]) > val[T_MIN] &&
             boards[nam][0][B_TIME]+(tim*24*60*60) < time()) {
        zap_message(nam, 0, 0);
        num++;
      }
      user_event( "inform", sprintf("Board handler removes %d messages "
                                       "from %s", num, nam), "message");
    }
  }
  if (find_call_out("expire_boards") == -1) {
    call_out("expire_boards", 60*60);
  }
}
int query_prevent_shadow() {
  return 1;
}
int query_num() {
  return num;
}
mixed *stats() {
  if(!total_reads)
    total_reads = 1;
  if(!cache_hits)
    cache_hits = 1;
  if(!ram_hits)
    ram_hits = 1;
  return  ({
    ({ "messages read", total_reads, }),
#ifdef USE_CACHE
      ({ "cache hit percent", (cache_hits * 100) / total_reads, }),
#endif
      ({ "ram hit percent", (ram_hits * 100) / total_reads, }),
      ({ "messages in cache", sizeof(keys(message_cache)), }),
      ({ "newsrc reads", _newsrc_reads, }),
      ({ "newsrc hit percent", (_newsrc_cache_hits * 100) / _newsrc_reads, }),
        ({ "newsrcs in cache", sizeof(keys(_newsrc_cache)), }),
          });
}
void query_cache() {
    printf("%O\n", sort_array(keys(message_cache), 0));
}
int load_newsrc(string player) {
  string fname, board;
  _newsrc_reads++;
  if(_newsrc_cache[player]) {
    _newsrc_cache_hits++;
    return 1;
  }
  fname = NEWSRC_SAVE_DIR+player[0..0]+"/"+player+ ".o";
  if(unguarded( (: file_size($(fname)) :)) > 0) {
    _newsrc_cache[player] =
      unguarded((: restore_variable(read_file($(fname))) :));
    if (arrayp(_newsrc_cache[player]->newsrc)) {
      _newsrc_cache[player]->newsrc = ([ ]);
      if (find_call_out("flush_newsrc") == -1) {
        call_out("flush_newsrc", NEWSRC_SAVE_DELAY);
      }
    }
    return 1;
  } else {
    _newsrc_cache[player] = new(class newsrc,
                                cached : time(),
                                kill : ({ }),
                                newsrc : ([ ]),
                                board_order : ({ }));
    if(PLAYER_HANDLER->test_property(player, NEWS_RC))
      _newsrc_cache[player]->newsrc =
        PLAYER_HANDLER->test_property(player, NEWS_RC);
    if(PLAYER_HANDLER->test_property(player, BOARD_ORDER))
      _newsrc_cache[player]->board_order =
        PLAYER_HANDLER->test_property(player, BOARD_ORDER);
    foreach(board in keys(boards)) {
      if(PLAYER_HANDLER->test_property(player, "news_kill_"+board)) {
        _newsrc_cache[player]->kill += ({ board });
      }
    }
    _newsrc_cache[player]->changed = time();
    if(find_call_out("flush_newsrc") == -1)
      call_out("flush_newsrc", NEWSRC_SAVE_DELAY);
    return 1;
  }
  return 0;
}
void flush_newsrc(int force) {
  string fname, player, board, *board_list;
  object ob;
  board_list = map(keys(boards), (: lower_case($1) :));
  foreach(player in keys(_newsrc_cache)) {
    if(!force && (!_newsrc_cache[player]->changed ||
       (_newsrc_cache[player]->changed > time() - NEWSRC_SAVE_DELAY &&
        !find_object("/obj/shut"))))
      continue;
    fname = NEWSRC_SAVE_DIR + player[0..0] + "/" + player + ".o";
    if(unguarded( (: file_size($(fname)) :)) > 0) {
      _newsrc_cache[player]->newsrc =
        filter(_newsrc_cache[player]->newsrc,
               (: member_array(lower_case($1), $(board_list)) != -1 :));
      if(_newsrc_cache[player]->kill)
        _newsrc_cache[player]->kill =
          filter(_newsrc_cache[player]->kill,
                 (: member_array(lower_case($1), $(board_list)) != -1 :));
      if(_newsrc_cache[player]->board_order)
        _newsrc_cache[player]->board_order =
          filter(_newsrc_cache[player]->board_order,
                 (: member_array(lower_case($1), $(board_list)) != -1 :));
      unguarded( (: write_file($(fname), save_variable(_newsrc_cache[$(player)]),
                               1) :));
    } else if(ob = find_player(player)) {
      unguarded( (: write_file($(fname),
                               save_variable(_newsrc_cache[$(player)]), 1) :));
      ob->remove_property(NEWS_RC);
      ob->remove_property(BOARD_ORDER);
      foreach(board in keys(boards)) {
        ob->remove_property("news_kill_" + lower_case(board));
      }
    } else {
      PLAYER_HANDLER->special_add_property(player, NEWS_RC, _newsrc_cache[player]->newsrc);
    }
    _newsrc_cache[player]->changed = 0;
  }
}
mapping query_newsrc(string player) {
  if(!load_newsrc(player))
    return ([ ]);
  _newsrc_cache[player]->cached = time();
  return _newsrc_cache[player]->newsrc;
}
int set_newsrc(string player, mapping newsrc) {
  if(!load_newsrc(player))
    return 0;
  _newsrc_cache[player]->newsrc = (mapping)newsrc;
  _newsrc_cache[player]->cached = time();
  _newsrc_cache[player]->changed = time();
  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);
  return 1;
}
int query_killfile(string player, string board) {
  if(!load_newsrc(player))
    return 0;
  _newsrc_cache[player]->cached = time();
  return member_array(board, _newsrc_cache[player]->kill) != -1;
}
int set_killfile(string player, string board) {
  if(!load_newsrc(player))
    return 0;
  if(member_array(board, _newsrc_cache[player]->kill) != -1)
    return 1;
  _newsrc_cache[player]->kill += ({ board });
  _newsrc_cache[player]->changed = time();
  _newsrc_cache[player]->cached = time();
  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);
  return 1;
}
int remove_killfile(string player, string board) {
  if(!load_newsrc(player))
    return 0;
  if(member_array(board, _newsrc_cache[player]->kill) == -1)
    return 1;
  _newsrc_cache[player]->kill -= ({ board });
  _newsrc_cache[player]->changed = time();
  _newsrc_cache[player]->cached = time();
  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);
  return 1;
}
string *list_killfile(string player) {
  if(!load_newsrc(player))
    return ({ });
  return _newsrc_cache[player]->kill;
}
string *query_board_order(string player) {
  if(!load_newsrc(player))
    return ({ });
  _newsrc_cache[player]->cached = time();
  if(!_newsrc_cache[player]->board_order)
    return ({ });
  return _newsrc_cache[player]->board_order;
}
int set_board_order(string player, string *new_order) {
  if(!load_newsrc(player))
    return 0;
  _newsrc_cache[player]->board_order = new_order;
  _newsrc_cache[player]->changed = time();
  _newsrc_cache[player]->cached = time();
  if(find_call_out("flush_newsrc") == -1)
    call_out("flush_newsrc", NEWSRC_SAVE_DELAY);
  return 1;
}
void dest_me() {
  flush_newsrc(1);
  destruct(this_object());
}

==================================================
FILE: handlers/book_handler.c
==================================================

#include <book_handler.h>
#include <language.h>
#define SAVE_DIR "/save/book_handler/"
#define SAVE_FILE (SAVE_DIR "main_save")
#define OWNER_INDEX "owner"
#define PAGES_INDEX "pages"
int current_book_number;
mapping banished_books;
int compare_page(object page1, object page2);
void load_it();
void save_it();
int check_book_same(object book, int num);
protected string *query_pages(object book);
int compare_pages(string *pages1, string *pages2);
string *query_book_pages(int book_num);
void create() {
   banished_books = ([ ]);
   seteuid(getuid());
   load_it();
}
int query_book_exists(int book_num) {
   return unguarded((: file_size(SAVE_DIR + $(book_num) + ".o") :)) > 0;
}
int add_book(object book, int num, string pl_name) {
   string *stuff;
   mapping bing;
   if (num) {
      if (check_book_same(book, num)) {
         return num;
      }
   }
   while (query_book_exists(current_book_number)) {
      current_book_number++;
   }
   stuff = query_pages(book);
   bing = ([ OWNER_INDEX : pl_name, PAGES_INDEX : stuff ]);
   unguarded( (: write_file(SAVE_DIR + current_book_number + ".o",
              save_variable($(bing))) :) );
   num = current_book_number++;
   save_it();
   return num;
}
int check_book_same(object book, int num) {
   string *bing;
   string *fluff;
   int old_open_page;
   int same;
   old_open_page = book->query_open_page();
   same = 0;
   if (query_book_exists(num) > 0) {
      bing = query_book_pages(num);
      fluff = query_pages(book);
      if (compare_pages(bing, fluff) > 90) {
         same = 1;
      }
   } else {
      same = 0;
   }
   book->set_open_page(old_open_page);
   return same;
}
string *query_book_pages(int book_num) {
   mapping bing;
   string tmp;
   tmp = unguarded((: read_file(SAVE_DIR + $(book_num) + ".o") :));
   if (tmp) {
      bing = restore_variable(tmp);
      return bing[PAGES_INDEX];
   }
   return 0;
}
string query_book_owner(int book_num) {
   mapping bing;
   string tmp;
   tmp = unguarded((: read_file(SAVE_DIR + $(book_num) + ".o") :));
   if (tmp) {
      bing = restore_variable(tmp);
      return bing[OWNER_INDEX];
   }
   return 0;
}
string *query_pages(object book) {
   int i;
   string *ret;
   mixed *stuff;
   mixed *group;
   string text;
   int old_open_page;
   object ob;
   ret = ({ });
   old_open_page = book->query_open_page();
   for (i = 0; i < book->query_num_pages(); i++) {
      book->set_open_page(i);
      ob = book->query_current_page();
      if (!book->is_current_page_torn_out() &&
          !ob->query_property(BH_IGNORE_PAGE)) {
         stuff = ob->query_read_mess();
         text = "";
         foreach (group in stuff) {
            text += group[READ_MESS];
         }
         ret += ({ text  });
      }
   }
   book->set_open_page(old_open_page);
   return ret;
}
int compare_pages(string *pages1, string *pages2) {
   int no_chars;
   int no_same;
   int pos;
   int start;
   string page;
   string *tmp;
   pos = 0;
   if (sizeof(pages1) > sizeof(pages2)) {
      tmp = pages1;
      pages1 = pages2;
      pages2 = tmp;
   }
   foreach (page in pages1) {
      pos = 0;
      do {
         start = strsrch(page, pages2[pos]);
         if (start == -1) {
            start = strsrch(pages2[pos], page);
            if (start == -1) {
               pos++;
            } else {
               no_same += strlen(page);
            }
         } else {
            no_same += strlen(pages2[pos]);
         }
      } while ((start == -1) && (pos < sizeof(pages2)));
      no_chars += strlen(page);
   }
   if (no_chars > 0) {
      return (no_same * 100) / no_chars;
   }
   return 0;
}
int compare_page(string page1, string page2) {
   mixed *stuff1;
   mixed *stuff2;
   string text1;
   string text2;
   int i;
   stuff2 = page2->query_read_mess();
   text1 = "";
   for (i = 0; i < sizeof(stuff1); i++) {
      text1 += stuff1[READ_MESS];
   }
   text2 = "";
   for (i = 0; i < sizeof(stuff2); i++) {
      text2 += stuff2[READ_MESS];
   }
   return (text1 == text2);
}
int add_banished_book(int book_num, string reason) {
   if (!stringp(reason) || !intp(book_num)) {
      return 0;
   }
   if (!query_book_exists(book_num)) {
      return 0;
   }
   banished_books[book_num] = reason;
}
string query_banished_book(int book_num) {
   return banished_books[book_num];
}
mapping query_all_banished_books() {
   return banished_books;
}
void save_it() {
   unguarded((: save_object(SAVE_FILE) :));
}
void load_it() {
   unguarded((: restore_object(SAVE_FILE) :));
   if (!current_book_number) {
      current_book_number = 1;
   }
   if (!banished_books) {
      banished_books = ([ ]);
   }
}

==================================================
FILE: handlers/bounty.c
==================================================

#include <money.h>
#define SAVE_FILE "/save/bounty"
#define EXPIRY 60 * 60 * 8 * 60
#define BASE 40000
#define TAXES 60
#define LOGIN "/secure/login"
class bounty {
   string short;
   string *victims;
   int value;
   int active;
   int time;
}
mapping bounty, collect;
void create() {
   bounty  = ([ ]);
   collect = ([ ]);
   seteuid( "Room" );
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
   call_out( "tidy_bounties", 120 );
}
void save_file() { unguarded( (: save_object, SAVE_FILE :) ); }
void delete_bounty( string word ) {
   map_delete( bounty, word );
   save_file();
}
void tidy_bounties() {
   int now = time();
   string word;
   object thing;
   class bounty record;
   foreach ( word, record in bounty ) {
      if ( LOGIN->test_creator( word ) ) {
         log_file( "BOUNTY", "%s: bounty removed from %s (creator)\n",
               ctime( now ), word );
         map_delete( bounty, word );
         continue;
      }
      if (record && record->time + EXPIRY < now ) {
         if (record->active )
            log_file( "BOUNTY", "%s: bounty on %s of %d expired\n",
                  ctime( now ), word, record->value );
         else
            log_file( "BOUNTY", "%s: inactive bounty on %s cancelled\n",
                  ctime( now ), word );
         thing = find_player( word );
         if ( objectp( thing ) )
            tell_object( thing, "You feel that there is no longer "
                  "a price on your head.\n" );
         map_delete( bounty, word );
         continue;
      }
   }
   foreach ( word, record in collect )
      if ( !LOGIN->test_user( word ) ) {
         map_delete( collect, word );
         continue;
      }
      if (record && record->time + EXPIRY < now ) {
         log_file( "BOUNTY", "%s: bounty of %d owed to %s expired\n",
               ctime( now ), record->value, word );
         thing = find_player( word );
         if ( objectp( thing ) )
            tell_object( thing, "You have the funniest feeling that "
                  "you just let a lot of money get away.\n" );
         map_delete( collect, word );
      }
   save_file();
}
void clear_bounties() {
   if ( !master()->high_programmer( geteuid( this_player( 1 ) ) ) )
      return 0;
   bounty  = ([ ]);
   collect = ([ ]);
   save_file();
}
void dest_me() { destruct( this_object() ); }
void register_kill( object victim, object *attackers ) {
   int now, reward;
   string killed, killer, *killers;
   object thing;
   class bounty record;
   if ( member_array( victim, attackers ) != -1 )
      return;
   if ( victim->query_creator() || victim->query_property( "no bounties" ) )
      return;
   if ( !environment( victim ) )
      return;
   if ( environment( victim )->query_property( "bar brawling" ) )
      return;
   now = time();
   killed = (string)victim->query_short();
   if ( undefinedp( bounty[ lower_case( killed ) ] ) ) {
      return;
      foreach ( thing in attackers ) {
         if ( !objectp( thing ) )
            continue;
         if ( thing->query_creator() )
            continue;
         if ( !userp( thing ) && !thing->query_property( "unique" ) )
            continue;
         if ( ( (object)thing->query_property( "inhumer" ) == victim ) &&
               ( (object)victim->query_property( "inhumee" ) == thing ) )
            continue;
         killer = (string)thing->query_short();
         if ( undefinedp( bounty[ lower_case( killer ) ] ) ) {
            record = new( class bounty );
            bounty[ lower_case( killer ) ] = record;
            record->short = killer;
            record->victims = ({ killed });
         } else {
            record = (class bounty)bounty[ lower_case( killer ) ];
            if ( strsrch( lower_case( killed ),
                  lower_case( implode( record->victims, ", " ) ) ) == -1 )
               record->victims += ({ killed });
         }
         record->time = now;
         if ( record->active ) {
            record->value = sizeof( record->victims ) * BASE;
            if ( sizeof( record->victims ) > 1 )
               call_out( "inform_bounty", 30, thing );
         }
      }
      save_file();
      return;
   }
   if ( !( ( (class bounty)bounty[ lower_case( killed ) ] )->active ) )
      return;
   killers = ({ });
   foreach ( thing in attackers ) {
      if ( !objectp( thing ) )
         continue;
      if ( thing->query_creator() )
         continue;
      if ( !userp( thing ) && !thing->query_property( "unique" ) &&
            !thing->query_property( "bounty hunter" ) )
         continue;
      killer = (string)thing->query_short();
      killers += ({ killer });
      call_out( "well_done", 30, thing, (string)victim->query_gender() );
   }
   if ( sizeof( killers ) ) {
      reward = ( (class bounty)bounty[ lower_case( killed ) ] )->value /
            sizeof( killers );
      foreach ( killer in killers ) {
         if ( !undefinedp( bounty[ lower_case( killer ) ] ) )
            continue;
         if ( undefinedp( collect[ lower_case( killer ) ] ) ) {
            record = new( class bounty );
            collect[ lower_case( killer ) ] = record;
            record->short = killer;
            record->victims = ({ killed });
         } else {
            record = (class bounty)collect[ lower_case( killer ) ];
            record->victims += ({ killed });
         }
         record->time = now;
         record->value += reward;
      }
      log_file( "BOUNTY", "%s: bounty on %s fulfilled by %s\n",
            ctime( now ), lower_case( killed ),
            query_multiple_short( map_array( killers,
            (: lower_case( $1 ) :) ) ) );
      map_delete( bounty, lower_case( killed ) );
   }
   save_file();
}
void inform_bounty( object thing ) {
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   tell_object( thing, "You feel the price on your head rise.\n" );
}
void well_done( object thing, int gender ) {
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   tell_object( thing, "You feel good about killing a wanted "+
         ({ "creature", "man", "woman" })[gender] +".\n" );
}
string report_murder( string killer ) {
   string place;
   class bounty record;
   if ( undefinedp( bounty[ lower_case( killer ) ] ) )
      return "According to the records, \""+ killer +
            "\" has never killed anyone.";
   killer = lower_case( killer );
   record = (class bounty)bounty[ killer ];
   if ( record->active ) {
      place = (string)environment( this_player() )->query_property( "place" );
      if ( !place || ( place == "" ) )
         place = "default";
      return "There is already a bounty of "+
            (string)MONEY_HAND->money_value_string( record->value, place ) +
            " offered for the death of "+ record->short +".";
   }
   record->active = 1;
   record->value = sizeof( record->victims ) * BASE;
   call_out( "issue_warrant", 30, killer );
   save_file();
   if ( strsrch( lower_case( (string)this_player()->query_short() ),
         lower_case( implode( record->victims, ", " ) ) ) == -1 )
      return "Ah, a concerned citizen reporting a murder.  I'll issue "
            "a bounty notice for "+ record->short +" right away.";
   return "I'm sorry to hear that "+ record->short +" caused you "
         "harm.  I'll issue a bounty notice right away.";
}
void issue_warrant( string killer ) {
   object thing;
   thing = find_player( killer );
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   thing->remove_hide_invis( "hide" );
   tell_room( environment( thing ), "There is a small unspectacular flash "
         "of light and a small orange imp appears.  It promptly informs "+
         (string)thing->the_short() +" that a bounty has been placed on "+
         (string)thing->query_possessive() +" head.  The imp bows deeply, "
         " smiles evilly, and vanishes in an equally unspectacular flash "
         "of light.\n", thing );
   tell_object( thing, "There is a small unspectacular flash of light and "
         "a small orange imp appears.  It promptly informs you that a bounty "
         "has been placed on your head.  The imp bows deeply, smiles evilly, "
         "and vanishes in an equally unspectacular flash of light.\n" );
}
string collect_bounty() {
   int money;
   string collector, place;
   class bounty record;
   collector = lower_case( (string)this_player()->query_short() );
   if ( undefinedp( collect[ collector ] ) )
      return "According to the records, you've done nothing "
            "to deserve a bounty.";
   record = (class bounty)collect[ collector ];
   money = ( record->value * ( 100 - TAXES ) ) / 100;
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   this_player()->adjust_money( (mixed *)MONEY_HAND->create_money_array( money,
         place ) );
   this_player()->set_title( "bounty", "Bounty Hunter" );
   map_delete( collect, collector );
   save_file();
   return "Ah yes, let's see.  Monies owed to you total "+
         (string)MONEY_HAND->money_value_string( record->value, place ) +
         ", minus death tax, inheritance tax, income tax, pension fund "
         "contribution, union dues, VAT, Save the Womble donations and "
         "administrative charges, which leaves you with the grand sum of "+
         (string)MONEY_HAND->money_value_string( money, place ) +
         ".  Nice doing business with you.";
}
int query_bounty( string word ) { return !undefinedp( bounty[ word ] ); }
int query_bounty_value( string word ) {
   if ( undefinedp( bounty[ word ] ) )
      return 0;
   return ( (class bounty)bounty[ word ] )->value;
}
string query_all_bounties() {
   int cre;
   string list, word, place;
   class bounty record;
   cre = (int)this_player( 1 )->query_creator();
   if ( !sizeof( bounty ) )
      return "There are no bounties currently offered.\n";
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   list = "";
   foreach ( word, record in bounty )
      if ( record->active ) {
         list += sprintf( " -   %-15s for %s\n", record->short,
               (string)MONEY_HAND->money_value_string( record->value,
               place ) );
         if ( cre )
            list += sprintf( "               %-#60s\n               %s\n",
                  implode( record->victims, "\n" ),
                  ctime( record->time + EXPIRY ) );
      } else
         if ( cre )
            list += sprintf( " -   %-15s (inactive)\n"
                  "               %-#60s\n               %s\n",
                  record->short, implode( record->victims, "\n" ),
                  ctime( record->time + EXPIRY ) );
   if ( list == "" )
      return "There are no bounties currently offered.\n";
   return "The following bounters are currently offered:\n"+ list;
}
string query_all_collectors() {
   string list, word, place;
   class bounty record;
   if ( !sizeof( collect ) )
      return "There are no bounties awaiting collection.\n";
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   list = "";
   foreach ( word, record in collect )
         list += sprintf( " -   %-15s owed %s\n               %s\n",
               record->short,
               (string)MONEY_HAND->money_value_string( record->value, place ),
               ctime( record->time + EXPIRY ) );
   return "The following bounties are awaiting collection:\n"+ list;
}
string query_bounty_info( string word ) {
   string place;
   class bounty record;
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   if ( undefinedp( bounty[ word ] ) )
      return 0;
   record = (class bounty)bounty[ word ];
   if ( !record->active )
      return 0;
   return "A bounty of "+
         (string)MONEY_HAND->money_value_string( record->value, place ) +
         " is offered for the death of "+ record->short +" for the murder of "+
         query_multiple_short( record->victims ) +".\n";
}

==================================================
FILE: handlers/broadcaster.c
==================================================

#define DIR_ARRAY ({ "east", "northeast", "north", "northwest", \
                     "west", "southwest", "south", "southeast", "east" })
#define SAVE_FILE "/save/broadcaster"
#define BROADCAST_HISTORY_LENGTH 10
void broadcast_event( object *things,
                      int *centre,
                      string message,
                      int range,
                      int inside,
                      int underwater );
void npc_hear_shouts(object newlistener);
int npc_unhear_shouts(object oldlistener);
void npc_shout_event( object shouter,
                      string start,
                      string message,
                      string lang,
                      int *coord,
                      int range );
private void load_me();
private void save_me();
private nosave object *_listeners;
private nosave mapping _channels;
private nosave mapping _channel_history;
private mapping _channel_ids;
void create() {
   _listeners = ({ });
   _channels = ([ ]);
   _channel_ids = ([ ]);
   _channel_history = ([ ]);
   load_me();
}
mixed *get_direc_dist( int *co_ord1, int *co_ord2 ) {
   int dx, dy, dz, sector;
   if (!pointerp(co_ord1) ||
       !pointerp(co_ord2)) {
      return ({ 0, DIR_ARRAY[0], 0 });
   }
   dx = co_ord1[ 0 ] - co_ord2[ 0 ];
   dy = co_ord1[ 1 ] - co_ord2[ 1 ];
   dz = co_ord1[ 2 ] - co_ord2[ 2 ];
   if ( dx > 0 ) {
      if ( ( 1000 * dy ) > ( 2414 * dx ) ) {
         sector = 0;
      } else {
         if ( ( 1000 * dy ) > ( 414 * dx ) ) {
            sector = 1;
         } else {
            if ( ( 1000 * dy ) > ( -414 * dx ) ) {
               sector = 2;
            } else {
               if ( ( 1000 * dy ) > ( -2414 * dx ) ) {
                  sector = 3;
               } else {
                  sector = 4;
               }
            }
         }
      }
   } else {
      if ( ( 1000 * dy ) < ( 2414 * dx ) ) {
         sector = 4;
      } else {
         if ( ( 1000 * dy ) < ( 414 * dx ) ) {
            sector = 5;
         } else {
            if ( ( 1000 * dy ) < ( -414 * dx ) ) {
               sector = 6;
            } else {
               if ( ( 1000 * dy ) < ( -2414 * dx ) ) {
                  sector = 7;
               } else {
                  sector = 8;
               }
            }
         }
      }
   }
   return ({ dx * dx + dy * dy + dz * dz, DIR_ARRAY[ sector ], dz });
}
void broadcast_event( object *things, int *centre, string message,
      int range, int inside, int underwater ) {
   int *to;
   string text;
   object thing, place;
   mixed *dir_direc;
   if ( !pointerp( things ) ||
        !pointerp( centre ) ||
        sizeof( centre ) != 3 ) {
      return;
   }
   foreach ( thing in things ) {
      if ( !living( thing ) ) {
         continue;
      }
      place = environment( thing );
      if ( !place ) {
         continue;
      }
      to = (int *)place->query_co_ord();
      if ( !pointerp( to ) || sizeof( to ) != 3 ) {
         continue;
      }
      switch ( (string)place->query_property( "location" ) ) {
         case "inside" :
            if ( !inside ) {
               continue;
            }
            break;
         case "underwater" :
            if ( !underwater ) {
               continue;
            }
            break;
         default :
      }
      dir_direc = get_direc_dist( centre, to );
      if ( dir_direc[ 0 ] < 0 ) {
         continue;
      }
      if ( dir_direc[ 0 ] > range * range ) {
         continue;
      }
      switch ( dir_direc[ 0 ] ) {
         case 0 :
            continue;
         case 1 .. 2500 :
            if ( ( dir_direc[ 2 ] * dir_direc[ 2 ] ) > ( dir_direc[ 0 ] / 2 ) ) {
               if ( dir_direc[ 2 ] > 0 ) {
                  text = "Right above you, "+ message +"\n";
               } else {
                  text = "Right below you, "+ message +"\n";
               }
            } else {
               text = "Very close to the "+ dir_direc[ 1 ] + ", "+
                     message +"\n";
            }
            break;
         case 2501 .. 40000 :
            text = "Nearby to the "+ dir_direc[ 1 ] + ", "+ message +"\n";
            break;
         case 40001 .. 640000 :
            text = "To the "+ dir_direc[ 1 ] + ", "+ message +"\n";
            break;
         case 640001 .. 10240000 :
            text = "In the distance to the "+ dir_direc[ 1 ] + ", "+
                  message +"\n";
            break;
         default:
            continue;
      }
      if(interactive(thing) && query_verb() == "shout") {
        text = thing->colour_event("shout", "") + text + "%^RESET%^";
      }
      thing->add_message( "$I$5="+ text, ({ }) );
   }
}
void npc_hear_shouts(object newlistener) {
  int i;
  if (member_array(newlistener,_listeners)!=-1) {
     return;
  }
  i = member_array(0,_listeners);
  if (i != -1) {
    _listeners[i]=newlistener;
  } else {
    _listeners=_listeners+({newlistener});
  }
}
int npc_unhear_shouts(object oldlistener) {
  int i;
  if (sizeof(_listeners)==0) {
    return 0;
  }
  i = member_array(oldlistener,_listeners);
  if (i == -1) {
    return 0;
  }
  _listeners = _listeners[0..i] + _listeners[i+1..];
  return 1;
}
void npc_shout_event( object shouter, string start, string message,
      string lang, int *coord, int range ) {
  if (_listeners) {
    _listeners -= ({ 0 });
    _listeners->event_person_shout(shouter, start, message,
                                  lang, coord, range );
  }
}
void add_object_to_channel(string channel_name,
                           object ob) {
   if (!_channels[channel_name]) {
      _channels[channel_name] = ({ });
   }
   _channels[channel_name] += ({ ob });
}
int remove_object_from_channel(string channel_name,
                               object ob) {
   if (_channels[channel_name]) {
      if (member_array(ob, _channels[channel_name]) != -1) {
         _channels[channel_name] -= ({ ob });
         if (!sizeof(_channels[channel_name])) {
           map_delete(_channels, channel_name);
         }
         return 1;
      }
   }
   return 0;
}
void broadcast_to_channel(mixed ob,
                          string channel,
                          mixed message) {
   string str;
   if (!ob) {
      return ;
   }
   if (objectp(ob)) {
      str = ob->query_cap_name();
   }
   if (_channels[channel]) {
      _channels[channel] -= ({ 0 });
      _channels[channel]->event_channel_message(ob, channel, message);
      if (!_channel_history[channel]) {
         _channel_history[channel] = ({ });
      }
      _channel_history[channel] += ({ ({ str, message, time() }) });
      if (sizeof(_channel_history[channel]) > BROADCAST_HISTORY_LENGTH) {
         _channel_history[channel] = _channel_history[channel][1..];
      }
   }
}
mixed *query_channel_history(string channel) {
   return _channel_history[channel];
}
object *query_channel_members(string channel) {
   return _channels[channel];
}
int is_channel(string channel) {
  return !undefinedp(_channels[channel]);
}
mapping query_all_channels() {
   return _channels;
}
int query_next_channel_number(string channel) {
   int next_num;
   next_num = ++_channel_ids[channel];
   save_me();
   return next_num;
}
private void save_me() {
   unguarded( (: save_object(SAVE_FILE) :) );
}
private void load_me() {
   unguarded( (: restore_object(SAVE_FILE, 1) :) );
}
mapping query_dynamic_auto_load() {
   return ([ "channels" : _channels,
       "history" : _channel_history ]);
}
void init_dynamic_arg(mapping arg) {
   _channels = arg["channels"];
   if (!_channels) {
      _channels = ([ ]);
   }
   _channel_history = arg["history"];
   if (!_channel_history) {
      _channel_history = ([ ]);
   }
}

==================================================
FILE: handlers/change_skills.c
==================================================

#include <login_handler.h>
#include <language.h>
#include <tune.h>
#include <skills.h>
#include <combat.h>
#define ORIGINAL "alpha"
#define VERSION "beta"
#define VERSION_2 "gamma"
#define VERSION_3 "delta"
#define VERSION_4 "epsilon"
#define VERSION_5 "zeta"
#define VERSION_6 "eta"
#define OLD_SKILLS ({ \
      "magic.spells.offensive.area", \
      "magic.spells.offensive.target", \
      "magic.spells.defensive.area", \
      "magic.spells.defensive.self", \
      "magic.spells.defensive.target", \
      "magic.spells.misc.area", \
      "magic.spells.misc.self", \
      "magic.spells.misc.target", \
      "magic.spells.special", \
      "magic.items.held.wand", \
      "magic.items.held.rod", \
      "magic.items.held.staff", \
      "magic.items.held.broom", \
      "magic.items.worn.amulet", \
      "magic.items.worn.ring", \
      "magic.items.scroll", \
      "magic.points", \
      "occult.methods.brewing", \
      "occult.methods.dancing", \
      "occult.methods.chanting", \
      "occult.methods.flying", \
      "occult.spells.cursing", \
      "occult.spells.summoning", \
      "occult.spells.enchanting", \
      "occult.spells.charming", \
      "occult.spells.healing", \
   })
#define OTHER_SKILLS ({ \
      "magic", \
      "magic.spells", \
      "magic.spells.offensive", \
      "magic.spells.defensive", \
      "magic.spells.misc", \
      "magic.items", \
      "magic.items.held", \
      "magic.items.worn", \
      "occult", \
      "occult.methods", \
      "occult.spells", \
   })
#define ETA_CHANGES (["other.tracking" : "crafts.hunting.tracking", \
                      "other.swimming" : "other.movement.swimming", \
                      "other.riding" : "other.movement.riding", \
                      "other.riding.horse" : "other.movement.riding.horse", \
                      "other.riding.camel" : "other.movement.riding.camel", \
                      "other.climbing" : "other.movement.climbing", \
                      "other.climbing.tree" : "other.movement.climbing.tree", \
                      "other.climbing.rock" : "other.movement.climbing.rock", \
                      "other.climbing.rope" : "other.movement.climbing.rope", \
                      "other.valueing" : "other.trading.valueing", \
                      "other.valueing.gems" : "other.trading.valueing.gems", \
                      "other.valueing.jewellery" : "other.trading.valueing.jewellery", \
                      "other.valueing.weapons" : "other.trading.valueing.weapons", \
                      "other.valueing.armour" : "other.trading.valueing.armour"])
#define EFFECTS ({"magic.defensive.floating", "magic.shield.impact", \
                  "magic.defensive.skin.troll", "priest.shield" })
int query_level_in( mapping skills, string skill ) {
   string *bits;
   if ( !undefinedp( skills[ skill ] ) )
      return skills[ skill ];
   bits = explode( skill, "." );
   if ( sizeof( bits ) == 1 )
      return 0;
   bits = delete( bits, sizeof( bits ) - 1, 1 );
   skill = implode( bits, "." );
   return query_level_in( skills, skill );
}
void change_skills( object thing ) {
   int i, total;
   mapping skills;
   skills = (mapping)thing->query_skills();
   if ( !m_sizeof( skills ) )
      return;
   for ( i = 0; i < sizeof( OLD_SKILLS ); i++ ) {
      total += query_level_in( skills, OLD_SKILLS[ i ] );
      if ( !undefinedp( skills[ OLD_SKILLS[ i ] ] ) )
         skills = m_delete( skills, OLD_SKILLS[ i ] );
   }
   for ( i = 0; i < sizeof( OTHER_SKILLS ); i++ )
      if ( !undefinedp( skills[ OTHER_SKILLS[ i ] ] ) )
         skills = m_delete( skills, OTHER_SKILLS[ i ] );
   if ( !total )
      return;
   thing->add_property( "magic levels", total );
   thing->set_skills( skills );
   tell_object( thing, "\n\nAn imp that only you can see flashes into "+
         "existence.\n" );
   tell_object( thing, "The imp tells you: The magic and occult skill "+
         "categories are being amalgamated and restructured.\n" );
   tell_object( thing, "The imp tells you: You have a total of "+ total +
         " levels that you can spend on the new magic skills.\n" );
   tell_object( thing, "The imp tells you: Go and find the black "+
         "monolith in the middle of Sator Square which you can use to "+
         "to spend them.\n" );
   tell_object( thing, "The imp flashes back to wherever it came from.\n\n" );
}
int query_minimum_skill_xp(int lvl) {
   int i;
   int xp;
   xp = 0;
   for (i = 0; i < lvl; i++) {
      xp += ( DEFAULT_COST * STD_COST * 100 ) / (( LEVEL_DIV + 1) * 500);
   }
   return xp;
}
void change_language_skills( object thing, int lev ) {
   int i;
   int total_xp;
   mapping skills;
   string *bits;
   string start;
   string *langs;
   string health;
   skills = thing->query_skills();
   if (!sizeof(skills))
      return ;
   bits = keys(skills);
   health = skills["other.health"];
   start = "other.language.";
   total_xp = 0;
   for (i = 0; i < sizeof(bits); i++) {
      if (bits[i][0..strlen(start)-1] == start) {
         total_xp += query_minimum_skill_xp(skills[bits[i]]);
         map_delete(skills, bits[i]);
      }
   }
   langs = thing->query_languages();
   for (i = 0; i < sizeof(langs); i++) {
      thing->add_language(langs[i]);
      thing->remove_language( langs[i] );
   }
   if (skills["other.language"]) {
      total_xp += query_minimum_skill_xp(skills["other.language"]);
      map_delete(skills, "other.language");
   }
   thing->add_language("common");
   if(thing->query_guild_ob() == "/std/guilds/wizard") {
     thing->add_language("wizard spells");
   }
   if(thing->query_guild_ob() == "/std/guilds/thief") {
     thing->add_language("thieves' cant");
   }
   if(skills["other.health"] != health) {
     tell_object(thing, "A fluffy cabbage tells you: Something has gone wrong "
                 "with your language adjustment, please tell Ceres or "
                 "Pinkfish\n");
     return;
   }
   thing->adjust_xp( total_xp );
   tell_object(thing,
"A fluffy cabbage turns up and stares straight into your eyes.\n"
"You feel that the fluffy cabbage has shuffled around some bits of your mind.\n"
               );
   if (total_xp > 0 && lev < 2) {
      tell_object(thing,
"Your languages have been shifted, you appear to have gained "+total_xp+" xp.\n"
                 );
   }
}
mapping recalc_parents(mapping skills, string skill) {
  int i, j, lvl;
  string *tree, *bits, this_skill;
  bits = explode(skill, ".");
  for(i=sizeof(bits)-1; i>=0; i--) {
    this_skill = implode(bits[0..i], ".");
    tree = (string *)SKILL_OB->query_immediate_children(this_skill);
    lvl = 0;
    for(j=0; j<sizeof(tree); j++) {
      lvl += skills[tree[j]];
    }
    if(sizeof(tree))
      skills[this_skill] = lvl / sizeof(tree);
  }
  return skills;
}
void change_skills_epsilon( object thing ) {
  int lvl, rest;
   mapping skills;
   string *bits;
   skills = thing->query_skills();
   if (!sizeof(skills))
      return ;
   bits = keys(skills);
   tell_object(thing, "A squirrel appears and says: I'm just updating your "
               "skill tree, will be just a jiffy.\n");
   lvl = skills["covert.sleight-of-hand"];
   if(lvl > 0) {
     m_delete(skills, "covert.sleight-of-hand");
     if(lvl > 300) {
       rest = lvl - 300;
       lvl = 300;
       if(rest > 600) {
         lvl += 300;
         rest -= 600;
         lvl += rest / 5;
       } else
         lvl += rest / 2;
     }
     skills["covert.manipulation.stealing"] = lvl;
     skills["covert.manipulation.palming"] = lvl;
     skills["covert.manipulation.passing"] = lvl;
     skills["covert.manipulation.sleight-of-hand"] = lvl;
     skills["covert.manipulation"] = lvl;
     recalc_parents(skills, "covert");
   }
   lvl = skills["fighting.combat.melee.sharp"];
   if(lvl > 0) {
     if(lvl > 300) {
       rest = lvl - 300;
       lvl = 300;
       if(rest > 600) {
         lvl += 300;
         rest -= 600;
         lvl += rest / 5;
       } else
         lvl += rest / 2;
     }
     skills["fighting.combat.melee.sharp"] = lvl;
     skills["fighting.combat.melee.pierce"] = lvl;
     skills = recalc_parents(skills, "fighting.combat.melee");
   }
   lvl = skills["fighting.combat.parry.thrown"];
   rest = skills["fighting.combat.parry.fired"];
   if(lvl > 0 || rest > 0) {
     if(rest > lvl)
       lvl = rest + (lvl / 5);
     else
       lvl += (rest / 5);
     m_delete(skills, "fighting.combat.parry.thrown");
     m_delete(skills, "fighting.combat.parry.fired");
     skills["fighting.combat.parry.range"] = lvl;
     lvl = skills["fighting.combat.parry.held"];
     m_delete(skills, "fighting.combat.parry.held");
     skills["fighting.combat.parry.melee"] = lvl;
     skills = recalc_parents(skills, "fighting.combat.parry");
   }
   lvl = skills["fighting.combat.special"];
   if(lvl > 0) {
     if(lvl > 300) {
       rest = lvl - 300;
       lvl = 300;
       if(rest > 600) {
         lvl += 300;
         rest -= 600;
         lvl += rest / 5;
       } else
         lvl += rest / 2;
     }
     skills["fighting.combat.special.weapon"] = lvl;
     skills["fighting.combat.special.unarmed"] = lvl;
     skills["fighting.combat.special.tactics"] = lvl - lvl / 4;
     skills = recalc_parents(skills, "fighting.combat.special");
   }
   lvl = skills["other.tracking.woodland"];
   m_delete(skills, "other.tracking.woodland");
   lvl += skills["other.tracking.desert"];
   m_delete(skills, "other.tracking.desert");
   lvl += skills["other.tracking.mountain"];
   m_delete(skills, "other.tracking.mountain");
   lvl += skills["other.tracking.road"];
   m_delete(skills, "other.tracking.road");
   lvl += skills["other.tracking.field"];
   m_delete(skills, "other.tracking.field");
   if(lvl > 0)
     skills["other.tracking"] = lvl;
   thing->set_skills( skills );
   tell_object(thing, "The squirrel says: Ok, all done now.\n");
}
int new_skill_value(int sk) {
  float f = 1000.0;
  float k = 0.3;
  if(sk == 0)
    return 0;
  return to_int(f * log( 1.0 + sk/(f + sk * k) ) + 0.5);
}
void change_skills_zeta( object thing ) {
   mapping skills;
   string *bits, bit;
   skills = thing->query_skills();
   if (!sizeof(skills))
      return ;
   bits = keys(skills);
   tell_object(thing, "A small blue frog appears and says: I'm just updating "
         "your skill levels, this won't take a second.\n");
   foreach(bit in bits) {
     if(bit[0..13] != "other.language" &&
        SKILL_OB->query_immediate_children(bit) == ({ })) {
       skills[bit] = new_skill_value(skills[bit]);
       skills = recalc_parents(skills, bit);
     }
   }
   thing->set_skills( skills );
   tell_object(thing, "The frog says: Ok, all done now.\n");
}
void fixup_stats(object thing) {
  mapping values;
  mapping changes;
  int stat_total;
  string str;
  changes = ([ ]);
  values = ([
    "con" : thing->query_real_con(),
    "dex" : thing->query_real_dex(),
    "int" : thing->query_real_int(),
    "wis" : thing->query_real_wis(),
    "str" : thing->query_real_str()
            ]);
  stat_total = values["con"] + values["dex"] + values["wis"] + values["str"] +
               values["int"];
  if (stat_total > 65) {
     if (thing->query_real_con() > 8) {
        thing->adjust_con(-1);
        stat_total--;
        values["con"]--;
        changes["con"]++;
     }
     if (stat_total > 65 && thing->query_real_dex() > 8) {
        thing->adjust_dex(-1);
        stat_total--;
        values["dex"]--;
        changes["dex"]++;
     }
     while (stat_total > 65) {
        string highest;
        int value;
        string stat;
        int v;
        value = 0;
        foreach (stat, v in values) {
           if (v > value) {
              value = v;
              highest = stat;
           }
        }
        call_other(thing, "adjust_" + highest, -1);
        values[highest]--;
        changes[highest]++;
        stat_total--;
     }
  }
  str = query_multiple_short(map(keys(changes), (: $1 + " changed by " + $2[$1] :), changes));
  tell_object(thing, "The armadillo says: Stats changed: " + str + "\n");
}
void change_skills_eta(object thing) {
  mapping skills;
  string bit, effect;
  class tactics tactics;
  int eff;
  tactics = new(class tactics,
                attitude : "neutral",
                response : "neutral",
                parry : "both",
                parry_unarmed : 0,
                mercy : "ask",
                focus_zone : 0,
                ideal_distance : 0);
  thing->set_tactics(tactics);
  skills = thing->query_skills();
  if(!sizeof(skills))
    return;
  tell_object(thing, "An armadillo appears out of nowhere and says: "
              "I'm just updating your skills, this won't take a second.\n");
  foreach(bit in keys(ETA_CHANGES)) {
    tell_object(thing, "Mapping " + bit + " to " + ETA_CHANGES[bit] + ".\n");
    skills[ETA_CHANGES[bit]] = skills[bit];
    map_delete(skills, bit);
  }
  tell_object(thing, "Adding new skills.\n");
  foreach(bit in
          "/std/skills"->query_immediate_children("crafts")) {
    if(!skills[bit]) {
      skills[bit] = 0;
    }
  }
  recalc_parents(skills, "crafts.hunting");
  recalc_parents(skills, "crafts");
  recalc_parents(skills, "other.movement.riding");
  recalc_parents(skills, "other.movement.climbing");
  recalc_parents(skills, "other.movement");
  recalc_parents(skills, "other.trading.valueing");
  recalc_parents(skills, "other.trading");
  recalc_parents(skills, "other");
  thing->set_skills( skills );
  foreach(effect in EFFECTS)
    foreach(eff in thing->effects_matching(effect))
      catch(thing->delete_effect(eff));
  tell_object(thing, "Fixing stats.\n");
  fixup_stats(thing);
  tell_object(thing, "Granting rearrange.\n");
   thing->add_known_command("rearrange");
  if ((thing->query_guild_ob() == "/std/guilds/assassin" &&
       thing->query_property("assassin") > 1) ||
      (thing->query_guild_ob() == "/std/guilds/wizard" &&
       "/obj/handlers/guild_things/wizard_orders"->query_order() == "last")) {
    tell_object(thing, "Returning PK flag.\n");
    thing->set_player_killer(1);
  }
  thing->remove_property(PKER);
  thing->remove_property(PKER_MISSPELL);
  thing->add_property("not real newbie", 1);
  tell_object(thing, "Removing old combat commands.\n");
  if(thing->query_known_command("strike"))
    thing->remove_known_command("strike");
  if(thing->query_guild_ob() != "/std/guilds/warrior") {
    thing->remove_known_command("impale");
    thing->remove_known_command("crush");
    thing->remove_known_command("behead");
  }
  thing->remove_known_command("punch");
  thing->remove_known_command("kick");
  tell_object(thing, "The armadillo says: Ok, all done now.\n");
  "/d/liaison/NEWBIE/choose_land"->fixup_player(this_player());
}
void entering( string name, string type ) {
   object thing;
   int lvl;
   if ( type != LOGIN )
      return;
   if ( !( thing = find_player( name ) ) )
      return;
   switch((string)thing->query_property( "skills version" )) {
   case VERSION:
     change_skills( thing );
   case VERSION_2:
     change_language_skills( thing, lvl );
   case VERSION_3:
     change_skills_epsilon( thing );
   case VERSION_4:
     change_skills_zeta(thing);
   case VERSION_5:
     change_skills_eta(thing);
   default:
     thing->add_property("skills version", VERSION_6);
     return;
   }
}
string query_version() { return VERSION_5; }

==================================================
FILE: handlers/chime_handler.c
==================================================

#define CREATOR "Ceres"
#include <am_time.h>
#include <chime.h>
#define FIFTEEN_MINS (AM_SECONDS_PER_MINUTE * 15)
class chime {
  object ob;
  int type;
  string mess;
}
void do_chime(class chime record, int type);
class chime *chime_list;
int last_strike;
void create() {
  int next_chime;
  chime_list = ({ });
  next_chime = 301 - (time() % 300);
  remove_call_out("check_time");
  call_out("check_time", next_chime);
}
int register_for_chimes(object ob, int num, string mess) {
  class chime record;
  foreach(record in chime_list) {
    if(record->ob == ob && record->type == num && record->mess == mess) {
      record->type = num;
      record->mess = mess;
      return 1;
    }
  }
  record = new(class chime);
  record->ob = ob;
  record->type = num;
  record->mess = mess;
  chime_list += ({ record });
  return 1;
}
void check_time() {
  int next_chime, minute;
  class chime record;
  minute = AM_TIME_HANDLER->query_am_minute(time());
  foreach(record in chime_list) {
    catch{
      if(minute % 60 < 5)
        do_chime(record, CHIME_HOUR);
      else if(minute % 30 < 5 && record->type > CHIME_HOUR)
        do_chime(record, CHIME_HALF_HOUR);
      else if(minute % 15 < 5 && record->type == CHIME_QUARTER_HOUR)
        do_chime(record, CHIME_QUARTER_HOUR);
    };
  }
  next_chime = (FIFTEEN_MINS + 1) - (time() % FIFTEEN_MINS);
  remove_call_out("check_time");
  call_out("check_time", next_chime);
}
void do_chime(class chime record, int type) {
  if(!record || !record->ob)
    return;
  (record->ob)->chime(record->mess, type);
}
void reset() {
  int next_chime;
  class chime record;
  next_chime = (FIFTEEN_MINS + 1) - (time() % FIFTEEN_MINS);
  remove_call_out("check_time");
  call_out("check_time", next_chime);
  foreach(record in chime_list) {
    if(!record->ob)
      chime_list -= ({ record });
  }
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "chime_list" : chime_list ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   if (maps["chime_list"])
      chime_list = maps["chime_list"];
}
mixed stats() {
  return ({ ({ "chime count", sizeof(chime_list) }) });
}

==================================================
FILE: handlers/clothing_handler.c
==================================================

#include <clothing.h>
mapping _types;
mapping _equivilants;
mapping _zones;
string *_zone_level;
protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding);
protected void add_clothing_zone(string zone, string *types);
private int fixup_types(string type, string *types);
protected void add_equivilant_type(string name, string equiv);
private void check_clothing_types();
string *query_clothing_zone(string zone);
string *query_clothing_cannot_remove(string type);
string can_wear_or_remove(object thing, object player);
void create() {
   _types = ([ ]);
   _equivilants = ([ ]);
   _zones = ([ ]);
   _zone_level = ({ });
   add_clothing_type("bandaid", ({ }), ({ }));
   add_clothing_type("wig",
       ({ "hood", "helmet", "coif", "hat", "all covering" }),
       ({ "hood", "helmet", "coif", "hat", "all covering" }));
   add_clothing_type("hat",
       ({ "hood", "helmet", "all covering" }),
       ({ "hood", "helmet", "all covering" }));
   add_clothing_type("helmet",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering" }));
   add_clothing_type("hood",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("earring",
       ({ "coif", "all covering" }),
       ({ "hood", "coif", "all covering" }));
   add_clothing_type("moustache",
       ({ "coif", "mask", "all covering" }),
       ({ "coif", "mask", "all covering" }));
   add_clothing_type("glasses",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("nosering",
       ({ "mask", "coif", "all covering" }),
       ({ "mask", "coif", "all covering" }));
   add_clothing_type("mask",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("headband",
       ({ "hat", "hood", "helmet", "coif", "all covering" }),
       ({ "hat", "hood", "helmet", "coif", "all covering" }));
   add_clothing_type("scarf",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type("necklace",
       ({ "coif", "all covering" }),
       ({ "cloak", "coif", "all covering" }));
   add_clothing_type("collar",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type( "shoulder",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
          "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
          "all covering" }));
   add_clothing_type( "bra",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering", "long dress", "mini dress" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
           "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
           "all covering", "long dress", "mini dress" }));
   add_clothing_type("undershirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "waistcoat",
          "shirt", "harness", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "haubergon", "hauberk",
          "byrnie", "jacket", "jumper", "shirt", "long dress", "mini dress",
          "all covering" }));
   add_clothing_type("shirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "waistcoat",
          "harness", "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("waistcoat",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "harness",
          "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("harness",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("jumper",
       ({ "cloak", "cape", "sash", "robe", "breastplate", "haubergon",
          "hauberk", "byrnie", "tabard", "jacket",  "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "jacket",
          "all covering" }));
   add_clothing_type("jacket",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "all covering" }));
   add_clothing_type("tabard",
       ({ "cloak", "cape", "sash", "robe", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("robe",
       ({ "cloak", "cape", "sash", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cloak",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("sash",
       ({ "cloak", "cape", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cape",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("armband",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("glove",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("bracelet",
       ({ "glove", "all covering" }),
       ({ "cloak", "glove", "all covering" }));
   add_clothing_type("ring",
       ({ "glove", "all covering" }),
       ({ "glove", "all covering" }));
   add_clothing_type("box",
       ({ "cloak", "robe", "all covering" }),
       ({ "cloak", "robe", "skirt", "all covering" }));
   add_clothing_type("apron",
       ({ "cloak", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("underwear",
       ({ "harness", "trousers", "greave", "hauberk", "haubergon",
          "byrnie", "belt", "trousers", "all covering" }),
       ({ "cloak", "robe", "skirt", "trousers", "all covering",
          "long dress", "mini dress" }));
   add_clothing_type("garter",
       ({ "greave", "hauberk", "trousers", "all covering"}),
       ({ "cloak", "robe", "greave", "hauberk", "trousers", "skirt",
          "all covering", "long dress", "mini dress"}));
   add_clothing_type("skirt",
       ({ "belt", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("trousers",
       ({ "greave", "hauberk", "belt" }),
       ({ "cloak", "hauberk", "robe", "all covering" }));
   add_clothing_type("belt",
       ({"hauberk", "haubergon", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "haubergon", "byrnie", "all covering" }));
   add_clothing_type("sock",
       ({ "overshoe", "boot", "chausse", "all covering" }),
       ({ "cloak", "overshoe", "boot", "chausse", "all covering",
          "long dress", "trousers" }));
   add_clothing_type("anklet",
       ({ }),
       ({ "cloak", "overshoe", "chausse", "all covering" }));
   add_clothing_type("boot",
       ({ "overshoe" }),
       ({ "overshoe", "all covering" }));
   add_clothing_type("overshoe",
       ({ }),
       ({ "all covering" }));
   add_clothing_type("long dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("mini dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("small shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("large shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("badge",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("scabbard",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("small scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("belt scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("coif",
       ({ "hood", "scarf", "mask", "helmet", "hat", "all covering"}),
       ({ "hood", "all covering"}));
   add_clothing_type("byrnie",
       ({ "cloak", "breastplate", "backplate", "tabard", "small scabbard",
          "belt scabbard", "robe", "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("haubergon",
       ({ "cloak", "breastplate", "backplate", "tabard", "vambrace",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering"}));
   add_clothing_type("hauberk",
       ({ "cloak", "tabard", "vambrace", "greave", "breastplate", "backplate",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("chausse",
       ({ "boot", "overshoe", "all covering"}),
       ({ "boot", "overshoe", "all covering"}));
   add_clothing_type("breastplate",
       ({ "cloak", "small scabbard", "belt scabbard", "robe", "tabard",
          "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("backplate",
       ({ "cloak", "cape", "sash", "robe", "tabard", "all covering"}),
       ({ "cloak", "cape", "sash", "robe", "all covering"}));
   add_clothing_type("vambrace",
       ({ "glove", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("greave",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("all covering", ({}), ({}));
   add_clothing_zone("head",
       ({ "hood", "helmet", "coif", "hat", "wig", "headband", "moustache",
          "glasses", "mask" }));
   add_clothing_zone("neck",
       ({ "cloak", "hood", "coif", "cape", "scarf", "collar" }));
   add_clothing_zone("chest",
       ({ "cloak", "sash", "robe", "breastplate", "haubergon", "hauberk",
          "byrnie", "tabard", "jacket","jumper", "shirt", "undershirt",
          "shoulder", "bra","shield", "large shield", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("back",
       ({ "cloak", "cape", "sash", "robe", "hauberk", "haubergon", "byrnie",
          "jacket", "jumper", "shirt", "undershirt", "backplate",
          "long dress", "mini dress", "waistcoat" }));
   add_clothing_zone("abdomen",
       ({ "large shield", "robe", "breastplate", "byrnie", "hauberk",
          "skirt", "box", "trousers", "underwear", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("arms",
       ({ "cloak", "small shield", "shield", "large shield", "robe",
          "vambrace", "hauberk", "haubergon", "jacket", "armband",
          "jumper", "shirt", "long dress" }));
   add_clothing_zone("hands",
       ({ "glove", "small shield", "shield", "large shield" }));
   add_clothing_zone("legs",
       ({ "cloak", "robe", "greave", "hauberk", "skirt", "trousers",
          "long dress" }));
   add_clothing_zone("feet",
       ({ "overshoe", "boot", "chausse", "sock", "anklet" }));
   add_equivilant_type("shoe", "boot");
   add_equivilant_type("sandal", "boot");
   add_equivilant_type("clog", "boot");
   add_equivilant_type("sabaton", "boot");
   add_equivilant_type("turban", "helmet");
   add_equivilant_type("gorget", "collar");
   add_equivilant_type("stocking", "sock");
   add_equivilant_type("coat", "cloak");
   add_equivilant_type("overall", "long dress");
   call_out((: check_clothing_types() :), 2);
}
object* query_items_blocking(object thing, object player) {
   int i;
   int j;
   int k;
   string *stuff;
   object *blocking;
   mixed junk;
   mixed main_types;
   object *wearing;
   main_types = thing->query_type();
   if (stringp(main_types)) {
      main_types = ({ main_types });
   }
   wearing = player->query_wearing() - ({ thing });
   blocking = ({ });
   for (k=0;k<sizeof(main_types);k++) {
      stuff = query_clothing_cannot_remove(main_types[k]);
      if (!sizeof(wearing) || !stuff) {
         return ({ });
      }
      for (i = 0; i < sizeof(wearing); i++) {
         junk = wearing[i]->query_type();
         if (stringp(junk)) {
            junk = ({ junk });
         }
         for (j = 0; j < sizeof(junk); j++) {
            if (member_array(junk[j], stuff) != -1 &&
                 member_array(wearing[i], blocking) == -1) {
               blocking += ({ wearing[i] });
               break;
            }
         }
      }
   }
   return blocking;
}
string can_wear_or_remove( object thing, object player ) {
   object *blocking;
   blocking = query_items_blocking(thing, player);
   if (sizeof(blocking)) {
     return "when you are wearing "+ query_multiple_short(blocking);
   }
   return 0;
}
protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding) {
   _types[name] = new (class clothing_type, _hiding : hiding,
                                           _not_remove : not_remove);
}
class clothing_type query_clothing_type(string name) {
   return _types[name];
}
string *query_clothing_cannot_remove(string type) {
   class clothing_type bing;
   bing = _types[type];
   if (bing) {
      return bing->_not_remove;
   }
   return 0;
}
string *query_clothing_hiding(string type) {
   class clothing_type bing;
   bing = _types[type];
   if (bing) {
      return bing->_hiding;
   }
   return ({ });
}
int query_clothing_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int min_depth;
   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      min_depth = 100000;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth < min_depth && depth > 0) {
            min_depth = depth;
         }
      }
      return min_depth;
   }
   return 0;
}
int query_clothing_maximum_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int max_depth;
   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      max_depth = 0;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth > max_depth) {
            max_depth = depth;
         }
      }
      return max_depth;
   }
   return 0;
}
mapping query_all_clothing_types() {
   return _types;
}
private void check_clothing_types() {
   string ty;
   class clothing_type bits;
   string *stuff;
   string bing;
   string type;
   int rank;
tell_creator("presto", "called check_clothing_types\n");
   foreach (ty, bits in _types) {
      foreach (bing in bits->_not_remove) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the not remove "
                  " for " + ty + ".\n");
         }
      }
      foreach (bing in bits->_hiding) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the hiding "
                  " for " + ty + ".\n");
         }
      }
   }
   rank = 1;
   foreach (bing in _zone_level) {
      stuff = query_clothing_zone(bing);
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth &&
             (sizeof(bits->_not_remove) == 0  ||
             bits->_not_remove[0] == "all covering")) {
            bits->_depth = rank;
            rank = fixup_types(type, stuff);
         }
      }
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth) {
tell_creator("presto", "setting depth of %O to %d\n", type, rank + 1);
            bits->_depth = rank++;
         }
      }
   }
}
private int fixup_types(string type, string *types) {
   string bing;
   class clothing_type base;
   class clothing_type bits;
   int depth;
   base = _types[type];
   depth = base->_depth + 1;
   foreach (bing in types) {
      bits = _types[bing];
      if (!bits->_depth &&
          member_array(type, bits->_not_remove) != -1) {
         bits->_depth = depth;
         depth = fixup_types(bing, types);
      }
   }
   return depth;
}
protected void add_clothing_zone(string zone, string *types) {
   string ty;
   foreach (ty in types) {
      if (!query_clothing_type(ty)) {
         write("Incorrect clothing type " + ty + " in zone " + zone + ".\n");
      }
   }
   _zones[zone] = types;
   _zone_level += ({ zone });
}
protected void add_zone_coverage(string type, string *zones) {
  string zone;
  if(!query_clothing_type(type))
    write("Incorrect clothing type " + type + "\n");
  foreach(zone in zones)
    if(member_array(type, zones) != -1)
      _zones[zone] += ({ type });
}
mapping query_all_clothing_zones() {
   return _zones;
}
string *query_clothing_zone(string zone) {
   return _zones[zone];
}
string query_zone_name(string type) {
   string zone;
   string *stuff;
   foreach (zone, stuff in _zones) {
      if (member_array(type, stuff) != -1) {
         return zone;
      }
   }
   return 0;
}
string *query_zone_names(string type) {
   string zone;
   string *stuff;
   string *zones;
   if(_equivilants[type])
     type = _equivilants[type];
   zones = ({ });
   foreach (zone, stuff in _zones) {
     if (member_array(type, stuff) != -1 && zone) {
       zones += ({ zone });
     }
   }
   return zones;
}
int query_zone_level(string zone) {
   int i;
   i = member_array(zone, _zone_level);
   return i * 100;
}
protected void add_equivilant_type(string name, string equiv) {
   if (!query_clothing_type(equiv)) {
      write("Incorrect clothing type " + equiv + " in equivilant listing.\n");
   }
   _equivilants[name] = equiv;
}
mapping query_all_equivilant_types() {
   return _equivilants;
}
string query_equivilant_type(string type) {
   return _equivilants[type];
}
int query_valid_type(string type) {
   if (query_clothing_type(type) ||
       query_equivilant_type(type)) {
      return 1;
   }
   return 0;
}

==================================================
FILE: handlers/club_handler.c
==================================================

inherit "/obj/handlers/inherit/club_inherit";
void create() {
   ::create();
   setup_call_check_clubs(0, 1);
}
void dest_me() {
   save_cache();
   destruct(this_object());
}

==================================================
FILE: handlers/clusters.c
==================================================

#if !efun_defined(db_exec)
#define OLD
#else
#include <db.h>
#endif
#include <map.h>
#define SIZE 7
#define LEVEL(x) load(x)->level
#include <config.h>
nosave int maxnum = 0;
nosave int lasttime = 0;
nosave int count = 0;
nosave mapping used = ([ ]);
nosave mixed *todo= ({ });
nosave mapping cache = ([ ]);
nosave int setup_done = 1;
nosave int db;
nosave int setup_start_time;
class cluster{
  mixed *members;
  int level;
  int cluster_number;
  int this_cluster;
  mixed *contacts;
}
#ifndef OLD
private int get_cluster(mixed);
private mixed cdb_fetch(int fd, int row){
  mixed stuff = db_fetch(fd, row);
  if(arrayp(stuff)){
    mixed tmp, ret = ({});
    foreach(tmp in stuff){
      if(stringp(tmp)){
        int i;
        sscanf(tmp, "%d", i);
        if(i || tmp == "0")
          tmp = i;
      }
      ret += ({tmp});
    }
    stuff = ret;
  }
  return stuff;
}
#endif
private class cluster load(int x){
  mixed rows;
  class cluster tmp = new(class cluster);
  if(cache[x])
    return cache[x];
#ifdef OLD
  cache[x] = restore_variable(unguarded((: read_file(sprintf("/save/clusters/%d",
                                                           (int)$(x))) :)));
#else
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", x);
  if(stringp(rows) || !rows)
    return 0;
  tmp->members = ({});
  rows++;
  while(--rows)
    tmp->members += cdb_fetch(db, rows);
  rows = db_exec(db, "select level, in_cluster from cluster_list where cluster_number = %d", x);
  if(stringp(rows)){
    db_close(db);
    db = db_connect("localhost","discworld",CONFIG_DB_USER);
    return 0;
  }
  rows = cdb_fetch(db, 1);
  tmp->level = rows[0];
  tmp->cluster_number = rows[1];
  tmp->this_cluster = x;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", x);
  if(stringp(rows))
    return 0;
  tmp->contacts = ({});
  rows++;
  while(--rows)
    tmp->contacts += cdb_fetch(db, rows);
  cache[x] = tmp;
#endif
  return cache[x];
}
private void save(class cluster x){
#ifdef OLD
  unguarded((:write_file(sprintf("/save/clusters/%d", $(x->this_cluster)),
                           save_variable($(x)), 1):));
#else
  db_exec(db, "insert into cluster_list values (%d, %d, %d)", x->this_cluster,
          x->level, x->cluster_number);
  map(x->members, (:db_exec(db, "insert into cluster_members values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
  map(x->contacts, (:db_exec(db, "insert into cluster_contacts values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
#endif
  cache[x->this_cluster] = x;
}
private void make_clusters(mixed);
nosave function fix_contacts;
nosave function fix_room_contacts;
private void create(){
#ifndef OLD
  db = db_connect("localhost","discworld",CONFIG_DB_USER);
  map(({"cluster_members", "cluster_list", "cluster_contacts"}),
      (:db_exec(db, "delete from %s;", $1):));
#endif
  fix_room_contacts = function(int i){
    class cluster fixing = load(i);
    if((sizeof(fixing->contacts)) && intp(fixing->contacts[0])){
      error(sprintf("%d in two or more clusters", i));
      return;
    }
    fixing->contacts = uniq_array(map(fixing->contacts,
#ifdef OLD
                                      (:MAP->query_cluster($1):)
#else
                                      (:cache[$1]:)
#endif
                                      ));
  save(fixing);
  };
  fix_contacts = function (int i){
    class cluster fixing = load(i);
    reset_eval_cost();
    if(fixing->level){
      if((sizeof(fixing->contacts)) && (fixing->level ==
                                        LEVEL(fixing->contacts[0]))){
        error(sprintf("%d in two or more clusters", i));
        return;
      }
      fixing->contacts = uniq_array(map(fixing->contacts,
                                        (:load($1)->cluster_number:)));
      save(fixing);
      if(fixing->level > 1){
        map(fixing->members, (:efun::call_out((fix_contacts), 0, $1):));
        return;
      }
      map(fixing->members, fix_room_contacts);
    }
  };
#ifdef OLD
  unguarded(function(){
    string file, *files=get_dir("/save/clusters/");
    foreach(file in files)
      rm(sprintf("/save/clusters/%s", file));
  });
#endif
}
private void make_clusters(mixed start){
  int count = 0, depth = -1, oldmax = maxnum, level = (stringp(start)? 0 :
                                                       load(start)->level + 1);
  class cluster current;
  mixed *list;
  function qdd, real;
  if(stringp(start)){
    qdd = function(string room){
      function f = function(string there, string room){
        mixed tmp;
        return member_array(room,
                            (tmp = MAP->qdd(there), tmp? tmp : ({}))) + 1;
      };
      string *qdd = MAP->qdd(room);
      return filter(allocate(sizeof(qdd) / 2, (:$(qdd)[$1 * 2 + 1]:)), f, room);
    };
    real = (:$1:);
  } else {
    qdd = (:load($1)->contacts:);
    if(stringp(load(start)->contacts[0]))
      real = (:cache[$1]:);
    else
      real = (:load($1)->cluster_number:);
  }
  current = new (class cluster, members:({start}),
                 level:level,
                 this_cluster:++maxnum,
                 contacts:({}));
  list = ({start});
  if(used[start])
    error(sprintf("%O already in a cluster", start));
  used[start] = 1;
  while(++depth < sizeof(list) || sizeof(todo)){
    mixed *exits;
    mixed exit;
    if(depth < sizeof(list))
      exits = (*qdd)(list[depth]);
    else {
      count = SIZE + 1;
      exits = ({});
    }
    foreach(exit in exits) {
      if(!used[exit = (*real)(exit)]) {
        current->members += ({exit});
        list += ({exit});
        used[exit] = 1;
        if(++count > SIZE)
          break;
      }
    }
    if(count > SIZE || !(((1 + depth) < sizeof(list)) || sizeof(todo))){
      mixed tmp, *contacts = ({});
      count = 0;
      foreach(tmp in current->members){
        reset_eval_cost();
        if(stringp(tmp)){
#ifdef OLD
          MAP->set_cluster(tmp, current->this_cluster)
#endif
          ;
          cache[tmp] = current->this_cluster;
        }
        else{
          class cluster clust;
          clust = load(tmp);
          clust->cluster_number = current->this_cluster;
          cache[tmp] = clust;
        }
        exits = (*qdd)(tmp);
        if(exits){
          function add_non_member, convert_and_add;
          add_non_member = (: (member_array($2, $(current->members)) == -1)?
                            ($1 | ({ $2 })) :
                            $1
                           :);
          convert_and_add = (:evaluate($(add_non_member), $1,
                                      evaluate($(real), $2)):);
          contacts = implode(exits, convert_and_add, contacts);
        }
      }
      current->contacts = contacts;
      if(sizeof(contacts) || current->level > 1)
        cache[current->this_cluster] = current;
      else
        maxnum--;
      todo = filter(todo + list + contacts, (:!used[$1]:));
      depth = -1;
      if(sizeof(todo)){
        list = ({todo[0]});
        todo = todo[1..];
        if(used[list[0]])
          error("corrupt todo list");
        used[list[0]] = 1;
        current = new (class cluster, members:({list[0]}),
                       level:level,
                       this_cluster:++maxnum,
                       contacts:({}));
      } else
        list = ({ });
    }
  }
  if((maxnum - oldmax) > SIZE)
    make_clusters(current->this_cluster - 1);
  else {
    int i;
    for(i = oldmax + 1; i <= maxnum; i++)
      if(LEVEL(i))
        efun::call_out(fix_contacts, 0, i);
      else
        efun::call_out(fix_room_contacts, 0, i);
  }
  used = ([]);
  efun::call_out((:cache = ([]), setup_done = 1:), 2);
}
#ifndef OLD
private int get_cluster(mixed thing){
  if(stringp(thing)){
    mixed exret = db_exec(db, "select cluster_number from cluster_members where member = '%s'",
                          db_escape(thing));
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  } else if(intp(thing)){
    mixed exret = db_exec(db, "select in_cluster from cluster_list where cluster_number = %d",
                          thing);
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  }
  return 0;
}
#endif
private int query_top_cluster(string room){
  int ret;
#ifdef OLD
  ret = MAP->query_cluster(room);
  if(ret && unguarded((:file_size(sprintf("/save/clusters/%d", $(ret))):)) > 0)
    while(load(ret)->cluster_number){
      int last = ret;
      ret = load(ret)->cluster_number;
      if(last == ret)
        return ret;
    }
#else
  ret = get_cluster(room);
  if(ret){
    int last = ret;
    ret = get_cluster(ret);
    while(ret){
      last = ret;
      ret = get_cluster(ret);
    }
    return last;
  }
#endif
  else{
    setup_start_time = time();
    setup_done = 0;
    make_clusters(room);
  }
  return ret;
}
#ifndef OLD
private mixed *get_members(int clust){
  mixed rows;
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
private mixed *get_contacts(int clust){
  mixed rows;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
#endif
private mixed *find_places(int start, int end, int *places){
  int found = 0, depth = 0;
  int *key;
  int *exits, bing, *result, ob, exit;
  mapping search = ([]);
  if(start == end){
#ifdef OLD
    return load(start)->members;
#else
    return get_members(start);
#endif
  }
  key = ({ start });
  search[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
#ifdef OLD
      exits = load(ob)->contacts;
#else
      exits = get_contacts(ob);
#endif
      foreach(exit in exits) {
        if ((!search[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && ++depth >= sizeof(key))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
#ifdef OLD
    result += load(bing)->members;
#else
    result += get_members(bing);
#endif
    bing = search[bing];
  }
#ifdef OLD
  result += load(bing)->members;
#else
  result += get_members(bing);
#endif
  return result;
}
private mixed find_route(mixed start, mixed end, string *places){
  int found = 0, i, depth = 0;
  string *key;
  string *exits, bing, *result, ob;
  mapping route = ([]), search = ([]);
  int t = real_time();
  if(start == end)
    return ({});
  key = ({ start });
  route[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
      exits = MAP->qdd(ob);
      for (i = 1; i < sizeof(exits); i += 2) {
        mixed exit = exits[i];
        if ((!route[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          route[exit] = exits[i - 1];
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && (++depth >= sizeof(key) || (real_time() - t) > 4))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
    result = ({route[bing]}) + result;
    bing = search[bing];
  }
  return result;
}
nosave int debugging = 0;
private void debug(int *clusters){
  int cluster;
  if(debugging)
    error("read the error trace");
  debugging = 1;
  reset_eval_cost();
  while(intp(load(clusters[0])->members[0]))
    clusters = implode(clusters, (:$1 + load($2)->members:), ({}));
  foreach(cluster in clusters){
    string *rooms = load(cluster)->members;
    string room, room2;
    reset_eval_cost();
    foreach(room in rooms)
      foreach(room2 in rooms)
        if(!this_object()->get_route(room, room2))
          error("cluster error");
  }
}
string* get_route(string start, string end, function callback){
  mixed *places = ({}), *oldplaces;
  int sip = 0;
  int from, to;
  int level;
  if(lasttime != time()){
    lasttime = time();
    count = 0;
  } else {
    if(count++ > 10) {
      return ({});
    }
  }
  if(!setup_done){
    if((time()-setup_start_time) < 5)  {
      return 0;
    }
#ifndef OLD
#endif
    catch(unguarded(function(){
      cp("/log/runtime", "/w/wodan/clusterruntime");
      cp("/log/catch", "/w/wodan/clustercatch");
    }));
    tell_creator("wodan", "would have dested");
    setup_done = 1;
    return 0;
  }
  if(!stringp(start)){
    start = base_name(start);
    if(!stringp(start))
      error("illegal start point");
  }
  if(!stringp(end)){
    end = base_name(end);
    if(!stringp(end))
      error("illegal end point");
  }
  if(catch(from = query_top_cluster(start))){
#ifndef OLD
    db_close(db);
    db = db_connect("localhost","discworld", CONFIG_DB_USER);
#endif
    return 0;
  }
  if(!setup_done) {
    return 0;
  }
  if(from) {
    level = LEVEL(from);
  }
  to = query_top_cluster(end);
  if(!to || (level != LEVEL(to))) {
    return ({});
  }
  while (level) {
#ifdef OLD
    from = MAP->query_cluster(start);
    to = MAP->query_cluster(end);
#else
    from = get_cluster(start);
    to = get_cluster(end);
#endif
    while((from != to) && (LEVEL(from) < level)){
      from = load(from)->cluster_number;
      to = load(to)->cluster_number;
    }
    level = LEVEL(from);
    if(!level){
      if(!sip) {
        break;
      }
      error("wrong level");
    }
    oldplaces = places;
    places = find_places(from, to, places);
    if(!places){
      if(!sip) {
        return ({});
      }
      debug(oldplaces);
      error("this can't happen, honest!");
    }
    sip = 1;
    level--;
  }
#ifdef OLD
  from = MAP->query_cluster(start);
  to = MAP->query_cluster(end);
#else
  from = get_cluster(start);
  to = get_cluster(end);
#endif
  oldplaces = places;
  places = find_places(from, to, places);
  if(!places){
    if(!sip) {
      return ({});
    }
    debug(oldplaces);
    error("this can't happen, honest!!");
  }
  cache = ([]);
  return find_route(start, end, places);
}
#ifndef OLD
void dest_me(){
  db_close(db);
  destruct(this_object());
}
#endif

==================================================
FILE: handlers/cmr_handler.c
==================================================

#include <cmr.h>
#include <colour.h>
#include <library.h>
#define SAVE_FILE "/save/cmr_handler"
inherit "/std/object";
string *colour_names;
mapping colour_details;
string *material_names;
mapping material_details;
void load_cmr_handler();
void save_cmr_handler();
void create();
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh );
int *query_colour_details( string word );
int delete_colour( string word );
string *query_colour_names();
string identify_colour( string word, object player );
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh );
int *query_material_details( string word );
int delete_material( string word );
string *query_material_names();
string identify_material( string word, object player, int article );
string query_material_adjective( string word );
void load_cmr_handler() {
  if ( file_size( SAVE_FILE +".o" ) > 0 )
    unguarded((: restore_object, SAVE_FILE :));
}
void save_cmr_handler() {
  unguarded((: save_object, SAVE_FILE :));
}
void create() {
  colour_names = ({ });
  colour_details = ([ ]);
  material_names = ({ });
  material_details = ([ ]);
  ::create();
  load_cmr_handler();
}
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp != -1 ) return "colour already exists";
  colour_names += ({ word });
  colour_details += ([ word : ({ fine, crude, qp_thresh, sp_thresh }) ]);
  save_cmr_handler();
  return "the colour "+ word +", a shade of "+ ( ( fine == crude )?
         "pure ":MODIFIERS[fine] ) + COLOURS[crude] +", with thresholds of "+
         qp_thresh +" xp and "+ sp_thresh +" sp";
}
int *query_colour_details( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return ({ -1 });
  return colour_details[word];
}
int delete_colour( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return 0;
  colour_names -= ({ word });
  colour_details = m_delete( colour_details, word );
  save_cmr_handler();
  return 1;
}
string *query_colour_names() { return colour_names + ({ }); }
string identify_colour( string word, object player ) {
  int temp, *args;
  temp = member_array( word, colour_names );
  if ( temp == -1 )
    return "unknown colour";
  args = allocate( 4 );
  args = colour_details[word];
  if ( !player )
    return word;
  switch ( ( ( LIBRARY->query_quest_points(player->query_name()) ) > args[2] )+
           ( ( player->query_max_gp() ) > args[3] ) ) {
  case 0:
    return COLOURS[args[1]];
  case 1:
    return ( ( ( args[0] == args[1] )?"pure ":MODIFIERS[args[0]] ) +
             COLOURS[args[1]] );
  default:
    return word;
  }
}
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh ) {
  int temp;
  string text;
  temp = member_array( word, material_names );
  if ( temp != -1 ) return "material already exists";
  material_names += ({ word });
  material_details += ([ word : ({ colour, type, skill_reqd,
                         skill_thresh }) ]);
  save_cmr_handler();
  if ( !skill_reqd )
    text = " that is always recognised";
  else
    if ( skill_reqd == LEARNT )
      text = " that is recognised through knowledge";
    else
      text = " that has a threshold of "+ skill_thresh +" in "+
             SKILLS[skill_reqd];
  return word +", a"+ ( ( colour == COL_ORANGE )?"n ":" " ) +
         COLOURS[colour] +" "+ MATERIALS[type] + text;
}
int *query_material_details( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return ({ -1 });
  return material_details[word];
}
int delete_material( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return 0;
  material_names -= ({ word });
  material_details = m_delete( material_details, word );
  save_cmr_handler();
  return 1;
}
string *query_material_names() { return material_names + ({ }); }
string identify_material( string word, object player, int article ) {
  int temp, *args;
  string prefix;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "unknown material";
  args = allocate( 4 );
  args = material_details[word];
  prefix = ( ( article )?"a"+ ( ( args[0] == COL_ORANGE )?"n ":" " ):"" );
   if ( !args[ 2 ] || !player )
      return word;
  if ( args[2] == LEARNT )
    if ( member_array( word,
        (string *)CMR_LIBRARY->query_known_materials( player->query_name() ) )
        == -1 )
      return prefix + COLOURS[ args[ 0 ] ] +" "+
          MATERIALS[ args[ 1 ] ];
    else
      return word;
  if ( ( player->query_skill_bonus( SKILLS[args[2]] ) ) > args[3] )
    return word;
  else return prefix + COLOURS[args[0]] +" "+ MATERIALS[args[1]];
}
string query_material_adjective( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "an unknown material";
  args = allocate( 4 );
  args = material_details[word];
  return COLOURS[args[0]] +" "+ MATERIAL_ADJECTIVES[args[1]];
}
string query_material_ansi_colour( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "";
  args = allocate( 4 );
  args = material_details[word];
  return ANSI_COLOURS[args[0]];
}

==================================================
FILE: handlers/cmr_library.c
==================================================

#define RESTORE_PATH "/save/cmr_library/"
inherit "/std/object";
string player_name, *materials;
void init_data( string pname ) {
  player_name = pname;
  materials = ({ });
}
int get_data_file( string pname ) {
  if ( player_name != pname ) {
    if ( file_size( RESTORE_PATH + pname +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + pname :));
    else {
      init_data( pname );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
string *query_known_materials( string pname ) {
  get_data_file( pname );
  if ( !materials ) {
    return ({ });
  }
  return materials + ({ });
}
int query_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( !materials ) return 0;
  return ( member_array( material, materials ) != -1 );
}
int add_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( member_array( material, materials ) != -1 ) {
    return 0;
  }
  materials += ({ material });
  save_data_file( player_name );
  return 1;
}

==================================================
FILE: handlers/co_ordinate_handler.c
==================================================

#include <dirs.h>
class room_data {
   string other;
   string direction;
   int* coords;
   int last_update;
}
private mapping _rooms = ([ ]);
private nosave mapping _dirs;
int setup_room(string path);
void create() {
   mixed* bits;
   int i;
   bits = STD_ORDERS;
   _dirs = ([ ]);
   for (i = 0; i < sizeof(bits); i += 2) {
      _dirs[bits[i]] = bits[i + 1];
   }
}
private void setup_specific_room(string path, string new_path, string dir) {
   int* delta;
   int* co_ord;
   int k;
   class room_data data;
   delta = new_path->query_room_size_array() + path->query_room_size_array();
   co_ord = copy( _rooms[new_path]->coords);
   for ( k = 0; k < 3; k++ ) {
     co_ord[ k ] += _dirs[dir][ k ] *
                    ( delta[ k ] + delta[ k + 3 ] );
   }
   data = new(class room_data);
   data->other = new_path;
   data->coords = co_ord;
   data->direction = dir;
   data->last_update = _rooms[new_path]->last_update;
   _rooms[path] = data;
}
int* query_room_co_ords(string path) {
   class room_data data;
   data = _rooms[path];
   if (data) {
      if (!_rooms[data->other]) {
         map_delete(_rooms, path);
      } else {
         if (data->last_update != _rooms[data->other]->last_update) {
            setup_specific_room(path, data->other, data->direction);
         }
         return data->coords;
      }
   }
   if (setup_room(path)) {
      data = _rooms[path];
      return data->coords;
   }
   return 0;
}
int setup_room(string path) {
   string* bits;
   int i;
   string new_path;
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }
   bits = path->query_dest_dir();
   for (i = 0; i < sizeof(bits); i += 2) {
      if (find_object(bits[i+1])) {
         new_path = file_name(find_object(bits[i+1]));
      } else {
         new_path = bits[i+1];
      }
      if (_rooms[new_path]) {
         setup_specific_room(path, new_path, bits[i]);
         return 1;
      }
   }
   return 0;
}
void setup_fixed_room(string path, int* coords) {
   class room_data data;
tell_creator("pinkfish", "%O %O %O\n", path, path->query_property("location"),
               path->query_terrain_handler());
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }
   if (_rooms[path]) {
      data = _rooms[path];
      if (data->coords[0] == coords[0] &&
          data->coords[1] == coords[1] &&
          data->coords[2] == coords[2]) {
         return ;
      }
   } else {
      data = new(class room_data);
   }
   data->coords = coords;
   data->last_update = time();
   _rooms[path] = data;
}
mapping query_rooms() {
   return _rooms;
}

==================================================
FILE: handlers/colour.c
==================================================

#include <colour.h>
string calc_colour( int red, int green, int blue, int whitener ) {
   int main_hue;
   string result;
   result = "";
   if ( whitener > -1 ) {
      switch ( red + green + blue ) {
         case 0 .. 4 :
            return "colourless";
         case 5 .. 29 :
            result += "faint ";
            break;
         case 30 .. 154 :
            break;
         default :
            result += "intense ";
      }
   }
   return result;
}

==================================================
FILE: handlers/complaints_handler.c
==================================================

#include <board.h>
#define SAVEFILE "/save/complaints/complaints_handler.o"
#define BOARD "complaints"
int _complaintNumber;
void save_file() {
    unguarded( (: save_object( SAVEFILE ) :) );
}
void load_file() {
    unguarded( (: restore_object( SAVEFILE ) :) );
}
void create() {
    seteuid( getuid() );
    _complaintNumber = 1;
    load_file();
}
int do_submit_complaint( string str ) {
    int ret = 0;
    if ( str ) {
        ret = BOARD_HAND->
            add_message( BOARD, "Anonymous",
                         "Anonymous complaint #" + _complaintNumber,
                         sprintf( "%-=78s\n", str ) );
        _complaintNumber++;
        save_file();
    }
    return ret;
}
int board_access_check( int type, string, object previous, string name ) {
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
    case B_ACCESS_DELETE :
        return 0;
    }
}

==================================================
FILE: handlers/converter.c
==================================================

mixed *mail;
nosave string *names;
nosave int no_more;
int query_busy(string name);
void create() {
  seteuid("mailer");
  names = ({ });
  no_more = 0;
}
int ok_to_shut() {
  no_more = 1;
  return (sizeof(names) == 0);
}
void convert_it(string pname) {
  int i, bing;
  if (no_more) {
    write("Can't start converting mail, try again after the reboot.\n");
    return;
  }
  if (query_busy(pname)) {
    write("Argh ! Already busy converting mail for "+pname+".\n");
    return;
  }
  mail = ({ });
  if (file_size("/save/post/"+pname+".o") == -1)
    return;
  unguarded((: restore_object, "/save/post/"+pname :));
  bing = sizeof(mail);
  if (!bing) {
    unguarded((: rm, "/save/post/"+pname+".o" :));
    return;
  }
  write("Converting mail for "+pname+".\n");
  names += ({ pname });
  for (i = 0; i < bing; i++) {
    reset_eval_cost();
    call_out("do_it", (i+1)*3, (mail[i] + ({ pname })));
  }
  call_out("reset_busy", (i+1)*3, pname);
  unguarded((: rm, "/save/post/"+pname+".o" :));
}
void do_it(mixed *arg) {
  object handler = clone_object("/obj/handlers/folder_handler");
  handler->add_it((["to" : ({ arg[6] }),
    "cc" : ({ }), "from" : arg[1], "subject" : arg[3], "body" :
    "From "+arg[1]+" "+ctime(arg[0])+
    "\nDate: "+ctime(arg[0])+
    "\nFrom: "+arg[1]+
    "\nTo: "+arg[2]+
    "\nSubject: "+arg[3]+
    "\nCc: "+(arg[4]?arg[4]:"")+"\n\n"+
    arg[5] ]), 1);
}
int query_busy(string name) {
  return (member_array(name, names) != -1);
}
void reset_busy(string name) {
  names -= ({ name });
  if (no_more && !sizeof(names)) {
    "/obj/shut"->shut(2);
  }
}

==================================================
FILE: handlers/corpse_handler.c
==================================================

#include <player_handler.h>
#define CORPSE_SAVE_DIR "/save/corpses/"
#define CORPSE_RAM_DIR "/save/ramdisk/corpses/"
#define CORPSE_SAVE_FILE "/save/corpses/main"
#define CORPSE_OBJECT "/obj/corpse"
private mapping _corpses;
private nosave mapping _to_save;
private nosave int _save_things_id;
private int _corpse_id;
class corpse_data {
   int id;
}
void create() {
   seteuid(getuid());
   _corpses = ([ ]);
   _corpse_id = 1;
   _to_save = ([ ]);
   unguarded( (: restore_object(CORPSE_SAVE_FILE,  1) :));
   call_out("check_corpses", 10);
}
private void save_me() {
   unguarded( (: save_object(CORPSE_SAVE_FILE,  3) :));
}
private class corpse_data find_corpse_data(string name, int id) {
   class corpse_data corpse;
   if (!_corpses[name]) {
      return 0;
   }
   foreach (corpse in _corpses[name]) {
      if (corpse->id == id) {
         return corpse;
      }
   }
   return 0;
}
private class corpse_data find_corpse_ob_data(object ob) {
   string name;
   int id;
   name = ob->query_ownership();
   id = ob->query_corpse_id();
   return find_corpse_data(name, id);
}
object* find_player_corpses(string player) {
   object* corpses;
   corpses = filter( children( "/obj/corpse" ),
             (: $1 && $1->query_property( "player" ) &&
                $1->query_ownership() == $2 :), player );
   return corpses;
}
private void really_save_corpses() {
  object ob, player;
  class corpse_data corpse;
  string data;
  string fname;
  foreach (ob, corpse in _to_save) {
    if(!ob)
      continue;
    data = ob->query_save_data();
    if (stringp(data)) {
#ifdef USE_RAMDISK
      fname = CORPSE_RAM_DIR + corpse->id;
#else
      fname = CORPSE_SAVE_DIR + corpse->id;
#endif
      unguarded((: write_file($(fname), $(data), 1) :));
    } else {
      tell_creator("pinkfish", "Bad corpse save %O %O\n", ob, data);
    }
    player = find_player(ob->query_owner());
    if(player)
      player->save_me();
  }
  _to_save = ([ ]);
}
void save_corpse(object ob) {
   class corpse_data corpse;
   if (!ob->query_property("player") || !ob->query_ownership()) {
      return ;
   }
   corpse = find_corpse_ob_data(ob);
   if (!corpse) {
      tell_creator("pinkfish", "Cannot find the corpse to save %O [%O].\n",
                   ob, ob->query_ownership());
      return ;
   }
   _to_save[ob] = corpse;
   if (_save_things_id) {
      remove_call_out(_save_things_id);
   }
   _save_things_id = call_out((: really_save_corpses :), 2);
}
object create_corpse(string name, int id) {
   class corpse_data corpse;
   string data, fname;
   object ob;
   corpse = find_corpse_data(name, id);
#ifdef USE_RAMDISK
   if(unguarded( (: file_size(CORPSE_RAM_DIR + $(corpse->id)) :)) > 0)
     fname = CORPSE_RAM_DIR + corpse->id;
#endif
   if(!fname)
     fname = CORPSE_SAVE_DIR + corpse->id;
   data = unguarded( (: read_file($(fname)) :));
   if (data) {
     ob = clone_object(CORPSE_OBJECT);
     ob->setup_corpse_from_save(data, name, id);
     return ob;
   }
   return 0;
}
void check_corpses() {
   class corpse_data* corpses;
   string name;
   object* obs;
   int i;
   int j;
   foreach (name, corpses in _corpses) {
      obs = find_player_corpses(name);
      for (i = 0; i < sizeof(corpses); i++) {
         for (j = 0; j < sizeof(obs); j++) {
            if (obs[j]->query_corpse_id() == corpses[i]->id) {
               corpses = corpses[0..i -1] + corpses[i+1..];
               i--;
            }
         }
      }
      if (sizeof(corpses)) {
         for (i = 0; i < sizeof(corpses); i++) {
            create_corpse(name, corpses[i]->id);
         }
      }
   }
}
int query_next_corpse_id() {
   int id;
   id = _corpse_id++;
   save_me();
   return id;
}
void register_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;
   tell_creator("Registering %O (%O)\n", ob, ob->query_ownership());
   name = ob->query_ownership();
   if(PLAYER_HANDLER->test_creator(name)) {
     tell_creator("pinkfish", "Not registering creator corpse %O (%O)\n",
                  ob, ob->query_ownership());
     return;
   }
   id = ob->query_corpse_id();
   corpse = find_corpse_ob_data(ob);
   if (corpse) {
      save_corpse(ob);
      return ;
   }
   corpse = new(class corpse_data);
   corpse->id = id;
   if (!_corpses[name]) {
      _corpses[name] = ({ corpse });
   } else {
      _corpses[name] += ({ corpse });
   }
   save_me();
   save_corpse(ob);
}
void deregister_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;
   int i;
   if (!ob->query_property("player")) {
      return ;
   }
   name = ob->query_ownership();
   id = ob->query_corpse_id();
   for (i = 0; i < sizeof(_corpses[name]); i++) {
      corpse = _corpses[name][i];
      if (corpse->id == id) {
         _corpses[name] = _corpses[name][0..i-1] + _corpses[name][i+1..];
         if (!sizeof(_corpses[name])) {
            map_delete(_corpses, name);
         }
         save_me();
         unguarded( (: rm(CORPSE_SAVE_DIR + $(id)) :));
#ifdef USE_RAMDISK
         unguarded( (: rm(CORPSE_RAM_DIR + $(id)) :));
#endif
         return ;
      }
   }
}
mixed *stats() {
  return ({ ({ "corpses", keys(_corpses) }) });
}

==================================================
FILE: handlers/cpi_handler.c
==================================================

#define RESTORE_PATH "/save/cpi_indices/"
#define STOCK_EXCHANGE find_object( "/d/am/am/gomerchants" )
inherit "/std/object";
string material_name;
mapping prices;
void setup() {
  set_name( "board" );
  set_short( "price board" );
  set_long( "This is a large board with many small, wooden flaps attached "+
            "to it.  Painted onto the flaps are numbers and letters, and "+
            "the display is occasionally changed by means of a small imp "+
            "that seems to live inside somewhere.  The board lists the "+
            "purchasing prices of almost everything from gold and silk "+
            "to beef and chicken livers at various places where the "+
            "Merchants' Guild does business.\n" );
  add_adjective( "price" );
  set_main_plural( "price boards" );
  add_plural( "boards" );
  reset_get();
}
int look_up(string);
void init() {
  add_command("find", "<word'thing'>", (:look_up($4[0]):));
}
void imp_effect( string phrase ) {
  tell_room( STOCK_EXCHANGE, "A tiny door opens in the board, a warty imp "+
            "climbs out, clambers across the surface and "+ phrase +
            ".  The imp scowls a bit for the look of the thing, and then "+
            "disappears back inside the board.\n" );
}
void init_data( string word ) {
  material_name = word;
  prices = ([ ]);
}
int get_data_file( string word ) {
  if ( material_name != word ) {
    if ( file_size( RESTORE_PATH + word +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + word :));
    else {
      init_data( word );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
int query_price( string word1, string word2 ) {
   if ( !stringp( word1 ) )
      return 0;
   get_data_file( word1 );
   if ( !prices )
      return 0;
   return prices[ word2 ];
}
int add_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] != 0 ) return 0;
  prices += ([ word2 : number ]);
  imp_effect( "adds the price of "+ word1 +" in "+ word2 +" to the lists" );
  save_data_file( material_name );
  return 1;
}
int modify_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices[word2] = number;
  imp_effect( "updates the price of "+ word1 +" in "+ word2 );
  save_data_file( material_name );
  return 1;
}
int remove_price( string word1, string word2 ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices = m_delete( prices, word2 );
  imp_effect( "removes the price of "+ word1 +" in "+ word2 +
              " from the lists" );
  save_data_file( material_name );
  return 1;
}
int look_up( string word ) {
  int i;
  get_data_file( word );
  if ( !m_sizeof( prices ) ) {
    notify_fail( "You can't find any prices for "+ word +" on the board.\n" );
    return 0;
  }
  if ( m_sizeof( prices ) == 1 ) {
    write( "The only price on the board for "+ word +" is "+
              m_values( prices )[0] +" in "+ m_indices( prices )[0] +".\n" );
  } else {
    write( "You find the following price list for "+ word +":\n\n" );
    for ( i = 1; i < m_sizeof( prices ); i++ ) {
      printf( "%6-s %7d %4|s %40-s \n", "", m_values( prices )[i], "in",
                m_indices( prices )[i] +"," );
    }
    printf( "%6-s %7d %4|s %40-s \n", "  and ", m_values( prices )[0], "in",
              m_indices( prices )[0] +"." );
  }
  return 1;
}
string *query_available_datatypes()
{
  return get_dir(RESTORE_PATH);
}

==================================================
FILE: handlers/data.c
==================================================

#include <data.h>
#include <function.h>
#define CALLOUT_DELAY 0
#define DEBUG !
#define DC_DELIM 0
#define DC_ARRAY 1
#define DC_MAPPING 2
#define DC_OF 3
#define DC_CLASS 4
#define DC_STRING 5
#define DC_ITEM 6
#define DC_NUMBER 7
#define DC_GREY 8
#define MAX_SUBF_SIZE 16000
#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')
#ifdef DEBUG
#  define Error(s) write(s); log_file( "DATA_COMPILER", s);
#else
#  define Error(s) ;
#endif
string std_euid;
void create() {
    std_euid = "/secure/master"->creator_file(file_name(this_object()));
    seteuid(std_euid);
}
int tmp_file_no;
private string strip_string( string str ) {
    int     i, j;
    if (!str || str == "") return "";
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i <= j; i++ ) ;
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
    return str[ i..j ];
}
private mixed cleanup_assoc( mixed parse ) {
    int j;
    for (j = 0; j < sizeof(parse[0]); j++) {
        if ((parse[1][j] == DC_DELIM) || (parse[1][j] == DC_OF)) {
            parse[0][j] = 0;
            parse[1][j] = 0;
        }
    }
    parse[0] -= ({ 0 });
    parse[1] -= ({ 0 });
    return parse;
}
mixed compile_data( string *path ) {
    string tmp_name, data = "", file_data = "", s1, tmp_val, base, keyword;
    string *segments, *ind, *val, cur_index;
    int i, j, t, debug_file, class_pending, stat, subfunc_cnt,
        subfunc_char_cnt, data_keyword_found, allocated_data;
    int *index_types;
    mixed parse, index_max;
    if (!sizeof(path))
      return 0;
    tmp_name = path[0] + "_dc.c";
    if( find_object( tmp_name ) )
        tmp_name->dest_me();
    if (file_size(tmp_name) > 0) {
        if ((stat = seteuid("Root")) == 0) {
        }
        stat = unguarded((: rm, tmp_name :));
        if (!stat) {
            Error("Error: couldn't remove old .c file (" +
                  geteuid(this_object()) + ", " +
                  "secure/master"->valid_seteuid(this_object(), "Root") +
                  ")\n");
            seteuid(std_euid);
            return 0;
        }
    }
    seteuid(std_euid);
    for (i = 0; i < sizeof(path); i++) {
        if (file_size(path[i]) <= 0)
          continue;
        data += read_file( path[i] );
    }
    if (!data) {
        Error("Error: file(s) not found.\n");
        return 0;
    }
    segments = explode( "$\n" + data, "\n#" );
    if( !segments ) {
        Error( "prop_to_fun() : Nothing but comments?\n" );
        return 0;
    }
    segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
    for( i = 1; i < sizeof( segments ); i++ ) {
        if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
            segments[ i ] = "";
        }
    }
    data = implode( segments, "\n" );
    segments = explode( strip_string( data ), "::" );
    if (sizeof( segments ) % 2) {
      segments += ({""});
    }
    ind = allocate( sizeof( segments ) / 2 );
    val = allocate( sizeof( segments ) / 2 );
    allocated_data = 0;
    for( i = 0; i < sizeof( ind ); i++ ) {
        ind[ i ] = segments[ i * 2 ];
        val[ i ] = strip_string( segments[ i * 2 + 1 ] );
        if( ind[ i ][ 0..0 ] == "#" ) {
            ind[ i ] = lower_case( ind[ i ] );
            if( ind[ i ] == "#debug" ) {
                sscanf( val[ i ], "%d", debug_file );
            } else if( ind[ i ] == "#include" ) {
                tmp_val = val[i];
                file_data += "#include " + replace( tmp_val, " ", "" ) + "\n";
            }
        }
    }
    for( i = 0; i < sizeof( ind ); i++ ) {
        keyword = lower_case( ind[ i ] );
        if( keyword[ 0..0 ] == "#" ) {
            continue;
        }
        subfunc_char_cnt += sizeof(ind[i]) + sizeof(val[i]);
        if (keyword == "data") {
            if (data_keyword_found) {
                Error("Error: more than one data keyword found.\n");
                return 0;
            }
            data_keyword_found = 1;
            file_data += "void dest_me() { destruct( this_object() ); }\n\n";
            parse = reg_assoc(val[i],
                              ({ "array", "mapping", "of", "class +[^\t ]+",
                                 "[^\t ]+" }),
                              ({ DC_ARRAY, DC_MAPPING, DC_OF, DC_CLASS,
                                 DC_GREY }),
                              DC_DELIM);
            parse = cleanup_assoc( parse );
            for (j = 0; (j < sizeof(parse[0])) && !index_max; j++) {
                switch (parse[1][j]) {
                  case DC_ARRAY:
                    break;
                  case DC_MAPPING:
                    break;
                  case DC_CLASS:
                    base = implode(parse[0][j..], " ");
                    file_data += base + " item;\n";
                  case DC_GREY:
                    index_types = parse[1][0..j-1];
                    index_max = allocate(sizeof(index_types));
                    break;
                  default:
                    Error("Error: data parse error 1 (" + parse[0][j] + ")\n");
                    return 0;
                }
            }
            if (index_types[0] == DC_MAPPING)
              file_data += "mapping data = ([ ]);\n\n";
            else
              file_data += "mixed data;\n\n";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    index_max[j] = -1;
                    break;
                  case DC_MAPPING:
                    break;
                  default:
                    Error("Error: illegal index type found ("
                          + index_types[j] + ")\n");
                    return 0;
                }
            }
            file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
            subfunc_cnt++;
            continue;
        }
        if (keyword[0..3] == "item") {
            if (class_pending) {
                file_data += "  data" + cur_index + " = item;\n";
                class_pending = 0;
            }
            if (subfunc_char_cnt > MAX_SUBF_SIZE) {
                file_data += "}\n\n";
                file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
                subfunc_cnt++;
                subfunc_char_cnt = 0;
            }
            parse = reg_assoc( ind[i], ({ "\"[^\"]*\"", "item", "[0-9]+",
                                      "[^,\t ]+"}),
                              ({ DC_STRING, DC_ITEM, DC_NUMBER, DC_GREY }));
            parse = cleanup_assoc( parse );
            cur_index = "";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    if (parse[1][j+1] != DC_NUMBER) {
                        if (parse[0][j+1] == "i") {
                            parse[0][j+1] = index_max[j] + "";
                        } else if (parse[0][j+1] == "i++") {
                            parse[0][j+1] = index_max[j] + "";
                            index_max[j]++;
                        } else if (parse[0][j+1] == "++i") {
                            index_max[j]++;
                            parse[0][j+1] = index_max[j] + "";
                        } else {
                          Error("Error: illegal index for array (" +
                                  parse[0][j+1] + ")\n");
                            return 0;
                        }
                    }
                    if ((t = to_int(parse[0][j+1])) > index_max[j]) {
                        file_data += "  data" + cur_index
                          + " = allocate(" + (t-index_max[j]) + ");\n";
                        index_max[j] = t;
                        allocated_data = 1;
                    }
                    break;
                  case DC_MAPPING:
                    if (j) {
                        file_data += "  if (!mapp(data" + cur_index + "))"
                          + " data" + cur_index + " = ([]);\n";
                    }
                    break;
                  default:
                    Error("Error: illegal index type found (" + index_types[j]
                          + ")\n");
                    return 0;
                }
                cur_index += "[" + parse[0][j+1] + "]";
            }
            if (strip_string(val[i]) != "") {
                file_data += "  data" + cur_index + " = " + val[i] + ";\n";
            }
            continue;
        }
        if (keyword[0..1] == "->") {
            if (!class_pending) {
                file_data += "  item = new( " + base + " );\n";
                class_pending = 1;
            }
            file_data += "  item->" + ind[i][2..] + " = " + val[i] + ";\n";
            continue;
        }
        if (keyword == "quote") {
            file_data += val[i] + "\n";
            continue;
        }
    }
    if (class_pending) {
        file_data += "  data" + cur_index + " = item;\n";
    }
    file_data += "}\n\n";
    file_data += "mixed data_return() {\n";
    if ( !allocated_data ) {
        for (j = 0; j < sizeof(index_types); j++) {
            switch (index_types[j]) {
                case DC_ARRAY:
                    file_data += "  data = allocate(" + (to_int(index_max[j]) + 1) + ");\n";
                break;
            }
        }
    }
    for (i = 0; i < subfunc_cnt; i++) {
        file_data += "  data_return_" + i + "();\n";
    }
    file_data += "  return data;\n}\n";
    seteuid("Root");
    unguarded((: write_file, tmp_name, file_data, 1 :));
    seteuid(std_euid);
    return tmp_name->data_return();
}
class data_node {
   int type;
   mixed value;
}
class queue_node {
   string name;
   class data_node data;
}
class compile_data {
   string file_name;
   function call_back;
   int current_line;
   int look_for;
   int last_chunk_compile;
   int file_len;
   class queue_node* depths;
}
private nosave class compile_data* _to_compile = ({ });
void start_compile();
void parse_chunk(class compile_data data, string chunk);
#define DATA_UNKNOWN 0
#define DATA_CHILDREN 1
#define DATA_NUMBER 2
#define DATA_STRING 3
#define DATA_LIST 4
#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define START_LIST 5
#define END_NUMBER 6
#define ARGUMENT_VALUE 7
#define ARGUMENT_NAME 8
#define REST_OF_ARGUMENT 9
#define END_STRING_LIST 10
#define END_NUMBER_LIST 11
#define END_LIST 12
#define CHUNK_SIZE 10
void compile_file(string fname, function call_back) {
   class compile_data data;
   if (file_size(fname) == -1) {
      tell_object(this_player(), "The file "+
                         fname+" does not exist.\n");
      return ;
   }
   if (file_size(fname) == -2) {
      tell_object(this_player(), "The file "+
                         fname+" is a directory exist.\n");
      return ;
   }
   data = new(class compile_data);
   data->file_name = fname;
   data->call_back = call_back;
   data->look_for = OPEN_BRACKET;
   _to_compile += ({ data });
   start_compile();
}
void start_compile() {
   class compile_data data;
   if (!sizeof(_to_compile) || _to_compile[0]->last_chunk_compile) {
      return ;
   }
   data = _to_compile[0];
   data->last_chunk_compile = time();
   data->current_line = 1;
   data->look_for = OPEN_BRACKET;
   data->file_len = file_length(data->file_name);
   data->depths = ({ new(class queue_node,
                  data : new(class data_node, type : 0, value : ([ ]) )) });
   call_out("compile_chunk", CALLOUT_DELAY);
}
void compile_chunk() {
   string chunk;
   int end;
   class compile_data data;
   data = _to_compile[0];
   data->last_chunk_compile = time();
   if (data->current_line > data->file_len ||
       functionp(data->call_back) & FP_OWNER_DESTED) {
      call_out("start_compile", CALLOUT_DELAY);
      _to_compile = _to_compile[1..];
      if (!(functionp(data->call_back) & FP_OWNER_DESTED)) {
         evaluate(data->call_back, data->file_name, data->depths[0]->data->value);
      }
      return ;
   }
   if (data->current_line+CHUNK_SIZE > data->file_len) {
      end = data->file_len+1;
   } else {
      end = data->current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, data->file_name, data->current_line,
                               end-data->current_line :));
   data->current_line = end;
   call_out("compile_chunk", CALLOUT_DELAY);
   parse_chunk(data, chunk);
}
mixed to_diceint(string str) {
   class data_dice dice;
   string s1;
   if (strsrch(str, "d") != -1) {
      dice = new(class data_dice);
      if (sscanf(str, "%dd%s", dice->number, s1) == 2) {
         if (strsrch(s1, "+")) {
            if (sscanf(s1, "%d+%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            }
         } else if (strsrch(s1, "-")) {
            if (sscanf(s1, "%d-%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            } else {
               dice->modifier = - dice->modifier;
            }
         } else {
            dice->die = to_int(s1);
         }
      }
      return dice;
   }
   return to_int(str);
}
void parse_chunk(class compile_data data, string chunk) {
   string *bits;
   string s1;
   string s2;
   string s3;
   int pos;
   int chunk_size;
   int start;
   class data_node node;
   while (sscanf(chunk, "%s#%s\n%s", s1, s2, s3) == 3) {
      chunk = s1 + s3;
   }
   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (data->look_for) {
         case OPEN_BRACKET :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            if (chunk[pos] == ')') {
               data->look_for = END_BRACKET;
               break;
            }
            if (chunk[pos] == '(') {
               chunk = chunk[pos+1..];
               chunk_size = strlen(chunk);
               pos = 0;
               node = new(class data_node, type : 0);
               data->depths += ({ new(class queue_node, data : node) });
               data->look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;
         case ARGUMENT_NAME :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            while (pos < chunk_size && chunk[pos] != ' ' &&
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            data->depths[<1]->name = chunk[start..pos-1];
            data->look_for = ARGUMENT_VALUE;
            break;
         case ARGUMENT_VALUE :
         case START_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Error, found a bracket inside a list.\n");
                     pos = chunk_size;
                     break;
                  }
                  data->look_for = OPEN_BRACKET;
                  data->depths[<1]->data->type = DATA_CHILDREN;
                  data->depths[<1]->data->value = ([ ]);
                  break;
               case '"' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_STRING_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_STRING;
                     data->depths[<1]->data->value = "";
                  }
                  pos++;
                  data->depths[<1]->data->type = DATA_STRING;
                  break;
               case '0'..'9' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_NUMBER_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_NUMBER;
                     data->depths[<1]->data->value = "";
                  }
                  data->depths[<1]->data->type = DATA_NUMBER;
                  break;
               case '}' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_BRACKET;
                     pos++;
                     data->depths[<1]->data->type = DATA_LIST;
                  } else {
                     debug_printf("End of list without a start of list.\n");
                     pos = chunk_size;
                  }
                  break;
               case '{' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Cannot have nested lists.\n");
                     pos = chunk_size;
                  } else {
                     data->look_for = START_LIST;
                  }
                  data->depths[<1]->data->value = ({ });
                  data->depths[<1]->data->type = DATA_LIST;
                  pos++;
                  break;
               default :
                 if(chunk[pos] = 't')
                  if(chunk[pos..pos+3] == "true" || chunk[pos..pos+2] == "yes") {
                    if(chunk[pos..pos+3] == "true")
                      pos += 3;
                    else
                      pos += 2;
                    data->depths[<1]->data->value = 1;
                    data->depths[<1]->data->type = DATA_NUMBER;
                    data->look_for = END_BRACKET;
                    break;
                  }
                  debug_printf("Unknown data type %s in %s\n",
                               chunk[pos..pos+5], chunk);
                  pos = chunk_size;
                  break;
            }
            break;
         case END_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ',' :
                  pos++;
                  data->look_for = START_LIST;
                  break;
               case '}' :
                  data->look_for = START_LIST;
                  break;
               default :
                  debug_printf("Expected , or } not %s\n", chunk[pos..pos+5]);
                  pos = chunk_size;
                  break;
            }
            break;
         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               if (arrayp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] += ({
                       data->depths[<1]->data->value });
               } else if (sizeof(data->depths) == 2) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({
                       data->depths[<1]->data->value });
               } else if (!undefinedp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({
                       data->depths[<2]->data->value[data->depths[<1]->name],
                       data->depths[<1]->data->value });
               } else {
                  data->depths[<2]->data->value[data->depths[<1]->name] = data->depths[<1]->data->value;
               }
               data->depths = data->depths[0..<2];
               chunk = s2;
               chunk_size = strlen(s2);
               pos = 0;
               data->look_for = OPEN_BRACKET;
            }
            break;
         case END_NUMBER_LIST :
         case END_NUMBER :
            start = pos;
            while (pos < chunk_size && ((chunk[pos] >= '0' &&
                      chunk[pos] <= '9') ||
                      chunk[pos] == 'd' || chunk[pos] == '+' ||
                      chunk[pos] == '-')) {
               pos++;
            }
            if (data->look_for == END_NUMBER) {
               data->depths[<1]->data->value += chunk[start..pos - 1];
            } else {
               data->depths[<1]->data->value[<1] += chunk[start..pos - 1];
            }
            if (pos < chunk_size) {
               if (data->look_for == END_NUMBER) {
                  data->depths[<1]->data->value = to_diceint(data->depths[<1]->data->value);
                  data->look_for = END_BRACKET;
               } else {
                  data->depths[<1]->data->value[<1] = to_diceint(data->depths[<1]->data->value[<1]);
                  data->look_for = END_LIST;
               }
            }
            break;
         case END_STRING_LIST :
         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1, "\n", "");
                     data->look_for = END_BRACKET;
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1, "\n", "")+"\"";
                     data->look_for = END_LIST;
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               if (data->look_for == END_STRING) {
                  data->depths[<1]->data->value += replace(chunk, "\n", "");
               } else {
                  data->depths[<1]->data->value[<1] += chunk;
               }
               pos = chunk_size;
            }
            break;
         default :
            debug_printf("Horrible error "+data->look_for+" (" +
                         data->file_name + ") " + data->current_line + " " +
                         chunk[pos..] + "\n");
            pos = chunk_size;
            break;
      }
   }
}

==================================================
FILE: handlers/english_handler.c
==================================================

float *freq=({ 0.070012, 15.782218, 0.011949, 43.328090, 0.021800, 31.780955,
                 0.041222, 22.534301, 0.081093, 11.110506, 0.016799, 34.952377,
                 0.019235, 35.094824, 0.031751, 21.939816, 0.055348, 15.959625,
                 0.001028, 116.456628, 0.007624, 57.669862, 0.029144,
                 22.558570, 0.028764, 31.148966, 0.047194, 18.490345, 0.054178,
                 15.319177, 0.014415, 36.228697, 0.001335, 116.456628,
                 0.047561, 18.817823, 0.050139, 17.975454, 0.058789, 13.617099,
                 0.020638, 32.978418, 0.005222, 63.346619, 0.011713, 42.180909,
                 0.001264, 116.456628, 0.014661, 40.185678, 0.000530,
                 116.456628, 0.171614, 40.0, 0.000666, 116.456628,
                 0.084311, 10.304674
});
int FreqTest( string line ) {
  int len,i,ch;
  float badness,term;
  int *let;
  let=allocate(29);
  i = len = strlen(line);
  while (i--) {
    ch = line[i];
    if ((ch>=65 && ch<65+26) || (ch>=97 && ch<97+26)) let[(ch&31)-1]++;
    else if (ch==' ') let[26]++;
    else if (ch>='0' && ch<='9') let[27]++;
    else let[28]++;
  }
  badness = 0.0;
  for (i=0;i<29;i++) {
    term = to_float((to_float(let[i]) - freq[i<<1] * len) * freq[(i<<1)+1]);
    badness += (term>0 ? term : -term);
  }
  badness /= (29.0*len);
  i = 100 - 50*badness*badness;
  if (i<1) i=1;
  return i;
}
int ProfaneTest( string strin ) {
  int i,profane=0;
  string str,s;
  if (sizeof(strin)<1) return 0;
  strin=lower_case(strin)+" ";
  str="";
  for (i=0;i<sizeof(strin);i++) {
    if (strin[i]>='a' && strin[i]<='z') str+=strin[i..i];
  }
  if (sizeof(str)<2) return 0;
  s=str[0..0];
  for (i=1;i<sizeof(str);i++) {
    if (s[<1]!=str[i]) s+=str[i..i];
  }
  if (regexp(s,"bastard|tit|shaft|viag")
     || regexp(str,"poo|ass|butt")) profane+=25;
  if (regexp(s,"arse|sex|sux|crap|testic|fart|orgasm|orgy|turd|porn|niple|nazi|jesus|christ|satan|sperm|smeg|toilet|genital")
     || regexp(str,"piss|root|buttw|assho")
     || regexp(strin,"butt |ass ")) profane+=50;
  if (regexp(s,"netsex|arse|shit|screw|urine|rectum|tampon|vibrator|rectal|scatol|semen|suck|lick|dyke|dike|wank|mutha|prost|fag|feck|gay|homo|fuq|horny|blowjob|cuni")
     || regexp(str,"phall|hooter|poof")) profane+=100;
  if (regexp(s,"anal|rape|rapist|fuck|fuk|fuch|kuck|cunt|kunt|whor|slut|clit|masturb|masterb|penis|cock|dick|pusy|bitch|vagina")) profane+=200;
  return profane;
}

==================================================
FILE: handlers/error_handler.c
==================================================

inherit "/obj/handlers/inherit/error_handler";
void create() {
  seteuid("Root");
   ::create();
}
void setup_error_handler(string user, string db, string password) {
   ::setup_error_handler(user, db, password);
}

==================================================
FILE: handlers/error_tracker.c
==================================================

inherit "/std/dom/error_tracker_master";
void create() {
    set_domain( "mudlib" );
    set_name( "The Mudlib's Lord of the Whinge" );
    set_other_dirs( ({
        "/std%",
        "/obj%",
        "/global%",
        "/cmds%",
        "/mudlib%",
        "/include%",
        "/net%",
        "/soul%",
        "/room%",
        "/www%",
      }) );
    set_period( 604800 );
    ::create();
}

==================================================
FILE: handlers/fairy_godmothers.c
==================================================

#include <panic.h>
#include <config.h>
#include <playerinfo.h>
#include <cwc.h>
#define HARRY_SHADOW "/std/shadows/misc/harry_shadow"
object* _panicers;
object* _godmothers;
object* _queue;
#define FREE_NAME "free trip"
#define THRESHOLD 50
#define DAY (60*60*24)
public  void   continue_panicing(string str, object panicer);
private object startup_godmother(object ob);
private void   finish_with_person(object ob, int ok);
void create() {
  _panicers = ({ });
  _godmothers = allocate(NUM_GODMOTHERS);
  _queue = ({ });
}
object *query_godmothers() { return copy(_godmothers); }
int free_godmothers() {
  int i;
  for (i=0;i<sizeof(_godmothers);i++) {
    if (!_godmothers[i]) {
      return 1;
    }
  }
  return 0;
}
int do_startup(object panicer) {
  if (environment(panicer) &&
      environment(panicer)->query_property("no godmother")) {
    notify_fail(environment(panicer)->query_property("no godmother"));
    return 0;
  }
  if (panicer->query_property("attacked godmother") &&
      (panicer->query_property("attacked godmother") + DAY * 10) > time())
  {
    notify_fail("You attacked a godmother!  No help for you!\n");
    return 0;
  }
  if (sizeof(panicer->query_attacker_list())) {
    notify_fail("You cannot use a godmother whilst you are in a fight.\n");
    return 0;
  }
  panicer->remove_property("attacked godmother");
  _panicers -= ({ 0 });
  if (member_array(panicer, _panicers) != -1  ||
      member_array(panicer, _queue) != -1)
  {
    notify_fail("You are already requesting assistance.  Be patient.\n");
    return 0;
  }
  if (!panicer) {
    panicer = this_player();
  }
  if (panicer->query_level() < 10 ||
      !arrayp(environment(panicer)->query_exits()) ||
      !sizeof(environment(panicer)->query_exits()) ||
      !environment(panicer))
  {
    write("You feel help is on its way.\n");
    panicer->add_property("godmother", FREE_NAME);
    continue_panicing("y", panicer);
  }
  else {
    panicer->remove_property("godmother");
    if (panicer->query_level() < 50) {
      int max_gp;
      max_gp = panicer->query_max_gp();
      if (panicer->query_gp() < max_gp / 3) {
        notify_fail("You do not have enough guild points to summon "
                    "a godmother.  You need at least " +
                    (max_gp / 3) + ".\n");
        return 0;
      }
      write("This will cost you all of your current guild points and "
            "social points, and leave you feeling a little weak.  "
            "Do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
    }
    else {
      if (panicer->query_max_deaths() <= panicer->query_deaths()) {
        notify_fail("You do not have a life to spend on a godmother.\n");
        return 0;
      }
      write("This will cost you a life, do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
    }
  }
  return 1;
}
private void do_check_queue() {
   _queue -= ({ 0 });
   if (sizeof(_queue)) {
      if (startup_godmother(_queue[0])) {
         _queue = _queue[1..];
      }
   }
}
private void setup_harrass_callout() {
  int i;
  int check_queue;
  int waiting;
  int max_wait;
  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      waiting = _godmothers[i]->query_waiting();
      if (waiting > FIRST_WAIT_TIME && environment(_godmothers[i])) {
        _godmothers[i]->hurry_up();
      }
      if (!environment(_godmothers[i])) {
         _godmothers[i]->dest_me();
         check_queue = 1;
      }
      if (waiting > max_wait) {
        max_wait = waiting;
      }
    }
  }
  if (max_wait < FIRST_WAIT_TIME) {
    call_out("do_hurry_up", FIRST_WAIT_TIME-max_wait+2);
  }
  if (check_queue) {
    do_check_queue();
  }
}
void continue_panicing(string str, object panicer) {
  str = lower_case(str);
  if (!str || str == "" || (str[0] != 'y' && str[0] != 'n')) {
    if (panicer->query_level() < 100) {
      write("This will cost you all of your current guild points and "
            "social points and leave you feeling a little weak.  "
            "Do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
      return ;
    }
    else {
      write("This will cost you a life, do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
      return ;
    }
  }
  if (str[0] == 'n') {
    write("Ok.  They do not show up to help you.  Good luck.\n");
    return ;
  }
  if (!startup_godmother(panicer)) {
    write("You hope a godmother will turn up sometime soon.\n");
    _queue += ({ panicer });
    setup_harrass_callout();
  }
}
void do_panic_callout(object godmother, object ob) {
  godmother->do_panic(ob);
}
private object startup_godmother(object ob) {
  object godmother;
  int    i, num;
  i = random(NUM_GODMOTHERS);
  if (_godmothers[i]) {
    for (num = 1; num < NUM_GODMOTHERS; num++)  {
      i = (i + 1) % NUM_GODMOTHERS;
      if (!_godmothers[i])  break;
    }
  }
  if (num == NUM_GODMOTHERS)
     return 0;
  switch (i) {
    case 0:
      godmother = clone_object(GODMOTHER_DIR + "granny");
      break;
    case 1:
      godmother = clone_object(GODMOTHER_DIR + "magrat");
      break;
    default:
      write("Something is hosed.  Please file a bug report.\n");
      break;
  }
  _godmothers[i] = godmother;
  godmother->move(environment(ob), "As if by magic $N appears.", "");
  call_out("do_panic_callout", 1, godmother, ob);
  _panicers += ({ ob });
  return godmother;
}
void finish_panic(object person, int ok) {
  int i;
  if (person)  {
     finish_with_person(person, ok);
  }
  _panicers -= ({ person });
  for (i = 0; i < sizeof(_godmothers); i++)  {
    if (_godmothers[i] == previous_object()) {
      call_out("do_move", 10, _godmothers[i] );
      break;
    }
  }
  do_check_queue();
  if (!sizeof(_queue)) {
     remove_call_out("do_hurry_up");
  }
}
void do_move (object fairy) {
      fairy->move("/room/rubbish", "",
          "With a quick flick of her wand, the fairy godmother is gone.");
      fairy = 0;
}
private void finish_with_person(object person, int ok)  {
  if (member_array(person, _panicers) == -1) {
    log_file("GODMOTHER_ERROR", "person == %O, godmother == %s\n", person, previous_object()->query_short());
    write("Consistancy error, they never paniced.\n");
    return ;
  }
  if (ok) {
    if (person->query_property("godmother") == FREE_NAME) {
    }
    else if (person->query_level() < THRESHOLD) {
      person->adjust_tmp_con(-2);
      person->set_gp(0);
      person->set_sp(0);
    }
    else if (person->query_level() >= THRESHOLD &&
             person->query_max_deaths() > person->query_deaths()) {
      PLAYERINFO_HANDLER->add_entry(person,
        person->query_name(), "misc", "Lost a life to the Godmother");
      log_file("GODMOTHER_DEATH", "%s: %s lost a life to the Godmother\n",
        ctime(time()), person->query_name());
      person->adjust_deaths(1);
    }
    call_out(function(object person) {
      string destination;
      destination = person->query_nationality()->query_default_start_location();
      person->move_with_look(destination,
                             "$N appears out of nowhere.",
                             "$N disappears with a pop.");
      if (person->query_ghost()) {
        person->remove_ghost();
        clone_object(HARRY_SHADOW)->setup_shadow(person,
                                                 "a fairy godmother" );
      }
    }, 2, person);
  }
  person->remove_property("godmother");
}
void do_hurry_up() {
  int i;
  int waiting;
  int max_wait;
  if (!sizeof(_queue)) {
    return ;
  }
  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      if (!environment(_godmothers[i])) {
        _godmothers[i]->dest_me();
        _godmothers[i] = 0;
      }
      else {
        waiting = _godmothers[i]->query_waiting();
        if (waiting > FIRST_WAIT_TIME) {
          if (waiting > FINISH_WAIT_TIME) {
            _godmothers[i]->finish_up();
          } else {
            _godmothers[i]->hurry_up();
          }
        }
        if (waiting > max_wait) {
          max_wait = waiting;
        }
      }
    }
  }
  if (max_wait > 0) {
    if (FINISH_WAIT_TIME - max_wait < 10) {
      call_out("do_hurry_up", 10);
    } else {
      call_out("do_hurry_up", FINISH_WAIT_TIME-max_wait);
    }
  }
}
void dest_me() {
  int i;
  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      _godmothers[i]->dest_me();
    }
  }
  destruct(this_object());
}

==================================================
FILE: handlers/finderror_helper.c
==================================================

#include <log.h>
#include <config.h>
#include <db.h>
nosave inherit "/std/object";
private void recursive_add_directory( string word, string dir );
class error_data {
    string name;
    string *dirs;
    int no_calls;
}
nosave mapping _error_cache;
string name, *dirs;
void create() {
    ::create();
    set_name( "finderror_helper" );
    set_short( "finderror helper" );
    _error_cache = ([ ]);
}
private string strip_extension( string file ) {
    if ( file[<1] == '/' ) {
        return file[0..<2];
    }
    return file;
}
private class error_data get_data_file( string word ) {
    string file;
    if ( _error_cache[ word ] ) {
        return _error_cache[ word ];
    }
    seteuid( word );
    file = "/w/" + word + "/finderror.o";
    if ( file_size( file ) > 0 ) {
        unguarded( (: restore_object, file :) );
        _error_cache[ word ] = new( class error_data,
            name : name,
            dirs : map( dirs, (: strip_extension :) ),
            no_calls : 0 );
    }
    else {
        _error_cache[ word ] = new( class error_data,
            name : word,
            dirs : ({ }),
            no_calls : 0 );
    }
    return _error_cache[ word ];
}
private int save_data_file( string word ) {
    seteuid( word );
    if ( _error_cache[ word ] ) {
        name = _error_cache[ word ]->name;
        dirs = _error_cache[ word ]->dirs;
        unguarded( (: save_object, "/w/" + word + "/finderror" :) );
        return 1;
    }
    return 0;
}
string escape( string txt ) {
    return replace( txt, ({ "'", "\\'" }) );
}
private string assemble_dirs_sql( string *dirs ) {
    dirs = map( dirs, (: escape :) );
    return "(" + implode( map( dirs,
            (: "Directory" + ( strsrch( $1, "%" ) > -1 ? " LIKE " : " = " )
            +  "'" + $1 + "'" :) ), " OR " ) + ")";
}
void finished_query( int status, mixed data, function func, object player ) {
    evaluate( func, player, status, data );
}
public int query_dirs_count(mixed player, function finish_func ) {
  class error_data info;
  string query;
  string txt;
  string word;
    if ( objectp( player ) ) {
  word = player->query_name();
    }
    else {
        word = player;
        player = this_object();
    }
  info = get_data_file( word );
  if ( sizeof( info->dirs ) ) {
        txt = assemble_dirs_sql( info->dirs );
        query = "SELECT Directory, Type, COUNT(Id) FROM errors WHERE " + txt + " AND "
            "Status = 'OPEN' GROUP BY Directory, Type;";
        DB_HANDLER->make_sql_request("errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(player) ) :) );
        return 1;
  }
  return 0;
}
public int query_errors_in_dirs(string *directories, function finish_func ) {
    string query;
    string txt;
    if ( directories ) {
        directories = map( directories , (: escape :) );
        txt = "(" + implode( map( directories,
            (: "Directory" + ( strsrch( $1, "%" ) > -1 ? " LIKE " : " = " )
            +  "'" + $1 + "'" :) ), " OR " ) + ")";
        query = "SELECT Directory, Type, COUNT(Id) AS C FROM errors WHERE " + txt + " AND "
            "Status = 'OPEN' GROUP BY Directory, Type";
        DB_HANDLER->make_sql_request("errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(this_player()) ) :) );
        return 1;
    }
    return 0;
}
public void query_next_dir( object player, function finish_func ) {
    string query;
    string txt;
    string word;
    class error_data info;
    word = player->query_name();
    info = get_data_file( word );
    if ( sizeof( info->dirs ) ) {
        txt = assemble_dirs_sql( info->dirs );
        query = "SELECT Directory, COUNT(Id) AS C FROM errors WHERE " + txt +
            " AND Status = 'OPEN' GROUP BY Directory HAVING C > 0 LIMIT 1;";
        DB_HANDLER->make_sql_request( "errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(player) ) :) );
    }
    else {
        tell_object( player, "You have no finderrors directories defined.  Add "
            "them with 'finderrors add'\n" );
    }
}
public string *query_directories( string player ) {
    class error_data data;
    data = get_data_file( player );
    return copy( data->dirs );
}
public int add_directory( object player, string dir, int recursive ) {
    int res;
    class error_data info;
    string word;
    word = player->query_name();
    info = get_data_file( word );
    res = member_array( dir, info->dirs );
    if ( recursive )  {
        dir += "%";
    }
    if ( res == -1 ) {
        if ( dir[ <1 ] == '/') {
            dir = dir[ 0 .. <2 ];
        }
        info->dirs = ({ dir }) + info->dirs;
        tell_object( player, "Added " + dir +
            (recursive ? " (recursive)" : "") + "\n" );
        save_data_file( word );
    }
    return 1;
}
private void recursive_add_directory( object player, string dir ) {
    mixed *directories, *file;
    class error_data info;
    string word;
    word = player->query_name();
    info = get_data_file( word );
    info->no_calls--;
    directories = get_dir( dir, -1 );
    if ( directories ) {
        foreach ( file in directories ) {
            if ( file[ 1 ] == -2 && file[ 0 ] != "Maps") {
                add_directory( player, dir + file[ 0 ] +"/", 1 );
            }
        }
    }
    if ( info->no_calls == 0 ) {
        tell_object( player,
            "All subdirectories have been added to the list.\n" );
        save_data_file( word );
    }
}
public int remove_directory( object player, string directory, int recursive ) {
    class error_data info;
    string word;
    int pos;
    word = player->query_name();
    info = get_data_file( word );
    if ( recursive ) {
        pos = sizeof( directory ) - 1;
        info->dirs = filter( info->dirs,
            (: $1[ 0..$(pos) ] != $(directory) :));
    }
    else {
        pos = member_array( directory, info->dirs );
        if ( pos == -1 ) {
            return 0;
        }
       info->dirs = info->dirs[ 0..pos - 1 ] + info->dirs[ pos+1.. ];
    }
    save_data_file( word );
    return 1;
}

==================================================
FILE: handlers/firework.c
==================================================

#define BROADCASTER "/obj/handlers/broadcaster"
#define MAX_RANGE 1600
#define SHIFT 30
#define TIME 15
class firework_running {
   string *messages;
   int index;
   string caster;
   string text;
   int *co_ord;
}
mixed *_effects;
class firework_running *_fireworks;
protected void do_effects();
void create() {
  _effects = ({
    ({
      "A small dot flashes up high into the sky.",
      "The dot suddenly bursts open revealing bright multicoloured streams "
          "of flame that pour down towards the ground.",
      "Just as you thought the streams had faded to nothing, they shoot back "
          "up into the air giving a final brilliant yellow colour before "
          "vanishing entirely.",
      "As it fades you think you see the letters \"$arg$\" in the gradually "
          "disappearing smoke.",
    }),
    ({
      "A brilliant trail of yellow sparks follows a small dot up into the "
          "sky.",
      "The dot slowly slows down until it has stopped moving, and hovers for "
          "a few seconds.",
      "Suddenly the dot explodes, sending out bright red streamers of light "
          "in all directions and lighting up the sky for a few seconds.",
      "The red light fades to nothingness, and the last colour left in the "
          "sky shows the letters \"$arg$\" which slowly disappear.",
    }),
    ({
      "A light flashes up high into the sky trailing grey smoke behind it.",
      "The light wizzes around in circles making a high pitched whizzing "
          "noise.",
      "The dot bursts open sending brilliant green streamers of light to "
          "all the corners of the sky.",
      "With a sudden resounding bang, the streamers rush back together to form "
          "\"$arg$\" which hangs in the sky before slowly vanishing."
    }),
  });
  _fireworks = ({ });
}
varargs void random_firework( object caster, string text ) {
  mixed *co_ord;
  class firework_running new_firework;
  co_ord = (mixed *)environment( caster )->query_co_ord();
  if ( sizeof( co_ord ) < 3 ) {
    co_ord = ({ 0, 0, 0 });
  }
  if ( !text || ( text == "" ) ) {
    text = (string)caster->query_name();
  }
  new_firework = new(class firework_running);
  new_firework->messages = _effects[random(sizeof(_effects))];
  new_firework->index = 0;
  new_firework->text = capitalize(text);
  new_firework->co_ord = ({ co_ord[ 0 ], co_ord[ 1 ], co_ord[ 2 ] + SHIFT });
  if ( !sizeof(_fireworks)) {
    call_out( (: do_effects :), TIME );
  }
  _fireworks += ({ new_firework });
}
protected void do_effects() {
  class firework_running firework;
  foreach (firework in _fireworks) {
    BROADCASTER->broadcast_event( users(), firework->co_ord, "you see:\n"+
        replace( firework->messages[firework->index] , "$arg$",
        firework->text ), MAX_RANGE, 0, 0 );
    firework->index++;
    if ( firework->index >= sizeof( firework->messages ) ) {
      _fireworks -= ({ firework });
    }
  }
  if ( sizeof( _fireworks ) ) {
    call_out( (: do_effects :), TIME );
  }
}
mixed *query_effects() {
   return _effects;
}

==================================================
FILE: handlers/folder_handler.c
==================================================

#pragma strict_types
#include <board.h>
#include <comms.h>
#include <mail.h>
#include <network.h>
#include <mime.h>
#include <player_handler.h>
#define MAIL_PATH "/save/mail/"
int *mesg_numbers;
class mail_header *info;
int new_thingy;
nosave int link;
class mail_header *get_messages(string pname, string fname);
string load_message(string pname, string fname, int number);
void delete_it(string pname, string fname, int *deleted);
string check_local(string arg);
private int load_counter();
private void save_counter(int counter);
void dest_me();
void delete_account(string player);
void create() {
  seteuid("Mailer");
}
private string folder_filename(string name) {
  if(file_size(MAIL_PATH + name) != -1) {
    unguarded((: rename, MAIL_PATH + name,
         MAIL_PATH + name[0..0] + "/" + name :));
  } else if(file_size(MAIL_PATH + name + ".o") != -1) {
    unguarded((: rename, MAIL_PATH + name + ".o",
         MAIL_PATH + name[0..0] + "/" + name + ".o" :));
  }
  return MAIL_PATH+name[0..0] + "/"  + name;
}
private string message_filename(int num, string prefix) {
  if(file_size(MAIL_PATH+"new_mesg/" + (num % 50)) == -1) {
    unguarded((: mkdir, MAIL_PATH+"new_mesg/" + (num % 50) :));
  }
  if(file_size(MAIL_PATH+"new_mesg/"+(num % 50)+"/"+((num / 50) % 50)) == -1) {
    unguarded((: mkdir, MAIL_PATH+"new_mesg/" + (num %50) + "/" +
         ((num / 50) % 50) :));
  }
#ifdef 0
  if(file_size(MAIL_PATH + "mesg/" + prefix + num) != -1) {
    unguarded((: rename, MAIL_PATH + "mesg/" + prefix + num,
     MAIL_PATH+"new_mesg/"+ (num % 50) + "/" + ((num / 50) % 50) +
     "/" + prefix + num :));
  }
#endif
  return MAIL_PATH+"new_mesg/"+  (num % 50) + "/" + ((num / 50) % 50) +
    "/" + prefix + num;
}
nomask int can_create_folder(string player, string folder) {
    return file_size(folder_filename(player) + folder + ".o") == -1;
}
private void convert_links(int number) {
  string message;
  int tmplink;
  message = unguarded((: read_file, message_filename(number, "l"), 1, 1 :));
  if (!message || sscanf(message, "%d", tmplink) != 1) {
    return;
  }
  sscanf(message, "%d", tmplink);
  message = unguarded((: read_file, message_filename(number, "") :));
  unguarded((: rm, message_filename(number, "") :));
  unguarded((: rm, message_filename(number, "l") :));
  unguarded((: write_file, message_filename(number, ""),
               "" + tmplink + "\n" + message :));
}
private string query_message_data(int number) {
   string data;
   convert_links(number);
   data = unguarded((: read_file, message_filename(number, "") :));
   if(!data)
     return data;
   sscanf(data, "%*d\n%s", data);
   return data;
}
private void create_new_message(int number, string data, int links) {
   unguarded((: rm, message_filename(number, "") :));
   unguarded((: write_file, message_filename(number, ""),
                            "" +links + "\n" + data :));
}
private void increment_links(int number) {
  string message;
  int num_links;
  convert_links(number);
  message = unguarded((: read_file, message_filename(number, "") :));
  if (!message) {
     return ;
  }
  sscanf(message, "%d\n%s", num_links, message);
  num_links++;
  unguarded((: rm, message_filename(number, "") :));
  unguarded((: write_file, message_filename(number, ""),
               "" + num_links + "\n" + message :));
}
private void decrement_links(int number) {
  string message;
  int num_links;
  convert_links(number);
  message = unguarded((: read_file, message_filename(number, "") :));
  if (!message) {
     return ;
  }
  sscanf(message, "%d\n%s", num_links, message);
  num_links--;
  unguarded((: rm, message_filename(number, "") :));
  if (num_links > 0) {
     unguarded((: write_file, message_filename(number, ""),
                  "" + num_links + "\n" + message :));
  }
}
private int check() {
  string base;
  base = base_name(previous_object());
  if (base != "/obj/handlers/mailer" &&
      base != "/obj/handlers/folder_handler" &&
      base != "/obj/handlers/converter" &&
      base != "/net/daemon/pop3" &&
      base != "/net/daemon/imap4" &&
      base != "/secure/bulk_delete") {
    printf("Folder handler: Illegal access ! (%O)\n", base);
    return 1;
  } else
    return 0;
}
private void convert_class(string pname, string fname) {
  class mail_header hdr;
  int i;
  i = sizeof(info);
  while (i--) {
    hdr = new(class mail_header);
    hdr->number = ((mapping)info[i])["number"];
    hdr->status = ((mapping)info[i])["status"];
    hdr->subject = ((mapping)info[i])["subject"];
    hdr->from = ((mapping)info[i])["from"];
    info[i] = hdr;
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
}
class mail_header *get_messages(string pname, string fname) {
  if (check())
    return ({ });
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  return info;
}
string load_message(string pname, string fname, int number) {
  string message;
  if (check()) {
    return " ";
  }
  if (file_size(message_filename(number, "l")) > 0)  {
    convert_links(number);
  }
  message = query_message_data(number);
  if (!message) {
    printf("* Failed to load message.\n", number);
  }
  return message;
}
void delete_it(string pname, string fname, int *deleted) {
  int i, idx;
  if (check()) {
    return;
  }
  if (!PLAYER_HANDLER->test_user(pname)) {
    return;
  }
  if (sizeof(deleted) > 1) {
    deleted = uniq_array(deleted);
    deleted = sort_array(deleted, 1);
  }
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  i = sizeof(deleted);
  while (i--) {
    reset_eval_cost();
    if ((idx = member_array(deleted[i], mesg_numbers)) > -1) {
      if (file_size(message_filename(mesg_numbers[idx], "l")) > 0) {
        convert_links(mesg_numbers[idx]);
      }
      decrement_links(mesg_numbers[idx]);
      mesg_numbers = delete(mesg_numbers, idx, 1);
      if (idx < sizeof(info) && info[idx] &&
          ((class mail_header)info[idx])->status == "N") {
        new_thingy--;
      }
      info = delete(info, idx, 1);
    }
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
}
private void send_frog(object player, string to, string from) {
   object ob;
   if (!player || !environment(player)->send_message(to)) {
      catch(ob = clone_object(POST_FROG));
      write("A small frog with a post office hat wanders up and takes "
            "your mail.\n");
      say("A small frog with a post office hat wanders up to "+
          player->query_cap_name()+" and takes "+
          player->query_possessive()+" mail.\n");
      if (find_player(to) && sscanf(from, "%*s@%*s") == 2) {
        catch(ob->move(COMM_ROOM, ob->query_mmsgin(), ob->query_mmsgout()));
      } else {
        catch(ob->move(environment(player)));
      }
      catch(ob->send_mail(to, from));
   }
}
private void send_notification(string to,
                               string from) {
    if (find_player(from) ||
        sscanf(from, "%*s@%*s") == 2) {
       call_out((: send_frog :), 0, find_player(from), to, from);
    }
}
void add_it(class mail_message mesg, int flag) {
  int i, counter, bong, ptpost;
  string *local_to, *remote_to, *fail_to, str;
  class mail_header hdr;
  if (check()) {
    return;
  }
  if (sizeof(mesg->cc)) {
    mesg->to += mesg->cc;
  }
  mesg->to = MIME->get_email_addrs(implode(mesg->to, ","))[0];
  local_to = ({ });
  remote_to = ({ });
  fail_to = ({ });
  str = "";
  bong = sizeof(mesg->to);
  for (i = 0; i < bong; i++) {
    if ((str = check_local(mesg->to[i]))) {
      if (MAIL_TRACK->query_list(str)) {
        local_to += MAIL_TRACK->query_members(str) - ({ mesg->from });
        if ( str == "playtesters" ) {
          ptpost = 1;
        }
      } else {
        local_to += ({ str });
      }
    } else {
      remote_to += ({ mesg->to[i] });
    }
  }
  local_to = uniq_array(local_to);
  remote_to = uniq_array(remote_to);
  if ((i = sizeof(local_to))) {
    if (!(counter = load_counter())) {
      if (!flag) {
        printf("Aborting send of message...\n");
      }
      return;
    }
    if (file_size(message_filename(counter, "")) > 0) {
      if (!flag) {
        printf("Fatal error when sending message: File %d exists.\n"
               "Please contact Turrican.\n", counter);
      }
      return;
    }
    for (i = 0; i < sizeof(local_to); i++) {
      if (!flag) {
        printf("Sending to: %s.\n", capitalize(local_to[i]));
      }
      if(MAIL_TRACK->find_mailer(local_to[i]) ||
         PLAYER_HANDLER->test_user(local_to[i])) {
        mesg_numbers = ({ });
        info = ({ });
        new_thingy = 0;
        unguarded((: restore_object, folder_filename(local_to[i]+"inbox") :));
        if (sizeof(info) && mapp(info[0]))
          convert_class(local_to[i], "inbox");
        if(sizeof(mesg_numbers) > MAX_FOLDER_SIZE) {
          write("Sorry, mailbox is full for " + local_to[i] + ".\n");
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        if(!PLAYER_HANDLER->test_active(local_to[i])) {
          write("Sorry, " + local_to[i] + " is inactive and so unable to "
                "receive mail.\n");
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        mesg_numbers += ({ counter });
        new_thingy++;
        hdr = new(class mail_header);
        hdr->number = counter;
        hdr->status = "N";
        hdr->subject = mesg->subject;
        hdr->from = mesg->from;
        info += ({ hdr });
        if (!unguarded((: save_object, folder_filename(local_to[i]+"inbox") :))) {
          if (!flag) {
            printf("Couldn't save mailbox for %s...\n",
                   capitalize(local_to[i]));
          }
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        if(this_player() && environment(this_player()))
          send_notification(local_to[i], mesg->from);
      } else {
        fail_to += ({ local_to[i] });
        mesg->to -= ({ local_to[i] });
        mesg->cc -= ({ local_to[i] });
        local_to = delete(local_to, i--, 1);
      }
    }
    if (i) {
      ++counter;
      save_counter(counter);
      create_new_message(counter - 1, mesg->body, i);
    }
  }
  if ((i = sizeof(fail_to))) {
    while (i--) {
      MAILER->do_mail_message(mesg->from, "postmaster", "Error! User "+
                              fail_to[i]+" unknown", 0,
                              "Original message included:\n\n> "+
                              replace_string(mesg->body, "\n", "\n> "), 1, 0);
    }
  }
  if (sizeof(remote_to) && !flag) {
    for (i = 0; i < sizeof(remote_to); i++) {
      sscanf(remote_to[i], "%*s@%s", str);
      if (str && INTERMUD_D->GetMudName(str)) {
        printf("Sorry, Intermud mail is not currently supported.  "
               "Didn't send mail to %s.\n", remote_to[i]);
        remote_to = delete(remote_to, i--, 1);
        continue;
      }
    }
    SMTP->eventSendMail(remote_to, mesg->from, mesg->body);
  }
  if (ptpost) {
    BOARD_HAND->add_message("playtesters", capitalize(mesg->from),
                            mesg->subject, sprintf( "%-=78s\n",
                            mesg->body ));
  }
}
void mark_read(string pname, string fname, int *unread) {
  int i;
  if (check()) {
    return;
  }
  if (!PLAYER_HANDLER->test_user(pname)) {
    return;
  }
  unread = uniq_array(unread);
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  if (new_thingy == sizeof(unread)) {
    return;
  }
  new_thingy = 0;
  i = sizeof(mesg_numbers);
  while (i--) {
    if (member_array(i, unread) > -1) {
      ((class mail_header)info[i])->status = "N";
      new_thingy++;
    }
    else if(i < sizeof(info))
      ((class mail_header)info[i])->status = " ";
    else
      write("\nErk, problems. The arrays don't quite match.\n");
    reset_eval_cost();
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
  new_thingy = 0;
}
int move_it(string pname, string from, string to, int number) {
  class mail_header tmphdr;
  if (check())
    return 1;
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+to) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, to);
  }
  if (member_array(number, mesg_numbers) > -1) {
    return 1;
  }
  if(sizeof(mesg_numbers) > MAX_FOLDER_SIZE) {
    return 2;
  }
  if (file_size(message_filename(number, "l")) > 0) {
    convert_links(number);
  }
  increment_links(number);
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+from) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, from);
  }
  tmphdr = info[member_array(number, mesg_numbers)];
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+to) :));
  mesg_numbers += ({ number });
  info += ({ tmphdr });
  if (tmphdr->status == "N") {
    new_thingy++;
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+to) :));
  return 0;
}
int check_empty(string pname, string fname) {
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (!sizeof(mesg_numbers)) {
    unguarded((: rm, folder_filename(lower_case(pname)+fname)+".o" :));
    return 1;
  }
  return 0;
}
string check_local(string str) {
  string name;
  if (sscanf(lower_case(str),
             "%*([\n \t]*([ \t!-;=?-~]+<)?)%([A-Za-z]+)"
             "%*((.discworld(@|$))|$)",
             name) == 3) {
    return name;
  }
  return 0;
}
int *mail_count(string pname) {
  int num;
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(pname+"inbox") :));
  if(sizeof(info) && mapp(info[0]))
    convert_class(pname, "inbox");
  num = sizeof(mesg_numbers);
  if (!mesg_numbers || !num)
    return ({ 0, 0 });
  return ({ num, new_thingy});
}
string finger_mail(string pname) {
  string ret;
  int *tmp;
  tmp = mail_count(pname);
  if(!tmp[0])
    return "No mail.\n";
  if (tmp[0] == 1) {
    ret = "1 mail message";
  } else {
    ret = tmp[0] + " mail messages";
  }
  if(tmp[1] <= 0)
    ret += ".\n";
  else
    ret += ", " + tmp[1] + " of them unread.\n";
  return ret;
}
string check_mail(string pname) {
  int *tmp;
  string ret;
  tmp = mail_count(pname);
  switch(tmp[1]) {
  case 0:
    ret = "";
    break;
  case 1:
    ret = "\nYou have %^YELLOW%^1 NEW%^RESET%^ mail message.  Go to a "
      "post office to read it.\n\n";
    break;
  default:
    ret = "\nYou have %^YELLOW%^" + tmp[1] + " NEW%^RESET%^ mail messages.  "
      "Go to a post office to read them.\n\n";
  }
  if(tmp[0] > MAX_FOLDER_SIZE) {
    ret = "\n%^BOLD%^%^RED%^You have " + tmp[0] + " messages in your inbox.  "
      "You will receive no more mail until this number is reduced below "
      "acceptable limits.%^RESET%^" + ret;
  } else if(tmp[0] > WARN_FOLDER_SIZE) {
    ret = "\n%^BOLD%^%^RED%^You have " + tmp[0] + " messages in your inbox.  "
      "This is far too many.\n  Please delete some immediately!%^RESET%^" +
      ret;
  }
  return ret;
}
private void save_counter(int counter) {
  if (check())
    return;
  unguarded((: rm, MAIL_PATH+"counter.save" :));
  unguarded((: rename, MAIL_PATH+"counter", MAIL_PATH+"counter.save" :));
  unguarded((: write_file, MAIL_PATH+"counter", ""+counter :));
}
private int load_counter() {
  string bing;
  int ret;
  if (check()) {
    return 0;
  }
  if (bing = unguarded((: read_file, MAIL_PATH+"counter" :))) {
    sscanf(bing, "%d", ret);
  } else {
    printf("The mail counter was lost. Please contact Turrican.\n");
    return 0;
  }
  return ret;
}
void set_counter(int x) {
  if(file_size(message_filename(x, "")) > 0) {
    printf("Invalid counter value: File exists.\n");
    return;
  }
  save_counter(x);
}
void dest_me() {
  destruct(this_object());
}
void delete_account(string pname) {
  string folder;
  string *folders;
  int message;
  object mailer;
  if(previous_object() != find_object( "/secure/related_files") &&
     previous_object() != find_object( "/secure/bulk_delete"))
    return;
  mailer = clone_object(MAILER);
  folders = (string *)mailer->query_folders(pname);
  destruct(mailer);
  if (!folders && file_size(folder_filename(pname+"inbox.o")) == -1)
    return;
  if (!folders)
    folders = ({"inbox"});
  foreach (folder in folders) {
    mesg_numbers = ({ });
    unguarded( (: restore_object, folder_filename(pname+folder) :) );
    if (pointerp(mesg_numbers)) {
      foreach (message in mesg_numbers) {
        reset_eval_cost();
        if (file_size(message_filename(message, "l")) > 0) {
          convert_links(message);
        }
        decrement_links(message);
      }
    }
    unguarded( (: rm, folder_filename(pname + folder + ".o") :) );
  }
  unguarded( (: rm, folder_filename(pname +".o") :) );
}

==================================================
FILE: handlers/fuel_handler.c
==================================================

#include <fuel_handler.h>
object *burners;
void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   burners = ({ });
   call_out( "consume_fuel", FUEL_TIME );
}
void add_burner( object thing ) {
   burners += ({ thing });
}
void consume_fuel() {
   burners -= ({ 0 });
   catch( burners->consume_fuel() );
   call_out( "consume_fuel", FUEL_TIME );
}
void remove_burner( object thing ) {
   burners -= ({ thing });
}
object *query_burners() {
   return burners - ({ 0 });
}
mixed *stats() {
  return ({
    ({ "burners" , sizeof( burners ) }),
    ({ "next event", find_call_out( "consume_fuel" ) }),
   });
}

==================================================
FILE: handlers/garbage.c
==================================================

nosave string *trouble = ({});
nosave mapping cloned_by = ([]);
nosave object *_rooms;
nosave int lag, lastlag, maxlag, minlag, burstlag, users;
#define DEBUG
#define MIN_TIME 219599
#define MAX_TIME 219600
#define FAULT_RATE 4500
#define ROOM_IDLE_DELAY 7200
#define ROOM_STABLE_DELAY 10800
#define NO_AUTO_REBOOT 1
#define REBOOTS_PER_CRASH 6
#define CHANGE_SPEED 6
#define SAVE_FILE "/save/garbage"
int max_time;
int crash;
int limit;
nosave int faults_prev;
nosave int stime_prev;
nosave int utime_prev;
nosave int uptime_prev;
nosave int rate_exceeded;
nosave int times_run;
#if efun_defined(get_garbage)
int get_junk(object ob){
  return ob->query_dest_other() == 0;
}
#else
int get_junk(object ob){
  if(!clonep(ob) || refs(ob) != 2 || query_shadowing(ob) ||
     environment(ob) || ob->query_dest_other())
    return 0;
  return 1;
}
#endif
nosave int id;
void create(){
  function tmp;
  mapping map;
  unguarded(function(){
    restore_object(SAVE_FILE);
    if(!max_time) {
      max_time = MAX_TIME;
      crash = 1;
      limit = 1000;
      save_object(SAVE_FILE);
    } else {
      if(crash)
        max_time -= max_time/CHANGE_SPEED;
      else
        max_time += max_time/(CHANGE_SPEED*REBOOTS_PER_CRASH);
      if(max_time > MAX_TIME)
        max_time = MAX_TIME;
      crash = 1;
      save_object(SAVE_FILE);
    }
  });
  map = rusage();
  faults_prev = map["majflt"];
  stime_prev = map["stime"];
  utime_prev = map["utime"];
  uptime_prev = uptime();
  id = call_out("housekeeping", 300);
  tmp = function(function func) {
    int diff;
    diff = real_time() - time();
    if(diff > 2){
      diff -= 2;
      lag += diff;
      if(diff > maxlag) {
        maxlag = diff;
        if(maxlag > 600) {
          master()->crash("Too much lag to recover");
          shutdown(0);
        }
      }
    }
    if(diff < minlag) {
      minlag = diff;
    }
    if(diff > 2 && (diff - lastlag > burstlag))
      burstlag = diff - lastlag;
    lastlag = diff;
    diff = sizeof(users());
    if(diff > users) {
      users = diff;
    }
    efun::call_out(func, 1, func);
  };
  call_out(tmp, 1, tmp);
}
void check_reboot() {
  int faults_now;
  int stime_now;
  int utime_now;
  mapping map;
  int reboot;
  map = rusage();
  stime_now = map["stime"];
  utime_now = map["utime"];
  faults_now = map["majflt"];
  event(users(), "inform",
        "Cpu usage for period = "+
        ((((utime_now-utime_prev) + (stime_now-stime_prev) ) / 10.0 )/
         (uptime() - uptime_prev))+"% Fault rate is "+
       (faults_now - faults_prev), "cpu");
  event(users(), "inform", "Machine lag is "+
        (lag/900) + " seconds (average) "+minlag+" seconds (min) "+
        maxlag+" seconds (max) "+burstlag+" seconds (burst)", "cpu");
  log_file("GARBAGE", "%s lag %d (%d/%d) burst %d users %d faults %d "
           "cpu %.1f%%\n",
           ctime(time())[4..18], (lag/900), minlag, maxlag, burstlag,
           users, (faults_now - faults_prev),
           ((((utime_now-utime_prev) + (stime_now-stime_prev) ) /
             15.0 )/ (uptime() - uptime_prev)));
  if(find_object("/obj/shut") && "/obj/shut"->query_time_to_crash() != 9999)
    return;
#ifndef NO_TIMED_REBOOT
  if(uptime() > max_time)
    reboot = 1;
#endif
#ifndef NO_AUTO_REBOOT
  if((uptime() > MIN_TIME) &&
     (faults_now > (faults_prev + FAULT_RATE))) {
    if(rate_exceeded) {
      reboot = 1;
    }
  } else {
    rate_exceeded = 1;
  } else {
    rate_exceeded = 0;
  }
#endif
  if(reboot) {
    shout("A'Tuin cries out: Too heavy, I need to put the Disc down for a "+
          "moment.\n");
    "/obj/shut"->shut(10);
    log_file("GARBAGE", ctime(time())[4..18]+" Auto; Faults: "+
             faults_now+", "+ faults_prev+"; uptime: "+uptime()+"; Cpu: "+
             ((((utime_now-utime_prev) + (stime_now-stime_prev) ) / 15.0 ) /
              (uptime() - uptime_prev))+
             "\n");
    call_out(function(){
      crash = 0;
      unguarded((:save_object(SAVE_FILE):));
    }, 9*60);
    return;
  }
#if efun_defined(set_check_limit)
  if(lag > 900)
    limit += 5;
  if(lag < 300)
    limit--;
  limit = set_check_limit(limit);
#endif
  faults_prev = faults_now;
  uptime_prev = uptime();
  stime_prev = stime_now;
  utime_prev = utime_now;
  users = 0;
  lag = 0;
  maxlag = 0;
  burstlag = 0;
  minlag = 900;
}
void start_cleanup() {
  int i;
  int t = real_time();
  _rooms = filter(objects((: function_exists("query_last_visited", $1) :)),
                  (: $1->query_keep_room_loaded() == 0 &&
                   $1->query_last_visited() < (time() - ROOM_IDLE_DELAY) &&
                   $1->query_last_visited() > (time() - ROOM_STABLE_DELAY):));
  for(i=(times_run % 2); i<sizeof(_rooms); i += 2)
    catch(_rooms[i]->clean_up());
  log_file("GARBAGE", "%s cleaning %d rooms. Current memory %.2fM\n",
           ctime(time())[4..18], i/2, (memory_info() / 1024000.0));
  event(users(), "inform",
        sprintf("Cleaning %d idle rooms", i/2), "cpu");
  if(real_time() - t > 1)
    log_file("GARBAGE", "%s room cleanup took %d seconds.\n",
             ctime(time())[4..18], real_time() - t);
}
void tidy_up() {
  int rmem, ocount;
  rmem = memory_info();
  ocount = reclaim_objects();
  rmem -= memory_info();
  event(users(), "inform",
        sprintf("Reclaimed %d object%s (%d byte%s)",
                ocount, (ocount == 1 ? "" : "s"),
                rmem, (rmem == 1 ? "" : "s") ), "cpu");
}
void housekeeping() {
  string *tmpkeys;
  int i;
  object *junk;
  int t = real_time();
  i = set_eval_limit(0);
  set_eval_limit(5000000);
#if efun_defined(get_garbage)
  junk = filter(get_garbage(), (:get_junk:));
#else
  junk = objects((:get_junk:));
#endif
  set_eval_limit(i);
  times_run++;
  call_out("check_reboot", 10);
  if(!(times_run % 3))
    call_out("tidy_up", 30);
  if(times_run > 4 && (times_run % 2 == 1))
    call_out("start_cleanup", 60);
  foreach(object ob in junk)
    trouble |= ({base_name(ob)});
  id = call_out((:housekeeping:), 15 * 60);
  foreach(object ob in junk) {
#ifdef DEBUG
    if(cloned_by[file_name(ob)])
      log_file("GARBAGE_DEBUG", "%O cloned by %O\n", ob,
               cloned_by[file_name(ob)]);
#endif
    reset_eval_cost();
    ob->dest_me();
  }
  tmpkeys = keys(cloned_by);
  if(sizeof(tmpkeys)>10000){
    cloned_by = ([]);
  }
#if !efun_defined(add_action)
  "/obj/handlers/livings"->remove_garbage();
#endif
  if(real_time() - t > 1)
    log_file("GARBAGE", "%s garbage cleanup took %d seconds.\n",
             ctime(time())[4..18], real_time() - t);
}
nosave private object armoury, cloner;
void cloned(object ob){
  object obcloner;
  if(!armoury)
    armoury = find_object("/obj/handlers/armoury");
  if(!cloner)
    cloner = find_object("/global/cloner");
  if(previous_object(1) != armoury && previous_object() != cloner){
    obcloner = previous_object(1);
  } else catch {
    int i = 2;
    obcloner = armoury;
    while(obcloner == armoury || obcloner == cloner)
      obcloner = previous_object(i++);
  };
  if(member_array(base_name(ob), trouble) != -1){
    string tmp = "";
#if 0
    int i, j;
    for(i = 2; i < sizeof(call_stack()); i++){
      if(!call_stack(1)[i])
        break;
      for(j = 0; j < 4; j++)
        tmp = sprintf("%s %O", tmp, call_stack(j)[i]);
      tmp += "\n";
    }
#endif
    cloned_by[file_name(ob)] = sprintf("%O\n%s", obcloner, tmp);
  }
  if((find_call_out(id) < 0) && ((uptime() - uptime_prev) > (30 * 60)))
    id = call_out((:housekeeping:), 0);
}
int query_next_reboot() {
#ifndef NO_TIMED_REBOOT
  return max_time - uptime();
#else
  return -1;
#endif
}
int query_faults_prev() {
   return faults_prev;
}
void set_max_time(int i) { max_time = i; save_object(SAVE_FILE); }
void dest_me(){
  crash = 0;
  unguarded((:save_object(SAVE_FILE):));
  destruct(this_object());
}

==================================================
FILE: handlers/gathering.c
==================================================

#include <weather.h>
#include <tasks.h>
#define INIT_FILE "/obj/gatherables/handler.dat"
class item_data {
    string skill;
    int    difficulty;
    string *season;
    mixed  quant;
    string ob;
}
mapping items = ([ ]);
void create() {
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    items = "/obj/handlers/data"->compile_data(({ INIT_FILE }));
}
mixed query_item( string name ) {
    class item_data h;
    if (!(items[name])) {
        return 0;
    }
    h = (class item_data)items[name];
    return ({ h->skill, h->difficulty, h->season, h->quant, h->ob });
}
void add_item( string name, string skill, int diff,
               string *season, mixed quant, string ob ) {
    class item_data h;
    h = new( class item_data );
    h->skill = skill;
    h->difficulty = diff;
    h->season = season;
    h->quant = quant;
    h->ob = ob;
    items[name] = h;
}
mapping query_items() {
    return items;
}
object *gather_item( string word, object player ) {
object *basket = ({ });
object *matched = ({ });
object item;
mixed  *current_item;
class item_data info;
string temp_name;
int temp_scarcity;
int result;
int quantity;
   if ( !objectp( player ) || !environment( player ) )
      return ({ });
   matched = match_objects_for_existence( word, ({ environment( player ) }) );
   if ( !sizeof( matched ) )
      return ({ });
   foreach( object temp in matched ) {
      if ( environment( temp ) == environment( player ) )
         basket += ({ temp });
      current_item = temp->query_gather();
      temp_name = "";
      temp_scarcity = 0;
      if ( !sizeof( current_item ) )
         continue;
      if ( sizeof( current_item ) != 1 ) {
         error( "When Terano recoded this, he assumed that this array would "
            "only contain one array inside it. This turned out to be "
            "wrong.\n" );
      }
      for ( int x = 0; x < sizeof( current_item[0] ); x = x + 2 ) {
         switch ( current_item[ 0 ][ x ] ) {
           case "item name":
           case "item_name":
                  temp_name = evaluate( current_item[ 0 ][ x+1 ],
               environment( player ), player );
              if ( !stringp( temp_name ) )
                    temp_name = 0;
                  break;
           case "scarcity":
                    temp_scarcity = evaluate(current_item[0][ x+1 ],
                  environment( player ), player, temp_name);
                    if ( !intp( temp_scarcity ) )
                        temp_scarcity = 0;
                    break;
         }
      }
      tell_creator( player, "Started to check for %s.\n", temp_name );
       if ( random( 100 ) >= temp_scarcity) {
         tell_creator( player, "Not found %s due to scarcity (%d).\n",
            temp_name, temp_scarcity );
         continue;
      }
      if (!items[temp_name]) {
         tell_creator( player, "Not found %s due to no info!\n",
            temp_name );
         continue;
        }
      info = items[ temp_name ];
      if ( sizeof( info->season ) ) {
          if (member_array( WEATHER->query_season(), info->season ) == -1) {
         tell_creator( player, "Not found %s: Out of season!\n",
            temp_name );
         continue;
        }
      }
      if ( stringp( info->skill ) && strlen( info->skill ) ) {
         result = TASKER->perform_task( player, info->skill ,info->difficulty, TM_FREE );
      switch( result ) {
         case FAIL:
         case BARF:
            tell_creator( player, "Not found %s: Skillcheck failed!\n",
               temp_name );
            continue;
         case AWARD:
            tell_object(player,
                  "%^YELLOW%^You have learned something new about gathering!%^RESET%^\n" );
         case SUCCEED:
         }
      }
      quantity = evaluate( info->quant, environment( player ), player,
         temp_name );
      if ( !quantity || !intp( quantity ) )
         continue;
      item = clone_object( info->ob );
        if (item->query_continuous()) {
         item->set_amount( quantity );
            basket += ({ item });
        }
        else {
         item->dest_me();
         basket += allocate( quantity, (: clone_object( $(info->ob) ) :) );
      }
      continue;
   }
   return basket;
}

==================================================
FILE: handlers/gossip_handler.c
==================================================

#include <gossip.h>
mixed *gossip;
mixed *rumours;
nosave mixed *filter_these;
private void save_stuff();
void create() {
   seteuid(getuid());
   filter_these = ({ "fuck", "fucking", "fucker", "cunt", "bitch", "shit" });
   gossip = ({ });
   rumours = ({ });
   unguarded( (: restore_object(GOSSIP_SAVE_FILE) :) );
   call_out((: save_stuff :), 10*60);
}
private void save_stuff() {
   call_out((: save_stuff :), 10*60);
   if (sizeof(gossip) > GOSSIP_KEEP_LEVEL) {
      gossip = gossip[sizeof(gossip)-GOSSIP_KEEP_LEVEL..];
   }
   if (sizeof(rumours) > RUMOUR_KEEP_LEVEL) {
      rumours = rumours[sizeof(rumours)-RUMOUR_KEEP_LEVEL..];
   }
   unguarded( (: save_object(GOSSIP_SAVE_FILE) :) );
}
void add_gossip(string name, string mess) {
   string *bits;
   int i;
   bits = explode(mess, " ");
   for (i = 0; i < sizeof(bits); i++) {
      if (member_array(bits[i], filter_these) != -1) {
         return ;
      }
   }
   gossip += ({ ({ name, mess }) });
}
varargs string remove_gossip(string match, int force)
{
  int pos, index;
  if (!match || match == "") return "Must provide a match string";;
  pos = -1;
  for (index = sizeof(gossip); index; index--) {
    if (strsrch(gossip[index - 1][1], match) != -1) {
      if (pos == -1)
        pos = index - 1;
      else if (!force) {
        return "too many matches";
      }
    }
  }
  if (pos != -1) {
    string found = "found " + gossip[pos][1] + " by " + gossip[pos][0];
    gossip = delete(gossip, pos, 1);
    return found;
  } else
    return "No match";
}
void add_rumour(string name, string mess) {
   rumours += ({ ({ name, mess }) });
   save_stuff();
}
string *query_random_gossip() {
   if (sizeof(rumours) && random(2)) {
      return rumours[random(sizeof(rumours))];
   } else {
      if (sizeof(gossip))
	 return gossip[random(sizeof(gossip))];
      else
	 return 0;
   }
}
mixed *query_gossip() {
   return gossip;
}
string *query_filter() {
   return filter_these;
}
mixed *query_rumours() {
   return rumours;
}
