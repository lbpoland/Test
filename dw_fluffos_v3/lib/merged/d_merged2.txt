# Total Tokens: 15786
# Total Files Merged: 19
# Total Characters: 52677

p_topics/rooms/add_item/item_conflicts.c
==================================================

#include "path.h"
inherit "/std/room";
object key;
void setup() {
   set_short( "'add_item' room telling about resolving item conflicts" );
   set_light( 100 );
   set_long( "This is the room telling about resolving item conflicts in "
            "items defined with add_item.\n"
            "This room still has some basic problems, and shouldn't be used "
            "as an example.\n"
            "Inside, add_item creates one "
            "object per room for its use and assigns an alias to each item "
            "pointing to this object.  Therefore it is likely that "
            "if you have multiple add_items with verbs that call functions "
            "you can run into problems.  In this room there is a fountain and "
            "a pool.  Both of these define 'toss'.  If the wrong function is "
            "called, then your function must return a 0 in order for the "
            "correct function to be called.  Otherwise you will have a bug!  "
            "Please look at this code and notice how each function checks to "
            "make sure that the appropriate pattern is used.  If this code "
            "were removed, then funny things would start to happen.:)\n" );
   add_item( "small fountain",
            ({ "long",
               "You can see a few platinum coins in the water.",
               "toss", ({ this_object(), "do_throw_fount",
                  "<number> platinum [coins|coin] into <direct:object>" })
            }) );
   add_item( "small pool",
            ({ "long", "You can see some silver coins lying around in the "
                       "pool.",
               "toss", ({  this_object(),"do_throw_pool",
                  "<number> silver [coins|coin] into <direct:object>" })
            }) );
   add_exit( "west", PATH + "args_object", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_success_thing( int pool, int silver, int no ) {
   string coinstr, poolstr, nocoins;
   if( no < 0 ) return 0;
   if( silver ) coinstr = "silver";
   else coinstr = "platinum";
   if( pool ) poolstr = "pool";
   else poolstr = "fountain";
   nocoins = no+" "+coinstr+" coins";
   if( no == 1 ) nocoins = "one "+coinstr+" coin";
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V "+ nocoins +" into a "+ poolstr +".\n", ({ }) );
   return 1;
}
int do_throw_pool( string command, object *indir, string dir_match,
                  string indir_match, mixed *args, string pattern ) {
   string nocoins;
   int no;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_pool called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> silver [coins|coin] into <direct:object>" )
      return do_success_thing( 1, 0, no );
   if( !do_success_thing( 1, 1, no ) ) return 0;
   tell_object( this_player(), "You throw coins!\n");
   return 1;
}
int do_throw_fount( string command, object *indir, string dir_match,
                   string indir_match, mixed *args, string pattern ) {
   int no, stored, ran;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_fount called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> platinum [coins|coin] into <direct:object>" )
      return do_success_thing( 0, 1, no );
   if( !do_success_thing( 0, 0, no ) ) return 0;
   tell_object( this_player(),  "*giggle*\n");
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/item_helper.c
==================================================

#include "path.h"
inherit "/std/room";
string pattern;
string verb;
void setup() {
   set_short("add_item room #15, Testing and creating a form ");
   set_light(100);
   set_long("add_item room #15, Testing and creating a form "
            +"This item is ment to help in the formulation of items."
	    +"it provides a way to use add_item without coding.  I "
	    +"will try to explain it.  *sigh* You can change the pattern and "
	    +"name of the verb construct seperately. And you can add items to "
	    +"this room.  The 'add an object named XXXX' command creates an "
	    +"object with the name XXXX useing the current verb and pattern.  "
	    +"Once you have added the item, you can look at it, and use the "
	    +"defined verb on it.  The verb will spit out all of the "
	    +"arguments to the function, like room 12.  In this way you can "
	    +"test verb patterns - since many of them don't work - without "
	    +"any coding.  It should help you get an idea how it all works.  "
	    +"\nA reference sheet.\nA stupid object.\n");
   add_exit("west",PATH+"item_conflicts","path");
   add_exit("north",MAIN,"path" );
      add_item("reference sheet",
	    "Pattern: Is the add_command pattern( parse_command): \n"
	    +"Example string = \" 'get' / 'take' %i \" \n"
	    +"Syntax:\n"
	    +"  'word'          obligatory text     \n"
	    +"  [word]          optional text       \n"
	    +"  /               Alternative marker  \n"
	    +"  %o              Single item, object \n"
	    +"  %l              Living objects      \n"
	    +"  %s              Any text            \n"
	    +"  %w              Any word            \n"
	    +"  %p              One of a list (prepositions)  \n"
	    +"  %i              Any items                     \n"
	    +"  %d              Number 0- or tx(0-99)         \n"
	    +"Things from add_command                         \n"
	    +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
	    +"Currently %s and %w behave a bit erradically... \n"
	    +"If you put 'text' before and after them it might help.\n"
	    +"Hope this helps!\n" );
   pattern = "%D";
   verb    = "use";
   add_item("stupid object"
      ,({
            "long",       "This object is used to create items in the room!\n"
            +" set object pattern to <pattern> \n"
	    +" name object verb to <verb> \n"
            +" query object  ( returns the current pattern and verb ) \n"
            +" add an object named <item>\n"
            ,"set"      ,({this_object(),"do_set","%D 'pattern' 'to' %s" })
	    ,"name"     ,({this_object(),"do_name","%D 'verb' 'to' %s" })
            ,"query"    ,"@@do_query:"+file_name(this_object())+"@@\n"
            ,"add"      ,({this_object(),"do_add","'an' %D 'named' %s" })
        }));
}
int do_set(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   pattern = (string) a5[1];
   return 1;
}
int do_name(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   verb = (string) a5[1];
   return 1;
}
int do_add(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   object *obs;
  add_item( a5[1]
      ,({
            "long",
	       "This object's name is: "+a5[1]
	        +"\nAnd it can be used with the pattern:"+pattern
		+":\nAnd verb:"+verb+":\n\n"
            ,verb      ,({this_object(),"do_use",pattern })
        }));
   obs = all_inventory(this_object());
   obs->move("/room/void");
    obs->move(this_object());
   this_player()->move(this_object());
   return 1;
}
string do_query()
{ return "\nPattern:"+pattern+":Verb:"+verb+":\n"; }
int  do_use(mixed a1, mixed a2, mixed a3, mixed a4, mixed a5, mixed a6)
{
  printf("\nThe Verb:(A1):  %O\nThe Objects(A2):\n%O\nDirect Object(A3):  %O\nIndirect Object(A4):  %O\nReturn Array(A5):\n%O\nPattern(A6):  %O\n\n",a1,a2,a3,a4,a5,a6);
  tell_object(this_player(),"Hope that worked...\n");
  return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/main.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "primary room for \"add_item\"" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This is the start room for the examples for add_item.  "
            "Essentially boring, since it's only here to start you on your "
            "way:)\n" );
   add_exit( "start", PATH +"intro", "path" );
   add_exit( "failure", PATH +"verb_failure", "path" );
   add_exit( "success", PATH +"verb_success", "path" );
   add_exit( "patterns", PATH +"verb_patterns", "path" );
   add_exit( "arguments", PATH +"func_arguments", "path" );
   add_exit( "args_int", PATH +"args_integer", "path" );
   add_exit( "args_string", PATH +"args_string", "path" );
   add_exit( "args_object", PATH +"args_object", "path" );
   add_exit( "helper", PATH +"item_helper", "path" );
   add_exit( "exit", LEARNING + "search", "path" );
   add_property( "commented functions", ({ "add_item" }) );
   add_property( "keywords", ({ "room", "add_item", "action", "command" }) );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_names.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about simple items with many names" );
   set_light( 100 );
   set_long( "This is the room telling about making simple items with many "
            "names.  To help as examples it's been filled with several items "
            "including a small note, candles and some chairs.  Look at the "
            "note to learn more.  Go east to learn about adding verbs to the "
            "items, and west to go to a simpler example.\n" );
   add_item( "small note",
            "Ok things get more complicated here.\n"
            "First of all, the mudlib adds the plural forms of an "
            "item you add to a room.  Thus, \n"
            "  add_item( \"candle\", \"Very nice.\" );\n"
            "will take care of both \"look at candle\" and \"look at "
            "candles\".\n"
            "Secondly, the code:\n"
            "  add_item( \"small note\", \"Ok things ... \n"
            "will take care of both \"look at note\" and \"look at small "
            "note\"\n"
            "And finally, the code:\n"
            "  add_item( ({ \"corridor\", \"long hallway\" }), "
            "\"It is long.\" );\n"
            "will take care of \"look at corridor\", \"look at hallway\", "
            "\"look at long hallway\" and even \"look at long hallways\".\n"
            "If you look at the hallways you'll see the message you get is "
            "not very good as it refers to a single hallway.  To make a "
            "different description when you look at a single "
            "item and all of them, you can use the optional third parameter "
            "to tell the mudlib it shouldn't try to add the plural form. "
            "Thus:\n"
            "  add_item( \"chair\", \"This chair looks about ready to fall "
            "over.\", 1 );\n"
            "  add_item( \"chairs\", \"The chairs look ready to fall "
            "over.\", 1 );\n"
            "Oh, one last thing when listing things in this manner as a rule "
            "of thumb, put the best description first.\n" );
   add_item( "candle", "Very nice." );
   add_item( ({ "corridor", "long hallway" }), "It is long." );
   add_item( "chair", "This chair looks about ready to fall over", 1 );
   add_item( "chairs", "The chairs look ready to fall over", 1 );
   add_item( "item", "You don't see any since noone coded one yet!" );
   add_item( "reference", "Like one that you would find in a theusaures." );
   add_item( "room", "It is a big room." );
   add_exit( "east", PATH +"verbs", "path");
   add_exit( "west", PATH +"intro", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #4, many verbs ");
   set_light(100);
   set_long( "add_item room #4, many verbs \n"
            "Sometimes you have two or more identical verbs - or at least "
            "identical in how you want to treat them.  Take our oak tree "
            "we can cut it, slice it, saw it, etc...  Now all of these have "
            "the same meaning. How do we do this?\n"
            "A large oak.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the tree:\n"
      "    add_item(\"large oak tree\", ({\n"
      "      \"long\",\n"
      "              \"It looks like it is very well protected.\"\n"
      "      ({\"cut\",\"slice\",\"saw\",\"destroy\",\"kill\" }),\n"
      "              \"It seems to have no effect.\\n\"       }});\n\n"
      "Pretty obvious hunh?  Note that kill probably does not work( I "
      "say probably cuz things might change)  That is beacuse user commands "
      "have precidence over object actions in rooms.  Also be aware that a "
      "add_action on an item that a person is holding will most likely stop "
      "your verbs from being used (unless it's coded right:).  Soul commands "
      "do not have precedence, however.  So verbs like \"pick\" which would "
      "normally say \"You pick your nose\" can be trapped appropriately.\n"
   }) );
   add_item("large oak", ({
      "long", "It looks like it is very well protected.",
      ({ "cut", "slice", "saw", "destroy", "kill" }),
        "It seems to have no effect.\n" }) );
   add_exit( "east", PATH +"action_verbs", "path");
   add_exit( "west", PATH +"verbs", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/path.h
==================================================

#include <learning.h>
#define PATH HELP +"rooms/add_item/"
#define MAIN PATH +"main"

==================================================
FILE: learning/help_topics/rooms/add_item/verb_failure.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #7, verb failure messages ");
   set_light(100);
   set_long("add_item room #7, verb failure messages\n"
            +"Let us continue with our rat.  Sometimes the general failure "
            +"message just dosn't cut it.  When the player fails to  "
            +"touch our rat, the mud should tell him/her nicely and not "
            +"let them think they messed up.  This rat does just that.  "
            +"Notice that, unlike success messages, failure messages go only "
            +"to the player - not to everyone in the room.  *smile* \n"
            +"A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     +"int  do_touch()\n"
             +"{\n"
	     +"   if(!random(2)) {\n"
	     +"       this_player()->add_failed_mess(previous_object(),\n"
	     +"                       \"You miss the rat!\\n\",\n"
	     +"                       ({})); \n"
	     +"        return 0;\n"
	     +"    }\n"
	     +"    return 1;\n"
	     +"}\n\n"
	     +"The add_failed_mess is a pretty complicated fella.  The first "
	     +"argument I beleve is the object that the verb failed on, ie "
	     +"the rat.  The second argument is the failure message. Since "
	     +"it is going only to the player, it is really simple to "
	     +"understand.  The third argument is the set of indirect "
	     +"that were used in the failing attempt.  I think you can "
	     +"reference there name in the message as %I.  But don't quote "
	     +"me on that.  Similarly %D can be used as a substution for the "
	     +"direct object, ie previous_object().  It is complicated.  "
	     +"If you stick to this form, you shouldn't have any problems.  "
	     +"If all else fails, read the help file on it. *giggle* \n" }));
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }));
   add_exit( "east", PATH +"verb_success", "path" );
   add_exit( "west", PATH +"action_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_touch() {
   if(!random(2)) {
      this_player()->add_failed_mess(previous_object(),
                                     "You miss the rat!\n",
                                     ({}));
      return 0;
   }
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_patterns.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #9, verb patterns ");
   set_light(100);
   set_long("add_item room #9, verb patterns\n"
            +"Outdated! see man add_command for patterns\n "
            +"As you guessed I am still holding out on you.  There is, "
            +"unfortunately, tons more!  Most things take the form: VERB "
            +"DIRECT_OBJECT or $V $D.  Add item has a limited number of "
            +"patterns that it can recognize, the first limitation is that "
            +"the verb must come first.  ie VERB PATTERN.  The default "
            +"pattern we have been using to date is %D.  We can change the "
            +"pattern!\nReference sheet.\nLarge pool.\nNote.\n");
   add_item("reference sheet",
            "Pattern: Is the add_command pattern( parse_command): \n"
            +"Example string = \" 'get' / 'take' %i \" \n"
            +"Syntax:\n"
            +"  'word'          obligatory text     \n"
            +"  [word]          optional text       \n"
            +"  /               Alternative marker  \n"
            +"  %o              Single item, object \n"
            +"  %l              Living objects      \n"
            +"  %s              Any text            \n"
            +"  %w              Any word            \n"
            +"  %p              One of a list (prepositions)  \n"
            +"  %i              Any items                     \n"
            +"  %d              Number 0- or tx(0-99)         \n"
            +"Things from add_command                         \n"
            +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
            +"Currently %s and %w behave a bit erradically... \n"
            +"If you put 'text' before and after them it might help.\n"
            +"Hope this helps!\n" );
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the pool:\n"
      +"  add_item(\"large pool\", ({  \n"
      +"       \"long\",\n"
      +"                   \"It looks like you can jump into it!\"\n"
      +"	,\"jump\",\n"
      +"		   ({ this_object(), \"do_jump\", \n"
      +"			\" 'into' / 'in' %D \"  })  \n"
      +"	 )} );\n\n"
      +"Ok. Not much different, just one more argument.  Look at the "
      +"reference sheet.  Looks complicated hunh?  The most useful ones "
      +"are %D, %I, %d, [text], 'text', and /.  I will demonstrate how to "
      +"use %d and %I in a few rooms.  I have also changed the succeed "
      +"mess, otherwise it would say: \"You jump into / in a large pool.\"  "
      +"Not good huh? *smile* Oh well on to the next room!\n" }));
   add_item( "large pool", ({
      "long", "It looks like you can jump into it!",
      "jump", ({ this_object(), "do_jump", " [into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"func_arguments", "path");
   add_exit( "west", PATH +"verb_success", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_jump() {
   this_player()->add_succeeded_mess(previous_object(),
                                     "$N $V into a pool!\n",  ({}));
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_success.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #8, verb success messages ");
   set_light(100);
   set_long("add_item room #8, verb success messages\n"
	    "Let us continue with our rat.  Suppose now that we want the "
	    "player to succeed - but that the default message is really "
	    "inappropriate.  What we want to do is change the succeed "
	    "message!  Let's say when the player goes to touch the rat "
	    "it tells him - As you touch the rat, it snarls. - "
	    "Unfortunately succeed messages are much more complicated "
	    "beacuse your message is going to two parties, the player and "
	    "other players in the room. So you can't put the words \"You\" and "
	    "\"touch\" directly into code, because \"Fred\" and \"touches\" are the "
	    "appropriate substitutions to be used for the audience.  "
	    "Furthermore, if you are useing "
	    "multiple verbs, how do you know what verb the person used? "
	    "The solution is to use $V for verb and $N for player name.\n"
	    "A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     "int  do_touch()\n"
             "{\n"
             "      this_player()->add_succeeded_mess(previous_object(),\n"
	     "        \"As $N $V $D, it snarls.\\n\",  ({}));\n"
	     "    return 1;\n"
	     "}\n\n"
	     "The only difference between add_failed_mess and this one is "
	     "the message: When the message is processed for the player, "
	     "\"You\" is substituted for $N and \"touch\" for $V.  Likewise, when "
	     "the message is processed for others: \"Fred\" is substituted for $N "
	     "and \"touches\" is substituted for $V.  If you were using multiple "
	     "verbs, the appropriate verb would be used.  There might be "
	     "other $ stuff in the docs( namely $D and $I if you have an "
	     "indirect object list.)  There might be ones for pronouns and "
	     "possessives also.  At last "
	     "resort, you can always make this string a null string! And "
	     "insert tell_other and tell_room call's directly in your code."
	     "Of course add_failed_mess and this one can be used together in "
	     "the same code...\n" }));
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched.",
		"touch",
                           ({ this_object(), "do_touch" }) }));
   add_exit("west",PATH+"verb_failure","path");
   add_exit("east",PATH+"verb_patterns","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int  do_touch()
{
  this_player()->add_succeeded_mess(previous_object(),
	            "As $N $V $D, it snarls.\n",  ({}));
    return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #3, verbs ");
   set_light(100);
   set_long("add_item room #3, verbs \n"
            "As you know, things can be read, kicked, etc... in DiscWorld.  "
            "Therefore we need to make our items respond to actions.  The "
            "old way to do this is through add_action.  Unless you are "
            "experienced, you should not use this function.  add_item "
            "provides many facilities to do this which are much better to "
            "write, easier to understand, and have less chance of 'bugging' "
            "out on you.\nA large oak.\nA note.\n\n");
   add_item("note", ({ "long", "It can be read.",
      "read", "As you can see, this note can be read, "
      "this is our first introduction to verbs.  "
      "The code that does this:\n"
      "      add_item(\"note\", ({ \"long\", \"It can be read.\" \n"
      "                          \"read\", \"As you can see ... \" }) );\n"
      "This uses a mixed variable in the description part of the "
      "add_item.  The members of the mixed variables are strings which "
      "come in pairs.  Notice that \"long\" is not \"look\" this is just "
      "a simple way to specify a whole range of verbs that return this "
      "description, namely:  look, examine, ... \n"
      "After printing out the message the add_item program prints out to "
      "the person reading the note: \"You read a note.\"  More generally:  "
      "\"You <verb> <indefinate artical> <item>.\"  Similarly everyone "
      "else in the room sees:  \"Fred reads a note.\"\n\nA description of "
      "the tree can be found in treenote.\n" }));
   add_item("treenote", ({ "long", "Read it nim wit!",
      "read", "Here is the add_item for the oak:\n"
      " add_item( ({\"large oak tree\",\"large oak\"}) , ({  \n"
      "      \"long\",\"It looks like it can be climbed and cut.\"\n"
      "      \"climb\",\"You get half way up, and climb back down.\\n\"\n"
      "      \"cut\",\"You cannot hurt this tree!\\n\"  })); \n\n"
      "Oh joy.  Notice that it always prints out:\n"
      "   \"You <verb> a large oak.\" \n"
      "It picks the first description of the item from the mixed array.\n"
      "Some times you can interfere with item commands or soul commands "
      "by installing these actions. But, the interference would be more "
      "if you used add_action!.\n" }));
   add_item( ({ "large oak tree", "large oak" }) , ({
      "long", "It looks like it can be climbed and cut.",
      "climb", "You get half way up, and climb back down.\n",
      "cut", "You cannot hurt this tree!\n" }) );
   add_exit( "east", PATH +"many_verbs", "path" );
   add_exit( "west", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/situations/path.h
==================================================

#include <learning.h>
#define SIT "/d/learning/help_topics/rooms/situations/"

==================================================
FILE: learning/help_topics/rooms/situations/sitroom1.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/room";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Basic situation example room");
  set_light(100);
  set_long("This is a very simple situation example.  "
           "To start it \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom2", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "button", "There is a button on the wall you might \"press\".");
  add_situation( "frog",
    new(class situation,
        start_mess: "A little frog appears from nowhere.\n",
        extra_look: "There is a little frog here.",
        add_items: ({ ({ "frog", "The frog is small but happy." }) }),
        chat_rate: ({ 10, 30 }),
        chats: ({"The little frog hops on the spot.",
                 "The little frog says:  Ribbit." }) ,
        end_mess: "The little frog disappears into thin air."
    )
  );
}
int do_press()
{
  tell_object(this_player(),"You press the button.\n");
  tell_object(this_player(),"%^YELLOW%^You just started the frog situation.  "
              "It will go for 60 seconds.  It adds an add_item ( look frog ), "
              "an extra_look to the room ( look ) and some chats.%^RESET%^\n");
  change_situation( "frog", 60 );
  return 1;
}
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom2.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Combination of situations example room");
  set_light(40);
  set_long("This is a combination of situations example.  "
           "It is outside in a dark neighbourhood.  "
           "To start a combination of situations \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom3", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "button", "There is a button on the wall you might \"press\".");
  add_item( "house", "There are old wooden houses here.");
  add_situation( "house",
    new(class situation,
      add_items: ({
        ({ "nearby house", "The wooden house has thin walls so you can "
             "easily hear what goes on inside." }),
        ({ "voice", "There are voices coming from a nearby house here." })
            }),
      end_mess: "You hear running footsteps in the alley on the other side "
             "of the house.\nThe nearby wooden house falls eerily silent."
    )
  );
  add_situation( "argue",
    new(class situation,
      chats:({"A man yells shrilly, something that sounds like an accusation.",
        "A man with a deep voice threatens loudly.",
        "A woman's voice calls for calm." }),
      chat_rate: ({ 10, 30 })
   )
  );
  add_situation( "murder",
    new(class situation,
      start_mess:"There is a loud bang, as if something fell over or "
        "was struck solidly within the wooden house here.",
      chats:({"A man says something in shocked voice.",
              "A woman's voice hisses for silence.",
              "There is the sound of something heavy being moved inside the "
              "wooden house here." }),
      chat_rate: ({ 5, 15 })
    )
  );
}
int do_press()
{
  tell_object(this_player(),"You press the button.\n");
  tell_object(this_player(),"%^YELLOW%^You just started the argue and house "                "situations.  It will go for 80 seconds and then the murder "
              "and house situations will replace it for 40 more seconds.  "
              "As house follows itself immediately it just continues without "
              "being changed and its end message is given only at the very "
              "end.%^RESET%^\n");
  change_situation( ({ "argue,house", "murder,house" }), ({ 80, 40 }) );
  return 1;
}
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom3.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
object warrior;
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Automated situations (with function pointers) example room");
  set_light(40);
  set_long("This is a combination of situations example that is automated "
           "and makes use of function pointers.  "
           "It is outside in a run down neighbourhood.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom4", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "window", "There is window up high with maroon curtains." );
  add_item( "curtain", "That is all you can see, sorry." );
  add_situation( "sew1",
    new(class situation,
      chats: ({"There is a distinct giggle.",
        "A woman's giggle drifts down from an upstairs window.",
        "A man murmurs something upstairs." }),
      chat_rate: ({ 10, 15 })
    )
  );
  add_situation( "sew2",
    new(class situation,
      start_mess: "There is a whump like something landing on a matress "
         "above.",
      chats:({
        "A high-pitched giggle reaches the street from above.",
        "There is the creak of complaining coils from an upstairs window.",
        "You can make out a muffled voice from above." }),
      chat_rate: ({ 10, 15 }),
      end_mess: "The upstairs noises stop.\nYou hear the clink of coinage.",
      end_func: (: call_out("make_warrior",5) :)
    )
  );
  add_situation( "pause", new(class situation) );
  automate_situation( ({ "sew1","sew2","pause" }), ({ 25,35,20 }),
    WHEN_ANY_TIME, 500 );
}
void make_warrior()
{
  if (warrior)
    call_out( (: $1->move( "/room/rubbish",
     "", $1->the_short()+" races off to kill something.") :), 5, warrior );
  warrior = clone_object( "/d/am/chars/am_warrior_human" );
  warrior->move(this_object(),warrior->the_short()+
    " enters the street from a building nearby looking pleased with "
    +warrior->query_objective()+"self.");
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom4.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Exclusion and random words situations example room");
  set_light(100);
  set_long("This is a of situations example that is automated "
           "and makes use of random words and exclusion.  "
           "It is at a pier where one ship may dock at a time.  "
           "Exclusion means one situation (or set of them) "
           "prevents another from happenning at the same time "
           "and vice versa.  "
           "Random words mean that the text changes each time.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "next", SIT+"sitroom5", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "pier", "There is small pier here." );
  add_situation( "boat1",
    new(class situation,
      start_mess: "A little fishing boat comes up to the pier.  "
         "It has the name \"#1\" painted on the side.\n"
         "A fisherman jumps off the boat and ties its painter to a post.",
      chats: ({"The little boat bobs up and down next to the pier.",
               "A fisherman hops off the little boat." }),
      chat_rate: ({ 20, 30 }),
      extra_look: "There is a little boat here.",
      add_items: ({ ({ ({ "#1","little boat" }),
        "There is little fishing boat tied up at the pier here.  "
        "The name \"#1\" is painted on the side."   }) }),
      end_mess: "The fishermen get back on board and "
         "the little boat moves on.",
      random_words: ({ ({ "Honey Toad", "Piker", "Bing" }) })
    )
  );
  add_situation( "boat2",
    new(class situation,
      start_mess: "A fat trading vessel comes up to the pier.  "
         "It has the name \"#1\" painted on the prow.\n"
         "A sailor jumps off and ties the vessel to a post.",
      chats: ({"The trading vessel thumps against the pier.",
               "A sailor comes ashore.",
               "#2 is unloaded from the vessel.",
               "#3 is loaded onto the vessel." }),
      chat_rate: ({ 10, 20 }),
      extra_look: "There is a trading vessel docked here.",
      add_items: ({ ({ ({ "#1","fat vessel","ship" }),
        "There is a trading vessel docked at the pier here.  "
          "The name \"#1\" is painted on the prow." }) }),
      end_mess: "The sailors get back on board and "
         "the trading vessel departs.",
      random_words: ({ ({ "Fat Cat", "Scumbag", "Cap Pig" }),
          ({ "A pair of slaves", "A bale of wool", "A bolt of cloth" }),
          ({ "A stock option", "A cage of frogs", "A wooden crate" }), })
    )
  );
  automate_situation( "boat2", 61, WHEN_ANY_TIME, 300, "boat" );
  automate_situation( "boat1", 50, WHEN_ANY_TIME, 200, "boat" );
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom5.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Situation with a background state example room");
  set_light(100);
  set_long("This is a situations example that is automated "
           "and makes use of a background situation.  "
           "This means that when the automated manager has not "
           "fired up the labelled automated situations you specified "
           "there is another situation that goes by default the rest "
           "of the time.  It is marked in the list by having -1 "
           "for its duration.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_situation( "tramp_sleeping",
    new(class situation,
      chats: ({"The tramp snores." }),
      chat_rate: ({ 60,120 }),
      extra_look: "There is a tramp sleeping here.",
      add_items: ({ ({ "tramp",
        "There is dusty and fairly dirty tramp curled up and sleeping "
        "at one side of the road."   }) })
    )
  );
  add_situation( "tramp_awake",
    new(class situation,
      start_mess: "The tramp leaps to his feet, instantly alert.",
      chats: ({"The tramp produces some brightly coloured balls and juggles "
                 "them.",
               "The tramp does a handstand.",
               "The tramp leaps into the air and touches his toes.",
               "The tramp does a little dance.",
               "Dust billows from the frenetic tramp's clothes."
             }),
      chat_rate: ({ 20,30 }),
      extra_look: "There is a tramp bouncing around here.",
      add_items: ({ ({ "tramp",
        "The dusty tramp is bright eyed and very awake."  }) }),
      end_mess: "The tramp flops to the ground and slowly curls into a ball."
    )
  );
  automate_situation( ({ "tramp_sleeping", "tramp_awake" }),
                      ({ -1, 61 }) , WHEN_ANY_TIME, 300 );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_crippled_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the crippled.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":hobbles around pathetically.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a crippled beggar.  "
     "One of "+query_possessive()+
     " legs has wasted so that it ressembles a gnarled branch.\n" );
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "crippled beggar" );
   set_main_plural( "crippled beggars" );
   add_adjective("crippled");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_diseased_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the diseased.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":picks at some sores.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a diseased beggar.  "
     "Looking at the running sores covering "+query_possessive()+
     " body makes your skin crawl.\n");
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "diseased beggar" );
   set_main_plural( "diseased beggars" );
   add_adjective("diseased");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_poor_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the poor.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":looks down at the ground and sobs.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a poor beggar.  Perhaps you should give "+
            (string)query_objective() +" some money.\n" );
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "poor beggar" );
   set_main_plural( "poor beggars" );
   add_adjective("poor");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}
