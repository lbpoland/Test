# Total Tokens: 17930
# Total Files Merged: 14
# Total Characters: 59797

ite_control.c
==================================================

#include "path.h"
#include "access.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"
int do_banish(string);
int do_access();
int do_suspend(string);
int do_unsuspend(string);
void setup() {
  set_light(100);
  set_short("site-access control room");
  add_property("determinate", "the ");
  set_long(
    "In front of you teem hundreds of small packages.  They rush around "+
    "yelling out strange numbers and get directed into various parts "+
    "of the maze by large mice with red flags.  Everything happens at "+
    "break neck speed.  Every now and then one of the packages "+
    "spontaneously combusts.\n"+
"Available commands:\n"+
"  ban       :  Ban a site.\n"+
"  access    :  Show the current access of various sites.\n"+
"  suspend   :  Suspend someones access.\n"+
"  unsuspend :  Unsuspend someones access.\n");
  seteuid("Admin");
  add_exit("north", ROOM+"domain_control", "corridor");
}
#if efun_defined(add_action)
#define NUM
#else
#define NUM 1
#endif
void init() {
  ::init();
  if (!interactive(previous_object(NUM))) return 0;
  if ("/secure/master"->query_lord(geteuid(previous_object(NUM))))
    add_command("ban", "<string>", (:do_banish($4[0]):));
  add_command("access", "", (:do_access():));
  add_command("suspend", "<string'person'>", (:do_suspend($4[0]):));
  add_command("unsuspend", "<string'person'>", (:do_unsuspend($4[0]):));
}
int print_access(string bit, mapping bing, int depth, int cols) {
  mixed *bits;
  int i;
  if (this_player() != this_player(1))
    return 0;
  bits = m_indices(bing);
  if (depth == 4) {
    for (i=0;i<sizeof(bits);i++)
      switch (bing[bits[i]][0]) {
        case NO_NEW :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no new characters.\n");
          break;
        case NO_ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no characters.\n");
          break;
        case ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to normal access.\n");
          break;
    }
    return 1;
  }
  for (i=0;i<sizeof(bits);i++)
    print_access(bit+"."+bits[i], bing[bits[i]], depth+1, cols);
  return 1;
}
int do_access() {
  mixed bing;
  if (this_player() != this_player(1))
    return 0;
  bing = (mixed)"/secure/bastards"->query_all_access();
  if (!m_sizeof(bing)) {
    notify_fail("No access control defined.\n");
    return 0;
  }
  write("Current access list:\n");
  print_access("", bing, 0, (int)this_player()->query_cols());
  return 1;
}
int do_banish(string str) {
  string ip, ident, reason;
  int level;
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->high_programmer(geteuid(previous_object())))
    return 0;
  notify_fail("Syntax: banish <ip number> <ident> <level> <reason>\n"+
              "        <level> := 0 delete ident, 1 normal access,\n"+
              "                   2 no new players, 3 No access.\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s %d %s", ip, ident, level, reason) != 4)
    return 0;
  if (!"/secure/bastards"->change_access(explode(ip, "."), ident, level,
                                         reason))
    return 0;
  write("Access permisions changed.\n");
  return 1;
}
int do_suspend(string str) {
  string reason;
  string name;
  int tim;
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  if (!str || sscanf(str, "%s %d %s", name, tim, reason) != 3) {
    notify_fail("Syntax: suspend <name> <time> <reason>\nWhere time is in hours.\n");
    return 0;
  }
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->suspend_person(name, tim*60*60, reason))
    return 0;
  write(name+" suspended until "+ctime(time()+tim*60*60)+"\n");
  return 1;
}
int do_unsuspend(string str) {
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->unsuspend_person(str))
    return 0;
  write(str+" unsuspended.\n");
  return 1;
}

==================================================
FILE: admin/room/terrain.c
==================================================

#include "path.h"
#include <terrain.h>
#define COLS (int)this_player()->query_cols()
inherit "/std/room/basic_room";
int do_help();
int do_terrain(string name);
int do_list(string what);
int do_member(string type, string params);
int do_clear();
int do_add(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level);
int do_remove(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2);
string terrain_name;
object generator;
void setup() {
   set_short( "terrain-maker room" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This room is quite bare, save a notice that has been "
         "taped on the door but its walls have been painted with "
         "scenes of deserts and forests, oceans and mountains, caves and "
         "swamps, and all manner of other types of terrain.\n"
         "Use \"help room\" to list the room's commands.\n" );
   add_exit( "northwest", ROOM +"development", "door" );
   add_sign("The large notice has furled corners and has been taped "
           "and re-taped to the door.\n",
           "Due to the incomprehensible help in this room, this \n"
           "notice was put up to help with the confusion.\n"
           "\n"
           "1.  To get information on a certain terrain, you\n"
           "    need to select that terrain by typing \n"
           "    \"terrain <terrain_name>\".\n"
           "\n"
           "2.  To remove floating or fixed locations within the terrain,\n"
           "    type \"list floating\" or \"list fixed\".\n"
           "\n"
           "    remove floating <path of terrain> <all 6 co ordinates> <level>\n"
           "\n"
           "    remove fixed <path of room>\n"
           "\n"
           "3.  To add a floating location, same as above, only use add.\n"
           "    For both removing and adding, no commas and no .c at the end\n"
           "    of path names.  When removing/adding fixed locations, all\n"
           "    locations must be done one by one.\n", 0, "notice");
}
void reset() {
   if ( !generator ) {
      generator = clone_object( "/obj/handlers/terrain_things/dungeon_maker" );
      generator->move( this_object() );
   }
}
void init() {
  ::init();
  add_command("help", "room", (: do_help() :) );
  add_command("terrain", "<string>", (: do_terrain($4[0]) :) );
  add_command("list", "fixed", (: do_list("fixed") :) );
  add_command("list", "floating", (: do_list("floating") :) );
  add_command("member", "", (: do_member(0,0) :) );
  add_command("member", "fixed <string>",
    (: do_member("fixed", $4[0]) :) );
  add_command("member", "floating <string>",
    (: do_member("floating", $4[0]) :) );
  add_command("add",
    "fixed <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_add(0, $4[0], $4[1], $4[2], $4[3], 0, 0, 0, 0) :) );
  add_command("add",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'> <number'level'>",
    (: do_add(1, $4[0], $4[1], $4[2], $4[3],
                        $4[4], $4[5], $4[6],
                 $4[7]) :) );
  add_command("add",
    "floating <word'file'> <number'x'> <number'y'> <number'z'> "
      "<number'level'>",
    (: do_add(2, $4[0], $4[1], $4[2], $4[3],
                        0, 0, 0,
                 $4[4]) :) );
  add_command("remove",
    "fixed <word'file'>",
    (: do_remove(0, $4[0], 0, 0, 0, 0, 0, 0) :) );
  add_command("remove",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'>",
    (: do_remove(1, $4[0], $4[1], $4[2], $4[3],
		 $4[4], $4[5], $4[6]) :) );
  add_command("remove",
    "floating <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_remove(2, $4[0], $4[1], $4[2], $4[3],
		 0, 0, 0 ) :) );
  add_command("clear", "", (: do_clear() :) );
}
int do_help () {
  write( "Available commands are:\n\n"+
      "     terrain  -  set terrain name\n"+
      "     list     -  list locations in current terrain\n"+
      "     member   -  find locations matching coordinates\n"+
      "     add      -  add a new location\n"+
      "     remove   -  remove an old location\n"+
      "     clear    -  clear all clones and connections\n" );
  return 1;
}
int do_terrain( string name ) {
  if ( !name ) {
    if ( stringp( terrain_name ) )
      write( "Terrain name is "+ terrain_name +".\n" );
    else
      write( "There is no terrain name set.\n" );
    return 1;
  }
  write( "Terrain name set to "+ name +".\n" );
  terrain_name = name;
  return 1;
}
int do_list( string word ) {
  int i, size;
  string list;
  mapping locations;
  mixed indeces, values;
  if ( ( word != "fixed" ) && ( word != "floating" ) ) {
    write( "List what? Options are \"fixed\" and \"floating\".\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if ( !( (int)TERRAIN_MAP->get_data_file( terrain_name ) ) ) {
    write( "There are no locations in the terrain "+ terrain_name +".\n" );
    return 1;
  }
  if ( word == "fixed" ) {
    locations = (mapping)TERRAIN_MAP->query_fixed_locations( terrain_name );
    size = m_sizeof( locations );
    indeces = m_indices( locations );
    values = m_values( locations );
    if ( !size ) {
      write( "There are no fixed locations in the terrain "+ terrain_name
                +".\n" );
      return 1;
    }
    list = "The terrain "+ terrain_name +" has the following fixed location"+
              ( size == 1 ? "" : "s" ) +":\n";
    for ( i = 0; i < size; i++ )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, indeces[ i ] +
          " at ("+ values[ i ][ 0 ] +", "+ values[ i ][ 1 ] +", "+
          values[ i ][ 2 ] +")" );
    this_player()->more_string( list, "Fixed" );
    return 1;
  }
  locations = (mapping)TERRAIN_MAP->query_floating_locations( terrain_name );
  size = sizeof( locations );
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name
              +".\n" );
    return 1;
  }
  list = "The terrain "+ terrain_name +" has the following floating "+
      "location"+ ( size == 1 ? "" : "s" ) +":\n";
  for ( i = 0; i < size; i++ )
    if ( sizeof( locations[ i ][ 1 ] ) == 3 )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " at ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +"), level "+ locations[ i ][ 2 ] );
    else
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " from ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +") to ("+ locations[ i ][ 1 ][ 3 ] +
          ", "+ locations[ i ][ 1 ][ 4 ] +", "+ locations[ i ][ 1 ][ 5 ] +
          "), level "+ locations[ i ][ 2 ] );
  this_player()->more_string( list, "Floating" );
  return 1;
}
int do_member( string type, string parameters ) {
  int i, size, *co_ords;
  string list, location;
  mixed *locations;
  if (!type || !parameters) {
    write( "Syntax: member <fixed|floating> <coord1> ...\n" );
    return 1;
  }
  if ( ( type != "fixed" ) && ( type != "floating" ) ) {
    write( "Syntax: member <fixed|floating> ...\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  co_ords = allocate( 3 );
  if ( type == "fixed" ) {
    if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ],
        co_ords[ 2 ] ) != 3 ) {
      write( "Syntax: member fixed <coord1> <coord2> <coord3>\n" );
      return 1;
    }
    TERRAIN_MAP->get_data_file( terrain_name );
    location = (string)TERRAIN_MAP->member_fixed_locations( co_ords );
    if ( !location ) {
      write( "There is no fixed location in the terrain "+ terrain_name +
          " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
          ").\n" );
      return 1;
    }
    write( "The terrain "+ terrain_name +" has "+ location +" as a fixed "+
        "location at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ], co_ords[ 2 ] )
      != 3 ) {
    write( "Syntax: member floating <coord1> <coord2> <coord3>\n" );
    return 1;
  }
  TERRAIN_MAP->get_data_file( terrain_name );
  locations = (mixed *)TERRAIN_MAP->member_floating_locations( co_ords );
  size = sizeof( locations ) / 2;
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name +
        " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  list = "There "+ ( size == 1 ? "is one floating location" : "are "+
      query_num( size ) +" floating locations " ) +" in the terrain "+
      terrain_name +" at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+
      co_ords[ 2 ] +"):\n";
  for ( i = 0; i < size; i++ )
    list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ 2 * i ] +
        ", level "+ locations[ 2 * i + 1 ] );
  this_player()->more_string( list, "Member" );
  return 1;
}
int do_add(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 0 || floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if (floating == 0) {
    if ( !TERRAIN_MAP->add_fixed_location( terrain_name, file, co_ords ) ) {
      write( "The fixed location "+ file +" in the terrain "+ terrain_name
                +" already exists.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been added to the terrain "+
        terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +").\n" );
    return 1;
  }
  TERRAIN_MAP->add_floating_location( terrain_name, file, co_ords, level );
  if ( sizeof( co_ords ) == 6 )
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
        ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") at level "+ level +".\n" );
  else
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") and level "+ level +".\n" );
  return 1;
}
int do_remove(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else if (floating == 1) {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if ( floating == 0 ) {
    if ( !TERRAIN_MAP->delete_fixed_location( terrain_name, file ) ) {
      write( "There is no fixed location "+ file +" in the terrain "+
          terrain_name +" to remove.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been removed from the terrain "+
        terrain_name +".\n" );
    return 1;
  }
  if ( !TERRAIN_MAP->delete_floating_location( terrain_name, file, co_ords ) ) {
    if ( sizeof( co_ords ) == 6 )
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
          co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
          ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") to remove.\n" );
    else
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
          ", "+ co_ords[ 2 ] +") to remove.\n" );
    return 1;
  }
  if ( sizeof( co_ords ) == 6 )
    write( "The floating location using "+ file +" in the terrain "+
        terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +", "+
        co_ords[ 4 ] +", "+ co_ords[ 5 ] +") has been removed.\n" );
  else
    write( "The floating location using "+ file +" in the terrain "+
      terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
      ", "+ co_ords[ 2 ] +") has been removed.\n" );
  return 1;
}
int do_clear() {
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  TERRAIN_MAP->clear_cloned_locations( terrain_name );
  TERRAIN_MAP->clear_connections( terrain_name );
  write( "Clones and connections cleared for the terrain "+ terrain_name +
      ".\n" );
  return 1;
}

==================================================
FILE: admin/room/we_care/club_room_controller.c
==================================================

#include <clubs.h>
inherit "/std/room/controller/club_room_controller";
#include <room/club_room.h>
void setup() {
   set_save_file("/d/admin/save/club_room");
   set_board_associated(1);
   add_controlled_ownership("main room",
                            CLUB_ROOM_CONTROLLER_DISCUSSED,
                            CLUB_ROOM_OWNED_POSITION,
                            (: CLUB_HANDLER->query_president_position($2) :));
}

==================================================
FILE: admin/room/we_care/main_club_room.c
==================================================

#include "path.h"
inherit "/std/room/club_room";
void setup() {
   set_short("main club room");
   set_long("The main club room.\n");
   set_club_controller(CONTROLLER);
   set_light(70);
   set_leave_exit("south");
   add_exit("south", "/d/admin/room/meeting", "door");
}

==================================================
FILE: admin/room/we_care/owned_room1.c
==================================================

inherit "/std/room/inherit/club_owned_room";
#include "path.h"
void setup() {
   set_short("The first owned room");
   set_long("A room that is owned.\n");
   set_club_controller(CLUB_CONTROLLER);
   set_club_owned_id("main office");
}

==================================================
FILE: admin/room/we_care/path.h
==================================================

#define CONTROLLER "/d/admin/room/we_care/club_room_controller"

==================================================
FILE: admin/obj/bingle.c
==================================================

inherit "/std/object";
void setup() {
  set_name("domainer");
  set_long(
"This object shows you all of the creators who are in each domain and those "+
"that don't have directorys, are not cretors and ones who are not in a "+
"domain at all.\nThe command to view all this is \"info\".\n");
}
void init() {
  add_action("do_info", "info");
}
int do_info(string str) {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;
  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = get_dir("/d/");
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!"/secure/login"->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
    creators -= mem;
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!"/secure/login"->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
}

==================================================
FILE: admin/obj/check.c
==================================================

#define SAVE_FILE "/d/admin/log/"
string *paths, *cloned_by;
int *times;
mapping illegal;
void dest_me()
{
   destruct(this_object());
}
void create()
{
   illegal = ([ ]);
   paths = ({ });
   cloned_by = ({ });
}
void log_file()
{
   int p;
   string *person, *filename;
   filename=m_indices(illegal);
   person=values(illegal);
   if(sizeof(illegal)>0) {
      unguarded((: write_file, SAVE_FILE+"illegal.txt",
                 "\nSearch carried out on "+ctime(time())+" from here.\n" :));
      for(p=0;p<sizeof(illegal);p++) {
         unguarded((: write_file, SAVE_FILE+"illegal.txt",
                    filename[p]+"  -  on player "+person[p]+" - cloned by "+
                    cloned_by[p]+"\n" :));
      }
   }
}
void check_sub_inv(object *things, object owner)
{
int q, r, check;
string *pre_filename, filename, *switcher;
mixed info;
   for(q=0;q<sizeof(things);q++)
   {
      pre_filename=explode(file_name(things[q]),"#");
      filename=pre_filename[0];
      switcher=explode(filename,"/");
      if( (switcher[0]=="w") && (!owner->query_creator() ) )
      {
         illegal=illegal+([filename:owner->query_name()]);
         info = things[q]->stats();
         for(r=0; r<sizeof(info);r++)
         {
            if(info[r][0] == "cloned by")
            {
               cloned_by = cloned_by + ({ info[r][1] });
            }
         }
           destruct(things[q]);
       }
      if ( (!owner->query_creator()) && (sizeof(switcher)>2) && (switcher[0]=="obj") && (switcher[1]=="misc") )
      {
         switch(switcher[2]){
         case "mailer_ob":
         case "board_mas":
            info = things[q]->stats();
            for(r=0; r<sizeof(info);r++)
            {
               if(info[r][0] == "cloned by")
               {
                  cloned_by = cloned_by + ({ info[r][1] });
               }
            }
            illegal=illegal+([filename:owner->query_name()]);
             destruct(things[q]);
            break;
         }
      }
   }
}
void check_inv(object player)
{
int q;
object *things, *contents, owner;
   things=deep_inventory(player);
   owner=player;
   check_sub_inv(things, player);
}
do_seek()
{
   int p;
   object *everyone_on;
   seteuid("Admin");
   everyone_on = users();
   for(p=0;p<sizeof(everyone_on);p++)
   {
      check_inv(everyone_on[p]);
   }
   log_file();
   return 1;
}

==================================================
FILE: admin/obj/inv_check.c
==================================================

#include <playtesters.h>
#include <move_failures.h>
#define FILENAME "/save/inv_check"
int do_seek();
nosave string to_log;
string *forbidden = ({ });
void save_me() {
  unguarded ((: save_object (FILENAME) :));
}
void dest_me() {
   destruct( this_object() );
   save_me();
}
void create() {
  seteuid( "Admin" );
  unguarded ((: restore_object (FILENAME) :));
  do_seek();
}
void log_it() {
   if( sizeof( to_log ) > 0 ) {
      log_file( "ILLEGAL_OBJECT",
               "Illegal objects removed %s\n%s\n",
               ctime( time() ),
               to_log );
   }
}
void check_sub_inv( object *things, string owner, object owner_ob ) {
   string *pre_filename, filename, *switcher;
   object *obs, thing;
   object *contents, *fragile;
   string mess = "";
   object bag;
   obs = ({ });
   foreach ( thing in things ) {
     if ( thing->query_property( "virtual name" ) ) {
       filename = thing->query_property( "virtual name" );
     } else {
       pre_filename = explode( file_name( thing ),"#" );
       filename = pre_filename[ 0 ];
     }
      switcher = explode( filename, "/" );
      if( ( switcher[0]=="w" ) &&
          ( !"/obj/handlers/playtesters"->query_playtester( owner ) ) ) {
         to_log += sprintf("%s in %s, cloned by %s\n",
                           filename, owner,
                           (string)thing->query_cloned_by() );
         obs += ({ thing });
      }
      if ( ( sizeof( switcher ) > 2 ) &&
          ( switcher[ 0 ] == "obj" ) &&
          ( switcher[ 1 ] == "misc" ) ) {
         switch(switcher[2]){
          case "mailer_ob":
            if ( !"/obj/handlers/playtesters"->query_playtester( owner ) &&
                 ( !owner_ob->query_property("allowed mailer")) ) {
               to_log += sprintf("%s in %s, cloned by %s\n",
                                 filename, owner,
                                 (string)thing->query_cloned_by() );
               obs += ({ thing });
            }
            break;
          case "board_mas":
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            break;
         }
      }
      if (sizeof (switcher) ==4 &&
        switcher [0] == "d" &&
        switcher [1] == "liaison" &&
        switcher [2] == "items") {
           to_log += sprintf("%s in %s, cloned by %s\n",
                             filename, owner,
                             (string)thing->query_cloned_by() );
           obs += ({ thing });
      }
      reset_eval_cost();
      if (member_array (filename, forbidden) != -1) {
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            thing->add_property ("no recycling", 1);
            if (function_exists ("query_max_weight", thing)) {
              contents = all_inventory (thing);
            }
      }
   }
   if ( sizeof( obs ) ) {
      tell_object (owner_ob, owner_ob->colour_event ("say", "%^CYAN%^") +
        "A small official looking dwarf walks up to you and says: In "
        "accordance with paragraph 5, sub-paragraph 7 of the Domestic "
        "& Domesticated Animals (Care & Protection) Act, 1673, I hereby "
        "remove from you: "+ (string)query_multiple_short( obs, "one" )
        + ".%^RESET%^");
      if (sizeof (contents)) {
        mess += "\nThe dwarf removes all the inventory from the confiscated "
          "items.";
        fragile = filter (contents, (: $1->query_property("fragile") :));
        if (sizeof (fragile)) {
          mess += "\nHe hands " + query_multiple_short (fragile) + " to "
            "you.\n";
          contents -= fragile;
          fragile->move (owner_ob);
        }
        if (sizeof (contents)) {
          bag = clone_object ("/obj/baggage");
          bag->set_name ("bag");
          bag->set_short ("brown paper bag");
          bag->add_adjective (({"brown", "paper"}));
          bag->set_weight(5);
          bag->set_max_weight (implode (map (contents,
            (: $1->query_complete_weight() :)),(: $1 + $2 :)) + 1);
          bag->set_value (0);
          bag->set_long ("This is a plain, brown, paper bag... the kind grubby "
            "old men are often found in possession of after leaving their "
            "local newsagent.\n");
          contents->move (bag);
          if (bag->move (owner_ob) == MOVE_TOO_HEAVY) {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and leaves it on the ground.";
          }
          else {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and hands it to you.";
          }
        }
      }
      mess += "\nHe scribbles something on a clipboard, then walks away.\n";
      tell_object (owner_ob, mess);
      obs->move( "/room/rubbish" );
      call_out( "check_obs", 7, obs );
   }
}
void check_obs( object* obs ) {
   object thing;
   foreach( thing in obs ) {
      if( thing ) {
   thing->dest_me();
      }
   }
}
void check_inv( object player ) {
   object *things;
   things = deep_inventory( player );
   check_sub_inv( things, (string)player->query_name(), player );
}
int do_seek() {
  object user;
  to_log = "";
  foreach ( user in users() ) {
    if( user && !user->query_property( "guest" ) &&
       !user->query_creator() &&
       !PLAYTESTER_HAND->query_tester (user) &&
       !user->query_property ("test character") ) {
      check_inv( user );
    }
  }
  log_it();
  call_out( "do_seek", 300 );
  return 1;
}
int query_theft_command() { return -1; }
string parse_filename (string str) {
  if (strsrch (str, ".wep") != -1 ||
      strsrch (str, ".clo") != -1 ||
      strsrch (str, ".ob") != -1 ||
      strsrch (str, ".arm") != -1 ||
      strsrch (str, ".food") != -1 ||
      strsrch (str, ".sca") != -1) {
        if (file_size(str) <= 0) {
          return 0;
        }
        else {
          return str;
        }
  }
  else {
    str = explode (str, ".c")[0];
    if (file_size(str + ".c") <= 0 ) {
      return 0;
    }
    else {
      return str;
    }
  }
}
int ban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to ban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) == -1) {
      forbidden += ({ filename });
      printf ("%s added to the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s already banned.\n", filename);
    }
  }
  return 1;
}
int unban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to unban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) != -1) {
      forbidden -= ({ filename });
      printf ("%s removed from the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s not currently banned.\n", filename);
    }
  }
  return 1;
}
string list_banned() {
  if (sizeof (forbidden)) {
    return sprintf ("Objects cloned from the following filenames "
      "will be confiscated by the dwarves:\n%s\n",
      implode (forbidden, "\n"));
  }
  else {
    return "There are no objects currently forbidden.\n";
  }
}
mixed stats()
{
  return ({
    ({ "Time until next tick", query_num (find_call_out ("do_seek"))
      + " seconds"}),
  });
}

==================================================
FILE: admin/obj/path.h
==================================================



==================================================
FILE: liaison/common.c
==================================================

#include <config.h>
#define DOM_TITLE "Liaison Domain"
#define LORD "wyvyrn"
#define DOMAIN "liaison"
#define BOSS_ROOM "/w/wyvyrn/rooms/office"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
   set_dom( DOMAIN );
   set_light( 100 );
   set_short( "Liaison Domain Common room" );
   add_property( "determinate", "the " );
   set_long("The Liaison common room looks like a comfortable place to "
            "come to after a hard day's liaising.  The large pile of stress "
            "balls sat in one corner and the drinks cabinet against a wall "
            "highlight this.  The various evil-looking devices scattered "
            "around the room seem to add character and even a slightly "
            "malicious overtone to the entire place.  There are also a "
            "few chairs scattered around the place providing welcome bum "
            "relief.  One even looks to be occupied.\n"
            "A sign is hanging on the wall.\n");
   add_alias("balls", "ball");
   add_alias("devices", "device");
   add_alias("bottles", "bottle");
   add_alias("chairs", "chair");
   add_alias("whips", "whip");
   add_alias("chains", "chain");
   add_alias("easy chair", "chair");
   add_alias("dolls", "doll");
   add_alias("armrests", "armrest");
   add_alias("cushions", "cushion");
   add_alias("strings", "string");
   add_alias("needles", "needle");
   add_item( ({"ball", "stress ball"}), "The pile of stress balls seems very "
            "inviting, albeit until you get up close and see that they are "
            "actually coated in tough plastic and tied to a pole with string - "
            "effectively ending their usefulness.  They look nice though.");
   add_item("string", "Each piece of string connects a ball to the pole, "
            "stopping the ball moving very far.  Cruel.");
   add_item("pile", "The pile of stress balls seems very inviting, albeit "
            "until you get up close and see that they are actually coated in "
            "tough plastic and tied to a pole with string - effectively "
            "ending their usefulness. They look nice though.");
   add_item("lock", "A big lock that looks completely unpickable, mainly due "
            "to it having no keyhole.  Nothing will unlock it, so you heavy "
            "drinkers are just out of luck.");
   add_item("corner", "A corner of the room. Where two walls, the ceiling "
            "and the floor meet.");
   add_item("pole", "There is a short pole hiding unobtrusively behind the "
            "stress balls and it is only through very close scruitiny that "
            "it is actually noticable at all.  The pole seems to have "
            "lots of strings coming out of it, each of which lead to a "
            "stress ball, limiting the distance it can travel.\n"
            "It is secured to the floor and cannot come out.");
   add_item("device", "Devices of differing shapes and sizes litter most "
            "of the walls - all seemingly to do with harming nasty players. "
            " From the voodoo dolls in one corner to the rack in another, "
            "not to mention the whips and chains.  Serious stuff.");
   add_item("whip", "I told you not to mention them.");
   add_item("chain", "I told you not to mention them.");
   add_item("bottle", "The bottles line the inside of the cabinet, all "
            "different shapes and sizes of bottles.  Green bottles, "
            "blue bottles, red bottles, bottles with caterpillers in, "
            "bottles with toads in, bottles with DUCKs in, bottles "
            "with labels on, bottles with warnings on, bottles with "
            "skulls and crossbones on, so basically, lots of bottles.");
   add_item("cabinet", "The drinks cabinet is leaning idly against a "
            "wall [as much as a drinks cabinet can] and seems to sneer "
            "at you [as much as a drinks cabinet can].  The polished "
            "glass of the cabinet windows show all the drinks that "
            "seem to look smug [as much as bottles can].  The large "
            "lock holding the cabinet shut makes the bottles "
            "completely out of range.\n"
            "If you are really desperate, "
            "clone /w/lucifer/misc/blasterbottle.c and go nuts.");
   add_item("glass", "It's just some glass in the cabinet.  Nothing "
            "special.");
   add_item("chair", "The easy chairs that line the walls are "
            "pretty nondescript: big "
            "deep cushions and fluffy armrests, but that's all "
            "they are - and ever will be: chairs.  "
            "As a profound sense of misery sweeps over you, you "
            "notice one of the chairs is occupied by a rather "
            "despondant looking man.");
   add_item("doll", "The voodoo dolls lie in a messy pile in a "
            "corner of the room, looking particularly morbid with "
            "a hundred different needles sticking out at various "
            "points of their doll bodies.  The faces of the dolls "
            "are hard to make out, seeming to shift from likeness to "
            "likeness as you look at them.  There is a barrier in front "
            "of the dolls, suggesting they shouldn't be touched.");
   add_item("barrier", "A thick looking piece of metal completely blocking "
            "all access to the dolls.  Most probably for the best, too.");
   add_item("needle", "The needles are -unsurprisingly- sharp things "
            "currently embedded into the dolls, no doubt causing extreme "
            "pain.  Well, at least they would if the dolls were real. "
            "Which they aren't.  Which is a good thing.");
   add_item("rack", "The rack is a vicious looking instrument that allows "
            "the human [or non-human] body to be stretched to completely "
            "wrong proportions.  This is something that should be used "
            "with extreme caution.  Happily, it appears not to have been "
            "used yet [there is a still plastic covering on it] and long "
            "may it stay that way.");
   add_item("covering", "Mercifully there is a covering on the rack, "
            "showing it has never been used.  Which is a good thing.");
   add_item("armrest", "It's an armrest.  You rest your arm on it.");
   add_item("wall", "It's a wall.  That's about it.");
   add_item("cushion", "It's a cushion. You rest your bum on it.");
   add_item("man", "The man seated in one of the easy chairs looks "
            "to have resigned himself to a lifetime there, and "
            "from what you can see there appears to be a deep "
            "groove in the chair from his body shape.\n"
            "He notices you looking at him and speaks slowly, like he "
            "has nearly forgotten how: 'Do you know how long Moonchild "
            "will be? I've been waiting here for over 5 years now! I "
            "missed the fall of quest XP and everything - just because "
            "I wanted my items back!'\n"
            "As the man starts to froth at the mouth, you hurriedly turn "
            "your back on him and leave him to his waiting.");
   add_sign("This is a sign.  But then you knew that, or at least we hope "
            "you did.\n",
            "Commands available here are:\n"
            "add <name>   : add <name> as one of your characters.\n"
            "remove <name>: remove <name> as one of your characters.\n"
            "list [<name>]: list characters added for you or <name>.", 0, 0, 0);
   board = clone_object("/obj/misc/board");
   board->set_datafile(DOMAIN);
   board->move(this_object());
   add_exit("office", "/w/wyvyrn/rooms/study", "door");
   add_exit("drum", CONFIG_START_LOCATION, "path");
   add_exit("corridor", "/d/liaison/cre_corridor", "door");
   add_exit("interview", "/d/liaison/utils/interview", "door");
   BOSS_ROOM->add_exit("common", "/d/"+DOMAIN+"/common", "door");
}
void init() {
   this_player()->add_command( "add", this_object(), "<word> <word>" );
   this_player()->add_command( "add", this_object(), "<word>" );
   this_player()->add_command( "remove", this_object(), "<word> <word>" );
   this_player()->add_command( "remove", this_object(), "<word>" );
   this_player()->add_command( "list", this_object(), "" );
   this_player()->add_command( "list", this_object(), "<word>" );
}
int do_add( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->add_member_alias( args[ 0 ],
                                                    args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                args[ 1 ] +" added as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can add aliases to others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->add_member_alias( this_player()->query_name(),
                                                 args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                args[ 0 ] +" added as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                "Couldn't add "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_remove( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->delete_member_alias( args[ 0 ],
                                                       args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                    args[ 1 ] +" removed as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can remove aliases for others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->delete_member_alias(
                 this_player()->query_name(), args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                 args[ 0 ] +" removed as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                 "Couldn't remove "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_list( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   string *names, name;
   int i;
   switch( pattern ) {
    case "<word>":
      name = args[ 0 ];
      break;
    case "":
      name = this_player()->query_name();
      break;
   }
   names = "/d/liaison/master"->member_alias( name );
   name = capitalize( name );
   i = sizeof( names );
   if ( i ) {
      if ( i > 1 ) {
         while ( i-- ) {
            names[ i ] = capitalize( names[ i ] );
         }
         this_player()->add_succeeded_mess( this_object(),
                "Aliases for "+ name +" are "+
                query_multiple_short( names )+".\n" );
      } else {
         this_player()->add_succeeded_mess( this_object(),
                "Alias for "+ name +" is "+
                capitalize( names[ 0 ] )+".\n" );
      }
   } else {
      this_player()->add_succeeded_mess( this_object(),
             "No aliases known for "+ name +".\n" );
   }
   return 1;
}

==================================================
FILE: liaison/cre_corridor.c
==================================================

inherit "/std/room/basic_room";
string do_mirror();
void setup() {
    set_short("Liaison hallway");
    set_light(100);
    add_property("determinate", "the ");
    set_long("This is the homely corridor of the Liaison Domain.  There are "
             "a lot of doors leading off here, hopefully taking the plucky "
             "entrant a-wandering into Liaison workrooms.  Exercise caution "
             "as some Creators prefer you to ask or at least knock first.  "
             "Apart from the doors here there are some paintings of various "
             "people, as well as a large floor to ceiling mirror. Taking "
             "pride of place on one of the walls, however, is an ancient "
             "looking scroll housed in a picture frame.  There is "
             "also a sign here.\n");
    add_item("doors", "Lots of doors.  Tall doors, short doors, red doors, "
             "blue doors, green doors, thin doors, wide doors, old doors, "
             "grimy doors, wooden doors, metal doors and even a padded "
             "red linonium door - kinky.  However, you can only go through "
             "the doors marked in the exits, sorry.");
    add_item("paintings", "Paintings of people who have been important to "
             "the domain.  There's one of Ohdamn, Moonchild, Olorin, Shalla, "
             "Kaea, Nevvyn, Wyvyrn and - strangely enough - You.");
    add_item("painting of ohdamn", "The painting of Ohdamn shows a very "
             "tall man with reddish blond hair.  He appears to be carrying "
             "a box of chocolates and looks to be in the middle of a rousing "
             "love song, which may have something to do with the bottle of "
             "rum in his other hand.");
    add_item(({"mission", "scroll", "statement"}), "It's the liaison "
             "statement of mission!\n"
             "Or mission statement, if you would prefer.\n\n"
             "Our mission in the Liaison Domain is to give continuous "
             "support to the creator and player bases and facilitate "
             "communcation between them.\n"
             "Through a diverse range of activities, we aim to maintain "
             "Discworld MUD as an enjoyable, interesting, in-theme and "
             "safe virtual space.\n"
             "We seek to contribute to Discworld MUD as a visible and helpful "
             "helpful first point of creator contact for players.  Additionally, "
             "we will work within assigned creator areas to assist in the "
             "development and implementation of concepts.\n\n"
             "Impressive, huh?");
    add_alias("mission", "statement");
    add_item("frame", "It's just a frame holding a large scroll in place.");
    add_item("hair", "It's hair.  It's reddish blond and it's Ohdamn's.");
    add_item("rum", "It's rum.  Held very securely by Ohdamn.");
    add_item("chocolates", "They are chocolates.  On Ohdamn's painting.");
    add_item("painting of moonchild", "The painting of Moonchild shows a "
             "looming lady with a big whip and an evil grin.  She appears "
             "to be half in shadows.");
    add_item("whip", "A fearsome looking whip that seems to fit well in "
             "Moonchild's hand.");
    add_item("painting of olorin", "Olorin's picture appears to be only "
             "half done - as if the artist didn't have time to finish it.");
    add_item("painting of shalla", "Shalla's painting depicts a pretty "
             "lady and although she is fully clothed, your attention is "
             "drawn to her socks.  Strange.");
    add_item("socks", "Stop looking - that's illegal in some countries!");
    add_item("painting of kaea", "Kaea's painting shows a young lady with a "
             "silly looking grin on her face and giggling.  Seems to say it "
             "all really...");
    add_item("painting of nevvyn", "The painting of Nevvyn shows a man with a "
             "pint hefted in a salute and a cheeky looking grin on his face.");
    add_item("pint", "A half empty pint in Nevvyn's hand.  Says it all!");
    add_item("painting of wyvyrn", "Wyvyrn's painting depicts a ... well, a "
             "Wyvyrn.  He looks a bit like a dragon and has green wings - but "
             "seems to have the distinct disadvantage of looking cute.");
    add_item("wings", "Wings.  On Wyvyrn.");
    add_alias("painting of me", "painting of you");
    add_item("painting of you", "The painting of you is ... well, blank with the "
             "words 'Your Name Here' on it.  You get the feeling its a rather "
             "cheesy way of saying everyone is important!  If it wasn't so "
             "cheesy it might make you feel better.");
    add_sign("This is an important sign, for viewing along with the "
             "paintings.\n",
             "If you are having problems seeing the paintings, look at "
             "painting of <person>.  "
             "Please note: These paintings are done on collective images.  "
             "Basically, if you don't like your portrait, don't beat Luci "
             "up.  Thanks!");
    add_item("mirror", (: do_mirror() :));
    add_exit("common", "/d/liaison/common", "door");
    add_exit("drum", "/d/am/am/mendeddrum", "path");
}
string do_mirror() {
  string text;
  text = "The mirror is a full length floor to ceiling job, a full length "
    "mirror in the true sense of the word.  It's here to make sure you look "
    "you look your best.  Good job you are checking!\n\n";
  text += this_player()->long(this_player());
  tell_room (this_object(), this_player()->short() + " checks " +
    this_player()->query_objective() + "self in the big mirror.  Poser.\n",
    this_player());
  return text;
}

==================================================
FILE: liaison/master.c
==================================================

#define LORD "wyvyrn"
#define DOMAIN "liaison"
#include <liaison.h>
inherit "/std/dom/base_master";
mapping member_alias;
nosave string* member_cache = 0;
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return "eron";
}
string query_info() {
  if (file_size(LIAISON_DOMAIN_INFO) < 0) {
    return "\nFor information on this domain, please visit "
           "http:
  }
  return "\n"+ unguarded((: read_file(LIAISON_DOMAIN_INFO) :)) +"\n";
}
string *member_alias( string name ) {
   int i;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( undefinedp( members[ name ] ) ) {
      map_delete(member_alias, name);
      return 0;
   }
   if ( !member_alias[ name ] )
      member_alias[ name ] = ({ });
   i = sizeof( member_alias[ name ] );
   while ( i-- )
      member_alias[ name ][ i ] = lower_case( member_alias[ name ][ i ] );
   return member_alias[ name ] + ({ });
}
int add_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !"/secure/login"->test_user( alias ) )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   member_alias[ name ] += ({ alias });
   save_me();
   return 1;
}
int delete_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   save_me();
   return 1;
}
string *query_unsorted_members() {
    return ::query_members();
}
string *query_members() {
    string* temporary_array = ({});
    string* first = ({});
    string* seniors = ({});
    string* newbies = ({});
    if (!member_cache) {
        first = ({ query_lord() })   +
                sort_array(query_deputies(),1);
        temporary_array = ::query_members() - first;
        temporary_array = sort_array( temporary_array, 1 );
        foreach ( string person in temporary_array ) {
          if ( master()->query_senior(person) ) {
              seniors += ({ person });
          }
        }
        temporary_array -= seniors;
        foreach ( string person in temporary_array ) {
          if ( regexp( members[ person ], "^(N|n)ewbie$" ) ) {
              newbies += ({ person });
          }
        }
        temporary_array -= newbies;
        member_cache = first + seniors + temporary_array + newbies;
    }
    return copy(member_cache);
}
string *query_projects() {
    return values(members);
}

==================================================
FILE: liaison/NEWBIE/advancement.c
==================================================

#include "path.h"
inherit PATH + "inside";
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short("Advancement Room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a rather cosy room designed to encourage visitors to "
            "linger a while and read a few of the notices pinned to the "
            "walls.  The air is thick and overly warm, and there is a "
            "pervasive odour of stale tea, mothballs, and elderly ladies who "
            "collect rather more cats and string than they can properly "
            "handle.  "
            "Several overstuffed sofas have been grouped in the centre "
            "of the room along with wobbly occasional tables.  There is "
            "a small cage holding an odd-looking creature in one corner, "
            "and an immense ball of yarn in the other.  A door to the south "
            "leads back to the foyer.\n");
  add_item(({ "floor", "ground" }), "The floor is scuffed, dusty wood.  It "
           "was probably nice at some point.");
  add_item( "wall", "The walls (what can be seen of them under the notices) "
            "have been covered with a gaudy floral paper.");
  add_item(({ "paper", "wallpaper", "floral", "flower" }), "The wallpaper has "
            "a dark, muddy background covered with enormous fantasy flowers "
            "in red, blue, and yellow.");
  add_item( "door", "The plain wooden door has been propped open in an effort "
            "to let some of the stale air out.");
  add_item( "cage", "The cage is a small, rickety bamboo affair with a tiny "
            "door tied closed with a strand of wire.  It contains a strange "
            "creature.");
  add_item( "creature", "The creature is a pale, translucent colour.  It has "
            "long, spindly legs, big teeth, and eyes that glow like lamps "
            "when it is awake.  Even though it is small, you sense it would "
            "not be wise to disturb it.  It is holding a small card.");
  add_item( "wire", "The wire holding the cage door shut is a hopelessly "
            "twisted mass of spun octiron, the magical metal of Discworld.");
  add_item( "card", "The card is stamped 'Demon Local 45, Holywood' in "
            "fading ink.");
  add_item(({"ball", "yarn"}), "A large ball of string.");
  add_item("notice",
           ({ "long", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n",
                "read", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n"}));
  add_item("sofa", ({"long", "Several well-stuffed and well-worn sofas with "
                       "rather dirty, brown upholstery.",
                       "position", "a sofa",
                       "position multiple", 1 }));
  add_item("table", "A number of wobbly occasional tables made from "
           "some indeterminable kind of wood have been placed near the "
           "sofas.");
  sign=add_sign("A handwritten notice marked 'Statistics and Rearrange'.\n",
                "On Discworld your skill bonus typically determines your "
                "ability to perform a task.  Skill bonus is calculated "
                "from your skill level and your statistics.  Different "
                "stats affect different skills.\n"
                "Once you enter Discworld, you may rearrange your stats.  "
                "This should be done to improve your combination of "
                "constitution, dexterity, intelligence, strength and wisdom "
                "(your stats), but you are advised to wait until you have "
                "chosen a guild and have asked other guild members for "
                "advice.  Use the command 'rearrange' to do this, but "
                "consider it well, as you can only rearrange your stats "
                "once.\n", 0, "statistics", "general" );
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'statistics and rearrange'");
  sign=add_sign("A handwritten notice marked 'Guildpoints'.\n",
           "Guildpoints are a measure of your capability to perform guild "
           "commands such as stealing, fighting, casting spells or rituals, "
           "etc.  When you have used all your guild points, you will have to "
           "rest to allow them to regenerate.  For more information, type "
           "in 'help guildpoints'.\n", 0, "guildpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'guild points'");
  sign=add_sign("A handwritten notice marked 'Experience'.\n",
           "In addition to the direct skill advances provided by the "
           "taskmaster, quest completion, using your guild commands "
           "and by doing certain tasks, you are rewarded with "
           "experience points or XP.  These may be spent in advancing skills "
                "from your guild or by learning from other players.\n", 0,
                "experience", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'experience'");
  sign=add_sign("A handwritten notice marked 'Hitpoints'.\n",
           "Hitpoints, or HP determine how much damage you can take in "
           "combat before you die.  The number of hit points you have is "
           "dependent upon your stats (mostly Con) and on your levels of "
           "other.health.  Hitpoints regenerate gradually over time.  "
           "There are also a variety of other ways to be healed.  You "
           "can use 'monitor' to keep track of your hitpoints.  See also "
           "'help wimpy'.\n", 0, "hitpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'hitpoints'");
  sign=add_sign("A handwritten notice marked 'Skills'.\n",
           "To check your skill levels, use the command 'skills', and "
           "to see various statistics about yourself, use 'score'.  Your "
           "stats can also be reviewed using 'score stats'.  The command "
           "'help' will give you a variety of other topics with useful "
           "information.", 0, "skills", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'skills'");
  sign=add_sign("A handwritten notice marked 'advancement'.\n\n",
           "Skills can be advanced in a variety of ways on Discworld.  "
           "The guild you join will allow you to advance your skills "
           "for a certain number of experience points and a small fee.  "
           "When you reach the proper skill level your guild will "
           "teach you the commands that you will need to carry out "
           "your guild duties.\n"
           "You may also have another player teach you skills if they have "
           "a higher skill level than you, or you may teach yourself.  Both "
           "of these methods cost experience points, and it is generally more "
           "expensive to teach yourself.\n"
           "Finally, many of your skills can be advanced simply by performing "
           "tasks that make use of those skills.  For example, your fighting "
           "skills will get better as you participate in more fights.  For "
           "more information on this system, type "
           "'help taskmaster'.\n",0, "advancement", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'advancement'");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "south", "foyer");
}
