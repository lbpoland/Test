# Total Tokens: 45880
# Total Files Merged: 33
# Total Characters: 153020

==============================================

#include <config.h>
#include <board.h>
#include <bounty.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <drinks.h>
#include <library.h>
#include <living.h>
#include <login.h>
#include <login_handler.h>
#include <log.h>
#include <quest_handler.h>
#include <command.h>
#include <mail.h>
#include <player.h>
#include <skills.h>
#include <top_ten_tables.h>
#include <tune.h>
#include <weather.h>
#include <refresh.h>
#include <nroff.h>
#include <db.h>
#include <error_handler.h>
#include <player_handler.h>
#include <playerinfo.h>
#include <group_handler.h>
class player_info {
   int hb_num;
   int level;
   int level_time;
   int save_inhibit;
   int update_tmps_call_out;
   int last_save;
   object snoopee;
   mapping titles;
}
#include <clubs.h>
inherit "/global/line_ed";
inherit "/global/events";
inherit "/global/log";
inherit "/global/spells";
inherit "/global/more_string";
inherit "/global/finger";
inherit "/global/pweath";
inherit "/std/living/living";
inherit "/global/psoul";
inherit "/global/guild-race";
inherit "/global/more_file";
inherit "/global/path";
inherit "/global/start_position";
inherit "/global/family";
#define MIN_TIME_TO_SAVE 1800
#define FORGOT_CO_ORD_TIME (840553267+(8*60*60))
#define LEVEL_CACHE 60
#define ITEM_TRACKER ("/obj/handlers/item_tracker")
private nosave class player_info _pinfo;
private int time_on;
private int max_deaths;
private int monitor;
private int _refresh_time;
private int start_time;
private int creator;
private int deaths;
private int last_log_on;
private int no_logins;
private int activity_counter;
private int _flags;
private string cap_name;
private string last_on_from;
private nosave string my_file_name;
void start_player();
void public_commands();
int save();
void set_desc(string str);
void do_load_auto();
void set_name(string str);
int check_dark(int light);
void continue_start_player();
int restart_heart_beat();
int brief_verbose(string,
                  string);
int quit_alt(int verbose);
int review();
int toggle_wimpy(string);
int do_refresh(string);
int do_cap(string);
protected void set_invis(int level);
void set_player_killer(int);
int query_player_killer();
void finished_error_check( object player, string my_name, int status,
    mixed data );
void check_error_count();
void check_approve_list();
void create()
{
   if (query_name()) {
      return;
   }
   living::create();
   events::create();
   psoul::create();
   line_ed::create();
   more_string::create();
   start_position::create();
   add_property("determinate", "");
   spells::create();
   time_on = time();
   start_time = time();
   seteuid("PLAYER");
   Str = 13;
   Dex = 13;
   Int = 13;
   Con = 13;
   Wis = 13;
   set_max_sp(50);
   set_sp(50);
   wimpy = 20;
   max_deaths = 7;
   set_desc(0);
   add_ac("bing", "blunt", 15);
   add_ac("bing2", "sharp", 15);
   add_ac("bing3", "pierce", 15);
   add_property("player", 1);
   set_cols(79);
   set_rows(24);
   last_log_on = time();
   race_ob = RACE_STD;
   sscanf(file_name(this_object()), "%s#", my_file_name);
   _pinfo = new (class player_info, titles: ([ ]), save_inhibit:1);
}
void dest_me()
{
   if ((query_name() != "object") && objectp(this_player()) &&
       (this_player() != this_object()) &&
       (file_name(this_player()) != "/obj/shut") &&
       (explode(file_name(this_player()), "#")[0] != "/secure/login") &&
       (explode(file_name(this_player()), "#")[0] != "/secure/nlogin")) {
      user_event(this_object(), "inform",
                 (string) this_player()->query_name() +
                 " dests " + query_name(), "dest");
      tell_object(this_object(), "You were destructed by " +
                  capitalize((string) this_player()->query_name()) + ".\n");
   }
   if(file_size(PLAYER_HANDLER->query_player_file_name(query_name())+
                ".o.gz") > 0 &&
      PLAYER_HANDLER->query_player_disk_file_name(query_name()) &&
      PLAYER_HANDLER->query_player_file_name(query_name()) !=
      PLAYER_HANDLER->query_player_disk_file_name(query_name())) {
     unguarded((:rename,
                PLAYER_HANDLER->query_player_file_name(query_name())+".o.gz",
                PLAYER_HANDLER->query_player_disk_file_name(query_name())+
                ".o.gz" :));
   }
   ::dest_me();
}
void disallow_save()
{
   _pinfo->save_inhibit = 1;
}
void allow_save()
{
   _pinfo->save_inhibit = 0;
}
int query_save_inhibit()
{
   return _pinfo->save_inhibit;
}
int query_start_time()
{
   return start_time;
}
nomask string query_cap_name()
{
   return cap_name;
}
void move_player_to_start(string bong,
                          int new_flag,
                          string c_name,
                          string ident,
                          int go_invis) {
  string lang;
   if (file_name(previous_object())[0..12] != "/secure/login" &&
       file_name(previous_object())[0..13] != "/secure/nlogin") {
      write("You don't have clearance to do that.\n");
      return;
   }
   seteuid("Root");
   set_name(bong);
   if (!new_flag) {
      unguarded((: restore_object,
                   PLAYER_HANDLER->query_player_file_name(query_name()), 1 :));
      if (go_invis) {
        switch(go_invis) {
        case -1:
          set_invis(0);
          break;
        case 2:
          if (this_object()->query_lord()) {
            set_invis(2);
            break;
          }
        case 1:
          set_invis(1);
        }
      }
   }
   disallow_save();
   add_property("player", 1);
   cap_name = c_name;
   set_short(cap_name);
   add_property("determinate", "");
   no_logins++;
   if (!query_cols()) {
      set_cols(79);
   }
   remove_property("new player");
   if (this_player()->query_creator()) {
      seteuid(query_name());
      if (file_size("/w/" + query_name() + "/cmds") == -2)
         AddSearchPath(({ "/w/" + query_name() + "/cmds" }));
      AddSearchPath(({ DIR_PLAYER_CMDS, DIR_SECURE_PLAYER_CMDS,
                       DIR_CREATOR_CMDS, DIR_SECURE_CREATOR_CMDS,
                       DIR_PLAYTESTER_CMDS }));
   } else {
      seteuid("PLAYER");
      AddSearchPath(({ DIR_PLAYER_CMDS, DIR_SECURE_PLAYER_CMDS }));
   }
   if (!last_on_from) {
      printf("You have never logged in before.\n");
   } else {
      printf("You last logged in from %s and are currently "
             "logged in from %s (%s).\n", last_on_from,
             query_ip_name(this_object()), query_ip_number(this_object()));
   }
   last_on_from = query_ip_name(this_object()) + " (" +
      query_ip_number(this_object()) + ")";
   if (time_on > 0) {
      time_on = 0;
   }
   time_on += time();
   if (new_flag) {
      add_property("new player!", 1);
   }
   LOGIN_HANDLER->player_logon(bong, query_property("guest"),
                               (query_ip_name()? query_ip_name() :
                                query_ip_number()));
   if(query_property("guest")) {
     this_player()->set_nationality(DEFAULT_NATIONALITY);
     this_player()->
       set_nationality_region(this_player()->find_region(DEFAULT_NATIONALITY,
                                                         DEFAULT_REGION));
     lang = DEFAULT_NATIONALITY->query_language();
     this_player()->add_language(lang);
     this_player()->set_default_language(lang);
     this_player()->set_language(lang);
   }
   write(LOGIN_HANDLER->get_message("/doc/NEWS"));
   call_out((: continue_start_player :), 0);
   PLAYER_HANDLER->remove_cache_entry(query_name());
}
protected void move_to_start_pos()
{
   ::move_to_start_pos();
   if (query_verbose("look"))
      command("look");
   else
      command("glance");
   if (!finger_set()) {
      write
         ("%^BOLD%^Please set your finger information with 'chfn'.%^RESET%^\n");
   }
   if(no_logins == 1 && !query_property("guest")) {
     write("\n%^BOLD%^" +
           LOGIN_HANDLER->get_message("/doc/login/NEW_USER_START") +
           "%^RESET%^\n");
   }
   no_time_left();
   START_PLAYER->logged_on_times(no_logins);
   if(query_ip_number(this_object()) == query_ip_name(this_object()))
     resolve(query_ip_number(this_object()), "");
}
protected void update_activity(int logon)
{
   int time_on;
   if (last_log_on > 0) {
      time_on = last_command - last_log_on;
      if (time_on > 0)
         activity_counter -= (time_on / (3600 * 24 * 7)) * 10;
   }
   if (activity_counter <= -55) {
      activity_counter = -55;
   }
   if (logon) {
      activity_counter += 3;
   } else {
      activity_counter += 2 * ((time() - last_log_on) / 3600);
   }
   if (activity_counter >= 0)
      activity_counter = 0;
}
int query_activity_counter()
{
   return activity_counter;
}
private void display_bug_replies(int type, class error_replies* replies) {
   if (type == DB_SUCCESS) {
      if (sizeof(replies) > 0) {
         tell_object(this_object(), "\n\nYou have %^YELLOW%^" +
            sizeof(replies) + " NEW%^RESET%^ bug repl" +
            (sizeof(replies) > 1?"ies ":"y ") +
            "(read with 'bug replies').\n\n");
      }
   }
}
private void check_mccp() {
   if(!compressedp(this_object())) {
     write("\n%^BOLD%^%^RED%^You are logged in uncompressed!\n");
     write("Use of an MCCP capable mud client will reduce your load on "
           "the " + mud_name() + " system.%^RESET%^\n\n");
   }
}
void continue_start_player()
{
   string title;
   mapping news_rc;
   mixed *stuff;
   object book;
   if (this_object()->query_lord()) {
      creator = 1;
   }
   start_player();
   no_time_left();
   if (query_property(PASSED_OUT) && !query_property(TRANCE)) {
      call_out((: remove_property :), 10 + random(30), PASSED_OUT);
   }
   remove_property(UNKNOWN_MOVE);
   remove_property(RUNNING_MOVE);
   init_after_save();
   printf("%s", fix_string(MAILER->new_mail(query_name())));
   news_rc = BOARD_HAND->query_newsrc(query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = BOARD_HAND->get_subjects("announcements");
   if (sizeof(stuff)) {
      if (stuff[<1][B_TIME] > news_rc["announcements"]) {
         write("\nThere are %^YELLOW%^NEW%^RESET%^ announcements.  ");
         write("You can read them with \"news\".\n\n");
      }
   }
   call_out((: check_mccp :), 4);
   if (query_property("dead")) {
      (clone_object(DEATH_SHADOW))->setup_shadow(this_object());
      book = clone_object(DEAD_BOOK);
      book->move(this_object());
   }
   if (query_property("noregen")) {
      DEATH->person_died(query_name());
   }
   exec_alias("login", "");
   update_activity(1);
   last_log_on = time();
   title = LIBRARY->query_title(query_name());
   if (stringp(title)) {
      _pinfo->titles += ([ "quest" : title ]);
   }
   if (my_file_name != "/global/player") {
      check_error_count();
      if(my_file_name != "/global/playtester") {
        check_approve_list();
      }
   }
   if (query_property("new player!")) {
     PLAYERINFO_HANDLER->player_created(query_name());
      user_event(this_object(), "inform",
                 capitalize(query_name()) +
                 " arrives on " + mud_name() + " for the first time!", "new-player");
      remove_property("new player!");
      set_last_pos(CONFIG_NEWBIE_START_LOCATION);
      START_PLAYER->start_player(this_object());
   }
   check_family_name();
   call_out((: move_to_start_pos :), 0);
   call_out((: set_heart_beat(1) :), 1);
   ERROR_HANDLER->do_error_replies(query_name(), 1, (: display_bug_replies :));
}
void check_error_count() {
   string my_name;
   my_name = query_name();
   DB_HANDLER->make_sql_request( "errors", "atuin", "",
      "SELECT COUNT(Id) AS idc FROM errors WHERE Directory = '/w/" +
      my_name + "' AND Status = 'OPEN'",
       (: finished_error_check, this_object(), my_name :) );
}
void finished_error_check( object player, string my_name, int status,
    mixed data ) {
   int num;
   int ret;
   if ( file_size("/w/" + my_name + "/" + PLAYER_ERROR_LOG) > 0 ) {
       num = file_length("/w/" + my_name + "/" + PLAYER_ERROR_LOG);
       tell_object( player, "%^YELLOW%^You have %^RED%^" + num +
           "%^YELLOW%^ director" + (num == 1 ? "y" : "ies") +
           " with %^RED%^ERRORS%^YELLOW%^ in /w/" + my_name + "/" +
           PLAYER_ERROR_LOG + ".%^RESET%^\n");
   }
   if ( status == DB_SUCCESS && sizeof( data ) > 0 ) {
      if ( ( ret = data[0]["idc"] ) > 0 ) {
         tell_object( player, "%^YELLOW%^You have %^RED%^" + ret +
            " ERROR" +  (ret == 1 ? "" : "S") + "%^YELLOW%^ in /w/" +
            my_name +  ".%^RESET%^\n");
      }
   }
}
void check_approve_list() {
  string str;
  mapping assignments;
  int count;
  assignments = master()->query_directory_assignments();
  foreach(str in keys(assignments)) {
    if(member_array(this_object()->query_name(), assignments[str]) != -1 &&
       file_size(str + "/to_approve")) {
      count = sizeof(get_dir(str + "/to_approve
void start_player()
{
   if (this_object()->query_creator() && my_file_name != "/global/player") {
      this_player()->all_commands();
      this_player()->app_commands();
      this_player()->wiz_commands();
   }
   call_out((: do_load_auto :), 1);
   reset_get();
   enable_commands();
   public_commands();
   command_commands();
   parser_commands();
   force_commands();
   race_guild_commands();
   soul_commands();
   event_commands();
   finger_commands();
   communicate_commands();
   living_commands();
   logging_commands();
   editor_commands();
   if (this_player()->query_creator()) {
      set_living_name(query_name());
   }
   set_no_check(1);
   set_con(Con);
   set_dex(Dex);
   set_int(Int);
   set_str(Str);
   set_wis(Wis);
   reset_all();
   set_current_path(query_home_dir());
   if (wimpy > 100) {
      wimpy = 25;
   }
   if (contmp || dextmp || inttmp || strtmp || wistmp) {
      _pinfo->update_tmps_call_out = call_out((: update_tmps :), 900);
   }
}
int adjust_hp(int number,
              object attacker,
              object weapon,
              string attack)
{
   if (!interactive(this_object()))
      return query_hp();
   return::adjust_hp(number, attacker, weapon, attack);
}
void do_load_auto()
{
   load_auto_load_alt(query_auto_load_string(), this_object(), this_object(),
                      (: tell_object(this_object(),
                                     "\n%^CYAN%^Inventory regeneration complete.%^RESET%^\n") :));
   set_auto_load_string(0);
   allow_save();
}
void public_commands()
{
   add_command("restart", this_object(), "", (: restart_heart_beat() :));
   add_command("save", this_object(), "", (: save() :));
   add_command("quit", this_object(), "", (: quit_alt(-1) :));
   add_command("quit", this_object(), "brief", (: quit_alt(0) :));
   add_command("quit", this_object(), "verbose", (: quit_alt(1) :));
   add_command("review", this_object(), "", (: review() :));
   add_command("wimpy", this_object(), "", (: toggle_wimpy(0) :));
   add_command("wimpy", this_object(), "<word'number'>",
               (: toggle_wimpy($4[0]) :));
   add_command("refresh", this_object(), "<word'totally'>",
               (: do_refresh($4[0]) :));
   add_command("cap", this_object(), "<word'name'>", (: do_cap($4[0]) :));
}
int glance(string str)
{
   return command("glance" + (str ? " " + str : ""));
}
int look_me(string str)
{
   return command(str ? "look" + str : "look");
}
int review()
{
   write("Entry  : " + query_msgin() + "\n");
   write("Exit   : " + query_msgout() + "\n");
   write("MEntry : " + query_mmsgin() + "\n");
   write("MExit  : " + query_mmsgout() + "\n");
   write("Editor : " + query_editor() + "\n");
   return 1;
}
int examine(string arg)
{
   return look_me(arg ? " at " + arg : "");
}
varargs string short(int dark,
                     int verbose)
{
   string str;
   string family;
   string title;
   if (!interactive(this_object())) {
      str = "the net dead statue of ";
   } else {
      str = "";
   }
   family = query_family_name();
   if (!family) {
      family = "";
   } else {
      family = " " + family;
   }
   if (verbose)
      title = query_player_title();
   if (!title) {
      title = "";
   } else {
      title = title + " ";
   }
   return str + title + living::short(dark) + family;
}
int toggle_wimpy(string str)
{
   int number;
   if (!str) {
      if (this_object()->query_wimpy())
         write("You are in wimpy mode, you will run away at " +
               this_object()->query_wimpy() +
               "% of your max hps.\n");
      else
         write("You are in brave mode.\n");
      write("Usage: wimpy <num> (caution read help wimpy)\n");
      return 1;
   }
   if (sscanf(str, "%d", number) != 1)
      return notify_fail("You must set your wimpy to a number.\n");
   if ((number < 0) || (number > 30))
      return notify_fail("Your wimpy must be between 0 and 30%.\n");
   this_object()->set_wimpy(number);
   printf("Wimpy set to %d%%\n", wimpy);
   return 1;
}
string extra_score()
{
   return "";
}
nomask int save() {
#ifdef UNUSED
  if(query_verb() == "save") {
    if(_pinfo->last_save > time() - 900) {
      tell_object(this_object(), "You saved only a few minutes ago.\n");
      return 1;
    }
    _pinfo->last_save = time();
  }
#endif
  if (((time() - time_on) < MIN_TIME_TO_SAVE) &&
      !LIBRARY->query_quest_points(query_name()) &&
      !query_property("authorised player")) {
    if (query_verb() == "save") {
      tell_object(this_object(), "You're too young to save... sorry.\n");
    }
    return 1;
  }
  tell_object(this_object(), "Saving...\n");
  this_object()->save_me();
  return 1;
}
void save_me() {
   mixed old;
#ifdef NOT_SAVEING_PLAYERS
   if (!this_object()->query_creator()) {
      write("Not saving for players currently.\n");
      return;
   }
#endif
   if (query_auto_loading())
      return;
   if (query_property("guest")) {
      if (query_verb() == "save")
         tell_object(this_object(), "But not saving for guests... Sorry.\n");
      return;
   }
   if (query_save_inhibit()) {
      return;
   }
   if (guild_ob) {
      guild_ob->player_save(this_object());
   }
   if (race_ob) {
      race_ob->player_save(this_object());
   }
   old = geteuid();
   check_last_pos();
   effect_freeze();
   effects_saving();
   create_auto_load(all_inventory(), 1);
   if (interactive(this_object())) {
      last_on_from = query_ip_name(this_object()) + " (" +
         query_ip_number(this_object()) + ")";
   }
   time_on -= time();
      catch(unguarded((: save_object,
                      PLAYER_HANDLER->query_player_file_name(query_name()), 3 :)));
   time_on += time();
   ITEM_TRACKER->save_all_item_states(this_object()->query_name());
   effect_unfreeze();
   set_auto_load_string(0);
}
void save_with_auto_load(mixed al)
{
   mixed old;
#ifdef NOT_SAVEING_PLAYERS
   if (!this_object()->query_creator()) {
      write("Not saving for players currently.\n");
      return;
   }
#endif
   if (query_property("guest")) {
      write("But not saving for guests... sorry.\n");
      return;
   }
   if (((time() - time_on) < MIN_TIME_TO_SAVE) && query_verb() == "save") {
     tell_object(this_object(), "You're too young to save... sorry.\n");
     return;
   }
   if (query_save_inhibit()) {
      return;
   }
   if (guild_ob) {
      guild_ob->player_save(this_object());
   }
   if (race_ob) {
      race_ob->player_save(this_object());
   }
   old = geteuid();
   effect_freeze();
   effects_saving();
   set_auto_load_string(al);
   if (((time() - time_on) >= MIN_TIME_TO_SAVE) ||
       LIBRARY->query_quest_points(query_name())) {
      time_on -= time();
         catch(unguarded((: save_object,
                         PLAYER_HANDLER->query_player_file_name(query_name()),
                         3 :)));
      time_on += time();
   }
   effect_unfreeze();
}
int quit_alt(int verbose)
{
   object frog;
   if (verbose == -1) {
      verbose = query_verbose("quit");
   }
   if (query_auto_loading()) {
      if (!interactive(this_object())) {
         dest_me();
      } else {
         write
            ("You cannot quit yet: your inventory is still being generated.\n");
      }
      return 1;
   }
   if (sizeof(filter_array((object *) this_object()->query_attacker_list(),
                           (: living($1) :))) &&
       this_player() == this_object() && interactive(this_object())) {
      write
         ("You cannot quit while in combat.  Use 'stop' to stop fighting.\n");
      return 1;
   }
   check_last_pos();
   update_activity(0);
   last_log_on = time();
   catch(this_object()->event_quit(this_object()));
   catch(environment(this_object())->event_quit(this_object()));
   catch(editor_check_do_quit());
   write("A small gecko takes your hand and rushes you to the departure "
         "lounge.\n");
   say(query_cap_name() + " leaves the game.\n");
   catch(move("/room/departures"));
   user_event(this_object(), "inform",
              query_cap_name() + " leaves " + mud_name() + "", "logon", this_object());
   catch(LOGIN_HANDLER->player_logout(query_name()));
   if (race_ob) {
      catch(race_ob->player_quit(this_object()));
   }
   if (guild_ob) {
      catch(guild_ob->player_quit(this_object()));
   }
   frog = clone_object("/obj/monster/greco");
   frog->move("/room/departures");
   frog->get_rid_of(this_object(), verbose);
   return 1;
}
int do_quit()
{
   return quit_alt(-1);
}
int quit()
{
   if (query_auto_loading() || query_save_inhibit()) {
      tell_object(this_object(),
                  "Forced to quit whilst auto loading.  Not saving.\n");
      ::dest_me();
      return 1;
   }
   check_last_pos();
   update_activity(0);
   last_log_on = time();
   catch(editor_check_do_quit());
   catch(this_object()->event_quit(this_object()));
   catch(environment(this_object())->event_quit(this_object()));
   tell_object(this_object(), "Thanks for playing.  See you next time.\n");
   say(query_cap_name() + " leaves the game.\n");
   user_event(this_object(), "inform",
              query_cap_name() + " leaves " + mud_name() + "", "logon", this_object());
   catch(LOGIN_HANDLER->player_logout(query_name()));
   if (race_ob) {
      catch(race_ob->player_quit(this_object()));
   }
   if (guild_ob) {
      catch(guild_ob->player_quit(this_object()));
   }
   catch(save_me());
   foreach( object inv in all_inventory( this_object() ) ) {
      reset_eval_cost();
      catch( inv->set_tracked_item_status_reason("QUIT") );
      catch( inv->dest_me() );
   }
   catch(ITEM_TRACKER->
         save_all_item_states_delete_cache(this_object()->query_name()));
   effects_quiting();
   reset_eval_cost();
   if (catch(dest_me())) {
      destruct(this_object());
   }
   return 1;
}
mapping query_titles()
{
   return copy(_pinfo->titles);
}
string query_title()
{
   return implode(m_values(_pinfo->titles), ", ");
}
void set_title(string type,
               string title)
{
   _pinfo->titles[type] = title;
}
void remove_title(string type)
{
   map_delete(_pinfo->titles, type);
}
int query_deaths()
{
   return deaths;
}
void adjust_deaths(int i)
{
   if (i > 0) {
      deaths += i;
   }
}
nomask void set_name(string str) {
  if (query_name() && query_name() != "object") {
    return;
  }
  if (file_name(previous_object())[0..12] != "/secure/login" &&
      file_name(previous_object())[0..13] != "/secure/nlogin") {
    return;
  }
  ::set_name(str);
  set_living_name(query_name());
  set_main_plural(query_name());
}
void init_static_arg(mapping map)
{
   return;
}
void init_dynamic_arg(mapping, object) {
  return;
}
string long(string str,
            int dark)
{
   string s;
   string tmp;
   string title;
   string nationality;
   title = query_player_title();
   if (!title) {
      title = "";
   } else {
      title = title + " ";
   }
   s = "You see " + title + query_short();
   tmp = query_family_name();
   if (tmp) {
      s += " " + query_family_name();
   }
   if (guild_ob) {
      s += " " + (string) guild_ob->query_title(this_object()) + ".\n";
   } else {
      s += ".\n";
   }
   if (race_ob) {
      s += (string) race_ob->query_desc(this_object());
   }
   nationality = query_nationality_description(this_player());
   if (nationality  &&  nationality != "") {
      s += nationality + "\n";
   }
   if (dark == 2 || dark == -2) {
      s += "It is too ";
      if (dark == -2) {
         s += "dark";
      } else {
         s += "bright";
      }
      s += " to see their description or what " +
         query_pronoun() + " are wearing or carrying.\n";
      s += calc_extra_look();
   } else {
      if (query_desc() && query_desc() != "") {
         s += capitalize(query_pronoun()) + " " + query_desc() +
              query_main_zone_desc(query_wearing()) + "\n";
      }
      s += capitalize(query_pronoun()) + " " +
         this_object()->health_string() + ".\n";
      s +=
         capitalize(query_pronoun()) + " is " + query_position_short() +
         ".\n";
      s += calc_extra_look();
      s += weather_extra_look();
      s += query_living_contents(0);
   }
   return s;
}
mixed second_life()
{
   object corpse;
   string death_mess;
   add_property("dead", time());
   if (!DEATH->someone_died(this_object())) {
      deaths++;
   }
   effects_thru_death();
   corpse = make_corpse();
   reset_protectors();
   if (deaths > max_deaths) {
      death_mess = query_property ("death mess");
      tell_object(this_object(), "You have died your final death.  " +
                "Your name will be inscribed in the Hall of Legends.\n");
      if (death_mess && sizeof (death_mess)) {
        death_mess = strip_colours (death_mess);
        death_mess = replace (death_mess, ({"\n", "", "\a", ""}));
        shout(capitalize(query_name()) + " has died for the last time.  " +
          death_mess + "\n");
      }
      else {
        shout(capitalize(query_name()) + " has died for the last time.  " +
             capitalize(query_pronoun()) + " is mourned.\n");
      }
      LIBRARY->complete_death(query_name());
      corpse->move(PLAYER_MORGUE);
   } else
      corpse->move(environment());
   call_out((: save_me :), 0);
   if (find_object(OFFLER) && (deaths <= max_deaths)) {
      OFFLER->person_died(query_name());
   } else {
      DEATH->person_died(query_name());
   }
   clone_object(DEATH_SHADOW)->setup_shadow(this_object());
   if (guild_ob) {
      guild_ob->member_died(this_object());
   }
   gp = 0;
   hp = 0;
   set_sp(0);
   set_max_sp(50);
   xp = 0;
   reset_spells();
   reset_processes();
   contmp = dextmp = inttmp = strtmp = wistmp = 0;
   remove_call_out(_pinfo->update_tmps_call_out);
   adjust_tmp_con(-2);
   adjust_tmp_dex(-2);
   adjust_tmp_int(-2);
   adjust_tmp_str(-2);
   adjust_tmp_wis(-2);
   return corpse;
}
void remove_ghost()
{
   if (deaths > max_deaths) {
      if (this_player() != this_object()) {
         tell_object(this_object(), this_player()->query_cap_name() +
                     " tried to raise you, but you are completely dead.\n");
         tell_object(this_player(), query_cap_name() +
                     " is completely dead, you cannot raise " +
                     query_objective() + ".\n");
      } else {
         tell_object(this_object(), "You are completely dead.  You cannot " +
                     "be raised.\n");
         say(query_cap_name() +
             " struggles to appear in a solid form, but fails.\n");
         return;
      }
   }
   remove_property("dead");
   tell_object(this_object(), "You reappear in a more solid form.\n");
   if (guild_ob) {
      guild_ob->member_resurrected(this_object());
   }
   say(query_cap_name() + " appears in more solid form.\n");
   if (query_hp() < 0) {
      set_hp(1);
   }
   set_personal_temp(0);
   this_object()->dest_death_shadow();
   save_me();
   all_inventory()->recovery_from_death();
}
void net_dead()
{
   if (!environment() || file_name(environment()) == "/room/departures") {
      return;
   }
   if ((query_name() == "guest") || (query_name() == "root")) {
      say(query_name() + " vanishes in a puff of logic.\n");
      quit();
   } else {
      say(query_name() + " goes white, looks very chalky and turns into a " +
          "statue.\n");
      user_event(this_object(), "inform",
                 capitalize(query_name()) + " has lost " +
                 query_possessive() + " link", "link-death", this_object());
      check_last_pos();
      LOGIN_HANDLER->player_net_dead(query_name());
      save_me();
   }
   event(environment(), "net_dead", this_object());
}
void idle_out()
{
   say(cap_name + " has been idle for too long; " + query_pronoun() +
       " vanishes in a puff of boredom.\n");
   write("You idled out, sorry.\n");
   quit();
}
void heart_beat()
{
   catch {
      int idle_time;
      events::print_messages();
      flush_queue();
      if (!interactive(this_object())) {
         idle_time = time() - last_command;
      } else {
         idle_time = query_idle(this_object());
      }
      if (query_creator()) {
         idle_time = idle_time / 3;
      }
      if (idle_time > FULL_IDLE) {
         if ((LOGIN_HANDLER->is_discworld_full() || idle_time > MAX_IDLE) &&
             (!interactive(this_object())
              || my_file_name != "/global/lord")) {
            call_out((: idle_out :), 2);
         }
      }
      if (interactive(this_object())) {
         living::heart_beat();
         adjust_sp(1);
         adjust_xp(3);
         living::update_volumes();
         this_object()->do_spell_effects(0);
         if (_pinfo->hb_num++ > 1800)
            _pinfo->hb_num = 0;
         if (!(_pinfo->hb_num % 120)) {
            calc_personal_temp();
            adjust_max_sp(1);
         }
      }
   };
}
int query_monitor()
{
   return monitor;
}
void set_monitor(int i) {
  monitor = i;
}
protected void write_prompt()
{
   efun::tell_object(this_object(), "> ");
   return;
}
#ifdef UNUSED
protected void write_prompt()
{
   string prompt;
   int tmp,
     i;
   string stuff;
   if (!(monitor & 2) || !this_object()->query_creator())
      efun::tell_object(this_object(), "> ");
   else {
      prompt = "";
      stuff = this_player()->query_property("prompt");
      for (i = 0; i < strlen(stuff); i++) {
         switch (stuff[i]) {
         case 'h':
            tmp = ((query_hp() * 100) / query_max_hp());
            prompt += "Hp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += tmp + "%^RESET%^";
            break;
         case 'H':
            tmp = ((query_hp() * 100) / query_max_hp());
            prompt += "Hp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += query_hp() + "%^RESET%^";
            break;
         case 'g':
            tmp = (query_gp() * 100) / query_max_gp();
            prompt += "Gp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += tmp + "%^RESET%^";
            break;
         case 'G':
            tmp = (query_gp() * 100) / query_max_gp();
            prompt += "Gp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += query_gp() + "%^RESET%^";
            break;
         case 's':
            tmp = (query_sp() * 100) / query_max_sp();
            prompt += "Sp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += tmp + "%^RESET%^";
            break;
         case 'S':
            tmp = (query_sp() * 100) / query_max_sp();
            prompt += "Sp:";
            switch (tmp) {
            case 50..100:
               prompt += "%^GREEN%^";
               break;
            case 20..49:
               prompt += "%^YELLOW%^";
               break;
            default:
               prompt += "%^RED%^";
            }
            prompt += query_sp() + "%^RESET%^";
            break;
         case 'X':
         case 'x':
            prompt += "Xp:" + query_xp();
            break;
         default:
            if (sizeof(prompt) > 0 && prompt[sizeof(prompt) - 1] != stuff[i])
               prompt += sprintf("%c", stuff[i]);
         }
      }
      prompt += "> ";
      efun::tell_object(this_object(), fix_string(prompt));
   }
}
#endif
int run_away()
{
   int number;
   become_flummoxed();
   number =::run_away();
   if (number)
      tell_object(this_object(), "Your feet run away with you!\n");
   else
      tell_object(this_object(), "You try to run away, but no matter how "
                  "you scrabble, you can't find any way out.\n");
   return number;
}
nomask int query_time_on()
{
   return time_on - time();
}
int query_mature()
{
   return (MATURITY * 60 * 60 + time_on < time());
}
int check_dark(int light)
{
   int i;
   if (race_ob)
      if (catch(i = (int) race_ob->query_dark(light)))
         race_ob = RACE_STD;
      else
         return i;
   return (int) RACE_STD->query_dark(light);
}
int query_level()
{
   string tmp;
   if (_pinfo->level_time < (time() - LEVEL_CACHE)) {
      if (guild_ob) {
         _pinfo->level = (int) guild_ob->query_level(this_object());
      } else {
         tmp = query_property("backup guild");
         if (tmp) {
            _pinfo->level = tmp->query_level(this_object());
         } else
            _pinfo->level = CONFIG_DEFAULT_GUILD->query_level(this_object());
      }
      _pinfo->level_time = time();
   }
   return _pinfo->level;
}
int restart_heart_beat()
{
   set_heart_beat(1);
   write("Ok, heart_beat restarted.\n");
   return 1;
}
nomask void set_snoopee(object ob)
{
   _pinfo->snoopee = ob;
}
nomask object query_snoopee()
{
   return _pinfo->snoopee;
}
void set_creator(int i)
{
   if (previous_object() != master()) {
      write("Illegal attempt to set creator!\n");
      log_file("ILLEGAL", this_player(1)->query_name() + " (" +
               file_name(this_player(1)) +
               ") Illegal attempt to set_creator " + "at " + ctime(time()) +
               " from " + file_name(previous_object()) + "\n");
      return;
   }
   creator = i;
   set_home_dir("/w/" + query_name());
   save_me();
}
int query_prevent_shadow(object ob)
{
   if (function_exists("query_prevent_shadow", ob) ||
       function_exists("query_name", ob) ||
       function_exists("query_creator", ob) ||
       function_exists("query_lord", ob) ||
       function_exists("query_hidden", ob) ||
       function_exists("dest_me", ob) ||
       function_exists("query_object_type", ob) ||
       function_exists("query_lord", ob) || function_exists("save_me", ob))
      return 1;
   return 0;
}
int query_max_deaths()
{
   return max_deaths;
}
protected void set_max_deaths(int i)
{
   max_deaths = i;
}
int adjust_max_deaths(int i)
{
   if (i > 0) {
      return (max_deaths += i);
   }
}
varargs int move(mixed dest,
                 string msgin,
                 string msgout)
{
   int i;
   object env = environment();
   i = living::move(dest, msgin, msgout);
   if (!i) {
      me_moveing(env);
   }
   return i;
}
nomask protected int do_refresh(string str) {
   if (query_property("guest")) {
      return notify_fail("Guests cannot refresh, sorry.\n");
   }
   if (!str || str != "totally") {
      return notify_fail("Please read the docs before using this command.\n");
   }
   write("%^BOLD%^WARNING!  This will restart your character.%^RESET%^\n\n" +
         "Are you sure you wish to refresh yourself totally? ");
   input_to("refresh_docs");
   return 1;
}
protected int refresh_docs(string str) {
   string helpfile = "";
   str = lower_case(str);
   if (str[0] != 'y') {
      write("Ok, not refreshing.\n");
      return 1;
   }
   NROFF_HAND->create_nroff( "/doc/helpdir/refresh", helpfile );
   helpfile = NROFF_HAND->cat_file( helpfile );
   write ( helpfile[0..670] );
   write("\n\n%^BOLD%^Having read the documentation, are you still sure you "
         "wish to refresh totally?%^RESET%^\n");
   input_to("refresh3");
   return 1;
}
protected int refresh2(string str, int noevent) {
   object ob;
   string group;
   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write
         ("Pardon?  I do not understand.  Do you want to refresh yourself? ");
      input_to("refresh2");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not refreshing.\n");
      return 1;
   }
   write("Doing refresh.\n");
   Str = 13;
   Con = 13;
   Int = 13;
   Wis = 13;
   Dex = 13;
   inttmp = dextmp = wistmp = strtmp = contmp = 0;
   race_ob = CONFIG_DEFAULT_RACE;
   if (guild_ob)
      catch(guild_ob->delete_member(query_name()));
   if (!noevent) {
      REFRESH_HANDLER->player_refreshed(this_object(), PARTIAL_REFRESH);
   }
   guild_ob = 0;
   set_al(0);
   if (query_deity()) {
#ifndef __DISTRIBUTION_LIB__
      catch(DEITY->delete_worshipper(query_deity(), query_name()));
      catch(DEITY->delete_priest(query_deity(), query_name()));
#endif
   }
   set_deity(0);
   set_skills(0);
   PLAYTESTER_HAND->remove_playtester(query_name());
   if (query_family_name()) {
      CLUB_HANDLER->remove_member(query_family_name(), query_name());
      set_family_name(0);
   }
   reset_effects();
   reset_spells();
   reset_processes();
   setup_default_titles();
   guild_ob = 0;
   set_guild_data(0);
   xp = 0;
   deaths = 0;
   max_deaths = 7;
   _refresh_time = time();
   totaly_zap_bonus_cache();
   known_commands = ({ "skills", "rearrange", "gp", "newbie" });
   reset_starts();
   race_guild_commands();
   totaly_zap_stat_cache();
   drink_info = allocate(D_SIZEOF);
   map_prop = ([ "determinate" : "",
                 "player" : 1,
                 "skills version" :
                 (string) "/obj/handlers/change_skills"->query_version() ]);
   this_object()->remove_ghost();
   set_nationality(0);
   set_nationality_region(0);
   set_language("general");
   set_default_language("general");
   reset_all();
   group = this_player()->query_group();
   if (group) {
      GROUP->remove_member(group, this_player(), " refreshed themselves.");
   }
   set_last_pos(CONFIG_NEWBIE_START_LOCATION);
   START_PLAYER->give_junk(this_object());
   foreach (ob in query_attacker_list()) {
      catch(ob->stop_fight(this_object()));
      catch(stop_fight(ob));
   }
   call_out((: move_to_start_pos :), 0);
   if (!noevent) {
      write("Done refreshing.\n");
      say(cap_name + " refreshes " + query_objective() + "self.\n");
      save_me();
   }
   return 1;
}
protected int refresh3(string str)
{
   object *items,
    *ritems,
     item;
   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write("Pardon?  I do not understand.  Do you want to refresh " +
            "yourself totally? ");
      input_to("refresh3");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not refreshing.\n");
      return 1;
   }
   write("Ok, refreshing totally.\n");
   ritems = filter(all_inventory(environment()),
                   (: $1->query_property("dropped") &&
                      $1->query_property("dropped")[0] == query_name() :));
   move(CONFIG_NEWBIE_START_LOCATION);
   refresh2("y", 1);
   set_player_killer(0);
   _pinfo->titles = ([ ]);
   REFRESH_HANDLER->player_refreshed(this_object(), TOTAL_REFRESH);
   "/secure/related_files"->delete_related_files(query_name(),
                                                 0, TOTAL_REFRESH);
   items = ritems + all_inventory();
   foreach(item in items) {
      item->dest_me();
   }
   foreach(item in children("/obj/corpse")) {
      if (item->query_owner() == this_object()->query_name()) {
        item->move("/room/rubbish");
      }
   }
   foreach (string club in query_player_clubs()) {
      catch(CLUB_HANDLER->remove_member(club, this_player()->query_name()));
   }
   if (query_family_name()) {
      catch(CLUB_HANDLER->remove_member(query_family_name(),
                                  this_player()->query_name()));
      call_out("check_family_name", 2);
   }
   write("Done refreshing.\n");
   say(cap_name + " refreshes " + query_objective() + "self.\n");
   save_me();
   return 1;
}
string query_object_type(object player)
{
   if ("/obj/handlers/playtesters"->query_playtester(query_name())) {
      return "p";
   }
   return " ";
}
int do_cap(string str)
{
   if (!str)
      return notify_fail("Syntax: " + query_verb() + " <cap_name>\n");
   if (lower_case(str) != query_name())
      return
         notify_fail
         ("You must have the same letters in your capitalized name.\n");
   cap_name = str;
   write("Capitalized name set to " + cap_name + ".\n");
   return 1;
}
void set_my_ident(string str)
{
   return;
}
string query_my_ident()
{
   return 0;
}
void event_enter(object thing,
                 string mess,
                 object from)
{
   events::event_enter(thing, mess, from);
   living::event_enter(thing, mess, from);
}
void event_exit(object thing,
                string mess,
                object to)
{
   events::event_exit(thing, mess, to);
   living::event_exit(thing, mess, to);
}
string *parse_command_id_list()
{
   if (query_player_killer()) {
      return ({ "killer" }) +
             living::parse_command_id_list() + family::parse_command_id_list();
   } else {
      return living::parse_command_id_list() + family::parse_command_id_list();
   }
}
string *parse_command_plural_id_list()
{
   if (query_player_killer()) {
      return ({ "killers" }) + living::parse_command_plural_id_list() +
         family::parse_command_plural_id_list();
   } else {
      return living::parse_command_plural_id_list() +
         family::parse_command_plural_id_list();
   }
}
string *parse_command_adjectiv_id_list()
{
   return living::parse_command_adjectiv_id_list() +
         family::parse_command_adjectiv_id_list();
}
int query_last_log_on()
{
   return last_log_on;
}
int query_refresh_time()
{
   return _refresh_time;
}
int query_no_logins()
{
   return no_logins;
}
int query_creator()
{
   return 0;
}
int _living(){return 1;}
protected void set_invis(int level) {
}
int query_player_killer() {
   return _flags & PLAYER_KILLER_FLAG;
}
void set_player_killer(int flag) {
   if (flag) {
      _flags |= PLAYER_KILLER_FLAG;
   } else {
      _flags &= ~PLAYER_KILLER_FLAG;
   }
}
void set_role_playing(int i) {
  if(i)
    add_property(RPMODE, 1);
  else
    remove_property(RPMODE);
}
int query_role_playing() {
  return query_property(RPMODE);
}

==================================================
FILE: playtester.c
==================================================

#include <login_handler.h>
#include <command.h>
#include <player.h>
#define PROTECTION_LOG "/log/secure/playtesters/protection_log"
#define MAX_COUNTER 2
class playtester_data {
   int protect;
   int hp;
   string log_file;
   int log_death;
   int log_damage;
   int turn_off;
   int protection_counter;
   int room_protection;
}
inherit "/global/player";
int query_in_pt_arena();
private nosave class playtester_data _pt_data;
int query_pt_area (object ob) {
  string *file;
  if (strsrch (base_name (ob), "_pt") != -1) {
    return 1;
  }
  if (strsrch (base_name (ob), "_dev") != -1) {
    return 1;
  }
  file = explode (base_name (ob), "/");
  if (file[1] == "playtesters") {
    return 1;
  }
  return 0;
}
void create() {
   ::create();
   _pt_data = new(class playtester_data);
}
void move_player_to_start(string bong, int new_pl, string c_name, string ident, int go_invis) {
  if(!sscanf(file_name(previous_object()), "/secure/login#%*s") &&
     !sscanf(file_name(previous_object()), "/secure/nlogin#%*s"))
    return 0;
#ifndef NEW_DRIVER
#endif
  ::move_player_to_start(bong, new_pl, c_name, ident, go_invis);
  AddSearchPath(({ DIR_PLAYTESTER_CMDS }));
  if (PLAYTESTER_HAND->query_senior_playtester(query_name())) {
     AddSearchPath(({ DIR_SENIOR_PLAYTESTER_CMDS }));
  }
  if (PLAYTESTER_HAND->query_exec_access (query_name())) {
     AddSearchPath(({ DIR_EXEC_PLAYTESTER_CMDS }));
  }
}
int query_playtester() { return 1; }
string query_object_type(object) {
  if (PLAYTESTER_HAND->query_pt_exec(query_name())) {
    return "E";
  }
  if (PLAYTESTER_HAND->query_senior_playtester(query_name())) {
    return "P";
  }
  return "p";
}
int query_pt_protection() {
  if (_pt_data->room_protection) {
    return 2;
  }
  return _pt_data->protect;
}
int enable_pt_protection() {
  if (_pt_data->room_protection != 1) {
   log_file (PROTECTION_LOG, "%s: %s had room PT "
    "protection enabled by %s.\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
    tell_object (this_player(), "%^BOLD%^You have had your playtester "
      "protection enabled by an external source.  It will last until switched "
      "off by another external source.\n%^RESET%^");
    _pt_data->room_protection = 1;
    return 1;
  }
  return 0;
}
int disable_pt_protection() {
  if (_pt_data->room_protection == 1) {
   log_file (PROTECTION_LOG, "%s: %s had room PT "
    "protection disabled by %s.\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
    tell_object (this_player(), "%^BOLD%^The playtester protection enabled "
      "by an external source has been switched off.\n%^RESET%^");
    _pt_data->room_protection = 0;
    return 1;
  }
  return 0;
}
int enable_personal_pt_protection() {
  if (query_pt_protection()) {
    return 0;
  }
   _pt_data = new(class playtester_data);
   _pt_data->hp = ::query_hp();
   _pt_data->protect = 1;
   _pt_data->log_file = "/d/playtesters/log/pain";
   tell_room (environment (this_player()), this_player()->one_short()
      + " looks as if " + this_player()->query_pronoun() + " no longer has "
      "any fear of the risks of the real world.\n", this_player());
   log_file (PROTECTION_LOG, "%s: %s enabled PT "
    "protection (%s).\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
   if (_pt_data->turn_off) {
      remove_call_out(_pt_data->turn_off);
   }
   if (!query_pt_area (environment (this_player()))) {
      tell_object (this_player(), "%^BOLD%^You feel somewhat more secure, as if "
        "you can no longer be harmed by conventional weapons (This will "
        "only last a maximum of fifteen minutes).%^RESET%^\n");
     _pt_data->protection_counter = 0;
     _pt_data->turn_off = call_out("disable_personal_pt_protection", 5 * 60);
   }
   else {
      tell_object (this_player(), "%^BOLD%^You feel somewhat more secure, as if "
        "you can no longer be harmed by conventional weapons (This will "
        "last until you switch it off or leave a PT area).%^RESET%^\n");
  }
   return 1;
}
int disable_personal_pt_protection() {
  if (query_pt_protection() != 1) {
    return 0;
  }
  if (this_player()) {
    _pt_data->protection_counter = MAX_COUNTER;
  }
  if (_pt_data->protection_counter < MAX_COUNTER) {
    tell_object (this_player(), "%^BOLD%^You still have your PT protection "
      "enabled.\n%^RESET%^");
    log_file (PROTECTION_LOG, "%s: %s warned about still enabled PT "
      "protection (%s).\n", ctime(time()), this_player()->query_name(),
      base_name (environment (this_player())));
    _pt_data->turn_off = call_out("disable_personal_pt_protection", 5 * 60);
    _pt_data->protection_counter = _pt_data->protection_counter + 1;
    return 0;
  }
   _pt_data->turn_off = 0;
   _pt_data->protect = 0;
   _pt_data->protection_counter = 0;
   log_file (PROTECTION_LOG, "%s: %s disabled PT "
    "protection (%s).\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
   tell_object (this_player(), "%^BOLD%^You feel less secure in your "
    "indestructability.%^RESET%^\n");
   tell_room (environment (this_player()), this_player()->one_short()
      + " looks as if the risks of the real world are once again "
      "relevant.\n", this_player());
   return 1;
}
void pt_set_hp( int hp ) {
   _pt_data->hp = hp;
}
int pt_query_hp() {
   return _pt_data->hp;
}
object pt_make_corpse() {
   object corpse;
   corpse = clone_object( "/obj/corpse" );
   corpse->set_owner( 0, this_object() );
   corpse->set_ownership( query_name() );
   corpse->set_race_name( query_race() );
   if ( !query_race_ob() ) {
      corpse->set_race_ob( "/std/races/unknown" );
   } else {
      corpse->set_race_ob( query_race_ob() );
   }
   corpse->add_adjective( query_adjectives() );
   corpse->start_decay();
   return corpse;
}
object pt_do_death() {
   object corpse, flowers;
   DEATH->death_informer( this_object(), 0, _pt_data->log_file, 1 );
   tell_object( this_object(),
         "The Death of Playtesters sneaks up behind you and taps "
         "you on the shoulder.\n"
         "%^CYAN%^The Death of Playtesters says: MY, WE'VE BEEN A BIT "
         "CARELESS, HAVEN'T WE?%^RESET%^\n"
         "The Death of Playtesters coughs.\n"
         "%^CYAN%^The Death of Playtesters says: Sorry about the Voice.  "
         "We have to do that, you know.  Well, you should really be dead "
         "now, but the Playtesters' Union renegotiated the whole death deal "
         "with the powers that be.%^RESET%^\n" );
   call_out ("pt_set_hp", 0, query_max_hp());
   corpse = pt_make_corpse();
   corpse->move( environment( ) );
   flowers = clone_object( "/std/object" );
   flowers->set_name( "flowers" );
   flowers->set_short( "bunch of flowers" );
   flowers->add_alias( "bunch" );
   flowers->add_adjective( ({ "bunch", "of" }) );
   flowers->set_main_plural( "bunches of flowers" );
   flowers->add_plural( ({ "bunches", "bunches of flowers" }) );
   flowers->set_long( "This is a small bunch of nice flowers.\n" );
   flowers->set_weight( 5 + random( 10 ) );
   flowers->set_value( 0 );
   flowers->set_read_mess( "Rest In Peas", "common" );
   flowers->move( corpse );
   return corpse;
}
varargs int pt_adjust_hp( int hp, object attacker ) {
   _pt_data->hp += hp;
   if( ( hp < 0 || hp > 10 ) && _pt_data->log_damage && stringp( _pt_data->log_file ) )
      log_file( _pt_data->log_file, ctime( time() ) +": "+
                query_name() +" - "+ hp +" hitpoints.\n" );
   if( _pt_data->hp <= 0 && hp < 0) {
      pt_do_death();
   } else if( _pt_data->hp > ::query_max_hp() ) {
      _pt_data->hp = ::query_max_hp();
   }
   if( hp < 0 && _pt_data->hp > 0 && attacker && attacker != this_object() ) {
      if( 100 * _pt_data->hp < query_wimpy() * ::query_max_hp() ) {
         run_away();
      }
   }
   return _pt_data->hp;
}
void set_pt_log_file( string str ) {
   _pt_data->log_file = str;
}
string query_pt_log_file() {
   return _pt_data->log_file;
}
void enable_death_log() {
   _pt_data->log_death = 1;
}
void disable_death_log() {
   _pt_data->log_death = 0;
}
int query_log_death() {
   return _pt_data->log_death;
}
void enable_damage_log() {
   _pt_data->log_damage = 1;
}
void disable_damage_log() {
   _pt_data->log_damage = 0;
}
int query_log_damage() {
   return _pt_data->log_damage;
}
object do_death( object thing ) {
   if( query_pt_protection() || query_in_pt_arena())
      return pt_do_death();
   else
      return ::do_death( thing );
}
varargs int adjust_hp( int hp, object attacker ) {
   if( query_pt_protection() ) {
     return pt_adjust_hp( hp, attacker );
   } else {
      return ::adjust_hp( hp, attacker );
   }
}
int query_hp() {
   if( query_pt_protection() )
      return pt_query_hp();
   else
      return ::query_hp();
}
mixed *stats() {
   return ::stats() + ({
      ({ "PT hitpoints", _pt_data->hp }),
      ({ "PT protection", ( query_pt_protection() ? "On" : "Off" ) })
   });
}
string extra_score() {
   return ::extra_score() +
         "Your playtester protection is "+
         ( query_pt_protection() ? "on" : "off" ) +".\n";
}
int query_in_pt_arena() {
  if (!environment(this_object())) {
    return 0;
  }
  if (environment (this_object())->query_pt_arena()) {
    return 1;
  }
  return 0;
}
int advancement_restriction() {
  if (query_pt_protection()) {
    return 1;
  }
  if (query_in_pt_arena()) {
    return 1;
  }
  return 0;
}
varargs int adjust_xp(int number, int shared) {
  if ( advancement_restriction() && number > 0) {
    return 0;
  }
  return ::adjust_xp(number, shared);
}
void event_move_object(mixed from, mixed to) {
  ::event_move_object (from, to);
  if (query_pt_protection()) {
    if (query_pt_area(from) && !query_pt_area (to)) {
       _pt_data->protection_counter = MAX_COUNTER;
      if (_pt_data->turn_off) {
        remove_call_out(_pt_data->turn_off);
      }
      tell_object (this_player(), "%^BOLD%^You are now leaving a PT area.  "
        "Your protection is still on.\n%^RESET%^");
      log_file (PROTECTION_LOG, "%s: %s left a playtester area with protection "
        "still active (%s).\n", ctime(time()), this_player()->query_name(),
        base_name (environment (this_player())));
      _pt_data->turn_off = call_out("disable_pt_protection", 5 * 60);
    }
    else if (!query_pt_area (from) && query_pt_area (to)) {
      tell_object (this_player(), "%^BOLD%^You are now entering a PT area.  "
        "Your protection will not wear off until you leave or switch it "
        "off.\n%^RESET%^");
      if (_pt_data->turn_off) {
        remove_call_out(_pt_data->turn_off);
        _pt_data->protection_counter = 0;
      }
    }
  }
}
int query_player_killer() {
  if (query_in_pt_arena()) {
    return 1;
  }
  return ::query_player_killer();
}
int query_contractable() {
  return ::query_player_killer();
}

==================================================
FILE: psoul.c
==================================================

#include <living.h>
#include <player.h>
#include <soul.h>
inherit "/global/alias";
inherit "/global/nickname";
nosave int time_left;
nosave int tl_updated;
nosave int doing_it;
nosave int last_command;
nosave int bypass_queue;
nosave int flush_call_id;
nosave string *queued_commands;
nosave string in_command;
nosave mixed interrupt;
nosave private function cmd = 0;
#if !efun_defined(add_action)
protected mixed _process_input(string);
protected mixed command(string);
#endif
void create() {
  time_left = ROUND_TIME;
  tl_updated = time();
  last_command = time();
  queued_commands = ({ });
}
void bypass_queue() { bypass_queue = 1; }
void no_time_left() {
  time_left = -ROUND_TIME;
}
protected int drunk_check(string str);
void soul_commands() {
#if efun_defined(add_action)
  add_action("lower_check","*", -10000);
  add_action((:drunk_check:),"*", 10000);
#endif
  alias_commands();
  nickname_commands();
  history_commands();
}
int query_queued_commands() {
  return sizeof(queued_commands);
}
int soul_com_force(string str) {
  if (file_name(previous_object()) != SOUL_OBJECT)
    return 0;
  command(str);
  return 1;
}
void do_soul(string str, mixed bing) {
  say(str, bing);
}
int query_time_left() {
  time_left += ((time() - tl_updated) / 2) * ROUND_TIME;
  if(time_left > ROUND_TIME)
    time_left = ROUND_TIME;
  tl_updated = time();
  return time_left;
}
int adjust_time_left(int i) {
   return time_left += i;
}
private void do_flush(int first) {
  int i;
  string str;
  if ( ( time_left < 0 ) || !sizeof( queued_commands ) ||
       ( this_object()->queue_commands(queued_commands[0]) &&
         !this_object()->query_creator() ) ) {
    return;
  }
  if (!first) {
    str = queued_commands[0];
    queued_commands = queued_commands[1..];
    doing_it = 1;
    catch(command(str));
    doing_it = 0;
    if (!sizeof(queued_commands)) {
      queued_commands = ({ });
      doing_alias = ([ ]);
    }
    return ;
  }
  for (i = 0; (i < 2) && (i < sizeof(queued_commands)); i++) {
    flush_call_id = call_out((: do_flush(0) :), 1);
  }
  flush_call_id = call_out((: do_flush(1) :), 2);
}
private void call_interrupt(int time_left, object interupter) {
   mixed stuff;
   stuff = interrupt;
   interrupt = 0;
   if (pointerp(stuff)) {
      catch(call_other(stuff[1],
                       stuff[0],
                       time_left,
                       stuff[2],
                       this_object(),
                       interupter,
                       in_command));
   } else if (functionp(stuff)) {
      catch(evaluate(stuff,
                     time_left,
                     this_object(),
                     interupter,
                     in_command));
   }
}
protected void flush_queue() {
  query_time_left();
  remove_call_out(flush_call_id);
  do_flush(1);
  if (!sizeof(queued_commands)) {
    if (interrupt && time_left > 0) {
      call_interrupt(0, this_object());
    }
    in_alias_command = 0;
    doing_alias = ([ ]);
    if (!sizeof(queued_commands)) {
      return ;
    }
    doing_alias = ([ ]);
    in_alias_command = 0;
  }
}
void set_interupt_command(mixed func, mixed ob, mixed arg) {
  if (!functionp(func)) {
    interrupt = ({ func, ob, arg });
    if ( !stringp( func ) )
      interrupt = 0;
  } else {
    interrupt = func;
  }
}
mixed *query_interupt_command() {
   return interrupt;
}
void set_interrupt_command(function func) {
  set_interupt_command(func, 0, 0);
}
void remove_queue() {
   queued_commands = ({ });
   if ( interrupt && ( time_left < 0 ) ) {
      call_interrupt(-time_left, this_object());
   }
   tell_object( this_object(), "Removed queue.\n" );
   if (this_object()->query_lord()) {
     time_left = 0;
   } else {
     time_left = -DEFAULT_TIME;
   }
}
void interupt_command(object interupter) {
   if (interupter) {
      call_interrupt(-time_left, interupter);
   }
}
void command_override(function func){
  if(!functionp(func))
    error("command_override needs a function!");
  cmd = func;
}
protected int drunk_check(string str) {
   string *rabbit;
   string *green;
   string mess;
   string comm;
   string arg;
   if(cmd){
     object owner = function_owner(cmd);
     if(owner && owner == environment(this_player())){
       int res = evaluate(cmd, str);
       if(res)
         return res;
     } else cmd = 0;
   }
   if ( in_command == str ) {
      in_command = 0;
      sscanf(str, "%s %*s", str);
      if (is_doing_alias(str)) {
         this_object()->add_failed_mess(this_object(),
             "Recursive aliases. Bad "+
             ({"thing","boy","girl"})[(int)this_object()->query_gender()]+
                ".\n", ({ }));
      }
      return 0;
   }
   if ( bypass_queue ) {
      bypass_queue = 0;
      return 0;
   }
   last_command = time();
   if ( this_object()->query_property( PASSED_OUT ) ||
         !interactive( this_object() ) ) {
      if ( ( str == "quit" ) || ( str == "quit_old" ) ) {
         return 0;
      }
      mess = this_object()->query_passed_out_message();
      if ( !stringp( mess ) ) {
         mess = "You are unconscious.  You can't do anything.\n";
      }
      write( mess );
      if ( !this_object()->query_creator() ) {
         return 1;
      }
      write( "On the other hand, you're a creator...\n" );
   }
   if ( ( str == "stop" ) || ( str == "restart" ) ) {
      remove_queue();
      return 0;
   }
   if ( stringp( str ) ) {
      if ( str[ 0 .. 4 ] == "stop " ) {
         return 0;
      }
   }
   if ( ( time_left < 0 ) ||
        (this_object()->queue_commands(str) &&
         !this_object()->query_creator()) ||
         ( !doing_it && ( sizeof( queued_commands ) ||
         ( find_call_out( flush_call_id ) != -1 ) ) ) ) {
      rabbit = explode(str, " ");
      if (rabbit[0] != upper_case(rabbit[0])) {
         write( "Queued command: "+ str +"\n" );
      }
      if ( str == "quit" ) {
         write( "If you are trying to quit and it is queueing things, use "
               "\"stop\" to stop your commands, and or \"restart\" to start "
               "your heartbeat.\n" );
      }
      if(sizeof(queued_commands) < 256) {
        if(sizeof(rabbit) > 1 && member_array(str, queued_commands) != -1)
          time_left -= (DEFAULT_TIME / 2);
        queued_commands += ({ str });
      }
      return 1;
   }
   if (interrupt) {
      call_interrupt(0, this_object());
   }
   interrupt = 0;
   in_command = str;
   if (sscanf(str, "%s %s", comm, arg) != 2) {
      comm = str;
      arg = "";
   }
   rabbit = run_alias(comm, arg);
   if (rabbit) {
      set_doing_alias(comm);
      green = queued_commands;
      queued_commands = ({ });
      foreach (comm in rabbit) {
         catch(command(comm));
      }
      queued_commands += green;
#if USE_ADD_ACTION
   } else if(sizeof(str) > 512) {
     write("Command too long.\n");
#endif
   } else {
      time_left -= DEFAULT_TIME;
      command(str);
   }
   if (interrupt && time_left >= 0) {
      call_interrupt(0, this_object());
   }
   return 1;
}
protected string process_input(string str) {
  float secs;
  int t = time_expression{
    reset_eval_cost();
    if (str[0] == '.')
      str = expand_history(str[1..]);
    else if (str[0] == '^')
      str = substitute_history(str[1..]);
    this_object()->add_history(str);
#if efun_defined(add_action)
    return str;
#else
    _process_input(str);
  };
  secs = t/1000000.0;
  if((secs > 1.0) &&
     (strlen(str) < 2 || str[0..1] != "su") &&
     str != "upgrade") {
    log_file("GARBAGE", "%s command: %s time: %:3f place: %s\n",
       ctime(time())[4..18], str, secs,
       file_name(environment()));
    if(this_object()->query_creator())
      printf("\nThat command froze the mud for %:3f "
       "seconds.\n\n", secs);
  }
  return 0;
#endif
}
#if !efun_defined(add_action)
protected mixed _process_input(string str){
  object ob;
  int i;
  string* bits;
  if(str == "") {
    return 0;
  }
  ob = this_player();
  efun::set_this_player(this_object());
  _notify_fail(0);
  while (str[0] == ' ') {
    str = str[1..];
  }
  if (str == ""){
      efun::set_this_player(ob);
      return 0;
    }
  while(str[<1] == ' ') {
    str = str[0..<2];
  }
  if (str == ""){
    efun::set_this_player(ob);
    return 0;
  }
  if (strsrch(str, "%^") != -1) {
    bits = explode("f" + str + "g", "%^");
    for (i = 1; i < sizeof(bits); i += 2) {
      if (bits[i][0..3] != "USER") {
         bits[i] = "USER_" + bits[i];
      }
    }
    bits[0] = bits[0][1..];
    bits[<1] = bits[<1][0..<2];
    str = implode(bits, "%^");
  }
  if(!drunk_check(str)) {
    if(!this_object()->exit_command(str)) {
      if(!this_object()->cmdAll(str)) {
        if(!this_object()->new_parser(str)) {
          if(!this_object()->lower_check(str)){
            if(!(str = query_notify_fail())){
              string *responses=({"What?", "Try something else."});
              receive(responses[random(sizeof(responses))]+"\n");
            } else {
              receive(str);
            }
            efun::set_this_player(ob);
            return 0;
          }
        }
      }
    }
  }
  efun::set_this_player(ob);
  return "bing";
}
protected mixed command(string cmd){
  int time = eval_cost();
  if(_process_input(cmd))
    return eval_cost() - time + 1;
  return 0;
}
#endif
int lower_check(string str) {
  query_time_left();
  return (str == "stop");
}

==================================================
FILE: pweath.c
==================================================

#include <weather.h>
#include <clothing.h>
#include <playtesters.h>
#define COMFORTABLE 20
int temperature;
string temperature_str;
int query_wetness()
{
   return 0;
}
void add_wetness(int arg)
{
}
void dry_out()
{
}
void set_personal_temp(int i)
{
   temperature = i;
}
void adjust_personal_temp(int i)
{
   temperature += i;
}
int query_personal_temp()
{
   return temperature;
}
string query_temp_str()
{
   if (!temperature_str || temperature_str == "") {
      return "quite comfortable";
   }
   return temperature_str;
}
int calc_personal_temp()
{
   mixed tmp;
   object where,
    *clothes;
   string item,
     zone,
     type,
    *types,
    *zones;
   int adjustment,
     room_temp,
     correction,
    *enums;
   if (this_object()->query_property("dead")) {
      temperature = 0;
      return 0;
   }
   where = environment(this_object());
   if (!where->query_property("location") &&
       environment(where) && environment(where)->query_property("location"))
      where = environment(where);
   switch (where->query_property("location")) {
   case "outside":
      room_temp = (WEATHER->query_temperature(where) - COMFORTABLE);
      break;
   default:
      room_temp = 0;
   }
   room_temp += where->query_property("warmth");
   room_temp -= where->query_property("cooling");
   adjustment = room_temp;
   adjustment += this_object()->query_property("warmth");
   adjustment -= this_object()->query_property("cooling");
   clothes = filter_array(this_object()->query_wearing(),
                          (: !$1->id("scabbard") &&
                             !$1->id("belt") &&
                             !$1->id("backpack") &&
                             !$1->id("glasses") && !$1->id("jewellery") :));
   zones = ({ });
   foreach(item in clothes) {
      tmp = item->query_type();
      if (arrayp(tmp))  types = tmp;
      else types = ({ tmp });
      foreach(type in types) {
         if (CLOTHING_HANDLER->query_equivilant_type(type))
            type = CLOTHING_HANDLER->query_equivilant_type(type);
         foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
            if (member_array(zone, zones) == -1) {
               zones += ({ zone });
            }
            tmp = item->query_property("warmth");
            if (!tmp) {
               adjustment++;
            } else if (intp(tmp) && tmp) {
               adjustment += tmp;
            }
            if (room_temp > 0 && item->query_property("cooling")) {
               adjustment -= item->query_property("cooling");
            }
         }
      }
   }
   if (room_temp < 0) {
      adjustment += sizeof(zones);
      if (room_temp + sizeof(zones) > 5) {
         adjustment -= (room_temp + sizeof(zones) - 5);
      }
   } else {
      adjustment -= sizeof(zones);
      if (room_temp - sizeof(zones) < -5) {
         adjustment -= (room_temp - sizeof(zones) + 5);
      }
   }
   enums = (int *) this_object()->effects_matching("body.wetness");
   if (sizeof(enums)) {
      adjustment -= sqrt(sqrt((int) this_object()->arg_of(enums[0]))) * 2;
   }
   if (temperature > room_temp && room_temp >= 0 || temperature > 5) {
      correction -= (temperature / 5) + 5;
   }
   if (temperature < room_temp && room_temp <= 0 || temperature < -5) {
      correction -= (temperature / 5) - 5;
   }
#ifdef 0
   if ((room_temp < 10 && temperature >= 0) ||
       (room_temp > 10 && temperature <= 0)) {
      factor = (ABS(room_temp - temperature) / 10.0);
      if (factor > 1.0 || factor < 0.0)
         factor = 1.0;
   } else {
      factor = 1.0;
   }
   temperature += to_int((adjustment + correction) * factor);
#endif
   temperature += (adjustment + correction);
   temperature_str = (this_object()->query_race_ob())->
      temperature_effects(this_object(), temperature);
   return temperature;
}
string weather_extra_look()
{
   if (stringp(temperature_str) && strlen(temperature_str)) {
      return capitalize((string) this_object()->query_pronoun()) + " looks " +
         temperature_str + ".\n";
   }
   return "";
}

==================================================
FILE: shut.c
==================================================

inherit "/std/container";
#include <config.h>
int time_of_crash;
void setup() {
  if ( file_name( this_object() ) != "/global/shut" ) {
    write("This object can't be cloned.\n");
    dest_me();
    return;
    }
  set_name("offler");
  set_living_name("offler");
  add_adjective( ({ "offler", "the", "crocodile" }));
  add_alias("god");
  enable_commands();
  set_short( "Offler" );
  add_property( "determinate", "" );
  set_long("The Crocodile God.  He looks big, green, and, well "+
           "like this really.\n");
  add_alias("shut");
  move(CONFIG_START_LOCATION,
      "Offler the Crocodile God appears in a puff of smoke.",
      "Offler the Crocodile God appears in a puff of smoke.");
  reset_get();
}
#define ishout(str) shout("Offler the Crocodile God shouts: "+str+"\n")
void ashout( string words ) {
  int i;
  object *people;
  people = users();
  for ( i = 0; i < sizeof( people ); i++ )
    tell_object( people[ i ], "Offler the Crocodile God shouts: "+
        words +"\n" );
}
void heart_beat() {
  int time_to_crash;
  if (!time_of_crash) return;
  time_to_crash = time_of_crash - time();
  if (time_to_crash < 1) {
    call_out("end_it_all",0);
    set_heart_beat(0);
    return;
  }
  if (time_to_crash < 10)  {
    ashout( "Game reboot in "+ time_to_crash +" seconds." );
    return;
  }
  if (time_to_crash < 60 && time_to_crash % 10 < 2) {
    ashout( "Game is rebooting in "+ time_to_crash +" seconds." );
    return;
  }
  if (time_to_crash % 60 > 1) return;
  time_to_crash /= 60;
  if (time_to_crash > 30) {
    return ;
  }
  if(time_to_crash == 1)
  {
    ashout( "Game is rebooting in one minute." );
    return;
  }
  if (time_to_crash < 10 || !(time_to_crash % 10)) {
    ishout( "Game is rebooting in "+ time_to_crash +" minutes." );
    return;
  }
}
void shut(int minutes) {
  object *players;
  int i;
  string fname;
  if (!intp(minutes)) {
    write("Bad argument\n");
    return;
  }
  fname = file_name(previous_object());
  if (minutes <= 0) {
    write("No time given\n");
    return;
  }
  players = users();
  for (i=0;i<sizeof(players);i++)
    if (players[i]->query_creator())
      tell_object(players[i], "Offler the Crocodile God wishes you to know:\n"+
          "The mud is rebooting in "+ number_as_string( minutes ) +
          " minutes.\n" );
  set_long("He is firmly concentrating on counting.\n");
  if (time_of_crash)
    write( "There was already a reboot scheduled, set for "+
      (time_of_crash - time()) + " seconds.\n");
  time_of_crash = time() + minutes*60;
  set_heart_beat(1);
}
string long(string str, int dark) {
  ::long();
  if (time_of_crash && this_player()->query_wizard())
     return ::long(str,dark)+
            "Game reboot will be in " + ( time_of_crash - time() ) +
            " seconds.\n";
  return ::long(str,dark);
}
void end_it_all() {
  int i;
  object *obs;
  ishout("Shutdown now!");
  obs = users();
  for (i=0;i<sizeof(obs);i++)
    call_out("force_quit", i, obs[i]);
  call_out("blue", 10);
}
void force_quit(object ob) {
  if (!objectp(ob))
    return ;
  if (!ob->query_property("quiting frog"))
    ob->quit_alt();
}
void blue() {
  if (sizeof(users()) > 0 &&
      time() - time_of_crash < 120)
    call_out("blue", 10);
  else
    shutdown(0);
}
int query_time_to_crash() {
  if ( !time_of_crash ) {
    call_out( "dest_me", 1 );
    return 9999;
  }
  return time_of_crash - time();
}

==================================================
FILE: spells.c
==================================================

#include "spells.h"
nosave mixed *_spell_effects;
void create() {
  _spell_effects = ({ });
}
mixed query_effects() { return _spell_effects; }
int queue_commands() { return sizeof( _spell_effects ); }
int add_spell_effect(int no_rnds, string type, string name, object callee,
                     string func, mixed params) {
  int i,j;
   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("add_spell_effect in %s\n",
                          file_name(this_object())));
  if ((i=member_array(type, _spell_effects)) != -1)
    if ((j=member_array(name, _spell_effects[i+1])) == -1)
      _spell_effects[i+1] += ({ name, ({ no_rnds, callee, func, params }) });
    else
      _spell_effects[i+1][j+1] = ({ no_rnds, callee, func, params });
  else
    _spell_effects += ({ type, ({ name, ({ no_rnds, callee, func, params }) }) });
}
int remove_spell_effect(string name) {
  int i, j;
   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("remove_spell_effect in %s\n",
                          file_name(this_object())));
  for (i=0;i<sizeof(_spell_effects);i+=2)
    if ((j=member_array(name, _spell_effects[i+1])) != -1) {
      _spell_effects[i+1] = delete(_spell_effects[i+1], j, 2);
      if (!sizeof(_spell_effects[i+1])) {
        _spell_effects = delete(_spell_effects, i, 2);
        i -= 2;
      }
    }
  return 1;
}
mixed query_spell_effect(string name) {
   int i;
   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("query_spell_effect in %s\n",
                          file_name(this_object())));
  if ((i=member_array(name, _spell_effects)) == -1)
    return 0;
  if (sizeof(_spell_effects[i+1]))
    return _spell_effects[i..i]+_spell_effects[0..1];
  return 0;
}
mixed *query_spell_effects_type(string type) {
  int i, j;
  mixed *ret;
  if ((i=member_array(type, _spell_effects)) == -1)
    return ({ });
  ret = ({ });
  for (j=0;j<sizeof(_spell_effects);j+=2)
    ret += ({ _spell_effects[i], _spell_effects[i+1][j..j+1] });
  return ret;
}
int do_spell_effects(object attacker) {
  int i, j;
  this_object()->remove_property("casting");
  for (i=0;i<sizeof(_spell_effects);i+=2)
    for (j=0;j<sizeof(_spell_effects[i+1]);j+=2) {
      call_out("do_call_out_effect", 1, ({ _spell_effects[i+1][j+1], attacker }));
      _spell_effects[i+1][j+1][SP_NO_RNDS]--;
      if ( !_spell_effects[i+1][j+1][SP_NO_RNDS] || !_spell_effects[i+1][j+1][SP_OBJECT]) {
        _spell_effects[i+1] = delete(_spell_effects[i+1], j, 2);
        j -= 2;
        if (!sizeof(_spell_effects[i+1])) {
          _spell_effects = delete(_spell_effects, i, 2);
          i -= 2;
          break;
        }
      }
    }
    return 0;
}
void do_call_out_effect(mixed *params) {
  if (params[0][SP_OBJECT])
    call_other(params[0][SP_OBJECT],
             params[0][SP_FUNC],
             params[1],
             params[0][SP_PARAM],
             params[0][SP_NO_RNDS]);
}

==================================================
FILE: start_position.c
==================================================

inherit "/std/basic/virtual_quit_control";
#include <playerinfo.h>
#include <config.h>
#define MULTIPLAYER "/obj/handlers/multiplayer"
private int  *saved_co_ords;
private string last_pos;
private string *starts;
protected void inform_entered_game();
int query_creator();
string query_name();
string query_cap_name();
string the_short();
varargs int move(string pos, string messin, string messout);
string query_nationality_start_location();
void create() {
   starts = ({ });
}
int *query_saved_co_ords() { return saved_co_ords; }
protected void set_last_pos(string pos) {
  if(pos[0..4] != "/room")
    last_pos = pos;
}
string query_last_pos() {
   return last_pos;
}
string query_start_pos() {
   string start_pos;
   if ( !sizeof( starts ) ) {
      start_pos = query_nationality_start_location();
   } else {
      start_pos = starts[ 0 ];
   }
   if ( !find_object( start_pos ) ) {
      if ( catch( call_other( start_pos, "??" ) ) ) {
         start_pos = query_nationality_start_location();
      }
   }
   return start_pos;
}
string *query_starts() {
   return starts;
}
void reset_starts() { starts = ({ }); }
void add_start( string start_file, string start_desc ) {
   if ( !starts ) {
      starts = ({ });
   }
   if ( member_array( start_file, starts ) != -1 ) {
      return;
   }
   starts += ({ start_file, start_desc });
}
void remove_start( string start_file ) {
   int i;
   if ( !starts ) {
      return;
   }
   i = member_array( start_file, starts );
   if ( i == -1 ) {
      return;
   }
   starts = delete( starts, i, 2 );
}
void set_start_location( string start_file ) {
  int i;
  if ( !starts) {
    return ;
  }
  i = member_array(start_file, starts);
  if (i <= 0) {
    return ;
  }
  starts = starts[i..i + 1] + starts[0..i - 1] + starts[i + 2..];
}
protected void move_to_start_pos() {
   if (!last_pos || catch(call_other(last_pos, "??"))) {
      last_pos = query_start_pos();
      saved_co_ords = 0;
   }
   move(last_pos);
   if ( !last_pos->query_co_ord() && !last_pos->query_property( "no map" ) &&
         saved_co_ords && !query_creator() ) {
      last_pos->set_co_ord( saved_co_ords );
   }
   inform_entered_game();
}
private function query_extra_login_stuff(string start) {
   string ip_str;
   object *obs;
   object mph;
   string alert;
   int num;
   string *dups;
   switch (this_object()->query_invis()) {
      case 3 :
         start += " (trustee invisible)";
         break;
      case 2 :
         start += " (director invisible)";
         break;
      case 1 :
         start += " (invisible)";
         break;
   }
   mph = load_object(MULTIPLAYER);
   obs = filter(users() - ({ this_object() }),
                (: query_ip_number($1) == query_ip_number(this_object()) &&
                   !$1->query_login_ob() :));
   if (sizeof(obs) &&
       sizeof((dups = mph->check_allowed(this_object(), obs)))) {
      ip_str = " (" + query_ip_name(this_object()) + ")";
      ip_str += " Duplicate: " + query_multiple_short(dups);
   }
   if (!catch(num = PLAYERINFO_HANDLER->query_alerts_for(query_name()))) {
      if (num > 0) {
         alert = " %^BOLD%^%^RED%^" + num + " alert";
         if (num > 1) {
            alert += "s";
         }
         alert += "%^RESET%^";
      }
   }
   if (ip_str) {
      if (!alert) {
         alert = "";
      }
      return (: $(start) +
                       ($1->query_creator()?$(ip_str) + $(alert):"") :);
   } else {
      if (alert) {
         return (: $(start) + ($1->query_creator()?$(alert):"") :);
      } else {
         return (: $(start) :);
      }
   }
}
protected void inform_entered_game() {
   string logon_str;
   if ("/d/liaison/master"->query_member( query_name() ) ) {
      logon_str = query_cap_name() + " enters "
           "" + mud_name() + " %^YELLOW%^(Liaison)";
   } else {
      logon_str = query_cap_name() + " enters " +
           ( this_object()->query_property( "guest" ) ? "as a guest of " : "" ) +"" + mud_name() + ""+
           ( this_object()->query_property( "new player!" ) ? " (new player)" : "" );
   }
   user_event( this_object(), "inform",
               query_extra_login_stuff(logon_str),
               "logon", this_object());
   say(the_short()+" enters the game.\n", 0);
   last_pos->enter(this_object());
}
void inform_reconnect_game() {
   user_event( "inform",
         query_extra_login_stuff(query_cap_name() +
         " reconnects"), "link-death", this_object() );
}
void check_last_pos() {
   last_pos = find_start_pos(this_object(), environment());
   saved_co_ords = find_start_coord(this_object(), environment());
}

==================================================
FILE: telnet.c
==================================================

#include "telnet.h"
nosave string last_term;
nosave int got_terminal;
void check_terminal_type(string type);
void telnet_suboption(string str) {
  switch (str[0]) {
    case TELOPT_TTYPE :
      if (str[1] != TELQUAL_IS)
        return ;
      check_terminal_type(str[2..1000]);
      break;
  }
}
void player_connected() {
  printf("%c%c%c", IAC, DO, TELOPT_TTYPE);
  printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
}
void check_terminal_type(string type) {
  if (last_term == type) {
    if (!got_terminal)
      this_object()->set_network_terminal_type(0);
    return ;
  }
  if (!got_terminal && this_object()->set_network_terminal_type(type))
    got_terminal = 1;
  printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
  last_term = type;
}

==================================================
FILE: wiz_channels.c
==================================================

#include <broadcaster.h>
#include <creator.h>
#include <network.h>
#include <newudp.h>
#define TALKER "/std/shadows/object/talker"
#define BEEP sprintf("%c",7)
#define CHAN_OK 1
#define CHAN_FORCED 2
#define CHAN_EMOTED 4
#define CHAN_QUERY 8
private int channel_cmd(string mess);
private int channel_hist();
nomask string *channel_list() {
  string channel, *tmp, *channels;
  tmp = "/secure/master"->query_domains();
  tmp -= NO_CHANNELS;
  channels = ({ });
  foreach(channel in tmp)
    if("/secure/master"->query_senior(this_object()->query_name()) ||
       ("/d/"+channel+"/master")->query_member(this_object()->query_name()))
      channels += ({ channel });
  channels += ADDITIONAL_CHANNELS + keys(INTERMUD_MAP);
  if(this_object()->query_lord())
    channels += ({ "lord" });
  return channels;
}
void wiz_commands() {
  string channel;
  foreach(channel in channel_list()) {
    add_command(channel, "<string'mess'>", (: channel_cmd($4[0]) :));
    add_command(channel+"@", "<string'mess'>", (: channel_cmd("@"+$4[0]) :));
    add_command(channel+"?", "", (: channel_cmd("?") :));
    if(!INTERMUD_MAP[channel]) {
      add_command(channel+"!", "", (: channel_cmd("!") :));
      add_command("h"+channel, "", (: channel_hist() :));
    }
  }
}
private void my_mess(string fish, string erk) {
  int bing;
  if (!interactive(this_player())) {
    return;
  }
  bing = strlen(fish);
  if (bing > 15) {
    bing = 15;
  }
  efun::tell_object(this_player(),
                    this_player()->fix_string(sprintf("%s%s\n", fish, erk),
                                              (int)this_player()->query_cols(),
                                              bing));
}
protected int handle_command_line(string channel, string mess) {
  int retval;
  function map_func;
  int i;
  object *people, *off_line;
  add_failed_mess("Syntax: "+channel+"[@|?] [text]\n");
  if(!channel || !mess) {
    return 0;
  }
  if(member_array(channel, channel_list()) == -1) {
    add_failed_mess("No such channel " + channel + ".\n");
    return 0;
  }
  switch (mess[0]) {
  case '!' :
    retval |= CHAN_FORCED;
    break;
  case '@' :
    retval |= CHAN_EMOTED;
    break;
  case '?' :
    if (mess == "?") {
      if(INTERMUD_MAP[channel]) {
        SERVICES_D->eventSendChannelWhoRequest(INTERMUD_MAP[channel]);
        retval |= CHAN_QUERY;
        return retval;
      }
      people = filter(users(), (: $1 && $1->query_creator() &&
                                $1->query_visible(this_object()) :));
      off_line = ({ });
      for (i=0;i<sizeof(people);i++) {
        if(!people[i] || !people[i]->channel_list() ||
           member_array(channel, people[i]->channel_list()) == -1) {
          people = delete(people, i, 1);
          i--;
        } else if(people[i]->check_earmuffs(channel) ||
                  (member_array(channel, keys(INTERMUD_MAP)) != -1 &&
                   people[i]->check_earmuffs("intermud-all"))) {
          off_line += ({ people[i] });
          people = delete(people, i, 1);
          i--;
        }
      }
      people = sort_array(people, (: strcmp($1->query_name(),
                                            $2->query_name()) :) );
      off_line = sort_array(off_line, (: strcmp($1->query_name(),
                                                $2->query_name()) :) );
      map_func = function (object ob) {
        string str;
        if (ob->query_invis()) {
          if (ob->query_invis() == 2) {
            str = "({" + $1->query_cap_name() + "})";
          } else {
            str = "(" + $1->query_cap_name() + ")";
          }
        } else {
          str = $1->query_cap_name();
        }
        if (query_idle(ob) > 120) {
          int hours, mins, secs;
          secs = query_idle(ob);
          mins = secs / 60;
          secs %= 60;
          hours = mins / 60;
          mins %= 60;
          if ( !hours )  {
            str += sprintf(" [%02dm]", mins);
          } else {
            str += sprintf(" [%02dh:%02dm]", hours, mins);
          }
        }
        return str;
      };
      people = map(people, map_func);
      off_line = map(off_line, map_func);
      if (sizeof(people)) {
        write(sprintf( "On line: %-=" + (this_player()->query_cols() - 10) +
                       "s", query_multiple_short( people ) +".\n"));
      }
      if (sizeof(off_line)) {
        write(sprintf( "Off line: %-=" + (this_player()->query_cols() - 11) +
                       "s", query_multiple_short( off_line ) +".\n"));
      }
      retval |= CHAN_QUERY;
    }
    break;
  default :
    return CHAN_OK;
    break;
  }
  return retval;
}
private int channel_cmd(string mess) {
  int flags;
  string pad = " ";
  string start;
  string channel;
  object *things;
  channel = query_verb();
  if(channel[<1] == '?' || channel[<1] == '@' || channel[1] == ':') {
    channel = channel[0..<2];
  }
  flags = handle_command_line(channel, mess);
  if (!flags) {
    return 0;
  }
  if (flags & CHAN_QUERY) {
    return 1;
  }
  if(mess[0] == '!' || mess[0] == '@' || mess[0] == '?') {
    mess = mess[1..1000];
  }
  if (mess[0] == ' ') {
    mess = mess[1..1000];
  }
  if (mess == "") {
    return 0;
  }
  if (this_object()->check_earmuffs(channel)) {
    write("Why use " + channel + "-tell when you can't hear a response?\n");
    return 1;
  }
  mess = replace(mess, BEEP, "");
  if (mess[0..0] == "'") {
    pad = "";
  }
  if (flags & CHAN_EMOTED) {
    start = this_object()->query_cap_name() + pad;
    if(INTERMUD_MAP[channel])
      SERVICES_D->eventSendChannel((string)this_player()->query_cap_name(),
                                   INTERMUD_MAP[channel], "$N " + mess,
                                   flags & CHAN_EMOTED);
    else
      my_mess("(" + channel + ") "+
              ((string)this_object()->query_cap_name()) + pad,
              mess);
  } else {
    start = this_object()->query_cap_name() +": ";
    if(INTERMUD_MAP[channel])
      SERVICES_D->eventSendChannel((string)this_player()->query_cap_name(),
                                   INTERMUD_MAP[channel], mess,
                                   flags & CHAN_EMOTED);
    else
      my_mess("You " + channel + "-tell: ", mess);
  }
  if(INTERMUD_MAP[channel]) {
    user_event(this_object(), "intermud_tell", start, mess, channel);
    if(channel == "dwchat") {
      things = children(TALKER);
      things -= ({ find_object(TALKER) });
      if ( flags & CHAN_EMOTED ) {
        mess = ":" + mess;
      }
      things->receive("intermud", this_object()->query_cap_name(),
                       mess);
    }
  } else {
    user_event(this_object(), "creator_tell", start, mess,
                flags & CHAN_FORCED, channel);
    HIST_HANDLER->add_chat_history(channel, start, mess);
  }
  return 1;
}
private int channel_hist() {
  int i;
  mixed *hist;
  string channel;
  channel = query_verb()[1..];
  hist = HIST_HANDLER->query_chat_history(channel);
  if (!pointerp(hist) || !sizeof(hist)) {
    return notify_fail("Nobody said anything on the " + channel +
                       " channel.\n");
  }
  write("The " + channel + " channel history is:\n");
  for (i=0;i<sizeof(hist);i++) {
    if (sizeof(hist[i]) > 2) {
      efun::tell_object(this_object(),
                        this_object()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_object()->query_cols()-strlen(hist[i][0])-11,
                                                          hist[i][1])));
    } else {
      efun::tell_object(this_object(),
                        (string)this_object()->fix_string(sprintf("%s%-=*s\n",
               hist[i][0], (int)this_object()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
    }
  }
  return 1;
}

==================================================
FILE: wiz_file_comm.c
==================================================

#include <creator.h>
#include <login_handler.h>
#include <ls.h>
#include <playtesters.h>
#include <player_handler.h>
#include <cmds/friends.h>
#ifdef USE_LE
inherit "/global/le";
#endif
inherit "/global/wiz_object_comm";
inherit "/global/playtester";
inherit "/global/wiz_info_comm";
inherit "/global/wiz_channels";
inherit "/global/wiz_inter_comm";
private int invis;
private string *allowed;
private nosave mixed _in_wiz_editor;
private nosave string *dir_list;
private nosave mixed last_location;
private int change_dir(string str);
private int pushd(string str);
private int popd();
protected int set_home_dir(string str);
private int visible();
private int invisible(string level);
private int allow(string word);
private int disallow(string word);
void create() {
   playtester::create();
   wiz_object_comm::create();
   allowed = ({ });
}
protected void wiz_commands() {
   wiz_object_comm::wiz_commands();
   wiz_info_comm::wiz_commands();
   wiz_inter_comm::wiz_commands();
   wiz_channels::wiz_commands();
#ifdef USE_LE
   le::le_commands();
#endif
   add_command("cd", this_object(), "<string'directory'>", (: change_dir($4[0]) :));
   add_command("cd", this_object(), "", (: change_dir(0) :));
   add_command("pushd", this_object(), "<string'directory'>", (: pushd($4[0]) :));
   add_command("pushd", this_object(), "", (: pushd(0) :));
   add_command("popd", this_object(), "", (: popd() :));
   add_command("homedir", this_object(), "<string'directory'>", (: set_home_dir($4[0]) :));
   add_command("visible", this_object(), "", (: visible() :));
   add_command("vis", this_object(), "", (: visible() :));
   add_command("invisible", this_object(), "{1|2|3}", (: invisible($4[0]) :));
   add_command("invis", this_object(), "", (: invisible("1") :));
   if (this_player()->query_director()) {
      add_command("invis", this_object(), "{1|2|3}", (: invisible($4[0]) :));
   }
   add_command("allow", this_object(), "<word'name'>", (: allow($4[0]) :));
   add_command("allow", this_object(), "", (: allow(0) :));
   add_command("disallow", this_object(), "<word'name'>", (: disallow($4[0]) :));
   add_command("disallow", this_object(), "all", (: disallow("all") :));
}
nomask int query_invis() {
  return invis;
}
protected void set_invis(int level) {
   invis = level;
}
nomask string *query_allowed() {
  return copy(allowed);
}
int is_friend(string str) {
   return ::is_friend(str) ||
          member_array(str, allowed) != -1;
}
string query_friend_tag(string str) {
   string womble;
   if(!userp(previous_object())) {
     womble = ::query_friend_tag(str);
     if (!womble) {
       if (member_array(str, allowed) != -1) {
         return "allowed to reference";
       }
     }
     return womble;
   }
   return "";
}
string* query_friends() {
   if (file_name(previous_object()) == FRIENDS_CMD) {
      return ::query_friends() | allowed;
   }
   return ({ });
}
private int visible() {
   if (GetForced()) {
      return 0;
   }
   if (!query_invis()) {
      return notify_fail("You are already visible.\n");
   }
   if (invis >= 2) {
      invis = 0;
      LOGIN_HANDLER->player_logon(this_player()->query_name());
   } else {
      invis = 0;
   }
   write("You appear.\n");
   return 1;
}
private int invisible( string word ) {
   int max, type;
   if (GetForced()) {
      return 0;
   }
   if (!word) {
      word = sprintf("%d", query_invis());
      if (word == "0") {
         word = "1";
      }
   }
   max = 1 + (int)master()->query_director(query_name()) +
      (int)master()->query_trustee(query_name());
   if (!sscanf(word, "%d", type) || (type > max) || (type < 1)) {
      return notify_fail("Syntax: invisible [1"+ ( max > 1 ? "|2" : "" ) +
                         ( max > 2 ? "|3" : "" ) + "]\n");
   }
   word = ({ "frog", "creator", "director", "trustee" })[type];
   if (type == query_invis()) {
      return notify_fail("You are already "+ word +" invisible.\n");
   }
   if (type < invis && type < 2 && invis >= 2) {
      invis = type;
      LOGIN_HANDLER->player_login(this_player()->query_name());
   } else {
      invis = type;
   }
   write("You become "+ word +" invisible.\n");
   return 1;
}
private int allow(string word) {
    string player, mud;
   if (!word) {
      if (!sizeof(allowed)) {
         write("You are not allowing anyone to refer to you.\n");
      } else {
         write("You are currently allowing "+
               query_multiple_short( map_array( sort_array(allowed, 0),
                                                (: capitalize( $1 ) :))) +
               " to refer to you.\n" );
      }
      return 1;
   }
   word = lower_case(word);
   if ( word != "playtesters" && !PLAYER_HANDLER->test_user(word) &&
       sscanf( word, "%s@%s", player, mud ) != 2 ) {
      return notify_fail("There is no user called $C$"+ word +".\n");
   }
   if (member_array(word, allowed) != -1) {
      return notify_fail("You have already allowed $C$"+ word +
                         " to refer to you.\n");
   }
   allowed += ({ word });
   write(word +" is now allowed to refer to you.\n");
   return 1;
}
private int disallow(string word) {
   if (!word) {
      return notify_fail("Disallow who?\n");
   }
   if (word == "all") {
     allowed = ({ });
     write("Cleared your allow list.\n");
   } else {
     word = lower_case(word);
     allowed -= ({ word });
     write(word +" is no longer allowed to refer to you.\n");
   }
   return 1;
}
int query_visible(object thing) {
   string word;
   if (thing == this_object()) {
      return 1;
   }
   word = (string)thing->query_name();
   if (member_array(word, allowed) != -1) {
      return ::query_visible(thing);
   } else if((member_array("playtesters", allowed) != -1) &&
             PLAYTESTER_HAND->query_playtester(word)) {
     return ::query_visible(thing);
   }
   switch (query_invis()) {
   case 3 :
      return (int)master()->query_trustee(word);
   case 2 :
      return (int)master()->query_director(word);
   case 1 :
      return (int)thing->query_creator();
   default :
      return ::query_visible(thing);
   }
}
mixed query_in_editor() {
   return _in_wiz_editor || ::query_in_editor();
}
void set_in_editor(mixed what) {
   _in_wiz_editor = what;
}
private int change_dir(string str) {
   string *filenames;
   object *obs;
   if (GetForced()) {
      return 0;
   }
   if (!str) {
      if (!query_home_dir()) {
         add_failed_mess(this_object(),
                         "No homedir.  Use homedir to set it.\n", ({ }));
         return 0;
      }
      str = query_home_dir();
   }
   else {
      if ( this_object()->query_property( LS_COMMAND_NICKNAME_PROPERTY ) ) {
         str = this_object()->expand_nickname( str );
      }
   }
   filenames = get_files(str);
   if (sizeof(filenames) > 1) {
      add_failed_mess(this_object(),
                      "Ambiguous directory.\n", ({ }));
      return 0;
   }
   if (!sizeof(filenames)) {
      if (!sizeof(obs = WIZ_PRESENT->wiz_present(str, this_object()))) {
         add_failed_mess(this_object(),
                         "No such dir.\n", ({ }));
         return 0;
      }
      if (sizeof(obs) > 1) {
         add_failed_mess(this_object(),
                         "Ambiguous directory.\n", ({ }));
         return 0;
      }
      filenames =
         map(obs,
             (: sprintf("/%s",implode(explode(file_name($1), "/")[0..<2],
                                      "/")) :));
   }
   str = filenames[0];
   if (file_size(str) != -2) {
      printf("cd: %s: Not a directory.\n", str);
   } else {
      set_current_path(str);
   }
   printf("%s\n", query_current_path());
   return 1;
}
private int pushd(string str) {
   if (!dir_list) {
      dir_list = ({ });
   }
   dir_list += ({ query_current_path() });
   return change_dir(str);
}
private int popd() {
   string dest;
   if (!sizeof(dir_list)) {
      return 0;
   }
   dest = dir_list[sizeof(dir_list)-1];
   dir_list = delete(dir_list, sizeof(dir_list)-1, 1);
   return change_dir(dest);
}
string query_path() {
   return query_current_path();
}
private int set_home_dir(string str) {
   if (GetForced()) {
      return 0;
   }
   if (str) {
      ::set_home_dir(get_path(str));
   }
   printf("Home directory set to %s.\n", query_home_dir());
   return 1;
}
int query_ed_setup() {
   return query_property("ed_setup");
}
void set_ed_setup(int i) {
   add_property("ed_setup", i);
}
int review() {
   playtester::review();
   wiz_info_comm::review();
   return 1;
}
void set_last_location(mixed loc) { last_location = loc; }
mixed query_last_location() { return last_location; }
protected string process_input(string inp){
  int start;
  start = strsrch(inp, '@');
  if(start > 0){
    int space = strsrch(inp, ' ');
    if(!(space > 0 && ((space == start+1) || space < start))){
      inp = inp[0..start] + " " + inp[start+1..];
    }
  }
  start = strsrch(inp, '`');
  if(start > 0){
    int end;
    end = strsrch(inp, '`', -1);
    if(end != start){
      string lpc = inp[start+1..end-1];
      string err;
      mixed ret;
      ret = "/secure/cmds/creator/exe_c"->do_exec("return "+lpc, ref err);
      if(!err){
        if(intp(ret))
          ret = ""+ret;
        if(objectp(ret))
           ret = file_name(ret);
        if(arrayp(ret)){
          ret = filter(ret, (:stringp($1) || intp($1) || objectp($1):));
          ret = map(ret, (:intp($1)?""+$1:(objectp($1)?file_name($1):$1):));
          if(sizeof(ret))
            ret = implode(ret, ",");
        }
        if(stringp(ret)){
          inp = inp[0..start-1] + ret + inp[end+1..];
        }
      }
    }
  }
  return ::process_input(inp);
}
protected mixed command( string txt ) {
    return ::command( txt );
}

==================================================
FILE: wiz_info_comm.c
==================================================

#define PEOPLER "/obj/handlers/peopler"
protected int do_gauge(string str);
int add_command(string name, object ob, string format, function func);
protected void wiz_commands() {
  add_command("gauge", this_object(), "<string>", (: do_gauge($4[0]) :));
  if(clonep())
    call_out("driver_version", 20);
}
int driver_version(){
  string old = this_object()->query_property("driver_version");
  if(!old) {
    return this_object()->add_property("driver_version", __VERSION__);
  }
  if(old != __VERSION__){
    this_object()->add_property("driver_version", __VERSION__);
    write("%^RED%^The driver has been changed to version " +
          __VERSION__ + ", see /doc/driver/Changes for more information.%^RESET%^\n");
  }
  return 1;
}
int review() {
  PEOPLER->review();
  return 1;
}
protected int do_gauge(string str) {
  int eval_cost;
  if (this_player(1) != this_object()) return 0;
  if(!str) {
    notify_fail("Usage : gauge command.\n");
    return 0;
  }
  eval_cost = command(str);
  write("\nThe command '" + str + "' took: " + eval_cost + " CPU cycles.\n");
  return 1;
}

==================================================
FILE: wiz_inter_comm.c
==================================================

#include <network.h>
private nosave string *imud_ignored;
int do_block(string);
int do_unblock(string);
void wiz_commands() {
  add_command("block", "", (:do_block(0):));
  add_command("block", "<word'name'>", (:do_block($4[0]):));
  add_command("unblock", "<word'name'>", (:do_unblock($4[0]):));
}
int do_block(string str) {
  if (!str) {
    if (!sizeof(imud_ignored)) {
      write("Not blocking anyone.\n");
      return 1;
    }
    write("Blocking "+query_multiple_short(imud_ignored)+".\n");
    return 1;
  }
  if (!pointerp(imud_ignored))
    imud_ignored = ({ lower_case(str) });
  else
    imud_ignored += ({ lower_case(str) });
  write("Okay, now ignoring intermud channel messages from "+str+".\n");
  write("Use \"unblock\" to remove.\n");
  return 1;
}
int do_unblock(string str) {
  int idx;
  if (!str)
    return notify_fail("Syntax: unblock <name>|all\n");
  if (!pointerp(imud_ignored) || !sizeof(imud_ignored))
    return notify_fail("You are not blocking anyone.\n");
  if (str == "all") {
    imud_ignored = 0;
    write("Okay, unblocked everyone.\n");
    return 1;
  }
  if ((idx = member_array(lower_case(str), imud_ignored)) == -1)
    return notify_fail("You are not blocking "+str+".\n");
  imud_ignored = delete(imud_ignored, idx, 1);
  write("Okay, removed "+str+" from your blocked list.\n");
  return 1;
}
int check_not_ignored(string who) {
  if (!pointerp(imud_ignored))
    return 1;
  return member_array(lower_case(who), imud_ignored) == -1;
}

==================================================
FILE: wiz_object_comm.c
==================================================

#include <creator.h>
private nosave mapping obvar;
void create() {
   obvar = ([ ]);
}
protected void wiz_commands() {
}
int affirmative(string s)
{
    s = lower_case(s);
    return (s == "y" || s == "yes" || s == "ok" || s == "please");
}
void handle_error(string erm, string desc) {
    if (erm) {
         write(desc + " failed : " + erm);
    }
}
void set_obvar(string key, object value) {
  obvar[key] = value;
}
void del_obvar(string key) {
  map_delete(obvar, key);
}
object get_obvar(string key) {
  return obvar[key];
}
mapping get_obvars() {
  return obvar;
}
string desc_object(mixed o) {
  log_file("WIZ_PRESENT", sprintf("desc_object() called by %O.\n",
      previous_object()));
  return "";
}
string desc_f_object(mixed o) {
  log_file("WIZ_PRESENT", sprintf("desc_f_object() called by %O.\n",
      previous_object()));
  return "";
}
object *wiz_present(string str, object onobj, int nogoout) {
  log_file("WIZ_PRESENT", sprintf("wiz_present() called by %O.\n",
      previous_object()));
  return ({});
}

==================================================
FILE: wiz_present.c
==================================================

#include <obj_parser.h>
string desc_object(mixed o){
  string str;
  if (!o) return "** Null-space **";
  if (!catch(str = (string)o->short()) && str) return str;
  if (!catch(str = (string)o->query_name()) && str) return str;
  return file_name(o);
}
string desc_f_object(object o){
  string str, tmp;
  str = desc_object(o);
  if (o && str != file_name(o)) {
    if (tmp)
      str += " (" + tmp + ")";
    else
      str += " (" + file_name(o) + ")";
  }
  return str;
}
object *wzpresent2(string str, mixed onobj) {
  object *obs, ob, *obs2, obj;
  string s1;
  class obj_match result;
  if (pointerp(onobj)) {
    obs = ({ });
    foreach(ob in onobj)
      obs += wzpresent2(str,ob);
    return obs;
  }
  if (str == "all")
    return all_inventory(onobj);
  if (sscanf(str,"every %s",s1) == 1) {
    obs2 = all_inventory(onobj);
    obs = ({ });
    foreach (ob in obs2)
      if (ob->id(s1)) obs += ({ ob });
    return obs;
  }
  result = (class obj_match)match_objects_in_environments(str,onobj);
  if (result->result == OBJ_PARSER_SUCCESS ||
      result->result == OBJ_PARSER_AMBIGUOUS) {
    return result->objects;
  }
  if (obj = present(str,onobj)) return ({ obj });
  for (obj = first_inventory(onobj); obj; obj = next_inventory(obj)) {
    s1 = file_name(obj);
    if (sscanf(s1, "%*s/"+str+"#%*d") || sscanf(s1, "%*s#"+str))
      return ({ obj });
  }
  return ({ });
}
varargs object *wiz_present(string str, object onobj, int nogoout) {
  int j;
  object ob, *obs, *obs2;
  string s1, s2, *sts;
  mixed thing;
  class obj_match result;
  if (!str || !onobj)
    return ({ });
  seteuid(geteuid(this_player()));
  if(str[0] == '@') {
    if (ob = find_living(
        (string)this_player()->expand_nickname(extract(str, 1))))
      return ({ ob });
    notify_fail("Unable to find living object: "+extract(str,1)+".\n");
    return ({ });
  }
  if (str == "me") return ({ this_player() });
  if (str == "here") return ({ environment(this_player()) });
  if( str == "everyone") {
    if(!this_object()->query_lord())
      return ({ });
    obs = users();
    if(nogoout)
      return filter( obs, (: environment( $1 ) == $(onobj) :) );
    return obs;
  }
  if( str == "creators" ) {
    obs = filter( users(), (: $1->query_creator() :) );
    if(nogoout)
      return filter( obs, (: environment( $1 ) == $(onobj) :) );
    return obs;
  }
  if(str[0] == '/') {
    if (ob = find_object(str)) return ({ ob });
    if (sizeof((sts = (string *)this_player()->get_cfiles(str))))  {
      obs = ({ });
      obs = map(sts, (: find_object($1) :)) - ({0});
      return obs;
    }
    notify_fail("No loaded object: "+str+".\n");
    return ({ });
  }
  if (str[0] == '(' && str[strlen(str) - 1] == ')') {
    obs = wiz_present(extract(str,1,strlen(str) - 2),onobj);
    if (!sizeof(obs)) return obs;
    obs = map(obs, (: environment($1) :)) - ({0});
    return obs;
  }
  if (sscanf(str,"%s on %s",s1,s2) == 2 ||
      sscanf(str,"%s in %s",s1,s2) == 2) {
    obs = wiz_present(s2, onobj);
    if (!sizeof(obs)) return obs;
    obs2 = ({ });
    foreach (ob in obs)
      obs2 += wiz_present(s1, ob, 1);
    return obs2;
  }
  if (sscanf(str,"%s and %s",s1,s2) == 2) {
    obs = wiz_present(s1, onobj);
    obs2= wiz_present(s2, onobj);
    obs2 += filter(obs, (: member_array($1, $(obs2)) < 0 :));
    return obs2;
  }
  if (sscanf(str,"%s except %s",s1,s2) == 2 ||
      sscanf(str,"%s but %s",s1,s2) == 2) {
    obs = wiz_present(s1, onobj);
    obs2= wiz_present(s2, onobj);
    foreach (ob in obs2)
      while ((j=member_array(ob, obs)) > -1)
        obs = delete(obs,j--,1);
    return obs;
  }
  if (sscanf(str, "env of %s", s1) == 1) {
    obs = wiz_present(s1, onobj);
    if (!sizeof(obs)) {
       return obs;
    }
    return map(obs, (: environment($1) :)) - ({0});
  }
  if (sscanf(str, "children of %s", s1) == 1) {
    obs = wiz_present(s1, onobj);
    obs2 = ({ });
    foreach (ob in obs) {
      s1 = file_name(ob);
      sscanf(s1, "%s#%*d", s1);
      obs2 += children(s1);
    }
    return obs2;
  }
  if (sscanf(str,"player %s",s1)) {
    return ({ find_player(s1) });
  }
  if (!sizeof(obs2 = wzpresent2(str,onobj)) && !nogoout) {
    obs2 = wzpresent2(str, environment(onobj));
  }
  if (sizeof(obs2)) {
    return obs2;
  }
  result = (class obj_match)match_objects_in_environments(str,onobj);
  if (result->result == OBJ_PARSER_SUCCESS ||
      result->result == OBJ_PARSER_AMBIGUOUS) {
    return result->objects;
  }
  ob = find_living( this_player()->expand_nickname(str) );
  if( ob && ( !nogoout || ( environment(ob) == onobj ) ) )
    return ({ ob });
  if (thing = this_player()->get_obvar(str)) {
    if (objectp(thing)) return ({ thing });
    if (pointerp(thing)) {
      return filter( thing, (: objectp( $1 ) :) );
    }
  }
  if (sizeof((sts = (string *)this_player()->get_cfiles(str))))  {
    obs = ({ });
    obs = map(sts, (: find_object($1) :)) - ({0});
    return obs;
  }
  return ({ });
}

==================================================
FILE: virtual/c_compiler.c
==================================================

#include "virtual.h"
void initialize_methods();
void create() {
    initialize_methods();
    seteuid(getuid());
}
void initialize_methods() {
    SERVER->add_method("c",  file_name(this_object()), "compile_c");
}
object compile_c(string name, int clone) {
    if (!clone) {
	name->go_ahead_make_my_womble();
	return efun::find_object(name);
    } else {
	return efun::clone_object(name);
    }
}

==================================================
FILE: virtual/compiler.c
==================================================

#include "virtual.h"
#include "compiler.h"
void    initialize_methods();
string  strip_string( string str );
#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')
mapping o_funcs;
mapping r_funcs;
mapping arm_funcs;
mapping clo_funcs;
mapping sca_funcs;
mapping wep_funcs;
mapping cont_funcs;
mapping food_funcs;
mapping mon_funcs;
mapping clotrans_funcs;
object  return_ob;
int     tmp_file_no;
int     debug_file;
void    create()
{
  seteuid("Root");
  initialize_methods();
  o_funcs = O_FUN;
  r_funcs = O_FUN + R_FUN;
  arm_funcs = ARM_FUN + O_FUN;
  clo_funcs = CLO_FUN + O_FUN;
  sca_funcs = SCA_FUN + O_FUN;
  wep_funcs = WEP_FUN + O_FUN;
  mon_funcs = MON_FUN + O_FUN;
  cont_funcs = CONT_FUN + O_FUN;
  food_funcs = FOOD_FUN + CONT_FUN + O_FUN;
  clotrans_funcs = O_FUN + CLO_FUN + CLOTRANS_FUN;
}
object  query_return_ob()
{
    return return_ob;
}
void    set_return_ob( object ob )
{
    return_ob = ob;
}
void    initialize_methods()
{
    SERVER->add_method( "r", file_name( this_object() ), "compile_r",
                        CLONE|LOAD );
    SERVER->add_method( "ro", file_name( this_object() ), "compile_r",
                        CLONE|LOAD );
    SERVER->add_method( "ob", file_name( this_object() ), "compile_ob" );
    SERVER->add_method( "arm", file_name( this_object() ), "compile_arm" );
    SERVER->add_method( "clo", file_name( this_object() ), "compile_clo" );
    SERVER->add_method( "trans", file_name( this_object() ), "compile_clotrans" );
    SERVER->add_method( "sca", file_name( this_object() ), "compile_sca" );
    SERVER->add_method( "wep", file_name( this_object() ), "compile_wep" );
    SERVER->add_method( "mon", file_name( this_object() ), "compile_mon" );
    SERVER->add_method( "food", file_name( this_object() ), "compile_food" );
    SERVER->add_method( "cont", file_name( this_object() ), "compile_cont" );
    SERVER->add_method( "imp", file_name( this_object() ), "compile_imp" );
}
#define Error(s) write(s); log_file( "VO_COMPILER", s); return 0;
mixed  *extract_arguments( string str );
void    do_clone( object dest, string str )
{
    object  ob;
    ob = clone_object( str );
    if( ob )
        ob->move( dest );
}
object  prop_to_fun( string file, mapping funs, string virt_class,
                    string virt_include, int clone )
{
    string *segments, *ind, data, s1, dir, tmp_name, tmp_val;
    string file_data;
    mixed  *val;
    int     i;
    int pos;
    debug_file = 0;
    file_data = "";
    pos = strsrch(file, "/", -1);
    tmp_name = file[0..pos] + "." + file[pos+1..] + "_virtual_.c";
    if (file_size(tmp_name) <= 0 ||
        stat(file)[1] > stat(tmp_name)[1]) {
       tmp_file_no++;
       if( find_object( tmp_name ) ) {
           tmp_name->dest_me();
       }
       ind = explode( file, "/" );
       dir = implode( ind[ 0..sizeof( ind ) - 2 ], "/" );
       unguarded((: rm, tmp_name :));
       file_data = "#include <"+ virt_include +">\n\n"
                "void dest_me() { destruct( this_object() ); }\n\n"
                "void create()\n{\n"
                "  seteuid( (string)\"/secure/master\"->creator_file( file_name( this_object() ) ) );\n"
                "} \n"
                "\nobject create_virtual_ob() {\n"
                "   object clone;\n\n";
       data = read_file( file );
       if( !data )
       {
           Error( "prop_to_fun() : file " + file + " not found\n" );
       }
       segments = explode( "$\n" + data, "\n#" );
       if( !segments )
       {
           Error( "prop_to_fun() : Nothing but comments?\n" );
       }
       segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
       for( i = 1; i < sizeof( segments ); i++ ) {
           if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
               segments[ i ] = "";
           }
       }
       data = implode( segments, "\n" );
       segments = explode( strip_string( data ), "::" );
       if (sizeof( segments ) % 2) {
         segments += ({""});
       }
       ind = allocate( sizeof( segments ) / 2 );
       val = allocate( sizeof( segments ) / 2 );
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = segments[ i * 2 ];
           val[ i ] = replace( segments[ i * 2 + 1 ], "\n", " " );
           if( ind[ i ][ 0..0 ] == "#" )
           {
               ind[ i ] = lower_case( ind[ i ] );
               if( ind[ i ] == "#debug" )
               {
                   sscanf( val[ i ], "%d", debug_file );
               }
               else
               {
                   if( ind[ i ] == "#class" )
                   {
                       virt_class = replace( val[i], " ", "" );
                   }
                   else
                   {
                       if( ind[ i ] == "#include" )
                       {
                           tmp_val = val[i];
                           file_data += "#include " +
                                       replace( tmp_val, " ", "" ) +
                                       "\n";
                       }
                   }
               }
           }
       }
       file_data += "  clone = (object)SERVER->create_virtual_object( " +
                   virt_class + ", 1 );\n"
                   "  clone->add_property( VIRTUAL_NAME_PROP, \""
                   + file + (clone ? "#1" : "") + "\" );\n";
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = lower_case( ind[ i ] );
           if( ind[ i ][ 0..0 ] == "#" )
           {
               continue;
           }
           val[ i ] = replace( val[ i ], ({"(:", "bind( (:",
                                           ":)", ":), clone )" }) );
           if( ind[ i ][ 0..0 ] == "$" )
           {
               {
                   file_data +="  call_other( clone, \"" +
                               ind[ i ][ 1..100 ] + "\", " + val[ i ] +
                               " );\n";
               }
               continue;
           }
           if( funs[ ind[ i ] ] )
           {
               if( !pointerp( funs[ ind[ i ] ] ) )
               {
                   file_data += "  call_other( clone, \"" +
                               funs[ ind[ i ] ] + "\", " + val[ i ] + " );\n";
               }
               else
               {
                   file_data += "  call_other( " + funs[ ind[ i ] ][ 1 ] +
                               ", " + funs[ ind[ i ] ][ 0 ] + ", " + val[ i ] +
                               " );\n";
               }
           }
           else
           {
               write( "Error: Unknown index " + ind[ i ] + "\n" );
           }
       }
       file_data += "   return clone;\n} \n";
       unguarded((: write_file, tmp_name, file_data :));
   }
   if( data = catch( return_ob = tmp_name->create_virtual_ob() ) )
   {
        write( "Error loading " + file + ", " + data + "\n" );
        if( debug_file )
        {
            write( "File not removed.\n" );
        }
        else
        {
        }
    }
    else
    {
        tmp_name->dest_me();
        return return_ob;
    }
}
string  strip_string( string str )
{
    int     i, j;
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i < j; i++ ) ;
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
    return str[ i..j ];
}
mixed   str_to_var( string str )
{
    int     i;
    str = strip_string( str );
    switch( str[ 0 ] )
    {
        case '{':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return map_array( explode( str, "," ), "str_to_var",
                                  this_object() );
            }
        case '"':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return replace( str, "\n", " " ) + "\n";
            }
        case '0'..'9':
        case '-':
            {
                sscanf( str, "%d", i );
                return i;
            }
    }
    return str;
}
mixed  *extract_arguments( string str )
{
    return map_array( explode( str, "
}
object  compile_r( string name, int clone ) {
    object r;
    r = prop_to_fun( name, r_funcs, "\"/obj/virtual_room.c\"",
                    "virtual_room.h", 1 );
    r->reset();
    return r;
}
object  compile_ob( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/std/object.c\"",
                    "virtual.h", clone );
}
object  compile_arm( string name, int clone ) {
    if (name[0 .. 19] == "/obj/armours/shield/")
        return prop_to_fun(name, arm_funcs, "\"/obj/shield.c\"",
                        "virtual.h", clone );
    return prop_to_fun( name, arm_funcs, "\"/obj/armour.c\"",
                    "virtual.h", clone );
}
object  compile_clo( string name, int clone ) {
    return prop_to_fun( name, clo_funcs, "\"/obj/clothing.c\"",
                    "virtual.h", clone );
}
object compile_sca( string name, int clone ) {
   return prop_to_fun( name, sca_funcs, "\"/obj/scabbard.c\"",
                    "virtual.h", clone );
}
object  compile_wep( string name, int clone ) {
    return prop_to_fun( name, wep_funcs, "\"/obj/weapon.c\"",
                    "virtual.h", clone );
}
object  compile_mon( string name, int clone ) {
    return prop_to_fun( name, mon_funcs, "\"/obj/monster.c\"",
                    "virtual.h", clone );
}
object  compile_food( string name, int clone ) {
    return prop_to_fun( name, food_funcs, "\"/obj/food.c\"",
                    "virtual.h", clone );
}
object  compile_cont( string name, int clone ) {
    return prop_to_fun( name, cont_funcs, "\"/obj/cont_medium.c\"",
                    "virtual.h", clone );
}
object  compile_clotrans( string name, int clone ) {
    return prop_to_fun( name, clotrans_funcs, "\"/obj/clothing_transport.c\"",
                    "virtual.h", clone );
}
object  compile_imp( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/obj/implement.c\"",
                    "virtual.h", clone );
}
int set_debug_status(int d_stat) {
  debug_file=d_stat;
  return debug_file;
}

==================================================
FILE: virtual/compiler.h
==================================================

#define TMP_FILE "/global/virtual/tmp_file.c"
#define O_FUN ([ "item"  : "add_item",\
                 "name"  : "set_name",\
                 "long"  : "set_long",\
                 "light" : "set_light",\
                 "alias" : "add_alias",\
                 "plural" : "add_plural",\
                 "adjective" : "add_adjective",\
                 "plural adjective" : "add_plural_adjective",\
                 "main_plural" : "set_main_plural",\
                 "main plural" : "set_main_plural",\
                 "weight" : "set_weight",\
                 "length" : "set_length",\
                 "width" : "set_width",\
                 "value" : "set_value",\
                 "value info" : "set_value_info", \
                 "material" : "set_material", \
                 "property" : "add_property",\
                 "clone" : ({ "do_clone", file_name(this_object()) }), \
                 "money" : "adjust_money",\
                 "effect" : "add_effect",\
                 "read mess" : "add_read_mess", \
                 "short" : "set_short" ])
#define R_FUN ([ "exit" : "add_exit",\
                 "modify exit" : "modify_exit",\
                 "reset" : "add_reset_item",\
                 "dark mess" :  "set_dark_mess",\
                 "co ord" : "set_co_ord", \
                 "size" : "set_room_size", \
                 "zone" : "set_zone", \
                 "cloned object" : "add_cloned_object", \
                 "alias" : "add_alias", \
                 "sign" : "add_sign" ])
#define ARM_FUN ([ "setup" : "setup_armour",\
                   "no limbs" : "set_no_limbs", \
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "ac" : "add_ac", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "damage chance" : "set_damage_chance" ])
#define CLO_FUN ([ "setup" : "setup_clothing",\
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "pocket mess" : "set_pocket_mess", \
                   "pocket" : "add_pocket", \
                   "stuck" : "set_stuck", \
                   "key" : "set_key", \
                   "damage chance" : "set_damage_chance", \
                   "pair" : "set_is_pair" ])
#define CLOTRANS_FUN ([ \
                   "race" : "set_worn_by_race", \
                   "mount modifier" : "set_mount_difficulty_modifier", \
                   "direction modifier" : "set_direction_difficulty_modifier", \
                 ])
#define SCA_FUN ([ "setup" : "setup_scabbard",\
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "types" : "set_types", \
                   "damage chance" : "set_damage_chance" ])
#define CONT_FUN ([ \
                    "amount" : "set_amount", \
                    "continuous" : "set_continuous", \
                    "weight unit" : "set_weight_unit", \
                    "medium alias" : "set_medium_alias", \
                    "pile name" : "set_pile_name", \
                    "amount types" : "set_amount_types", \
                    "pile types" : "set_pile_types", \
                  ])
#define FOOD_FUN ([ \
                    "bites gone" : "set_bites_gone", \
                    "weight per bite" : "set_weight_per_bite", \
                    "eat mess" : "set_eat_mess", \
                    "eat effects" : "add_eat_effect", \
                    "piece description" : "set_piece_description", \
                  ])
#define WEP_FUN ([ "setup" : "new_weapon",\
                   "condition" : "set_condition", \
                   "enchant" : "set_enchant", \
                   "attack" : "add_attack", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune", \
                   "no limbs" : "set_no_limbs", \
                   "attack message" : "add_attack_message", \
                   "damage chance" : "set_damage_chance" ])
#define MON_FUN ([ "move after" : "set_move_after", \
                   "move zone" : "add_move_zone", \
                   "race" : "set_race", \
                   "class" : "set_class", \
                   "guild" : "set_guild", \
                   "level" : "set_level", \
                   "attack" : "add_attack", \
                   "attack message" : "add_attack_message", \
                   "ac" : "add_ac", \
                   "skill" : "add_skill_level", \
                   "equip" : "init_equip", \
                   "remove ac" : "remove_ac", \
                   "remove attack" : "remove_attack", \
                   "attack everyone" : "set_attack_everyone", \
                   "random stats" : "set_random_stats", \
                   "money" : "give_money", \
                   "chat" : "add_chat_string", \
                   "chat chance" : "set_chat_chance", \
                   "achat" : "add_achat_string", \
                   "achat chance" : "set_achat_chance", \
                   "talk string" : "add_talk_string", \
                   "join fights" : "set_join_fights", \
                   "alignment" : "set_al", \
                   "follow speed" : "set_follow_speed", \
                   "aggressive" : "set_aggressive", \
                   "str" : "set_str", \
                   "con" : "set_con", \
                   "dex" : "set_dex", \
                   "wis" : "set_wis", \
                   "bonus int" : "set_bonus_int", \
                   "bonus str" : "set_bonus_str", \
                   "bonus con" : "set_bonus_con", \
                   "bonus dex" : "set_bonus_dex", \
                   "bonus wis" : "set_bonus_wis", \
                   "int" : "set_int", \
                   "gender" : "set_gender", \
                   "command" : "add_known_command", \
                   "concentrate" : "set_concentrate", \
                   "protect" : "do_protect", \
                   "follow" : "do_follow", \
                   "throw out" : "set_throw_out", \
                   "basic setup" : "basic_setup" ])

==================================================
FILE: virtual/data_compiler.c
==================================================

#include "virtual.h"
#include <soul.h>
#include <random_names.h>
void initialize_methods();
void create() {
  initialize_methods();
  seteuid(getuid());
}
void initialize_methods() {
  SERVER->add_method("s",  file_name(this_object()), "compile_soul", 1);
  SERVER->add_method("r_n",  file_name(this_object()), "compile_random_name", 1);
}
object compile_soul(string name, int) {
  object ob;
  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(SOUL_DIR)-1] != SOUL_DIR) {
    return 0;
  }
  name = name[strlen(SOUL_DIR)..];
  SOUL_COMPILER->compile_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
}
object compile_random_name(string name, int clone) {
  object ob;
  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(RANDOM_NAME_DATA_DIR)-1] != RANDOM_NAME_DATA_DIR) {
    return 0;
  }
  name = name[strlen(RANDOM_NAME_DATA_DIR)..];
  RANDOM_NAME_GENERATOR->open_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
}

==================================================
FILE: virtual/efuns.c
==================================================

#define HANDLER "/global/virtual/handler"
object clone_object(string name) {
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
}
void destruct(mixed name) {
  object obj;
  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
}
string file_name(object obj) {
  string name, number, file;
  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
}
object find_object(string str) {
  object obj;
  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
}

==================================================
FILE: virtual/handler.c
==================================================

mapping cloned_objects;
create() {
  seteuid("Room");
  cloned_objects = ([ ]);
  unguarded((: restore_object, "/global/virtual/handler" :));
}
self_dest() {
  unguarded((: save_object, "/global/virtual/handler" :));
  destruct(this_object());
}
mapping query_cloned_objects() { return cloned_objects; }
destruct_virtual_object(object obj) {
  string name, trash;
  name = file_name(obj);
  if(sscanf(name, "%s#%s", name, trash) == 2)
    name = trash;
  if(cloned_objects[name])
    map_delete(cloned_objects, name);
}
object find_virtual_object(string name) {
  string trash;
  if(sscanf(name, "%s#%s", name, trash) == 2)
    name = trash;
  if(cloned_objects[name])
    return (object)cloned_objects[name];
  return (object)0;
}
int error(string str) {
  write(str+"\n");
  return 1;
}
int str_to_int(string str) {
  int i, j, k;
  for(i=strlen(str)-1,j=1;i>-1;k+=(str[i--]-48)*j,j*=10) ;
  return k;
}
mixed *sort_arguments(mixed *args) {
  int i;
  for(i=0;i<sizeof(args);i++) {
    if(pointerp(args[i]))
      args[i] = sort_arguments(args[i]);
    else if(args[i][0..0] != "\"")
      args[i] = str_to_int(args[i]);
    else {
      args[i] = args[i][1..strlen(args[i])-2];
      if(args[i][strlen(args[i])-2..strlen(args[i])-1] == "\\n")
        args[i] = args[i][0..strlen(args[i])-3] + "\n";
    }
  }
  return args;
}
mixed *add_item(mixed *args, int m, string str) {
  if(m == 0)
    args += ({ str });
  else
    args[sizeof(args)-1] = add_item(args[sizeof(args)-1], m-1, str);
  return args;
}
mixed *add_level(mixed *args, int m) {
  if(m == 0) {
    args += ({ "" });
    args[sizeof(args)-1] = ({ });
  } else
    args[sizeof(args)-1] = add_level(args[sizeof(args)-1], m-1);
  return args;
}
object use_efun_clone(string file) {
  log_file("NON_VIRTUAL", file +"\n");
  return efun::clone_object(file);
}
object clone_virtual_object(string file) {
  int i, j, k, l, m, len;
  string data, *line, file_to_inherit, start, comment, rest;
  object obj;
  mixed *args;
  if(file_size(file) > 5000)
    return use_efun_clone(file);
  data = read_file(file);
  line = explode(file, "/");
  file_to_inherit = "/" + implode(line[0..sizeof(line)-2], "/") + "/";
  line = ({ (string)0 });
  while(sscanf(data, "%s#include \"%s\"%s", start, comment, rest) == 3) {
    if(!(line[0] = read_file(file_to_inherit + comment)))
      line[0] = read_file("/include/" + comment);
    if(line[0])
      data = start + line[0] + rest;
    else {
      error("Include file not found.");
      return (object)0;
    }
  }
  while(sscanf(data, "%s%s", start, comment, rest) == 3)
    data = start + rest;
  i = 0;
  file_to_inherit = data;
  while(sscanf(file_to_inherit, "%sinherit%s", start, file_to_inherit) == 2) {
    i++;
  }
  if(i != 1)
    return use_efun_clone(file);
  i = 0;
  file_to_inherit = data;
  while(sscanf(file_to_inherit, "%s({%s", start, rest)  == 2)
    file_to_inherit = start + rest;
  while(sscanf(file_to_inherit, "%s{%s", start, file_to_inherit)  == 2)
    i++;
  if(i != 1)
    return use_efun_clone(file);
  if(!(sscanf(data, "%ssetup()%s", start, rest) == 2))
    return use_efun_clone(file);
  line = explode(data, "\n");
  line -= ({ "" });
  for(i=0;i<sizeof(line);i++) {
    len = strlen(line[i]);
    for(j=0;j<len;j++) {
      if((line[i][j..j] == " " || line[i][j..j] == "\t") && j == 0) {
        line[i] = line[i][1..len];
        j--;
      }
    }
    for(j=len-1;j>-1;j--) {
      if((line[i][j..j] == " " || line[i][j] == 0) && j == (len-1)) {
        line[i] = line[i][0..len-2];
        len--;
      }
    }
  }
  for(i=0;i<sizeof(line);i++)
    if((line[i][0..3] == "int ") ||
       (line[i][0..5] == "mixed ") ||
       (line[i][0..6] == "object ") ||
       (line[i][0..6] == "string ") ||
       (line[i][0..7] == "mapping "))
      return use_efun_clone(file);
  for(i=0;i<sizeof(line);i++)
    if(line[i][0..7] == "#define ") {
      len = strlen(line[i]);
      for(j=8;j<len && line[i][j..j] != " ";j++);
      comment = line[i][8..j-1];
      file_to_inherit = line[i][j+1..len];
      line = delete(line, i--, 1);
      if(j < len)
        for(k=0;k<sizeof(line);k++)
          if(sscanf(line[k], "%s"+comment+"%s", start, rest) == 2)
            line[k] = start + file_to_inherit + rest;
    }
  for(i=0;i<sizeof(line);i++) {
    for(j=0,k=0,l=0;j<strlen(line[i]);j++) {
      switch(line[i][j..j]) {
        case "\"" :
          if(!k) {
            k = 1;
            if(l && l+1 == j)
              if(l+2 < strlen(line[i]))
                line[i] = line[i][0..l-2] + line[i][l+2..strlen(line[i])];
              else {
                line[i] = line[i][0..l-2] + line[i+1];
                line = delete(line,i+1,1);
              }
          }
          else
            k = 0;
          break;
        case " " :
          if(!k)
            if(j)
              line[i] = line[i][0..--j] + line[i][j+2..strlen(line[i])];
            else
              line[i] = line[i][1..strlen(line[i])];
          break;
        case ";" :
          if(!k && j != strlen(line[i])-1) {
            line = line[0..i] + line[i][j+1..1000] + line[i+1..1000];
            line[i] = line[i][0..j];
            j=0;
          }
          break;
        case "+" :
          if(!k && j && line[i][j-1..j-1] == "\"")
            l = j;
          break;
      }
    }
    if((k)) {
      line[i] = line[i--] + line[i+2];
      line = delete(line,i+2,1);
    }
  }
  for(i=0;i<sizeof(line);i++) {
    len = strlen(line[i]);
    if(line[i][len-1..len-1] != ";")
      if(line[i][len-2..len-1] == "\"+") {
        if(line[i+1][0..0] == "\"")
          line[i] = line[i--][0..len-3] + line[i+2][1..1000];
        else
          line[i] = line[i--] + line[i+2];
        line = delete(line,i+2,1);
      }
  }
  for(i=0;i<sizeof(line);i++)
    if(line[i][0..6] == "inherit")
      file_to_inherit = line[i][8..sizeof(line[i])-3];
  if(file_to_inherit[0..8] == "/std/room")
    return use_efun_clone(file);
  obj = clone_object(file_to_inherit);
  obj->add_property("file_name", file);
  start = file_name(obj);
  if(sscanf(start, "%s#%s", start, rest) == 2)
    cloned_objects[rest] = obj;
  else
    cloned_objects[start] = obj;
  for(i=0;i<sizeof(line);i++)
    if(line[i] == "setup(){" || line[i] == "voidsetup(){")
      break;
  for(i++;i<sizeof(line);i++) {
    if(line[i] != "}") {
      sscanf(line[i], "%s(%s", start, comment);
      for(j=0,l=0,args=({});j<strlen(comment);j++) {
        if(comment[j..j] == "(") {
          if(comment[j+1..j+1] == "{" || comment[j+1..j+1] == "[") {
            args = add_level(args, l++);
            comment = comment[j+2..1000];
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == ")") {
          if(comment[j-1..j-1] == "}" || comment[j-1..j-1] == "]") {
            if(j-1)
              args = add_item(args, l--, comment[0..j-2]);
            comment = comment[j+1..1000];
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == "\"") {
          if(k)
            k = 0;
          else
            k = 1;
        }
        if(comment[j..j] == "," && k == 0) {
          if(!l) {
            if(j)
              args = add_item(args, l, comment[0..j-1]);
            comment = comment[j+1..1000];
            j = -1;
            continue;
          } else {
            if(comment[j+1..j+1] == "}" || comment[j+1..j+1] == "]") {
              if(!j)
                comment = comment[j+1..1000];
              else
                comment = comment[0..j-1] + comment[j+1..1000];
            } else {
              if(j)
                args = add_item(args, l, comment[0..j-1]);
              comment = comment[j+1..1000];
            }
            j = -1;
            continue;
          }
        }
        if(comment[j..j] == ")" && k == 0 && l == 0) {
          if(comment[j-1..j-1] != "}" && comment[j-1..j-1] != "]") {
            args = add_item(args, l, comment[0..j-1]);
            comment = comment[j+1..1000];
            j = -1;
          }
        }
      }
      args = sort_arguments(args);
      switch(sizeof(args)) {
        case 1 :
          call_other(obj, start, args[0]);
          break;
        case 2 :
          call_other(obj, start, args[0], args[1]);
          break;
        case 3 :
          call_other(obj, start, args[0], args[1], args[2]);
          break;
        case 4 :
          call_other(obj, start, args[0], args[1], args[2], args[3]);
          break;
        case 5 :
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4]);
          break;
        case 6 :
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4], args[5]);
          break;
        case 7 :
          call_other(obj, start, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          break;
      }
    }
  }
  log_file("VIRTUAL", file +"\n");
  return obj;
}

==================================================
FILE: virtual/modified_efuns.c
==================================================

#define MAX_SIZE 50000
varargs void say(string str, mixed avoid)
{
  if (!pointerp(avoid))
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  else
    avoid += ({ this_player(), previous_object() });
  if (!environment(previous_object()))
    if(this_player() && environment(this_player()))
      event(environment(this_player()), "say", str, avoid);
    else
      event(previous_object(), "say", str, avoid);
  else
  {
    if (environment(environment(previous_object())))
      event(environment(environment(previous_object())), "say", str, avoid);
    else
      event(environment(previous_object()), "say", str, avoid);
  }
}
varargs void tell_room(object ob, string str, mixed avoid) {
  if (!ob || !objectp(ob))
    return ;
  event(ob, "say", str, avoid);
}
void tell_object(object ob, string str) {
  if (objectp(ob))
    ob->event_write(previous_object(), str);
}
object find_living(string str) {
  string nick;
  object ob;
  if (this_player() && (nick = (string)this_player()->expand_nickname(str)))
    str = nick;
  if ((ob = efun::find_living(str)))
    if ((int)ob->query_invis() == 2) {
      if (member_array(this_player()->query_name(),
                       (object *)ob->query_allowed()) == -1)
        return 0;
    }
  return ob;
}
object find_player(string str) {
  object ob;
  if ((ob = efun::find_player(str)))
    if ((int)ob->query_invis() == 2)
      if (member_array(this_player()->query_name(),
                       (object *)ob->query_allowed()) == -1)
        return 0;
  return ob;
}
void log_file(string name, string mess) {
  if (file_size("/log/"+name) > MAX_SIZE) {
    seteuid("Root");
    rm("/log/"+name+".old");
    rename("/log/"+name, "/log/"+name+".old");
  }
  seteuid("Root");
  write_file("/log/"+name, mess);
  seteuid(0);
}
#ifdef MUD_NAME
string mud_name() {
  return capitalize(MUD_NAME);
}
#endif
void cat(string file, int start_line, int number) {
  string bing;
  seteuid(geteuid(previous_object()));
  bing = read_file(file, start_line, number);
  seteuid(0);
  if (bing)
    printf("%s", bing[0..5000]);
}
#define HANDLER "/global/virtual/handler"
object clone_object(string name) {
  seteuid(geteuid(previous_object()));
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
}
void destruct(mixed name) {
  object obj;
  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
}
string file_name(object obj) {
  string name, number, file;
  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
}
object find_object(string str) {
  object obj;
  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
}

==================================================
FILE: virtual/new_c_compiler.c
==================================================

object clone_virtual_object(string name) {
  return efun::clone_object(name);
}

==================================================
FILE: virtual/server.c
==================================================

#include "virtual.h"
void add_method(string suffix, mixed ob, string fun, int type);
mapping methods;
#define OB   0
#define FUN  1
#define TYPE 2
nosave mapping cache;
void create() {
  seteuid(getuid());
  methods = ([ ]);
  add_method("c", "/global/virtual/c_compiler.c", "compile_c",
                        CLONE|LOAD);
  add_method("C", "/global/virtual/c_compiler.c", "compile_c",
                        CLONE|LOAD);
  cache = ([ ]);
}
object create_virtual_object(string name, int clone);
void add_method(string suffix, mixed ob, string fun, int type) {
  if (!type)
    type = CLONE;
  if (!methods[suffix]) {
    methods[suffix] = ({ ob, fun, type });
  }
}
#define Error(s) write(s); log_file("VO_HANDLER", s); return 0;
string get_mod_time(string name) {
  if(cache[name])
    return cache[name];
  if(file_size(name) <= 0)
    cache[name] = "";
  else
    cache[name] = stat(name)[1];
  return cache[name];
}
object create_virtual_object(string name, int clone) {
  string *split;
  mixed  *method;
  object ob;
  split = explode(name, ".");
  method = methods[split[sizeof(split) - 1]];
  if (method) {
    if (clone ||
        (method[TYPE]&LOAD)) {
      ob =  (object) call_other(method[OB], method[FUN], name, clone);
      if (ob)  {
      ob->add_property(VIRTUAL_NAME_PROP, name);
        if (get_mod_time(name) != "")
          ob->add_property("virtual time", get_mod_time(name));
      }
      return ob;
    }
    return 0;
  }
  Error("create_virtual_object() : unknown suffix to " + name + "\n");
}
void reset() {
  cache = ([ ]);
}

==================================================
FILE: virtual/server2.c
==================================================

#include "virtual.h"
void add_method(string suffix, object ob, string fun, int type);
mapping methods;
#define OB   0
#define FUN  1
#define TYPE 2
#define LOAD   1
#define CLONE  2
void create() {
  seteuid(getuid());
  methods = ([ ]);
  add_method("C", "/global/virtual/c_compiler.c", "compile_c",
                        CLONE|LOAD);
}
object create_virtual_object(string name, int clone);
void add_method(string suffix, object ob, string fun, int type) {
  if (!type)
    type = CLONE;
  if (!methods[suffix]) {
    methods[suffix] = ({ ob, fun, type });
  }
}
#define Error(s) write(s); log_file("VO_HANDLER", s); return 0;
object create_virtual_object(string name, int clone) {
  string *split;
  mixed  *method;
  object ob;
  split = explode(name, ".");
  method = methods[split[sizeof(split) - 1]];
  if (method) {
    if (clone ||
        (method[TYPE]&LOAD)) {
      ob =  (object) call_other(method[OB], method[FUN], name, clone);
      ob->add_property("virtual name", name);
      return ob;
    }
    return 0;
  }
  Error("create_virtual_object() : unknown suffix to " + name + "\n");
}

==================================================
FILE: virtual/virtual.h
==================================================

#include <virtual.h>
#define SERVER "/global/virtual/server"
#define LOAD   1
#define CLONE  2

==================================================
FILE: virtual/vr_hand.c
==================================================

object compile_virtual_room(string filename);
void parse_object(object room, string command);
void create()
{
  seteuid(getuid(this_object()));
}
object compile_virtual_room(string filen)
{
  string tmp, tmp2;
  object new_room;
  int i;
  i=3;
  tmp=read_file(filen, 2, 1);
  tmp2=tmp[1..strlen(tmp)-2];
  new_room=clone_object("/"+tmp2);
  while (read_file(filen, i, 1))
  {
    tmp=read_file(filen, i, 1);
    if(tmp=="") break;
    parse_object(new_room, tmp);
    i++;
  }
  return new_room;
}
void parse_object(object room, string command)
{
  string *func_call,s1,s2,s3;
  int i1,i2,i3,i4;
  if(!command) return;
  func_call=explode(command, "#");
  if((string)func_call[0][0]==";") return;
  switch (func_call[0])
  {
    case "SHORT" :
      room->set_short(func_call[1]);
      break;
    case "LONG" :
      room->set_long(func_call[1]);
      break;
    case "EXIT" :
      room->add_exit(func_call[1], func_call[2]);
      break;
    case "LIGHT" :
      i1=sscanf(func_call[1], "%d", i2);
      room->set_light(i2);
      break;
    case "ITEM" :
      room->add_item(explode(func_call[1], ","), explode(func_call[2], ","));
      break;
    case "TASTE" :
      room->add_taste(func_call[1], func_call[2]);
      break;
    case "SMELL" :
      room->add_smell(func_call[1], func_call[2]);
      break;
    case "SOUND" :
      room->add_sound(func_call[1], func_call[2]);
      break;
    case "TOUCH" :
      room->add_feel(func_call[1], func_call[2]);
      break;
    case "OBJECT" :
      room->add_object(func_call[1]);
      break;
    case "ACTION" :
      i2=0;
      catch(i1=sscanf(func_call[3], "%d", i2));
      room->action_add(func_call[1], func_call[2], i2);
      break;
    case "CODE" :
      room->set_code_module(func_call[1]);
      break;
    case "PROP" :
      room->add_property(func_call[1], func_call[2]);
      break;
    case "COORD" :
      i1=sscanf(func_call[1], "%d,%d,%d", i2,i3,i4);
      room->set_co_ord(({i2,i3,i4}));
      break;
  }
  return;
}

==================================================
FILE: virtual/setup_compiler/Outside.c
==================================================

inherit "/std/outside.c";
#include "Room.inc"

==================================================
FILE: virtual/setup_compiler/Room.c
==================================================

inherit "/std/room.c";
#include "Room.inc"

==================================================
FILE: virtual/setup_compiler/SetupCompiler.c
==================================================

#include "SetupCompiler.h"
void initialize_methods();
object return_ob;
int tmp_file_no;
void create() {
  seteuid(getuid(this_object()));
  initialize_methods();
}
object query_return_ob() { return return_ob; }
void set_return_ob(object ob) { return_ob = ob; }
void initialize_methods() {
    SERVER->add_method("vrm",  file_name(this_object()), "compile_vrm");
    SERVER->add_method("vro",  file_name(this_object()), "compile_vro");
    SERVER->add_method("vrw",  file_name(this_object()), "compile_vrw");
    SERVER->add_method("vra",  file_name(this_object()), "compile_vra");
    SERVER->add_method("vrc",  file_name(this_object()), "compile_vrc");
}
#define Error(s) write(s); log_file("VO_COMPILER", s); return 0;
object prop_to_fun(string file, int clone, string incfile ) {
    string  data, data2, s1, *ind, dir, tmp_name;
    int      i;
    tmp_name = file+"-"+(tmp_file_no++)+".c";
    if (find_object(tmp_name))
      tmp_name->dest_me();
    ind = explode(file, "/");
    dir = implode(ind[0..sizeof(ind)-2], "/");
    unguarded((: rm, tmp_name :));
    unguarded((: write_file, tmp_name,
               "object MyRoom;\n"
               "#include \""+incfile+"\"\n\n"
               "object this_room() { return MyRoom; }\n" :));
    data = read_file(file);
    if (!data) {
        Error("prop_to_fun() : file " + file + " not found\n");
    }
    unguarded((: write_file, tmp_name, data :));
    unguarded((: write_file, tmp_name, "\n\n"
               "void dest_me() { destruct(this_object()); }\n\n"
               "void setup();\n\n"
               "void create() {\n"
               "  seteuid((string)\"/secure/master\"->"
               "creator_file(this_object()));\n"
               "  MyRoom = (object)\""+SERVER+
               "\"->create_virtual_object(CLONEFILE, 1);\n"
               "  MyRoom->add_property(\"virtual name\", \""+
               file+(clone?"#1":"")+"\");\n"
               "\n  setup();\n"+
               "\n MyRoom->reset(); \n"
               "  \""+file_name(this_object())+"\"->"
               "set_return_ob(MyRoom);\n} \n" :));
    if (data = catch(tmp_name->bing())) {
      write("Error loading "+file+", "+data+"\n");
      write("File could not be loaded.\n");
    } else {
      tmp_name->dest_me();
      unguarded((: rm, tmp_name :));
      return return_ob;
    }
}
object compile_vrc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+ROOMFUNCS );
}
object compile_vmc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+MON_FUNCS );
}
object compile_vac(string name, int clone) {
    return prop_to_fun(name, clone, PATH+ARM_FUNCS );
}
object compile_vwc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+WEP_FUNCS );
}
object compile_voc(string name, int clone) {
    return prop_to_fun(name, clone, PATH+OBJ_FUNCS );
}

==================================================
FILE: virtual/setup_compiler/SetupCompiler.h
==================================================

#define TMP_FILE "/global/virtual/tmp_file.c"
#define SERVER "/global/virtual/server"
#define PATH  "/global/virtual/setup_compiler/"
#define ROOMFUNCS  "VirtualRoom.h"
#define WEP_FUNCS  "VirtualWeapon.h"
#define OBJ_FUNCS  "VirtualObject.h"
#define ARM_FUNCS  "VirtualArmour.h"
#define MON_FUNCS  "VritualMonster.h"

==================================================
FILE: virtual/setup_compiler/UWater.c
==================================================

inherit "/std/uwater.c";
#include "Room.inc"

==================================================
FILE: virtual/setup_compiler/VirtualRoom.h
==================================================

#define CLONEFILE "/global/virtual/setup_compiler/Room.c"
mixed add_item(mixed a1, mixed a2)
 { MyRoom->add_item(a1,a2); }
mixed set_name(mixed a1)
 { MyRoom->set_name(a1); }
mixed set_long(mixed a1)
 { MyRoom->set_long(a1); }
mixed set_light(mixed a1)
 { MyRoom->set_light(a1); }
mixed add_property(mixed a1, mixed a2)
 { MyRoom->add_property(a1,a2); }
mixed set_short(mixed a1)
 { MyRoom->set_short(a1); }
mixed add_exit(string a1, string a2, string a3)
{
	if( file_size(a2) > 0 )
		{ MyRoom->add_exit(a1,a2,a3); return; }
	if( file_size(a2+".c") > 0 )
		{ MyRoom->add_exit(a1,a2+".c",a3); return ; }
	if( file_size(a2+".vrc") > 0 )
		{ MyRoom->add_exit(a1,a2+".vrc",a3); return; }
	if( file_size(a2+".r") > 0 )
		{ MyRoom->add_exit(a1,a2+".r",a3); return; }
	write("Error: Bad arg 2 to add_exit in virtual room");
	return;
}
mixed modify_exit(string m1, mixed *m2)
 { MyRoom->modify_exit(m1,m2); }
mixed set_dark_mess(mixed a1)
 { MyRoom->set_dark_mess(a1); }
mixed set_co_ord(mixed a1)
 { MyRoom->set_co_ord(a1); }
mixed set_zone(mixed a1)
 { MyRoom->set_zone(a1); }
void add_reset_func( mixed ob, string func )
{
  MyRoom->add_reset_func( ob, func );
}
void add_dest_func( mixed ob, string func )
{
  MyRoom->add_dest_func( ob, func );
}
void add_enter_func( mixed ob, string func )
{
  MyRoom->add_enter_func( ob, func );
}
void add_exit_func( mixed ob, string func )
{
  MyRoom->add_exit_func( ob, func );
}
void add_death_func( mixed ob, string func )
{
  MyRoom->add_death_func( ob, func );
}
void add_clone_on_reset( string fname )
{
  MyRoom->add_clone_on_reset( fname );
}
#include "/w/mithal/UTIL/use_comments.h"

==================================================
FILE: handlers/more_string.c
==================================================

#define COLS (int)this_object()->query_cols()
#define ROWS ( (int)this_object()->query_rows() - 1 )
class more_string_info {
   int fsize;
   int topl;
   int botl;
   string last_search;
   string *the_bit;
   string finish_func;
   string more_bit;
   string stat_line;
   object finish_ob;
}
nosave mixed *_pending_more;
class more_string_info _current_info;
int internal_more_string();
void create() {
   add_command("Internal_More_String", "<string>", (:internal_more_string:));
}
void string_display_file(class more_string_info info) {
  int i;
  string stuff;
  info->botl = info->topl + ROWS;
  stuff = "";
  for ( i = info->topl; ( i < info->botl ) && ( i < info->fsize ); i++ ) {
    stuff += info->the_bit[ i ] +"\n";
  }
  efun::tell_object( this_object(), stuff );
}
void more_string_status_line(class more_string_info info) {
   string *frog;
   string s;
   int i;
   int percentage;
   if (!info->stat_line) {
      info->stat_line = "$N From $T to $B of $S ($%%) - h for help. ";
   }
   s = "";
   frog = explode(info->stat_line, "$");
   for (i=0;i<sizeof(frog);i++) {
      if (frog[i] == "") {
         s += "$";
         i ++;
      } else switch (frog[i][0]) {
         case 'N' :
            s += info->more_bit+frog[i][1..];
            break;
         case 'T' :
            s += ( info->topl + 1 ) + frog[ i ][ 1 .. ];
            break;
         case 'B' :
            if (info->botl > info->fsize)
               s += info->fsize+frog[i][1..];
            else
               s += info->botl+frog[i][1..];
            break;
         case '%' :
            percentage = (info->botl*100)/info->fsize;
            if (percentage > 100) {
               percentage = 100;
            }
            s += percentage + frog[i][1..];
            break;
         case 'S' :
            s += info->fsize + frog[i][1..];
            break;
      }
   }
   efun::tell_object( this_object(), (string)this_object()->fix_string( s ) );
   return;
}
void string_next_page(string str, class more_string_info info) {
   int num;
   int noargs;
   int i;
   int redraw;
   string s1;
   if (!str) {
     str = "";
   }
   if (sscanf(str,"%d%s", num, str) != 2) {
     noargs = 1;
   }
   s1 = str[1..];
   if (str == "") {
      str = "f";
   }
   switch(str[0]) {
      case 'h' :
         cat("/doc/helpdir/more");
         break;
      case 'q' :
         if (info->finish_func) {
            if (functionp(info->finish_func)) {
               evaluate(info->finish_func);
            } else {
               call_other(info->finish_ob, info->finish_func);
            }
         }
         info->finish_func = 0;
         _current_info = 0;
         return;
      case 'f' :
      case 'F' :
         info->topl += ROWS;
         redraw = 1;
         break;
      case 'b' :
      case 'B' :
         info->topl -= ROWS;
         redraw = 1;
         break;
      case '/' :
         i = info->topl + 4;
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 4; i < info->fsize; i++) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == info->fsize) {
            tell_object( this_object(), "Sorry "+ s1 +" not found.\n" );
         } else {
            tell_object( this_object(), "Found " + s1 + " on line "+ i +".\n");
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case '?' :
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 2; i > 0; i--) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == 0) {
            tell_object(this_object(), "Sorry " + s1 + " not found.\n");
         } else {
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case 'b' :
         if (info->topl > 0) {
            info->topl -= ROWS;
            redraw = 1;
            if (info->topl < 0) {
               info->topl = 0;
            }
         }
         break;
      case 'g' :
         info->topl = num;
         if (info->topl >= info->fsize)
            info->topl = info->fsize - 2;
         redraw = 1;
         break;
      case 'G' :
         redraw = 1;
         if (noargs)
            info->topl = info->fsize - ROWS;
         else
            info->topl = num;
         if (info->topl > info->fsize)
            info->topl = info->fsize - 2;
         break;
   }
   if (redraw) {
      string_display_file(info);
      if ( info->botl < info->fsize ) {
         more_string_status_line(info);
         input_to("string_next_page", 0, info);
      } else {
         if (info->finish_func) {
            if ( info->finish_ob ) {
               call_other(info->finish_ob, info->finish_func);
            }
            info->finish_func = 0;
         }
         _current_info = 0;
      }
   } else {
      more_string_status_line(info);
      input_to("string_next_page", 0, info);
   }
}
varargs int more_string( string text, string bity, int noreline ) {
  int i, ncols;
  string *bits;
  class more_string_info info;
  if ( this_player() != this_object() ){
     if ( !_pending_more ) {
        _pending_more = ({ ({ text, bity, noreline }) });
     } else {
        _pending_more += ({ ({ text, bity, noreline }) });
     }
     this_object()->ignore_from_history("Internal_More_String something");
     command( "Internal_More_String something" );
     return 1;
  }
  _current_info = info = new(class more_string_info);
  if ( bity ) {
    info->more_bit = bity;
  } else {
    info->more_bit = "--- MORE";
  }
  info->last_search = "";
  if ( !stringp( text ) || !strlen( text ) ) {
    return notify_fail( "Empty string.\n" );
  }
  if ( noreline ) {
    info->the_bit = explode( this_object()->fix_string( text ), "\n" );
  } else {
    info->the_bit = ({ });
    ncols = COLS;
    bits = explode( text, "\n" );
    for ( i = 0; i < sizeof( bits ); i++ ) {
      reset_eval_cost();
      if ( bits[ i ] == "" ) {
        info->the_bit += ({ "" });
      } else {
        info->the_bit +=
          explode( this_object()->fix_string( bits[ i ], ncols ), "\n" );
      }
    }
  }
  info->fsize = sizeof( info->the_bit );
  info->topl = 0;
  string_display_file(info);
  if ( info->botl < info->fsize ) {
    more_string_status_line(info);
    input_to( "string_next_page", 0, info );
  } else {
      if ( info->finish_func ) {
         if ( !info->finish_ob ) {
            info->finish_func = 0;
            return 1;
         }
         call_other( info->finish_ob, info->finish_func );
         info->finish_func = 0;
      }
      _current_info = 0;
  }
  return 1;
}
varargs void set_finish_func(string str, object ob) {
  _current_info->finish_func = str;
  if (!ob) {
    _current_info->finish_ob = previous_object();
  } else {
    _current_info->finish_ob = ob;
  }
}
int internal_more_string() {
   string text, bity;
   int noreline;
   if ( sizeof( _pending_more ) ) {
      text = _pending_more[ 0 ][ 0 ];
      bity = _pending_more[ 0 ][ 1 ];
      noreline = _pending_more[ 0 ][ 2 ];
      _pending_more = _pending_more[ 1 .. <1 ];
      more_string( text, bity, noreline );
   }
   return 1;
}
