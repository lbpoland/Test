# Total Tokens: 16199
# Total Files Merged: 11
# Total Characters: 54038

thing_handler.c
==================================================

#include <clothing.h>
mapping _types;
mapping _equivilants;
mapping _zones;
string *_zone_level;
protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding);
protected void add_clothing_zone(string zone, string *types);
private int fixup_types(string type, string *types);
protected void add_equivilant_type(string name, string equiv);
private void check_clothing_types();
string *query_clothing_zone(string zone);
string *query_clothing_cannot_remove(string type);
string can_wear_or_remove(object thing, object player);
void create() {
   _types = ([ ]);
   _equivilants = ([ ]);
   _zones = ([ ]);
   _zone_level = ({ });
   add_clothing_type("bandaid", ({ }), ({ }));
   add_clothing_type("wig",
       ({ "hood", "helmet", "coif", "hat", "all covering" }),
       ({ "hood", "helmet", "coif", "hat", "all covering" }));
   add_clothing_type("hat",
       ({ "hood", "helmet", "all covering" }),
       ({ "hood", "helmet", "all covering" }));
   add_clothing_type("helmet",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering" }));
   add_clothing_type("hood",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("earring",
       ({ "coif", "all covering" }),
       ({ "hood", "coif", "all covering" }));
   add_clothing_type("moustache",
       ({ "coif", "mask", "all covering" }),
       ({ "coif", "mask", "all covering" }));
   add_clothing_type("glasses",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("nosering",
       ({ "mask", "coif", "all covering" }),
       ({ "mask", "coif", "all covering" }));
   add_clothing_type("mask",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("headband",
       ({ "hat", "hood", "helmet", "coif", "all covering" }),
       ({ "hat", "hood", "helmet", "coif", "all covering" }));
   add_clothing_type("scarf",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type("necklace",
       ({ "coif", "all covering" }),
       ({ "cloak", "coif", "all covering" }));
   add_clothing_type("collar",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type( "shoulder",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
          "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
          "all covering" }));
   add_clothing_type( "bra",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering", "long dress", "mini dress" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
           "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
           "all covering", "long dress", "mini dress" }));
   add_clothing_type("undershirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "waistcoat",
          "shirt", "harness", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "haubergon", "hauberk",
          "byrnie", "jacket", "jumper", "shirt", "long dress", "mini dress",
          "all covering" }));
   add_clothing_type("shirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "waistcoat",
          "harness", "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("waistcoat",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "harness",
          "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("harness",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("jumper",
       ({ "cloak", "cape", "sash", "robe", "breastplate", "haubergon",
          "hauberk", "byrnie", "tabard", "jacket",  "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "jacket",
          "all covering" }));
   add_clothing_type("jacket",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "all covering" }));
   add_clothing_type("tabard",
       ({ "cloak", "cape", "sash", "robe", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("robe",
       ({ "cloak", "cape", "sash", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cloak",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("sash",
       ({ "cloak", "cape", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cape",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("armband",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("glove",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("bracelet",
       ({ "glove", "all covering" }),
       ({ "cloak", "glove", "all covering" }));
   add_clothing_type("ring",
       ({ "glove", "all covering" }),
       ({ "glove", "all covering" }));
   add_clothing_type("box",
       ({ "cloak", "robe", "all covering" }),
       ({ "cloak", "robe", "skirt", "all covering" }));
   add_clothing_type("apron",
       ({ "cloak", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("underwear",
       ({ "harness", "trousers", "greave", "hauberk", "haubergon",
          "byrnie", "belt", "trousers", "all covering" }),
       ({ "cloak", "robe", "skirt", "trousers", "all covering",
          "long dress", "mini dress" }));
   add_clothing_type("garter",
       ({ "greave", "hauberk", "trousers", "all covering"}),
       ({ "cloak", "robe", "greave", "hauberk", "trousers", "skirt",
          "all covering", "long dress", "mini dress"}));
   add_clothing_type("skirt",
       ({ "belt", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("trousers",
       ({ "greave", "hauberk", "belt" }),
       ({ "cloak", "hauberk", "robe", "all covering" }));
   add_clothing_type("belt",
       ({"hauberk", "haubergon", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "haubergon", "byrnie", "all covering" }));
   add_clothing_type("sock",
       ({ "overshoe", "boot", "chausse", "all covering" }),
       ({ "cloak", "overshoe", "boot", "chausse", "all covering",
          "long dress", "trousers" }));
   add_clothing_type("anklet",
       ({ }),
       ({ "cloak", "overshoe", "chausse", "all covering" }));
   add_clothing_type("boot",
       ({ "overshoe" }),
       ({ "overshoe", "all covering" }));
   add_clothing_type("overshoe",
       ({ }),
       ({ "all covering" }));
   add_clothing_type("long dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("mini dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("small shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("large shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("badge",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("scabbard",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("small scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("belt scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("coif",
       ({ "hood", "scarf", "mask", "helmet", "hat", "all covering"}),
       ({ "hood", "all covering"}));
   add_clothing_type("byrnie",
       ({ "cloak", "breastplate", "backplate", "tabard", "small scabbard",
          "belt scabbard", "robe", "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("haubergon",
       ({ "cloak", "breastplate", "backplate", "tabard", "vambrace",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering"}));
   add_clothing_type("hauberk",
       ({ "cloak", "tabard", "vambrace", "greave", "breastplate", "backplate",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("chausse",
       ({ "boot", "overshoe", "all covering"}),
       ({ "boot", "overshoe", "all covering"}));
   add_clothing_type("breastplate",
       ({ "cloak", "small scabbard", "belt scabbard", "robe", "tabard",
          "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("backplate",
       ({ "cloak", "cape", "sash", "robe", "tabard", "all covering"}),
       ({ "cloak", "cape", "sash", "robe", "all covering"}));
   add_clothing_type("vambrace",
       ({ "glove", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("greave",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("all covering", ({}), ({}));
   add_clothing_zone("head",
       ({ "hood", "helmet", "coif", "hat", "wig", "headband", "moustache",
          "glasses", "mask" }));
   add_clothing_zone("neck",
       ({ "cloak", "hood", "coif", "cape", "scarf", "collar" }));
   add_clothing_zone("chest",
       ({ "cloak", "sash", "robe", "breastplate", "haubergon", "hauberk",
          "byrnie", "tabard", "jacket","jumper", "shirt", "undershirt",
          "shoulder", "bra","shield", "large shield", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("back",
       ({ "cloak", "cape", "sash", "robe", "hauberk", "haubergon", "byrnie",
          "jacket", "jumper", "shirt", "undershirt", "backplate",
          "long dress", "mini dress", "waistcoat" }));
   add_clothing_zone("abdomen",
       ({ "large shield", "robe", "breastplate", "byrnie", "hauberk",
          "skirt", "box", "trousers", "underwear", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("arms",
       ({ "cloak", "small shield", "shield", "large shield", "robe",
          "vambrace", "hauberk", "haubergon", "jacket", "armband",
          "jumper", "shirt", "long dress" }));
   add_clothing_zone("hands",
       ({ "glove", "small shield", "shield", "large shield" }));
   add_clothing_zone("legs",
       ({ "cloak", "robe", "greave", "hauberk", "skirt", "trousers",
          "long dress" }));
   add_clothing_zone("feet",
       ({ "overshoe", "boot", "chausse", "sock", "anklet" }));
   add_equivilant_type("shoe", "boot");
   add_equivilant_type("sandal", "boot");
   add_equivilant_type("clog", "boot");
   add_equivilant_type("sabaton", "boot");
   add_equivilant_type("turban", "helmet");
   add_equivilant_type("gorget", "collar");
   add_equivilant_type("stocking", "sock");
   add_equivilant_type("coat", "cloak");
   add_equivilant_type("overall", "long dress");
   call_out((: check_clothing_types() :), 2);
}
object* query_items_blocking(object thing, object player) {
   int i;
   int j;
   int k;
   string *stuff;
   object *blocking;
   mixed junk;
   mixed main_types;
   object *wearing;
   main_types = thing->query_type();
   if (stringp(main_types)) {
      main_types = ({ main_types });
   }
   wearing = player->query_wearing() - ({ thing });
   blocking = ({ });
   for (k=0;k<sizeof(main_types);k++) {
      stuff = query_clothing_cannot_remove(main_types[k]);
      if (!sizeof(wearing) || !stuff) {
         return ({ });
      }
      for (i = 0; i < sizeof(wearing); i++) {
         junk = wearing[i]->query_type();
         if (stringp(junk)) {
            junk = ({ junk });
         }
         for (j = 0; j < sizeof(junk); j++) {
            if (member_array(junk[j], stuff) != -1 &&
                 member_array(wearing[i], blocking) == -1) {
               blocking += ({ wearing[i] });
               break;
            }
         }
      }
   }
   return blocking;
}
string can_wear_or_remove( object thing, object player ) {
   object *blocking;
   blocking = query_items_blocking(thing, player);
   if (sizeof(blocking)) {
     return "when you are wearing "+ query_multiple_short(blocking);
   }
   return 0;
}
protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding) {
   _types[name] = new (class clothing_type, _hiding : hiding,
                                           _not_remove : not_remove);
}
class clothing_type query_clothing_type(string name) {
   return _types[name];
}
string *query_clothing_cannot_remove(string type) {
   class clothing_type bing;
   bing = _types[type];
   if (bing) {
      return bing->_not_remove;
   }
   return 0;
}
string *query_clothing_hiding(string type) {
   class clothing_type bing;
   bing = _types[type];
   if (bing) {
      return bing->_hiding;
   }
   return ({ });
}
int query_clothing_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int min_depth;
   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      min_depth = 100000;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth < min_depth && depth > 0) {
            min_depth = depth;
         }
      }
      return min_depth;
   }
   return 0;
}
int query_clothing_maximum_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int max_depth;
   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      max_depth = 0;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth > max_depth) {
            max_depth = depth;
         }
      }
      return max_depth;
   }
   return 0;
}
mapping query_all_clothing_types() {
   return _types;
}
private void check_clothing_types() {
   string ty;
   class clothing_type bits;
   string *stuff;
   string bing;
   string type;
   int rank;
tell_creator("presto", "called check_clothing_types\n");
   foreach (ty, bits in _types) {
      foreach (bing in bits->_not_remove) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the not remove "
                  " for " + ty + ".\n");
         }
      }
      foreach (bing in bits->_hiding) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the hiding "
                  " for " + ty + ".\n");
         }
      }
   }
   rank = 1;
   foreach (bing in _zone_level) {
      stuff = query_clothing_zone(bing);
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth &&
             (sizeof(bits->_not_remove) == 0  ||
             bits->_not_remove[0] == "all covering")) {
            bits->_depth = rank;
            rank = fixup_types(type, stuff);
         }
      }
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth) {
tell_creator("presto", "setting depth of %O to %d\n", type, rank + 1);
            bits->_depth = rank++;
         }
      }
   }
}
private int fixup_types(string type, string *types) {
   string bing;
   class clothing_type base;
   class clothing_type bits;
   int depth;
   base = _types[type];
   depth = base->_depth + 1;
   foreach (bing in types) {
      bits = _types[bing];
      if (!bits->_depth &&
          member_array(type, bits->_not_remove) != -1) {
         bits->_depth = depth;
         depth = fixup_types(bing, types);
      }
   }
   return depth;
}
protected void add_clothing_zone(string zone, string *types) {
   string ty;
   foreach (ty in types) {
      if (!query_clothing_type(ty)) {
         write("Incorrect clothing type " + ty + " in zone " + zone + ".\n");
      }
   }
   _zones[zone] = types;
   _zone_level += ({ zone });
}
protected void add_zone_coverage(string type, string *zones) {
  string zone;
  if(!query_clothing_type(type))
    write("Incorrect clothing type " + type + "\n");
  foreach(zone in zones)
    if(member_array(type, zones) != -1)
      _zones[zone] += ({ type });
}
mapping query_all_clothing_zones() {
   return _zones;
}
string *query_clothing_zone(string zone) {
   return _zones[zone];
}
string query_zone_name(string type) {
   string zone;
   string *stuff;
   foreach (zone, stuff in _zones) {
      if (member_array(type, stuff) != -1) {
         return zone;
      }
   }
   return 0;
}
string *query_zone_names(string type) {
   string zone;
   string *stuff;
   string *zones;
   if(_equivilants[type])
     type = _equivilants[type];
   zones = ({ });
   foreach (zone, stuff in _zones) {
     if (member_array(type, stuff) != -1 && zone) {
       zones += ({ zone });
     }
   }
   return zones;
}
int query_zone_level(string zone) {
   int i;
   i = member_array(zone, _zone_level);
   return i * 100;
}
protected void add_equivilant_type(string name, string equiv) {
   if (!query_clothing_type(equiv)) {
      write("Incorrect clothing type " + equiv + " in equivilant listing.\n");
   }
   _equivilants[name] = equiv;
}
mapping query_all_equivilant_types() {
   return _equivilants;
}
string query_equivilant_type(string type) {
   return _equivilants[type];
}
int query_valid_type(string type) {
   if (query_clothing_type(type) ||
       query_equivilant_type(type)) {
      return 1;
   }
   return 0;
}

==================================================
FILE: handlers/club_handler.c
==================================================

inherit "/obj/handlers/inherit/club_inherit";
void create() {
   ::create();
   setup_call_check_clubs(0, 1);
}
void dest_me() {
   save_cache();
   destruct(this_object());
}

==================================================
FILE: handlers/clusters.c
==================================================

#if !efun_defined(db_exec)
#define OLD
#else
#include <db.h>
#endif
#include <map.h>
#define SIZE 7
#define LEVEL(x) load(x)->level
#include <config.h>
nosave int maxnum = 0;
nosave int lasttime = 0;
nosave int count = 0;
nosave mapping used = ([ ]);
nosave mixed *todo= ({ });
nosave mapping cache = ([ ]);
nosave int setup_done = 1;
nosave int db;
nosave int setup_start_time;
class cluster{
  mixed *members;
  int level;
  int cluster_number;
  int this_cluster;
  mixed *contacts;
}
#ifndef OLD
private int get_cluster(mixed);
private mixed cdb_fetch(int fd, int row){
  mixed stuff = db_fetch(fd, row);
  if(arrayp(stuff)){
    mixed tmp, ret = ({});
    foreach(tmp in stuff){
      if(stringp(tmp)){
        int i;
        sscanf(tmp, "%d", i);
        if(i || tmp == "0")
          tmp = i;
      }
      ret += ({tmp});
    }
    stuff = ret;
  }
  return stuff;
}
#endif
private class cluster load(int x){
  mixed rows;
  class cluster tmp = new(class cluster);
  if(cache[x])
    return cache[x];
#ifdef OLD
  cache[x] = restore_variable(unguarded((: read_file(sprintf("/save/clusters/%d",
                                                           (int)$(x))) :)));
#else
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", x);
  if(stringp(rows) || !rows)
    return 0;
  tmp->members = ({});
  rows++;
  while(--rows)
    tmp->members += cdb_fetch(db, rows);
  rows = db_exec(db, "select level, in_cluster from cluster_list where cluster_number = %d", x);
  if(stringp(rows)){
    db_close(db);
    db = db_connect("localhost","discworld",CONFIG_DB_USER);
    return 0;
  }
  rows = cdb_fetch(db, 1);
  tmp->level = rows[0];
  tmp->cluster_number = rows[1];
  tmp->this_cluster = x;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", x);
  if(stringp(rows))
    return 0;
  tmp->contacts = ({});
  rows++;
  while(--rows)
    tmp->contacts += cdb_fetch(db, rows);
  cache[x] = tmp;
#endif
  return cache[x];
}
private void save(class cluster x){
#ifdef OLD
  unguarded((:write_file(sprintf("/save/clusters/%d", $(x->this_cluster)),
                           save_variable($(x)), 1):));
#else
  db_exec(db, "insert into cluster_list values (%d, %d, %d)", x->this_cluster,
          x->level, x->cluster_number);
  map(x->members, (:db_exec(db, "insert into cluster_members values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
  map(x->contacts, (:db_exec(db, "insert into cluster_contacts values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
#endif
  cache[x->this_cluster] = x;
}
private void make_clusters(mixed);
nosave function fix_contacts;
nosave function fix_room_contacts;
private void create(){
#ifndef OLD
  db = db_connect("localhost","discworld",CONFIG_DB_USER);
  map(({"cluster_members", "cluster_list", "cluster_contacts"}),
      (:db_exec(db, "delete from %s;", $1):));
#endif
  fix_room_contacts = function(int i){
    class cluster fixing = load(i);
    if((sizeof(fixing->contacts)) && intp(fixing->contacts[0])){
      error(sprintf("%d in two or more clusters", i));
      return;
    }
    fixing->contacts = uniq_array(map(fixing->contacts,
#ifdef OLD
                                      (:MAP->query_cluster($1):)
#else
                                      (:cache[$1]:)
#endif
                                      ));
  save(fixing);
  };
  fix_contacts = function (int i){
    class cluster fixing = load(i);
    reset_eval_cost();
    if(fixing->level){
      if((sizeof(fixing->contacts)) && (fixing->level ==
                                        LEVEL(fixing->contacts[0]))){
        error(sprintf("%d in two or more clusters", i));
        return;
      }
      fixing->contacts = uniq_array(map(fixing->contacts,
                                        (:load($1)->cluster_number:)));
      save(fixing);
      if(fixing->level > 1){
        map(fixing->members, (:efun::call_out((fix_contacts), 0, $1):));
        return;
      }
      map(fixing->members, fix_room_contacts);
    }
  };
#ifdef OLD
  unguarded(function(){
    string file, *files=get_dir("/save/clusters/");
    foreach(file in files)
      rm(sprintf("/save/clusters/%s", file));
  });
#endif
}
private void make_clusters(mixed start){
  int count = 0, depth = -1, oldmax = maxnum, level = (stringp(start)? 0 :
                                                       load(start)->level + 1);
  class cluster current;
  mixed *list;
  function qdd, real;
  if(stringp(start)){
    qdd = function(string room){
      function f = function(string there, string room){
        mixed tmp;
        return member_array(room,
                            (tmp = MAP->qdd(there), tmp? tmp : ({}))) + 1;
      };
      string *qdd = MAP->qdd(room);
      return filter(allocate(sizeof(qdd) / 2, (:$(qdd)[$1 * 2 + 1]:)), f, room);
    };
    real = (:$1:);
  } else {
    qdd = (:load($1)->contacts:);
    if(stringp(load(start)->contacts[0]))
      real = (:cache[$1]:);
    else
      real = (:load($1)->cluster_number:);
  }
  current = new (class cluster, members:({start}),
                 level:level,
                 this_cluster:++maxnum,
                 contacts:({}));
  list = ({start});
  if(used[start])
    error(sprintf("%O already in a cluster", start));
  used[start] = 1;
  while(++depth < sizeof(list) || sizeof(todo)){
    mixed *exits;
    mixed exit;
    if(depth < sizeof(list))
      exits = (*qdd)(list[depth]);
    else {
      count = SIZE + 1;
      exits = ({});
    }
    foreach(exit in exits) {
      if(!used[exit = (*real)(exit)]) {
        current->members += ({exit});
        list += ({exit});
        used[exit] = 1;
        if(++count > SIZE)
          break;
      }
    }
    if(count > SIZE || !(((1 + depth) < sizeof(list)) || sizeof(todo))){
      mixed tmp, *contacts = ({});
      count = 0;
      foreach(tmp in current->members){
        reset_eval_cost();
        if(stringp(tmp)){
#ifdef OLD
          MAP->set_cluster(tmp, current->this_cluster)
#endif
          ;
          cache[tmp] = current->this_cluster;
        }
        else{
          class cluster clust;
          clust = load(tmp);
          clust->cluster_number = current->this_cluster;
          cache[tmp] = clust;
        }
        exits = (*qdd)(tmp);
        if(exits){
          function add_non_member, convert_and_add;
          add_non_member = (: (member_array($2, $(current->members)) == -1)?
                            ($1 | ({ $2 })) :
                            $1
                           :);
          convert_and_add = (:evaluate($(add_non_member), $1,
                                      evaluate($(real), $2)):);
          contacts = implode(exits, convert_and_add, contacts);
        }
      }
      current->contacts = contacts;
      if(sizeof(contacts) || current->level > 1)
        cache[current->this_cluster] = current;
      else
        maxnum--;
      todo = filter(todo + list + contacts, (:!used[$1]:));
      depth = -1;
      if(sizeof(todo)){
        list = ({todo[0]});
        todo = todo[1..];
        if(used[list[0]])
          error("corrupt todo list");
        used[list[0]] = 1;
        current = new (class cluster, members:({list[0]}),
                       level:level,
                       this_cluster:++maxnum,
                       contacts:({}));
      } else
        list = ({ });
    }
  }
  if((maxnum - oldmax) > SIZE)
    make_clusters(current->this_cluster - 1);
  else {
    int i;
    for(i = oldmax + 1; i <= maxnum; i++)
      if(LEVEL(i))
        efun::call_out(fix_contacts, 0, i);
      else
        efun::call_out(fix_room_contacts, 0, i);
  }
  used = ([]);
  efun::call_out((:cache = ([]), setup_done = 1:), 2);
}
#ifndef OLD
private int get_cluster(mixed thing){
  if(stringp(thing)){
    mixed exret = db_exec(db, "select cluster_number from cluster_members where member = '%s'",
                          db_escape(thing));
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  } else if(intp(thing)){
    mixed exret = db_exec(db, "select in_cluster from cluster_list where cluster_number = %d",
                          thing);
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  }
  return 0;
}
#endif
private int query_top_cluster(string room){
  int ret;
#ifdef OLD
  ret = MAP->query_cluster(room);
  if(ret && unguarded((:file_size(sprintf("/save/clusters/%d", $(ret))):)) > 0)
    while(load(ret)->cluster_number){
      int last = ret;
      ret = load(ret)->cluster_number;
      if(last == ret)
        return ret;
    }
#else
  ret = get_cluster(room);
  if(ret){
    int last = ret;
    ret = get_cluster(ret);
    while(ret){
      last = ret;
      ret = get_cluster(ret);
    }
    return last;
  }
#endif
  else{
    setup_start_time = time();
    setup_done = 0;
    make_clusters(room);
  }
  return ret;
}
#ifndef OLD
private mixed *get_members(int clust){
  mixed rows;
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
private mixed *get_contacts(int clust){
  mixed rows;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
#endif
private mixed *find_places(int start, int end, int *places){
  int found = 0, depth = 0;
  int *key;
  int *exits, bing, *result, ob, exit;
  mapping search = ([]);
  if(start == end){
#ifdef OLD
    return load(start)->members;
#else
    return get_members(start);
#endif
  }
  key = ({ start });
  search[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
#ifdef OLD
      exits = load(ob)->contacts;
#else
      exits = get_contacts(ob);
#endif
      foreach(exit in exits) {
        if ((!search[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && ++depth >= sizeof(key))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
#ifdef OLD
    result += load(bing)->members;
#else
    result += get_members(bing);
#endif
    bing = search[bing];
  }
#ifdef OLD
  result += load(bing)->members;
#else
  result += get_members(bing);
#endif
  return result;
}
private mixed find_route(mixed start, mixed end, string *places){
  int found = 0, i, depth = 0;
  string *key;
  string *exits, bing, *result, ob;
  mapping route = ([]), search = ([]);
  int t = real_time();
  if(start == end)
    return ({});
  key = ({ start });
  route[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
      exits = MAP->qdd(ob);
      for (i = 1; i < sizeof(exits); i += 2) {
        mixed exit = exits[i];
        if ((!route[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          route[exit] = exits[i - 1];
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && (++depth >= sizeof(key) || (real_time() - t) > 4))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
    result = ({route[bing]}) + result;
    bing = search[bing];
  }
  return result;
}
nosave int debugging = 0;
private void debug(int *clusters){
  int cluster;
  if(debugging)
    error("read the error trace");
  debugging = 1;
  reset_eval_cost();
  while(intp(load(clusters[0])->members[0]))
    clusters = implode(clusters, (:$1 + load($2)->members:), ({}));
  foreach(cluster in clusters){
    string *rooms = load(cluster)->members;
    string room, room2;
    reset_eval_cost();
    foreach(room in rooms)
      foreach(room2 in rooms)
        if(!this_object()->get_route(room, room2))
          error("cluster error");
  }
}
string* get_route(string start, string end, function callback){
  mixed *places = ({}), *oldplaces;
  int sip = 0;
  int from, to;
  int level;
  if(lasttime != time()){
    lasttime = time();
    count = 0;
  } else {
    if(count++ > 10) {
      return ({});
    }
  }
  if(!setup_done){
    if((time()-setup_start_time) < 5)  {
      return 0;
    }
#ifndef OLD
#endif
    catch(unguarded(function(){
      cp("/log/runtime", "/w/wodan/clusterruntime");
      cp("/log/catch", "/w/wodan/clustercatch");
    }));
    tell_creator("wodan", "would have dested");
    setup_done = 1;
    return 0;
  }
  if(!stringp(start)){
    start = base_name(start);
    if(!stringp(start))
      error("illegal start point");
  }
  if(!stringp(end)){
    end = base_name(end);
    if(!stringp(end))
      error("illegal end point");
  }
  if(catch(from = query_top_cluster(start))){
#ifndef OLD
    db_close(db);
    db = db_connect("localhost","discworld", CONFIG_DB_USER);
#endif
    return 0;
  }
  if(!setup_done) {
    return 0;
  }
  if(from) {
    level = LEVEL(from);
  }
  to = query_top_cluster(end);
  if(!to || (level != LEVEL(to))) {
    return ({});
  }
  while (level) {
#ifdef OLD
    from = MAP->query_cluster(start);
    to = MAP->query_cluster(end);
#else
    from = get_cluster(start);
    to = get_cluster(end);
#endif
    while((from != to) && (LEVEL(from) < level)){
      from = load(from)->cluster_number;
      to = load(to)->cluster_number;
    }
    level = LEVEL(from);
    if(!level){
      if(!sip) {
        break;
      }
      error("wrong level");
    }
    oldplaces = places;
    places = find_places(from, to, places);
    if(!places){
      if(!sip) {
        return ({});
      }
      debug(oldplaces);
      error("this can't happen, honest!");
    }
    sip = 1;
    level--;
  }
#ifdef OLD
  from = MAP->query_cluster(start);
  to = MAP->query_cluster(end);
#else
  from = get_cluster(start);
  to = get_cluster(end);
#endif
  oldplaces = places;
  places = find_places(from, to, places);
  if(!places){
    if(!sip) {
      return ({});
    }
    debug(oldplaces);
    error("this can't happen, honest!!");
  }
  cache = ([]);
  return find_route(start, end, places);
}
#ifndef OLD
void dest_me(){
  db_close(db);
  destruct(this_object());
}
#endif

==================================================
FILE: handlers/cmr_handler.c
==================================================

#include <cmr.h>
#include <colour.h>
#include <library.h>
#define SAVE_FILE "/save/cmr_handler"
inherit "/std/object";
string *colour_names;
mapping colour_details;
string *material_names;
mapping material_details;
void load_cmr_handler();
void save_cmr_handler();
void create();
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh );
int *query_colour_details( string word );
int delete_colour( string word );
string *query_colour_names();
string identify_colour( string word, object player );
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh );
int *query_material_details( string word );
int delete_material( string word );
string *query_material_names();
string identify_material( string word, object player, int article );
string query_material_adjective( string word );
void load_cmr_handler() {
  if ( file_size( SAVE_FILE +".o" ) > 0 )
    unguarded((: restore_object, SAVE_FILE :));
}
void save_cmr_handler() {
  unguarded((: save_object, SAVE_FILE :));
}
void create() {
  colour_names = ({ });
  colour_details = ([ ]);
  material_names = ({ });
  material_details = ([ ]);
  ::create();
  load_cmr_handler();
}
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp != -1 ) return "colour already exists";
  colour_names += ({ word });
  colour_details += ([ word : ({ fine, crude, qp_thresh, sp_thresh }) ]);
  save_cmr_handler();
  return "the colour "+ word +", a shade of "+ ( ( fine == crude )?
         "pure ":MODIFIERS[fine] ) + COLOURS[crude] +", with thresholds of "+
         qp_thresh +" xp and "+ sp_thresh +" sp";
}
int *query_colour_details( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return ({ -1 });
  return colour_details[word];
}
int delete_colour( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return 0;
  colour_names -= ({ word });
  colour_details = m_delete( colour_details, word );
  save_cmr_handler();
  return 1;
}
string *query_colour_names() { return colour_names + ({ }); }
string identify_colour( string word, object player ) {
  int temp, *args;
  temp = member_array( word, colour_names );
  if ( temp == -1 )
    return "unknown colour";
  args = allocate( 4 );
  args = colour_details[word];
  if ( !player )
    return word;
  switch ( ( ( LIBRARY->query_quest_points(player->query_name()) ) > args[2] )+
           ( ( player->query_max_gp() ) > args[3] ) ) {
  case 0:
    return COLOURS[args[1]];
  case 1:
    return ( ( ( args[0] == args[1] )?"pure ":MODIFIERS[args[0]] ) +
             COLOURS[args[1]] );
  default:
    return word;
  }
}
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh ) {
  int temp;
  string text;
  temp = member_array( word, material_names );
  if ( temp != -1 ) return "material already exists";
  material_names += ({ word });
  material_details += ([ word : ({ colour, type, skill_reqd,
                         skill_thresh }) ]);
  save_cmr_handler();
  if ( !skill_reqd )
    text = " that is always recognised";
  else
    if ( skill_reqd == LEARNT )
      text = " that is recognised through knowledge";
    else
      text = " that has a threshold of "+ skill_thresh +" in "+
             SKILLS[skill_reqd];
  return word +", a"+ ( ( colour == COL_ORANGE )?"n ":" " ) +
         COLOURS[colour] +" "+ MATERIALS[type] + text;
}
int *query_material_details( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return ({ -1 });
  return material_details[word];
}
int delete_material( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return 0;
  material_names -= ({ word });
  material_details = m_delete( material_details, word );
  save_cmr_handler();
  return 1;
}
string *query_material_names() { return material_names + ({ }); }
string identify_material( string word, object player, int article ) {
  int temp, *args;
  string prefix;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "unknown material";
  args = allocate( 4 );
  args = material_details[word];
  prefix = ( ( article )?"a"+ ( ( args[0] == COL_ORANGE )?"n ":" " ):"" );
   if ( !args[ 2 ] || !player )
      return word;
  if ( args[2] == LEARNT )
    if ( member_array( word,
        (string *)CMR_LIBRARY->query_known_materials( player->query_name() ) )
        == -1 )
      return prefix + COLOURS[ args[ 0 ] ] +" "+
          MATERIALS[ args[ 1 ] ];
    else
      return word;
  if ( ( player->query_skill_bonus( SKILLS[args[2]] ) ) > args[3] )
    return word;
  else return prefix + COLOURS[args[0]] +" "+ MATERIALS[args[1]];
}
string query_material_adjective( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "an unknown material";
  args = allocate( 4 );
  args = material_details[word];
  return COLOURS[args[0]] +" "+ MATERIAL_ADJECTIVES[args[1]];
}
string query_material_ansi_colour( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "";
  args = allocate( 4 );
  args = material_details[word];
  return ANSI_COLOURS[args[0]];
}

==================================================
FILE: handlers/cmr_library.c
==================================================

#define RESTORE_PATH "/save/cmr_library/"
inherit "/std/object";
string player_name, *materials;
void init_data( string pname ) {
  player_name = pname;
  materials = ({ });
}
int get_data_file( string pname ) {
  if ( player_name != pname ) {
    if ( file_size( RESTORE_PATH + pname +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + pname :));
    else {
      init_data( pname );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
string *query_known_materials( string pname ) {
  get_data_file( pname );
  if ( !materials ) {
    return ({ });
  }
  return materials + ({ });
}
int query_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( !materials ) return 0;
  return ( member_array( material, materials ) != -1 );
}
int add_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( member_array( material, materials ) != -1 ) {
    return 0;
  }
  materials += ({ material });
  save_data_file( player_name );
  return 1;
}

==================================================
FILE: handlers/co_ordinate_handler.c
==================================================

#include <dirs.h>
class room_data {
   string other;
   string direction;
   int* coords;
   int last_update;
}
private mapping _rooms = ([ ]);
private nosave mapping _dirs;
int setup_room(string path);
void create() {
   mixed* bits;
   int i;
   bits = STD_ORDERS;
   _dirs = ([ ]);
   for (i = 0; i < sizeof(bits); i += 2) {
      _dirs[bits[i]] = bits[i + 1];
   }
}
private void setup_specific_room(string path, string new_path, string dir) {
   int* delta;
   int* co_ord;
   int k;
   class room_data data;
   delta = new_path->query_room_size_array() + path->query_room_size_array();
   co_ord = copy( _rooms[new_path]->coords);
   for ( k = 0; k < 3; k++ ) {
     co_ord[ k ] += _dirs[dir][ k ] *
                    ( delta[ k ] + delta[ k + 3 ] );
   }
   data = new(class room_data);
   data->other = new_path;
   data->coords = co_ord;
   data->direction = dir;
   data->last_update = _rooms[new_path]->last_update;
   _rooms[path] = data;
}
int* query_room_co_ords(string path) {
   class room_data data;
   data = _rooms[path];
   if (data) {
      if (!_rooms[data->other]) {
         map_delete(_rooms, path);
      } else {
         if (data->last_update != _rooms[data->other]->last_update) {
            setup_specific_room(path, data->other, data->direction);
         }
         return data->coords;
      }
   }
   if (setup_room(path)) {
      data = _rooms[path];
      return data->coords;
   }
   return 0;
}
int setup_room(string path) {
   string* bits;
   int i;
   string new_path;
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }
   bits = path->query_dest_dir();
   for (i = 0; i < sizeof(bits); i += 2) {
      if (find_object(bits[i+1])) {
         new_path = file_name(find_object(bits[i+1]));
      } else {
         new_path = bits[i+1];
      }
      if (_rooms[new_path]) {
         setup_specific_room(path, new_path, bits[i]);
         return 1;
      }
   }
   return 0;
}
void setup_fixed_room(string path, int* coords) {
   class room_data data;
tell_creator("pinkfish", "%O %O %O\n", path, path->query_property("location"),
               path->query_terrain_handler());
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }
   if (_rooms[path]) {
      data = _rooms[path];
      if (data->coords[0] == coords[0] &&
          data->coords[1] == coords[1] &&
          data->coords[2] == coords[2]) {
         return ;
      }
   } else {
      data = new(class room_data);
   }
   data->coords = coords;
   data->last_update = time();
   _rooms[path] = data;
}
mapping query_rooms() {
   return _rooms;
}

==================================================
FILE: handlers/colour.c
==================================================

#include <colour.h>
string calc_colour( int red, int green, int blue, int whitener ) {
   int main_hue;
   string result;
   result = "";
   if ( whitener > -1 ) {
      switch ( red + green + blue ) {
         case 0 .. 4 :
            return "colourless";
         case 5 .. 29 :
            result += "faint ";
            break;
         case 30 .. 154 :
            break;
         default :
            result += "intense ";
      }
   }
   return result;
}

==================================================
FILE: handlers/complaints_handler.c
==================================================

#include <board.h>
#define SAVEFILE "/save/complaints/complaints_handler.o"
#define BOARD "complaints"
int _complaintNumber;
void save_file() {
    unguarded( (: save_object( SAVEFILE ) :) );
}
void load_file() {
    unguarded( (: restore_object( SAVEFILE ) :) );
}
void create() {
    seteuid( getuid() );
    _complaintNumber = 1;
    load_file();
}
int do_submit_complaint( string str ) {
    int ret = 0;
    if ( str ) {
        ret = BOARD_HAND->
            add_message( BOARD, "Anonymous",
                         "Anonymous complaint #" + _complaintNumber,
                         sprintf( "%-=78s\n", str ) );
        _complaintNumber++;
        save_file();
    }
    return ret;
}
int board_access_check( int type, string, object previous, string name ) {
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
    case B_ACCESS_DELETE :
        return 0;
    }
}

==================================================
FILE: handlers/converter.c
==================================================

mixed *mail;
nosave string *names;
nosave int no_more;
int query_busy(string name);
void create() {
  seteuid("mailer");
  names = ({ });
  no_more = 0;
}
int ok_to_shut() {
  no_more = 1;
  return (sizeof(names) == 0);
}
void convert_it(string pname) {
  int i, bing;
  if (no_more) {
    write("Can't start converting mail, try again after the reboot.\n");
    return;
  }
  if (query_busy(pname)) {
    write("Argh ! Already busy converting mail for "+pname+".\n");
    return;
  }
  mail = ({ });
  if (file_size("/save/post/"+pname+".o") == -1)
    return;
  unguarded((: restore_object, "/save/post/"+pname :));
  bing = sizeof(mail);
  if (!bing) {
    unguarded((: rm, "/save/post/"+pname+".o" :));
    return;
  }
  write("Converting mail for "+pname+".\n");
  names += ({ pname });
  for (i = 0; i < bing; i++) {
    reset_eval_cost();
    call_out("do_it", (i+1)*3, (mail[i] + ({ pname })));
  }
  call_out("reset_busy", (i+1)*3, pname);
  unguarded((: rm, "/save/post/"+pname+".o" :));
}
void do_it(mixed *arg) {
  object handler = clone_object("/obj/handlers/folder_handler");
  handler->add_it((["to" : ({ arg[6] }),
    "cc" : ({ }), "from" : arg[1], "subject" : arg[3], "body" :
    "From "+arg[1]+" "+ctime(arg[0])+
    "\nDate: "+ctime(arg[0])+
    "\nFrom: "+arg[1]+
    "\nTo: "+arg[2]+
    "\nSubject: "+arg[3]+
    "\nCc: "+(arg[4]?arg[4]:"")+"\n\n"+
    arg[5] ]), 1);
}
int query_busy(string name) {
  return (member_array(name, names) != -1);
}
void reset_busy(string name) {
  names -= ({ name });
  if (no_more && !sizeof(names)) {
    "/obj/shut"->shut(2);
  }
}

==================================================
FILE: handlers/corpse_handler.c
==================================================

#include <player_handler.h>
#define CORPSE_SAVE_DIR "/save/corpses/"
#define CORPSE_RAM_DIR "/save/ramdisk/corpses/"
#define CORPSE_SAVE_FILE "/save/corpses/main"
#define CORPSE_OBJECT "/obj/corpse"
private mapping _corpses;
private nosave mapping _to_save;
private nosave int _save_things_id;
private int _corpse_id;
class corpse_data {
   int id;
}
void create() {
   seteuid(getuid());
   _corpses = ([ ]);
   _corpse_id = 1;
   _to_save = ([ ]);
   unguarded( (: restore_object(CORPSE_SAVE_FILE,  1) :));
   call_out("check_corpses", 10);
}
private void save_me() {
   unguarded( (: save_object(CORPSE_SAVE_FILE,  3) :));
}
private class corpse_data find_corpse_data(string name, int id) {
   class corpse_data corpse;
   if (!_corpses[name]) {
      return 0;
   }
   foreach (corpse in _corpses[name]) {
      if (corpse->id == id) {
         return corpse;
      }
   }
   return 0;
}
private class corpse_data find_corpse_ob_data(object ob) {
   string name;
   int id;
   name = ob->query_ownership();
   id = ob->query_corpse_id();
   return find_corpse_data(name, id);
}
object* find_player_corpses(string player) {
   object* corpses;
   corpses = filter( children( "/obj/corpse" ),
             (: $1 && $1->query_property( "player" ) &&
                $1->query_ownership() == $2 :), player );
   return corpses;
}
private void really_save_corpses() {
  object ob, player;
  class corpse_data corpse;
  string data;
  string fname;
  foreach (ob, corpse in _to_save) {
    if(!ob)
      continue;
    data = ob->query_save_data();
    if (stringp(data)) {
#ifdef USE_RAMDISK
      fname = CORPSE_RAM_DIR + corpse->id;
#else
      fname = CORPSE_SAVE_DIR + corpse->id;
#endif
      unguarded((: write_file($(fname), $(data), 1) :));
    } else {
      tell_creator("pinkfish", "Bad corpse save %O %O\n", ob, data);
    }
    player = find_player(ob->query_owner());
    if(player)
      player->save_me();
  }
  _to_save = ([ ]);
}
void save_corpse(object ob) {
   class corpse_data corpse;
   if (!ob->query_property("player") || !ob->query_ownership()) {
      return ;
   }
   corpse = find_corpse_ob_data(ob);
   if (!corpse) {
      tell_creator("pinkfish", "Cannot find the corpse to save %O [%O].\n",
                   ob, ob->query_ownership());
      return ;
   }
   _to_save[ob] = corpse;
   if (_save_things_id) {
      remove_call_out(_save_things_id);
   }
   _save_things_id = call_out((: really_save_corpses :), 2);
}
object create_corpse(string name, int id) {
   class corpse_data corpse;
   string data, fname;
   object ob;
   corpse = find_corpse_data(name, id);
#ifdef USE_RAMDISK
   if(unguarded( (: file_size(CORPSE_RAM_DIR + $(corpse->id)) :)) > 0)
     fname = CORPSE_RAM_DIR + corpse->id;
#endif
   if(!fname)
     fname = CORPSE_SAVE_DIR + corpse->id;
   data = unguarded( (: read_file($(fname)) :));
   if (data) {
     ob = clone_object(CORPSE_OBJECT);
     ob->setup_corpse_from_save(data, name, id);
     return ob;
   }
   return 0;
}
void check_corpses() {
   class corpse_data* corpses;
   string name;
   object* obs;
   int i;
   int j;
   foreach (name, corpses in _corpses) {
      obs = find_player_corpses(name);
      for (i = 0; i < sizeof(corpses); i++) {
         for (j = 0; j < sizeof(obs); j++) {
            if (obs[j]->query_corpse_id() == corpses[i]->id) {
               corpses = corpses[0..i -1] + corpses[i+1..];
               i--;
            }
         }
      }
      if (sizeof(corpses)) {
         for (i = 0; i < sizeof(corpses); i++) {
            create_corpse(name, corpses[i]->id);
         }
      }
   }
}
int query_next_corpse_id() {
   int id;
   id = _corpse_id++;
   save_me();
   return id;
}
void register_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;
   tell_creator("Registering %O (%O)\n", ob, ob->query_ownership());
   name = ob->query_ownership();
   if(PLAYER_HANDLER->test_creator(name)) {
     tell_creator("pinkfish", "Not registering creator corpse %O (%O)\n",
                  ob, ob->query_ownership());
     return;
   }
   id = ob->query_corpse_id();
   corpse = find_corpse_ob_data(ob);
   if (corpse) {
      save_corpse(ob);
      return ;
   }
   corpse = new(class corpse_data);
   corpse->id = id;
   if (!_corpses[name]) {
      _corpses[name] = ({ corpse });
   } else {
      _corpses[name] += ({ corpse });
   }
   save_me();
   save_corpse(ob);
}
void deregister_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;
   int i;
   if (!ob->query_property("player")) {
      return ;
   }
   name = ob->query_ownership();
   id = ob->query_corpse_id();
   for (i = 0; i < sizeof(_corpses[name]); i++) {
      corpse = _corpses[name][i];
      if (corpse->id == id) {
         _corpses[name] = _corpses[name][0..i-1] + _corpses[name][i+1..];
         if (!sizeof(_corpses[name])) {
            map_delete(_corpses, name);
         }
         save_me();
         unguarded( (: rm(CORPSE_SAVE_DIR + $(id)) :));
#ifdef USE_RAMDISK
         unguarded( (: rm(CORPSE_RAM_DIR + $(id)) :));
#endif
         return ;
      }
   }
}
mixed *stats() {
  return ({ ({ "corpses", keys(_corpses) }) });
}

==================================================
FILE: handlers/cpi_handler.c
==================================================

#define RESTORE_PATH "/save/cpi_indices/"
#define STOCK_EXCHANGE find_object( "/d/am/am/gomerchants" )
inherit "/std/object";
string material_name;
mapping prices;
void setup() {
  set_name( "board" );
  set_short( "price board" );
  set_long( "This is a large board with many small, wooden flaps attached "+
            "to it.  Painted onto the flaps are numbers and letters, and "+
            "the display is occasionally changed by means of a small imp "+
            "that seems to live inside somewhere.  The board lists the "+
            "purchasing prices of almost everything from gold and silk "+
            "to beef and chicken livers at various places where the "+
            "Merchants' Guild does business.\n" );
  add_adjective( "price" );
  set_main_plural( "price boards" );
  add_plural( "boards" );
  reset_get();
}
int look_up(string);
void init() {
  add_command("find", "<word'thing'>", (:look_up($4[0]):));
}
void imp_effect( string phrase ) {
  tell_room( STOCK_EXCHANGE, "A tiny door opens in the board, a warty imp "+
            "climbs out, clambers across the surface and "+ phrase +
            ".  The imp scowls a bit for the look of the thing, and then "+
            "disappears back inside the board.\n" );
}
void init_data( string word ) {
  material_name = word;
  prices = ([ ]);
}
int get_data_file( string word ) {
  if ( material_name != word ) {
    if ( file_size( RESTORE_PATH + word +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + word :));
    else {
      init_data( word );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
int query_price( string word1, string word2 ) {
   if ( !stringp( word1 ) )
      return 0;
   get_data_file( word1 );
   if ( !prices )
      return 0;
   return prices[ word2 ];
}
int add_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] != 0 ) return 0;
  prices += ([ word2 : number ]);
  imp_effect( "adds the price of "+ word1 +" in "+ word2 +" to the lists" );
  save_data_file( material_name );
  return 1;
}
int modify_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices[word2] = number;
  imp_effect( "updates the price of "+ word1 +" in "+ word2 );
  save_data_file( material_name );
  return 1;
}
int remove_price( string word1, string word2 ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices = m_delete( prices, word2 );
  imp_effect( "removes the price of "+ word1 +" in "+ word2 +
              " from the lists" );
  save_data_file( material_name );
  return 1;
}
int look_up( string word ) {
  int i;
  get_data_file( word );
  if ( !m_sizeof( prices ) ) {
    notify_fail( "You can't find any prices for "+ word +" on the board.\n" );
    return 0;
  }
  if ( m_sizeof( prices ) == 1 ) {
    write( "The only price on the board for "+ word +" is "+
              m_values( prices )[0] +" in "+ m_indices( prices )[0] +".\n" );
  } else {
    write( "You find the following price list for "+ word +":\n\n" );
    for ( i = 1; i < m_sizeof( prices ); i++ ) {
      printf( "%6-s %7d %4|s %40-s \n", "", m_values( prices )[i], "in",
                m_indices( prices )[i] +"," );
    }
    printf( "%6-s %7d %4|s %40-s \n", "  and ", m_values( prices )[0], "in",
              m_indices( prices )[0] +"." );
  }
  return 1;
}
string *query_available_datatypes()
{
  return get_dir(RESTORE_PATH);
}
