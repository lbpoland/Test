# Total Tokens: 19411
# Total Files Merged: 4
# Total Characters: 64712

ney_handler.c
==================================================

#include <money.h>
#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#define USE_VAULT DEF_VALUE
mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where);
void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_all_values() { return copy( values ); }
string *query_all_places() {
   return keys(values);
}
mixed *query_values() { return copy( values[ "default" ] ); }
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
}
mixed *query_weighted_values_in( string where, int backwards ) {
    mixed *bits;
    int i, j;
    int max_size;
    int len;
    mixed *arr, *reversed;
    if ( !where || ( where == "" ) ) {
        return 0;
    }
    bits = copy( values[ where ] );
    arr = ({ });
    max_size = 0;
    for ( i = 0; i < sizeof( bits ); i += 2 ) {
        len = sizeof( bits[ i ] );
        if ( len > max_size ) {
            arr += ({ bits[ i ], bits[ i + 1 ] });
            max_size = len;
            continue;
        }
        for ( j = 0; j < sizeof( arr ); j += 2 ) {
            if ( len <= sizeof( arr[ j ] ) ) {
                arr = arr[ 0..j-1] + ({ bits[ i ], bits[ i + 1 ] }) + arr[j..];
                break;
            }
        }
    }
    if ( backwards ) {
        reversed = ({ });
        for ( i = sizeof( arr ) - 1; i > 0; i -= 2) {
            reversed += ({ arr[ i - 1 ], arr[ i ] });
        }
        return reversed;
    }
    else {
       return arr;
    }
}
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;
   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
}
void add_type( string where, string type, int value ) {
   int i;
   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
}
void remove_type( string where, string type ) {
   int i;
   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
}
mapping query_details() { return copy( details ); }
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
}
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
}
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
}
mapping query_symbols() { return copy( symbols ); }
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
}
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
}
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
}
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
}
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
}
string *query_aliases_for( string type ) {
   string *ret;
   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
}
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
}
string *query_adjectives_for( string type ) {
   string *ret;
   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   return ret;
}
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
}
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
}
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
}
string query_main_plural_for( string type ) {
   string *type_exp;
   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
}
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
}
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
}
string money_string( mixed mon_array ) {
   int i;
   string ret;
   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 );
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
}
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
}
varargs string money_value_string( int value, string where ) {
   string symboliser;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
}
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;
   if (!where) {
      where = "default";
   }
   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = query_weighted_values_in( where, 1 );
   if (!value && stuff) {
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
}
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
}
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;
   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
}
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }
      value *= query_value( type, where );
   }
   if (!value) {
      return 0;
   }
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   if ( value > total ) {
      return 0;
   }
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];
   ret = ({ });
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }
   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }
   return ({ ret, value, mon_array });
}
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;
   if (!type) {
     return 0;
   }
   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
}
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;
   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }
      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }
   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }
   if (sizeof(change_array) == 0) {
      return 0;
   }
#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;
}
varargs object make_new_amount( int value, string where ) {
   object money;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
}
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   object *monies;
   m_array = money->query_money_array();
   monies = filter_legal_money_array(m_array, where);
#ifdef USE_VAULT
   MONEY_VAULT->add_to_list(money);
#else
   money->move("/room/rubbish");
#endif
   return monies;
}
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   object good, no_good;
   mixed *money_arrays;
   money_arrays = filter_legal_money_to_array(m_array, where);
   if (sizeof(money_arrays[0]) == 0) {
      good = 0;
   } else  {
#ifdef USE_VAULT
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(money_arrays[0]);
   }
   if (sizeof(money_arrays[1]) == 0) {
      no_good = 0;
   } else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(money_arrays[1]);
   }
   return ({ good, no_good });
}
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where) {
   int i;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });
   if (sizeof(m_array) == 0) {
      return ({ ({ }), ({ }) });
   }
   if (!where || where == "") {
     where = "default";
   }
   if (!(poss_values = values[where])) {
      return ({ ({ }), copy(m_array) });
   }
   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }
   return ({ good_array, no_good_array });
}
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;
   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;
}
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   int     adjust_flag;
   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[i]) < m_array[i + 1]) {
            return NO_MATCH;
         }
      }
      adjust_flag = 1;
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      adjust_flag = 0;
      m_array = ({ });
      foreach (thing in things) {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   monies = filter_legal_money_array(m_array, place);
   if(monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
      if (!adjust_flag)
         this_player()->adjust_money(m_array);
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#else
      monies[1]->dest_me();
#endif
   }
   if (monies[0])  {
      if (adjust_flag)  {
         m_array2 = copy(monies[0]->query_money_array());
         for (i = 0; i < sizeof(m_array2); i += 2)
            m_array2[i + 1] = -m_array2[i + 1];
         this_player()->adjust_money(m_array2);
      }
      return monies[0];
   }
   else  {
      return NO_LEGAL;
   }
}
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;
   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
}
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
  tmp = values(query_all_values());
  foreach( elem in tmp ){
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}
string query_origin_of( string type ){
  string elem, *places;
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  places = query_all_places();
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  types = query_valid_types();
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   r = 1;
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
int smallest_value_in( string place ) {
   int i, smallest;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
      }
   }
   return smallest;
}
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;
   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
}

==================================================
FILE: handlers/monster_handler.c
==================================================

int num;
void create() {
  seteuid("Room");
  unguarded((: restore_object, "/save/monster-handler" :));
}
string query_shadow_name() {
  num++;
  return "/tmp/mon-shad/frog-"+num;
}
void reset() {
  unguarded((: save_object, "/save/monster-handler" :));
}
void dest_me() {
  unguarded((: save_object, "/save/monster-handler" :));
}

==================================================
FILE: handlers/multiplayer.c
==================================================

#include <login_handler.h>
#include <playerinfo.h>
#define SAVE_FILE   "/save/multiplayer"
#define ALIST "/secure/alist"
#define ALLOWED_ITEMS ({ "/obj/misc/club_badge", "/obj/misc/al_receipt" })
string *denied_parcels;
mapping allowed;
protected void create() {
  string denied_parcel;
  int changed = 0;
  denied_parcels = ({ });
  allowed = ([ ]);
  seteuid(master()->creator_file(file_name()));
  if (file_size(SAVE_FILE + ".o") > 0) {
    unguarded((: restore_object, SAVE_FILE, 1 :));
  }
  foreach (denied_parcel in denied_parcels) {
    if (!PLAYER_HANDLER->test_user(denied_parcel)) {
      denied_parcels -= ({ denied_parcel });
      changed = 1;
    }
  }
  if (changed) {
    unguarded((: save_object, SAVE_FILE :));
  }
}
private void save_me() {
  unguarded((: save_object, SAVE_FILE :));
}
string *check_allowed(mixed user, mixed *others) {
  string *not_allowed;
  mixed tmp, alt;
  if(objectp(user))
    user = user->query_name();
  if(!allowed[user] && PLAYERINFO_HANDLER->query_alt_of(user) != "")
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  not_allowed = ({ });
  foreach(tmp in others) {
    if(objectp(tmp))
      tmp = tmp->query_name();
    alt = PLAYERINFO_HANDLER->query_alt_of(tmp);
    if(!alt)
      alt = tmp;
    if(!allowed[user] || member_array(alt, allowed[user]) == -1)
      not_allowed += ({ tmp });
  }
  return not_allowed;
}
int add_git(string git) {
  PLAYERINFO_HANDLER->add_entry(this_player(), git, "multiplay",
                                "Caught multiplaying.\n");
  return 1;
}
int add_allowed(string user, string other) {
  int oldsize, changed;
  if (!(PLAYER_HANDLER->test_user(user) && PLAYER_HANDLER->test_user(other))) {
    return 0;
  }
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if(PLAYERINFO_HANDLER->query_alt_of(other))
    other = PLAYERINFO_HANDLER->query_alt_of(other);
  if (undefinedp(allowed[user])) {
    allowed[user] = ({ other });
  } else {
    oldsize = sizeof(allowed[user]);
    allowed[user] |= ({ other });
  }
  if (!oldsize || (oldsize != sizeof(allowed[user]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + other + ".\n");
  }
  if (undefinedp(allowed[other])) {
    allowed[other] = ({ user });
  } else {
    oldsize = sizeof(allowed[other]);
    allowed[other] |= ({ user });
  }
  if (!oldsize || (oldsize != sizeof(allowed[other]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), other, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + user + ".\n");
  }
  if (changed) {
    call_out((: save_me :), 1);
  }
  return 1;
}
int delete_allowed(string user) {
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if (undefinedp(allowed[user]))
    return 0;
  map_delete(allowed, user);
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                "Deleted from multiplayer handler "
                                "(allowed).\n");
  return 1;
}
mapping query_allowed() {
  return copy(keys(allowed));
}
int add_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to add a user to this list.\n");
    return 0;
  }
  if (member_array( user, denied_parcels) != -1) {
    denied_parcels -= ({ user });
  }
  if (!PLAYER_HANDLER->test_user(user)) {
    return 0;
  }
  denied_parcels += ({ lower_case(user) });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                            "Denied the use of the parcel system.\n");
  return 1;
}
int remove_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to remove a user to this list.\n");
    return 0;
  }
  if (member_array(user, denied_parcels) == -1)
    return 0;
  denied_parcels -= ({ user });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                           "Allowed the use of the parcel system.\n");
  return 1;
}
int member_denied_parcel( string user ) {
  if (member_array(user, denied_parcels) == -1)
    return 0;
  return 1;
}
string *query_denied_parcels() {
  return copy(denied_parcels);
}
varargs void mark_log(string user, string comment) {
  if (!comment) {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + " Previous log entries handled.\n");
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Previous log entries handled.\n");
  } else {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + ": " + comment + "\n" );
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  comment + "\n");
  }
}
string query_name() {
  return "Multiplayer handler";
}
void record_object(string action, object player, object item) {
  mixed stuff;
  stuff = item->query_property("dropped");
  if(sizeof(stuff) && player->query_name() != stuff[0])
    stuff = ({ player->query_name(), query_ip_number(player), time(),
                 stuff[0] });
  else
    stuff = ({ player->query_name(), query_ip_number(player), time() });
  item->add_property("dropped", stuff, 1800);
}
int check_multiplayers(string action, object player, object item) {
  mixed stuff;
  string direction, verb, res, is;
  if(objectp(player) && !interactive(player))
    return 0;
  stuff = item->query_property("dropped");
  if(!stuff)
    return 0;
  is = "";
  switch(action) {
  case "get":
    verb = " got ";
    direction = " from ";
    break;
  case "give":
    verb = " was given ";
    direction = " by ";
    is = "is ";
    break;
  case "slip":
    verb = " was slipped ";
    direction = " by ";
    is = "is ";
    break;
  case "palm":
    verb = " palmed ";
    direction = " from ";
    break;
  case "plant":
    verb = " planted ";
    direction = " on ";
    is = "is ";
    break;
  case "recover":
    verb = " recovered ";
    direction = " from ";
    break;
  }
  if(stuff[0] != player->query_name() &&
     query_ip_number(player) == stuff[1] &&
     sizeof(check_allowed(player, ({ stuff[0]}) ))) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who " + is +"logged in from the same "
      "address.";
  } else if(direction != " by " &&
            player->query_name() == stuff[0] &&
            player->query_refresh_time() > stuff[2]) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      " after a refresh.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) == 100) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who is " + player->query_possessive() +
      " alt.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) >= 60) {
    res = capitalize(player->query_name()) + verb +  item->a_short() +
      direction + stuff[0] + " who is POSSIBLY " +
      player->query_possessive() + " alt.";
  } else if(sizeof(stuff) == 4) {
    if(player->query_name() == stuff[3]) {
      if(player->query_refresh_time() > stuff[2]) {
        res = capitalize(player->query_name()) + verb + item->a_short() +
          " after a refresh" + direction + stuff[0] + ".";
      }
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) == 100) {
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is " + player->query_possessive() +
        " alt.";
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) >= 60) {
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is _POSSIBLY_ " +
        player->query_possessive() + " alt.";
    }
  } else if((PLAYER_HANDLER->test_creator(stuff[0]) ||
             PLAYER_HANDLER->test_property(stuff[0], "test character")) &&
            !player->query_creator() &&
            !player->query_property("test character") &&
            member_array(base_name(item), ALLOWED_ITEMS) == -1 &&
            base_name(item)[0..14] != "/d/liaison/TOYS") {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0];
    user_event("inform", res, "cheat");
    log_file("/d/admin/log/CHEAT", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
    return 0;
  }
  if(res) {
    user_event("inform", res, "multiplayer");
    log_file("MULTIPLAYERS", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
  }
  return 0;
}

==================================================
FILE: handlers/new_soul.c
==================================================

#include <player.h>
#include <soul.h>
#include <user_parser.h>
#define SAVE_FILE "/save/soul"
#define SOUL_DATA_DIR "/save/soul/data/"
#define POS_SELF   0
#define POS_TARGET 1
#define POS_REST   2
#define PCACHE_MAX_SIZE 30
#define SCACHE_MAX_SIZE 100
#define CLEAN_UP_DELAY 300
mixed soul_commands;
mapping soul_command_names;
nosave mapping pattern_cache;
nosave mapping soul_cache;
nosave string *pcache_order,
 *scache_order;
nosave int scache_hits, scache_reads, pcache_hits, pcache_reads, cache_callout;
void load_it();
void save_it();
void print_messages(string verb, mixed obs, string arg, string self,
                    string rest, string target, string force,
                    mapping position);
protected void save_soul_command(string name, mixed *data);
void create() {
  soul_commands = 0;
  soul_command_names = ([ ]);
  pattern_cache = ([ "" : NO_ARGUMENT ]);
  pcache_order = ({ });
  scache_order = ({ });
  soul_cache = ([ ]);
  seteuid("Room");
  load_it();
}
void clean_cache() {
  int i;
  for (i = 0; i < (sizeof(pcache_order) - PCACHE_MAX_SIZE); i++) {
    map_delete(pattern_cache, pcache_order[i]);
  }
  pcache_order = pcache_order[i..];
  for (i = 0; i < (sizeof(scache_order) - SCACHE_MAX_SIZE); i++) {
    map_delete(soul_cache, scache_order[i]);
  }
  scache_order = scache_order[i..];
  cache_callout = 0;
}
void add_soul_command(string name, mixed data) {
  if (file_name(previous_object()) != SOUL_COMPILER)
    return;
  save_soul_command(name, data);
  map_delete(soul_cache, name);
  save_it();
}
void delete_soul_command(string name) {
  map_delete(soul_cache, name);
  map_delete(soul_command_names, name);
  unguarded((: rm, SOUL_DATA_DIR + name + ".os" :));
  save_it();
}
string *query_soul_commands() {
  return keys(soul_command_names);
}
protected mixed *query_soul_command_data(string str) {
  scache_reads++;
  if (!soul_cache[str] && soul_command_names[str]) {
    string tmp;
    tmp = unguarded((: read_file, SOUL_DATA_DIR + str + ".os" :));
    soul_cache[str] = restore_variable(tmp);
    if (!cache_callout && (sizeof(scache_order) > SCACHE_MAX_SIZE))
      cache_callout = call_out("clean_cache", CLEAN_UP_DELAY);
  } else {
    scache_order -= ({ str });
    scache_hits++;
  }
  scache_order += ({ str });
  return soul_cache[str];
}
mixed *query_soul_command_stuff(string str) {
  return query_soul_command_data(str) + ({ });
}
protected void save_soul_command(string name, mixed *data) {
  string str;
  str = save_variable(data);
  unguarded((: rm, SOUL_DATA_DIR + name + ".os" :));
  unguarded((: write_file, SOUL_DATA_DIR + name + ".os", str :));
  soul_command_names[name] = 1;
}
void save_it() {
  unguarded((: save_object, SAVE_FILE :));
}
void load_it() {
  string *names;
  int i;
  unguarded((: restore_object, SAVE_FILE :));
  if (mapp(soul_commands)) {
    soul_command_names = ([ ]);
    names = keys(soul_commands);
    for (i = 0; i < sizeof(names); i++) {
      reset_eval_cost();
      save_soul_command(names[i], soul_commands[names[i]]);
    }
    soul_commands = 0;
    save_it();
  }
}
private mixed create_pattern_cache(string pattern) {
  mixed *bing, ret;
  string s1, s2;
  bing = explode("#" + pattern, "<indirect:");
  if (sizeof(bing) == 1)
    if (sscanf(bing[0], "%s<word>%s", s1, s2) ||
        sscanf(bing[0], "%s<string>%s", s1, s2))
      ret = ONLY_ARGUMENT;
    else
      ret = NO_ARGUMENT;
  else if (sscanf(bing[0], "%s<word>%s", s1, s2) ||
           sscanf(bing[0], "%s<string>%s", s1, s2))
    ret = ARGUMENT_FIRST;
  else if (sscanf(bing[1], "%s<word>%s", s1, s2) ||
           sscanf(bing[1], "%s<string>%s", s1, s2))
    ret = ARGUMENT_SECOND;
  else
    ret = ONLY_TARGET;
  return ret;
}
mixed *query_soul_command(string name) {
  mixed *data;
  mixed *ret;
  string pat;
  int i;
  if (!soul_command_names[name]) {
    return 0;
  }
  data = query_soul_command_data(name);
  if (!data) {
    return 0;
  }
  ret = ({ ({ ({ }), "", 0, this_object(), 0 }) });
  for (i = 0; i < sizeof(data[PATTERNS]); i++) {
    pat = data[PATTERNS][i];
    pcache_reads++;
    if (!pattern_cache[pat]) {
      pattern_cache[pat] = create_pattern_cache(pat);
      if (!cache_callout && sizeof(pcache_order) > PCACHE_MAX_SIZE) {
        cache_callout = call_out("clean_cache", CLEAN_UP_DELAY);
      }
    } else {
      pcache_hits++;
      pcache_order -= ({ pat });
    }
    pcache_order += ({ pat });
    ret += ({ ({ ((mixed *) PATTERN_OB->query_pattern(pat))[1],
                   pat, 0, this_object(), 0 }) });
  }
  return ret;
}
int command_control(string verb, object * obs, string, string in_dir_match,
                    string *args, string pattern) {
  int i;
  int j;
  string arg;
  mixed *stuff;
  object *wom;
  object *rem;
  mixed *data;
  if (!soul_command_names[verb]) {
    return 0;
  }
  if (pattern != "") {
    stuff = PATTERN_OB->query_pattern(pattern);
    for (i = 1; i < sizeof(stuff); i++) {
      switch (stuff[i]) {
      case INDIRECT_OBJECT:
        i += 2;
        wom = obs;
        if (previous_object()->query_property("no soul")) {
          previous_object()->add_failed_mess(this_object(),
                                           "You cannot use directed souls.\n",
                                             ({ }));
          return 0;
        }
        if ((sizeof(obs) == 1) &&
            !previous_object()->query_creator() &&
            obs[0]->query_property("ignoring") &&
            member_array((string) previous_object()->query_name(),
                         (string *)obs[0]->query_property("ignoring")) != -1) {
          return 0;
        }
        if (sizeof(obs) > 1) {
          obs = filter(obs, (: !$1->check_earmuffs("multiple-soul") :));
          if (!sizeof(obs)) {
            previous_object()->add_failed_mess(this_object(),
               "Everyone seems to have their multiple souls earmuffed.  "
               "I'm depressed, are you depressed?\n",
                                               ({ }));
            return 0;
          }
        }
        rem = filter(obs,
                     (:
                      (!interactive($1) &&
                       environment(previous_object(1)) != environment($1)) ||
                      (interactive($1) && $1->query_role_playing() &&
                       environment($1) != environment(previous_object(1)))
                      :));
        obs -= rem;
        obs -= previous_object()->query_ignoring(obs);
         if(previous_object()->query_role_playing())
           obs -= filter(obs,
                         (:
                          environment($1) != environment(previous_object(1)) ||
                          (interactive($1) &&
                           !previous_object(1)->is_friend($1->query_name()))
                          :));
         if (!sizeof(obs)) {
           return 0;
         }
         if (previous_object()->check_earmuffs("remote-soul")) {
           if (previous_object()->query_earmuffs() ==
               PLAYER_ALLOW_FRIENDS_EARMUFF) {
             rem = filter(obs,
                          (:
                          environment(previous_object(1)) != environment($1) &&
                           !previous_object(1)->is_friend($1->query_name())
                           :));
           } else {
             rem = filter(obs,
                          (:
                           environment(previous_object(1)) != environment($1)
                           :));
           }
           if (sizeof(rem) == sizeof(obs)) {
             previous_object()->add_failed_mess(this_object(),
               "You cannot do a remote soul when you have remote souls "
                                                "earmuffed.\n", ({ }));
             return 0;
           }
           obs = obs - rem;
         } else {
           obs = filter(obs, (: !$1->check_earmuffs("remote-soul") ||
                              (environment(previous_object(1)) ==
                               environment($1)) :));
           if (!sizeof(obs)) {
             previous_object()->add_failed_mess(this_object(),
               "Remote soul earmuffs enabled for $I.\n", wom);
             return 0;
           }
         }
         j++;
         break;
       case STRING:
       case SINGLE_WORD:
       case SHORT_STRING:
         arg = args[j++];
         break;
       case NUMBER:
         j++;
         break;
       case FRACTION:
         j += 2;
         break;
       case OPTIONAL:
       case OPTIONAL_SPACES:
         i++;
         break;
       case WORD_LIST:
       case WORD_LIST_SPACES:
         i++;
         if (pointerp(stuff[i]) && sizeof(stuff[i]) > 1)
           j++;
         break;
       }
     }
   }
   if (!pattern_cache[pattern]) {
     return 0;
   }
   if (!previous_object()->query_creator()) {
     if ((int) previous_object()->adjust_sp(-SOUL_COST *
                                            (1 + sizeof(obs))) < 0) {
       previous_object()->add_failed_mess(this_object(), NO_POWER, ({ }));
       return 0;
     }
   }
   data = query_soul_command_data(verb);
   switch (pattern_cache[pattern]) {
   case NO_ARGUMENT:
     if (data[SINGLE])
       if (data[SINGLE][NO_ARGUMENTS]) {
         if (sizeof(data[SINGLE][NO_ARGUMENTS]) > POSITION_SINGLE) {
           print_messages(verb, 0, "", data[SINGLE][NO_ARGUMENTS][SELF],
                          data[SINGLE][NO_ARGUMENTS][REST],
                          0, 0,
                          data[SINGLE][NO_ARGUMENTS][POSITION_SINGLE]);
         } else {
           print_messages(verb, 0, "", data[SINGLE][NO_ARGUMENTS][SELF],
                          data[SINGLE][NO_ARGUMENTS][REST], 0, 0, 0);
         }
         return 1;
       } else {
         if (!data[SINGLE][ARGUMENTS])
           return 0;
         arg = data[SINGLE][ARGUMENTS][ARGS][0];
       } else
         return 0;
   case ONLY_ARGUMENT:
     if (arg == "?") {
       j = 0;
       for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
         j += sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
       j = random(j);
       for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
         if (j < sizeof(data[SINGLE][ARGUMENTS][i + ARGS])) {
           if (data[SINGLE][ARGUMENTS][i + ARGS][j] == "#") {
             if (j > 0)
               j--;
             else {
               j++;
               if (j >= sizeof(data[SINGLE][ARGUMENTS][i + ARGS])) {
                 j -= sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
                 continue;
               }
             }
           }
           print_messages(verb, 0, data[SINGLE][ARGUMENTS][i + ARGS][j],
                          data[SINGLE][ARGUMENTS][i + SELF],
                          data[SINGLE][ARGUMENTS][i + REST], 0, 0,
                          data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
           return 1;
         } else {
           j -= sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
         }
     }
     for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE) {
       if ((j = member_array(arg, data[SINGLE][ARGUMENTS][i + ARGS], 0, 1))
           != -1) {
         print_messages(verb, 0, data[SINGLE][ARGUMENTS][i + ARGS][j],
                        data[SINGLE][ARGUMENTS][i + SELF],
                        data[SINGLE][ARGUMENTS][i + REST],
                        0, 0,
                        data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
         return 1;
       }
     }
     for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
       if ((j = member_array("#", data[SINGLE][ARGUMENTS][i + ARGS], 0, 1))
           != -1) {
         print_messages(verb, 0, arg,
                        data[SINGLE][ARGUMENTS][i + SELF],
                        data[SINGLE][ARGUMENTS][i + REST], 0, 0,
                        data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
         return 1;
       }
     previous_object()->add_failed_mess(this_object(),
                                        arg +
                                        " is not a valid argument to the soul "
                                        "command \"" + verb + "\".\n",
                                        ({ }));
     return 0;
   case ARGUMENT_FIRST:
   case ARGUMENT_SECOND:
     break;
   case ONLY_TARGET:
     if (data[TARGET][NO_ARGUMENTS]) {
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, 0);
       print_messages(verb, obs, "",
                      data[TARGET][NO_ARGUMENTS][SELF],
                      data[TARGET][NO_ARGUMENTS][REST],
                      data[TARGET][NO_ARGUMENTS][TARGET],
                      data[TARGET][NO_ARGUMENTS][FORCE],
                      data[TARGET][NO_ARGUMENTS][POSITION]);
       return 1;
     }
     if (!data[TARGET][ARGUMENTS]) {
       return 0;
     }
     arg = data[TARGET][ARGUMENTS][ARGS][0];
     break;
   }
   if (arg == "?") {
     j = 0;
     for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
       j += sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
     }
     j = random(j);
     for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
       if (j < sizeof(data[TARGET][ARGUMENTS][i + ARGS])) {
         if (data[TARGET][ARGUMENTS][i + ARGS][j] == "#") {
           if (j > 0) {
             j--;
           } else {
             j++;
             if (j >= sizeof(data[TARGET][ARGUMENTS][i + ARGS])) {
               j -= sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
               continue;
             }
           }
         }
         obs->event_soul_command(this_object(), verb, previous_object(),
                                 in_dir_match, arg);
         print_messages(verb, obs, data[TARGET][ARGUMENTS][i + ARGS][j],
                        data[TARGET][ARGUMENTS][i + SELF],
                        data[TARGET][ARGUMENTS][i + REST],
                        data[TARGET][ARGUMENTS][i + TARGET],
                        data[TARGET][ARGUMENTS][i + FORCE],
                        data[TARGET][ARGUMENTS][i + POSITION]);
         return 1;
       } else {
         j -= sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
       }
     }
   }
   for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
     if ((j =
          member_array(arg, data[TARGET][ARGUMENTS][i + ARGS], 0,
                       1)) != -1) {
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, arg);
       print_messages(verb, obs, data[TARGET][ARGUMENTS][i + ARGS][j],
                      data[TARGET][ARGUMENTS][i + SELF],
                      data[TARGET][ARGUMENTS][i + REST],
                      data[TARGET][ARGUMENTS][i + TARGET],
                      data[TARGET][ARGUMENTS][i + FORCE],
                      data[TARGET][ARGUMENTS][i + POSITION]);
       return 1;
     }
   }
   for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
     if ((j =
          member_array("#", data[TARGET][ARGUMENTS][i + ARGS], 0,
                       1)) != -1) {
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, arg);
       print_messages(verb, obs, arg,
                      data[TARGET][ARGUMENTS][i + SELF],
                      data[TARGET][ARGUMENTS][i + REST],
                      data[TARGET][ARGUMENTS][i + TARGET],
                      data[TARGET][ARGUMENTS][i + FORCE],
                      data[TARGET][ARGUMENTS][i + POSITION]);
       return 1;
     }
   }
   return 0;
}
string get_name(object ob, int use_name, int type) {
  if(ob == previous_object())
    return ob->query_objective() + "self";
  if(userp(ob) && use_name && environment(ob) != environment(previous_object()))
    return "$mirror_short:" + file_name(ob) + "$";
  return ob->one_short(use_name);
}
private string create_message(mixed targets, string args, string pattern,
                              int type, string verb, string position,
                              string actor_position, mixed me,
                              int use_name) {
  string *bits;
  string *rabbit;
  string singular;
  string plural;
  int i;
  int word_break;
  if(arrayp(targets) && sizeof(targets) == 1)
    targets = targets[0];
  if (stringp(verb) && type && (sizeof(explode(pattern, "$V$")) < 2)) {
    if (pointerp(targets) && sizeof(targets) > 0) {
      pattern = replace_string(pattern, pluralize(verb), "$V$1=" +
                               pluralize(verb) + "," + verb + "$V$");
    } else {
      pattern = replace_string(pattern, pluralize(verb), "$V$0=" +
                               pluralize(verb) + "," + verb + "$V$");
    }
  }
  if(pattern) {
    pattern = replace_string(pattern, "$V$", "VERBFROG");
    bits = explode("%" + replace(pattern, ({ "$arg$", args })), "$");
  }
  if (!me) {
    me = previous_object();
  }
  for (i = 1; i < sizeof(bits); i += 2) {
    switch (bits[i]) {
    case "article":
      if (vowel(args[0])) {
        bits[i] = "an";
      } else {
        bits[i] = "a";
      }
      break;
    case "hcname":
      if (stringp(targets)) {
        bits[i] = targets;
        break;
      }
      if (objectp(targets)) {
        if ((targets == me)) {
          if (type) {
            bits[i] = (string) targets->query_objective() + "self";
          } else {
            bits[i] = "yourself";
          }
        } else {
          bits[i] = (string) get_name(targets, use_name, type);
        }
        break;
      }
      if(arrayp(targets)) {
        bits[i] = "$M$" + implode(map(targets, (: get_name :), use_name, type), "") +
                  "$M$";
      }
      break;
    case "mhcname":
      if (stringp(targets)) {
        bits[i] = targets + "'s";
        break;
      }
      if (objectp(targets)) {
        if ((targets == me))
          if (type)
            bits[i] = (string) targets->query_possessive();
          else
            bits[i] = "your";
        else
          bits[i] = (string) targets->the_poss_short();
        break;
      }
      bits[i] = "$M$" + implode(map(targets,
        (: objectp($1) ? $1->the_poss_short($(use_name)) : $1 + "'s" :)), "") +
        "$M$";
      break;
    case "hposs":
      if (objectp(targets))
        bits[i] = (string) targets->query_possessive();
      else
        bits[i] = "their";
      break;
    case "hpronoun":
      if (objectp(targets))
        bits[i] = (string) targets->query_pronoun();
      else
        bits[i] = "they";
      break;
    case "hobj":
      if (objectp(targets))
        bits[i] = (string) targets->query_objective();
      else
        bits[i] = "them";
      break;
    case "mcname":
      if(stringp(me))
        bits[i] = me;
      else if (me != previous_object()) {
        bits[i] = (string) me->short(0, 0);
      } else if(userp(me) && use_name) {
        bits[i] = me->short(0, 0);
      } else
        bits[i] = me->the_short();
      break;
    case "mposs":
      if (type && objectp(me)) {
        bits[i] = (string) me->query_possessive();
      } else {
        bits[i] = "your";
      }
      break;
    case "mpronoun":
      bits[i] = (string) me->query_pronoun();
      break;
    case "mobj":
      if(objectp(me))
        bits[i] = (string) me->query_objective();
      else
        bits[i] = "you";
      break;
    case "position":
      if (position) {
        rabbit = explode("%" + position, "$");
        rabbit[0] = rabbit[0][1..];
        if ((sizeof(rabbit) % 2) == 1) {
          rabbit += ({ "" });
        }
        bits = bits[0..i] + rabbit + bits[i + 1..];
      }
      bits[i] = "";
      break;
    case "aposition":
      if (actor_position) {
        rabbit = explode("%" + actor_position, "$");
        rabbit[0] = rabbit[0][1..];
        if ((sizeof(rabbit) % 2) == 1) {
          rabbit += ({ "" });
        }
        bits = bits[0..i] + rabbit + bits[i + 1..];
      }
      bits[i] = "";
      break;
    case "s":
      if (i == 0)
        break;
      word_break = strsrch(bits[i - 1], ' ', -1);
      if (word_break == -1)
        break;
      if (me == previous_object())  {
        if (use_name)
          bits[i] = pluralize(bits[i - 1][word_break + 1 .. ]);
        else  {
          if (pointerp(targets)  &&  sizeof(targets) > 0)
            bits[i] = "$V$1=";
          else
            bits[i] = "$V$0=";
          bits[i] +=  pluralize(bits[i - 1][word_break + 1 .. ]) + "," +
                    bits[i - 1][word_break + 1 .. ] + "$V$";
        }
        bits[i - 1] = bits[i - 1][0 .. word_break];
      }
      break;
    case "verb":
      if (i + 1 < sizeof(bits))  {
        if (sscanf(bits[i + 1], "%s,%s", singular, plural) == 2)
        {
          if (me == previous_object())  {
            if (use_name)
              bits[i] = singular;
            else  {
              if (pointerp(targets)  &&  sizeof(targets) > 0)
                bits[i] = "$V$1=";
              else
                bits[i] = "$V$0=";
              bits[i] +=  singular + "," + plural + "$V$";
            }
          }
          else bits[i] = singular;
          bits = bits[0 .. i] + bits[i + 2 .. ];
        }
      }
      break;
    case "dollar":
      bits[i] = "$";
      break;
    }
  }
  pattern = implode(bits, "")[1..] + "\n";
  pattern = replace_string(pattern, "VERBFROG", "$V$");
  return pattern;
}
private string position_command(mixed bing) {
  if (stringp(bing)) {
    return bing;
  }
  if (mapp(bing)) {
    return bing["cmd"];
  }
  return 0;
}
private void do_position_stuff(object ob, mapping position) {
  string cur_pos;
  string new_pos;
  if (position) {
    cur_pos = ob->query_position();
    if (position[cur_pos]) {
      new_pos = position_command(position[cur_pos]);
    } else if (position["default"]) {
      new_pos = position_command(position["default"]);
    }
    if (new_pos && new_pos != "ignore" &&
        !ob->query_cannot_change_position() &&
        ("/cmds/living/" + new_pos)->query_position_command()) {
      ("/cmds/living/" + new_pos)->position(ob, position["silent"]);
    }
  }
}
private string *position_string(object ob, mapping position, int) {
  string *str;
  string cur_pos;
  mixed new_pos;
  str = ({ 0, 0, 0 });
  if (position) {
    cur_pos = ob->query_position();
    if (position[cur_pos]) {
      new_pos = position[cur_pos];
    } else if (position["default"]) {
      new_pos = position["default"];
    }
    if (mapp(new_pos)) {
      return ({ new_pos["self"], new_pos["target"], new_pos["rest"] });
    }
    if (new_pos && new_pos != "ignore" &&
        !ob->query_cannot_change_position() &&
        ("/cmds/living/" + new_pos)->query_position_command()) {
      str = ({ " making you " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down(),
                 " making $hobj$ " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down(),
                 " making $hobj$ " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down()
                 });
    }
  }
  return str;
}
private string position_of(object ob, mapping position) {
  string tmp;
  tmp = ob->query_position();
  if (position[tmp]) {
    tmp = position_command(position[tmp]);
    if (tmp) {
      return tmp;
    }
  }
  if (position["default"]) {
    tmp = position_command(position["default"]);
    if (tmp) {
      return tmp;
    }
  }
  return "";
}
private string env_position_of(object ob, mapping position) {
  return file_name(ob->query_current_room()) + position_of(ob, position);
}
private void print_messages(string verb, mixed obs, string arg, string self,
                            string rest, string target, string force,
                            mapping position) {
  object *here, *targ;
  string *pos_stuff, *actor_pos_stuff;
  if(!obs)
    obs = ({ });
  if(!position)
    position = ([ ]);
  switch(sizeof(obs)) {
  case 0:
    pos_stuff = position_string(previous_object(), position, 0);
    actor_pos_stuff = ({ "", "", ""});
    do_position_stuff(previous_object(), position);
    break;
  case 1:
    pos_stuff = position_string(obs[0], position, 0);
    actor_pos_stuff = position_string(previous_object(), position["actor"], 0);
    do_position_stuff(obs[0], position);
    if (position && position["actor"])
      do_position_stuff(previous_object(), position["actor"]);
    break;
  default:
    actor_pos_stuff = position_string(previous_object(), position["actor"], 0);
    pos_stuff = ({ "", "", "" });
    if (position && position["actor"])
      do_position_stuff(previous_object(), position["actor"]);
  }
  here = filter(obs, (: environment(previous_object(1)) == environment($1) :));
  targ = obs - here - ({ previous_object() });
  if(!sizeof(obs) || sizeof(here))
    previous_object()->remove_hide_invis("hiding");
  if(member_array(previous_object(), obs) == -1) {
    previous_object()->event_soul(previous_object(),
                                 create_message(obs, arg, self, 0, 0,
                                                 pos_stuff[POS_TARGET],
                                                 actor_pos_stuff[POS_TARGET],
                                                 0, 1), ({ }), verb, arg, 0);
  } else {
    if(sizeof(obs) > 1)
      obs -= ({ previous_object() });
    previous_object()->event_soul(previous_object(),
                                  create_message(obs, arg, self, 0, 0,
                                                 pos_stuff[POS_SELF],
                                                 actor_pos_stuff[POS_SELF],
                                                 0, 1), ({ }), verb, arg, 0);
  }
  if(arg)
    arg = replace(arg,
                  ({ "yourself", previous_object()->query_objective() + "self",
                       "your", previous_object()->query_possessive() }));
  if(sizeof(targ)) {
    target = replace(target, ({ " you.", " $hcname$.",
                                " you ", " $hcname$ ",
                                " you!", " $hcname$!",
                                " your ", " $mhcname$ " }));
    targ->event_soul(previous_object(),
                     create_message(obs, arg, target, 1, 0,
                                    pos_stuff[POS_SELF],
                                    actor_pos_stuff[POS_TARGET], 0, 1),
                     ({ }), verb, arg, 0);
  }
  obs -= ({ previous_object() });
  if(!sizeof(obs) || sizeof(here)) {
    if(sizeof(here) > 1)
      here -= ({ previous_object() });
    if(environment(previous_object()))
      event(environment(previous_object()), "soul",
            create_message(here, arg, rest, 1, 0, pos_stuff[POS_REST],
                           actor_pos_stuff[POS_REST], 0, 0),
            ({ previous_object() }) + targ, verb, arg,
            sizeof(here)>=1?here[0]:0);
  }
#ifdef DISABLED
  if(sizeof(obs) && stringp(force)) {
    force = replace(force, "$mcname$", previous_object()->query_name());
    foreach(ob in obs)
      call_out("do_force", 2, ({ ob, force }));
  }
#endif
}
string add_start(string pat, string verb) {
  return verb + " " + pat;
}
string help_list() {
  return "$P$Soul$P$The commands available in this soul currently number " +
    sizeof(soul_command_names) +
    ".\nHere is a nice list of them.\nGood luck!\n" +
    sprintf("%-#*s\n\n", (int) this_player()->query_cols(),
            implode(sort_array(keys(soul_command_names), 1), "\n"));
}
string help_string(string verb) {
  string ret, arg;
  int i;
  mixed target;
  mixed *data;
  if (!soul_command_names[verb])
    return 0;
  data = query_soul_command_data(verb);
  ret = sprintf("Allowed command patterns:\n%-#*s\n\n",
                (int) this_player()->query_cols(),
                implode(map_array(data[PATTERNS],
                                  "add_start", this_object(), verb), "\n"));
  if (data[SINGLE]) {
    if (data[SINGLE][NO_ARGUMENTS]) {
      ret += "Has a no arguments mode.\nSelf:   " +
        create_message(0, "", data[SINGLE][NO_ARGUMENTS][SELF], 0, 0,
                       0, 0, this_player(), 0) +
        "Others: " +
        create_message(0, "", data[SINGLE][NO_ARGUMENTS][REST], 1, 0,
                       0, 0, this_player(), 0) + "\n";
    }
    if (data[SINGLE][ARGUMENTS]) {
      for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE) {
        arg = data[SINGLE][ARGUMENTS][i + ARGS][0];
        ret += sprintf("For the arguments: [%-=*s",
                       (int) this_player()->query_cols() - 20,
                       implode(data[SINGLE][ARGUMENTS][i + ARGS],
                               ", ") + "]") + "\nSelf:   " +
          create_message(0, arg, data[SINGLE][ARGUMENTS][i + SELF], 0, 0,
                         0, 0, this_player(), 0)
          + "Others: " + create_message(0, arg,
                                        data[SINGLE][ARGUMENTS][i + REST], 1,
                                        0, 0, 0, this_player(), 0)
          + "\n";
      }
    }
  }
  if (data[TARGET]) {
    target = query_multiple_short(({ "Womble", "Cabbage" }));
    if (data[TARGET][NO_ARGUMENTS]) {
      ret += "Has a no arguments, targeted mode.\nSelf:   " +
        create_message(target, "", data[TARGET][NO_ARGUMENTS][SELF], 0, 0,
                       0, 0,
                       this_player(), 0) + "Target: " +
        (data[TARGET][NO_ARGUMENTS][TARGET] ?
         create_message(target, "", data[TARGET][NO_ARGUMENTS][TARGET], 2,
                        0, 0, 0, this_player(), 0) :
         create_message(target, "", data[TARGET][NO_ARGUMENTS][REST],
                        1, 0, 0, 0,this_player(), 0)) +
        "Others: " + create_message(target, "",
                                    data[TARGET][NO_ARGUMENTS][REST], 1,
                                    0, 0, 0, this_player(), 0) + "\n";
    }
    if (data[TARGET][ARGUMENTS]) {
      for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
        arg = data[TARGET][ARGUMENTS][i + ARGS][0];
        ret += sprintf("For the arguments: [%-=*s",
                       (int) this_player()->query_cols() - 20,
                       implode(data[TARGET][ARGUMENTS][i + ARGS],
                               ", ") + "]") + "\nSelf:   " +
          create_message(target, arg, data[TARGET][ARGUMENTS][i + SELF],
                         0, 0, 0, 0,
                         this_player(), 0) + "Target: " +
          (data[TARGET][ARGUMENTS][TARGET + i] ?
           create_message(target, arg,
                          data[TARGET][ARGUMENTS][i + TARGET], 2, 0, 0,
                          0, this_player(), 0) :
           create_message(target, arg,data[TARGET][ARGUMENTS][i + REST],
                          1, 0, 0, 0,this_player(), 0)) +
          "Others: " + create_message(target, arg,
                                      data[TARGET][ARGUMENTS][i + REST],
                                      1, 0, 0, 0, this_player(), 0);
      }
    }
  }
  return this_player()->convert_message(ret);
}
void do_force(mixed *arr) {
  string cmd;
  cmd = explode(arr[1], " ")[0];
  if (soul_command_names[cmd] &&
      !arr[0]->query_property("dead") &&
      userp(arr[0]))
    arr[0]->eventForce(arr[1]);
}
int query_pcache_size() {
  return sizeof(keys(pattern_cache));
}
int query_scache_size() {
  return sizeof(keys(soul_cache));
}
mixed *stats() {
  return ({ ({ "souls read", scache_reads, }),
              ({ "soul cache hit percent",
                   (scache_hits * 100) / scache_reads, }),
              ({ "souls in cache", sizeof(keys(soul_cache)), }),
              ({ "patterns read", pcache_reads, }),
              ({ "pattern cache hit percent",
                   (pcache_hits * 100) / pcache_reads, }),
              ({ "patterns in cache", sizeof(keys(pattern_cache)) - 1, }), });
}
