# Total Tokens: 17416
# Total Files Merged: 10
# Total Characters: 58092

c
==================================================

#include <money.h>
#include <player.h>
inherit "/std/room/basic_room";
void load_me();
class stable {
   int date_in;
   int last_paid;
   string name;
   mixed* save_info;
}
private nosave string _directory;
private nosave int _start_cost;
private nosave int _cost_per_week;
private nosave mapping _stable_cache;
private nosave string* _stable_types;
private mapping _accounts;
int do_list();
int do_stable( object *obs );
int do_deposit( string mon );
int do_return( string num );
void create() {
  _start_cost = 400;
  _cost_per_week = 400;
  _stable_cache = ([ ]);
  _accounts = ([ ]);
  _stable_types = ({ });
  add_help_file( "stable" );
  ::create();
}
void init() {
  add_command( "list", "", (: do_list() :) );
  add_command( "stable", "<indirect:object:here>", (: do_stable($1) :) );
  add_command( "deposit", "<string'money'>", (: do_deposit($4[0]) :) );
  add_command( "return", "<string'horse num'>", (: do_return($4[0]) :) );
}
void set_save_directory( string directory ) {
  if ( directory[<1] != '/' )
    directory += "/";
  _directory = directory;
  load_me();
}
string query_save_directory() {
  return _directory;
}
void set_start_cost( int start_cost ) {
  _start_cost = start_cost;
}
int query_start_cost() {
  return _start_cost;
}
void set_cost_per_week( int cost_per_week ) {
  _cost_per_week = cost_per_week;
}
int query_cost_per_week() {
  return _cost_per_week;
}
void save_me() {
  unguarded( (: save_object(_directory + "main_account") :) );
}
void load_me() {
  unguarded( (: restore_object(_directory + "main_account", 1) :) );
}
int query_balance( string name ) {
  return _accounts[name];
}
void set_balance( string name, int amt ) {
  _accounts[name] = amt;
   save_me();
}
void adjust_balance( string name, int amt ) {
  _accounts[name] += amt;
  save_me();
}
int query_player_money( object player, string place ) {
  return player->query_value_in( place ) +
         query_balance( player->query_name() );
}
void remove_player_money( object player, int amt, string place ) {
  int balance;
  balance  = query_balance( player->query_name() );
  if ( balance < 0 ) {
     amt += -balance;
     balance = 0;
  } else {
    if ( amt <= balance ) {
      balance -= amt;
      amt = 0;
    } else {
      amt -= balance;
      balance = 0;
    }
  }
  if ( amt > 0 ) {
    player->pay_money( MONEY_HAND->create_money_array( amt, place ),
                       place );
   }
   set_balance( player->query_name(), balance );
}
void add_stable_type( string type ) {
  if ( member_array( type, _stable_types ) == -1) {
    _stable_types += ({ type });
  }
}
string* query_stable_types() {
  return _stable_types;
}
int can_stable_type( string type ) {
  if ( member_array( type, _stable_types ) != -1 ) {
    return 1;
  }
  return 0;
}
protected class stable* query_stable( string name ) {
  string str;
  if ( !_stable_cache[name] && file_size( _directory + name + ".o" ) > 0 ) {
    str = read_file( _directory + name + ".o" );
    if ( str ) {
      _stable_cache[name] = restore_variable( str );
    }
  }
  return _stable_cache[name];
}
protected void set_stable( string name, class stable* value ) {
  _stable_cache[name] = value;
  if ( !value || !sizeof( value ) ) {
    unguarded( (: rm(_directory + $(name) + ".o") :) );
  } else {
    unguarded( (: write_file( _directory + $(name) + ".o",
                  save_variable( $(value) ), 1 ) :) );
  }
}
int query_stabling_cost( string name, int pos ) {
  class stable* bing;
  bing = query_stable( name );
  if ( pos < 0 || pos >= sizeof( bing ) ) {
    return 0;
  }
  return ( ( time() - bing[pos]->last_paid ) * _cost_per_week ) /
           (7 * 24 * 60 * 60);
}
int add_to_stable( string name, object* horses ) {
  class stable* bing;
  class stable womble;
  object horse;
  bing = query_stable( name );
  if ( !bing ) {
    bing = ({ });
  }
  foreach ( horse in horses ) {
    womble = new( class stable );
    womble->date_in = time();
    womble->last_paid = time();
    womble->name = horse->query_short();
    womble->save_info = AUTO_LOAD_OB->create_auto_load( ({ horse }) );
    bing += ({ womble });
  }
  set_stable( name, bing );
  horses->move("/room/rubbish");
  return 1;
}
void print_ok_message( object me, object* horses ) {
  write( "You stable " + query_multiple_short( horses ) + " into " +
         the_short() + ".\n" );
  say( this_player()->the_short() + " stables " +
       query_multiple_short( horses ) + " into " + the_short() + ".\n" );
}
int do_stable( object *obs ) {
  class stable* bing;
  int cost;
  object horse;
  object *ok;
  string place;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  bing = query_stable( this_player()->query_name() );
  ok = ({ });
  foreach ( horse in obs ) {
    if ( !can_stable_type( horse->query_transport_type() ) ) {
      add_failed_mess( "$I is not able to be stabled here.\n", ({ horse }) );
    } else if ( horse->query_owner() != this_player()->query_name() ) {
      add_failed_mess( "You do not own $I and therefore cannot stable them.\n",
                       ({ horse }) );
    } else {
      ok += ({ horse });
      cost += _start_cost;
    }
  }
  if ( sizeof( ok ) ) {
    if ( query_player_money( this_player(), place ) < cost ) {
      add_failed_mess( "You do not have enough money to stable $I, you "
                       "need " + MONEY_HAND->money_value_string(cost, place) +
                       ".\n", ok );
      return 0;
    }
    write( "It will cost you " + MONEY_HAND->money_value_string( cost, place ) +
           " to stable " + query_multiple_short( ok ) + " here and " +
           MONEY_HAND->money_value_string( _cost_per_week, place ) +
           " for each horse for every week it stays here.\nDo you accept "
           "this? " );
    input_to( "check_stable", 0, cost, ok, place );
    add_succeeded_mess( "" );
  }
  return sizeof( ok );
}
protected void check_stable( string mess, int cost, object *ok, string place ) {
  if ( strlen( mess ) && lower_case( mess )[0] == 'y' ) {
    if ( query_player_money( this_player(), place ) < cost ) {
      write("Oops!  You seem to have run out of money.\n" );
    } else {
      remove_player_money( this_player(), cost, place );
      add_to_stable( this_player()->query_name(), ok );
      print_ok_message( this_player(), ok );
    }
  } else {
    write( "Ok, abandoning the check in.\n" );
  }
}
int do_list() {
  class stable* bing;
  int i;
  int cost;
  int balance;
  string debt;
  string place;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  bing = query_stable( this_player()->query_name() );
  balance = query_balance( this_player()->query_name() );
  if ( !bing || !sizeof( bing ) ) {
    if( !balance ) {
      add_failed_mess( "You do not have any horses stabled here.\n" );
      return 0;
    }
    write( "You have a balance of " +
           MONEY_HAND->money_value_string( cost, place ) +
           " in your stabling account.\n" );
    return 1;
  }
  for ( i = 0; i < sizeof( bing ); i++ ) {
    cost = query_stabling_cost( this_player()->query_name(), i );
    if ( cost == 0 ) {
      debt = "paid up";
    } else if (cost < 0) {
      debt = "in credit " + MONEY_HAND->money_value_string( -cost, place );
    } else {
      debt = "in debt " + MONEY_HAND->money_value_string( cost, place );
    }
    write( sprintf( " %c) %s; %s\n ", 'A' + i, bing[i]->name, debt ) );
  }
  if ( balance > 0 ) {
    write( "You have a stable balance of " +
           MONEY_HAND->money_value_string( balance, place ) + ".\n" );
  } else if ( balance < 0 ) {
    write( "You have a stable balance of " +
           MONEY_HAND->money_value_string( balance, place ) + " in debt.\n" );
  } else {
    write( "You do not have a balance at this time.\n" );
  }
  add_succeeded_mess( ({ "", "$N checks out $p horses.\n" }) );
  return 1;
}
int do_return( string num ) {
  class stable* bing;
  int pos;
  int cost;
  object* horses;
  string place;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  bing = query_stable( this_player()->query_name() );
  if ( !sizeof( bing ) ) {
    add_failed_mess( "You do not have any horses stabled here.\n" );
    return 0;
  }
  num = lower_case( num );
  pos = num[0] - 'a';
  if ( pos < 0 || pos > sizeof( bing ) ) {
    add_failed_mess( "You must return a horse in the range 'A' - '" +
                     sprintf( "%c", 'A' + sizeof( bing ) - 1 ) + "'.\n" );
    return 0;
  }
  cost = query_stabling_cost( this_player()->query_name(), pos );
  if ( query_player_money( this_player(), place ) < cost ) {
    add_failed_mess( "You do not have enough money to return this horse "
                     "you need " +
                     MONEY_HAND->money_value_string( cost, place ) +
                     ".\n" );
    return 0;
  }
  horses = AUTO_LOAD_OB->load_auto_load_to_array( bing[pos]->save_info );
  horses->move( this_object() );
  horses->set_owner( this_player()->query_name() );
  bing = bing[0..pos - 1] + bing[pos + 1..];
  set_stable( this_player()->query_name(), bing );
  if ( cost > 0 ) {
    remove_player_money( this_player(), cost, place );
  }
  add_succeeded_mess( "$N $V $I from " + the_short() + ".\n", horses );
  return 1;
}
int do_deposit( string mon ) {
  string place;
  mixed money;
  int amt;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  if ( undefinedp( query_balance( this_player()->query_name() ) ) ) {
    add_failed_mess( "You do not currently have a balance here.\n" );
    return 0;
  }
  money = MONEY_HAND->parse_money( mon, this_player(), place );
  if ( intp( money ) ) {
    switch ( money ) {
      case NO_MATCH :
        add_failed_mess( "You do not have '" + mon + "'.\n" );
        return 0;
      case NO_MONEY :
        add_failed_mess( "You can only deposit money.\n" );
        return 0;
      default :
        add_failed_mess( "You can only deposit legal tender.\n" );
        return 0;
    }
  }
  amt = money->query_value_in( place );
  if ( place != "default" ) {
    amt += money->query_value_in( "default" );
  }
  adjust_balance( this_player()->query_name(), amt );
  add_succeeded_mess( ({ "You deposit " +
                      MONEY_HAND->money_string( money->query_money_array() ) +
                      " into your stable account.\n",
                      "$N deposits some money into $p account.\n" }) );
  return 1;
}

==================================================
FILE: room/voting_room.c
==================================================

#include <board.h>
#define DEFAULT_VOTE_DURATION 2600*24*7
inherit "/std/room/basic_room";
inherit "/std/room/inherit/voting_room";
void create() {
  voting_room::create();
  do_setup++;
  add_help_file("voting_room");
  basic_room::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
}
void init() {
   basic_room::init();
   voting_room::init();
}

==================================================
FILE: room/water_inside.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/basic/water";
private int _setting_water_light = 0;
void init() {
  water::init();
  basic_room::init();
}
int is_allowed_position(string poss) {
  return water::is_allowed_position(poss);
}
mixed *query_default_position(object ob) {
  return water::query_default_position(ob);
}
int add_exit(string direc, mixed dest, string type) {
  int retval = basic_room::add_exit(direc, dest, type);
  water::add_exit(direc, dest, type);
  return retval;
}
int query_light() {
  update_water_light();
  if (query_surface()) {
    return ::query_light();
  }
  return ::query_light()*query_clarity()/100;
}
int set_water_light(int number) {
  _setting_water_light = 1;
  set_light(number);
  _setting_water_light = 0;
}
int adjust_light(int number) {
  if (!_setting_water_light) {
    set_use_surface_light(0);
  }
  return ::adjust_light(number);
}
mixed query_property(string tag) {
  if ("location" == tag && !query_surface()) {
    return "underwater";
  }
  return ::query_property(tag);
}
int attack_speed() { return 5; }

==================================================
FILE: room/water_outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/room/basic/water";
private int _setting_water_light = 0;
void init() {
  water::init();
  outside::init();
}
int is_allowed_position(string poss) {
  return water::is_allowed_position(poss);
}
mixed *query_default_position(object ob) {
  return water::query_default_position(ob);
}
int add_exit(string direc, mixed dest, string type) {
  int retval = outside::add_exit(direc, dest, type);
  water::add_exit(direc, dest, type);
  return retval;
}
int query_light() {
  update_water_light();
  if (query_surface()) {
    return ::query_light();
  }
  return ::query_light()*query_clarity()/100;
}
int set_water_light(int number) {
  _setting_water_light = 1;
  set_light(number);
  _setting_water_light = 0;
}
int adjust_light(int number) {
  if (!_setting_water_light) {
    set_use_surface_light(0);
  }
  return ::adjust_light(number);
}
mixed query_property(string tag) {
  if ("location" == tag && !query_surface()) {
    return "underwater";
  }
  return ::query_property(tag);
}
int attack_speed() { return 5; }

==================================================
FILE: room/basic/chatter.c
==================================================

#include <room.h>
nosave int _off;
nosave object _room;
nosave mixed *_chats;
void set_chat_min_max( int min,int  max ) {
  if (_chats) {
    _chats[0]=min;
    _chats[1]=max;
  }
}
void setup_chatter( object my_room,  mixed *chat_args ) {
   _off = 1;
   _room = my_room;
   if( !arrayp( chat_args ) ) {
      chat_args = ({ chat_args });
   }
   _chats = chat_args + ({ 0 });
}
void dest_me() {
  destruct( this_object() );
}
void make_chat() {
   int saying;
   mixed stuff;
   if(!_room) {
     dest_me();
     return;
   }
   if ( !_chats || sizeof(_chats) < 3 || !sizeof(_chats[2]) ||
        !sizeof( filter( all_inventory( _room ), (: interactive($1) :),
         this_object() ) ) ) {
      _off = 1;
      return;
   }
   saying = random( sizeof( _chats[ 2 ] ) );
   if ( saying == _chats[ 3 ] ) {
     saying = ( saying + 1 ) % sizeof( _chats[ 2 ] );
   }
   _chats[ 3 ] = saying;
   stuff = _chats[ 2 ][ saying ];
   if (stringp(stuff)) {
      if ( stuff[ 0 ] == '#' ) {
         call_other( _room, stuff[ 1 .. 99 ] );
      } else {
         tell_room( _room, _chats[ 2 ][ saying ] +"\n" );
      }
   }
   if ( intp( stuff ) ) {
      map( filter( all_inventory( _room ), (: $1 && living( $1 )
         && $1->query_creator() :) ), (: tell_creator( $1, "Warning: "
         "room_chat array contains integer argument. Did you mix up "
         "the syntax with load_chat()'s?\n" ) :) );
   }
   ROOM_HANDLER->add_chatter( this_object(), _chats[ 0 ] +
         random( _chats[ 1 ] - _chats[ 0 ] + 1 ) );
}
void check_chat() {
   if ( !_off || !pointerp( _chats ) ) {
      return;
   }
   _off = 0;
   ROOM_HANDLER->add_chatter( this_object(), ( _chats[ 0 ] +
         random( _chats[ 1 ] - _chats[ 0 ] + 1 ) ) / 2 );
}
void add_room_chats( string *new_chats ) {
   if (sizeof(new_chats)) {
     if (sizeof(_chats[2])) {
        _chats[2] = _chats[2] + new_chats;
     } else {
        _chats[2]= new_chats;
     }
   }
}
void remove_room_chats( string *dead_chats ) {
   if (sizeof(_chats[2])) {
      _chats[2] = _chats[2] - dead_chats;
   }
   if (!sizeof(_chats[2])) {
      destruct(this_object());
   }
}
mixed *query_room_chats() { return _chats; }
int clean_up( int parent ) {
  if (parent)
    return 0;
  if (!_room || _room->query_chatter() != this_object())
    dest_me();
}

==================================================
FILE: room/basic/door.c
==================================================

#include <door.h>
#include <room.h>
#include <parse_command.h>
#include <dirs.h>
#define BEVERB ({ " is ", " are " })
#define PRONOUN ({ "it", "them" })
#define CLOSED        2
#define CLOSED_LOCKED 3
inherit "/std/basic/enchant";
inherit "/std/basic/hide_invis";
inherit "/std/basic/property";
inherit "/std/basic/close_lock";
inherit "/std/basic/trap";
inherit "/std/basic/id_match";
private int how_many;
private int one_way;
private string _lock_owner;
private string shrt;
private string lng;
private string my_id;
private string other_id;
private string *name;
private string *adjs;
private string *plu;
private string dest;
private string _door_name;
private object key;
private object my_room;
void create() {
   hide_invis::create();
   property::create();
   close_lock::create();
   name = ({ "door" });
   lng = "It's just a door.\n";
   shrt = "door";
   adjs = ({ });
   plu = ({ });
   add_property( "determinate", "the " );
   set_unlocked();
}
int query_how_many() {
    return how_many;
}
void set_how_many( int number ) {
  if(number)
    add_property("group object", 1);
  else
    remove_property("group object");
  how_many = number;
}
int query_one_way() {
    return one_way;
}
void set_one_way( int number ) {
    one_way = number;
}
string query_short() {
    return shrt;
}
void set_short( string words ) {
   string *bits;
   shrt = words;
   bits = explode( words, " " );
   bits += implode( map( bits, (: explode( $1, "-" ) :) ), (: $1 + $2 :) );
   bits = uniq_array( bits );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs += bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
}
string query_door_name() {
    return _door_name;
}
void set_door_name( string word ) {
    _door_name = word;
}
void set_lock_owner(string owner) {
    _lock_owner = owner;
}
mixed query_lock_owner() {
    return _lock_owner;
}
string query_long() { return lng; }
void set_long( string word ) {lng = word;}
string query_my_id() { return my_id; }
void set_my_id( string word ) { my_id = word; }
string query_other_id() { return other_id; }
void set_other_id( string word ) { other_id = word; }
string *query_name() { return name; }
string *query_adjs() { return adjs; }
string *query_plu() { return plu; }
string query_dest() { return dest; }
void set_dest( string word ) { dest = word; }
object query_my_room() { return my_room; }
void init() {
   add_command( "knock", "on <direct:object>" );
   close_lock::init();
}
string query_determinate() { return "the "; }
string short() { return query_short(); }
string a_short() { return "$a_short:"+ file_name( this_object() ) +"$"; }
string one_short() { return "$one_short:"+ file_name( this_object() ) +"$"; }
string poss_short() { return "$poss_short:"+ file_name( this_object() ) +"$"; }
string the_short() { return "$the_short:"+ file_name( this_object() ) +"$"; }
string pretty_short() { return query_short(); }
string query_plural() { return pluralize( query_short() ); }
string pretty_plural() { return pluralize( query_short() ); }
string long() {
  return lng + ( ( this_player()->query_see_octarine() ) ? enchant_string() :
                 "" ) + long_status();
}
int drop() { return 1; }
int get() { return 1; }
void setup_door( string word, object mine, string his, mixed *args,
                 string type) {
   string *bits;
   my_id = word;
   my_room = mine;
   dest = his;
   switch(type) {
   case "window":
     if(word != "window")
       shrt = word + " window";
     else
       shrt = word;
     lng = "It's just the " + shrt + ".\n";
     name = ({ shrt, "window" });
     plu = ({ "windows" });
     break;
   default:
     if ( word[ 0 .. 5 ] == "enter " ) {
       if(SHORTEN[word[6..100]])
         name += ({ SHORTEN[word[6..100]] });
       shrt = word[ 6 .. 100 ] +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     } else {
       if(SHORTEN[word])
         name += ({ SHORTEN[word] });
       shrt = word +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     }
     break;
   }
   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits;
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
   (!args[ D_CLOSED ]) ? set_closed() : set_open();
   (args[ D_LOCKED ]) ? set_locked() : set_unlocked();
   set_key(args[ D_KEY ] );
   set_difficulty(args[ D_DIFFICULTY ] );
   if ( args[ D_SECRET ] )
      add_hide_invis( "secret", 0, 200, 0 );
   if(sizeof(args) >= D_TRANSPARENT && args[D_TRANSPARENT])
     set_transparent();
   set_door_name(args[D_NAME]);
}
void add_alias( string word ) {
   string *bits;
   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
}
int force_other() {
  string door_name, direc;
  if(!find_object(dest)) {
    if(!load_object(dest))
      return 0;
    dest->query_door( my_room, _door_name );
  }
  if(!other_id) {
    door_name = my_room->call_door(my_id, "query_door_name");
    direc = dest->query_door(my_room, door_name);
    my_room->modify_exit( my_id, ({ "other", direc }) );
  }
  if(!other_id)
    return 0;
  return 1;
}
int do_open() {
  if(!::do_open())
    return 0;
  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }
  if(((string)my_room->query_property( "location" ) == "outside") &&
     (member_array(find_object(ROOM_HANDLER), previous_object(-1)) == -1))
    ROOM_HANDLER->add_door( this_object() );
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    if(this_player())
      dest->tell_door(other_id, (string)this_player()->a_short() +
                      " opens the $D.\n", 0);
    else
      dest->tell_door(other_id, "Someone opens the $D.\n", 0);
  }
  return 1;
}
int do_close() {
  if(!::do_close())
    return 0;
  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D which "
                       "lock$s as $p close$s.\n", 0 );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D.\n", 0 );
    }
  }
  return 1;
}
int do_lock(object *obs) {
  if(!::do_lock(obs))
    return 0;
  if(!force_other() && !one_way) {
    set_unlocked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 1 }));
    dest->tell_door(other_id, "Someone locks the $D.\n", 0);
  }
  return 1;
}
int do_unlock(object *obs) {
  if(!::do_unlock(obs))
    return 0;
  if(!force_other() && !one_way) {
    set_locked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 0 }));
    dest->tell_door(other_id, "Someone unlocks the $D.\n", 0);
  }
  return 1;
}
int do_knock() {
  if(this_player()->query_property("dead"))
    return 0;
  if ( !other_id && !one_way ) {
    ROOM_HANDLER->check_door( ({ my_room, my_id }) );
    if ( !other_id )
      return 0;
  }
  if ( one_way )
    return 1;
  if(query_transparent())
    dest->tell_door(other_id, this_player()->a_short() +
                    " knocks on the $D.\n", 0);
  else
    dest->tell_door( other_id, "Someone knocks on the $D.\n", 0 );
  event(find_object(dest), "door_knock", this_player(), other_id);
  return 1;
}
int pick_unlock(object thing) {
  if (stringp(_lock_owner)) {
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }
  if(!::pick_unlock(thing)) {
    return 0;
  }
  if(!force_other() && !one_way ) {
    set_locked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 0 }) );
    dest->tell_door( other_id, "Someone unlocks the $D.\n", 0 );
  }
  return 1;
}
int pick_lock( object thing ) {
  if (stringp(_lock_owner)) {
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }
  if(!::pick_lock(thing))
    return 0;
  if(!force_other() && !one_way ) {
    set_unlocked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 1 }) );
    dest->tell_door( other_id, "Someone locks the $D.\n", 0 );
  }
  return 1;
}
string *parse_command_id_list() {
  return (this_player() ? name + ({ this_player()->find_rel(my_id) }) : name);
}
string *parse_command_adjectiv_id_list() { return adjs; }
string *parse_command_plural_id_list() { return plu; }
object query_parse_id( mixed *arr ) {
   if (arr[P_THING] == 0) {
      return this_object();
   }
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return this_object();
   }
   arr[P_THING]--;
   if (arr[P_THING] != 0) {
      return this_object();
   }
   arr[P_THING] = -10101;
   return this_object();
}
mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   if (input[<1] == "all") {
      return 0;
   }
   return ::parse_match_object(input, viewer, context);
}
void dest_me() {
  destruct( this_object() );
}
void dwep() { destruct( this_object() ); }
void go_away() { call_out("dest_me", 0); }
int move() { return 1; }
int moving_open( object thing ) {
  if(!::do_open())
    return 0;
  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    dest->tell_door(other_id, (string)thing->a_short() + " opens the $D.\n", 0);
  }
  tell_object( thing, "You open the "+ shrt +".\n" );
  tell_room( my_room, (string)thing->the_short() +
             " opens the "+ shrt +".\n", thing );
  return 1;
}
int moving_close( object thing ) {
  if(!::do_close())
    return 0;
  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }
  if(!one_way && find_object(dest))
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door(other_id, (string)thing->the_short() +
                      " closes the $D which lock$s as $p close$s.\n", thing );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      if ( thing->short() )
        dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                         " closes the $D.\n", thing );
    }
  if(query_autolock()) {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +
                 " which locks as it closes.\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +" which locks as it closes.\n", thing );
  } else {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +".\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +".\n", thing );
  }
  return 1;
}
int moving_unlock(object thing) {
  if(!::do_unlock(all_inventory(thing)))
    return 0;
  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 0 }));
  tell_object(thing, "You unlock the "+ shrt +".\n");
  if (thing->short())
    tell_room( my_room, capitalize( (string)thing->the_short() ) +
               " unlocks the "+ shrt +".\n", thing );
  return 1;
}
int moving_lock(object thing) {
  if(!::do_lock(all_inventory(thing)))
    return 0;
  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 1 }));
  tell_object( thing, "You lock the "+
               (string)dest->call_door( other_id, "query_short" ) +".\n" );
  if (thing->short())
    dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                     " locks the $D.\n", thing );
  return 1;
}
void tell_door(string words, object thing) {
  tell_room(my_room, replace( words, ({
    "$D", shrt, "$p", PRONOUN[how_many], "$s", ({ "s", "" })[how_many] })),
            ({ thing }));
}
mixed *stats() {
  return property::stats() + close_lock::stats() +
         ({ ({ "lock owner", _lock_owner }),
            ({ "other id", other_id }),
            ({ "dest", dest }) });
}
string long_status() {
   string str;
   if (!query_stuck()) {
      if(query_how_many() > 0)
      {
        str = "They are";
      }
      else
      {
        str = "It is";
      }
      switch (query_closed_locked_status()) {
         case CLOSED_LOCKED :
            return str + " closed and locked.\n";
         case CLOSED :
            return str + " closed.\n";
         default :
            return str + " open.\n";
      }
   } else {
      return "";
   }
}

==================================================
FILE: room/basic/graffbase.c
==================================================

#include <language.h>
#define GRAFFITI "graffiti"
#define ETP environment(this_player())
#define TO this_object()
object writing_on;
object old;
string olds;
string query_drawingwith();
int do_check();
int done_check();
string query_drawingwith() { return "something"; }
int do_check() { return 0; }
int done_check() { return 0; }
void init() {
 this_player()->add_command( "scrawl", this_object(), "with charcoal on wall");
 this_player()->add_command( "scrawl", this_object(), "on wall with charcoal");
}
int do_scrawl( object *things ) {
    string language;
    if ( !ETP->query_property( GRAFFITI) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "+
          "this wall.\n");
        return 0;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "
           "a wall when you're not using a language that can be used for "
          "scrawling on a wall with.\n",({writing_on}));
        return 0;
    }
    if(( old = present("graffiti",ETP)) && !interactive(old))
    {
        olds = old->query_property("graffiti");
    }
    if ( writing_on ) {
        this_player()->add_failed_mess( this_object(), "The writing "+
          "spot seems to be busy at the moment.\n",
          ({writing_on}));
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(), ({"You start scrawling "+
      "on a wall with some charcoal.\n", "$N starts scrawling on a wall with "
      "some charcoal.\n"}) );
    writing_on = ETP;
    call_out( "begin_writing", 0, this_player() );
    return 1;
}
void begin_writing( object writer ) {
    if ( !writer ) {
        writing_on = 0;
        return;
    }
    writer->do_edit( 0, "end_writing" );
}
void end_writing( string words ) {
    string language;
    string extra;
    if ( !words || ( words == "" ) ) {
        write( "You don't scrawl anything on "+
         "the wall.\n");
        say( (string)this_player()->the_short() +" doesn't "+
          "scrawl anything after all.\n" );
        writing_on = 0;
        return;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        write( "You seem to have changed to using a non-written language.\n" );
        say( (string)this_player()->the_short() +" seems "+
          "linguistically-challenged.\n" );
        writing_on = 0;
        return;
    }
    if ( !writing_on ) {
        write( "You seem to have lost what you were scrawling on.\n" );
        say( (string)this_player()->the_short() +" looks around "+
          "in puzzlement.\n" );
        return;
    }
    if (  writing_on != ETP ) {
        write("The wall seems to have run away from you.\n" );
        say( (string)this_player()->the_short() +" looks like "+
          (string)this_player()->query_pronoun() +"'s lost something.\n" );
        writing_on = 0;
        return;
    }
    if(!stringp(olds)) olds = "";
    words = olds +"\n"+"%^MAGENTA%^Scrawled with rough charcoal, you "
             "read the words:%^RESET%^\n\n"+
    words;
    if(old) old->move("/room/rubbish");
    extra = TO->extra_stuff();
    if(!strlen(extra))extra = "Some disreputable character has scrawled "
        "graffiti over this wall.  You may be able to \"read\" it.\n";
    ETP->add_sign(
      extra,
      words,
      "graffiti",
      ({"graffiti","scrawl"}),
      language
    );
    old = present("graffiti",ETP);
    old->add_property("determinate","some ");
    old->add_property("there","on the wall");
    if(old) old->add_property("graffiti",words);
    write( "As you finish scrawling on the wall, the piece of charcoal "
           "breaks.\n" );
    say( (string)this_player()->the_short() +" finishes scrawling "+
      "on the wall.\n" );
    this_object()->done_check();
    writing_on = 0;
}

==================================================
FILE: room/basic/item.c
==================================================

#define DEBUG 1;
#include <parse_command.h>
#include <obj_parser.h>
#define POSITION_SIZE 2
#define POSITION_DESC 0
#define POSITION_MULT 1
private mixed *_lng;
private string *_shrt;
private string *_adjs;
private string *_plu;
private string *_name;
#ifdef DEBUG
private string _creator_room;
#endif
private mapping _verb;
private mapping _plural;
private mapping _other_things;
private mapping _pattern;
private int *_cur_desc;
private mapping _gather;
private mapping _position_stuff;
private mapping _count;
void init() {
    string name;
    mixed rest;
    foreach (name, rest in _other_things) {
            this_player()->add_command(name, this_object(), _pattern[name]);
    }
}
#ifdef DEBUG
string query_creator_room() { return _creator_room; }
void print_stuff() {
    printf("lng = %O\nshrt = %O\nadjs = %O\nplu = %O\nname = %O\n" +
      "verb = %O\nplural = %O\nother_things = %O\npattern = %O\n" +
      "cur_desc = %O\ngather = %O\n", _lng, _shrt, _adjs, _plu, _name, _verb,
      _plural, _other_things, _pattern, _cur_desc, _gather);
}
#endif
void create() {
#ifdef DEBUG
    _creator_room = file_name(previous_object());
#endif
    _adjs = ({ });
    _lng = ({ "" });
    _shrt = ({ "" });
    _gather = ([ ]);
    _plu = ({ });
    _name = ({ });
    _verb = ([ ]);
    _plural = ([ ]);
    _pattern = ([ ]);
    _cur_desc = ({ });
    _count = ([ ]);
    _other_things = ([ "smell" : 0, "taste" : 0, "read" : 0 ]);
}
int query_visible( object thing ) { return 1; }
string hide_invis_string() { return ""; }
string *query_short_array() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ _shrt[i] });
    }
    return ret;
}
string short() {
    return query_multiple_short(query_short_array());
}
string pretty_short() {
    string *ret;
    ret = query_short_array();
    if (sizeof(ret)) {
        return query_multiple_short(ret);
    } else {
        return "something";
    }
}
string a_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:" + add_a( $1 ) + "$" :)), "");
}
string the_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " +  $1 + "$" :)), "");
}
string one_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string poss_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string query_read_short() {
    return "$name$";
}
string query_plural() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ pluralize(_shrt[i]) });
    }
    return query_multiple_short(ret);
}
string pretty_plural() {
    int i;
    foreach (i in _cur_desc) {
        return pluralize(_shrt[i]);
    }
    return 0;
}
string long( string name, int dark ) {
    int i;
    string *ret;
    ret = ({ });
    foreach (i in _cur_desc) {
        if ( !_lng[ i ] ) {
            continue;
        }
        if (functionp(_lng[ i ])) {
            ret += ({ evaluate(_lng[ i ]) });
        } else {
            ret += ({ _lng[ i ] });
        }
    }
    if ( !sizeof( ret ) ) {
        return "You don't think that the "+name+" is here.\n";
    }
    return implode( evaluate(ret), "\n")+"\n";
}
int *query_cur_desc() { return _cur_desc; }
mapping query_verbs() { return _verb; }
mapping query_plurals() { return _plural; }
string *query_lng() { return _lng; }
string *query_shrt() { return _shrt; }
mixed *query_gather() {
    mixed *g = ({ });
    int i;
    foreach (i in _cur_desc) {
        if (_gather[i]) {
            g += ({ _gather[i] });
        }
    }
    return g;
}
int drop() { return 1; }
int get() { return 1; }
int query_item(string str) { return _verb[str]; }
private void setup_bits_for_item(int index, mixed bits) {
    int i;
    string str;
    mixed pat;
    if (!pointerp(bits)) {
        _lng[index] = bits;
        return ;
    }
    _lng[index] = "You see nothing special.\n";
    for (i = 0; i < sizeof(bits); i += 2) {
        if ((arrayp( bits[i + 1] ) && sizeof( bits[i + 1] ) == 3) ||
          (sizeof( bits[i + 1] ) == 2 && functionp( bits[i + 1][0] ))) {
            pat = bits[i + 1][<1];
            if (!arrayp(pat)) {
                pat = ({ pat });
            }
        }
        else {
            pat = ({ "<direct:object>" });
        }
        if (!pointerp(bits[i])) {
            bits[i] = ({ bits[i] });
        }
        foreach (str in bits[i]) {
            if (str == "long") {
                _lng[index] = bits[i+1];
            } else if (str == "gather") {
                _gather[index] = bits[i+1];
            } else if (str == "item_count")  {
               if (!_count[index])  _count[index] = bits[i + 1];
            } else if (str == "position" ||
              str == "position multiple") {
                if (!_position_stuff)
                    _position_stuff = ([ ]);
                if (!_position_stuff[index]) {
                    _position_stuff[index] = allocate(POSITION_SIZE);
                }
                if (str == "position") {
                    _position_stuff[index][POSITION_DESC] = bits[i + 1];
                } else {
                    _position_stuff[index][POSITION_MULT] = bits[i + 1];
                }
            } else if (!_other_things[str]) {
                _pattern[str] = pat;
                _other_things[str] = ([ index : bits[i+1] ]);
            } else {
                if (member_array(pat, _pattern[str]) == -1) {
                    _pattern[str] += pat - (string *)_pattern[str];
                }
                _other_things[str][index]   = bits[i+1];
            }
        }
    }
}
private void remove_bits_for_item(int index) {
    string str;
    string adj;
    mixed value;
    int frog;
    int bing;
    int i;
    int j;
    map_delete(_gather, index);
    foreach (frog, bing in _gather) {
        if (frog > index) {
            map_delete(_gather, frog);
            _gather[frog - 1] = bing;
        }
    }
    if (_position_stuff) {
        map_delete(_position_stuff, index);
        foreach (frog, bing in _position_stuff) {
            if (frog > index) {
                map_delete(_position_stuff, frog);
                _position_stuff[frog - 1] = bing;
            }
        }
    }
    foreach (str, value in _other_things) {
        if (value) {
            map_delete(value, index);
            if (!sizeof(value)) {
                map_delete(_other_things, str);
                map_delete(_pattern, str);
            } else {
                foreach (frog, bing in value) {
                    if (frog > index) {
                        map_delete(value, frog);
                        value[frog - 1] = bing;
                    }
                }
            }
        }
    }
    foreach (str, value in _verb) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                foreach (adj in value[i]) {
                    j = member_array(adj, _adjs);
                    if (j != -1) {
                        _adjs = _adjs[0..i - 1] + _adjs[i + 1..];
                    }
                }
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
                j = member_array(str, _name);
                if (j != -1) {
                    _name = _name[0..j - 1] + _name[j + 1..];
                }
            }
        }
        _verb[str] = value;
    }
    foreach (str, value in _plural) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
            }
        }
        _plural[str] = value;
    }
}
private void add_name_reference(int index, string name, int no_plural) {
    string *bits;
    string plural;
    string s;
    bits = explode(name, " ");
    s = bits[<1];
    if (member_array(s, _name) == -1) {
        _name += ({ s });
    }
    if (!_verb[s]) {
        _verb[s] = ({ bits[0..<2], index });
    } else {
        _verb[s] += ({ bits[0..<2], index });
    }
    if (!no_plural) {
        plural = pluralize(s);
        if (member_array(plural, _plu) == -1) {
            _plu += ({ plural });
        }
        if (!_plural[plural]) {
            _plural[plural] = ({ bits[0..<2], index });
        } else {
            _plural[plural] += ({ bits[0..<2], index });
        }
    }
    _adjs += bits[0..<2];
}
int setup_item(mixed nam, mixed long, int no_plural) {
    int index;
    string str;
    index = sizeof(_lng);
    if (pointerp(nam)) {
        if (sizeof(nam) > 0) {
            _shrt += ({ nam[0] });
            if (no_plural) {
                _plu += ({ "no plural" });
            } else {
                _plu += ({ pluralize(nam[0]) });
            }
        }
        foreach (str in nam) {
            add_name_reference(index, str, no_plural);
        }
    } else {
        _shrt += ({ nam });
        if (no_plural) {
            _plu += ({ "no plural" });
        } else {
            _plu += ({ pluralize(nam) });
        }
        add_name_reference(index, nam, no_plural);
    }
    _lng += ({ 0 });
    setup_bits_for_item(index, long);
    return index;
}
int modify_item_by_index(int index, mixed long) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    setup_bits_for_item(index, long);
    return 1;
}
int modify_item_by_name(string str, mixed long) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return modify_item_by_index(index, long);
}
int modify_item(mixed str, mixed long) {
    if (stringp(str)) {
        return modify_item_by_name(str, long);
    }
    if (intp(str)) {
        return modify_item_by_index(str, long);
    }
    return 0;
}
int remove_item_by_index(int index) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    _shrt = _shrt[0..index - 1] + _shrt[index + 1..];
    _adjs = _adjs[0..index - 1] + _adjs[index + 1..];
    _lng = _lng[0..index - 1] + _lng[index + 1..];
    _plu = _plu[0..index - 1] + _plu[index + 1..];
    remove_bits_for_item(index);
}
int remove_item_by_name(string str) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return remove_item_by_index(index);
}
int remove_item(mixed str) {
    if (stringp(str)) {
        return remove_item_by_name(str);
    }
    if (intp(str)) {
        return remove_item_by_index(str);
    }
    return 0;
}
string *parse_command_id_list() { return _name; }
string *parse_command_plural_id_list() { return _plu; }
string *parse_command_adjectiv_id_list() { return _adjs; }
object query_parse_id(mixed *arr)
{
    string *bits;
    mixed stuff;
    int i, j, match, all_match;
    bits = explode(arr[P_STR], " ");
    bits -= ({ "a", "an", "the" });
    if (arr[P_THING] == 0)
    {
        stuff = _plural[bits[<1]];
        if (!stuff) {
            stuff = _verb[bits[<1]];
            if (!stuff) {
                return 0;
            }
        }
        _cur_desc = ({ });
        all_match = 0;
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (match) {
                all_match = 1;
                if (member_array(stuff[j+1], _cur_desc) == -1) {
                    _cur_desc += ({ stuff[j+1] });
                }
            }
        }
        if (all_match) {
            return this_object();
        } else {
            return 0;
        }
    }
    if (arr[P_THING] < 0) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (++arr[P_THING] != 0) {
                continue;
            }
            if (match) {
                _cur_desc = ({ stuff[j+1] });
                arr[P_THING] = -10321;
                return this_object();
            }
        }
        return 0;
    }
    stuff = _plural[bits[<1]];
    if (!stuff) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
    }
    _cur_desc = ({ });
    for (j = 0; j < sizeof(stuff); j += 2) {
        match = 1;
        for (i=0;i<sizeof(bits)-1;i++) {
            if ( member_array( bits[ i ], stuff[ j ] ) == -1 ) {
                match = 0;
                break;
            }
        }
        if (match) {
            if (member_array(stuff[j+1], _cur_desc) == -1) {
                _cur_desc += ({ stuff[j+1] });
            }
            arr[P_THING]--;
            if (arr[P_THING] <= 0) {
                arr[P_THING] = -10786;
                return this_object();
            }
        }
    }
    return 0;
}
mixed* parse_match_object(string* input,
                          object player,
                          class obj_match_context context) {
   int *stuff;
   mixed *plural;
   mixed *sing;
   string *its, *thems;
   string item;
   int i;
   int j;
   int match;
   int ret;
   if (input[<1] == "here" && sizeof(input) > 1) {
      input = input[0..<2];
   }
   if ( this_object() == context->it &&
        input[<1] == "it" ) {
      sing = ({ });
      its = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in its ) {
          if ( arrayp( _verb[ item ] ) ) {
             sing += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      plural = ({ });
   } else if( input[<1] == "them" &&
              context->plural &&
              member_array( this_object(), context->plural ) != -1) {
      plural = ({ });
      thems = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in thems ) {
          if ( arrayp( _verb[ item ] ) ) {
             plural += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      sing = ({ });
   } else {
      plural = _plural[input[<1]];
      sing = _verb[input[<1]];
   }
   if (!sizeof(plural) && !sizeof(sing)) {
      return 0;
   }
   stuff = ({ });
   for (i = 0; i < sizeof(sing); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], sing[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(sing[i+1], stuff) == -1) {
            stuff += ({ sing[i+1] });
            ret |= OBJ_PARSER_MATCH_SINGULAR;
         }
      }
   }
   for (i = 0; i < sizeof(plural); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], plural[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(plural[i+1], stuff) == -1) {
            stuff += ({ plural[i+1] });
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }
   if (sizeof(stuff)) {
       if (context->ordinal) {
          if (context->ordinal > sizeof(stuff)) {
             context->ordinal -= sizeof(stuff);
             return 0;
          }
          context->ignore_rest = 1;
          context->ordinal--;
          _cur_desc = stuff[context->ordinal..context->ordinal];
       } else if (context->number_included) {
          _cur_desc = stuff[0..context->number_included];
          context->number_included -= sizeof(stuff);
          if (context->number_included <= 0) {
             context->ignore_rest = 1;
          }
       } else if (ret & OBJ_PARSER_MATCH_PLURAL) {
          _cur_desc = stuff;
       } else {
          _cur_desc = stuff[0..0];
       }
       return ({ ret, ({ this_object() }) });
   } else {
      return 0;
   }
}
void dest_me() {
    destruct(this_object());
    return ;
}
void dwep() {
    destruct(this_object());
    return ;
}
int move() { return 1; }
int command_control(string command, object *indir, string id_arg,
  string ii_arg, string *args, string pattern) {
    int desc, size, num;
    mixed temp;
    if (!_other_things[command]) {
        return 0;
    }
    size = sizeof(_cur_desc);
    foreach (desc in _cur_desc) {
        temp = _other_things[command][desc];
        if (arrayp(temp)) {
            if (sizeof(temp) == 3 || (sizeof(temp) == 2 && !functionp(temp[0]))) {
                num += call_other(temp[0], temp[1], command, indir, id_arg,
                  ii_arg, args, pattern);
            }
            else {
                if (sizeof(temp) == 2 && functionp(temp[0])) {
                        num += evaluate(temp[0], command, indir, id_arg, ii_arg,
                            args, pattern);
                }
            }
        }
        else {
            if (functionp(temp)) {
                temp = evaluate(temp, command, indir, id_arg, ii_arg, args,
                    pattern);
            }
            if (stringp(temp)) {
                write(temp);
                num++;
                add_succeeded_mess(({ "", "$N $V $D.\n" }));
            }
            else {
                if ( intp( temp ) ) {
                    num += temp;
                }
            }
        }
    }
    return num;
}
mapping query_other_things() { return _other_things; }
mapping query_pattern() { return _pattern; }
string query_position_string(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_DESC];
        }
    }
    return 0;
}
int query_position_multiple(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_MULT];
        }
    }
    return 0;
}
mapping query_position_stuff() { return _position_stuff; }
int query_count()  {
   int i;
   int ret = 0;
   foreach (i in _cur_desc)  {
      ret += evaluate(_count[i]);
   }
   return ret;
}

==================================================
FILE: room/basic/linker.c
==================================================

#include <room.h>
nosave int av_flag, ad_flag, rm_flag;
string d_prep, s_prep, r_name, *rooms;
object room;
void setup_shadow(object thing, string *words, string word1,
  string word2, string word3) {
  shadow(thing, 1);
  room = thing;
  rooms = words;
  if(!word1) {
    d_prep = "into";
  } else {
    d_prep = word1;
  }
  if(!word2) {
    s_prep = "in";
  } else {
    s_prep = word2;
  }
  r_name = word3;
}
void destruct_shadow(object thing) {
  if(thing == this_object()) {
    destruct(this_object());
  } else {
    thing->destruct_shadow(thing);
  }
}
string *query_rooms() {
  return rooms;
}
string query_dynamic_preposition() {
  return d_prep;
}
string query_static_preposition() {
  return s_prep;
}
string query_room_name() {
  return r_name;
}
string area_name() {
  string *bits;
  if(r_name) {
    return r_name;
  }
  bits = explode((string)room->query_short(), " of ");
  if(sizeof(bits) > 1) {
    return bits[ sizeof( bits ) - 1];
  }
  return "the area";
}
string compose_start() {
  if(s_prep == "") {
    return capitalize((string)room->the_short());
  }
  return capitalize(s_prep)+" "+(string)room->the_short();
}
void event_person_say( object person, string start, string rest,
      string language, string accent ) {
   int i;
   if ( start[ 0 .. 3 ] == "the " )
      start = explode( (string)person->a_short(), " " )[ 0 ] +
            start[ 3 .. strlen( start ) - 1 ];
   for ( i = 0; i < sizeof( rooms ); i++ )
      if ( find_object( rooms[ i ] ) )
         all_inventory( find_object( rooms[ i ] ) )->event_person_say( person,
                compose_start() +", "+ start, rest, language, accent );
    room->event_person_say( person, start, rest, language, accent );
}
private string conjugate_verbs(string mess) {
  string *words, verb, part;
  int i;
  if(strsrch(mess, "$s") == -1)
    return mess;
  words = explode( mess, " " );
  for ( i = sizeof( words ) - 1; i > -1; i-- ) {
    if ( ( sscanf( words[ i ], "%s$s%s", verb, part ) == 2 ) &&
         ( ( part[ 0 ] < 97 ) || ( part[ 0 ] > 122 ) ) ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
    if ( sscanf( words[ i ], "%%%s%%%s", verb, part ) == 3 ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
  }
  return implode( words, " " );
}
void event_exit(object person, string message, object to) {
  int ad_flag, rm_flag, i;
  string arrive, direc, *exits, link_mess, *link_array;
  room->event_exit(person, message, to);
  if(!message) {
    return;
  }
  arrive = "";
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(to == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(arrayp(room->query_dest_other())) {
    if(member_array(direc, room->query_dest_other()) != -1) {
      i = member_array(direc, room->query_dest_other());
      link_array = room->query_dest_other()[i + 1][11];
    }
  }
  if(arrayp(link_array)) {
    link_mess = link_array[0];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));
    link_mess = conjugate_verbs(link_mess);
  }
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      if(to != find_object(rooms[i])) {
        tell_room(find_object(rooms[i]), link_mess);
      }
    }
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to == find_object(rooms[i])) {
      arrive = (string)to->query_dynamic_preposition()+" "+
        (string)to->the_short();
      rm_flag = 1;
    }
  }
  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ "+direc;
    message += " "+arrive;
    if(rm_flag) {
      message += ".\n";
    } else {
      message += "and $V$0=leaves,leave$V$ "+ area_name() +".\n";
    }
  } else {
    message = (string)person->a_short() +" $V$0=teleports,teleport$V$";
    if(rm_flag) {
      message += " "+ arrive +".\n";
    } else {
      message += " out of "+area_name()+".\n";
    }
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to != find_object(rooms[i])) {
      tell_room(find_object(rooms[i]), message);
    }
  }
}
void event_enter( object person, string message, object from ) {
  int ad_flag, rm_flag, i;
  string direc, *exits, link_mess, *link_array;
  room->event_enter(person, message, from);
  if(!message || !from) {
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(from == find_object(rooms[i])) {
      rm_flag = 1;
    }
  }
  if(rm_flag) {
    return;
  }
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(from == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(member_array(direc, room->query_dest_other()) != -1) {
    i = member_array(direc, room->query_dest_other());
    link_array = room->query_dest_other()[i + 1][11];
  }
  if(arrayp(link_array)) {
    link_mess = link_array[1];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));
    link_mess = conjugate_verbs(link_mess);
  }
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      tell_room(find_object(rooms[i]), link_mess);
    }
    return;
  }
  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ into "+
      area_name()+" from the "+direc+".\n";
  } else {
    message = (string)person->a_short()+
      " $V$0=teleports,teleport$V$ into "+area_name() +".\n";
  }
  for(i = 0; i < sizeof(rooms); i++) {
    tell_room(find_object(rooms[i] ), message);
  }
}
int query_linked() { return 1; }

==================================================
FILE: room/basic/multichatter.c
==================================================

#include <room.h>
nosave int off;
nosave object room;
nosave mixed *chats;
void set_chat_min_max( int min,int  max ) {
  if (chats) {
    chats[0]=min;
    chats[1]=max;
  }
}
void setup_chatter( object my_room,  mixed *chat_args ) {
   off = 1;
   room = my_room;
   if (sizeof(chats)) chats += chat_args + ({0,0});
   else chats = chat_args + ({0,0});
}
void dest_me() {
  destruct( this_object() );
}
int query_multichatter() { return 1; }
int check_interactive( object thing ) { return interactive( thing ); }
void make_chat() {
  int saying;
  string stuff;
  int set,nextt,t;
  if (!sizeof( filter_array( all_inventory( room ), "check_interactive",
        this_object() ) ) ) {
    off = 1;
    return;
  }
  nextt=2147483647;
  t=time();
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) {
      if (t>=chats[set+4]) {
        saying = random( sizeof( chats[ set+2 ] ) );
        if ( saying == chats[ set+3 ] )
        saying = ( saying + 1 ) % sizeof( chats[ set+2 ] );
        chats[ set+3 ] = saying;
        stuff = chats[ set+2 ][ saying ];
        if ( stuff[ 0 ] == '#' )
          call_other( room, stuff[ 1 .. 99 ] );
        else
          tell_room( room, chats[ set+2 ][ saying ] +"\n" );
        chats[ set+4 ]=time()+chats[ set ]
            +random(chats[ set+1 ] - chats[ set ] + 1)-4;
      }
      if (chats[ set+4 ]<nextt) nextt=chats[ set+4 ];
    }
  }
  if (nextt!=2147483647) {
    if ((nextt+=4-t)<5) nextt=5;
    ROOM_HANDLER->add_chatter( this_object(), nextt );
  }
}
void check_chat() {
  int set,t,nextt;
  if ( !off || !pointerp( chats ) )
      return;
  off = 0;
  t=time();
  nextt=2147483647;
  for (set=0; set<sizeof(chats); set+=5) {
    if (t>=chats[set+4]+chats[set]) chats[set+4]=t+random(chats[set+1]);
    if (chats[set+4]<nextt) nextt=chats[set+4];
  }
  if ((nextt+=4-t)<5) nextt=5;
  ROOM_HANDLER->add_chatter( this_object(), nextt );
}
void add_room_chats( string *new_chats ) {
   if (sizeof(new_chats)) {
     if (sizeof(chats[2])) chats[2] = chats[2] + new_chats;
     else chats[2]= new_chats;
   }
}
void remove_room_chats( string *dead_chats ) {
  int set;
  mixed *new_chats;
  new_chats=({ });
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) chats[set+2] = chats[set+2] - dead_chats;
    if (set==0 || sizeof(chats[set+2]))
       new_chats=new_chats+chats[(set)..(set+4)];
  }
  chats=new_chats;
}
mixed *query_room_chats() { return chats; }
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (!room) dest_me();
}
