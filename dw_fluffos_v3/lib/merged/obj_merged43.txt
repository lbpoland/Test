# Total Tokens: 17748
# Total Files Merged: 13
# Total Characters: 59193

ommercial/blackjack.c
==================================================

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";
#include <money.h>
#define BLACKJACK_BET 0
#define BLACKJACK_PLAYING 1
#define BLACKJACK_BUST 2
#define BLACKJACK_STAND 3
class player_data {
   class playing_card* hand;
   int starting_bet;
   int state;
}
#define BOARD_TAG "blackjack"
private int _cost;
private int _finished;
private int _max_bet;
private int _min_bet;
private int _timeout_call;
private int _timeout_length;
private int _num_decks;
private int _soft_seventeen;
private int _double_on_doubles;
private class playing_card* _dealer_hand;
private class playing_card* _deck;
private class playing_card* _discard;
int query_hand_value(class playing_card* cards);
void create() {
   multiplayer_base::create();
   commercial::create();
}
void setup() {
   set_name( "table" );
   set_short( "blackjack table" );
   add_adjective( ({ "blackjack" } ));
   add_alias("blackjack");
   set_long( "The green felt of the table looks nice and soft, there is "
             "a single deck of cards sitting in the middle of the table.  "
             "The table looks like it will seat 4 people.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   _timeout_length = 5 * 60;
   _cost = 400;
   _num_decks = 1;
   add_player_id_type("green", 0);
   add_player_id_type("red", 0);
   add_player_id_type("blue", 0);
   add_player_id_type("maroon", 0);
   set_minimum_needed(1);
   add_help_file("blackjack");
   set_commercial_size(15);
   set_commercial_type("gambling");
   set_shop_use_types(({ "blackjack" }));
}
string query_card_status() {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   class playing_card card;
   string* womble;
   string place;
   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = environment()->query_property("place");
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing) ||
          is_game_started()) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->starting_bet) {
               ret += "  " +
                      MONEY_HAND->money_value_string(data->starting_bet, place);
               if (sizeof(data->hand)) {
                  foreach (card in data->hand) {
                     ret += "  " + query_card_string(card);
                  }
               }
               if (data->state == BLACKJACK_STAND) {
                  ret += " (stand)";
               } else if (data->state == BLACKJACK_BUST) {
                  ret += " (bust)";
               }
               ret += "\n";
            } else {
               ret += "  No bet yet.\n";
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }
   if (sizeof(not_playing)) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                               " are not playing.\n";
   }
   ret += "\n";
   if (sizeof(_dealer_hand)) {
      ret += "Dealer's cards ";
      if (!_finished) {
         ret += "XXXX";
      }
      foreach (card in _dealer_hand[(_finished?0:1)..]) {
         ret += "  " + query_card_string(card);
      }
      if (query_hand_value(_dealer_hand) > 21) {
         ret += " (bust)";
      }
      ret += "\n";
   }
   return ret;
}
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status();
}
class playing_card query_next_card() {
   class playing_card card;
   if (!sizeof(_deck)) {
      if (!sizeof(_discard)) {
         _deck = make_deck(_num_decks, 0);
         _deck = shuffle_deck(_deck);
      } else {
         _deck = make_deck(_num_decks, 0);
         _deck = shuffle_deck(_deck);
      }
      tell_all_players("The dealer shuffles the deck before the next card "
                       "is dealt.\n");
      _discard = ({});
   }
   card = _deck[0];
   _deck = _deck[1..];
   return card;
}
void deal_cards(string id) {
   class player_data data;
   string hands;
   if (!sizeof(_dealer_hand)) {
      _dealer_hand = ({ query_next_card(), query_next_card() });
   }
   hands = "";
      data = query_player_data(id);
      data->hand = ({ query_next_card(), query_next_card() });
      hands += query_player_cap_name(id) + " hand is: "+
                      query_card_string(data->hand[0]) + "  " +
                      query_card_string(data->hand[1]) +
                      "  (total " +
                      query_hand_value(data->hand) + ")\n";
   hands += "Dealer's cards: XXXX " +
             query_card_string(_dealer_hand[0]) + "\n"
             "You need to stay or hit yourself for more cards.\n";
   tell_all_players(hands);
}
int start_game() {
   class player_data data;
   string id;
   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->starting_bet = 0;
      data->hand = ({ });
      data->state = BLACKJACK_BET;
      set_player_data(id, data);
   }
   _dealer_hand = ({ });
   _finished = 0;
   tell_all_players("Place your starting bets.\n");
   return 1;
}
int query_hand_value(class playing_card* cards) {
   class playing_card bing;
   int value;
   int no_aces;
   foreach (bing in cards) {
      if (bing->number == 1) {
         no_aces++;
      } else if (bing->number >= 10) {
         value +=  10;
      } else {
         value += bing->number;
      }
   }
   if (no_aces > 0) {
      if (no_aces > 1) {
         value += no_aces - 1;
      }
      if (value <= 10) {
         value += 11;
      } else {
         value += 1;
      }
   }
   return value;
}
int is_soft_result(class playing_card* cards) {
   class playing_card bing;
   int value;
   int no_aces;
   foreach (bing in cards) {
      if (bing->number == 1) {
         no_aces++;
      } else if (bing->number >= 10) {
         value +=  10;
      } else {
         value += bing->number;
      }
   }
   if (no_aces > 0) {
      if (no_aces > 1) {
         value += no_aces - 1;
      }
      if (value <= 10) {
         return 1;
      }
   }
   return 0;
}
void finish_bet(string id) {
   class player_data data;
   data = query_player_data(id);
   call_out("deal_cards", 2, id);
}
void complete_round() {
   int value;
   string stuff;
   object ob;
   int new_value;
   class playing_card card;
   class player_data data;
   string id;
   string place;
   int paid;
   string* winners;
   string* losers;
   remove_call_out(_timeout_call);
   _timeout_call = 0;
   place = environment()->query_property("place");
   value = query_hand_value(_dealer_hand);
   while (value < 17 ||
          (value == 17 && _soft_seventeen && is_soft_result(_dealer_hand))) {
      _dealer_hand += ({ query_next_card() });
      value = query_hand_value(_dealer_hand);
   }
   stuff = "";
   foreach (card in _dealer_hand) {
      stuff += "  " + query_card_string(card);
   }
   if (value > 21) {
      stuff += "  Total " + value + " (bust)\n";
      value = 0;
   } else {
      stuff += "  Total " + value + "\n";
   }
   winners = ({ });
   losers = ({ });
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      if (data->state == BLACKJACK_STAND) {
         new_value = query_hand_value(data->hand);
         if (new_value == 21 && sizeof(data->hand) == 2) {
            winners += ({ id });
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array((data->starting_bet * 5) / 2,
                                           place), place);
            }
            adjust_float(-(data->starting_bet * 3) / 2);
            if (ob) {
               stuff += ob->query_cap_name();
            } else {
               stuff += id;
            }
            stuff += " gets a payout of " +
                     MONEY_HAND->money_value_string((data->starting_bet * 3) / 2, place) +
                     " (plus their original money back).\n";
            paid = 1;
         } else if (new_value > value) {
            winners += ({ id });
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(data->starting_bet * 2,
                                           place), place);
            }
            adjust_float(-data->starting_bet);
            if (ob) {
               stuff += ob->the_short();
            } else {
               stuff += id;
            }
            stuff += " gets a payout of " +
                     MONEY_HAND->money_value_string(data->starting_bet, place) +
                     " (plus their original money back).\n";
            paid = 1;
         } else {
            losers += ({ id });
         }
      }
   }
   if (!paid) {
      stuff += "No one gets paid anything.\n";
   }
   tell_all_players("The dealer reveals their cards as " +
                    stuff);
   if (sizeof(winners)) {
      tell_room(environment(),
                query_multiple_short(winners) + " win" +
                (sizeof(winners) > 1?"":"s") + " the blackjack hand.\n");
   } else {
      tell_room(environment(),  "No one wins the blackjack hand.\n");
   }
   finish_game(0);
   _finished = 1;
}
void force_finish() {
   if (is_game_started()) {
      complete_round();
   }
}
int do_bet(string str) {
   string place;
   string id;
   int amount;
   class player_data data;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   place = environment()->query_property("place");
   amount = MONEY_HAND->value_from_string(str, place);
   if (!amount) {
      add_failed_mess("Invalid bet amount.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have that much to bid.\n");
      return 0;
   }
   if (amount < _min_bet) {
      add_failed_mess("The minimum bet for $D is " +
         MONEY_HAND->money_value_string(_min_bet, place) + ".\n");
      return 0;
   }
   if (amount > _max_bet) {
      add_failed_mess("The maximum bet for $D is " +
         MONEY_HAND->money_value_string(_max_bet, place) + ".\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->starting_bet) {
      add_failed_mess("You have already bet on $D.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);
   adjust_float(amount);
   data->starting_bet = amount;
   data->state = BLACKJACK_PLAYING;
   finish_bet(id);
   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
}
int do_hit() {
   int value;
   int not_done;
   string id;
   class player_data data;
   class playing_card card;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != BLACKJACK_PLAYING) {
      add_failed_mess("You are out of the game and cannot get any more "
                      "cards.\n");
      return 0;
   }
   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot hit before you have been dealt cards.\n");
      return 0;
   }
   card = query_next_card();
   data->hand += ({ card });
   value = query_hand_value(data->hand);
   if (value > 21) {
      add_succeeded_mess("$N $V and get$s " + query_card_string(card) +
                         " giving a total of " + value +
                         " and going bust on $D.\n");
      data->state = BLACKJACK_BUST;
      foreach (id in query_currently_playing_ids()) {
         data = query_player_data(id);
         if (data->state != BLACKJACK_BUST &&
             data->state != BLACKJACK_STAND) {
            not_done = 1;
         }
      }
      if (!not_done) {
          remove_call_out(_timeout_call);
          _timeout_call = call_out("complete_round", 2);
      }
   } else {
      add_succeeded_mess("$N $V and gets " + query_card_string(card) +
                         " giving a total of " + value + " on $D.\n");
   }
   return 1;
}
int do_stand() {
   int value;
   string id;
   class player_data data;
   int not_done;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != BLACKJACK_PLAYING) {
      add_failed_mess("You are not playing and set yourself to stand.\n");
      return 0;
   }
   value = query_hand_value(data->hand);
   data->state = BLACKJACK_STAND;
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      if (data->state != BLACKJACK_BUST &&
          data->state != BLACKJACK_STAND) {
         not_done = 1;
      }
   }
   if (!not_done) {
       remove_call_out(_timeout_call);
       _timeout_call = call_out("complete_round", 2);
   }
   add_succeeded_mess("$N $V with a total of " + value +
                      " on $D.\n");
   return 1;
}
int do_start() {
   if (!is_open_for("blackjack", this_player()->query_name())) {
      add_failed_mess("The blackjack table is not open.\n");
      return 0;
   }
   if (_timeout_call) {
      add_failed_mess("Someone is still playing, you cannot start a "
                      "new game yet.\n");
      return 0;
   }
   if (query_float() < (_max_bet * 3 * 4) / 2) {
      if (is_allowed(this_player()->query_name())) {
         add_failed_mess("The float is too low for the table to open.\n");
         return 0;
      }
      add_failed_mess("The blackjack table is not open.\n");
      return 0;
   }
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }
   if (!start_game()) {
      add_failed_mess("You need at least three people to play modern art.\n");
      return 0;
   }
   add_succeeded_mess("$N $V a game on $D.\n");
   remove_call_out(_timeout_call);
   _timeout_call = call_out("force_finish", _timeout_length);
   tell_all_players("Timeout for this game is " + (_timeout_length / 60) +
                    " minutes.\n");
   return 1;
}
int do_finish() {
   string person;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }
   force_finish();
   return 1;
}
string query_main_status(int hint) {
   string place;
   string ret;
   place = query_money_place();
   ret = "$I$0=Blackjack table:\n"
          "$I$6=   Table is " +
             (query_float() >= (_max_bet * 3 * 4) / 2?"open.\n":
              "closed! (Float needed: " +
              MONEY_HAND->money_value_string((_max_bet * 3 * 4) / 2, place) +
              "; current: " +
              MONEY_HAND->money_value_string(query_float(), place) + ")\n") +
          "$I$6=   Timeout length: " + (_timeout_length / 60) + " minutes.\n";
   if (hint) {
      ret += "$I$6=      set timeout <number> on <table>\n";
   }
   ret += "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) + "\n";
   if (hint) {
      ret += "$I$6=      set maximum bet <amount> on <table>\n";
   }
   ret += "$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) + "\n";
   if (hint) {
      ret += "$I$6=      set minimum bet <amount> on <table>\n";
   }
   ret += "$I$6=   Num Decks  : " + _num_decks + "\n";
   if (hint) {
      ret += "$I$6=      set num decks <amount> on <table>\n";
   }
   ret += "$I$6=   Soft 17    : " + (_soft_seventeen?"on":"off") + "\n";
   if (hint) {
      ret += "$I$6=      set hit on soft seventeen {on|off} on <table>\n";
   }
   ret += "$I$6=   Float needed: " +
              MONEY_HAND->money_value_string((_max_bet * 3 * 4) / 2, place) +
          " (max players * max bet * 3 / 2)\n$I$6=   Revenue: " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n\n";
   return ret;
}
int do_set_bet(string str, int max_bet) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_timeout(int length) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (length <= 0) {
      add_failed_mess("The timeout must be greator than 0.\n");
      return 0;
   }
   _timeout_length = length * 60;
   add_succeeded_mess("$N set$s the timeout on $D to " + length + " minutes.\n");
   return 1;
}
int do_set_soft_seventeen(int value) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   _soft_seventeen = value;
   add_succeeded_mess("$N set$s the soft seventeen dealer hit on $D " +
                      (value?"on":"off") + ".\n");
   return 1;
}
int do_set_double_on_doubles(int value) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   _double_on_doubles = value;
   add_succeeded_mess("$N set$s the double on doubles on $D " +
                      (value?"on":"off") + ".\n");
   return 1;
}
int do_set_num_decks(int num_decks) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (num_decks <= 0) {
      add_failed_mess("The timeout must be greator than 0.\n");
      return 0;
   }
   if (num_decks >= 10) {
      add_failed_mess("The number of decks must be less than 10.\n");
      return 0;
   }
   _num_decks = num_decks;
   add_succeeded_mess("$N set$s the number of decks on $D to " + num_decks +
                      ".\n");
   return 1;
}
void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("bet", "<string'amount'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("hit", "on <direct:object>",
               (: do_hit() :));
   add_command("stay", "on <direct:object>",
               (: do_stand() :));
   add_command("start", "[new] game on <direct:object>",
               (: do_start() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
      add_command("set", "timeout <number'minutes'> on <direct:object>",
                  (: do_set_timeout($4[0]) :));
      add_command("set", "num decks <number'num decks'> on <direct:object>",
                  (: do_set_num_decks($4[0]) :));
      add_command("set", "hit on soft seventeen {on|off} on <direct:object>",
                  (: do_set_soft_seventeen($4[0] == "on") :));
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "dealer hand", _dealer_hand);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "finished", _finished);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "min bet ", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "timeout", _timeout_length);
   add_auto_load_value(map, BOARD_TAG, "num decks", _num_decks);
   add_auto_load_value(map, BOARD_TAG, "soft seventeen", _soft_seventeen);
   add_auto_load_value(map, BOARD_TAG, "double on doublet", _double_on_doubles);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   _dealer_hand = query_auto_load_value(map, BOARD_TAG, "dealer hand");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _finished = query_auto_load_value(map, BOARD_TAG, "finished");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _timeout_length = query_auto_load_value(map, BOARD_TAG, "timeout");
   _num_decks = query_auto_load_value(map, BOARD_TAG, "num decks");
   _soft_seventeen = query_auto_load_value(map, BOARD_TAG, "soft seventeen");
   _double_on_doubles = query_auto_load_value(map, BOARD_TAG, "double on doublet");
   if (!_num_decks) {
      _num_decks = 1;
   }
   if (is_game_started()) {
      remove_call_out(_timeout_call);
      _timeout_call = call_out("force_finish", _timeout_length);
   }
}

==================================================
FILE: furnitures/commercial/filing_cabinet.c
==================================================

inherit "/std/room/furniture/document_handler";
void setup() {
   set_short("filing cabinet");
   set_name("cabinet");
   add_alias("filing");
   set_long("A big grey wooden box with draws that slide in and out.  It "
            "looks like it could hold bunches of documents, nicely order "
            "and available for quick retrieval.");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   set_commercial_size(5);
   set_commercial_type("utility");
}

==================================================
FILE: furnitures/commercial/medium_shop.c
==================================================

inherit "/std/room/furniture/shop_base";
void setup() {
   set_name( "counter" );
   set_short( "medium shop counter" );
   add_adjective( ({ "medium", "shop" } ));
   set_long( "The smooth polished surface of the medium counter shines and "
             "glows at you.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(1200000);
   set_maximum_inventory_size(100);
   set_commercial_size(60);
}

==================================================
FILE: furnitures/commercial/money_changer.c
==================================================

inherit "/std/room/furniture/commercial";
#include <money.h>
#include <move_failures.h>
private mapping _money;
private int _cut;
private int _cost;
#define BOARD_TAG "money changer"
void setup() {
   set_name( "counter" );
   set_short( "money changer counter" );
   add_adjective( ({ "money", "changer" } ));
   add_alias("changer");
   set_long( "A box with a bunch of holes in it, it looks like it will "
             "change coins into other types of coins.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   add_help_file("money_changer");
   set_commercial_size(5);
   _cut = 10;
   _cost = 400;
   _money = ([ ]);
}
int change( string words, string type ) {
   int val_index;
   int value;
   int value_type;
   int value_unit;
   int value_change;
   int value_num;
   int i;
   string place;
   mixed money;
   object changed;
   object *monies;
   mixed *change;
   mixed *values;
   mixed *money_bits;
   place = query_money_place();
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   values = (mixed *)MONEY_HAND->query_values_in( place );
   MONEY_OBJECT->set_money_array( values );
   val_index = (int)MONEY_OBJECT->find_best_fit( type );
   if ( val_index == -1 ) {
      return notify_fail( "The coin type \""+ type +
            "\" is not legal tender here.\n" );
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only change money here.\n" );
         default :
            return notify_fail( "You can only change legal tender.\n" );
      }
   }
   if (place != "default")  {
      monies = MONEY_HAND->filter_legal_tender(money, "default");
      if (monies[0])  monies[0]->move(this_player());
      if (!monies[1])  {
         return notify_fail( "You can only change legal tender.\n" );
      }
      money = monies[1];
   }
   money_bits = money->query_money_array();
   value = (int)money->query_value_in( place );
   i = member_array(values[val_index], money->query_money_array());
   if (i != -1) {
      value_type = money->query_money_array()[i + 1] * values[val_index + 1];
   }
   value_unit = (values[val_index + 1] * (100 + _cut)) / 100;
   value_change = (value - value_type) % value_unit;
   value_num = (value - value_type) / value_unit;
   value = value_num * values[val_index + 1] + value_type;
   if ( value < values[ val_index + 1 ] ) {
      money->move( this_player() );
      return notify_fail( MONEY_HAND->money_string(money->query_money_array(), place) +
                         " is not even worth one "+ values[ val_index ] +
                       ".\n" );
   }
   if (_money[values[val_index]] < value_num) {
      money->move( this_player() );
      add_failed_mess("The money changer does not have enough " +
                      MONEY_HAND->query_main_plural_for(values[val_index]) +
                      " to pay you.\n");
      return 0;
   }
   _money[values[val_index]] -= value_num;
   for (i = 0; i < sizeof(money_bits); i += 2) {
      _money[money_bits[i]] += money_bits[i + 1];
   }
   changed = clone_object( MONEY_OBJECT );
   changed->set_money_array( ({ values[ val_index ],
                                value / values[ val_index + 1 ] }));
   change = (mixed *)MONEY_HAND->create_money_array( value_change, place );
   for (i = 0; i < sizeof(changed); i += 2) {
      _money[change[i]] -= change[i + 1];
   }
   this_player()->add_succeeded_mess(this_object(),
    ({ "You changed "+query_multiple_short(money->half_short( 1 ) ) +
         " into "+
         query_multiple_short( changed->half_short( 1 ) ) +".\n",
       "$N $V some money into "+type+".\n" }), ({ }) );
   money->move( "/room/rubbish" );
   if ( sizeof( change ) ) {
      changed->adjust_money( change );
      write( "You were returned "+ (string)MONEY_HAND->money_string( change )
            +" in change.\n" );
   }
   if ( (int)changed->move( this_player() ) != MOVE_OK ) {
      write( "Unfortunately, you're too heavily burdened to accept all that "+
            "money, so it's put on the table for you.\n" );
      changed->move( this_object() );
   }
   return 1;
}
string query_main_status(int hint) {
   string type;
   string place;
   int num;
   string str;
   place = query_money_place();
   str = "$I$0=Money Changer:\n";
   str += "$I$6=   Percentage cut " + _cut + "%\n";
   foreach (type, num in _money) {
      str += "$I$6=   " + num + " " + type + "\n";
   }
   return str;
}
int do_set_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   _cost = value;
   add_succeeded_mess("$N set$s the cost of each use of $D to " +
          MONEY_HAND->money_value_string(value, place) + ".\n");
   return 1;
}
int do_set_cut(int number) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (number < 0) {
      add_failed_mess("You need to set the cut to a number greator than 0.\n");
      return 0;
   }
   if (number > 500) {
      add_failed_mess("You need to set the cut to a number less than 500.\n");
      return 0;
   }
   _cut = number;
   add_succeeded_mess("$N set$s the cut for $D to " + _cut + "%.\n");
   return 1;
}
int do_deposit(int num, string str) {
   mixed* values;
   int i;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   values = this_player()->query_money_array();
   for (i = 0; i < sizeof(values); i += 2) {
      if (lower_case(values[i]) == lower_case(str)) {
         break;
      }
   }
   if (i >= sizeof(values)) {
      add_failed_mess("You do not have any " + str + " to deposit.\n");
      return 0;
   }
   if (values[i + 1] < num) {
      add_failed_mess("You do not have " + num + " of " + values[i] +
                      ", you only have " + values[i+1] + ".\n");
      return 0;
   }
   _money[values[i]] += num;
   this_player()->adjust_money(-num, values[i]);
   add_succeeded_mess("$N deposit$s " + num + " of " + str + " in $D.\n");
   return 1;
}
int do_withdraw(int num, string str) {
   string tmp;
   int bing;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   foreach (tmp, bing in _money) {
      if (lower_case(str) == lower_case(tmp)) {
         if (num > bing) {
            add_failed_mess("The $D does not have " +
                            num + " of " + tmp + " it only has " +
                            bing + ".\n");
            str = tmp;
         }
      }
   }
   if (!_money[str]) {
      add_failed_mess("You do not appear to have any " + str + " in $D.\n");
      return 0;
   }
   _money[str] -= num;
   if (!_money[str]) {
      map_delete(_money, str);
   }
   this_player()->adjust_money(num, str);
   add_succeeded_mess("$N withdraw$s " + num + " of " + str + " from $D.\n");
   return 1;
}
void init() {
   commercial::init();
   add_command("change", "<string'money'> into <string'type'> on <direct:object>",
                  (: change($4[0], $4[1]) :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("deposit", "<number> of <string'type'> on <direct:object>",
                  (: do_deposit($4[0], $4[1]) :));
      add_command("withdraw", "<number> of <string'type'> on <direct:object>",
                  (: do_withdraw($4[0], $4[1]) :));
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cut", _cut);
   add_auto_load_value(map, BOARD_TAG, "money", _money);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   _cut = query_auto_load_value(map, BOARD_TAG, "cut");
   _money = query_auto_load_value(map, BOARD_TAG, "money");
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
}

==================================================
FILE: furnitures/commercial/newspaper_archive_box.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
#define BOARD_TAG "newspaper box"
private string _paper;
private int _cost;
private int _back_issue_cost;
void setup() {
   set_name("box");
   set_short("newspaper archive box");
   add_adjective(({ "archive", "box" }));
   add_help_file("newspaper_archive_box");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_value(2700);
   set_commercial_size(5);
   reset_get();
}
void set_paper(string paper) {
   string place;
   string* bits;
   if (!paper) {
      return ;
   }
   _paper = paper;
   place = query_money_place();
   set_short(_paper + " box");
   set_long("This is a very large battered looking metal box that is full "
            "of old and new copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + " for the current "
            "issue and " +
            MONEY_HAND->money_value_string(_back_issue_cost, place) +
            " for back issues.\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy(int issue) {
   int paper_cost;
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_money_place();
   if (issue == -1) {
      edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
      if (!edition) {
         add_failed_mess("There is no edition to buy.\n");
         return 0;
      }
      cost = _cost;
      paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   } else {
      edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
      if (issue <= 0 || issue > edition) {
         add_failed_mess("The issue numberm ust be between 1 and " +
                         edition + ".\n");
         return 0;
      }
      edition = issue;
      paper_cost = NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2;
      cost = _back_issue_cost;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   adjust_float(cost - paper_cost);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N pull$s a newspaper from $D.\n");
   return 1;
}
string query_main_status(int hints) {
   string ret;
   int paper_cost;
   int back_issue_cost;
   string place;
   place = query_money_place();
   paper_cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   back_issue_cost = paper_cost * 2;
   paper_cost = (paper_cost * 2) / 3;
   ret = "$I$0=" + the_short() + ":\n";
   ret +=   "$I$6=   Revenue                        : " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$6=   Cost from publisher            : " +
          MONEY_HAND->money_value_string(paper_cost, place) +
          "\n$I$6=   Sale price                     : " +
          MONEY_HAND->money_value_string(_cost, place) +
          "\n$I$6=   Back Issue Cost from publisher : " +
          MONEY_HAND->money_value_string(back_issue_cost, place) +
          "\n$I$6=   Back Issue Sale price          : " +
          MONEY_HAND->money_value_string(_back_issue_cost, place) +
          "\n";
   if (hints) {
      ret += "$I$6=      set cost <amount> on <box>\n";
   }
   return ret;
}
int do_set_cost(string amount, int back_issue) {
   int amt;
   string place;
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }
   if (back_issue) {
      _back_issue_cost = amt;
   } else {
      _cost = amt;
   }
   set_long("This is a very large battered looking metal box that is full "
            "of old and new copies of " +
            (lower_case(_paper)[0..3] == "the "?"":"the ") +
            _paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + " for the current "
            "issue and " +
            MONEY_HAND->money_value_string(_back_issue_cost, place) +
            " for back issues.\n");
   if (back_issue) {
      add_succeeded_mess("$N set$s the cost to buy back issue of the paper "
                         "from $D to " +
                         MONEY_HAND->money_value_string(amt, place) + ".\n");
   } else {
      add_succeeded_mess("$N set$s the cost to buy papers from $D to " +
                         MONEY_HAND->money_value_string(amt, place) + ".\n");
   }
   return 1;
}
void init() {
   add_command("buy", "issue <number> from <direct:object>",
               (: do_buy($4[0]) :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy(-1) :));
   add_command("pull", "open <direct:object>", (: do_buy(-1) :));
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0], 0) :));
      add_command("set", "back issue cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0], 1) :));
   }
   ::init();
}
mapping query_commercial_options() {
   mapping ret;
   string paper;
   ret = ([ ]);
   foreach (paper in NEWSPAPER_HANDLER->query_all_papers()) {
      ret[paper] = 0;
   }
   return ([ "paper" : ret ]);
}
void set_commercial_option(string type, string name) {
   switch (type) {
   case "paper" :
      _cost = NEWSPAPER_HANDLER->query_paper_cost(name);
      _back_issue_cost = NEWSPAPER_HANDLER->query_paper_cost(name) * 3;
      call_out("set_paper", 1, name);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "paper", _paper);
   add_auto_load_value(map, BOARD_TAG, "back cost", _back_issue_cost);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   string name;
   commercial::init_dynamic_arg(map, player);
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   _back_issue_cost = query_auto_load_value(map, BOARD_TAG, "back cost");
   name = query_auto_load_value(map, BOARD_TAG, "paper");
   call_out("set_paper", 1, name);
}

==================================================
FILE: furnitures/commercial/newspaper_box.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
#define BOARD_TAG "newspaper box"
private string _paper;
private int _cost;
void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_value(900);
   set_commercial_size(1);
   reset_get();
}
void set_paper(string paper) {
   string place;
   string* bits;
   if (!paper) {
      return ;
   }
   _paper = paper;
   place = query_money_place();
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy() {
   int paper_cost;
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_money_place();
   cost = _cost;
   paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   adjust_float(cost - paper_cost);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N pull$s a newspaper from $D.\n");
   return 1;
}
string query_main_status(int hints) {
   string ret;
   int paper_cost;
   string place;
   place = query_money_place();
   paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   ret = the_short() + ":\n";
   ret +=   "$I$6=   Revenue             : " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$6=   Cost from publisher : " +
          MONEY_HAND->money_value_string(paper_cost, place) +
          "\n$I$6=   Sale price          : " +
          MONEY_HAND->money_value_string(_cost, place) +
          "\n";
   if (hints) {
      ret += "$I$6=      set cost <amount> on <box>\n";
   }
   return ret;
}
int do_set_cost(string amount) {
   int amt;
   string place;
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }
   _cost = amt;
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(_paper)[0..3] == "the "?"":"the ") +
            _paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + ".\n");
   add_succeeded_mess("$N set$s the cost of buy papers from $D to " +
                      MONEY_HAND->money_value_string(amt, place) + ".\n");
   return 1;
}
void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0]) :));
   }
   ::init();
}
mapping query_commercial_options() {
   mapping ret;
   string paper;
   ret = ([ ]);
   foreach (paper in NEWSPAPER_HANDLER->query_all_papers()) {
      ret[paper] = 0;
   }
   return ([ "paper" : ret ]);
}
void set_commercial_option(string type, string name) {
   switch (type) {
   case "paper" :
      _cost = NEWSPAPER_HANDLER->query_paper_cost(name);
      call_out("set_paper", 1, name);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "paper", _paper);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   string name;
   commercial::init_dynamic_arg(map, player);
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   name = query_auto_load_value(map, BOARD_TAG, "paper");
   call_out("set_paper", 1, name);
}

==================================================
FILE: furnitures/commercial/pickler.c
==================================================

inherit "/std/room/furniture/commercial";
#include <money.h>
#define FEE_PER_USE 40
#define BOARD_TAG "pickler"
private int _revenue;
private int _cost;
void setup() {
   set_name( "pickler" );
   set_short( "pickler" );
   set_long( "A small wooden box with a handle on it, it has some words "
             "written on it.\n");
   add_read_mess("Pickler, pull for results", 0, "common");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   add_help_file("pickler");
   set_commercial_size(2);
   set_commercial_type("utility");
   set_shop_use_types(({ "pickler" }));
   _cost = 80;
}
int do_pickle(object* obs) {
   object* pickleable;
   string place;
   int amt;
   int here_amt;
   if (!is_open_for("pickler", this_player()->query_name())) {
      add_failed_mess("The pickler is not open.\n");
      return 0;
   }
   place = query_money_place();
   pickleable = filter(obs, (: !$1->query_cured() &&
                               ($1->query_property("cureable") ||
                                $1->query_decay_speed()) :));
   if (!sizeof(pickleable)) {
      add_failed_mess("You cannot pickle any of " +
                      query_multiple_short(obs) + ".\n");
      return 0;
   }
   amt = sizeof(pickleable) * _cost;
   here_amt = amt - sizeof(pickleable) * FEE_PER_USE;
   if (here_amt < 0) {
      if (query_float() < -here_amt) {
          add_failed_mess(environment()->the_short() + " does not "
                          "have enough money to pickle anything.\n");
          return 0;
      }
   }
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to pay for $I to be pickled.\n", pickleable);
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place), place);
   pickleable->do_cure();
   adjust_float(here_amt);
   _revenue += here_amt;
   add_succeeded_mess("$N pickle$s $I on $D.\n", pickleable);
   return 1;
}
int do_set_cost(string amount) {
   int amt;
   string place;
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }
   _cost = amt;
   add_succeeded_mess("$N set$s the cost of using $D to " +
                      MONEY_HAND->money_value_string(amt, place) + ".\n");
   return 1;
}
string query_main_status(int hint) {
   string place;
   place = query_money_place();
   return the_short() + " status:\n"
          "\n$I$6=   Fee Per Use : " +
              MONEY_HAND->money_value_string(FEE_PER_USE, place) + " (fixed)"
          "\n$I$6=   Cost Per Use: " +
              MONEY_HAND->money_value_string(_cost, place) +
          "\n$I$6=   Profit      : " +
             MONEY_HAND->money_value_string(_revenue, place) + "\n";
}
int do_stats() {
   string ret;
   ret = query_main_status(0);
   write(ret);
   add_succeeded_mess("");
   return 1;
}
void init() {
   commercial::init();
   add_command("use", "<direct:object> to [pickle] <indirect:object>",
               (: do_pickle :));
   add_command("use", "<direct:object> with <indirect:object>",
               (: do_pickle :));
   add_command("pickle", "<indirect:object> with <direct:object>",
               (: do_pickle :));
   add_command("pull", "[handle] [on] <direct:object> with <indirect:object>",
               (: do_pickle :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>",
                  (: do_stats() :));
      add_command("set", "cost <string'cost'> on <direct:object>",
                  (: do_set_cost($4[0]) :));
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "revenue", _revenue);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   _revenue = query_auto_load_value(map, BOARD_TAG, "revenue");
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
}

==================================================
FILE: furnitures/commercial/poll_data.c
==================================================

inherit "/std/room/inherit/voting_room";
inherit "/std/room/furniture/commercial";
#include <money.h>
#define BOARD_TAG "poll data"
#define POLL_DATA_MAXIMUM_RESULTS 10
private int _allow_open_voting;
private string* _finished_votes;
void finish_vote(string type, string description, string* choices,
                 mapping votes, string* voted);
void create() {
   voting_room::create();
   commercial::create();
   _finished_votes = ({ });
}
void setup() {
   set_name( "poll" );
   set_short( "opinion poll" );
   add_adjective( ({ "opinion" } ));
   set_long( "A box with a bunch of pieces paper sitting on it.  It seems "
             "to be keeping a tally of something.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   set_commercial_size(2);
   set_commercial_type("misc");
   set_shop_use_types(({ "poll add", "poll vote" }));
   set_completion_action((: finish_vote :));
   set_no_elections(1);
   set_vote_conditions((: is_open_for("poll vote", $1->query_name()) :));
   add_help_file("poll_data");
}
int load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }
   set_save_file(query_save_dir() + query_commercial_id());
   if (!_finished_votes) {
      _finished_votes = ({ });
   }
}
int do_show_results() {
   string ret;
   string result;
   ret = "";
   foreach (result in _finished_votes) {
      ret += result + "\n\n";
   }
   write("$P$Vote Archive$P$" + ret);
   add_succeeded_mess("");
   return 1;
}
int do_create_vote(string choices) {
   if (!is_open_for("poll add", this_player()->query_name())) {
      add_failed_mess("Unable to add a vote.\n");
      return 0;
   }
  return ::do_create_vote(choices);
}
void finish_vote(string type, string description, string* choices,
                 int* votes, string* voted)
{
   string ret;
   int i;
   ret = "Vote finished at " + ctime(time()) + ":\n";
   ret += "$I$3=   " + description + "\n\n";
   ret += "$I$0=Results:\n$I$3=   ";
   for (i = 0; i < sizeof(choices); i++) {
      ret += choices[i] + ": " + votes[i] + "\n";
   }
   if (!_finished_votes) {
      _finished_votes = ({ ret });
   } else {
      _finished_votes += ({ ret });
   }
   if (sizeof(_finished_votes) > POLL_DATA_MAXIMUM_RESULTS) {
      _finished_votes = _finished_votes[0..POLL_DATA_MAXIMUM_RESULTS];
   }
   save_room();
}
int do_set_duration(int hours) {
   if (hours <= 0) {
      add_failed_mess("The duration must be positive.\n");
      return 0;
   }
   set_vote_duration(hours * 60 * 60);
   add_succeeded_mess("Set the vote duration to " + hours + " hours.\n");
   return 1;
}
int do_delete_vote(int id) {
   if (!::delete_vote(id)) {
      add_failed_mess("Cannot delete the vote id #" + id + ".\n");
      return 0;
   }
   add_succeeded_mess("Deleted the vote id#" + id + ".\n");
   return 1;
}
int do_end_vote(int id) {
   if ( !query_our_votes()[ id ] ) {
      add_failed_mess("Cannot end the vote id #" + id + ".\n");
      return 0;
   }
   end_vote(id);
   add_succeeded_mess("Finished the vote id#" + id + ".\n");
   return 1;
}
string query_main_status() {
   string ret;
   ret = "Vote duration:    " + (query_vote_duration() / (60 * 60)) +
         " hours\n";
   return ret;
}
void init() {
   commercial::init();
   voting_room::init();
   voting_room::init_add_vote();
   add_command("results", "of votes", (: do_show_results() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "vote duration <number'hours'> on <direct:object>",
                  (: do_set_duration($4[0]) :));
      add_command("delete", "vote <number'vote id'>",
                  (: do_delete_vote($4[0]) :));
      add_command("finish", "vote <number'vote id'>",
                  (: do_end_vote($4[0]) :));
   }
}

==================================================
FILE: furnitures/commercial/postal.c
==================================================

inherit "/std/room/furniture/commercial";
#include <money.h>
#include <mail.h>
#define BOARD_TAG "postal"
int _num_uses;
void setup() {
   set_name( "counter" );
   set_short( "postal counter" );
   add_adjective("postal");
   set_long( "A wooden counter that looks like a place you could write "
             "and read mail.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(6400000);
   add_help_file("postal");
   set_commercial_size(25);
   set_commercial_type("utility");
   set_shop_use_types(({ "pickler" }));
}
int do_mail(string to) {
   if (MAIL_TRACK->mail(to)) {
      _num_uses++;
      return 1;
   }
   return 0;
}
string query_main_status(int hint) {
   string place;
   place = query_money_place();
   return the_short() + " status:\n"
          "\n$I$6=   Number of  uses : " + _num_uses + "\n";
}
void init() {
   commercial::init();
   add_command("mail", "<string'to'>",
               (: do_mail($4[0]) :));
   add_command("mail", "[handle] [on] <direct:object> with <indirect:object>",
               (: do_mail(0) :));
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "uses", _num_uses);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   _num_uses = query_auto_load_value(map, BOARD_TAG, "uses");
}

==================================================
FILE: furnitures/commercial/small_shop.c
==================================================

inherit "/std/room/furniture/shop_base";
void setup() {
   set_name( "counter" );
   set_short( "small shop counter" );
   add_adjective( ({ "small", "shop" } ));
   set_long( "The smooth polished surface of the small counter shines and "
             "glows at you.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(480000);
   set_maximum_inventory_size(50);
   set_commercial_size(40);
}

==================================================
FILE: furnitures/artwork/mountain_painting.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "painting" );
    set_short( "painting of a misty mountain range" );
    add_adjective( ({ "of", "a", "misty", "mountain", "range" }) );
    set_long( "This is a watercolour painting of a range of "
        "mountains skirting a misty lake.  Fiery red trees "
        "border the indescript water's edge, snaking their "
        "branches out horizontally more than vertically.  "
        "The mountains have been painted complementing "
        "shades of steel grey and persian blue, while the "
        "water itself is a strangely creamy white.\n" );
    set_weight( 40 );
    set_value( 46775 );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}

==================================================
FILE: furnitures/fake_plants/silk_cabbage_plant.c
==================================================

inherit "/std/room/furniture/basic";
void setup () {
    set_name( "plant" );
    add_adjective( ({ "silk", "potted", "cabbage" }) );
    set_short( "potted silk cabbage plant" );
    add_alias( "cabbage" );
    set_main_plural ( "potted silk cabbage plants" );
    add_property( "determinate", "a " );
    set_long( "Rare and magnificent!  Strange and exotic!  Potted in a "
        "subtley plain pot, this fine silk-leafed brassica has been "
        "created in Sum Dim by none other than Brown Fingers Dibbler, "
        "purveyor of the finest silken forn plants.  Its leaves even look "
        "as though they have been nibbled slightly by a caterpillar, "
        "for the authentic touch.\n" );
    set_value( 35000 );
    set_weight( 150 );
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "lying" : "lies" ]));
}

==================================================
FILE: furnitures/safes/small_safe.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
  set_name("safe");
  set_short("small iron safe");
  add_adjective(({"small", "iron"}));
  set_long("This is a small iron safe.  It bears the logo of "
           "Joseph Thighbiter a renowned safe maker.  It appears "
           "to feature one of his patented locks.\n");
  add_drawer("top", 50);
  add_drawer("middle", 25);
  add_drawer("bottom", 25);
  set_drawers_inside(1);
  set_weight(900);
  set_value(120000);
  set_allowed_room_verbs((["squatting" : "squats" ]));
  set_pick_skill("covert.lockpick.safes");
  set_difficulty(4);
  setup_trap(300, "pick",
             "Hidden inside the lock is a small ampule which, if touched by "
             "an unwary tool would trigger a puff of poisonous gas.",
             ({"A small cloud of gas puffs out of the safe.\n",
                 "A small cloud of gas puffs out of the safe.\n"}),
             ({"/std/effects/poisons/poison_gas", 600}));
}
void init() {
  string key_id;
  object key;
  if(!query_key()) {
    key_id = "safe"+random(10000);
    set_key(key_id);
    key = clone_object("/std/key");
    key->set_key("small iron", key_id);
    key->set_long("This small, yet sturdy, key looks like it is for a "
                  "safe.\n");
    key->move(this_object());
    set_closed();
  }
  ::init();
}
