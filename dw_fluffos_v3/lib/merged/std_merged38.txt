




==================================================
FILE: /lib/std/languages/language_inherit.c
==================================================

#include <fixed_random.h>
#include <tasks.h>
#include <living.h>
private string _long;
private string _name;
private string _start_text_bit;
void setup();
void create() {
  setup();
}
void set_long(string str) {
   _long = str;
}
string query_long() {
   return _long;
}
void set_name(string str) {
   _name = str;
}
string query_name() {
   return _name;
}
void setup() {
}
void set_start_text_bit(string str) {_start_text_bit = str; }
string do_garble(string word, string type) {
  string ret;
  int i;
  ret = "";
  for (i=0;i<strlen(word);i++)
    if (word[i] != ' ')
      ret += "*";
    else
      ret += " ";
  return ret;
}
void check_level_increase(object player, int difficulty, int level,
                          string skill, string mess) {
   int chance;
   if(query_verb() == "shout" || player->query_property("dead") ||
      player->query_property(PASSED_OUT) ||
      (userp(player) && !interactive(player)))
     return;
   if(player->query_current_language() !=
      lower_case(this_object()->query_name()))
     return;
   if (player->query_property("last message:" + skill) == mess ||
       player->query_property("dead")) {
      return ;
   }
   if(player->query_specific_gp("other") < difficulty) {
     return;
   } else {
     player->adjust_gp(-(difficulty*2));
   }
   player->add_property("last message:" + skill, mess, 360);
   if (difficulty <= level && level < 100) {
        chance = 800 + ((level - 40) * (level - 40)) / 20;
      chance -= level - difficulty;
      if (random(1000) > chance) {
        if(player->add_skill_level(skill, 1)) {
          tell_object(player, "%^YELLOW%^You feel like the " +
                      capitalize(_name) +
                      " language is less confusing.%^RESET%^\n");
        }
      }
   }
}
string garble_message(string mess, object player, object speaker,
                      string type, string skill, int no_increase) {
  int i, level, num;
  int max_difficulty, diff, difference;
  string *bits;
  int something_garbled;
  level = player->query_skill(skill);
  if (level > 100) {
    player->add_skill_level(skill, 100 - level, 1);
  }
  num = speaker->query_skill(skill);
  if (num > 100) {
    speaker->add_skill_level(skill, 100 - num, 1);
  }
  difference = speaker->query_skill(skill) - player->query_skill(skill);
  if (num < level)
    level = num;
  if (level >= 100) {
    return mess;
  }
  if (level == 0) {
    max_difficulty = 0;
  } else {
    max_difficulty = 1000;
  }
  RANDOM_OBJ->set_seed(crc32(mess));
  bits = explode(mess, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (strlen(mess)) {
      if (level > 0) {
         num = (int)RANDOM_OBJ->random(100);
         if (strlen(mess) < 8) {
           diff = (level*100) / (strlen(mess)*10);
           if (num >= (level*100 / strlen(mess)*10)) {
             if (max_difficulty > diff)
               max_difficulty = diff;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               bits[i] = "";
             }
           }
         } else {
           diff = (level*100) / 90;
           if (num >= diff) {
             max_difficulty = level*100 / 100;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               bits[i] = "";
             }
           }
         }
      } else {
         if (interactive(player)) {
           bits[i] = do_garble(bits[i], type);
           something_garbled = 1;
         } else {
           bits[i] = "";
         }
      }
    }
  }
  if (something_garbled && (difference > -10) && !no_increase) {
    check_level_increase(player, max_difficulty, level, skill, mess);
  }
  return implode(bits, " ");
}
mixed garble_say(string start, string mess, object player,
                 object from, string type, string skill, int no_increase) {
  return ({ start, garble_message(mess, player, from, "speech", skill,
                                  no_increase) });
}
string garble_text( mixed text, object thing, object player, string skill) {
  string bing;
  if (stringp(text)) {
    if (player->query_default_language() != query_name()) {
      return _start_text_bit +
        garble_message(text, player, player, "text", skill, 0);
    } else {
      return garble_message(text, player, player, "text", skill, 0);
    }
  }
  if ( pointerp( text ) ) {
    if ( ( bing = (string)text[ 0 ]->garble_text( text, thing, player ) ) ) {
      if (player->query_default_language() != query_name()) {
        return _start_text_bit + bing;
      } else {
        return bing;
      }
    }
  }
  return "You cannot read the spidery writing.\n";
}
void dest_me() {
  destruct(this_object());
}

==================================================
FILE: /lib/std/languages/rabbit.c
==================================================

#include <language.h>
inherit LANGUAGE_INHERIT;
void setup() {
   set_long( "This is the local language of Rabbit.\n" );
   set_name( "Rabbitian" );
   set_start_text_bit( "Some carefully constructed characters "
                       "that might mean:\n" );
}
mixed do_garble_text( string text ) {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
}
string do_garble( string text, string text_type )  {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
}

==================================================
FILE: /lib/std/languages/wommon.c
==================================================

string long() {
  return
"International womens day language.\n";
}
string filter_string(string str) {
  return replace(" "+str,
      ({ " he ", " they ",
         " He ", " They ",
         " HE ", " THEY ",
         " his ", " theirs ",
         " His ", " Theirs ",
         " HIs ", " THEIrs ",
         " HIS ", " THEIRS ",
         " him ", " them ",
         " Him ", " Them ",
         " HIm ", " THem ",
         " HIM ", " THEM ",
         "man", "person",
         "Man", "Person",
         "MAn", "PERson",
         "MAN", "PERSON", }))[1..10000];
}
mixed garble_tell(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_shout(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_say(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_text(string str, object ob) {
  return filter_string(str);
}

==================================================
FILE: /lib/std/dom/base_master.c
==================================================

#include <project_management.h>
#include <player_handler.h>
#include <error_handler.h>
#define LOCK_MASK 8
#define PROJECT_CODE "$project$"
mapping members;
mapping access;
nosave private mapping _project_cache;
private int _use_tracker;
private string _idle_mess;
string *deputies;
private mapping _directory_assignments;
private mapping _rcsforce_allowed;
string query_lord();
int query_use_tracker();
void set_use_tracker(int);
string query_domain() {
  string *words;
  if (!file_name (this_object())) {
    return "";
  }
  words =  explode (file_name(this_object()), "/");
  if (sizeof (words) < 2) {
    return "";
  }
  return words[1];
}
int query_prevent_shadow() {
   return 1;
}
protected void create() {
   members = ([ ]);
   access = ([ ]);
   deputies = ({ });
   _project_cache = ([ ]);
   _rcsforce_allowed = ([ ]);
   _idle_mess = 0;
   unguarded((: restore_object, file_name(this_object()) :));
   if (!deputies) {
      deputies = ({ });
   }
   if (!_directory_assignments) {
      _directory_assignments = ([ ]);
   }
   if ( !_rcsforce_allowed ) {
       _rcsforce_allowed = ([ ]);
   }
}
void save_me() {
   unguarded((: save_object, file_name(this_object()) :));
}
int add_permission(string euid,
                   string path,
                   int mask)
{
   if (previous_object() != master()) {
      return 0;
   }
   if (!access[path]){
      access[path] = ([ euid : mask ]);
   } else {
      access[path][euid] |= mask;
   }
   save_me();
   return 1;
}
int remove_permission(string euid,
                      string path,
                      int mask)
{
   if (previous_object() != master())
      return 0;
   if (!access[path])
      return 0;
   if (!access[path][euid])
      return 0;
   access[path][euid] &= ~mask;
   if (!access[path][euid])
      map_delete(access[path], euid);
   if (!sizeof(access[path]))
      map_delete(access, path);
   save_me();
   return 1;
}
int check_permission(string euid,
                     string *path,
                     int mask)
{
   string p;
   mapping perms;
   if ((sizeof(path) >= 3)
       && (path[2] == "master.c" || path[2] == "master.o"
           || path[2] == "master"))
      return 0;
   p = "/" + implode(path, "/");
   perms = master()->permission_match_path(access, p);
   if (!perms || !sizeof(perms)) {
      return 0;
   }
   if (perms[euid] && ((perms[euid] & mask) || (perms["all"] & mask))) {
      return 1;
   }
   if (perms["all"] & LOCK_MASK) {
      return -1;
   }
   return 0;
}
int valid_read(string,
               string euid,
               string)
{
   return 1;
   return (members[euid] != 0);
}
int valid_write(string *path,
                string euid,
                string)
{
   return 0;
   if ((sizeof(path) >= 3)
       && (path[2] == "master.c" || path[2] == "master.o"
           || path[2] == "master"))
      return 0;
   return (members[euid] != 0);
}
void dest_me()
{
   destruct(this_object());
}
int check_call_tree(int only_lord)
{
   object *obs;
   int found;
   int i;
   obs = previous_object(-1);
   for (i = 0; i < sizeof(obs); i++) {
     if (file_name(obs[i])[0..12] == "/global/lord#" ||
         (file_name(obs[i])[0..15] == "/global/creator#")) {
       if("/secure/master"->query_administrator(obs[i]->query_name()) ||
          obs[i]->query_name() == query_lord() ||
          (!only_lord &&
           (member_array(obs[i]->query_name(), deputies) != -1))) {
         found = 1;
       } else {
         return 0;
       }
     }
   }
   return found;
}
int add_member(string name)
{
   if (!check_call_tree(0)) {
      return 0;
   }
   if (members[name])
      return 0;
   members[name] = "newbie";
   save_me();
   return 1;
}
int remove_member(string name)
{
   int pos;
   if (!check_call_tree(member_array(name, deputies) != -1)) {
      return 0;
   }
   if (!members[name])
      return 0;
   members = m_delete(members, name);
   pos = member_array(name, deputies);
   if (pos != -1) {
      deputies = deputies[0..pos - 1] + deputies[pos + 1..];
   }
   save_me();
   return 1;
}
int add_deputy(string name)
{
   if (!check_call_tree(1)) {
      return 0;
   }
   if (!members[name])
      return 0;
   if (!deputies)
      deputies = ({ });
   if (member_array(name, deputies) != -1)
      return 1;
   deputies += ({ name });
   save_me();
   return 1;
}
int remove_deputy(string name)
{
   int pos;
   if (!check_call_tree(1)) {
      return 0;
   }
   if (!deputies)
      deputies = ({ });
   pos = member_array(name, deputies);
   if (pos == -1)
      return 0;
   deputies = deputies[0..pos - 1] + deputies[pos + 1..];
   save_me();
   return 1;
}
int add_rcsforce_allowed( string creator, string directory ) {
    if (!check_call_tree(1)) {
      return 0;
   }
   if ( _rcsforce_allowed[ creator ] ) {
        _rcsforce_allowed[ creator ] += ({ directory });
   }
   else {
        _rcsforce_allowed[ creator ] = ({ directory });
   }
   save_me();
   return 1;
}
int remove_rcsforce_allowed( string creator, string directory ) {
    if (!check_call_tree(1)) {
      return 0;
   }
   if ( _rcsforce_allowed[ creator ] ) {
        _rcsforce_allowed[ creator ] -= ({ directory });
        if ( sizeof( _rcsforce_allowed ) == 0 ) {
            map_delete( _rcsforce_allowed, creator );
        }
        save_me();
   }
   return 1;
}
string *query_members()
{
   return keys(members);
}
int set_project(string name,
                string pro)
{
   if (!check_call_tree(0)) {
      return 0;
   }
   if (!members[name])
      return 0;
   if (!pro || pro == "")
      pro = "project unset";
   members[name] = pro;
   save_me();
   return 1;
}
string query_project(string name)
{
  string *proj;
  string project;
  project = members[name];
  if (!project) {
    return "project unset";
  }
  if (strsrch (project, PROJECT_CODE) != -1) {
    if (!sizeof (_project_cache)) {
      _project_cache = ([ ]);
    }
   if (undefinedp (_project_cache[name])) {
      proj = PROJECT_HANDLER->query_projects_for_creator_in_domain
        (name, query_domain());
      if (sizeof (proj)) {
        _project_cache[name] = query_multiple_short (proj);
      }
      else {
        _project_cache[name] = members[name];
      }
    }
    return replace (project, ({PROJECT_CODE,
      _project_cache[name]}));
  }
  else {
    return members[name];
  }
}
int query_deputy(string name)
{
   if (!deputies)
      return 0;
   if (member_array(name, deputies) != -1)
      return 1;
   return 0;
}
string *query_deputies()
{
   return copy(deputies);
}
mapping query_access()
{
   return copy(access);
}
string query_lord()
{
   return "Something is broken";
}
int can_rcsforce(string file, string person, string locker) {
    string *directories;
    string fdir;
    if (query_deputy(person)) {
        return 1;
    }
    directories = _rcsforce_allowed[ person ];
    if ( directories ) {
        fdir = file[ 0..strsrch( file, "/", -1 ) -1 ];
        foreach ( string directory in directories ) {
            if ( fdir[ 0.. sizeof( directory ) - 1 ] == directory ) {
                return 1;
            }
        }
    }
    return 0;
}
string query_changelog (string filename) {
  return  "/d/" + query_domain() + "/ChangeLog";
}
void set_use_tracker(int i) {
  _use_tracker = i;
}
int query_use_tracker() {
  return _use_tracker;
}
int nuke_creator_project_cache(string *creators) {
  if (!_project_cache) {
    return 0;
  }
  foreach (string c in creators) {
    map_delete (_project_cache, c);
    return 1;
  }
}
int set_idle_mess( string txt ) {
   if (!check_call_tree(1)) {
        return 0;
   }
   _idle_mess = txt;
   save_me();
   return 1;
}
string query_idle_mess() {
    return _idle_mess;
}
string* query_assigned_to_directory(string* dir) {
   string str;
   int i;
   i = sizeof(dir) - 1;
   do {
      str = "/" + implode(dir[0..<i], "/");
      i--;
   } while (i >= 0 && !_directory_assignments[str]);
   if (_directory_assignments[str]) {
      return _directory_assignments[str];
   }
   return ({ query_lord() });
}
int assign_people_to_directory(string dir, string* people) {
   if (previous_object() != master()) {
      return 0;
   }
   if (sizeof(people)) {
      if (sizeof(people) == 1 && people[0] == ERROR_ASSIGNED_NO_ONE) {
         people = ({ });
      }
      _directory_assignments[dir] = people;
   } else {
      map_delete(_directory_assignments, dir);
   }
   save_me();
   return 1;
}
mapping query_directory_assignments() {
   mapping ret;
   string dir;
   ret = copy(_directory_assignments);
   dir = "/d/" + query_domain();
   if (!ret[dir]) {
      ret[dir] = ({ query_lord() });
   } else {
      ret[dir] |= ({ query_lord() });
   }
   return ret;
}

==================================================
FILE: /lib/std/dom/cmn_mas.c
==================================================

inherit "/std/room/basic_room";
private nosave string _dom_name;
string query_dom() { return _dom_name; }
void set_dom(string str) { _dom_name = str; }
int do_list(string);
int add_creator(string);
int delete_creator(string);
int set_project(string, string);
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/commonroom");
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  add_command("list", "<word'domain'>", (:do_list($4[0]):));
  add_command("list", "", (:do_list(0):));
  add_command("add", "<word'creator'>", (:add_creator($4[0]):));
  add_command("delete", "<word'creator'>" ,(:delete_creator($4[0]):));
  add_command("project", "<word'name'> <string'project'>",
    (:set_project($4[0], $4[1]):));
}
int do_list(string arg) {
  string *domains, mast, s = "";
  string *members;
  int i, j;
  if(arg == "all")
    domains = get_dir("/d/");
  else if(!arg)
    domains = ({ _dom_name });
  else {
    domains = ({ arg });
  }
  if(sizeof(domains) > 1) {
    write("All domains:\n");
  }
  else {
    write("This domain:\n");
  }
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    if (!load_object (mast)) {
      continue;
    }
    members = mast->query_members();
    if(!members) {
      members = ({ });
    }
    s += sprintf("%s has %s members and is owned by %s.\n", capitalize (domains[i]),
      query_num (sizeof(members)), capitalize((string)mast->query_lord()));
    for(j=0; j<sizeof(members); j++)
      s +=sprintf("* %s's project: %-=*s\n", capitalize(members[j]),
                       this_player()->query_cols()-12-strlen(members[j]),
                       mast->query_project(members[j]));
      s += "\n\n";
  }
  this_player()->set_finish_func(0);
  this_player()->more_string(s);
  return 1;
}
int add_creator(string arg) {
  string mast;
  arg = (string)this_player()->expand_nickname(arg);
  mast = "/d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));
    return 0;
  }
  if(!mast->add_member(arg)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is already a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())),
      ({ }));
    return 0;
  }
  write("Creator " + capitalize(arg) + " now added to " + _dom_name + ".\n");
  return 1;
}
int delete_creator(string arg) {
  string mast;
  arg = (string)this_player()->expand_nickname(arg);
  mast = "d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));
    return 0;
  }
  if (!mast->remove_member(arg)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is not a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())),
      ({ }));
    return 0;
  }
  write("Member " + capitalize(arg) + " removed from " + _dom_name + ".\n");
  return 1;
}
int set_project(string arg, string project)
{
  string mast;
  mast = "d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));
    return 0;
  }
  arg = (string)this_player()->expand_nickname(arg);
  if(!mast->set_project(arg, project)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is not a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())),
      ({ }));
    return 0;
  }
  write(capitalize(arg) + "'s project set to : " + project + ".\n");
  return 1;
}

==================================================
FILE: /lib/std/dom/common.c
==================================================

#include <config.h>
inherit "/std/dom/cmn_mas";
object board;
void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", CONFIG_START_LOCATION, "door");
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs addorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}
void dest_me()
{
  if(board) board->dest_me();
  ::dest_me();
}

==================================================
FILE: /lib/std/dom/error_tracker.c
==================================================

inherit "/std/dom/error_tracker_master";
void create()
{
  set_domain("klatch");
  set_name("klatchian error tracker");
  set_other_dirs(({ }));
  set_period(604800);
  ::create();
}

==================================================
FILE: /lib/std/dom/error_tracker_master.c
==================================================

#include <board.h>
#include <db.h>
#include <config.h>
#include <project_management.h>
#define HELPER "/obj/handlers/finderror_helper"
inherit "/global/path";
private void finished_count_errors( object player, int status, mixed data );
private string domain = "unset";
private string _board;
private string tracker_name = "generic error tracker";
private string *other_dirs = ({ });
private int period = 604800;
private int nexttime;
private nosave mapping _messages;
private nosave string *_queue;
private nosave object _tester;
private nosave string _save_file;
private nosave int starttime;
#define ERROR_INDEX 0
#define TYPO_INDEX 1
#define IDEA_INDEX 2
#undef OLD_SYTEM
void do_the_work();
protected void save_me()
{
   if (domain != "unset" && _save_file) {
      unguarded( (: save_object, _save_file, 0 :) );
   }
}
void create()
{
   int retval;
   _messages = ([ ]);
   _tester = 0;
   seteuid(master()->creator_file(file_name()));
   _save_file = file_name();
   if (catch(retval = unguarded((: restore_object, _save_file, 1 :))) ||
         !retval) {
      string temp;
      temp = "/save/" + replace(file_name()[1..], "/", "_");
      if (catch(retval = unguarded((: restore_object, temp, 1 :))) ||
            !retval) {
         if (catch(save_me())) {
            _save_file = temp;
         }
      } else {
         _save_file = temp;
      }
   }
   if (!retval) {
      nexttime = 0;
   }
   if (nexttime < time()) {
      do_the_work();
   } else {
      call_out("do_the_work", nexttime - time());
   }
}
void set_board(string board) {
   _board = board;
}
string query_board() {
   return _board;
}
void dest_me()
{
   save_me();
   destruct(this_object());
}
nomask mixed dwep()
{
   destruct(this_object());
   return "Destructed With Extreme Prejudice";
}
protected varargs int post( string message, string title )
{
   string temp;
   if( undefinedp( title ) ) {
      temp = "Status summary for "+ capitalize( domain ) + ".";
   } else {
      temp = title;
   }
   if (_tester) {
      _tester->more_string(message);
      _tester = 0;
      return 0;
   }
   if (_board) {
      return BOARD_HAND->add_message(_board,
         capitalize(tracker_name), temp ,
         message);
   } else {
      return BOARD_HAND->add_message(domain,
         capitalize(tracker_name), temp ,
         message);
   }
}
string * query_classifications() {
    return ({ "live", "playtesting", "development" });
}
string query_post_message() {
   string message;
   int diff;
   if (!sizeof(_messages)) {
      message = "Congratulations!   There are no errors in all of " +
         capitalize(domain) + "!   Excellent work, everyone.\n";
   }
   else {
       message = "";
         foreach( string key in query_classifications() ) {
            if ( _messages[ key ] ) {
                message += "There are reports in the following " + key +
                    " areas:\n\n" + _messages[ key ] + "\n";
            }
            else {
                if ( key == "live" ) {
                    message += "\n\nThere are no live bugs in all of " +
                        capitalize(domain) + ".   Good work, everyone!\n";
                }
                else {
                    message += "\n\nThere are no outstanding " + key + " bugs.\n";
                }
            }
        }
   }
   diff = (real_time() - starttime);
   message += "\n\nThis message took " + diff +
     " second" + (diff != 1 ? "s" : "") + " to produce.\n";
   return message;
}
string query_project_message() {
   string str;
   class project* projects, *my_projects;
   class project project;
   mapping status;
   str = "\nCurrent Domain Projects:\n\n";
   projects = PROJECT_HANDLER->filter_by_query(([ "domains" : domain ]));
   if (sizeof(projects)) {
        status = unique_mapping( projects, (: STATUS[((class project)$1)->status] :) );
        map_delete( status, "play" );
        if ( !sizeof(status) ){
            str += "This domain is project free.\n";
        }
        foreach( string key in sort_array( keys( status ), 1 ) ) {
            str += "Projects classified as " +
                upper_case(key) + ":\n";
            my_projects = sort_array(status[key],
                (: strcmp(((class project)$1)->name,
                ((class project)$2)->name) :) );
            foreach (project in my_projects) {
                str += "    * " + project->name + " - " +
                    query_multiple_short(sort_array(map(project->creators,
                    (: capitalize :) ), 1)) + "\n";
            }
            str += "\n";
        }
   }
   else {
      str += "This domain is project free.\n";
   }
   return str;
}
protected void iterate()
{
#ifdef OLD
   string message;
   if (sizeof(_queue)) {
      string dir = _queue[0];
      if (sizeof(_queue) > 1) {
         _queue = _queue[1..];
      } else {
         _queue = ({ });
      }
      if (strsrch (dir, "_dev") != -1) {
         dodir(dir, (: _dev_msg += ({ $1 }), iterate() :));
      } else if (strsrch (dir, "_pt") != -1) {
         dodir(dir, (: _pt_msg += ({ $1 }), iterate() :));
      } else {
         dodir(dir, (: _messages += ({ $1 }), iterate() :));
      }
   } else {
      message = query_project_message() + "\n";
      message += query_post_message();
      post(message);
      _messages = ({ });
      if( function_exists( "domain_customisation" , this_object() ) ) {
            call_out( "domain_customisation" , 1 );
      }
   }
#endif
    HELPER->query_errors_in_dirs(_queue, (: finished_count_errors :) );
}
void initialise_variables() {
   _queue = ({ "/d/" + domain + "%" }) + other_dirs;
   _messages = ([ ]);
}
void do_the_work()
{
   if (domain == "unset") return;
   nexttime = time() + period;
   remove_call_out("do_the_work");
   call_out("do_the_work", period);
   save_me();
   starttime = real_time();
   initialise_variables();
   iterate();
}
varargs void test()
{
   _tester = this_player();
   starttime = real_time();
   initialise_variables();
   iterate();
}
void set_name(string name)
{
   tracker_name = name;
   save_me();
}
void set_domain(string name)
{
   domain = name;
   save_me();
}
string query_domain() {
   return domain;
}
void set_period(int length)
{
   remove_call_out("do_the_work");
   nexttime -= period;
   period = length;
   nexttime += period;
   save_me();
}
void set_other_dirs(string *others)
{
   if (arrayp(others)) {
      other_dirs = others;
   } else {
      other_dirs = ({ });
   }
   save_me();
}
mixed stats()
{
   return ({
      ({ "domain", domain }),
      ({ "name", tracker_name }),
      ({ "period", period }),
      ({ "next time", ctime(nexttime) }),
      ({ "testing by", _tester }),
      ({ "queue length", sizeof(_queue) }),
      ({ "message length", sizeof(_messages) }),
      ({ "other dirs", sizeof(other_dirs) ? implode(other_dirs, ", ") : 0 }),
      ({ "save file", _save_file }),
   });
}
protected string classify_directory(string path) {
    if ( strsrch( path, "_pt" ) > -1 ) {
        return "playtesting";
    }
    if ( strsrch( path, "_dev" ) > -1 ) {
        return "development";
    }
    return "live";
}
private int sort_errors( mapping mdata, string key1, string key2 ) {
    int total1, total2;
    total1 = mdata[key1][0] + mdata[key1][1] + mdata[key1][2];
    total2 = mdata[key2][0] + mdata[key2][1] + mdata[key2][2];
    if ( total1 > total2 )  {
        return -1;
    } else {
        if ( total1 == total2 ) {
            return 0;
        } else {
            return 1;
        }
    }
}
private void finished_count_errors( object player, int status, mixed data ) {
    int *count;
    string *paths;
    mapping errors = ([ ]);
    mapping total = ([ ]);
    string txt;
    string classification;
    mapping mdata;
    string message;
    foreach( mapping direc in data ) {
        classification = classify_directory( direc[ "Directory" ] );
        if ( !errors[ classification ] ) {
            errors[ classification ] = ([ ]);
        }
        if ( !total[ classification ] ) {
            total[ classification ] = ({ 0, 0, 0 });
        }
        count = errors[ classification ][ direc[ "Directory" ] ];
        if ( undefinedp( count ) ) {
            count = ({ 0, 0, 0 });
        }
        switch( direc[ "Type" ] ) {
            case "BUG":
                count[ 0 ] = direc[ "C" ];
                total[ classification ][ 0 ] += count[ 0 ];
            break;
            case "TYPO":
                count[ 1 ] = direc[ "C" ];
                total[ classification ][ 1 ] += count[ 1 ];
            break;
            case "IDEA":
            default:
                count[ 2 ] = direc[ "C" ];
                total[ classification ][ 2 ] += count[ 2 ];
        }
        errors[ classification ][ direc[ "Directory" ] ] = count;
    }
    foreach ( classification, mdata in errors ) {
        paths = sort_array( keys( mdata ), (: sort_errors( $(mdata), $1, $2 ) :) );
        txt = "BUGS TYPO IDEA [Assigned] Dir\n";
        foreach( string key in paths ) {
            string* assigned;
            assigned = master()->query_assigned_to_directory(key);
            if (!sizeof(assigned)) {
               assigned = ({ "No one" });
            }
            txt += sprintf( "%4d %4d %4d %-11s %s\n",
                mdata[ key ][ 0 ],
                mdata[ key ][ 1 ],
                mdata[ key ][ 2 ],
                query_multiple_short(assigned),
                key );
        }
        txt += "-------------\n";
        txt += sprintf( "%4d %4d %4d\n",
            total[ classification ][ 0 ], total[ classification ][ 1 ],
            total[ classification ][ 2 ] );
        _messages[ classification ] = txt;
    }
  message = query_project_message() + "\n";
  message += query_post_message();
  if (function_exists("extend_error_message", this_object())) {
      message += this_object()->extend_error_message( copy( errors ) );
  }
  post(message);
  _messages = ([ ]);
  if( function_exists( "domain_customisation" , this_object() ) ) {
        call_out( "domain_customisation" , 1 );
  }
}

==================================================
FILE: /lib/std/dom/interview_inherit.c
==================================================

#include <player_handler.h>
#include <mail.h>
#define LORD capitalize (load_object ("/d/" + query_domain() + "/master")->query_lord())
#define SECURE "/d/" + query_domain() + "/secure/"
#define SAVE query_interview_dir() + "candidate_list"
#define LOG query_interview_dir() + "candidate_log.txt"
#define EVENTS "/global/events"
#define DEBUG 1
inherit "/std/room";
int add_creator (string);
int do_add (string);
int do_confirm (string);
int do_flag (string, string);
varargs int do_interview (object, string);
int do_query_text(string);
int do_list();
int do_read (string);
int flush();
int query_allowed_creators();
int query_interview();
int remove_candidate (string);
int remove_creator (string);
int remove_interviewed (string);
int set_interview_dir (string);
int set_part_two (string);
int query_part_two_required();
void set_acceptance(string);
void set_confirmation(string);
void set_rejection(string);
void set_interview (int);
void set_subject (string);
void set_interviewer(mixed);
void set_cc (string*);
string query_acceptance();
string query_applicants_text();
string query_cc();
string query_confirmation();
string query_domain();
string query_interview_dir();
string query_part_two();
string query_rejection();
string query_subject();
private nosave int _interview;
private nosave int _pt_two = 1;
private nosave string _acceptance_text;
private nosave string _confirmation_text;
private nosave string _domain;
private nosave string _filename;
private nosave string _interview_dir;
private nosave string _rejection_text;
private nosave string _subject;
private nosave string *_int;
private string *_allowed_creators = ({ });
private string *candidates = ({ });
private string *_cc = ({ });
private string *interviewed = ({ });
private string *submitted = ({ });
private string *accepted = ({ });
private string *rejected = ({ });
nosave string *movie = ({
  "First of all, I'd like to congratulate you for getting this far with the "
  "application process.  The second part of the application, in addition to "
  "testing descriptive and coding skills, is also designed to help weed out "
  "those who aren't really serious about becoming creators.  :-)",
  "I should make it clear at this point that getting this far doesn't mean "
  "that you're guaranteed a promotion.  We just want to get a fuller "
  "appreciation of applicants before we reach a decision on whether you are "
  "to be promoted or not.  :-)",
  "Being a creator, regardless of the rumours or jokes to the contrary, is "
  "not an easy option.  Unlike many MUDs, being a creator on " + mud_name() + " is "
  "not the same as early retirement.  You'll be expected to spend time "
  "coming to terms with the mudlib (the body of code that is used to "
  "create the MUD) and your domain (the areas you actually adventure "
  "in).  As a creator, you have considerable power over large segments of "
  "the MUD.  The important thing is learning how to use that power "
  "responsibly.",
  "We have a number of strict rules on " + mud_name() + " .. rules you should be "
  "aware of before you make any decisions as to whether the role is for "
  "you.  Creators aren't allowed to affect the game in any measurable "
  "way.  Chatting is fine... killing NPCs at random or indiscriminately "
  "cloning cash for players is not.",
  "Being a creator is also not about policing the " + mud_name() + "   That falls "
  "under the jurisdiction of Admin and the Liaison domain.  As a coding "
  "creator your responsibilities lie in dealing with the code that "
  "makes up the MUD.  It is quite common that you will be approached by "
  "players with questions, particularly when they are no liaisons "
  "online.  In cases such as this, you are expected to refer them to "
  "a liaison or a Director.  If none are online, you are expected to ask "
  "them to wait until one is.",
  "In rare cases, it will be necessary for immediate action to be "
  "taken... in such cases, it may be acceptable for you to deal with a "
  "player problem yourself.  Always keep in mind however that you are "
  "here to code.  If it is liaising and player interaction that you think "
  "you would enjoy most, it would be best to consider an application "
  "instead to the Liaison domain.",
  "There is also a stern security policy on " + mud_name() + "   As a creator, you "
  "are expected not to violate this policy.  This means:  No passing "
  "creator information on to players, and no revealing what is posted on "
  "creator boards.   As a creator you have access to a lot of information "
  "players do not... this information should be treated as confidential "
  "unless you have Express Permission from your Leader that you may reveal "
  "it.  In short, we have to be able to trust you with sensitive "
  "information.",
  "The most important thing to remember is that you are expected to "
  "create.  If all you're really interested in is coding toys, then this "
  "role is not for you.  " + mud_name() + " is not strict in the sense of 'You have "
  "to code X rooms per day!', but you are expected to make a measurable "
  "and consistent contribution to your domain.  Your Leader and the "
  "deputy immediately supervising you will check up on this on a "
  "regular basis.",
  "It may sound like an awful lot of work to be a creator... and it is.  "
  "But at the same time, it's an awful lot of fun, and provides you with "
  "the means of giving something back to a MUD that has hopefully provided "
  "you with many hours of entertainment.  :-)",
  "Now that the movie is over, are you still willing to continue your "
  "application to be a creator?  If not, then the exit 'drum' will "
  "return you to the " + mud_name() + "   If you are, hang around a while.  :-)"
  });
void save() {
  unguarded ((: save_object (SAVE) :));
}
void load() {
  unguarded ((: restore_object (SAVE) :));
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/interview_help");
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  this_player()->add_command ("show", this_object(), "movie");
  this_player()->add_command ("stop", this_object(), "movie");
  this_player()->add_command ("interview", this_object(),
      "<indirect:living>", (: do_interview ($1[0]) :));
  this_player()->add_command ("interview", this_object(),
      "<indirect:living> with <string>", (: do_interview ($1[0], $4[1]) :));
  this_player()->add_command ("end", this_object(), "interview");
  this_player()->add_command ("add", this_object(), "<string> [as "
      "candidate]", (: do_add ($4[0]) :));
  this_player()->add_command ("query", this_object(), "applicants");
  this_player()->add_command ("query", this_object(), "permitted "
    "[creators]", (: query_allowed_creators () :));
  this_player()->add_command ("query", this_object(),
    "{confirmation|acceptance|rejection} [text]",
    (: do_query_text ($4[0]) :));
  this_player()->add_command ("delete", this_object(), "<string> [from "
      "candidates]", (: remove_candidate ($4[0]) :));
  this_player()->add_command ("clear", this_object(), "[all] candidates",
      (: flush() :));
  this_player()->add_command ("confirm", this_object(), "<string>",
      (: do_confirm ($4[0]) :));
  this_player()->add_command ("grant", this_object(), "[access to] "
    "<string>", (: add_creator ($4[0]) :));
  this_player()->add_command ("remove", this_object(), "<string> "
    "[as allowed]", (: remove_creator ($4[0]) :));
  this_player()->add_command ("flag", this_object(), "<string> as "
    "{accepted|rejected}", (: do_flag ($4[0], $4[1]) :));
  this_player()->add_command ("read", this_object(),
    "interview for <string>",
    (: do_read ($4[0]) :));
  this_player()->add_command ("list", this_object(), "interviews");
}
void set_movie (string *m) {
  movie = m;
}
int query_permitted(string name) {
  object ob = load_object("/d/" + query_domain() + "/master");
  if (!ob) {
    printf ("Erk, this room is horribly borken!!  Please set the domain "
      "correctly.\n");
    return 0;
  }
  if (member_array (ob, previous_object (-1)) != -1) {
    return 2;
  }
  if (master()->high_programmer (name)) {
    return 1;
  }
#ifdef DEBUG
  if (name == "drakkos") {
    return 1;
  }
#endif
  if ((ob->query_lord() != name) &&
    !(ob->query_deputy (name)) && (member_array (name, _allowed_creators)
    == -1)) {
        return 0;
    }
  return 1;
}
private void write_to_file (string text) {
  unguarded ((: write_file (query_interview_dir()
        +query_subject() +".txt",
        sprintf ("%-=*s", 79, $(text) + "\n")) :));
}
void event_person_say(object ob, string start, string mess, string lang) {
  if (query_subject()) {
      write_to_file (sprintf ("%s says: %s\n", ob->short(),
          mess));
  }
}
void event_emote(object ob, string mess) {
  if (query_subject()) {
      write_to_file (replace (EVENTS->convert_message (mess), ({"$C$", ""})));
  }
}
int do_show() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot show a "
        "movie!\n", ({ }));
      return 0;
  }
  else {
    call_out ("play_movie", 5, 0);
  }
  this_player()->add_succeeded_mess (this_object(), "$N dim$s the light "
          "before pulling out a grubby looking movie projector and pointing "
          "it at an empty wall.  After flicking a switch, a thin ray of "
          "light shoots at the wall.\n", ({ }));
  return 1;
}
int do_stop() {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot stop a "
        "movie!\n", ({ }));
      return 0;
  }
  do {
    i = remove_call_out ("play_movie");
  } while (i != -1);
  this_player()->add_succeeded_mess (this_object(), "$N stop$s the movie.\n",
    ({ }));
  return 1;
}
void play_movie (int i) {
  if (movie[i][0] == '#') {
    tell_room (this_object(), "The movie shows " +
      movie[i][1..sizeof(movie[i])] + "\n");
  }
  else {
    event (this_object(), "person_say", "The voice from the movie says: ",
      movie[i], "general");
  }
  if (i < sizeof (movie)) {
    call_out ("play_movie", 15, ++i);
  }
}
varargs int do_interview (object ob, string names) {
  string *inter = ({ });
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot start an "
        "interview!\n", ({ }));
      return 0;
  }
  if (query_subject()) {
      this_player()->add_failed_mess (this_object(), "You'll have to end "
          "the interview with " + query_subject() + " first.\n", ({ }));
      return 0;
  }
  else {
      if (sizeof (names)) {
        names = replace (names, ({" ", ""}));
        inter = explode (names, ",");
        tell_creator ("drakkos", "%O.\n", inter);
        inter = filter (inter, (: find_player ($1)
          && find_player ($1)->query_playtester() :));
        tell_creator ("drakkos", "%O.\n", inter);
      }
      inter += ({ this_player()->query_name() });
      set_subject (ob->query_name());
      set_interviewer (inter);
      write_to_file (sprintf ("Interview with %s, started %s.  Interview "
        "conducted by %s.\n\n", ob->short(), ctime (time()),
        query_multiple_short (inter)));
  }
  this_player()->add_succeeded_mess (this_object(), "$N press$es a button "
      "on $p tape recorder, indicating the interview is now being "
      "recorded.\n", ({ }));
  return 1;
}
int do_end() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot end an "
        "interview!\n", ({ }));
      return 0;
  }
  if (!query_subject()) {
      this_player()->add_failed_mess (this_object(), "You are not currently "
          "interviewing anyone!\n", ({ }));
      return 0;
  }
  else {
      if (member_array (query_subject(), candidates) != -1) {
          candidates -= ({query_subject()});
      }
      if (member_array (query_subject(), submitted) != -1) {
          submitted -= ({query_subject()});
      }
      interviewed += ({query_subject()});
      interviewed = uniq_array (interviewed);
      save();
      write_to_file (sprintf ("Interview with %s, ended %s.\n", query_subject(),
        ctime (time())));
      set_subject (0);
      set_interviewer (0);
      this_player()->add_succeeded_mess (this_object(), "$N switch$es off "
          "$p tape recorder, indicating the interview is at an end.\n", ({ }));
      return 1;
  }
}
void event_soul(object ob, string str, mixed avoid) {
  if (environment (this_player()) != this_object()) {
    return;
  }
  if (query_subject()) {
    write_to_file (EVENTS->convert_message (str));
  }
}
int *query_co_ord() {
  return 0;
}
int do_query() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot query "
        "creator candidates!\n",
          ({ }));
      return 0;
  }
  if (!sizeof (query_applicants_text())) {
    this_player()->add_failed_mess (this_object(), "No information.\n");
  }
  else {
    tell_object (this_player(), this_object()->query_applicants_text());
  }
  return 1;
}
int do_add (string candidate) {
  int i = query_permitted (this_player()->query_name());
  if (!i) {
      this_player()->add_failed_mess (this_object(), "You cannot add a "
        "candidate!\n", ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (query_part_two_required()) {
    if (member_array (candidate, candidates) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        candidates += ({candidate});
    }
    else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
    }
  }
  else if (member_array (candidate, submitted) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        submitted += ({candidate});
  }
  else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
  }
    AUTO_MAILER->auto_mail( candidate, capitalize
      (this_player()->query_name()), "Your application to "
        + capitalize (query_domain()) + ".", query_cc(),
        query_part_two(), 0, 0);
    save();
    this_player()->add_succeeded_mess (this_object(), "$N add$s a "
      "name to the candidate list.\n", ({ }));
    return 1;
}
string* query_submitted() {
  return submitted;
}
string query_applicants_text() {
  string ret = "", *temp = allocate (sizeof (submitted));
  int i;
  if (sizeof (submitted)) {
      for (i = 0; i < sizeof (submitted); i++) {
          if (find_player (submitted[i])) {
              temp [i] = "%^BOLD%^"+submitted[i] + "%^RESET%^";
          }
          else {
              temp [i] = submitted [i];
          }
      }
    }
  if (query_part_two_required()) {
    if (sizeof (candidates)) {
      ret += sprintf ("The candidates for %s still to submit answers to "
          "part two of the application process are: %s.\n",
            capitalize (query_domain()), query_multiple_short (candidates));
    }
  }
  else {
    if (query_interview()) {
      if (sizeof (temp)) {
        ret += sprintf ("The following candidates for %s " +
        (query_part_two_required()? "have submitted "
          "answers to part two of the test and " :  "")
          + "are awaiting an interview.  "
          "Names in bold are currently online: %s.\n",
          capitalize (query_domain()), query_multiple_short (temp));
      }
    }
    else {
      ret += sprintf ("The following candidates for %s have submitted "
        "answers to part two of the test and are awaiting a response.  "
        "Names in bold are currently online: %s.\n",
        capitalize (query_domain()), query_multiple_short (temp));
    }
  }
  if (query_interview()) {
    if (sizeof (interviewed)) {
        ret += sprintf ("The following candidates have been interviewed "
            "for %s, and are awaiting a response: %s.\n",
            capitalize (query_domain()), query_multiple_short (interviewed));
    }
  }
  if (sizeof (accepted)) {
    ret += sprintf ("The following candidates have been accepted "
            "for %s: %s.\n",
            capitalize (query_domain()), query_multiple_short (accepted));
  }
  if (sizeof (rejected)) {
    ret += sprintf ("The following candidates have been rejected from "
            "%s: %s.\n",
            capitalize (query_domain()), query_multiple_short (rejected));
  }
  if (!sizeof (ret)) {
      ret += "There are no outstanding candidates, and no-one has been "
          "interviewed recently.\n";
  }
  return ret;
}
int clear_interviewed() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  interviewed = ({ });
  return 1;
}
int clear_candidates() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  return 1;
}
int flush() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  interviewed = ({ });
  submitted = ({ });
  accepted = ({ });
  rejected = ({ });
  return 1;
}
int remove_candidate(string candidate) {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, candidates) != -1) {
      candidates -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, submitted) != -1) {
      submitted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, accepted) != -1) {
      accepted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, rejected) != -1) {
      rejected -= ({candidate});
      i = 1;
  }
  if (i == 1) {
    this_player()->add_succeeded_mess (this_object(), "$N delete$s a "
      "name from the candidate list.\n", ({ }));
    save();
    return 1;
  }
  this_player()->add_failed_mess (this_object(), "No candidate by that "
    "name is on the list.\n", ({ }));
  return 0;
}
int add_candidate(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, candidates) == -1) {
      candidates += ({name});
      return 1;
  }
  return 0;
}
int add_interviewed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, interviewed) == -1) {
      interviewed += ({name});
      return 1;
  }
  return 0;
}
int add_confirmed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, submitted) == -1) {
      submitted += ({name});
      return 1;
  }
  return 0;
}
int remove_interviewed(string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      return 1;
  }
  return 0;
}
int do_confirm (string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (candidate, submitted) != -1) {
    this_player()->add_failed_mess (this_object(), "You have already "
      "confirmed receipt of this candidate's submission.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
    this_player()->add_failed_mess (this_object(), "This candidate "
      "has already been interviewed.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, candidates) != -1) {
    candidates -= ({candidate});
  }
    submitted += ({candidate});
    AUTO_MAILER->auto_mail( candidate, capitalize
        (this_player()->query_name()), "Thank you for your submission.",
        query_cc(), query_confirmation(), 0, 0);
    save();
  this_player()->add_succeeded_mess (this_object(), "$N confirm$s "
    "receipt of a candidate's application.\n", ({ }));
  return 1;
}
void set_domain(string dom) {
  _domain = dom;
}
string query_domain () {
  if (!_domain) {
    return "unset";
  }
  else {
    return _domain;
  }
}
void set_confirmation(string text) {
  _confirmation_text = text;
}
string query_confirmation() {
  if (!sizeof (_confirmation_text)) {
    if (query_interview()) {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "The next part of the application process will be an interview "
        "to discuss your application to the %s domain.  "
        "This interview is likely to take around an hour of your time, "
        "so if you could mail me with a list of your "
        "common online times, hopefully we'll be able to make an "
        "appointment that is mutually convenient.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
    else {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "Your application to the %s domain is now being considered, and "
        "you should expect to hear back within a week or two with an "
        "answer.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
  }
  else {
    return _confirmation_text;
  }
}
string query_lord() {
  return LORD;
}
void set_part_two_required (int i) {
  _pt_two = i;
}
int query_part_two_required () {
  return _pt_two;
}
void set_interview(int i) {
  _interview = i;
}
int query_interview() {
  return _interview;
}
string query_subject(){
  if (_subject) {
    return _subject;
  }
  return 0;
}
private void set_subject (string name) {
    _subject  = name;
}
private void set_interviewer (mixed name) {
  if (arrayp (name)) {
    _int  = name;
  }
  else {
    _int = ({ name });
  }
}
string *query_interviewer() {
  return _int;
}
int query_is_interviewer (string name) {
  if (!sizeof (_int)) {
    return 0;
  }
  if (member_array (name, _int) != -1) {
    return 1;
  }
  return 0;
}
string* query_permitted_creators() {
  return copy (_allowed_creators);
}
private void add_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) == -1) {
    _allowed_creators += ({ name });
  }
}
private void remove_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) != -1) {
    _allowed_creators -= ({ name });
  }
}
int add_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator (name)) {
      this_player()->add_failed_mess (this_object(), "Only creators "
        "may be permitted to use the interview room.\n", ({ }));
      return 0;
  }
  add_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N add$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int remove_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  remove_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N remove$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int query_allowed_creators() {
  if (!sizeof (query_permitted_creators())) {
    this_player()->add_failed_mess (this_object(), "Only the domain lord and "
      "the domain deputies are currently permitted to use this room.\n",
      ({ }));
    return 0;
  }
  tell_object (this_player(), sprintf ("In addition to the domain Lord and "
    "the domain deputies, the following creators are permitted "
    "to make use of this room: %s.\n", query_multiple_short
    (query_permitted_creators())));
  return 1;
}
string query_part_two(){
  string temp;
  if (_filename) {
    temp = unguarded ((: read_file (_filename) :));
    if (sizeof (temp)) {
      return temp;
    }
  }
  return sprintf ("Bing!\n\nThank you for your application to the %s domain. "
    "\n\nYour application has been received and is awaiting processing.\n\n"
    "Regards,\n%s.", query_domain(), LORD);
}
int set_part_two(string file) {
  if (!sizeof (file)) {
    printf ("No file given for part two of application.  Aborting.\n");
    return 0;
  }
  if (file_size(file) == -1) {
    printf ("File given for set_part_two() does not exist.  No file set.\n");
    return 0;
  }
  _filename = file;
  return 1;
}
string query_interview_dir(){
  if (sizeof (_interview_dir)) {
    return _interview_dir;
  }
  else {
    return SECURE;
  }
}
int set_interview_dir(string dir) {
  if (!sizeof (dir)) {
    printf ("No directory given for interviews.  Aborting.\n");
    return 0;
  }
  if (file_size(dir) != -2) {
    printf ("Directory given for set_interview_dir does not exist.  "
      "Aborting.\n");
    return 0;
  }
  _interview_dir = dir;
  return 1;
}
int do_query_text(string flag) {
  string temp;
  switch (flag) {
    case "confirmation":
      temp = query_confirmation();
    break;
    case "acceptance":
      temp = query_acceptance();
    break;
    case "rejection":
      temp = query_rejection();
    break;
    default:
      temp = "I'm sorry, there has been an error.\n";
    break;
  }
  tell_object (this_player(), temp);
  return 1;
}
int do_flag(string name, string flag) {
  if (member_array (name, candidates) != -1) {
        candidates -= ({name});
  }
  if (member_array (name, submitted) != -1) {
      submitted -= ({name});
  }
  if (member_array (name, interviewed) != -1) {
      interviewed -= ({name});
  }
  if (flag == "accepted") {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), "Congratulations!",
          query_cc(), query_acceptance(), 0, 0);
    if (member_array (name, accepted) == -1) {
      accepted += ({name});
    }
  }
  else {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), sprintf ("Your application to the %s "
        "domain.", query_domain()), query_cc(), query_rejection(), 0, 0);
    if (member_array (name, rejected) == -1) {
      rejected += ({name});
    }
  }
  this_player()->add_succeeded_mess (this_object(), sprintf ("$N flag$s a "
    "player as %s.\n", flag), ({ }));
  save();
  unguarded ((: write_file (LOG, sprintf ("%s flagged %s as %s "
          "on %s.\n", this_player()->query_name(),
          $(name), $(flag), ctime(time()))) :));
  return 1;
}
void set_rejection(string text) {
  _rejection_text = text;
}
void set_acceptance(string text) {
  _acceptance_text = text;
}
string query_rejection() {
  if (!sizeof (_rejection_text)) {
    return sprintf ("Hello.\n\n"
      "I'm sorry to say that your application to the %s domain has been "
      "unsuccessful.  My apologies that I cannot hire you at this time.  "
      "I will of course keep your details on file should you wish to "
      "apply again in the future.\n\nRegards,\n%s.",
          query_domain(), LORD);
  }
  else {
    return _rejection_text;
  }
}
string query_acceptance() {
  if (!sizeof (_acceptance_text)) {
    return sprintf ("Bing!\n\n"
      "It is my great pleasure to inform you that your application to the %s "
        "domain has been successful.  Congratulations!\n\nBefore being promoted, "
        "you will need to ensure you repay any debts you have.  If you wish "
        "to bequeath your inventory on a fellow player, this must also be "
        "done before you are employed - you won't get a chance once you're "
        "a creator.\n\nPlease send me a mail letting me know when you will "
        "be available for promotion and your orientation lecture.\n\n"
        "Congratulations,\n%s.",query_domain(), LORD);
  }
  else {
    return _acceptance_text;
  }
}
int do_read (string name) {
  string path;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
        ({ }));
    return 0;
  }
  path = query_interview_dir() + name + ".txt";
  if (!file_size (path)) {
    this_player()->add_failed_mess (this_object(), "This document does "
      "not exist.\n", ({ }));
    return 0;
  }
  this_player()->more_string (unguarded ((: read_file ($(path)) :)));
  return 1;
}
string query_cc() {
  if (sizeof (_cc)) {
    return implode (_cc, ",");
  }
  return 0;
}
void set_cc (string *i) {
  _cc = i;
}
int do_list() {
  string *list, text;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You are not permitted "
      "to do this.\n", ({ }));
    return 0;
  }
  else {
    list = get_dir (query_interview_dir());
    list -= ({"candidate_list.o", "candidate_log.txt"});
  }
  list = map (list, (: capitalize ($1) :));
  text = replace (query_multiple_short (list), ({".txt", ""}));
  tell_object (this_player(), sprintf ("The following interviews have been "
    "conducted for the %s domain: %s.\n", query_domain(),
      text));
  this_player()->add_succeeded_mess (this_object(), "$N list$s the completed "
    "interviews.\n", ({ }));
  return 1;
}
string* query_all_applicants() {
  return uniq_array (candidates + interviewed + submitted + accepted + rejected);
}
string* query_interviewed() {
  return interviewed;
}

==================================================
FILE: /lib/std/dom/loader.c
==================================================

string *pre_load;
void create() {
  int i;
  string domain;
  foreach(domain in "/secure/master"->query_domains()) {
    unguarded((: restore_object, "/d/"+ domain + "/loader" :));
    if (!pre_load)
      pre_load = ({ });
    for (i=0;i<sizeof(pre_load);i++) {
      if(pre_load && explode(pre_load[i], "/")[1] != domain)
        printf("invalid " + domain + " preload: " + pre_load[i] +
               "\n");
      else {
        printf(domain +" pre_loading "+pre_load[i]+".\n");
        if (catch(call_other(pre_load[i], "??")))
          call_out("do_load", 0, pre_load[i]);
      }
    }
  }
}
void do_load(string str) {
  call_other(str, "??");
}
int add_pre_load(string domain, string str) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object("/d/" + domain + "/loader");
  return 1;
}
int remove_pre_load(string domain, string str) {
  int i;
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object("/d/" + domain + "/loader");
}
string *query_pre_load(string domain) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return ({ });
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  return pre_load;
}

==================================================
FILE: /lib/std/dom/master.c
==================================================

inherit "/std/dom/base_master";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "";
}

==================================================
FILE: /lib/std/environ/snowball.c
==================================================

#include <tasks.h>
inherit "std/object";
int strength;
void set_strength( int number );
void setup() {
   set_name( "snowball" );
   add_alias( "ball" );
   add_adjective( "snow" );
   set_strength( 99 );
   set_heart_beat( 1 );
}
int query_strength() { return strength; }
void set_strength( int number ) { strength = number; }
string long( string word, int dark ) {
   return "This is a "+ ({
      "very small lump of slush",
      "small and rather soggy lump of snow",
      "small snowball",
      "smallish snowball",
      "vaguely small snowball",
      "decent sized snowball",
      "reasonably sized snowball",
      "snowball for throwing at someone",
      "good snowball for throwing at someone",
      "nice, big snowball, just right for throwing at someone"
   })[ strength / 10 ] +".\n";
}
void init() {
    add_command( "throw", "<direct:object> {at|to} <indirect:object>" );
}
void heart_beat() {
   strength--;
   if ( strength < 1 ) {
      set_heart_beat( 0 );
      move( "/room/rubbish" );
   }
}
private object find_person(object ob) {
   if (living(ob)) {
      return ob;
   } else {
      while (ob && !living(ob)) {
         ob = environment(ob);
      }
      if (ob) {
         return ob;
      }
   }
   return 0;
}
int do_throw( object *obs ) {
   object per;
   int chance;
   per = find_person(obs[0]);
   if (per) {
      if (per != obs[0]) {
         chance = 0;
      } else {
         chance = 30;
      }
      if (per == this_player()) {
         per->add_effect( "/std/effects/external/snowball", strength );
      } else {
         switch (TASKER->compare_skills(this_player(),
                                        "fighting.combat.range.thrown",
                                        per,
                                        "fighting.combat.dodging.range",
                                        chance,
                                        TM_FREE,
                                        TM_FREE)) {
         case OFFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to throw "
                                       "snowballs at people.\n%^YELLOW%^");
         case OFFWIN :
            per->add_effect( "/std/effects/external/snowball", strength );
            add_succeeded_mess( ({ "$N throw$s $D at $I and hit$s!\n",
                "$N throw$s $D at $I and hits!\n" }),  ({ obs[0] }) );
            break;
         case DEFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to dodge "
                                       "snowball thrown by people.\n%^YELLOW%^");
         case DEFWIN :
            add_succeeded_mess( "$N throw$s $D at $I and miss$es!\n",
                                   ({ obs[0] }) );
            break;
         }
      }
   } else {
      add_succeeded_mess( "$N throw$s $D at $I.\n", ({ obs[ 0 ] }) );
   }
   move( "/room/rubbish" );
   return 1;
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "strength" : strength
   ]);
}
void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   strength = map[ "strength" ];
}

==================================================
FILE: /lib/std/environ/snowman.c
==================================================

#include <move_failures.h>
inherit "/std/object";
private int _call_out_handle;
void setup() {
    reset_get();
    if ( clonep() ) {
        _call_out_handle = call_out("die",400);
    }
}
void set_type(string type) {
    set_name(type);
    set_short(type);
    set_long("A wonderful " + type + " with glowing eyes made of coal and twigs "
      "for ears.\n");
    add_extra_look( this_object() );
}
string extra_look( object ob ) {
    int time_left;
    if ( !_call_out_handle ) {
        return "";
    }
    time_left = find_call_out( _call_out_handle );
    debug_printf( "time left is %d\n", time_left );
    if ( time_left > 300 || time_left < 0 ) {
        return "";
    }
    return "It is " + ({ "mostly", "half", "slightly" })[time_left/100] +
        " melted.\n";
}
void die() {
    string noun;
    switch( environment( this_object() )->query_property( "location" ) ) {
    case "inside":
        noun = "floor";
        break;
    case "outside":
        noun = "ground";
        break;
    case "underwater":
        noun = "seabed";
        break;
    default:
        noun = "floor";
        break;
    }
    tell_room( environment( this_object() ),
      the_short() + " $V$0=melts,melt$V$ into the " + noun + ".\n");
    if ( this_object()->move( "/room/rubbish" ) != MOVE_OK ) {
        dest_me();
    }
}

==================================================
FILE: /lib/std/environ/weather.c
==================================================

#include <config.h>
inherit "std/object";
#include "climate.h"
#define FILE_NAME "/save/environ/weather"
#define HOME "/obj/handlers/weather_room"
#define MAX_DIST 100
#define YEAR 60
#define DAY 60
#define SPEED 40
mixed *coldarr,
      *cloudarr,
      *rainarr;
int timeofyear,
    mooncycle,
    moonoff,
    timeofday,
    intensity;
int distance(mixed *co_ord1,mixed *co_ord);
int cloud_index(object env);
int rain_index(object env);
int temperature_index(object env);
string cloud_string(object env);
string rain_string(object env);
string temperature_string(object env);
void setup() {
  set_name("weather");
  set_short("weather controller extrodinare");
  set_long("The weather controller, at least this one is always right!\n");
  cloudarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  rainarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  coldarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  intensity = 100;
  restore_object(FILE_NAME);
  call_out("update_low",SPEED);
  move("bing");
}
move(arg) {
  ::move(HOME);
}
mixed *query_cold() { return coldarr; }
mixed *query_rain() { return rainarr; }
mixed *query_cloud() { return cloudarr; }
int query_moon() { return mooncycle; }
string query_moon_string(object env) {
  int bing;
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 0;
  return ({ "full moon",
            "waning three quarter moon",
            "waning half moon",
            "waning quarter moon",
            "waning cresent moon",
            "new moon",
            "waxing cresent moon",
            "waxing quarter moon",
            "waxing half moon",
            "waxing three quarter moon" })[mooncycle];
}
int distance(mixed *co_ord1, mixed *co_ord2) {
  int off;
  if (!pointerp(co_ord1) || !pointerp(co_ord2))
    return 0;
  if (co_ord1[0]>co_ord2[0])
    off = co_ord1[0] - co_ord2[0];
  else
    off = co_ord2[0] - co_ord1[0];
  if (co_ord1[1]>co_ord2[1])
    off += co_ord1[1] - co_ord2[1];
  else
    off += co_ord2[1] - co_ord1[1];
  return off;
}
int query_season() { return timeofyear/15; }
int query_time_of_year() { return timeofyear; }
int query_time_of_day() { return timeofday; }
int query_day(object env) {
  int bing, bit;
  if (!env) {
    load_object(CONFIG_START_LOCATION);
    env = find_object(CONFIG_START_LOCATION);
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  bit = (DAY/2)-(timeofyear-(YEAR/2))/(YEAR/10);
  if (bing>bit)
    return 0;
  if (bit < 10)
    return bit;
  return -(bing - bit);
}
int query_darkness(object env) {
  int bing, per, i;
  per = -cloud_index(env);
  if (per <-100)
    per = -100;
  if (per > 100)
    per = 100;
  if ((i=query_day(env))) {
    i *= 20;
    if (i>100)
      i = 100;
    return 50+(per+100)*150*i/20000;
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 15+(per+100)*30/200;
  if (timeofday<0) timeofday += DAY;
  i = mooncycle -5;
  if (i<0)
    i = -i;
  return 30+(per+100)*14*i/200;
}
string weather_string(object env) {
  return temperature_string(env)+" with "+cloud_string(env)+
         rain_string(env);
}
int query_raining(object env) {
  int cloud,rain;
  if (temperature_index(env)/(100/7)<2) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_hailing(object env) {
  int cloud, rain;
  if (temperature_index(env)/(100/7)==2) {
    cloud = cloud_index(env);
    if (cloud <=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain <=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_snowing(object env) {
  int cloud,rain;
  if ((temperature_index(env)/(100/7))>=3) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = cloud_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
string rain_string(object env) {
  int cloud, rain, temp;
  string tempstr1,tempstr2;
  cloud = cloud_index(env);
  rain = rain_index(env);
  if (cloud<=0) return "";
  if (cloud-rain<=0) return "";
  temp = temperature_index(env)/(100/7);
  if (temp>3) temp = 3;
  if (temp<-3) temp = -3;
  tempstr1 = ({ "very hot ",
                "hot ",
                "warm ",
                "nice ",
                "cold ",
                "",
                "" })[temp+3];
  tempstr2 = ({ " rain",
                " rain",
                " rain",
                " rain",
                " rain",
                " hail",
                " snow" })[temp+3];
  cloud = (cloud-rain) / 20;
  if (cloud>5) cloud = 5;
  return "\n"+capitalize(tempstr1 + ({ "very light",
                      "light",
                      "medium",
                      "heavy",
                      "very heavy" }) [cloud]+tempstr2);
}
string temperature_string(object env) {
  int inten;
  inten = temperature_index(env);
  inten /= 10;
  if (inten>10)
    inten = 10;
  if (inten<-10)
    inten = -10;
  return ({ "Its one of those baking eggs on the pavement days",
            "So hot that the sun feels like its right next door",
            "Damn hot",
            "Very hot",
            "Hot",
            "Hot",
            "Reasonably hot",
            "Very warm",
            "Warm",
            "Pleasantly warm",
            "Average temerature",
            "A little chilly",
            "A slight nip in the air",
            "Chilly",
            "Very chilly",
            "Cold",
            "Cold",
            "Very cold",
            "Damn cold",
            "Incredibly cold",
            "Freezing cold" })[inten+10];
}
string cloud_string(object env) {
  int off;
  off = cloud_index(env) / 20;
  if (off>5) off = 5;
  if (off<-5) off = -5;
  return ({ "a beatifully clear sky",
            "a few high level sirius clouds",
            "scattered puffy clouds",
            "very thin complete cloud cover",
            "light cloud cover",
            "medium cloud cover",
            "dense cloud cover",
            "packed cloud cover",
            "packed cloud cover",
            "heavy black clouds",
            "thick heavy clouds",
         })[off+5];
}
int temperature_index(object env) {
  int off,i;
  mixed clim, *co_ord;
  for (i=0;i<sizeof(coldarr);i++)
    off += (distance((mixed *)env->query_co_ord(), coldarr[i]) % (MAX_DIST*2));
  off = off / sizeof(coldarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_TEMP];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0 - off;
  co_ord = (mixed *)env->query_co_ord();
  if (!co_ord)
    co_ord = ({ 0, 0, 0 });
  return (off + (timeofyear - (YEAR/2)) + (timeofday - (DAY/2)) + co_ord[2]);
}
int cloud_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(cloudarr);i++)
    off += (distance((mixed *)env->query_co_ord(), cloudarr[i]) % (MAX_DIST*2));
  off = off / sizeof(cloudarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_CLOUD];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0-off;
  return (off + (timeofyear - (YEAR/2)));
}
int rain_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(rainarr);i++)
    off += (distance((mixed *)env->query_co_ord(), rainarr[i]) % (MAX_DIST*2));
  off = off / sizeof(rainarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_RAIN];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= MAX_DIST/2;
  off = 0-off;
  return off;
}
void update_low() {
  int i;
  timeofday++;
  if (timeofday>DAY) {
    timeofday = 0;
    timeofyear++;
    mooncycle++;
    if (mooncycle %2) {
      moonoff += 1;
      moonoff = moonoff % (DAY/2);
    }
    timeofyear = timeofyear % YEAR;
    mooncycle = mooncycle % 10;
    save_object(FILE_NAME);
  }
  for (i=0;i<sizeof(rainarr);i++) {
    rainarr[i][0] += random(3)-1;
    rainarr[i][0] = rainarr[i][0] % (MAX_DIST*2);
    rainarr[i][1] += random(3)-1;
    rainarr[i][1] = rainarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(cloudarr);i++) {
    cloudarr[i][0] += random(3)-1;
    cloudarr[i][0] = cloudarr[i][0] % (MAX_DIST*2);
    cloudarr[i][1] += random(3)-1;
    cloudarr[i][1] = cloudarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(coldarr);i++) {
    coldarr[i][0] += random(3)-1;
    coldarr[i][0] = coldarr[i][0] % (MAX_DIST*2);
    coldarr[i][1] += random(3)-1;
    coldarr[i][1] = coldarr[i][1] % (MAX_DIST*2);
  }
  intensity += random(3)-1;
  if (intensity<50)
    intensity=50;
  if (intensity>300)
    intensity=300;
  call_out("update_low",SPEED);
}
void dest_me() {
  save_object(FILE_NAME);
  ::dest_me();
}

==================================================
FILE: /lib/std/environ/weather_room.c
==================================================

inherit "std/room";
mixed leverarr;
reset (arg) {
  if (arg) return;
  set_short("The weather room");
  set_long("The weather control center for the entire mud. On the floor should\n"+
           "be the controller itself, scattered around the room are hundred of impresive\n"+
           "flashing lights, dials and levers. You get the feeling however that they dont\n"+
           "actually do anything.\n");
  set_light(1);
  seteuid("pinkfish");
  add_property("inside");
  add_exit("pinkfish","d/Fish/pinkfish/workroom");
  add_item("lights","What did I say? there are lots of them and they are insesantly\n"+
           "flashing.\n");
  add_item("dials","Large dials with all sort of things on them. One you can see says\n"+
           "'Colour of spring', it is currently pointing at purple.\n");
  add_item("levers",
           "The levers are large multicolour protuberances which are scattered around the\n"+
           "room in random profusion.\n");
  leverarr = ({ ({ "blue",
       "The rooms spins and a small bit of printed paper falls from the\n"+
       "Weather controller saying:\n#query_rain" }),
                ({ "white",
       "The ground heaves in a major convulsion and a mound of paper falls onto\n"+
       "You from the ceiling saying:\n#query_cloud" }) });
}
init() {
  ::init();
  add_action("pull","pull");
  add_action("push","push");
}
pull(str) {
  int i;
  string type,rand;
  object lever, weather;
  if (str == "lever" || str == "levers")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,rand)) {
      notify_fail("You have to pull a lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++) {
      if (leverarr[i][0] == type) {
        lever = leverarr[i];
        break;
      }
    }
  }
  if (!lever) {
    notify_fail("You need to choose and existing lever");
    return ;
  }
  weather = present("weather",this_object());
  if (!weather) {
    notify_fail("Opps the weather controller does not exist.\n");
    return 0;
  }
  sscanf(lever[1],"%s#%s",type,rand);
  write(type);
  this_player()->print_object(call_other(weather,rand));
  return 1;
}
push(str) {
  object lever;
  int i;
  string type,bing;
  if (str == "levers" && str == "lever")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,bing)) {
      notify_fail("You must push an existing lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++)
      if (type == leverarr[i][0]) {
        lever = leverarr[i];
        break;
      }
  }
  if (!lever) {
    notify_fail("An existing lever could be usefull...\n");
    return 0;
  }
  write("You huff and you puff, but you just cant push that lever.\n");
}
# Total Tokens: 24383
# Total Files Merged: 15
# Total Characters: 81325

