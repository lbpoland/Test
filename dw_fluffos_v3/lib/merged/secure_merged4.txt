# Total Tokens: 21917
# Total Files Merged: 36
# Total Characters: 73145

odified_efuns.c
==================================================

#define MAX_SIZE 50000
#define LIV "/obj/handlers/livings"
#define LOG_NAME(X) ((X[0] == '/') ? X : "/log/"+X)
#include <login.h>
#include <player_handler.h>
#include <playtesters.h>
#if !efun_defined(base_name)
inherit "/secure/simul_efun/base_name";
#endif
string back_trace();
#if !efun_defined(event)
void event(mixed,string,mixed ...);
#endif
#if !efun_defined(add_action)
int _notify_fail(string);
int living(object ob);
object find_player(string);
#endif
private nosave int _callouttime;
private nosave mapping _calloutfunc = ([]);
private nosave mapping _log_file_info = ([ ]);
private nosave int _log_file_flush_id;
private nosave mapping _loggers = ([ ]);
private nosave string _reset_eval_message="simul_efun updated";
private nosave int _reset_eval_message_count=1;
private nosave int _in_reference_allowed;
#define DELAY_LOG_FLUSH 15
varargs void say(string str, mixed avoid)
{
  if (!pointerp(avoid)) {
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  } else {
    avoid += ({ this_player(), previous_object() });
  }
  if (!environment(previous_object())) {
    if(this_player() && environment(this_player())) {
      event(environment(this_player()), "say", str, avoid);
    } else {
      event(previous_object(), "say", str, avoid);
    }
  } else {
    if (environment(environment(previous_object()))) {
      event(environment(environment(previous_object())), "say", str, avoid);
    } else {
      event(environment(previous_object()), "say", str, avoid);
    }
  }
}
varargs void tell_room(mixed ob, string str, mixed avoid) {
  if (!ob || !(objectp(ob) || stringp(ob))) {
    return ;
  }
  if (stringp(ob)) {
    ob = load_object(ob);
  }
  event(ob, "say", str, avoid);
}
void tell_object(object ob, string str) {
  if (objectp(ob)) {
    ob->do_efun_write( str );
  }
}
#if !efun_defined(reference_allowed)
varargs int reference_allowed(object referree, mixed referrer) {
  string referrer_name;
  string *allowed;
  object referrer_obj;
  int ret, invis;
  if(!referree)
    return 0;
  invis = (int)referree->query_invis();
  if(!invis || !referree->query_creator() || _in_reference_allowed)
    return 1;
  _in_reference_allowed = 1;
  if(!referrer)
    referrer = this_player();
  if (objectp(referrer)) {
    if(!referrer || (referree == referrer)) {
      _in_reference_allowed = 0;
      return 1;
    }
    referrer_name = referrer->query_name();
    referrer_obj = referrer;
  } else if (stringp(referrer)) {
    referrer_name = referrer;
    referrer_obj = find_player(referrer);
  } else {
    _in_reference_allowed = 0;
    return 0;
  }
  if(!referrer_name) {
    _in_reference_allowed = 0;
    return 1;
  }
  allowed = (string *)referree->query_allowed();
  if ( pointerp( allowed ) ) {
    if ( member_array( referrer_name, allowed ) != -1 ||
         (member_array("playtesters", allowed) != -1 &&
          PLAYTESTER_HAND->query_playtester(referrer_name))) {
      _in_reference_allowed = 0;
      return 1;
    }
  }
  switch(invis) {
  case 3 :
    ret = master()->high_programmer( referrer_name );
    break;
  case 2 :
    ret = master()->query_lord( referrer_name );
    break;
  case 1 :
    if(referrer_obj)
      ret = referrer_obj->query_creator();
    else
      ret = PLAYER_HANDLER->test_creator( referrer_name );
    break;
  default :
    ret = 1;
  }
  _in_reference_allowed = 0;
  return ret;
}
#endif
object find_living( string word ) {
   object thing;
   if ( !word ) {
      return 0;
   }
#if efun_defined(find_living)
   thing = efun::find_living( word );
#else
   thing = LIV->find_living( word );
#endif
   if ( !thing || !this_player() ) {
      return thing;
   }
   if ( reference_allowed( thing ) ) {
      return thing;
   }
   return 0;
}
object find_player( string word ) {
   object thing;
   if ( !word ) {
      return 0;
   }
#if efun_defined(find_player)
   thing = efun::find_player( word );
#else
   thing = LIV->find_player( word );
#endif
   if ( !thing || !this_player() ) {
      return thing;
   }
    if ( reference_allowed( thing ) && thing->query_property( "player" ) ) {
      return thing;
   }
   return 0;
}
object *users() {
   if ( !this_player() || ( previous_object() == master() ) ||
         ( previous_object() == find_object( "/obj/shut" ) ) ||
         ( previous_object() == find_object( "/obj/handlers/livings") ) ) {
      return efun::users();
   }
   return filter( efun::users(), (: $1 && reference_allowed($1) :) );
}
object *named_livings() {
#if efun_defined(named_livings)
  return filter( efun::named_livings(), (: reference_allowed :) );
#else
  return filter( LIV->named_livings(), (: reference_allowed :) );
#endif
}
object *children(string name) {
   if (strsrch(name, "global/lord") != -1) {
      return filter( efun::children(name), (: reference_allowed :) );
   }
   return efun::children(name);
}
void user_event( mixed from, mixed first, mixed args ... ) {
   if ( stringp( from ) ) {
      call_other( efun::users(), "event_"+ from, previous_object(),
            first, args ... );
   } else {
      if ( objectp( from ) && stringp( first ) ) {
         call_other( efun::users(), "event_"+ first, from, args ... );
      }
   }
}
mixed unguarded(function f);
void flush_log_files() {
   string fname;
   string data;
   int size;
   _log_file_flush_id = 0;
   foreach (fname, data in _log_file_info) {
     size = file_size(LOG_NAME(fname));
      if (size > MAX_SIZE) {
        if ( file_size( LOG_NAME(fname) + ".5" ) >= 0 ) {
          unguarded((: rm, LOG_NAME(fname)+".5" :));
        }
        if ( file_size( LOG_NAME(fname) + ".4" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".4", LOG_NAME(fname)+".5" :));
        }
        if ( file_size( LOG_NAME(fname) + ".3" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".3", LOG_NAME(fname)+".4" :));
        }
        if ( file_size( LOG_NAME(fname) + ".2" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".2", LOG_NAME(fname)+".3" :));
        }
        if ( file_size( LOG_NAME(fname) + ".1" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".1", LOG_NAME(fname)+".2" :));
        }
        unguarded((: rename, LOG_NAME(fname), LOG_NAME(fname)+".1" :));
      }
      map_delete(_log_file_info, fname);
      if(size == -2)
        fname = fname + "BAD";
      unguarded((: write_file, LOG_NAME(fname), data :));
   }
   _log_file_info = ([ ]);
}
varargs void log_file(string name, string fmt, mixed *args ...) {
  if ( strlen( fmt ) > 8000 ) {
    fmt = fmt[ 0 .. 7999 ] +"\n\nPlus more...\n\n";
  }
  _loggers[name] = base_name(previous_object());
  fmt = terminal_colour(fmt, ([]));
  if (!_log_file_flush_id) {
     _log_file_flush_id = call_out((: flush_log_files :), DELAY_LOG_FLUSH);
  }
  if (!_log_file_info[name]) {
     _log_file_info[name] = "";
  }
  if (sizeof(args)) {
    _log_file_info[name] += sprintf(fmt, args ...);
  } else {
    _log_file_info[name] += fmt;
  }
}
mapping query_loggers() { return _loggers; }
#ifdef MUD_NAME
string mud_name() {
  return capitalize(MUD_NAME);
}
#endif
void cat(string file, int start_line, int number) {
  string bing;
  bing = read_file(file, start_line, number);
  if (bing) {
    printf("%s", bing[0..5000]);
  }
}
#ifdef NEW_DRIVER
int wizardp(mixed arg) {
  if (!objectp(arg)) {
    return 0;
  }
  return interactive(arg) && arg->query_creator();
}
#endif
int exec(object to, object from) {
  string s;
  object prev;
  if(!objectp(to) || !objectp(from))
    return 0;
  if (file_name(previous_object())[0..12] == "/secure/login" ||
      file_name(previous_object())[0..13] == "/secure/nlogin") {
    return efun::exec(to, from);
  }
  s = "";
  if (prev = this_player()) {
    s += "TP:"+ sprintf("%8s ", prev -> query_name());
  }
  if (prev = this_player(1)) {
    s += "TP1:"+ sprintf("%8s ", prev -> query_name());
  }
  s += "PO:"+ sprintf("%8s ", file_name(previous_object()));
  log_file("ILLEGAL", "Exec: %-40s : %s\n", s, ctime( time() ) );
  return 0;
}
varargs int call_out(mixed fun, int delay, mixed *args ...) {
  string func;
  if (_callouttime != time()) {
    _callouttime = time();
    _calloutfunc = ([]);
  }
  if(delay == 0) {
    func = functionp(fun)?""+functionp(fun):fun +
      file_name(previous_object());
    if(_calloutfunc[func] == -1)
      delay = 2;
    else if(++_calloutfunc[func] > 100) {
      delay = 2;
      _calloutfunc[func] = -1;
      if ( stringp(previous_object()->query_name())) {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), previous_object()->query_name(), fun);
      } else {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), file_name(previous_object()), fun);
      }
    }
  }
  return evaluate(bind((: efun::call_out($(fun), $(delay), $(args) ... ) :)
                       , previous_object()));
}
string query_verb() {
   string verb;
#if efun_defined(query_verb)
   verb = efun::query_verb();
#else
   verb = "";
#endif
   if ( ( verb != "" ) || !objectp( this_player() ) ) {
      return verb;
   }
   return (string)this_player()->query_current_verb();
}
int strcasecmp(string str1, string str2) {
  return strcmp(lower_case(str1), lower_case(str2));
}
#define COMPAT_TAIL
#ifdef COMPAT_TAIL
int tail(string fname) {
   int offset = file_size(fname);
   string str;
   if (offset < 0) {
      return 0;
   }
   offset -= 54 * 20;
   if (offset < 0) {
      offset = 0;
   }
   str = read_bytes(fname, offset, 1080);
   if (!str) {
      return 0;
   }
   if (offset) {
      str = str[strsrch(str, "\n")+1..];
   }
   write(str);
   return 1;
}
#else
varargs string tail(string fname, int nlines) {
  int chunk = nlines * 80;
  int offset = file_size(fname);
  int num_nl, p, skip;
  string str = "";
  reset_eval_cost();
  while (offset > 0 && num_nl <= nlines) {
    num_nl = 0;
    offset -= chunk;
    if (offset < 0) {
      chunk += offset;
      offset = 0;
    }
    str = read_bytes(fname, offset, chunk) + str;
    p = -1;
    while (p < sizeof(str)-1 && p = member_array('\n', str, p+1))
      num_nl++;
  }
  skip = num_nl - nlines;
  p = -1;
  while (skip--)
    p = member_array('\n', str, p+1);
  return str[p..];
}
#endif
void write(mixed str) {
  if (!this_player()) {
    return ;
  }
  if (intp(str)) {
    str = ""+str;
  }
  this_player()->do_efun_write(str);
}
int notify_fail( mixed stuff ) {
   if (!this_player())  {
      return 0;
   }
   if ( functionp( stuff ) ) {
      stuff = evaluate( stuff );
   }
   if ( !stringp( stuff ) ) {
      return 0;
   }
   this_player()->print_messages();
   stuff = (string)this_player()->convert_message( stuff );
   stuff = (string)this_player()->fit_message( stuff );
   stuff = (string)this_player()->fix_string( stuff );
#if efun_defined(notify_fail)
   return efun::notify_fail( stuff );
#else
   return _notify_fail( stuff );
#endif
}
varargs string replace(string str, mixed bing, string rep) {
  int i;
  if (pointerp(bing)) {
    for (i=0;i<sizeof(bing);i+=2) {
      if (stringp(bing[i]) && stringp(bing[i+1])) {
        str = replace_string(str, bing[i], bing[i+1]);
      }
    }
    return str;
  }
  if(!stringp(str) || !stringp(rep))
    return str;
  return replace_string(str, bing, rep);
}
string cap_words(string words)  {
  return implode(map(explode(words, " "), (: capitalize :)), " ");
}
mixed *uniq_array(mixed *arr){
  return keys(allocate_mapping(arr, 1));
}
varargs void shout( string words, object avoid ) {
   object thing, *things;
   things = efun::users();
   foreach( thing in things ) {
      if ( thing && ( thing != avoid ) && !thing->check_earmuffs( "shout" ) ) {
         if ( thing != this_player() ) {
            thing->event_say( previous_object(), words, ({ }) );
         }
      }
   }
}
nosave int eval_cost_time;
nosave int eval_cost_real_time;
nosave string reset_eval_message;
nosave object eval_ob;
void reset_eval_cost() {
  int i;
  string *funs, stack;
  object *obs;
  if(time() == eval_cost_time && previous_object() == eval_ob) {
    if(real_time() - eval_cost_real_time > 5) {
      stack = "";
      obs = call_stack(1);
      funs = call_stack(2);
      for(i=0; i<sizeof(obs); i++) {
        if(clonep(obs[i]))
          stack += base_name(obs[i]) + "#" + obs[i]->query_name();
        else
          stack += base_name(obs[i]);
        stack += "->" + funs[i] + "()\n";
      }
      reset_eval_message =
        sprintf("%s uses reset_eval_cost to last %d seconds\n%s",
                query_multiple_short(map(previous_object(-1),
                                         (: file_name($1) :))),
                real_time() - eval_cost_real_time,
                stack);
    }
  } else {
    if(reset_eval_message)
      log_file("GARBAGE", sprintf("%s %s\n", ctime(eval_cost_time),
                                  reset_eval_message));
    reset_eval_message = 0;
    eval_cost_time = time();
    eval_cost_real_time = real_time();
    eval_ob = previous_object();
  }
  efun::reset_eval_cost();
}
#if !efun_defined(event)
varargs int member_array(mixed item, mixed arr, int start, int flag){
  if(!arr || !arrayp(arr))
    return -1;
  if(!flag)
    return efun::member_array(item, arr, start);
  if(stringp(item)) {
    string *tmp;
    tmp = map(arr, (:$1[0..$(strlen(item)-1)]:));
    return efun::member_array(item, tmp, start);
  }
}
void event(mixed ob, string func, mixed rest ...){
  object origin = previous_object(), *bing;
  string name = "event_" + func;
  if(arrayp(ob)){
    ob = filter(ob, (:$1:));
    call_other(ob, name, origin, rest ...);
    return;
  } else if(!objectp(ob)) {
    return;
  }
  call_other(ob, name, origin, rest ...);
  bing = all_inventory(ob);
  bing -= ({origin});
  bing = filter(bing, (:$1:));
  call_other(bing, name, origin, rest ...);
}
#endif
#if !efun_defined(add_action)
void move_object(mixed ob){
  object tp, *obs, bing;
  if(stringp(ob)) {
    ob = find_object(ob);
  }
  evaluate(bind((: efun::move_object($(ob)):), previous_object()));
  if(ob->no_init()){
    return;
  }
  tp = this_player();
  if(living(previous_object())){
    efun::set_this_player(previous_object());
    ob->init();
    (all_inventory(ob) - ({previous_object()}))->init();
  }
  obs = filter(all_inventory(ob),
               (:living($1) && $1 != $(previous_object()):));
  foreach(bing in obs){
    efun::set_this_player(bing);
    previous_object()->init();
  }
  if(living(ob)){
    efun::set_this_player(ob);
    previous_object()->init();
  }
  efun::set_this_player(tp);
}
#endif
#if efun_defined(db_exec)
varargs mixed db_exec(int fd, string fmt, mixed *args ...) {
  mixed ret;
  int starttime = real_time();
  if (!sizeof(args)) {
    ret = evaluate(bind((:efun::db_exec, fd, fmt:), previous_object()));
  } else {
    ret = evaluate(bind((:efun::db_exec, fd, sprintf(fmt, args ...):), previous_object()));
  }
  if((real_time() - starttime) > 1)
    this_object()->log_file("GARBAGE", "db_exec in %O, time: %d\n",
                            previous_object(), real_time() - starttime);
  return ret;
}
#else
varargs int db_connect(mixed *args ...){
  error("No database installed");
}
varargs string db_exec(int fd, string fmt, mixed *args ...) {
  return "No database installed";
}
mixed *db_fetch(int fd, int row){
  error("No database installed");
}
void db_close(int fd){}
#endif
void shutdown(int bing){
  string thing = base_name(previous_object());
  if(thing != "/obj/shut" && thing != "/global/lord"){
    unguarded((:write_file, "/d/admin/log/SHUTDOWN.log",
               sprintf("value %d\n%s", bing, back_trace()):));
  }
  efun::shutdown(bing);
}
#if !efun_defined(real_time)
int real_time(){return time();}
#endif
#if efun_defined(memory_summary)
string memory_summary() {
   return "Not on this mud...\n";
}
#endif
#if efun_defined(debug_info)
string debug_info( int operation, object ob ) {
  string path;
  if ( operation != 2 )
    return efun::debug_info( operation, ob );
  path = base_name( ob );
  path += ".c";
  if ( !master()->valid_read( path,
                              this_player()->query_name(), "debug_info" ) ) {
    this_object()->unguarded((:write_file, "/d/admin/log/DEBUG_INFO.log",
                sprintf( "%s: %s tried to debug %s.\n", ctime( time() ),
                         this_player()->query_name(),
                         base_name( ob ) ) :));
    return "You are not authorised to do that.\n";
  }
  if ( interactive( ob ) && !this_player()->query_lord() &&
       ob != this_player()) {
    this_object()->unguarded((:write_file, "/d/admin/log/DEBUG_INFO.log",
                sprintf( "%s: %s tried to debug %s.\n", ctime( time() ),
                         this_player()->query_name(),
                         ob->query_name() ) :));
    return "Only Lords can dump an interactive object.\n";
  }
  return efun::debug_info( operation, ob );
}
#endif
void input_to(mixed fun, mixed flag, mixed args ...){
  function f = function(string input, object ob, mixed fun, mixed args){
    int t = real_time();
    if(functionp(fun))
      evaluate(fun, input, args...);
    else
      evaluate(bind((:call_other, ob, fun, input, args ...:), ob));
    if((real_time() - t) > 1) {
      if(fun == "logon2")
        input = "******";
      this_object()->log_file("GARBAGE", "input_to %O (%O) in %O, time: %d\n",
                              fun, input,
                              ob, real_time() - t);
    }
  };
  if(!args)
    args = ({});
  if(!intp(flag)){
    args = ({flag}) + args;
    flag = 0;
  }
  efun::input_to(f, flag, previous_object(), fun, args);
}
#if 0
private nosave function _wrap = function(mixed func, mixed *args) {
  int t = real_time();
  if(stringp(func)) {
    call_other(this_object(), func, args ...);
  } else if(functionp(func)) {
    evaluate(func, args ...);
  }
  if((real_time() - t) > 1) {
    "/secure/simul_efun"->log_file("GARBAGE", "object: %O function: %O time: %d\n", this_object(), func, real_time()-t);
  }
};
varargs int call_out(mixed fun, int delay, mixed *args ...) {
  string func;
  function wrap;
  wrap = bind(_wrap, previous_object());
  if (_callouttime != time()) {
    _callouttime = time();
    _calloutfunc = ([]);
  }
  if(delay == 0) {
    func = functionp(fun)?""+functionp(fun):fun +
      file_name(previous_object());
    if(_calloutfunc[func] == -1)
      delay = 2;
    else if(++_calloutfunc[func] > 100) {
      delay = 2;
      _calloutfunc[func] = -1;
      if ( stringp(previous_object()->query_name())) {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), previous_object()->query_name(), fun);
      } else {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), file_name(previous_object()), fun);
      }
    }
  }
  return evaluate(bind((: efun::call_out($(wrap), $(delay), $(fun), $(args)) :)
                       , previous_object()));
}
#endif

==================================================
FILE: simul_efun/multiple_short.c
==================================================

varargs string query_multiple_short( mixed *args, string type,
                                     int no_dollars, int quiet,
                                     int dark ) {
   int i;
   string func;
   string ret;
   if (no_dollars && sizeof(args) && objectp(args[0]) && undefinedp(dark) &&
       this_player() && environment(this_player())) {
      dark = this_player()->check_dark(environment(this_player())->query_light());
      if (dark) {
         return "some objects you cannot make out";
      }
   }
   args = copy(args);
   if ( !type ) {
      type = "a";
   }
   for ( i = 0; i < sizeof( args ); i++ ) {
      if ( !objectp( args[ i ] ) ) {
         break;
      }
   }
   func = type + "_short";
   if ( i == sizeof( args ) && !no_dollars) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         args[ i ] = call_other(args[ i ], func, quiet);
      }
      return "$M$"+ implode( args, "" ) +"$M$";
   }
   for ( i = 0; i < sizeof( args ); i++ ) {
      if ( objectp( args[ i ] ) ) {
         args[ i ] = call_other(args[ i ], func, quiet);
      } else if ( pointerp( args[ i ] ) ) {
         args[ i ] = "$"+ type +"_short:"+ file_name( args[ i ][ 1 ] ) +"$";
      }
   }
   i = sizeof( args );
   switch ( i ) {
      case 0 :
         return "";
      case 1 :
         ret = args[ 0 ];
         break;
      default :
         ret = implode( args[ 0 .. i - 2 ], ", " ) +" and "+ args[ i - 1 ];
         break;
   }
   if (no_dollars) {
      if (this_player()) {
         return this_player()->convert_message(ret);
      } else {
         return "/global/player"->convert_message(ret);
      }
   }
   return ret;
}

==================================================
FILE: simul_efun/mxp.c
==================================================

varargs string mxp_tag(string tag, string output, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
      return "MXP<" + tag + "MXP>" + output + "MXP</" + tag + "MXP>";
   }
#endif
   return output;
}
varargs string mxp_tag_args(string tag, string args, string output, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
      return "MXP<" + tag + " " + args + "MXP>" + output + "MXP</" + tag + "MXP>";
   }
#endif
   return output;
}
varargs string mxp_choice(string non_mxp, string mxp, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
      return mxp;
   }
#endif
   return non_mxp;
}
varargs string mxp_secure(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[6z", 27);
   }
#endif
   return "";
}
varargs string mxp_open(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[5z", 27);
   }
#endif
   return "";
}
varargs string mxp_next_secure(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[4z", 27);
   }
#endif
   return "";
}
varargs string mxp_expire(string category, object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return "MXP<EXPIRE " + category + "MXP>";
   }
#endif
   return "";
}

==================================================
FILE: simul_efun/obj_parser.c
==================================================

#include <obj_parser.h>
#if !efun_defined(query_multiple_short)
inherit "/secure/simul_efun/multiple_short";
#endif
#include <playtesters.h>
#ifdef DEBUG
#define TRACE(ARG) tell_creator("pinkfish", ARG + "\n")
#else
#define TRACE(ARG)
#endif
#define EVERY_NUM 18729487
private nosave mapping _ordinals;
private nosave mapping _counters;
private nosave mapping _fractions;
void tell_creator(string player, string text, mixed arg ...);
#if !efun_defined(living)
int living (object);
#endif
class obj_match match_objects_in_environments( string input, mixed env_list,
                                      int type, object player);
void create()
{
   _ordinals = ([
      "any" : 1,
      "a" : 1,
      "an" : 1,
      "the" : 1,
      "1st" : 1, "first" : 1,
      "2nd" : 2, "second" : 2,
      "3rd" : 3, "third" : 3,
      "4th" : 4, "fourth" : 4,
      "5th" : 5, "fifth" : 5,
      "6th" : 6, "sixth" : 6,
      "7th" : 7, "seventh" : 7,
      "8th" : 8, "eighth" : 8,
      "9th" : 9, "ninth" : 9,
      "10th" : 10, "tenth" : 10,
      "last" : -1
   ]);
   _counters = ([
      "1" : 1, "one" : 1,
      "2" : 2, "two" : 2,
      "3" : 3, "three" : 3,
      "4" : 4, "four" : 4,
      "5" : 5, "five" : 5,
      "6" : 6, "six" : 6,
      "7" : 7, "seven" : 7,
      "8" : 8, "eight" : 8,
      "9" : 9, "nine" : 9,
      "10" : 10, "ten" : 10,
      "11" : 11, "eleven" : 11,
      "12" : 12, "twelve" : 12,
      "13" : 13, "thirteen" : 13,
      "14" : 14, "fourteen" : 14,
      "15" : 15, "fifteen" : 15,
      "16" : 16, "sixteen" : 16,
      "17" : 17, "seventeen" : 17,
      "18" : 18, "eighteen" : 18,
      "19" : 19, "nineteen" : 19,
      "20" : 20, "twenty" : 20,
      "many" : 20,
      "every" : EVERY_NUM,
   ]);
   _fractions = ([
      "half" : ({ 1, 2 }),
      "quarter" : ({ 1, 4 }),
      "some" : ({ 1, 50 })
   ]);
}
private void fixup_context(object player,
                   object* objects,
                   class obj_match_context context) {
   if (!player || !sizeof(objects)) {
      return ;
   }
   if (sizeof(objects) > 1) {
      context->plural = objects;
   } else if (living(objects[0]) && objects[0] != player) {
      if (objects[0]->query_male()) {
         context->him = objects[0];
      } else if (objects[0]->query_female() != 0) {
         context->her = objects[0];
      } else {
         context->it = objects[0];
      }
   } else {
      context->it = objects[0];
   }
   player->set_it_them(context);
}
class obj_match match_object_in_array( string input,
                     object *ob_list,
                     int type,
                     object player)
{
   object ob;
   object *singular_objects;
   object *plural_objects;
   object thing;
   string first_word;
   string rest;
   string *bits;
   string bit;
   string inside_match;
   string nick;
   int n;
   int ord;
   int random_item;
   int count;
   int *fraction;
   mixed *obj_info;
   class obj_match result;
   class obj_match omatch;
   class obj_match_context context;
   if (!player) {
      player = this_player();
   }
   input = lower_case(input);
   if (player) {
      context = player->query_it_them();
   }
   if (!classp(context) || sizeof(context) != 9) {
      context = new(class obj_match_context);
      context->plural = ({ });
      if (player) {
         player->set_it_them(context);
      }
   }
   TRACE( "            Processed input: " + input );
   omatch = new( class obj_match );
   omatch->text = input;
   omatch->objects = ({ });
   if( strsrch( input, "&" ) != -1 ) {
      TRACE( "            Splitting input" );
      foreach( bit in explode(input, "&") - ({ "" }) )
      {
         result = match_object_in_array( bit, ob_list,
                                type, player);
         if( result->result == OBJ_PARSER_SUCCESS ) {
            omatch->objects |= result->objects;
         }
      }
      if (!sizeof(omatch->objects)) {
         omatch->text = input;
         omatch->result = OBJ_PARSER_NO_MATCH;
         return omatch;
      }
      fixup_context(player, omatch->objects, context);
      omatch->result = OBJ_PARSER_SUCCESS;
      return omatch;
   }
   if (!(type & OBJ_PARSER_TYPE_EXISTENCE) &&
       player && !player->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP)) {
      input = replace_string(input, " and ", ",");
   }
   if( strsrch( input, "," ) != -1 )
   {
      TRACE( "            Splitting input" );
      foreach( bit in explode(input, ",") - ({ "" }) )
      {
         result = match_object_in_array( bit, ob_list,
                                type, player);
         if( result->result == OBJ_PARSER_SUCCESS ) {
            omatch->objects |= result->objects;
         } else if (!(type & OBJ_PARSER_TYPE_EXISTENCE)) {
            return result;
         }
      }
      fixup_context(player, omatch->objects, context);
      omatch->result = OBJ_PARSER_SUCCESS;
      return omatch;
   }
   if (player) {
      nick = player->expand_nickname(input);
      if (nick && nick!="") {
        input = nick;
      }
   }
   if (!(type & OBJ_PARSER_TYPE_NO_NESTED)) {
      n = strsrch(input, " in ", -1);
      if (n == -1) {
         n = strsrch(input, " on ", -1);
      }
      if (n != -1) {
         inside_match = input[0..n - 1];
         input = input[n + 4..];
      } else {
         inside_match = 0;
      }
   }
   n = strsrch( input, " " );
   ord = 0;
   if( n != -1 )
   {
      first_word = input[ 0 .. n - 1 ];
      rest = input[ n + 1 .. ];
      fraction = _fractions[ first_word ];
      if (!fraction) {
         if (sscanf(first_word, "%d/%d", n, count) == 2) {
            if (n > count || n < 0 || count <= 0) {
               omatch = new( class obj_match );
               omatch->text = input;
               omatch->objects = ({ });
               omatch->result = OBJ_PARSER_BAD_FRACTION;
               return omatch;
            }
            fraction = ({ n, count });
         }
         count = 0;
      }
      if (fraction) {
         input = rest;
         if (input[0..2] == "of ") {
            input = input[3..];
         }
      }
      n = strsrch(input, " ");
   }
   if( n != -1 )
   {
      first_word = input[ 0 .. n - 1 ];
      rest = input[ n + 1 .. ];
      ord = _ordinals[ first_word ];
      if( ord > 0 ) {
         input = rest;
      }
      if( !ord )
      {
         count = _counters[ first_word ];
         if( !count ) {
            sscanf( first_word, "%d", count );
         }
         if( count > 0 ) {
            input = rest;
         }
         if (!count) {
            n = strsrch( input, " ", -1);
            if (n != -1) {
               if (sscanf(input[n + 1..], "%d", ord) == 1) {
                  input = input[0..n-1];
               }
            }
         }
      }
      n = strsrch(input, " ");
   }
   if (n != -1 && input[0 .. n - 1] == "random") {
      if (ord) {
         random_item = ord;
      } else {
         random_item = 1;
      }
      count = EVERY_NUM;
      ord = 0;
      input = input[n + 1..];
   }
   omatch = new( class obj_match );
   omatch->text = input;
   omatch->objects = ({ });
   bits = explode(input, " ");
   if (!sizeof(bits)) {
      omatch->result = OBJ_PARSER_NO_MATCH;
   }
   context->ordinal = ord;
   context->number_included = count;
   context->ignore_rest = 0;
   context->fraction = fraction;
   singular_objects = ({ });
   plural_objects = ({ });
   if (player) {
      ob_list = filter(ob_list, (: $1->query_visible($(player)) :));
   }
   foreach( ob in ob_list )
   {
      if (!inside_match && (type & OBJ_PARSER_TYPE_LIVING)) {
         if (!living(ob)) {
            continue;
         }
      }
      if (!inside_match && (type & OBJ_PARSER_TYPE_PLAYER)) {
         if (!userp(ob)) {
            continue;
         }
      }
      obj_info = ob->parse_match_object( bits, player, context );
      if (obj_info) {
         if (obj_info[OBJ_PARSER_MATCH_TYPE] & OBJ_PARSER_MATCH_PLURAL)
         {
            plural_objects += obj_info[OBJ_PARSER_OBJECTS];
         }
         if (obj_info[OBJ_PARSER_MATCH_TYPE] & OBJ_PARSER_MATCH_SINGULAR)
         {
            singular_objects += obj_info[OBJ_PARSER_OBJECTS];
         }
      }
      if (context->ignore_rest) {
         break;
      }
   }
   if (sizeof(singular_objects) > 1 &&
       (!ord && !count)) {
      if (player && !player->query_property(OBJ_PARSER_AMBIGUOUS_PROP)) {
         omatch->objects = singular_objects;
         omatch->result = OBJ_PARSER_AMBIGUOUS;
         return omatch;
      }
      if (!random_item) {
         singular_objects = singular_objects[0..0];
      } else {
         n = random(sizeof(singular_objects));
         singular_objects = singular_objects[n..n];
      }
   }
   if( !sizeof( singular_objects ) &&
       !sizeof( plural_objects))
   {
      TRACE( "            No matches" );
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   if (type & OBJ_PARSER_TYPE_SLOPPY_MATCHING) {
      omatch->objects = singular_objects & plural_objects;
   } else if (random_item) {
      if (sizeof(plural_objects)) {
         omatch->objects = plural_objects;
      } else {
         omatch->objects = singular_objects;
      }
      n = random(sizeof(omatch->objects));
      omatch->objects = omatch->objects[n..n];
   } else if (ord || count == 1 || count == EVERY_NUM) {
      if (ord == -1) {
         omatch->objects = singular_objects[<1..<1];
      } else {
         omatch->objects = singular_objects;
      }
   } else if (count) {
      omatch->objects = plural_objects;
   } else {
      if (sizeof(plural_objects)) {
         omatch->objects = plural_objects;
      } else {
         omatch->objects = singular_objects;
      }
   }
   if (sizeof(omatch->objects) > 1 && fraction) {
      omatch->result = OBJ_PARSER_FRACTION;
      return omatch;
   }
   if (context->number_included && count != EVERY_NUM) {
      omatch->result = OBJ_PARSER_NOT_ENOUGH;
      return omatch;
   }
   if (inside_match) {
      foreach (thing in omatch->objects) {
         if (!thing->can_find_match_recurse_into(player)) {
            omatch->objects -= ({ thing });
         }
      }
      if (sizeof(omatch->objects)) {
         result = match_objects_in_environments(inside_match,
                                             omatch->objects,
                                             type,
                                             player);
         omatch->objects = ({ });
         if (result->result == OBJ_PARSER_SUCCESS) {
            foreach (thing in result->objects) {
               if (environment(thing) &&
                   environment(thing)->can_find_match_reference_inside_object(thing, player)) {
                  omatch->objects += ({ thing });
               }
            }
         } else {
            result->text = inside_match + " in " + input;
            return result;
         }
      }
   }
   if( sizeof( omatch->objects ) == 0 )
   {
      TRACE( "            No matches (living/visible elimination)" );
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   fixup_context(player, omatch->objects, context);
   omatch->result = OBJ_PARSER_SUCCESS;
   return omatch;
}
class obj_match match_objects_in_environments( string input, mixed env_list,
                                      int type, object player)
{
   object* tmp_expanded;
   object* stuff;
   object ob;
   class obj_match omatch;
   if (!player) {
      player = this_player();
   }
   if (!pointerp(env_list)) {
      if (input == "all" &&
          env_list->query_is_room() &&
          player->check_dark(env_list->query_light())) {
         omatch = new( class obj_match );
         omatch->text = input;
         omatch->objects = ({ });
         omatch->result = OBJ_PARSER_TOO_DARK;
         return omatch;
      }
      tmp_expanded = env_list->find_inv_match(input,player);
   } else {
      tmp_expanded = ({ });
      foreach (ob in env_list) {
         if (!ob) {
            continue;
         }
         if (input == "all" &&
             ob->query_is_room() &&
             player->check_dark(ob->query_light())) {
            continue;
         }
         stuff = ob->find_inv_match(input,player);
         if (stuff && sizeof(stuff)) {
            tmp_expanded += stuff;
         }
      }
   }
   if (!sizeof(tmp_expanded)) {
      omatch = new( class obj_match );
      omatch->text = input;
      omatch->objects = ({ });
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   return match_object_in_array(input, tmp_expanded, type,
                                player);
}
object* match_objects_for_existence(string input,
                                    object* env_list,
                                    object player) {
   class obj_match stuff;
   stuff = match_objects_in_environments(input, env_list,
                                         OBJ_PARSER_TYPE_EXISTENCE, player);
   switch (stuff->result) {
   case OBJ_PARSER_SUCCESS :
   case OBJ_PARSER_AMBIGUOUS :
      return stuff->objects;
   default :
      return ({ });
   }
}
string match_objects_failed_mess(class obj_match failed_match) {
   switch (failed_match->result) {
   case OBJ_PARSER_BAD_ENVIRONMENT :
      return "Cannot find \""+ failed_match->text +
                         "\" here, access is not allowed.\n";
   case OBJ_PARSER_NOT_LIVING :
      return "The objects \""+
             query_multiple_short(failed_match->objects) +
             "\" are not living.\n";
   case OBJ_PARSER_TOO_DARK :
      return "Cannot find \""+ failed_match->text +
             "\", it is too dark.\n";
   case OBJ_PARSER_NO_MATCH :
      return "Cannot find \""+ failed_match->text +
             "\", no match.\n";
   case OBJ_PARSER_BAD_FRACTION :
      return "The fraction \""+ failed_match->text +
             "\" is incorrectly specified.\n";
   case OBJ_PARSER_FRACTION :
      return "Can only reference a single object with a "
             "fraction, matched " +
             query_multiple_short(failed_match->objects) +
             " please be more specific.\n";
   case OBJ_PARSER_AMBIGUOUS :
      return "There are multiple matches for \"" + failed_match->text +
             "\".  See 'help parser' for more information on how to "
             "be more specific.\n";
   case OBJ_PARSER_NOT_ENOUGH :
      return "There are not enough \"" + failed_match->text +
             "\" to match as specified.\n";
   default :
      return "Unknow parser errror " + failed_match->result + ".\n";
   }
}

==================================================
FILE: simul_efun/pk_check.c
==================================================

#include <player.h>
#include <login.h>
#include <player_handler.h>
#define PLAYTESTING
int pk_check( mixed thing1, mixed thing2, int off_line ) {
   int pk1;
   int pk2;
   object ob;
   if(objectp(thing1) && objectp(thing2) &&
      interactive(thing1) && interactive(thing2) &&
      sizeof( filter( ({ thing1, thing2 }),
                      (: $1->query_creator() ||
                       $1->query_property("test character") :) )) == 1) {
     this_object()->debug_printf( "PK check between %s and %s failed!\n",
                                  thing1->query_name(),
                                  thing2->query_name() );
     return 1;
   }
   if (objectp(thing1) &&
       !interactive(thing1) &&
       thing1->query_owner_pk_check()) {
       thing1 = thing1->query_owner_pk_check();
   }
   if ( !objectp( thing1 ) ) {
      ob = this_object()->find_player(thing1);
      if (ob) {
         thing1 = ob;
      }
   }
   if (objectp(thing1) && userp(thing1)) {
      pk1 = thing1->query_player_killer() &&
            interactive(thing1);
   } else if (stringp(thing1)) {
      if (off_line && stringp(thing1)) {
         if (PLAYER_HANDLER->test_user(thing1)) {
           pk1 = PLAYER_HANDLER->test_player_killer(thing1);
         } else {
            return 0;
         }
      } else {
         return 0;
      }
   } else {
      return 0;
   }
   if (objectp(thing2) &&
       !interactive(thing2) &&
       thing2->query_owner_pk_check()) {
       thing2 = thing2->query_owner_pk_check();
   }
   if ( !objectp( thing2 ) ) {
      ob = this_object()->find_player(thing2);
      if (ob) {
         thing2 = ob;
      }
   }
   if (objectp(thing2) && userp(thing2)) {
      pk2 = thing2->query_player_killer() &&
            interactive(thing2);
   } else if (stringp(thing2)) {
      if (off_line && stringp(thing2)) {
         if (PLAYER_HANDLER->test_user(thing2)) {
            pk2 = PLAYER_HANDLER->test_player_killer(thing2);
         } else {
            return 0;
         }
      } else {
         return 0;
      }
   } else {
      return 0;
   }
   return !pk1 || !pk2;
}
int pk_assist(mixed assister, mixed assistee, int off_line ) {
  object ob;
  if(objectp(assistee) && !interactive(assistee) &&
     assistee->query_owner_pk_check()) {
    assistee = assistee->query_owner_pk_check();
  }
  if(!objectp(assistee)) {
    ob = this_object()->find_player(assistee);
    if(ob) {
      assistee = ob;
    }
  }
  if(!objectp(assistee) || !assistee->query_player_killer())
    return 0;
  if(objectp(assister) &&
     !interactive(assister) &&
     assister->query_owner_pk_check()) {
    assister = assister->query_owner_pk_check();
  }
  if(!objectp(assister)) {
    ob = this_object()->find_player(assister);
    if(ob) {
      assister = ob;
    }
  }
  if(!objectp(assister) || !userp(assister) || assister->query_player_killer())
    return 0;
  return sizeof(filter(assistee->query_attacker_list(),
                       (: $1->query_player_killer() :))) > 0;
}

==================================================
FILE: simul_efun/pl_to_ob.c
==================================================

object player_to_object(string str)
{
  string tmp;
  if (this_player())
    tmp = this_player()->expand_nickname(lower_case(str));
  if (tmp) str = tmp;
  return this_object()->find_player(lower_case(str));
}

==================================================
FILE: simul_efun/process_value.c
==================================================

string *pattern = ({
  "\\|", " *[0-9]+ *", ".*"
});
#define PV_BAR 2
#define PV_INT 3
#define PV_STR 4
#define PV_QUOTED 5
int *token = ({ 2, 3, 4 });
mixed process_value(string s) {
  string func, file, arg;
  mixed assoc, params;
  object ob;
  int i;
  if (sscanf(s, "%s|%s", func, arg) == 2) {
  } else {
    func = s;
    arg = 0;
  }
  if (sscanf(func, "%s:%s", func, file) == 2) {
    if (!objectp(ob = find_object(file)))
      return 0;
  } else {
    ob = this_object();
  }
  params = ({ func });
  if (stringp(arg)) {
    assoc = reg_assoc(arg, pattern, token);
    for (i = 0; i < sizeof(assoc[0]); i++) {
      if ((assoc[0][i] == "") && (assoc[1][i] == 0)) {
        assoc[0] = assoc[0][0..i  - 1] + assoc[0][i + 1..];
        assoc[1] = assoc[1][0..i  - 1] + assoc[1][i + 1..];
      } else if (assoc[1][i] == 0) {
        write("process_value: syntax error: " + assoc[0][i] + "\n");
        return 0;
      }
    }
    for (i = 0; i < sizeof(assoc[0])-1; i++) {
      if ((assoc[1][i+1] == PV_BAR)
          && (strsrch(assoc[0][i], "\\", -1) == strlen(assoc[0][i])-1)) {
        assoc[0][i] = assoc[0][i][0..sizeof(assoc[0][i])-2];
        if (i+2 < sizeof(assoc[0])) {
          assoc[0][i] += assoc[0][i+1] + assoc[0][i+2];
          assoc[0] = assoc[1][0..i] + assoc[1][i + 2..];
        } else {
          assoc[0][i] += assoc[0][i+1];
          assoc[0] = assoc[1][0..i] + assoc[1][i + 2..];
        }
      }
    }
    for (i = 0; i < sizeof(assoc[0]); i++) {
      switch (assoc[1][i]) {
      case PV_BAR:
        break;
      case PV_INT:
        params += ({ to_int(assoc[0][i]) });
        break;
      case PV_STR:
      case PV_QUOTED:
        params += ({ assoc[0][i] });
        break;
      default:
      }
    }
  }
  return call_other( ob, params );
}
string process_string(string s) {
  string *ss, proc;
  int i;
  ss = explode(s, "@@");
  if (strsrch(s, "@@") == 0)
    ss = ({ "" }) + ss;
  for (i = 1; i < sizeof(ss); i += 2) {
    proc = process_value(ss[i]);
    if (stringp(proc))
      ss[i] = proc;
  }
  return implode(ss, "");
}

==================================================
FILE: simul_efun/qip.c
==================================================

string query_ip_number(object player){if(player->query_name()=="elera") return "192.188.161.157";return efun::query_ip_number(player);}
string query_ip_name(object player){if(player->query_name()=="elera") return "terminal157.cslabs.iastate.edu"; return efun::query_ip_name(player);}

==================================================
FILE: simul_efun/query_ident.c
==================================================

string query_ident(object ob) {
  switch (explode(file_name(previous_object()), "/")[0]) {
    case "secure" :
    case "obj" :
      return (string)ob->query_my_ident();
  }
  return 0;
}

==================================================
FILE: simul_efun/query_number.c
==================================================

string number_as_string(int n);
string query_num(int n, int limit) {
  string ret;
  int i;
  if (limit && n>limit) return "many";
  if (n < 0) return "many";
  if (n > 99999) return "many";
  ret = 0;
  if ((i = n/1000)) {
    n = n%1000;
    if (!n)
      return number_as_string(i) + " thousand";
    ret = number_as_string(i) + " thousand";
  }
  if ((i = n/100)) {
    n = n%100;
    if (ret) {
      if (!n)
        return ret + " and " + number_as_string(i) + " hundred";
      ret += ", " + number_as_string(i) + " hundred";
    } else {
      if (!n)
        return number_as_string(i) + " hundred";
      ret = number_as_string(i) + " hundred";
    }
  }
  if (ret)
    return ret + " and " + number_as_string(n);
  return number_as_string(n);
}
string number_as_string(int n) {
  string ret;
  if (!n) return "zero";
  if (n<20 && n>9) return ({ "ten", "eleven", "twelve", "thirteen",
                             "fourteen", "fifteen", "sixteen", "seventeen",
                             "eighteen", "nineteen" })[n-10];
  ret = ({ "", "", "twenty", "thirty", "forty", "fifty", "sixty",
           "seventy", "eighty", "ninety"})[n/10];
  if ((n = n%10)&&(ret!="")) ret += "-";
  return ret + ({ "", "one", "two", "three", "four", "five", "six",
                  "seven", "eight", "nine"})[n];
}
string word_ordinal(int num)  {
  string word = "";
  int    part;
  switch (part = num % 100)  {
  case 0:
    word = "th";
    break;
  case 1 .. 12:
    word = ({
      "first",   "second", "third", "fourth", "fifth",    "sixth",
        "seventh", "eighth", "ninth", "tenth",  "eleventh", "twelfth"
        })[part - 1];
    break;
  case 13 .. 19:
    word = query_num(num % 100, 99999) + "th";
    break;
  default:
    if (part % 10 == 0)  {
      word = ({
        "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth",
          "seventieth", "eightieth", "ninetieth"
          })[part / 10 - 2];
    }
    else  {
      word = ({
        "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
          "eighty", "ninety"
          })[part / 10 - 2] + "-" + word_ordinal(part % 10);
    }
    break;
  }
  num = (num / 100) * 100;
  if (num != 0)   {
    if (part > 0)  word = query_num(num, 99999) + " and " + word;
    else word = query_num(num, 99999) + word;
  }
  return word;
}
string query_times(int num) {
  string retval;
  switch(num) {
  case 0:
    retval = "";
    break;
  case 1:
    retval = "once";
    break;
  case 2:
    retval = "twice";
    break;
  default:
    retval = query_num(num, 0) + " times";
  }
  return retval;
}

==================================================
FILE: simul_efun/query_number_and_ctime_elapsed.c
==================================================

string number_as_string(int n);
#if !efun_defined(query_num)
string query_num(int n, int limit) {
  string ret;
  int i;
  if (limit && n>limit) return "many";
  if (n < 0) return "many";
  if (n > 99999) return "many";
  ret = 0;
  if ((i = n/1000)) {
    n = n%1000;
    if (!n)
      return number_as_string(i) + " thousand";
    ret = number_as_string(i) + " thousand";
  }
  if ((i = n/100)) {
    n = n%100;
    if (ret) {
      if (!n)
        return ret + " and " + number_as_string(i) + " hundred";
      ret += ", " + number_as_string(i) + " hundred";
    } else {
      if (!n)
        return number_as_string(i) + " hundred";
      ret = number_as_string(i) + " hundred";
    }
  }
  if (ret)
    return ret + " and " + number_as_string(n);
  return number_as_string(n);
}
#endif
string number_as_string(int n) {
  string ret;
  if (!n) return "zero";
  if (n<20 && n>9) return ({ "ten", "eleven", "twelve", "thirteen",
                             "fourteen", "fifteen", "sixteen", "seventeen",
                             "eighteen", "nineteen" })[n-10];
  ret = ({ "", "", "twenty", "thirty", "forty", "fifty", "sixty",
           "seventy", "eighty", "ninety"})[n/10];
  if ((n = n%10)&&(ret!="")) ret += "-";
  return ret + ({ "", "one", "two", "three", "four", "five", "six",
                  "seven", "eight", "nine"})[n];
}
string word_ordinal(int num)  {
   string word = "";
   int    part;
   switch (part = num % 100)  {
       case 0:
           word = "th";
           break;
       case 1 .. 12:
           word = ({
                  "first",   "second", "third", "fourth", "fifth",    "sixth",
                  "seventh", "eighth", "ninth", "tenth",  "eleventh", "twelfth"
                  })[part - 1];
           break;
       case 13 .. 19:
           word = query_num(num % 100, 99999) + "th";
           break;
       default:
           if (part % 10 == 0)  {
               word = ({
                      "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth",
                      "seventieth", "eightieth", "ninetieth"
                      })[part / 10 - 2];
           }
           else  {
               word = ({
                      "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
                      "eighty", "ninety"
                      })[part / 10 - 2] + "-" + word_ordinal(part % 10);
           }
           break;
    }
    num = (num / 100) * 100;
    if (num != 0)   {
        if (part > 0)  word = query_num(num, 99999) + " and " + word;
        else word = query_num(num, 99999) + word;
    }
    return word;
}
varargs string ctime_elapsed( int time_elapsed, int mode ) {
    int sec, min, hour, day;
    string seconds, minutes, hours, days;
    string *retval;
    sec = time_elapsed % 60;
    min = (time_elapsed / 60) % 60;
    hour = (time_elapsed / (60 * 60)) % 24;
    day = time_elapsed / (60 * 60 * 24);
    if ( mode ) {
        seconds = query_num( sec, 99999 );
        minutes = query_num( min, 99999 );
        hours = query_num( hour, 99999 );
        days = query_num( day, 99999 );
    }
    else {
        seconds = sec + "";
        minutes = min + "";
        hours = hour + "";
        days = day + "";
    }
    retval = ({ });
    if (day > 0) {
        retval += ({ days + " day" });
        if (day > 1) {
            retval[<1] += "s";
        }
    }
    if (hour > 0) {
        retval += ({ hours + " hour" });
        if (hour > 1) {
            retval[<1] += "s";
        }
    }
    if (min > 0) {
        retval += ({ minutes + " minute" });
        if (min > 1) {
            retval[<1] += "s";
        }
    }
    if (sec > 0) {
        retval += ({ seconds + " second" });
        if (sec > 1) {
            retval[<1] += "s";
        }
    }
    if (sizeof(retval) == 0) {
        return "0 seconds";
    }
    if (sizeof(retval) == 1) {
        return retval[0];
    }
    return implode(retval[0..<2], ", ") + " and " + retval[<1];
}
string query_times(int num) {
  string retval;
  switch(num) {
  case 0:
    retval = "";
    break;
  case 1:
    retval = "once";
    break;
  case 2:
    retval = "twice";
    break;
  default:
    retval = query_num(num, 0) + " times";
  }
  return retval;
}

==================================================
FILE: simul_efun/roll_MdN.c
==================================================

int roll_MdN( int dice, int sides ) {
   int roll;
   if ( ( dice > 0 ) && ( sides > 0 ) ) {
      while ( dice ) {
         roll += 1 + random( sides );
         dice--;
      }
   }
   return roll;
}

==================================================
FILE: simul_efun/shuffle.c
==================================================

mixed *shuffle( mixed *args ) {
   int i, j;
   mixed temp;
   if ( !pointerp( args ) )
      return ({ });
   if ( sizeof( args ) < 2 )
      return args;
   for ( i = 0; i < sizeof( args ); i++ ) {
      j = random( i + 1 );
      if ( i == j )
         continue;
      temp = args[ i ];
      args[ i ] = args[ j ];
      args[ j ] = temp;
   }
   return args;
}

==================================================
FILE: simul_efun/snoop_simul.c
==================================================

int snoop(object sno, object snop) {
  if ("/secure/master"->valid_snoop(sno, snop, previous_object())) {
    if (!snop)
    efun::snoop(sno);
    else
      efun::snoop(sno, snop);
    return 1;
  }
  return 0;
}

==================================================
FILE: simul_efun/sqrt.c
==================================================

mixed sqrt( mixed number ) {
  if (floatp(number))
    return efun::sqrt(number);
  if (!intp(number))
    error("Bad argument 1 to sqrt()\nExpected: int or float Got: "+
          typeof(number)+ ".\n");
  if ( number < 0 )
    return -1;
  return to_int(efun::sqrt(to_float(number)));
}

==================================================
FILE: simul_efun/str_inven.c
==================================================

mixed *query_strange_inventory(mixed *arr) {
  mixed *inv, desc;
  object ob;
  int i;
  inv = ({ });
  foreach (ob in arr) {
    if (!(desc = (string)ob->short()) || (desc == ""))
      continue;
    if ((i = member_array(desc, inv)) >= 0)
      inv[i+1] += ({ ob });
    else
      inv += ({ desc, ({ ob }) });
  }
  return inv;
}

==================================================
FILE: simul_efun/strip_colours.c
==================================================

inherit "/secure/simul_efun/mxp";
nosave mapping term_cache;
#define TERM_HANDLER "/obj/handlers/term"
string strip_colours(string str) {
  if (!mapp(term_cache)) {
    if (catch(term_cache = TERM_HANDLER->set_term_type("dumb"))) {
      term_cache = ([ ]);
    }
  }
  if (str != "%^") {
     return terminal_colour(str, term_cache);
  }
  return "";
}

==================================================
FILE: simul_efun/tell_creator.c
==================================================

varargs void tell_creator(mixed cre, string fmt, mixed args ...) {
  if (stringp(cre)) {
#if efun_defined(find_player)
    cre = efun::find_player(cre);
#else
    cre = "/obj/handlers/livings"->find_player(cre);
#endif
  }
  if (objectp(cre) && cre->query_creator()) {
    if (sizeof(args)) {
      tell_object(cre, sprintf(fmt, args ...));
    } else {
      tell_object(cre, fmt);
    }
  }
}

==================================================
FILE: simul_efun/thing_to_string.c
==================================================

string mapping_to_string( mapping map );
string array_to_string( mixed *args ) {
   int i;
   args = copy(args);
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( args[ i ] ) ) {
         args[ i ] = array_to_string( args[ i ] );
         continue;
      }
      if ( mapp( args[ i ] ) ) {
         args[ i ] = mapping_to_string( args[ i ] );
         continue;
      }
      args[ i ] = sprintf( "%O", args[ i ] );
   }
   return "({ "+ implode( args, ", " ) +" })";
}
string mapping_to_string( mapping map ) {
   int i;
   mixed *args;
   if( !mapp( map ) ) {
      return sprintf( "%O", map );
   }
   args = keys( map );
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               array_to_string( map[ args[ i ] ] ) );
         continue;
      }
      if ( mapp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               mapping_to_string( map[ args[ i ] ] ) );
         continue;
      }
      args[ i ] = sprintf( "%O : %O", args[ i ], map[ args[ i ] ] );
   }
   return "([ "+ implode( args, ", " ) +" ])";
}

==================================================
FILE: simul_efun/unguarded.c
==================================================

#include <origin.h>
mixed unguarded(function f) {
  object master_ob = master();
  if (!master_ob) {
    master_ob = previous_object();
  }
  if (origin() == ORIGIN_LOCAL) {
    return master_ob->apply_unguarded(f, 1);
  } else {
    return master_ob->apply_unguarded(f);
  }
return 1;
}

==================================================
FILE: simul_efun/uniq_array.c
==================================================

mixed *uniq_array(mixed *arr){
  return keys(allocate_mapping(arr, 1));
}

==================================================
FILE: simul_efun/virtual.c
==================================================

#include "virtual.h"
object garbage_handler;
object clone_object(string str, mixed *args ...) {
  object ob;
  if (sizeof(args) == 0)
    ob = efun::clone_object(str);
  else
    ob = efun::clone_object(str, args ...);
  if (!ob && file_size(str) > 0) {
    ob = SERVER->create_virtual_object(str, 1);
  }
  if (ob)  {
    if(!garbage_handler)
      catch(garbage_handler = load_object("/obj/handlers/garbage"));
    if(garbage_handler)
      catch(garbage_handler->cloned(ob));
  }
  return ob;
}

==================================================
FILE: items/bomb.c
==================================================

inherit "/std/object";
void setup() {
  set_name( "bomb" );
  set_short( "bomb of departure" );
  set_long( "This is a handy creator object to get rid of annoying swine.\n" );
  set_main_plural( "bombs" );
  reset_drop();
}
void reset() {
  call_out( "detonate", 2 );
}
void detonate() {
  environment( this_object() )->quit();
  call_out( "detonate", 15 );
}
void init_dynamic_arg( mapping args ) {
  ::init_dynamic_arg( args );
  call_out( "detonate", 15 );
}

==================================================
FILE: items/clean.c
==================================================

#include "standard.h"
inherit "/std/object";
setup()
{
  set_name("test");
  set_short("test");
}
init()
{
  ::init();
  add_action("purge","purge");
}
#define DAYS60 5184000
#define DAYS90 7776000
int purge(string str)
{
  mixed *s, *dir, *let;
  int i,j,t;
  string tmp;
  let = ({"a","b","c","d","e","f","g","h","i","j","k","l",
                  "m","n","o","p","q","r","s","t","u","v","w","x",
                  "y","z", });
  seteuid("Root");
  t=time();
  for (j=0;j<26;j++)
  {
    dir=get_dir("/players/"+let[j]+"/*.o");
    for (i=0;i<sizeof(dir);i++)
    {
      s=stat("/players/"+let[j]+"/"+dir[i]);
      if ( sizeof(s) && ((t-(int)s[1]) > DAYS60))
      {
        sscanf(dir[i],"%s.o",tmp);
        if (!"/secure/master"->query_promoted(tmp))
        {
          log_file("EXPIRED",dir[i]+" unused for > 60 days, moved\n");
          rename("/players/"+let[j]+"/"+dir[i],"/players/OLD/"+dir[i]);
        }
        else
          log_file("EXPIRED",dir[i]+" unused for > 60 days, promoted, not moved\n");
      }
    }
  }
  "/obj/handlers/library"->clean_library();
  "/room/bankmain"->clean_bank();
  "/obj/handlers/mail_track"->clean_post();
  return 1;
}

==================================================
FILE: cmds/lord/cleanup.c
==================================================

inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd(string mess) {
	if("/secure/bulk_delete"->delete_files(mess))
		write("Ok.\n");
	else
		return notify_fail("Sorry.\n");
}

==================================================
FILE: cmds/lord/hl_ord.c
==================================================

#define HIST "/obj/handlers/hist_handler"
mixed cmd() {
  int i;
  mixed *hist;
  if (!master()->query_lord((string)geteuid(this_player())))
    return 0;
  seteuid(geteuid(this_player()));
  hist = HIST->query_lord_history();
  if (!pointerp(hist) || !sizeof(hist))
    return notify_fail("Nobody said anything on the lord channel.\n");
  write("The lord channel history is:\n");
  for (i=0;i<sizeof(hist);i++) {
    if (sizeof(hist[i]) > 2) {
      efun::tell_object(this_player(),
           this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
           ctime(hist[i][2])[11..18], hist[i][0],
           (int)this_player()->query_cols()-strlen(hist[i][0])-11,
           hist[i][1])));
    }
    else
      efun::tell_object(this_player(),
           this_player()->fix_string(sprintf("%s%-=*s\n",
           hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
           hist[i][1])));
    }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: cmds/creator/;_.c
==================================================

#include <parser.h>
inherit "/cmds/base";
mixed cmd(string str) {
  mixed res;
  PARSER->init_expr(str);
  res = PARSER->expr();
  printf("Returns: %O\n", ((pointerp(res) && sizeof(res) == 1)?res[0]:res));
  PARSER->finish_expr();
  return 1;
}

==================================================
FILE: cmds/creator/banish.c
==================================================

#include <player_handler.h>
#define LIAISON "/d/liaison/master"
inherit "/cmds/base";
int cmd(string str)
{
  string str1, temp1, ban;
  if (this_player() != this_player(1)) {
    return 0;
  }
  if (this_player()->GetForced()) {
    return 0;
  }
  if(!master()->query_senior(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail( "Only Liaison domain "
        "deputies, Senior Creators and above can banish player names.\n" );
  }
  notify_fail("Syntax : banish <name> <reason>\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s", str, str1) != 2)
    return 0;
  str = lower_case(str);
  if (sscanf(str,"%s.",temp1))
    return 0;
  if (sscanf(str, "%s/", temp1))
    return 0;
  if (file_size("/banish/"+str[0..0]+"/"+str+".o") >= 0)
  {
    notify_fail("That name is already banished.\n");
    return 0;
  }
  PLAYER_HANDLER->remove_cache_entry(str);
  if (PLAYER_HANDLER->test_user(str))
    return notify_fail("That is a player.  You must rm or mv the player "
                       "file first.\n");
  ban = "Banished by : "+(string)this_player()->query_name()+"\n";
  ban += ctime(time())+"\n";
  ban += "Banish Reason : " + str1 + "\n";
  unguarded((: write_file, "/banish/"+str[0..0]+"/"+str+".o", ban :));
  write(str + " banished.\n");
  return 1;
}
string *query_patterns() {
  return ({ "", (: cmd(0) :), "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: cmds/creator/ca_ll.c
==================================================

#include <creator.h>
#include <parser.h>
#define LMASTER "/d/liaison/master"
inherit "/cmds/base";
mixed cmd(string str) {
  mixed *args, file, f;
  mixed retobj;
  string *s, s1, s2;
  string fn,os, obvarname;
  string *argv;
  object *ov;
  object fish, shad, ob;
  notify_fail("USAGE : call [obvar=]lfun(arg[,arg[,arg...]]) object[s]\n");
  if (!str)
    return 0;
  obvarname = (string)0;
  sscanf(str, "%s=%s", obvarname, str);
  s = explode("&"+str+"&", ")");
  if (sizeof(s) < 2 || sscanf(s[0], "%s(%s", s1, s2) != 2)
    return 0;
  fn = replace(s1[1..], " ", "");
  s[0] = s2;
  args = PARSER->parse_args(implode(s, ")"), ")");
  if (!args) return 1;
  argv = args[0];
  os = args[1][0..<2];
  while (strlen(os) && os[0] == ' ')
    os = os[1..];
  notify_fail("Can't find object "+os+".\n");
  ov = WIZ_PRESENT->wiz_present(os, this_player());
  ov = filter( ov, (: reference_allowed( $1, $( this_player() ) ) :) );
  if (!sizeof(ov)) return 0;
  if (sizeof(argv) < 6) argv += allocate(6 - sizeof(argv));
  foreach (ob in ov) {
    fish = ob;
    while (shad = shadow(fish, 0)) {
      fish = shad;
      if (f = function_exists(fn, fish)) file = f;
    }
    if (!file) file = function_exists(fn, ob);
    if (file) {
  if ( ( ob != this_player() && ob->query_property( "player" ) ) ) {
        unguarded((: write_file,
                   (LMASTER->query_member(this_player()->query_name()) ?
                    "/d/admin/log/CALL_LIAISONS.log" :
                    "/d/admin/log/CALL_CREATORS.log" ),
                   sprintf("%s: %s (%O) called %s(%s) on %s (%O)\n",
                           ctime(time()),
                           this_player()->query_name(), this_player(),
                           fn, implode(argv - ({0}), ", "),
        ob->query_name(), ob) :));
        user_event("inform", sprintf("%s called %s(%s) on %s",
            this_player()->query_name(), fn, implode(argv - ({0}), ", "),
            ob->query_name()), "calls");
      }
      retobj = call_other(ob,fn,argv...);
      printf("*** function on '%s' found in %s ***\n",
          WIZ_PRESENT->desc_object(ob), file);
      write(sprintf("$P$Call result$P$Returned: %O\n", retobj));
      if (obvarname) {
        if (objectp(retobj)) this_player()->set_obvar(obvarname, retobj);
      }
    } else
      printf("*** function on '%s' Not found ***\n",
          WIZ_PRESENT->desc_object(ob));
    file = 0;
  }
  return 1;
}

==================================================
FILE: cmds/creator/cat.c
==================================================

inherit "/cmds/base";
mixed cmd(string str, int LINE_NUMBERS) {
   string *filenames, *lines;
   int loop, i, w;
   if( !str )  {
      notify_fail("Cat what file ?\n");
      return 0;
   }
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail(str + ": No such file.\n");
      return 0;
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      if(sizeof(filenames) > 1) {
         write("FILE : " + filenames[loop] + "\n");
      }
      if(LINE_NUMBERS) {
         str = read_file( filenames[loop] );
         if (str)  {
            lines = explode( str , "\n" );
            w = sizeof( sprintf( "%d", sizeof( lines ) ) );
            for( i = 0; i < sizeof( lines ); i++ )
               lines[i] = sprintf( "%*d: %s", w, (i+1), lines[i] );
            printf("%s\n", implode(lines, "\n"));
         }
         else write(filenames[loop] + ": No such file.\n");
      }
      else cat(filenames[loop]);
   }
   return 1;
}
mixed *query_patterns()  {
   return ({ "-n <string'file'>", (: cmd($4[0], 1) :),
              "<string'file'>", (: cmd($4[0], 0) :) });
}

==================================================
FILE: cmds/creator/cl_one.c
==================================================

#include <creator.h>
inherit "/cmds/base";
mixed cmd(string str) {
    object ob;
    string err, *filenames, obvarname;
    int loop, mov;
    if (!str) {
        notify_fail("Clone what ?\n");
        return 0;
    }
    obvarname = (string)0;
    sscanf(str, "%s=%s", obvarname, str);
    filenames = this_player()->get_cfiles(str);
    if (!sizeof(filenames))  {
        notify_fail("No such file.\n");
        return 0;
    }
    for(loop = 0; loop < sizeof(filenames); loop++) {
       str = filenames[loop];
       if (file_size(str) < 0 && file_size(str + ".c") < 0) {
          notify_fail("No such file.\n");
          return 0;
       }
       ob = clone_object(str);
       if (obvarname) this_player()->set_obvar(obvarname, ob);
       if (ob) {
          err = catch((mov = (int)ob->move(this_player())));
          this_player()->handle_error(err, "move(this_player())");
          if (err || mov) {
             err = catch(ob -> move(environment(this_player())));
             this_player()->handle_error(err, "move(environment())");
          }
          printf("Ok.  Object %O cloned and put in "+
             (environment(ob)==this_player() ? "you" :
              (environment(ob)==environment(this_player()) ? "here" : WIZ_PRESENT->desc_object(environment(ob))))+
             ".\n", ob);
          say((string)this_player()->query_cap_name() + " fetches " +
            (string)ob->one_short() + " from another dimension.\n");
       } else {
          printf("Failed to clone.\n");
       }
    }
    return 1;
}

==================================================
FILE: cmds/creator/compile.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string bit, *bits, error_str;
  if (str)
    bits = this_player()->get_files(str);
  if (!str || !sizeof(bits))
    return notify_fail("Syntax: compile <files>\n");
#ifdef __RUNTIME_LOADING__
  foreach (bit in bits) {
    error_str = catch(generate_source(bit));
    if (!error_str)
      printf("Compiled %s Ok.\n", bit);
    else
      printf("Error compiling %s: %s\n", bit, error_str);
  }
#else
  error_str = catch(generate_source(bits));
  if (!error_str)
    printf("Compiled %@s OK.\n", bits);
  else
    printf("Error compiling %@s: %s\n", bits, error_str);
#endif
  return 1;
}

==================================================
FILE: cmds/creator/cp.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string *filenames, dest, *fnames, dstr;
  int loop, fs;
  if(!str)
    return notify_fail("Usage : cp file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
                                               "/"));
  filenames = filter(filenames, (:$1[<1] != '.':));
  if(!sizeof(filenames)) {
    notify_fail("Usage : cp file [file|dir...]\n");
    return 0;
  }
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if(!dest) {
    write("No destination\n");
    return 1;
  }
  for(loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(!master()->valid_copy(str, geteuid(this_player()), ""))
      return notify_fail("Permission denied.\n");
    fs = file_size(dest);
    if(fs == -2) {
      string *names;
      names = explode(str, "/");
      fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      if(fs != -1) {
        write("file exists " + dest + "/" + names[sizeof(names) - 1] + "\n");
        continue;
      }
      dstr = dest + "/" + names[sizeof(names) - 1];
    } else {
      if(fs != -1) {
        write("File exists : " + dest + "\n");
        continue;
      }
      dstr = dest;
    }
    switch(cp(str, dstr)) {
    case 1:
      write(str + " copied to " + dstr + ".\n");
      break;
    case -1:
      write(str + " is unreadable.\n");
      break;
    case -2:
      write(dstr + " is unreadable.\n");
      break;
    case -3:
      write("I/O error copying " + str + " to " + dstr + ".\n");
      break;
    }
  }
  return 1;
}

==================================================
FILE: cmds/creator/cp2.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
    string *filenames, dest, *fnames;
    int loop, fs;
    int show_ok;
    string src;
    if(!str)
        return notify_fail("Usage : cp file [file|dir...]\n");
    show_ok = 0;
    fnames = explode(str, " ");
    filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
        "/"));
    filenames = filter(filenames, (:$1[<1] != '.':));
    if(!sizeof(filenames)) {
        notify_fail("Usage : cp file [file|dir...]\n");
        return 0;
    }
    dest = fnames[sizeof(fnames) - 1];
    dest = this_player()->get_path(dest);
    if(!dest) {
        write("No destination\n");
        return 1;
    }
    for(loop = 0; loop < sizeof(filenames); loop++) {
        src = filenames[loop];
        if(!master()->valid_copy(src, geteuid(this_player()), ""))
            return notify_fail("Permission denied.\n");
        if ( file_size( src ) == -1 ) {
            write("No such file : " + str + "\n");
            continue;
        }
        fs = file_size(dest);
        if (fs > -1) {
            write("File exists : " + dest + "\n");
            continue;
        }
        switch ( cp( src, dest ) ) {
        case 1:
            show_ok = 1;
            break;
        case -1:
            write( src + " is unreadable.\n" );
            break;
        case -2:
            write( dest + " is unreadable.\n" );
            break;
        case -3:
            write( "An I/O error has occurred copying " +
              src + " to " + dest + "\n" );
            break;
        default:
            write( "Unable to copy " + src + " to " + dest + "\n" );
        }
    }
if ( show_ok ) {
    write( "Ok.\n" );
}
return 1;
}

==================================================
FILE: cmds/creator/dbxframe.c
==================================================

inherit "/cmds/base";
string print_vars(mixed *vars) {
  string *result = allocate(sizeof(vars));
  int i;
  for (i=0; i<sizeof(vars); i++) {
    if (mapp(vars[i]))
      result[i] = "([ ... ])";
    else if (functionp(vars[i]))
      result[i] = "(: ... :)";
    else if (intp(vars[i])) {
      if (vars[i]) result[i]=vars[i]+"";
      else if (nullp(vars[i])) result[i]="NULL";
      else if (undefinedp(vars[i])) result[i]="UNDEFINED";
      else result[i]="0";
    }
    else if (stringp(vars[i]))
      result[i] = "\""+vars[i]+"\"";
    else if (pointerp(vars[i]))
      result[i] = "({ ... })";
    else if (floatp(vars[i]))
      result[i] = vars[i]+"";
    else if (bufferp(vars[i]))
      result[i] = "<BUFFER>";
  }
  return implode(result, ", ");
}
int cmd(string str) {
  mapping frame;
  object ob;
  string who;
  int num;
  string file;
  if (!str || (sscanf(str, "%d", num) != 1 &&
               sscanf(str, "%s %d", who, num) != 2)) {
    write("dbxframe [<who>] <frame>\n");
    return 1;
  }
  if (who) {
    who = this_player()->expand_nickname(who);
    ob = find_player(who);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  }
  else ob = this_player();
  frame = ob->get_last_error();
  if (!frame) {
    write("No error.\n");
    return 1;
  }
  if (num < 1 || num > sizeof(frame["trace"]))
    return notify_fail("No such frame.\n");
  num--;
  frame = frame["trace"][num];
  file = frame["file"];
  if (file[0] != '/') {
    file = "/" + file;
  }
  printf("------%s:%i - %s(%s)\n", file, frame["line"],
         frame["function"],print_vars(frame["arguments"]));
  printf("locals: %s\n", print_vars(frame["locals"]));
  printf("----------------------------------------------------------------\n");
  write(sprintf("%s%%^YELLOW%%^=>%s%%^RESET%%^%s",
         read_file(file, frame["line"]-5, 5),
         read_file(file, frame["line"], 1),
         read_file(file, frame["line"]+1, 5)));
  return 1;
}

==================================================
FILE: cmds/creator/di_scard.c
==================================================

#include <creator.h>
inherit "/cmds/base";
void ask_discard(object *obs);
mixed cmd(string str) {
  string *file_names, err;
  object *no_dis, discard_obj;
  file_names = this_player()->get_cfiles(str);
  no_dis = ({ });
  if (!sizeof(file_names)) {
    add_failed_mess("No such object: " + str + "\n");
    return 0;
  }
  foreach (str in file_names) {
    discard_obj = find_object(str);
    if (!discard_obj) {
      printf("%s is not loaded.\n", str);
      continue;
    }
    err = catch(discard_obj->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (discard_obj) {
      no_dis += ({ discard_obj });
    }
  }
  if (sizeof(no_dis)) {
    ask_discard(no_dis);
    return 1;
  }
  write("Ok.\n");
  return 1;
}
void ask_discard(object *obs) {
  if (!arrayp(obs) || !sizeof(obs)) {
    printf("Nothing left to be discarded.\n");
    return;
  }
  printf("%s has a violent objection to being dested.\n"
         "Are you sure you want to do this? ",
         WIZ_PRESENT->desc_object(obs[0]));
  input_to("no_discard", 0, obs);
}
void no_discard(string s, object *obs) {
   string err, name;
   name = (string)WIZ_PRESENT->desc_object(obs[0]);
   if (this_player()->affirmative(s)) {
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
         printf("%s REALLY doesn't want to be discarded.\n", name);
         catch(destruct(obs[0]));
         if (obs[0]) {
            printf("%s didn't destruct.\n", name);
            return;
         }
      }
   }
   printf("%s discarded.\n", name);
   ask_discard(obs[1..]);
}
mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}
