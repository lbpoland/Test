




==================================================
FILE: /lib/cmds/player/locate.c
==================================================

inherit "/cmds/base";
#define TP this_player()
object *look_in_container(object fluff,
                          string word) {
   object frog;
   object *obs;
   object *things;
   things = match_objects_for_existence(word, ({ fluff }));
   obs = all_inventory(fluff);
   foreach (frog in obs) {
      if (sizeof(all_inventory(frog))) {
         things += look_in_container(frog, word);
      }
   }
   return things;
}
mixed cmd( string word ) {
   int i;
   int base_num;
   string list;
   object thing;
   object *things;
   object *extra_things;
   debug_printf("%s", word);
   if (environment(TP)) {
      switch(TP->check_dark(environment(TP)->query_light())) {
      case -2:
      case -1:
        if (this_player()->query_creator()) {
          write("It is too dark to locate anything, but since you are a cre...\n");
        } else {
          return notify_fail("It's too dark to locate anything.\n");
        }
        break;
      case 1:
      case 2:
        if (this_player()->query_creator()) {
          write("It is too bright to locate anything, but since you are a cre...\n");
        } else {
           return notify_fail("It's too bright to locate anything.\n");
        }
        break;
      }
   }
   things = match_objects_for_existence( word, ({ environment( TP ) }) );
   things = filter(things, (: environment($1) == environment(TP) ||
                             environment($1) == TP :));
   extra_things = look_in_container(this_player(), word) - things;
   base_num = sizeof(things);
   things += extra_things;
   if ( !sizeof( things ) ) {
      return notify_fail( "There is nothing here matching \""+ word +"\".\n" );
   }
   if ( sizeof( things ) == 1 ) {
     if ( things[0] == TP ) {
       write("You are here! :)\n");
       return 1;
     }
     list = "$C$"+ (string)things[ 0 ]->the_short();
     if ( (object)things[ 0 ]->query_wielded() == TP ) {
       list += " (held in " + query_multiple_short(TP->query_holding_limbs(things[0])) + ")";
     }
     if ( (object)things[ 0 ]->query_worn_by() == TP ) {
       list += " (worn)";
     }
     if ( things[ 0 ]->query_keep() ) {
       list += " (keeping)";
     }
     word = (string)things[ 0 ]->query_full_identifier();
     if ( stringp( word ) ) {
       list += " (\""+ word +"\")";
     }
     if (environment(things[0]) == this_player()) {
       list += (things[0]->group_object() ? " are" : " is") +
         " in your inventory.\n";
     } else {
       list += (things[0]->group_object() ? " are in " : " is in ");
       list += inside_the_short(environment( things[ 0 ] )) + ".\n";
     }
     write( list );
     return 1;
   }
   list = "";
   foreach ( thing in things ) {
      i++;
      if ( thing == TP ) {
         list += "You (" + i + ") are here :)\n";
         continue;
      }
      if (i > 30) {
         list += "Truncated list!  Cannot list more than 30 items.\n";
         break;
      }
      list += "$C$" + (string)thing->the_short();
      if (i <= base_num) {
         list += " (" + i + ")";
      }
      if ( (object)thing->query_wielded() == TP ) {
         list += " (held in " + query_multiple_short(TP->query_holding_limbs(thing)) + ")";
      }
      if ( (object)thing->query_worn_by() == TP ) {
         list += " (worn)";
      }
      if ( thing->query_keep() ) {
         list += " (keeping)";
      }
      word = (string)thing->query_full_identifier();
      if ( stringp( word ) ) {
         list += " (\""+ word +"\")";
      }
      if (environment(thing) == this_player()) {
         list += (thing->group_object() ? " are " : " is ") +
           "in your inventory.\n";
      } else {
        list += (thing->group_object() ? " are in " : " is in ");
         list += inside_the_short(environment( thing )) + ".\n";
      }
   }
   write( "$P$Locate$P$"+ list );
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'object name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/lockg_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
mixed cmd(string str) {
  object owner;
  int locked;
   str = TEAM_HANDLER->query_group(this_player());
   if(!str)
      return notify_fail("You are not a member of any group.\n");
  owner = TEAM_HANDLER->query_owner(str);
  if(!owner || owner != this_player())
    return notify_fail("Sorry, you are not the owner of "+str+".\n");
  locked = TEAM_HANDLER->query_locked(str);
  if(locked) {
    TEAM_HANDLER->set_locked(str, 0);
    write("Team "+str+" unlocked for new members.\n");
  } else {
    TEAM_HANDLER->set_locked(str, 1);
    write("Team "+str+" locked to new members.\n");
  }
  return 1;
}

==================================================
FILE: /lib/cmds/player/lockout.c
==================================================

#include <player_handler.h>
#include <playerinfo.h>
inherit "/cmds/base";
nosave mapping info = ([ ]);
private int cmd(int tim, string type, string reason, int use_alts) {
   string p1;
   string* alts;
   if (this_player() != this_player(1))
    return 0;
   if(type[<1] != 's')
      type += "s";
  switch (type) {
   case "days":
      tim *= 24;
      break;
   case "weeks":
      tim *= 24 * 7;
    break;
   case "hours":
     tim = tim;
     break;
   default:
      return notify_fail("Invalid time.\n");
  }
  if (tim > 24 * 31) {
    return notify_fail( "You can't lock yourself out for more than "
                        "one month!\n" );
  }
  if(sizeof(reason) > 80) {
    return notify_fail("Reason cannot be more than 80 characters.\n");
  }
   if (use_alts) {
      p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
      alts = (string*)PLAYERINFO_HANDLER->query_alts(this_player()->query_name()) |
             (string*)PLAYERINFO_HANDLER->query_alts(p1) |
             ({ this_player()->query_name() });
   } else {
      alts = ({ this_player()->query_name() });
   }
  info[this_player()->query_name()] = ({ tim, reason, alts });
  write("This will lockout " + query_multiple_short(alts) + ".\n");
  write("Enter your password: ");
  input_to("get_pw", 1, this_player());
  return 1;
}
int get_pw(string pass, object player) {
   int tim;
  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("\nSorry, incorrect password.\n");
    return 0;
  }
   if(!info[player->query_name()]) {
      write("\nSomething went wrong, please try again.\n");
      return 0;
   }
  tim = info[player->query_name()][0];
  if (tim < 24) {
    write("\nYour lockout will last " + tim  + " hour" +
          (tim == 1 ? "" : "s" ) + ".  It cannot be " +
          "undone.  Are you completely sure you wish to continue?\n");
  } else {
    write("\nYour lockout will last " + tim / 24 + " day" +
          ((tim / 24) == 1 ? "" : "s" ) + ".  It cannot be " +
          "undone.  Are you completely sure you wish to continue?\n");
  }
  input_to("confirm", 0, this_player());
  return 1;
}
int confirm(string yesno, object player) {
   int tim;
   string reason;
   string* alts;
   string name;
   if (yesno[0] != 'y') {
      write("Ok, cancelling lockout...\n");
      write("Lockout cancelled.\n");
      return 1;
   }
   if(!info[player->query_name()]) {
      write("Something went wrong, please try again.\n");
      return 0;
   }
   tim = info[player->query_name()][0];
   reason = info[player->query_name()][1];
   alts = info[player->query_name()][2];
   foreach (name in alts) {
      if (!"/secure/bastards"->lockout_person(name,
                                           tim*60*60, reason)) {
         write("Sorry, we failed.\n");
         return 0;
      }
   }
   write("Ok, you are now locked out.  Quit when ready.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<number'number of'> "
                     "<word'days|weeks|hours'> <string'reason'>",
                     (: cmd($4[0], $4[1], implode($4[2..], " "), 0 ) :),
             "alts <number'number of'> "
                     "<word'days|weeks|hours'> <string'reason'>",
                     (: cmd($4[0], $4[1], implode($4[2..], " "), 1 ) :) });
}

==================================================
FILE: /lib/cmds/player/mailinfo.c
==================================================

#include <mail.h>
#include <player_handler.h>
mixed cmd(string str) {
  if (!str || str=="")
    str = this_player()->query_name();
  else
    str = this_player()->expand_nickname(str);
  if (!PLAYER_HANDLER->test_user(lower_case(str)))
  {
    write("Sorry, but I don't know any "+capitalize(str)+".\n");
    return 1;
  }
  write("Player "+capitalize(str)+": "+(string)MAILER->finger_mail(str));
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: /lib/cmds/player/make.c
==================================================

#include <config.h>
#include <weather.h>
#include <move_failures.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
inherit  "/cmds/base";
#define TP this_player()
private string *_snow_creatures = ({
    "snowman",
    "snowwoman",
    "snowboy",
    "snowgirl",
    "snowbunny",
    "snowfrog",
    "snowball",
    "snowwomble",
    "snowangel",
    "snowcabbage",
    "snowwitch",
    "snowwizard",
    "snowwarrior",
    "snowthief",
    "snowpriest",
    "snowassassin",
    "snowfamily",
    "snowfox",
    "snowdwarf",
    "snowplayerkiller",
    "snowtroll"
});
private string _make_pattern_cache;
void create() {
    ::create();
    _snow_creatures = sort_array( _snow_creatures, 1 );
}
int is_snowing(object player, string str) {
  object env;
  int *co_ords;
  env = environment(player);
  if ((string)env->query_property("location") == "inside") {
    add_failed_mess("You must be outside to make a " + str + ".\n");
    return 0;
  }
  co_ords = (mixed *)env->query_co_ord();
  if (!WEATHER->query_snowing(env)) {
     add_failed_mess("You need snow to make a " + str + ".\n");
     return 0;
  }
  return 1;
}
mixed cmd(string str) {
  object ob;
  object env;
  env = environment(TP);
  switch (str) {
  case "snowball" :
    if (is_snowing(TP, str)) {
      ob = clone_object("/std/environ/snowball");
      if (ob->move(TP) != MOVE_OK) {
        add_succeeded_mess(({ "$N try to make a snowball, but you cannot "
                              "pick it up so it disintergrates in "
                              "disinterest.\n",
                              "$N tries to make a snowball, but they cannot "
                                "pick it up.\n" }));
      } else {
        add_succeeded_mess(({
          "$N $V a lovely big snowball.  Have fun with it ;)\n",
            "$N $V a lovely big snowball.\n" }));
      }
      return 1;
    }
    break;
#ifndef __DISTRIBUTION_LIB__
  case "cream pie":
    if (SPECIAL_DAY_HANDLER->query_special_day() == CREAM_PIE_DAY) {
      if (TP->query_property("made cream pie")) {
        add_failed_mess("You made a cream pie less than 30 seconds ago.  "
                        "Don't be greedy now.\n");
      } else {
        ob = clone_object("/obj/misc/cream_pie");
        if (ob->move(TP) != MOVE_OK) {
          add_succeeded_mess(({ "You try to magicaly conjure a cream pie up "
                                  "out of nowhere, but you cannot pick it up.\n",
                                  "$N tries to conjure up a cream pie, but "
                                  "just looks silly.\n" }));
          ob->dest_me();
          return 1;
        } else {
          TP->add_property("made cream pie", 1, 30);
          add_succeeded_mess("$N conjure$s up $I.\n", ({ ob }));
          return 1;
        }
      }
    } else {
       add_failed_mess("You can only create cream pies on cream pie day!\n");
    }
    break;
  default:
    if ( member_array( str, _snow_creatures ) > -1 ) {
        if (is_snowing(TP, str)) {
          ob = clone_object("/std/environ/snowman");
          ob->set_type(str);
          ob->move(env);
          add_succeeded_mess("$N $V a beautiful " + str + ".\n");
          return 1;
        }
    }
    break;
#endif
  }
  return 0;
}
mixed *query_patterns() {
    if ( !_make_pattern_cache ) {
        _make_pattern_cache = "{" + implode( _snow_creatures +
            ({ "cream pie" }), "|" ) + "}";
    }
   return ({ _make_pattern_cache, (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/map.c
==================================================

inherit "/cmds/base";
int do_map() {
   string map;
   int* coords;
   object env;
   string handler;
   env = environment(this_player());
   if (!env)  {
      add_failed_mess("You are somewhere not on any map.\n");
      return 0;
   }
   if (this_player()->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   switch(this_player()->check_dark(environment(this_player())->query_light()))
   {
   case -2:
   case -1:
     return add_failed_mess("It is too dark to see anything.\n");
   case 2:
   case 1:
     return add_failed_mess("It is too bright to see anything.\n");
   }
   coords = env->query_terrain_coords();
   handler = env->query_terrain_handler();
   if (!coords  ||  !handler) {
      add_failed_mess("You can only do this in a terrain.\n");
      return 0;
   }
   map = handler->query_player_map(coords[0], coords[1], coords[2],
                                   env->query_visibility(env));
   if (!map) {
      add_failed_mess("There is no map available here.\n");
      return 0;
   }
   write(map);
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: do_map :) });
}

==================================================
FILE: /lib/cmds/player/mccp.c
==================================================

inherit "/cmds/base";
int cmd() {
    object *players;
    int compressed;
    if ( compressedp( this_player() ) ) {
        tell_object( this_player(), "You are currently using MCCP to "
          "connect to " + mud_name() + ".\n" );
    }
    else {
        tell_object( this_player(), "You are not currently using MCCP to "
          "connect to " + mud_name() + ".  Please read 'help compression' for "
          "more information about MCCP.\n" );
    }
    players = filter( users(), (: !$1->query_login_ob() &&
        reference_allowed( $1, $(this_player()) ) :) );
    compressed = sizeof( filter( players, (: compressedp :) ) );
    tell_object( this_player(), "%^BOLD%^$C$" + query_num( compressed, 1000 ) +
                 " users (" + ((compressed * 100) / sizeof(players)) + "%) are "
                 "currently using MCCP and " + query_num(sizeof(players) - compressed, 1000) + " users (" + (((sizeof(players) - compressed) * 100) / sizeof(players)) + "%) are uncompressed.%^RESET%^\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd :) });
}

==================================================
FILE: /lib/cmds/player/money.c
==================================================

#include <money.h>
inherit "/cmds/base";
private mapping _money_types;
void create()
{
   string zone;
   string *zones;
   zones = MONEY_HAND->query_all_places();
   _money_types = allocate_mapping(sizeof(zones));
   foreach(zone in zones) {
      _money_types[lower_case(zone)] = zone;
   }
   ::create();
   return;
}
int cmd(string str,
        int brief,
        object * containers)
{
   object *monies;
   object new_money;
   object *divided_money;
   object money;
   object tmp_money;
   object *inv;
   mixed *total;
   int success;
   if (this_player()->
          check_dark(environment(this_player())->query_light()) < 0)
   {
      add_failed_mess("It's too dark to count your money.\n");
      return 0;
   }
   if (str) {
      if (str == "here") {
         if (environment(this_player())->query_bank_name())
            str = environment(this_player())->query_money_place();
         else
            str = environment(this_player())->query_property("place");
         if (!str) {
            add_failed_mess("No idea what type of currency is used here.\n");
            return 0;
         }
      }
      str = lower_case(str);
      if (!_money_types[str]) {
         add_failed_mess("This is not a valid type of money, try one of " +
            query_multiple_short(keys(_money_types) + ({ "here" })) + ".\n");
         return 0;
      }
   }
   inv = all_inventory(this_player());
   monies = filter_array(inv, (: this_object()->find_the_dough($1) :));
   total = ({ });
   if (sizeof(monies)) {
      success = 0;
      divided_money = ({ 0, 0 });
      foreach(money in monies) {
         tmp_money = 0;
         if (!str) {
            tmp_money = money;
         } else if (str && _money_types[str]) {
            new_money = MONEY_VAULT->get_money_ob();
            new_money->set_money_array(money->query_money_array());
            divided_money = MONEY_HAND->
               filter_legal_tender(new_money, _money_types[lower_case(str)]);
            tmp_money = divided_money[0];
            if (divided_money[1]) {
               divided_money[1]->dest_me();
            }
         }
         if (tmp_money) {
               if (!brief) {
                  write("Your purse contains " +
                        query_multiple_short(tmp_money->half_short(1)) +
                        ".\n");
               }
               else  {
                  write("Your purse contains " +
                     query_multiple_short(tmp_money->half_symbol_short()) +
                     ".\n");
               }
            success++;
            if (divided_money[0]) {
               divided_money[0]->dest_me();
            }
         }
      }
      if (!success) {
         write("You have no money from the Land of " + capitalize(str) +
               ".\n");
      }
   }
   else write("You are flat broke.\n");
   return 1;
}
int find_the_dough(object env)
{
   if (member_array(MONEY_ALIAS, env->query_alias()) > -1) {
      while ((env = environment(env)) != this_player()) {
         if (env->query_closed() && !env->query_transparent()) {
            return 0;
         }
      }
      return 1;
   } else
      return 0;
}
mixed *query_patterns()
{
   return ({ "", (: cmd(0, 0, 0) :),
             "brief", (: cmd(0, 1, 0) :),
             "<string'area name'>", (: cmd($4[0], 0, 0) :),
             "<string'area name'> brief", (: cmd($4[0], 1, 0) :),
          });
}

==================================================
FILE: /lib/cmds/player/monitor.c
==================================================

#include <cmds/options.h>
inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  int monitor;
  monitor = TP->query_monitor();
  if(!str) {
    write("Your hit point monitor is set to " + MONITOR_OPTIONS[monitor] +
          ".\n");
    return 1;
  }
  if(member_array(str, MONITOR_OPTIONS) != -1) {
    write("Your hit point monitor is set to " + str + ".\n");
    TP->set_monitor(member_array(str, MONITOR_OPTIONS));
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{" + implode(MONITOR_OPTIONS, "|") + "}", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/mudlist.c
==================================================

#define INTERMUD_D "/net/intermud3/intermud"
int cmd(string str) {
  mixed *info;
  string *list;
  mapping borg;
  string mud;
  if( str && str != "") {
    mapping tmp;
    string opt, tmpstr;
    tmp = (mapping)INTERMUD_D->GetMudList();
    if( str[0] != '-' ) str = "-n " + str;
    opt = str[1..1];
    str = str[3..];
    borg = ([]);
    foreach(mud, info in tmp) {
      int x, y, z;
      switch(opt) {
      case "m":
        x = 5;
        break;
      case "d":
        x = 7;
        break;
      case "n":
        x = 0;
        break;
      }
      tmpstr = (x ? info[x] : mud);
      z = strlen(str = replace_string(lower_case(str), " ", ""));
      y = strlen(tmpstr = replace_string(lower_case(tmpstr), " ", ""));
      if( str == tmpstr ) {
        borg = ([ mud : info ]);
        break;
      }
      else if( y > z && tmpstr[0..z-1] == str && info[0] == -1 )
        borg[mud] = info;
    }
  }
  else {
    borg = ([ ]);
    foreach( mud, info in (mapping)INTERMUD_D->GetMudList() )
      if( info[0] == -1 ) borg[mud] = info;
  }
  if( !sizeof(borg) ) {
    write(mud_name()+" does not have any MUD matching "+str+" in "
          "its mudlist.\n");
    return 1;
  }
  else if( sizeof(borg) == 1 ) {
    string msg, svc;
    int val, comma = 0;
    mud = keys(borg)[0];
    msg = "\nDetailed information on %^GREEN%^" + mud + "%^RESET%^:\n";
    msg += "Server: " + borg[mud][7] + " (" + borg[mud][8] + ")\n";
    msg += "BaseLib: " + borg[mud][6] + "\n";
    msg += "Library: " + borg[mud][5] + "\n";
    msg += "Status: " + borg[mud][9] + "\n";
    msg += "Admin E-mail: " + borg[mud][10] + "\n";
    msg += "Services: ";
    foreach(svc, val in borg[mud][11]) {
      if( val == 1 ) {
        if( comma ) msg += ", " + svc;
        else {
          msg += svc;
          comma = 1;
        }
      }
    }
    msg += "\nHost: " + borg[mud][1] + "\n";
    msg += "Telnet port: " + borg[mud][2] + "\n";
    if( borg[mud][11]["http"] )
      msg += "HTTP port (World Wide Web): " + borg[mud][11]["http"]+"\n";
    if( borg[mud][11]["ftp"] )
      msg += "FTP port (File Transfer): " + borg[mud][11]["ftp"] + "\n";
    if( borg[mud][11]["rcp"] )
      msg += "RCP port (Remote Creator): " + borg[mud][11]["rcp"] + "\n";
    write(msg);
    return 1;
  }
  list = ({});
  foreach(mud, info in borg)
    list += ({ sprintf("%:-15s %:-10s %:-15s %:-15s %s %d",
                       mud, info[8], info[7], info[5], info[1], info[2]) });
  list = sort_array(list, 1);
  list = ({ mud_name() + " recognizes " + sizeof(borg)+" muds"
              " matching your query: ", "" }) + list;
  previous_object()->more_string(implode(list, "\n")+"\n", "Mudlist");
  return 1;
}
int alphabet(string a, string b) {
    if((a = lower_case(a)) == (b = lower_case(b))) return 0;
    else if(a > b) return 1;
    else return -1;
}
void help() {
    message("help", "Syntax: <mudlist>\n"
      "        <mudlist -dmn [arg]>\n\n"
      "Without any arguments, it gives a full listing of all muds "
      "with which this mud is capable of communication through "
      "tell, mail, finger, rwho, and other intermud services.  "
      "With arguments, <mudlist> requires one and only one option "
      "which must be one of the following:\n"
      "\t-d [driver]: List only muds using the named driver\n"
      "\t-m [mudlib]: List only muds using the named mudlib\n"
      "\t-n [mudname]: List only the muds with the name given\n\n"
      "Note that the argument need not be complete, for example:\n"
      "\t mudlist -n idea\n"
      "will list IdeaExchange as well as any other mud whose name "
      "begins with the string \"idea\".\n\n"
      "See also: finger, mail, rwho, tell", this_player());
}
void clean_up() {
  destruct(this_object());
}
void reset() {
  destruct(this_object());
}
void dest_me() {
  destruct(this_object());
}

==================================================
FILE: /lib/cmds/player/news.c
==================================================

#include <board.h>
inherit "/cmds/base";
object board;
string board_name = "announcements";
void do_list(int all);
int do_read(int num);
#define LOGON_LIMIT 10
#define MOST 1
#define ALL 2
#define SOME 0
mixed cmd(string str) {
  int msg;
  switch(str) {
  case "help":
  case "?":
  case "h":
    tell_object( this_player(),
                "Usage:\n"
                "To read next news item type: \"news\".\n"
                "To read a specific news item type: \"news <num>\".\n"
                "To list new news items type: \"news list\".\n"
                "To list all news items type: \"news review\".\n");
    break;
  case "l":
  case "list":
    do_list(MOST);
    break;
  case "r":
  case "review":
    do_list(ALL);
    break;
  default:
    if(str) sscanf(str, "%d", msg);
    do_read(msg);
  }
  return 1;
}
int do_read(int num) {
  mapping news_rc;
  mixed *stuff;
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if ( !news_rc ) {
    news_rc = ([ ]);
  }
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if(!num) {
    num = sizeof(stuff);
    while((num > 0) && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
    }
    if(num == sizeof(stuff)) {
      write("No news is good news.\n");
      return 1;
    }
    num++;
  }
  if(num < 0) {
    num = sizeof(stuff) + num + 1;
  }
  if(( num < 1) || (num > sizeof(stuff))) {
    write("No news item of that number.\n");
    return 1;
  }
  num--;
  if(news_rc[ board_name ] < stuff[ num ][ B_TIME ]) {
    news_rc[ board_name ] = stuff[ num ][ B_TIME ];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  this_player()->more_string( "Note #"+ ( num + 1 ) +" posted at " +
        ctime(stuff[num][B_TIME])[0..9] + " Title: \""+
        stuff[ num ][ B_SUBJECT ][ 0 .. (int)this_player()->query_cols() -
       10 ] +"\"\n\n"+ (string)BOARD_HAND->get_message( board_name, num ),
       "[Note "+ ( num + 1 ) +"]" );
  return 1;
}
string the_date(int i) {
  return ctime(i)[4..9];
}
void do_list(int all) {
  int i, newones;
  mixed *stuff;
  string ret;
  mapping news_rc;
  ret = "";
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (!sizeof(stuff)) {
    tell_object(this_player(), "No news is good news.\n");
    return;
  }
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc) {
    news_rc = ([ ]);
  }
  newones = 0;
  for (i = 0; i < sizeof(stuff); i++) {
    if (news_rc[board_name] < stuff[i][B_TIME]) {
      ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
      newones += 1;
      if (all == SOME) {
        if (newones > LOGON_LIMIT) {
          write("Plus more....\n");
          break;
        }
      }
    } else if(all == ALL) {
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
    }
  }
  if(!newones && all != ALL) {
    ret += "\nNo news is good news.\n";
  }
  if (all == SOME) {
    ret += "\nUse 'news list' for all new news items and 'news review' for all news times.\n";
  }
  this_player()->more_string( ret, "News" );
}

==================================================
FILE: /lib/cmds/player/nickname.c
==================================================

inherit "cmds/base";
int print_nicknames(mapping map_nicknames);
int add_nickname(string str, mapping map_nicknames);
int print_single_nickname(string str) {
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  str = lower_case(str);
  if(!map_nicknames[str]) {
    add_failed_mess("That nickname does not exist.\n");
    return 0;
  }
  write("Setting for nickname "+str+" is "+map_nicknames[str]+".\n");
  return 1;
}
int print_nicknames(int sorted) {
  int i;
  int cols;
  string str;
  string str_long;
  string str_middle;
  string str_small;
  string bit;
  string *tmp;
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  bit = "";
  str_long = "";
  str_middle = "";
  str_small = "";
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!sizeof(map_nicknames)) {
     write("You do not have any nicknames.\n");
     return 1;
  }
  tmp = sort_array(keys(map_nicknames), 1);
  cols = (int)this_player()->query_cols();
  for (i=0;i<sizeof(tmp);i++) {
    str = tmp[i]+": "+map_nicknames[tmp[i]]+"  ";
    if (strlen(str) > 39 || sorted) {
      str_long += sprintf(tmp[i]+": %-=*s\n", cols - strlen(tmp[i]), map_nicknames[tmp[i]]);
    } else if (strlen(str) > 19) {
      str_middle += str+"\n";
    } else {
      str_small += str+"\n";
    }
  }
  if (strlen(str_middle)) {
    str_long += sprintf("%-#*s\n", cols, str_middle);
  }
  if (strlen(str_small)) {
    str_long += sprintf("%-#*s\n", cols, str_small);
  }
  this_player()->more_string(str_long, "Nicknames");
  return 1;
}
int add_nickname(string s1, string s2) {
  mapping map_nicknames;
  s1 = lower_case(s1);
  s2 = lower_case(s2);
  if( member_array( s1, ({ "a", "an", "the" }) ) != -1 ) {
    add_failed_mess( "Using articles as nicknames confuses the parser.  "
                     "Choose another.\n" );
    return 0;
  }
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!map_nicknames[s1]) {
    map_nicknames[s1] = s2;
    write("Added nickname "+s1+" for "+s2+".\n");
    return 1;
  }
  write("Changed nickname "+s1+" from "+map_nicknames[s1]+" to "+s2+".\n");
  map_nicknames[s1] = s2;
  this_player()->set_nicknames(map_nicknames);
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: print_nicknames(0) :),
             "sorted", (: print_nicknames(1) :),
             "<string'nickname'>", (: print_single_nickname($4[0]) :),
             "<string'nickname'> <string'realname'>", (: add_nickname($4[0], $4[1]) :)
           });
}

==================================================
FILE: /lib/cmds/player/options.c
==================================================

inherit "/cmds/base";
#include <cmds/options.h>
int cmd_set(string option, string value);
int cmd_display(string option) {
   string *bits;
   string *groups;
   string bing;
   if (sscanf(option, "%s=%s", option, bing) == 2) {
      return cmd_set(option, bing);
   }
   if (OPTION_HANDLER->is_option(this_player(), option)) {
     write(sprintf("%-20s = %s (%s)\n", option,
                   OPTION_HANDLER->query_option_value(this_player(), option),
                   OPTION_HANDLER->query_option_help(this_player(),option)));
      return 1;
   } else if (OPTION_HANDLER->is_option_group(this_player(), option)) {
      bits = OPTION_HANDLER->query_sub_options(this_player(), option);
      if (option == "") {
         write("Top level:\n");
      } else {
         write(option + ":\n");
      }
      bits = sort_array(bits, (: strcmp :));
      groups = filter(bits, (: OPTION_HANDLER->is_option_group(this_player(),
                                               $2 + " " + $1) :), option);
      bits -= groups;
      foreach (bing in groups) {
         write(sprintf("   %-17s <more options>\n", bing));
      }
      foreach (bing in bits) {
         if (OPTION_HANDLER->is_option(this_player(), option + " " + bing)) {
            write(sprintf("$I$30=   %-17s = %-10s <%s>\n", bing,
                    OPTION_HANDLER->query_option_value(this_player(),
                                                     option + " " + bing),
                    implode(OPTION_HANDLER->query_option_values(this_player(),
                                        option + " " + bing), "|")));
         }
      }
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
int cmd_set_all(string option, string value) {
   string* stuff;
   string* ok;
   string* bad;
   string opt;
   if (!OPTION_HANDLER->is_option_group(this_player(), option)) {
      add_failed_mess("The option must be an option group to use the 'all' "
                      "keywork.\n");
      return 0;
   }
   stuff = OPTION_HANDLER->query_sub_options(this_player(), option);
   option += " ";
   ok = ({ });
   bad = ({ });
   foreach (opt in stuff) {
      if (OPTION_HANDLER->is_option(this_player(), option + opt)) {
         if (OPTION_HANDLER->set_option_value(this_player(), option + opt,
                                              value)) {
            ok += ({ option + opt });
         } else {
            bad += ({ option + opt });
         }
      } else {
         bad += ({ option + opt });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("Set " + query_multiple_short(ok) + " to " +
                         value + ".\n");
      return 1;
   }
   add_failed_mess("Unable to set " + query_multiple_short(bad) + " to " +
                   value + ".\n");
   return 0;
}
int cmd_set(string option, string value) {
   string *bits;
   if (!option  ||  option == "")
      return 0;
   bits = explode(option, " ");
   if(!sizeof(bits))
     return 0;
   if (bits[<1] == "all") {
      if (sizeof(bits) > 1) {
         return cmd_set_all(implode(bits[0..<2], " "), value);
      }
      add_failed_mess("Cannot use 'all' as an option by itself.\n");
      return 0;
   }
   if (OPTION_HANDLER->is_option(this_player(), option)) {
      if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
         write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
         return 1;
      } else {
         add_failed_mess("Unable to set option " + option + " to " +
                value +
                ".\n");
         return 0;
      }
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
int cmd_edit(string option) {
   string value;
   if (OPTION_HANDLER->is_option(this_player(), option)) {
      value = OPTION_HANDLER->query_option_value(this_player(), option);
      write("Editing the option " + option + ".\n");
      this_player()->do_edit(value, "finish_edit", this_object(),
                             0, option);
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
void finish_edit(string value, string option) {
   if (!value) {
      write("Aborting.\n");
      return ;
   }
   if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
      write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
   } else {
      write("Unable to set the option " + option + ".\n");
   }
}
mixed *query_patterns() {
   return ({ "<string'option'>",
               (: cmd_display($4[0]) :),
             "",
               (: cmd_display("") :),
             "edit <string'option'>",
                (: cmd_edit($4[0]) :),
             "<string'option'> = <word'value'>",
                (: cmd_set($4[0], $4[1]) :),
             "<string'option'> all = <word'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             "set <string'option'> all <string:quoted'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             });
}

==================================================
FILE: /lib/cmds/player/perm_it.c
==================================================

inherit "/cmds/base";
int cmd( object player ) {
  object *corpses, corpse;
  int i;
  corpses = filter( children( "/obj/corpse" ),
                    (: $1 && $1->query_property("player" ) :) );
  corpses = filter( corpses,
                    (: $1 && $1->query_ownership() ==
                     $(this_player()->query_name()) :) );
  if( sizeof( corpses ) ) {
    foreach( corpse in corpses ){
      if(member_array(player->query_name(), corpse->query_permitted()) != -1) {
        i++;
      } else {
        corpse->give_permission( player->query_name() );
      }
    }
  } else {
    add_failed_mess("You don't seem to have a corpse!  Why not die and try "
                    "again?%^RESET%^\n");
    return 0;
  }
  if( i == sizeof( corpses ) ){
    write(capitalize(player->query_name()) + " is already permitted to "
          "remove items from your corpse.%^RESET%^\n" );
  } else {
    write(capitalize(player->query_name()) + " is now permitted to "
          "remove items from your corpse.%^RESET%^\n" );
    tell_object(player, "%^BOLD%^%^GREEN%^You now have permission to get "
                "items from " + this_player()->query_cap_name() +
                "'s corpse.%^RESET%^\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}

==================================================
FILE: /lib/cmds/player/position.c
==================================================

#include <player.h>
#define MAXLEN 30
inherit "/cmds/base";
private string* _bad_words;
void create() {
   _bad_words = ({ "teach", "skill", "finger", "lesson", ":)", ";)",
                   "chainsaw", "0", "1", "2", "3", "4", "5", "6", "7", "8",
                   "9", ":", ";", ",", "'", "*", "%", "!",
                   "@", "~", "`", "#", "$", "^", "&", "(", ")",
                   "_", "-", "=", "+", "{", "}", "[", "]",
                   "<", ".", ">", "?", "/", "\\",
                   ":->", ":-)", ";-)", ";->", "\""});
}
int cmd( string new_pos ) {
  object player = this_player();
  string word, tmp;
  if (!new_pos) {
    write("You are " + player->query_position_short() + ".\n");
    return 1;
  }
  if ( strlen(new_pos) > MAXLEN ) {
    add_failed_mess("Sorry, your position cannot be more than " +
                        MAXLEN + " letters long.\n");
    return 0;
  }
  if ( player->query_sp() < SET_POSITION_COST ) {
    add_failed_mess( NO_POWER );
    return 0;
  }
  new_pos = replace_string(new_pos, "^", "");
  new_pos = replace_string(new_pos, "%", "");
  tmp = lower_case(new_pos);
  foreach(word in _bad_words) {
    if(strsrch(tmp, word) != -1) {
      add_failed_mess("You cannot bring yourself to set that position.\n");
      return 0;
    }
  }
  player->set_position( new_pos );
  player->adjust_sp( - SET_POSITION_COST );
  tell_object( player, "People will now see:\n" +
               player->query_cap_name() + " is " + new_pos + ".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
          "<string'new position'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: /lib/cmds/player/pstatus.c
==================================================

broken
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <tune.h>
#include <skills.h>
inherit "/cmds/base";
string find_hp_string( int current, int max );
string find_gp_string( int current, int max );
string find_xp_string( int current );
string find_wimpy_string( int wimpy );
string find_surrender_string( int surr );
string find_align_string( object tp );
string find_death_string( int remaining );
int calc_percent( float x, float y );
int calc_xp_cost( string skill );
int cmd() {
   object me;
   me = this_player();
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if (this_player()->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   switch( me->query_verbose( "score" ) ) {
   case 1:
      printf( "%s.\n%s and %s.\n%s.\n%s.\n%s and %s.\n%s.\n%s.\n",
              "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ),
              capitalize( find_align_string( me ) ),
              capitalize( find_wimpy_string( me->query_wimpy() ) ),
              find_surrender_string( me->query_surrender() ),
              "You are "+ me->burden_string(),
              find_death_string( me->query_max_deaths() - me->query_deaths() ) );
      return 1;
   default:
      printf( "%s and %s.\n%s.\n",
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ) );
      return 1;
   }
}
int cmd_stats() {
   object me;
   int stat;
   string ret;
   me = this_player();
   ret = "";
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if ( stat = ( me->query_tmp_str() + me->query_bonus_str() ) ) {
      if ( stat > 0 ) {
         ret += "You feel stronger then usual.\n";
      } else {
         ret += "You feel weaker then usual.\n";
      }
   }
   if ( stat = ( me->query_tmp_int() + me->query_bonus_int() ) ) {
      if ( stat > 0 ) {
         ret += "You feel smarter then normal.\n";
      } else {
         ret += "You feel less smart then normal.\n";
      }
   }
   if ( stat = ( me->query_tmp_con() + me->query_bonus_con() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more healthy then usual.\n";
      } else {
         ret += "You feel a bit sickly.\n";
      }
   }
   if ( stat = ( me->query_tmp_dex() + me->query_bonus_dex() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more nimble then usual.\n";
      } else {
         ret += "You feel more clumsy than you normally do.\n";
      }
   }
   if ( stat = ( me->query_tmp_wis() + me->query_bonus_wis() ) ) {
      if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
      } else {
         ret += "You feel a bit vague.\n";
      }
   }
   if ( !strlen( ret ) ) {
      ret += "You feel fine.\n";
   }
   printf( "%s", ret );
   return 1;
}
string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are in perfect health";
   case 70..89:
      return "you are slightly wounded";
   case 50..69:
      return "you are moderately wounded";
   case 30..49:
      return "you are seriously wounded";
   case 15..29:
      return "you are critically wounded";
   case 6..14:
      return "you are fatally wounded";
   case 0..5:
      return "you are near death";
   default:
      return "you are broken";
   }
}
string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are full of energy";
   case 70..89:
      return "you are enthusiastic";
   case 50..69:
      return "you are not quite so full of beans";
   case 30..49:
      return "you are weary";
   case 15..29:
      return "you are tired";
   case 6..14:
      return "you are exhausted";
   case 0..5:
      return "you are nearly unconscious";
   default:
      return "you are broken";
   }
}
string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   xptotal /= sizeof( skills );
   tell_creator( find_player( "terano" ), "%s: Current XP is: %d, Avg XP is %d, Ratio is: %d.\n",
                 this_player()->query_name(), current, xptotal, calc_percent( current, xptotal ) );
   switch( calc_percent( current, xptotal ) ) {
   case 0..20:
      return "you don't think you can learn much at the moment";
   case 21..59:
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100:
      return "if you squeezed it, you could gain some insight";
   case 101..300:
      return "you might be able to learn something new, if you found the right teacher";
   case 301..400:
      return "a small amount could be learned with training";
   case 401..800:
      return "a bit of training might be in order";
   case 801..1200:
      return "you could very well learn something new from training";
   case 1201..1500:
      return "you could benefit from training";
   case 1501..2000:
      return "you feel like training might help";
   case 2001..2500:
      return "you should consider training your skills";
   case 2501..4000:
      return "your skills could be greatly improved with training";
   default:
      return "certainly a hearty training session is in order!";
   }
}
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
}
string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
}
string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
}
string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }
   switch ( remaining ) {
   case 0..0:
      return "Death has a special interest in your next appointment";
   case 1..3:
      return "Death is starting to lose patience with you";
   case 4..7:
      return "You and Death are on good terms";
   default:
      return "You have an \"arrangement\" with Death";
   }
}
int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;
   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   if (!total) {
      total = cost;
   }
   return total;
}
int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
}
mixed *query_patterns() {
   return ({ "", (: cmd() :), "stats", (: cmd_stats() :) });
}

==================================================
FILE: /lib/cmds/player/qalias.c
==================================================

int cmd()
{
   string *aliases, alias_mess, message;
   int cols;
   aliases = keys( this_player()->query_aliases() );
   if( !sizeof( aliases ) )
   {
      tell_object( this_player(), "You have no aliases.\n" );
      return 1;
   }
   message = "\nYou have the following aliases:\n";
   aliases = sort_array( aliases, (: strcmp :) );
   alias_mess = implode( aliases, ", " );
   cols = this_player()->query_cols() - 3;
   message += sprintf( "   %-=*s\n", cols, alias_mess );
   message += "A total of " + sizeof( aliases ) + " aliases.\n";
   tell_object( this_player(), message );
   return 1;
}
mixed *query_patterns()
{
   return ({ "", (: cmd() :) });
}

==================================================
FILE: /lib/cmds/player/qwho.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>
int playercompare(object p1, object p2);
int cmd(string guild_name) {
   int i;
   int countcre;
   int countplay;
   int counttest;
   int countloginq;
   int countlogins;
   int compressed;
   string obtyp;
   string tmp;
   object *arr;
   string nam;
   string cres;
   string plays;
   string testers;
   string *login_q;
   string logins;
   int showmasters;
   mapping user_data;
   object *liaisons;
   string friends;
   int countFriends;
   int totalUsers;
   int totalPlayers;
   int totalCompressed;
   if (this_player()->query_creator()) {
      showmasters = 1;
   } else {
      showmasters = 0;
   }
   countcre = 0;
   countplay = 0;
   counttest = 0;
   compressed = 0;
   cres = "";
   plays = "";
   testers = "";
   logins = "";
   friends = "";
   user_data = unique_mapping( users(),
       (: "/d/liaison/master"->query_member( $1->query_name() ) :) );
   if ( user_data[1] ) {
       liaisons = sort_array( user_data[1], (: playercompare :) );
   }
   else {
       liaisons = ({ });
    }
   if ( user_data[0] ) {
       arr = sort_array( user_data[0], (: playercompare :));
   }
   else {
       arr = ({ });
   }
   arr = liaisons + arr;
   arr = filter(arr, (: (!$1->query_invis() || reference_allowed(this_player(),
     $1)) && !$1->query_login_ob() :) );
   if (guild_name) {
      arr = "/cmds/player/who"->filter_users(arr, guild_name, 1);
      if (!sizeof(arr)) {
         add_failed_mess("Unable to find any members of " +
                         guild_name + ".\n");
         return 0;
      }
   }
   for(i=0;i<sizeof(arr);i++) {
      nam = arr[i]->query_cap_name();
      if (!nam) {
         if (showmasters) {
            nam = "/secure/master";
         } else {
            continue;
         }
      }
      switch (arr[i]->query_invis()) {
      case 0:
         break;
      case 1:
         nam = "[" + nam + "]";
         break;
      case 2:
         nam = "[{" + nam + "}]";
         break;
      case 3:
         nam = "[<" + nam + ">]";
         break;
      default:
         nam = "?" + nam + "?";
         break;
      }
      obtyp = arr[i]->query_object_type();
      switch(obtyp) {
      case "X":
         break;
      case " ":
         break;
      case "C":
         nam += "(%^CYAN%^C%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "S":
         nam += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "T":
         nam += "(%^BOLD%^%^RED%^T%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "D":
         nam += "(%^RED%^D%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      default:
         break;
      }
      if (this_player()->is_friend(arr[i]->query_name())) {
         nam += "(%^GREEN%^F%^RESET%^)";
      }
      if (compressedp(arr[i])) {
          compressed++;
      }
      if (arr[i]->query_creator()) {
         countcre++;
         cres = cres + " " + nam;
      } else if (obtyp == "p") {
         counttest++;
         testers = testers + " " + nam;
      } else if(arr[i]->query_login_ob()) {
         countlogins++;
         logins = logins + " " + nam;
      } else if (this_player()->is_friend(arr[i]->query_name())) {
         countFriends++;
         friends = friends + " " + nam;
      } else {
         countplay++;
         plays = plays + " " + nam;
      }
   }
   if (guild_name) {
      arr = LOGIN_HANDLER->query_login_queue();
      arr = "/cmds/player/who"->filter_users(arr, guild_name);
      login_q = map(arr, (: $1->query_cap_name() :));
   } else {
      login_q = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
   }
   login_q = filter(login_q, (: $1 :));
   login_q = sort_array(login_q, 1);
   countloginq = sizeof(login_q);
   tmp = sprintf("%%^BOLD%%^%d Creator%s:%%^RESET%%^%s\n",
                 countcre, countcre != 1 ? "s" : "", cres);
   write(tmp);
   if (guild_name != "creator" && guild_name != "creators") {
      switch (counttest) {
        case 0:
            break;
        case 1:
           write("%^BOLD%^" + counttest + " Playtester:%^RESET%^" + testers + "\n");
        break;
        default:
           write("%^BOLD%^" + counttest + " Playtesters:%^RESET%^" + testers + "\n");
        break;
     }
      if (countFriends) {
         write("%^GREEN%^" + countFriends + " Friend" +
             (countFriends > 1 ? "s" : "") + ":%^RESET%^" + friends + "\n");
      }
      write("%^BOLD%^" + countplay + " Players:%^RESET%^" + plays + "\n");
      if (countlogins < countloginq) {
         countlogins = countloginq;
      }
      if (countlogins-countloginq) {
         logins = replace(logins, ({ "[", "", "]", ""}));
         if(countloginq) {
            foreach(tmp in login_q) {
               logins = replace(logins, tmp+" ", "");
            }
         }
         write("%^BOLD%^" + (countlogins - countloginq) +
               " Logging in:%^RESET%^" + logins + "\n");
      }
      if(countloginq) {
         write("%^BOLD%^" + countloginq + " Queued:%^RESET%^ " +
               implode(login_q, " ") + "\n");
      }
   } else {
      countlogins = 0;
      counttest = 0;
      countplay = 0;
   }
   totalUsers = countcre + counttest + countplay + countlogins + countFriends;
   totalPlayers = counttest + countplay + countFriends;
   totalCompressed = compressed - countFriends;
   write("%^BOLD%^" + (totalPlayers) + " Players, " +
         totalUsers + " Total%^RESET%^\n" );
   return 1;
}
int playercompare(object p1, object p2) {
   return strcmp(p1->query_name(), p2->query_name());
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string'guild name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/recover.c
==================================================

#include <obj_parser.h>
inherit "/cmds/base";
#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
#include <player.h>
#define MAX_RECOVER 20
int cmd_recover(string name) {
   object* obs;
   object* fail;
   object* ok_me;
   object* ok_here;
   object cont;
   object ob;
   class obj_match omatch;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   if (this_player()->query_property("dead")) {
      add_failed_mess("You're a disembodied spirit, how do you expect to "
                      "recover anything at all?\n");
      return 0;
   }
   cont = BURY_EFFECT->query_buried_container(environment(this_player()));
   if (!cont) {
      add_failed_mess("There is nothing buried here.\n");
      return 0;
   }
   omatch = (class obj_match)match_objects_in_environments(name, cont);
   if (omatch->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(omatch));
      return 0;
   }
   obs = omatch->objects;
   if ( sizeof( obs ) > MAX_RECOVER ) {
      add_failed_mess( "You can only recover " +
        query_num( MAX_RECOVER ) + " items at a time.\n" );
      return 0;
   }
   fail = ({ });
   ok_me = ({ });
   ok_here = ({ });
   if (sizeof(obs)) {
      foreach (ob in obs) {
#ifndef __DISTRIBUTION_LIB__
        if(interactive(this_player()) &&
           PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("recover",
                                                           this_player(),
                                                           ob)) {
          fail += ({ ob });
        } else
#endif
         if (ob->move(this_player()) == MOVE_OK) {
            ok_me += ({ ob });
         } else if (ob->move(environment(this_player())) == MOVE_OK) {
            ok_here += ({ ob });
         } else {
            fail += ({ ob });
         }
      }
      if (!sizeof(ok_me) && !sizeof(ok_here)) {
         add_failed_mess("Unable to recover $I.\n", fail);
         return 0;
      }
      if (sizeof(ok_me)) {
         add_succeeded_mess("$N $V $I.\n", ok_me);
      }
      if (sizeof(ok_here)) {
         add_succeeded_mess("$N $V $I and leave$s " +
                            (sizeof(ok_here) > 1?"them":"it") +
                            " here.\n", ok_here);
      }
      return 1;
   } else {
      ok_me = all_inventory(cont);
      if (sizeof(ok_me)) {
         add_failed_mess("Unable to recover " + name + ", available objects "
                       "are " + query_multiple_short(ok_me) +
                      ".\n");
      } else {
         add_failed_mess("Unable to recover " + name + ".\n");
      }
      return 0;
   }
}
mixed* query_patterns() {
   return ({ "<string'buried object'>", (: cmd_recover($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/refer.c
==================================================

#include <login.h>
#include <clubs.h>
inherit "/cmds/base";
int cmd(string str) {
   string ret;
   str = lower_case(str);
   str = (string)this_player()->expand_nickname(str);
   ret = (string)"/secure/finger"->refer_info(str);
   if (ret) {
      this_player()->more_string( this_player()->fit_message(ret),
                                  "refer: "+str );
      return 1;
   }
   add_failed_mess("No one by the name of " + str + " has "
                   "ever visited " + mud_name() + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({"<string'name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/register.c
==================================================

#include <player_handler.h>
#include <playerinfo.h>
inherit "/cmds/base";
int cmd(string alt) {
  string p1;
  string p2;
  alt = lower_case(alt);
  if (!PLAYER_HANDLER->test_user(alt))
    return notify_fail(alt + " is not a player.\n");
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if(!p1 || p1 == "") {
     p1 = this_player()->query_name();
   }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(p1 == p2) {
     add_failed_mess("You and " + alt + " are already registered.\n");
     return 0;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2)) &&
      sizeof(PLAYERINFO_HANDLER->query_alts(p1))) {
     add_failed_mess("Sorry, there is a clash of alts here, you'll need to "
                     "ask a creator for assistance.\n");
     return 0;
   }
  write("Enter your password (this character): ");
  input_to("get_pw", 1, this_player(), alt);
  return 1;
}
void get_pw(string pass, object player, string alt) {
  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  write("\nEnter the password for " + alt + ": ");
  input_to("get_alt_pw", 1, player, alt);
}
void get_alt_pw(string pass, object player, string alt) {
  string result;
  string p1, p2;
  write("\n");
  if(this_player() != player) {
    write("Something has gone wrong, player objects don't match.\n");
    return;
  }
  if (!PLAYER_HANDLER->test_password(alt, pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  p1 = PLAYERINFO_HANDLER->query_alt_of(player->query_name());
  if(!p1 || p1 == "") {
    p1 = player->query_name();
  }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2))) {
     write("Registering " + p1 + " as an alt of " + p2 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p2, p1);
   } else {
     write("Registering " + p2 + " as an alt of " + p1 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p1, p2);
   }
   write(result);
}
int cmd_list() {
   string* alts;
   string p1;
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!p1) {
      p1 = this_player()->query_name();
   }
   alts = (string*)PLAYERINFO_HANDLER->query_alts(p1) |
          (string*)PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!sizeof(alts)) {
      write("No alts registered.\n");
      return 1;
   }
   write("Your registered alts are " + query_multiple_short(alts) + ".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "list", (: cmd_list :),
             "<word'alt-name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/relationship.c
==================================================

#include <clubs.h>
inherit "/cmds/base";
string show_relationship(object from, object to, string rel, object telling);
int do_relationship(string relationship, object *players, int force) {
   object player;
   string family;
   string my_family;
   string their_family;
   string rel;
   class family_response_data frog;
   int ok;
   string *relations;
   my_family = this_player()->query_family_name();
   if (!my_family) {
      add_failed_mess("You must be in a family to form a relationship with "
                      "someone.\n");
      return 0;
   }
   my_family = CLUB_HANDLER->query_club_name(my_family);
   rel = CLUB_HANDLER->query_ungendered_relationship(relationship);
   if (!rel) {
      add_failed_mess("The relationship '" + relationship +
                      "' is not valid.  The valid relationships are " +
                      query_multiple_short(
                              CLUB_HANDLER->query_all_relationships()) +
                      ".\n");
      return 0;
   }
   relationship = rel;
   foreach (player in players) {
      player->check_family_name();
      their_family = player->query_family_name();
      relations = CLUB_HANDLER->query_relationships_to(my_family,
                                                      this_player()->query_name(),
                                                      player->query_name());
      if (!their_family && sizeof(relations)) {
         foreach (rel in relations) {
            CLUB_HANDLER->remove_relationship(my_family,
                                              this_player()->query_name(),
                                              their_family,
                                              player->query_name(),
                                              rel);
         }
      }
      rel = CLUB_HANDLER->query_relationship_gender(relationship,
                                                    player->query_female());
      if (sizeof(relations)) {
         if (member_array(relationship, relations) != -1 &&
             force) {
            family = my_family;
	    tell_object(player, this_player()->the_short() +
                             " offers to use "
                             "the relationship of " + rel + " with "
                             "you in the family " + my_family + " to allow "
                             "you to join the family.  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
            frog = new(class family_response_data);
            frog->family = family;
            frog->relationship = relationship;
            player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                        this_player(),
                                        frog);
            ok++;
            add_succeeded_mess(({
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\nThis will setup the "
                               "relationships of: " +
                               show_relationship(this_player(), player,
                                                 relationship, this_player()) + "\n",
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\n",
                                }),
                               ({ player }));
         } else {
            add_failed_mess("You are already related to $I, you can only force "
                            "them to join your family.\n", ({ player }) );
         }
      } else if (player->query_family_name()) {
         if (!force) {
	    if (!CLUB_HANDLER->is_valid_interfamily_relationship(relationship)) {
	       add_failed_mess("$I is in a family already and '" +
                               rel +
			       "' is not a valid interfamily relationship.\n");
	       continue;
	    }
	    family = player->query_family_name();
	    tell_object(player, this_player()->the_short() +
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you.  This will not cause you to change the "
                             "family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() +
                             " as " + rel + "\n");
	 } else {
            if (!CLUB_HANDLER->is_valid_join_family_relationship(relationship)) {
               add_failed_mess("$I is in a family already and the "
                               "relationship '" + rel +
                               "' is not valid to cause them to join "
                               "your family.\n");
               continue;
            }
            family = my_family;
	    tell_object(player, this_player()->the_short() +
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
	 }
         frog = new(class family_response_data);
         frog->family = family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                     this_player(),
                                     frog);
         ok++;
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      } else {
         tell_object(player, this_player()->the_short() + " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
         frog = new(class family_response_data);
         frog->family = my_family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                     this_player(),
                                     frog);
         ok++;
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      }
   }
   return ok;
}
string show_relationship(object from, object to, string rel, object telling) {
   string opp;
   string from_arg;
   string to_arg;
   opp = CLUB_HANDLER->query_opposite_relationship(rel);
   if (from == telling) {
      from_arg = "are";
   } else {
      from_arg = "is";
   }
   if (to == telling) {
      to_arg = "are";
   } else {
      to_arg = "is";
   }
   return from->the_short() + " " + from_arg + " the " +
          CLUB_HANDLER->query_relationship_gender(rel, from->query_female()) +
          " of " + to->the_short() + " and " +
          to->the_short() + " " + to_arg + " the " +
          CLUB_HANDLER->query_relationship_gender(opp, to->query_female()) +
          " of " + from->the_short() + ".";
}
int list_relationships() {
   string *relationships;
   relationships = CLUB_HANDLER->query_all_relationships();
   relationships = map(sort_array(relationships, 1), (: capitalize($1) :));
   printf("The currently allowed relationships are:\n   %-=*s\n",
          this_player()->query_cols() - 4,
          query_multiple_short(relationships) + ".");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'relationship'> with <indirect:player:here>",
                (: do_relationship($4[0], $1, 0) :),
             "<string'relationship'> with <indirect:player:here> and join family",
                (: do_relationship($4[0], $1, 1) :),
             "list",
               (: list_relationships() :) });
}

==================================================
FILE: /lib/cmds/player/rem_ote.c
==================================================

#include <library.h>
#include <player.h>
#include <network.h>
#define TELL_REPLY_LOCK_ID "lock fluff"
inherit "/cmds/base";
mixed cmd( object *obs, string words ) {
   object other;
   object *ok;
   object *ignoring;
   object *roleplaying;
   object *net_dead;
   object *fail;
   object *earmuffed;
   object *multiple_earmuffed;
   object *update_list;
   string* prop;
   string me_name;
   string tmp;
   string pad = " ";
   string* ok_string;
   int colour;
   if ( this_player()->query_role_playing() ) {
      add_failed_mess( "You cannot use remotes when you are role playing.\n" );
      return -1;
   }
   if ( this_player()->check_earmuffs( "remote" ) ) {
      if (this_player()->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         if (sizeof(filter(obs, (: !this_player()->is_friend($1->query_name()) :)))) {
            add_failed_mess("One of the people you are trying to remote is not a "
                            "friend (and you have tells earmuffed).\n");
            return -1;
         }
      } else {
         return notify_fail( "You have remote ear muffed.\n" );
      }
   }
   if ( userp( this_player() ) && !this_player()->query_creator() ) {
      if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
            "remote" ) )
         return notify_fail( NOT_ALLOWED );
      if ( environment( this_player() )->query_property( "no remote" ) )
         return 0;
      if ( (int)this_player()->adjust_sp( -REMOTE_COST ) < 0 )
         return notify_fail( NO_POWER );
   }
   ok = ({ });
   ignoring = ({ });
   roleplaying = ({ });
   net_dead = ({ });
   earmuffed = ({ });
   multiple_earmuffed = ({ });
   update_list = ({ });
   if (sizeof(obs) == 0)  {
      prop = this_player()->query_tell_reply_list();
      if (prop)
         obs = map(prop, (: find_player($1) :));
      else  {
         add_failed_mess("No one has told you anything in the last 15 "
                         "minutes.\n");
         return 0;
      }
   }
   if (sizeof(obs) == 1 && obs[0] == this_player()) {
      add_failed_mess("Interesting way of expression emotion, try "
                      "talking to someone else.\n");
      return 0;
   }
   fail = this_player()->query_ignoring(obs);
   if ( sizeof( fail ) )  {
      write( "You are currently ignoring " +
             query_multiple_short(fail) + ", so you ought to leave " +
             (sizeof(fail) > 1 ? "them" : fail[0]->query_objective()) +
             " alone.\n" );
      obs -= fail;
   }
   ok_string = ({ this_player()->query_name() });
   foreach (other in obs) {
      if ( other && other->query_property( "ignoring" ) ) {
         if ( member_array( (string)this_player()->query_name(),
                             other->query_property( "ignoring" ) ) != -1 &&
               !this_player()->query_creator()) {
           ignoring += ({ other });
           other = 0;
         }
      }
      if ( other && other->query_role_playing() &&
          !this_player()->query_creator() ) {
         roleplaying += ({ other });
         other = 0;
      }
      if (other) {
         this_player()->adjust_time_left( -10 );
         if( userp(other) &&
             !interactive( other ) ) {
            net_dead += ({ other });
         } else if( other->check_earmuffs( "remote" ) ) {
            earmuffed += ({ other });
         } else if( other->check_earmuffs( "multiple-remote" ) &&
                    sizeof(obs) > 1) {
            multiple_earmuffed += ({ other });
         } else if (other != this_player()) {
            ok += ({ other });
            ok_string |= ({ other->query_name() });
            prop = other->query_tell_reply_list();
            if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
               if (member_array(this_player()->query_name(), prop) != -1) {
                  other->set_tell_reply_list(prop);
               }
            } else {
               update_list += ({ other });
            }
         }
      }
   }
   update_list->set_tell_reply_list(ok_string);
   if( sizeof( ignoring ) ) {
      write( query_multiple_short(ignoring) +
            ( sizeof( ignoring ) > 1 ? " are":" is" ) +
            " ignoring you and will not have seen your message.\n" );
   }
   if ( sizeof( roleplaying ) ) {
      write( query_multiple_short( roleplaying ) +
            ( sizeof( roleplaying ) > 1 ? " are":" is" ) +
            " currently role playing and will not have seen your message.\n" );
   }
   if( sizeof( earmuffed ) ) {
      write( query_multiple_short( earmuffed ) +
            ( sizeof( earmuffed ) > 1 ? " have":" has" ) +
            " remotes earmuffed and will not have seen your message.\n" );
   }
   if (sizeof( multiple_earmuffed)) {
      write( query_multiple_short( multiple_earmuffed ) +
            ( sizeof( multiple_earmuffed ) > 1 ? " have":" has" ) +
            " multiple-remotes earmuffed and will not have seen your "
            "message.\n" );
   }
   colour = strsrch(words, "%^") != -1;
   words = replace(words, ({"        ", " ",
                              "       ", " ",
                              "      ", " ",
                              "     ", " ",
                              "    ", " ",
                              "   ", " ",
                              "  ", " "}));
   if (colour) {
      words += "%^RESET%^";
   }
   me_name = this_player()->query_short();
   if (this_player()->query_family_name()) {
      me_name += " " + this_player()->query_family_name();
   }
   if (words[0..0] == "'") pad = "";
   if (sizeof(net_dead) || sizeof(ok)) {
     if (sizeof(ok + net_dead) > 1) {
       foreach(other in ok)  {
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                         tmp +
                         "$C$Remotes to " +
                         query_multiple_short(net_dead + ok) + ": " +
                         me_name + pad + words +
                         (colour?"\n" + tmp + "--End of remote--": "") +
                         "%^RESET%^\n");
         other->add_tell_history(me_name + " remotes ", words, 1);
       }
     } else {
       foreach(other in ok)  {
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                       tmp + "$C$" + me_name + pad +
                       words +
                       (colour?"\n" + tmp + "--End of remote--": "") +
                       "%^RESET%^\n");
         other->add_tell_history(me_name + " ", words, 1);
       }
     }
     this_player()->add_tell_history("You remote to " +
                                      query_multiple_short(net_dead + ok, "a", 1) +
                                     ": ",
                                     me_name + pad + words, 1);
     write( "You remote to " + query_multiple_short(net_dead + ok) + ": $C$" +
            me_name + pad + words +"%^RESET%^\n" );
   }
   if( sizeof( net_dead ) ) {
      write( query_multiple_short( net_dead ) +
            ( sizeof( net_dead ) > 1 ? " are":" is" ) +
            " netdead and may not have seen your message.\n" );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player> <string>", (: cmd($1, $4[1]) :),
              "reply <string>",
              (: cmd(({ }), $4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/removeg_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
int do_leave(string group, object member);
mixed cmd(string str) {
  string group;
  object player, *members, member;
  notify_fail("Syntax: removegroup <member>\n");
  player = find_player(str);
  if(!(group = TEAM_HANDLER->query_group(this_player())))
    return notify_fail("You are not a member of a group.\n");
  if(TEAM_HANDLER->query_owner(group) != player)
    return notify_fail("Sorry, you are not the leader of " + group + ".\n");
  if(member_array(player, TEAM_HANDLER->query_members(group)) == -1)
    return notify_fail("Sorry, " + str + " is not a member of " + group +
                       ".\n");
  members = TEAM_HANDLER->query_members( group );
  if ( !members) {
    TEAM_HANDLER->leave_group(group, this_player());
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no members.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  } else if(!(TEAM_HANDLER->query_owner(group))) {
    TEAM_HANDLER->leave_group( group, member );
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no leader.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  }
  foreach( member in members ) {
    if ( !member )
      continue;
    tell_object(member, player->short()+" is removed from the "
                "group.\n");
  }
  do_leave(group, player);
  return 1;
}
int do_leave(string group, object member) {
   object person;
   if(!TEAM_HANDLER->leave_group(group, member))
      return notify_fail("Ack, something went wrong.\n");
   if ( !sizeof( (object *)TEAM_HANDLER->query_members( group ) ) )
      return 0;
   foreach(person in TEAM_HANDLER->query_members(group)) {
      if(person) {
         member->remove_protector(person);
         person->remove_protector(member);
         member->remove_follower(person);
         person->remove_follower(member);
      }
   }
   return 1;
}

==================================================
FILE: /lib/cmds/player/resize.c
==================================================

#include <telnet.h>
inherit "/cmds/base";
mixed cmd(string str) {
  printf("%c%c%c", IAC, DO, TELOPT_NAWS);
  write("Okay, resizing your terminal...\n");
  return 1;
}

==================================================
FILE: /lib/cmds/player/rituals.c
==================================================

#include <spells.h>
inherit "/cmds/base";
int cmd( string words ) {
   string spell, *religious;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   religious = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( sscanf( spells[ spell ][ 0 ], "%*spriest%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*srituals%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*swizard%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*switch%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*sspell%*s" ) == 2 )
         continue;
   }
   if ( !sizeof( religious ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   if ( sizeof( religious ) ) {
      write( "You know the following religious ritual"+
            ( sizeof( religious ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( religious, 1 ), "\n" ) );
   }
   return 1;
}

==================================================
FILE: /lib/cmds/player/rot13.c
==================================================

inherit "/cmds/base";
string rot13(string str);
int cmd(string str) {
   printf("You rot: \"%s\".\n", rot13(str));
   return 1;
}
string rot13(string str) {
   int i;
   for(i = 0; i < sizeof(str); i++) {
      if(str[i] >= 'A' && str[i] <= 'Z') {
         str[i] = ((13 + str[i] - 'A') % 26) + 'A';
      } else if(str[i] >= 'a' && str[i] <= 'z') {
         str[i] = ((13 + str[i] - 'a') % 26) + 'a';
      } else if(str[i] >= '0' && str[i] <= '9') {
         str[i] = ((5 + str[i] - '0') % 10) + '0';
      }
   }
   return str;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/rpskills.c
==================================================

#include <skills.h>
inherit "/cmds/base";
string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }
    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) ||
              (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero))))
        str += sprintf( "%*'| 's%*'.'-s " + (no_bonus?"\n":"%4s\n"),
              ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ],
              bonus_to_string( (int)this_player()->query_skill_bonus( tp ) ) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         if ((only_leaf || o_l) && (tmp != ""))
           str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
int cmd( string word ) {
   int i;
   string result, *bits;
   mixed *args;
   result = "";
   if ( !"/obj/handlers/playtesters"->query_tester( this_player() ) )
       return 0;
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Proficiency" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Proficiency");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}
# Total Tokens: 25130
# Total Files Merged: 28
# Total Characters: 83854

