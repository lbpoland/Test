# Total Tokens: 17781
# Total Files Merged: 32
# Total Characters: 59361

ct/extra_description.c
==================================================

#include <effect.h>
string query_classification() {
    return "object.extra_description";
}
void beginning( object thing , mixed *args ) {
    string description;
    int duration;
    description = args[ 0 ];
    duration = args[ 1 ];
    if( !stringp( description ) || !intp( duration ) ) return;
    thing->add_extra_look( this_object() );
    thing->submit_ee( 0 , duration , EE_REMOVE );
}
string extra_look( object thing ) {
    int *enums;
    string message, temp;
    enums = thing->effects_matching( query_classification() );
    if( !sizeof( enums ) ) {
        thing->remove_extra_look( this_object() );
        return "";
    }
    message = "";
    foreach( int elem in enums ) {
        temp =  ( thing->arg_of( elem ) ) [ 0 ];
        if( !stringp( temp ) ) {
            temp = "";
        } else {
           if( strlen( temp ) < 2 || temp[ <2 .. ] != "\n" ) temp += "\n";
        }
        message += temp;
    }
    return message;
}
void end( object thing , mixed *args , int id ) {
    if( sizeof( args ) == 3 && stringp( args[ 2 ] ) ) {
         string end_mess = args[ 2 ];
         if( end_mess[<2 .. ] != "\n" ) end_mess += "\n";
         tell_object( thing , end_mess );
    }
}

==================================================
FILE: effects/object/heat.c
==================================================

#include "path.h"
#include <effect.h>
string query_classification()
{
  return "object.heat";
}
string query_shadow_ob()
{
  return SHADOWS+"heat_shadow";
}
int beginning(object ob, int heat, int id)
{
  ob->submit_ee("change_temperature", ({ 45, 15 }), EE_CONTINUOUS);
  ob->add_extra_look(this_object());
  return heat;
}
void restart(object ob)
{
  ob->add_extra_look(this_object());
}
int merge_effect(object ob, int new_heat, int old_heat, int id)
{
  int heat;
  heat = new_heat + old_heat;
  if(heat < 21)
  {
    ob->submit_ee(0, 0, EE_REMOVE);
  }
  return heat;
}
void end(object ob, int heat, int id)
{
  ob->remove_extra_look(this_object());
}
void change_temperature(object ob, int heat, int id)
{
  int shift;
  int env_temp;
  int new_heat;
  env_temp = environment(ob)->query_heat();
  if(!env_temp)
  {
    env_temp = 20;
  }
  if(env_temp > heat)
  {
    shift = 100 + ((env_temp - heat) / 10);
    if((heat + shift) > env_temp)
    {
      shift = env_temp - heat;
    }
  }
  else
  {
    shift = -100 - ((heat - env_temp) / 10);
    if((heat + shift) < env_temp)
    {
      shift = env_temp - heat;
    }
  }
  tell_creator(find_living("gototh"), "Heat shift: %O\n", shift);
  new_heat = heat + shift;
  if(heat > ob->query_property("red hot at") &&
    new_heat < (ob->query_property("red hot at") + 1))
  {
    tell_room(environment(ob),
      "$C$" + ob->one_short() + " stops glowing red hot.\n");
  }
  if((heat > 80) && (new_heat < 81))
  {
    tell_room(environment(ob),
      "$C$" + ob->one_short() + " seems to have cooled down.\n");
  }
  if(new_heat < 21)
  {
    ob->submit_ee(0, 0, EE_REMOVE);
  }
  else
  {
    ob->set_arg_of(ob->sid_to_enum(id), new_heat);
  }
}
string extra_look(object ob)
{
  int heat;
  int *enums;
  int red_hot;
  enums = ob->effects_matching("object.heat");
  if(!sizeof(enums))
  {
    return "";
  }
  heat = ob->arg_of(enums[0]);
  red_hot = ob->query_property("red hot at");
  if(red_hot)
  {
    if(heat > red_hot)
    {
      return "It is red hot.\n";
    }
    if(heat > 80)
    {
      return "It looks hot.\n";
    }
  }
  return "";
}

==================================================
FILE: effects/object/horse.c
==================================================

#include <effect.h>
#define SHADOWS "/std/effects/object/"
string query_classification(){return "object.horse"; }
void beginning(object player, int amount){
    player->submit_ee(0, amount, EE_REMOVE);
    player->add_extra_look(this_object());
}
int merge_effect(object player, int old_amount, int new_amount){
   if (old_amount > new_amount)
      return old_amount;
   return new_amount;
}
string query_shadow_ob(){
   return SHADOWS+"shadow_horse";
}
int survive_death(){
   return 0;
}
string extra_look(object player){
   return capitalize((string)player->the_short()) +
         " is mounted on a large, black horse.\n";
}
void end(object player, int amount, int id){
   player->remove_extra_look(this_object());
}

==================================================
FILE: effects/object/identity_hold.c
==================================================

#include <effect.h>
#include "path.h"
class special_stuff {
   int keep;
   string identity;
}
int query_indefinite() { return 1; }
string query_classification() { return "object.identify"; }
string query_shadow_ob() { return SHADOWS + "identity_hold"; }
class special_stuff beginning( object thing, mapping data, int id ) {
   class special_stuff special_stuff;
   special_stuff = new(class special_stuff);
   special_stuff->keep = data["keep"];
   special_stuff->identity = data["identity"];
   thing->set_keep_value(special_stuff->keep);
   thing->set_identifier(special_stuff->identity);
   thing->set_identity_hold_owner(this_player());
   return special_stuff;
}
class special_stuff merge_effect( object thing,
                                  class special_stuff data,
                                  mapping arg,
                                  int id ) {
   if (!nullp(arg["keep"])) {
      data->keep = arg["keep"];
   }
   if (!nullp(arg["identity"])) {
      data->identity = arg["identity"];
   }
   thing->set_keep_value(data->keep);
   thing->set_identifier(data->identity);
   return data;
}
void end( object thing, mixed* store, int id ) {
}
class special_stuff restart( object thing, class special_stuff data, int id ) {
   thing->set_keep_value(data->keep);
   thing->set_identifier(data->identity);
   thing->set_identity_hold_owner(this_player());
   return data;
}

==================================================
FILE: effects/object/label.c
==================================================

#include <effect.h>
int query_indefinite() { return 1; }
object create_store(mapping map,
                    object player) {
   object store;
   store = clone_object( "/std/container" );
   if ( objectp( player ) ) {
      store->set_player( player );
   }
   if ( mapp( map ) ) {
      store->init_dynamic_arg( map );
   }
   return store;
}
string query_classification() { return "object.label"; }
mixed* beginning( object thing, object label, int id ) {
   object store;
   store = clone_object( "/std/container" );
   label->move( store );
   thing->add_extra_look( file_name(this_object()) );
   return ({ store, store->query_dynamic_auto_load() });
}
mixed* merge_effect( object thing, mixed* store, object label, int id ) {
   if (!store) {
      store = ({ 0, ([ ]) });
   }
   if (mapp(store)) {
      store = ({ 0, store });
   }
   if ( !store[0] ) {
      store[0] = create_store(store[1], environment(thing));
   }
   label->move( store[0] );
   store[1] = store[0]->query_dynamic_auto_load();
   return store;
}
void end( object thing, mixed* store, int id ) {
  int i;
  if (arrayp(store)) {
    for(i=0; i<sizeof(store); i++)
      if(objectp(store[i]))
         store[i]->dest_me();
  } else if(objectp(store))
    store->dest_me();
   thing->remove_extra_look( this_object() );
}
mixed* restart( object thing, mixed stuff, int id ) {
   object player;
   object store;
   mapping map;
   int enum;
   if (mapp(stuff)) {
      map = stuff;
   } else if (stuff) {
      map = stuff[1];
   } else {
      map = ([ ]);
   }
   player = environment( thing );
   thing->add_extra_look( file_name(this_object()) );
   store = create_store(map, environment(thing));
   enum = thing->sid_to_enum(id);
   thing->set_arg_of(enum, ({ store, map }));
}
string extra_look( object thing ) {
   int *enums;
   object store;
   object *labels;
   mixed *bing;
   enums = (int *)thing->effects_matching( "object.label" );
   if ( !sizeof( enums ) ) {
      return "";
   }
   bing = thing->arg_of( enums[ 0 ] );
   if (pointerp(bing)) {
      store = bing[0];
      if (!store) {
         store = create_store(bing[1], environment(thing));
         thing->set_arg_of(enums[0], ({ store, bing[1] }));
      }
   }
   if ( !objectp( store ) ) {
      return "";
   }
   labels = (object *)store->find_inv_match( "" );
   if ( !sizeof( labels ) ) {
      return "";
   }
   return capitalize( (string)thing->query_pronoun() ) +" has "+
         query_multiple_short( labels ) +" stuck on "+
         (string)thing->query_objective() +".\n";
}

==================================================
FILE: effects/object/newbie_shoes.c
==================================================

#include "path.h"
#include <effect.h>
#define CLASS "misc.worn.shoes.orthopaedic"
string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS + "newbie_shoes"; }
void chat(object player, mixed arg, int id)
{
  string *mechats = ({
    "Something's crawling inside the shoes.\n",
    "The Cobblers of Sek must've made these things!\n",
    "Did that vice just screw down tighter?\n",
    "*OUCH* that stung!\n",
    "You not-so-idly wonder who came up with these shoes.\n"
    });
  string *youchats = ({
    " winces in pain.\n",
    " mutters something about shoes.\n",
    " stumbles.\n"
    });
  if (!interactive(player)) return;
  tell_object(player, mechats[random(sizeof(mechats))]);
  tell_room(environment(player),
    player->query_cap_name() + youchats[random(sizeof(youchats))],
    ({ player }) );
}
void notify(object player, mixed arg, int id)
{
  tell_object(player,
    "A fiery pain shoots up your legs from your feet.\n");
}
void beginning( object player, int amount, int id )
{
  player->add_extra_look( this_object() );
  player->adjust_bonus_dex(-1);
  player->submit_ee("chat", ({ 10, 30 }), EE_CONTINUOUS);
  player->submit_ee("notify", 1, EE_ONCE);
}
void restart( object player, int amount, int id )
{
  beginning(player, amount, id);
}
void merge_effect(object player, mixed oldarg, mixed newarg, int id)
{
  return;
}
void end( object player, int amount, int id )
{
  player->remove_extra_look( this_object() );
  player->adjust_bonus_dex(1);
  tell_object(player, "Ahhhh!  Free from those evil shoes!\n");
}
string extra_look( object player )
{
  int *enums;
  enums = (int *)player->effects_matching( CLASS );
  if ( !sizeof( enums ) )
     return "";
  return(capitalize(player->query_pronoun()) +
    " looks embarrassed and uncomfortable.\n");
}

==================================================
FILE: effects/object/no_save.c
==================================================

#include "path.h"
string query_classification() { return "mudlib.object.nosave"; }
string query_shadow_ob() { return SHADOWS +"no_save"; }
int query_indefinite() { return 1; }
void beginning( object thing, string owner, int id ) { return; }
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   return old_owner;
}

==================================================
FILE: effects/object/object_desc.c
==================================================

#include <effect.h>
string query_classification(){return "crafts.description"; }
string* beginning(object thing, string* desc){
   switch(sizeof(desc)){
      case 5:
         thing->add_property("determinate", desc[4]);
      case 4:
         thing->add_alias(desc[3]);
      case 3:
         thing->add_adjective(desc[2]);
      case 2:
         thing->set_long(desc[1]);
      case 1:
         thing->set_short(desc[0]);
   }
   return desc;
}
string* merge_effect(object player, string* old_desc, string* new_desc){
   return new_desc;
}
mixed* restart(object thing, string* description, int id){
   switch(sizeof(description)){
      case 5:
         thing->add_property("determinate", description[4]);
      case 4:
         thing->add_alias(description[3]);
      case 3:
         thing->add_adjective(description[2]);
      case 2:
         thing->set_long(description[1]);
      case 1:
         thing->set_short(description[0]);
   }
   return ({thing, description, id});
}

==================================================
FILE: effects/object/owned_weapon.c
==================================================

#include "path.h"
string query_classification() { return "mudlib.owned.weapon"; }
string query_shadow_ob() { return SHADOWS +"owned_weapon"; }
int query_indefinite() { return 1; }
void beginning( object thing, string owner, int id ) { return; }
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   write( "There is a bug with the ownership of "+
         (string)thing->the_short() +" ("+ file_name( thing ) +
         ")!  Please bug report it and contact a creator!\n" );
   return old_owner;
}

==================================================
FILE: effects/object/path.h
==================================================

#define PATH "/std/effects/object/"
#define SHADOWS "/std/shadows/object/"

==================================================
FILE: effects/object/swim_fins.c
==================================================

#include <effect.h>
#define SHADOW "/std/shadows/object/swim_fins"
string query_classification() { return "clothing.swim_fins"; }
string query_shadow_ob() { return SHADOW; }
void beginning(object player, int time ) {
   player->submit_ee( "test_worn", 1, EE_ONCE );
   player->submit_ee( "test_worn", 20, EE_CONTINUOUS );
}
void restart( object player ) {
}
int merge_effect( object player, int old_state, int new_state ) {
   return old_state | new_state;
}
int test_for_effect( object thing ) {
   if ( !thing )
      return 0;
   return member_array( file_name( this_object() ),
         (string *)thing->query_wear_effects() ) != -1;
}
void test_worn( object player ) {
   if ( player->still_auto_loading() )
      return;
   if ( !sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
}

==================================================
FILE: effects/object/talker.c
==================================================

#include "path.h"
#include <library.h>
#include <talker.h>
#include <player.h>
#include <playtesters.h>
#include <deity.h>
#include <nomic_system.h>
#define HELP_CMD "/cmds/player/help"
nosave mapping _channel_cache;
nosave string *valid_channels = ({"one", "two", "A'Tuin", "Intermud", "Apex",
    "Adventurers", "Priests", "Wizards",
    "Assassins", "Warriors", "Thieves",
    "Witches", "playerkillers",
    "playtesters", "Catfish", "Fish",
    "Gapp", "Gufnork", "Hat",
    "Pishe", "Sandelfon", "Sek",
      "theAgateanEmpireCouncil",
     "KlatchCouncil", "KlatchCouncilMagistrate",
    "Ankh-MorporkCouncil",
    "Ankh-MorporkCouncilMagistrate" });
string query_classification() { return "magic.talker"; }
string query_shadow_ob() { return SHADOWS +"talker"; }
int query_indefinite() { return 1; }
protected class talker_args new_talker_args() {
    return new(class talker_args, status : 1, channels : ({ "one" }),
        verbose : 1, local_echo : 0, colour : 0 );
}
class talker_args beginning( object thing, mixed args, int id ) {
    if ( environment( thing ) )
        tell_object( environment( thing ), "Somewhere inside " +
            thing->the_short() + " a pair of glittering eyes swirl "
            "into being.\n" );
    thing->add_extra_look( this_object() );
    thing->add_alias( "talker" );
    thing->add_plural( "talkers" );
    if (arrayp(args)) {
        args = new_talker_args();
        return args;
    }
    if (!classp(args)) {
        return new_talker_args();
    }
}
class talker_args merge_effect(object thing, mixed old_args, mixed new_args) {
    class talker_args args;
    if (!classp(old_args) || !classp(new_args))
        return new_talker_args();
    args = copy(old_args);
    args->channels += new_args->channels;
    args->channels = uniq_array(args->channels);
    return args;
}
void restart( object thing, mixed args, int id ) {
    if (!classp(args)) {
        thing->set_arg_of(thing->sid_to_enum(id), new_talker_args());
        tell_object( environment( thing ), "Your talker quivers "
            "uncontrollably and starts to jump around.  You will have "
            "to re-add your talker channels and reconfigure your talker.\n" );
    }
    thing->add_extra_look( this_object() );
    thing->add_alias( "talker" );
    thing->add_plural( "talkers" );
}
void end( object thing, mixed *args, int id ) {
    if ( environment( thing ) )
        tell_object( environment( thing ), "The pair of glittering eyes in "+
          (string)thing->the_short() +" close and fade away forever.\n" );
    thing->remove_extra_look( this_object() );
    thing->remove_alias( "talker" );
    thing->remove_plural( "talkers" );
}
string extra_look( object thing ) {
    int *enums;
    mixed args;
    enums = (int *)thing->effects_matching( "magic.talker" );
    if ( !sizeof( enums ) ) {
        return "";
    }
    args = thing->arg_of( enums[ 0 ] );
    if (!classp(args)) {
         return "";
    }
    if ( args->status ) {
        return "Just beneath the surface, you can make out what looks like a "
        "pair of glittering eyes.\n";
    }
    return "Just beneath the surface, you can make out what looks like a "
    "pair of closed eyes.\n";
}
string *all_channels( object player ) {
    string word, *list;
    string p_name;
    class cache_data settings;
    string* areas;
    if ( player->query_property("gagged") ) {
        return ({ });
    }
    list = ({ "one", "two" });
    word = (string)player->query_guild_ob();
    if ( file_size( word +".c" ) > 0 ) {
        if (word != "disavowed") {
            list += ({ capitalize(word->query_name()) });
        }
    }
    else {
        list += ({ "Adventurers" });
    }
    word = (string)player->query_deity();
    if ( stringp( word ) ) {
        list += ({ capitalize( word ) });
    }
    word = (string)player->query_name();
    p_name = player->query_name();
    if (!_channel_cache) {
        _channel_cache = ([ ]);
    }
    if (undefinedp(_channel_cache[p_name])) {
        _channel_cache[p_name] = new(class cache_data,
          talker_quest : LIBRARY->query_quest_done(p_name, "talker quest"),
          playtester : PLAYTESTER_HAND->query_playtester(p_name),
          apex_member : "/d/am/buildings/apex/admin_office"->query_member(p_name)
        );
    }
    settings = _channel_cache[p_name];
    if (settings->talker_quest) {
        list += ({ "A'Tuin", "Intermud" });
    }
    if (settings->apex_member) {
        list += ({ "Apex" });
    }
    if (settings->playtester) {
        list += ({ "playtesters" });
    }
    if ( player->query_player_killer()) {
        list += ({ "playerkillers" });
    }
    areas = NOMIC_HANDLER->query_citizenship_areas();
    foreach (word in areas) {
       if (NOMIC_HANDLER->is_citizen_of(word, p_name)) {
          list += ({ replace_string(word, " ", "") + "Council" });
       }
       if (NOMIC_HANDLER->is_magistrate_of(word, p_name)) {
          list += ({ replace_string(word, " ", "") + "CouncilMagistrate" });
       }
    }
    return list;
}
string channels() {
    return sprintf( "%#-*s\n", (int)this_player()->query_cols(),
      implode( all_channels( this_player() ), "\n" ) );
}
varargs int valid( mixed word, object who) {
    if (!who) {
        who = this_player();
    }
    if (arrayp(word) && arrayp(valid_channels)) {
        if (sizeof( word - valid_channels ) != 0) {
            return 0;
        }
    } else {
        if (member_array( word, valid_channels ) == -1) {
            return 0;
        }
    }
    if (who->query_lord()) {
       return 1;
    }
    if ( who->query_creator() ) {
        if (stringp(word) &&
            word[<7..] != "Council" &&
            word[<10..] != "Magistrate") {
            return 1;
        } else if (arrayp(word)) {
            if (!sizeof(filter(word, (: $1[<7..] == "Council" &&
                                        $1[<10..] == "Magistrate" :)))) {
                return 1;
            }
        }
    }
    if ( arrayp( word ) ) {
        return sizeof( word - all_channels( who ) ) == 0;
    }
    return ( member_array( word, all_channels( who ) ) != -1 );
}
object find_actual_talker( object thing ) {
    object talker;
    while ( thing ) {
        talker = thing;
        thing = query_shadowing( thing );
    }
    return talker;
}
string list( string word, int brief ) {
    int space;
    int *enums;
    string sender;
    string table;
    object thing;
    object *ok;
    object *things;
    object holder;
    class talker_args args;
    table = "";
    space = (int)this_player()->query_cols() - 20;
    things = children( SHADOWS + "talker" ) -
        ({ find_object( SHADOWS + "talker" ) });
    things = filter( map( things, (: find_actual_talker( $1 ) :) ),
        (: $1 && environment($1) && living(environment($1)) &&
           (!userp($1) || interactive($1)) :) );
    things = uniq_array(things);
    things = sort_array( things,
        (: strcmp( environment($1)->query_name(),
            environment($2)->query_name() ) :) );
    ok = ({ });
    foreach( thing in things ) {
        holder = environment( thing );
        if (userp(holder)) {
            sender = capitalize( holder->query_cap_name() );
        } else {
            sender = capitalize( holder->query_name() );
        }
        if ( holder->query_invis() ) {
            continue;
        }
        enums = (int *)thing->effects_matching( "magic.talker" );
        if ( !sizeof( enums ) ) {
            if ( !word ) {
                table += sprintf( LIST_FORMAT, sender, space, "(barfed)" );
            }
            continue;
        }
        args = thing->arg_of( enums[ 0 ] );
        if (!classp(args)) {
            continue;
        }
        if ( !args->status) {
            if ( !word ) {
                table += sprintf( LIST_FORMAT, sender, space, "(asleep)" );
            }
            continue;
        }
        if ( !word || ( member_array( word, args->channels ) != -1 ) ) {
            if (brief) {
                ok += ({ sender });
            } else {
                table += sprintf( LIST_FORMAT, sender, space,
                    query_multiple_short( args->channels ) );
            }
        }
    }
    if (brief) {
       return "$I$5=People listing to the channel " + word + " are: " +
              query_multiple_short(ok) + "\n";
    }
    if ( table == "" ) {
        return sprintf( LIST_FORMAT, "None", space, "" );
    }
    return table;
}
string normalise_name( string channel ) {
    int position;
    mixed *details;
    string *lower_names;
    string lower_channel;
    lower_channel = lower_case( channel );
    lower_names = map( valid_channels, (: lower_case($1) :) );
    position = member_array( lower_channel, lower_names );
    if ( position == -1 ) {
        details = HELP_CMD->find_match_in_array( lower_channel,
            lower_names );
        if ( details[ 1 ] > 70 ) {
            return valid_channels[ details[ 0 ] ];
        }
        return channel;
    }
    return valid_channels[ position ];
}
varargs mapping query_channel_cache(string person) {
    if (!_channel_cache)
        return ([ ]);
    if (stringp(person) && classp(_channel_cache[person])) {
        return copy(_channel_cache[person]);
    }
    return copy(_channel_cache);
}
void reset() {
    _channel_cache = ([ ]);
}
void clear_cache(string person) {
    if (_channel_cache) {
        map_delete(_channel_cache, person);
    }
}

==================================================
FILE: effects/object/wet.c
==================================================

#include <effect.h>
string query_classification() { return "object.wet"; }
void beginning( object thing, int amount, int id ) {
   thing->submit_ee( "dry_off", ({ 30, 90 }), EE_CONTINUOUS );
   thing->add_extra_look( this_object() );
   thing->add_adjective("wet");
}
int merge_effect( object thing, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
}
void end( object thing, int amount, int id ) {
   thing->remove_extra_look( this_object() );
   thing->remove_adjective("wet");
}
void restart( object thing, int amount, int id ) {
   thing->add_extra_look( this_object() );
}
void dry_off( object thing, int amount, int id ) {
   amount -= 100 + amount / 10;
   if ( amount > 0 )
      thing->set_arg_of( (int)thing->sid_to_enum( id ), amount );
   else
      thing->submit_ee( 0, 0, EE_REMOVE );
}
string wet_string( object thing ) {
   int *enums;
   string wetness;
   enums = (int *)thing->effects_matching( "object.wet" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)thing->arg_of( enums[ 0 ] ) / ( 1 +
         (int)thing->query_weight() ) ) {
      case 0 :
         return "just barely damp";
      case 1 .. 5 :
         wetness = "slightly wet";
         break;
      case 6 .. 10 :
         wetness = "wet";
         break;
      case 11 .. 30 :
         wetness = "very wet";
         break;
      case 31 .. 80 :
         wetness = "sopping wet";
         break;
      default :
          wetness = "absolutely soaking wet";
   }
   return wetness;
}
string extra_look(object thing)  {
   return "It is " + wet_string(thing) + ".\n";
}

==================================================
FILE: effects/external/coffee_nose.c
==================================================

#include <effect.h>
void beginning( object player, int time ) {
    if (time > 1800)
        time = 1800;
    tell_object( player, "\n" );
    tell_room( environment( player ), (string)player->the_short() + " drinks some of his coffee and ends up with a small amount of froth on "+player->query_possessive()+" nose.\n", player);
    player->submit_ee( 0, time, EE_REMOVE );
    player->add_extra_look( this_object() );
}
int merge_effect( object player, int time1, int time2 ) {
    int newtime;
     newtime = (time1 > time2 ) ? time1 : time2;
     newtime = ( newtime > 1800 ) ? 1800 : newtime;
    player->submit_ee( 0, newtime, EE_REMOVE );
    return newtime;
}
void end( object player, int time ) {
    if ( !player->query_property( "dead" ) )
        tell_object( player, "A small amount of frothy Coffee drops onto the floor.\n" );
    player->remove_extra_look( this_object() );
}
string query_classification() { return "coffee.nose"; }
string extra_look( object player ) {
    return capitalize( player->query_pronoun()+" looks "
      "like "+player->query_pronoun()+" has a small amount of creamy, frothy coffee on "+player->query_possessive()+" nose.\n" );
}

==================================================
FILE: effects/external/flea_cure.c
==================================================

#include <effect.h>
int infested;
int cleanse( object thing, int bonus ) {
    int i, flag, *effnums;
    class effect *effs;
    if ( !thing )
      return 0;
    if ( !living( thing ) )
      return 0;
    effnums = (int *)thing->effects_matching(
              "disease.parasite.external.flea");
    if ( !sizeof( effnums ) )
      return 0;
    effs = (class effect *)thing->query_effs();
    for ( i = sizeof( effnums ) - 1; i >= 0; i-- )
      if ( effs[ effnums[ i ] ]->ob_name->test_remove( thing,
          effs[ effnums[ i ] ]->arg, effnums[ i ], bonus ) ) {
          thing->delete_effect( effnums[ i ] );
          flag = 1;
      }
    infested = flag;
    return flag;
}
void beginning( object player, int time ) {
   player->submit_ee( "make_smell", ({ 20, 30 }), EE_CONTINUOUS );
   player->submit_ee( "kill_flea", ({ 30, 40 }), EE_CONTINUOUS );
   call_out("cleanse", 0, player, time/10);
   player->submit_ee( 0, time, EE_REMOVE );
}
int merge_effect( object player, int time1, int time2 ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   if (!infested)
       call_out("cleanse", 0, player, (time1+time2)/10);
   return time1 + time2;
}
void end( object player, int time ) {
   tell_object( player, "The odd odour is gone now.\n" );
}
void kill_flea( object player ) {
    if (infested && random(2)) {
        tell_object( player, "You hear a faint scream and see a small dot " +
                    "fall past your eyes.\n" );
        tell_room( environment( player ), "You see a tiny speck leap from " +
                  (string)player->short() + "'s head, screaming pitifully.\n",
                  player );
    }
}
void make_smell( object player ) {
    tell_object( player, "You notice a strange odour, like wet Grflx "
              "and rotting cabbage, in the air.\n" );
    tell_room( environment( player ),  "A smell reminiscent of a wet Grflx "+
              "and rotting cabbages seems to emanate from "+
              (string)player->short() + ".\n", player );
}
string query_classification() { return "body.smell.insecticide"; }
string smell_string( object player, int time ) {
   return "the odd odour of wet Grflx and rotting cabbage";
}

==================================================
FILE: effects/external/insect_repellent.c
==================================================

#include "effect.h"
string query_classification() {
  return "herb.insect.repellent";
}
int beginning(object them, int power, int id) {
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->add_property("insect", power);
  them->submit_ee("start_mess", 2, EE_ONCE);
  them->submit_ee("smell", ({30, 60}), EE_CONTINUOUS);
  return power;
}
int merge_effect(object them, int power, int adjust) {
  power += adjust;
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->submit_ee(0, -1, EE_REMOVE);
  return power;
}
void start_mess(object them, int power, int id) {
  string start_mess;
  switch (power) {
  case 1:
    start_mess = "You smell rather pleasant, much as you might wish to for a "
           "date.";
    break;
  case 2..3:
    start_mess = "A pungent smell envelops you.";
    break;
  default:
    start_mess = "A horribly pungent smell envelops you, sufficient to make "
           "anyone with a sense of smell keep their distance.";
  }
  tell_object(them, start_mess+"\n");
}
void smell(object them, int power, int id) {
  string self_mess, other_mess;
  object env;
  if (--power <= 0) {
    tell_object(them, "The herbal odour around you fades away.\n");
    them->remove_property("insect");
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  switch (power) {
  case 1:
    self_mess = "A pleasant smell emanates from your body.";
    other_mess = "A pleasant smell emanates from "+them->one_short()+".";
    break;
  case 2..3:
    self_mess = "A pungent herbal smell emanates from your body.";
    other_mess = "A pungent herbal smell emanates from "+them->one_short()+".";
    break;
  default:
    self_mess = "You reek of pungent herbs.";
    other_mess = "$C$"+them->one_short()+" $V$0=reeks,reek$V$ of pungent "
           "herbs.";
  }
  tell_object(them, self_mess+"\n");
  if ((env = environment(them)) && env->query_property("location")) {
    tell_room(env, other_mess+"\n", them);
  }
}

==================================================
FILE: effects/external/snowball.c
==================================================

#include <effect.h>
string query_classification() { return "mudlib.snowball"; }
void beginning( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
   player->submit_ee( "decrease_amount", 15, EE_CONTINUOUS );
}
void restart( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
}
int merge_effect( object player, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
}
void end( object player, int amount, int id ) {
   player->remove_extra_look( this_object() );
}
void decrease_amount( object player, int amount, int id ) {
   amount -= 3 + random( random(amount) );
   if ( amount < 0 ) {
      amount = 0;
      player->submit_ee( 0, 1, EE_REMOVE );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), amount );
   player->add_effect("/std/effects/other/wetness", roll_MdN( 10, 10 ) );
}
string extra_look( object player ) {
   int *enums;
   string desc;
   enums = (int *)player->effects_matching( "mudlib.snowball" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)player->arg_of( enums[ 0 ] ) ) {
      case 0 .. 99 :
         desc = " has a little bit of snow";
         break;
      case 100 .. 199 :
         desc = " has a bit of snow";
         break;
      case 200 .. 299 :
         desc = " has a few small lumps of snow";
         break;
      case 300 .. 399 :
         desc = " has a few lumps of snow";
         break;
      case 400 .. 499 :
         desc = " has a number of lumps of snow";
         break;
      case 500 .. 599 :
         desc = " has quite a lot of snow";
         break;
      case 600 .. 699 :
         desc = " has a lot of snow";
         break;
      default :
         desc = " has a thick layer of snow";
   }
   return capitalize( (string)player->query_pronoun() ) + desc +" on "+
         (string)player->query_possessive() +" face.\n";
}

==================================================
FILE: effects/disease/basic_disease.c
==================================================

#include <effect.h>
#include <disease.h>
int do_setup;
string name, classification, shadow_ob;
void set_name( string str ) { name = str; }
string query_name() { return name; }
void set_classification( string str ) { classification = str; }
string query_classification() { return classification; }
void create() {
   name = "Some undefined disease";
   classification = "disease.unset";
   if ( !do_setup )
      this_object()->setup();
}
int cure( object person, string cure_classification, int power, int enum ) {
   int arg, i, scale;
   string *cure_class, *disease_class;
   arg = person->arg_of( enum );
   disease_class = explode( classification, "." )[ 1 .. <1 ];
   cure_class = explode( cure_classification, "." )[ 1 .. <1 ];
   while ( sizeof( disease_class ) && sizeof( cure_class ) &&
          ( disease_class[ 0 ] == cure_class[ 0 ] ) ) {
      disease_class = disease_class[ 1 .. <1 ];
      cure_class = cure_class[ 1 .. <1 ];
   }
   scale = 1;
   i = sizeof( disease_class );
   while ( i-- )
      scale *= DISEASE_SCALE[ i ];
   i = sizeof( cure_class );
   while ( i-- )
      scale *= CURE_SCALE[ i ];
   arg -= power / scale;
   power = -arg * scale;
   person->set_arg_of( enum, arg );
   if ( arg > 0 )
      this_object()->disease_better( person, arg );
   return power;
}

==================================================
FILE: effects/disease/common_cold.c
==================================================

#include <disease.h>
#include <effect.h>
inherit SIMPLE_DISEASE;
void setup() {
   set_name( "Common Cold" );
   set_cure_rate( 6 );
   set_classification( "disease.infection.respiratory.cold" );
}
int disease_start( object player, int arg, int sid ) {
   tell_object( player, "You realise that your nose is running.\n" );
   player->submit_ee2( sid, "sap_strength", ({ 600, 600 }), EE_CONTINUOUS );
   return arg;
}
void disease_end( object player, int arg, int sid ) {
   if ( !player->query_property( "dead" ) )
      tell_object( player, "You realise that your nose is clear again.\n" );
}
void disease_action( object player, int arg ) {
   switch ( random( 3 ) ) {
      case 0 :
         player->new_parser( "sniff" );
         break;
      case 1 :
         player->new_parser( "cough" );
         break;
      default :
         player->new_parser( "sneeze" );
   }
}
void sap_strength( object player ) {
   tell_object( player, "You feel your strength being sapped by the cold.\n" );
   player->adjust_tmp_str( -1 );
}

==================================================
FILE: effects/disease/flea_infestation.c
==================================================

#include <effect.h>
#include <disease.h>
inherit SIMPLE_DISEASE;
void setup() {
   set_name( "Fleas" );
   set_classification( "disease.parasite.external.flea" );
  set_infection_chance( 2 );
   set_infection_check( (: living( $1 ) &&
               ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
               $1->query_mature() ) && !$1->query_property( "dead" ) :) );
}
int disease_start( object player, int arg, int ) {
   string race_ob;
   race_ob = (string)player->query_race_ob();
   if ( ( (string)race_ob->query_name() == "troll" ) ||
         player->query_property( "no fleas" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   return arg;
}
void disease_action( object player, int, int ) {
   switch( random( 14 ) ) {
      case 0 .. 3 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Something itches.  You scratch yourself.\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " scratches "+ (string)player->query_objective() +"self.\n",
               player );
         break;
      case 4 .. 7 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Ouch!  Something bit you!\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " starts as if bitten.\n", player );
         player->adjust_hp( -10 - random( 10 ) );
         break;
      case 8 .. 11 :
         tell_object( player, "You notice a small red welt on your skin.\n" );
         break;
      default:
   }
   if(!random(10) && !userp(player))
     player->submit_ee(0, 0, EE_REMOVE);
}
int test_remove( object player, int arg, int enum, int bonus ) {
   log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
   if ( arg + bonus < 30 ) {
      player->set_arg_of( enum, arg + bonus );
      return 0;
   }
   return 1;
}

==================================================
FILE: effects/disease/flu.c
==================================================

#include <effect.h>
#include "path.h"
int query_secs_between_hb() { return 1; }
string query_classification() { return "disease.infection.general.flu"; }
int beginning(object player, mixed arg) {
   tell_object(player, "You shiver.\n");
   return arg;
}
int effect_heart_beat(object player, int hbnum, mixed arg, int id){
   if (hbnum == arg) return REMOVE_THIS_EFFECT;
   return arg;
}
void end(object player) {
   tell_object(player, "You feel altogether healthy again.\n");
}
string query_shadow_ob(){ return SHADOWS+"flu_shadow"; }

==================================================
FILE: effects/disease/general_hypothermia.c
==================================================

#include <effect.h>
#include <weather.h>
#include <clothing.h>
#define DEBUG 1
#define COMFORTABLE 20
#define DEATH -500
void shiver(object player, int temperatureess, int id);
int calc_personal_temp(object player);
string query_classification() { return "disease.hypothermia"; }
int beginning( object player, int temperature, int id ) {
  if(temperature + calc_personal_temp(player) < COMFORTABLE) {
    tell_object(player, "You feel a bit chilly.\n");
    player->submit_ee( "shiver", ({ 20, 20 }), EE_CONTINUOUS );
    player->submit_ee( "stat_adjusts", ({ 240, 240 }), EE_CONTINUOUS );
    player->add_extra_look( this_object() );
  } else {
    player->submit_ee(0, 0, EE_REMOVE );
  }
  return temperature + calc_personal_temp(player) - COMFORTABLE;
}
int merge_effect( object player, int new_temperature, int old_temperature,
                  int id ) {
  return old_temperature + (new_temperature + calc_personal_temp(player) -
                            COMFORTABLE);
}
void restart(object player) {
  player->add_extra_look( this_object() );
}
void end( object player ) {
  tell_object( player, "You don't feel cold anymore.\n" );
  player->remove_extra_look( this_object() );
}
void shiver(object player, int temperature, int id) {
  int *enums, pwet, personal;
  int room_temp, min;
  if (!environment(player))
    return;
  room_temp = WEATHER->temperature_index(environment(player));
  personal = calc_personal_temp(player);
  if(room_temp + personal > COMFORTABLE)
    temperature += (room_temp + personal - COMFORTABLE);
  min = 100 * (personal + room_temp - COMFORTABLE);
  if(min > COMFORTABLE)
    min = personal + room_temp - COMFORTABLE;
  if(temperature < min)
    temperature = min;
  if(temperature >= COMFORTABLE)
    player->submit_ee(0, 0, EE_REMOVE );
  if ( temperature < DEATH ) {
    player->dest_hide_shadow();
    tell_object( player, "The cold is just too much for you.\n" );
    tell_room( environment( player ), "Frost riming "+
              (string)player->query_possessive() +" skin in a thick crust, "+
              (string)player->the_short() +" expires.\n", player );
    player->do_death();
    return;
  }
  switch(random(4)) {
  case 0 :
    player->new_parser("shiver");
    tell_object(player, "You feel cold to your bones.\n");
    break;
  case 1 :
    player->dest_hide_shadow();
    tell_object( player, "You rub your arms briskly in an attempt to "+
                "keep warm.\n" );
    tell_room( environment( player ),
              capitalize( (string)player->short() ) +" rubs "+
              (string)player->query_possessive() +" arms briskly.\n",
              player );
    break;
  case 2 :
    player->new_parser("shiver");
    enums = (int *)player->effects_matching("body.wetness");
    if ( sizeof( enums ) )
      pwet = (int)player->arg_of( enums[ 0 ] );
    if ( (int)pwet > 25 ) {
      tell_object( player, "You dislodge a lump of ice, which falls "+
                  "to the ground and shatters.\n" );
      tell_room( environment( player ),
                capitalize( (string)player->short() ) +" dislodges a lump "+
                "of ices, which falls to the ground and shatters.\n",
                player );
      player->add_effect("/std/effects/other/wetness", -25 );
    }
    break;
  default :
    player->new_parser("shiver");
    tell_object(player, "You feel really cold.\n" );
  }
  player->set_arg_of( (int)player->sid_to_enum( id ), temperature );
  return;
}
int calc_personal_temp(object player) {
  object where;
  string item, zone, type, *types, *zones;
  int count;
  zones = ({ });
  where = environment(player);
  count = 0;
  if(where->query_property("location") == "inside")
    count += 20;
  count += where->query_property("warmth");
  foreach(item in player->query_wearing()) {
    types = item->query_type();
    if(!arrayp(types))
      types = ({ item->query_type() });
    foreach(type in types) {
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth"))
          count += item->query_property("warmth");
        else
          count ++;
      }
    }
  }
  count += sizeof(zones);
  count += environment(player)->query_property("warmth");
  return count;
}
void stat_adjusts(object player, int temperature, int id ) {
  if(WEATHER->temperature_index(environment(player)) > 0 ||
     temperature > -100)
    return;
  switch(player->query_race()) {
  case "troll":
    tell_object( player, "You feel a tingling between your ears and "+
                 "new and strangely clever thoughts race along the "+
                 "superconducting neural pathways of your brain.\n" );
    player->adjust_int( 1 );
    break;
  default:
    tell_object( player, "You feel your strength being drained by the "+
                 "freezing temperatures.\n" );
    player->adjust_tmp_str( -1 );
    player->adjust_tmp_con( -1 );
    break;
  }
}
string extra_look( object player ) {
  string desc;
  int temperature;
  int *enums;
  enums = (int *)player->effects_matching( "disease.hypothermia" );
  if ( !sizeof( enums ) )
    return "";
  temperature = (int)player->arg_of(enums[0]);
  switch(temperature/5) {
    case -5 .. 100 :
      desc = "looks a bit cold.\n";
      break;
    case -10 .. -6 :
      desc = "looks rather cold.\n";
      break;
    case -30 .. -11 :
      desc = "looks very cold.\n";
      break;
    case -80 .. -31 :
      desc = "appears to be suffering from extreme hypothermia.\n";
      break;
    case -100 .. -81 :
      desc = "looks close to death from hypothermia.\n";
      break;
    default :
      return "";
  }
  return capitalize( (string)player->query_pronoun() ) +" "+ desc;
}

==================================================
FILE: effects/disease/gp_drain_effect.c
==================================================

#include <effect.h>
#include "path.h"
#include "/std/living/stats.c"
#define CLASS "general.gp.drain"
string query_classification(){
  return CLASS;
}
string query_death_reason(){
  return "wasting away slowly";
}
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;
  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }
  tell_object( player, "You feel woozy.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  ( player )->adjust_gp( -damage );
  tell_creator( player,
                "Drain: " + damage + "\n" );
}
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}
void end( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[1] + "\n" );
}
void restart( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[0] + "\n" );
}

==================================================
FILE: effects/disease/headache.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "disease.pain.headache"; }
int beginning(object player, mixed arg) {
   tell_object(player, "Your head hurts.\n");
   player->submit_ee(0, arg, EE_REMOVE);
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}
int restart(object player, mixed arg) {
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( "end", duration, EE_REMOVE );
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   return duration;
}
void pains( object player) {
   switch (random(5)) {
    case 0:
      tell_object( player, "Your head hurts.\n");
      tell_room( environment( player ), player->the_short()
           + " looks pained.\n",  ({ player }) );
      break;
    case 1:
      tell_object( player, "You clutch your aching head.\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive() + " head.\n",
          ({ player }) );
      break;
    case 2:
      tell_object( player, "Owwwwwwwwwwww!\n");
      tell_room( environment( player ), player->the_short()
           + " moans.\n",  ({ player }) );
      break;
    case 3:
      tell_object( player, "Your head pounds!\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive()
           + " head and moans.\n",  ({ player }) );
      break;
    case 4:
      tell_object( player, "Arrrrgh!  Migraine!\n");
      tell_room( environment( player ), player->the_short()
           + " whimpers.\n",  ({ player }) );
      break;
   }
}
void end(object player) {
   tell_object(player, "Your head feels better.\n");
   player->adjust_bonus_con(1);
   player->adjust_bonus_dex(1);
   player->adjust_bonus_wis(1);
   player->adjust_bonus_int(1);
}
string query_shadow_ob(){ return SHADOWS+"disease/headache_shadow"; }

==================================================
FILE: effects/disease/hp_drain_effect.c
==================================================

#include <effect.h>
#include "path.h"
#include "/std/living/stats.c"
#define CLASS "general.hp.drain"
string query_classification(){
  return CLASS;
}
string query_death_reason(){
  return "wasting away slowly";
}
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;
  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }
  tell_object( player, "You feel weak.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  if( ( player )->adjust_hp( -damage ) < 0 ){
    ( player )->attack_by( this_object() );
  }
  tell_creator( player,
                "Damage: " + damage + "\n" );
}
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}
void end( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[1] + "\n" );
}
void restart( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[0] + "\n" );
}

==================================================
FILE: effects/disease/hypothermia.c
==================================================

#include <effect.h>
string query_classification() { return "disease.hypothermia"; }
int beginning( object player, int index, int id ) {
    if ( !index )
        index = 100;
   tell_object( player, "You feel a bit chilly.\n" );
   player->submit_ee( "change_index", ({ 60, 60 }), EE_CONTINUOUS );
   player->submit_ee( "stat_adjusts", ({ 90, 90 }), EE_CONTINUOUS );
   return index;
}
int merge_effect( object player, int index ) { return index; }
void end( object player ) {
   tell_object( player, "You feel a lot warmer now.\n" );
}
void change_index( object player, int index, int id ) {
  int *enums, pwet;
   if ( !environment( player ) )
      return;
   if ( !environment( player )->query_property( "freezer" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   index -= 7 - (int)player->query_con() / 7;
   if ( index < 0 ) {
      player->dest_hide_shadow();
      tell_object( player, "The cold is just too much for you.\n" );
      tell_room( environment( player ), "Frost riming "+
            (string)player->query_possessive() +" skin in a thick crust, "+
            (string)player->the_short() +" expires.\n", player );
      player->do_death();
      return;
   }
   switch( random( 4 ) ) {
      case 0 :
         player->dest_hide_shadow();
         tell_object( player, "You shiver.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" shivers.\n", player );
         break;
      case 1 :
         player->dest_hide_shadow();
         tell_object( player, "You rub your arms briskly in an attempt to "+
               "keep warm.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" rubs "+
               (string)player->query_possessive() +" arms briskly.\n",
               player );
         break;
      case 2 :
        enums = (int *)player->effects_matching("body.wetness");
         if ( sizeof( enums ) )
           pwet = (int)player->arg_of( enums[ 0 ] );
         if ( (int)pwet > 25 ) {
            player->dest_hide_shadow();
            tell_object( player, "You dislodge a lump of ice, which falls "+
                  "and shatters on the floor.\n" );
            tell_room( environment( player ),
                  capitalize( (string)player->short() ) +" dislodges a lump "+
                  "of ices, which falls and shatters on the floor.\n",
                  player );
            player->add_effect("/std/effects/wetness", -25 );
         }
         break;
      default :
         tell_object( player, "You're getting really cold in here.\n" );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), index );
}
void stat_adjusts( object player ) {
   switch ( random( 3 ) ) {
      case 0 :
         tell_object( player, "You feel your strength being drained by the "+
               "below freezing temperatures.\n" );
         player->adjust_tmp_str( -1 );
         return;
      case 1 :
         tell_object( player, "You really don't feel at all well stuck in "+
               "here.\n" );
         player->adjust_tmp_con( -1 );
         return;
      default :
         if ( (string)player->query_race() == "troll" ) {
            tell_object( player, "You feel a tingling between your ears and "+
                  "new and strangely clever thoughts race along the "+
                  "superconducting neural pathways of your brain.\n" );
            player->adjust_int( 1 );
         }
   }
}

==================================================
FILE: effects/disease/path.h
==================================================

#include <disease.h>

==================================================
FILE: effects/disease/rabies.c
==================================================

#include <effect.h>
#define COMBAT_EFFECT "/std/effects/fighting/combat"
string *wretch_msg = ({
    "You start to froth at the mouth and your head spins.\n",
    "The pain is so intense you want to rip your eyes out.\n",
    "The pain from your ripped flesh radiates through your body.\n",
    "You feel like howling at the moon in rabid madness.\n",
    "You spray rabid froth everywhere.\n"
});
string *room_msg = ({
    " starts to froth at the mouth and looks crazed.\n",
    "'s eyes roll in crazed fury.\n",
    " seethes in agony.\n",
    " howls at the moon in rabid agony.\n",
    " sprays froth everywhere.\n"
});
string query_classification() { return "body.disease.rabies"; }
int beginning( object player, int time ) {
   if( player->query_property( "undead" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return -1;
   }
   player->submit_ee( "wretch", ({ 30, 60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
   tell_object( player, "Throbbing pains radiate from your bite wound, and "
      "you feel your sanity slip away.\n" );
   return time;
}
int merge_effect( object player, int time1, int time2 ) {
    return time1;
}
int restart( object player, int time ) {
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
   return time;
}
void end( object player, int time ) {
   player->adjust_bonus_int( 2 );
   player->adjust_bonus_wis( 2 );
   tell_object( player, "You feel the madness leave you, and stop frothing"
      ".\n" );
}
void wretch( object player, int time ) {
    int msg_no;
    msg_no = random( sizeof( wretch_msg ) );
    tell_object( player, wretch_msg[ msg_no ] );
    tell_room( environment( player ), (string)player->the_short() +
              room_msg[ msg_no ], player );
    player->adjust_hp( - ( ( (int)player->query_hp() / 10 ) +
                           ( random( 50 ) ) ) );
    COMBAT_EFFECT->monitor_points( player, 1 );
}
string query_death_reason() {
   return "a nasty case of rabies";
}

==================================================
FILE: effects/disease/simple_disease.c
==================================================

#include <effect.h>
#include <disease.h>
inherit BASIC_DISEASE;
int cure_rate, infection_chance;
string shadow_ob;
function infection_check;
void set_cure_rate( int i ) { cure_rate = i; }
int query_cure_rate() { return cure_rate; }
void set_infection_chance( int i ) { infection_chance = i; }
int query_infection_chance() { return infection_chance; }
void set_infection_check( function f ) { infection_check = f; }
void set_shadow_ob( string str ) { shadow_ob = str; }
string query_shadow_ob() { return shadow_ob; }
void create() {
   do_setup++;
   ::create();
   do_setup--;
   shadow_ob = 0;
   infection_chance = 0;
   infection_check = 0;
   cure_rate = 0;
   if ( !do_setup )
      this_object()->setup();
}
int beginning( object person, int arg, int id ) {
  id = person->sid_to_enum( id );
   arg = this_object()->disease_start( person, arg, id );
   if ( !arg ) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   return arg;
}
int merge_effect( object person, int old_arg, int new_arg, int id ) {
   if ( old_arg < new_arg ) {
      old_arg = new_arg;
      this_object()->disease_worse( person, old_arg, id );
   }
   return old_arg;
}
void end( object person, int arg, int id ) {
   this_object()->disease_end( person, arg, id );
}
void disease_tick( object person, int arg, int id ) {
   object *things;
   int i;
   if ( arg > 100000 )
      arg = 10000;
   arg -= ( cure_rate*( (int)person->query_con() + 7 ) ) / 20 ;
   person->set_arg_of( (int)person->sid_to_enum( id ), arg );
   if ( arg < 0) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   if (person && environment(person) &&
       file_name(environment(person)) != "/room/void" &&
       file_name(environment(person)) != "/room/rubbish" &&
       infection_chance > 0 &&
       (random( 100 ) < infection_chance) ) {
     if ( functionp( infection_check ) ) {
       things = filter_array( all_inventory( environment( person ) ),
                             infection_check ) - ({ person });
     } else {
       things = filter_array( all_inventory( environment( person ) ),
                  (: living( $1 ) &&
                   ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
                   userp( $1 ) ) && !$1->query_property( "dead" ) :) )
            - ({ person });
     }
     i = sizeof( things );
     if ( i ) {
       i = random( i );
       things[ i ]->add_effect( file_name( this_object() ), arg );
#ifdef DEBUG
       log_file( "INFECTION", "%s, %s infected with %s by %s\n",
                ctime( time() ),
                things[ i ]->query_name(),
                this_object()->query_name(),
                person->query_name() );
#endif
     }
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   if ( !query_heart_beat( person ) )
      return;
   this_object()->disease_action( person, arg, id );
}
int test_remove( object, int, int, int ) {
#ifdef DEBUG
  log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
#endif
}

==================================================
FILE: effects/curses/alone.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "misc.curse.alone"; }
string query_shadow_ob() { return SHADOWS+"alone"; }
int beginning( object player, int time ) {
   player->add_extra_look( this_object() );
}
void merge_effect( object player, int time1, int time2 ) {
}
void end(object player) {
   player->remove_extra_look( this_object() );
}
string extra_look( object player ) {
   if ( player == this_player() )
     return "";
   return capitalize( (string)player->query_pronoun() )+
     " can't see you.\n";
}

==================================================
FILE: effects/curses/antisqeal.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your ability to mangle the english language "
                         "returns.\n");
}
string query_classification() { return "misc.curse.antisqeal"; }
string query_shadow_ob() { return "/std/shadows/curses/antisqeal"; }

==================================================
FILE: effects/curses/chef_curse.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your craving for swedish meatballs goes away.\n");
}
string query_classification() { return "misc.curse.chef"; }
string query_shadow_ob() { return "/std/shadows/curses/chef_curse"; }
