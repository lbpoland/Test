




==================================================
FILE: /lib/obj/handlers/login_handler.c
==================================================

#include <login.h>
#ifdef LOGIN_DEBUG
#undef MAX_COMPRESSED_PLAYERS
#undef MAX_UNCOMPRESSED_PLAYERS
#undef MAX_PLAYERS
#define LOGIN_MAX_COMPRESSED_PLAYERS 2
#define MAX_UNCOMPRESSED_PLAYERS 1
#define MAX_PLAYERS (MAX_COMPRESSED_PLAYERS + MAX_UNCOMPRESSED_PLAYERS)
#endif
#ifdef LOGIN_DEBUG
#define is_compressed_login(x) (strsrch((x)->query_name(), "test") > -1)
#else
#define is_compressed_login(x) (compressedp(x))
#endif
#define COMPRESSED_INTAKE_COUNT 5
#ifdef USE_RAMDISK
#define SAVE_TIME 300
#else
#define SAVE_TIME 900
#endif
#define NEW_SAVE_TIME 15
#define SAVE_NAME "/save/login_handler"
#define BUFFER_TIME 30
#define LOCKDOWN_TIME 900
#define MAX_FAILURES 3
class login_information {
    mixed ob;
    string funct;
}
mapping _static_login_calls;
nosave mapping _dynamic_login_calls;
nosave string _best;
nosave string _worst;
nosave string *_players_on;
nosave mapping _compressed_players_on;
nosave mapping _telnet_players_on;
nosave object *_compressed_login_queue;
nosave object *_telnet_login_queue;
nosave int _compressed_login_count;
nosave string enter_log;
nosave int last_entry;
nosave mapping messages;
nosave mapping lockdowns;
nosave int _creators;
nosave int _players;
nosave int _login_q;
nosave int _next_user_log;
nosave int _title_call;
nosave int _save_call;
nosave int _out_q;
nosave int _q_time;
nosave int _last_queue_time;
nosave int _last_queue_result;
int is_discworld_full(int test_login_queue);
void write_log(string event, string name, int guest, string other);
void save_users();
private void store_user_count();
private void log_user_count();
protected void check_all_titles( string player );
private void do_all_calls(string player, string event);
private void do_call(class login_information login_inf,
  string player, int event);
int is_uncompressed_full( int );
void create() {
    object pl;
    string name;
    _static_login_calls = ([ ]);
    _dynamic_login_calls = ([ ]);
    seteuid( "Root" );
    unguarded((: restore_object, SAVE_NAME :));
    foreach(name in keys(_static_login_calls)) {
      if(!sizeof(_static_login_calls[name])) {
        map_delete(_static_login_calls, name);
      }
      catch(unguarded((: save_object, SAVE_NAME :)));
    }
    _compressed_players_on = ([ ]);
    _telnet_players_on = ([ ]);
    _players_on = ({ });
    foreach(pl in users()) {
        if (is_compressed_login(pl)) {
            _compressed_players_on[ pl->query_name() ] = 1;
        }
        else {
            _telnet_players_on[ pl->query_name() ] = 1;
        }
        _players_on += ({ pl->query_name() });
    }
    _compressed_login_queue = ({ });
    _telnet_login_queue = ({ });
    _compressed_login_count = 1;
    _save_call = call_out( "save_users", NEW_SAVE_TIME );
    _next_user_log = time() + 3601 - (time() % 3600);
    enter_log = "";
    last_entry = time();
    call_out("clean_lockdowns", 3600);
    write_log("Periodic", "", 0, "");
}
mapping query_static_login_calls() {
    return copy(_static_login_calls);
}
mapping query_dynamic_login_calls() {
    return copy(_dynamic_login_calls);
}
string query_best() { return _best; }
string query_worst() { return _worst; }
string *query_players_on() {
    return keys( _compressed_players_on ) + keys( _telnet_players_on );
}
object *query_login_queue() {
    return _compressed_login_queue + _telnet_login_queue;
}
void add_to_login_queue(object login_ob) {
    if ( is_compressed_login( login_ob ) ) {
        _compressed_login_queue += ({ login_ob });
    }
    else {
        _telnet_login_queue += ({ login_ob });
    }
}
void remove_from_login_queue(object ob) {
    _compressed_login_queue -= ({ ob });
    _telnet_login_queue -= ({ ob });
}
int can_jump_queue( object ob ) {
    return ob->query_creator() || ob->query_net_dead() ||
        ob->query_property( "test character" );
}
object pop_from_login_queue() {
    object ob;
    object *login_queue;
    login_queue = query_login_queue();
    if ( !sizeof( login_queue ) ) {
        return 0;
    }
    if(time() != _q_time){
      _q_time = time();
      _out_q = 0;
    }
    _out_q++;
    foreach( ob in _compressed_login_queue ) {
        if ( can_jump_queue( ob ) ) {
            remove_from_login_queue( ob );
            return ob;
        }
    }
    reset_eval_cost();
    if(sizeof(_telnet_login_queue) &&
       !is_uncompressed_full(WITHOUT_LOGIN_QUEUE)) {
      foreach( ob in _telnet_login_queue ) {
        if ( can_jump_queue( ob ) ) {
          remove_from_login_queue( ob );
          return ob;
        }
      }
    }
    if ( sizeof( _compressed_login_queue) &&
         _compressed_login_count < COMPRESSED_INTAKE_COUNT ) {
        _compressed_login_count++;
        ob = _compressed_login_queue[ 0 ];
        _compressed_login_queue = _compressed_login_queue[ 1.. ];
    } else {
        _compressed_login_count = 0;
        ob = _telnet_login_queue[ 0 ];
        _telnet_login_queue = _telnet_login_queue[ 1.. ];
    }
    return ob;
}
int add_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;
  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }
  if(obj[0..3] == "/w/")
    return 0;
  if(_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
    login_inf->funct == funct) {
  return 1;
      }
    }
  }
  if (!_static_login_calls[player]) {
    _static_login_calls[player] = ({ });
  }
  login_inf = new (class login_information, funct : funct, ob : obj);
  _static_login_calls[player] += ({ login_inf });
  catch(unguarded((: save_object, SAVE_NAME :)));
  return 1;
}
int remove_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;
  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
          login_inf->funct == funct) {
        _static_login_calls[player] -= ({ login_inf });
        if(!sizeof(_static_login_calls[player]))
          map_delete(_static_login_calls, player);
        catch(unguarded((: save_object, SAVE_NAME :)));
        return 1;
      }
    }
  }
  return 0;
}
int add_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;
    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }
    if (!_dynamic_login_calls[player]) {
        _dynamic_login_calls[player] = ({ });
    }
    login_inf = new (class login_information, funct : funct, ob : obj);
    _dynamic_login_calls[player] += ({ login_inf });
    return 1;
}
int remove_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;
    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }
    if (_dynamic_login_calls[player]) {
        foreach (login_inf in _dynamic_login_calls[player]) {
            if (login_inf->ob == obj &&
              login_inf->funct == funct) {
                _dynamic_login_calls[player] -= ({ login_inf });
                return 1;
            }
        }
    }
    return 0;
}
void update_players_on( string player ) {
    object ob = find_player( player );
    if ( !ob ) {
        return;
    }
    if ( is_compressed_login( ob ) ) {
        if ( undefinedp( _compressed_players_on[ player ] ) ) {
            _compressed_players_on[ player ] = 1;
        }
    }
    else {
        if ( undefinedp( _telnet_players_on[ player ] ) ) {
            _telnet_players_on[ player ] = 1;
        }
    }
    if ( member_array( player, _players_on ) == -1 ) {
        _players_on += ({ player });
    }
}
int tidy_players_on( string player ) {
    int pos;
    int ret;
    ret = 0;
    if ( _compressed_players_on[ player ] ) {
        map_delete( _compressed_players_on, player );
        ret = 1;
    }
    if ( _telnet_players_on[ player ] ) {
        map_delete( _telnet_players_on, player );
        ret = 1;
    }
    pos = member_array( player, _players_on );
    if ( pos != -1 ) {
        _players_on = _players_on[0..pos-1] + _players_on[pos+1..];
        ret = 1;
    }
    return ret;
}
int player_logon(string player, int guest, string ip) {
    if(lower_case(player) != (string)previous_object()->query_name()) {
        return 0;
    }
    update_players_on( player );
    do_all_calls(player, LOGIN);
    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player );
    }
    write_log("Enter", player, guest, ip);
}
private void do_all_calls(string player, string event_t) {
  class login_information login_inf;
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_static_login_calls["all"]) {
    foreach (login_inf in _static_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls[player]) {
    foreach (login_inf in _dynamic_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls["all"]) {
    foreach (login_inf in _dynamic_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
}
private void do_call(class login_information login_inf,
                     string player, int event_t) {
  object ob;
  if (!find_player(player) || find_player(player)->query_invis() < 2) {
    if (!functionp(login_inf->funct)) {
      if(login_inf->ob && login_inf->funct)
        catch(ob = load_object(login_inf->ob));
      if ( ob ) {
        catch(call_other(ob, login_inf->funct, player,
                         event_t));
      } else {
        tell_creator("ceres", "failed to load %s", login_inf->ob);
      }
    } else {
      catch(evaluate(login_inf->funct, player, event_t));
    }
  }
}
int player_logout(string player) {
    object ob;
    do_all_calls(player, LOGOUT);
    if ( tidy_players_on( player ) ) {
        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }
    if(find_call_out(_save_call) == -1) {
        _save_call = call_out("save_users", NEW_SAVE_TIME );
    }
    while (sizeof(query_login_queue()) &&
        !is_discworld_full(WITHOUT_LOGIN_QUEUE) ) {
        ob = pop_from_login_queue();
        if (ob) {
            ob->remove_from_login_queue();
        }
    }
    write_log("Exit", player, 0, "");
    return 1;
}
int player_net_dead(string player) {
    object ob;
    if ( tidy_players_on( player ) ) {
        do_all_calls(player, NETDEATH);
        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }
    while ( sizeof(query_login_queue()) && !is_discworld_full(WITHOUT_ANY_LOGINS) ) {
        ob = pop_from_login_queue();
        if (ob) {
            ob->remove_from_login_queue();
        }
    }
    write_log("NDead", player, 0, "");
    return 1;
}
int player_reconnected(string player) {
    update_players_on(player);
    do_all_calls(player, RECONNECT);
    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player);
    }
    write_log("Recon", player, 0, query_ip_name(find_player(player)));
}
protected void check_all_titles( string player ) {
    int al, good, bad;
    object good_thing, bad_thing, thing, *things;
    good = -250;
    bad = 250;
    things = users();
    foreach( thing in things ) {
      if (!thing || thing->query_creator() ) {
        continue;
      }
      al = (int)thing->query_al();
      if ( al > bad ) {
        bad = al;
        bad_thing = thing;
      }
      if ( al < good ) {
        good = al;
        good_thing = thing;
      }
    }
    if ( bad_thing ) {
      if ( stringp( _worst ) && ( _worst != player ) ) {
        thing = find_player( _worst );
      } else {
        thing = 0;
      }
      if ( bad_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)bad_thing->query_gender() ) {
        case 1 :
          bad_thing->set_title( "align", "Lord of Darkness" );
          break;
        case 2 :
          bad_thing->set_title( "align", "Lady of Darkness" );
          break;
        default :
          bad_thing->set_title( "align", "Monster of Darkness" );
        }
        _worst = (string)bad_thing->query_name();
      }
    }
    if ( good_thing ) {
      if ( stringp( _best ) && ( _best != player ) ) {
        thing = find_player( _best );
      } else {
        thing = 0;
      }
      if ( good_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)good_thing->query_gender() ) {
        case 1 :
          good_thing->set_title( "align", "Lord of Light" );
          break;
        case 2 :
          good_thing->set_title( "align", "Lady of Light" );
          break;
        default :
          good_thing->set_title( "align", "Creature of Light" );
        }
        _best = (string)good_thing->query_name();
      }
    }
}
void save_users() {
    int number;
    int next_time;
    string word;
    object thing;
    number = sizeof( _players_on );
    if ( !number ) {
        _players_on = query_players_on();
        _save_call = call_out("save_users", NEW_SAVE_TIME );
        return;
    }
    store_user_count();
    if(_next_user_log < time()) {
        log_user_count();
    }
    word = _players_on[ 0 ];
    thing = find_player( word );
    if ( objectp( thing ) && ( number > 1 ) ) {
        if ( environment( thing ) ) {
            thing->save_me();
        }
        _players_on = _players_on[1..] + ({ word });
    } else {
        _players_on = _players_on[1..] + ({ word });
    }
    next_time = SAVE_TIME / number;
    if ( next_time > 10 ) {
        next_time = 10;
    }
    _save_call = call_out( (: save_users :), next_time );
}
int int_is_discworld_full(int logins) {
    object *players;
    int compressed;
    int uncompressed;
    int ret;
    int ext;
    players = users();
    switch (logins) {
    case WITHOUT_LOGINS_NOT_IN_QUEUE :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :)) + query_login_queue();
        break;
    case WITHOUT_LOGIN_QUEUE :
        players -= query_login_queue();
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    case WITHOUT_ANY_LOGINS :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :));
        ext = _out_q;
        break;
    default :
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    }
    if(time() != _q_time){
      ext = 0;
      _out_q = 0;
      _q_time = time();
    }
    compressed = sizeof( filter( players, (: is_compressed_login($1) :) )  ) + ext;
    uncompressed = sizeof( players ) - compressed;
    ret = DISCWORLD_IS_EMPTY;
    if ( compressed >= MAX_COMPRESSED_PLAYERS ) {
        ret |= COMPRESSED_FULL;
    }
    if ( uncompressed >= MAX_UNCOMPRESSED_PLAYERS ) {
        ret |= UNCOMPRESSED_FULL;
    }
    return ret;
}
int is_compressed_full( int logins ) {
    return int_is_discworld_full( logins ) & COMPRESSED_FULL;
}
int is_uncompressed_full( int logins ) {
    return int_is_discworld_full( logins ) & UNCOMPRESSED_FULL;
}
int is_discworld_full(int logins) {
    int ret;
    ret = int_is_discworld_full( logins );
    ret = (ret & COMPRESSED_FULL) && (ret & UNCOMPRESSED_FULL);
    return ret;
}
private void store_user_count() {
    object pl;
    int current_players, current_creators, current_login_q;
    string *logins_n;
    foreach(pl in users()) {
      if (pl && !pl->query_login_ob()) {
        if (pl->query_creator()) {
          current_creators++;
        } else {
          current_players++;
        }
      }
    }
    logins_n = map(LOGIN_HANDLER->query_login_queue(),
      (: $1->query_cap_name() :));
    logins_n = sort_array(logins_n, 1);
    current_login_q = sizeof(logins_n);
    if(current_players + current_login_q > _players + _login_q) {
        _players = current_players;
        _creators = current_creators;
        _login_q = current_login_q;
    }
}
private void log_user_count() {
    log_file("USERS", "%s %d %d %d\n" ,ctime(time()), _creators, _players,
      _login_q);
    _creators = 0;
    _players = 0;
    _login_q = 0;
    _next_user_log = time() + 3601 - (time() % 3600);
}
void write_log(string event, string name, int guest, string other) {
    switch(event) {
    case "Enter":
        enter_log += sprintf( "%s [Enter] %-15s %s%s\n",
          ctime(time())[4..18], name,
          guest?"(guest) ":"",
          other);
        break;
    case "Su":
        enter_log += sprintf( "%s [Su]    %15-s %15-s\n",
          ctime(time())[4..18], name, other);
        break;
    case "Periodic":
        call_out("write_log", BUFFER_TIME, "Periodic", "", 0, "");
        if (sizeof(enter_log) && time() - last_entry > BUFFER_TIME) {
            unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
            enter_log = "";
            last_entry = time();
        }
        return;
    case "Recon":
        enter_log += sprintf( "%s [Recon] %15-s %s\n",
          ctime(time())[4..18], name, other);
        break;
    default:
        enter_log += sprintf("%s %-7s %15-s\n", ctime(time())[4..18],
          "["+event+"]", name);
        break;
    }
    last_entry = time();
    if(sizeof(enter_log) > 1024) {
        unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
        enter_log = "";
    }
}
void dest_me() {
    unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
    enter_log = "";
    destruct(this_object());
}
string get_message(string mess_name) {
    if(!messages)
        messages = ([ ]);
    if(mess_name[0..4] != "/doc/")
        return 0;
    if(!messages[mess_name])
        messages[mess_name] = read_file(mess_name);
    return messages[mess_name];
}
void clear_messages() {
    messages = ([ ]);
}
int site_lockeddown(string ip_addr) {
    if(!lockdowns)
        lockdowns = ([ ]);
    if(lockdowns[ip_addr] &&
      (sizeof(lockdowns[ip_addr]) >= MAX_FAILURES) &&
      (lockdowns[ip_addr][0] > time() - LOCKDOWN_TIME))
        return 1;
    return 0;
}
void failed_login(string ip_addr) {
  int i;
  if(!lockdowns)
    lockdowns = ([ ]);
  if(!lockdowns[ip_addr])
    lockdowns[ip_addr] = ({ time() });
  else {
    for(i=0; i<sizeof(lockdowns[ip_addr]); i++)
      if(lockdowns[ip_addr][i] < time() - LOCKDOWN_TIME) {
        lockdowns[ip_addr] -= ({ lockdowns[ip_addr][i] });
        i--;
      }
    lockdowns[ip_addr] += ({ time() });
    if(sizeof(lockdowns[ip_addr]) > MAX_FAILURES) {
      lockdowns[ip_addr] =
        lockdowns[ip_addr][sizeof(lockdowns[ip_addr])-MAX_FAILURES..];
    }
  }
}
void clean_lockdowns() {
  string ip;
  call_out("clean_lockdowns", 1800);
  foreach(ip in keys(lockdowns)) {
    if(lockdowns[ip][sizeof(lockdowns[ip])-1] < time() - LOCKDOWN_TIME) {
      map_delete(lockdowns, ip);
    }
  }
}
void clear_lockdowns(string ip) {
  if(!ip)
    lockdowns = ([ ]);
  else if(lockdowns[ip])
    map_delete(lockdowns, ip);
}
void query_lockdowns() {
    printf("%O\n", lockdowns);
}
void reset() {
    if (find_call_out(_save_call) == -1) {
        save_users();
    }
}

==================================================
FILE: /lib/obj/handlers/mag_eff_handler.c
==================================================

#define BLACK_MASS 1000
#define NUM_POSS 6
#define NUM_USER 20
private mixed *_octonite;
private int _call_out_no;
protected void update_octonite();
protected void schedule_next();
int block( object thing ) {
   if ( !thing->query_closed() )
      return 0;
   return (int)thing->query_property( "enchantment block" );
}
int ambient_enchantment( object thing ) {
   int i, total;
   object *tops;
   tops = ({ thing });
   while ( environment( tops[ 0 ] ) ) {
      tops = ({ environment( tops[ 0 ] ) }) + tops;
   }
   for ( i = 0; i < sizeof( tops ); i++ ) {
      total += (int)tops[ i ]->query_enchant();
      total = ( total * ( 100 - block( tops[ i ] ) ) + 50 ) / 100;
   }
   return total;
}
int *choose_effect( int number ) {
  return ({ number, random( NUM_POSS * number ) / BLACK_MASS });
}
void do_effect( int number, string name, object place ) {
  int i;
  string word;
  object thing, *things;
  switch( number ) {
    case 0:
      tell_room( place, "How curious.\n" );
      break;
    case 1:
      tell_room( place, name +" spins slowly in mid-air, then "+
        "vanishes with a small \"pop!\"\n" );
      break;
    case 2:
      i = random( 4 );
      tell_room( place, name +" sparkles and turns into a small "+
        ({ "yellow", "green", "hairy", "spotted" })[ i ] +" caterpillar.\n" );
      thing = clone_object( "/obj/monster" );
      thing->set_name( "caterpillar" );
      thing->set_short( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillar" );
      thing->add_adjective( ({ "yellow", "green", "hairy", "spotted" })[ i ] );
      thing->set_main_plural( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillars" );
      thing->add_plural( "caterpillars" );
      thing->set_long( "This is a small, common or garden caterpillar.\n" );
      thing->set_race( "caterpillar" );
      thing->set_level( 1 );
      thing->move( place );
      break;
    case 3:
      tell_room( place, name +" vanishes with a sharp \"spang!\"\n"+
        "A moment later, you hear a small thunderclap.\n" );
      break;
    case 4:
      tell_room( place, "Balefire blossoms, and "+ name +" turns into "+
        "a bunch of flowers.\n" );
      thing = clone_object( "/std/object" );
      thing->set_name( "flowers" );
      thing->set_short( "bunch of flowers" );
      thing->set_main_plural( "bunches of flowers" );
      thing->add_adjective( ({ "bunch", "bunches", "of" }) );
      thing->add_plural( "bunches" );
      thing->set_long( "A nice bunch of flowers.\n" );
      thing->set_weight( 10 );
      thing->set_value( 100 );
      thing->move( place );
      break;
    case 5:
      tell_room( place, "With a small gout of flame, "+ name +" begins "+
        "to accelerate.\n" );
      switch( (string)place->query_property( "location" ) ) {
        case "outside":
          tell_room( place, name +" vanishes into the distance.\n" );
          break;
        default:
          tell_room( place, "There is a small puff of burning dust as "+
            name +" passes through a wall.\n" );
      }
      things = users() - all_inventory( place );
      if ( sizeof( things ) > ( i = random( NUM_USER ) ) ) {
        if ( !( thing = environment( things[ i ] ) ) ) break;
        tell_object( find_player( "deutha" ),
            (string)things[ i ]->query_name() +"\n" );
        tell_room( thing, "You hear a high-pitched whine.\n" );
        tell_object( things[ i ], "Something small and very hot zooms past "+
          "you at ear level.\n" );
        if ( ( !( word = (string)things[ i ]->query_short() ) || ( word == "" )
          ) || things[ i ]->query_invis() ) break;
        tell_room( thing, word +" looks shaken.\n", things[ i ] );
      }
      break;
    default:
      tell_room( place, "Something really, really strange happens.\n" );
  }
}
object *query_octonite_crystals() { return _octonite; }
void add_octonite_crystal( object crystal ) {
   int i, when;
   when = time() + roll_MdN( 5, 60 );
   if ( !sizeof( _octonite ) ) {
      _octonite = ({ crystal, when });
      schedule_next();
   } else {
      for ( i = 0; i < sizeof( _octonite ); i += 2 ) {
         if ( when < _octonite[ i + 1 ] ) {
            break;
         }
      }
      if ( i == 0 ) {
         _octonite = ({ crystal, when }) + _octonite;
         schedule_next();
         return;
      }
      if ( i >= sizeof( _octonite ) ) {
         _octonite += ({ crystal, when });
         return;
      }
      _octonite = _octonite[ 0 .. i - 1 ] + ({ crystal, when }) +
            _octonite[ i ..  ];
   }
}
protected void schedule_next() {
   int next;
   remove_call_out(_call_out_no);
   next = _octonite[ 1 ] - time();
   if ( next > 0 ) {
      _call_out_no = call_out( (: update_octonite :), next );
   } else {
      _call_out_no = call_out( (: update_octonite :), 0 );
   }
}
protected void update_octonite() {
   int ambient, weight;
   object crystal;
   crystal = _octonite[ 0 ];
   if ( objectp( crystal ) ) {
      weight = 20 * (int)crystal->query_weight();
      tell_object( find_player( "deutha" ), "Current: "+ weight +".\n" );
      ambient = ambient_enchantment( crystal );
      if ( ambient > weight ) {
         weight += ( ambient - weight ) / 4;
      }
      weight -= ( weight * ( 100 - block( environment( crystal ) ) ) ) / 800;
      if ( random( 20 ) < weight % 20 ) {
         weight += 20;
      }
      weight /= 20;
      if ( !weight )
         crystal->dest_me();
      else {
         crystal->set_weight( weight );
         crystal->set_enchant( ( 7 * (int)crystal->query_max_enchant() ) / 8 );
         crystal->set_value_info( "magic", weight * 10000 );
      }
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
      if ( crystal ) {
         add_octonite_crystal( crystal );
      }
   } else {
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
   }
}
string extra_look( object thing ) {
   if ( explode( file_name( thing ), "#" )[ 0 ] != "/obj/magic/octonite" ) {
      return "";
   }
   switch ( (int)thing->query_weight() ) {
      case 0 :
         return "";
      case 1 .. 2 :
         return "It is about the size of a pea.\n";
      case 3 .. 6 :
         return "It is about the size of a hazelnut.\n";
      case 7 .. 12 :
         return "It is about the size of a walnut.\n";
      case 13 .. 20 :
         return "It is about the size of an orange.\n";
      case 21 .. 30 :
         return "It is about the size of a grapefruit.\n";
      default :
         return "It is about the size of a pumpkin.\n";
   }
}

==================================================
FILE: /lib/obj/handlers/mail_track.c
==================================================

inherit "std/object";
#include <mail.h>
#include <mail_track.h>
#include <player_handler.h>
#define SECURITY if (!master()->query_leader(previous_object(-1))) return 0;
int add_member(string list, string mem);
private void load_me();
private void save_me();
int query_list(string list);
int create_list(string list, string creator);
nosave mixed *our_mailers;
mapping mailing_lists;
void setup() {
   set_name("tracker");
   set_short("mail tracker");
   add_property("determinate", "the ");
   add_property("there", "mounted on one wall");
   add_adjective("mail");
   set_long("This thing tracks mail.   Clever, innit?\n");
   reset_get();
   reset_drop();
   our_mailers = ({ });
   mailing_lists = ([ ]);
   seteuid("Root");
   load_me();
   if (!query_list("postmaster")) {
      create_list("postmaster", "pinkfish");
   }
   move(MAIL_ROOM);
}
int add_mailer(object ob, string str) {
   int i;
   if (!stringp(str) || !objectp(ob)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      our_mailers += ({ ob, str });
   } else {
      write(i);
      if (our_mailers[i-1]) {
         our_mailers[i-1]->dest_me();
      }
      our_mailers += ({ ob, str });
   }
   return 1;
}
object find_mailer(string str) {
   int i;
   if (!stringp(str)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      return 0;
   }
   return our_mailers[i-1];
}
int delete_mailer(object ob) {
   int i;
   if (!objectp(ob)) {
      return 0;
   }
   i = member_array(ob, our_mailers);
   if (i == -1) {
      return 0;
   }
   our_mailers = delete(our_mailers, i, 2);
}
void we_are_done(object me) {
   if (objectp(me)) {
      me->dest_me();
   }
}
int mail(string str, string sub) {
   object mailer;
   mailer = clone_object(MAILER);
   mailer->set_do_this_last(({ this_object(), "we_are_done", mailer }));
   mailer->read_mail(str, sub);
   return 2;
}
private void save_me() {
   unguarded((: save_object, "/save/mail_track" :));
}
private void load_me() {
   string *list_names, name;
   mixed *list;
   unguarded((: restore_object, "/save/mail_track" :));
   list_names = keys(mailing_lists);
   if (sizeof(list_names) && !classp(mailing_lists[list_names[0]])) {
      foreach (name, list in mailing_lists) {
         mailing_lists[name] = new(class mailing_list, members : list[0],
                                                controllers : list[1], creator : list[2]);
      }
      save_me();
   }
}
string *query_mailing_lists() {
   return keys(mailing_lists) +
     "/secure/master"->query_domains() +
      ({ "seniors", "lords", "hlords" });
}
int query_list(string list) {
   return member_array(list, query_mailing_lists()) != -1;
}
string *query_members(string list) {
  string *tmp;
  switch (list) {
  case "playtesters" :
    tmp = (string *)"/obj/handlers/playtesters"->query_playtesters();
    return ({ "/d/playtesters/master"->query_lord() }) + sort_array(tmp, 1);
  case "seniors" :
    tmp = (string *)master()->query_all_seniors();
    return tmp;
  case "lords" :
    tmp = (string *)master()->query_all_leaders();
    return tmp;
  case "hlords" :
    tmp = ((string *)master()->query_administrators() -
           ({ "Admin", "Root", "offler" }));
    return tmp;
  default :
  }
  if (file_size("/d/"+ list) == -2) {
    tmp = (string *)("/d/"+ list +"/master")->query_members() +
      ({ (string)("/d/"+ list +"/master")->query_lord() });
  }
  else if (mailing_lists[list]) {
    tmp = copy(mailing_lists[list]->members);
  }
  if(tmp)
    return filter_array(tmp, (: PLAYER_HANDLER->test_active($1, 1) :));
  return ({ });
}
int query_member(string list_name, string name) {
   class mailing_list list;
   list = mailing_lists[list_name];
   if (list) {
      return member_array(name, list->members) != -1;
   }
   if (file_size("/d/" + list_name) == -2) {
      return (int)("/d/" + list_name + "/master")->query_member(name);
   }
   if (list_name == "seniors") {
      return (int)master()->query_senior(name);
   }
   if (list_name == "lords") {
      return (int)master()->query_leader(name);
   }
   if (list_name == "hlords") {
      return (int)master()->query_administrator(name);
   }
}
string *query_controllers(string list) {
   if (file_size("/d/"+ list) == -2) {
      return ({ (string)("/d/"+ list +"/master")->query_lord() });
   }
   if (mailing_lists[list]) {
      return copy(mailing_lists[list]->controllers);
   }
   return ({ });
}
int query_controller(string list_name, string name) {
   class mailing_list list = mailing_lists[list_name];
   if (!list) {
      return 0;
   }
   return member_array(name, list->controllers) != -1;
}
string query_creator(string list_name) {
   class mailing_list list = mailing_lists[list_name];
   if (!classp(list)) {
      return 0;
   }
   return list->creator;
}
int create_list(string list, string creator) {
   SECURITY
   if (mailing_lists[list]) {
      return 0;
   }
   if (file_size("/d/" + list) == -2) {
      return 0;
   }
   if (PLAYER_HANDLER->test_user(list)) {
      return 0;
   }
   mailing_lists[list] = new(class mailing_list, members : ({ creator }),
                                          controllers : ({ creator }), creator : creator);
   save_me();
   return 1;
}
protected int delete_list(string list) {
   if (!mailing_lists[list]) {
      return 0;
   }
   map_delete(mailing_lists, list);
   save_me();
   return 1;
}
int add_controller(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->controllers) != -1) {
      return 0;
   }
   list->controllers += ({ mem });
   add_member(list_name, mem);
   save_me();
   return 1;
}
int remove_controller(string list_name, string name) {
   int i;
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(name, list->controllers)) == -1) {
      return 0;
   }
   list->controllers = delete(list->controllers, i, 1);
   save_me();
   return 1;
}
int add_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->members) != -1) {
      return 0;
   }
   list->members += ({ mem });
   save_me();
   return 1;
}
int remove_member(string list_name, string mem) {
   int i;
   class mailing_list list = mailing_lists[list_name];
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(mem, list->members)) == -1) {
      return 0;
   }
   list->members = delete(list->members, i, 1);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
}
int delete_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!remove_member(list_name, mem)) {
      return 0;
   }
   remove_controller(list_name, mem);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
}

==================================================
FILE: /lib/obj/handlers/mailer.c
==================================================

#include <mime.h>
#include <mail.h>
#include <localtime.h>
#include <player_handler.h>
#define FOLDER_H "/obj/handlers/folder_handler.c"
#define MAIL_PATH "/save/mail/"
#define COLS (int)owner->query_cols()
#define ROWS (int)owner->query_rows()
#undef CONVERTER
nosave class mail_header *folder;
nosave int *deleted, *newish, no_menu, last_read, full_header;
nosave string current, to, subject, cc, mailrc;
nosave mixed *do_this_last;
nosave object owner;
nosave string *ignore = ({
  "email-version",
  "x-lines",
  "expires",
  "transport-options",
  "x-mailer",
  "errors-to",
  "lines",
  "priority",
  "newsgroups",
  "default-options",
  "auto-forward-count",
  "ua-message-id",
  "approved",
  "followup-to",
  "message-version",
  "message-id",
  "message-service",
  "message-type",
  "sender",
  "end-of-header",
  "content-type",
  "path",
  "report-version",
  "submitted-by",
  "message-protocol",
  "posting-number",
  "x-postmark",
  "apparently-to",
  "organization",
  "posted-date",
  "return-receipt-to",
  "keywords",
  "x-sun-charset",
  "summary",
  "in-reply-to",
  "reply-to",
  "distribution",
  "sent-by",
  "company",
  "references",
  "mts-message-id",
  "x-sequence",
  "via",
  "content-charset",
  "status",
  "confirmed-by",
  "ua-content-id",
  "content-length",
  "mime-version",
  "auto-forwarded-from",
  "content-transfer-encoding",
  "received",
  "end-of-protocol",
  "x-uidl",
  "precedence",
  "return-path"
});
string *folder_names;
varargs protected void rm_message(string input);
protected void unrm_message(string input);
private void print_message(int number);
varargs private void reply_message(int input, int flag);
private void save_me();
private int load_me();
void dest_me();
private void read_messages(string fname);
protected void read_loop(string input);
private void prompt();
protected void change_folder(string input);
varargs private void delete_it(string bonk, int last, string newish_folder);
varargs protected void move_message(string input, int flag);
private void save_message(string input);
protected void get_recipient(string input);
varargs protected void get_subject(string input, int number, int flag);
varargs protected void main_menu(string fname, int flag, int *range);
protected void forward_message(string input);
void finish_write_message(string input);
string format_date(int x);
private int *expand_range(string str);
private int valid_name(string str);
void read_mail(string str, string sub);
private void forward_email(int number);
private void write_message();
private void check_external_mail();
private void create() {
    mapping aliases;
    seteuid("Mailer");
    no_menu = full_header = 0;
    last_read = -1;
    newish = ({ });
    folder = ({ });
    folder_names = ({ "inbox" });
    deleted = ({ });
    current = "";
    if (clonep()) {
        owner = this_player();
        if (owner) {
            aliases = owner->query_aliases();
            if (aliases) {
                mailrc = aliases[".mailrc"];
            }
        }
    } else {
        check_external_mail();
    }
}
#define HEADER_NAME 1
#define HEADER_VAL  2
private string folder_filename(string name) {
    return MAIL_PATH+name[0..0] + "/"  + name;
}
private string strip_header(string message) {
    mixed *ra;
    int i;
    string header;
    if ((i = strsrch(message, "\n\n")) == -1) {
        return message;
    }
    header = message[0..i];
    message = message[i+1..];
    ra = reg_assoc(header,
      ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
      ({ HEADER_NAME, HEADER_VAL }));
    for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
        if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
            if (member_array(replace_string(lower_case(ra[0][i]), ":", ""),
                ignore) != -1) {
                ra[0][i] = ra[0][i+2] = "";
            }
        }
    }
    return implode(ra[0], "") + message;
}
private void check_external_mail() {
    string *dir, fname, mess, t, ccs;
    class mail_message msg = new(class mail_message);
    class mime_header hdr;
    dir = unguarded((: get_dir, EXTERNAL_MAIL_PATH :));
    if (!dir) {
        call_out((: check_external_mail :), 60);
        return;
    }
    foreach (fname in dir) {
        mess = unguarded((: read_file, EXTERNAL_MAIL_PATH + fname :));
        mess = replace(mess, ({ "\r\n", "\n", "\t", "        " }));
        hdr = MIME->parse_headers(mess);
        if (!hdr) {
            unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
            continue;
        }
        msg->from = hdr->header_m["from"];
        msg->subject = hdr->header_m["subject"];
        t = hdr->header_m["to"];
        if (!t) {
            continue;
        }
        msg->to = explode(t, ",");
        ccs = hdr->header_m["cc"];
        if (!ccs) {
            ccs = "";
        }
        msg->cc = explode(ccs, ",");
        msg->body = mess;
        FOLDER_H->add_it(msg, 1);
        unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
    }
    call_out((: check_external_mail :), 60);
}
void set_do_this_last(mixed *bing) { do_this_last = bing; }
mixed *query_do_this_last() { return do_this_last; }
varargs int do_mail_message(string t, string from, string sub, string ccs,
  string body, int, string only_to, int flag) {
    string *cc_e, *goto;
    class mail_message msg;
    if(file_name(previous_object())[0..12] != "/secure/login" &&
       file_name(previous_object())[0..13] != "/secure/nlogin" &&
       file_name(previous_object())[0..13] != "/obj/handlers/" &&
       file_name(previous_object())[0..4] != "/www/" &&
       file_name(previous_object())[0..11] != "/net/daemon/" &&
       file_name(previous_object())[0..11] != "/global/lord" &&
       file_name(previous_object())[0..14] != "/global/creator" &&
       file_name(previous_object())[0..18] != "/global/auto_mailer" &&
       file_name(previous_object())[0..12] != "/cmds/creator" &&
       file_name(previous_object())[0..9] != "/cmds/lord" &&
       file_name(previous_object()) != "/d/am/buildings/post/parcel" &&
       file_name(previous_object()) != "/d/am/buildings/apex/admin_office" &&
       file_name(previous_object()) != "/d/am/bookkeepers/weichert_office" &&
       file_name(previous_object()) != "/d/ram/ohulan/market/post_office" &&
       file_name(previous_object()) != "/d/ram/interview" &&
       file_name(previous_object()) != "/d/forn/utils/interview" &&
       file_name(previous_object()) != "/d/am/buildings/flintwick/lawyer_office" &&
       file_name(previous_object()) != "/d/am/buildings/council/court" &&
       file_name(previous_object()) != "/d/klatch/djel/city/palace/council_court" &&
       file_name(previous_object()) != "/d/guilds/error_tracker" &&
       file_name(previous_object())[0..25] != "/d/ram/ohulan/market/post2") {
        printf("MAILER: illegal access (%O).\n", file_name(previous_object()));
        return 0;
    }
    if ((file_name(previous_object())[0..11] == "/global/lord" ||
        file_name(previous_object())[0..14] == "/global/creator") &&
        (lower_case(from) != (string)this_player()->query_name())) {
        printf("MAILER: illegal acces.\n");
        return 0;
    }
    if (!ccs) {
        ccs = "";
    }
    cc_e = explode(ccs, ",")-({""});
    goto = explode(t, ",")-({""});
    if (only_to) {
        goto = explode(only_to, ",")-({""});
    }
    msg = new(class mail_message);
    msg->to = goto;
    msg->cc = cc_e;
    msg->body = "From " + from + " " + ctime(time()) +
    "\nDate: " + format_date(time()) +
    "\nFrom: " + from +
    "\nTo: " + t +
    "\nSubject: " + sub +
    "\n" + (sizeof(cc_e)?"Cc: "+ ccs+ "\n":"")+
    "\n" + body;
    msg->from = lower_case(from);
    msg->subject = sub;
    FOLDER_H->add_it(msg, flag);
    return 1;
}
string finger_mail(string pname) {
    return FOLDER_H->finger_mail(lower_case(pname));
}
string new_mail(string pname) {
    return FOLDER_H->check_mail(lower_case(pname));
}
private void prompt() {
    printf("\nCommand (h for main menu): ");
}
void read_mail(string str, string sub) {
    if (this_player()->query_property("guest")) {
        write("Sorry, mailer access is not allowed for guests.\n");
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }
    if (!load_me()) {
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }
    if (str) {
        no_menu = 1;
        if (!sub) {
            get_recipient(str);
        } else {
            to = str;
            get_subject(sub);
        }
        return;
    }
    MAIL_TRACK->add_mailer(this_object(), owner->query_name());
    main_menu("inbox");
    return;
}
varargs private void main_menu(string fname, int flag, int *range) {
    int i, size, offs, cols, fromcols, statcols;
    cols = COLS;
    printf("%|=*s", cols, "" + mud_name() + " mailer system version 2.0\n\n");
    if (!strlen(fname)) {
        fname = "inbox";
    }
    current = fname;
    if (!flag) {
        read_messages(current);
        last_read = -1;
        deleted = ({ });
    }
    if (!range) {
        range = ({ });
    }
    newish = ({ });
    size = sizeof(folder);
    for (i = 0; i < size; i++) {
        if (folder[i]->status == "N") {
            newish += ({ i });
        }
    }
    if (sizeof(newish) && newish[0] != 0 && last_read == -1) {
        last_read = newish[0]-1;
    }
    if (size && !sizeof(newish) && last_read == -1) {
        last_read = size-1;
    }
    printf(owner->fix_string(sprintf("%s%|=*s%s","%^CYAN%^",cols,
          "Folder "+current+" with "+
          (size?""+size:"no")+
          " message"+(size == 1?"":"s")+".\n\n",
          "%^RESET%^")));
    if (!sizeof(range)) {
        i = size - ROWS + 11;
        if (i < 0) {
            i = 0;
        }
        range = expand_range(sprintf("%d-%d", i, size));
    }
    size = sizeof(range);
    if (size) {
        offs = range[0]-1;
    } else {
        offs = 0;
    }
    statcols = cols / 3;
    fromcols = 2 * cols / 3 - 8;
    for (i = 0; i<size; i++) {
        printf(owner->
          fix_string(sprintf("%s%-6s %-*.*s %-*.*s%s\n",
              (last_read == i+offs?
                "%^REVERSE%^":""),
              (last_read == i+offs?">":" ")+
              folder[i+offs]->status+
              " " + (i+offs+1), statcols, statcols, "From: " +
              folder[i+offs]->from, fromcols, fromcols,
              "Subject: "+
              replace_string(terminal_colour(folder[i+offs]->subject,
                  ([ ])), "%", "%%"),
              "%^RESET%^")));
    }
    printf("%|=*s", cols, "\n  You can use any of the following commands by "
      "entering the first character;\nd)elete or u)ndelete mail,  m)ail a "
      "message,  r)eply or f)orward mail,  q)uit,\n"
      "> = move messages, c)hange folder, i)ndex of folders, ? = help\n"
      "To read next unread message, press <return>.\n");
    printf("Command: ");
    input_to("read_loop");
}
protected void read_loop(string input) {
    int i, num;
    string s1, s2, comm, *tmp;
    num = 0;
    i = 0;
    if (sscanf(input, "%d%s", num, input) != 2) {
        comm = "";
        if (sscanf(input, "%s %d %s", s1, num, s2) == 3) {
            i = 1;
            input = s1 + " " + s2;
        }
    }
    if (sscanf(input, "%s %s", comm, input) != 2) {
        comm = input;
        input = "";
    }
    if (i)
        input = ""+num+" "+input;
    switch(comm) {
    case "q" :  if (current == "inbox") {
            if (sizeof(folder) &&
              (sizeof(folder) != sizeof(newish)) &&
              (sizeof(deleted) != sizeof(folder))) {
                printf( "\nMove read message(s) to \"received\" folder? "
                  "(y/[n]): ");
                input_to("get_yesno");
                break;
            }
        }
        delete_it(current, 1);
        break;
    case "d" :
        if (input != "") {
            rm_message(input);
            break;
        }
        printf( "\nDelete which messages (number or range): " );
        input_to("rm_message");
        break;
    case "u" :
        if (input != "") {
            unrm_message(input);
            break;
        }
        printf( "\nUndelete which messages (number or range): " );
        input_to("unrm_message");
        break;
    case "c" :
        if (input != "") {
            change_folder(input);
            break;
        }
        printf( "\nChange to which folder (= for inbox): " );
        input_to("change_folder");
        break;
    case "m" :
        if (input != "") {
            get_recipient(input);
            break;
        }
        printf( "\nRecipient: " );
        input_to("get_recipient");
        break;
    case "R" :
        reply_message(num);
        break;
    case "r" :
        reply_message(num, 1);
        break;
    case "$" :
        main_menu(current);
        break;
    case "f" :
        if (input != "") {
            forward_message(input);
            break;
        }
        printf("\nForward a message.  Ranges are not supported.\n"
          "Enter the number of the message and the name(s) of the "
          "recipient(s), separated by a comma: ");
        input_to("forward_message");
        break;
    case "F" :
        forward_email(num);
        break;
    case "i" :
        printf("\nHere's the index of your folders:\n");
        printf("\n%-#*s\n", COLS, implode(folder_names, "\n"));
        prompt();
        input_to("read_loop");
        break;
    case "L" :
        if (full_header) {
            printf("\nOkay, now showing abbreviated header.\n");
            full_header = 0;
        } else {
            printf("\nOkay, now showing full header.\n");
            full_header = 1;
        }
        prompt();
        input_to("read_loop");
        break;
    case "l" :
        if (input != "") {
            if (!MAIL_TRACK->query_list(input)) {
                printf( "\nSorry, list "+input+" does not exist.\n" );
                prompt();
                input_to("read_loop");
                break;
            }
            printf( "\nMembers of list "+ input +":\n" );
            tmp = MAIL_TRACK->query_members(input);
        } else {
            printf( "\nCurrently available mailing lists:\n" );
            tmp = MAIL_TRACK->query_mailing_lists();
        }
        printf("\n%-#*s\n", COLS, implode(tmp,"\n"));
        prompt();
        input_to("read_loop");
        break;
    case ">" :
        if (!PLAYER_HANDLER->test_user(owner->query_name())) {
            printf( "You can't do that as a guest.\n" );
            break;
        }
        if (input != "") {
            move_message(input);
            break;
        }
        printf("\nMove message to folder.\nEnter the number "
          "(or range) of the message and the name of the folder, "
          "separated by a comma: ");
        input_to("move_message");
        break;
    case "h" :
        if (input != "") {
            main_menu(current, 1, expand_range(input));
            break;
        }
        main_menu(current, 1);
        break;
    case "s" :
        save_message(input);
        break;
    case "?" :
        owner->set_finish_func("finish_print");
        comm = read_file("/doc/helpdir/mailer");
        owner->more_string(comm);
        break;
    case "" :
        if (num) {
            print_message(num-1);
            last_read = num-1;
            break;
        }
        if (newish == ({ })) {
            printf("\nNo more new messages in folder.\n");
            prompt();
            input_to("read_loop");
            break;
        }
        last_read = newish[0];
        print_message(newish[0]);
        break;
    default :
        printf("\nUnknown command.  Use \"?\" for help.\n");
        prompt();
        input_to("read_loop");
        break;
    }
}
protected void get_yesno(string input) {
    int bing, i;
    if (!input || (input == "")) {
        printf("No.\n");
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "n") {
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "y") {
        bing = sizeof(folder);
        for (i = 0; i < bing; i++) {
            if ((member_array(i, newish) == -1) &&
              (member_array(folder[i]->number, deleted) == -1)) {
                move_message(""+(i+1)+" received", 1);
            }
        }
    }
    delete_it(current, 1);
    return;
}
private void forward_email(int number) {
    int i;
    string email, body;
    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    if (!(email = PLAYER_HANDLER->test_email(owner->query_name()))) {
        printf("Sorry, your E-mail address is not set.  Use chfn or email "
          "to set it.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (email[0] == ':') {
        email = email[1..];
    }
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (body) {
        SMTP->eventSendMail(email, owner->query_name(), body);
        printf("Message #%d forwarded to your E-mail address.\n", number + 1);
    }
    prompt();
    input_to("read_loop");
}
private string rewrite_local(string rcpt) {
    string tmpr;
    if ((tmpr = FOLDER_H->check_local(rcpt))) {
        return tmpr;
    }
    return rcpt;
}
varargs private void reply_message(int number, int flag) {
    int i;
    string body;
    class mime_header hdr;
    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    to = folder[number]->from;
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (!body) {
        prompt();
        input_to("read_loop");
        return;
    }
    hdr = MIME->parse_headers(body);
    if (!hdr) {
        prompt();
        input_to("read_loop");
        return;
    }
    if (hdr->header_m["reply-to"]) {
        to = hdr->header_m["reply-to"];
    }
    if (!flag) {
        string tmp;
        cc = hdr->header_m["cc"];
        tmp = hdr->header_m["to"];
        if (tmp) {
            if (cc) {
                cc += "," + tmp;
            } else {
                cc = tmp;
            }
        }
        if (cc == "") {
            cc = 0;
        }
        if (cc) {
            cc = implode(map(MIME->get_email_addrs(cc)[0],
                (: rewrite_local($1) :))-({ owner->query_name(), to }),
              ",");
        }
    }
    printf("Include original message? (y/[n]/q) ");
    input_to("finish_reply_message", 0, number);
}
protected void finish_reply_message(string input, int number) {
    int flag, i;
    string s1;
    if (!input || input == "" || lower_case(input)[0] != 'y') {
        if (lower_case(input)[0] == 'q') {
            cc = 0;
            to = "";
            printf("Aborting.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        printf( "No.\n" );
    } else flag = 1;
    subject = folder[number]->subject;
    if (sscanf(subject, "Re:#%d %s", i, s1) != 2)
        subject = "Re:#1 " + subject;
    else
        subject = sprintf("Re:#%d %s", (i+1), s1);
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (flag)
        input_to("get_subject", 0, ++number, 1);
    else
        input_to("get_subject");
}
protected void change_folder(string input) {
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (input == "=") {
        delete_it(current, 0, "inbox");
        return;
    }
    if (member_array(input, folder_names) == -1) {
        printf("No folder named %s.\n", input);
        prompt();
        input_to("read_loop");
        return;
    }
    delete_it(current, 0, input);
}
protected void get_recipient(string input) {
    string *str, *full, nn;
    int i;
    mixed *addrs;
    if (!input || input == "") {
        printf("No recipient given: aborting.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i=0;i<sizeof(str);i++){
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (sizeof(full))
        to = implode(full, ",");
    else {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    subject = "";
    printf("Subject: ");
    input_to("get_subject");
}
varargs protected void get_subject(string input, int number, int flag) {
    if ((!input || input == "") && (!subject || subject == "")) {
        printf("No subject given: aborting.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    if (input && input != "")
        subject = input;
    printf("Cc: ");
    input_to("get_cc", 0 , number, flag);
}
private int valid_name(string str) {
    string mud;
    str = lower_case(str);
    if (!sscanf(str, "%s@%s", str, mud) ||
      lower_case(mud) == lower_case(mud_name())) {
        return (int)PLAYER_HANDLER->test_user(str) ||
        (int)MAIL_TRACK->query_list(str);
    }
    return 1;
}
varargs protected void get_cc(string input, int number, int flag) {
    string *str, body, *full, nn;
    int i;
    mixed *addrs;
    if (!input || input == "**" || input == "") {
        if (number) {
            body = FOLDER_H->load_message(owner->query_name(), current,
              folder[number-1]->number);
            if (!body) {
                prompt();
                input_to("read_loop");
                return;
            }
            if (!flag) {
                finish_write_message("> " + replace_string(body, "\n", "\n> ") + "\n");
                return;
            }
            owner->do_edit("> " + replace_string(body, "\n", "\n> ") + "\n",
              "finish_write_message");
            return;
        }
        write_message();
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc", 0, number, flag);
}
private void write_message() {
    owner->do_edit(0, "finish_write_message");
}
void finish_write_message(string input) {
    if (!input || input == "") {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    printf("Cc: ");
    input_to("get_cc_after", 0, input);
}
protected void get_cc_after(string input, string body) {
    mixed *goto, cc_e, *addrs;
    class mail_message msg;
    string *str, *full, nn;
    int i;
    if (!input || input == "**" || input == "") {
        body += owner->append_signature();
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        goto = explode(to, ",") - ({ "" });
        if (cc && cc != "") {
            cc_e = explode(cc, ",") - ({ "" });
        } else {
            cc_e = ({ });
        }
        msg = new(class mail_message);
        msg->to = goto;
        msg->cc = cc_e;
        msg->body = "From " + owner->query_name() + " " + ctime(time()) +
        "\nDate: " + format_date(time()) +
        "\nFrom: " + owner->query_name() +
        "\nTo: " + to +
        "\nSubject: " + subject +
        "\n" + (sizeof(cc_e)?"Cc: " + cc + "\n":"") +
        "\n" + body;
        msg->from = owner->query_name();
        msg->subject = subject;
        FOLDER_H->add_it(msg, 0);
        to = "";
        cc = 0;
        subject = "";
        printf("Message sent.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc_after", 0, body);
}
varargs private void delete_it(string fname, int last, string newish_folder) {
    if (!fname)
        fname = current;
    if (deleted != ({ })) {
        printf("Delete message(s)? ([y]/n) ");
        input_to("finish_delete_it", 0, fname, last, newish_folder);
        return;
    }
    if (last) {
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        save_me();
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
}
protected void finish_delete_it(string input, string fname, int last,
  string newish_folder) {
    if (lower_case(input) == "n" || (input && input != "" &&
        lower_case(input) != "y")) {
        printf("Keeping message(s).\n");
        deleted = ({ });
        if (last) {
            FOLDER_H->mark_read(owner->query_name(), current, newish);
            save_me();
            if (do_this_last && objectp(do_this_last[0]))
                call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
            else
                dest_me();
            return;
        }
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        if (!newish_folder || newish_folder == "")
            main_menu(fname);
        else
            main_menu(newish_folder);
        return;
    }
    printf("Deleting message(s).\n");
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    FOLDER_H->delete_it(owner->query_name(), fname, deleted);
    deleted = ({ });
    save_me();
    if (last) {
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
    return;
}
varargs protected void rm_message(string input, int flag) {
    int i, tmp;
    int *range;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number,
            deleted) == -1) {
            newish -= ({ range[i]-1 });
            deleted += ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "D";
            printf("Marked message %d as deleted.\n", range[i]);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
}
protected void unrm_message(string input) {
    int i, tmp;
    int *range;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number,
            deleted) > -1) {
            deleted -= ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "U";
            printf("Undeleted message %d.\n", range[i]);
        }
    }
    prompt();
    input_to("read_loop");
}
protected void forward_message(string input) {
    int number, i;
    string *str, *full, nn;
    mixed *addrs;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (sscanf(input, "%d %s", number, to) != 2) {
        printf("Wrong syntax (ranges are not supported with forward).\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (number > sizeof(folder) || !number) {
        printf("Oh dear. No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(to);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (sizeof(full)) {
        to = implode(full, ",");
    } else {
        prompt();
        input_to("read_loop");
        return;
    }
    cc = 0;
    printf("Edit outgoing message? (y/[n]) ");
    input_to("edit_it", 0, number);
}
protected void edit_it(string input, int number) {
    subject = folder[number-1]->subject + " (fwd)";
    if (!input || input == "")
        printf( "No.\n" );
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (!strlen(input) || (lower_case(input) == "n"))
        input_to("get_subject", 0, number);
    else if (lower_case(input) == "y")
        input_to("get_subject", 0, number, 1);
    return;
}
varargs protected void move_message(string input, int flag) {
    int *range, i, bing;
    string to_folder, number;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (!sscanf(input, "%s %s", number, to_folder)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == current) {
        printf("Destination folder is the same as source folder: not moved.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == "=")
        to_folder = "inbox";
    range = expand_range(number);
    bing = sizeof(range);
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    for (i = 0; i < bing; i++) {
        int status;
        if (member_array(to_folder, folder_names) == -1) {
            if (FOLDER_H->can_create_folder(owner->query_name(), to_folder)) {
                folder_names += ({ to_folder });
            } else {
                printf("Cannot create a folder called %s, please choose "
                    "another another name.\n", to_folder);
                break;
            }
        }
        deleted += ({ folder[range[i]-1]->number });
        status = FOLDER_H->move_it(owner->query_name(), current, to_folder,
          folder[range[i]-1]->number);
        folder[range[i]-1]->status = "D";
        switch(status) {
        case 2:
          printf("Folder full!\n");
        case 1:
          printf("Marked message %d as deleted.\n", range[i]);
          break;
        case 0:
          if(!flag)
            printf("Saved message %d to folder %s.\n", range[i], to_folder);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
}
private void save_message(string input) {
    int *range, i, bing, ret;
    string to_file, number, body, err;
    if (!wizardp(owner)) {
        printf("Sorry, only creators can save mail to files.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (!input || input == "") {
        if (last_read != -1)
            input = sprintf("%d ~/mbox",(last_read+1));
        else {
            printf("No messages in folder or all messages still unread.\n");
            prompt();
            input_to("read_loop");
            return;
        }
    }
    if (!sscanf(input, "%s %s", number, to_file)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    seteuid(geteuid(owner));
    to_file = (string)owner->get_path(to_file);
    if (!master()->valid_write(to_file, owner, "write_file")) {
        printf("You cannot write to that file.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if ((i=file_size(to_file)) > 0)
        printf("Appending to existing file.\n");
    else if (i == -2) {
        printf("That is a directory.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(number);
    bing = sizeof(range);
    i = 0;
    for (i = 0; i < bing; i++) {
        body = FOLDER_H->load_message(owner->query_name(), current,
          folder[range[i]-1]->number);
        if (!body) {
            continue;
        }
        err = catch(ret = write_file(to_file, body + "\n\n"));
        if (err) {
            printf("Writing to file failed: %s\n", err);
        } else if (!ret) {
            printf("Writing to file failed.\n");
        } else {
            printf("Saved message %d to %s.\n", range[i], to_file);
        }
    }
    seteuid("Mailer");
    prompt();
    input_to("read_loop");
}
private void print_message(int number) {
    string body;
    if (number > sizeof(folder)-1 || number < 0) {
        printf("No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (folder[number]->status == "N") {
        newish -= ({ number });
        folder[number]->status = " ";
    }
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (!body) {
        rm_message(""+(number+1));
        return;
    }
    owner->set_finish_func("finish_print");
    printf("\n\nMessage %d\n", (number + 1));
    owner->more_string((full_header?body:strip_header(body)),
      "Message "+(number+1));
}
void finish_print() {
    printf("\n");
    prompt();
    input_to("read_loop");
}
private void save_me() {
    if (!PLAYER_HANDLER->test_user(owner->query_name())) {
        return;
    }
    if (current != "inbox") {
        if (FOLDER_H->check_empty(owner->query_name(), current)) {
            folder_names -= ({ current });
        }
    }
    unguarded((: save_object, folder_filename(owner->query_name()) :));
}
private int load_me() {
#ifdef CONVERTER
    if ("/obj/handlers/converter"->query_busy(owner->query_name())) {
        printf( "You cannot use the mailer now, your mail is being converted.\n" );
        return 0;
    }
#endif
    unguarded((: restore_object, folder_filename(owner->query_name()) :));
    if (!folder_names) {
        folder_names = ({ "inbox" });
    }
    return 1;
}
string *query_folders(string pname) {
    unguarded((: restore_object, folder_filename(pname) :));
    if (!folder_names)
        return ({});
    return folder_names;
}
private void read_messages(string fname) {
    folder = FOLDER_H->get_messages(owner->query_name(), fname);
}
void dest_me() {
    MAIL_TRACK->delete_mailer(this_object());
    destruct(this_object());
}
string format_date(int x) {
    string str;
    string mon;
    mixed *tm;
    if (x<0 || !intp(x))
        return "Bad time";
    tm = localtime(x);
    str = DAYS[tm[LT_WDAY]];
    mon = MONTHS[tm[LT_MON]];
    str = sprintf("%s, %d %s %d %02d:%02d %s", str, tm[LT_MDAY], mon,
      tm[LT_YEAR], tm[LT_HOUR], tm[LT_MIN], tm[LT_ZONE]);
    return str;
}
private int *expand_range(string str) {
    int *ms, i, start, end;
    if (!str)
        str = "";
    if (!sizeof(folder))
        return ({ });
    str = replace_string(str, " ", "");
    ms = ({ });
    if (sscanf(str, "%*sall%*s")==2) {
        int size = sizeof(folder) + 1;
        for (i = 1; i < size; i++) {
            ms += ({ i });
        }
        return ms;
    }
    while (sscanf(str, "%d%s", start, str) == 2) {
        if (start < 1)
            start = 1;
        if (start > sizeof(folder))
            start = sizeof(folder);
        if (str && str != "" && (str[0] == '-' || ((strlen(str) > 1) &&
              str[0..1] == ".."))) {
            sscanf(str, "%*(-|(..))%d%s", end, str);
            if (end >= start) {
                if (end > sizeof(folder))
                    end = sizeof(folder);
                for (i = start; i <= end; i++)
                    if (member_array(i, ms) == -1)
                        ms += ({ i });
            }
        } else
        if (member_array(start, ms) == -1)
            ms += ({ start });
        sscanf(str, ",%s", str);
    }
    return ms;
}
# Total Tokens: 21117
# Total Files Merged: 4
# Total Characters: 70400

