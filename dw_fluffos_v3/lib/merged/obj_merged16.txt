# Total Tokens: 22008
# Total Files Merged: 5
# Total Characters: 73375

off.c
==================================================

#include <nroff.h>
mixed *nroffed_file;
string nroffed_file_name;
int modified_time;
nosave int new_string;
nosave int force_string;
void create() {
  nroffed_file = ({ });
  seteuid("Root");
}
#define do_bounds(bing) (bing<0?bing+cols:bing)
string cat_file(string fname, int update) {
   int i;
   int k;
   int cols;
   string ret;
   string pat;
   mixed* tmp;
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname))
      return 0;
   if (!nroffed_file_name && update)
      return 0;
   if (update) {
      mixed *something;
      if (!master()->valid_read(nroffed_file_name,
                                geteuid(previous_object()),
                                "restore_object"))
         return 0;
      if (file_size(nroffed_file_name) <= 0)
         return 0;
      something = stat(nroffed_file_name);
      if (something[1] > modified_time)
         return 0;
   }
   ret = "";
   if (this_player()) {
      cols = (int)this_player()->query_cols();
   } else {
      cols = 79;
   }
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += nroffed_file[i];
      } else {
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += sprintf("%%^BOLD%%^%s%%^RESET%%^\n", nroffed_file[i+1]);
            i++;
            break;
          case V_CENTER :
            ret += sprintf("%|=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_ALL :
            ret += "%^BOLD%^\n" + sprintf("%-s%*|s%*s\n",
                           nroffed_file[i+2],
                           cols - nroffed_file[i+1]*2,
                           nroffed_file[i+3],
                           nroffed_file[i+1],
                           nroffed_file[i+4]) + "%^RESET%^\n";
            i += 4;
            break;
          case V_INDENT :
            ret += sprintf( "%*=s%-=*s", nroffed_file[ i + 1 ], "",
                           cols - nroffed_file[ i + 1 ], nroffed_file[ i + 2 ] );
            i += 2;
            break;
          case V_PARA :
            if (nroffed_file[i+1])
            ret += sprintf("%*=s%-=*s%=*s\n", nroffed_file[i+1], "",
                           cols-nroffed_file[i+1]-
                           nroffed_file[i+2], nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else if (nroffed_file[i+2])
            ret += sprintf("%-=*s%=*s\n", cols-nroffed_file[i+2],
                           nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else
            ret += sprintf("%-=*s\n", cols, nroffed_file[i+3]);
            i += 3;
            break;
          case V_LEFT :
            ret += sprintf("%-=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_TABLE :
            ret += sprintf("%-#*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_COLUMN : {
             int j;
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s\n", do_bounds(nroffed_file[i+1][0]),
                                  nroffed_file[i+2][j],
                                  do_bounds(nroffed_file[i+1][1]),
                                  nroffed_file[i+3][j]);
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s%*-=s\n",
                               do_bounds(nroffed_file[i+1][0]),
                               nroffed_file[i+2][j],
                               do_bounds(nroffed_file[i+1][1]),
                               nroffed_file[i+3][j],
                               do_bounds(nroffed_file[i+1][2]),
                               nroffed_file[i+4][j]);
                }
                i += 4;
                break;
             default :
                pat = implode(allocate(sizeof(nroffed_file[i+1]), "%*-=s"), "");
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   tmp = ({ });
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      tmp += ({ do_bounds(nroffed_file[i+1][k]),
                                nroffed_file[i+2+k][j] });
                   }
                   ret += sprintf(pat + "\n", tmp ... );
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             break;
          }
         }
      }
   }
   return " \n"+ret;
}
private string htmlify(string  str) {
  return replace(str, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;"}));
}
string html_file(string file, string title) {
   int i, j, cols, in_bold, in_italic;
   int k;
   string ret, *bits;
   if (!master()->valid_read(file, geteuid(previous_object()),
                             "restore_object"))
      return 0;
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(file))
      return 0;
   ret = "";
   cols = 78;
   for (i=0;i<sizeof(nroffed_file);i++)
     if (stringp(nroffed_file[i]))
       nroffed_file[i] = htmlify(nroffed_file[i]);
     else if(arrayp(nroffed_file[i])) {
       for (j=0;j<sizeof(nroffed_file[i]);j++)
         if(stringp(nroffed_file[i][j]))
           nroffed_file[i][j] = htmlify(nroffed_file[i][j]);
     }
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += "<h3>"+nroffed_file[i]+"</h3>";
#ifdef UNUSED
         if(strsrch(nroffed_file[i], "See also") > -1) {
           for(j=i+1; j < sizeof(nroffed_file); j++) {
             if(stringp(nroffed_file[j])) {
               nroffed_file[j] = make_links(nroffed_file[j]);
             }
           }
         }
#endif
      } else {
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += "<h3>"+replace_string(nroffed_file[i+1], "\n", "<br>")+
              "</h3>";
            i++;
            break;
          case V_CENTER :
            ret += "<center>"+replace(nroffed_file[i+1], "\n", "<br>")+
            "</center>";
            i++;
            break;
          case V_ALL :
            ret += "\n<table width=100%><tr>\n" +
                   "<td nowrap width=* align=left><h2>" +
                   nroffed_file[i+2] + "</h2></td>\n" +
                   "<td nowrap align=center><h2>" +
                   nroffed_file[i+3] + "</h2></td>\n" +
                   "<td nowrap width=* align=right><h2>" +
                   nroffed_file[i+4] + "</h2></td>\n" +
                   "</tr></table>\n";
            i += 4;
            break;
          case V_INDENT :
            ret += replace(nroffed_file[i+2], ({"<", "&lt;", ">",
               "&gt;", "\n", "<br>"}));
            i += 2;
            break;
          case V_PARA :
            ret += replace(nroffed_file[i+3], "\n", "<p>");
            i += 3;
            break;
          case V_LEFT :
            ret += "<left>"+nroffed_file[i+1]+"</left>";
            i++;
            break;
          case V_TABLE :
            ret += "<ul><li>"+replace(nroffed_file[i+1], "\n", "<li>")+"</ul>";
            i++;
            break;
          case V_COLUMN : {
             ret += "<table cellpadding=10>";
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+3][j] + "</td>";
                  ret += "</tr>";
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td nowrap>"+nroffed_file[i+3][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+4][j] + "</td>";
                  ret += "</tr>";
                }
                i += 4;
                break;
             default :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += "<tr>\n";
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      ret += "<td nowrap>" + nroffed_file[i+2+k][j] + "</td>\n";
                   }
                   ret += "</tr>\n";
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             ret += "</table>";
             break;
          }
         }
      }
   }
   bits = explode(ret, "%^");
   ret = "";
   for (i=0;i<sizeof(bits);i+=2) {
      ret += bits[i];
    if (i+1 < sizeof(bits)) {
       switch (bits[i+1]) {
        case "BOLD" :
          if (!in_bold)
             ret += "<strong>";
          else
             ret += "</strong>";
          in_bold = !in_bold;
          break;
        case "RESET" :
          if (in_bold)
             ret += "</strong>";
          if (in_italic)
             ret += "</i>";
          in_bold = 0;
          in_italic = 0;
          break;
        default :
          if (!in_italic)
             ret += "<i>";
          else
             ret += "</i>";
          in_italic = !in_italic;
          break;
       }
    }
   }
   return ret;
}
private void add_array(mixed *i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
}
private void add_int(int i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
}
private void add_string(string s) {
  if (!sizeof(nroffed_file) || new_string) {
    nroffed_file += ({ s });
  } else if (stringp(nroffed_file[<1])) {
    nroffed_file[<1] += s;
  } else {
    nroffed_file += ({ s });
  }
  new_string = 0;
  force_string = 0;
}
int create_nroff(string in_file, string out_file) {
  string text,
         tmp,
         *bits;
  string *bing;
  mixed  *cols;
  int strip_crs,
      col_mode,
      conv_tabs,
      i, j, k, fluff,
      num_cols;
  if (!master()->valid_read(in_file, geteuid(previous_object()),
                            "read_file"))
    return 0;
  nroffed_file_name = in_file;
  modified_time = time();
  text = read_file(in_file);
  if (!text) {
    return 0;
  }
  bits = explode("#\n"+text, "\n.");
  bits[0] = bits[0][1..];
  nroffed_file = ({ 0 });
  if (strlen(bits[0])) {
    add_string(bits[0]);
  }
  for (i=1;i<sizeof(bits);i++) {
     if (sscanf(bits[i], "%s\n%s", tmp, bits[i]) != 2) {
        tmp = bits[i];
        bits[i] = "";
        fluff = 1;
     } else {
        fluff = 0;
     }
     switch (tmp[0..1]) {
      case "SH" :
        add_int(V_HEADER);
        add_string(tmp[3..]);
        new_string = 1;
        break;
      case "SI" :
        add_int(V_INDENT);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        force_string = 1;
        break;
      case "EI" :
        add_string("");
        new_string = 1;
        break;
      case "SP" :
        add_int(V_PARA);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        j = 0;
        sscanf(tmp, " %d%s", j, tmp);
        add_int(j);
        force_string = 1;
        strip_crs = 1;
        break;
      case "EP" :
        add_string("");
        new_string = 1;
        strip_crs = 0;
        break;
      case "SC" :
        add_int(V_CENTER);
        force_string = 1;
        break;
      case "EC" :
        new_string = 1;
        break;
      case "SL" :
        add_int(V_LEFT);
        force_string = 1;
        break;
      case "EL " :
        new_string = 1;
        break;
      case "ST" :
        add_int(V_TABLE);
        force_string = 1;
        conv_tabs = 1;
        break;
      case "ET" :
        new_string = 1;
        conv_tabs = 0;
        break;
      case "DT" :
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 3) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .DT directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0;
        }
        add_int(V_ALL);
        if (strlen(bing[0]) > strlen(bing[2]))
           add_int(strlen(bing[0]));
        else
           add_int(strlen(bing[2]));
        new_string = 1;
        add_string(bing[0]);
        new_string = 1;
        add_string(bing[1]);
        new_string = 1;
        add_string(bing[2]);
        new_string = 1;
        bits[i] = implode(bing[3..], "\n");
        break;
      case "SO" :
        num_cols = 0;
        tmp = tmp[2..];
        cols = ({ });
        while (sscanf(tmp, "%d%s", j, tmp) == 2) {
           cols += ({ j });
           num_cols++;
           while (strlen(tmp) && tmp[0] == ' ')
           tmp = tmp[1..];
        }
        add_int(V_COLUMN);
        if (sscanf(tmp, "%d", j) == 1) {
           cols += ({ j });
           num_cols++;
        }
        add_array(cols);
        cols = allocate(num_cols);
        for (j=0;j<num_cols;j++) {
           cols[j] = ({ });
        }
        col_mode = 1;
        break;
      case "EO" :
        for (j=0;j<num_cols;j++) {
           add_array(cols[j]);
        }
        col_mode = 0;
        break;
      case "NF" :
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 1) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .NF directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0;
        }
        text = read_file(bing[ 0 ]);
        if (!text) {
          return 0;
        }
        bits = explode("#\n"+text, "\n.");
        bits[0] = bits[0][1..];
        nroffed_file = ({ 0 });
        if (strlen(bits[0])) {
           add_string(bits[0]);
        }
        strip_crs = col_mode = conv_tabs = fluff = num_cols = i = 0;
        break;
     }
     if (fluff) {
        continue;
     }
     if (conv_tabs) {
        bits[i] = replace(bits[i], "\t", "\n");
     }
     if (col_mode) {
        string *frog;
        frog = explode(bits[i], "\n");
        for (k = 0; k < sizeof(frog); k++) {
           bing = explode("#"+frog[k], "\t");
           bing[0] = bing[0][1..];
           for (j = 0; j < num_cols && j < sizeof(bing); j++) {
              cols[j] += ({ bing[j] });
           }
           for (j = sizeof(bing);j < num_cols; j++) {
              cols[j] += ({ "\n" });
           }
        }
     } else if (strip_crs) {
        bits[i] = replace_string(bits[i], "\n\n", "$%^NeW_LiNe^%$");
        bits[i] = replace_string(bits[i], ".\n", ".  ");
        bits[i] = replace_string(bits[i], "\n", " ");
        bits[i] = replace_string(bits[i], "$%^NeW_LiNe^%$", "\n\n");
        add_string(bits[i]+" ");
     } else {
        add_string(bits[i]+"\n");
     }
  }
  new_string = 0;
  force_string = 0;
  unguarded((: save_object, out_file :));
  return 1;
}
string query_file_name( string fname ) {
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname)) {
      return 0;
   }
   return nroffed_file_name;
}

==================================================
FILE: handlers/options_handler.c
==================================================

#include <cmds/options.h>
#include <cmds/teach.h>
#include <colour.h>
#include <clubs.h>
#include <ls.h>
#include <obj_parser.h>
#include <player.h>
#include <creator.h>
#include <terrain_map.h>
#include <error_handler.h>
class option {
   mixed type;
   int restriction;
   function set;
   function query;
   mapping suboptions;
   string help;
}
private mapping _options;
private string* _colours;
private mapping _cache_input;
protected int add_option(string path, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help);
private int set_player_brief(object player, string variable, int value);
private int query_player_brief(object player, string variable);
private mapping get_inform_colours(object player);
private mapping get_club_colours(object player);
private int change_bool_property(string prop, object player, int new_value);
private int change_earmuffs(object player, string ear, int new_value);
private int setup_earmuffs(object player, string value);
private int valid_birthday(string str);
private string convert_birthday(string birthday);
private int change_error_reports(object player, string ear, int new_value);
void create() {
   string womble;
   _options = ([ ]);
   _cache_input = ([ ]);
   _colours = ({
    "BOLD",
    "FLASH",
    "BLACK",
    "RED",
    "BLUE",
    "CYAN",
    "MAGENTA",
    "ORANGE",
    "YELLOW",
    "GREEN",
    "WHITE",
    "B_RED",
    "B_ORANGE",
    "B_YELLOW",
    "B_BLACK",
    "B_CYAN",
    "B_WHITE",
    "B_GREEN",
    "B_MAGENTA" });
   add_option("output look", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display room descriptions briefly or in full");
   add_option("output combat", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display all combat messages or only those involving damage");
   add_option("output errors", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display errors in the error handler briefly");
   add_option("output score", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Amount of detail to be displayed by the 'score' command");
   add_option("output accent", ({ "mangle", "unadulterated" }),
              OPTIONS_TYPE_ALL,
              (: $1->set_mangle_accent($3 == "mangle"), 1 :),
              (: $1->query_mangle_accent() ? "mangle" : "unadulterated" :),
              "Show others speech with or without regional accents");
   add_option("output names", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display player names with or without title and surname");
   add_option("output htell", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Cause the 'htell' command to display times for tells or not");
   add_option("output msgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgout($3) :),
              (: $1->query_msgout() :),
              "The message that is displayed when you walk out of a room");
   add_option("output msgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgin($3) :),
              (: $1->query_msgin() :),
              "The message that is displayed when you walk into a room");
   add_option("output mmsgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgout($3) :),
              (: $1->query_mmsgout() :),
              "The message that is displayed when you trans out of a room");
   add_option("output mmsgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgin($3) :),
              (: $1->query_mmsgin() :),
              "The message that is displayed when you trans into of a room");
   add_option("output usercolour",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_ALLOW_COLOURED_SOULS, 1):
                    $1->remove_property(PLAYER_ALLOW_COLOURED_SOULS), 1 :),
              (: $1->query_property(PLAYER_ALLOW_COLOURED_SOULS) :),
              "Display user chosen colours in souls");
   add_option("output plainmaps",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_PLAIN_MAPS, 1):
                    $1->remove_property(PLAYER_PLAIN_MAPS), 1 :),
              (: $1->query_property(PLAYER_PLAIN_MAPS) :),
              "Display terrain maps without colour");
   add_option("output lookmap", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3?$1->add_property(TERRAIN_MAP_IN_LOOK_PROP, 1):
                    $1->remove_property(TERRAIN_MAP_IN_LOOK_PROP), 1 :),
              (: $1->query_property(TERRAIN_MAP_IN_LOOK_PROP) :),
              "Display room a map in the terrain long or not");
   add_option( "output tabstops", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_CRE_ONLY,
              (: $1->add_property( TABSTOP_PROP, $3 ) :),
              (: $1->query_property( TABSTOP_PROP ) :),
               "Show tabstops as <TAB> or as spaces");
   add_option( "output shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_OUTPUT_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_OUTPUT_PROP ) :),
               "Convert others shorthand text into long form");
   foreach (womble in USER_COLOUR_LIST) {
      add_option("colour " + womble, OPTIONS_TYPE_COLOUR, 0,
                 (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                 "The colour for " + womble + " messages");
   }
   foreach (womble in ADDITIONAL_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   foreach (womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   add_option("colour inform", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_inform_colours :),
              "The colours of various informational messages");
   add_option("colour club", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_club_colours :),
              "The colour for club messages");
   add_option("terminal type", OPTIONS_TYPE_TERMINAL, 0,
              (: $1->set_term_type($3), 1 :),
              (: $1->query_term_name() :),
              "The type of terminal you are using");
   add_option("terminal rows", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_rows($3), 1 :),
              (: $1->query_rows() :),
              "The number of rows in your terminal");
   add_option("terminal cols", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_cols($3), 1 :),
              (: $1->query_cols() :),
              "The number of coloumns in your terminal");
    add_option("combat wimpy", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_wimpy($3) :),
              (: $1->query_wimpy() :),
               "The percentage of your hitpoints at which you will run away");
   add_option("combat monitor", MONITOR_OPTIONS, 0,
              (: $1->set_monitor(member_array($3, MONITOR_OPTIONS)), 1 :),
              (: MONITOR_OPTIONS[$1->query_monitor()] :),
              "The frequency of display of your combat monitor");
   add_option("combat tactics attitude",
              ({ "insane", "offensive", "neutral", "defensive", "wimp" }), 0,
              (: $1->set_combat_attitude($3), 1 :),
              (: $1->query_combat_attitude() :),
              "Your combat attitude (see help tactics)");
   add_option("combat tactics response",
              ({ "dodge", "neutral", "parry" }), 0,
              (: $1->set_combat_response($3), 1 :),
              (: $1->query_combat_response() :),
              "Your combat response (see help tactics)");
   add_option("combat tactics parry",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_parry($3), 1 :),
              (: $1->query_combat_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics unarmed_parry",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $1->set_unarmed_parry($3), 1 :),
              (: $1->query_unarmed_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics attack",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_attack($3), 1 :),
              (: $1->query_combat_attack() :),
              "Which hand you will attack with (see help tactics)");
#ifdef USE_SURRENDER
   add_option("combat tactics mercy",
              ({ "always", "ask", "never" }), 0,
              (: $1->set_combat_mercy($3), 1 :),
              (: $1->query_combat_mercy() :),
              "Whether or not you will show mercy to opponents");
#endif
   add_option("combat tactics focus",
              ({"upper body", "lower body", "head", "neck", "chest",
                  "abdomen", "arms", "hands", "legs", "feet", "none"}), 0,
              (: $1->set_combat_focus($3), 1 :),
              (: $1->query_combat_focus() :),
              "Which body part you will focus on in combat (see help tactics)");
#ifdef USE_DISTANCE
   add_option("combat tactics distance",
              ({"long", "medium", "close", "hand-to-hand", "none" }), 0,
              (: $1->set_combat_distance($3), 1 :),
              (: $1->query_combat_distance() :),
              "Your ideal combat distance (see help tactics)");
#endif
   add_option("combat killer",
              OPTIONS_TYPE_BOOLEAN, 1,
              (: $1->set_player_killer($3) :),
              (: $1->query_player_killer() :),
              "Whether or not you are a registered player killer");
   add_option("input ambiguous", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_AMBIGUOUS_PROP, $1, !$3) :),
              (: !$1->query_property(OBJ_PARSER_AMBIGUOUS_PROP) :),
              "Should the parser notify you of ambiguities");
   add_option("input andascomma", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP, $1, !$3) :),
          (: !$1->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP) :),
              "Should 'and' be treated as a comma (an inclusive list)");
   add_option("input editor", ({ "menu", "magic", "command", "ed" }), 0,
              (: $1->set_editor($3) :),
              (: $1->query_editor() :),
              "Your preferred editor");
   add_option( "input shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_PROP ) :),
               "Convert your shorthand typing into long form");
   foreach (womble in ({ "shout", "newbie", "cryer", "remote-soul",
                           "multiple-soul", "multiple-tell",  "teach",
                           "tell", "remote", "multiple-remote" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, 0,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ADDITIONAL_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ({ "lord", "intermud-all", "intercre",
                          "intergossip", "dwcre", "dwchat", "remote-spam" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   add_option("earmuff state",
              ({ "on", "off", "allowfriends" }), 0,
              (: setup_earmuffs($1, $3) :),
              (: $1->query_earmuffs()? ($1->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF ? "allowfriends" : "on") : "off" :),
              "Enable or disable earmuffs always or just for friends");
   add_option("earmuff cut-through", ({ "off", "ask", "auto"}), 1,
              (: $1->add_property("cut earmuffed tells",
                    member_array($3, ({ "off", "ask", "auto"}))) :),
              (: ({ "off", "ask", "auto" })[$1->query_property(
                                             "cut earmuffed tells")] :),
              "Cut through a players tell earmuffs");
   add_option("command ls use_nickname", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
              (: $3 ? change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 1 ) : change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 0 ) :),
              (: $1->query_property( LS_COMMAND_NICKNAME_PROPERTY ) :),
              "Should 'ls' check for nicknames");
   foreach(womble in ERROR_TYPE) {
      womble = lower_case(womble);
      add_option("command look error " + womble, OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_CRE_ONLY,
              (: change_error_reports($1, $2[<1], $3) :),
              (: member_array(upper_case($2[<1]), ($1->query_property(PLAYER_SHOW_ERRORS_PROP)?$1->query_property(PLAYER_SHOW_ERRORS_PROP):({}))) != -1 :),
              "Show the errors of type " + lower_case(womble) +
              " when doing a look.");
   }
   add_option("personal description", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_desc($3 == "none"?0:$3), 1) :),
              (: (($1->query_desc())?($1->query_desc()):"none") :),
              "Ain't you perdy");
   add_option("personal real_name", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_real_name($3 == "none"?0:$3), 1) :),
              (: (($1->query_real_name())?($1->query_real_name()):"none") :),
              "The real name displayed in your finger information");
   add_option("personal location", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_where($3 == "none"?0:$3), 1) :),
              (: (($1->query_where())?($1->query_where()):"none") :),
              "The location displayed in your finger information");
   add_option("personal home_page", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_homepage($3 == "none"?0:$3), 1) :),
              (: (($1->query_homepage())?($1->query_homepage()):"none") :),
              "The url displayed in your finger information");
   add_option("personal email", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_email($3 == "none"?0:$3), 1) :),
              (: (($1->query_email())?($1->query_email()):"none") :),
              "The email address displayed in your finger information");
   add_option("personal birthday", OPTIONS_TYPE_STRING, 0,
              (: (!valid_birthday($3) || $1->query_birthday())? 0:($1->set_birthday($3 == "none"?0:convert_birthday($3)), 1) :),
              (: (($1->query_birthday())?($1->query_birthday()):"none") :),
              "Your birthday");
   add_option("personal execinclude", OPTIONS_TYPE_STRING, 0,
              (: ($3=="none"?$1->remove_property(OPTION_EXEC_INCLUDE):$1->add_property(OPTION_EXEC_INCLUDE, $3)), 1 :),
              (: ($1->query_property(OPTION_EXEC_INCLUDE)?$1->query_property(OPTION_EXEC_INCLUDE):"none") :),
              "The path of files to be included in exec commands?");
   add_option("personal auto teach", OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(TEACH_COMMAND_AUTO_PROPERTY,$3):$1->remove_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              (: $1->query_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              "Are you available to auto-teach");
   add_option("personal travel",
              ({ "walk", "journey" }), 0,
              (: $3 == "walk" ?$1->remove_property(TERRAIN_MAP_LONG_JUMP_PROPERTY):$1->add_property(TERRAIN_MAP_LONG_JUMP_PROPERTY,1), 1 :),
              (: $1->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)?"journey":"walk" :),
              "By default should you walk or journey across terrains");
   add_option("playtester protection", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3 ? $1->enable_personal_pt_protection() : $1->disable_personal_pt_protection() :),
              (: $1->query_pt_protection() :),
              "Enable or disable playtester protection");
   add_option("personal roleplaying", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $1->set_role_playing($3), 1 :),
              (: $1->query_role_playing() :),
              "Enable or disable roleplaying mode");
}
protected void add_option_to_mapping(mapping array, string name, mixed type,
                                     int cre_only, function set_function,
                                     function query_function, string help) {
   class option fluff;
   fluff = new(class option);
   fluff->type = type;
   fluff->set = set_function;
   fluff->query = query_function;
   fluff->restriction = cre_only;
   fluff->suboptions = ([ ]);
   fluff->help = help;
   array[name] = fluff;
}
protected int add_option(string name, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help) {
   string option;
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = _options;
   foreach (option in path[0..<2]) {
      if (!stuff[option]) {
         add_option_to_mapping(stuff, option, OPTIONS_TYPE_GROUP, cre_only,
                               0, 0, help);
      } else if (((class option)stuff[option])->type != OPTIONS_TYPE_GROUP) {
         return 0;
      }
      stuff = stuff[option]->suboptions;
   }
   add_option_to_mapping(stuff, path[<1], type, cre_only, set_function,
                         query_function, help);
   return 1;
}
private mixed query_sub_option(object player, string name, mapping tree) {
   mixed tmp;
   if (mapp(tree[name])) {
      return tree[name];
   }
   if (classp(tree[name])) {
      switch (tree[name]->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_DYNAMIC_GROUP) {
         tmp = evaluate(tree[name]->query, player, name);
         return tmp;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_GROUP) {
         return tree[name]->suboptions;
      }
      return tree[name];
   }
   return 0;
}
private mixed query_bottom_sub_option(object player, string* path) {
   string option;
   mixed stuff;
   if (!sizeof(path)) {
      return _options;
   }
   stuff = _options;
   foreach (option in path[0..<2]) {
      stuff = query_sub_option(player, option, stuff);
      if (!mapp(stuff)) {
         return 0;
      }
   }
   stuff = query_sub_option(player, path[<1], stuff);
   if (classp(stuff)) {
      switch (stuff->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
   }
   return stuff;
}
int is_option(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!classp(stuff)) {
      return 0;
   }
   return 1;
}
int is_option_group(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!mapp(stuff)) {
      return 0;
   }
   return 1;
}
string *query_sub_options(object player, string name) {
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (mapp(stuff)) {
      return filter(keys(stuff),
                    (: query_bottom_sub_option($2, $3 + ({ $1 })) :),
                    player, path);
   }
   return ({ });
}
string* query_option_values(object player, string name) {
   mixed stuff;
   class option opt;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (classp(stuff)) {
      opt = stuff;
      if (intp(opt->type)) {
         switch (opt->type) {
         case OPTIONS_TYPE_BOOLEAN :
            return ({ "on", "off" });
         case OPTIONS_TYPE_BRIEF :
            return ({ "brief", "verbose" });
         case OPTIONS_TYPE_INTEGER :
            return ({ "integer" });
         case OPTIONS_TYPE_STRING :
            return ({ "string" });
         case OPTIONS_TYPE_PERCENTAGE :
            return ({ "0..100" });
         case OPTIONS_TYPE_COLOUR :
            return ({ "none", "default", "colour" });
         }
      } else {
         return opt->type;
      }
   }
   return ({ });
}
string query_option_value(object player, string path) {
   string* bits;
   mixed value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      value = evaluate(stuff->query, player, bits);
      if (intp(stuff->type)) {
         switch (stuff->type) {
         case OPTIONS_TYPE_BRIEF:
            if (value) {
               value = "verbose";
            } else {
               value = "brief";
            }
            break;
         case OPTIONS_TYPE_BOOLEAN :
            if (value) {
               value = "on";
            } else {
               value = "off";
            }
            break;
         case OPTIONS_TYPE_COLOUR :
            if (value == "") {
               value = "[none]";
            } else if (value == "default") {
               value = "[default]";
            } else {
               value = "[" + value + "" +
                       lower_case(replace(value, ({ "%^%^", " ", "%^", "" }))) +
                       "%^RESET%^]";
            }
            break;
         default :
         }
      }
      return value + "";
   }
}
string query_option_help(object player, string path) {
  string *bits;
  mixed stuff;
  bits = explode(path, " ");
  stuff = query_bottom_sub_option(player, bits);
  if (classp(stuff)) {
    return copy(stuff->help);
  }
  return "";
}
int set_option_value(object player, string path, string value) {
   string* bits;
   string* bad;
   mixed set_value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      if (pointerp(stuff->type)) {
         if (member_array(value, stuff->type) == -1) {
            add_failed_mess("You must set your type to one of " +
                            query_multiple_short(stuff->type) + ".\n");
            return 0;
         }
         set_value = value;
      } else switch (stuff->type) {
      case OPTIONS_TYPE_BRIEF:
         if (value == "verbose") {
            set_value = 1;
         } else if (value == "brief") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_BOOLEAN :
         if (value == "on" || value == "true") {
            set_value = 1;
         } else if (value == "off" || value == "false") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PERCENTAGE :
      case OPTIONS_TYPE_INTEGER :
         if (sscanf(value, "%d", set_value) != 1) {
            return 0;
         }
         if (stuff->type == OPTIONS_TYPE_PERCENTAGE &&
             (set_value < 0 || set_value > 100)) {
            add_failed_mess("Value must be between 0 and 100.\n");
            return 0;
         }
         break;
      case OPTIONS_TYPE_COLOUR :
         if (value == "none" || value == "default") {
            set_value = value;
         } else {
            set_value = map(explode(value, " "),
                         (: upper_case($1) :));
            bad = filter(set_value, (: member_array($1, _colours) == -1 :));
            if (sizeof(bad)) {
               add_failed_mess("Bad colours " + implode(bad, " ") + ".\n");
               return 0;
            }
            set_value = "%^" + implode(set_value, (: $1 + "%^ %^" + $2 :)) + "%^";
         }
         break;
      default :
         set_value = value;
         break;
      }
      return evaluate(stuff->set, player, bits, set_value);
   }
   return 0;
}
private mapping get_inform_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   if (player->query_creator()) {
      index = "colour 1";
   } else if (player->query_lord()) {
      index = "colour 2";
   } else {
      index = "colour 0";
   }
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = player->query_inform_types();
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours($2[<1], $3), 1 :),
                            (: $1->colour_event($2[<1], "default") :),
                            "The colour of " + womble + " informs");
   }
   _cache_input[index] = ret;
   return ret;
}
private mapping get_club_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   index = "colour " + player->query_name();
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = map(this_player()->query_player_clubs(),
                 (: CLUB_HANDLER->normalise_name($1) :) );
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours("club_" + $2[<1], $3), 1 :),
                            (: $1->colour_event("club_" + $2[<1], "default") :),
                            "The colour for " + womble + " club messages");
   }
   _cache_input[index] = ret;
   call_out((: map_delete(_cache_input, $1) :), 5 * 60, index);
   return ret;
}
private int change_bool_property(string prop, object player, int new_value) {
   if (new_value) {
      player->add_property(prop, 1);
   } else {
      player->remove_property(prop);
   }
   return 1;
}
private int setup_earmuffs(object player, string ear) {
   switch (ear) {
   case "on" :
      if (!player->query_earmuffs()) {
         player->toggle_earmuffs();
      } else if (player->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         player->toggle_earmuffs();
         player->toggle_earmuffs();
      }
      break;
   case "off" :
      if (player->query_earmuffs()) {
         player->toggle_earmuffs();
      }
      break;
   case "allowfriends" :
      player->set_allow_friends_earmuffs();
      break;
   }
   return 1;
}
private int change_error_reports(object player, string error, int new_value) {
   string *on;
   on = player->query_property(PLAYER_SHOW_ERRORS_PROP);
   if (!on) {
      on = ({ });
   }
   error = upper_case(error);
   if (new_value) {
      if (member_array(error, on) == -1) {
         on += ({ error });
         player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
      }
   } else {
      on -= ({ error });
      player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
   }
   return 1;
}
private int change_earmuffs(object player, string ear, int new_value) {
   string *on;
   on = player->query_property("earmuffs");
   if (!on) {
      on = ({ });
   }
   if (new_value) {
      if (member_array(ear, on) == -1) {
         on += ({ ear });
         player->add_property("earmuffs", on);
      }
   } else {
      on -= ({ ear });
      player->add_property("earmuffs", on);
   }
   return 1;
}
private int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}

==================================================
FILE: handlers/parcel.c
==================================================

#define BASE_PATH "/save/parcels/"
#define SAVE_PATH BASE_PATH + location + "/" + name[0..0]
#define SAVE_FILE BASE_PATH + location + "/" + name[0..0] + "/" + name + ".o"
#define POST_LOG "PARCEL_LOG"
inherit "/global/auto_load";
#undef USE_COMPRESSION
#include <player_handler.h>
class parcel {
  string from;
  string *autoloadinfo;
  int exp_time;
}
mapping parcels;
private nosave string _current_name, _current_location;
nosave class parcel *_parcels;
int test_expire( class parcel temp );
void create() {
  string dir;
  seteuid( master()->creator_file( base_name( this_object() ) ) );
  parcels = ([ ]);
  if(parcels) {
    parcels = copy(parcels);
    parcels = ([ ]);
  }
  _parcels = ({ });
}
private void save_file(string name, string location) {
  string str;
  map_delete(parcels, name);
  if(sizeof(keys(parcels)))
    unguarded( (: save_object, SAVE_PATH, 2 :));
  if(file_size(SAVE_PATH) == -1)
    unguarded( (: mkdir, SAVE_PATH :) );
  if(_parcels != ({ })) {
    str = save_variable(_parcels);
#ifdef USE_COMPRESSION
    if(!ungarded( (: write_buffer, SAVE_FILE + ".gz", 0, compress(str) :) ))
#else
    if(!unguarded((: write_file, SAVE_FILE, str, 1 :) ))
#endif
      log_file(POST_LOG, "%s: error writing to %s\n",
               ctime(time()), SAVE_FILE);
  } else {
    if(file_size(SAVE_FILE) > 0)
      unguarded( (: rm, SAVE_FILE :));
    if(file_size(SAVE_FILE+".gz") > 0)
      unguarded( (: rm, SAVE_FILE + ".gz" :));
  }
}
private void load_file( string name, string location ) {
  if(_current_name == name && _current_location == location)
    return;
#ifdef USE_COMPRESSION
  if(file_size(SAVE_FILE + ".gz") > 0) {
    _parcels = restore_variable(uncompress(read_file(SAVE_FILE)));
  } else
#endif
  if(file_size(SAVE_FILE) > 0) {
    debug_printf("%s", SAVE_FILE);
    _parcels = restore_variable(unguarded( (: read_file, SAVE_FILE :) ));
  } else if (file_size(SAVE_PATH+ ".o.gz") > 0) {
    unguarded( (: restore_object, SAVE_PATH+".o.gz" :));
    _parcels = parcels[name];
  } else if(file_size(SAVE_PATH+".o") > 0) {
    unguarded( (: restore_object, SAVE_PATH :) );
    _parcels = parcels[name];
  } else {
    parcels = ([ ]);
    _parcels = ({ });
  }
  _current_name = name;
  _current_location = location;
}
public int deposit(string to, string from, string location, object *obs) {
  class parcel temp;
  object boxy;
  string obsstuff, tmp;
  obsstuff = "/global/events"->convert_message(query_multiple_short (obs));
  if(!PLAYER_HANDLER->test_user(to))
    return 0;
#ifndef __DISTRIBUTION_LIB__
    if("/secure/alist"->query_alt(from, to) == 100) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her alt " + capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(from, to) > 40) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her POSSIBLE alt "+ capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  load_file(to, location );
  if(undefinedp(_parcels) || !arrayp(_parcels))
    _parcels = ({ });
  boxy = clone_object("/obj/baggage");
  boxy->set_name("boxy");
  boxy->set_max_weight(100000);
  obs->move( boxy );
  temp = new( class parcel,
              from : from,
              exp_time: time() + ( 14 * 24 * 60 * 60));
  temp->autoloadinfo = create_auto_load( ({ boxy }), 0 );
  _parcels += ({ temp });
  save_file(to, location);
  boxy->dest_me();
  log_file (POST_LOG, "%s: %s deposited %s at %s for %s.\n", ctime(time()),
      from, obsstuff, location, to);
}
public int collect(string name, string location, object target, int copy) {
  class parcel temp;
  object *box_array = ({ });
  object *obs = ({ });
  string tmp;
  load_file(name, location );
  if(!_parcels || _parcels == ({ }))
    return 0;
  foreach(temp in _parcels) {
    box_array += load_auto_load_to_array(temp->autoloadinfo, this_player());
#ifndef __DISTRIBUTION_LIB__
    obs = all_inventory(box_array[<1]);
    if("/secure/alist"->query_alt(name, temp->from) == 100) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her alt " + capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(name, temp->from) > 40) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her POSSIBLE alt "+ capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  }
  foreach( object box in box_array ) {
    obs += all_inventory (box);
    all_inventory( box )->move( target );
    box->dest_me();
  }
  if ( !copy )
    _parcels = ({ });
  log_file (POST_LOG, "%s: %s collected %s at %s.\n", ctime(time()),
            name, "/global/events"->convert_message(query_multiple_short(obs)),
            location);
  save_file(name, location);
  return 1;
}
class parcel *queryparcels_for(string name, string location) {
  load_file(name, location);
  return _parcels;
}
void do_migrate(int letter, string location) {
  string name;
  class parcel temp2;
  tell_creator("ceres", "Processing %c in %s\n", letter, location);
  load_file(sprintf("%c", letter), location);
  foreach(name, temp2 in parcels) {
    _parcels = filter(temp2, (: test_expire :));
    save_file(name, location);
  }
  if(!sizeof(keys(parcels))) {
    name = BASE_PATH + location + "/" + sprintf("%c", letter) + ".o.gz";
    unguarded((: rm, name :));
  }
  if(letter < 'z') {
    letter++;
    call_out("do_migrate", 15 + random(30), letter, location);
  }
}
int test_expire(class parcel temp ) {
  if ( temp->exp_time > time() )
    return 1;
  return 0;
}
void player_refreshed(mixed name, int total ) {
  string location;
  string *dirs = map( filter( get_dir( BASE_PATH, -1 ),
                              (: $1[1] == -2 :) ), (: $1[0] :) );
  if (objectp(name))
    name = name->query_name();
  foreach(location in dirs) {
    load_file(name, location);
    map_delete(parcels, name);
    save_file(name, location);
  }
}

==================================================
FILE: handlers/pattern_compiler.c
==================================================

#include <user_parser.h>
#define PATTERN_CACHE_SIZE 200
nosave mapping patterns;
nosave mapping pattern_short;
nosave string *pattern_order;
nosave int hits, reqs, cache_callout;
nomask mixed *compile_pattern(string str);
void create() {
   patterns = ([ "" : ({ 100 }) ]);
   pattern_short = ([ "" : "" ]);
}
void clean_cache() {
  int i;
  for(i=0; i<(sizeof(pattern_order)-PATTERN_CACHE_SIZE); i++) {
    map_delete(patterns, pattern_order[i]);
    map_delete(pattern_short, pattern_order[i]);
  }
  pattern_order = pattern_order[i..];
  cache_callout = 0;
}
nomask mixed *query_pattern(string pattern) {
  if (!patterns[pattern]) {
    patterns[pattern] = compile_pattern(pattern);
  }
  return patterns[pattern];
}
nomask mixed *compile_pattern(string str) {
   mixed *pattern;
   mixed *bits;
   int i;
   int failed;
   int type;
   int weight;
   mixed env;
   string short;
   string short_bit;
   int pos;
   int pos2;
   int j;
   int k;
   bits = explode(str, " ") - ({ 0, "" });
   pattern = ({ });
   short = "";
   for (i = 0; i < sizeof(bits) && !failed; i++) {
      switch (bits[i][0]) {
      case '<' :
         pos = strsrch(bits[i], "'");
         if (pos != -1) {
             pos2 = strsrch(bits[i][pos + 1..], "'", pos + 1);
             if (pos2 == -1) {
                for (j = i + 1; j < sizeof(bits); j++) {
                   pos2 = strsrch(bits[j], "'");
                   if (pos2 != -1) {
                      break;
                   }
                }
                if (j < sizeof(bits)) {
                   for (k = i + 1; k <= j; k++) {
                      bits[i] += " " + bits[k];
                   }
                   bits[j] = bits[i];
                   i = j;
                   pos2 = strsrch(bits[i], "'", -1);
                }
             } else {
                pos2 += pos + 1;
             }
             if (pos2 != -1) {
                short_bit = bits[i][pos+1..pos2-1];
                bits[i] = bits[i][0..pos-1] + bits[i][pos2+1..];
             } else {
                short_bit = 0;
             }
         } else {
             short_bit = 0;
         }
         bits[i] = bits[i][1..<2];
         bits[i] = explode(bits[i], ":");
         if (!bits[i]) {
            bits[i] = ({ "" });
         }
         switch (bits[i][0]) {
         case "direct" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of direct (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                   short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ DIRECT_OBJECT, type, env });
            break;
         case "indirect" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               case "wiz-present" :
                  type = WIZ_PRESENT_TARGET;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of indirect (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                  short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ INDIRECT_OBJECT, type, env });
            break;
         case "string" :
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "small" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 6;
                  pattern += ({ SHORT_STRING });
                  break;
               case "long" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 5;
                  pattern += ({ STRING });
                  break;
               case "quoted" :
                  if (!short_bit) {
                     short += "\"<string>\" ";
                  } else {
                     short += "\"<" + short_bit + ">\" ";
                  }
                  weight += 8;
                  pattern += ({ QUOTED_STRING });
                  break;
               default :
                  printf("Invalid type of string (%s).\n", bits[i][1]);
                  failed = 1;
                  break;
               }
            } else {
               if (!short_bit) {
                  short += "<string> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               weight += 5;
               pattern += ({ STRING });
            }
            break;
         case   "number" :
            if (!short_bit) {
               short += "<number> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ NUMBER });
            break;
         case "word" :
            if (!short_bit) {
               short += "<word> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 7;
            pattern += ({ SINGLE_WORD });
            break;
         case "fraction" :
            if (!short_bit) {
               short += "<fraction> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ FRACTION });
            break;
         default :
            weight += 10;
            bits[i] = implode(bits[i], ":");
            if (master()->query_word_list(bits[i])
                  || this_player()->query_word_list(bits[i])) {
               if (!short_bit) {
                  short += "<"+bits[i]+"> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               pattern += ({ WORD_LIST, bits[i] });
            } else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
            }
            break;
         }
         break;
      case '{' :
         weight += 10;
         if (bits[i][<1] == '}') {
            pattern += ({ WORD_LIST, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != '}'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ WORD_LIST_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      case '[' :
         weight += 4;
         if (bits[i][1] == '<') {
            if (MASTER->query_word_list(bits[i][2..<3])
                  || this_player()->query_word_list(bits[i][2..<3]))
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            }
            short += bits[i]+" ";
         } else if (bits[i][1] == '{') {
            if (bits[i][<1] == ']') {
               pattern += ({ OPTIONAL, explode(bits[i][2..<3], "|") });
               short += bits[i]+" ";
            } else {
               int old = i;
               string elm, *res;
               for (++i; bits[i][<1] != ']'; i++);
               res = ({});
               foreach (elm in explode(implode(bits[old..i], " ")[2..<3], "|"))
                  res += ({ explode(elm, " ") });
               pattern += ({ OPTIONAL_SPACES, res });
               short += implode(bits[old..i], " ")+" ";
            }
         } else if (bits[i][<1] == ']') {
            pattern += ({ OPTIONAL, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != ']'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ OPTIONAL_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      default :
         weight += 10;
         short += bits[i]+" ";
         pattern += ({ WORD_LIST, ({ bits[i] }) });
         break;
      }
   }
   if (failed) {
      return 0;
   }
   pattern_short[str] = short;
   return ({ weight }) + pattern;
}
string query_short_pattern(string str) {
  reqs++;
  if(!pattern_short[str])
    compile_pattern(str);
  else
    hits++;
  return pattern_short[str];
}
mixed *stats() {
  return  ({
    ({ "patterns", sizeof(keys(pattern_short)), }),
        ({ "requests", reqs, }),
          ({ "cache hit percent", (hits * 100) / reqs, }),
            });
}

==================================================
FILE: handlers/peopler.c
==================================================

#include <peopler.h>
#define MULTIPLAYER "/obj/handlers/multiplayer"
string *de_names,
       *abbrev,
       *var_names;
void create() {
  de_names = DE_NAMES;
  abbrev = ABBREV;
  var_names = ({
      "dirs",
      "netstat",
      "people",
      "qpeople",
      "terms",
      "netdups",
    });
}
object *get_people(string str) {
  object *ob;
  int i;
  string s1;
  ob = users();
  for(i = 0; i<sizeof(ob); i++) {
    if (str && (sscanf(ob[i]->query_name(),str+"%s", s1) != 1)) {
      ob = ob[0..i - 1] + ob[i+1..];
      i--;
    }
  }
  return ob;
}
private string create_title(mixed *bits) {
  int i, pos;
  string str;
  str = "";
  for (i=0;i<sizeof(bits);i+=2) {
    if ((pos = (bits[i]&~MASK)) == STRING)
      str += bits[i+1];
    else
      if (strlen(de_names[pos]) > bits[i+1])
        str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", "");
      else
        switch (bits[i]&MASK) {
          case CENTER :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"|s", de_names[pos]);
            break;
          case RIGHT :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", de_names[pos]);
            break;
          default :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"-s", de_names[pos]);
            break;
        }
  }
  return str;
}
private string review_thingy(mixed *bing) {
  int i;
  string str;
  str = "";
  for (i = 0; i < sizeof(bing); i += 2) {
    if (bing[i] == STRING) {
      str += bing[i+1];
    } else {
      switch (bing[i]&MASK) {
        case CENTER :
          str += "%|"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        case RIGHT :
          str += "%"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        default :
          str += "%-"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
      }
    }
  }
  return str;
}
private void print_entrys(object *obs, mixed *format, int with_dups,
                          string constraint) {
  int age, j;
  mixed g;
  string form, str, mess, *not_allowed;
  object ob, env, *dups;
  mapping per_ip;
  reset_eval_cost();
  if (with_dups) {
    per_ip = unique_mapping(obs, (: query_ip_number($1) :));
  }
  mess = sprintf("%s\n", create_title(format));
  foreach(ob in obs) {
    str = "";
    for (j=0;j<sizeof(format);j+=2) {
      switch (format[j]&MASK) {
        case RIGHT :
          form = "%"+format[j+1]+"."+format[j+1];
          break;
        case CENTER :
          form = "%|"+format[j+1]+"."+format[j+1];
          break;
        default :
          form = "%-"+format[j+1]+"."+format[j+1];
          break;
      }
      switch (format[j]&~MASK) {
        case STRING :
          str += format[j+1];
          break;
        case C_NAME :
          str += sprintf(form+"s", capitalize( (string)ob->query_name() ) );
          break;
        case GENDER :
          str += sprintf(form+"s", ob->query_gender_string());
          break;
        case NAME :
          str += sprintf(form+"s", (ob->query_in_editor()?"*":"")+
              ( ob->query_invis() ? "("+ (string)ob->query_name() +")" :
              (string)ob->query_name() ) );
          break;
        case GUILD :
          if(ob)
            str += sprintf(form+"s",
                           ((g=(object)ob->query_guild_ob())?
                            g->query_name():"No guild"));
          else
            str += sprintf(form+"s", "Broken guild");
          break;
        case LEVEL :
          str += sprintf(form+"s", ""+ ob->query_level());
          break;
        case ROWS :
          str += sprintf(form+"s", ""+ ob->query_rows());
          break;
        case COLS :
          str += sprintf(form+"s", ""+ ob->query_cols());
          break;
        case TERMINAL :
          str += sprintf(form+"s",
                         ((g = ob->query_term_name()) ?
                          g + (g == "network" ? " (" +
                               ob->query_cur_term() + ")" : "") : ""));
          break;
        case IP_NUMBER :
          str += sprintf(form+"s", query_ip_number(ob));
          break;
        case IP_NAME :
          str += sprintf(form+"s",
                           (query_ident(ob)?query_ident(ob)+"@":"")+
                           query_ip_name(ob));
          break;
        case TYPE :
          str += sprintf(form+"s", ob->query_object_type()+"");
          break;
        case AGE :
          age = (int)ob->query_time_on();
          if (age < -86400)
            str += sprintf(form+"s", (age/-86400)+"D");
          else if (age < -3600)
            str += sprintf(form+"s", (age/-3600)+"h");
          else if (age < -60)
            str += sprintf(form+"s", (age/-60)+"m");
          else
            str += sprintf(form+"s", (age/-1)+"s");
          break;
        case ROOM :
          env = environment(ob);
          str += sprintf(form+"s",env?file_name(env):"No environment");
          break;
        case EUID :
          env = environment(ob);
          str += sprintf(form+"s",env?geteuid(env):"No environment");
          break;
        case UID :
          env = environment(ob);
          str += sprintf(form+"s",env?getuid(env):"No environment");
          break;
        case CFILE :
          env = environment(ob);
          str += sprintf(form+"s",env?"/secure/master"->creator_file(env)
                         :"No environment");
          break;
        case CUR_DIR :
          str += sprintf(form+"s", (ob->query_current_path()?
                                    ob->query_current_path():"No dir"));
          break;
        case ND_ALLOWED :
          dups = per_ip[query_ip_number(ob)] - ({ ob });
          not_allowed = MULTIPLAYER->check_allowed(ob, dups);
          str += sprintf(form+"s", (sizeof(not_allowed) ?
                                    query_multiple_short(not_allowed) :
                                    ""));
          break;
      }
    }
    if(!constraint || strsrch(str, constraint) != -1)
      mess += sprintf("%s\n", str);
  }
  this_player()->more_string( mess );
}
int do_command(mixed *pattern, string constraint, function sort_func,
               int only_duplicates) {
   object *obs;
   object *tmpobs;
   int i;
   obs = get_people("");
   if (!sizeof(obs)) {
      notify_fail("Nobody seems to start with '" + constraint + "'.\n");
      return 0;
   }
   if (!sort_func) {
      sort_func = (: strcmp($1->query_name(), $2->query_name()) :);
   }
   obs = sort_array(obs, sort_func);
   if (only_duplicates) {
      tmpobs = ({ });
      for (i = 1; i <sizeof(obs); i++) {
         if (!evaluate(sort_func, obs[i - 1], obs[i])) {
            if (member_array(obs[i - 1], tmpobs) == -1) {
               tmpobs += obs[i - 1..i];
            } else {
               tmpobs += ({ obs[i] });
            }
         }
      }
      if (!sizeof(tmpobs)) {
         notify_fail("Unable to find any duplicates.\n");
         return 0;
      }
      obs = tmpobs;
   }
   print_entrys(obs, pattern, only_duplicates, constraint);
   return 1;
}
int review() {
  mixed *bing;
  bing = (mixed *)this_player()->query_property("people list");
  if (!bing)
    bing = P_DEFAULT;
  write("People : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("qpeople list");
  if (!bing)
    bing = QP_DEFAULT;
  write("Qpeople: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netstat list");
  if (!bing)
    bing = N_DEFAULT;
  write("Netstat: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("term list");
  if (!bing)
    bing = T_DEFAULT;
  write("Terms  : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("dir list");
  if (!bing)
    bing = D_DEFAULT;
  write("Dirs   : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netdup list");
  if (!bing)
    bing = ND_DEFAULT;
  write("Netdups: "+review_thingy(bing)+"\n");
}
private mixed *create_review(string str) {
  string *bits, rest;
  int i, bing, width, tmp;
  mixed *ret;
  bits = explode("$"+str, "%");
  bits[0] = bits[0][1..];
  if (!strlen(bits[0]))
    ret = ({ });
  else
    ret = ({ STRING, bits[0] });
  for (i=1;i<sizeof(bits);i++) {
    bing = RIGHT;
    rest = bits[i];
    if (rest[0] == '|') {
      bing = CENTER;
      rest = rest[1..];
    } else if (rest[0] == '-') {
      bing = 0;
      rest = rest[1..];
    }
    if (sscanf(rest, "%d%s", width, rest) == 2) {
      tmp = member_array(rest[0..0], abbrev);
      if (tmp == -1) {
        write("Unknown thingy '"+rest[0..0]+"'\n");
        return 0;
      }
      ret += ({ tmp+bing, width });
      rest = rest[1..];
      if (strlen(rest))
        ret += ({ STRING, rest });
    } else {
      ret += ({ STRING, bits[i] });
    }
  }
  return ret;
}
private void list_matches() {
  int i;
  for (i=0;i<sizeof(de_names);i++) {
    if (i == STRING) continue;
    printf("%s: %s\n", abbrev[i], de_names[i]);
  }
}
int set_var(string str) {
  string name, type;
  mixed *bing;
  if (str == "help") {
    write("The non helpful help.\nThis is the list of things that go after "+
          "the %'s in the value.\n");
    list_matches();
    return 1;
  }
  if (!str || sscanf(str, "%s %s", name, type) != 2) {
    notify_fail("Syntax: "+query_verb()+" <var_name> <value>\n"+
                "        "+query_verb()+" help\n");
    return 0;
  }
  if (member_array(name, var_names) == -1) {
    notify_fail("You cannot set the var "+name+", it has to be one of "+
                implode(var_names[0..<2], ", ")+" or " + var_names[<1] +
                ".\n");
    return 0;
  }
  bing = create_review(type);
  if (!bing)
    return 1;
  this_player( 1 )->add_property( name +" list", bing );
  write("Ok, set var "+name+" to "+type+".\n");
  return 1;
}
