# Total Tokens: 16900
# Total Files Merged: 8
# Total Characters: 56352

r_shop/office_code/lists.c
==================================================

string badge_list()
{
   string *results = ({}),
          *creators = ({});
   foreach(object ob in children(BADGE))
   {
      if (ob == find_object(BADGE)) continue;
      if (ob->query_channel() != _channel) continue;
      if (environment(ob)->query_creator())
         creators += ({ environment(ob)->query_name() });
   }
   if (member_array(CREATOR, creators) != -1)
   {
      object ob = find_player(CREATOR);
      creators -= ({CREATOR});
      if (ob && !ob->query_invis())
      {
         string temp_result = ob->query_cap_name() +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   }
   if (sizeof(creators))
      foreach(string word in sort_array(creators, 1))
      {
         string temp_result = cap_name(word) +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   foreach (string word in sort_array(_retired, 1))
   {
      object ob;
      if (ob = find_player(word))
      {
         string temp_result = "%^CYAN%^"+ ob->query_cap_name() +
            "%^RESET%^ (R)";
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_managers())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (m)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_supervisors())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (s)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_employees())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   if (!sizeof(results))
      return "\nJust you, I'm afraid.\n";
   return sprintf("\n%s\n", query_multiple_short(results));
}
int do_list()
{
   int emps_in;
   string results = "   Employees of "+ _shop_name + "\n"
                    "     As at " + ctime(time()) + "\n\n";
   foreach (string word in sort_array(_retired, 1))
   {
      object ob = find_player(word);
      if (ob)
         results += "%^GREEN%^";
      results += "     "+ cap_name(word)+
      "%^RESET%^ (retired manager)\n";
   }
   foreach (string word in get_managers())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (manager)"+
        list_stuff(word);
   }
   foreach (string word in get_supervisors())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (supervisor)"+
        list_stuff(word);
   }
   foreach (string word in get_employees())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in ++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^"+ list_stuff(word);
   }
   results += "\n";
   if (this_player()->query_creator() ||
     _employees[this_player()->query_name()][EMP_POINTS] & MANAGER)
   {
      results += (emps_in == 1)?"   There is one employee ":
                 "   There are "+ query_num(emps_in,0)+ " employees ";
      results += "out of "+ query_num(sizeof(_employees) - 1)+
        " on " + mud_name() + " at the moment, with "+ query_num(num_employees_in(),
          0) + " currently clocked in.\n\n";
   }
   tell_object(this_player(), "$P$Employees$P$"+ results);
   add_succeeded_mess("");
   return 1;
}
private int do_office()
{
   int employee;
   object tp = this_player();
   string tp_name = tp->query_name(),
          board_mess = "";
   if (!_board)
      board_mess = "   memo      - send a memo to the other employees\n";
   add_succeeded_mess("");
   tp = this_player();
   tp_name = tp->query_name();
   if (member_array(tp_name, _retired) != -1)
   {
      tell_object( tp, "As a retired manager, you can use the following "
        "commands:\n"
        "   claim     - claim a badge or handbook\n"
        "   list      - list the other employees of the shop\n"
        "   logs      - review the shop's logs\n"
        "   resign    - terminate your association with Tarnach's\n"+
        board_mess+
        "You may also enter the managers' office for more commands.\n" );
      return 1;
   }
   employee = (tp->query_creator())?SUPERVISOR + MANAGER:
              _employees[tp_name][EMP_POINTS];
   tell_object(tp, "As an employee, you can use the following commands:\n"
     "   clock     - start or finish your working day\n"+
     "   claim     - claim a badge, handbook, or this month's bonus\n"
     "   bank      - set to which bank account you are paid\n"
     "   list      - list the other employees of the shop\n"
     "   promotion - request to be ignored for promotion\n"
     "   resign    - end your employment at the shop\n"+
     board_mess );
   if (employee & SUPERVISOR)
      tell_object( tp, "\nAs a supervisor, you can also use:\n"
        "   chart   - change the information on the sales chart\n"
        "   check   - check cabinet assignments\n"
        "   logs    - review the shop's logs\n" );
   if (employee & MANAGER)
      tell_object( tp, "\nAs a manager you can enter the managers' "
        "office and use the commands listed there.\n" );
   add_succeeded_mess("");
   return 1;
}
string employees_clocked_in()
{
   object *words = ({}), ob;
   if (!num_employees_in()) words = ({"No employees"});
   if (find_object(_shopkeeper) &&
      _employees[_shopkeeper->query_name()][EMP_POINTS] & CLOCKED_IN)
      words = ({_shopkeeper->query_short()});
   foreach (string word in m_indices(_employees))
   {
      ob = find_player(word);
      if (ob && _employees[word][EMP_POINTS] & CLOCKED_IN)
            words += ({ob->query_cap_name()});
   }
   return query_multiple_short(words);
}
private string list_stuff(string word)
{
   string results = "",
          tp = this_player()->query_name();
   if (member_array(word, _retired) != -1) return "\n";
   if (_employees[word][EMP_POINTS] & NPC) return query_worked(word) + "\n";
   if (this_player()->query_creator())
      results = " ["+ (_employees[word][EMP_POINTS] / 32) +"]";
   else if ((word == tp) && !(_employees[word][EMP_POINTS] & MANAGER))
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] /
           32 - SUPER_POINTS)) /
           (MANAGER_POINTS - SUPER_POINTS)) +"%]";
      else
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] / 32)) /
           SUPER_POINTS) +"%]";
   if (this_player()->query_creator() || (_employees[tp][EMP_POINTS] & MANAGER))
      results += query_worked(word);
   return results + "\n";
}

==================================================
FILE: shops/player_shop/office_code/logging.c
==================================================

int do_logs(mixed *args, string pattern)
{
    string start, end, file, *files, words;
    add_succeeded_mess("");
    switch (pattern)
    {
    case LOG_BLANK :
        files = get_dir(_savedir +"general.log*");
        words = "Available logs:\n\n";
        if (sizeof(files))
            words += " 1: current log\n";
        for (int i = sizeof(files); i > 1; i--)
        {
            sscanf(unguarded((: read_file, _savedir + files[i-1], 2, 1 :)),
              "%*s, %s:", start);
            sscanf(unguarded((: read_file, _savedir + files[i-1],
                  file_length(_savedir + files[i-1]), 1 :)),
              "%*s, %s: %*s", end );
            if (start == end)
                words += sprintf("%2d: %s\n",
                  sizeof(files)-(i-2), start);
            else
                words += sprintf("%2d: %s to %s\n",
                  sizeof(files)-(i-2), start, end);
        }
        words += "\nUse \"logs <number>\" to read one of them, or \"logs ";
        if ((_employees[this_player()->query_name()] &&
            _employees[this_player()->query_name()][EMP_POINTS] & MANAGER) ||
          this_player()->query_creator())
        {
            words += "{personnel|accounts|chart}\" to view "
            "those logs.\n";
        }
        else
        {
            words += "chart\" to view that log.\n";
        }
        tell_object(this_player(),"$P$Logs$P$"+ words);
        break;
    case LOG_NUMBER :
        files = get_dir(_savedir +"general.log*");
        if ((args[0] < 1) || (args[0] > sizeof(files)))
        {
            tell_object(this_player(), "There are "+ sizeof(files) +
              " logs.  Use \"logs\".\n");
            return 1;
        }
        if (args[0] == 1)
            sscanf(unguarded((: read_file, _savedir +
                  files[0] :)), "%*s\n%s", words);
        else
            sscanf(unguarded((: read_file, _savedir +
                  files[sizeof(files) - (args[0]-1)] :)), "%*s\n%s", words);
        tell_object(this_player(),"$P$Log "+ args[0]+ "$P$"+ words);
        break;
    case LOG_CHART :
        file = _savedir + "chart.log";
        if (file_size(file) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$Chart log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The chart log is empty.\n");
            return 1;
        }
        break;
    case LOG_MGR :
        file = _savedir + args[0] + ".log";
        if (file_size( file ) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$"+ capitalize(args[0])+
              " log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The "+ args[0]+ " log is empty.\n");
            return 1;
        }
        break;
    }
    return 1;
}
private void employee_log(string employee, string note)
{
    load_history();
    if (!sizeof(_history)) _history = ([employee:({({}),({}),})]);
    else if (!_history[employee]) _history += ([employee:({({}),({}),})]);
    _history[employee][0] += ({time()});
    _history[employee][1] += ({note});
    save_hist();
    remove_call_out(_call_times);
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([ employee:0 ]);
    _times[employee] = time();
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
void shop_log(int logtype, string word, string words, int paid)
{
    string date, month, colour;
    sscanf(amtime(time()), "%*s %*s %*s %s %*s", month);
    if (file_size(_savedir +"general.log") > 0)
    {
        date = ctime(time())[0 .. 9];
        if (date != unguarded((: read_file,
              _savedir +"general.log", 1, 1 :))[0 .. 9])
        {
            string logfile = _savedir +"general.log-"+ time(),
            summary = sprintf( "%sFor the period ending %s:%s\n",
              "%^BOLD%^", amtime(time()), "%^RESET%^" ),
            sign = "";
            _storeroom->force_load();
            call_out((: update_averages() :), 60);
            unguarded((: rename, _savedir +"general.log", logfile :));
            call_out((: review_employees() :), 5 );
            foreach (string item in m_indices(_list))
            {
                summary += sprintf(" %s - Bought %d, Sold %d\n", capitalize(item),
                  _list[item][CHART_BOUGHT], _list[item][CHART_SOLD]);
                _list[item][CHART_AVESALE] = (_list[item][CHART_AVESALE] +
                  _list[item][CHART_SOLD] + random(2)) / 2;
                _list[item][CHART_SOLD] = 0;
                _list[item][CHART_BOUGHT] = 0;
            }
            save_list();
            if (_net_takings < 0)
            {
                _net_takings = -_net_takings;
                sign = "-";
            }
            summary += sprintf("%sThe net takings of the shop were %s%s.%s\n\n",
              "%^BOLD%^", sign, MONEY_HAND->money_value_string(_net_takings,
                _place), "%^RESET%^");
            _net_takings = 0;
            save_me();
            unguarded((: write_file, _savedir +"general.log",
                date +"\n" + summary :));
            foreach (string file in get_dir(_savedir +"general.log-*"))
            {
                sscanf(file, "%*s-%s", date);
                if (time() - to_int(date) > (60*60*24*LOG_DAYS))
                    unguarded((: rm, _savedir + "general.log-"+ date :));
            }
        }
    }
    if (month != _last_month && !_call_review)
    {
        if (member_array(month, ({"Offle", "February", "March",
              "April", "May", "June", "Grune", "August", "Spune",
              "Sektober", "Ember", "December", "Ick"})) != -1)
        {
            _review_month = month;
            remove_call_out(_call_review);
            _call_review = call_out((: monthly_review() :), 60);
        }
    }
    if (_employees[word])
    {
        if (!(_employees[word][EMP_POINTS] & NPC))
            _employees[word][EMP_EOM]++;
        if (paid && _employees[word][EMP_POINTS] & CLOCKED_IN)
        {
            if (_employees[word][EMP_POINTS] & MANAGER)
                _employees[word][EMP_PAY] += (_pay_val * 2);
            else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
              _eom == word)
            {
                _employees[word][EMP_PAY] += to_int(_pay_val * 1.5);
                _employees[word][EMP_POINTS] += 32;
            }
            else
            {
                _employees[word][EMP_PAY] += _pay_val;
                _employees[word][EMP_POINTS] += 32;
            }
        }
        set_emp_time(word);
        save_emps();
    }
    switch (logtype)
    {
    case PURCHASE :
        colour = "%^GREEN%^";
        break;
    case SALE :
        colour = "%^RED%^";
        break;
    case GENERAL :
        colour = "%^CYAN%^";
        break;
    case PERSONNEL :
        log_file(_savedir+ "personnel.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case ACCOUNTS :
        log_file(_savedir+ "accounts.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case CHARTLOG :
        log_file(_savedir+ "chart.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    default :
        colour = "%^RESET%^";
        break;
    }
    unguarded((: write_file, _savedir +"general.log", colour + amtime(time())+
        ": "+ cap_name(word) +"%^RESET%^ - "+ words +"\n" :));
}

==================================================
FILE: shops/player_shop/office_code/masked.c
==================================================

void dest_me()
{
   if (_very_short != UNSET_STR)
   {
      if (remove_call_out(_call_save) != -1) do_save();
      if (remove_call_out(_call_apps) != -1) do_save_applicants();
      if (remove_call_out(_call_hist) != -1) do_save_hist();
      if (remove_call_out(_call_newpols) != -1) do_save_new_policies();
      if (remove_call_out(_call_pols) != -1) do_save_policies();
      if (remove_call_out(_call_times) != -1) save_times();
      if (remove_call_out(_call_emps) != -1) do_save_emps();
   }
   if (_chart) _chart->dest_me();
   if (_board) _board->dest_me();
   if (_notice) _notice->dest_me();
   ::dest_me();
}
void event_death(object killed, object *others, object killer,
  string rmess, string kmess)
{
   if (!killed->query_player() &&
     !(query_employee(killed->query_name()) & NPC)) return;
   if (!killer) return;
   if ((query_employee(killed->query_name()) & NPC)  ||
    (query_employee(killed->query_name())))
   {
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
      foreach(object baddie in others)
         if (baddie->query_player())
            add_baddie(baddie->query_name(),
              "the vicious assault on "+ killed->query_name(),
              _proprietor);
      return;
   }
   if (query_employee(killer->query_name()) & CLOCKED_IN)
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
   if (sizeof(others))
      foreach(object baddie in others)
      {
         if (!baddie->query_player()) continue;
         if (query_employee(baddie->query_name())& CLOCKED_IN)
            add_baddie(baddie->query_name(), "the vicious assault on "+
               killed->query_name(), _proprietor);
      }
}
void event_enter(object ob, string message, object from)
{
   string room;
   if (!from || ob->query_creator() || from == find_object("/room/void") ||
     !ob->query_player()) return;
   room = file_name(from);
   if (room == _counter || room == _shop_front || room == _storeroom ||
     room == _mgr_office || from == this_object()) return;
#ifdef DEBUG
   tell_creator(CREATOR, "%s arrived from %O.\n", ob->query_name(), from);
#endif
   fire_them(_proprietor, ob->query_name(), "for teleporting into the shop");
}
void init()
{
   object tp = this_player();
   string word = tp->query_name();
   ::init();
   if (!tp->query_creator() && !_employees[word] &&
     (member_array(word, _retired) == -1)) return;
   add_command("claim", "{badge|handbook|bonus}", (: do_claim($4[0]) :));
   add_command("resign", "", (: do_resign() :));
   add_command("list", "", (: do_list() :));
   add_command("office", "", (: do_office() :));
   if (!_board) add_command("memo", "", (: do_memo() :));
   if (member_array(word, _retired) != -1) return;
   add_command("clock", "{in|out}", (: do_clock($4[0]) :));
   add_command("bank", ({ "", "<number>" }), (: do_bank($4) :));
   if (!this_player()->query_property("no score"))
      add_command( "promotion", "{on|off}", (: do_promote($4[0]) :) );
   if (!tp->query_creator() &&  !(_employees[word][EMP_POINTS] & SUPERVISOR))
      return;
   add_command("chart", ({CHART_ADDITEM, CHART_REMITEM, CHART_MAXITEM,
      CHART_BUYITEM, CHART_SELLITEM, CHART_ASSIGN_ITEM, CHART_UNASSIGN_ITEM}),
     (: do_chart($4,$5) :));
   add_command("check", "cabinets", (: do_check() :));
   if (!tp->query_creator() && !(_employees[word][EMP_POINTS] & MANAGER))
      add_command( "logs", ({LOG_BLANK, LOG_NUMBER, LOG_CHART}),
      (: do_logs($4,$5) :));
   else
      add_command("logs", ({LOG_BLANK, LOG_NUMBER,
        LOG_MGR}), (: do_logs($4,$5) :));
}
void refresh_function(mixed employee, int flag)
{
   string emp_name;
   switch (flag)
   {
      case PLAYER_DELETED :
        emp_name = employee;
        break;
      case TOTAL_REFRESH :
      case PARTIAL_REFRESH :
        emp_name = employee->query_name();
        break;
   }
   if (query_applicant(emp_name))
   {
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your application at "+ _shop_name+
             " has been removed.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }
   }
   if (member_array(emp_name, _retired) != -1)
   {
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your employment at "+ _shop_name+
             " has been terminated.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }
   }
   if (!_employees[emp_name]) return;
   switch (flag)
   {
      case PLAYER_DELETED :
        shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
        employee_log(emp_name, "Deleted character");
        remove_employee(emp_name);
        break;
      case TOTAL_REFRESH :
        tell_object(employee, "Your employment at "+ _shop_name+
          " has been terminated.\n");
        shop_log(PERSONNEL, emp_name, "refreshed totally", UNPAID);
        employee_log(emp_name, "Refreshed totally");
        remove_employee(emp_name);
        break;
      case PARTIAL_REFRESH :
        tell_object(employee, "Your employment level at "+ _shop_name+
          " has been reset.\n");
        shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
        employee_log(emp_name, "Refreshed character");
        _employees[emp_name] = EMP_MAP;
        set_emp_time(emp_name);
        _got_bonus += ({emp_name});
        save_me();
        break;
   }
}
protected void set_long(string long_desc)
{
   string ob_file = file_name(this_object());
   _chart = clone_object(SHOP_CHART);
   _chart->set_office(ob_file);
   add_hidden_object(_chart);
   _notice = clone_object(SHOP_NOTICE);
   _notice->set_office(ob_file);
   add_hidden_object(_notice);
   long_desc += "Employees may \"clock\" in and out of work here "
     "and examine the items chart.  There is also a policy notice "
     "located next to the chart.\n";
   ::set_long(long_desc);
}

==================================================
FILE: shops/player_shop/office_code/memo.c
==================================================

private int do_memo()
{
   tell_object(this_player(), "Subject: (hit enter for general memo)\n");
   input_to((: write_memo($1) :), 0);
   add_succeeded_mess("");
   return 1;
}
private void end_memo(string text, string subject)
{
   if (!text)
   {
      tell_object(this_player(), "Aborted.\n");
      return;
   }
   tell_object(this_player(), "Do you want to keep a copy of the memo? ");
   input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
private void send_memo(string ans, string subject, string text)
{
   object tp = this_player();
   string *employees = _retired,
          tp_name = tp->query_name();
   tp = this_player();
   tp_name = tp->query_name();
   ans = lower_case(ans);
   if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
   {
      tell_object(tp,
        "Do you want to keep a copy of the memo? (Yes or No)? ");
      input_to((: send_memo($1,$(subject),$(text)) :), 0);
      return;
   }
   if (tp->query_creator() && tp_name != _creator)
      employees += ({tp_name});
   employees += ({_creator});
   foreach(string employee in m_indices(_employees))
      if (!(_employees[employee][EMP_POINTS] & NPC))
         employees += ({employee});
   if (ans[0] == 'n') employees -= ({tp_name});
   if (!sizeof(employees))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "No employees to send mail to.\n");
#endif
      tell_object(tp, "There is no-one to send a memo to!\n");
      return;
   }
#ifdef DEBUG
   tell_creator(CREATOR, "Sending employee memo to %s.\n",
     implode(employees, "," ));
#endif
   tell_object( tp, "Sending your memo.\n" );
   if (subject && subject != "") subject = " - " + subject;
   else subject = "";
   AUTO_MAILER->auto_mail(implode(employees, ","),
     tp_name, _very_short+ " employee memo" + subject, "", text, 0, 0);
}
private void write_memo(string text)
{
   this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}

==================================================
FILE: shops/player_shop/office_code/personnel.c
==================================================

private void add_employee(string player)
{
    if (!_employees[player])
    {
        _employees += ([player:EMP_MAP]);
        _employees[player][EMP_NOBONUS] = 1;
        set_emp_time(player);
        _got_bonus += ({player});
        save_me();
        save_emps();
    }
}
private void demote(string demoter, string demotee)
{
    int points = _employees[demotee][EMP_POINTS] & CLOCKED_IN;
    if (_employees[demotee][EMP_POINTS] & MANAGER)
        points += (SUPER_POINTS * 32) + EMPLOYEE + SUPERVISOR;
    else points += EMPLOYEE;
    _employees[demotee][EMP_POINTS] = points;
    save_emps();
    PLAYER_SHOP->auto_mail(demotee, _proprietor, "Demotion", "",
      "This is to advise you that you have today been demoted.\n"
      "This demotion will now stay on your employment record.\n");
    employee_log(demotee, "Demoted by "+ demoter);
    shop_log(PERSONNEL, demoter, "demoted "+ cap_name(demotee), PAID);
}
int do_commend(string emp)
{
    string commender;
    if (!_employees[emp])
    {
        tell_object(this_player(), cap_name(emp)+
          " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        tell_object(this_player(), "You can't commend a manager.\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  "
          "You can't commend $C$"+ emp +".\n");
        return 1;
    }
    commender = this_player()->query_cap_name();
    AUTO_MAILER->auto_mail(emp, lower_case(commender), "Commendation",
      "", "This is to advise you that you have today received a "
      "commendation for outstanding service.\nThis will now stay on "
      "your employment record.\n");
    employee_log(emp, "Received a commendation from "+ commender);
    shop_log(PERSONNEL, commender, "commended "+ cap_name(emp), PAID);
    _employees[emp][EMP_POINTS] += (_employees[emp][EMP_POINTS] & SUPERVISOR)?
    to_int(MANAGER_POINTS * 0.05 * 32) : to_int(SUPER_POINTS * 0.05 * 32);
    save_emps();
    tell_object(this_player(), "You commend "+ cap_name(emp)+ ".\n");
    return 1;
}
int do_demote(string emp)
{
    object tp = this_player();
    emp = lower_case(emp);
    if (!_employees[emp])
    {
        tell_object(tp, cap_name(emp)+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER && !tp->query_creator())
    {
        tell_object(tp, "You don't have the authority to "
          "demote $C$"+ emp +".\n");
        return 1;
    }
    if (!( _employees[emp][EMP_POINTS] & SUPERVISOR))
    {
        tell_object(tp, "Don't be silly!  You can't demote $C$"+
          emp +".\n");
        return 1;
    }
    demote(tp->query_cap_name(), emp);
    tell_object(tp, "You demote "+ cap_name(emp)+ ".\n");
    return 1;
}
int do_fire(mixed *args)
{
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(this_player(), cap_name(args[0])+
          " doesn't work at the shop!\n");
        return 1;
    }
    if ((member_array(args[0], _retired) != -1) ||
      query_manager(args[0]) && !this_player()->query_creator())
    {
        tell_object(this_player(), "You don't have the authority "
          "to fire $C$"+ args[0] +".\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  You can't fire $C$"+
          args[0] +".\n");
        return 1;
    }
    fire_them(this_player()->query_name(), args[0], args[1]);
    tell_object(this_player(), "You fire "+ cap_name(args[0])+
      " for "+ args[1]+ ".\n" );
    return 1;
}
int do_leave(mixed *args)
{
    object tp = this_player();
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an employee!\n");
        return 1;
    }
    if (args[1] > MAX_LEAVE)
    {
        tell_object(tp, "You cannot place an employee on leave "
          "for more than "+ MAX_LEAVE+ " days at a time.\n");
        return 1;
    }
    _times[args[0]] = time() + (args[1] * 86400);
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
    add_succeeded_mess(cap_name(args[0])+
      " is on leave until "+ ctime(time() + (args[1] * 86400))+ ".\n");
    shop_log(PERSONNEL, tp->query_name(), "placed "+
      cap_name(args[0])+ " on leave for " + args[1]+ " days", PAID);
    employee_log(args[0], "Placed on leave by "+ tp->query_cap_name()+
      " for "+ args[1]+ " days.");
    tell_object(tp, "You place "+ cap_name(args[0])+
      " on leave for " + args[1]+ " days.\n");
    return 1;
}
private int do_promote(string on)
{
    object tp = this_player();
    add_succeeded_mess("");
    if (tp->query_creator())
    {
        tell_object(tp, "Creators don't get promoted.\n");
        return 1;
    }
    switch (on)
    {
    case "off" :
        _employees[tp->query_name()][EMP_NOPROMOTE] = TRUE;
        tell_object(tp, "You have now requested to be "
          "passed over for promotion.\n");
        break;
    case "on" :
        if (tp->query_property("no score"))
        {
            tell_object(tp, "Sorry, you cannot be promoted.\n");
            return 1;
        }
        _employees[tp->query_name()][EMP_NOPROMOTE] = FALSE;
        tell_object(tp, "You have now requested to be "
          "considered for promotion.\n");
        break;
    }
    save_emps();
    return 1;
}
private int do_resign()
{
    string word = this_player()->query_name();
    add_succeeded_mess("$N $V.\n");
    remove_employee(word);
    shop_log(PERSONNEL, word, "resigned", UNPAID);
    employee_log(word, "Resigned");
    return 1;
}
int do_retire()
{
    string manager = this_player()->query_name();
    if (!(_employees[manager][EMP_POINTS] & MANAGER)) return 0;
    remove_employee(manager);
    _retired += ({manager});
    shop_log(PERSONNEL, manager, "retired from management", UNPAID);
    employee_log(manager, "Retired from management");
    save_me();
    add_succeeded_mess("$N retire$s.\n");
    return 1;
}
int do_suspend(mixed *args)
{
    string suspender;
    object tp = this_player();
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if ((_employees[args[0]][EMP_POINTS] & MANAGER) &&
      (!tp->query_creator()))
    {
        tell_object(tp, "You don't have the authority to "
          "suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  "
          "You can't suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    suspender = tp->query_cap_name();
    _employees[args[0]][EMP_NOBONUS] = args[1];
    save_emps();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Suspended bonus", "",
      sprintf( "This is to advise you that you have had your bonus "
        "entitlement suspended for %d month%s.\nThis suspension will "
        "now stay on your employment record.\n", args[1],
        (args[1] == 1)?"":"s"));
    employee_log(args[0], sprintf("Bonus suspended for %d month%s by %s",
        args[1], (args[1] == 1)?"":"s", suspender));
    shop_log(PERSONNEL, suspender,
      sprintf("suspended %s's bonus for %d month%s", args[0],
        args[1], (args[1] == 1)?"":"s"), PAID);
    tell_object(tp, "You suspend "+ cap_name(args[0])+
      "'s bonus for "+ args[1]+ " months.\n");
    return 1;
}
int do_warn(mixed *args)
{
    string warner;
    object tp = this_player();
    int points;
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & MANAGER && !tp->query_creator() )
    {
        tell_object( tp, "You don't have the authority to "
          "warn $C$"+ args[0] +".\n" );
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  You can't warn $C$"+ args[0] +".\n");
        return 1;
    }
    warner = tp->query_cap_name();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Official warning", "",
      "This is to advise you that you have today received a formal "
      "warning for " + args[1] + ".\nThis warning will now stay on "
      "your employment record.\n");
    employee_log(args[0], "Received a warning from "+ warner+
      " for "+ args[1]);
    shop_log(PERSONNEL, warner, "warned "+
      cap_name( args[0] ) + " for "+ args[1], PAID);
    points = _employees[args[0]][EMP_POINTS] & CLOCKED_IN;
    if (_employees[args[0]][EMP_POINTS] & SUPERVISOR)
        _employees[args[0]][EMP_POINTS] -= to_int(MANAGER_POINTS * 0.05 * 32);
    else
    {
        _employees[args[0]][EMP_POINTS] -= to_int(SUPER_POINTS * 0.05 * 32) +
        EMPLOYEE;
        if (_employees[args[0]][EMP_POINTS] < 1)
            _employees[args[0]][EMP_POINTS] = EMPLOYEE + points;
    }
    save_emps();
    tell_object(tp, "You warn "+ cap_name(args[0])+ " for "+
      args[1]+ ".\n");
    return 1;
}
private void fire_them(string word, string them, string reason)
{
    if (!_employees[them]) return;
    BANK_HANDLER->adjust_account(them, BANKS[_employees[them][EMP_BANK]][1],
      _employees[them][EMP_PAY]);
    shop_log(ACCOUNTS, _proprietor, "paid "+
      MONEY_HAND->money_value_string(_employees[them][EMP_PAY], _place)+
      " to "+ cap_name(them), UNPAID);
    shop_log(PERSONNEL, word, "fired "+ cap_name(them) +
      " for "+ reason, PAID);
    PLAYER_SHOP->auto_mail(them, word, _shop_name, "",
      "Unfortunately, I have to inform you that you have today "
      "been fired for " + reason + ".  You have been paid the sum of "+
      MONEY_HAND->money_value_string( _employees[them][EMP_PAY], _place )+
      " for the work you have carried out to this date.\nIf you feel you "
      "have been unfairly dismissed, please refer to a manager.\n");
    employee_log(them, "Fired by "+ cap_name(word)+
      " for "+ reason);
    remove_employee(them);
}
private void hire(string word)
{
    int gender;
    remove_applicant(word);
    if (!test_player(word) || _employees[word] || query_baddie(word)) return;
    add_employee(word);
    employee_log(word, "Hired");
    shop_log(PERSONNEL, _proprietor, "hired "+ cap_name(word), UNPAID);
    PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
      "Congratulations!  You've been hired to work at "+ _shop_name+
      ".  You'll find that you can now move through the counter "
      "to the back areas of the shop.  The first things you should "
      "do are \"claim\" a new badge and staff handbook.\n");
    gender = PLAYER_HANDLER->test_gender(word);
    add_board_message("New employee", sprintf("%s has today been employed to "
        "work for the shop.  Please make %s feel welcome, and assist %s while "
        "%s gets started in %s new position.\n", cap_name(word),
        ({"it", "him", "her"})[gender] ,({"it", "him", "her"})[gender],
        ({"it", "he", "she"})[gender], ({"its", "his", "her"})[gender]));
    remove_call_out(_call_mail_hirees);
    _call_mail_hirees = call_out((: mail_hirees() :), 5);
}
private string query_worked(string emp)
{
    string blurb;
    if (_employees[emp][EMP_POINTS] & CLOCKED_IN)
        return " is currently clocked in";
    if (_employees[emp][EMP_POINTS] & NPC)
        return " has gone home for tea";
    if (_times[emp] > time())
        return " - %^CYAN%^on leave until "+ ctime(_times[emp])+ "%^RESET%^";
    blurb = " - last action ";
    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        if ((time() - _times[emp]) > ((60*60*24*MGR_DEMOTE)-7))
            blurb += "%^RED%^";
        else if ((time() - _times[emp]) > (60*60*24*MGR_WARN))
            blurb += "%^RED%^";
    }
    else if (_employees[emp][EMP_POINTS] & SUPERVISOR)
    {
        if (( time() - _times[emp]) > ((60*60*24*SPR_DEMOTE)-7))
            blurb += "%^RED%^";
        else if ((time() - _times[emp]) > (60*60*24*SPR_WARN))
            blurb += "%^YELLOW%^";
    }
    else if (( time() - _times[emp]) > ((60*60*24*EMP_FIRE)-7))
        blurb += "%^RED%^";
    else if ((time() - _times[emp]) > (60*60*24*EMP_WARN))
        blurb += "%^YELLOW%^";
    return blurb + ctime(_times[emp])+ "%^RESET%^";
}
private void set_emp_time(string employee)
{
    if (!_employees[employee]) return;
    if (_employees[employee][EMP_INACTIVE])
    {
        _employees[employee][EMP_INACTIVE] = 0;
        save_emps();
    }
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([employee:0]);
    _times[employee] = time();
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
void view_record(string person, string pattern)
{
    if (pattern == VIEW_EMP)
    {
        string text = sprintf("Employment history of %s:\n\n", cap_name(person));
        load_history();
        if (!sizeof(_history) || !_history[person])
        {
            tell_object(this_player(), "There is no history for that person.\n");
            return;
        }
        for(int i = 0; i < sizeof(_history[person][0]); i++)
            text += sprintf("%s: %s\n", ctime(_history[person][0][i]),
              _history[person][1][i]);
        tell_object(this_player(), sprintf("$P$%s's history$P$%s",
            cap_name(person), text));
        clear_history();
    }
    else
    {
        if (!query_applicant(person))
        {
            tell_object(this_player(), "That person has no application form "
              "on file.\n");
            return;
        }
        load_applicants();
        tell_object(this_player(),
          sprintf("$P$%s's history$P$Application of %s:\n\n%s", cap_name(person),
            cap_name(person), _applicants[person][APP_MESSAGE]));
        clear_applicants();
    }
}

==================================================
FILE: shops/player_shop/office_code/policies.c
==================================================

private void add_policy(string policy)
{
   load_policies();
   load_new_policies();
   if (!_policies[policy])
   {
      _policies += ([policy:({"",0})]);
      _policies[policy][0] = _new_policies[policy][POLICY_TEXT];
      _policies[policy][1] = _new_policies[policy][POLICY_TYPE];
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "", "Your proposition has been "
        "accepted by majority vote and is now policy.\n" );
      shop_log(GENERAL, "Shop", "accepted the "+ policy + " policy.", UNPAID);
   }
   else
   {
      map_delete(_policies, policy);
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "",
        "Your proposition to remove the above policy has been accepted "
        "by majority vote.\n");
      shop_log(GENERAL, "Shop", "removed the "+ policy + " policy.", UNPAID);
   }
   map_delete(_new_policies, policy);
   save_policies();
   save_new_policies();
}
void add_policy_suggest(string name, string text, string mgr, int type)
{
   if (previous_object() && previous_object() != find_object(_mgr_office))
   {
      LOG_ERROR("office.c", "add_policy_suggest("+name+","+text+","+mgr+")");
      return;
   }
   load_new_policies();
   if (!sizeof(_new_policies)) _new_policies = ([ name:POLICY_MAP ]);
   else _new_policies += ([ name:POLICY_MAP ]);
   load_policies();
   if (sizeof(_policies) && _policies[name]) text = _policies[name][0];
   _new_policies[name][POLICY_TIME] = time();
   _new_policies[name][POLICY_MGR] = mgr;
   _new_policies[name][POLICY_TEXT] = text;
   _new_policies[name][POLICY_TYPE] = type;
   do_policy_vote(mgr, name, "y");
   clear_policies();
   save_new_policies();
}
private int do_policy_vote(string mgr, string policy, string decision)
{
   int managers;
   load_new_policies();
   if (!m_sizeof(_new_policies) || !_new_policies[policy])
   {
      tell_object(this_player(), "There is no such policy pending!\n");
      return 1;
   }
   if (member_array(mgr, _new_policies[policy][POLICY_FOR]) != -1 ||
     member_array(mgr, _new_policies[policy][POLICY_AGAINST]) != -1 )
   {
      tell_object(this_player(), "You have already voted on this policy!\n");
      return 1;
   }
   if (decision == "y")
   {
      _new_policies[policy][POLICY_FOR] += ({mgr});
      tell_object(this_player(), "You vote for the " + policy+ " policy.\n");
   }
   else
   {
      _new_policies[policy][POLICY_AGAINST] += ({mgr});
      tell_object(this_player(), "You vote against the "+
         policy+ " policy.\n");
   }
   shop_log(GENERAL, mgr, "voted on the "+ policy + " policy.", PAID);
   save_new_policies();
   managers = sizeof(get_managers()) + sizeof(get_retired());
   if (sizeof(_new_policies[policy][POLICY_FOR]) > managers / 2)
      add_policy(policy);
   else if (sizeof(_new_policies[policy][POLICY_AGAINST]) >= managers / 2)
      remove_policy(policy);
   return 1;
}
string get_stock_policy() { return copy(_stock_policy); }
private void remove_policy(string policy)
{
   load_new_policies();
   PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR],
     "Tarnach Fendertwin", "Policy proposition - "+ policy, "",
     "Your proposition has been rejected by majority vote.\n");
   shop_log(GENERAL, "Shop", "rejected the "+ policy + " policy.\n", UNPAID);
   map_delete(_new_policies, policy);
   save_new_policies();
}

==================================================
FILE: shops/player_shop/office_code/review.c
==================================================

private void monthly_review()
{
   int amount = calc_pay(),
       bonus_divisor = 0,
       cabinet_cost = (_num_cabinets - MIN_CABINETS) * CABINET_COST,
       pay;
   float pay_multiplier = 1.0;
   string *emps = m_indices(_employees);
   log_file("/log/PLAYER_SHOP", "%s: %s entered monthly review (review.c)\n",
      ctime(time()), _very_short);
   if (cabinet_cost)
   {
      adjust_profit(_proprietor, -cabinet_cost);
      shop_log(ACCOUNTS, _proprietor,
         "paid "+ MONEY_HAND->money_value_string(cabinet_cost,
         _place) + " for the rent of " + (_num_cabinets - MIN_CABINETS) +
         " cabinets", UNPAID);
   }
   if (_accounts["profit"] < 0) adjust_bonus("Shop",_accounts["profit"]);
   if (amount > _accounts["profit"])
      pay_multiplier = _accounts["profit"] / amount;
   foreach (string word in emps)
   {
      if (!_employees[word][EMP_PAY]) continue;
      pay = to_int(_employees[word][EMP_PAY] * pay_multiplier);
      if (!(_employees[word][EMP_POINTS] & NPC))
      {
         BANK_HANDLER->adjust_account(word,
            BANKS[_employees[word][EMP_BANK]][1], pay );
         PLAYER_SHOP->auto_mail(word, _proprietor, "Pay advice for "+
            _last_month, "", sprintf("For your work during %s, you have been "
            "paid a total of %s.  Keep up the good work.\n--\n%s "
            "(proprietor)\n", _last_month, MONEY_HAND->money_value_string(pay,
            _place ), _proprietor));
      }
      else _employees[word][EMP_POINTS] = EMPLOYEE + NPC;
      shop_log(ACCOUNTS, _proprietor, "paid "+ MONEY_HAND->
        money_value_string(pay, _place)+ " to "+ cap_name(word), UNPAID);
      _employees[word][EMP_PAY] = 0;
      _accounts["profit"] -= pay;
   }
   _bonus += _accounts["bonus"];
   if (_bonus < 0)
   {
      _accounts["bonus"] = _bonus;
      _bonus = 0;
   }
   else _accounts["bonus"] = 0;
   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS]) continue;
      if (!test_prop(word, _very_short+ " handbook")) continue;
      if (_employees[word][EMP_POINTS] & MANAGER)
      {
         bonus_divisor += 4;
      }
      else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
         _eom == word)
      {
         bonus_divisor += 3;
      }
      else
      {
         bonus_divisor += 2;
      }
   }
   if (!bonus_divisor) _bonus_val = _bonus;
   else _bonus_val = (_bonus * 2) / bonus_divisor;
   _got_bonus = ({});
   _eom = sort_array(get_employees(),
      (: _employees[$2][EMP_EOM] - _employees[$1][EMP_EOM] :))[0];
   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS])
      {
         _employees[word][EMP_NOBONUS]--;
         _got_bonus += ({word});
      }
      _employees[word][EMP_EOM] = 0;
   }
   employee_log(_eom, _last_month+ "'s Employee Of The Month");
   add_board_message("Bonuses for "+ _last_month,
      sprintf("Based on the bonus fund of %s for %s, the following "
      "bonuses have been awarded:\n\n     Managers    - %s\n     Supervisors"
      " - %s\n     Employees   - %s\n\n%s's Employee Of The Month was %s.  "
      "Well done to you.\n", MONEY_HAND->money_value_string(_bonus, _place),
      _last_month, MONEY_HAND->money_value_string(_bonus_val * 2, _place),
      MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
      MONEY_HAND->money_value_string(_bonus_val, _place), _last_month,
      cap_name(_eom)));
   if (_bonus)
   {
      shop_log( ACCOUNTS, _proprietor, "paid out "+
        MONEY_HAND->money_value_string(_bonus, _place)+
        " in bonuses for "+ _last_month, UNPAID );
   }
   if (_eom == _shopkeeper->query_name())
   {
      _bonus -= to_int(_bonus_val * 1.5);
      shop_log(GENERAL, _eom, "claimed "+
         MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
         UNPAID);
   }
   else
   {
      _bonus -= _bonus_val;
      shop_log(GENERAL, _shopkeeper->query_name(), "claimed "+
         MONEY_HAND->money_value_string(_bonus_val, _place), UNPAID);
   }
   if (_bonus < 0) _bonus = 0;
   _last_month = _review_month;
   _call_review = 0;
   save_me();
   save_emps();
}
private void review_employees()
{
   int prom = FALSE,
       prom_number,
       managers,
       time = time();
   string *promos = ({}),
          promopost,
          *emps = _retired + m_indices(_employees);
   log_file("/log/PLAYER_SHOP", "%s: %s entered review_employees (review.c)\n",
      ctime(time()), _very_short);
   foreach (string word in emps)
   {
      if (!test_player(word))
      {
         if (_employees[word][EMP_POINTS] & NPC) continue;
         fire_them(_proprietor, word, "not existing");
      }
      else if (test_cre(word))
         fire_them(_proprietor, word, "being a creator");
      else if (test_prop(word,"no score") &&
         _employees[word][EMP_POINTS] & SUPERVISOR )
      {
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
         save_emps();
         PLAYER_SHOP->auto_mail(word, _proprietor, "Demotion", "",
         "This is to advise you that, due to you having a creator alt, "
         "you have today been demoted.\n");
         employee_log(word, "Demoted by "+ _proprietor);
         shop_log(PERSONNEL, _proprietor, "demoted "+ cap_name(word), UNPAID);
      }
      if (!test_prop(word, _very_short+ " handbook"))
      {
         _employees[word][EMP_PAY] = 0;
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
      }
   }
   foreach (string word in get_managers())
      if ((time - _times[word]) > (60*60*24*MGR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*MGR_WARN) &&
         !_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
           "", "It has come to my attention that you have now been "
           "inactive for over " + MGR_WARN+ " days.  As you are a manager, "
           "you are required to meet certain levels of attendance.  "
           "You are now in serious danger of being demoted without "
           "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
               cap_name(word) + " about inactivity", UNPAID);
      }
   foreach(string word in sort_array(get_supervisors(),
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
      if (time - _times[word] > (60*60*24*SPR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*SPR_WARN) &&
        !_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
            "", "It has come to my attention that you have now been "
            "inactive for over "+ SPR_WARN+ " days.  As you are a supervisor, "
            "you are required to meet certain levels of attendance.  "
            "You are now in serious danger of being demoted without "
            "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
            cap_name(word) + " about inactivity", UNPAID);
      }
      else
      {
         prom_number = (_max_emp * PERCENT_M) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * MANAGER_POINTS) &&
           sizeof(get_managers()) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            set_employee(word, MANAGER);
            shop_log(PERSONNEL, _proprietor, "promoted "+
               cap_name(word)+ " to manager", UNPAID);
            employee_log(word, "Promoted to manager");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!",
              "", "Congratulations!  You've been promoted to manager "
              "of "+ _shop_name+ ".  You'll find that you can now enter "
              "the managers' office.  Please remember to use the \"memo\" "
              "facility from there to discuss any major admin points with "
              "other managers.  This includes hiring, firing, and so on.\n");
            promos += ({word});
            prom = TRUE;
         }
      }
   foreach(string word in sort_array(get_employees(),
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
   {
      if (_employees[word][EMP_POINTS] & NPC) continue;
      if (time - _times[word] > (60*60*24*EMP_FIRE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         fire_them(_proprietor, word, "serious inactivity");
         continue;
      }
      if (time - _times[word] > (60*60*24*EMP_WARN))
      {
         if (!_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
         {
            PLAYER_SHOP->auto_mail(word, _proprietor, "Inactivity",
              "", "It has come to my attention that you have now been "
              "inactive for over "+ EMP_WARN+ " days.  Unless this "
              "situation is resolved, the management may have no option "
              "but to terminate your employment.\n---\n"+ _proprietor+
              " (proprietor)\n");
            _employees[word][EMP_INACTIVE] = TRUE;
            shop_log(PERSONNEL, _proprietor, "warned "+
              cap_name(word)+ " about inactivity", UNPAID);
            employee_log(word, "Warned about inactivity");
         }
      }
      else
      {
         prom_number = (_max_emp * PERCENT_S) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * SUPER_POINTS) &&
           sizeof( get_supervisors() ) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            if(_employees[word][EMP_POINTS] & CLOCKED_IN)
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) +
                 EMPLOYEE+ SUPERVISOR + CLOCKED_IN;
            else
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) +
                 EMPLOYEE+ SUPERVISOR;
            shop_log(PERSONNEL, _proprietor, "promoted "+
              cap_name(word)+ " to supervisor", UNPAID);
            employee_log(word, "Promoted to supervisor");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!", "",
              "Congratulations!  You've been promoted to supervisor "
              "of "+ _shop_name+ ".  You will now be able to use your "
              "newly acquired supervisor commands.\n");
            promos += ({word});
            prom = TRUE;
         }
      }
   }
   if (prom)
   {
      promopost = "The following employees have been promoted:\n\n";
      foreach (string word in promos)
         promopost += sprintf("     %s has been promoted to %s\n",
           cap_name(word), (_employees[word][EMP_POINTS] & MANAGER)?
           "manager":"supervisor");
      promopost += "\nCongratulations!\n";
      add_board_message("Promotions", promopost);
   }
   foreach (string word in m_indices(_baddies))
      if (time - _baddies[word][BAD_TIME] > (60*60*24*BAN_LENGTH))
         remove_baddie( word );
   foreach (string word in m_indices(_declined))
      if (time - _declined[word] > (60*60*24*DECLINE_LENGTH))
         remove_declined(word);
   remove_call_out(_call_hire_list);
   _call_hire_list = call_out((: check_hire_list() :), 5);
   save_emps();
   managers = sizeof(get_managers()) + sizeof(get_retired());
   load_new_policies();
   if (sizeof(_new_policies))
   {
      foreach (string word in m_indices(_new_policies))
      {
         if (sizeof(_new_policies[word][POLICY_FOR]) > managers / 2)
         {
            add_policy(word);
         }
         else if (time - _new_policies[word][POLICY_TIME] > VOTE_TIMEOUT)
         {
            if (sizeof(_new_policies[word][POLICY_FOR]) >=
               sizeof(_new_policies[word][POLICY_AGAINST]))
            {
               add_policy(word);
            }
            else remove_policy(word);
         }
      }
   }
   clear_new_policies();
   load_history();
   foreach (string word in m_indices(_history))
   {
      if (!test_player(word) || test_cre(word) ||
        !_times[word] || _times[word] < (time - HIST_TIMEOUT))
      {
         map_delete(_times, word);
         map_delete(_history, word);
      }
   }
   save_hist();
   save_times();
}

==================================================
FILE: shops/player_shop/office_code/save.c
==================================================

private void do_save()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving shop data to %s/.\n", _savedir);
#endif
   unguarded((: save_object, _savedir+ "shop_data" :));
}
private void do_save_applicants()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving applications data to %s.\n",
     _savedir+ "applications");
#endif
   unguarded((: write_file, _savedir+ "applications",
     save_variable(_applicants), 1 :));
   clear_applicants();
}
private void do_save_emps()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving employee data to %s.\n",
     _savedir+ "employees");
#endif
   unguarded((: write_file, _savedir+ "employees",
     save_variable(_employees), 1 :));
}
private void do_save_hist()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving history data to %s.\n",
     _savedir+ "history");
#endif
   unguarded((: write_file, _savedir+ "history",
     save_variable(_history), 1 :));
   clear_history();
}
private void do_save_new_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving new policies data to %s.\n",
     _savedir+ "new_policies");
#endif
   unguarded((: write_file, _savedir+ "new_policies",
     save_variable(_new_policies), 1 :));
   _call_newpols_clear = call_out((: _new_policies= 0 :), CLEAR_DELAY);
}
private void do_save_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving policies data to %s.\n",
     _savedir+ "policies");
#endif
   unguarded((: write_file, _savedir+ "policies",
      save_variable(_policies), 1 :));
   clear_policies();
}
private void save_list()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving chart list data to %s.\n",
     _savedir+ "list");
#endif
   unguarded((: write_file, _savedir+ "list",
     save_variable(_list), 1 :));
}
void save_register(mixed *money)
{
   _register = money;
   save_me();
}
private void save_times()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving times data to %s.\n",
     _savedir+ "times");
#endif
   unguarded((: write_file, _savedir+ "times",
     save_variable(_times), 1 :));
}
