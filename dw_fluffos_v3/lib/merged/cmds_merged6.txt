# Total Tokens: 25318
# Total Files Merged: 27
# Total Characters: 84474

ayer/whois.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd(object *obs) {
  write("That is " + (string)(DIR_PLAYER_CMDS +"/who")->
        who_line(this_player()->expand_nickname(obs[0]),
                 this_player()->query_creator(),
                 this_player()->query_cols()) +".\n" );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1) :),
            this_player()->query_name(), (: cmd(({this_player()})) :) });
}

==================================================
FILE: /lib/cmds/player/group_cmds/assist.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_assist( object member, string group );
int do_unassist( object member, string group );
int do_assist_list(string group);
void create() {
   ::create();
   add_group_sub_command( "assist", "<indirect:living'member'>",
      (: do_assist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "unassist", "<indirect:distant-living'member'>",
      (: do_unassist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "assist", "list",
      (: do_assist_list( $6 ) :) );
   set_membership_required( "assist", 0, 1 );
}
int do_assist_list( string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( sizeof( assisting ) )
   {
      tell_object( this_player(), "You are currently "
         "assisting " + query_multiple_short( assisting ) +
         ".\n" );
      return 1;
   }
   add_failed_mess("You are not assisting anyone.\n");
   return 0;
}
int do_assist( object member, string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( !GROUP->is_member( group, member ) ) {
      add_failed_mess( member->the_short() + " is not a "
         "member of your group.\n" );
      return 0;
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      add_failed_mess( "You are already assisting " + member->the_short() +
         ".\n" );
      return 0;
   }
   if( sizeof( assisting ) >= MAX_PEOPLE_YOU_CAN_ASSIST ) {
      add_failed_mess( "You can not assist any more people.\n" );
      return 0;
   }
   add_succeeded_mess( "$N begin$s keeping a close eye on $I.\n",
                       ({ member }) );
   member->add_assister( this_player() );
   return 1;
}
int do_unassist( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      member->remove_assister( this_player() );
      add_succeeded_mess( ({ "You stop assisting " + member->the_short() +
         ".\n", "" }) );
      return 1;
   }
   add_failed_mess("You are not assisting $I.\n", ({ member }));
   return 0;
}
string query_help_string_for( string sub ) {
   return "With this command you can guard a group member.  If the "
      "person you're guarding gets attacked, you will automatically "
      "join the fight after a delay.  The length of the delay depends "
      "on how many people you're guarding at the moment.  Use "
      "\"list\" to see who you are currently assisting.  To stop "
      "assisting someone, use \"group assist <someone>\" again "
      "on that person.\n";
}

==================================================
FILE: /lib/cmds/player/group_cmds/base_group.c
==================================================

#define GROUP_ARRAY_SIZE      3
#define GROUP_ARRAY_FUNCTION  0
#define GROUP_ARRAY_MEM_REQ   1
#define GROUP_ARRAY_LDR_REQ   2
mapping _commands;
void create() {
   _commands = ([ ]);
}
int query_group_sub_command_amount() {
   return sizeof( _commands );
}
int add_group_sub_command( string verb, string pattern,
   function cmd_function ) {
   if( !_commands[ verb ] ) {
      _commands += ([ verb : ([ pattern : ({ cmd_function, 0, 0 }) ]) ]);
      return 1;
   }
   if( _commands[ verb ][ pattern ] ) {
      return 0;
   }
   _commands[ verb ] += ([ pattern : ({ cmd_function, 0, 0 }) ]);
   return 1;
}
varargs int remove_group_sub_command( string verb, string pattern ) {
   if( undefinedp( pattern ) ) {
      if( !_commands[ verb ] ) {
         return 0;
      }
      map_delete( _commands, verb );
      return 1;
   }
   if( !_commands[ verb ] || !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   map_delete( _commands[ verb ], pattern );
   return 1;
}
string *query_group_sub_command_verbs() {
   return keys( _commands );
}
string *query_group_sub_command_patterns( string verb ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   return keys( _commands[ verb ] );
}
varargs function *query_group_sub_command_function( string verb, string
   pattern ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( undefinedp( pattern ) ) {
      return values( _commands[ verb ] );
   }
   if( !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_FUNCTION ];
}
int set_membership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_MEM_REQ ] = flag;
   }
   return 1;
}
int set_leadership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_LDR_REQ ] = flag;
   }
   return 1;
}
varargs int query_membership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_MEM_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ];
}
varargs int query_leadership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_LDR_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ];
}

==================================================
FILE: /lib/cmds/player/group_cmds/create.c
==================================================

#include <group_handler.h>
#include <player_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_create( string name );
void create() {
   ::create();
   add_group_sub_command( "create", "<string'name'>", (: do_create( $4[ 0 ] ) :) );
}
int do_create( string name ) {
   string short;
   name = strip_colours(name);
   if( this_player()->query_group() ) {
      return notify_fail( "You are already a member of " +
         this_player()->query_group() + ".\n" );
   }
   if( GROUP->is_group( name ) ) {
      return notify_fail( "Such a group already exists.\n" );
   }
   short = name;
   name = GROUP->short_to_name( short );
   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }
   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }
   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   if( !GROUP->create_group( name, this_player() ) ) {
      return notify_fail( "You failed to create the group.\n" );
   }
   GROUP->set_group_short( name, short );
   this_player()->add_succeeded_mess( this_object(), "$N begin$s "
      "an adventuring group.\n" );
   GROUP->add_member( name, this_player() );
   GROUP->set_leader( name, this_player() );
   return 1;
}
string query_help_string_for( string sub_command ) {
   if( sub_command != "create" ) {
      return 0;
   }
   return "This sub-command creates a new group and sets you as the "
      "leader of it.  You create it by typing \"group create <name>\" "
      "with <name> being the name of your group.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/emote.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_emote( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "emote", "<string'message'>",
      (: do_group_emote( $4[ 0 ], $6 ) :) );
   set_membership_required( "emote", 0, 1 );
}
int do_group_emote( string message, string group ) {
   message = replace( message, ({ "%^", "", }) );
   GROUP->notify_group( group, this_player(), ({
      "You emote: " + this_player()->query_cap_name() + " " + message,
      this_player()->query_cap_name() + " " + message
      }) );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to emote on the group "
      "channel.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/follow.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_follow( object *who, string group, int unfollow );
void create() {
   ::create();
   add_group_sub_command( "follow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 0 ) :) );
   add_group_sub_command( "unfollow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 1 ) :) );
   set_membership_required( "follow", 0, 1 );
   set_membership_required( "unfollow", 0, 1 );
}
int do_group_follow( object *who, string group, int unfollow ) {
   int size;
   string fault_message;
   object *what_not, *follow, *already_following;
   fault_message = "";
   who -= ({ 0 });
   if( member_array( this_player(), who ) != -1 ) {
      who -= ({ this_player() });
      fault_message += "You cannot follow yourself.  ";
   }
   follow = ( who & GROUP->members_of( group ) );
   what_not = who - follow;
   switch( unfollow ) {
      case 1:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) == -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are not following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      case 0:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) != -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are already following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      default:
         printf( "Barf.\n" );
   }
   size = sizeof( what_not );
   if( size ) {
      fault_message += "$C$" + query_multiple_short( what_not, "the" ) +
         ( size > 1 ? " are not members of your group" :
         " is not a member of your group" ) + ".  ";
   }
   fault_message += "\n";
   if( sizeof( follow ) ) {
      GROUP->handle_group_follow( group, this_player(), follow,
         unfollow, 0 );
      return 1;
   } else {
      tell_object( this_player(), fault_message );
      return 1;
   }
}
string query_help_string_for( string sub ) {
   switch( sub ) {
      case "follow":
         return "This command lets you follow your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
      case "unfollow":
         return "This command lets you stop following your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
   }
   return 0;
}

==================================================
FILE: /lib/cmds/player/group_cmds/history.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_channel_history();
void create() {
   ::create();
   add_group_sub_command( "history", "", (: do_channel_history() :) );
   set_membership_required( "history", 0, 1 );
}
int do_channel_history() {
   this_player()->display_group_history();
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you recap what has been said on your "
      "group's channel.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/invite.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_invite( object person, string group );
void create() {
   ::create();
   add_group_sub_command( "invite", "<indirect:living'person'>", (:
      do_invite( $1, $6 ) :) );
   set_membership_required( "invite", 0, 1 );
   set_leadership_required( "invite", 0, 1 );
}
int do_invite( object *persons, string group ) {
   object person;
   persons -= ({ this_player() });
   if( !sizeof( persons ) ) {
      return notify_fail( "I would come up with "
         "something witty, but I'm not going to "
         "bother.\n" );
   }
   if( sizeof( persons ) > 1 ) {
      return notify_fail( "You can only invite one person "
         "at a time.\n" );
   }
   person = persons[ 0 ];
   if( sizeof( GROUP->invitations_of( group ) ) >=
      MAX_INVITATIONS_PER_PARTY_AT_ONCE ) {
      return notify_fail( "You can only have a total of " +
         MAX_INVITATIONS_PER_PARTY_AT_ONCE + " invitations pending "
         "at one time.\n" );
   }
   if( GROUP->is_invited( group, person ) ) {
      return notify_fail( person->the_short() + " has "
         "already been invited to your group.\n" );
   }
   if( GROUP->is_member( group, person ) ) {
      return notify_fail( person->the_short() + " is "
         "already a member of your group.\n" );
   }
   if( !userp( person ) ) {
      return notify_fail( "You cannot invite " + person->the_short() +
         " to your group.\n" );
   }
   GROUP->add_invite( group, person );
   GROUP->notify_group( group, this_player(), person->query_cap_name() +
      " has been invited by " + this_player()->query_cap_name() + ".  " );
   tell_object( person, "You have been invited by " +
      this_player()->a_short() + " to join " +
      this_player()->query_possessive() + " group.  "
      "You have " + INVITE_TIMEOUT + " seconds to join "
      "the group before the invitation is withdrawn.  Use "
      "\"group join " + this_player()->query_name() + "\" "
      "to join.\n" );
   if( person->query_group() ) {
      tell_object( person, "%^BOLD%^Note that accepting the invitation "
         "will force you to leave your current group.%^RESET%^\n" );
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "With this command the leader of a group can invite new "
      "members to the group.  A person who has been invited must then "
      "use the \"join\" command to actually become a member.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/join.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_join( object member );
void create() {
   ::create();
   add_group_sub_command( "join", "<indirect:living'existing member'>",
      (: do_join( $1[ 0 ] ) :) );
}
int do_join( object member ) {
   string his_group, my_group;
   his_group = member->query_group();
   if( this_player() == member ) {
      return notify_fail( "I could come up with something witty, "
         "but I'm not going to bother.\n" );
   }
   if( !his_group ) {
      return notify_fail( member->the_short() + " is not a member "
         "of any group.\n" );
   }
   if( !GROUP->is_invited( his_group, this_player() ) ) {
      return notify_fail( "You have not been invited to that "
         "group.\n" );
   }
   if( sizeof( GROUP->members_of( his_group ) ) >= MAX_PEOPLE_PER_PARTY ) {
      return notify_fail( "The group you are trying to join is "
         "full.\n" );
   }
   my_group = this_player()->query_group();
   if( my_group && ( my_group == his_group ) ) {
      return notify_fail( "You are already a member of "
         "that group.\n" );
   }
   if( my_group ) {
      if( !GROUP->remove_member( my_group, this_player() ) ) {
         return notify_fail( "You fail to leave your previous "
            "group.. for some reason.\n" );
      }
      tell_object( this_player(), "%^BOLD%^You leave your current "
         "group behind to join a new one.%^RESET%^\n" );
   }
   if( !GROUP->add_member( his_group, this_player() ) ) {
      return notify_fail( "You failed to join the group "
         "for some weird reason.\n" );
   }
   return 1;
}
string query_help_string_for( string sub_command ) {
   switch( sub_command ) {
      case "join":
         return "This command lets you join an existing group.  To join, "
            "type \"group join <existing member>\" where "
            "<existing member> is someone who is already a member of the "
            "group you wish to be a part of.  You must be invited to a "
            "group by its leader before you can join.";
      default:
         return 0;
   }
}

==================================================
FILE: /lib/cmds/player/group_cmds/kick.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_kick_member( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "kick", "<indirect:any-living'member'>",
      (: do_kick_member( $1[ 0 ], $6 ) :) );
   set_membership_required( "kick", 0, 1 );
   set_leadership_required( "kick", 0, 1 );
}
int do_kick_member( object member, string group ) {
   if( this_player() == member ) {
      this_player()->new_parser(
         "skick " + this_player()->query_name() );
      return 1;
   }
   if( !GROUP->is_member( group, member ) ) {
      return notify_fail( member->the_short() + " is not a member "
         "of your group.\n" );
   }
   GROUP->notify_group( group, this_player(), ({
      "You kick " + member->query_cap_name() + " from your ranks.",
      this_player()->query_cap_name() + " has kicked " +
      member->the_short() + " from the group." }) );
   GROUP->remove_member( group, member );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you boot out offending members in "
      "your group.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/leader.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_leader( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "leader", "<indirect:any-living'member'>",
      (: do_leader( $1[ 0 ], $6 ) :) );
   set_membership_required( "leader", 0, 1 );
   set_leadership_required( "leader", 0, 1 );
}
int do_leader( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Oh, good thinking, sparky.\n" );
   }
   if( member->query_group() != group ) {
      return notify_fail( member->the_short(1) + " is not in your "
         "group.\n" );
   }
   GROUP->set_leader( group, member, this_player() );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to relinquish command and "
      "appoint a new leader for the group.  It does not remove "
      "your membership of the group, but you lose all special "
      "privileges granted to leaders.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/leave.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_leave( string group );
void create() {
   ::create();
   add_group_sub_command( "leave", "", (: do_leave( $6 ) :) );
   set_membership_required( "leave", 0, 1 );
}
int do_leave( string group ) {
   if( !GROUP->remove_member( this_player()->query_group(),
      this_player() ) ) {
      return notify_fail( "You failed to leave the group "
         "for some odd-ball reason.\n" );
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to leave your current "
      "group.  If you're the leader, a new one will be "
      "chosen at random from the remaining members.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/list.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
string *leader_adjectives =
   ({
      "daring",
      "heroic",
      "brave",
      "bold",
      "courageous",
      "dauntless",
      "fearless",
      "intrepid",
      "valiant",
      "awesome",
      "stalwart"
   });
string *follower_messages =
   ({
      " and also includes",
      " and features such prominent figures as",
      ", whose supporters consist of",
      " and features such renowned names as",
   });
int do_list_groups(string person);
void create() {
   ::create();
   add_group_sub_command( "list", "", (: do_list_groups(0) :) );
   add_group_sub_command( "list", "[with] <string'player'>",
                           (: do_list_groups($4[0]) :) );
}
int do_list_groups(string person) {
   string group, *groups, prefix, suffix, message, adjective, colour, stats;
   object *members, leader;
   int num_groups, num_members;
   object person_ob;
   groups = sort_array( GROUP->query_groups(),
       (: strcmp( lower_case(GROUP->query_group_short( $1 )),
            lower_case(GROUP->query_group_short( $2 )) ) :) );
   num_groups = sizeof( groups );
   if (person) {
      person = this_player()->expand_nickname(person);
      person_ob = find_player(person);
      if (!person_ob) {
         add_failed_mess("Sorry, " + person + " is not logged on.\n");
         return 0;
      }
   }
   if( !num_groups )
   {
      return notify_fail( "There are currently no active groups.\n" );
   }
   prefix = "$I$+8,+0=  + ";
   suffix = "$I$-8,-0=\n";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   message = "";
   num_members = 0;
   num_groups = 0;
   foreach( group in groups )
   {
      leader = GROUP->leader_of( group );
      members = GROUP->members_of( group );
      if( !leader || !sizeof( members ) )
      {
         continue;
      }
      if (!person_ob || person_ob == leader ||
          member_array(person_ob, members) != -1) {
         num_members += sizeof( members );
         message += prefix;
         message += colour + GROUP->query_group_short( group ) +
            "%^RESET%^ is led by ";
         members -= ({ leader });
         adjective = leader_adjectives[ random( sizeof(
                                                       leader_adjectives ) ) ];
         message += "the " + adjective + " %^BOLD%^" +
            leader->query_short(1) + "%^RESET%^";
         if( sizeof( members ) )
         {
            message += follower_messages[ random( sizeof( follower_messages )
               ) ] + " %^BOLD%^" + query_multiple_short( members->short(1) ) +
               "%^RESET%^.";
         }
         else
         {
            message += " and has no other members.";
         }
         message += suffix;
         num_groups++;
      }
   }
   switch( num_groups )
   {
      case 0:
         if (!person) {
            stats = "There are currently no groups, ";
         } else {
            add_failed_mess("There are no groups with " + person +
                            " in them.\n");
            return 0;
         }
         break;
      case 1:
         stats = "There is currently %^BOLD%^one%^RESET%^ active group, ";
         break;
      default:
         stats = "There are currently %^BOLD%^" + query_num( num_groups ) +
            "%^RESET%^ active groups, ";
         break;
   }
   stats += "with a total number of %^BOLD%^" +
      query_num( num_members ) + "%^RESET%^ persons:\n";
   tell_object( this_player(), stats + message );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you list all currently active "
      "groups and their members and leaders.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/rename.c
==================================================

#include <group_handler.h>
#include <player_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_rename_group( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "rename", "<string'new name'>",
      (: do_rename_group( $4[ 0 ], $6 ) :) );
   set_membership_required( "rename", 0, 1 );
   set_leadership_required( "rename", 0, 1 );
}
int do_rename_group( string new_group, string group ) {
   string short;
   string name;
   if( GROUP->is_group( new_group ) ) {
      return notify_fail( new_group + " already exists.\n");
   }
   short = new_group;
   name = GROUP->short_to_name( short );
   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }
   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }
   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   if (!GROUP->rename_group( group, name)) {
      add_failed_mess("Not allowed to rename the group.\n");
      return 0;
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you rename a group to something more "
          "exciting.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/report.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
#define GROUP_CMD_STATUS  ( GROUP_SUB_CMDS_DIR+"status" )
int do_report( string group );
void create() {
   ::create();
   add_group_sub_command( "report", "", (: do_report( $6 ) :) );
   set_membership_required( "report", 0, 1 );
}
int do_report( string group ) {
   string message;
   message = this_player()->query_cap_name() + " reports that " +
      this_player()->query_pronoun() + " is ";
   message += GROUP_CMD_STATUS->generate_status_message( this_player() );
   GROUP->notify_group( group, this_player(), ({
      "You report:  " + message,
      message
      }) );
   return 1;
}
string query_help_string_for( string sub_command ) {
   return "This command lets you report your current "
      "condition on the group's channel.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/say.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_say( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "say", "<string'message'>",
      (: do_group_say( $4[ 0 ], $6 ) :) );
   set_membership_required( "say", 0, 1 );
}
int do_group_say( string message, string group ) {
   message = replace( message, ({ "%^", "" }) );
   GROUP->notify_group( group, this_player(),
      this_player()->query_cap_name() + ": " + message );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to say something on "
      "the group's channel.";
}

==================================================
FILE: /lib/cmds/player/group_cmds/shields.c
==================================================

#include <command.h>
#include <group_handler.h>
#define CMD_SHIELDS ( DIR_PLAYER_CMDS "/shields" )
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_shields( object *members, string group );
void create()
{
   ::create();
   add_group_sub_command( "shields", "", (: do_shields( 0, $6 ) :) );
   add_group_sub_command( "shields", "<indirect:any-living'member'>",
      (: do_shields( $1, $6 ) :) );
   set_membership_required( "shields", 0, 1 );
}
int do_shields( object *suggested_members, string group )
{
   object cmd_shields, member, *members, *check_for;
   string shields, mess, colour;
   cmd_shields = load_object( CMD_SHIELDS );
   if( !cmd_shields )
   {
      return notify_fail( "Cannot find the \"shield\" command.  "
         "Please bug report this group command.\n" );
   }
   check_for = members = GROUP->members_of( group );
   if( sizeof( suggested_members ) )
   {
      check_for = ( suggested_members & members );
   }
   if( !sizeof( check_for ) )
   {
      return notify_fail( "$C$" + query_multiple_short( suggested_members ) +
         ( sizeof( suggested_members ) > 1 ? " are not members " : " is not "
         "a member " ) + "of your group.\n" );
   }
   mess = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   foreach( member in check_for )
   {
		 if(!member)
			 continue;
		 shields = cmd_shields->construct_shield_message( member, 1 );
		 if( sizeof( shields ) ) {
         mess += "Arcane protection for " + colour +
					 member->query_cap_name() + "%^RESET%^:-\n";
         mess += shields + "\n";
		 } else {
			 mess += colour + member->query_cap_name() +
				 "%^RESET%^ has no arcane protection.\n\n";
		 }
   }
   if( sizeof( mess ) > 2 && mess[ sizeof( mess ) - 1 ] == '\n' )
   {
      mess = mess[ 0..( sizeof( mess ) - 2 ) ];
   }
   tell_object( this_player(), mess );
   return 1;
}
string query_help_string_for( string what )
{
   return "The \"group shields\" command allows you to view "
      "the arcane protection of all or some of your group's "
      "members.  You can either specify no arguments, or "
      "you can include the names of only those members "
      "whose protection you wish to check.\n";
}

==================================================
FILE: /lib/cmds/player/group_cmds/status.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_status( string verbose, string group );
int display_verbose_group_status( string group );
int display_brief_group_status( string group );
string calc_idle_string( object player );
string generate_status_message( object player );
string convert_percentage_to_colour( int percentage );
string convert_percentage_to_hp_message( int percentage );
string convert_percentage_to_gp_message( int percentage );
void create() {
   ::create();
   add_group_sub_command( "status", "<word'brief|verbose'>",
      (: do_group_status( $4[ 0 ], $6 ) :) );
   add_group_sub_command( "status", "",
      (: do_group_status( "default", $6 ) :) );
   set_membership_required( "status", 0, 1 );
}
int do_group_status( string verbose, string group ) {
   int use_verbose;
   switch( verbose ) {
      case "default":
         use_verbose = this_player()->query_verbose( "score" );
         break;
      case "verbose":
         use_verbose = 1;
         break;
      case "brief":
         use_verbose = 0;
         break;
      default:
         return notify_fail( "[ERROR]: Unknown return value from verbose information.\n" );
   }
   switch( use_verbose ) {
      case 1:
         return display_verbose_group_status( group );
      case 0:
         return display_brief_group_status( group );
      default:
         return notify_fail( "[ERROR]: This shouldn't happen.\n" );
   }
}
int display_verbose_group_status( string group ) {
   int size, cols;
   object member, *members, *assisting;
   string pronoun, message, status, short, colour, idle;
   cols = this_player()->query_cols();
   short = GROUP->query_group_short( group );
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   message = "\n";
   message += sprintf( "   %'+'*|s\n", cols - 3, "|" + short + "|" );
   size = sizeof( message ) - 3;
   message = replace( message, ({ short, ( colour + short +
      "%^RESET%^" ) }) );
   message += "\n";
   message += sprintf( "%' '*|s\n",
      cols - 3,
      "The group was started on " +
         ctime( GROUP->query_start_time( group ) ) + "." );
   message += "\n";
   members = GROUP->members_of( group );
   message += sprintf( "   %-=*s\n\n",
      size, "The group has %^BOLD%^" + query_num( sizeof( members ) ) +
      "%^RESET%^ " + ( sizeof( members ) > 1 ? "members" : "member" ) +
      ":" );
   if (!members) {
      message += "Very unhappy group.\n";
   } else {
      foreach( member in members ) {
          if(!member)
             continue;
          status = "$I$+8,+0=   " + colour;
          status += capitalize( member->query_cap_name() ) + "%^RESET%^" +
             " is " + generate_status_message( member ) + "  ";
          pronoun = member->query_pronoun();
          idle = calc_idle_string( member );
          if( idle ) {
             status += "  %^BOLD%^" + idle + ".%^RESET%^";
          }
          if( member == GROUP->leader_of( group ) ) {
             status += "  " + capitalize( pronoun ) + " is the " +
                colour + "current leader%^RESET%^ of the group.";
          }
          assisting = member->query_assisting();
          if( sizeof( assisting ) ) {
             status += "  " + capitalize( pronoun ) + " is assisting " +
                query_multiple_short( assisting, "one", 0, 1 ) + ".";
          }
          status += "$I$-8,-0=\n";
          message += status;
      }
   }
   tell_object( this_player(), message );
   return 1;
}
int display_brief_group_status( string group ) {
   object member, *others;
   string message, colour, idle;
   int my_gp, my_hp, my_max_hp, my_max_gp;
   message = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   others = GROUP->members_of( group ) - ({ this_player() });
   my_hp = this_player()->query_hp();
   my_gp = this_player()->query_gp();
   my_max_hp = this_player()->query_max_hp();
   my_max_gp = this_player()->query_max_gp();
   message += colour;
   message += capitalize( this_player()->query_cap_name() );
   message += "%^RESET%^; Hp: " + convert_percentage_to_colour( my_hp * 100 / my_max_hp ) +
      my_hp + "/" + my_max_hp + "%^RESET%^ Gp: " +
      convert_percentage_to_colour( my_gp * 100 / my_max_gp ) +
      my_gp + "/" + my_max_gp + "%^RESET%^.\n";
   foreach( member in others ) {
     if(!member)
       continue;
      message += colour;
      message += capitalize( member->query_cap_name() );
      message += "%^RESET%^ is " + generate_status_message( member );
      idle = calc_idle_string( member );
      if( idle ) {
         message += "  (" + idle + ")";
      }
      if( member == GROUP->leader_of( group ) ) {
         message += " (" + colour + "L%^RESET%^)";
      }
      if( member->query_property( "dead" ) ) {
         message += " (%^BOLD%^%^RED%^D%^RESET%^)";
      }
      message += "\n";
   }
   tell_object( this_player(), message );
   return 1;
}
string calc_idle_string( object player ) {
   int idle;
   if( !interactive( player ) ) {
      return "Net Dead";
   }
   idle = query_idle( player );
   if( idle < 15 ) {
      return 0;
   }
   return "Idle: " + ( idle / 60 ) + ":" + sprintf("%'0'2d", ( idle % 60 ));
}
string generate_status_message( object player ) {
   int hp_percentage, gp_percentage;
   hp_percentage = player->query_hp() * 100 / player->query_max_hp();
   gp_percentage = player->query_gp() * 100 / player->query_max_gp();
   return (
      convert_percentage_to_colour( hp_percentage ) +
      convert_percentage_to_hp_message( hp_percentage ) +
      "%^RESET%^ and " +
      convert_percentage_to_colour( gp_percentage ) +
      convert_percentage_to_gp_message( gp_percentage ) +
      "%^RESET%^." );
}
string query_help_string_for( string sub_command ) {
   return "The status sub-command displays vital statistics "
      "of your group's members.  Depending on your brief "
      "settings for \"score\", the command will either "
      "show the verbose statistics or prompt a brief "
      "display.  You can also force either version by "
      "adding the argument \"verbose\" or \"brief\".";
}
string convert_percentage_to_colour( int percentage ) {
   switch( percentage ) {
      case -1000..10: return "%^BOLD%^%^RED%^";
      case 11..20:    return "%^RED%^";
      case 21..30:    return "%^ORANGE%^";
      case 31..40:    return "%^YELLOW%^";
      case 41..50:    return "%^MAGENTA%^";
      case 51..60:    return "%^CYAN%^";
      case 61..70:    return "%^BOLD%^%^CYAN%^";
      case 71..80:    return "%^GREEN%^";
      case 81..90:    return "%^BOLD%^%^GREEN%^";
      case 91..100:   return "%^BOLD%^%^WHITE%^";
      default:        return "";
   }
}
string convert_percentage_to_hp_message( int percentage ) {
   switch( percentage ) {
      case -1000..0: return "perfectly healthy, for a ghost";
      case 1..5:     return "near death";
      case 6..10:    return "critically wounded";
      case 11..20:   return "seriously wounded";
      case 21..30:   return "heavily wounded";
      case 31..40:   return "badly wounded";
      case 41..50:   return "wounded";
      case 51..60:   return "slightly wounded";
      case 61..70:   return "injured";
      case 71..80:   return "slightly injured";
      case 81..89:   return "slightly hurt";
      case 90..94:   return "scratched";
      case 95..99:   return "almost unhurt";
      case 100:      return "unhurt";
      default:       return "ERROR";
   }
}
string convert_percentage_to_gp_message( int percentage ) {
   switch( percentage ) {
      case 0..10:    return "near unconscious";
      case 11..20:   return "severely fatigued";
      case 21..30:   return "highly fatigued";
      case 31..40:   return "very fatigued";
      case 41..50:   return "fatigued";
      case 51..60:   return "slightly fatigued";
      case 61..70:   return "confused";
      case 71..80:   return "slightly confused";
      case 81..90:   return "concentrated";
      case 91..99:   return "clear of mind";
      case 100:      return "refreshed";
      default:       return "ERROR";
   }
}
string convert_percentage_to_share_message( int percentage ) {
   switch( percentage ) {
      case 100:       return "all";
      case 95..99:    return "almost all";
      case 90..94:    return "a very large portion";
      case 80..89:    return "a large portion";
      case 70..79:    return "a major portion";
      case 60..69:    return "an above average portion";
      case 52..59:    return "a slightly above average portion";
      case 49..51:    return "an average portion";
      case 41..48:    return "a slightly below average portion";
      case 31..40:    return "a below average portion";
      case 21..30:    return "a minor portion";
      case 11..20:    return "a small portion";
      case 6..10:     return "a very small portion";
      case 1..5:      return "a miniscule portion";
      case 0:         return "next to none";
      default:        return "an ERRONEOUS portion ";
   }
}

==================================================
FILE: /lib/cmds/guild-race/gp.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_nroff_file("gp");
   set_command_name("gp");
}
int cmd() {
   int i, gp, max_gp, other_gp;
   gp = (int)this_player()->query_gp();
   max_gp = (int)this_player()->query_max_gp();
   write( "You have "+ gp +" ("+ max_gp +") guild points.\n" );
   for ( i = 0; i < sizeof( STD_SKILLS ); i += SKILL_ARR_SIZE ) {
      other_gp = (int)this_player()->query_skill_bonus( STD_SKILLS[ i ]
            +".points" ) + 50;
      if ( other_gp >= max_gp ) {
         write( "* All of your guild points can be used for "+
               STD_SKILLS[ i ] +" commands.\n" );
         continue;
      }
      if ( gp + other_gp <= max_gp ) {
         write( "* You cannot use any guild points for "+
               STD_SKILLS[ i ] +" commands until\n    your points "+
               "reach "+ ( max_gp - other_gp ) +".\n" );
         continue;
      }
      write( "* You can use "+ ( gp + other_gp - max_gp ) +" ("+ other_gp +
            ") for "+ STD_SKILLS[ i ] +" commands.\n" );
   }
   return 1;
}

==================================================
FILE: /lib/cmds/guild-race/newb_ie.c
==================================================

#include <player.h>
#include <language.h>
#include <cmds/options.h>
#include <newbiehelpers.h>
#define HIST "/obj/handlers/hist_handler"
#define SPAM_PROPERTY "newbie_tell"
#define TIME_OUT     30
#define TIME  0
#define WORDS 1
inherit "/cmds/guild_base";
inherit "/cmds/speech";
int newbie_history(object who);
void create() {
   ::create();
   set_nroff_file("newbie");
   set_command_name("newbie");
}
int cmd( string words ) {
   mixed *array;
   if (words == "history") {
      return newbie_history(this_player());
   }
   if ( this_player()->query_mature() &&
        !this_player()->query_creator() &&
        !this_player()->query_property( "newbie helper" ) &&
        !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      write( "You are no longer a newbie, being older than " + MATURITY +
             " hours.\n" );
      this_player()->remove_known_command( "newbie" );
      return 1;
   }
   if ( array = this_player()->query_property( SPAM_PROPERTY ) ) {
     if ( array[ WORDS ] == words ) {
       write( "You only said that a few seconds ago, why not wait for a "
         "response?\n" );
       return 1;
     }
     if ( time() < array[ TIME ] ) {
       write( "You only used the newbie channel a few seconds ago, why not "
         "wait for a response?\n" );
       return 1;
     }
   }
   if (this_player()->query_property("gagged")) {
      write("You are gagged!  You will not be able to use the "
            "newbie channel until a creator removes your gag.\n");
      return 1;
   }
   if(this_player()->query_property(SHORTHAND_PROP))
     words = LANGUAGES->fix_shorthand(words);
   words = strip_colours (words);
   write( "You newbie-tell: "+ words +"\n" );
   user_event("newbie", this_player()->query_cap_name() + ": "+words);
   HIST->add_chat_history("newbie", this_player()->query_name() +
                          " newbie-told: ", words);
   if (!this_player()->query_creator() &&
       !this_player()->query_property( "newbie helper") &&
       !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
     this_player()->add_property( SPAM_PROPERTY, ({ time() + 5, words }),
                                  TIME_OUT );
     write( "Please remember: this command is for obtaining assistance; "
            "it is not a chat channel.  If you over use it players "
            "stop listening and you don't get assistance when you "
            "really need it!\n");
   }
   return 1;
}
int newbie_history(object who) {
    mixed *history;
    string result;
    history = HIST->query_chat_history("newbie");
    if ( !arrayp( history ) || !sizeof( history ) ) {
        tell_object(who, "Nothing has been said on the newbie channel.\n");
    }
    else {
        result = "$P$Newbie Channel$P$";
        result += implode(map(history, (: "$I$5=$C$" + $1[0] + $1[1] +
                    "%^RESET%^" :)), "\n");
        tell_object(who, result);
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<string'message'>", (: cmd($4[0]) :),
              "history", (: cmd("history") :) });
}

==================================================
FILE: /lib/cmds/guild-race/rearrange.c
==================================================

#include <playerinfo.h>
#define ME_CON points[ this_player() ][ "me_con" ]
#define ME_DEX points[ this_player() ][ "me_dex" ]
#define ME_INT points[ this_player() ][ "me_int" ]
#define ME_STR points[ this_player() ][ "me_str" ]
#define ME_WIS points[ this_player() ][ "me_wis" ]
#define POOL points[ this_player() ][ "pool" ]
inherit "/cmds/guild_base";
mapping points = ([ ]);
int cmd();
void create() {
   ::create();
   set_command_name("rearrange");
}
void do_save() {
   int player, here;
   player = this_player()->query_real_con() +
      this_player()->query_real_dex() +
      this_player()->query_real_str() +
      this_player()->query_real_int() +
      this_player()->query_real_wis();
   here = ME_CON + ME_DEX + ME_STR + ME_INT + ME_WIS;
   if (player != here) {
      log_file("BAD_REARRANGE",
         sprintf("%s: %s had %d now has %d\n",
            ctime(time()),
            this_player()->query_name(),
            player, here));
      PLAYERINFO_HANDLER->add_entry(
         this_object(),
         this_player()->query_name(),
         "misc",
         sprintf("rearranged from %d points to %d points", player, here),
         0);
   }
   this_player()->set_con( ME_CON );
   this_player()->set_dex( ME_DEX );
   this_player()->set_int( ME_INT );
   this_player()->set_wis( ME_WIS );
   this_player()->set_str( ME_STR );
   this_player()->remove_known_command( "rearrange" );
   map_delete(points, this_player());
}
void display_stats() {
   printf( "Con: %d Dex: %d Int: %d Str: %d Wis: %d Pool: %d\n",
         ME_CON, ME_DEX, ME_INT, ME_STR, ME_WIS, POOL );
}
int get_stat_bit( string word ) {
   int num;
   string stat;
   word = lower_case( word );
   if ( word == "save" ) {
      if ( POOL ) {
         write( "WARNING: You still have points left in your pool that "
		   "could be used to make your character more powerful. If you "
		   "leave these unspent now, you will not be able to get them again later. "
           "Are you sure you want to save? [y/n] " );
         input_to( "get_check" );
         return 1;
      }
      write( "Saving.\n" );
      do_save();
      return 1;
   }
   if ( word == "quit") {
      write( "Quitting.\n" );
      map_delete(points, this_player());
      return 1;
   }
   if ( word == "reset" ) {
      write( "Resetting to previous arrangement.\n" );
      return cmd();
   }
   if ( sscanf( word, "%s %d", stat, num ) != 2 )
      stat = word;
   if ( !stat || ( stat == "" ) )
      stat = "X";
   if ( num > POOL )
      if ( !POOL ) {
         write( "Cannot add to stat.  Need to add to the pool first.\n" );
         stat = "X";
      } else {
         write( "Pool has only "+ POOL +" points in it.  "+
               "Adding these to stat.\n" );
         num = POOL;
      }
   switch( stat[ 0 ] ) {
      case 'c' :
         if ( ( ME_CON + num ) < 8 ) {
            write( "Cannot set constitution to less than 8.\n" );
         } else
            if ( ( ME_CON + num ) > 23 ) {
               write( "Cannot set constitution to more than 23.\n" );
            } else {
               ME_CON += num;
               POOL -= num;
            }
         break;
      case 'd' :
         if ( ( ME_DEX + num ) < 8 ) {
            write( "Cannot set dexterity to less than 8.\n" );
         } else
            if ( ( ME_DEX + num ) > 23 ) {
               write( "Cannot set dexterity to more than 23.\n" );
            } else {
               ME_DEX += num;
               POOL -= num;
            }
         break;
      case 'i' :
         if ( ( ME_INT + num ) < 8 ) {
            write( "Cannot set intelligence to less than 8.\n" );
         } else
            if ( ( ME_INT + num ) > 23 ) {
               write( "Cannot set intelligence to more than 23.\n" );
            } else {
               ME_INT += num;
               POOL -= num;
            }
         break;
      case 's' :
         if ( ( ME_STR + num ) < 8 ) {
            write( "Cannot set strength to less than 8.\n" );
         } else
            if ( ( ME_STR + num ) > 23 ) {
               write( "Cannot set strength to more than 23.\n" );
            } else {
               ME_STR += num;
               POOL -= num;
            }
         break;
      case 'w' :
         if ( ( ME_WIS + num ) < 8 ) {
            write( "Cannot set wisdom to less than 8.\n" );
         } else
            if ( ( ME_WIS + num ) > 23 ) {
               write( "Cannot set wisdom to more than 23.\n" );
            } else {
               ME_WIS += num;
               POOL -= num;
            }
         break;
      default :
         break;
   }
   display_stats();
   write( "Enter [d|c|i|w|s|save|reset|quit] <num> : " );
   input_to( "get_stat_bit" );
   return 1;
}
int get_check( string word ) {
   word = lower_case( word );
   if ( word[ 0 ] != 'y' ) {
      write( "Going back to stat entering.\n" );
      return get_stat_bit( "" );
   }
   do_save();
   write( "Saving.\n" );
   return 1;
}
int cmd() {
   write( "Rearranging stats.\n\n" );
   points[ this_player() ] = ([ ]);
   ME_CON = (int)this_player()->query_real_con();
   ME_DEX = (int)this_player()->query_real_dex();
   ME_INT = (int)this_player()->query_real_int();
   ME_STR = (int)this_player()->query_real_str();
   ME_WIS = (int)this_player()->query_real_wis();
   POOL = 0;
   if ( ME_CON > 8)  {
      POOL += ME_CON - 8;
      ME_CON = 8;
   }
   if ( ME_DEX > 8) {
      POOL += ME_DEX - 8;
      ME_DEX = 8;
   }
   if ( ME_INT > 8 ) {
      POOL += ME_INT - 8;
      ME_INT = 8;
   }
   if ( ME_STR > 8 ) {
      POOL += ME_STR - 8;
      ME_STR = 8;
   }
   if ( ME_WIS > 8 ) {
      POOL += ME_WIS - 8;
      ME_WIS = 8;
   }
   write( "Type \"c 3\" to add 3 points to your constitution from the pool, "+
         "or \"c -4\" to remove 4 points from constitution and add them to "+
         "the pool.  Use \"save\" to save the current state and quit.  Note "+
         "that \"%^YELLOW%^reset%^RESET%^\" will return you to your "+
         "starting position, while \"%^YELLOW%^quit%^RESET%^\" will quit "+
         "without saving any changes.\n\n" );
   return get_stat_bit( "" );
}
int teach( object thing ) { return 0; }
int clean_up() {
  if (sizeof(points))
    return 1;
  ::clean_up();
}
void reset() {
  if (sizeof(points))
    return;
  ::reset();
}
string query_name()
{
  return "Rearrange Command";
}

==================================================
FILE: /lib/cmds/guild-race/skills.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_command_name("skills");
}
string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }
    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}
string level_to_string( int level ) {
    switch( level ) {
        case 0..15:
            return "novice";
        case 16..30:
            return "apprentice";
        case 31..45:
            return "competent";
        case 46..60:
            return "proficient";
        case 61..75:
            return "skilled";
        case 76..85:
            return "adept";
        case 86..95:
            return "expert";
        default:
            return "master";
    }
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus, rp;
   string str, tp, tmp;
   rp = this_player()->query_role_playing();
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) ||
          (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero)))) {
        if(rp) {
          str += sprintf( "%*'| 's%*'.'-s %4s\n",
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ),
              args[ i ],
              (no_bonus ? level_to_string(sk) : bonus_to_string( this_player()->query_skill_bonus( tp ) ) ), "" );
        } else {
          str += sprintf( "%*'| 's%*'.'-s %4d " + (no_bonus?"   -\n":"%4d\n"),
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
                          (int)this_player()->query_skill_bonus( tp ) );
        }
      }
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         if ((only_leaf || o_l) && (tmp != "")) {
           if(rp) {
             str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           } else {
             str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           }
         } else
           str += tmp;
      }
   }
   return str;
}
int cmd( string word ) {
   int i, rp;
   string result, *bits;
   mixed *args;
   result = "";
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }
   rp = this_player()->query_role_playing();
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      if(rp) {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Proficiency" );
      } else {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Level/Bonus" );
      }
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   if(rp) {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Proficiency");
   } else {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Level/Bonus");
   }
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/guild-race/crafts/leatherwork.c
==================================================

#include <money.h>
#include <tasks.h>
#define TEACH_LEVEL 10
#define LEARN_LEVEL 10
#define SKILL "crafts.materials.leatherwork"
#define SKILLS ({ "crafts.materials.leatherwork", \
                  "crafts.materials.needlework" })
#define A_MAX 5
#define C_MAX 100
#define A_COND 5
#define C_COND 25
#define SCALE 50
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_nroff_file("leatherwork");
   add_teach_skill(SKILL, 20, 10);
   set_command_name("leatherwork");
}
int cmd( object *things, int costing ) {
   int bonus, cond, low, max, diff, cost, per, val, award;
   string place;
   if ( !environment( this_player() )->query_property( "leatherwork" )&&
      member_array(1,  (all_inventory(environment(this_player()))->
      query_property("leatherwork"))) == -1 )
      return notify_fail( "You are not in a leatherworking shop, "
            "so you cannot repair anything.\n" );
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) ){
      place = "default";
   }
   if ( sizeof( things ) > 1 )
      return notify_fail( "You can only repair one thing at a time.\n" );
   if (things[0]->query_material() != "leather")
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is not made of leather!  Wrong shop!\n" );
   if ( things[ 0 ]->query_worn_by() )
      return notify_fail( "You should probably remove "+
            (string)things[ 0 ]->the_short() +
            " before you jab yourself with a needle "
            "while trying to patch it up.\n" );
   per = 100 -
    (int)environment( this_player() )->query_discount( this_player() );
   if ( per < 0 )
      per = 0;
   val = (int)this_player()->query_value_in( place );
   if ( place != "default" )
      val += (int)this_player()->query_value_in( "default" );
   low = (int)things[ 0 ]->query_lowest_cond();
   if ( !low )
      low = 1;
   cond = (int)things[ 0 ]->query_cond();
   max = (int)things[ 0 ]->query_max_cond();
   if ( !max )
      max = 1;
   if ( 100 * cond > 98 * max )
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is already in top condition.\n" );
   diff = max - cond;
   if ((100 * diff)/max > 70){
     bonus = (int)this_player()->query_skill_bonus( SKILLS[ 1 ] );
     cost = (( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) /
       (max * 50) + 13);
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[1],
                                          diff, TM_COMMAND ) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the thread to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
      write( "%^YELLOW%^"+ replace( ({ "As you begin to fix $I, you realise "
            "how to make better use of the materials.", "As you work on $I, "
            "you find that you're able to fix it completely.", "You discover "
            "that you can fix $I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "You sew up all the holes in "+ (string)things[ 0 ]->the_short() +
            ", bringing it to top condition.\n" );
   else
      write( "You manage to sew up some of the holes in "+ (string)things[ 0 ]->the_short() +
            " but a few pop back open due to poor stitching.\n" );
   write( "The thread and sinew costs you "+
         (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
         (string)things[ 0 ]->a_short() +".\n" );
   return 1;
  }else{
  bonus = (int)this_player()->query_skill_bonus( SKILLS[ 0 ] );
  cost = ( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) /
      (max * 3) +123;
   if ( !cond ) {
      write( "You begin to work on "+ (string)things[ 0 ]->the_short() +
            " when it falls apart!  It must have been too damaged to fix.\n" );
      say( (string)this_player()->one_short() +" begins to work on "+
            (string)things[ 0 ]->the_short() +" when it falls to scraps!\n" );
      things[ 0 ]->break_me();
      return 1;
   }
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[0],
                                          diff, TM_COMMAND) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the leather to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
     write("%^YELLOW%^"+ replace( ({ "As you begin to cut and sew the "
           "leather patches for $I, you realise how to make better use of "
           "the leather.", "As you work on $I, you find that you're able "
           "to repair it completely.", "You discover that you can repair "
           "$I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "Your patching of "+ (string)things[ 0 ]->the_short() +
            " goes quite well, and you bring it to top condition.\n" );
   else
      write( "You manage to create reasonably good patches for "+
             (string)things[ 0 ]->the_short() +
             ", but the size wasn't quite right, and the stitching doesn't "
             "look like it will hold very well.\n" );
   write( "The repair materials cost you "+
          (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
        (string)things[ 0 ]->a_short() +".\n" );
   return 1;
 }
}
int teach( object thing ) {
   if ( (int)this_player()->query_skill( SKILL ) < TEACH_LEVEL )
      return -1;
   if ( (int)thing->query_skill( SKILL ) < LEARN_LEVEL )
      return -2;
   thing->add_known_command( "leatherwork" );
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1, 0) :),
            "cost <indirect:object:me>", (: cmd($1, 1) :) });
}

==================================================
FILE: /lib/cmds/guild-race/other/judge.c
==================================================

#include <tasks.h>
#include <weapon.h>
#undef DEBUG
#define COST 25
#define SKILL "other.evaluating.weapons"
#define QUEST_AVE 140
#define QUEST_MAX 300
#define LEARN 5
#define TEACH 50
inherit "/cmds/guild_base";
nosave string *_attack_types = ({ "blunt", "sharp", "pierce" });
nosave string *attacks;
void create() {
    ::create();
    set_nroff_file("judge");
    set_command_name("judge");
    add_teach_skill(SKILL, 50, 5);
}
varargs int *calc_rating( object weapon, object player ) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;
    data = (mixed *)weapon->query_attack_data();
    if ( !( size = sizeof( data ) ) )
        return ({ 0, 0 });
    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
      debug_printf("[%s - ave: %d max: %d]\n", data[ i + W_TYPE],
                   ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100,
                   damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ]);
    }
    debug_printf("[%s - ave: %d max: %d]\n", weapon->short(), ave, max );
    return ({ ave, max });
}
void judge_against( object player, object first, object second ) {
  int grain, rating, rating_1, rating_2, difficulty, margin, *data_1,
    *data_2;
  data_1 = calc_rating( first, player );
  data_2 = calc_rating( second, player );
  difficulty = data_1[ 0 ] - data_2[ 0 ];
    if ( difficulty > 0 )
        difficulty = QUEST_AVE - difficulty;
    else
        difficulty = QUEST_AVE + difficulty;
    margin = ( difficulty + ( difficulty * ( data_1[ 1 ] + data_2[ 1 ] ) ) /
        ( 2 * QUEST_MAX ) ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL, difficulty - 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapons$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to better judge "
                "$weapons$.", "As you inspect $weapons$, you feel a sense "
                "of surety in your judgement." })[ random( 3 ) ], "$weapons$",
                query_multiple_short( ({ first, second }), "the" ) ) +
                "%^RESET%^\n" );
        case SUCCEED:
            break;
        default:
            tell_object( player,
                "You examine "+ query_multiple_short( ({ first, second }),
                    "the" ) + " closely, but you're not sure which is "
                    "better.\n" );
            return;
    }
    grain = sqrt( (int)this_player()->query_skill_bonus( SKILL ) );
    if ( grain > 12 )
        grain = 12;
    rating_1 = QUEST_AVE * data_1[ 1 ] + QUEST_MAX * data_1[ 0 ];
    rating_1 = ( grain * rating_1 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating_2 = QUEST_AVE * data_2[ 1 ] + QUEST_MAX * data_2[ 0 ];
    rating_2 = ( grain * rating_2 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating = rating_1 - rating_2;
    if ( rating > 0 )
        rating++;
    else
        rating--;
    rating = 6 + rating / 2;
    if ( rating > 12 )
        rating = 12;
    if ( rating < 0 )
        rating = 0;
    if ( rating == 6 ) {
        tell_object( player, "You think that " +
            query_multiple_short( ({ first, second }), "the" ) +
            " are exactly the same.\n" );
        return;
    }
    tell_object( player, "You think that " + first->the_short() +" is "+ ({
         "amazingly worse", "extremely worse", "very much worse",
         "much worse", "worse", "a bit worse", "!", "a bit better",
         "better", "much better", "very much better",
         "extremely better", "amazingly better" })[ rating ] +" than "+
         second->the_short() +".\n" );
}
int judge_weapon( object player, object weapon ) {
    int grain, rating, margin, *data;
    string res;
    data = calc_rating( weapon, player );
    margin = ( data[ 0 ] + ( data[ 0 ] * data[ 1 ] ) / QUEST_MAX ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL,  data[ 0 ] + 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapon$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to judge "
                "$weapon$.", "As you inspect $weapon$, you feel a sense of "
                "surety in your judgement." })[ random( 3 ) ], "$weapon$",
                weapon->the_short() ) +"%^RESET%^\n" );
    case SUCCEED:
      break;
    default:
      tell_object( player, "You think that " + weapon->the_short() +
                   " is a good weapon, but you're not sure.\n" );
      return 0;
    }
    grain = sqrt( player->query_skill_bonus( SKILL ) / 2 );
    if ( grain > 14 )
      grain = 14;
    rating = QUEST_AVE * data[ 1 ] + QUEST_MAX * data[ 0 ];
    rating = ( grain * rating + QUEST_AVE * QUEST_MAX ) /
      ( 2 * QUEST_AVE * QUEST_MAX );
    rating += 14 - grain;
    if ( rating > 14 ) {
#ifdef DEBUG
      log_file( "BAD_WEAPON", "%s exceeds weapon specifications, rating is "
                "%d.\n", file_name( weapon ), rating );
#endif
      rating = 14;
    }
    attacks = player->query_known_commands();
    attacks = filter(weapon->query_attack_names(),
                  (: (member_array($1, attacks) != -1) :));
    attacks -= ({ "crush" });
    attacks -= ({ "impale" });
    attacks -= ({ "behead" });
    if(member_array("smash", weapon->query_attack_names()) != -1 &&
       member_array("crush", player->query_known_commands()) != -1)
       attacks += ({ "crush" });
    if(member_array("pierce", weapon->query_attack_names()) != -1 &&
       member_array("impale", player->query_known_commands()) != -1)
       attacks += ({ "impale" });
    if(member_array("slice", weapon->query_attack_names()) != -1 &&
       member_array("behead", player->query_known_commands()) != -1)
       attacks += ({ "behead" });
    res = "You think that "+ weapon->the_short() +" is " + ({
      "an atrocius", "an extremely poor", "a very poor", "a rather poor",
        "a poor", "a pretty poor", "a quite poor", "a reasonable",
        "a quite good", "a pretty good", "a good", "a rather good",
        "a very good", "an extremely good", "an excellent" })[ rating ] +
      " weapon";
    debug_printf("attacks: %O", attacks);
    if(sizeof(attacks))
      res += " that can be used to " + query_multiple_short(attacks, "", 0, 1,
                                                            0);
    res += ".\n";
    tell_object(player, res);
    return rating;
}
int valid_weapon( object player, object ob ) {
  if ( living( ob ) ) {
    if ( ob == player ) {
      add_failed_mess( "You stare at your muscles for a moment, "
                       "and decide that you're more than capable of destroying "
                       "any enemy that decides to interfere with you.\n" );
      return 0;
    }
    add_failed_mess( "You stare at $I for a while, but decide it "
                     "would be better if you considered them instead.\n",
                     ({ ob }) );
    return 0;
  }
  if ( !ob->query_weapon() ) {
    add_failed_mess( "$C$$I is not a weapon.\n", ({ ob }) );
    return 0;
  }
  if(environment(ob) != this_player())
    return add_failed_mess("You can't find $I.\n", ({ ob }));
  return 1;
}
int cmd( object first, object second ) {
  object *indirect_obs;
  int cost;
  function judge_func;
  if ( !valid_weapon( this_player(), first ) ) {
    return 0;
  }
  cost = COST;
  if ( second ) {
    if ( !valid_weapon( this_player(), second ) ) {
      return 0;
    }
    cost *= 2;
    indirect_obs = ({ first, second });
    judge_func = (: judge_against :);
  } else {
    indirect_obs = ({ first });
    judge_func = (: judge_weapon :);
  }
  if ( this_player()->query_specific_gp( "other" ) < cost ) {
    add_failed_mess( "You can't muster the energy to scrutinise "
                     "$I at the moment.\n", indirect_obs );
    return 0;
  }
  this_player()->adjust_gp( -cost );
  call_out( judge_func, 0, this_player(), first, second );
  add_succeeded_mess( "$N look$s closely at $I.\n", indirect_obs );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object'weapon'>", (: cmd( $1[0], 0 ) :),
              "<indirect:object:me'weapon'> against <indirect:object:me'weapon'>",
              (: cmd( $1[0][0], $1[1][0] ) :) });
}

==================================================
FILE: /lib/cmds/guild-race/other/vurdere.c
==================================================

#include <clothing.h>
#include <weapon.h>
#define COST 5
#define SKILL "other.evaluating.armour"
#define LEARN_LEVEL 2
#define TEACH_LEVEL 10
inherit "/cmds/guild_base";
void create() {
  ::create();
  set_nroff_file("vurdere");
  set_command_name("vurdere");
  add_teach_skill(SKILL, 10, 2);
}
mixed *calc_ac( object ob ) {
  int j;
  string i;
  mapping ac;
  mixed *ret, bit;
  ac = (mapping)ob->query_armour_class();
  ret = ({ });
  foreach ( i in keys( ac ) ) {
    if ( member_array( ac[ i ][ A_TYPE ], ({ "blunt",
                                               "sharp", "pierce" }) ) == -1 )
      continue;
    bit = ac[ i ][ A_AC ];
    if( (j = member_array( ac[ i ][ A_TYPE ], ret )) == -1 ) {
      j = sizeof( ret );
      ret += ({ ac[ i ][ A_TYPE ], ({ 0, 0, 0 }) });
    }
    j++;
    if ( intp( bit ) ) {
      ret[ j ][ 1 ] += bit / 2;
      ret[ j ][ 2 ] += bit;
    } else
      switch ( sizeof( bit ) ) {
      case 1 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += bit[ 0 ];
        ret[ j ][ 2 ] += bit[ 0 ];
        break;
      case 2 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ]);
        break;
      case 3 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ]);
        break;
      default :
        write( "Barf!\n" );
      }
  }
  return ret;
}
int calc_sausage( int sausage, int lvl ) {
  int tmp;
  tmp = 99 - (lvl * 99) / 200;
  if( tmp < 0 )
    tmp = 0;
  return random( sausage ) * tmp / 100 - random( sausage ) * tmp / 100 +
    sausage;
}
string check_string( int val, int bon ) {
  int dist;
  string s;
  dist = (350 - bon) / 10;
  if( dist > (val < 0 ? -val : val) )
    return " is the same as ";
  if( val > 0 )
    s = "better than ";
  else {
    s = "worse than ";
    val -= val;
  }
  if( !val )
    return " is exactly the same as ";
  if( val < 10 )
    return " is slightly " + s;
  if( val < 20 )
    return " " + s;
  if( val < 40 )
    return " is much " + s;
  return " is amazingly " + s;
}
int cmd_against( object*from, object *to ) {
  int i, j, k, l, arm_lvl;
  object *ok, *fail;
  mixed *rat, *to_ac, *zip;
  arm_lvl = (int)this_player()->query_skill_bonus( SKILL );
  if(sizeof(from) + sizeof(to) > 10) {
    add_failed_mess("You cannot compare that many items at once.\n");
    return 0;
  }
  i = (COST*(sizeof(from)+sizeof(to)));
  if(this_player()->query_specific_gp("other") < i) {
    add_failed_mess("You cannot concentrate enough to compare these "
                       "items.\n");
    return 0;
  }
  this_player()->adjust_gp( -i);
  to_ac = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( to ); i++ ) {
    if( to[ i ]->query_armour() ) {
      rat = calc_ac( to[ i ] );
      to_ac += ({ to[ i ], rat });
    } else {
      fail += ({ to[ i ] });
      to = delete( to, i, 1 );
      i--;
    }
  }
  if( !sizeof( to ) ) {
    notify_fail( "None of " + query_multiple_short( fail ) +
                 " are armour.\n" );
    return 0;
  }
  fail = ({ });
  ok = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      if( !sizeof( to_ac ) ) {
        fail += ({ from[ i ] });
        continue;
      }
      rat = calc_ac( from[ i ] );
      zip = ({ });
      for( j = 0; j < sizeof( to_ac ); j += 2 ) {
        for( k = 0; k < sizeof( to_ac[ j + 1 ] ); k += 2 ) {
          if( (l = member_array( to_ac[ j + 1 ][ k ], rat )) == -1 ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          } else {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( (rat[ l + 1 ][ 0 ] + rat[ l + 1 ][ 1 ] +
                                  rat[ l + 1 ][ 2 ]) / 3 -
                                 (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          }
          zip += ({ to_ac[ j + 1 ][ k ] });
        }
        for( k = 0; k < sizeof( rat ); k += 2 ) {
          if( member_array( rat[ 0 ], zip ) ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] +
                                      rat[ j + 1 ][ 2 ]) / 3, arm_lvl ) +
                   to_ac[ j ]->short() + " at " + rat[ j ] + ".\n" );
          }
        }
      }
      if(member_array(from[i], ok) == -1) {
        ok += ({ from[ i ] });
      }
    } else {
      if(member_array(from[i], fail) == -1) {
        fail += ({ from[ i ] });
      }
    }
  }
  if( sizeof( fail ) ) {
    add_failed_mess( "Failed to compare " + query_multiple_short( fail ) +
                 " against " + query_multiple_short( to ) + ".\n" );
    return 0;
  }
  if( sizeof( ok ) ) {
    say( this_player()->query_cap_name() + " looks closely at " +
         query_multiple_short( uniq_array( ok + to ) ) + ".\n" );
  }
  return 1;
}
int cmd_normal( object* from ) {
  int i, j;
  object *ok, *fail;
  mixed *rat, bing;
  string type, *types, *zones;
  ok = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      rat = calc_ac( from[ i ] );
      for( j = 0; j < sizeof( rat ); j += 2 ) {
        bing = (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] + rat[ j + 1 ][ 2 ]) / 3;
        bing /= 5;
        if( bing >= 10 ) {
          bing = 9;
        }
        if( bing < 0 ) {
          bing = 0;
        }
        write( from[ i ]->the_short() + ({ " is terrible",
                                       " is amazingly poor",
                                       " is pretty poor",
                                       " is poor",
                                       " is ok",
                                       " is average",
                                       " is good",
                                       " is very good",
                                       " is extremely good",
                                       " is excellent", })[ bing ] +
                                       " at stopping " + rat[ j ] +
                                       " attacks.\n" );
        ok += ({ from[ i ] });
      }
      if(!arrayp(from[i]->query_type())) {
        types = ({ from[i]->query_type() });
      } else {
        types = from[i]->query_type();
      }
      zones = ({ });
      foreach(type in types) {
        if(CLOTHING_HANDLER->query_equivilant_type(type)) {
          zones += CLOTHING_HANDLER->query_zone_names(CLOTHING_HANDLER->query_equivilant_type(type));
        } else {
          zones += CLOTHING_HANDLER->query_zone_names(type);
        }
      }
      if(!sizeof(zones)) {
      	write(from[i]->the_short() +
              " does not protect any parts of your body.\n");
      } else {
        write(from[i]->the_short() + " protects your " +
              query_multiple_short(zones, "poss") + ".\n");
      }
      continue;
    }
    fail += ({ from[ i ] });
  }
   from = uniq_array( from );
  if( !sizeof( ok ) ) {
    notify_fail( "You failed to vurdere " + query_multiple_short( from ) +
                 ".\n" );
    return 0;
  }
    ok = uniq_array( ok );
  say( this_player()->query_cap_name() + " peers carefully at " +
       query_multiple_short( ok ) + ".\n" );
  return 1;
}
int teach( object ob ) {
  if( this_player()->query_skill( SKILL ) < TEACH_LEVEL )
    return -1;
  if( ob->query_skill( SKILL ) < LEARN_LEVEL )
    return -2;
  ob->add_known_command( "vurdere" );
  return 1;
}
mixed* query_patterns() {
   return ({ "<indirect:object:me'from'> against <indirect:object:me'to'>",
                (: cmd_against($1[0], $1[1]) :),
             "<indirect:object:me'normal'>",
                (: cmd_normal($1) :) });
}

==================================================
FILE: /lib/cmds/living/accept.c
==================================================

#include <cmds/offer.h>
#include <money.h>
#include <move_failures.h>
inherit "/cmds/base";
int is_in(object ob, object source);
int do_buy(object *people) {
   object person;
   int ret;
   class offer_sale wombat;
   object *obs;
   object *moved;
   mixed *payment;
   object ob;
   int i;
   foreach (person in people) {
      wombat = this_player()->query_respond_command("sell", person);
      if (wombat) {
         obs = filter(wombat->sell_obs, (: is_in($1, $2) :),
                      wombat->seller);
         if (sizeof(obs) != sizeof(wombat->sell_obs)) {
            add_failed_mess("$I no longer has " +
                            query_multiple_short(wombat->sell_obs - obs) +
                            " to buy.\n",
                            ({ person }) );
         } else if (this_player()->query_value_in(wombat->place) <
                    wombat->value) {
            add_failed_mess("You no longer have enough money to buy " +
                            query_multiple_short(wombat->sell_obs) +
                            " from $I.\n", ({ person }));
         } else {
            payment = MONEY_HAND->query_person_payments(wombat->value,
                                                        wombat->place,
                                                        this_player(), person);
            if (!payment) {
               add_failed_mess("You no longer have the correct change "
                               "to pay for $I.\n", ({ person }) );
            } else {
               moved = ({ });
               foreach (ob in wombat->sell_obs) {
                  if (ob->move(this_player()) == MOVE_OK) {
                     moved += ({ ob });
                  }
               }
               if (sizeof(moved) != sizeof(wombat->sell_obs)) {
                  moved->move(person);
                  tell_object(person, "Unable to move " +
                                      query_multiple_short(wombat->sell_obs -
                                                           moved) +
                                      " out of your inventory, cancelling "
                                      "the sale.\n");
                  add_failed_mess("Unable to move some objects out "
                                  "of the inventory of $I, canceling sale.\n",
                                  ({ person }) );
               } else {
                  if (sizeof(payment[MONEY_PAY_CHANGE])) {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " from " + this_player()->the_short() +
                              " and give back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " to " + person->the_short() +
                              " and receive back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                  } else {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " from " + this_player()->the_short() +".\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " to " + person->the_short() + ".\n");
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_RETURN]); i += 2) {
                     this_player()->adjust_money(-payment[MONEY_PAY_RETURN][i+1],
                                                 payment[MONEY_PAY_RETURN][i]);
                     person->adjust_money(payment[MONEY_PAY_RETURN][i+1],
                                          payment[MONEY_PAY_RETURN][i]);
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_CHANGE]); i += 2) {
                     person->adjust_money(-payment[MONEY_PAY_CHANGE][i+1],
                                                 payment[MONEY_PAY_CHANGE][i]);
                     this_player()->adjust_money(payment[MONEY_PAY_CHANGE][i+1],
                                          payment[MONEY_PAY_CHANGE][i]);
                  }
                  add_succeeded_mess("$N buy$s " +
                                     query_multiple_short(wombat->sell_obs) +
                                     " from $I.\n", ({ person }) );
                  ret++;
               }
            }
         }
         this_player()->remove_respond_command("sell", person);
      } else {
         add_failed_mess("Sorry, $I has not offered to sell you anything.\n",
                         ({ person }) );
      }
   }
   return ret;
}
int is_in(object ob, object source) {
   object env;
   if (!ob) {
      return 0;
   }
   env = ob;
   do {
      env = environment(env);
      if (env == source) {
         return 1;
      }
   } while (env);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer from <indirect:living'person'>", (: do_buy($1) :) });
}
int query_theft_command() {
   return 1;
}

==================================================
FILE: /lib/cmds/living/attack.c
==================================================

inherit "/cmds/living/kill";
