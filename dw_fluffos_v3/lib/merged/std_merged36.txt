# Total Tokens: 21560
# Total Files Merged: 7
# Total Characters: 71884

ure/fireplace.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
#define WIZARD "/std/guilds/wizard"
#define CMD "/cmds/"
#define BURN_PER_TICK   1
#define BRIGHT 30
#define K      1
inherit "/std/room/furniture/surface";
private nosave int _light_produced;
private nosave int _is_lit;
private nosave int _frequency;
private nosave string _lit_mess;
private nosave string _unlit_mess;
private nosave string *_lit_chats;
private nosave string *_dying_chats;
private nosave string _turn_on_mess;
private nosave string _turn_off_mess;
private nosave string _out_of_fuel_mess;
void set_light_produced(int b);
void set_lit_mess(string str);
void set_unlit_mess(string str);
void set_frequency(int i);
void set_lit_chats(string *str);
void add_lit_chat(string str);
string request_lit_chat();
void set_dying_chats(string *str);
void add_dying_chat(string str);
string request_dying_chat();
void set_turn_on_mess(string mess);
void set_turn_off_mess(string mess);
void set_out_of_fuel_mess(string mess);
int do_light(object *obs);
int do_zap();
int turn_on();
int do_dowse(object *obs);
int turn_off();
int calc_fuel();
void create() {
  do_setup++;
  surface::create();
  do_setup--;
  set_name("fireplace");
  add_alias( ({ "fireplace", "furniture", "hearth", "fire" }) );
  add_plural( "fireplaces" );
  add_property( "shop type", "furniture" );
  add_property( "degrees", 0 );
  set_light_produced( BRIGHT );
  set_lit_mess("A fire blazes happily in the hearth, providing "
      "a soft red glow and pleasant warmth. It crackles and spits "
      "occasionally, giving the room that homely feel.\n");
  set_unlit_mess("The hearth is blackened with ashes and old embers.\n");
  set_frequency(5);
  set_lit_chats( ({
      "The fire crackles and spits cheerfully.",
      "The warm fire soothes your weariness.",
      "An enchanting orange glow radiates from the hearth.",
      "Small glowing embers dance over the fire.",
      "The fire blazes in the grate." }) );
  set_dying_chats( ({
      "The fire splutters.",
      "The warm red glow flickers.",
      "A whisp of smoke from the fire trails around the room." }) );
  set_turn_on_mess("Soon a roaring fire is blazing in the grate.\n");
  set_turn_off_mess("The embers smoke slightly and their glow dims.\n");
  set_out_of_fuel_mess("The fire flickers and dies away.\n");
  if ( !do_setup ) {
      this_object()->setup();
  }
  this_object()->add_extra_look( this_object() );
  add_help_file("fireplace");
}
void init() {
  this_player()->add_command("light", this_object(), "<direct:object> with <indirect:object>");
  this_player()->add_command("extinguish", this_object(), "<direct:object>", (: do_dowse :) );
  this_player()->add_command("dowse", this_object(), "<direct:object>");
  if( this_player()->query_guild_ob() == WIZARD ){
    this_player()->add_command("zap", this_object(), "<direct:object>");
    this_player()->add_command("point", this_object(), "[finger] at <direct:object>", (: do_zap :) );
  }
}
int query_fuel_left(){  return calc_fuel();  }
void set_light_produced(int b){  _light_produced = b;  }
int query_light_produced(){  return _light_produced;  }
void set_frequency(int i){  _frequency = i + 1;  }
int query_frequency(){  return _frequency;  }
int do_light(object *obs){
  string q_n;
  q_n = obs[0]->query_name();
  if( _is_lit ){
    this_player()->add_failed_mess( this_object(),
         "$D is already ablaze.\n", ({ }) );
    return 0;
  }
  if( q_n != "flint" && q_n != "match" && q_n != "lighter" ){
    this_player()->add_failed_mess(this_object(),
         "You can't light $D with $I.\n", ({ obs[0] }) );
    return 0;
  }
  if( this_player()->query_dex() < random(18) ){
    this_player()->add_failed_mess(this_object(),
      "You strike $I, but can't quite get the spark to catch.\n", ({ obs[0] }) );
    return 0;
  }
  if ( calc_fuel() <= 0 ) {
    this_player()->add_failed_mess( this_object(),
        "There is nothing in the fireplace to burn.\n", ({ }) );
    return 0;
  }
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D with $I.\n", ({ obs[0] }) );
  return turn_on();
}
int do_zap(){
  object tp;
  tp = this_player();
  if(tp->query_gp() < 10){
    tell_object(tp, "You don't even have the energy for such a small task!\n");
    return 1;
  }
  if(_is_lit){
    tell_object(tp, "There is already a merry fire burning in the fireplace.\n");
    return 1;
  } else {
    tp->add_succeeded_mess(this_object(),
      "$N extend$s an arm towards $D.\nA small fireball leaps from $p "
      "index finger and throws itself onto the hearth.\n", ({ }) );
    tp->adjust_gp( -10 );
    return turn_on();
  }
}
void set_turn_on_mess(string mess){  _turn_on_mess = mess;  }
string query_turn_on_mess(){  return _turn_on_mess;  }
void set_turn_off_mess(string mess){  _turn_off_mess = mess;  }
string query_turn_off_mess(){  return _turn_off_mess;  }
void msg_on(){
  if(_is_lit){
    tell_room(environment( this_object() ), query_turn_on_mess() );
  }
}
int turn_on(){
  int x;
  FUEL_HANDLER->add_burner( this_object() );
  _is_lit = 1;
  adjust_light( query_light_produced() );
    x = query_light_produced() / 4;
    add_property("degrees", query_light_produced() * 4);
    environment( this_object() )->add_property("warmth", x );
  call_out( "msg_on", 7 );
  return 1;
}
int do_dowse(object *obs){
  if( !_is_lit ){
    this_player()->add_failed_mess( this_object(),
         "There is no fire to put out.\n", ({ }) );
    return 0;
  } else {
    this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and the room loses its warm glow.\n", ({ }) );
    return turn_off();
  }
}
void msg_off() {
  if(!_is_lit){
    tell_room(environment( this_object() ), query_turn_off_mess() );
  }
}
int turn_off(){
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
  adjust_light( -query_light_produced() );
  add_property( "degrees", 0 );
  environment( this_object() )->remove_property("warmth");
  call_out( "msg_off", 10 );
  return 1;
}
void set_out_of_fuel_mess(string mess){  _out_of_fuel_mess = mess;  }
string query_out_of_fuel_mess(){  return _out_of_fuel_mess;  }
void out_of_fuel() {
  turn_off();
  tell_room(environment( this_object() ), query_out_of_fuel_mess() );
}
void set_lit_chats(string *str){  _lit_chats = str;  }
void add_lit_chat(string str){
  if( !_lit_chats ){
    _lit_chats = ({ });
  }
  _lit_chats += ({ str });
}
string request_lit_chat(){
  return _lit_chats[random( sizeof(_lit_chats) - 1 )];
}
void set_dying_chats(string *str){  _dying_chats = str;  }
void add_dying_chat(string str){
  if( !_dying_chats ){
    _dying_chats = ({ });
  }
  _dying_chats += ({ str });
}
string request_dying_chat(){
  return _dying_chats[random( sizeof(_dying_chats) - 1 )];
}
void set_lit_mess(string str){  _lit_mess = str;  }
string query_lit_mess(){  return _lit_mess;  }
void set_unlit_mess(string str){  _unlit_mess = str;  }
string query_unlit_mess(){  return _unlit_mess;  }
void consume_fuel() {
  int x;
  int q;
  int z;
  int w;
  int amount;
  string r;
  object *inv;
  object ashes;
  object thing;
  object env;
  inv = filter(all_inventory( this_object() ),
              (:$1->query_property("fuel") :));
  if( !inv || inv == ({ }) || calc_fuel() < 1){
    out_of_fuel();
    return;
  }
  x = sizeof(inv);
  foreach(thing in inv){
      q = thing->query_amount_left();
      w = thing->query_weight();
      z = q - ( ( BURN_PER_TICK * 100 / x ) / w );
      if ( z < 1 ){
          thing->move("/room/rubbish");
          amount = roll_MdN(4, 20);
          ashes = clone_object("/obj/cont_medium");
          ashes->set_name("ash");
          ashes->set_short("fine grey ash");
          ashes->add_property("determinate", "some ");
          ashes->add_adjective(({"some", "fine", "grey", "pinch", "pinches",
           "handful", "handfuls", "bucketful", "bucketfuls", "of"}));
          ashes->add_plural("ash");
          ashes->set_long("This is $pile_size$ of fine grey ash, "
            "$amount_size$. It looks like it was the leftovers "
            "from someone's camp fire.\n");
          ashes->set_weight_unit(({ 1, 50 }));
          ashes->set_medium_alias("FiNeGrEyAsH");
          ashes->set_amount_types((["pinch" : ({1, "pinches"}),
           "handful" : ({50, "handfuls"}),
           "bucketful" : ({1000, "bucketfuls"})]));
          ashes->set_pile_types(({50, "small", 100, "medium",
            200, "large", "huge"}));
          ashes->set_continuous();
          ashes->set_amount(amount);
          ashes->move(this_object());
      } else {
        thing->set_amount_left( z );
      }
  }
  calc_fuel();
  env = environment( this_object() );
  if( random( query_frequency() ) == 1 ){
    if( calc_fuel() > 10 ){
      r = request_lit_chat();
      tell_room( env, r + "\n");
    } else {
      r = request_dying_chat();
      tell_room( env, r + "\n");
    }
  }
}
int calc_fuel(){
  object *inv;
  object thing;
  int tot_fuel = 0;
  int w;
  int amt;
  inv = all_inventory( this_object() );
  if( !inv || inv == ({ }) ) { return 0; }
  foreach(thing in inv){
    if( thing->query_property("fuel") ){
      w =  thing->query_weight();
      amt = thing->query_amount_left();
      tot_fuel += w * amt * K / 100 ;
    }
  }
  return tot_fuel;
}
int test_remove( object thing, int flat, mixed dest){
  object tp;
  object *prev;
  tp = this_player();
  prev = previous_object(-1);
  if(_is_lit && tp && strsrch( file_name(prev[1]), CMD ) != -1 ){
    tell_object(tp, "You reach out towards the fire but "
       "you can't brave the flames and quickly pull away.\n");
    tell_room( environment(tp), tp->query_short() + " tries to take something "
      "from the fire but pulls back sucking " + tp->query_possessive() +
      " fingers.\n", tp);
    tp->adjust_hp( -random(120) );
    return 0;
  }
  return ::test_remove(thing, flat, dest);
}
int test_add( object thing, int flag ) {
  if( !thing->query_property("fuel") && environment(thing) ){
    tell_object(this_player(), "You don't think " + thing->the_short() +
      " would be a suitable fuel.\n");
    return 0;
  }
  if( _is_lit ){
    tell_room(environment( this_object() ),
      ({ "The fire crackles.\n",
         "A shower of glowing embers tumble around the hearth.\n" })[random(2)] );
  }
  call_out("calc_fuel",1);
  return 1;
}
string extra_look( object ob ){
  if( _is_lit ) {
      return query_lit_mess();
  }
  else {
      return query_unlit_mess();
  }
}
void pre_dest_me() {
  int tmp;
  if(_is_lit && environment()) {
    FUEL_HANDLER->remove_burner( this_object() );
    _is_lit = 0;
    adjust_light( -query_light_produced() );
    tmp = environment()->query_property("warmth");
    if(tmp > query_light_produced() / 4)
      environment()->add_property("warmth", tmp -
                            (query_light_produced() / 4));
    else
      environment()->remove_property("warmth");
  }
  return;
}
void dest_me() {
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
   ::dest_me();
}

==================================================
FILE: room/furniture/fireplace_inherit.c
==================================================

inherit "/std/room/furniture/fireplace";

==================================================
FILE: room/furniture/fuel_inherit.c
==================================================

inherit "/std/object";
private nosave int _amount;
private nosave string *_shorts;
private nosave string *_longs;
string fuel_short();
string fuel_long();
void create(){
   ::create();
   if(!_amount){
     _amount = 100;
   }
   set_short( (: fuel_short :) );
   set_long( (: fuel_long :) );
   add_property("no recycling", 1);
   add_property("fuel", 1);
}
void set_amount_left(int i){  _amount = i;  }
void adjust_amount_left(int i){  _amount += i;  }
int query_amount_left(){  return _amount;  }
void set_shorts(string *desc){  _shorts = desc;  }
void set_longs(string *desc){  _longs = desc;  }
string fuel_short(){
   int i;
   int x;
   x = sizeof(_shorts);
   for(i = 1; i <= x; i++){
      if( (_amount + 1) > 100 - ( i * 100 / x ) ){
         return _shorts[(i-1)];
      }
   }
   return "fuel";
}
string fuel_long(){
   int i;
   int x;
   x = sizeof(_longs);
   for(i = 1; i <= x; i++){
      if( ( _amount + 1 ) > ( 100 - ( i * 100 / x )) ){
         return _longs[(i-1)];
      }
   }
   return "fuel";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "amount" : _amount
          ]);
}
void init_dynamic_arg(mapping arg) {
   _amount = arg[ "amount" ];
   ::init_dynamic_arg(arg["::"]);
}

==================================================
FILE: room/furniture/furniture.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
private nosave object *_on_top;
private nosave int _has_surface;
#define DEBUG
void create() {
  do_setup++;
  ::create();
  _drawer_mess = "a drawer in $ob_short$";
  _drawers = ({ });
  _on_top = ({ });
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if (!query_property("shop type"))
    add_property( "shop type", "furniture" );
   do_setup--;
   if(!do_setup)
     this_object()->setup();
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
int query_has_surface() { return _has_surface; }
void set_has_surface(int i) { _has_surface = i; }
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   if(sizeof(_on_top))
     ret += query_contents( "On " + the_short() + " " +
                            (sizeof(_on_top) == 1 ? "is " : "are " ), _on_top);
   return ret;
}
varargs string query_contents( string start, object *things,
  int ignore_living) {
  if(!arrayp(things)) {
    things = this_object()->find_inv_match( "", this_player() );
    things -= ({ this_player() });
    things = filter_array( things, (: environment( $1 ) == this_object() :) );
    things -= _on_top;
  }
  return ::query_contents(start, things, ignore_living);
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  result = ::test_remove(thing, flag, dest);
  if(result) {
    stuff = thing->query_property("dropped");
    if(environment() &&
       dest == this_player() &&
       function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(this_player()->query_name()) &&
       (!sizeof(stuff) || stuff[0] != this_player()->query_name())) {
      event(environment(this_player()), "theft", this_player(), this_object(),
            ({ thing }));
    }
    if(dest) {
      _on_top -= ({ thing });
      thing->remove_property("_on_top");
    }
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  int result;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  result = ::test_add(thing, flag);
  if(!result)
    return 0;
  if("/cmds/living/put"->query_con() == "on" && _has_surface) {
    _on_top += ({ thing });
    thing->add_property("_on_top", 1);
  } else if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  return result;
}
int pick_unlock(object player) {
  mixed owner;
  if(!environment())
    return ::pick_unlock(player);
  if(!environment() || !function_exists("query_owner", environment()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions( map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
void init_dynamic_arg(mapping bing) {
  object item;
  ::init_dynamic_arg(bing);
  foreach(item in all_inventory(this_object())) {
    if(item->query_property("_on_top"))
      _on_top += ({ item });
  }
}
string query_help_file_directory() {
  return "/doc/furniture/";
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  ret += ({ ({ "surface", _has_surface }) });
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}

==================================================
FILE: room/furniture/mirror.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/basic";
int _in_extra;
void create(){
	::create();
	add_extra_look(this_object());
}
string extra_look(object ob) {
	int dark;
	object env;
	env = environment(ob);
	if(living(env))
		return "You can see yourself in the mirror.";
	dark = (int) this_player()->check_dark((int)env->query_light());
	if(dark)
		return "It is too dark to see much in the room.";
	return "Reflected in the mirror is " +
		query_multiple_short(all_inventory(env) - ({ ob }), "a", 0, 1, dark) +
		".";
}

==================================================
FILE: room/furniture/poker.c
==================================================

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";
#include <money.h>
#include <room/card_base.h>
#define HAND_TYPE_HIGH_CARD  1
#define HAND_TYPE_PAIR       2
#define HAND_TYPE_TWO_PAIR   3
#define HAND_TYPE_THREE      4
#define HAND_TYPE_STRAIGHT   5
#define HAND_TYPE_FLUSH      6
#define HAND_TYPE_FULL_HOUSE 7
#define HAND_TYPE_FOUR       8
#define HAND_TYPE_STRAIGHT_FLUSH 9
#define POKER_STATE_ANTE      0
#define POKER_STATE_PAID_ANTE 1
#define POKER_STATE_DEALT     2
#define POKER_STATE_BET       3
#define POKER_STATE_DISCARD   4
#define POKER_STATE_AFTER_DISCARD   5
#define POKER_STATE_FINAL_BET 6
#define POKER_STATE_FOLDED    7
#define POKER_STATE_END       8
#define TIE -1
class hand_type {
   int hand_type;
   class playing_card* kickers;
   class playing_card duplicate_1;
   class playing_card duplicate_2;
   class playing_card high_card;
}
class player_data {
   class playing_card* hand;
   class hand_type hand_type;
   int bet;
   int state;
}
#define BOARD_TAG "poker"
private int _return;
private int _ante_amount;
private int _ante_house;
private int _house_cut;
private int _min_bet;
private int _max_bet;
private int _current_bet;
private int _pot;
private int _finished;
private int _poker_phase;
private int _turn_timeout;
private int _draw_round;
private int _max_draw_rounds;
private class playing_card* _deck;
private class playing_card* _discard;
private mapping _player_stats;
int query_hand_value(class playing_card* cards);
class hand_type query_hand_type(class playing_card* hand);
void create() {
   multiplayer_base::create();
   set_minimum_needed(2);
   add_help_file("poker");
   _ante_house = 400;
   _ante_amount = 400;
   _min_bet = 400;
   _max_bet = 1200;
   _max_draw_rounds = 1;
   _player_stats = ([ ]);
   set_shop_use_types(({ "poker" }));
   commercial::create();
   set_commercial_type("gambling");
   set_commercial_name("poker");
}
string query_hand_type_string(class hand_type bing) {
   string ret;
   switch (bing->hand_type) {
   case HAND_TYPE_FULL_HOUSE :
      ret = "Full house";
      break;
   case HAND_TYPE_THREE :
      ret = "Three of a kind";
      break;
   case HAND_TYPE_FLUSH :
      ret = "Flush";
      break;
   case HAND_TYPE_STRAIGHT :
      ret = "Straight";
      break;
   case HAND_TYPE_STRAIGHT_FLUSH :
      ret = "Straight flush";
      break;
   case HAND_TYPE_PAIR :
      ret = "Pair";
      break;
   case HAND_TYPE_FOUR :
      ret = "Four of a kind";
      break;
   case HAND_TYPE_TWO_PAIR :
      ret = "Two pairs";
      break;
   case HAND_TYPE_HIGH_CARD :
      ret = "High card " + query_card_string(bing->high_card);
      break;
   default :
      ret = "Nothing";
      break;
   }
   return ret;
}
string query_card_status(string id) {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   string* womble;
   string place;
   int left;
   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = query_money_place();
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing)) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->state == POKER_STATE_FOLDED) {
               ret += " Folded!\n";
            } else {
               if (data->state == POKER_STATE_PAID_ANTE) {
                  ret += " (paid ante) ";
               }
               if (data->state == POKER_STATE_AFTER_DISCARD) {
                  ret += " (discarded) ";
               }
               if (data->state == POKER_STATE_BET ||
                   data->state == POKER_STATE_FINAL_BET) {
                  if (id_bing == query_current_player()) {
                     ret += " <-- Their bet ";
                  }
               }
               if (data->bet) {
                  ret += "  Current bet " +
                         MONEY_HAND->money_value_string(data->bet, place);
                  ret += "\n";
               } else {
                  ret += "  No bet yet.\n";
               }
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }
   if (sizeof(not_playing) > 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " are not playing.\n";
   } else if (sizeof(not_playing) == 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " is not playing.\n";
   }
   ret += "The pot is " +
          MONEY_HAND->money_value_string(_pot, place) + ".\n";
   if (is_game_started()) {
      if (_draw_round < _max_draw_rounds) {
         left = _max_draw_rounds - _draw_round;
         ret += left + " draw round" + (left>1?"s":"") + " left.\n";
      }
   }
   ret += "\n";
   if (id) {
      if (!_finished) {
         data = query_player_data(id);
         if (data && sizeof(data->hand)) {
            ret += "Your hand (" +
                   query_hand_type_string(data->hand_type) +
                   (data->state == POKER_STATE_FOLDED?" -- Folded":"") +
                   "):\n";
            if (data->state != POKER_STATE_FOLDED) {
               ret += query_hand_string(data->hand,
                                     CARD_HAND_THREE|CARD_HAND_LETTERS,
                                     this_player()->query_cols());
            }
         }
         if (_finished) {
            tell_all_players(query_player_cap_name(id) + " peeks at their hand on " +
                         the_short() + ".\n", ({ id }));
         }
      } else {
         foreach (id in query_started_player_ids()) {
            data = query_player_data(id);
            if (data && sizeof(data->hand)) {
               ret += query_player_cap_name(id);
               if (data->state == POKER_STATE_FOLDED) {
                  ret += " folded, so the cards are hidden.\n";
               } else {
                  ret += " hand (" +
                         query_hand_type_string(data->hand_type) + ":\n";
                  ret += query_hand_string(data->hand, CARD_HAND_SINGLE,
                                        this_player()->query_cols());
               }
            }
         }
      }
   }
   return ret;
}
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status(find_player_id_of_person(this_player()));
}
int check_end_round() {
   int bet;
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         if (!data->bet) {
            return 0;
         } else if (!bet && data->bet) {
            bet = data->bet;
         } else if (bet != data->bet) {
            return 0;
         }
      }
   }
   if (bet) {
      call_out("complete_round", 2);
      _poker_phase = POKER_STATE_END;
      return 1;
   }
}
void next_person_turn() {
   class player_data data;
   string start_id;
   start_id = query_current_player();
   do {
      increment_current_player();
      data = query_player_data(query_current_player());
   } while (data->state == POKER_STATE_FOLDED &&
            query_current_player() != start_id);
   if (query_current_player() == start_id) {
      printf("Force end of game.\n");
      call_out("complete_round", 2, 1);
      _poker_phase = POKER_STATE_END;
   } else {
      call_out("tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n");
   }
}
void deal_cards() {
   string id;
   class player_data data;
   _deck = make_deck(1, 0);
   _deck = shuffle_deck(_deck);
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      data->hand = sort_cards(_deck[0..4], 3);
      data->bet = 0;
      if (data->state != POKER_STATE_FOLDED) {
         if (!_max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
      data->hand_type = query_hand_type(data->hand);
      _deck = _deck[5..];
      if (query_player_object(id)) {
         tell_player(id, "Your hand:\n" +
                query_hand_string(data->hand, CARD_HAND_THREE|CARD_HAND_LETTERS,
                                  query_player_object(id)->query_cols()) +
            query_hand_type_string(data->hand_type) + ".\n");
      }
   }
   if (!_max_draw_rounds) {
      _poker_phase = POKER_STATE_FINAL_BET;
   } else {
      _poker_phase = POKER_STATE_BET;
   }
   next_person_turn();
   tell_all_players(query_player_cap_name(query_current_player()) +
                    " goes first.\n");
   _current_bet = 0;
}
int start_game() {
   class player_data data;
   string id;
   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->bet = 0;
      data->hand = ({ });
      data->state = POKER_STATE_ANTE;
      set_player_data(id, data);
   }
   _poker_phase = POKER_STATE_ANTE;
   _pot = 0;
   _finished = 0;
   _draw_round = 0;
   _discard = ({ });
   tell_all_players("%^BOLD%^Place your ante to start playing.%^RESET%^\n");
   return 1;
}
void check_for_finish_ante() {
   string id;
   class player_data data;
   object ob;
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      ob = query_player_object(id);
      if (ob && !interactive(ob)) {
         data->state = POKER_STATE_FOLDED;
      }
      if (ob && interactive(ob) && data->state == POKER_STATE_ANTE) {
         return ;
      }
   }
   _poker_phase = POKER_STATE_BET;
   call_out("deal_cards", 2);
}
int is_card_higher(class playing_card card_new, class playing_card card_old) {
   if (card_new->number == card_old->number) {
      return 0;
   }
   if (card_new->number == CARD_NUMBER_ACE) {
      return 1;
   }
   if (card_old->number == CARD_NUMBER_ACE) {
      return 0;
   }
   if (card_new->number > card_old->number) {
      return 1;
   }
   return 0;
}
class hand_type query_hand_type(class playing_card* hand) {
   int high_num;
   int num;
   int id;
   int i;
   int j;
   class playing_card* tmp_hand;
   class hand_type ret_type;
   class playing_card tmp_card;
   ret_type = new(class hand_type);
   high_num = 0;
   for (i = 1; i < sizeof(hand); i++) {
      if (is_card_higher(hand[i], hand[high_num])) {
         high_num = i;
      }
   }
   ret_type->hand_type = HAND_TYPE_HIGH_CARD;
   ret_type->high_card = hand[high_num];
   high_num = 1;
   for (i = 0; i < sizeof(hand) - 1; i++) {
      num = 1;
      for (j = 0; j < sizeof(hand) - i - 1; j++) {
         if (hand[i]->number == hand[i + j + 1]->number) {
            num++;
         }
      }
      if (num > high_num) {
         high_num = num;
         id = hand[i]->number;
      }
   }
   tmp_hand = hand;
   if (high_num > 1) {
      for (i = 0; i < sizeof(tmp_hand); i++) {
         if (tmp_hand[i]->number == id) {
            ret_type->duplicate_1 = tmp_hand[i];
            tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            i--;
         }
      }
   }
   if (high_num == 2) {
      high_num = 1;
      for (i = 0; i < sizeof(tmp_hand) - 1; i++) {
         num = 1;
         for (j = 0; j < sizeof(tmp_hand) - i - 1; j++) {
            if (tmp_hand[i]->number == tmp_hand[i + j + 1]->number) {
               num++;
            }
         }
         if (num > high_num) {
            high_num = num;
            id = tmp_hand[i]->number;
         }
      }
      if (high_num == 2) {
         ret_type->hand_type = HAND_TYPE_TWO_PAIR;
         for (i = 0; i < sizeof(tmp_hand); i++) {
            if (tmp_hand[i]->number == id) {
               ret_type->duplicate_2 = tmp_hand[i];
               tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            }
         }
         if (is_card_higher(ret_type->duplicate_2, ret_type->duplicate_1)) {
            tmp_card = ret_type->duplicate_1;
            ret_type->duplicate_1 = ret_type->duplicate_2;
            ret_type->duplicate_2 = tmp_card;
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      } else {
         ret_type->hand_type = HAND_TYPE_PAIR;
         high_num = 0;
         for (i = 1; i < sizeof(tmp_hand); i++) {
            if (is_card_higher(tmp_hand[i], tmp_hand[high_num])) {
               high_num = i;
            }
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 3) {
      if (tmp_hand[0]->number == tmp_hand[1]->number) {
         ret_type->hand_type = HAND_TYPE_FULL_HOUSE;
         ret_type->duplicate_2 = tmp_hand[0];
         ret_type->kickers = ({ });
      } else {
         ret_type->hand_type = HAND_TYPE_THREE;
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 4) {
      ret_type->hand_type = HAND_TYPE_FOUR;
      ret_type->high_card = tmp_hand[0];
      return ret_type;
   }
   for (i = 0; i < sizeof(hand) - 1; i++) {
      if (hand[i + 1]->suit != hand[0]->suit) {
         break;
      }
   }
   if (i == sizeof(hand) - 1) {
      ret_type->hand_type = HAND_TYPE_FLUSH;
      ret_type->kickers = sort_cards(hand, 3);
      high_num = 0;
      for (i = 1; i < sizeof(hand); i++) {
         if (is_card_higher(hand[i], hand[high_num])) {
            high_num = i;
         }
      }
      ret_type->high_card = hand[high_num];
   }
   tmp_hand = sort_array(hand, (: ((class playing_card)$1)->number -
                                  ((class playing_card)$2)->number :));
   if (tmp_hand[0]->number == CARD_NUMBER_ACE) {
      if (tmp_hand[1]->number == 2) {
         j = 1;
      } else {
         j = 0;
         tmp_hand = tmp_hand[1..] + ({ tmp_hand[0] });
      }
   } else {
      j = 0;
   }
   for (i = j; i < sizeof(tmp_hand) - 1; i++) {
      if (tmp_hand[i]->number + 1 != tmp_hand[i + 1]->number) {
         if (tmp_hand[i + 1]->number != CARD_NUMBER_ACE ||
             tmp_hand[i]->number != CARD_NUMBER_KING) {
            break;
         }
      }
   }
   if (i == sizeof(tmp_hand) - 1) {
      if (ret_type->hand_type == HAND_TYPE_FLUSH) {
         ret_type->hand_type = HAND_TYPE_STRAIGHT_FLUSH;
         ret_type->high_card = tmp_hand[<1];
      } else {
         ret_type->hand_type = HAND_TYPE_STRAIGHT;
         ret_type->high_card = tmp_hand[<1];
      }
   }
   if (ret_type->hand_type == HAND_TYPE_HIGH_CARD) {
      ret_type->kickers = sort_cards(hand, 3);
   }
   return ret_type;
}
int is_greator_hand(class hand_type new_hand,
                    class hand_type old_hand) {
   int i;
   if (new_hand->hand_type > old_hand->hand_type) {
      return 1;
   }
   if (new_hand->hand_type < old_hand->hand_type) {
      return 0;
   }
   if (new_hand->hand_type == old_hand->hand_type) {
      switch (new_hand->hand_type) {
      case HAND_TYPE_HIGH_CARD :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(old_hand->high_card,
                            new_hand->high_card)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FLUSH :
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_TWO_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_THREE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FOUR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_FULL_HOUSE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         break;
      case HAND_TYPE_STRAIGHT :
      case HAND_TYPE_STRAIGHT_FLUSH :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 0;
         }
         break;
      }
   }
   return TIE;
}
void test_hand_type() {
   class playing_card* other_tmp_hand;
   class playing_card* tmp_hand;
   other_tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 12),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13) });
   tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 2),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 3),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 4),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 1),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 5) });
write(query_hand_type_string(query_hand_type(tmp_hand)) + " --\n" +
      query_hand_type_string(query_hand_type(other_tmp_hand)));
printf("%O\n", sizeof(query_hand_type(tmp_hand)->kickers));
printf("%O\n", sizeof(query_hand_type(other_tmp_hand)->kickers));
write("Result: " + is_greator_hand(query_hand_type(tmp_hand),
      query_hand_type(other_tmp_hand)) + "\n");
}
void complete_round(int force_end) {
   string stuff;
   object ob;
   class player_data data;
   string id;
   string place;
   string* winner;
   class hand_type winning_hand_type;
   class playing_card* winning_hand;
   int paid;
   int discard;
   int result;
   int num;
   if (_finished) {
      return 0;
   }
   place = query_money_place();
   stuff = "";
   winner = ({ });
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if ((data->state == POKER_STATE_BET || discard) && !force_end) {
         if (data->state != POKER_STATE_FOLDED) {
            data->state = POKER_STATE_DISCARD;
            data->bet = 0;
         }
         discard = 1;
      } else if (data->state != POKER_STATE_FOLDED) {
         num++;
         if (!winning_hand) {
            winning_hand = data->hand;
            winning_hand_type = data->hand_type;
            winner = ({ id });
         } else {
            data->hand_type = query_hand_type(data->hand);
            result = is_greator_hand(data->hand_type, winning_hand_type);
            if (result == TIE) {
               winner += ({ id });
            } else if (result) {
               winning_hand = data->hand;
               winning_hand_type = data->hand_type;
               winner = ({ id });
            }
         }
         stuff += query_player_cap_name(id) + "'s hand (" +
                  query_hand_type_string(data->hand_type) + "):\n" +
                  query_hand_string(data->hand, CARD_HAND_SINGLE,
                                     this_player()->query_cols()) + "\n";
      }
   }
   if (num == 1) {
      stuff = "All but one person folded so the cards are not revealed.\n";
   }
   if (discard) {
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state == POKER_STATE_FOLDED) {
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "You have folded.\n");
         } else {
            data->bet = 0;
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "Your hand:\n" +
               query_hand_string(data->hand, CARD_HAND_THREE | CARD_HAND_LETTERS,
                                    80));
         }
      }
   } else {
      if (_house_cut) {
         stuff += "House takes " +
            MONEY_HAND->money_value_string((_pot * _house_cut) / 100, place) +
                  ".\n";
        adjust_float((_pot * _house_cut) / 100);
        _pot -= (_pot * _house_cut) / 100;
      }
      if (sizeof(winner) > 1) {
         stuff += "Tie for winning between " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", they each win " +
                  MONEY_HAND->money_value_string(_pot / sizeof(winner), place) +
                  ".\n";
         paid = _pot / sizeof(winner);
         foreach (id in winner) {
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(paid, place), place);
               _player_stats[ob->query_name()] += paid;
            } else {
               stuff += "Unable to find " + id + " to pay them, money "
                               "going to the house.\n";
               adjust_float(paid);
            }
         }
      } else {
         stuff += "Winner is " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", and they win " +
                  MONEY_HAND->money_value_string(_pot, place) +
                  ".\n";
         ob = query_player_object(winner[0]);
         ob->adjust_money(MONEY_HAND->create_money_array(_pot, place), place);
         _player_stats[ob->query_name()] += _pot;
      }
      tell_all_players("The players reveal their cards as:\n" +
                       stuff);
      tell_room(environment(), "The game ends with " + query_multiple_short(winner) +
                               " as the winner.\n");
      finish_game(query_multiple_short(winner));
      _finished = 1;
   }
}
void finish_discard() {
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_AFTER_DISCARD &&
          data->state != POKER_STATE_FOLDED) {
         return 0;
      }
   }
   _draw_round++;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state == POKER_STATE_AFTER_DISCARD) {
         if (_draw_round >= _max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
   }
   _current_bet = 0;
   _poker_phase = POKER_STATE_FINAL_BET;
   call_out("tell_all_players", 0,
            "Discard round completed.  Now onto the " +
            (_draw_round >= _max_draw_rounds?"final ":"") + "betting round.\n");
   next_person_turn();
}
int do_ante() {
   string place;
   string id;
   int amount;
   class player_data data;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != POKER_STATE_ANTE) {
      add_failed_mess("You have already put in your ante.\n");
      return 0;
   }
   place = query_money_place();
   amount = _ante_house + _ante_amount;
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " to meet the ante.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amount;
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);
   adjust_float(_ante_house);
   _pot += _ante_amount;
   data->state = POKER_STATE_PAID_ANTE;
   environment()->event_save(this_object());
   check_for_finish_ante();
   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
}
int do_discard(string throw_away) {
   int i;
   string id;
   class player_data data;
   string* bits;
   int* new_bits;
   throw_away = lower_case(throw_away);
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot discard before you have been dealt "
                      "cards.\n");
      return 0;
   }
   if (data->state != POKER_STATE_DISCARD) {
      add_failed_mess("You are not in the discard phase.\n");
      return 0;
   }
   if (throw_away && throw_away != "none") {
      throw_away = lower_case(replace_string(throw_away, " ", ""));
      bits = explode(throw_away, ",");
      if (sizeof(filter(bits, (: strlen($1) > 1 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      new_bits = map(bits, (: $1[0] - 'a' :));
      if (sizeof(filter(new_bits, (: $1 < 0 || $1 >= 5 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      for (i = 0; i < sizeof(new_bits); i++) {
         if (member_array(new_bits[i],
                          new_bits[0..i-1] + new_bits[i+1..]) != -1) {
            add_failed_mess("You have referenced the card " +
                            sprintf("%c", 'A' + new_bits[i]) + " twice.\n");
            return 0;
         }
      }
      new_bits = sort_array(new_bits, (: $2 - $1 :));
      for (i = 0; i < sizeof(new_bits); i++) {
         _discard += ({ data->hand[new_bits[i]] });
         data->hand = data->hand[0..new_bits[i]-1] +
                      data->hand[new_bits[i]+1..];
      }
      i = 5 - sizeof(data->hand) - 1;
      if (sizeof(_deck) < i) {
         _deck += _discard;
         _deck = shuffle_array(_deck);
         _discard = ({ });
      }
      data->hand += _deck[0..i];
      _deck = _deck[i + 1..];
      data->hand = sort_cards(data->hand, 3);
      data->hand_type = query_hand_type(data->hand);
      add_succeeded_mess(({ "", "$N draw$s " + query_num(sizeof(new_bits)) +
                                " new card" +
                               (sizeof(new_bits) > 1?"s":"") + " on $D.\n" }));
      write("Your new hand (" +
            query_hand_type_string(data->hand_type) +
            "):\n" +
            query_hand_string(data->hand, CARD_HAND_THREE,
                                  this_player()->query_cols()));
      data->state = POKER_STATE_AFTER_DISCARD;
   } else {
      new_bits = ({ });
      data->state = POKER_STATE_AFTER_DISCARD;
      add_succeeded_mess("$N do$es not discard any cards on $D.\n");
   }
   finish_discard();
   return 1;
}
int do_check() {
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (_current_bet) {
      add_failed_mess("You cannot check since betting has started.\n");
      return 0;
   }
   add_succeeded_mess("$N check$s on $D.\n");
   next_person_turn();
   return 1;
}
int do_call() {
   class player_data data;
   int amt;
   string place;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (!_current_bet) {
      add_failed_mess("No one has bet anything for you to call.\n");
      return 0;
   }
   place = query_money_place();
   data = query_player_data(query_current_player());
   if (_current_bet && data->bet == _current_bet) {
      call_out("complete_round", 2);
      if (_poker_phase == POKER_STATE_ANTE) {
         _poker_phase = POKER_STATE_DISCARD;
      } else {
         _poker_phase = POKER_STATE_ANTE;
      }
   } else {
      amt = _current_bet - data->bet;
      if (this_player()->query_value_in(place) < amt) {
         add_failed_mess("You do not have the necessary " +
                         MONEY_HAND->money_value_string(amt, place) +
                         " to call the bet.\n");
         return 0;
      }
      _player_stats[this_player()->query_name()] -= amt;
      this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
      _pot += amt;
      data->bet = _current_bet;
      if (!check_end_round()) {
         next_person_turn();
      }
   }
   add_succeeded_mess("$N call$s the bet by adding " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to the pot for a total bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   return 1;
}
int do_raise(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   raise_amt = amt;
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_bet(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt == _current_bet) {
      return do_call();
   }
   if (amt < _current_bet) {
      add_failed_mess("You have to bet higher than the current bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " money amount.\n");
      return 0;
   }
   amt = amt - _current_bet;
   raise_amt = amt;
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_fold() {
   class player_data data;
   string id;
   int not_folded;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   data->state = POKER_STATE_FOLDED;
   add_succeeded_mess("$N fold$s on $D.\n");
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         not_folded++;
      }
   }
   if (not_folded == 1) {
      call_out("complete_round", 0, 1);
      _poker_phase = POKER_STATE_END;
   } else if (!check_end_round()) {
      next_person_turn();
   }
   return 1;
}
int do_start() {
   int old_pot;
   if (!is_open_for("poker", this_player()->query_name())) {
      add_failed_mess("The poker table is not open.\n");
      return 0;
   }
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }
   old_pot = _pot;
   if (!start_game()) {
      add_failed_mess("You need at least two people to play poker.\n");
      return 0;
   }
   adjust_float(old_pot);
   add_succeeded_mess("$N $V a game on $D.\n");
   return 1;
}
int do_finish() {
   string person;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }
   finish_game(0);
   reset_game();
   return 1;
}
string query_main_status(int hint) {
   string place;
   string ret;
   string name;
   int amt;
   place = query_money_place();
   ret = "$I$0=Poker table:\n"
          "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Ante       : " +
              MONEY_HAND->money_value_string(_ante_amount, place) +
          "\n$I$6=   House Ante : " +
              MONEY_HAND->money_value_string(_ante_house, place) +
          "\n$I$6=   Draw Rounds: " + _max_draw_rounds +
          "\n$I$6=   Cut        : " + _house_cut + "%"
          "\n$I$6=   Revenue    : " +
              MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$0=";
   foreach (name, amt in _player_stats) {
      ret += sprintf(" %-13s: %s\n" , name,
                     MONEY_HAND->money_value_string(amt, place));
   }
   return ret + "\n";
}
int do_set_ante(string str, int ante_game) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (lower_case(str) == "none" && !ante_game) {
      value = 0;
   } else {
      place = query_money_place();
      value = MONEY_HAND->value_from_string(str, place);
      if (!value) {
         add_failed_mess("Unable to parse the string " + str + ".\n");
         return 0;
      }
   }
   if (ante_game) {
      _ante_amount = value;
      add_succeeded_mess("$N set$s the ante amount to play to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _ante_house = value;
      add_succeeded_mess("$N set$s the ante amount for the house to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_bet(string str, int max_bet) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   _house_cut = percent;
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_draw(int draw) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (draw < 0) {
      add_failed_mess("You cannot set the number of draws less than 0.\n");
      return 0;
   }
   if (draw > 5) {
      add_failed_mess("You cannot set the draw to greator than 5.\n");
      return 0;
   }
   _max_draw_rounds = draw;
   add_succeeded_mess("$N set$s the number of draw rounds to " + draw + " on $D.\n");
   return 1;
}
int do_rules() {
   string ret;
   string place;
   place = query_money_place();
   ret = "The rules for this table are:\n";
   ret += "$I$6=   Maximum amount that can be raised " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum amount that can be raised " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Total ante " +
              MONEY_HAND->money_value_string(_ante_amount + _ante_house, place) +
          "\n$I$6=   Cut of the pool : " + _house_cut +
          "\n$I$6=   Draw Rounds     : " + _max_draw_rounds +
          "\n$I$6=   House Ante      : " +
              MONEY_HAND->money_value_string(_ante_house, place);
   write("$P$Rules$P$" + ret);
}
int do_reset() {
   if (::do_reset()) {
      _player_stats = ([ ]);
      add_succeeded_mess("$N clear$s the player stats.\n");
      return 1;
   }
}
void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("discard", "<string'card'> on <direct:object>",
               (: do_discard($4[0]) :));
   add_command("ante", "on <direct:object>",
               (: do_ante() :));
   add_command("check", "on <direct:object>",
               (: do_check() :));
   add_command("call", "on <direct:object>",
               (: do_call() :));
   add_command("bet", "<string'total bet'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("raise", "<string'raise'> on <direct:object>",
               (: do_raise($4[0]) :));
   add_command("fold", "on <direct:object>",
               (: do_fold() :));
   add_command("finish", "game on <direct:object>",
               (: do_finish() :));
   add_command("start", "game on <direct:object>",
               (: do_start() :));
   add_command("rules", "<direct:object>",
               (: do_rules() :));
   add_command("rules", "{for|on|of} <direct:object>",
               (: do_rules() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "draw <number'rounds'> on <direct:object>",
                  (: do_set_draw($4[0]) :));
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "ante house <string'amount|none'> on <direct:object>",
                  (: do_set_ante($4[0], 0) :));
      add_command("set", "ante game <string'amount'> on <direct:object>",
                  (: do_set_ante($4[0], 1) :));
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
   }
}
void resign_person(string id) {
   class player_data data;
   int not_folded;
   data = query_player_data(id);
   if (data && data->state != POKER_STATE_FOLDED) {
      tell_all_players(query_player_cap_name(id) +
                       " resigns and folds.\n");
      data->state = POKER_STATE_FOLDED;
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state != POKER_STATE_FOLDED) {
            not_folded++;
         }
      }
      if (not_folded == 1) {
         call_out("complete_round", 0, 1);
         _poker_phase = POKER_STATE_END;
      }
   } else {
      switch (_poker_phase) {
      case POKER_STATE_ANTE :
         check_for_finish_ante();
         break;
      case POKER_STATE_BET :
         check_end_round();
         break;
      case POKER_STATE_DISCARD :
         finish_discard();
         break;
      }
   }
}
void event_exit(object ob, string mess, object to) {
   string id;
   if (userp(ob) && to != environment()) {
      id = find_player_id_of_person(ob);
      if (id) {
         resign_person(id);
      }
   }
}
void multiplayer_someone_resigns(string id, string name) {
   resign_person(id);
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, BOARD_TAG, "return", _return);
   add_auto_load_value(map, BOARD_TAG, "ante amount", _ante_amount);
   add_auto_load_value(map, BOARD_TAG, "house cut", _house_cut);
   add_auto_load_value(map, BOARD_TAG, "ante house", _ante_house);
   add_auto_load_value(map, BOARD_TAG, "min bet", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "current bet", _current_bet);
   add_auto_load_value(map, BOARD_TAG, "pot", _pot);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "poker phase", _poker_phase);
   add_auto_load_value(map, BOARD_TAG, "draw round", _draw_round);
   add_auto_load_value(map, BOARD_TAG, "max draw rounds", _max_draw_rounds);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "player stats", _player_stats);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);
   _return = query_auto_load_value(map, BOARD_TAG, "return");
   _ante_amount = query_auto_load_value(map, BOARD_TAG, "ante amount");
   _ante_house = query_auto_load_value(map, BOARD_TAG, "ante house");
   _house_cut = query_auto_load_value(map, BOARD_TAG, "house cut");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _current_bet = query_auto_load_value(map, BOARD_TAG, "current bet");
   _pot = query_auto_load_value(map, BOARD_TAG, "pot");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _poker_phase = query_auto_load_value(map, BOARD_TAG, "poker phase");
   _draw_round = query_auto_load_value(map, BOARD_TAG, "draw round");
   _max_draw_rounds = query_auto_load_value(map, BOARD_TAG, "max draw rounds");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _player_stats = query_auto_load_value(map, BOARD_TAG, "player stats");
   if (!_player_stats) {
      _player_stats = ([ ]);
   }
}

==================================================
FILE: room/furniture/shop_base.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/player_craft_shop_base";
#define SAVE_TIME 1
private int _save_call;
private int _last_saved;
private string _counter_short;
#define OBJECT_TAG "shop base"
void create() {
   player_craft_shop_base::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("craft shop");
}
int query_player_craft_shop() {
   return 1;
}
int disallow_sale_here(object room) {
   object* obs;
   obs = room->find_commercial_items(query_commercial_name());
   return sizeof(obs);
}
int query_royalty(string person) {
   return commercial::query_royalty(person);
}
string query_craft_shop_save_dir() {
   return environment()->query_save_dir() + "craft_shop";
}
void adjust_royalty(string person, int amount) {
   commercial::adjust_royalty(person, amount);
}
string query_parcel_post() {
   return commercial::query_parcel_post();
}
void reset_weekly_status() {
   player_craft_shop_base::reset_weekly_status();
}
string query_weekly_status_string() {
   return player_craft_shop_base::query_weekly_status_string();
}
void load_me() {
  string fname, tmp;
#ifdef USE_RAMDISK
  tmp = replace_string(query_save_dir() + "craft_shop_file", "/save/",
                       "/save/ramdisk/");
  if(unguarded((: file_size($(tmp) = ".o.gz") :)) > 0 ||
     unguarded((: file_size($(tmp) = ".o") :)) > 0) {
    fname = tmp;
  }
#endif
  if(!fname) {
    fname = query_save_dir() + "craft_shop_file";
  }
   unguarded( (: restore_object($(fname)) :));
#ifdef USE_RAMDISK
   tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                        "/save/ramdisk/");
   unguarded( (: mkdir($(tmp)) :));
#endif
   unguarded( (: mkdir(query_craft_shop_save_dir()) :));
   reload_shop();
   add_property("place", environment()->query_property("place"));
}
void init() {
   player_craft_shop_base::init();
   commercial::init();
}
void do_save() {
  string fname;
  string dir;
   _save_call = 0;
   if (environment() && query_save_dir()) {
#ifdef USE_RAMDISK
     dir = replace_string(query_save_dir(), "/save/",
                            "/save/ramdisk/");
     if (file_size(dir) == -2) {
        fname = dir + "craft_shop_file";
     }
#endif
     if(!fname) {
       fname = query_save_dir() + "craft_shop_file";
     }
     debug_printf("Saving to %O\n", fname);
     unguarded( (: save_object($(fname), 2) :));
   }
}
void dest_me() {
   do_save();
   player_craft_shop_base::dest_me();
   commercial::dest_me();
}
string query_commercial_information() {
   return "This shop can have a maximum of " + query_maximum_inventory_size() +
          " items for sale.  "
          "You can only have "
          "one shop counter in any room, more than one will not be "
          "able to be bought.";
}
void event_save(object ob) {
   if (!_save_call) {
      if(_last_saved > time() - SAVE_TIME) {
         _save_call = call_out("do_save", SAVE_TIME - (time() - _last_saved));
      } else {
         _save_call = call_out("do_save", SAVE_TIME);
      }
#ifdef DEBUG
      debug_printf("Adding call_out");
#endif
   }
}
mapping query_commercial_options() {
   return ([
    "counter type" : ([
       "polished hardwood counter" : 500000,
       "shiny polished counter" : 150000,
       "unfinished pine counter" : 0,
      ]),
   "stockroom size" : ([
       "50" : 0,
       "100" : 1000000,
       "150" : 2500000,
      ]),
   ]);
}
void set_commercial_option(string type, string name) {
   string* bits;
   int size;
   switch (type) {
   case "counter type" :
      _counter_short = name;
      set_short(_counter_short);
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
      break;
   case "stockroom size" :
      sscanf(name, "%d", size);
      set_maximum_waiting_queue_size(size);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "stocksize", query_maximum_waiting_queue_size());
   add_auto_load_value(map, OBJECT_TAG, "counter short", _counter_short);
}
void init_dynamic_arg(mapping map, object player) {
   string* bits;
   int size;
   commercial::init_dynamic_arg(map, player);
   size = query_auto_load_value(map, OBJECT_TAG, "stocksize");
   _counter_short = query_auto_load_value(map, OBJECT_TAG, "counter short");
   if (size) {
      set_maximum_waiting_queue_size(size);
   }
   if (_counter_short) {
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
   }
}
