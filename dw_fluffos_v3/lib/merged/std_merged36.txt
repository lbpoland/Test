




==================================================
FILE: /lib/std/effects/external/insect_repellent.c
==================================================

#include "effect.h"
string query_classification() {
  return "herb.insect.repellent";
}
int beginning(object them, int power, int id) {
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->add_property("insect", power);
  them->submit_ee("start_mess", 2, EE_ONCE);
  them->submit_ee("smell", ({30, 60}), EE_CONTINUOUS);
  return power;
}
int merge_effect(object them, int power, int adjust) {
  power += adjust;
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->submit_ee(0, -1, EE_REMOVE);
  return power;
}
void start_mess(object them, int power, int id) {
  string start_mess;
  switch (power) {
  case 1:
    start_mess = "You smell rather pleasant, much as you might wish to for a "
           "date.";
    break;
  case 2..3:
    start_mess = "A pungent smell envelops you.";
    break;
  default:
    start_mess = "A horribly pungent smell envelops you, sufficient to make "
           "anyone with a sense of smell keep their distance.";
  }
  tell_object(them, start_mess+"\n");
}
void smell(object them, int power, int id) {
  string self_mess, other_mess;
  object env;
  if (--power <= 0) {
    tell_object(them, "The herbal odour around you fades away.\n");
    them->remove_property("insect");
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  switch (power) {
  case 1:
    self_mess = "A pleasant smell emanates from your body.";
    other_mess = "A pleasant smell emanates from "+them->one_short()+".";
    break;
  case 2..3:
    self_mess = "A pungent herbal smell emanates from your body.";
    other_mess = "A pungent herbal smell emanates from "+them->one_short()+".";
    break;
  default:
    self_mess = "You reek of pungent herbs.";
    other_mess = "$C$"+them->one_short()+" $V$0=reeks,reek$V$ of pungent "
           "herbs.";
  }
  tell_object(them, self_mess+"\n");
  if ((env = environment(them)) && env->query_property("location")) {
    tell_room(env, other_mess+"\n", them);
  }
}

==================================================
FILE: /lib/std/effects/external/snowball.c
==================================================

#include <effect.h>
string query_classification() { return "mudlib.snowball"; }
void beginning( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
   player->submit_ee( "decrease_amount", 15, EE_CONTINUOUS );
}
void restart( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
}
int merge_effect( object player, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
}
void end( object player, int amount, int id ) {
   player->remove_extra_look( this_object() );
}
void decrease_amount( object player, int amount, int id ) {
   amount -= 3 + random( random(amount) );
   if ( amount < 0 ) {
      amount = 0;
      player->submit_ee( 0, 1, EE_REMOVE );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), amount );
   player->add_effect("/std/effects/other/wetness", roll_MdN( 10, 10 ) );
}
string extra_look( object player ) {
   int *enums;
   string desc;
   enums = (int *)player->effects_matching( "mudlib.snowball" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)player->arg_of( enums[ 0 ] ) ) {
      case 0 .. 99 :
         desc = " has a little bit of snow";
         break;
      case 100 .. 199 :
         desc = " has a bit of snow";
         break;
      case 200 .. 299 :
         desc = " has a few small lumps of snow";
         break;
      case 300 .. 399 :
         desc = " has a few lumps of snow";
         break;
      case 400 .. 499 :
         desc = " has a number of lumps of snow";
         break;
      case 500 .. 599 :
         desc = " has quite a lot of snow";
         break;
      case 600 .. 699 :
         desc = " has a lot of snow";
         break;
      default :
         desc = " has a thick layer of snow";
   }
   return capitalize( (string)player->query_pronoun() ) + desc +" on "+
         (string)player->query_possessive() +" face.\n";
}

==================================================
FILE: /lib/std/effects/disease/basic_disease.c
==================================================

#include <effect.h>
#include <disease.h>
int do_setup;
string name, classification, shadow_ob;
void set_name( string str ) { name = str; }
string query_name() { return name; }
void set_classification( string str ) { classification = str; }
string query_classification() { return classification; }
void create() {
   name = "Some undefined disease";
   classification = "disease.unset";
   if ( !do_setup )
      this_object()->setup();
}
int cure( object person, string cure_classification, int power, int enum ) {
   int arg, i, scale;
   string *cure_class, *disease_class;
   arg = person->arg_of( enum );
   disease_class = explode( classification, "." )[ 1 .. <1 ];
   cure_class = explode( cure_classification, "." )[ 1 .. <1 ];
   while ( sizeof( disease_class ) && sizeof( cure_class ) &&
          ( disease_class[ 0 ] == cure_class[ 0 ] ) ) {
      disease_class = disease_class[ 1 .. <1 ];
      cure_class = cure_class[ 1 .. <1 ];
   }
   scale = 1;
   i = sizeof( disease_class );
   while ( i-- )
      scale *= DISEASE_SCALE[ i ];
   i = sizeof( cure_class );
   while ( i-- )
      scale *= CURE_SCALE[ i ];
   arg -= power / scale;
   power = -arg * scale;
   person->set_arg_of( enum, arg );
   if ( arg > 0 )
      this_object()->disease_better( person, arg );
   return power;
}

==================================================
FILE: /lib/std/effects/disease/common_cold.c
==================================================

#include <disease.h>
#include <effect.h>
inherit SIMPLE_DISEASE;
void setup() {
   set_name( "Common Cold" );
   set_cure_rate( 6 );
   set_classification( "disease.infection.respiratory.cold" );
}
int disease_start( object player, int arg, int sid ) {
   tell_object( player, "You realise that your nose is running.\n" );
   player->submit_ee2( sid, "sap_strength", ({ 600, 600 }), EE_CONTINUOUS );
   return arg;
}
void disease_end( object player, int arg, int sid ) {
   if ( !player->query_property( "dead" ) )
      tell_object( player, "You realise that your nose is clear again.\n" );
}
void disease_action( object player, int arg ) {
   switch ( random( 3 ) ) {
      case 0 :
         player->new_parser( "sniff" );
         break;
      case 1 :
         player->new_parser( "cough" );
         break;
      default :
         player->new_parser( "sneeze" );
   }
}
void sap_strength( object player ) {
   tell_object( player, "You feel your strength being sapped by the cold.\n" );
   player->adjust_tmp_str( -1 );
}

==================================================
FILE: /lib/std/effects/disease/flea_infestation.c
==================================================

#include <effect.h>
#include <disease.h>
inherit SIMPLE_DISEASE;
void setup() {
   set_name( "Fleas" );
   set_classification( "disease.parasite.external.flea" );
  set_infection_chance( 2 );
   set_infection_check( (: living( $1 ) &&
               ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
               $1->query_mature() ) && !$1->query_property( "dead" ) :) );
}
int disease_start( object player, int arg, int ) {
   string race_ob;
   race_ob = (string)player->query_race_ob();
   if ( ( (string)race_ob->query_name() == "troll" ) ||
         player->query_property( "no fleas" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   return arg;
}
void disease_action( object player, int, int ) {
   switch( random( 14 ) ) {
      case 0 .. 3 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Something itches.  You scratch yourself.\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " scratches "+ (string)player->query_objective() +"self.\n",
               player );
         break;
      case 4 .. 7 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Ouch!  Something bit you!\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " starts as if bitten.\n", player );
         player->adjust_hp( -10 - random( 10 ) );
         break;
      case 8 .. 11 :
         tell_object( player, "You notice a small red welt on your skin.\n" );
         break;
      default:
   }
   if(!random(10) && !userp(player))
     player->submit_ee(0, 0, EE_REMOVE);
}
int test_remove( object player, int arg, int enum, int bonus ) {
   log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
   if ( arg + bonus < 30 ) {
      player->set_arg_of( enum, arg + bonus );
      return 0;
   }
   return 1;
}

==================================================
FILE: /lib/std/effects/disease/flu.c
==================================================

#include <effect.h>
#include "path.h"
int query_secs_between_hb() { return 1; }
string query_classification() { return "disease.infection.general.flu"; }
int beginning(object player, mixed arg) {
   tell_object(player, "You shiver.\n");
   return arg;
}
int effect_heart_beat(object player, int hbnum, mixed arg, int id){
   if (hbnum == arg) return REMOVE_THIS_EFFECT;
   return arg;
}
void end(object player) {
   tell_object(player, "You feel altogether healthy again.\n");
}
string query_shadow_ob(){ return SHADOWS+"flu_shadow"; }

==================================================
FILE: /lib/std/effects/disease/general_hypothermia.c
==================================================

#include <effect.h>
#include <weather.h>
#include <clothing.h>
#define DEBUG 1
#define COMFORTABLE 20
#define DEATH -500
void shiver(object player, int temperatureess, int id);
int calc_personal_temp(object player);
string query_classification() { return "disease.hypothermia"; }
int beginning( object player, int temperature, int id ) {
  if(temperature + calc_personal_temp(player) < COMFORTABLE) {
    tell_object(player, "You feel a bit chilly.\n");
    player->submit_ee( "shiver", ({ 20, 20 }), EE_CONTINUOUS );
    player->submit_ee( "stat_adjusts", ({ 240, 240 }), EE_CONTINUOUS );
    player->add_extra_look( this_object() );
  } else {
    player->submit_ee(0, 0, EE_REMOVE );
  }
  return temperature + calc_personal_temp(player) - COMFORTABLE;
}
int merge_effect( object player, int new_temperature, int old_temperature,
                  int id ) {
  return old_temperature + (new_temperature + calc_personal_temp(player) -
                            COMFORTABLE);
}
void restart(object player) {
  player->add_extra_look( this_object() );
}
void end( object player ) {
  tell_object( player, "You don't feel cold anymore.\n" );
  player->remove_extra_look( this_object() );
}
void shiver(object player, int temperature, int id) {
  int *enums, pwet, personal;
  int room_temp, min;
  if (!environment(player))
    return;
  room_temp = WEATHER->temperature_index(environment(player));
  personal = calc_personal_temp(player);
  if(room_temp + personal > COMFORTABLE)
    temperature += (room_temp + personal - COMFORTABLE);
  min = 100 * (personal + room_temp - COMFORTABLE);
  if(min > COMFORTABLE)
    min = personal + room_temp - COMFORTABLE;
  if(temperature < min)
    temperature = min;
  if(temperature >= COMFORTABLE)
    player->submit_ee(0, 0, EE_REMOVE );
  if ( temperature < DEATH ) {
    player->dest_hide_shadow();
    tell_object( player, "The cold is just too much for you.\n" );
    tell_room( environment( player ), "Frost riming "+
              (string)player->query_possessive() +" skin in a thick crust, "+
              (string)player->the_short() +" expires.\n", player );
    player->do_death();
    return;
  }
  switch(random(4)) {
  case 0 :
    player->new_parser("shiver");
    tell_object(player, "You feel cold to your bones.\n");
    break;
  case 1 :
    player->dest_hide_shadow();
    tell_object( player, "You rub your arms briskly in an attempt to "+
                "keep warm.\n" );
    tell_room( environment( player ),
              capitalize( (string)player->short() ) +" rubs "+
              (string)player->query_possessive() +" arms briskly.\n",
              player );
    break;
  case 2 :
    player->new_parser("shiver");
    enums = (int *)player->effects_matching("body.wetness");
    if ( sizeof( enums ) )
      pwet = (int)player->arg_of( enums[ 0 ] );
    if ( (int)pwet > 25 ) {
      tell_object( player, "You dislodge a lump of ice, which falls "+
                  "to the ground and shatters.\n" );
      tell_room( environment( player ),
                capitalize( (string)player->short() ) +" dislodges a lump "+
                "of ices, which falls to the ground and shatters.\n",
                player );
      player->add_effect("/std/effects/other/wetness", -25 );
    }
    break;
  default :
    player->new_parser("shiver");
    tell_object(player, "You feel really cold.\n" );
  }
  player->set_arg_of( (int)player->sid_to_enum( id ), temperature );
  return;
}
int calc_personal_temp(object player) {
  object where;
  string item, zone, type, *types, *zones;
  int count;
  zones = ({ });
  where = environment(player);
  count = 0;
  if(where->query_property("location") == "inside")
    count += 20;
  count += where->query_property("warmth");
  foreach(item in player->query_wearing()) {
    types = item->query_type();
    if(!arrayp(types))
      types = ({ item->query_type() });
    foreach(type in types) {
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth"))
          count += item->query_property("warmth");
        else
          count ++;
      }
    }
  }
  count += sizeof(zones);
  count += environment(player)->query_property("warmth");
  return count;
}
void stat_adjusts(object player, int temperature, int id ) {
  if(WEATHER->temperature_index(environment(player)) > 0 ||
     temperature > -100)
    return;
  switch(player->query_race()) {
  case "troll":
    tell_object( player, "You feel a tingling between your ears and "+
                 "new and strangely clever thoughts race along the "+
                 "superconducting neural pathways of your brain.\n" );
    player->adjust_int( 1 );
    break;
  default:
    tell_object( player, "You feel your strength being drained by the "+
                 "freezing temperatures.\n" );
    player->adjust_tmp_str( -1 );
    player->adjust_tmp_con( -1 );
    break;
  }
}
string extra_look( object player ) {
  string desc;
  int temperature;
  int *enums;
  enums = (int *)player->effects_matching( "disease.hypothermia" );
  if ( !sizeof( enums ) )
    return "";
  temperature = (int)player->arg_of(enums[0]);
  switch(temperature/5) {
    case -5 .. 100 :
      desc = "looks a bit cold.\n";
      break;
    case -10 .. -6 :
      desc = "looks rather cold.\n";
      break;
    case -30 .. -11 :
      desc = "looks very cold.\n";
      break;
    case -80 .. -31 :
      desc = "appears to be suffering from extreme hypothermia.\n";
      break;
    case -100 .. -81 :
      desc = "looks close to death from hypothermia.\n";
      break;
    default :
      return "";
  }
  return capitalize( (string)player->query_pronoun() ) +" "+ desc;
}

==================================================
FILE: /lib/std/effects/disease/gp_drain_effect.c
==================================================

#include <effect.h>
#include "path.h"
#include "/std/living/stats.c"
#define CLASS "general.gp.drain"
string query_classification(){
  return CLASS;
}
string query_death_reason(){
  return "wasting away slowly";
}
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;
  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }
  tell_object( player, "You feel woozy.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  ( player )->adjust_gp( -damage );
  tell_creator( player,
                "Drain: " + damage + "\n" );
}
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}
void end( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[1] + "\n" );
}
void restart( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[0] + "\n" );
}

==================================================
FILE: /lib/std/effects/disease/headache.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "disease.pain.headache"; }
int beginning(object player, mixed arg) {
   tell_object(player, "Your head hurts.\n");
   player->submit_ee(0, arg, EE_REMOVE);
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}
int restart(object player, mixed arg) {
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( "end", duration, EE_REMOVE );
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   return duration;
}
void pains( object player) {
   switch (random(5)) {
    case 0:
      tell_object( player, "Your head hurts.\n");
      tell_room( environment( player ), player->the_short()
           + " looks pained.\n",  ({ player }) );
      break;
    case 1:
      tell_object( player, "You clutch your aching head.\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive() + " head.\n",
          ({ player }) );
      break;
    case 2:
      tell_object( player, "Owwwwwwwwwwww!\n");
      tell_room( environment( player ), player->the_short()
           + " moans.\n",  ({ player }) );
      break;
    case 3:
      tell_object( player, "Your head pounds!\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive()
           + " head and moans.\n",  ({ player }) );
      break;
    case 4:
      tell_object( player, "Arrrrgh!  Migraine!\n");
      tell_room( environment( player ), player->the_short()
           + " whimpers.\n",  ({ player }) );
      break;
   }
}
void end(object player) {
   tell_object(player, "Your head feels better.\n");
   player->adjust_bonus_con(1);
   player->adjust_bonus_dex(1);
   player->adjust_bonus_wis(1);
   player->adjust_bonus_int(1);
}
string query_shadow_ob(){ return SHADOWS+"disease/headache_shadow"; }

==================================================
FILE: /lib/std/effects/disease/hp_drain_effect.c
==================================================

#include <effect.h>
#include "path.h"
#include "/std/living/stats.c"
#define CLASS "general.hp.drain"
string query_classification(){
  return CLASS;
}
string query_death_reason(){
  return "wasting away slowly";
}
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;
  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }
  tell_object( player, "You feel weak.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  if( ( player )->adjust_hp( -damage ) < 0 ){
    ( player )->attack_by( this_object() );
  }
  tell_creator( player,
                "Damage: " + damage + "\n" );
}
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}
void end( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[1] + "\n" );
}
void restart( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[0] + "\n" );
}

==================================================
FILE: /lib/std/effects/disease/hypothermia.c
==================================================

#include <effect.h>
string query_classification() { return "disease.hypothermia"; }
int beginning( object player, int index, int id ) {
    if ( !index )
        index = 100;
   tell_object( player, "You feel a bit chilly.\n" );
   player->submit_ee( "change_index", ({ 60, 60 }), EE_CONTINUOUS );
   player->submit_ee( "stat_adjusts", ({ 90, 90 }), EE_CONTINUOUS );
   return index;
}
int merge_effect( object player, int index ) { return index; }
void end( object player ) {
   tell_object( player, "You feel a lot warmer now.\n" );
}
void change_index( object player, int index, int id ) {
  int *enums, pwet;
   if ( !environment( player ) )
      return;
   if ( !environment( player )->query_property( "freezer" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   index -= 7 - (int)player->query_con() / 7;
   if ( index < 0 ) {
      player->dest_hide_shadow();
      tell_object( player, "The cold is just too much for you.\n" );
      tell_room( environment( player ), "Frost riming "+
            (string)player->query_possessive() +" skin in a thick crust, "+
            (string)player->the_short() +" expires.\n", player );
      player->do_death();
      return;
   }
   switch( random( 4 ) ) {
      case 0 :
         player->dest_hide_shadow();
         tell_object( player, "You shiver.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" shivers.\n", player );
         break;
      case 1 :
         player->dest_hide_shadow();
         tell_object( player, "You rub your arms briskly in an attempt to "+
               "keep warm.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" rubs "+
               (string)player->query_possessive() +" arms briskly.\n",
               player );
         break;
      case 2 :
        enums = (int *)player->effects_matching("body.wetness");
         if ( sizeof( enums ) )
           pwet = (int)player->arg_of( enums[ 0 ] );
         if ( (int)pwet > 25 ) {
            player->dest_hide_shadow();
            tell_object( player, "You dislodge a lump of ice, which falls "+
                  "and shatters on the floor.\n" );
            tell_room( environment( player ),
                  capitalize( (string)player->short() ) +" dislodges a lump "+
                  "of ices, which falls and shatters on the floor.\n",
                  player );
            player->add_effect("/std/effects/wetness", -25 );
         }
         break;
      default :
         tell_object( player, "You're getting really cold in here.\n" );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), index );
}
void stat_adjusts( object player ) {
   switch ( random( 3 ) ) {
      case 0 :
         tell_object( player, "You feel your strength being drained by the "+
               "below freezing temperatures.\n" );
         player->adjust_tmp_str( -1 );
         return;
      case 1 :
         tell_object( player, "You really don't feel at all well stuck in "+
               "here.\n" );
         player->adjust_tmp_con( -1 );
         return;
      default :
         if ( (string)player->query_race() == "troll" ) {
            tell_object( player, "You feel a tingling between your ears and "+
                  "new and strangely clever thoughts race along the "+
                  "superconducting neural pathways of your brain.\n" );
            player->adjust_int( 1 );
         }
   }
}

==================================================
FILE: /lib/std/effects/disease/rabies.c
==================================================

#include <effect.h>
#define COMBAT_EFFECT "/std/effects/fighting/combat"
string *wretch_msg = ({
    "You start to froth at the mouth and your head spins.\n",
    "The pain is so intense you want to rip your eyes out.\n",
    "The pain from your ripped flesh radiates through your body.\n",
    "You feel like howling at the moon in rabid madness.\n",
    "You spray rabid froth everywhere.\n"
});
string *room_msg = ({
    " starts to froth at the mouth and looks crazed.\n",
    "'s eyes roll in crazed fury.\n",
    " seethes in agony.\n",
    " howls at the moon in rabid agony.\n",
    " sprays froth everywhere.\n"
});
string query_classification() { return "body.disease.rabies"; }
int beginning( object player, int time ) {
   if( player->query_property( "undead" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return -1;
   }
   player->submit_ee( "wretch", ({ 30, 60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
   tell_object( player, "Throbbing pains radiate from your bite wound, and "
      "you feel your sanity slip away.\n" );
   return time;
}
int merge_effect( object player, int time1, int time2 ) {
    return time1;
}
int restart( object player, int time ) {
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
   return time;
}
void end( object player, int time ) {
   player->adjust_bonus_int( 2 );
   player->adjust_bonus_wis( 2 );
   tell_object( player, "You feel the madness leave you, and stop frothing"
      ".\n" );
}
void wretch( object player, int time ) {
    int msg_no;
    msg_no = random( sizeof( wretch_msg ) );
    tell_object( player, wretch_msg[ msg_no ] );
    tell_room( environment( player ), (string)player->the_short() +
              room_msg[ msg_no ], player );
    player->adjust_hp( - ( ( (int)player->query_hp() / 10 ) +
                           ( random( 50 ) ) ) );
    COMBAT_EFFECT->monitor_points( player, 1 );
}
string query_death_reason() {
   return "a nasty case of rabies";
}

==================================================
FILE: /lib/std/effects/disease/simple_disease.c
==================================================

#include <effect.h>
#include <disease.h>
inherit BASIC_DISEASE;
int cure_rate, infection_chance;
string shadow_ob;
function infection_check;
void set_cure_rate( int i ) { cure_rate = i; }
int query_cure_rate() { return cure_rate; }
void set_infection_chance( int i ) { infection_chance = i; }
int query_infection_chance() { return infection_chance; }
void set_infection_check( function f ) { infection_check = f; }
void set_shadow_ob( string str ) { shadow_ob = str; }
string query_shadow_ob() { return shadow_ob; }
void create() {
   do_setup++;
   ::create();
   do_setup--;
   shadow_ob = 0;
   infection_chance = 0;
   infection_check = 0;
   cure_rate = 0;
   if ( !do_setup )
      this_object()->setup();
}
int beginning( object person, int arg, int id ) {
  id = person->sid_to_enum( id );
   arg = this_object()->disease_start( person, arg, id );
   if ( !arg ) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   return arg;
}
int merge_effect( object person, int old_arg, int new_arg, int id ) {
   if ( old_arg < new_arg ) {
      old_arg = new_arg;
      this_object()->disease_worse( person, old_arg, id );
   }
   return old_arg;
}
void end( object person, int arg, int id ) {
   this_object()->disease_end( person, arg, id );
}
void disease_tick( object person, int arg, int id ) {
   object *things;
   int i;
   if ( arg > 100000 )
      arg = 10000;
   arg -= ( cure_rate*( (int)person->query_con() + 7 ) ) / 20 ;
   person->set_arg_of( (int)person->sid_to_enum( id ), arg );
   if ( arg < 0) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   if (person && environment(person) &&
       file_name(environment(person)) != "/room/void" &&
       file_name(environment(person)) != "/room/rubbish" &&
       infection_chance > 0 &&
       (random( 100 ) < infection_chance) ) {
     if ( functionp( infection_check ) ) {
       things = filter_array( all_inventory( environment( person ) ),
                             infection_check ) - ({ person });
     } else {
       things = filter_array( all_inventory( environment( person ) ),
                  (: living( $1 ) &&
                   ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
                   userp( $1 ) ) && !$1->query_property( "dead" ) :) )
            - ({ person });
     }
     i = sizeof( things );
     if ( i ) {
       i = random( i );
       things[ i ]->add_effect( file_name( this_object() ), arg );
#ifdef DEBUG
       log_file( "INFECTION", "%s, %s infected with %s by %s\n",
                ctime( time() ),
                things[ i ]->query_name(),
                this_object()->query_name(),
                person->query_name() );
#endif
     }
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   if ( !query_heart_beat( person ) )
      return;
   this_object()->disease_action( person, arg, id );
}
int test_remove( object, int, int, int ) {
#ifdef DEBUG
  log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
#endif
}

==================================================
FILE: /lib/std/effects/curses/alone.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "misc.curse.alone"; }
string query_shadow_ob() { return SHADOWS+"alone"; }
int beginning( object player, int time ) {
   player->add_extra_look( this_object() );
}
void merge_effect( object player, int time1, int time2 ) {
}
void end(object player) {
   player->remove_extra_look( this_object() );
}
string extra_look( object player ) {
   if ( player == this_player() )
     return "";
   return capitalize( (string)player->query_pronoun() )+
     " can't see you.\n";
}

==================================================
FILE: /lib/std/effects/curses/antisqeal.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your ability to mangle the english language "
                         "returns.\n");
}
string query_classification() { return "misc.curse.antisqeal"; }
string query_shadow_ob() { return "/std/shadows/curses/antisqeal"; }

==================================================
FILE: /lib/std/effects/curses/chef_curse.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your craving for swedish meatballs goes away.\n");
}
string query_classification() { return "misc.curse.chef"; }
string query_shadow_ob() { return "/std/shadows/curses/chef_curse"; }

==================================================
FILE: /lib/std/effects/curses/deaf_effect.c
==================================================

#include "effect.h"
string query_classification() { return "misc.curse.deafness"; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return "/std/shadows/curses/deaf_shadow"; }
mixed beginning( object player, mixed arg ) {
   tell_object( player, "Sounds seem dim and muffled.\n" );
   if ( pointerp( arg ) ) {
      player->submit_ee( "hear_better", arg[ 1 ], EE_CONTINUOUS );
      return arg[ 0 ];
   } else {
      return arg;
   }
}
void end( object player ) {
   tell_object( player, "Your hearing has returned to normal.\n" );
}
void hear_better( object player, mixed arg, int id ) {
   player->add_message(this_object(), "Your hearing improves somewhat.\n", 0);
   arg = 100 - ((100 - arg) * 2/3);
   if (arg == 100) player->delete_effect( player->sid_to_enum( id ) );
   else
      player->set_arg_of( player->sid_to_enum( id ), arg );
}
mixed merge_effect( object player, mixed old_arg, mixed new_arg, int id ) {
   player->add_message( this_object(), "Your hearing gets worse.\n", 0 );
   player->set_arg_of( player->sid_to_enum( id ), new_arg );
}

==================================================
FILE: /lib/std/effects/curses/ken_curse.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your craving for fish & chips passes.\n");
}
string query_classification() { return "misc.curse.ken"; }
string query_shadow_ob() { return "/std/shadows/curses/ken_curse"; }

==================================================
FILE: /lib/std/effects/curses/no_player_title.c
==================================================

#include <effect.h>
#include "path.h"
void beginning( object ob, int time, int id ) {
    if ( time > 0 ) {
        ob->submitt_ee( 0, time, EE_REMOVE );
    }
}
void end( object ob, int time, int id ) {
}
string query_classification() {
    return "player.no-title-allowed";
}
string query_shadow_ob() {
    return SHADOWS + "no_player_title";
}
void spam( object player, mixed args, int id ) {
tell_creator ("taffyd", "Spam\n" );
}

==================================================
FILE: /lib/std/effects/curses/ridcullian_curse.c
==================================================

#include <effect.h>
string query_classification() { return "misc.curse.ridcullian"; }
int merge_effect( object player, int old_arg, int new_arg, int id ) {
   player->submit_ee( 0, player->expected_tt() + new_arg, EE_REMOVE );
   tell_object(player, "You feel more concerned about your hair loss.\n");
}
int test_remove( object player, int a, int id, int bonus) {
   if (bonus > 150) return 1;
   tell_object(player, "You feel less concerned about your hair loss.\n");
   player->submit_ee(0, player->expected_tt() - bonus, EE_REMOVE);
   return 0;
}
int beginning( object player, int a, int id) {
   player->submit_ee("hair_worry", ({ 10, 20 }), EE_CONTINUOUS);
   player->submit_ee(0, a, EE_REMOVE);
   tell_object( player, "You reach up to smooth your hair, and a large "+
               "chunk of hair comes out.\n");
   tell_room( environment( player ), player->the_short() + " smooths " +
             player->query_possessive() + " hair and then stares in "+
             "horror at " + player->query_possessive() + " hands.\n",
             ({ player }) );
}
void end( object player, mixed a, int id ) {
   tell_object( player, "Ahhhh.  Your hair seems to have stopped "
               "falling out so prematurely.\n");
}
void hair_worry( object player, mixed a, int id ) {
   switch (random(5)) {
    case 0:
      player->do_say("I'm not going bald!  I mean it's "+
                     "ridiculous!  My family have never gone "+
                     "bald, except for one of my aunts!");
      break;
    case 1:
      player->do_say("I mean it wasn't there yesterday!");
      break;
    case 2:
      player->do_say("I have NOT got a bald spot!");
      break;
    case 3:
      player->do_say("Something's definitely happening, "+
                     "I can feel it in my water.");
      break;
    case 4:
      player->do_say("What about this, then?");
      break;
   }
}

==================================================
FILE: /lib/std/effects/curses/smurf.c
==================================================

#include <effect.h>
string query_classification() { return "misc.curse.smurf"; }
string query_shadow_ob() { return "/std/shadows/curses/ensmurfed"; }
int beginning( object player, int time ) {
   tell_object( player, "You suddenly find yourself filled with a strange "
               "fear of someone called \"Gargamel\".\n");
   if (time)
     player->submit_ee( 0, time, EE_REMOVE );
   return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
   tell_object( player, "Your fear of Gargamel has abated.\n");
}

==================================================
FILE: /lib/std/effects/room/albatross_attack.c
==================================================

#include <effect.h>
#define BLIND "/std/effects/religious/blind"
#define CLASS "auriental.punishment.albatross"
#define COMBAT "/std/effects/fighting/combat"
string query_classification(){ return CLASS; }
int query_indefinite(){ return 1; }
void damage_player( object pl, int damage ){
  if( damage > 0 )
    damage = damage * -1;
  if( pl->adjust_hp( damage ) <= 0 )
    pl->attack_by( this_object() );
  COMBAT->monitor_points( pl, 1 );
}
void pecking( object pl ){
  int damage = roll_MdN( 3, 150 );
  object room = environment( pl );
  if( room->query_property( "location" ) != "outside" ){
    if( pl->expected_tt() )
      pl->submit_ee( 0, ( pl->expected_tt() + 15 + random( 20 ) ), EE_REMOVE );
    tell_object( pl,
      "The albatrosses pace around the area, glaring at you.\n" );
    tell_room( room,
      "Albatrosses pace underfoot, looking quite upset.\n",
      pl );
    return;
  }
  switch( roll_MdN( 2, 3 ) ){
    case 2:
      tell_object( pl,
        "The albatrosses peck at your eyes, blinding you.\n" );
      tell_room( room,
        "A flock of albatrosses peck at " + pl->the_short() + "'s eyes.\n",
        ({ pl }) );
      damage_player( pl, damage * 3 / 2 );
      pl->add_effect( BLIND, damage / 2 );
      break;
    case 3:
      tell_object( pl,
        "A lone albatross dive-bombs you, skewering you with its beak.\n" );
      tell_room( room,
        "A single albatross dives at " + pl->the_short() + ", impaling " +
        pl->query_objective() + " with its beak.\n",
        ({ pl }) );
      damage_player( pl, damage );
      break;
    case 4:
      tell_room( room,
        "The albatrosses circle, watching you with cold, beady eyes.\n" );
      break;
    case 5:
      tell_object( pl,
        "One of the albatrosses swoops low above you, dropping an oyster "
        "shell directly on your head.\n" );
      tell_room( room,
        "A large oyster shell drops from the sky, splitting open on " +
        pl->the_short() + "'s head.\n",
        ({ pl }) );
      damage_player( pl, damage / 2 );
      break;
    default:
      tell_object( pl,
        "Several albatrosses land on your shoulders, spearing their beaks "
        "into you.\n" );
      tell_room( room,
        "Several albatrosses drop onto " + pl->the_short() + "'s shoulders, "
        "skewering " + pl->query_objective() + " with their beaks before "
        "taking off again.\n",
        ({ pl }) );
      damage_player( pl, damage * 2 );
      break;
  }
}
int beginning( object pl, int args ){
  tell_object( pl,
    "A flock of albatrosses forms above you.  They don't look pleased to see "
    "you at all.\n" );
  tell_room( environment( pl ),
    "A flock of albatrosses circles above " + pl->the_short() + "\n",
    ({ pl }) );
  pl->submit_ee( "pecking", ({ 15, 45 }), EE_CONTINUOUS, pl );
  pl->submit_ee( 0, args, EE_REMOVE );
  pl->add_extra_look( this_object() );
  return args;
}
int merge_effect( object pl, int old_args, int new_args ){
  pl->submit_ee( 0, new_args, EE_REMOVE );
  return new_args;
}
int restart( object pl, int args ){
  tell_object( pl,
    "The flock of albatrosses returns, apparently not finished with their "
    "attack.\n" );
  tell_room( environment( pl ),
    "A flock of albatrosses forms above " + pl->the_short() + "\n",
    ({ pl }) );
  pl->add_extra_look( this_object() );
  return args;
}
void end( object pl, int args ){
  tell_room( environment( pl ),
    "The albatrosses lose interest and slowly fly away, trying to remember "
    "how to be properly pointless.\n" );
  pl->remove_extra_look( this_object() );
}
string extra_look( object pl ){
  if( environment( pl )->query_property( "location" ) != "outside" ){
    return capitalize( pl->query_pronoun() ) +
      " is surrounded by angry albatrosses.\n";
  }
  return capitalize( pl->query_pronoun() ) +
    " has an angry flock of albatrosses around " +
    pl->query_objective() + ".\n";
}
string query_death_reason(){
  return "being pecked to death by albatrosses";
}

==================================================
FILE: /lib/std/effects/room/bubble_bath.c
==================================================

#include <effect.h>
#define PATH __DIR__
string query_classification() { return "room.bubblebath"; }
int query_surface_water(object room) {
    return room->query_surface() ||
     sizeof(filter(all_inventory(room), (: $1->query_baths() :)));
}
void beginning( object room, mixed *args) {
    object uproom;
   tell_room( room, "As the liquid enters the water it diffuses into "
         "a "+ args[1][0] +" coloured cloud.\n" );
   if(query_surface_water(room))
       tell_room( room, "A gentle fragrance of " + args[1][1] +
          " fills the room.\n");
   else if(uproom = find_object(room->query_destination(room->query_up_dir())))
       uproom->add_effect(PATH + "bubble_bath", args);
   room->submit_ee( "bubblebubble", ({10,30}), EE_CONTINUOUS );
   room->submit_ee( 0, args[0], EE_REMOVE );
   room->add_extra_look( this_object() );
   room->add_item(args[1][0] + " bubbles", "These " + args[1][0] + " coloured "
           "bubbles fill the room.");
}
mixed *merge_effect( object room, mixed *old_arg, mixed *new_arg, int id ) {
  int index,count,copy=0;
  string type;
  object uproom;
   tell_room( room, "The bubbles surge as more bubble bath is added.\n" );
   room->submit_ee( 0, new_arg[0] + (int)room->expected_tt(), EE_REMOVE );
   count = sizeof(old_arg);
   for( index = 1; index < count; index++) {
     if( new_arg[1][0] == old_arg[index][0] ) {
       copy = 1;
       break;
     }
   }
   if(!copy) {
     old_arg += ({ new_arg[1] });
     room->add_extra_look(this_object());
     type = (room->query_surface()?"air":"water");
     room->add_item( new_arg[1][0] + " bubbles", "These " + new_arg[1][0] +
        " coloured bubbles fill the " + type + ".");
     tell_room( room, "As the liquid enters the water it diffuses into "
         "a "+ new_arg[1][0] +" coloured cloud.\n" );
     if(query_surface_water(room))
     tell_room( room, "A gentle fragrance of " + new_arg[1][1] +
          " fills the air.\n");
     else if(uproom = find_object(room->query_destination(room->query_up_dir()))) {
         uproom->add_item( new_arg[1][0] + " bubbles", "These " + new_arg[1][0] +
        " coloured bubbles fill the " + type + ".");
         uproom->add_effect(PATH + "bubble_bath", new_arg);
     }
     return old_arg;
   }
   return 0;
}
void end( object room, mixed *args, int id) {
    int index, count;
    string type =(room->query_surface()?"fragrant":"colourful");
    tell_room( room, "The last of the bubbles disappear with a " + type +
             " *pop*.\n" );
    room->remove_extra_look( this_object() );
    count = sizeof(args);
    for (index = 1; index < count; index++ )
       room->remove_item( args[index][0] + " bubbles" );
}
string extra_look( object room ) {
  int *enums;
  int count, size;
  mixed  shades=({});
  string bubblez;
  string type;
  enums = room->effects_matching( query_classification() );
  type = (room->query_surface()?"smelling":"looking");
  if ( !sizeof ( enums )) return "";
  shades = room->arg_of( enums[0] );
  if ( !sizeof ( shades )) return "";
  if ( sizeof ( shades ) == 1 )
      bubblez = "A multitude of " + shades[1][0] +" coloured bubbles fill the "
      "room, " + type +  " delicately of " + shades[1][1] + ".\n";
  if ( sizeof ( shades ) > 1 ) {
    size = sizeof ( shades );
    bubblez = "The room is filled with " + shades[1][0];
    for ( count = 2; count < size; count++ ) {
        if ( count != size-1 ) {
            bubblez += ", ";
        }
        else {
            bubblez += " and ";
        }
            bubblez += shades[count][0];
    }
    bubblez += " coloured bubbles, floating everywhere.\n";
  }
      return bubblez;
}
void bubblebubble( object room, mixed *args) {
    int index = 0;
    string type = (query_surface_water(room)?"fragrance":"colours");
    string where= (query_surface_water(room)?"air":"water");
    while (!index) index = random(sizeof(args));
    tell_room( room, "The gentle " + type + " of " + args[index][1] + " floats "
               "through the " + where + " as some of the " + args[index][0] + " bubbles "
               "pop.\n");
}

==================================================
FILE: /lib/std/effects/room/burial.c
==================================================

#include <effect.h>
#include <cmds/bury.h>
class arg_stuff {
   object cont;
   object* obs;
   int* added;
}
private mapping _stuff;
private int _call_id;
int timeout_ob(object room, int enum, object ob);
void check_buried();
void create() {
   _stuff = ([ ]);
}
string query_classification() { return "room.burial"; }
mixed beginning( object room, object ob ) {
   if (!_stuff[room]) {
      _stuff[room] = new(class arg_stuff);
      _stuff[room]->cont = clone_object("/std/container");
      _stuff[room]->cont->add_property("burial object", 1);
      _stuff[room]->obs = ({ });
      _stuff[room]->added = ({ });
   }
   ob->move(_stuff[room]->cont);
   event (ob, "bury", ob, room);
   _stuff[room]->obs += ({ ob });
   _stuff[room]->added += ({ time() });
   if (!_call_id) {
      _call_id = call_out("check_buried", BURY_TIMEOUT);
   }
   return room;
}
mixed merge_effect( object room, class arg_stuff womble, object ob ) {
   if (!_stuff[room]) {
      _stuff[room] = new(class arg_stuff);
      _stuff[room]->cont = clone_object("/std/container");
      _stuff[room]->obs = ({ });
      _stuff[room]->added = ({ });
      _stuff[room]->cont->add_property("burial object", 1);
   }
   ob->move(_stuff[room]->cont);
   event (ob, "bury", ob, room);
   _stuff[room]->obs += ({ ob });
   _stuff[room]->added += ({ time() });
   if (!_call_id) {
      _call_id = call_out("check_buried", BURY_TIMEOUT);
   }
   return room;
}
void end( object room, class arg_stuff womble ) {
    if ( womble && classp( womble ) ) {
      all_inventory(womble->cont)->move("/room/rubbish");
      womble->cont->dest_me();
    }
}
int query_indefinite() { return 1; }
void check_buried() {
   object room;
   int i;
   class arg_stuff bing;
   _call_id = call_out("check_buried", BURY_TIMEOUT);
   foreach (room, bing in _stuff) {
     if(!classp(bing))
       continue;
     if (!room) {
       bing->obs = filter(bing->obs, (: $1 && environment($1) == $2 :),
                          bing->cont);
       bing->obs->dest_me();
       if(bing->cont)
         bing->cont->dest_me();
       map_delete(_stuff, room);
     } else {
       for (i = 0; i < sizeof(bing->obs); i++) {
         if (!bing->obs[i] ||
             environment(bing->obs[i]) != bing->cont)  {
           bing->obs = bing->obs[0..i-1] + bing->obs[i+1..];
           bing->added = bing->added[0..i-1] + bing->added[i+1..];
         } else if (bing->added[i] + BURY_TIMEOUT < time()) {
           bing->obs[i]->dest_me();
           bing->obs = bing->obs[0..i-1] + bing->obs[i+1..];
           bing->added = bing->added[0..i-1] + bing->added[i+1..];
         }
       }
       if (!sizeof(bing->obs)) {
         if (bing->cont) {
           bing->cont->dest_me();
         }
         map_delete(_stuff, room);
       }
     }
   }
   if (!sizeof(_stuff)) {
     remove_call_out(_call_id);
     _call_id = 0;
   }
}
object* query_buried_objects(object room) {
   if (_stuff[room]) {
      return _stuff[room]->obs;
   }
   return ({ });
}
object query_buried_container(object room) {
   if (_stuff[room]) {
      return _stuff[room]->cont;
   }
   return 0;
}
int remove_from_burial(object room, object ob) {
   int i;
   if (_stuff[room]) {
      i = member_array(ob, _stuff[room]->obs);
      if (i != -1) {
         _stuff[room]->obs = _stuff[room]->obs[0..i-1] +
                             _stuff[room]->obs[i+1..];
         _stuff[room]->added = _stuff[room]->added[0..i-1] +
                               _stuff[room]->added[i+1..];
         return 1;
      }
   }
   return 0;
}
mapping query_dynamic_auto_load() {
   return ([ "stuff" : _stuff ]);
}
void init_dynamic_arg(mapping map) {
   if (map && map["stuff"]) {
      _stuff = map["stuff"];
      if (!_call_id) {
         _call_id = call_out("check_buried", BURY_TIMEOUT);
      }
   }
}

==================================================
FILE: /lib/std/effects/room/crater.c
==================================================

#include <effect.h>
string query_classification() { return "room.crater.broom"; }
string *beginning( object room, string name ) {
  room->add_item( ({ name + " shaped crater", "crater" }),
      "There is a large crater in the ground, as if " +
      capitalize( name ) + " happened here recently, from a "
      "very great height indeed." );
  room->add_extra_look( this_object() );
  return ({ name });
}
string *merge_effect( object room, mixed old_names, string name ) {
  if( member_array( name, old_names ) != -1 ) {
    return old_names;
  }
  room->add_item( ({ name + " shaped crater", "crater" }),
      "There is a large crater in the ground, as if " +
      capitalize( name ) + " happened here recently, "
      "from a very great height indeed." );
  return old_names += ({ name });
}
void end( object room, mixed names ) {
  string name;
  foreach( name in names )  {
    room->remove_item( name + " shaped crater" );
  }
  room->remove_extra_look( this_object() );
}
int query_indefinite() { return 1; }
string extra_look( object room ) {
   int     *enums;
   string  *shapes;
   enums = room->effects_matching( query_classification() );
   if( !sizeof( enums ) )
     return "";
   shapes = room->arg_of( enums[0] );
   if( !sizeof( shapes ) )
     return "";
   if( sizeof( shapes ) == 1 )
     return "There is " + add_a( capitalize( shapes[0] ) ) +
         " shaped crater in the ground.\n";
   else {
     return "There are " + query_multiple_short( map( shapes, (: capitalize(
                $1 ) :) ) ) + " shaped craters in the ground.\n";
   }
}

==================================================
FILE: /lib/std/effects/room/hat_tent.c
==================================================

#include <effect.h>
void beginning() {
}
void end() {
}
string query_shadow_ob() {
   return "/std/shadows/room/hat_tent";
}
string query_classification() {
   return "room.hattent";
}

==================================================
FILE: /lib/std/effects/room/magic_octogram.c
==================================================

#include <effect.h>
string query_classification() { return "magic.octogram"; }
void beginning( object thing, int number, int id ) {
   tell_room( thing, "An octogram begins to glow "+
         (string)thing->query_property( "here" ) +".\n" );
   thing->submit_ee( 0, number, EE_REMOVE );
   thing->add_extra_look( this_object() );
   thing->add_item( "octogram", "The octogram glows in eldritch fashion, "
         "and that has nothing to do with being oblong." );
}
int merge_effect( object thing, int old_arg, int new_arg, int id ) {
   tell_room( thing, "The octogram pulses for a moment.\n" );
   thing->submit_ee( 0, new_arg + (int)thing->expected_tt(), EE_REMOVE );
   return old_arg + new_arg;
}
void end( object thing, int number, int id ) {
   if ( !sizeof( filter_array( previous_object( -1 ),
         (: $1->query_magic_spell() :) ) ) )
      tell_room( thing, "The octogram flickers and disappears.\n" );
   thing->remove_extra_look( this_object() );
}
string extra_look( object thing ) {
   return "An octogram "+ (string)thing->query_property( "here" ) +
         " glows in eldritch fashion.\n";
}

==================================================
FILE: /lib/std/effects/room/swinging.c
==================================================

#include <effect.h>
#define SWINGS "/d/sur/Sto_Lat/hill_street/playground/playground04"
string query_classification() { return "other.swinging"; }
void beginning(object player, int arg) {
  int st, tt;
  player->submit_ee("swinging", ({15, 30}), EE_CONTINUOUS);
  player->submit_ee( 0, arg, EE_REMOVE );
  tt = (int)player->expected_tt();
  st = (tt - 15);
  player->submit_ee("slowing", (st), EE_ONCE);
  if (tt < 61) {
    player->add_succeeded_mess(previous_object(), ({
      "You push off with your feet and start to swing back and "
        "forth.\n",
      "$N push$s off with $p feet and start$s to swing back and "
        "forth.\n"}));
    player->set_position("swinging back and forth");
    player->set_position_type("on");
  }
}
void merge_effect(object player, int old_arg, int new_arg) {
  int tt, st;
  tt = (int)player->expected_tt();
  tell_room(environment(player), capitalize(player->a_short() ) +
    " leans back and pulls on the swing to gain momentum.\n", player);
  tell_object(player, "You lean back and pull on the swing "
    "to gain momentum.\n");
  player->submit_ee(0, new_arg + tt, EE_REMOVE);
  st = (tt -15);
  player->submit_ee("slowing", (st), EE_ONCE);
}
void end(object player) {
  if(file_name(environment(player)) != SWINGS)
      return;
  tell_object(player, "You stop swinging.\n");
  tell_room(environment(player), capitalize(player->a_short()) +
    " stops swinging.\n", player);
  player->set_position("sitting");
  player->set_position_type("in");
}
void swinging(object player) {
   if(file_name(environment(player)) != SWINGS){
      player->submit_ee(0, 0, EE_REMOVE);
      return;
   }
  switch (random(3)) {
  case 1 :
    if (player->query_gender() == 2) {
      tell_room(environment(player), capitalize(player->a_short() ) +
        " seems very happy as she reaches the bottom of her "
        "arc on the swing.\n", player);
      tell_object(player, "You feel a pleasant tickling sensation "
        "in your stomach as you reach the bottom of your arc on "
        "the swing.\n");
    }
    else {
      tell_room(environment(player), capitalize(player->a_short() ) +
        " swings back and forth happily, just like a child again.\n",
        player);
      tell_object(player, "You swing back and forth happily, just "
        "like a child again.\n");
    }
  break;
  case 2 :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " looks at if "+player->query_pronoun()+" could just "
      "fly right off into the sky as "+player->query_pronoun()+
      " reaches the top of "+player->query_possessive()+" arc on "
      "the swing.\n", player);
    tell_object(player, "You feel as if you could just fly right "
      "off into the sky as you reach the top of your arc on the "
      "swing.\n");
  break;
  case 3 :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " arcs through the air like a pendlum.\n", player);
    tell_object(player, "You arc through the air like a "
      "pendlum.\n");
  break;
  default :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " swings back and forth.\n", player);
    tell_object(player, "You swing back and forth.\n");
  }
}
void slowing(object player) {
  if ( (int)player->expected_tt() < 20 ) {
    tell_object(player, "Your swinging is slowing down as you "
      "gradually lose momentum.\n");
    tell_room(environment(player), capitalize(player->a_short()) +
      " slows down a bit as "+player->query_pronoun()+" loses "
      "momentum.\n", player);
  }
}

==================================================
FILE: /lib/std/effects/room/terrain_dont_unload.c
==================================================

#include <effect.h>
string query_classification() {return "terrain.dont.unload"; }
string query_shadow_ob() {return "/std/shadows/room/terrain_dont_unload"; }
mixed beginning( object player, mixed *arg) {
    player->setup_shad();
    return arg;
}
mixed merge_effect( object player, mixed *old, mixed *newish ) {
    player->setup_shad();
    return newish;
}

==================================================
FILE: /lib/std/effects/room/vomit.c
==================================================

#include <effect.h>
void pool_descripts( object room , int pools );
string query_classification () { return "room.vomit"; }
void beginning ( object room, int *args )
{
    int duration, pools ;
    duration = args [ 0 ] ;
    pools    = args [ 1 ] ;
    pool_descripts ( room , pools ) ;
    room -> submit_ee ( 0 , duration , EE_REMOVE ) ;
}
void pool_descripts ( object room , int pools )
{
    room -> remove_item( "pool" );
    room -> add_item( ({ "pool" , "vomit" , "puddle"  }) , "There " +
        ( ( pools == 1 ) ? "is a pool" : "are " + query_num( pools , 10 ) +
        " pools" ) + " of vomit decorating the place.  Inevitably there "
        "are little bits of carrot in it, and it would also be a good "
        "idea to watch one's step." ) ;
    room->add_extra_look( this_object() );
}
int *merge_effect( object room , int *new_args , int *old_args )
{
    int duration , pools ;
    duration = new_args [ 0 ] + room -> expected_tt()  ;
    pools =    new_args [ 1 ] + old_args [ 1 ] ;
    pool_descripts( room , pools ) ;
    return ({ duration , pools }) ;
}
void end( object room, mixed names )
{
    room -> remove_item ( "pool" );
    room -> remove_extra_look( this_object() );
}
string extra_look( object room )
{
    int     *enums;
    int     pools;
    string  look, number;
    enums = room -> effects_matching( query_classification() );
    if( !sizeof( enums ) ) return "";
    pools = ( room -> arg_of( enums[0] ) ) [ 1 ] ;
    number = query_num( pools , 10 );
    look = "There " + ( ( pools == 1 ) ? ( "is a pool " ) : ( "are " +
        number + " pools ") ) + "of vomit here.\n" ;
    return look;
}

==================================================
FILE: /lib/std/effects/room/yellow-green_gas.c
==================================================

#include <effect.h>
#define DAMAGE 1 + random(300)
#define CHOKE_TIME 20
string query_classification()
{
  return "gas.poisonous";
}
void beginning(object room, int time, int)
{
  tell_room(room,
    "A billowing yellow-green gas fills the area!\n");
  room->submit_ee("choke", CHOKE_TIME, EE_CONTINUOUS);
  room->submit_ee("clear", time, EE_REMOVE);
  room->add_extra_look(this_object());
  room->add_item("billowing yellow-green gas",
    "A thick, yellow-green gas swirls around the area.");
}
int merge_effect(object, int new_time, int old_time, int)
{
  int time_left;
  time_left = new_time + old_time;
  return time_left;
}
void clear(object room, int, int)
{
  tell_room(room, "The yellow-green gas clears.\n");
  room->remove_item("gas");
}
void choke(object room, int, int)
{
  int damage;
  object ob, *obs;
  obs = filter(all_inventory(room), (: living($1) :));
  foreach(ob in obs)
  {
    damage = DAMAGE;
    damage -= ob->query_ac("gas", damage, "head");
    if(damage > 0)
    {
      tell_object(ob,
        "You choke as you inhale the noxious gas!\n");
      tell_room(room,
        "$C$"+ob->one_short()+" chokes as "+ob->query_pronoun()+
        " inhales the noxious gas!\n", ob);
      ob->adjust_hp(-damage);
      if(ob->query_monitor())
      {
        ob->monitor_points();
      }
    }
  }
}
void end(object room, int time, int id)
{
  room->remove_extra_look(this_object());
}
string extra_look(object thing)
{
  return "A billowing yellow-green gas swirls around here.\n";
}

==================================================
FILE: /lib/std/effects/npc/basilisk_stare.c
==================================================

#include <effect.h>
#include "path.h"
void do_damage(object to, int amount, object from, int id)
{
  if (!to) return;
  if (to->query_hp() <= amount)
    to->delete_effect(to->sid_to_enum(id));
  to->attack_by(this_object());
  to->adjust_hp(-amount, from);
}
void stop_fighting(object who, mixed arg, int id)
{
  int *fights, i;
  fights = who->effects_matching("fighting");
  if (sizeof(fights))
    for (i = sizeof(fights) - 1; i >= 0; i--)
      who->delete_effect(fights[i]);
}
void doit(object them, int arg, int id)
{
  int dam;
  object basilisk;
  arg--;
  them->set_arg_of(them->sid_to_enum(id), arg);
  if (!arg) {
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  if (sizeof(match_objects_for_existence("basilisk", environment(them))) == 0) {
    tell_object(them, "You suddenly notice that the basilisk is no "
                "longer here.\n");
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  tell_object(them,
         ({
      "You cannot stand the deadly stare.\n",
      "Your soul is being drilled through and out the other side.\n",
      "Your eyeballs are being ripped apart.\n",
      "Your brain is being flayed.\n"
      })[random(4)]);
  tell_room(environment(them),
       ({
         them->one_short()+" cannot bear the deadly gaze.\n",
         them->one_short()+"'s soul is being torn apart.\n",
         them->one_short()+"'s brain is afire.\n",
         them->one_short()+"'s eyeballs are being drilled through.\n"
         })[random(4)], them);
  basilisk = find_living("basilisk");
  if (basilisk) {
    dam = random(50)+50;
    call_out("do_damage", 1, them, dam, basilisk, id);
  }
}
int beginning(object them, int arg, int id)
{
  tell_object(them, "You feel a pair of mental diamond drills penetrating "
         "your brain.\n");
  tell_room(environment(them), them->one_short() +
            "'s soul is about to be ripped apart.\n", them) ;
  them->submit_ee("stop_fighting", 1, EE_ONCE);
  them->submit_ee("doit", 10, EE_CONTINUOUS);
  them->add_property("passed out", 1);
  return arg;
}
void end(object them)
{
  tell_object(them, "You are freed from the basilisk's deadly stare.\n");
  them->remove_property("passed out");
}
string query_shadow_ob() {
  return SHADOWS+"basilisk_stare";
}
void merge_effect(object them, int arg1, int arg2, int id)
{
  them->set_arg_of(them->sid_to_enum(id), arg1 + arg2);
}
string query_classification() { return "magic.offensive.paralysis.stare"; }
string query_name()
{
  return "a horrible sight";
}

==================================================
FILE: /lib/std/effects/npc/controlled_monster.c
==================================================

#include "path.h"
string query_shadow_ob() { return SHADOWS + "controlled_monster"; }
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time2;
}
string query_classification() { return "npc.controlled_monster"; }

==================================================
FILE: /lib/std/effects/npc/dont_move.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, int arg, int id ) {
   player->submit_ee(0, arg, EE_REMOVE);
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - player->expected_tt(),
          EE_REMOVE );
   return time1 + time2;
}
string query_classification() { return "npc.move.no"; }
string query_shadow_ob() { return SHADOWS + "dont_move"; }

==================================================
FILE: /lib/std/effects/npc/drink_silly.c
==================================================

#include <effect.h>
#include <pub.h>
#include <shops/pub_shop.h>
#include "path.h"
mixed normalise(mixed arg, object player) {
   if (stringp(arg)) {
      arg = ({ arg, player });
   } else if (functionp(arg)) {
      arg = ({ arg, player });
   } else if (!pointerp(arg)) {
      arg = ({ });
   }
   return arg;
}
void beginning( object player, mixed arg, int id ) {
   player->submit_ee("buy_something", 5, EE_CONTINUOUS);
   player->do_command("stand at bar");
   return normalise(arg, player);
}
int merge_effect( object player, int time1, int time2, int id ) {
   return normalise(time1, player) + normalise(time2, player);
}
void end(object player, mixed arg, int id) {
   int i;
   for (i = 0; i < sizeof(arg); i += 2) {
      if (functionp(arg[i])) {
         evaluate(arg[i]);
      } else {
         call_other(arg[i], arg[i+1]);
      }
   }
}
string query_classification() { return "npc.drink"; }
void buy_something(object player, mixed arg, int id) {
   mapping items;
   mixed *stuff;
   string *rabbit;
   int i;
   int value;
   mixed ret;
   string place;
   string name;
   class menu_item menu;
   items = environment(player)->query_menu_items();
   rabbit = ({ });
   if (mapp(items)) {
      stuff = keys(items);
      place = environment(player)->query_property( "place" );
      if ( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)player->query_value_in( place );
      if ( place != "default" ) {
         value += (int)player->query_value_in( "default" );
      }
      if (environment(player)->query_pub()) {
         foreach (name, menu in items) {
            if (menu->intox > 0 &&
                menu->cost < value) {
               rabbit += ({ name });
            }
         }
      } else {
         foreach (name, stuff in items) {
            if (stuff[DR_INTOX] > 0 &&
                stuff[DR_COST] < value) {
               rabbit += ({ name });
            }
         }
      }
   }
   if (!sizeof(rabbit)) {
      player->delete_effect(player->sid_to_enum(id));
   } else {
      do {
         i = random(sizeof(rabbit));
         ret = player->do_command("buy "+rabbit[i]);
         rabbit = rabbit[0..i-1] + rabbit[i+1..];
      } while (ret <= 0 && sizeof(rabbit));
      if (ret <= 0) {
         player->delete_effect(player->sid_to_enum(id));
      }
   }
}

==================================================
FILE: /lib/std/effects/npc/eat_corpse.c
==================================================

#include <effect.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.corpse"; }
string query_shadow_ob() { return SHADOWS + "eat_corpse"; }
int query_indefinate() { return 1; }

==================================================
FILE: /lib/std/effects/npc/eat_edible.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.edible"; }
string query_shadow_ob() { return SHADOWS + "eat_edible"; }

==================================================
FILE: /lib/std/effects/npc/enter.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.enter"; }
string query_shadow_ob() { return SHADOWS + "enter"; }

==================================================
FILE: /lib/std/effects/npc/exit.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.exit"; }
string query_shadow_ob() { return SHADOWS + "exit"; }

==================================================
FILE: /lib/std/effects/npc/given.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.given"; }
string query_shadow_ob() { return SHADOWS + "given"; }

==================================================
FILE: /lib/std/effects/npc/good_fighter.c
==================================================

#include "path.h"
#include <effect.h>
#define CLASS "npc.fighter"
string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS "good_fighter"; }
void gfs(object player)
{
  player->good_fighter_setup();
}
int *beginning(object player, int *arg)
{
  if (!arg || !arrayp(arg) || sizeof(arg) != 2)
    arg = ({ 0, 0 });
  player->submit_ee("gfs", 1, EE_ONCE);
  return arg;
}
void restart(object player, int *arg)
{
  beginning(player, arg);
}
int *merge_effect(object player, int *oldarg, int *newarg)
{
  return oldarg;
}
void end(object player, int *arg)
{
}

==================================================
FILE: /lib/std/effects/npc/gossip.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.gossip"; }
string query_shadow_ob() { return SHADOWS + "gossip"; }

==================================================
FILE: /lib/std/effects/npc/goto_destination.c
==================================================

#include <effect.h>
#include "path.h"
#define LOG_FILE "EFFECTS"
private string standardize(mixed dest);
void call_move_to(object player, string dest)
{
  if (!player) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: player became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }
  if(!dest) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: dest became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }
  player->move_me_to(dest);
}
void remove_effect(object player, int id)
{
  if (player)
    player->remove_effect(id);
}
void beginning( object player, mixed arg, int id ) {
   mixed dest;
   if (pointerp(arg)) {
      if (sizeof(arg) > 3) {
         arg = arg[0..2];
      } else while (sizeof(arg) < 3) {
         arg += ({ 20 });
      }
   } else {
      arg = ({ arg, 0, 20 });
   }
   arg[0] = standardize(arg[0]);
   if (!dest) {
      while (!arg[0] && sizeof(arg) > 3) {
         arg = arg[3..];
         arg[0] = standardize(arg[0]);
      }
      if (!arg[0]) {
         call_out("remove_effect", 2, player, id);
         return ;
      }
   }
   if (objectp(arg[0])) {
      call_out("call_move_to", 2, player, file_name(environment(arg[0])));
   } else {
      call_out("call_move_to", 2, player, arg[0]);
   }
}
private string standardize(mixed dest) {
   if (objectp(dest)) {
      if (!living(dest)) {
         dest = file_name(dest);
      }
   } else if (stringp(dest)) {
      if (catch(dest->rabbit_well())) {
         dest = 0;
      } else {
         dest = file_name(find_object(dest));
      }
   }
   return dest;
}
mixed merge_effect( object player, mixed arg1, mixed arg2, int id ) {
   if (!pointerp(arg1)) {
      arg1 = ({ arg1, 0, 20 });
   }
   if (sizeof(arg1) > 0) {
      while (sizeof(arg1) < 3) {
         arg1 += ({ 20 });
      }
      arg1[0] = standardize(arg1[0]);
   }
   if (!pointerp(arg2)) {
      arg2 = ({ arg2, 0, 20 });
   }
   if (sizeof(arg2) > 0) {
      while (sizeof(arg2) < 3) {
         arg2 += ({ 20 });
      }
      arg2[0] = standardize(arg2[0]);
   }
   arg1 += arg2;
   while (!arg1[0] && sizeof(arg1) > 3) {
      arg1 = arg1[3..];
      arg1[0] = standardize(arg1[0]);
   }
   if (!arg1[0]) {
      call_out("remove_effect", 2, player, id);
      return ({ });
   }
   return arg1;
}
void effect_womble(object player, mixed *arr) {
  if(!player)
    return;
   player->add_effect(file_name(this_object()), arr);
}
void do_the_sell(object player) {
   object *obs;
   int i;
   obs = all_inventory(player);
   for (i = 0; i < sizeof(obs); i++) {
      if (!obs[i]->query_property("start equipment")) {
         call_out((: $1->do_command("sell "+file_name($2)) :),
                   1, player, obs[i]);
      }
   }
}
void end( object player, mixed room, int id ) {
   int ok;
   if (pointerp(room)) {
      if (sizeof(room) > 3) {
         call_out( "effect_womble", room[2], player, room[3..]);
      }
      if (!room[0]) {
         ok = 0;
      } else if (objectp(room[0])) {
         ok = (environment(room[0]) == environment(player));
      } else {
         ok = file_name(environment(player)) == room[0];
      }
      if (functionp(room[1])) {
         evaluate(room[1], player, room[0], ok, room[1]);
      }
      if (stringp(room[1])) {
         if (ok) {
            switch (room[1]) {
               case "sell" :
                  do_the_sell(player);
                  break;
               default :
                  player->do_command(room[1]);
                  break;
            }
         }
      }
      if (pointerp(room[1])) {
         call_other(room[1][0], room[1][1], player, room[0], ok, room[1]);
      }
   }
}
string query_classification() { return "npc.move"; }
string query_shadow_ob() { return SHADOWS + "goto_destination"; }

==================================================
FILE: /lib/std/effects/npc/i_died.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.death.me"; }
string query_shadow_ob() { return SHADOWS + "i_died"; }

==================================================
FILE: /lib/std/effects/npc/light_change.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.light_change"; }
string query_shadow_ob() { return SHADOWS + "light_change"; }

==================================================
FILE: /lib/std/effects/npc/mock_block.c
==================================================

#include "path.h"
string *beginning( object player, string *skills ) {
  return skills;
}
string *merge_effect( object player, string *old, string *arg ) {
  arg = filter( arg, (: member_array( $1, $2 ) == -1 :), old );
  return old + arg;
}
string query_classification() { return "mock.block.npc"; }
string query_shadow_ob() { return SHADOWS "mock_block"; }
int query_indefinite() { return 1; }

==================================================
FILE: /lib/std/effects/npc/no_follow.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
   player->do_command("lose everyone");
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.follow.no"; }
string query_shadow_ob() { return SHADOWS + "no_follow"; }

==================================================
FILE: /lib/std/effects/npc/pub_brawl.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.pub_brawl"; }
string query_shadow_ob() { return SHADOWS + "pub_brawl"; }

==================================================
FILE: /lib/std/effects/npc/savage_corpse.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.savage"; }
string query_shadow_ob() { return SHADOWS + "savage_corpse"; }

==================================================
FILE: /lib/std/effects/npc/scavenge.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.given"; }
string query_shadow_ob() { return SHADOWS + "given"; }

==================================================
FILE: /lib/std/effects/npc/spell_effects.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.spell_effects"; }
string query_shadow_ob() { return SHADOWS + "spell_effects"; }

==================================================
FILE: /lib/std/effects/npc/they_died.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.death.them"; }
string query_shadow_ob() { return SHADOWS + "they_died"; }

==================================================
FILE: /lib/std/effects/npc/unsocial_effect.c
==================================================

#include <effect.h>
void beginning( object player,mixed *arg, int id ) {
   tell_object( player, "The spectral image of a "+arg[0]+" appears in front "
         "of you and looks sadly at you through pale eyes.  You shudder "
         "in horror as the image passes through you with tears in its "
         "eyes.  You find your yourself less able to communicate from the "
         "shock.\n");
   tell_room( environment( player ), player->the_short()+" suddenly looks "
         "straight ahead and shudders for no visible reason.\n", player );
   player->submit_ee( "reminder_mess", 20, EE_CONTINUOUS );
   player->submit_ee( 0, arg[1], EE_REMOVE );
   player->set_max_sp( 0 );
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
}
void end( object player, int time, int id ) {
   int number;
   tell_object( player, "You feel you have recovered and are ready to "
         "communicate with the world again.\n");
   number= player->query_real_max_sp();
   player->adjust_max_sp( number );
}
void reminder_mess( object player, mixed *arg, int id ) {
   string message;
   if (!random(4))
       switch(random(2)){
         case 0 :
           message = "The spectral image of a "+arg[0]+" just like you had "
            "as a "
            "child appears in front of you.  Before you know what you are "
            "doing you strike out at the "+arg[0]+" spilling spectral blood "
            "everywhere.\n";
           break;
         default :
           message = "You have a vision of yourself walking down a street "
            "when suddenly a masked "+arg[0]+" jumps out of the shadows "+
            "and cuts you into pieces with its natural weapons.\n";
           break;
       }
   else message = "The pitiful looking ghost of a "+arg[0]+
         " suffering from horrifying wounds drifts past you.\n";
   tell_object( player, message);
   tell_room( environment( player ),player->the_short()+" shudders and "
         "looks worried.\n", player );
   player->run_away();
   if (sizeof(player->effects_matching("priest.paralysis"))){
     tell_object(player,"You look around in panicked confusion, unsure "
                 "of exactly where you are.\n");
     tell_room( environment( player ),player->the_short()+ " stares dazedly "
                "at their surroundings.\n",player);
     tell_object(player,((environment(player)->query_long() )+"\n"));
  }
}
string query_classification() { return "curse.magic.social"; }

==================================================
FILE: /lib/std/effects/npc/vampirebite_effect.c
==================================================

#include <effect.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
mapping compass = ([ "north" : 1, "northeast" : 1, "east" : 1, "southeast" : 1,
                     "south" : 1, "southwest" : 1, "west" : 1, "northwest" : 1
                    ]);
void come_around( object person );
string query_classification() { return "body.bite.vampire"; }
string query_shadow_ob() { return "/std/shadows/npc/vampirebite_shadow"; }
int survive_death() { return 1; }
int beginning( object person, int extent, int id ) {
   int con, time;
   tell_object( person, "Pain shoots through your veins, exploding inside "
      "your head, making you scream in agony as the effect of the vampire's "
      "bite fills your body.\n" );
   person->add_extra_look( this_object() );
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);
   person->submit_ee( "bite_pain", ({ 10, 60 }), EE_CONTINUOUS );
   con = person->query_con();
   if( con < 1 ) con = 1;
   time = 2 * extent / con;
   person->submit_ee( 0, time, EE_REMOVE );
   return time;
}
int merge_effect( object person, int old_time, int new_extent, int id ) {
   int con, new_time;
   con = person->query_con();
   if( con < 1 ) con = 1;
   new_time = ( 2 * new_extent / con ) + person->expected_tt();
   person->submit_ee( 0, new_time, EE_REMOVE );
   return new_time;
}
void restart( object person, int time, int id ) {
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);
}
void end( object person, int time, int id ) {
   if( person->query_property( PASSED_OUT_PROP ) )
      come_around( person );
   person->adjust_bonus_int(2);
   person->adjust_bonus_wis(2);
   person->adjust_bonus_str(2);
   person->adjust_bonus_dex(2);
   tell_object( person, "The firey pain screaming through your veins and "
      "incessant pounding inside your head finally wear off, leaving you "
      "with a mild headache.\n" );
}
void bite_pain( object person, int time, int id ) {
   int timeleft, selector;
   timeleft = (int)person->expected_tt();
   if( person->query_property( PASSED_OUT_PROP ) ) {
      switch( random(3) ) {
      case 0 :
         tell_room( environment(person), person->one_short() + " shakes "
            "slightly in silent agony.\n", person );
         break;
      case 1 :
         tell_room( environment(person), person->one_short() + " moans, "
            "writhing on the ground.\n", person );
         break;
      case 2 :
         tell_room( environment(person), person->one_short() + " opens " +
            person->query_possessive() + " eyes, stares around wildly as if "
            "in a fever, and passes out again with a groan.\n", person );
         break;
      }
      return;
   }
   selector = random( timeleft ) / person->query_con() / 5;
   switch( selector ) {
   case 0 :
      break;
   case 1 :
   case 2 :
      switch( random(4) ) {
      case 0 :
         person->new_parser( "gasp in pain" );
         break;
      case 1 :
         person->new_parser( "moan agonisingly" );
         break;
      case 2 :
         person->new_parser( "stumble" );
         break;
      default :
         person->new_parser( "dloh head in pain" );
         break;
      }
      break;
   case 3 :
   case 4 :
   case 5 :
      switch( random(4) ) {
      case 0 :
         tell_object( person, "You clutch your head and groan in agony as "
            "the effect of the vampires bite burns through you.\n" );
         tell_room( environment( person ), person->the_short() +
            " clutches " + person->query_possessive() + " head and groans "
            "in agony.\n", person );
         break;
      case 1 :
         tell_object( person, "You stagger about, your vision blurring and "
            "fading for a moment while your head throbs with pain.\n" );
         tell_room( environment( person ), person->the_short() +
            " staggers about, " + person->query_possessive() + " eyes "
            "drifting in and out of focus.\n", person );
         break;
      case 2 :
         tell_object( person, "You feel yourself go lightheaded and the "
            "pain fades for just a moment, before slamming back into you "
            "like a hammer to the forehead.\n" );
         tell_room( environment( person ), person->the_short() + " pales "
            "as the blood drains from " + person->query_possessive() +
            " face, then clenches " + person->query_possessive() + " teeth "
            "and groans with pain.\n", person );
         break;
      default :
         tell_object( person, "The fire flooding through your veins causes "
            "you to scream in agony, your body racked with pain.\n" );
         tell_room( environment( person ), person->the_short() + " leans "
            + person->query_possessive() + " head back and screams in "
            "pain.\n", person );
         break;
      }
      break;
   default :
      if( timeleft > 100 ) {
         switch( random(2) ) {
         case 0 :
            tell_object( person, "The world goes black.  You have "+
                "passed out.\n" );
            tell_room( environment( person ), "The blood drains from " +
                person->the_short() + "'s face, and " +
                person->query_pronoun() + " collapses heavily to the "
                "ground.\n", person );
            person->add_property( PASSED_OUT_PROP, 1 );
            person->submit_ee( "come_around", ({ 50, 80 }), EE_ONCE );
            break;
         case 1 :
            person->submit_ee( "wander_about", 3, EE_ONCE );
            break;
         }
      }
   }
}
void come_around( object person ) {
   tell_object( person, "You feel a pounding headache coming on and realise "
      "you are finally conscious.\n" );
   tell_room( environment( person ), person->the_short() + " groans "
      "painfully, opens " + person->query_possessive() + " eyes and slowly "
      "picks " + person->query_objective() + "self up.\n", person );
   person->remove_property( PASSED_OUT_PROP );
}
void wander_about( object person, int time, int id ) {
   int i, flag;
   string *direcs;
   if( person->query_property( PASSED_OUT_PROP ) || !environment( person ) )
      return;
   if( random( 4 ) )
      person->submit_ee( "wander_about", ({ 8, 8 }), EE_ONCE );
   direcs = (string *)environment( person )->query_direc();
   while( sizeof( direcs ) && !flag ) {
      i = random( sizeof( direcs ) );
      if(
          !environment( person )->query_door_open( direcs[ i ] ) ) {
         direcs = delete( direcs, i, 1 );
         continue;
      }
      person->add_property( UNKNOWN_MOVE, 1 );
      if( compass[direcs[i]] )
         flag = person->exit_command( 0, ({ direcs[ i ], "$N attempt$s to "
            "walk in one direction and instead stumble$s off towards the "
            "$T." }) );
      else
         flag = person->exit_command( 0, ({ direcs[ i ], "$N stumble$s off "
            "towards the $T." }) );
      tell_object( person, "You attempt to get up and walk and just "
         "manage to stumble around a bit.\n" );
      person->remove_property( UNKNOWN_MOVE );
      if( !flag )
         direcs = delete( direcs, i, 1 );
   }
}
string extra_look( object player, mixed *args ) {
    return capitalize(player->query_pronoun()+" looks rather pale with cold,"
    " clammy skin and a look of dizziness.\n");
}
# Total Tokens: 25454
# Total Files Merged: 54
# Total Characters: 84999

