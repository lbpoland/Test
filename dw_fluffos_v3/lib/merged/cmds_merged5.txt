# Total Tokens: 25463
# Total Files Merged: 27
# Total Characters: 84955

.c
==================================================

inherit "/cmds/base";
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <player_handler.h>
#include <clubs.h>
#include <player.h>
#include <nomic_system.h>
#include <tune.h>
#include <skills.h>
#include <combat.h>
#define essify(x,y) (x > 1  ||  x == 0 ? " " y "s" : " " y)
#define LIMIT 150
int score_quests(object ob, int sorted) {
   string *quests;
   mixed *quest_info;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   if(this_player()->query_role_playing()) {
     write("Sorry, you're roleplaying.\n");
     return 1;
   }
   quests = LIBRARY->query_quests( ob->query_name() );
   if ( !sizeof( quests ) ) {
      printf( "You have not completed any quests.\n" );
      return 1;
   }
   quest_info = map(quests, (: ({ QUEST_HANDLER->query_quest_title($1),
                                  QUEST_HANDLER->query_quest_story($1) }) :));
   if (sorted) {
      quest_info = sort_array(quest_info, (: strcmp($1[0], $2[0]) :));
   }
   write( "$P$Quests$P$You have completed the following quests:\n"+
         implode( map_array( map_array( quest_info, (: "     \""+
         $1[0] +"\", in which you "+
         replace( $1[1],
         "was", "were" ) :) ), (: sprintf( $1[ 0 .. 24 ] +"%*-=s",
         $(ob)->query_cols() - 30, $1[ 25 .. ] ) :) ), ",\n" ) +".\n" );
   return 1;
}
int query_verbose(object ob, string verbose)  {
   if (!verbose) {
      return ob->query_verbose("score");
   }
   if (verbose == "verbose") {
      return 1;
   }
   return 0;
}
int score_stats(object ob, string verbose)  {
   string word;
   int stat;
   string ret;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
     write( "You are just a disembodied spirit.  What use does a wispy thing "
            "like you have for a collection of meaningless numbers?\n" );
     return 1;
   }
   if(this_player()->query_role_playing()) {
     ret = "";
     if(stat = (this_player()->query_tmp_str() +
                this_player()->query_bonus_str())) {
       if ( stat > 0 ) {
         ret += "You feel stronger than usual.\n";
       } else {
         ret += "You feel weaker than usual.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_int() +
                   this_player()->query_bonus_int() ) ) {
       if ( stat > 0 ) {
         ret += "You feel smarter than normal.\n";
       } else {
         ret += "You feel less smart than normal.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_con() +
                   this_player()->query_bonus_con() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more healthy than usual.\n";
       } else {
         ret += "You feel a bit sickly.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_dex() +
                   this_player()->query_bonus_dex() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more nimble than usual.\n";
       } else {
         ret += "You feel more clumsy than you normally do.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_wis() +
                   this_player()->query_bonus_wis() ) ) {
       if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
       } else {
         ret += "You feel a bit vague.\n";
       }
     }
     if ( !strlen( ret ) ) {
       ret += "You feel fine.\n";
     }
     printf( "%s", ret );
   } else {
     word = ( ob->query_weight() / 20 ) +"."+ ( ob->query_weight() % 10 );
     if (query_verbose(ob, verbose))  {
       printf( "%-#*s\n", ob->query_cols(),
               "Constitution ... "+ ob->query_con() +"\n"+
               "Dexterity ...... "+ ob->query_dex() +"\n"+
               "Intelligence ... "+ ob->query_int() +"\n"+
               "Strength ....... "+ ob->query_str() +"\n"+
               "Wisdom ......... "+ ob->query_wis() +"\n"+
               "Height ......... "+ ob->query_height() +" cm\n"+
               "Weight ......... "+ word +"kg\n" );
     } else  {
       printf( "%-#*s\n", ob->query_cols(),
               "Con: "+ ob->query_con() +"\nDex: "+ ob->query_dex() +"\n"+
               "Int: "+ ob->query_int() +"\nStr: "+ ob->query_str() +"\n"+
               "Wis: "+ ob->query_wis() +"\nHgt: "+ ob->query_height() +" cm\n"+
               "Wgt: "+ word +"kg\n" );
     }
   }
   return 1;
}
int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
}
string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are in perfect health";
   case 70..89:
      return "you are slightly wounded";
   case 50..69:
      return "you are moderately wounded";
   case 30..49:
      return "you are seriously wounded";
   case 15..29:
      return "you are critically wounded";
   case 6..14:
      return "you are fatally wounded";
   case 0..5:
      return "you are near death";
   default:
      return "you are broken";
   }
}
string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are full of energy";
   case 70..89:
      return "you are enthusiastic";
   case 50..69:
      return "you are not quite so full of beans";
   case 30..49:
      return "you are weary";
   case 15..29:
      return "you are tired";
   case 6..14:
      return "you are exhausted";
   case 0..5:
      return "you are nearly unconscious";
   default:
      return "you are broken";
   }
}
int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;
   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   if (!total) {
      total = cost;
   }
   return total;
}
string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   xptotal /= sizeof( skills );
   switch( calc_percent( current, xptotal ) ) {
   case 0..20:
      return "you don't think you can learn much at the moment";
   case 21..59:
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100:
      return "if you squeezed it, you could gain some insight";
   case 101..300:
      return "you might be able to learn something new, if you found the right teacher";
   case 301..400:
      return "a small amount could be learned with training";
   case 401..800:
      return "a bit of training might be in order";
   case 801..1200:
      return "you could very well learn something new from training";
   case 1201..1500:
      return "you could benefit from training";
   case 1501..2000:
      return "you feel like training might help";
   case 2001..2500:
      return "you should consider training your skills";
   case 2501..4000:
      return "your skills could be greatly improved with training";
   default:
      return "certainly a hearty training session is in order";
   }
}
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
}
string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
}
string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
}
string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }
   switch ( remaining ) {
   case 0..0:
      return "Death has a special interest in your next appointment";
   case 1..3:
      return "Death is starting to lose patience with you";
   case 4..7:
      return "You and Death are on good terms";
   default:
      return "You have an \"arrangement\" with Death";
   }
}
int score_rp(object me, string verbose) {
  if(query_verbose(me, verbose)) {
    printf( "%s.\n%s and %s.\n%s.\n%s.\n%s.\n%s.\n%s.\n",
            "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ),
            capitalize( find_align_string( me ) ),
            capitalize( find_wimpy_string( me->query_wimpy() ) ),
            "You are "+ me->burden_string() + " and " +
               this_player()->query_temp_str(),
            find_death_string( me->query_max_deaths() - me->query_deaths() ) );
  } else {
    printf( "%s and %s.\n%s.\n",
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ) );
  }
  return 1;
}
int score_burden(object me, string verbose) {
  write( sprintf("You are %s (%d%%).\n", me->burden_string(),
          me->query_burden()));
  return 1;
}
int score_normal(object ob, string verbose)  {
   string word;
   string guild_ob;
   string area;
   string* magistrates;
   string* citizens;
   int age, temp1, temp2, temp3, temp4;
   int no_title;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   if(ob->query_role_playing())
     return score_rp(ob, verbose);
   if (query_verbose(ob, verbose))  {
      guild_ob = ob->query_guild_ob();
      if (!guild_ob) {
         guild_ob = "/std/guilds/warrior";
         no_title = 1;
      }
      temp1 = ob->query_hp();
      temp2 = ob->query_gp();
      temp3 = (int)LIBRARY->query_quest_points( ob->query_name() );
      temp4 = ob->query_sp();
      printf( "%-=*s", ob->query_cols(), "You have " +
            temp1 + " (" + ob->query_max_hp() + ") hit" +
            essify(temp1, "point") + ", " +
            temp2 + " (" + ob->query_max_gp() + ") guild" +
            essify(temp2, "point") + ", " +
            temp3 + " (" + (int)QUEST_HANDLER->query_total_qp() + ") quest" +
            essify(temp3, "point") + " and " +
            temp4 + " (" + ob->query_max_sp() + ") social" +
            essify( temp4, "point") + ".\n" );
      if ( guild_ob && find_object( guild_ob ) )  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() + " and you are level " +
               (int)ob->query_level() + " in the " +
               (no_title?"Adventurers' Guild":guild_ob->query_short()) +
               ((ob->query_guild_ob() == "/std/guilds/thief" &&
               !(ob->query_guild_data() == 0)) ?
               ", specialised as a " + ob->query_guild_data() : "") +
               "; your overall rating is " + (int)TOP_TEN_HANDLER->
               calculate_rating( ob ) + ".\n" );
      }  else  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() +".\n" );
      }
      temp1 = ob->query_deaths();
      temp2 = ob->query_max_deaths() - temp1;
      printf( "%-=*s", ob->query_cols(), "You have died " +
            temp1 + essify(temp1, "time") + " and can die " +
            temp2 + essify(temp2, "time") + " before you are completely "
            "dead.\n" );
      if ( ob->query_wimpy() )  {
         printf( "Your wimpy is set to %d%%.\n", ob->query_wimpy() );
      } else  {
         printf( "You are in brave mode.\n" );
      }
#ifdef USE_SURRENDER
      if (ob->query_surrender())  {
         printf("You will surrender at %d%% of your maximum hit points.\n",
            ob->query_surrender());
      } else  {
         printf("You won't surrender.\n");
      }
#endif
      printf( "You are %s (%d%%) and %s.\n", ob->burden_string(),
              ob->query_burden(),
               this_player()->query_temp_str());
      word = ob->query_deity();
#ifndef __DISTRIBUTION_LIB__
      if ( stringp( word ) )  {
         printf( "You are %s, worshipping %s.\n", ob->align_string(),
               capitalize( word ) +", "+ (string)DEITY->query_title( word ) );
      } else  {
         printf( "You are %s, worshipping no god.\n", ob->align_string() );
      }
#endif
      citizens = ({ });
      magistrates = ({ });
      word = ob->query_name();
      foreach (area in NOMIC_HANDLER->query_citizenship_areas()) {
         if (NOMIC_HANDLER->is_magistrate_of(area, word)) {
            magistrates += ({ area });
         } else if (NOMIC_HANDLER->is_citizen_of(area, word)) {
            citizens += ({ area });
         }
      }
      if (sizeof(magistrates)) {
          printf("You are a magistrate of: " +
                 query_multiple_short(magistrates) + ".\n");
      }
      if (sizeof(citizens)) {
          printf("You are a citizen of: " +
                 query_multiple_short(citizens) + ".\n");
      }
      if ( ob->query_property( PKER ) )  {
         printf( "You are registered as a player killer.\n" );
      }
      if ( m_sizeof( ob->query_hide_invis() ) )  {
         printf( "%-=*s\n", ob->query_cols(), "You are " +
               query_multiple_short( m_indices( ob->query_hide_invis() ) +
                                     ({ }) ) + "." );
      }
      printf( "%-=*s", ob->query_cols(), (string)ob->extra_score() );
      age = -ob->query_time_on();
      temp3 = ob->query_no_logins();
      word = sprintf("You are %s old and have logged in %d %s.\n",
                     query_time_string(age, -1),
                     temp3, (temp3 == 1 ? "time" : "times"));
      printf("%-=*s", ob->query_cols(), word);
   } else {
      printf( "%-=*s", ob->query_cols(), "Hp: " + ob->query_hp() + "(" +
            ob->query_max_hp() + ")  Gp: " + ob->query_gp() + "(" +
            ob->query_max_gp() + ")  Xp: "+ ob->query_xp() + "\n" );
   }
   return 1;
}
string create_relationship_text( string relationship, mapping data ) {
    string *relatives;
    int size;
    if ( !( relatives = data[ relationship ] ) )
        return "";
    if ( !size = sizeof( relatives ) )
        return "";
    if ( size == 1 ) {
        return capitalize( relatives[0] ) + " is your " +
            relationship;
    }
    return query_multiple_short( map( sort_array( relatives, 1 ),
        (: capitalize( $1 ) :) ) ) + " are your " +
        pluralize( relationship );
}
int get_gender( string name ) {
    int gender;
    gender = PLAYER_HANDLER->test_gender( name );
    if ( gender )
        gender -= 1;
    return gender;
}
int score_relationships( object ob, int verbose ) {
    string txt, family;
    string *sorted;
    class relationship_data *bing;
    mapping grouped;
    family = ob->query_family_name();
    if ( !family || !CLUB_HANDLER->is_family( family ) ) {
        add_failed_mess( "You're not in a family!\n" );
        return 0;
    }
    bing = CLUB_HANDLER->query_relationships( family, ob->query_name() );
    if ( !sizeof( bing ) ) {
        add_failed_mess( "You have no relatives.\n" );
        return 0;
    }
    grouped = unique_mapping( bing,
        (: CLUB_HANDLER->query_relationship_gender(
           CLUB_HANDLER->query_opposite_relationship( $1->relationship ),
           get_gender( $1->related_to ) )  :) );
    grouped = map( grouped, (: map( $2, (: $1->related_to :) ) :) );
    sorted = sort_array( keys( grouped ), 1 );
    txt = implode( map( sorted,
        (: create_relationship_text( $1, $(grouped) ) :) ), ".\n" );
    tell_object( ob, "$P$Relationships$P$" + txt + ".\n" );
    return 1;
}
int score_align( object ob, int verbose ) {
  int upper, lower, middle, align;
  string god, opinion;
  if (ob->query_property( "dead" )) {
     write( "You're dead.  Things such as 'good' and 'evil' are no longer of
      your concern.\n" );
     return 1;
  }
   if( !ob->query_deity() ) {
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
    }
  else {
    god = ob->query_deity();
    align = ob->query_al();
#ifndef __DISTRIBUTION_LIB__
    lower = DEITY->query_al_lower( god );
    upper = DEITY->query_al_upper( god );
    middle = DEITY->query_al_middle( god );
    opinion = "pleased with";
    if( align <= lower - LIMIT || align >= upper + LIMIT )
      opinion = "very angry with";
    if( ( align < lower && align > lower - LIMIT ) ||
        ( align > upper && align < upper + LIMIT ) )
      opinion = "quite annoyed with";
    if( ( align >= lower && align <= lower + LIMIT ) ||
        ( align <= upper && align >= upper - LIMIT ) )
      opinion = "a little concerned about";
    if( align > middle - ( LIMIT / 2 ) && align < middle + ( LIMIT / 2 ) )
      opinion = "very happy with";
    write( "You are " + ob->align_string() + ".  " + capitalize( god ) +
      " is " + opinion + " you.\n" );
#else
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
#endif
  }
  return 1;
}
int score_fighting( object player, int verbose ) {
    object *attacker_list;
    object *attacker_list_here;
    string ret;
    class tactics tactics;
    attacker_list = player->query_attacker_list() - ({ 0 });
    ret = "";
    if ( attacker_list ) {
       attacker_list_here = filter( attacker_list, (: $1 && living( $1 ) &&
           environment( $1 ) == environment( $(player) ) :) );
       if ( !sizeof( attacker_list ) ) {
           ret += "You are not fighting anything!\n";
       } else {
          attacker_list -= attacker_list_here;
          if (sizeof(attacker_list_here)) {
             ret += "$I$5=You are currently fighting " +
                 query_multiple_short( attacker_list_here ) + " here.\n";
          }
          if (sizeof(attacker_list)) {
             ret += "$I$5=You are currently fighting " +
                 query_multiple_short( attacker_list ) + " (these are "
                 "people you will auto attack on sight).\n" ;
          }
       }
    }
    tactics = (class tactics) this_player()->query_tactics();
    ret += "$I$0=Your current tactics are:\n"
      "   Attitude       :   "+ tactics->attitude +"\n"
      "   Response       :   "+ tactics->response +"\n"
#ifdef USE_SURRENDER
      "   Mercy          :   "+ (tactics->mercy?tactics->mercy:"none") + "\n"
#endif
      "   Focus          :   "+
      (tactics->focus_zone?tactics->focus_zone:"none") + "\n"
#ifdef USE_DISTANCE
      "   Target distance:   "+
      (tactics->ideal_distance?tactics->ideal_distance:"none") + "\n"
#endif
      "   Attack         :   "+ (tactics->attack == "both" ? "both" :
                     (tactics->attack?tactics->attack:"both")) + "\n"
      "   Parry          :   " + (tactics->parry == "both" ? "both" :
                      (tactics->parry?tactics->parry:"both")) + "\n"
      "   Unarmed Parry  :   " + (tactics->parry_unarmed ? "yes" : "no") + "\n";
    write(ret);
    return 1;
}
int score_temperature( object player, int verbose ) {
   return "/cmds/player/temp_erature"->cmd();
}
mixed *query_patterns() {
   return ({
             "quests", (: score_quests(this_player(), 0) :),
             "quests sorted", (: score_quests(this_player(), 1) :),
             "{brief|verbose} stats", (: score_stats(this_player(), $4[0]) :),
             "stats", (: score_stats(this_player(), 0) :),
             "{brief|verbose}", (: score_normal(this_player(), $4[0]) :),
             "relationships", (: score_relationships( this_player(), 0 ) :),
             "temperature", (: score_temperature( this_player(), 0 ) :),
             "burden", (: score_burden( this_player(), 0 ) :),
             "", (: score_normal(this_player(), 0) :),
             "{align|alignment}", (: score_align(this_player(), 0) :),
             "fighting", (: score_fighting( this_player(), 0 ) :) });
}

==================================================
FILE: player/sea_rch.c
==================================================

#include <tasks.h>
#include <player.h>
inherit "/cmds/base";
#define SKILL "other.perception"
#define GP_COST 15
nosave mapping callouts = ([]);
int cmd(string str) {
   if (this_player()->query_specific_gp("other") < GP_COST) {
      add_failed_mess("You are too weary to complete a "
                      "proper search of your surroundings.\n");
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess("Ghosts cannot search!\n");
      return 0;
   }
   if (sizeof(filter(this_player()->query_attacker_list(),
                     (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot search, you are in combat!\n");
      return 0;
   }
   this_player()->adjust_time_left( -ROUND_TIME * 4 );
   if (callouts[this_player()->query_name()]) {
      remove_call_out(callouts[this_player()->query_name()]);
   }
   callouts[this_player()->query_name()] =
      call_out("search_callout", 4*1, this_player(), str);
   this_player()->adjust_gp(-GP_COST);
   write("You start to search around.\n");
   say(this_player()->the_short() + " $V$0=starts,start$V$ to search around.\n");
   return 1;
}
void search_callout(object who, string str) {
   mapping hide_invis;
   int i;
   string *types;
   string* ground;
   mixed see;
   object *found, ob;
   if (who->query_fighting()) {
      write("Oops!  You appear to have entered combat and cannot "
            "finish searching.\n");
      return ;
   }
   if ( function_exists( "do_search", environment( who ) ) ) {
      i = (int)environment( who )->do_search( str );
      switch(i) {
      case 1:
         return;
      case 0:
         if(query_notify_fail())
            write(query_notify_fail());
         return;
      default:
         break;
      }
   }
   if(!str) {
      found = ({ });
      foreach(ob in all_inventory(environment(who))) {
         if(ob->query_visible(who) ||
            ob->query_creator() ||
            pk_assist(this_player(), ob))
           continue;
         hide_invis =  ob->query_hide_invis();
         if(mapp(hide_invis)) {
            types = m_indices( hide_invis );
         } else {
            types = ({});
         }
         if ( !sizeof( types ) ) {
            continue;
         }
         for ( i = 0; i < sizeof( types ); i++ ) {
            if ( hide_invis[ types[ i ] ][ 0 ] == who ) {
               continue;
            }
            see = hide_invis[ types[ i ] ][ 1 ];
            if ( intp( see ) ) {
               see -= random(environment(who)->query_light());
               see /= 2;
               switch(TASKER->perform_task(who, SKILL, see, TM_FREE)) {
               case AWARD:
                  write("%^YELLOW%^"+
                        ({"You feel very perceptive", "You realise "
                             "something new about searching"})[random(2)]+
                             "%^RESET%^.\n");
               case SUCCEED:
                  found += ({ ob });
                  ob->remove_hide_invis(types[i]);
                  break;
               }
               break;
            }
         }
      }
   }
   if(sizeof(found)) {
      write("You search around and find "+query_multiple_short(found)+".\n");
   } else {
      ground = environment(who)->query_default_search_description();
      if (!ground) {
         write( ({
         "You search around for a while, but don't find anything.\n",
         "You scrounge around.  The ground does look interesting, "
            "you decide.\n",
         "You look carefully at everything, but you find nothing.\n",
         "After an intense search, you find nothing.\n" })[ random( 4 ) ] );
      } else {
         write(ground[random(sizeof(ground))]);
      }
   }
   say("$one_short:" + file_name(who) + "$ $V$0=searches,search$V$ around the "
       "place a bit.\n" );
   event(environment(who), "player_search");
   map_delete(callouts, who->query_name());
   return;
}
void interrupt_search(object who) {
   if(callouts[who->query_name()]) {
      remove_call_out(callouts[who->query_name()]);
      tell_object(who, "You stop searching.\n");
      map_delete(callouts, who->query_name());
   }
}
mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :),
             "here", (: cmd(0) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/shields.c
==================================================

#include <armour.h>
#include <combat.h>
inherit "/cmds/base";
string construct_shield_message( object player, int not_self );
int cmd() {
  string mess;
  mess = construct_shield_message(this_player(), 0);
  if( sizeof( mess ) ) {
    tell_object( this_player(), "Arcane protection status:\n" + mess );
  } else {
    tell_object( this_player(), "You do not have any arcane protection.\n" );
  }
  return 1;
}
string construct_shield_message( object player, int not_self ) {
  int i, j;
  string mess;
  mixed *callbacks;
  string *res;
  class armour_callback cb;
  class combat_special cs;
  mess = "";
  callbacks = player->query_armour_callbacks();
  for( i = 0; i < sizeof(callbacks); i++) {
    for(j=0; j < sizeof(callbacks[i]); j++) {
      cb = callbacks[i][j];
      if(cb->callback[0]) {
        res = (cb->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
      }
    }
  }
  callbacks = player->query_specials();
  for(i=0; i<sizeof(callbacks); i++) {
    cs = callbacks[i];
    if(cs->callback[0]) {
      res = (cs->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
    }
  }
  return mess;
}
mixed *query_patterns() {
  return ({ "", (: cmd :) });
}

==================================================
FILE: player/spells.c
==================================================

#include <spells.h>
inherit "/cmds/base";
int cmd() {
   string spell, *magic;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   magic = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( !stringp( spells[ spell ][ S_OBJECT ] ) ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*spriest%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*srituals%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*swizard%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*switch%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*sspell%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
   }
   if ( !sizeof( magic ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   if ( sizeof( magic ) ) {
      write( "You know the following magic spell"+
            ( sizeof( magic ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( magic, 1 ), "\n" ) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/splash.c
==================================================

inherit "/cmds/base";
#include <weather.h>
#define TP this_player()
mixed cmd(object *obs) {
    object env, ob;
    string str;
    env = environment(TP);
    if ( !env->query_baths()  &&  (!env->query_water()  ||  !env->query_surface()) ) {
        if ((string)env->query_property("location") == "inside")
            return notify_fail("You must be outside to do that.\n");
        if (!WEATHER->query_raining(env))
            return notify_fail("It must be raining to splash someone.\n");
    }
    foreach(ob in obs) {
        ob->add_effect("/std/effects/other/wetness", 2 + random(4));
        if(ob == this_player())
            continue;
        tell_object(ob, (string)TP->a_short()+" splashes "+
          query_multiple_short(obs - ({ ob }) + ({ "you" }))+".\n");
    }
    str = query_multiple_short(obs);
    write("You splash "+str+".\n");
    say(TP->a_short()+" splashes "+str+".\n", obs);
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:living>",(: cmd($1) :) });
}

==================================================
FILE: player/start.c
==================================================

inherit "/cmds/base";
int clear_starts() {
  write( "Clearing your list of starting positions...\n" );
  this_player()->reset_starts();
  return 1;
}
int list_starts() {
   int z, i;
   string *starts;
   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;
   if ( z == -1 ) {
      write( "Your starting position is " +
             this_player()->query_start_pos()->the_short() + ".\n");
      return 1;
   }
   if ( !z ) {
      write( "Your starting position is "+ starts[ 1 ] +".\n" );
      return 1;
   }
   write( "Your current starting position is "+ starts[ 1 ] +".\n"+
         "You can also choose your starting position from:\n" );
   for ( i = 1; i <= z; i++ )
      write( sprintf( "% 5d: $I$7=%s\n", i, starts[ 2 * i + 1 ] ) );
   write( "Choose a new starting position using: start <number>\n"+
         "To clear your list of starting positions, use: start clear\n" );
   return 1;
}
int set_start( int num ) {
   string *starts;
   int z;
   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;
   if (sizeof(starts) < 2) {
      add_failed_mess("You only have one starting location.\n");
      return 0;
   }
   if (z == 0) {
      add_failed_mess("You have no starting locations to choose from at all.\n");
      return 0;
   }
   if ( ( num < 1 ) || ( num > z ) ) {
      add_failed_mess( "You must choose a number from 1 to "+ z +".\n" );
      return 0;
   }
   num *= 2;
   write( "Your new starting position is "+ starts[ num + 1 ]  +".\n" );
   this_player()->set_start_location(starts[num]);
   return 1;
}
mixed *query_patterns() {
  return ({ "<number>", (: set_start($4[0]) :),
            "clear", (: clear_starts() :),
            "", (: list_starts() :) });
}

==================================================
FILE: player/stop.c
==================================================

inherit "/cmds/base";
int no_okay;
object tmp;
mixed cmd( string word ) {
   object *atts;
   switch( word ) {
      case "debate" :
      case "debating" :
         this_player()->interrupt_debate();
         break;
      case "spell" :
         this_player()->interrupt_spell();
         break;
      case "ritual" :
         this_player()->interrupt_ritual();
         break;
      case "fight" :
      case "fighting" :
         atts = this_player()->query_attacker_list();
         if ( !sizeof( atts ) ) {
            write( "You are not fighting anyone.\n" );
            return 1;
         }
         if ( (int)this_player()->query_hp() < 0 ) {
            write( "You have already died; stopping now is pointless.\n" );
            return 1;
         }
         write( "Stopping fight.  Please wait.\n" );
         call_out( "stop_fight", 5+random(10), this_player() );
         return 1;
      default:
         no_okay = 1;
         cmd( "debate" );
         cmd( "spell" );
         cmd( "ritual" );
         cmd( "fight" );
         no_okay = 0;
   }
   "/cmds/player/sea_rch"->interrupt_search(this_player());
   if ( !no_okay )
      write( "Okay.\n" );
   return 1;
}
void stop_fight( object who ) {
  object *atts, ob;
  if ( !who )
    return;
  atts = who->query_attacker_list();
  atts -= ({ 0 });
  tmp = who;
  if(atts == ({ }))
    return;
  tell_object( who, "You stop fighting "+
               query_multiple_short( map_array( atts,
         (: $1->query_property( "dead" ) ? (string)$1->a_short() + " (dead anyway)" : $1 :) ) ) +".\n" );
  foreach(ob in atts)
    who->stop_fight(ob);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{debate|debating|spell|ritual|fight|fighting}", (: cmd($4[0]) :) });
}

==================================================
FILE: player/su.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>;
#define TEAM_HANDLER "/obj/handlers/team"
#define TP this_player()
mixed cmd(string str) {
  string from;
  if (!str || str == "")
    return notify_fail("Usage: su <name>\n");
  if ( TP->query_auto_loading() ) {
    printf("You cannot quit yet: your inventory is still being generated.\n" );
    return 1;
  }
  if ( find_object( "/obj/shut" )) {
    write("You cannot su during a reboot.\n");
    return 1;
  }
  if(sizeof(TP->query_attacker_list())) {
    write("You cannot quit while in combat.\n");
    return 1;
  }
  if (TEAM_HANDLER->query_group(this_player()))  {
    "/cmds/player/leaveg_roup"->cmd(0);
  }
  if (environment(this_player()) == find_object("/room/departures"))  {
    write("You can't use su in the departure lounge.\n");
    return 1;
  }
  from = TP->query_name();
  clone_object("/secure/login")->do_su(str);
  seteuid( "Root" );
  if(str == from)
    LOGIN_HANDLER->write_log("Su", TP->query_name(),
                             TP->query_property("guest"), "(to self)");
  else
    LOGIN_HANDLER->write_log("Su", from, TP->query_property("guest"), str);
  return 1;
}
mixed* query_patterns() {
   return ({ "<string'new name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/t_ell.c
==================================================

#include <drinks.h>
#include <player.h>
#include <language.h>
#define TP this_player()
#define TELL_REPLY_LOCK_ID "lock fluff"
#define CUT_THOUGH_PROPERTY "cut earmuffed tells"
#define FAIL_DONT_ASK 0
#define ASK 1
#define CUT_DONT_ASK 2
inherit "/cmds/base";
inherit "/cmds/speech";
void delayed_tell(string yesno,
                  object * recicipients,
                  string message);
#ifdef USE_SMILEYS
string *two_smileys = ({ ":)", ":(", ":P", ":p", ":b", ";)",
                           ";(", ";P", ";p", ";b", "=)", "=("
                           });
string *three_smileys = ({ ":-)", ":-(", ":-P", ":-p", ":-b",
                             ";-)", ";-(", ";-P", ";-p", ";-b", ":o)", ":o(",
                             ":oP", ":op", ":ob", ";o)", ";o(", ";oP", ";op",
                             ";ob", "=-)", "=-(", "=o)", "=o("
                             });
#endif
int cmd(string arg, mixed thing, int silent) {
  class message mess;
  string words,
    word;
  string them_mess,
    extra;
  string *ok_string;
  string *prop;
  object *obs;
  object *net_dead;
  object *multiple_earmuffed;
  object *cannot_see;
  object *ok;
  object *fail;
  object *earmuffed;
  object *roleplaying;
  mixed busy;
  if (pointerp(thing)) {
    words = arg;
    thing -= ({ 0 });
    if (TP && environment(TP) &&
        function_exists("trap_tell", environment(TP)) &&
        member_array(this_object(), previous_object(-1)) == -1) {
      return (int) environment(TP)->trap_tell(words, thing, 0);
    }
  } else if (!objectp(thing)) {
    if (!arg || sscanf(arg, "%s %s", word, words) != 2) {
      return 0;
    }
    word = lower_case(word);
    word = (string) TP->expand_nickname(word);
    if (sizeof(thing = explode(word, ",")) == 1)
      thing = ({ find_player(word) });
    else {
      thing = map(thing, (: find_player :));
    }
    thing -= ({ 0 });
    if (sizeof(thing) == 0) {
      if (TP->query_creator() && sscanf(word, "%*s@%*s") == 2) {
        "/net/daemon/out_tell"->do_tell(word + " " + words);
        return 1;
      }
      add_failed_mess(capitalize(word) + " is not logged in.\n");
      return 0;
    }
    if (environment(TP)) {
      if (function_exists("trap_tell", environment(TP)) &&
          member_array(this_object(), previous_object(-1)) == -1) {
        return environment(TP)->trap_tell(words, thing, 0);
      }
    }
  } else {
    thing = ({ thing }) - ({ 0 });
    words = arg;
  }
  if (TP->check_earmuffs("tell")) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      fail = filter(thing, (: !TP->is_friend($1->query_name()) &&
                            $1 != this_player() :));
      if (sizeof(fail)) {
        add_failed_mess("One of the people ($I) you "
                        "are trying to tell is not a "
                        "friend (and you have tells earmuffed).\n",
                        fail );
        return -1;
      }
    } else {
      add_failed_mess("You have tells ear muffed.\n");
      return -1;
    }
  }
  if(TP->query_role_playing()) {
    add_failed_mess("You cannot send tells as you are currently "
        "role playing.\n");
    return -1;
  }
  mess = build_message(words, thing, "tell");
  switch(mess->status) {
  case NOT_DISTANCE:
    return add_failed_mess("The language " + capitalize(mess->language) +
                           " is not able to used over a distance.\n");
  case NOT_SPOKEN:
    return add_failed_mess(capitalize(mess->language) +
                           " is not a spoken language.\n");
  case NO_MESSAGE:
    return add_failed_mess("No message given.\n");
  }
  obs = thing - ({ this_player() });
  if (!sizeof(obs)) {
    add_failed_mess("Talking to yourself again.  I don't know.\n");
    return 0;
  }
  if (sizeof(obs) > 20) {
    add_failed_mess("You can only tell up to 20 people a message.\n");
    return 0;
  }
  fail = this_player()->query_ignoring(obs);
  if (sizeof(fail)) {
    write("You are currently ignoring " +
          query_multiple_short(fail, 0, 1, 0, 0) + ", so " +
          (sizeof(fail) > 1 ? " they" : fail[0]->query_pronoun()) +
          " couldn't reply anyway.\n");
    obs -= fail;
    if (!sizeof(obs)) {
      return 1;
    }
  }
  fail = this_player()->query_ignored_by(obs);
  if (sizeof(fail)) {
    if (!this_player()->query_creator()) {
      write("You are currently being ignored by " +
            query_multiple_short(fail, 0, 1, 0, 0) + ", so "
            "you cannot tell them anything.\n");
      obs -= fail;
      if (!sizeof(obs)) {
        return 1;
      }
    } else {
      write("Warning!  " + query_multiple_short(fail, 0, 1, 0, 0) +
            " have you on ignore.\n");
    }
  }
  if (!TP->query_creator() && (TP->adjust_sp(-TELL_COST) < 0)) {
    return notify_fail(NO_POWER);
  }
  net_dead = ({ });
  multiple_earmuffed = ({ });
  earmuffed = ({ });
  ok = ({ });
  roleplaying = ({ });
  cannot_see = ({ });
  if (sizeof(obs) > 1 && this_player()->check_earmuffs("multiple-tell")) {
    add_failed_mess("You cannot do a multiple-tell if you have them "
                    "earmuffed yourself.\n");
    return 0;
  }
  foreach(thing in obs) {
    if (sizeof(obs) > 1 && thing->check_earmuffs("multiple-tell")) {
      multiple_earmuffed += ({ thing });
    } else if (thing->check_earmuffs("tell")) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        write("You cut through the ear muffs of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your ear muffs.\n");
        ok += ({ thing });
      } else {
        earmuffed += ({ thing });
      }
    } else if(thing->query_role_playing()) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        write("You cut through the roleplaying mode of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your roleplaying mode.\n");
        ok += ({ thing });
      } else {
        roleplaying += ({ thing });
      }
    } else if (!this_player()->query_invis() ||
               reference_allowed(this_player(), thing)) {
      ok += ({ thing });
    } else {
      cannot_see += ({ thing });
      ok += ({ thing });
    }
  }
  ok_string = map(ok, (: $1->query_name() :)) +
    ({ this_player()->query_name() });
  switch (mess->type) {
  case "exclaim":
    extra = " to";
    break;
  default:
    extra = "";
    break;
  }
  foreach(thing in ok) {
    them_mess = query_multiple_short(map(ok- ({ thing }),
                                         (: $1->short(0, 0) :)) +
                                     ({ "you"  }), 0, 1, 0, 0);
    if ( interactive( this_player() ) ) {
      thing->event_person_tell(TP, capitalize((string) TP->short(0, 0)) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    else {
      thing->event_person_tell(TP, capitalize( TP->the_short()) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    prop = thing->query_tell_reply_list();
    if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
      if (member_array(TP->query_name(), prop) != -1) {
        thing->set_tell_reply_list(prop);
      }
    } else {
      thing->set_tell_reply_list(ok_string);
    }
    if (!interactive(thing) && userp(thing)) {
      net_dead += ({ thing });
    }
  }
  if (!silent) {
    if (sizeof(net_dead)) {
      write("Warning: " +
            query_multiple_short(map(net_dead, (: $1->query_cap_name() :)), 0,
                                 1, 0, 0) + " " +
            (sizeof(net_dead) > 1 ? "are" : "is") + " net dead.\n");
    }
    if (sizeof(multiple_earmuffed)) {
      write(capitalize(query_multiple_short(multiple_earmuffed, 0, 1, 0, 0)) +
            (sizeof(multiple_earmuffed) > 1 ? " have " : " has ") +
            "multiple tells ear muffed.\n");
    }
    if (sizeof(earmuffed)) {
      write(capitalize(query_multiple_short(earmuffed, 0, 1, 0, 0)) +
            (sizeof(earmuffed) > 1 ? " have " : " has ") +
            "tells ear muffed.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    if (sizeof(roleplaying)) {
      write(capitalize(query_multiple_short(roleplaying, 0, 1, 0, 0)) +
            (sizeof(roleplaying) > 1 ? " are " : " is ") +
            "role playing.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    busy = this_player()->query_busy();
    if (busy == 1) {
      write("Warning! You have your busy flag on.\n");
    } else if (pointerp(busy) && sizeof(ok - busy)) {
      write("Warning! You are currently set as busy with " +
            query_multiple_short(busy, 0, 1, 0, 0) + ".\n");
    }
    if (sizeof(cannot_see)) {
      write("Warning! " + query_multiple_short(cannot_see, 0, 1, 0, 0) +
            " cannot see you and will not be able to respond.\n");
    }
    if (sizeof(ok)) {
      them_mess =
        TP->convert_message(query_multiple_short(map(ok, (:
$1->short(0,0) :)), 0, 1, 1, 0));
      my_mess("You " + mess->emote + mess->type + extra + " " +
              them_mess + ": ", mess->text);
      TP->add_tell_history("You " + mess->emote + mess->type + extra +
                           " " + them_mess + ": ", mess->text);
    } else if (TP->query_creator() && !sizeof(earmuffed)) {
      add_failed_mess("It seems no one was listening.\n");
      return -1;
    }
  }
  TP->adjust_time_left(-5);
  return 1;
}
int reply_cmd(string mess) {
  string *rep;
  object *obs;
  rep = this_player()->query_tell_reply_list();
  if (!rep) {
    add_failed_mess
      ("No one has told you anything in the last 15 minutes.\n");
    return 0;
  }
  obs = map(rep, (: find_living($1) :)) - ({ 0 });
  if (!sizeof(obs)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are currenttly online.\n");
    return 0;
  }
  this_player()->set_tell_reply_list(rep);
  return cmd(mess, obs, 0);
}
int replylock_cmd(string names) {
  string *rest;
  string *rep;
  rep = uniq_array(explode(names, ","));
  rep = map(rep, (: this_player()->expand_nickname($1) :));
  rest = filter(rep, (: $1 && find_player($1) && interactive(find_player($1)) :));
  if(!sizeof(rest)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are logged in.  You cannot lock onto someone who is "
                    "not here.\n");
    return 0;
  }
  this_player()->set_tell_reply_list(({ TELL_REPLY_LOCK_ID }) + rest);
  add_succeeded_mess(({ "You lock in " +
                          query_multiple_short(rest, 0, 1, 0, 0) +
                          " in your reply list.\n", "" }));
  return 1;
}
int replylockremove_cmd() {
  this_player()->set_tell_reply_list(0);
  add_succeeded_mess(({ "You remove any possible reply locks.\n", "" }));
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player> <string'message'>",
              (: cmd($4[1], $1, 0) :),
              "reply <string'message'>", (: reply_cmd($4[0]) :),
              "replylock <string'names'>", (: replylock_cmd($4[0]) :),
              "replylock remove", (: replylockremove_cmd() :),
              "<string>", (: cmd($4[0], 0, 0) :) });
}
void delayed_tell(string yesno,
                  object * recicipients,
                  string message) {
  object ob,
    *netdead;
  int disappeared;
  if (!(yesno == "yes" || yesno == "y")) {
    write("Ok, tell aborted.\n");
    return;
  }
  netdead = ({ });
  foreach(ob in recicipients) {
    if (!ob) {
      disappeared++;
      recicipients -= ({ ob });
    } else {
      if (!interactive(ob))
        netdead += ({ ob });
      message = replace(message, "%^", " ");
      ob->event_person_tell(TP, capitalize(TP->query_name()) +
                            " cuts through your ear muffs and tells "
                            + query_multiple_short(recicipients -
                                                   ({ ob }) + ({ "you" }), 0,
                                                   1, 0, 0) + ": ", message);
    }
  }
  if (sizeof(netdead))
    write("Warning: " + query_multiple_short(netdead, 0, 1, 0, 0) +
          (sizeof(netdead) > 1 ? " is" : " are") + " net dead.\n");
  if (disappeared)
    write("It seems " + disappeared + " person" +
          (disappeared > 1 ? "s have" : " has")
          + " disappeared.\n");
  if (!sizeof(recicipients)) {
    write("No one wanted to stay around long enough "
          "to hear what you had to say.\n");
    return;
  }
  my_mess("You tell " +
          TP->convert_message(query_multiple_short(recicipients, 0, 1, 0, 0))
          + ": ", message);
  TP->add_tell_history("You cut through earmuffs and tell " +
                       TP->convert_message(capitalize(
                       query_multiple_short(recicipients, 0, 1, 0, 0))) +
                       ": ", message);
  return;
}

==================================================
FILE: player/temp_erature.c
==================================================

#include <weather.h>
#include <clothing.h>
#include <playtesters.h>
#define COMFORTABLE 20
#define ABS(x) (x > 0? x : -x)
string disp_warmth(int, int);
string disp_total(int i);
int cmd(string str) {
  object where, *clothes, item;
  string zone, type, *zones, tmp;
  mixed types;
  int adjustment, correction, temperature, room_temp, *enums, cwarm, ccool;
  where = environment(this_player());
  if(!where)
    return notify_fail("You have no environment.\n");
  if(!where->query_property("location") &&
     environment(where) &&
     environment(where)->query_property("location")) {
    where = environment(where);
  }
  switch(where->query_property("location")) {
  case "outside":
    room_temp = (WEATHER->query_temperature(where) - COMFORTABLE);
    break;
  default:
    room_temp = 0;
  }
  temperature = this_player()->query_personal_temp();
  room_temp += where->query_property("warmth");
  room_temp -= where->query_property("cooling");
  write(sprintf("It's %s here.\n",
         WEATHER->temp_string(room_temp + COMFORTABLE)));
  clothes = filter_array(this_player()->query_wearing(),
                         (: !$1->id("scabbard") &&
                          !$1->id("belt") &&
                          !$1->id("backpack") &&
                          !$1->id("glasses") &&
                          !$1->id("jewellery") :));
  zones = ({ });
  foreach(item in clothes) {
    types = item->query_type();
    if(!arrayp(types)) {
      types = ({ item->query_type() });
    }
    ccool = 0;
    cwarm = 0;
    foreach(type in types) {
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth")) {
          adjustment += item->query_property("warmth");
          cwarm += item->query_property("warmth");
        } else {
          adjustment++;
          cwarm++;
        }
        if(room_temp > 0 && item->query_property("cooling")) {
          adjustment -= item->query_property("cooling");
          ccool += item->query_property("cooling");
        }
      }
    }
    tmp = item->query_name();
    if(cwarm && ccool) {
      write(sprintf("Your %s provide%s %s and %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1),
             disp_warmth(ccool, 0)));
    } else if(cwarm) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1)));
    } else if(ccool) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(ccool, 0)));
    }
  }
  if(room_temp < 0) {
    adjustment += sizeof(zones);
    if(room_temp + sizeof(zones) > 5)
      adjustment -= (room_temp + sizeof(zones) - 5);
  } else {
    adjustment -= sizeof(zones);
    if(room_temp - sizeof(zones) < -5)
      adjustment -= (room_temp - sizeof(zones) + 5);
  }
  ccool = 0;
  enums = (int *)this_player()->effects_matching("body.wetness");
  if ( sizeof( enums ) ) {
    adjustment -= sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
    ccool = sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
  }
  adjustment += this_player()->query_property("warmth");
  adjustment -= this_player()->query_property("cooling");
  if(temperature > room_temp && room_temp >= 0 || temperature > 5)
    correction -= (temperature / 5) + 5;
  if(temperature < room_temp && room_temp <= 0 || temperature < -5)
    correction -= (temperature / 5) - 5;
  write(sprintf("On balance, you are %s and %s.\n",
         this_player()->query_temp_str(),
         disp_total(to_int((room_temp+adjustment + correction)))));
  return 1;
}
string disp_warmth(int i, int warm) {
  string pos, neg;
  if(warm) {
    pos = " warmth";
    neg = " cooling";
  } else {
    pos = " cooling";
    neg = " warmth";
  }
  switch(i) {
  case -1000..-19: return "an enormous amount of"+neg;
  case -9..-18: return "a lot of"+neg;
  case -8..-4: return "quite a lot of"+neg;
  case -3..-2: return "some"+neg;
  case -1: return "a bit of"+neg;
  case 0: return "no"+pos;
  case 1: return "a bit of"+pos;
  case 2..3: return "some"+pos;
  case 4..8: return "quite a lot of"+pos;
  case 9..18: return "a lot of"+pos;
  default: return "an enormous amount of"+pos;
  }
}
string disp_total(int i) {
  switch(i) {
  case -1000..-51: return "are freezing fast";
  case -50..-21: return "are cooling down quickly";
  case -20..-11: return "are cooling down";
  case -10..-6: return "are cooling down slowly";
  case -5..5: return "will stay pretty much as you are";
  case 6..10: return "are warming up slowly";
  case 11..20: return "are warming up";
  case 21..50: return "are warming up quickly";
  case 51..1000: return "are cooking rapidly";
  default:
    return "broken: " + i + "\n";
  }
}
mixed *query_patterns()  {
   return ({ "", (: cmd("") :) });
}

==================================================
FILE: player/time.c
==================================================

#include <localtime.h>
#include <dst.h>
#include <am_time.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
#include <config.h>
inherit "/cmds/base";
mixed *_timezones;
void show_mud_time();
void create() {
   mixed *time_rubbish;
   time_rubbish = localtime(time());
   _timezones = ({
      "Seattle", - time_rubbish[LT_GMTOFF] + (US_DST * 60 * 60),
      "Toronto", - time_rubbish[LT_GMTOFF] + (3 + CA_DST) * (60 * 60),
     "London", (UK_DST * 60 * 60),
      "Sydney", (10 + AUS_DST) * (60 * 60),
                 });
}
mixed cmd( string word ) {
   mixed *time_rubbish;
   int i;
   string mess;
   time_rubbish = localtime(time());
   mess = "";
   for (i = 0; i < sizeof(_timezones); i += 2) {
      mess += sprintf( "[%s in %-9s]\n", ctime(time() + time_rubbish[LT_GMTOFF] +
                                    _timezones[i + 1]), _timezones[i]);
   }
   if ( this_player()->query_creator() )
      show_mud_time();
   write(mess);
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd :) });
}
void show_mud_time() {
#ifndef __DISTRIBUTION_LIB__
   string mess;
   string day = cap_words(SPECIAL_DAY_HANDLER->query_special_day());
   mess = sprintf( "In Ankh-Morpork, it is %s%s\n", amtime( time() ),
           ( strlen(day) ? ".  Today is "+ day +".": ".") );
   write( mess );
#endif
}

==================================================
FILE: player/title.c
==================================================

inherit "/cmds/base";
#include <player.h>
mixed cmd_list() {
   string* titles;
   if (this_player()->query_player_title()) {
      write("Your player title is currently set to: " +
            this_player()->query_player_title() + ".\n");
   } else {
      write("Your player title is currently not set.\n");
   }
   titles = this_player()->query_all_player_titles();
   write("You can set your player title to one of " +
         query_multiple_short(map(titles, (: capitalize($1) :))) + ".\n");
   return 1;
}
int cmd_set(string title) {
    mixed mess;
   title = lower_case(title);
   if (strlen(title) > 20) {
      add_failed_mess("Your title is too long.\n");
   }
   if (member_array(title,
                    this_player()->query_all_player_titles()) == -1) {
      add_failed_mess("The title '" + title + "' is not valid.\n");
      return 0;
   }
   if (this_player()->query_player_title() &&
       lower_case(this_player()->query_player_title()) == title) {
      add_failed_mess("You already have your player title set to '" + title +
                      "'.\n");
      return 0;
   }
   this_player()->set_player_title(title);
   if ( sizeof( this_player()->query_hide_invis() ) ) {
       mess = ({ "$N set$s $p player title to " + capitalize(title) +
           ".\n", "" });
   }
   else {
       mess = "$N set$s $p player title to " + capitalize(title) +  ".\n";
   }
   add_succeeded_mess(mess);
   return 1;
}
int cmd_reset() {
   if (!this_player()->query_player_title()) {
      add_failed_mess("Your player title is already unset.\n");
      return 0;
   }
   this_player()->set_player_title(0);
   add_succeeded_mess("$N reset$s $p player title.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "<string'title'>", (: cmd_set($4[0]) :),
             "none", (: cmd_reset() :) });
}

==================================================
FILE: player/tu_rn.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  int i;
  mixed * facing;
  if ( !( i = ([ "half right": 1, "right": 2, "rt": 2, "around": 4, "left": 6,
      "lt": 6, "half left": 7 ])[ str ] ) ) {
    return 0;
  }
  facing = TP->query_facing();
  facing[ 0 ] = ( i + facing[ 0 ] ) % 8;
  write( "You reorient yourself with the world.\n" );
  if(TP->query_sneak_level())
    say( TP->one_short(1)+" reorients "+ TP->query_objective() +"self.\n");
  else
    say(TP->one_short() +" reorients "+ TP->query_objective() +"self.\n" );
  TP->set_facing(facing);
  if ( environment(TP) )
    environment(TP)->init();
  return 1;
}
mixed *query_patterns()  {
    return ({ "<string'around, [half] right, [half] left, rt, lt'>",
              (: cmd($4[0]) :) });
}

==================================================
FILE: player/typo.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("TYPO");
   set_use_last_error(0);
}

==================================================
FILE: player/un_alias.c
==================================================

inherit "/cmds/base";
varargs int unalias(string str, object who ) {
    if (!who) who = this_player();
   if (!who->is_alias(str)) {
      add_failed_mess("The alias '" + str +
                      "' does not exist, cannot unalias.\n");
      return 0;
   }
   if (who->remove_player_alias(str)) {
      write("Successfully unaliased '" + str + "'.\n");
      return 1;
   } else {
      add_failed_mess("Unable to unalias '" + str + "'.\n");
      return 0;
   }
}
varargs int unalias_pattern(string filter) {
   mapping aliases;
   string* tmp;
   string* ok;
   string gfilter;
   string bing;
   aliases = this_player()->query_aliases();
   tmp = m_indices(aliases);
   if (regexp(filter,
        "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
      add_failed_mess("Bad pattern to alias.\n");
      return 0;
   }
   if (filter[0] == '*' || filter[0] == '+') {
      add_failed_mess("Cannot start a regular expression with a '*' or '+', "                         "try: '.*' or '.+'.\n");
      return 0;
   }
   gfilter = "^" + filter;
   tmp = filter_array(tmp, (: $1 && regexp($1, $(gfilter)) :));
   ok = ({ });
   foreach (bing in tmp) {
      if (this_player()->remove_player_alias(bing)) {
         ok += ({ bing });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("Successfuly removed the aliases " +
            query_multiple_short(map(ok, (: "'" + $1 + "'" :))) + ".\n");
      return 1;
   }
   add_failed_mess("Unable to remove any of the aliases " +
            query_multiple_short(map(tmp, (: "'" + $1 + "'" :))) + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({
      "pattern <word'alias'>", (: unalias_pattern($4[0]) :),
      "<word'alias'>", (: unalias($4[0]) :),
         });
}

==================================================
FILE: player/unidentify.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
mixed cmd(object *indirect_obs)
{
   object *things;
   things = filter(indirect_obs, (: $1->query_identifier() :));
   if (!sizeof(things))  {
      if (sizeof(indirect_obs) > 1)
         write("You do not have any of those things identified.\n");
      else
         write("You do not have " + indirect_obs[0]->the_short() +
               " identified.\n");
   }
   else  {
      things->set_identifier(0);
      write("You stop identifying " + query_multiple_short(things, "one") +
            ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me'object(s)'>", (: cmd($1) :) });
}

==================================================
FILE: player/unignore.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#define TP this_player()
inherit "/cmds/base";
int cmd(string str) {
  string *ignoring;
  ignoring = TP->query_property("ignoring");
  if(!ignoring)
    ignoring = ({ });
  if(!str)
    return notify_fail("unignore who?\n");
  str = lower_case(TP->expand_nickname(str));
  if(str == "all") {
    TP->remove_property("ignoring");
    write("You are no longer ignoring anyone.\n");
    return 1;
  }
  if(member_array(str, ignoring) == -1) {
    write("You are not ignoring "+str+".\n");
    return 1;
  }
  ignoring = delete(ignoring, member_array(str, ignoring), 1);
  TP->add_property("ignoring", ignoring);
  write(str+" has been removed from your list of ignored players.\n");
  return 1;
}

==================================================
FILE: player/unkeep.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
int cmd( object *obs ) {
   object thing, *success;
   success = ({ });
   foreach (thing in obs)  {
      if (thing->query_keep())  {
         thing->reset_keep();
         success += ({ thing });
      }
   }
   if (!sizeof(success))  {
      write("You are not attempting to keep anything.\n");
   }
   else  {
      write("You will no longer attempt to keep " +
            query_multiple_short(success) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

==================================================
FILE: player/upt_ime.c
==================================================

#include <player.h>
inherit "/cmds/base";
mixed cmd(int brief) {
  mapping u;
  int r;
  string str;
  string output;
  str = "/secure/finger"->time_elapsed_string(uptime());
#ifndef __DISTRIBUTION_LIB__
  output = "A'Tuin has been paddling through space for "+
      str + ".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
  output += "  He (or as it may be, she) has been "
      "performing "+ query_load_average()+".";
#else
  output += mud_name() + " has been up for "+ str +
      ".  The load average is " +
      query_load_average()+".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
#endif
  u = rusage();
#ifndef __DISTRIBUTION_LIB__
  output += sprintf("  This has taken %.2f%% of his (or her) energy and %.2fMB "
                    "of his (or her) mental capacity.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#else
  output += sprintf("  This has taken %.2f%% of the cpu and %.2fMB of "
                    "of memory.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#endif
#ifndef __DISTRIBUTION_LIB__
  r = "/obj/handlers/garbage"->query_next_reboot();
  if (r == -1) {
    output += "It is unknown when he (or she) will be "
      "taking his (or her) next rest.";
  } else if (r < 0 || find_object(OFFLER)) {
    output += "He (or she) will be taking his (or her) next rest "
      "any moment now.";
  } else {
    str = "";
    if(r / (60*60*24)) {
      str += (string) (r / (60*60*24)) + " day";
      str += ((r /(60*60*24)) > 1 ? "s" : "");
    }
    if(r / ((60*60)) % 24) {
      if(str != "") {
        str += " and ";
      }
      str += (string)((r/(60*60))%24);
      str += " hour" + (((r/(60*60))%24) > 1 ? "s" : "");
    } else if(str == "") {
      switch(r/ 60) {
      case 0..7:
        str = "less than 15 minutes";
        break;
      case 8..22:
        str = "about a quarter of an hour";
        break;
      case 23..38:
        str = "about half an hour";
        break;
      case 39..53:
        str = "about three quarters of an hour";
        break;
      default:
        str = "just under an hour";
        break;
      }
    }
    output += "He (or she) will be taking his (or her) next rest "
      "in " + str + ".";
  }
#endif
  write(sprintf("%-=*s\n",
                  (int)this_player()->query_cols(), output));
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd(0) :),
             "{brief|verbose}", (: cmd($4[0] == "brief") :) });
}

==================================================
FILE: player/users.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>
int cmd() {
  int players, logins, login_q, first, creators, total;
  string output, *str, *logins_n;
  object pl;
  str = ({ });
  foreach(pl in users()) {
    if (pl->query_login_ob())
      logins++;
    else {
      str += ({ pl->query_cap_name() });
      if (pl->query_creator())
        creators++;
      else
        players++;
    }
  }
  logins_n = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
  logins_n = filter(logins_n, (: $1 :));
  logins_n = sort_array(logins_n,
                        (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (login_q > 0) {
    first = 0;
    if (login_q > 1)
      write(sprintf(login_q+" currently queued: %-=*s\n",
                    this_player()->query_cols()-17,
                    implode(logins_n[0..<2], ", ")+" and "+
                    logins_n[<1]));
    else
      write(sprintf("Currently Queued: %-=*s\n",
                    this_player()->query_cols()-19,
                    logins_n[0]));
  }
  output = "There ";
  first = 1;
  if (creators > 0) {
    if (first)
      if (creators == 1)
        output += "is ";
      else
        output += "are ";
    if (creators == 1)
      output += "one creator";
    else
      output += creators +" creators";
    first = 0;
    if (logins - login_q > 0)
      output += ", ";
    else
      if ( !players )
        output += " logged on.\n";
      else
        output += " and ";
  }
  if (logins - login_q > 0) {
    if (first)
      if (logins - login_q == 1)
        output += "is ";
      else
        output += "are ";
    if (logins - login_q == 1)
      output += "one person logging in";
    else
      output += ( logins - login_q ) +" people logging in";
    first = 0;
    if ( !players )
      output += ".\n";
    else
      output += " and ";
  }
  if ( players ) {
    if (first)
      if (players == 1)
        output += "is ";
      else
        output += "are ";
    if (players == 1)
      output += "one player ";
    else
      output += players +" players ";
  }
  total = sizeof(users());
  output += "a total of "+ sizeof(users()) + " people logged on.\n";
  write( output );
  str = filter(str, (: $1 :));
  str = sort_array(str, (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (sizeof(str) > 1) {
    this_player()->more_string(sprintf("Currently logged on: %-=*s\n",
                  this_player()->query_cols()-24,
                  implode(str[0..<2], ", ")+" and "+
                  str[<1]), "Who", 1 );
  } else {
    write("Currently logged on: "+str[0]+".\n");
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/verbose.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(string which, string type) {
  string t, disp;
  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types()) {
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    }
    write(disp + "\n");
    return 1;
  }
  if(type == "all") {
    foreach(t in TP->query_verbose_types()) {
      TP->set_verbose(t, which == "verbose");
    }
    write("Ok\n");
    return 1;
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
    return 1;
  } else {
    write("No such option.\n");
    return 1;
  }
}
mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("verbose", $4[0]) :),
            "", (: cmd("verbose", 0) :),
         });
}

==================================================
FILE: player/weigh.c
==================================================

#define MAX_OBJECTS_AT_ONCE   5
string weight_string(int number);
int cmd(object *things, int brief);
string weight_string(int number) {
   number = (number + 4) / 9;
   switch (number) {
      case 0:
         return "uh oh";
      case 1:
         return "half a pound";
      case 2:
         return "a pound";
      case 3:
         return "a pound and a half";
      case 4 .. 14 :
         return query_num((number + 1) / 2) + " pounds";
      case 15 .. 24:
         return "ten pounds";
      case 25 .. 34:
         return "fifteen pounds";
      case 35 .. 149:
         return query_num(((number + 10) / 20) * 10) + " pounds";
      case 150 .. 249:
         return "a hundred pounds";
      case 250 .. 349:
         return "a hundred and fifty pounds";
      case 350 .. 1499:
         return query_num(((number + 100) / 200) * 100) + " pounds";
      case 1500 .. 2499:
         return "a thousand pounds";
      case 2500 .. 2499:
         return "fifteen hundred pounds";
      case 3500 .. 14999:
         return query_num(((number + 1000) / 2000) * 1000) + " pounds";
      case 15000 .. 24999:
         return "ten thousand pounds";
      case 25000 .. 34999:
         return "fifteen thousand pounds";
      default:
         return query_num(((number + 10000) / 20000) * 10000) + " pounds";
   }
}
int cmd(object *things, int brief) {
   int     accuracy;
   int     weight;
   int     total = 0;
   string  results;
   object  thing;
   object *worn;
   object *wearing;
   if (sizeof(things) > MAX_OBJECTS_AT_ONCE)
   {
      return notify_fail("You cannot weigh that many things at once.\n");
   }
   accuracy = 9 + 89 / (1 + this_player()->query_dex());
   results = "";
   wearing = this_player()->query_wearing();
   worn = filter(things, (: member_array($1, $(wearing)) > -1 :));
   things -= worn;
   if (brief)  {
      foreach (thing in things)
         total += thing->query_complete_weight();
   }
   else foreach (thing in things)  {
      results += "You heft " + thing->the_short() +
                 " and guess that " +
        (thing->group_object() ? "they weigh " :
         thing->query_pronoun() + " weighs ");
      weight = thing->query_complete_weight();
      total += weight;
      if (4 * weight > accuracy)  {
         weight = (4 * weight + accuracy) / (2 * accuracy);
         results += "about " + weight_string(weight * accuracy) + ".\n";
      }
      else  {
         results += "less than " + weight_string(accuracy)+ ".\n";
      }
   }
   if (sizeof(worn))  {
      write("You are wearing " + query_multiple_short(worn, "the") +
             ".\n");
   }
   if (sizeof(things))  {
      if (!brief)  {
         write(results);
      }
      if (sizeof(things) > 1  ||  brief)  {
         if (4 * total > accuracy)  {
             total = (4 * total + accuracy) / (2 * accuracy);
             printf("The total weight is about " +
                    weight_string(total * accuracy) + ".\n");
         }
         else  {
             printf("The total weight is less than " +
                    weight_string(accuracy) + ".\n");
         }
      }
      tell_room(environment(this_player()),
                this_player()->one_short() + " hefts " +
                query_multiple_short(things) + (sizeof(things) > 1 ?
                " one at a time to see how much they weigh" :
                " to see how much it weighs" ) + ".\n",
                ({ this_player() }));
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me'item(s)'>", (: cmd($1, 0) :),
             "<indirect:object:me'item(s)'> brief", (: cmd($1, 1) :) });
}

==================================================
FILE: player/wet.c
==================================================

inherit "/cmds/base";
#include <dirs.h>
#define THRESHOLDS ({ 10, 30, 200, 300 })
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define BODY_WET_EFFECT "/std/effects/other/wetness"
mixed cmd(object *things) {
   string results;
   string no_wet_results;
   object thing;
   object* not_wet;
   string wet_mess;
   if (!things) {
      things = all_inventory(this_player()) + ({ this_player() });
   }
   results = "";
   not_wet = ({ });
   no_wet_results = "";
   foreach (thing in things) {
      wet_mess = OBJECT_WET_EFFECT->wet_string(thing);
      if (strlen(wet_mess)) {
         if (thing == this_player()) {
            wet_mess = "are " + wet_mess;
         } else {
            wet_mess = "is " + wet_mess;
         }
      } else {
         wet_mess = BODY_WET_EFFECT->wet_string(thing, thing == this_player());
      }
      if (strlen(wet_mess)) {
         results += "$C$" + thing->the_short(1) + " " + wet_mess + ".\n";
      } else {
         not_wet += ({ thing });
      }
   }
   if (results == "") {
      write(query_multiple_short(not_wet) +
            ((sizeof(not_wet) > 1  ||  not_wet[0] == this_player()) ?
               " are ":" is ") + "not wet.\n");
   } else {
      write(results);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/when.c
==================================================

#include <login.h>
inherit "/cmds/base";
int cmd(string who)   {
   object player;
   int last;
   int caller;
   string* bits;
   string womble;
   int bing;
   bits = explode(who, ",");
   if (sizeof(bits) > 1) {
      bing = 0;
      foreach (womble in bits) {
         if (cmd(womble)) {
            bing = 1;
         }
      }
      return bing;
   }
   caller = this_player()->query_invis();
   who = this_player()->expand_nickname(lower_case(who));
   player = find_player( who );
   if (player &&
       (caller >= player->query_invis() ||
        reference_allowed(player, this_player()))) {
      if ( interactive( player ) ) {
         write( who + " has been on for " +
                   query_time_string(time() - player->query_last_log_on(), -1) +
                   ".\n");
      } else {
         write( who + " is currently net-dead.\n" );
      }
      return 1;
   } else {
      last = PLAYER_HANDLER->test_last(who);
      if ( last < 1 ) {
         return notify_fail( "Cannot find any record of $C$" + who + ".\n" );
      } else   {
         if (time() - last < 30) {
            write(who + " only just logged off.\n");
         } else {
            write(who + " last logged off " +
                  query_time_string(time() - last, -1) +
                  " ago.\n");
         }
         return 1;
      }
   }
}
mixed *query_patterns()   {
   return ({ "<string'player name'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/who.c
==================================================

#include <clubs.h>
#include <playtesters.h>
#include <config.h>
inherit "/cmds/base";
#include <player.h>
string who_string(int width, int cre, int verbose, string name);
string who_line(object ob, int cre, int width);
mapping _nationalities;
void create() {
  string file;
  object ob;
  ::create();
  _nationalities = ([ ]);
  foreach(file in get_dir("/std/nationality
object *filter_users(object *tarr, string name, int no_cres)  {
  string *guilds;
  string guild;
  string start_guild;
  string *domains;
  object *ret_arr;
  object *arr;
  int not_tag;
  name = lower_case(name);
  name = replace(name, ({"assassins", "assassin",
                           "priests", "priest",
                           "thieves",   "thief",
                           "warriors",    "warrior",
                           "witches",   "witch",
                           "wizards",     "wizard",
                           "creators",  "creator",
                           "liaisons", "liaison",
                           "adventurers", "adventurer",
                           "fighters", "warrior",
                           "fighter", "warrior",
                           "killers", "killer",
                           "helpers", "helper",
                           "playtesters", "playtester",
                           "friends", "friend",
                           "families", "family" }));
  guilds = explode(name, "&") - ({ "" });
  if (sizeof(guilds) > 1) {
    arr = filter_users(tarr, guilds[0], no_cres);
    foreach (guild in guilds[1..]) {
      arr &= filter_users(tarr, guild, no_cres);
    }
    return arr;
  }
  guilds = explode(name, ",") - ({ "", 0 });
  domains = "/secure/master"->query_domains();
  ret_arr = ({ });
  foreach (guild in guilds)  {
    start_guild = guild;
    guild = replace(guild, " ", "", "\t", "");
    if (guild[0] == '-') {
       not_tag = 1;
       guild = guild[1..];
    } else {
       not_tag = 0;
    }
    arr = ({ });
    if (guild == "adventurer")  {
      arr += filter(tarr, (: !$1->query_guild_ob()  &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "friend")  {
      arr += filter(tarr, (: !$1->query_login_ob() && this_player()->is_friend($1->query_name()) :));
    } else if (guild == "creator")  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           $1->query_visible(this_player()) :) );
    } else if (guild == "helper") {
      arr += filter( tarr, (: !$1->query_creator() &&
                            $1->query_property( "newbie helper" ) :) );
    } else if (guild == "killer") {
      arr += filter(tarr, (: $1->query_player_killer() &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "family") {
      arr += filter(tarr, (: $1->query_family_name() :));
    } else if (guild == "playtester") {
      arr += filter(tarr,
                    (: PLAYTESTER_HAND->query_playtester($1->query_name()) :));
    } else if (member_array(guild, domains) > -1)  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           ("/d/"+$(guild)+"/master")->query_member($1->query_name())  &&
                           $1->query_visible(this_player()) :));
    } else if(member_array(guild, keys(_nationalities)) > -1) {
      arr += filter(tarr, (: $1->query_nationality() == $2 :),
                    _nationalities[guild]);
    } else  {
      if (file_size("/std/guilds/" + guild + ".c") > 0)  {
        arr += filter(tarr,
                      (: (!$(no_cres) || !$1->query_creator()) &&
                       stringp($1->query_guild_ob()) &&
                       $1->query_guild_ob() == "/std/guilds/" + $(guild) :));
      } else if (CLUB_HANDLER->is_family(start_guild)) {
        arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1) :));
      } else if (CLUB_HANDLER->is_club(start_guild)) {
        if (!CLUB_HANDLER->query_club_secret(start_guild) ||
            CLUB_HANDLER->is_member_of(start_guild, this_player()->query_name())) {
          arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1->query_name()) :));
        }
      } else {
        arr += filter(tarr, (: $1->query_deity() == $2 &&
                             (!$(no_cres) || !$1->query_creator()) :),
                      guild);
      }
    }
    if (not_tag) {
       ret_arr |= (tarr - arr);
    } else {
       ret_arr |= arr;
    }
  }
  return ret_arr;
}
int cmd(string str, int verbose)  {
  this_player()->more_string( who_string(this_player()->query_cols(),
                                         this_player()->query_creator(),
                                         verbose,
                                         str),
                              "Who", 1 );
  return 1;
}
string who_string(int width, int cre, int verbose, string name) {
  object *arr;
  int number;
  string tmp;
  string tmp2;
  string prt;
  int x;
  if (name == "here") {
    arr = filter(all_inventory(environment(this_player())), (: userp($1) &&
                                                             $1->query_visible(this_player()) :) );
  } else {
    arr = filter(users(), (: strsrch(file_name($1), "secure/login") == -1 :));
    if (name && sizeof(arr))  {
      arr = filter_users(arr, name, 1);
    }
  }
  number = sizeof(arr);
  if (number == 0)  {
    if (name)  {
      return "There are no guild(s) or members of " + name + " online.\n";
    }
    return "There is no one on " + mud_name() + "?\n";
  }
  prt = sprintf("%|*'-'s\n", width-1, "==========]  " + mud_name() + "  [===========");
  arr = sort_array(arr, (: strcmp($1->query_name(), $2->query_name() ) :) );
  tmp2 = "";
  if(!name && verbose == 0) {
    int i;
#ifndef __DISTRIBUTION_LIB__
    arr = filter_array(arr, (: !$1->query_creator() ||
                             "/d/liaison/master"->query_member($1->query_name()) :) );
#endif
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = (string)arr[i]->query_cap_name();
      if(!tmp) {
        --number;
      } else {
        x = 14;
        if (arr[i]->query_creator()) {
          if ("/secure/master"->query_trustee(arr[i]->query_name())) {
            tmp += " (%^RED%^T";
          } else if("/secure/master"->query_director(arr[i]->query_name())){
            tmp += " (%^RED%^D";
          } else if("/secure/master"->query_senior(arr[i]->query_name())){
            tmp += " (%^RED%^S";
          } else  {
            tmp += " (%^RED%^C";
          }
          x += 16;
          if ( "/d/liaison/master"->query_member(arr[i]->query_name())) {
            tmp += "%^YELLOW%^l";
            x += 10;
          }
          if(this_player()->is_friend(arr[i]->query_name())) {
            tmp += "%^GREEN%^F";
            x += 9;
          }
          tmp += "%^RESET%^)";
        } else if(this_player()->is_friend(arr[i]->query_name())) {
          tmp += " (%^GREEN%^F%^RESET%^)";
          x += 18;
        }
        tmp2 += sprintf("%-" + x + "s ", tmp);
        if((i+1) % (width/15) == 0  && tmp2 != "") {
          prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
          tmp2 = "";
        }
      }
    }
    prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
  } else {
    int i;
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = who_line(arr[i], cre, width);
      if ( !tmp )  {
        --number;
      } else  {
        prt += this_player()->fix_string(tmp + "\n", width, 10);
      }
    }
  }
  if ( name == "here" )  {
    if (number == 1)
      tmp = "> You are all by yourself. <";
    else
      tmp = "> There are " + query_num(number, 500) + " people here. <";
  } else if ( name )  {
    tmp = "> There " + (number > 1 ? "are " : "is ") +
      query_num(number, 500) +
      (number > 1 ? " members of" : " member of");
    if (strsrch(name, ",") != -1) {
      tmp += " those guilds on the " + mud_name() + ". <";
    } else {
      tmp += " this guild on the " + mud_name() + ". <";
    }
  } else if (number < 2)  {
    tmp = "> You are all alone on the " + mud_name() + ". <";
  } else  {
    tmp = "> There are " + query_num(number, 500) +
      " mudders on the " + mud_name() + ". <";
  }
  prt += sprintf("%*'-'|s\n", width-1, tmp);
  return prt;
}
string who_line(object ob, int cre, int width)  {
  string s;
  string tmp;
  tmp = ob->query_player_title();
  if (tmp) {
    tmp += " ";
  } else {
    tmp = "";
  }
  s = tmp + ob->query_cap_name();
  if ( !s )  {
    return 0;
  }
  tmp = ob->query_family_name();
  if (tmp) {
    s += " " + tmp;
  }
  if ( "/d/liaison/master"->query_member( (string)ob->query_name() ) )  {
    s += " (%^YELLOW%^Liaison%^RESET%^)";
  }
  if (ob->query_creator()) {
    if ("/secure/master"->query_trustee((string)ob->query_name()))  {
      s += " (%^RED%^Trustee%^RESET%^)";
    } else if("/secure/master"->query_director((string)ob->query_name())){
      s += " (%^RED%^Director%^RESET%^)";
    } else if("/secure/master"->query_senior((string)ob->query_name())) {
      s += " (%^RED%^Senior%^RESET%^)";
    } else  {
      s += " (%^RED%^Creator%^RESET%^)";
    }
    if (ob->query_invis() == 1) {
      s += " (Invisible)";
    } if (ob->query_invis() > 1) {
      s += " (Super Invisible)";
    }
  }
  if (cre)  {
    if ((tmp = (string)ob->query_in_editor()))  {
      s += " (editing: " + tmp + ")";
    }
  }
  if (ob->query_property("guest"))  {
    s += " guest of " + mud_name() + "";
  } else if (tmp = (string)ob->query_gtitle())  {
    s += " " + tmp;
  } else  {
    s += " the Adventurer";
  }
  if (tmp = (string)ob->query_property("player_title"))  {
    s += ", " + tmp;
  }
  tmp = (string)ob->query_title();
  if ( tmp && ( tmp != "" ) )  {
    s += ", " + tmp;
  }
  if ( PLAYTESTER_HAND->query_playtester( ob->query_name() ) ) {
    if ( PLAYTESTER_HAND->query_senior_playtester( ob->query_name() ) ) {
      s += ", (%^BOLD%^%^CYAN%^Senior Playtester%^RESET%^)";
    }
    else {
      s += ", (%^CYAN%^Playtester%^RESET%^)";
    }
  }
  if (interactive(ob))  {
    if (query_idle(ob) > 120)  {
      s += " (Idle: " + (query_idle(ob) / 60) + ")";
    }
  }
  return s + "%^RESET%^";
}
mixed *query_patterns() {
  return ({ "", (: cmd(0, 0) :),
              "verbose", (: cmd(0, 1) :),
              "here", (: cmd("here", 1) :),
              "<string'guild|liaisons|creators|killers|helpers|playtesters|friends|families|nationality'>", (: cmd( $4[0], 0 ) :) });
}

==================================================
FILE: player/whoami.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd() {
  write( "You are "+ (string)( DIR_PLAYER_CMDS +"/who" )->
         who_line(this_player(), this_player()->query_creator(),
                  this_player()->query_cols(), 1) +".\n" );
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/whois.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd(object *obs) {
  write("That is " + (string)(DIR_PLAYER_CMDS +"/who")->
        who_line(this_player()->expand_nickname(obs[0]),
                 this_player()->query_creator(),
                 this_player()->query_cols()) +".\n" );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1) :),
            this_player()->query_name(), (: cmd(({this_player()})) :) });
}
