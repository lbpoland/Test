# Total Tokens: 118477
# Total Files Merged: 63

=====
FILE: armour.c
==================================================

#include <move_failures.h>
#include <virtual.h>
#define AC_LIMIT 100
#undef INFORM
inherit "/std/object";
inherit "/std/basic/wearable";
inherit "/std/armour_logic";
void create() {
   do_setup++;
   object::create();
   armour_logic::create();
   wearable::create();
   add_alias( "armour" );
   add_plural( "armours" );
   add_help_file("armour");
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   do_setup--;
   if ( !do_setup )
      this_object()->setup();
}
int query_armour() { return 1; }
string long( string word, int dark ) {
   return object::long( word, dark ) + wearable::long( word, dark );
}
varargs int query_ac( string type, int amount, string zone ) {
   int a_class, tmp;
#ifdef INFORM
   string message;
#endif
   a_class = armour_logic::query_ac( type, amount, zone );
#ifdef INFORM
   message = query_short() +": striking " + zone + ", basic value "+ a_class;
#endif
   if ( a_class > AC_LIMIT )
      a_class = AC_LIMIT;
   a_class += ( a_class * query_enchant() ) / query_max_enchant() + query_enchant();
#ifdef INFORM
   message += "; after enchant "+ a_class;
   if ( objectp( worn_by ) )
      event( environment( worn_by ), "inform", message, "combat" );
#endif
   do_damage( type, amount );
   a_class = ( a_class * query_cond() ) / query_max_cond();
   switch(random(a_class)) {
   case 0:
     return 0;
   case 1:
     return a_class / 2;
   case 2..3:
     return a_class * 2 / 3;
   default:
     if(a_class > amount)
       tmp = amount - (amount / (5 + random(10)));
     else
       tmp = a_class - (amount / (5 + random(10)));
     if(tmp < a_class / 2)
       tmp = a_class / 2;
     return tmp;
   }
}
void setup_armour( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
}
int query_value() {
   return modify_value( object::query_value() );
}
int query_full_value() { return object::query_value(); }
void player_wear() {
   if ( !environment() )
      return;
   wearable::player_wear();
}
int drop(mixed dest) {
   if ( worn_by && living(worn_by))
      return 1;
   return object::drop(dest);
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = object::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
}
void dest_me() {
   set_worn_by( 0 );
   object::dest_me();
}
mixed *stats() {
   return object::stats() + armour_logic::stats() + wearable::stats() +
          ({ ({ "max ac", AC_LIMIT }) });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : object::int_query_static_auto_load(),
      "ac" : ac,
      "armour types" : armour_types,
   ]) + wearable::query_static_auto_load();
}
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([
      "::" : object::query_dynamic_auto_load(),
   ]) + wearable::query_dynamic_auto_load();
   return map;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      object::init_static_arg( map[ "::" ] );
   wearable::init_static_arg( map );
   if ( map[ "ac" ] )
      ac = map[ "ac" ];
   if (pointerp(ac)) {
     int i;
     mixed *tmp;
     tmp = (mixed *)ac;
     ac = ([ ]);
     for (i=0;i<sizeof(tmp);i+=2)
       add_ac(tmp[0], tmp[1][1], tmp[1][0]);
   } else if ( map[ "armour types" ] )
      armour_types = map[ "armour types" ];
   set_type( query_type() );
}
void replace_me(){
  object receipt;
  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}
void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );
   wearable::init_dynamic_arg( map );
   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
}

==================================================
FILE: baggage.c
==================================================

#include <move_failures.h>
inherit "/std/container";
inherit "/std/basic/close_lock_container";
inherit "/std/basic/condition";
inherit "/std/basic/holdable";
void create() {
  do_setup++;
  container::create();
  close_lock_container::create();
  condition::create();
  holdable::create();
  set_max_cond(400);
  set_cond(400);
  set_damage_chance(20);
  set_can_export_inventory();
  set_opaque();
  set_open();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  add_help_file("baggage");
}
void init() {
  close_lock_container::init();
}
int add_weight( int n ) {
  if ( !( ::add_weight( n ) ) ) return 0;
  if ( n >= 0 ) {
    remove_call_out( "check_breakages" );
    call_out( "check_breakages", 5 + random( 16 ) );
  }
  return 1;
}
void check_breakages() {
  object *obs, carrier;
  int i, amt, wt;
  carrier = environment(this_object());
  while (carrier && (!living(carrier)))
    carrier = environment(carrier);
  if (!carrier)
    return;
  obs = all_inventory();
  wt = query_loc_weight() - (int)query_property("padded");
  for (i=0;i<sizeof(obs);i++)
    if ((amt = obs[i]->query_property("fragile"))) {
      if (wt <= amt || ((wt - amt)*100)/amt <= random(100))
          obs[i] = 0;
    } else
      obs[i] = 0;
  obs = obs - ({ 0 });
  if (sizeof(obs) && environment(carrier)) {
    tell_room(environment(carrier), carrier->the_short()+" breaks "+
          (sizeof(obs)>1?"some things":"one thing")+" in "+
          query_multiple_short(({ this_object() }))+".\n", ({ carrier }));
    tell_object(carrier, "You break "+query_multiple_short(obs)+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    obs->dest_me();
  }
}
string long( string word, int dark ) {
  string ret;
  ret = ::long( word, dark );
  ret += cond_string();
  if ( query_transparent() || !query_closed() ) {
    if (dark == 2 ||
        dark == -2) {
       if (query_contents() != "") {
          ret += "$C$$the_short:" + file_name(this_object()) + "$ contains "
                 "some items you cannot make out.\n";
       }
    } else {
       ret += query_contents( "$C$$the_short:"+ file_name( this_object() ) +
           "$ contains " );
    }
  }
  ret += long_status();
  return ret;
}
int ensure_open() {
  if ( query_locked() ) {
      write( "The "+ short( 0 ) +" is locked.\n" );
      return 0;
   }
   if ( query_closed() ) {
      if ( do_open() ) {
         write( "You open the "+ short( 0 ) +".\n" );
         return 1;
      } else {
         write( "You can't open the "+ short( 1 ) +".\n" );
         return 0;
      }
   }
   return 1;
}
mixed stats() {
   return container::stats() + close_lock_container::stats();
}
mapping int_query_static_auto_load() {
  return ([
    "::" : container::int_query_static_auto_load(),
    "condition" : condition::query_static_auto_load(),
    "hold" : holdable::query_static_auto_load(),
    "trans" : query_transparent(),
    "difficulty" : query_difficulty(),
    "key" : query_key(),
    "trap open func" : query_open_trap_func(),
    "trap lock func" : query_lock_trap_func(),
    "trap open ob" : query_open_trap_ob(),
    "trap lock ob" : query_lock_trap_ob(),
  ]);
}
mapping query_dynamic_auto_load() {
   return ([
     "::" : container::query_dynamic_auto_load(),
     "condition" : condition::query_dynamic_auto_load(),
     "hold" : holdable::query_dynamic_auto_load(),
     "locked" : query_locked(),
     "stuck" : query_stuck(),
     "closed" : query_closed(),
   ]);
}
void init_dynamic_arg(mapping map, object) {
  object money;
  if (map["::"]) {
    container::init_dynamic_arg(map["::"]);
  }
  if (map["condition"]) {
    condition::init_dynamic_arg(map["condition"]);
  }
  if (map["hold"]) {
    holdable::init_dynamic_arg(map["hold"]);
  }
  if (sizeof(map["money"])) {
     money = clone_object("/obj/money");
     money->set_money_array(map["money"]);
     money->move(this_object());
  }
  if (map["closed"]) {
     set_closed();
  } else {
     set_open();
  }
  if (map["locked"]) {
     set_locked();
  } else {
     set_unlocked();
  }
  set_stuck(map["stuck"]);
}
void init_static_arg(mapping args) {
  if (args["::"]) {
    ::init_static_arg(args["::"]);
  }
  if (args["condition"]) {
    condition::init_static_arg(args["condition"]);
  }
  if (args["hold"]) {
    holdable::init_static_arg(args["hold"]);
  }
  if (!undefinedp(args["trans"])) {
    if (args["trans"]) {
       set_transparent();
    } else {
       set_opaque();
    }
  }
  if (!undefinedp(args["difficulty"])) {
    set_difficulty(args["difficulty"]);
  }
  if (!undefinedp(args["key"])) {
    set_key(args["key"]);
  }
  if (!undefinedp(args["trap open func"])) {
    set_open_trap(args["trap open ob"], args["trap open func"]);
  }
  if (!undefinedp(args["trap lock func"])) {
    set_lock_trap(args["trap lock ob"], args["trap lock func"]);
  }
  if (!query_max_weight()) {
     set_max_weight(5);
  }
}
mixed query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/baggage" ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   return ::can_find_match_recurse_into(looker);
}
int test_add(object ob, int flag) {
  if(flag)
    return 0;
  return ::test_add(ob, flag);
}
varargs int move(mixed dest, string mess1, string mess2) {
   object from;
   int result;
   result = holdable::move(dest);
   if (result != MOVE_OK) {
      return result;
   }
   from = environment();
   result = container::move(dest, mess1, mess2);
   if (result == MOVE_OK) {
      we_moved(from, environment());
   }
   return result;
}
string *parse_command_adjectiv_id_list() {
    return container::parse_command_adjectiv_id_list() +
        close_lock_container::parse_command_adjectiv_id_list();
}
void break_me() {
  all_inventory()->move( environment(), "$N fall$s out of " + a_short() +"." );
  ::break_me();
}
void dest_me() {
   close_lock_container::dest_me();
   container::dest_me();
}

==================================================
FILE: bottle.c
==================================================

#define PHIAL 150
#define BOTTLE 1000
#define QUIRM 2500
#define DEMIJOHN 50000
inherit "/obj/vessel";
nosave string glass;
void make_bottle( string word, int number ) {
   float mass;
   string adjective, noun;
   glass = word;
   set_max_volume(number*4);
   mass = number / 100.0;
   if ( !mass ) mass = 1;
   set_leak_rate( 0 );
   set_value( to_int(mass * 25 + random( mass * 10 )) );
   set_weight( to_int(mass + random( mass * 10 ) / 10 ));
   set_max_weight( to_int(mass * 2 ));
   add_property( "fragile", to_int(mass * 20 + random( mass * 5 )) );
   switch( number ) {
      case 0..PHIAL:
         adjective = "small";
         noun = "phial";
         set_length( 2 );
         set_width( 1 );
         break;
      case PHIAL+1..BOTTLE:
         adjective = "medium sized";
         noun = "bottle";
         set_length( 12 );
         set_width( 6 );
         break;
      case BOTTLE+1..QUIRM:
         adjective = "large";
         noun = "Quirm";
         set_length( 24 );
         set_width( 12 );
         break;
      case QUIRM+1..DEMIJOHN:
         adjective = "very large";
         noun = "demijohn";
         set_length( 48 );
         set_width( 24 );
         break;
      default:
         adjective = "huge";
         noun = "tank";
         set_length( 88 );
         set_width( 48 );
   }
   set_name( lower_case( noun ) );
   set_short( adjective +" "+ glass +" "+ noun );
   set_long( "This is a "+ adjective +" "+ glass +" glass "+ noun +".\n" );
   add_alias( "bottle" );
   add_adjective( ({ adjective, glass }) );
   set_main_plural( adjective +" "+ glass +" "+ noun +"s" );
   add_plural( lower_case( noun ) +"s" );
   set_material( ({ "glass" }) );
}
string query_glass() { return glass; }
int query_number() { return (int)query_property( "number" ); }
mixed *stats() {
   return ::stats() + ({
      ({ "glass", glass, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "glass" : glass,
   ]);
}
void init_static_arg( mapping map ) {
   if ( map["::"] )
      ::init_static_arg( map["::"] );
   if ( !undefinedp( map["glass"] ) )
      glass = map["glass"];
}
mixed query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/bottle" )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: clock.c
==================================================

#define CREATOR "Ceres"
#include <am_time.h>
inherit "std/object";
#define HOURS ({"twelve", "one", "two", "three", "four", "five", "six", \
                "seven", "seven plus one", "nine", "ten", "eleven" })
#define CHIME_HANDLER "/obj/handlers/chime_handler"
int show_date;
void create() {
  do_setup++;
  object::create();
  do_setup--;
  if(!do_setup)
    this_object()->setup();
  add_extra_look(this_object());
}
string query_time_string() {
  string mess;
  int minute, hour, *arr;
  minute = (AM_TIME_HANDLER->query_am_minute(time()) % 60);
  hour = AM_TIME_HANDLER->query_am_hour(time());
  if(minute > 30 )
    hour = hour + 1;
  hour = hour % 12;
  mess = "";
  switch(minute) {
  case 53..57:
    mess += "five to " + HOURS[hour]; break;
  case 48..52:
    mess += "ten to " + HOURS[hour]; break;
  case 43..47:
    mess += "quarter to " + HOURS[hour]; break;
  case 38..42:
      mess += "twenty to " + HOURS[hour]; break;
  case 33..37:
    mess += "twenty-five to " + HOURS[hour]; break;
  case 28..32:
    mess += "half past " + HOURS[hour]; break;
  case 23..27:
    mess += "twenty-five past " + HOURS[hour]; break;
  case 18..22:
    mess += "twenty past " + HOURS[hour]; break;
  case 13..17:
    mess += "a quarter past " + HOURS[hour]; break;
  case 8..12:
    mess += "ten past " + HOURS[hour]; break;
  case 3..7:
    mess += "five past " + HOURS[hour]; break;
  default:
    mess += HOURS[hour] + " o'clock";
  }
  if(show_date) {
    arr = AM_TIME_HANDLER->query_am_time_array(time());
    mess += " on " +
      AM_TIME_HANDLER->query_day_of_week(arr[AM_TIME_DAY_OF_WEEK]) + " the " +
      ordinal(arr[AM_TIME_DAY_OF_MONTH]) + " of " +
      AM_TIME_HANDLER->query_month(arr[AM_TIME_MONTH]);
  }
  return mess;
}
string extra_look(object thing) {
  return query_time_string() + ".\n";
}
void set_show_date() { show_date = 1; }
void set_chimes(int num, string mess) {
  CHIME_HANDLER->register_for_chimes(this_object(), num, mess);
}
void chime(string chime_message, int type) {
  say(chime_message);
}

==================================================
FILE: clothing.c
==================================================

#include <move_failures.h>
#include <virtual.h>
inherit "/std/container";
inherit "/std/basic/wearable";
inherit "/std/basic/close_lock";
string pocket_mess;
mixed *pockets;
nosave int biggest;
int _is_pair = 0;
void create() {
   do_setup++;
   container::create();
   wearable::create();
   close_lock::create();
   set_stuck(1);
   set_can_export_inventory();
   pocket_mess = "a pocket in $ob_short$";
   pockets = ({ });
   add_alias( "clothing" );
   add_plural( "clothes" );
   add_immune_to( "blunt" );
   add_help_file("clothing");
   set_opaque();
   set_open();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "haberdashery" );
   }
   do_setup--;
   if ( !do_setup ) {
      this_object()->setup();
   }
}
int query_clothing() { return 1; }
string query_pronoun()  {
   if (!_is_pair)
      return "it";
   return "they";
}
string query_objective()  {
   if (!_is_pair)
      return "it";
   return "them";
}
void set_is_pair(int comes_in_pairs)  {
   _is_pair = comes_in_pairs;
   if (_is_pair)
      add_adjective(({ "pair", "of" }));
}
int query_is_pair() { return _is_pair; }
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
   ret = container::long( word, dark );
   if ( sizeof( pockets ) && !dark ) {
      types = ([ ]);
      for ( i = 0; i < sizeof( pockets ); i += 2 ) {
         types[ pockets[ i ] ]++;
      }
      sizes = m_indices( types );
      for ( i = 0; i < sizeof( sizes ); i++ ) {
         sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
               " pocket"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
      }
      ret += "$C$"+ the_short() +" has "+ query_multiple_short( sizes ) +".\n"+
            query_contents( "It contains: " );
      ret += close_lock::long_status();
   }
   return ret + wearable::long( word, dark );
}
varargs string pretty_short( object thing ) {
   mixed pshort = ::pretty_short( thing );
   string short_stat = close_lock::short_status();
   if( arrayp( pshort ) ) {
      for( int i = 0; i < sizeof( pshort ); ++i ) {
         pshort[i] = short_stat + pshort[i];
      }
   } else {
      pshort = short_stat + pshort;
   }
   return pshort;
}
varargs string pretty_plural( object thing ) {
   mixed plural = ::pretty_plural( thing );
   string short_stat = close_lock::short_status();
   if( arrayp( plural ) ) {
      for( int i = 0; i < sizeof( plural ); ++i ) {
         plural[i] = short_stat + plural[i];
      }
   } else {
      plural = short_stat + plural;
   }
   return plural;
}
string query_pocket_mess() { return pocket_mess; }
void set_pocket_mess( string words ) { pocket_mess = words; }
mixed *query_pockets() { return pockets; }
void remove_pockets() {
  for( int i = 0; i < sizeof( pockets ); i+=2 ) {
    set_max_weight( query_max_weight() - pockets[ i+1 ] );
  }
  pockets = ({ });
}
void add_pocket( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   pockets += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > biggest ) {
      biggest = amount;
   }
}
int test_add( object thing, int flag ) {
   int i;
   if ( !sizeof( pockets )  || flag ) {
      return 0;
   }
   if ( !environment( thing ) ) {
      return 1;
   }
   if ( !biggest ) {
      for ( i = 0; i < sizeof( pockets ); i+= 2 ) {
         if ( pockets[ i + 1 ] > biggest ) {
            biggest = pockets[ i + 1 ];
         }
      }
   }
   if ( (int)thing->query_complete_weight() > biggest ) {
      return write( (string)thing->the_short() +" is too big "+
            "to fit in any of "+ the_short() +"'s pockets.\n" );
   }
   return ::test_add(thing, flag);
}
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   return ::can_find_match_recurse_into(looker);
}
int query_ac( string type, int amount ) {
   do_damage( type, amount );
   return 0;
}
void setup_clothing( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
}
int query_value() {
   return modify_value( container::query_value() );
}
int query_full_value() { return container::query_value(); }
int drop(mixed stuff) {
   if ( worn_by ) {
      if ( living( worn_by ) ) {
         return 1;
      }
   }
   return container::drop(stuff);
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   object from;
   from = environment();
   flag = container::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by ) {
      set_worn_by( 0 );
      if (from) {
         from->remove_inventory_container(this_object());
      }
      if (environment()) {
         environment()->add_inventory_container(this_object());
      }
   }
   return flag;
}
string *parse_command_adjectiv_id_list() {
    return container::parse_command_adjectiv_id_list() +
        close_lock::parse_command_adjectiv_id_list();
}
void dest_me() {
   set_worn_by( 0 );
   container::dest_me();
}
void break_me() {
   if ( worn_by ) {
      all_inventory()->move( environment( worn_by ), "$N fall$s from "+
            a_short() +"." );
   } else {
      all_inventory()->move( environment(), "$N fall$s out of "+
            a_short() +"." );
   }
   ::break_me();
}
mixed *stats() {
   int i;
   mixed *ret;
   ret = container::stats() + wearable::stats();
   for ( i = 0; i < sizeof( pockets ); i += 2 ) {
      ret += ({ ({ pockets[ i ] +" pocket", pockets[ i + 1 ] }) });
   }
   return ret;
}
mapping int_query_static_auto_load() {
   return ([
      "::" : container::int_query_static_auto_load(),
      "wear" : wearable::query_static_auto_load(),
      "pocket mess" : pocket_mess,
      "pockets" : pockets,
      "trans" : query_transparent(),
      "difficulty" : query_difficulty(),
      "key" : query_key(),
      "trap open func" : query_open_trap_func(),
      "trap lock func" : query_lock_trap_func(),
      "trap open ob" : query_open_trap_ob(),
      "trap lock ob" : query_lock_trap_ob(),
      "stuck" : query_stuck(),
      "pair" : _is_pair
   ]);
}
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : container::query_dynamic_auto_load(),
      "wear" : wearable::query_dynamic_auto_load(),
      "locked" : query_locked(),
      "closed" : query_closed(),
   ]);
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      container::init_static_arg( map[ "::" ] );
   }
   if ( map[ "wear" ] ) {
      wearable::init_static_arg( map[ "wear" ] );
   }
   if ( !undefinedp( map[ "pocket mess" ] ) ) {
      pocket_mess = map[ "pocket mess" ];
   }
   if ( !undefinedp( map[ "pockets" ] ) ) {
      pockets = map[ "pockets" ];
   }
   if (!undefinedp(map["pair"]))
      _is_pair = map["pair"];
   if (!undefinedp(map["trans"])) {
      if (map["trans"]) {
         set_transparent();
      } else {
         set_opaque();
      }
   }
   if (!undefinedp(map["difficulty"])) {
      set_difficulty(map["difficulty"]);
   }
   if (!undefinedp(map["key"])) {
      set_key(map["key"]);
   }
   if (!undefinedp(map["trap open func"])) {
      set_open_trap(map["trap open ob"], map["trap open func"]);
   }
   if (!undefinedp(map["trap lock func"])) {
      set_lock_trap(map["trap lock ob"], map["trap lock func"]);
   }
   if ( !undefinedp( map[ "stuck" ] ) ) {
      set_stuck(map["stuck"]);
   }
}
void replace_me(){
  object receipt;
  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}
void init_dynamic_arg( mapping map, object ob ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] ) {
      container::init_dynamic_arg( map[ "::" ], ob );
   }
   if ( map[ "wear" ] ) {
      wearable::init_dynamic_arg( map[ "wear" ], ob );
   }
   if ( !undefinedp( map[ "locked" ] ) ) {
      if ( map[ "locked" ] ) {
         set_locked();
      } else {
         set_unlocked();
      }
   }
   if ( !undefinedp( map[ "closed" ] ) ) {
      if (map["closed"]) {
         set_closed();
      } else {
         set_open();
      }
   }
   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
      if( file_size( virt_name ) == -1 ) {
         new_name = ( CLONER )->other_file( virt_name );
         if( stringp( new_name ) && ( new_name != virt_name ) ) {
            add_property( VIRTUAL_NAME_PROP, new_name );
            virt_name = new_name;
         } else {
            if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
               call_out( "replace_me", 1 );
            } else {
               VIRTUAL_HANDLER->add_missing( virt_name );
            }
         }
      }
      if( file_size( virt_name ) != -1 &&
          query_property( "virtual time" ) < stat( virt_name )[1] ) {
         stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
         if( mapp( stat_temp ) ) {
            init_static_arg( stat_temp );
            add_property( "virtual time", time() );
         }
      }
   }
}

==================================================
FILE: clothing_transport.c
==================================================

inherit "/obj/clothing";
private int _mount_difficulty_modifier;
private int _direction_difficulty_modifier;
private string _race;
void create() {
   clothing::create();
}
void set_worn_by_race(string race) {
   _race = race;
}
string query_worn_by_race() {
   return _race;
}
void set_mount_difficulty_modifier(int diff) {
   _mount_difficulty_modifier = diff;
}
int query_mount_difficulty_modifier() {
   return _mount_difficulty_modifier;
}
void set_direction_difficulty_modifier(int diff) {
   _direction_difficulty_modifier = diff;
}
int query_direction_difficulty_modifier() {
   return _direction_difficulty_modifier;
}
mapping int_query_static_auto_load() {
   return ([
      "::" : clothing::int_query_static_auto_load(),
      "worn by race" : _race,
      "mount difficulty" : _mount_difficulty_modifier,
      "direction difficulty" : _direction_difficulty_modifier
   ]);
}
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
void init_static_arg(mapping map) {
   if (map["::"]) {
      clothing::init_static_arg(map["::"]);
   }
   _race = map["worn by race"];
   _mount_difficulty_modifier = map["mount difficulty"];
   _direction_difficulty_modifier = map["direction difficulty"];
}

==================================================
FILE: cont_medium.c
==================================================

#include <move_failures.h>
#include <parse_command.h>
#include <obj_parser.h>
inherit "/std/object";
private int amount;
private int continuous;
private int collective;
private nosave string my_filename;
private int *weight_unit;
private nosave int no_join;
private float value_scale;
private string medium_alias;
private string pile_name;
private string *_sorted_amount_names;
private mapping amount_types;
private mixed *pile_types;
private nosave mixed _short_name;
object make_medium_clone( int number );
void create() {
  int junk;
  do_setup++;
  ::create();
  do_setup--;
  continuous = 0;
  collective = 0;
  weight_unit = ({ 1, 200 });
  pile_name = "pile";
  if ( !do_setup )
    this_object()->setup();
  if( !clonep( this_object() ) )
    return;
  sscanf( file_name( this_object() ), "%s#%d", my_filename, junk );
  amount = 1;
}
void set_name( string word ) {
  ::set_name( word );
  if ( continuous )
    add_plural( word );
}
int query_amount() { return amount; }
void set_amount( int number ) {
  if(environment() && continuous)
    environment()->add_volume(number - amount);
  amount = number;
  if(continuous || collective)
    set_weight((amount * weight_unit[ 0 ] ) / weight_unit[ 1 ]);
}
void adjust_amount(int number) {
  if(environment() && continuous)
    environment()->add_volume(number);
  amount += number;
  if(amount < 1) {
    no_join = 1;
    move( "/room/rubbish" );
    return;
  }
  if(continuous || collective)
    set_weight((amount * weight_unit[0]) / weight_unit[1]);
}
int query_continuous() { return continuous; }
int query_collective() { return collective; }
int query_merger() { return 1; }
void set_continuous() {
  collective = 0;
  if (continuous) {
    return;
  }
  if ( environment() ) {
    environment()->add_volume( -200*query_weight() );
  }
  continuous = 1;
  if(environment()) {
    environment()->add_volume( amount );
  }
}
void reset_continuous() {
  if (!continuous) {
    return;
  }
  continuous = 0;
  if ( environment() ) {
    environment()->add_volume( -amount );
  }
}
void set_collective() {
  collective = 1;
  continuous = 0;
  add_property( "determinate", "" );
}
void reset_collective() {
  collective = 0;
}
int *query_weight_unit() { return weight_unit; }
void set_weight_unit( int *numbers ) { weight_unit = numbers; }
int query_no_join() { return no_join; }
void set_no_join() { no_join = 1; }
void reset_no_join() { no_join = 0; }
string query_medium_alias() { return medium_alias; }
void set_medium_alias( string word ) {
   medium_alias = word;
   add_alias( medium_alias );
}
string query_pile_name() { return pile_name; }
void set_pile_name( string word ) { pile_name = word; }
mapping query_amount_types() { return amount_types; }
void set_amount_types( mapping map ) {
  amount_types = map;
  _sorted_amount_names = sort_array(m_indices( amount_types ),
      (: amount_types[$1][0] - amount_types[$2][0] :));
}
mixed query_pile_types() { return pile_types; }
void set_pile_types( mixed *args ) { pile_types = args; }
int query_max_seen() { return 12; }
int query_value() {
  if (!floatp(value_scale) || !continuous) {
    if(collective)
      return (amount * ::query_value() );
    return ::query_value();
  }
  return to_int(::query_value() * value_scale * amount);
}
void set_value_scale(float f) { value_scale = f; }
float query_value_scale() { return value_scale; }
int query_how_many() {
  int biggest_amount;
  int how_many;
  string size;
  string biggest_size;
  if(!amount)
    return 0;
  if(!m_sizeof(amount_types)) {
    if(collective)
        return amount;
    return 0;
  }
  biggest_size = _sorted_amount_names[0];
  foreach (size in _sorted_amount_names) {
    if (amount < amount_types[size][0]) {
      break;
    }
    biggest_size = size;
  }
  biggest_amount = amount_types[biggest_size][0];
  how_many = ( amount + biggest_amount / 2 ) / biggest_amount;
  return how_many;
}
varargs string amount_size(int exact) {
   int biggest_amount;
   int how_many;
   string size;
   string biggest_size;
   string biggest_plural;
   if ( !amount ) {
      return "none at all";
   }
   if ( !m_sizeof( amount_types ) ) {
      return "minus one Cornish pint";
   }
   biggest_size = _sorted_amount_names[0];
   foreach (size in _sorted_amount_names) {
     if (amount < amount_types[size][0]) {
       break;
     }
     biggest_size = size;
   }
   biggest_amount = amount_types[biggest_size][0];
   biggest_plural = amount_types[biggest_size][1];
   how_many = ( amount + biggest_amount / 2 ) / biggest_amount;
   if ( !how_many ) {
      return "apparently not containing any "+ biggest_plural;
   }
   if ( how_many == 1 ) {
      return "about one "+ biggest_size;
   }
   if ( !exact  &&  how_many > query_max_seen() ) {
      return "more "+ biggest_plural +" than you can count";
   }
   return "about "+ query_num( how_many ) +" "+ biggest_plural;
}
string amount_size_short() {
   int biggest_amount;
   int how_many;
   string size;
   string biggest_size;
   string ret;
   string biggest_plural;
   if ( !amount || !sizeof( amount_types ) ||
        (query_property("determinate") == "some ") ) {
     if(collective)
       return query_num(amount, 20) + " ";
     return "";
   }
   if (_short_name && _short_name[0] == amount) {
      return _short_name[1];
   }
   biggest_size = _sorted_amount_names[0];
   foreach (size in _sorted_amount_names) {
     if (amount < amount_types[size][0]) {
       break;
     }
     biggest_size = size;
   }
   biggest_amount = amount_types[biggest_size][0];
   biggest_plural = amount_types[biggest_size][1];
   how_many = ( amount + biggest_amount / 2 ) / biggest_amount;
   if(!how_many) {
     if(collective)
       ret = query_num(amount) + " ";
     else
       ret = "a smidgeon of ";
   } else if(collective && amount < biggest_amount) {
     ret = query_num(amount) + " ";
   } else if(how_many == 1) {
     ret = "one "+ biggest_size + " of ";
   } else {
     ret = query_num( how_many, query_max_seen()) +" "+ biggest_plural +
       " of ";
   }
   _short_name = ({ amount, ret });
   return ret;
}
string pile_size() {
   int i;
   if ( !sizeof( pile_types ) ) {
      return "a surreal "+ pile_name;
   }
   for ( i = 0; i < ( sizeof( pile_types ) - 1 ); i += 2 ) {
      if ( amount <= pile_types[ i ] ) {
         return add_a( pile_types[ i + 1 ] ) +" "+ pile_name;
      }
   }
   return add_a( pile_types[ sizeof( pile_types ) - 1 ] ) +" "+ pile_name;
}
varargs string pretty_short( object thing ) {
  if(collective) {
    if(amount > 1)
      return pretty_plural(thing);
    else
      return add_a(::pretty_short(thing));
  }
  return amount_size_short() + ::pretty_short( thing );
}
varargs string pretty_plural( object thing ) {
  if(amount > 1)
    return amount_size_short() + ::pretty_plural( thing );
  return ::pretty_plural(thing);
}
#ifdef 0
string short(int dark) {
  string ret;
  ret = ::short( dark );
  if(!ret || ret == "something" || !collective)
    return(ret);
  if(amount == 1)
    return add_a(ret);
  return( query_num(amount, 9999 ) + " " + query_main_plural());
}
#endif
string long(string words, int dark ) {
  int i;
  string ret;
  string *bits;
  if(continuous)
    return replace( ::long( words, dark ),
                    ({ "$amount_size$", amount_size(),
                         "$pile_size$", pile_size() }) );
  ret = replace( ::long( words, dark ), "$N", short( dark ) );
  if(collective && amount > 1) {
    ret = replace( ret, ",$", "$comma_dollar$" );
    ret = replace( ret, ({ ",", " $spaced_comma$", ";", " $spaced_semi$",
        ":", " $spaced_colon$", ".", " $spaced_period$" }) );
    ret = replace( ret, "$comma_dollar$", ",$");
    bits = explode(ret, " ");
    for(i = 0; i < sizeof(bits); i++) {
        switch( bits[ i ] ) {
        case "This":
          bits[i] = "These";
          break;
        case "this":
          bits[i] = "these";
          break;
        case "is":
          bits[i] = "are";
          break;
        case "a":
        case "an":
          bits[i] = amount_size_short();
          bits[i] = bits[i][0..<2];
          break;
        case "it":
           bits[i] = "they";
           break;
        case "It":
           bits[i] = "They";
           break;
        case "its":
           bits[i] = "their";
           break;
        case "Its":
           bits[i] = "Their";
           break;
        case "$a":
        case "$an":
           bits[i] = bits[i][1..];
           break;
        default:
           if( bits[i][0..1] == "$V" ) {
              bits[i] = replace_string( bits[i], "$V", "" );
              bits[i] = explode( bits[i], "$" )[1];
           };
           if( bits[i][0..1] == "$P" ) {
              bits[i] = replace_string( bits[i], "$P", "" );
              bits[i] = pluralize( bits[i] );
           };
           if( bits[i][0..1] == "$A" ) {
              bits[i] = replace_string( bits[i], "$A", "" );
              bits[i] = pluralize( bits[i] );
           };
           if(strsrch(bits[i], query_plural(dark)) == -1)
               bits[i] = replace(bits[i], short(dark), query_plural(dark));
        }
      }
    ret = implode(bits, " ");
    ret = replace(ret, ({ " $spaced_comma$", ",", " $spaced_semi$", ";",
        " $spaced_colon$", ":", " $spaced_period$", "." })  );
  } else if( collective && amount == 1 ) {
     bits = explode(ret, " ");
     for(i = 0; i < sizeof(bits); i++) {
        if( bits[i][0..1] == "$V" ) {
           bits[i] = replace_string( bits[i], "$V", "" );
           bits[i] = explode( bits[i], "$" )[0];
        };
        if( bits[i][0..1] == "$P" ) {
           bits[i] = replace_string( bits[i], "$P", "" );
        };
        if( bits[i] == "$a" || bits[i] == "$an" ) {
           bits[i] = bits[i][1..];
        };
        if( bits[i][0..1] == "$A" ) {
           bits[i] = replace_string( bits[i], "$A", "" );
           bits[i] = add_a( bits[i] );
        };
     };
     ret = implode( bits, " " );
  };
  return ret;
}
string query_long(string words, int dark)  {
   return long(words, dark);
}
object new_collective(int number) {
  object ob;
  object place;
  ob = make_medium_clone(number);
  adjust_amount(-number);
  ob->set_no_join();
  if(environment()) {
    place = (object)environment()->query_property( "medium dest" );
    if(!place)
      place = environment();
    ob->move(place);
  }
  ob->reset_no_join();
  ob->call_out("merge", 1);
  return ob;
}
int merge_criteria(object ob) {
  return medium_alias == ob->query_medium_alias();
}
void merge() {
  object *obs;
  if(environment())
     obs = filter(all_inventory(environment()) - ({ this_object() }),
                  "merge_criteria", this_object());
  if(sizeof(obs) && objectp(obs[0])) {
    no_join = 1;
    move("/room/rubbish");
    obs[0]->adjust_amount(amount);
  }
  return;
}
varargs int move( mixed dest, string messin, string messout ) {
  int check;
  if((check = ::move(dest, messin, messout)) != MOVE_OK)
    return check;
  if(no_join || !medium_alias || (!continuous && !collective))
    return MOVE_OK;
  call_out("merge", 0);
  return MOVE_OK;
}
object make_medium_clone( int number ) {
   object medium;
   mapping map;
   medium = clone_object( explode( file_name( this_object() ), "#" )[ 0 ] );
   map = (mapping)this_object()->query_dynamic_auto_load();
   medium->init_dynamic_arg( map );
   map = (mapping)this_object()->query_static_auto_load();
   if ( map ) {
      medium->init_static_arg( map );
   }
   medium->set_amount( number );
   medium->set_enchant( query_enchant() * medium->query_max_enchant() /
                        query_max_enchant() );
   return medium;
}
object cont_query_parse_id( mixed *args ) {
   int i;
   string *sizes;
   object medium, place;
   if ( args[ P_THING ] < 0 ) {
      args[ P_THING ]++;
      if ( args[ P_THING ] ) {
         return 0;
      }
      args[ P_THING ] = -99999;
      return this_object();
   }
   sizes = m_indices( amount_types );
   if ( args[ P_THING ] == 1 ) {
      for ( i = 0; i < sizeof( sizes ); i++ ) {
         if ( member_array( sizes[ i ], explode( args[ P_STR ], " " ) ) !=
               -1 ) {
            if ( amount_types[ sizes[ i ] ][ 0 ] > amount ) {
               return 0;
            }
            medium = make_medium_clone( amount_types[ sizes[ i ] ][ 0 ] );
            place = (object)environment()->query_property( "medium dest" );
            if ( !place ) {
               place = environment();
            } else {
               remove_call_out( "no_env_move" );
               call_out( "dest_old_env", 1, environment() );
            }
            adjust_amount( -amount_types[ sizes[ i ] ][ 0 ] );
            this_object()->set_no_env_move( place );
            medium->move( place );
            args[ P_THING ] = -99999;
            return medium;
         }
      }
      args[ P_THING ] = -99999;
      return this_object();
   }
   for ( i = 0; i < sizeof( sizes ); i++ ) {
      if ( member_array( amount_types[ sizes[ i ] ][ 1 ],
            explode( args[ P_STR ], " " ) ) != -1 ) {
         if ( amount_types[ sizes[ i ] ][ 0 ] * args[ P_THING ] > amount ) {
               return 0;
         }
         medium = make_medium_clone( amount_types[ sizes[ i ] ][ 0 ] *
                args[ P_THING ] );
         place = (object)environment()->query_property( "medium dest" );
         if ( !place ) {
            place = environment();
         } else {
            remove_call_out( "no_env_move" );
            call_out( "dest_old_env", 1, environment() );
         }
         adjust_amount( -amount_types[ sizes[ i ] ][ 0 ] * args[ 0 ] );
         this_object()->set_no_env_move( place );
         medium->move( place );
         args[ P_THING ] = -99999;
         return medium;
      }
   }
   return 0;
}
object coll_query_parse_id( mixed *arr ) {
   string *bits;
   if((arr[0] < 0)) {
     return 0;
   }
   if(arr[0] == 0) {
     bits = explode( arr[ 1 ], " " );
     if(sizeof(bits) == 1) {
       if(bits[0] == query_main_plural()) {
         return this_object();
       }
     }
     if(member_array(bits[sizeof(bits) - 1 ], query_plurals()) == -1) {
       return this_object();
     }
     return 0;
   }
   if(id(arr[1])) {
     return new_collective(amount - arr[0]);
   }
}
object query_parse_id( mixed *args ) {
  if(continuous)
    return cont_query_parse_id(args);
  return coll_query_parse_id(args);
}
mixed* cont_parse_match_object(string* input, object player,
                               class obj_match_context context) {
   int result;
   string size;
   mixed* amt;
   int make_amt;
   int smallest;
   int num;
   object medium;
   object place;
   result = ::is_matching_object(input, player, context);
   if (!continuous || !result) {
      if (result) {
         if (update_parse_match_context(context, 1, result)) {
            return ({ result, ({ this_object() }) });
         }
      }
      return 0;
   }
   smallest = amount;
   foreach (size, amt in amount_types) {
      if ( member_array( size, input) != -1) {
         if ( amt[ 0 ] > amount ) {
            return 0;
         }
         make_amt = amt[0];
      } else if ( member_array( amt[1], input ) != -1 ) {
         if ( amt[ 0 ] > amount ) {
            return 0;
         }
         make_amt = amt[0];
      }
      if (smallest > amt[0]) {
         smallest = amt[0];
      }
   }
   if (!make_amt) {
     if(!amount)
       make_amt = 1;
     else
       make_amt = amount;
   }
   num = update_parse_match_context(context, (amount / make_amt), result);
   if (!num) {
      return 0;
   }
   make_amt *= num;
   if (context->fraction) {
      make_amt = (make_amt * context->fraction[0]) / context->fraction[1];
   }
   if (make_amt < smallest) {
      make_amt = smallest;
   }
   if (make_amt < amount) {
      medium = make_medium_clone( make_amt );
      place = (object)environment()->query_property( "medium dest" );
      if ( !place ) {
         place = environment();
      } else {
         remove_call_out( "no_env_move" );
         call_out( "dest_old_env", 1, environment() );
      }
      adjust_amount( -make_amt );
      this_object()->set_no_env_move( place );
      medium->move( place );
      return ({ result, ({ medium }) });
   }
   return ({ result, ({ this_object() }) });
}
mixed* coll_parse_match_object(string* input, object viewer,
                               class obj_match_context context) {
  int ret;
  int num;
  int make_amt;
  string size;
  mixed *amt;
  int smallest;
  ret = ::is_matching_object(input, viewer, context);
  if (!ret) {
    return 0;
  }
  if (sizeof(input) == 1 &&
      !context->number_included &&
      !context->ordinal &&
      (member_array(input[<1], query_plurals()) != -1 ||
       input[<1] == "all" || input[<1] == "thing")) {
    return ({ OBJ_PARSER_MATCH_PLURAL, ({ this_object() }) });
  }
  if(amount_types) {
    smallest = amount;
    foreach (size, amt in amount_types) {
      if(member_array( size, input) != -1) {
        if(amt[0] > amount) {
          return 0;
        }
        make_amt = amt[0];
        ret = OBJ_PARSER_MATCH_SINGULAR;
      } else if(member_array( amt[1], input ) != -1) {
        if(amt[ 0 ] > amount) {
          return 0;
        }
        make_amt = amt[0];
        ret = OBJ_PARSER_MATCH_PLURAL;
      }
      if (smallest > amt[0]) {
        smallest = amt[0];
      }
    }
  }
  if(!make_amt)
    make_amt = 1;
  num = update_parse_match_context(context, to_int(amount / make_amt), ret);
  if (!num)
    return 0;
  num *= make_amt;
  if (context->fraction) {
    num = (num  * context->fraction[0]) / context->fraction[1];
  }
  if(num < amount) {
    new_collective(amount - num);
    return ({ ret, ({ this_object() }) });
  }
  return ({ ret, ({ this_object() }) });
}
mixed *parse_match_object(string *input, object player,
                          class obj_match_context context) {
  if(continuous)
    return cont_parse_match_object(input, player, context);
  return coll_parse_match_object(input, player, context);
}
void set_no_env_move( object dest ) {
   object place;
   if ( file_name( environment() ) == "/room/rubbish" ) {
      return;
   }
   place = clone_object( "/std/container" );
   place->add_property( "medium dest", dest );
   move( place );
   call_out( "no_env_move", 0, dest, place );
}
void no_env_move( object dest, object place ) {
   if ( environment() == place ) {
      move( dest );
   }
   call_out( "dest_old_env", 1, place );
}
void dest_old_env( object place ) {
   if ( place ) {
      place->dest_me();
   }
}
mapping query_dynamic_auto_load() {
   return ([
      "::": ::query_dynamic_auto_load(),
      "continuous": continuous,
      "collective": collective,
      "amount": amount,
   ]);
}
void init_dynamic_arg( mapping map, object ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ]);
  if ( map[ "amount" ] )
    set_amount( map[ "amount" ] );
  if ( !undefinedp( map[ "continuous" ] ) )
    if ( map[ "continuous" ] ) {
      set_continuous();
    } else {
      reset_continuous();
    }
  if(!undefinedp(map["collective"]))
    collective = map["collective"];
}
mapping int_query_static_auto_load() {
   return ([
      "::": ::int_query_static_auto_load(),
      "weight_unit": weight_unit,
      "medium_alias": medium_alias,
      "pile_name": pile_name,
      "amount_types": amount_types,
      "pile_types": pile_types,
      "value_scale": value_scale,
   ]);
}
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
      return int_query_static_auto_load();
   return 0;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   if ( !undefinedp( map[ "medium_alias" ] ) )
      medium_alias = map[ "medium_alias" ];
   if ( pointerp( map[ "weight_unit" ] ) )
      weight_unit = map[ "weight_unit" ];
   if ( stringp( map[ "pile_name" ] ) )
      pile_name = map[ "pile_name" ];
   if ( mapp( map[ "amount_types" ] ) )
      set_amount_types(map[ "amount_types" ]);
   if ( pointerp( map[ "pile_types" ] ) )
      pile_types = map[ "pile_types" ];
   if ( floatp( map[ "value_scale" ] ) )
      value_scale = map[ "value_scale" ];
}
mixed *stats() {
   return ::stats() + ({
      ({ "amount", amount }),
      ({ "medium alias", medium_alias }),
      ({ "continuous", continuous }),
      ({ "collective", collective }),
      ({ "value scale", value_scale }),
   });
}

==================================================
FILE: cont_save.c
==================================================

inherit "/obj/baggage";
private mapping details;
private nosave string _save_file;
private object _loading;
private nosave int _can_recurse;
varargs void do_load( object thing ) {
   if ( _save_file ) {
      all_inventory( this_object() ) -> dest_me();
      if ( file_size( _save_file + ".o" ) > 0 ) {
         unguarded((: restore_object, _save_file :));
         if ( thing ) {
            set_player( thing );
         }
         if ( sizeof( details ) ) {
            init_dynamic_arg( details, 0 );
         }
      }
   }
}
void create() {
   _save_file = "";
   details = ([ ]);
   _can_recurse = 0;
   ::create();
}
protected int handle_restore_inventory(object ob) {
   _loading = ob;
   return ::handle_restore_inventory(ob);
}
string query_long_details(string arg, int dark, object looker) {
   string ret;
   ret = ::query_long_details(arg, dark, looker);
   if (query_auto_loading()) {
      return ret + the_short() + " contents is still being generated.\n";
   }
   return ret;
}
int test_remove( object thing, int flag, mixed dest ) {
   if (!query_auto_loading()) {
      remove_call_out( "do_save" );
      if ( find_call_out( "do_save" ) == -1 ) {
         call_out( "do_save", 1 );
      }
      return ::test_remove( thing, flag, dest );
   } else if (_loading == thing) {
      return ::test_remove( thing, flag, dest );
   } else {
      return 0;
   }
}
int test_add( object ob, int flag) {
   if (!query_auto_loading()) {
      remove_call_out( "do_save" );
      if ( find_call_out( "do_save" ) == -1 ) {
         call_out( "do_save", 1 );
      }
      return 1;
   } else if (_loading == ob) {
      return ::test_add( ob, flag );
   } else {
      return 0;
   }
}
void do_save() {
   if ( _save_file && _save_file != "" &&
        !query_auto_loading()) {
      details = ([ ]);
      details = query_dynamic_auto_load();
      unguarded((: save_object, _save_file :));
   }
}
void check_euid() {
   if ( previous_object() ) {
      seteuid( geteuid( previous_object() ) );
   }
}
varargs void set_save_file( string file, object thing ) {
   _save_file = file;
   call_out( "do_load", 0, thing );
}
string query_save_file() {
   return _save_file;
}
void set_can_recurse(int recurse_flag) { _can_recurse = recurse_flag; }
int query_can_recurse() { return _can_recurse; }
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   if (!_can_recurse)
      return ::can_find_match_recurse_into(looker);
   return 1;
}

==================================================
FILE: container.c
==================================================

#include "move_failures.h"
#include "parse_command.h"
#include "potion_attrs.h"
inherit "/std/container";
inherit "/std/basic/close_lock_container";
#define MAX_INVENT 40
nosave int full_weight, leak_rate, hb_count;
mixed *misc_attrs;
nosave mixed *all_attrs;
nosave mixed *active_attrs;
int volume, max_volume;
int water;
int *ps_coord;
int ps_quantity;
nosave mixed *potion_id, *potion_adjective;
nosave int volume_to_womble;
void set_volume_to_womble(int n) { volume_to_womble = n; }
int query_volume_to_womble() { return volume_to_womble; }
void set_full_weight(int i) { full_weight = i; }
void set_leak_rate(int i) { leak_rate = i; }
int query_full_weight() { return full_weight; }
int query_leak_rate() { return leak_rate; }
int query_volume() { return volume; }
void set_volume(int i) {
   volume = i;
   if (leak_rate) {
      set_heart_beat(1);
   }
}
int query_max_volume() { return max_volume; }
int *query_ps_coord() { return ps_coord; }
int query_ps_quantity() { return ps_quantity; }
void set_ps_quantity(int n) { ps_quantity = n; }
int *query_all_attrs() { return all_attrs; }
int *query_misc_attrs() { return misc_attrs; }
int *query_active_attrs() { return active_attrs; }
void set_water_volume(int n) { water = n; if (leak_rate) set_heart_beat(1); }
int query_water_volume() { return water; }
void set_max_weight(int i) {
  if (!max_volume && i) {
    max_volume = i*10;
  }
  ::set_max_weight(i);
}
void set_max_volume(int i) {
  if (!query_max_weight() && i) {
    ::set_max_weight(i/10);
  }
  max_volume = i;
}
int empty_formula() {
   int vol_lost;
   vol_lost = 2 + volume * 95 / 100;
   if (vol_lost > volume) vol_lost = volume;
   return vol_lost;
}
int cull_neutral_obs( mixed ob ) {
   if ( ob->query_vect() ) {
     return 1;
   }
   return 0;
}
int *contents_vect() {
   object *inv;
   int *v;
   int ang, str, tot, i;
   inv = all_inventory(this_object());
   inv = filter_array(inv, "cull_neutral_obs", this_object());
   if (sizeof(inv) == 0) return ({ 0, 0, 0 });
   tot = ang = str = 0;
   for (i = 0; i < sizeof(inv); i++) {
      v = inv[i]->query_vect();
      tot += v[0];
      ang += v[1] * v[0];
      str += v[2] * v[0];
   }
   return ({ ang / tot, str / tot, tot });
}
int dest_active_contents() {
   object *inv;
   int i;
   inv = all_inventory(this_object());
   inv = filter_array(inv, "cull_neutral_obs", this_object());
   for (i = 0; i < sizeof(inv); i++) {
      inv[i]->dest_me();
   }
   return sizeof(inv);
}
int *squidge_vector(int *v, int meth_ang, int meth_mult) {
   int ca, cb;
   int da, cx, cy;
   object trig;
   "/obj/handlers/trig"->wibble_wobble();
   trig = find_object("/obj/handlers/trig");
   da = meth_ang - v[0];
   ca = v[1] * trig->cos(da);
   cb = v[1] * trig->sin(da);
   ca = ca * meth_mult;
   cb /= meth_mult;
   ca /= 1000000;
   cb /= 1000000;
   cx = ca * trig->cos(meth_ang) + cb * trig->sin(meth_ang);
   cy = ca * trig->sin(meth_ang) - cb * trig->cos(meth_ang);
   return ({ cx / 1000000, cy / 1000000 });
}
void set_ps_coord_quantity(int *coord, int quantity);
void add_ps_vect(int *v, int quant) {
   object trig;
   int ca, cb;
   if (quant <= 0) return;
   trig = find_object("/obj/handlers/trig");
   ca = v[0];  cb = v[1];
    ca = (int)trig->pow1_5(ps_coord[0] * 10 * ps_quantity /(ca * quant)) * ca / 1000000;
   cb = (int)trig->pow1_5(ps_coord[1] * 10 * ps_quantity /(cb * quant)) * cb / 1000000;
   set_ps_coord_quantity( ({ ps_coord[0] + ca, ps_coord[1] + cb }),
                          quant + ps_quantity);
   return;
}
string transparency_string(int trans)
{
   switch (trans) {
   case -10..9: return "opaque";
   case 10..24: return "milky";
   case 25..39: return "murky";
   case 40..59: return "cloudy";
   case 60..74: return "misty";
   case 75..89: return "slightly misty";
   case 90..110: return "clear";
   default: return "paisley";
   }
}
string consistency_string(int cons)
{
   switch (cons) {
   case -10..9: return "watery liquid";
   case 10..24: return "slightly viscous watery liquid";
   case 25..39: return "runny syrup";
   case 40..59: return "syrup";
   case 60..74: return "jelly";
   case 75..89: return "paste";
   case 90..110: return "solid";
   default: return "non-Newtonian fluid";
   }
}
void update_potion_parse()
{
   int i;
   string *exploded;
   potion_adjective = query_adjectives() +
                  ({ transparency_string(all_attrs[POTION_TRANSPARENCY]) });
   potion_id = ({ query_name() }) + query_alias() +
                  ({ consistency_string(all_attrs[POTION_CONSISTENCY]) });
   for (i = 0; i < sizeof(all_attrs[POTION_NAMES]); i++) {
      exploded = explode(all_attrs[POTION_NAMES][i][0], " ");
      potion_id += ({ exploded[sizeof(exploded) - 1] });
      if (sizeof(exploded) > 1) {
         potion_adjective += exploded[0..sizeof(exploded) - 2];
      }
   }
   for (i = 0; i < sizeof(all_attrs[POTION_COLOURS]); i++)
      potion_adjective += explode(all_attrs[POTION_COLOURS][i][0], " ");
}
void void_liquid()
{
   volume = 0;
   water = 0;
   misc_attrs = allocate(POTION_ATTRS_SIZE);
   misc_attrs[POTION_CONSISTENCY] = 0;
   misc_attrs[POTION_TRANSPARENCY] = 100;
   misc_attrs[POTION_NAMES] = ({ });
   misc_attrs[POTION_COLOURS] = ({ });
   misc_attrs[POTION_SMELLS] = ({ });
   misc_attrs[POTION_FLAVOURS] = ({ });
   ps_coord = (int *)POTION_SPACE_HANDLER->neutral_coordinate();
   ps_quantity = 0;
   active_attrs = all_attrs = misc_attrs;
   update_potion_parse();
}
void create() {
  do_setup++;
  container::create();
  close_lock_container::create();
  set_can_export_inventory();
  do_setup--;
  void_liquid();
  add_property("liquid", 1);
  add_property("watertight", 1);
  leak_rate = 1000;
  if ( !do_setup )
    this_object()->setup();
}
void init() {
  (void)this_player()->add_command("drink", this_object());
  (void)this_player()->add_command("splash", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("rub", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("apply", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("pour", this_object(), "<direct:object> <preposition> <indirect:object>");
  (void)this_player()->add_command("taste", this_object());
  (void)this_player()->add_command("smell", this_object());
  this_player()->add_command("fill", this_object(), "<indirect:object> <preposition> <direct:object>");
  this_player()->add_command("fill", this_object(), "<indirect:object> <fraction> up <preposition> <direct:object>");
  this_player()->add_command("fill", this_object(), "<indirect:object> <fraction> full <preposition> <direct:object>");
  (void)this_player()->add_command("empty", this_object());
  close_lock_container::init();
}
int query_complete_weight() {
  return ::query_complete_weight() + ( query_max_weight() * volume ) /
      ( max_volume + 1 );
}
int query_weight_left() {
  if (!max_volume)
    return query_max_weight() - query_loc_weight();
  return query_max_weight() - query_loc_weight() - (query_max_weight()*volume)/max_volume;
}
int query_volume_left() {
  if (!query_max_weight())
    return max_volume - volume;
  return max_volume - volume - (max_volume*query_loc_weight())/query_max_weight();
}
int add_weight( int n ) {
  if ( query_weight_left() < n ) return 0;
  if ( !( ::add_weight( n ) ) ) return 0;
  if ( n >= 0 ) {
    remove_call_out( "check_breakages" );
    call_out( "check_breakages", 5 + random( 16 ) );
  }
  return 1;
#ifdef BREAK_NOW
  obs = all_inventory();
  for (i=0;i<sizeof(obs);i++)
    if ((amt = obs[i]->query_property("fragile"))) {
      if (query_loc_weight() <= amt || ((query_loc_weight() - amt)*100)/amt <= random(100))
          obs[i] = 0;
    } else
      obs[i] = 0;
  obs = obs - ({ 0 });
  if (sizeof(obs)) {
    say(this_player()->one_short()+" breaks "+
          (sizeof(obs)>1?"some things":"one thing")+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    write("You break "+query_multiple_short(obs)+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    obs->dest_me();
  }
  return 1;
#endif
}
void check_breakages() {
  object *obs, carrier;
  int i, amt, wt;
  carrier = environment(this_object());
  while (carrier && (!living(carrier))) {
    carrier = environment(carrier);
  }
  if (!carrier)
    return;
  obs = all_inventory();
  wt = query_loc_weight() - (int)query_property("padded");
  for (i=0;i<sizeof(obs);i++) {
    if ((amt = obs[i]->query_property("fragile"))) {
      if (wt <= amt || ((wt - amt)*100)/amt <= random(100)) {
          obs[i] = 0;
      }
    } else {
      obs[i] = 0;
    }
  }
  obs = obs - ({ 0 });
  if (sizeof(obs) && environment(carrier)) {
    tell_room(environment(carrier), carrier->the_short()+" breaks "+
          (sizeof(obs)>1?"some things":"one thing")+" in "+
          query_multiple_short(({ this_object() }))+".\n", ({ carrier }));
    tell_object(carrier, "You break "+query_multiple_short(obs)+" in "+
          query_multiple_short(({ this_object() }))+".\n");
    obs->dest_me();
  }
}
varargs string pretty_short( object thing ) {
   return short_status() + ::pretty_short( thing );
}
varargs string pretty_plural( object thing ) {
   return short_status() + ::pretty_plural( thing );
}
string liquid_name()
{
   string liq_name;
   mixed *names, *colours;
   string *med, *lo;
   int no_names, no_colours, i;
   names = all_attrs[POTION_NAMES];
   colours = all_attrs[POTION_COLOURS];
   no_names = (sizeof(names) < 1 || names[0][1] < VERY_SMALL_AMOUNT);
   no_colours = (sizeof(colours) < 1 || colours[0][1] < VERY_SMALL_AMOUNT);
   if (no_names && no_colours) {
      liq_name = "a colourless " +
         transparency_string(all_attrs[POTION_TRANSPARENCY]) + " " +
         consistency_string(all_attrs[POTION_CONSISTENCY]);
   } else if (no_names) {
      if (colours[0][1] < SMALL_AMOUNT) {
         liq_name = "a faint " + colours[0][0];
      } else {
         liq_name = add_a(colours[0][0]);
      }
      liq_name += " " + transparency_string(all_attrs[POTION_TRANSPARENCY]) +
                     " " + consistency_string(all_attrs[POTION_CONSISTENCY]);
      med = ({ });
      i = 1;
      while (i < sizeof(colours) && colours[i][1] >= SMALL_AMOUNT)
         med += ({ colours[i++][0] });
      lo = ({ });
      while (i < sizeof(colours) && colours[i][1] >= VERY_SMALL_AMOUNT)
         lo += ({ colours[i++][0] });
      if (sizeof(med)) {
         liq_name += " with swirls of " + query_multiple_short(med);
      }
      if (sizeof(lo)) {
         if (sizeof(med)) liq_name += " and faint streaks of " + query_multiple_short(lo);
         else liq_name += " with faint streaks of " + query_multiple_short(lo);
      }
   } else if (no_colours) {
      i = 0;
      med = ({ });
      lo = ({ });
      while (i < sizeof(names) && names[i][1] >= SMALL_AMOUNT)
         med += ({ names[i++][0] });
      while (i < sizeof(names) && names[i][1] >= VERY_SMALL_AMOUNT)
         lo += ({ names[i++][0] });
      if (sizeof(med) > 1) liq_name = "a mixture of " + query_multiple_short(med);
      else if (sizeof(med) == 1) liq_name = med[0];
      if (!sizeof(med) && sizeof(lo) > 1)
         liq_name = "a diluted mixture of " + query_multiple_short(lo);
      else if (!sizeof(med) && sizeof(lo) == 1)
         liq_name = "diluted " + lo[0];
      else if (sizeof(med) && sizeof(lo))
         liq_name += "and small quantities of " + query_multiple_short(lo);
   } else {
      if (names[0][1] > colours[0][1] / 2)
      {
         i = 0;
         med = ({ });
         lo = ({ });
         while (i < sizeof(names) && names[i][1] >= SMALL_AMOUNT)
            med += ({ names[i++][0] });
         while (i < sizeof(names) && names[i][1] >= VERY_SMALL_AMOUNT)
            lo += ({ names[i++][0] });
         if (sizeof(med) > 1) liq_name = "a mixture of " + query_multiple_short(med);
         else if (sizeof(med) == 1) liq_name = med[0];
         if (!sizeof(med) && sizeof(lo) > 1)
            liq_name = "a diluted mixture of " + query_multiple_short(lo);
         else if (!sizeof(med) && sizeof(lo) == 1)
            liq_name = "diluted " + lo[0];
         else if (sizeof(med) && sizeof(lo))
            liq_name += "and small quantities of " + query_multiple_short(lo);
         if (colours[0][1] < SMALL_AMOUNT) liq_name += " (a faint " + colours[0][0];
         else liq_name += " (" + add_a(colours[0][0]);
         liq_name += " " + transparency_string(all_attrs[POTION_TRANSPARENCY]) +
                        " " + consistency_string(all_attrs[POTION_CONSISTENCY]);
         med = ({ });
         i = 1;
         while (i < sizeof(colours) && colours[i][1] >= SMALL_AMOUNT)
            med += ({ colours[i++][0] });
         lo = ({ });
         while (i < sizeof(colours) && colours[i][1] >= VERY_SMALL_AMOUNT)
            lo += ({ colours[i++][0] });
         if (sizeof(med)) {
            liq_name += " with swirls of " + query_multiple_short(med);
         }
         if (sizeof(lo)) {
            if (sizeof(med)) liq_name += " and faint streaks of " + query_multiple_short(lo);
            else liq_name += " with faint streaks of " + query_multiple_short(lo);
         }
         liq_name += ")";
      } else {
         if (colours[0][1] < SMALL_AMOUNT) liq_name = "a faint " + colours[0][0];
         else liq_name = add_a(colours[0][0]);
         liq_name += " " + transparency_string(all_attrs[POTION_TRANSPARENCY]) +
                        " " + consistency_string(all_attrs[POTION_CONSISTENCY]);
         med = ({ });
         i = 0;
         while (i < sizeof(names) && names[i][1] >= VERY_SMALL_AMOUNT)
            med += ({ names[i++][0] });
         liq_name += " containing " + query_multiple_short(med);
         med = ({ });
         i = 1;
         while (i < sizeof(colours) && colours[i][1] >= SMALL_AMOUNT)
            med += ({ colours[i++][0] });
         lo = ({ });
         while (i < sizeof(colours) && colours[i][1] >= VERY_SMALL_AMOUNT)
            lo += ({ colours[i++][0] });
         if (sizeof(med)) {
            liq_name += " with swirls of " + query_multiple_short(med);
         }
         if (sizeof(lo)) {
            if (sizeof(med)) liq_name += " and faint streaks of " + query_multiple_short(lo);
            else liq_name += " with faint streaks of " + query_multiple_short(lo);
         }
      }
   }
   return liq_name;
}
string query_liquid_short()
{
   if (sizeof(all_attrs[POTION_NAMES]) && sizeof(all_attrs[POTION_COLOURS])) {
      if (all_attrs[POTION_NAMES][0][1] > all_attrs[POTION_COLOURS][0][1] / 2) {
         return all_attrs[POTION_NAMES][0][0];
      }
   }
   return (sizeof(all_attrs[POTION_COLOURS]) ?
           all_attrs[POTION_COLOURS][0][0] : "colourless") + " " +
             transparency_string(all_attrs[POTION_TRANSPARENCY]) + " " +
             consistency_string(all_attrs[POTION_CONSISTENCY]);
}
string long(string str, int dark) {
  string ret;
  int bing;
  ret = ::long(str, dark);
  if (query_transparent() ||
      !query_closed()) {
    if ( ( dark == 2 ) || ( dark == -2 ) ) {
       if (query_contents() != "") {
          ret += "The "+ short( dark ) +" contains some items you cannot "
                 "make out.\n";
       }
    } else {
       ret += query_contents( "The "+ short( dark ) +" contains:\n" );
    }
  }
  ret += long_status();
  if ((query_transparent() || !query_closed()) && volume) {
    if ( ( dark == 2 ) || ( dark == -2 ) ) {
      ret += "It has some liquid of some sort in it.\n";
    } else {
      bing = (volume*8 + max_volume/16)/max_volume;
      if (bing <= 0) {
        ret += "It is slightly wet from "+liquid_name()+".\n";
      } else if (bing >= 8) {
        ret += "It is full to the brim with " + liquid_name()+".\n";
      } else {
        ret += "It is " + ({ "an eighth", "a quarter",
                "three eighths", "half", "five eighths", "three quarters",
                "seven eighths" })[bing-1]+" full of "+liquid_name()+".\n";
      }
    }
  }
  return ret;
}
string *fullness_adjectives()
{
   if (!max_volume) {
      return ({ "totally", "empty" });
   }
   switch (100 * volume / max_volume) {
   case 0..4: return ({ "totally", "empty" });
   case 5..13: return ({ "empty" });
   case 65..94: return ({ "full" });
   case 95..100: return ({ "totally", "full" });
   default: return ({ });
   }
}
string *parse_command_id_list() {
  return potion_id + ::parse_command_id_list();
}
string *parse_command_adjectiv_id_list() {
  return  fullness_adjectives() + potion_adjective + ::parse_command_adjectiv_id_list();
}
int sort_func(int *x, int *y)
{
   if (x[1] < y[1]) return 1;
   else return 0;
}
mixed *mix_liq(mixed *arr1, mixed *arr2, int vol1, int vol2, int tot_vol)
{
   int i, j;
   mixed *arr3;
   arr3 = allocate(sizeof(arr1));
   for (i = 0; i < sizeof(arr1); i++) {
      arr3[i] = ({ arr1[i][0], arr1[i][1] * vol1 / tot_vol });
      for (j = 0; j < sizeof(arr2); j++) {
         if (arr2[j][0] == arr1[i][0]) {
            arr3[i][1] += arr2[j][1] * vol2 / tot_vol;
            arr2[j][1] += 100000;
            break;
         }
      }
   }
   for (i = 0; i < sizeof(arr2); i++) {
      if (arr2[i][1] >= 100000) {
         arr2[i][1] -= 100000;
      } else {
         arr3 += ({ ({ arr2[i][0], arr2[i][1] * vol2 / tot_vol }) });
      }
   }
   arr3 = sort_array(arr3, "sort_func", this_object());
   for (i = sizeof(arr3) - 1; i >= 0; i--) {
      if (arr3[i][1] > 0) break;
   }
   if (i < 0) arr3 = ({ });
   else arr3 = arr3[0..i];
   return arr3;
}
mixed *merge_potions(mixed *potion1, mixed *potion2, int vol1, int vol2, int tot_vol)
{
   mixed *result;
   result = allocate(POTION_ATTRS_SIZE);
   result[POTION_CONSISTENCY] =
      (potion1[POTION_CONSISTENCY] * vol1 +
       potion2[POTION_CONSISTENCY] * vol2) / tot_vol;
   result[POTION_TRANSPARENCY] =
      (potion1[POTION_TRANSPARENCY] * vol1 +
       potion2[POTION_TRANSPARENCY] * vol2) / tot_vol;
   result[POTION_NAMES] = mix_liq(potion1[POTION_NAMES], potion2[POTION_NAMES],
                                  vol1, vol2, tot_vol);
   result[POTION_COLOURS] = mix_liq(potion1[POTION_COLOURS], potion2[POTION_COLOURS],
                                  vol1, vol2, tot_vol);
   result[POTION_FLAVOURS] = mix_liq(potion1[POTION_FLAVOURS], potion2[POTION_FLAVOURS],
                                  vol1, vol2, tot_vol);
   result[POTION_SMELLS] = mix_liq(potion1[POTION_SMELLS], potion2[POTION_SMELLS],
                                  vol1, vol2, tot_vol);
   return result;
}
void set_misc_attrs(mixed *new_misc_attrs, int misc_vol)
{
   misc_attrs = new_misc_attrs + ({ });
   volume = water + misc_vol;
   all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
   update_potion_parse();
   if (leak_rate) set_heart_beat(1);
}
mixed *change_concentration(mixed *potion, int new_conc)
{
   mixed *newpotion;
   int i;
   newpotion = potion + ({ });
   newpotion[POTION_CONSISTENCY] = newpotion[POTION_CONSISTENCY] * new_conc / 100;
   newpotion[POTION_TRANSPARENCY] =
      (100 - (100 - newpotion[POTION_TRANSPARENCY]) * new_conc / 100);
   for (i = 0; i < sizeof(newpotion[POTION_NAMES]); i++) {
      newpotion[POTION_NAMES][i][1] = newpotion[POTION_NAMES][i][1] * new_conc / 100;
   }
   for (i = 0; i < sizeof(newpotion[POTION_COLOURS]); i++) {
      newpotion[POTION_COLOURS][i][1] = newpotion[POTION_COLOURS][i][1] * new_conc / 100;
   }
   for (i = 0; i < sizeof(newpotion[POTION_SMELLS]); i++) {
      newpotion[POTION_SMELLS][i][1] = newpotion[POTION_SMELLS][i][1] * new_conc / 100;
   }
   for (i = 0; i < sizeof(newpotion[POTION_FLAVOURS]); i++) {
      newpotion[POTION_FLAVOURS][i][1] = newpotion[POTION_FLAVOURS][i][1] * new_conc / 100;
   }
   return newpotion;
}
void set_ps_coord_quantity(int *new_coord, int new_quantity)
{
   mixed *ps_attrs;
   ps_attrs = (mixed *)POTION_SPACE_HANDLER->query_attrs_at(new_coord);
   active_attrs = change_concentration(ps_attrs, new_quantity * 100 / water);
   ps_quantity = new_quantity;
   ps_coord = new_coord;
   all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
   update_potion_parse();
   (void)POTION_SPACE_HANDLER->potion_create(this_object(), new_coord, new_quantity);
}
void begin_config()
{
   potion_id = allocate(9);
   ps_coord = allocate(9);
}
void config(int vari, mixed cont)
{
   potion_id[vari] = cont;
   ps_coord[vari] = 1;
}
void end_config()
{
   mixed *ps_attrs;
   if (ps_coord[OC_VOL]) {
      volume = potion_id[OC_VOL];
      if (ps_coord[OC_MVOL]) water = volume - potion_id[OC_MVOL];
      else water = potion_id[OC_WVOL];
   } else {
      water = potion_id[OC_WVOL];
      volume = water + potion_id[OC_MVOL];
   }
   leak_rate = potion_id[OC_LEAKRATE];
   if (leak_rate && volume) set_heart_beat(1);
   if (ps_coord[OC_MAXVOL]) max_volume = potion_id[OC_MAXVOL];
   else max_volume = volume;
   ps_quantity = potion_id[OC_PSQUANT];
   if (ps_coord[OC_MISCATTRS]) misc_attrs = potion_id[OC_MISCATTRS];
   else misc_attrs = ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
   if (ps_coord[OC_PSCOORD]) ps_coord = potion_id[OC_PSCOORD];
   else ps_coord = ({ 0, 0 });
   ps_attrs = (mixed *)POTION_SPACE_HANDLER->query_attrs_at(ps_coord);
   active_attrs = change_concentration(ps_attrs, ps_quantity * 100 / water);
   all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
   update_potion_parse();
   (void)POTION_SPACE_HANDLER->potion_create(this_object(), ps_coord, ps_quantity);
}
mixed stats() {
  return container::stats() + close_lock_container::stats() + ({
    ({ "ps_quantity", query_ps_quantity() }),
   ({ "ps_coord", (pointerp(ps_coord) && sizeof(ps_coord) == 2) ?
      "({ " + ps_coord[0] + ", " + ps_coord[1] + " })" :
      sprintf("%O", ps_coord) }),
    ({ "volume", query_volume() + "" }),
    ({ "max volume", query_max_volume() }),
    ({ "water vol", query_water_volume() }),
    ({ "volume left", query_volume_left() }),
    ({ "weight left", query_weight_left() }),
    ({ "full_weight", query_full_weight(), }),
    ({ "leak_rate", query_leak_rate() + "" }),
  });
}
object query_parse_id(mixed *arr) {
  volume_to_womble = 0;
  return ::query_parse_id(arr);
}
object query_frac_parse_id(mixed *arr) {
  int i;
  volume_to_womble = 0;
  if (arr[P_THING] < 0) {
    arr[P_THING]++;
    if (arr[P_THING] != 0)
      return 0;
    volume_to_womble = volume*arr[P_TOP]/arr[P_BOT];
    call_out("set_volume_to_womble", 0, 0);
    arr[P_THING] = -1784628;
    return this_object();
  }
  if (arr[P_THING] == 0)
    if ((i=(arr[P_MAX_NUM]*arr[P_TOP])/arr[P_BOT]) > arr[P_CUR_NUM]++)
      return this_object();
    else
      if (i+1 == arr[P_CUR_NUM]) {
        volume_to_womble = volume*arr[P_TOP]/arr[P_BOT];
        call_out("set_volume_to_womble", 0, 0);
        return this_object();
      }
  else
    return 0;
  if ((i=(arr[P_THING]*arr[P_TOP])/arr[P_BOT]) > arr[P_CUR_NUM]++)
    return this_object();
  else
    if (i+1 == arr[P_CUR_NUM]) {
      volume_to_womble = volume*arr[P_TOP]/arr[P_BOT];
      call_out("set_volume_to_womble", 0, 0);
      return this_object();
    }
  return 0;
}
int remove_volume(int vol_lost)
{
   int q_lost;
   if (!volume) {
      q_lost = ps_quantity;
      water = 0;
      ps_quantity = 0;
      return q_lost;
   }
   q_lost = ps_quantity * vol_lost / volume;
   water -= water * vol_lost / volume;
   volume -= vol_lost;
   ps_quantity -= q_lost;
   return q_lost;
}
void heart_beat() {
  int lost, off;
   if (leak_rate == 0 || volume <= 0) {
      set_heart_beat(0);
      return;
   }
  if (hb_count--) return ;
  hb_count = 10;
  lost = leak_rate;
  if (lost > volume)
    lost = volume;
  off = lost/100;
  if (off > 10)
    off = 10;
  tell_room(environment(),
            capitalize(query_liquid_short())+({ " drips slowly",
                               " drips",
                               " dribbles",
                               " trickles slowly",
                               " trickles",
                               " trickles rapidly",
                               " pours sluggishly",
                               " pours",
                               " streams",
                               " gushes",
                               " fountains", })[off]+" out of the "+
                                                          short(1)+".\n");
  (void)remove_volume(lost);
  if (!volume) {
    set_heart_beat(0);
    void_liquid();
  }
}
void transfer_liquid_to(object dest, int vol_misc, mixed *misc,
                                     int vol_water, int *coord, int quantity)
{
   mixed *their_attrs;
   int their_vol, their_water, their_quantity, new_quantity, new_misc_vol;
   int *new_coord, *old_coord;
   their_attrs = (mixed *)dest->query_misc_attrs();
   their_vol = (int)dest->query_volume();
   their_water = (int)dest->query_water_volume();
   their_quantity = (int)dest->query_ps_quantity();
   new_quantity = quantity + their_quantity;
   if (!their_attrs)
      return ;
   new_misc_vol = vol_misc + their_vol - their_water;
   (void)dest->set_water_volume(their_water + vol_water);
   if (new_misc_vol) {
      their_attrs = merge_potions(misc_attrs, their_attrs,
                               vol_misc, their_vol - their_water,
                               new_misc_vol);
      (void)dest->set_misc_attrs(their_attrs, new_misc_vol);
   } else
      (void)dest->set_volume(their_water + vol_water);
   old_coord = (int *)dest->query_ps_coord();
   new_coord = allocate(2);
   if (pointerp(ps_coord) && new_quantity) {
      new_coord[0] = (ps_coord[0] * quantity + old_coord[0] * their_quantity) /
                     new_quantity;
      new_coord[1] = (ps_coord[1] * quantity + old_coord[1] * their_quantity) /
                     new_quantity;
      dest->set_ps_coord_quantity(new_coord, new_quantity);
   }
}
int ensure_open()
{
   if (query_locked()) {
      write("The " + short(1) + " is locked.\n");
      return 0;
   }
   if (query_closed())
      if (do_open()) {
         write("You open the "+short(1)+".\n");
         return 1;
      } else {
         write("You can't open the " + short(1) + ".\n");
         return 0;
      }
   return 1;
}
int do_pour(object *dest, string me, string him, string prep)
{
   int amount_poured, volume_transferred, old_water, old_volume;
   string liquid_desc;
   if (sizeof(dest) > 1) {
      write("Currently you can only pour into one object\n");
      return 0;
   }
   if (!ensure_open()) return 0;
   if (volume <= 0) {
      write("The " + short(0) + " you are trying to pour out of is empty.\n");
      return 0;
   }
   old_water = water;
   old_volume = volume;
   liquid_desc = query_liquid_short();
   if (volume_to_womble && volume_to_womble <= empty_formula())
      volume_transferred = volume_to_womble;
   else
      volume_transferred = empty_formula();
   amount_poured = remove_volume(volume_transferred);
   if (volume_transferred > dest[0]->query_volume_left()) {
      say(this_player()->short(0) + " attempts to pour from " + add_a(short(0))
         + " into " + add_a(dest[0]->short(0)) + " but ends up spilling "
         + liquid_desc + " all over the ground.\n");
      write(capitalize(liquid_desc) + " spills on the floor as you try to pour "
         + "from the " + short(0) + " into the " + dest[0]->short(0) + ".\n");
      amount_poured = (amount_poured * ((int)dest[0]->query_volume_left())) /
                         volume_transferred;
      volume_transferred = (int)dest[0]->query_volume_left();
   }
   transfer_liquid_to(dest[0], volume_transferred * (old_volume - old_water) / old_volume,
      misc_attrs, volume_transferred * old_water / old_volume, ps_coord, amount_poured);
   this_player()->add_succeeded(dest[0]);
   return 1;
}
int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {
   int m, n, i, run_out, volume_needed, their_volume, their_max,
       amount_poured, ok;
   if (intp(args[1]) && intp(args[2])) {
      m = args[0];
      n = args[1];
      if (m > n || m < 0 || n <= 0) {
         notify_fail("Interesting fraction you have there!\n");
         return 0;
      }
   } else {
      m = 1;
      n = 1;
   }
   if (query_locked()) {
      notify_fail("The " + short(0) + " is locked!\n");
      return 0;
   }
   if (query_closed()) {
      if (do_open()) {
         write("You open the " + short(0) + ".\n");
      } else {
         write("You cannot open the " + short(0) + ".\n");
         return 0;
      }
   }
   if (volume <= 0) {
      write("The " + short(0) + " is bone dry!\n");
      return 0;
   }
   run_out = 0;
   for (i = 0; i < sizeof(to) && !run_out; i++) {
      their_volume = (int)to[i]->query_volume();
      their_max = (int)to[i]->query_max_volume();
      if (their_max <= 0) {
         write("The " + to[i]->short(0) +
               " doesn't look like it can be filled!\n");
         continue;
      }
      if (their_volume >= their_max) {
         write("The " + to[i]->short(0) + " is full to the brim already.\n");
         continue;
      }
      volume_needed = their_max * m / n;
      if (their_volume >= volume_needed) {
         write("The " + to[i]->short(0) + " is more than " + m + "/" + n +
           " full already.\n");
         continue;
      }
      ok++;
      volume_needed -= their_volume;
      if (volume_needed > empty_formula()) {
         write("You drain the " + short(0) + " into the " + to[i]->short(0) +
            " but it is not enough.\n");
         volume_needed = empty_formula();
         run_out = 1;
         this_player()->add_succeeded(to[i]);
      } else {
         this_player()->add_succeeded(to[i]);
      }
      amount_poured = volume_needed * ps_quantity / volume;
      transfer_liquid_to(to[i], volume_needed * (volume - water) / volume,
         misc_attrs, volume_needed * water / volume, ps_coord, amount_poured);
      amount_poured = remove_volume(volume_needed);
   }
   return ok;
}
int do_drink(object *dest, string me, string him, string prep)
{
   int amount_drunk, amount_can_be_drunk;
   if (sizeof(dest)) {
      write("Drinking is a very simple operation - please don't complicate matters.\n");
      return 0;
   }
   if (!ensure_open()) return 0;
   if (volume <= 0) {
      write("The " + short(0) + " is bone dry!\n");
      return 0;
   }
   amount_can_be_drunk = (2000 - (int)this_player()->query_volume(2)) *
      (int)this_player()->query_con() / 12;
   if (!volume_to_womble) volume_to_womble = empty_formula();
   if (volume_to_womble > empty_formula()) volume_to_womble = empty_formula();
   if (volume_to_womble > amount_can_be_drunk) {
      write("You drink some of the liquid, but simply cannot fit it all in.\n");
      volume_to_womble = amount_can_be_drunk;
   }
   amount_drunk = remove_volume(volume_to_womble);
   (void)POTION_SPACE_HANDLER->potion_drunk(this_player(), ps_coord, amount_drunk);
   this_player()->adjust_volume(2, volume_to_womble * 12 /
      (int)this_player()->query_con());
   switch ((this_player()->query_volume(2) + 100) / 200) {
   case 5:
      write("You feel mildly full of liquid.\n");
      break;
   case 6:
      write("You feel very full of liquid.\n");
      break;
   case 7:
      write("You feel pissed.\n");
      break;
   case 8:
      write("You are awash with liquid.\n");
      break;
   case 9:
      write("You are full to the brim with liquid.\n");
      break;
   case 10:
      write("You feel you would burst if you drank any more.\n");
      break;
   }
   return 1;
}
int do_empty(object *dest, string me, string him, string prep)
{
   if (sizeof(dest)) {
      write("Passing on to pour ... bad move.\n");
      return do_pour(dest, me, him, prep);
   }
   if (!ensure_open()) { write("It aint open!\n"); return 0; }
   if (volume == 0) {
      write("The " + short(0) + " is already empty.\n");
      return 0;
   }
   if (volume_to_womble && volume_to_womble <= empty_formula())
      (void)remove_volume(volume_to_womble);
   else
      (void)remove_volume(empty_formula());
   return 1;
}
int do_splash(object *dest, string me, string him, string prep) {
   int amount_splashed;
   if (sizeof(dest) > 1) {
      write("You can only splash one object at a time.\n");
      return 0;
   }
   if (!sizeof(dest))
     return 0;
   if (!ensure_open()) return 0;
   if (volume_to_womble && volume_to_womble <= empty_formula())
      amount_splashed = remove_volume(volume_to_womble);
   else
      amount_splashed = remove_volume(empty_formula());
   (void)POTION_SPACE_HANDLER->potion_touch(dest[0], ps_coord, amount_splashed);
   (void)this_player()->add_succeeded(dest[0]);
   return 1;
}
int do_rub(object *dest, string me, string him, string prep) {
   int amount_rubbed;
   if (sizeof(dest) > 1) {
      write("You can only "+query_verb()+" on to one object at a time.\n");
      return 0;
   }
   if (!sizeof(dest))
     return 0;
   if (environment(dest[0]) != this_player()) {
      write("You can only "+query_verb()+" on to an object in your inventory.\n");
      return 0;
   }
   if (!ensure_open()) return 0;
   if (volume_to_womble && volume_to_womble <= empty_formula())
      amount_rubbed = remove_volume(volume_to_womble);
   else
      amount_rubbed = remove_volume(empty_formula());
   (void)POTION_SPACE_HANDLER->potion_touch(dest[0], ps_coord, amount_rubbed);
   (void)this_player()->add_succeeded(dest[0]);
   return 1;
}
void do_apply(object *dest, string me, string him, string prep ) {
   do_rub( dest, me, him, prep );
}
#define TASTE_AMOUNT 5
int do_taste() {
   int amount_tasted;
   string desc;
   mixed *group;
   int i;
   if (!ensure_open()) return 0;
   if (volume < TASTE_AMOUNT) {
      write("There is no liquid to taste.\n");
      return 0;
   }
   desc = "The " + query_liquid_short();
   if (!sizeof(all_attrs[POTION_FLAVOURS]) ||
     all_attrs[POTION_FLAVOURS][0][1] < VERY_SMALL_AMOUNT)
      desc += " has no discernible flavour";
   else {
      group = ({ });
      for (i = 0; i < sizeof(all_attrs[POTION_FLAVOURS]) &&
           all_attrs[POTION_FLAVOURS][i][1] >= SMALL_AMOUNT; i++)
         group += all_attrs[POTION_FLAVOURS][i][0..0];
      if (sizeof(group)) {
         desc += " tastes of " + query_multiple_short(group);
         if (i < sizeof(all_attrs[POTION_FLAVOURS]) &&
             all_attrs[POTION_FLAVOURS][i][1] >= VERY_SMALL_AMOUNT)
            desc += " with a faint hint of ";
      } else desc += " tastes faintly of ";
      group = ({ });
      for (; i < sizeof(all_attrs[POTION_FLAVOURS]) &&
           all_attrs[POTION_FLAVOURS][i][1] >= VERY_SMALL_AMOUNT; i++)
         group += all_attrs[POTION_FLAVOURS][i][0..0];
      if (sizeof(group)) desc += query_multiple_short(group);
   }
   write(desc + ".\n");
   say(this_player()->one_short() + " takes a small sip from the " +
       short(0) + ".\n");
   amount_tasted = remove_volume(TASTE_AMOUNT);
   (void)POTION_SPACE_HANDLER->potion_drunk(this_player(), ps_coord, TASTE_AMOUNT);
   return 1;
}
int do_smell()
{
   string desc;
   string *group;
   int i;
   if (!ensure_open()) return 0;
   if (volume < 1) {
      write("There is no liquid to smell.\n");
      return 0;
   }
   desc = "The " + query_liquid_short();
   if (!sizeof(all_attrs[POTION_SMELLS]) ||
     all_attrs[POTION_SMELLS][0][1] < VERY_SMALL_AMOUNT)
      desc += " has no distinct aroma";
   else {
      group = ({ });
      for (i = 0; i < sizeof(all_attrs[POTION_SMELLS]) &&
           all_attrs[POTION_SMELLS][i][1] >= SMALL_AMOUNT; i++)
         group += all_attrs[POTION_SMELLS][i][0..0];
      if (sizeof(group)) {
         desc += " smells of " + query_multiple_short(group);
         if (i < sizeof(all_attrs[POTION_SMELLS]) &&
             all_attrs[POTION_SMELLS][i][1] >= VERY_SMALL_AMOUNT)
            desc += " with a faint hint of ";
      } else desc += " smells faintly of ";
      group = ({ });
      for (; i < sizeof(all_attrs[POTION_SMELLS]) &&
           all_attrs[POTION_SMELLS][i][1] >= VERY_SMALL_AMOUNT; i++)
         group += all_attrs[POTION_SMELLS][i][0..0];
      if (sizeof(group)) desc += query_multiple_short(group);
   }
   write(desc + ".\n");
   say(this_player()->one_short() + " takes a whiff of the " +
       short(0) + ".\n");
   (void)POTION_SPACE_HANDLER->potion_smell(this_player(), ps_coord, ps_quantity * 100 / volume);
   return 1;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
            "leak rate" : leak_rate,
            "full weight" : full_weight,
            "trans" : query_transparent(),
            "difficulty" : query_difficulty(),
            "key" : query_key(),
            "trap open func" : query_open_trap_func(),
            "trap lock func" : query_lock_trap_func(),
            "trap open ob" : query_open_trap_ob(),
            "trap lock ob" : query_lock_trap_ob(),
            "max volume" : max_volume,
          ]);
}
mapping query_dynamic_auto_load() {
  if (!query_name() || query_name() == "object") {
    return 0;
  }
  return ([
           "::" : ::query_dynamic_auto_load(),
           "locked" : query_locked(),
           "stuck" : query_stuck(),
           "closed" : query_closed(),
           "volume" : volume,
           "water" : water,
           "misc attrs" : misc_attrs,
           "ps coord" : ps_coord,
           "ps quantity" : ps_quantity,
          ]);
}
void init_dynamic_arg(mapping map) {
  mixed *ps_attrs;
  object money;
  if (map["::"])
    ::init_dynamic_arg(map["::"]);
  if (sizeof(map["money"])) {
     money = clone_object("/obj/money");
     money->set_money_array(map["money"]);
     money->move(this_object());
  }
  if (map["locked"]) {
     set_locked();
  } else {
     set_unlocked();
  }
  set_stuck(map["stuck"]);
  if (map["closed"]) {
     set_closed();
  } else {
     set_open();
  }
  volume = map["volume"];
  set_water_volume(map["water"]);
  if (volume == 0) {
    void_liquid();
    update_potion_parse();
    return;
  }
  misc_attrs = map["misc attrs"];
  ps_quantity = map["ps quantity"];
  ps_coord = map["ps coord"];
  ps_attrs = (mixed *)POTION_SPACE_HANDLER->query_attrs_at(ps_coord);
  if(!water) water = 1;
  active_attrs = change_concentration(ps_attrs, ps_quantity * 100 / water);
  all_attrs = merge_potions(active_attrs, misc_attrs, water, volume - water, volume);
  update_potion_parse();
}
void init_static_arg(mapping args) {
  if (args["::"]) {
    ::init_static_arg(args["::"]);
  }
  if (!undefinedp(args["leak rate"])) {
    leak_rate = args["leak rate"];
  }
  if (!undefinedp(args["full weight"])) {
    full_weight = args["full weight"];
  }
  if (!undefinedp(args["trans"])) {
    if (args["trans"]) {
       set_transparent();
    } else {
       set_opaque();
    }
  }
  if (!undefinedp(args["difficulty"])) {
    set_difficulty(args["difficulty"]);
  }
  if (!undefinedp(args["key"])) {
    set_key(args["key"]);
  }
  if (!undefinedp(args["trap open func"])) {
    set_open_trap(args["trap open ob"], args["trap open func"]);
  }
  if (!undefinedp(args["trap lock func"])) {
    set_lock_trap(args["trap lock ob"], args["trap lock func"]);
  }
  if (!undefinedp(args["max volume"])) {
    max_volume = args["max volume"];
  }
}
mixed query_static_auto_load() {
  if (!query_name() || query_name() == "object") return 0;
  if (file_name(this_object())[0..13] == "/obj/container")
    return int_query_static_auto_load();
  return ([ ]);
}
int test_add(object ob, int flag) {
  return !query_closed() && !flag;
}
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   return ::can_find_match_recurse_into(looker);
}
int test_remove(object ob, int flag) { return !query_closed(); }
varargs int move(mixed dest, string messin, string messout) {
   int result;
   object from;
   object to;
   from = environment();
   result = ::move(dest, messin, messout);
   if (result == MOVE_OK) {
      to = environment();
      we_moved(from, to);
   }
   return result;
}
void dest_me() {
   close_lock_container::dest_me();
   container::dest_me();
}

==================================================
FILE: corpse.c
==================================================

#include <bit.h>
#include <corpse.h>
#include <move_failures.h>
#define DECAY_BASE 200
#define PLAYER_DECAY_BASE 600
#define RANDOM( x ) x[ random( sizeof( x ) ) ]
inherit "/std/container";
inherit "/std/living/carrying";
inherit "/std/basic/virtual_quit_control";
private int _decay;
private int _corpse_id;
private string _owner;
private string _race_ob;
private string _race_name;
private string *_bits_gone;
private string *_removed;
private string *_permitted;
private object _weapon;
private object *_armours;
private object *_holding;
private string _start_pos;
private string _nationality;
void set_decay_messages();
void remove_creator_corpse( object ob );
void set_race_ob(string _race_ob);
int query_corpse() {
  return 1;
}
int query_corpse_id() {
   return _corpse_id;
}
int query_decay() {
  return _decay;
}
void set_decay(int dec) {
  _decay = dec;
}
string query_owner() {
  return _owner;
}
string *query_permitted() {
  return _permitted;
}
void set_race_name(string str) {
  _race_name = str;
}
string query_race_name() {
  return _race_name;
}
object make_bit(string which_bit);
object *make_bits(string *what_bits);
void give_permission(string);
string query_name() {
  if (!::query_name())
    return "someone";
  return::query_name();
}
string *remove_array_parts(string *a1,
                           string *a2) {
  int i;
  string a;
  if (sizeof(a2))
    foreach(a in a2) {
    for (i = 0; i < sizeof(a1); i++) {
      if (a == a1[i]) {
        a1 = delete(a1, i, 1);
        break;
      }
    }
  }
  return a1;
}
void setup() {
  _bits_gone = ({ });
  _removed = ({ });
  add_property("cureable", 1);
  add_property("determinate", "the ");
  _owner = "noone";
  _race_name = "womble";
  _decay = DECAY_BASE;
  add_plural("corpses");
  add_plural("bodies");
  add_plural("carcasses");
  add_alias(({ "corpse", "body", "carcass" }));
  set_short("corpse");
  set_long("A corpse, it looks dead.\n");
  set_weight(STD_CORPSE_WEIGHT);
  set_race_ob("/std/races/unknown");
  _permitted = ({ });
  _armours = ({ });
  _holding = ({ });
  add_extra_look(this_object());
}
string extra_look() {
  if(sizeof(_removed))
    return "It appears to be missing its " + query_multiple_short(_removed) +
      ".\n";
  return "";
}
void give_permission(string words) {
  _permitted += ({ words });
}
int get(mixed dest) {
  if (query_property("player") && dest) {
    if (!this_player())
      return::get(dest);
    if (member_array((string) this_player()->query_name(), _permitted) ==
        -1)
      return MOVE_INVALID_DEST;
  }
  return::get(dest);
}
int test_remove(object thing,
                int flag,
                mixed dest) {
  int i;
  if (base_name(environment()) == "/room/rubbish") {
    return 1;
  }
  if (thing->query_property("my corpse") == this_object()) {
    return 1;
  }
  if (!query_property("player")) {
    return 1;
  }
  if (!sizeof(_permitted) || !this_player()) {
    i =::test_remove(thing, flag, dest);
  } else if (member_array((string) this_player()->query_name(), _permitted) ==
             -1) {
    i =::test_remove(thing, flag, dest);
  } else {
    write((string) thing->the_short() + " $V$0=buzzes,buzz$V$ for a "
          "moment.\n");
    return 1;
  }
  if (i && this_player() && thing &&
      sizeof(thing->effects_matching("mudlib.owned.weapon")) &&
      this_player()->query_name() != thing->query_owner() &&
      member_array((string) this_player()->query_name(), _permitted) == -1) {
    log_file("LOOT", "%s %s took %s [%s] from %s.\n",
             ctime(time()), this_player()->query_cap_name(),
             thing->query_short(), thing->query_owner(),
             this_object()->query_owner());
  }
  if (i) {
     CORPSE_HANDLER->save_corpse(this_object());
  }
  return i;
}
string long(string words,
            int dark) {
  if (dark == 2 || dark == -2) {
    if (query_living_contents(0) != "") {
      return::long(words, dark) + "Carrying, wearing or holding some "
        "things you cannot make out.\n";
    }
  }
  return::long(words, dark) + query_living_contents(0);
}
void set_owner(string words, object thing) {
  string det;
  string *tmp;
  if (stringp(words)) {
    _owner = words;
  } else {
    det = (string) thing->query_property("determinate");
    if (stringp(det)) {
      _owner = det + (string) thing->short();
    } else {
      _owner = add_a((string) thing->short());
    }
  }
  if (thing && thing->query_property("player")) {
    set_decay(PLAYER_DECAY_BASE);
    give_permission(thing->query_name());
    catch(_corpse_id = CORPSE_HANDLER->query_next_corpse_id());
    _start_pos = thing->query_start_pos();
    set_ownership(thing->query_name());
    add_property("player", 1);
  }
  set_name("corpse");
  set_short("corpse of " + _owner);
  add_adjective(({ "corpse", "of" }));
  tmp = explode(lower_case(_owner), " ");
  if (sizeof(tmp) > 1) {
    add_alias(tmp[<1]);
  }
  add_adjective(tmp);
  add_adjective(tmp[<1] + "'s");
  if (thing) {
     _nationality = thing->query_nationality();
    if(userp(thing)) {
      set_main_plural("corpses of " + thing->short());
    } else  if (thing->query_main_plural() && !userp(thing)) {
      set_main_plural("corpses of " + (string) thing->query_main_plural());
    } else {
      set_main_plural("corpses of " + pluralize((string) thing->short()));
    }
  } else {
    set_main_plural("corpses");
  }
  set_long("This is the dead body of " + _owner + ".\n");
  if (thing && thing->query_weight(1)) {
    set_weight((int) thing->query_weight(1));
  } else {
    set_weight(STD_CORPSE_WEIGHT);
  }
  if ( thing && ( thing->query_creator() ||
    thing->query_property( "test character" ) ) )
  remove_creator_corpse( thing );
  BIT_CONTROLLER->add_bit(this_object());
  if (thing && thing->query_property("player")) {
    catch(CORPSE_HANDLER->register_corpse(this_object()));
  }
}
void remove_creator_corpse( object ob ) {
  call_out( (: move( "/room/morgue", "$N lands in the room with a thud. The kind of thud a "
      "sack of steaks dropped from a great height would make.\n", "" ) :), 6 );
  call_out( (: tell_room( environment( $(ob) ), "squeeek THUMP squeeeek THUMP "
    "squeeek THUMP squeeeek THUMP\n" ) :), 1 );
  call_out( (: tell_room( environment( $(ob) ), "An igor pushing an old and "
    "battered wheelbarrow appears from somewhere.\n" ) :), 2 );
  call_out( (: tell_room( environment( $(ob) ), "%^CYAN%^The igor says \"Well bugger "
    "me. I've been wanting another one "
    "of those. The mathter will be so pleased.\"%^RESET%^\n" ) :), 4 );
  call_out( (: tell_room( environment( $(ob) ), "Igor cuts something off the corpse"
    " and stuffs it in his pocket before throwing the remains of the corpse into "
  "his barrow and shuffling away. \n" ) :), 6 );
  call_out( (: CORPSE_HANDLER->save_corpse(this_object()) :), 8 );
  return;
}
void do_decay() {
  int rate;
  if (!environment()) {
    return;
  }
  rate = 5 + (int) (environment()->query_property("decay rate"));
  if (rate > 0) {
    _decay -= rate;
  }
  set_decay_messages();
  if (_decay > 0) {
    CORPSE_HANDLER->save_corpse(this_object());
  }
}
void set_decay_messages() {
  if (!_race_name) {
    _race_name = (string) _race_ob->query_name();
  }
  switch (_decay) {
  case 101..PLAYER_DECAY_BASE:
    break;
  case 51..100:
    if (!find_player(query_name())) {
      set_short("somewhat decayed remains of " + add_a(query_name()));
      set_main_plural("somewhat decayed remains of " +
                      pluralize(query_name()));
    }
    break;
  case 1..50:
    set_short("decayed remains of " + add_a(_race_name));
    set_main_plural("decayed remains of " + pluralize(_race_name));
    set_long("This is the dead body of " + add_a(_race_name) + ".\n");
    break;
  default:
    CORPSE_HANDLER->deregister_corpse(this_object());
    set_ownership(0);
    all_inventory()->move(environment());
    move("/room/rubbish");
  }
}
void set_race_ob(string s) {
  _race_ob = s;
}
string query_race_ob() {
  return _race_ob;
}
string query_bit_left(string s) {
  string *bits;
  bits = _race_ob->query_possible_bits(s);
  if (!bits || !sizeof(bits)) {
    return 0;
  }
  bits = remove_array_parts(bits, _bits_gone);
  if (!sizeof(bits)) {
    return 0;
  }
  return bits[0];
}
string *query_bit_left_pl(string s) {
  string *bits;
  bits = _race_ob->query_possible_plural_bits(s);
  if (!bits || !sizeof(bits)) {
    return 0;
  }
  bits = remove_array_parts(bits, _bits_gone);
  if (!sizeof(bits)) {
    return 0;
  }
  return bits;
}
string *query_edible_bits_left() {
  string *bits;
  string *inedible;
  bits = _race_ob->query_possible_bits();
  inedible = _race_ob->query_all_inedible();
  if (!bits || !inedible) {
    return ({ });
  }
  return remove_array_parts(bits, _bits_gone) - inedible;
}
varargs object *find_inv_match(string s,
                               object looker) {
  string bit;
  string *bits;
  object *weap;
  object wep;
  int cut;
  if (undefinedp(s)) {
    return all_inventory();
  }
  bit = query_bit_left(s);
  bits = query_bit_left_pl(s);
  if (!bit && !sizeof(bits)) {
    return all_inventory();
  }
  cut = 0;
  if (looker) {
    weap = looker->query_weapons();
  }
  if (sizeof(weap)) {
    foreach(wep in weap) {
      if (wep->id("dagger") || wep->id("knife")) {
        cut = 1;
      }
    }
  }
  if (bit) {
    if (cut || _race_ob->query_pluckable(bit)) {
      return ({ make_bit(bit) });
    }
    if (sizeof(weap)) {
      tell_object(looker, "You can only cut things from a corpse "
                  "with a knife or dagger.\n");
    } else {
      tell_object(looker, "You can't cut bits from a corpse with your "
                  "bare hands.\n");
    }
    return ({ });
  }
  if (sizeof(bits)) {
    if (cut) {
      if (sizeof(bits) > 5) {
        return make_bits(bits[0..4]);
      } else {
        return make_bits(bits);
      }
    }
    foreach(bit in bits) {
      if (!((string) _race_ob->query_pluckable(bit))) {
        bits -= ({ bit });
      }
    }
    if (sizeof(bits)) {
      if (sizeof(bits) > 5) {
        return make_bits(bits[0..4]);
      } else {
        return make_bits(bits);
      }
    }
    if (sizeof(weap)) {
      tell_object(looker, "You can only cut things from a corpse "
                  "with a knife or dagger.\n");
    } else {
      tell_object(looker, "You can't cut bits from a corpse with your "
                  "bare hands.\n");
    }
    return ({ });
  }
}
object make_bit(string which_bit) {
  mixed *bit;
  object bitobj;
  bit = _race_ob->query_bit(which_bit);
  if ((sizeof(bit[2][2]) > 1) && stringp(bit[2][2][0])) {
    bitobj = clone_object(bit[2][2][0]);
  } else {
    bitobj = clone_object("/std/bit");
  }
  bitobj->set_race_ob(_race_ob);
  if (_race_name) {
    bitobj->set_race_name(_race_name);
  } else {
    bitobj->set_race_name(_race_ob->query_name());
  }
  bitobj->set_corpse_weight(query_weight());
  if (!_race_ob->query_eat(bit[BIT_NAME])) {
    bitobj->set_bit(bit[0], 0);
  } else {
    bitobj->set_bit(bit[0], (_decay * 2) / 3);
  }
  _bits_gone |= bit[BIT_EXTRA][3..] + ({ bit[BIT_NAME] });
  _removed += ({ bit[BIT_NAME] });
  if (which_bit == "head") {
    set_short("decapitated corpse of " + _owner);
    add_adjective("decapitated");
  }
  if (bitobj->move(this_object()) != MOVE_OK) {
    if (environment()) {
      bitobj->move(environment());
    }
  }
  bitobj->add_property("my corpse", this_object());
  return bitobj;
}
object *make_bits(string *what_bits) {
  string bit;
  object *bits = ({
  });
  foreach(bit in what_bits) {
    bits += ({ make_bit(bit) });
  }
  return bits;
}
string *query_bits_gone() {
  return _bits_gone;
}
mixed *add_bit_gone(string bit) {
  string *poss_bits;
  string tempbit;
  mixed *bit_details;
  poss_bits =
    remove_array_parts(_race_ob->query_possible_bits(bit), _bits_gone);
  if (!sizeof(poss_bits)) {
    return 0;
  }
  bit_details = _race_ob->query_bit(poss_bits[0]);
  _bits_gone += ({ bit_details[BIT_NAME] });
  foreach(tempbit in
          bit_details[BIT_EXTRA][3..sizeof(bit_details[BIT_EXTRA])]) {
    _bits_gone += ({ tempbit });
  }
  return bit_details;
}
void set_bits_gone(string *bits) {
  int i;
  _bits_gone = ({ });
  for (i = 0; i < sizeof(bits); i++) {
    add_bit_gone(bits[i]);
  }
}
string *query_bits_left() {
  int i;
  int j;
  string *all_bits;
  mixed *bits;
  bits = _race_ob->query_bits();
  all_bits = ({ });
  for (i = 0; i < sizeof(bits); i += 3) {
    if (bits[i + 2][2]) {
      for (j = 0; j < bits[i + 2][2][1]; j++) {
        all_bits += ({ bits[i] });
      }
    }
  }
  return remove_array_parts(all_bits, _bits_gone);
}
object *query_armours() {
  int i;
  _armours -= ({ 0 });
  for (i = 0; i < sizeof(_armours); i++) {
    if ((object) _armours[i]->query_worn_by() != this_object()) {
      _armours = delete(_armours, i, 1);
      i--;
    }
  }
  return _armours + ({ });
}
object *query_wearing() {
  return query_armours();
}
void set_armours(object * things) {
  int i;
  _armours = ({ });
  for (i = 0; i < sizeof(things); i++) {
    if (things[i]->query_no_limbs()) {
      _holding += ({ things[i] });
    } else {
      _armours += ({ things[i] });
    }
  }
}
void remove_armour(object arm) {
  _armours -= ({ arm });
}
object query_weapon() {
  return _weapon;
}
void set_weapon(object wpn) {
  _weapon = wpn;
}
void unwield_weapon(object wpn) {
  if (_weapon == wpn)
    _weapon = 0;
}
object *query_holding() {
  return _holding;
}
void set_holding(object * hold) {
  _holding += hold;
}
int *set_unhold(object ob) {
  int pos;
  if ((pos = member_array(ob, _holding)) == -1) {
    return ({ });
  }
  if (!ob->set_holder(0)) {
    return ({ });
  }
  _holding = _holding - ({ ob });
  return ({ pos });
}
int *set_hold(object ob,
              int pos) {
  if (member_array(ob, _holding) != -1) {
    return ({ });
  }
  _holding += ({ ob });
  return ({ pos });
}
int move_or_destruct(object dest) {
  if (objectp(dest)) {
    move_object(dest);
  } else {
    move("/room/void");
  }
  return 1;
}
void dest_me() {
  mixed *xp;
  object ob;
  xp = query_property("XP");
  if (xp && sizeof(xp) == 2) {
    foreach(ob in xp[0]) {
      if (ob) {
        ob->adjust_xp(xp[1], 1);
      }
    }
  }
  BIT_CONTROLLER->remove_bit(this_object());
  if (environment()) {
    all_inventory()->move(environment());
  }
  ::dest_me();
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
  mapping tmp;
  string pos;
  tmp = ([ "::" : ::query_dynamic_auto_load(),
           "decay" : _decay,
           "owner" : _owner,
           "race ob" : _race_ob,
           "id" : _corpse_id,
           "last pos" : pos,
           "start pos" : _start_pos,
           "nationality" : _nationality,
           "ownership" : query_ownership(),
           "race name" : _race_name, "bits gone" : _bits_gone, ]);
  return tmp;
}
void init_dynamic_arg(mapping map, object) {
  if (map["::"]) {
    ::init_dynamic_arg(map["::"]);
  }
  if (map["id"]) {
    _corpse_id = map["id"];
  }
  if (map["decay"]) {
    _decay = map["decay"];
  }
  if (map["owner"]) {
    _owner = map["owner"];
  }
  if (map["race ob"]) {
    _race_ob = map["race ob"];
  }
  _nationality = map["nationality"];
  set_ownership(map["ownership"]);
  if (map["race name"]) {
    _race_name = map["race name"];
  }
  if (map["bits gone"]) {
    _bits_gone = map["bits gone"];
  }
  if (map["start pos"]) {
    _start_pos = map["start pos"];
  }
  set_decay_messages();
}
string query_save_data() {
   string pos;
   object env;
   env = environment();
   while (env && environment(env)) {
      if (living(env) && env->query_property("player")) {
         return CORPSE_IN_PLAYER;
      }
      env = environment(env);
   }
   pos = find_start_pos( this_object(), env );
   return save_variable(({ query_dynamic_auto_load(), query_static_auto_load(), pos }));
}
void setup_corpse_from_save(string str_data, string name, int id) {
  mixed data;
  int res;
  if (str_data == CORPSE_IN_PLAYER) {
     return ;
  }
  data = restore_variable(str_data);
  init_static_arg(data[1]);
  init_dynamic_arg(data[0], 0);
  BIT_CONTROLLER->add_bit(this_object());
  res = MOVE_NO_DROP;
  tell_creator("pinkfish", "Trying to restore to location %O [%O]\n", data[2], this_object());
  catch(res = this_object()->move(data[2],
                         "$N looks confused and pops out of the ground.\n",
                         "$N looks confused and pops out of the ground.\n"));
  if (res != MOVE_OK) {
     tell_creator("pinkfish", "Trying to restore to location %O [%O]\n", _start_pos, this_object());
     catch(res = this_object()->move(_start_pos,
                         "$N looks confused and pops out of the ground.\n",
                         "$N looks confused and pops out of the ground.\n"));
  }
  if (res != MOVE_OK) {
     tell_creator("pinkfish", "Trying to restore to location %O [%O]\n", "/room/rubbish", this_object());
     move("/room/rubbish");
  }
}
mixed *stats() {
  return::stats() +
    ({ ({ "decay", _decay, }), ({ "owner", _owner, }),
         ({ "race ob", _race_ob, }), ({ "race name", _race_name, }) });
}
int test_add(object ob,
             int flag) {
  if (ob->query_bit_data()) {
    return 1;
  }
  return !flag;
}
int can_find_match_reference_inside_object(object thing,
                                           object player) {
  if (!query_property("player")) {
    return 1;
  }
  if (member_array(player->query_name(),
                   _permitted + ({ lower_case(_owner) })) == -1)
    {
      return 0;
    }
  return 1;
}
int can_find_match_recurse_into(object player) {
  return 0;
}

==================================================
FILE: cure_wand.c
==================================================

inherit "/std/effects/healing/basic_cure";
inherit "/obj/wand";
void create() {
   do_setup++;
   wand::create();
   basic_cure::create();
   do_setup--;
   if ( do_setup )
      this_object()->setup();
}

==================================================
FILE: fence.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <thief.h>
inherit "/obj/monster";
#define MAX 500
#define SKILL "other.trading.valueing"
#define PAY_RATES ({ 200, 95, \
                     400, 90, \
                     800, 85, \
                     1600, 80, \
                     3200, 75, \
                     6400, 70, \
                     12800, 65, \
                     60 })
class hist_offer {
  object ob;
  int old_offer;
  int value;
}
class offer {
  object who;
  int amount;
  int offer_time;
  object *objects;
}
class offer this_offer;
object cont;
string *move_data = ({ });
string fence_type;
mapping old_offers = ([ ]);
void whisper( object, string );
void give_back();
object query_cont() {
  return cont;
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if( !do_setup )
    this_object()->setup();
  cont = clone_object( "/std/container" );
  cont->move(this_object());
  cont->reset_drop();
  cont->reset_get();
  cont->set_name( "sack" );
  cont->set_short( "sack" );
  cont->set_long( "This is a large hessian sack.\n" );
  cont->add_property( "nosteal", 1 );
  set_wimpy( 20 );
  basic_setup( "human", "thief", 500 );
  add_respond_to_with( ({ "@say", ({ "yes", "Yes", "ok", "okay" }) }),
    "#do_yes" );
  add_respond_to_with( ({ "@nod", ({ "you" }) }), "#do_yes" );
  add_respond_to_with( ({ "@whisper", ({ "yes", "Yes", "ok", "okay" }) }),
    "#do_yes" );
  add_respond_to_with( ({ "@say", ({ "no", "No" }) }), "#do_no" );
  add_respond_to_with( ({ "@whisper", ({ "no", "No" }) }), "#do_no" );
  add_respond_to_with( ({ "@shake", ({ "you" }) }), "#do_no" );
}
void init() {
  ::init();
  this_player()->add_command( "fence", this_object(),
    "<indirect:object:me> to <direct:object>" );
}
void dest_me() {
  if( cont )
    cont->dest_me();
  ::dest_me();
}
void reset() {
  object ob;
  if( this_offer )
    return;
  foreach( ob in all_inventory( cont ) )
    ob->dest_me();
}
void check_cont() {
  if ( !cont )
    cont = clone_object( "/std/container" );
}
void set_fence_type( string str ) {
  fence_type = str;
}
int query_cost( object thing, object buyer ) {
   return (int)thing->query_value_at( this_object() );
}
string cost_string( object thing, string place, object buyer ) {
  return (string)MONEY_HAND->money_value_string( query_cost( thing, buyer ),
                                                 place );
}
string query_item_type( object ob ) {
  if( member_array( "weapons", ob->query_plurals()) != -1 )
    return "weapons";
  if( member_array( "jewellery", ob->query_plurals()) != -1 ||
      ob->query_property( "shop type" ) == "jewellers" )
    return "jewellery";
  if( member_array( "armours", ob->query_plurals()) != -1 )
    return "armour";
  if( member_array( "clothes", ob->query_plurals()) != -1 )
    return "armour";
  if( member_array( "gems", ob->query_plurals()) != -1 )
    return "gems";
  return "";
}
int judge_value( object ob, string type ) {
  int value, variance, skill;
  value = query_cost( ob, this_object() );
  if( type != "" )
    skill = query_skill_bonus( SKILL + "." + type );
  else
    skill = query_skill_bonus( SKILL );
  if( !skill )
    skill = 1;
  variance = value / sqrt( skill );
  value += random( variance ) - random( variance );
  return value;
}
string calc_place() {
  string place;
  place = environment()->query_property( "place" );
  if( !place || ( place == "" ) )
    place = "Ankh-Morpork";
  return place;
}
string cost_str( int amt ) {
  return MONEY_HAND->money_string( MONEY_HAND->create_money_array( amt,
                                   calc_place() ) );
}
int scaled_value( int n ) {
  int *fish, i, tot;
  fish = PAY_RATES;
  if( n < fish[0] ) {
    return n;
  }
  else {
    tot = fish[0];
    n -= fish[0];
  }
  i = 0;
  while( n && ( ( i + 1 ) < sizeof( fish ) ) ) {
    if( n >= fish[i]) {
      tot += fish[i+1] * fish[i] / 100;
      n -= fish[i];
    } else {
      tot += fish[i+1] * n / 100;
      n = 0;
    }
    i += 2;
  }
  if( n ) {
    tot += ( n * fish[sizeof( fish ) - 1] ) / 100;
  }
  return tot;
}
int do_fence( object *in_dir, string direct, string indirect, mixed args,
  string format ) {
  int offer, their_skill, returned, burdened, light;
  string type, skill, zone;
  object ob, *offered, *not_speciality, customer, thing;
  if( !this_player()->query_creator() &&
      !this_player()->query_visible( this_object() ) ) {
    this_object()->do_command( "puzzle" );
    this_object()->do_command( "wonder if someone is trying to be funny" );
    return 0;
  }
  light = environment( this_object() )->query_light();
  if ( ( light < 20 ) || ( light > 100 ) ) {
    if ( light > 100 ) {
      this_object()->do_command( "say I can't see anything in the glare!" );
    } else {
      this_object()->do_command( "say I can't see anything in the gloom!" );
    }
    return 0;
  }
  if( this_offer &&
      this_offer->who &&
      environment( this_offer->who ) == environment( this_object() ) ) {
    if( this_offer->offer_time > time() - 30 ) {
      if( this_offer->who != this_player() )
        whisper( this_player(), "Sorry, I'm already helping " +
          ( this_offer->who )->the_short() + "." );
      else
        whisper( this_player(), "I'm still waiting for a response from you!" );
      this_player()->add_succeeded_mess( this_object(), "", offered );
      return 1;
    } else {
      whisper( this_offer->who, "I guess you don't want my offer then." );
      customer = this_offer->who;
      burdened = 0;
      returned = 0;
      foreach( thing in this_offer->objects ) {
        if( !thing ) {
          whisper( customer, "Seems there is a hole in my sack!" );
          continue;
        }
        if( thing->move( customer ) != MOVE_OK ) {
          burdened = 1;
          thing->move( environment( this_object() ) );
          whisper( customer, "I'll just put the " + thing->short() +
            " down here since you are too burdened to accept it." );
        } else {
          returned = 1;
        }
      }
      if( burdened && returned ) {
      tell_object( customer, this_object()->a_short() + " returns the other "
        "items to you.\n" );
      } else {
        if( returned )
          tell_object( customer, this_object()->a_short() + " returns the "
            "items to you.\n" );
      }
      tell_room( environment(), this_object()->a_short() + " returns the "
        "items to " +  customer->a_short() + ".\n", ({ customer }) );
      this_offer = 0;
    }
  }
  not_speciality = ({ });
  if( sizeof( this_object()->query_move_zones() ) ) {
    foreach( zone in this_object()->query_move_zones() ) {
      move_data += ({zone});
      this_object()->remove_move_zone(zone);
    }
    this_object()->add_move_zone( 0 );
  }
  this_offer = new( class offer,
                    objects    : ({ }),
                    who        : this_player(),
                    offer_time : time()
                  );
  in_dir = filter_array( in_dir, (: !$1->query_keep() :) );
  if( sizeof( in_dir ) < 1 ) {
    whisper( this_player(), "You have nothing to fence that you're not overly "
      "fond of, it seems." );
    this_player()->add_succeeded_mess( this_object(), "", offered );
    this_offer = 0;
    return 1;
  }
  if( sizeof( in_dir ) > 10 ) {
    whisper( this_player(), "Sorry, I can't handle that many items at "
      "once." );
    this_player()->add_succeeded_mess( this_object(), "", offered );
    this_offer = 0;
    return 1;
  }
  tell_room( environment( this_object() ), this_object()->query_short() +
            " studies " + query_multiple_short( in_dir ) + ".\n" );
  foreach( ob in in_dir ) {
    if( environment( ob ) != this_offer->who ) {
      whisper( this_player(), "Do you think I'm blind?  I can see that you "
        "don't have " + strip_colours( ob->the_short()) + "." );
      continue;
    }
    if( base_name(ob) == "/obj/money" ) {
        whisper( this_player(), "I don't accept coins, I'm afraid. The market "
          "fluctuates far too much for it to be worthwhile.");
        continue;
    }
    if( ob->move( cont ) != MOVE_OK ) {
      whisper( this_player(), "If I can't take an item you can't fence it "
        "so you can't fence " + strip_colours( ob->the_short()) + "." );
      continue;
    }
    if( ob->do_not_sell() ) {
      whisper( this_player(), "You can't sell the " +
        strip_colours( ob->the_short() ) + "." );
      if( ob->move( this_player() ) != MOVE_OK ) {
        ob->move( environment( this_object() ) );
        whisper( this_player(), "So I'll just put it down here." );
      }
      else {
        whisper( this_player(), "So you can have it back." );
      }
      continue;
    }
    if( ob->query_property( "fenced" ) ) {
      do_command( "' Hang on a sec... this looks awful familiar." );
      do_command( "glare " + this_offer->who->query_name() );
      do_command( "' Just what are you trying to pull here?!" );
      do_command( "' I think I'll hang onto these little trinkets "
                  "until we can establish their correct ownership..." );
      this_offer = 0;
      this_player()->add_failed_mess( this_object(), this_object()->
        the_short() + " confiscates $I.\n", in_dir );
      return 0;
    }
    type = query_item_type( ob );
    offer = judge_value( ob, type );
    if( !offer ||
        offer < 4 ) {
      whisper( this_player(), ob->the_short() + " isn't worth anything." );
      if( ob->move( this_player() ) != MOVE_OK ) {
        ob->move( environment( this_object() ) );
        whisper( this_player(), "So I'll just put it down here." );
      }
      else {
        whisper( this_player(), "So you can have it back." );
      }
      continue;
    }
    if( type != fence_type ) {
      offer -= ( offer / 10 );
      not_speciality += ({ ob });
    }
    offer = (int)scaled_value( offer );
    if( !undefinedp( old_offers[ob] ) ) {
      if( !undefinedp( old_offers[ob][ob->query_value()] ) ) {
        offer = old_offers[ob][ob->query_value()];
      } else {
        old_offers[ob][ob->query_value()] = offer;
      }
    } else {
      old_offers[ob] = ([ ob->query_value() : offer ]);
    }
    if( type != "" )
      skill = SKILL + "." + type;
    else
      skill = SKILL;
    their_skill = this_player()->query_skill_bonus( skill );
    if( !their_skill)
      their_skill = 2;
    if( sqrt( their_skill ) < 3 )
      offer -= offer / 3;
    else {
      offer -= ( offer ) / sqrt( their_skill );
    }
    if( !offer ||
        offer < 4 ) {
      whisper( this_player(), ob->the_short() + " isn't worth anything." );
      if( ob->move( this_player() ) != MOVE_OK ) {
        ob->move( environment( this_object() ) );
        whisper( this_player(), "So I'll just put it down here." );
      }
      else {
        whisper( this_player(), "So you can have it back." );
      }
      continue;
    }
    this_offer->amount += offer;
    this_offer->objects += ({ ob });
  }
  if( sizeof( not_speciality ) == 1 )
    whisper( this_player(), "Well, " +
      strip_colours( query_multiple_short( not_speciality ) ) + " isn't really "
      "my speciality." );
  else
    if( sizeof( not_speciality ) > 1 )
      whisper( this_player(), "Well, " +
        strip_colours( query_multiple_short( not_speciality ) ) + " aren't "
        "really my speciality." );
  this_player()->add_succeeded_mess( this_object(), "", offered );
  if( !sizeof( this_offer->objects ) ) {
    whisper( this_player(), "Well, that was a waste of time." );
    this_offer = 0;
    return 1;
  }
  whisper( this_player(), "I'll give you " + cost_str( this_offer->amount ) +
          " for " + strip_colours( query_multiple_short( this_offer->
          objects ) ) + ", what do you think?" );
  return 1;
}
void do_yes( object person ) {
  object money, *selling, ob;
  mixed *m_array;
  string zone;
  if( !this_offer || person != this_offer->who )
    return;
  whisper( person, "You've got a deal." );
  selling = ({ });
  foreach( ob in this_offer->objects ) {
    ob->add_property( "fenced", (string)person->query_name() );
    selling += ({ ob });
  }
  m_array = (mixed *)MONEY_HAND->create_money_array( this_offer->amount,
                                                     calc_place() );
  money = clone_object( MONEY_OBJECT );
  money->set_money_array( m_array );
  if( (int)money->move( person ) != MOVE_OK) {
    money->move( environment( this_object() ) );
    whisper( person, "You're too heavily burdened to accept all "
      "that money, so I'll just put it on the floor." );
  } else {
    tell_object( person, this_object()->a_short() + " slips you " +
      cost_str( this_offer->amount ) + ".\n" );
    tell_room( environment(), this_object()->a_short() + " slips some coins "
      "to " + person->a_short() + ".\n", ({person}) );
  }
  this_offer = 0;
  if( sizeof( move_data ) > 0 ) {
    foreach( zone in move_data ) {
      this_object()->add_move_zone( zone );
    }
    this_object()->remove_move_zone( 0 );
    move_data = ({ });
  }
}
void do_no( object player ) {
  string zone;
  object customer, thing;
  int returned, burdened;
  if( !this_offer || player != this_offer->who )
    return;
  whisper( player, "Ok, have it your own way then." );
  customer = this_offer->who;
  burdened = 0;
  returned = 0;
  foreach( thing in this_offer->objects ) {
    if( !thing ) {
      whisper( customer, "Seems thare is a hole in my sack!" );
      continue;
    }
    if( thing->move( customer ) != MOVE_OK ) {
      burdened = 1;
      thing->move( environment( this_object() ) );
      whisper( customer, "I'll just put the " + thing->short() +
        " down here since you are too burdened to accept it." );
    } else {
      returned = 1;
    }
  }
  if( burdened && returned ) {
  tell_object( customer, this_object()->a_short() + " returns the other items "
    "to you.\n" );
  } else {
    if( returned )
      tell_object( customer, this_object()->a_short() + " returns the items to "
        "you.\n" );
  }
  tell_room( environment(), this_object()->a_short() + " returns the "
    "items to " +  customer->a_short() + ".\n", ({ customer }) );
  this_offer = 0;
  if( sizeof( move_data ) > 0 ) {
    foreach( zone in move_data ) {
      this_object()->add_move_zone( zone );
    }
    this_object()->remove_move_zone( 0 );
    move_data = ({ });
  }
}
void whisper( object ob, string message ) {
  do_command( "whisper " + message + " to " + ob->query_name() );
}
int busy() {
  if( this_offer )
    return 1;
  return 0;
}
void event_exit( object ob, string message, object to ) {
  object customer, thing;
  int returned, burdened;
  if( this_offer &&
      ob == this_offer->who ) {
    whisper( ob, "Since you're leaving, I'll give your stuff back." );
    customer = this_offer->who;
    burdened = 0;
    returned = 0;
    foreach( thing in this_offer->objects ) {
      if( !thing ) {
        whisper( customer, "Seems thare is a hole in my sack!" );
        continue;
      }
      if( thing->move( customer ) != MOVE_OK ) {
        burdened = 1;
        thing->move( environment( this_object() ) );
        whisper( customer, "I'll just put the " + thing->short() +
          " down here since you are too burdened to accept it." );
      } else {
        returned = 1;
      }
    }
    if( burdened && returned ) {
    tell_object( customer, this_object()->a_short() + " returns the other "
      "items to you.\n" );
    } else {
      if( returned )
        tell_object( customer, this_object()->a_short() + " returns the items "
          "to you.\n" );
    }
    tell_room( environment(), this_object()->a_short() + " returns the "
      "items to " +  customer->a_short() + ".\n", ({ customer }) );
    this_offer = 0;
  }
}
int attack_by( object ob ) {
  int burdened, returned;
  object customer, thing;
  if( this_offer &&
      this_offer->who &&
      environment( this_offer->who ) == environment( this_object() ) &&
      this_offer->offer_time > time() - 60 ) {
    do_command( "say Hey! I'm trying to do business here!" );
    whisper( this_offer->who, "Hey, you'd better take these." );
    customer = this_offer->who;
    burdened = 0;
    returned = 0;
    foreach( thing in this_offer->objects ) {
      if( !thing ) {
        whisper( customer, "Seems thare is a hole in my sack!" );
        continue;
      }
      if( thing->move( customer ) != MOVE_OK ) {
        burdened = 1;
        thing->move( environment( this_object() ) );
        whisper( customer, "I'll just put the " + thing->short() +
          " down here since you are too burdened to accept it." );
      } else {
        returned = 1;
      }
    }
    if( burdened && returned ) {
    tell_object( customer, this_object()->a_short() + " returns the other "
      "items to you.\n" );
    } else {
      if( returned )
        tell_object( customer, this_object()->a_short() + " returns the items "
                     "to you.\n" );
    }
    tell_room( environment(), this_object()->a_short() + " returns the "
               "items to " +  customer->a_short() + ".\n", ({ customer }) );
    this_offer = 0;
  }
  return ::attack_by(ob);
}
void give_back() {
  int burdened, returned;
  object customer, thing;
  customer = this_offer->who;
  burdened = 0;
  returned = 0;
  foreach( thing in this_offer->objects ) {
    if( !thing ) {
      whisper( customer, "Seems thare is a hole in my sack!" );
      continue;
    }
    if( thing->move( customer ) != MOVE_OK ) {
      burdened = 1;
      thing->move( environment( this_object() ) );
      whisper( customer, "I'll just put the " + thing->short() + " down here "
        "since you are too burdened to accept it." );
    } else {
      returned = 1;
    }
  }
  if( burdened && returned ) {
  tell_object( customer, this_object()->a_short() + " returns the other items "
    "to you.\n" );
  } else {
    if( returned )
      tell_object( customer, this_object()->a_short() + " returns the items to "
        "you.\n" );
  }
  tell_room( environment(), this_object()->a_short() + " returns the "
    "items to " +  customer->a_short() + ".\n", ({ customer }) );
  this_offer = 0;
}
string query_current_offer() {
  string str;
  str = "\nCustomer: " + ( this_offer->who )->short()  + "\n";
  str += "Amount: " + this_offer->amount + "\n";
  str += "Offer time: " + this_offer->offer_time + "\n";
  str += "Objects: " + query_multiple_short( this_offer->objects );
  return str;
}

==================================================
FILE: food.c
==================================================

#include <bits_controller.h>
#include <drinks.h>
#include <weapon.h>
#include <move_failures.h>
#include <playtesters.h>
inherit "/obj/cont_medium";
inherit "/std/basic/virtual_update";
#define DEFAULT_DECAY 7200
#define STATE_CHANGE ("/obj/handlers/state_change")
private int _liquid;
private int _dried, _cured;
private int _bites_gone;
private int _weight_per_bite;
private int _in_pieces;
private int _decay_level;
private int _decay_speed;
private int _splashable;
private int _applicable;
private int _external_pk_check;
private float _divisor = to_float(DEFAULT_DECAY) / to_float(6 * TIME_OUT);
private mixed _eat_mess;
private string _eat_object;
private string _eat_func;
private string _piece_desc;
private string _piece_short;
private string _piece_plural;
private string _piece_substance;
private mixed _eat_piece_mess;
private mixed _eat_amt_mess;
private mixed _eat_last_mess;
private mapping _eat_effects = ([ ]);
private mapping _external_effects = ([ ]);
varargs int do_cut(int num);
varargs int do_eat(int no_mess);
int do_mince();
void set_decay_speed(int decay);
int check_for_container();
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   reset_continuous();
   _eat_effects = ([ ]);
   set_decay_speed(DEFAULT_DECAY);
   add_help_file("food");
   if (!do_setup) {
      this_object()->setup();
   }
}
int query_liquid()
{
   return _liquid;
}
int query_edible()
{
   return !_liquid;
}
void set_liquid()
{
   set_continuous();
   _liquid = 1;
   if (environment()) {
      environment()->calc_liquid();
   }
   set_decay_speed(0);
}
void reset_liquid()
{
   reset_continuous();
   _liquid = 0;
   if (environment())
      environment()->calc_liquid();
   set_decay_speed(DEFAULT_DECAY);
   _divisor = to_float(DEFAULT_DECAY) / to_float(6 * TIME_OUT);
}
int query_food_object()
{
   return 1;
}
void init()
{
   if (query_continuous()) {
      add_command("rub", "<direct:object> <preposition> <indirect:living>");
      add_command("apply", "<direct:object> <preposition> <indirect:living>");
   }
   if (_liquid) {
      add_command("drink", "<direct:object>");
      add_command("quaff", "<direct:object>");
      add_command("splash",
                  "<direct:object> <preposition> <indirect:living>");
   } else {
      add_command("eat", "<direct:object>", (: do_eat(0) :));
      add_command("cut",
                  "<direct:object> into <number'number, eg: 3'> pieces",
                  (: do_cut($4[1]) :));
      add_command("cut", "<direct:object>", (: do_cut() :));
      add_command("slice", "<direct:object>", (: do_cut() :));
      add_command("mince", "<direct:object>", (: do_mince() :));
   }
}
int query_decays()
{
   return _decay_speed != 0;
}
int query_bites_gone()
{
   return _bites_gone;
}
int query_weight_per_bite()
{
   return _weight_per_bite;
}
string query_eat_object()
{
   return _eat_object;
}
string query_eat_func()
{
   return _eat_func;
}
string query_eat_mess()
{
   return _eat_mess;
}
string query_piece_description()
{
   return _piece_desc;
}
int query_in_pieces()
{
   return _in_pieces;
}
int query_decay_speed()
{
   return _decay_speed;
}
int query_decay_level() {
   return _decay_level;
}
void set_bites_gone(int number)
{
   _bites_gone = number;
}
void set_weight_per_bite(int number)
{
   _weight_per_bite = number;
}
void set_eat_object(string word)
{
   _eat_object = word;
}
void set_eat_func(string word)
{
   _eat_func = word;
}
void set_eat_mess(mixed word)
{
   _eat_mess = word;
}
void setup_eat_piece_messages(mixed piece,
                              mixed amt,
                              mixed last) {
   _eat_piece_mess = piece;
   _eat_amt_mess = amt;
   _eat_last_mess = last;
}
void set_piece_description(string word) {
   _piece_desc = word;
}
void set_piece_short(string short) {
   _piece_short = short;
}
void set_piece_plural(string plural) {
   _piece_plural = plural;
}
void set_piece_substance(string substance) {
   _piece_substance = substance;
}
void set_in_pieces(int number) {
   int p;
   _in_pieces = p;
}
void set_decay_level(int level) {
   _decay_level = level;
}
void set_decay_speed(int decay) {
   float tmp;
   if(decay != _decay_speed && !_dried && !_cured) {
      BITS_CONTROLLER->remove_bit(this_object());
      _decay_speed = decay;
      if (decay && !_dried && !_cured) {
         tmp = _divisor;
         _divisor = to_float(decay) / to_float(6 * TIME_OUT);
         _decay_level = to_int(_decay_level * _divisor / tmp);
         BITS_CONTROLLER->add_bit(this_object());
      }
   }
}
void do_decay() {
  if(_dried || _cured) {
    BITS_CONTROLLER->remove_bit(this_object());
    return;
  }
  if ( environment() && environment()->query_property( "no decay" ) )
    return;
  _decay_level++;
  if (_decay_level > (2 * _divisor) -1 ) {
    remove_adjective( "fresh" );
  }
  if (_decay_level > 6 * _divisor) {
    tell_room(environment(this_object()),
              capitalize(the_short()) + " crumbles to dust.\n");
    move("/room/rubbish");
  }
}
int query_weight() {
  if (query_liquid())
    return 0;
  return ::query_weight() - _bites_gone * _weight_per_bite;
}
string query_short_rotten_adjective() {
    string ret;
    ret = "";
    switch (to_int(_decay_level / _divisor)) {
    case 2:
      ret = "slightly rotten ";
      break;
    case 3:
      ret = "half rotten ";
      break;
    case 4:
      ret = "mostly rotten ";
      break;
    case 5:
      ret = "almost rotten ";
      break;
    case 6:
      ret = "rotten ";
      break;
    }
    return ret;
}
string short(int dark) {
  string ret;
  ret = ::short(dark);
  if (_decay_speed) {
     ret = query_short_rotten_adjective() + ret;
  }
  return ret;
}
string query_long_eat_level() {
   int twelfths;
   string ret;
    twelfths = (_bites_gone * _weight_per_bite * 12) / ::query_weight();
    switch (twelfths) {
        case 0..1:
            ret = "It has just been nibbled on.\n";
        break;
        case 2:
            ret = "It is about one sixth gone.\n";
        break;
        case 3:
            ret = "It is about one quarter gone.\n";
        break;
        case 4:
            ret = "It is about one third gone.\n";
        break;
        case 5:
            ret = "It is just under half gone.\n";
        break;
        case 6:
            ret = "It is about half gone.\n";
        break;
        case 7:
            ret = "It is just over half gone.\n";
        break;
        case 8:
            ret = "It is about two thirds gone.\n";
        break;
        case 9:
            ret = "It is about three quarters gone.\n";
        break;
        case 10:
            ret = "It is about five sixths gone.\n";
        break;
        case 11:
            ret = "It is almost all gone.\n";
        break;
        default:
            ret = "Schroedinger's cat has been at it.\n";
        break;
    }
    return ret;
}
string query_long_decay_level() {
    string ret;
    ret = "";
    switch (to_int(_decay_level / _divisor)) {
    case 0..1:
      if(query_collective() && query_amount() > 1)
        ret += "They look nice and fresh.\n";
      else
       ret += "It looks nice and fresh.\n";
      break;
    case 2:
      if(query_collective() && query_amount() > 1)
        ret += "They look a bit rotten.\n";
      else
        ret += "It looks a bit rotten.\n";
      break;
    case 3:
      if(query_collective() && query_amount() > 1)
        ret += "They are half rotten.\n";
      else
        ret += "It is half rotten.\n";
      break;
    case 4:
      if(query_collective() && query_amount() > 1)
        ret += "They are mostly rotten.\n";
      else
        ret += "It is mostly rotten.\n";
      break;
    case 5:
      if(query_collective() && query_amount() > 1)
        ret += "They are almost completely rotten.\n";
      else
        ret += "It is almost completely rotten.\n";
       break;
    case 6:
      if(query_collective() && query_amount() > 1)
        ret += "They are completely rotten.\n";
      else
        ret += "It is completely rotten.\n";
      break;
    }
    return ret;
}
string long(string words, int dark) {
   string ret;
   ret =::long(words, dark);
   if (_liquid) {
      return ret;
   }
   if (_weight_per_bite && _bites_gone) {
       ret += query_long_eat_level();
   }
   if (_decay_speed) {
       ret += query_long_decay_level();
   }
   else {
       if(_dried) {
           if(query_collective() && query_amount() > 1) {
              ret += "They are all dry and shrivelled up.\n";
           }
           else {
              ret += "It is all dry and shrivelled up.\n";
           }
        }
        else {
            if(_cured) {
                if(query_collective() && query_amount() > 1) {
                    ret += "They seem to have been pickled.\n";
                }
                else {
                    ret += "It seems to have been pickled.\n";
                }
            }
        }
   }
   return ret;
}
void setup_eat(string ob, string func) {
   _eat_object = ob;
   _eat_func = func;
}
mapping query_eat_effects() {
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   }
   return copy( _eat_effects );
}
void set_eat_effects(mapping map) {
   if (mapp(map)) {
      _eat_effects = map;
   }
}
int add_eat_effect(mixed word,
                   int number)
{
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   }
   if (mapp(word)) {
      int num;
      string name;
      foreach(name, number in word) {
         num += add_eat_effect(name, number);
      }
      return num;
   }
   if (_eat_effects[word]) {
      _eat_effects[word] += number;
   } else {
      _eat_effects[word] = number;
   }
   return _eat_effects[word];
}
void remove_eat_effect(string word)
{
   if (!undefinedp(_eat_effects[word])) {
      _eat_effects = m_delete(_eat_effects, word);
   }
}
void set_external_pk_check()
{
   _external_pk_check = 1;
}
void unset_external_pk_check()
{
   _external_pk_check = 0;
}
mapping query_external_effects()
{
   if (undefinedp(_external_effects))
      _external_effects = ([ ]);
   return _external_effects + ([ ]);
}
void set_external_effects(mapping map)
{
   _external_effects = map;
}
int add_external_effect(string word,
                        int number)
{
   if (undefinedp(_external_effects))
      _external_effects = ([ ]);
   if (_external_effects[word])
      _external_effects[word] += number;
   else
      _external_effects[word] = number;
   return _external_effects[word];
}
void remove_external_effect(string word)
{
   if (!undefinedp(_external_effects[word])) {
      _external_effects = m_delete(_external_effects, word);
   }
}
void set_splashable()
{
   _splashable = 1;
}
void unset_splashable()
{
   _splashable = 0;
}
int query_splashable(object splasher,
                     object splashee)
{
   if (splasher == splashee || !_external_pk_check) {
      return (_splashable && _liquid);
   }
   return (_splashable && _liquid && !(pk_check(splasher, splashee)));
}
void set_applicable()
{
   _applicable = 1;
}
void unset_applicable()
{
   _applicable = 0;
}
int query_applicable(object applier,
                     object appliee)
{
   if (applier == appliee || !_external_pk_check) {
      return _applicable;
   }
   return (_applicable && !(pk_check(applier, appliee)));
}
void being_joined_by(object thing)
{
   int i,
     that,
     this;
   string *words;
   mapping new_effects;
   that = (int) thing->query_amount();
   this = query_amount();
   if (!(this + that))
      return;
   if (thing->query_splashable(0, 0) && !_splashable)
      set_splashable();
   if (thing->query_applicable(0, 0) && !_applicable)
      set_applicable();
   if (thing->query_external_pk_check() && !_external_pk_check)
      set_external_pk_check();
   new_effects = (mapping) thing->query_eat_effects();
   words = m_indices(_eat_effects);
   for (i = 0; i < sizeof(words); i++) {
      if (new_effects[words[i]]) {
         new_effects[words[i]] *= that;
         new_effects[words[i]] += this * _eat_effects[words[i]];
      } else {
         new_effects[words[i]] = this * _eat_effects[words[i]];
      }
   }
   words = m_indices(new_effects);
   for (i = 0; i < sizeof(words); i++) {
      new_effects[words[i]] /= this + that;
   }
   _eat_effects = new_effects;
   new_effects = (mapping) thing->query_external_effects();
   words = m_indices(_external_effects);
   for (i = 0; i < sizeof(words); i++) {
      if (_external_effects[words[i]]) {
         new_effects[words[i]] *= that;
         new_effects[words[i]] += this * _external_effects[words[i]];
      } else {
         new_effects[words[i]] = this * _external_effects[words[i]];
      }
   }
   words = m_indices(new_effects);
   for (i = 0; i < sizeof(words); i++) {
      new_effects[words[i]] /= this + that;
   }
   _external_effects = new_effects;
}
varargs void consume(object consumer, int amount, string type) {
  int i, denominator, numerator, wholes;
  string *words;
  switch (type) {
  case "splash":
  case "apply":
  case "external":
    words = m_indices(_external_effects);
    break;
  default:
    words = m_indices(_eat_effects);
    break;
  }
  if (!amount && query_continuous()) {
    amount = query_amount();
  }
  if (amount) {
    if (query_continuous() && (amount > query_amount()))
      amount = query_amount();
    numerator = amount * query_weight_unit()[0];
    denominator = query_weight_unit()[1];
    if (type != "apply" && type != "splash" && type != "external") {
      if (_liquid) {
        consumer->adjust_volume(D_DRINK, (50 * numerator) / denominator);
      } else {
        consumer->adjust_volume(D_FOOD, (50 * numerator) / denominator);
      }
    }
    if (!this_object()->query_property("playtester") ||
        PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
        consumer->query_creator()) {
      for (i = 0; i < sizeof(words); i++) {
        switch (type) {
        case "splash":
        case "apply":
        case "external":
          numerator = _external_effects[words[i]] * amount *
            query_weight_unit()[0];
          break;
        default:
          numerator = _eat_effects[words[i]] * amount *
            query_weight_unit()[0];
          break;
        }
        wholes = numerator / denominator;
        numerator %= denominator;
        if (random(denominator) < numerator) {
          wholes++;
        }
        consumer->add_effect(words[i], wholes);
      }
    }
    adjust_amount(-amount);
  } else {
    if (_weight_per_bite) {
      _bites_gone++;
      if (type != "apply" && type != "splash" && type != "external") {
        consumer->adjust_volume(D_FOOD, 50 * _weight_per_bite);
      }
      if (!this_object()->query_property("playtester") ||
          PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
          consumer->query_creator()) {
        for (i = 0; i < sizeof(words); i++) {
          switch (type) {
          case "splash":
          case "apply":
          case "external":
            this_player()->add_effect(words[i],
                                      _external_effects[words[i]] *
                                      _weight_per_bite);
            break;
          default:
            this_player()->add_effect(words[i], _eat_effects[words[i]] *
                                      _weight_per_bite);
            break;
          }
        }
      }
    } else {
      consumer->adjust_volume(D_FOOD, 50 * weight);
      if (!this_object()->query_property("playtester") ||
          PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
          consumer->query_creator()) {
        for (i = 0; i < sizeof(words); i++) {
          switch (type) {
          case "apply":
          case "splash":
          case "external":
            consumer->add_effect(words[i],
                                 _external_effects[words[i]] * weight);
            break;
          default:
            consumer->add_effect(words[i],
                                 _eat_effects[words[i]] * weight);
            break;
          }
        }
      }
    }
  }
  if (type != "apply" && type != "splash" && type != "external") {
    if (_eat_func) {
      if (_eat_object) {
        call_other(_eat_object, _eat_func, this_object(), consumer);
      } else {
        call_other(this_object(), _eat_func, this_object(), consumer);
      }
    }
  }
}
varargs int do_eat(int no_mess) {
   int ret;
   if ((weight <= 0) && !query_continuous()) {
      if (_eat_mess && !no_mess) {
         add_succeeded_mess(_eat_mess, ({ }));
      }
      move("/room/rubbish");
      return 1;
   }
   if ((weight <= (_bites_gone + 1) * _weight_per_bite) || !_weight_per_bite) {
      if (!no_mess) {
         if (!query_continuous()) {
            if (_weight_per_bite) {
               if (_eat_last_mess) {
                  add_succeeded_mess(_eat_last_mess, ({ }));
               } else {
                  add_succeeded_mess("$N $V the last of $D.\n", ({ }));
               }
            } else if (_eat_mess) {
               add_succeeded_mess(_eat_mess, ({ }));
            }
         } else {
            if (_eat_amt_mess) {
               add_succeeded_mess(replace_string(_eat_amt_mess, "$amt$",
                                                 amount_size() ), ({ }));
            } else {
               add_succeeded_mess("$N $V " + amount_size() + " of $D.\n",
                                  ({ }));
            }
         }
      }
      ret = 2;
      move("/room/rubbish");
   } else {
      if (!no_mess) {
         if (_eat_piece_mess) {
            add_succeeded_mess(_eat_piece_mess, ({ }));
         } else {
            add_succeeded_mess("$N $V a piece of $D.\n", ({ }));
         }
      }
      ret = 1;
   }
   consume(this_player(), 0);
   return ret;
}
int check_sharp(object weapon)
{
   mixed *data;
   int i;
   if (!weapon) {
      return 0;
   }
   data = weapon->query_attack_data();
   for (i = W_TYPE; i < sizeof(data); i += W_ARRAY_SIZE) {
      if (data[i] == "sharp") {
         return 1;
      }
   }
   return 0;
}
varargs int do_cut(int num_pieces) {
  object bing, *obs, with;
  string name, *exploded_short;
  int i, j, k, size_of_each, gone;
  int portion_of_whole;
  int portion_of_parent;
  string temp_short, temp_plural;
  mixed rabbit;
  if (query_liquid()) {
    add_failed_mess("You cannot $V $D.\n");
    return -1;
  }
  obs = this_player()->query_holding();
  for (i = 0; i < sizeof(obs); i++) {
    if (check_sharp(obs[i])) {
      if (!with || (with && with->query_weight() > obs[i]->query_weight())) {
        with = obs[i];
      }
    }
  }
  if (!with) {
    add_failed_mess("You have to be holding a sharp object to $V $D.\n");
    return -1;
  }
  if (undefinedp(num_pieces))
    num_pieces = 2;
  if (query_continuous())
    return (do_mince());
  if (num_pieces <= 1 || !_weight_per_bite) {
    add_failed_mess("$D cannot be cut up.\n");
    return -1;
  } else if (num_pieces >
             ((query_weight() / _weight_per_bite) - _bites_gone)) {
    if (num_pieces == 2 || ((query_weight() / _weight_per_bite) -
                            _bites_gone) < 2) {
      add_failed_mess("$D cannot be cut up.\n");
    } else
      add_failed_mess("You can't $V $D into that many pieces.\n");
    return -1;
  }
  name = file_name(this_object());
  sscanf(name, "%s#%*d", name);
  size_of_each = (query_weight() - _weight_per_bite * _bites_gone) /
    num_pieces;
  gone = (::query_weight() - size_of_each) / _weight_per_bite;
  for (i = 0; i < num_pieces; i++) {
    bing = clone_object(name);
    bing->init_static_arg(query_static_auto_load());
    bing->init_dynamic_arg(query_dynamic_auto_load());
    bing->set_weight(size_of_each);
    bing->set_value(0);
    bing->add_property("whole:weight", query_property("whole:weight")
                       || query_weight());
    bing->add_property("whole:short", query_property("whole:short")
                       || this_player()->convert_message(a_short()));
    portion_of_whole = bing->query_property("whole:weight") / size_of_each;
    portion_of_parent = query_weight() / size_of_each;
    if (!_in_pieces) {
      if (_piece_desc) {
        bing->set_long(_piece_desc);
        if (!_in_pieces) {
          if (!_piece_short) {
            if (portion_of_whole == 1)
              temp_short = "piece";
            else if (portion_of_whole == 2)
              temp_short = "half";
            else if (portion_of_whole == 4)
              temp_short = "quarter";
            else
              temp_short = word_ordinal(portion_of_whole);
          }
          if (!_piece_plural) {
            if (_piece_short)
              _piece_plural = _piece_short + "s";
            else {
              if (temp_short == "half")
                temp_plural = "halves";
              else
                temp_plural = temp_short + "s";
            }
          }
          if (_piece_substance)
            rabbit = _piece_substance;
          else
            rabbit = bing->query_property("whole:short");
          bing->set_short((_piece_short || temp_short) +
                          " of " + rabbit);
          bing->set_main_plural((_piece_plural || temp_plural) +
                                " of " + rabbit);
        }
      }
    } else {
      bing->set_bites_gone(gone);
    }
    bing->add_alias(_piece_short || temp_short);
    bing->add_plural(_piece_plural || temp_plural);
    exploded_short = explode(bing->query_short(), " ");
    j = sizeof(exploded_short);
    bing->set_name(exploded_short[j - 1]);
    for (k = 0; k < sizeof(exploded_short) - 1; k++) {
      bing->add_adjective(exploded_short[k]);
    }
    bing->set_in_pieces(1);
    if (bing->move(environment((this_object())))!= MOVE_OK ) {
      bing->move(environment(this_player()));
    }
  }
  move("/room/rubbish");
  if (with->query_weight() < 20) {
    add_succeeded_mess(({ sprintf("$N $V $D into %s pieces with %s%s.\n",
                                  query_num(num_pieces), with->poss_short(),
                                  (num_pieces * size_of_each) <
                                  query_weight()?
                                  ", carelessly dribbling a bit while you do "
                                  "so" : ""),
                            sprintf("$N $V $D into %s pieces with %s.\n",
                                    query_num(num_pieces),
                                    with->poss_short()) }));
  } else {
    add_succeeded_mess(({sprintf("$N stand back and hack $D into %s pieces "
                                 "with %s%s.\n", query_num(num_pieces),
                                 with->poss_short(),
                                 (num_pieces * size_of_each) < query_weight()?
                                 ", carelessly obliterating a bit when you do "
                                 "so" : ""),
                           sprintf("$N stands back and hacks $D into %s "
                                   "pieces with %s.\n",
                                   query_num(num_pieces),
                                   with->poss_short()) }));
  }
  return 1;
}
varargs int do_mince()
{
   object *obs,
     with,
     transformed;
   int i,
     rem_pieces;
   if (query_liquid()) {
      add_failed_mess("You cannot $V $D.\n");
      return -1;
   }
   obs = this_player()->query_holding();
   for (i = 0; i < sizeof(obs); i++) {
      if (check_sharp(obs[i])) {
         if (!with || (with && with->query_weight() > obs[i]->query_weight())) {
            with = obs[i];
         }
      }
   }
   if (!with) {
      add_failed_mess("You have to be holding a sharp object to $V " "$D.\n");
      return -1;
   }
   transformed = STATE_CHANGE->transform(this_object(), "slice");
   if (!objectp(transformed)) {
      if (query_continuous()) {
         add_failed_mess("$D cannot be cut up any further.\n");
         return -1;
      }
      if (_weight_per_bite) {
         rem_pieces = (query_weight() / _weight_per_bite) - _bites_gone;
         return (do_cut(rem_pieces));
      }
      return -1;
   }
   this_object()->move("/room/rubbish");
   if (transformed->move(this_player()) != MOVE_OK) {
      call_out("tell_object", 0, this_player(), "You drop " +
               transformed->the_short() + ".\n");
      call_out("tell_room", 0, environment(this_player()),
               this_player()->the_short() + " drops " +
               transformed->the_short() + ".\n");
      transformed->move(environment(this_player()));
   }
   add_succeeded_mess("$N $V $D with " + with->the_short() +
                      " into $I.\n", ({ transformed }));
   return 1;
}
int do_drink()
{
   if (!check_for_container()) {
      add_failed_mess("You go to try and $V $D, but it suddenly "
                      "remembers what happens when it is not in a "
                      "container and drains away to dust.\n");
      move("/room/rubbish");
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D.\n", ({ }));
   consume(this_player(), 0);
   return 1;
}
int do_quaff()
{
   if (!check_for_container()) {
      add_failed_mess("You go to try and $V $D, but it suddenly "
                      "remembers what happens when it is not in a "
                      "container and drains away to dust.\n");
      move("/room/rubbish");
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() +
                                     " of $D spilling most of "
                                     "it of course.\n", ({ }));
   consume(this_player(), query_amount() * 6 / 10, "splash");
   consume(this_player(), query_amount() * 4 / 10);
   return 1;
}
int do_apply(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D to one person alone.\n", ({ }));
      return 0;
   }
   if (!_applicable) {
      add_failed_mess("You cannot $V $D to anybody.\n");
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to rub $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D to $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "apply");
   return 1;
}
int do_rub(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D on one person alone.\n", ({ }));
      return 0;
   }
   if (!_applicable) {
      add_failed_mess("You cannot $V $D on anybody.\n");
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to rub $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D on $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "apply");
   return 1;
}
int do_splash(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D on one person alone.\n", ({ }));
      return 0;
   }
   if (!_splashable || !_liquid) {
      add_failed_mess("You cannot $V $D on anybody.\n", ({ }));
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to splash $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D on $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "splash");
   return 1;
}
mapping int_query_static_auto_load() {
   return ([ "::" : ::int_query_static_auto_load(),
             "liquid" : _liquid,
             "weight_per_bite" : _weight_per_bite,
             "eat_object" : _eat_object,
             "eat_func" : _eat_func,
             "eat_mess" : _eat_mess,
             "splashable" : _splashable,
             "applicable" : _applicable,
             "external_pk_check" : _external_pk_check ]);
}
mapping query_static_auto_load()
{
   if ((explode(file_name(this_object()), "#")[0] != "/obj/food")
       && !query_continuous()) {
      return 0;
   }
   return int_query_static_auto_load();
}
void init_static_arg(mapping map)
{
   if (!mapp(map)) {
      return;
   }
   if (map["::"]) {
      ::init_static_arg(map["::"]);
   }
   _liquid = map["liquid"];
   _weight_per_bite = map["weight_per_bite"];
   _eat_object = map["eat_object"];
   _eat_func = map["eat_func"];
   _eat_mess = map["eat_mess"];
   _splashable = map["splashable"];
   _applicable = map["applicable"];
   _external_pk_check = map["external_pk_check"];
}
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "bites_gone" : _bites_gone,
             "eat_effects" : _eat_effects,
             "external_effects" : _external_effects,
             "in pieces" : _in_pieces,
             "piece desc" : _piece_desc,
             "piece short" : _piece_short,
             "piece plural" : _piece_plural,
             "piece substance" : _piece_substance,
             "decay speed" : _decay_speed,
             "decay level" : _decay_level,
             "dried" : _dried,
             "cured" : _cured,
             "divisor" : _divisor, ]);
}
void init_dynamic_arg(mapping map, object)
{
   if (!mapp(map)) {
      return;
   }
   if (map["::"]) {
      ::init_dynamic_arg(map["::"]);
   }
   _bites_gone = map["bites_gone"];
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   } else {
      if (mapp(map["eat_effects"])) {
         _eat_effects = map["eat_effects"];
      }
   }
   if (undefinedp(_external_effects)) {
      _external_effects = ([ ]);
   } else {
      _external_effects = map["external_effects"];
   }
   _in_pieces = map["in pieces"];
   _piece_desc = map["piece desc"];
   _piece_short = map["piece short"];
   _piece_plural = map["piece plural"];
   _piece_substance = map["piece substance"];
   if (_in_pieces && _piece_desc) {
      set_long(_piece_desc);
   }
   set_decay_speed(map["decay speed"]);
   _decay_level = map["decay level"];
   _divisor = map["divisor"];
   _dried = map["dried"];
   _cured = map["cured"];
   init_virtual_object();
}
mixed *stats()
{
   int i;
   string *words;
   mixed *args;
   args =::stats() + ({ ({ "liquid", _liquid }),
                        ({ "bites gone", _bites_gone }),
                        ({ "weight per bite", _weight_per_bite }),
                        ({ "eat object", _eat_object }),
                        ({ "eat function", _eat_func }),
                        ({ "eat message", _eat_mess }),
                        ({ "in pieces", _in_pieces }),
                        ({ "decay speed", _decay_speed }),
                        ({ "decay level", _decay_level }),
                        ({ "dried", _dried }),
                        ({ "cured", _cured }) });
   words = m_indices(_eat_effects);
   for (i = 0; i < sizeof(words); i++) {
      args += ({ ({ "eat effect#" + i, words[i] + " (" +
                    _eat_effects[words[i]] + ")" }) });
   }
   args += ({ ({ "applicable", _applicable }) });
   args += ({ ({ "splashable", _splashable }) });
   if (_splashable && !_liquid) {
      args += ({ ({ "***not splashable***", "because not a liquid" }) });
   }
   args += ({ ({ "external_pk_check", _external_pk_check }) });
   if (_external_effects) {
      words = keys(_external_effects);
      for (i = 0; i < sizeof(words); i++) {
         args += ({ ({ "external effect#" + i, words[i] + " (" +
                       _external_effects[words[i]] + ")" }) });
      }
   }
   return args;
}
int check_for_container()
{
   if (query_liquid()) {
      if (!environment()->query_max_volume() || living(environment())) {
         return 0;
      }
   }
   return 1;
}
private void move_check_for_container()
{
   if (!check_for_container()) {
      tell_room(environment(),
                the_short() + " dribbles all over the place and disappears "
                "into the dust.\n");
      if(move("/room/rubbish") != MOVE_OK) {
        debug_printf("Oops, failed to move us to the rubbish room.\n");
      }
   }
}
varargs int move(mixed dest, string mess1, string mess2) {
   int ret;
   ret =::move(dest, mess1, mess2);
   if (ret == MOVE_OK && dest != "/room/rubbish" && query_liquid()) {
      move_check_for_container();
   }
   return ret;
}
int query_rotten() {
    if ( _divisor ) {
        return to_int( _decay_level / _divisor ) > 1;
    }
    return 0;
}
string *query_adjectives() {
  if( query_rotten() ) {
    return ::query_adjectives() + ({ "rotten" });
  }
  return ::query_adjectives();
}
float query_decay_divisor() { return _divisor; }
int do_cure() {
  if(_dried || _liquid || _cured)
    return 0;
  _decay_speed = 0;
  _decay_level = 0;
  BITS_CONTROLLER->remove_bit(this_object());
  set_main_plural( "cured " + query_plural() );
  set_short( "cured " + query_short());
  add_adjective("cured");
  remove_adjective("fresh");
  _cured = 1;
  if( query_collective() ) {
    merge();
  }
  return 1;
}
int query_cured() { return _cured; }
int do_dry() {
  int new_weight;
  if(_dried || _liquid || _cured)
    return 0;
  _decay_speed = 0;
  _decay_level = 0;
  BITS_CONTROLLER->remove_bit( this_object() );
  set_main_plural("dried " + query_plural(0));
  set_short( "dried " + query_short());
  add_adjective("dried");
  remove_adjective("fresh");
  new_weight = ::query_weight() / 10;
  if ( new_weight ) {
    set_weight( new_weight );
  }
  else {
    set_weight( 1 );
  }
  if( query_collective() ) {
    merge();
  }
  _dried = 1;
  return 1;
}
int query_dried() { return _dried; }
int merge_criteria(object ob) {
  return ::merge_criteria(ob) &&
    _decay_speed == ob->query_decay_speed() &&
    _bites_gone == ob->query_bites_gone() &&
    ((to_int(_decay_level / _divisor) < 2 &&
     to_int(ob->query_decay_level() / ob->query_decay_divisor()) < 2) ||
     to_int(_decay_level / _divisor) ==
     to_int(ob->query_decay_level() / ob->query_decay_divisor()));
}

==================================================
FILE: fungus.c
==================================================

#include <move_failures.h>
inherit "/obj/food";
int delay, large_weight, stage;
string adjs, extra, type, *messages;
void next_stage();
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_name( "fungus" );
  add_plural( "fungi" );
  set_short( "fungus" );
  delay = 600;
  large_weight = 4;
  set_weight_per_bite( 1 );
  extra = "It looks edible.";
  type = "mushroom";
  messages = ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ silently releases a grey dust into the air.\n",
    "The $type$ collapses in on itself and falls apart.\n"
  });
  if ( !do_setup )
    this_object()->setup();
   if ( clonep( this_object() ) )
      call_out( "next_stage", delay / 2 + random( delay ) );
}
int query_growing() { return 1; }
int query_delay() { return delay; }
void set_delay( int number ) {
  if ( number < 60 )
    number = 60;
  delay = number;
  if ( remove_call_out( "next_stage" ) > -1 )
    call_out( "next_stage", delay / 2 + random( delay ) );
}
int query_large_weight() { return large_weight; }
int query_stage() { return stage; }
void set_stage( int number ) {
  if(number > 0) {
    stage = number - 1;
  }
  this_object()->next_stage();
}
void set_large_weight( int number ) { large_weight = number; }
string query_adjs() { return adjs; }
void set_adjs( string words ) { adjs = words; }
string query_extra() { return extra; }
void set_extra( string words ) { extra = words; }
string query_type() { return type; }
void set_type( string word ) { type = word; }
string *query_messages() { return messages; }
void set_messages( string *words ) {
  if ( sizeof( words ) != 5 ) {
    write( "WARNING: there must be five messages.\n" );
    return;
  }
  messages = words;
}
void init() {
   ::init();
   if ( stage > 5 )
      this_player()->add_command( "pick", this_object() );
}
int test_non_spore( object thing ) {
  return ( (int)thing->query_stage() > 5 );
}
void setup_spore() {
  set_name("pile");
  set_short("small, dusty pile of fungus spores");
  add_alias("dust");
  add_alias("spore");
  add_adjective("fungus");
  add_adjective("spore");
  set_main_plural("small, dusty piles of fungus spores");
  add_plural(({"piles","spores"}));
  add_plural_adjective("small, dusty piles of");
  add_plural_adjective("fungus");
  set_delay( delay );
  set_large_weight( large_weight );
  set_weight_per_bite( query_weight_per_bite() );
  set_adjs( adjs );
  set_extra( extra );
  set_long("This is a small pile of dust, mainly fungus "
           "spores, it seems.\n");
  set_type( type );
  set_messages( messages );
}
object make_spore( object place ) {
  object spore;
  spore = clone_object( explode( file_name( this_object() ), "#" )[0]);
  spore->setup_spore();
  spore->move( place );
  return spore;
}
void next_stage() {
  int i, number;
  string words;
  object *things;
  if ( !environment() )
    return;
  if ( adjs )
    words = adjs +" "+ type;
  else
    words = type;
  switch ( stage ) {
    case 0 .. 4 :
      this_object()->setup_spore();
      break;
    case 5 :
      things = match_objects_for_existence( pluralize(words),
                                            ({ environment() }) );
      things = filter_array( things, "test_non_spore", this_object() );
      if ( sizeof( things ) >=
          (int)environment()->query_property( words +" capacity" ) ) {
        move( "/room/rubbish" );
        return;
      }
      tell_room( environment(), replace( messages[ 0 ], "$type$", words ) );
      set_aliases( ({ type }) );
      set_plurals( ({ "fungi", pluralize( type ) }) );
      set_short( "small "+ words );
      if ( adjs )
        set_adjectives( ({ "small" }) + explode( adjs, " " ) );
      else
        set_adjectives( ({ "small" }) );
      set_main_plural( "small "+ pluralize( words ) );
      set_long( "This is a small "+ words +"."+ ( extra ? "  "+ extra : "" ) +
          "\n" );
      set_weight( large_weight / 4 );
      things = all_inventory( environment() );
      for ( i = 0; i < sizeof( things ); i++ )
        if ( living( things[ i ] ) )
          things[ i ]->add_command( "pick", this_object() );
      break;
    case 6 :
      tell_room( environment(), replace( messages[ 1 ], "$type$", words ) );
      set_short( "medium "+ words );
      if ( adjs )
        set_adjectives( ({ "medium" }) + explode( adjs, " " ) );
      else
        set_adjectives( ({ "medium" }) );
      set_main_plural( "medium "+ pluralize( words ) );
      set_long( "This is a medium sized "+ words +"."+ ( extra ? "  "+
          extra : "" ) +"\n" );
      set_weight( large_weight / 2 );
      break;
    case 7 :
      tell_room( environment(), replace( messages[ 2 ], "$type$", words ) );
      set_short( "large "+ words );
      if ( adjs )
        set_adjectives( ({ "large" }) + explode( adjs, " " ) );
      else
        set_adjectives( ({ "large" }) );
      set_main_plural( "large "+ pluralize( words ) );
      set_long( "This is a large "+ words +"."+ ( extra ? "  "+ extra : "" ) +
          "\n" );
      set_weight( large_weight );
      break;
    case 8 .. 10 :
      break;
    case 11 :
      if(!environment() || base_name(environment()) == "/room/rubbish")
        break;
      tell_room( environment(), replace( messages[ 3 ], "$type$", words ) );
      number = 2 + random( 3 );
      for ( i = 0; i < number; i++ )
        make_spore( environment() );
      break;
    default :
      tell_room( environment(), replace( messages[ 4 ], "$type$", words ) );
      move( "/room/rubbish" );
      return;
  }
  stage++;
  call_out( "next_stage", delay / 2 + random( delay ) );
}
int do_get() {
  if ( stage != -1 ) {
    write( the_short() +" is currently growing.  You could \"pick\" "+
        "it, though.\n" );
    return 0;
  }
  if ( move( this_player() ) == MOVE_OK )
    return 1;
  return 0;
}
int do_take() { return do_get(); }
int do_pick() {
  if ( stage < 6 )
    return 0;
  stage = -1;
  remove_call_out( "next_stage" );
  if ( move( this_player() ) != MOVE_OK )
    call_out( "too_heavy_mess", 0, this_player() );
  return 1;
}
void too_heavy_mess( object thing ) {
  if ( thing )
    tell_object( thing, "You are carrying too much to lift the "+ type +
        " as well, so you leave it on the ground.\n" );
}
string query_medium_short() {
  if ( adjs )
    return adjs +" "+ type;
  return type;
}
mapping query_static_auto_load() { return int_query_static_auto_load(); }
void init_dynamic_arg( mapping args, object) {
  ::init_dynamic_arg( args );
  stage = -1;
  remove_call_out( "next_stage" );
}

==================================================
FILE: gatherable.c
==================================================

#include <parse_command.h>
inherit "/std/object";
string item_name;
int scarcity;
string get_failure_mess = "Use \"gather\"\n";
void create() {
    ::create();
    reset_get();
}
void set_item_name(string name) { item_name = name; }
string query_item_name() { return item_name; }
void set_scarcity(int s) { scarcity = s; }
int query_scarcity() { return scarcity; }
void set_get_failure_mess(string s) { get_failure_mess = s; }
int do_get() {
    return notify_fail( get_failure_mess );
}

==================================================
FILE: holdable.c
==================================================

#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
void create() {
   holdable::create();
   object::create();
}
void dest_me() {
   holdable::dest_me();
   object::dest_me();
}
mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "hold" : holdable::query_dynamic_auto_load(),
          ]);
}
void init_dynamic_arg( mapping arg ) {
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return ;
   }
   if ( map[ "::" ] ) {
      object::init_static_arg( map[ "::" ] );
   }
   holdable::init_static_arg(map["hold"]);
}
mapping int_query_static_auto_load() {
   mapping tmp;
   tmp = object::int_query_static_auto_load();
   return ([ "::" : tmp,
      "hold" : holdable::query_static_auto_load(),
          ]);
}
mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/holdable" ) {
      return int_query_static_auto_load();
   }
   return 0;
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}

==================================================
FILE: hotfood.c
==================================================

#include <bits_controller.h>
#include <weather.h>
inherit "/obj/food";
#define WARM 10
#define WARM_TIME 60
#define COOL_RATE_DEFAULT 10
private int _cool_level;
private int _cool_rate;
private int _purchase_time;
private mixed _hot_eat_message;
private mixed _cold_eat_message;
private mixed _hot_eat_piece_message;
private mixed _hot_eat_amt_message;
private mixed _hot_eat_last_message;
private mixed _cold_eat_piece_message;
private mixed _cold_eat_amt_message;
private mixed _cold_eat_last_message;
void create();
void set_cool_rate( int rate );
void set_cool_level(int level);
int query_cool_rate();
int query_cool_level();
protected void do_cool();
void set_hot_eat_mess(mixed messages);
void set_cold_eat_mess(mixed messages);
mixed query_hot_eat_mess();
mixed query_cold_eat_mess();
void setup_cold_eat_piece_messages(mixed piece, mixed amt, mixed last);
void setup_hot_eat_piece_messages(mixed piece, mixed amt, mixed last);
mixed query_hot_eat_amt_message;
mixed query_hot_eat_piece_message;
mixed query_hot_last_message;
mixed query_cold_eat_amt_message;
mixed query_cold_eat_piece_message;
mixed query_cold_last_message;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   _cool_rate = COOL_RATE_DEFAULT;
   set_decay_speed( 1 );
   if ( !do_setup ) this_object()->setup();
   _cool_level = ( this_object()->query_weight() ) * 20;
   _purchase_time = time();
}
void set_cool_rate( int rate ) {
   _cool_rate = rate;
}
int query_cool_rate() {
   return _cool_rate;
}
int query_cool_level() {
   return _cool_level;
}
string query_short_rotten_adjective() {
   string ret;
   if (this_object()->query_cool_level() == 7){
       return ("cold " + ::query_short_rotten_adjective());
   }
   _cool_level = (time() - _purchase_time)/_cool_rate;
   ret = "";
   switch ( _cool_level ) {
     case 0..1:
        ret="piping hot " + ret;
        break;
     case 2:
        ret = "slightly cooled " + ret;
        break;
     case 3:
        ret = "partially cooled " + ret;
        break;
     case 4:
        ret = "half cooled " + ret;
        break;
     case 5:
        ret = "mostly cooled " + ret;
        break;
     case 6:
        ret = "almost completely cooled " + ret;
        break;
     default:
        ret ="stone cold " + ret;
        break;
        }
   return ret;
}
string query_long_decay_level() {
   string ret;
   int flag;
   if(query_collective() && query_amount() > 1 ) flag = 1;
   if (this_object()->query_cool_level() == 7){
       return ("It is stone cold. " + ::query_long_decay_level());
   }
   ret = "";
  _cool_level = (time() - _purchase_time)/_cool_rate;
   switch ( _cool_level) {
     case 0..1:
          ret += (flag?
          "They have not yet begun to cool.\n":
          "It has not yet begun to cool.\n");
        break;
     case 2:
           ret += (flag?
           "They have cooled slightly.\n":
           "It has cooled slightly.\n");
        break;
     case 3:
           ret += (flag?
           "They have partially cooled.\n":
           "It has partially cooled.\n");
        break;
     case 4:
           ret += (flag?
           "They are half cooled.\n":
           "It is half cooled.\n");
        break;
     case 5:
           ret += (flag?
           "They have mostly cooled.\n":
           "It has mostly cooled.\n");
        break;
     case 6:
           ret += (flag?
           "They are almost completely cold.\n":
           "It is almost completely cold.\n");
        break;
     default:
           ret += (flag?
           "They are stone cold.\n":
           "It is stone cold.\n");
        break;
        }
    return ret;
}
varargs int do_eat( int no_mess ) {
  int current_warmth;
  int remaining_time;
  int new_warmth;
  int new_time;
  if(this_object()->query_cool_level() >= 7 ){
    if (this_object()->query_weight_per_bite()){
      setup_eat_piece_messages(this_object()->query_cold_eat_piece_message(),
                               this_object()->query_cold_eat_amt_message(),
                               this_object()->query_cold_eat_last_message());
      }
    else {
      set_eat_mess( this_object()->query_cold_eat_message() );
      }
     return( ::do_eat( no_mess ));
  }
  if(this_player()->query_property("warmth")){
    current_warmth = this_player() -> query_property("warmth");
    remaining_time = this_player() -> query_property_time_left("warmth");
    new_warmth = current_warmth+WARM;
    new_time = (remaining_time + WARM_TIME)*0.75;
    this_player()->add_property( "warmth",new_warmth,new_time);
    }
  else{
     this_player()->add_property("warmth",WARM,WARM_TIME);
     }
  if(this_object()->query_weight_per_bite()){
    setup_eat_piece_messages(this_object()->query_hot_eat_piece_message(),
                                 this_object()->query_hot_eat_amt_message(),
                                 this_object()->query_hot_eat_last_message());
      }
  else{
    set_eat_mess( this_object()->query_hot_eat_message() );
    }
  return( ::do_eat( no_mess ) );
}
void set_hot_eat_message(mixed messages){
   _hot_eat_message = messages;
}
void set_cold_eat_message(mixed messages){
   _cold_eat_message = messages;
}
mixed query_hot_eat_message(){
  return _hot_eat_message;
}
mixed query_cold_eat_message(){
  return _cold_eat_message;
}
void setup_hot_eat_piece_messages(mixed piece, mixed amt, mixed last) {
   _hot_eat_piece_message = piece;
   _hot_eat_amt_message = amt;
   _hot_eat_last_message = last;
}
void setup_cold_eat_piece_messages(mixed piece, mixed amt, mixed last) {
   _cold_eat_piece_message = piece;
   _cold_eat_amt_message = amt;
   _cold_eat_last_message = last;
}
mixed query_cold_eat_piece_message(){
  return _cold_eat_piece_message;
}
mixed query_cold_eat_amt_message(){
  return _cold_eat_amt_message;
}
mixed query_cold_eat_last_message(){
  return _cold_eat_last_message;
}
mixed query_hot_eat_piece_message(){
  return _hot_eat_piece_message;
}
mixed query_hot_eat_amt_message(){
  return _hot_eat_amt_message;
}
mixed query_hot_eat_last_message(){
  return _hot_eat_last_message;
}
mixed *stats(){
   mixed *args;
   args =::stats() + ({ ({ "cool level", _cool_level }),
                        ({ "cool rate", _cool_rate }),
                        ({ "purchase time", _purchase_time }) });
   return args;
}
mapping int_query_static_auto_load(){
   return ([ "::" : ::int_query_static_auto_load(),
             "cool_level" : _cool_level,
             "cool rate" : _cool_rate,
             "purchase time" : _purchase_time ]);
}
mapping query_static_auto_load(){
   if ( ( base_name( this_object() ) != "/obj/food" )
       && !query_continuous() ) {
      return 0;
   }
   return int_query_static_auto_load();
}
void init_static_arg( mapping map ){
   if ( !mapp( map ) ) return;
   if ( map[ "::" ] ) ::init_static_arg( map[ "::" ] );
   _cool_level = map[ "cool_level" ];
   _cool_rate = map[ "cool rate" ];
   _purchase_time = map [ "purchase time" ];
}
mapping query_dynamic_auto_load(){
   return ([ "::" : ::query_dynamic_auto_load(),
             "cool_level" : _cool_level,
             "cool rate" : _cool_rate,
             "purchase time" : _purchase_time ]);
}
void init_dynamic_arg( mapping map, object ){
   if ( !mapp( map ) ) return;
   if ( map[ "::" ] ) ::init_dynamic_arg( map[ "::" ] );
   _cool_level = map[ "cool_level" ];
   _cool_rate = map[ "cool rate" ];
   _purchase_time = map [ "purchase time" ];
}
void do_decay() {
   if (this_object()->query_cool_level()>1) return;
   ::do_decay();
}
int query_decays() {
   if (this_object()->query_cool_level()>1) return 0;
   return 1;
}
int query_decay_speed() {
   if (this_object()->query_cool_level()>1) return 0;
   return (::query_decay_speed());
}
int query_decay_level() {
   if (this_object()->query_cool_level()>1) return 0;
   return (::query_decay_level());
}
void set_decay_speed( int decay ) {
  if (this_object()->query_cool_level()>1) return( ::set_decay_speed( 0 ) );
  return( ::set_decay_speed( 7200 ) );
}
void set_main_plural(mixed str) {
   return;
}

==================================================
FILE: implement.c
==================================================

inherit "/std/object";
inherit "/std/basic/holdable";
#include "money.h"
#include <move_failures.h>
#include <virtual.h>
string *un_modifyable;
mixed *wield_func;
void create() {
   holdable::create();
   object::create();
   add_alias("implement");
   add_alias("utensil");
   add_plural("implements");
   if (!query_property("shop type")) {
      add_property("shop type", "general");
   }
}
varargs int move( mixed dest, string messin, string messout ) {
   int ret;
   int limb;
   object holder;
   limb = query_my_limb();
   holder = query_holder();
   ret = holdable::move(dest);
   if (ret != MOVE_OK) {
      return ret;
   }
   ret = object::move( dest, messin, messout );
   if (ret != MOVE_OK && holder) {
      holder->set_hold(this_object(), limb);
   }
   return ret;
}
void dest_me() {
  holdable::dest_me();
  object::dest_me();
}
void player_wield(int pos) {
  if (!environment()) {
    return;
  }
  this_object()->hold_item( environment(), pos );
}
mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/implement" )
     return int_query_static_auto_load();
   return 0;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = object::int_query_static_auto_load();
  return ([ "::" : tmp,
            "hold" : holdable::query_static_auto_load()
            ]);
}
mapping query_dynamic_auto_load() {
  mapping map;
  map = ([
          "::" : object::query_dynamic_auto_load(),
          "hold" : holdable::query_dynamic_auto_load(),
          ]);
  return map;
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) return ;
  if ( map[ "::" ] ) {
    object::init_static_arg( map[ "::" ] );
  }
  holdable::init_static_arg(map);
}
void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );
   holdable::init_dynamic_arg(map["hold"], 1);
   if( virt_name = query_property( VIRTUAL_NAME_PROP) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
}

==================================================
FILE: key.c
==================================================

inherit "std/object";
string type;
void set_type(string str) {
  remove_adjective(type);
  type = str;
  add_adjective(type);
  set_main_plural(type + " keys");
  set_short(type + " key");
}
string query_type() {
  return type;
}
void create() {
  ::create();
  set_name("key");
  set_main_plural("normal keys");
  add_plural("keys");
  type = "normal";
  set_short(query_type() + " key");
  set_long("A key.  Wonder where it fits?\n");
  set_weight(1);
  adjust_money(1, "brass");
}

==================================================
FILE: lantern.c
==================================================

#include <fuel_handler.h>
inherit "/std/object";
#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
int  fuel_left;
int  is_lit;
void create(){
  ::create();
}
string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
  return ::short( 0 );
}
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
}
int do_dowse() {
   return do_extinguish();
}
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}
void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}
void out_of_fuel() {
   object env;
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else
      say( poss_short() +" burns out.\n" );
}
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
   }
}
string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
  return ::pretty_plural(thing);
}
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
}
void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
}
int query_fuel_left() {
    return fuel_left;
}
void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }
    fuel_left = i;
}
int query_max_fuel() {
    return MAX_FUEL;
}

==================================================
FILE: meltable.c
==================================================

#include <bits_controller.h>
#include <weather.h>
inherit "/obj/food";
#define CHILL -5
#define CHILL_TIME 10
#define MELT_RATE_DEFAULT 6
#define WATER "/obj/food/beverages/water.food"
#define _LOOKUP_RATE ({ 60, 57, 54, 51, 48, 42, 36, 30, 27, 24, \
                        20, 18, 16, 14, 12, 10,  9,  8,  7,  6, \
                         6,  6,  6,  5,  5,  5,  4,  4,  4,  3, \
                         3,  3,  3,  3,  3,  3,  3,  3,  3,  2, \
                         2,  2,  2,  2,  2,  2,  2,  2,  2,  1  })
private int _melt_level;
private int _original_melt_level;
private int _melt_rate;
private int _melt_counter;
private int _callout_id;
private string _melt_result;
void create();
void set_melt_result( string result );
string query_melt_result();
void set_melt_rate( int rate );
int query_melt_rate();
int query_melt_level();
private void setup_callout();
protected void do_melt();
void create() {
   do_setup++;
   ::create();
   do_setup--;
   _melt_rate = MELT_RATE_DEFAULT;
   _melt_counter = 0;
   set_melt_result( WATER );
   set_decay_speed( 1 );
   setup_callout();
   if ( !do_setup ) {
      this_object()->setup();
   }
   _melt_level = ( this_object()->query_weight() ) * 10;
   _original_melt_level = _melt_level;
}
void set_melt_result( string result ) {
   _melt_result = result;
}
string query_melt_result() {
   return _melt_result;
}
void set_melt_rate( int rate ) {
   _melt_rate = rate;
}
int query_melt_rate() {
   return _melt_rate;
}
int query_melt_level() {
   return _melt_level;
}
private void setup_callout() {
   if( _callout_id ) {
      remove_call_out( _callout_id );
   }
   _callout_id = call_out( "do_melt", _melt_rate );
}
protected void do_melt() {
   object liquid;
   object room, ob;
   int environment_temp, current_weight;
   ob = environment( this_object() );
   if( !ob ) {
      return;
   }
   room = ob;
   while( ob = environment( ob ) ) {
      room = ob;
   }
   if( room->query_property( "location" ) == "outside" ) {
      environment_temp = WEATHER->query_temperature( room );
   }
   else if( room->query_name() == "clone_on_demand-store" ) {
      environment_temp = 0;
   }
   else {
      environment_temp = 20 + room->query_property( "warmth" );
   }
   if( environment_temp > 1 ) {
      if( environment_temp > 50 ) {
         _melt_rate = 1;
      }
      else {
         _melt_rate = _LOOKUP_RATE[ environment_temp ];
      }
      _melt_level = _melt_level - 1;
      _melt_counter = _melt_counter + 1;
      if ( _melt_counter >= 10 ) {
         liquid = clone_object( _melt_result );
         liquid->set_amount( 20 );
         liquid->move( environment( this_object() ) );
         current_weight = this_object()->query_weight();
         if( current_weight <= 1 ) {
            this_object()->move( "/room/rubbish" );
         }
         else {
            this_object()->set_weight( current_weight - 1 );
         }
         _melt_counter = 0;
      }
   }
   _callout_id = call_out( "do_melt", _melt_rate );
}
string query_short_rotten_adjective() {
   string ret;
   int bing;
   bing = 100 - ( ( 100 * _melt_level ) / _original_melt_level );
   ret = "";
   switch ( bing ) {
   case 0..1:
      break;
   case 2..20:
      ret = "slightly melted " + ret;
      break;
   case 21..45:
      ret = "partially melted " + ret;
      break;
   case 46..55:
      ret = "half melted " + ret;
      break;
   case 56..80:
      ret = "mostly melted " + ret;
      break;
   case 81..100:
      ret = "almost completely melted " + ret;
      break;
   }
   return ret;
}
string query_long_decay_level() {
   string ret;
   int bing;
   bing = 100 - ( ( 100 * _melt_level ) / _original_melt_level );
   ret = "";
   switch ( bing ) {
   case 0..1:
     if( query_collective() && query_amount() > 1 )
        ret += "They have not yet begun to melt.\n";
     else
        ret += "It has not yet begun to melt.\n";
     break;
   case 2..20:
      if( query_collective() && query_amount() > 1 )
         ret += "They have melted slightly.\n";
      else
         ret += "It has melted slightly.\n";
      break;
   case 21..45:
      if( query_collective() && query_amount() > 1 )
         ret += "They have partially melted away.\n";
      else
         ret += "It has partially melted away.\n";
      break;
   case 46..55:
      if( query_collective() && query_amount() > 1 )
         ret += "They are half melted away.\n";
      else
         ret += "It is half melted away.\n";
      break;
   case 56..80:
      if( query_collective() && query_amount() > 1 )
         ret += "They have mostly melted away.\n";
      else
         ret += "It has mostly melted away.\n";
      break;
   case 81..100:
      if( query_collective() && query_amount() > 1 )
         ret += "They have almost complete melted away.\n";
      else
         ret += "It has almost completely melted away.\n";
      break;
   }
    return ret;
}
varargs int do_eat( int no_mess ) {
   this_player()->add_property( "warmth", CHILL, CHILL_TIME );
   return( ::do_eat( no_mess ) );
}
int do_apply( object * things ) {
   int i;
   if( i = ::do_apply( things ) ) {
      things[ 0 ]->add_property( "warmth", CHILL, CHILL_TIME );
   }
   return i;
}
int do_rub( object * things ) {
   int i;
   if( i = ::do_rub( things ) ) {
      things[ 0 ]->add_property( "warmth", CHILL, CHILL_TIME );
   }
   return i;
}
mixed *stats()
{
   mixed *args;
   args =::stats() + ({ ({ "melt level", _melt_level }),
                        ({ "melt result", _melt_result }),
                        ({ "original melt level", _original_melt_level }),
                        ({ "melt rate", _melt_rate }),
                        ({ "melt counter", _melt_counter }),
                        ({ "callout id", _callout_id }) });
   return args;
}
mapping int_query_static_auto_load() {
   return ([ "::" : ::int_query_static_auto_load(),
             "melt_level" : _melt_level,
             "melt_result" : _melt_result,
             "original melt level" : _original_melt_level,
             "melt rate" : _melt_rate,
             "melt counter" : _melt_counter,
             "callout id" : _callout_id ]);
}
mapping query_static_auto_load()
{
   if ( ( base_name( this_object() ) != "/obj/food" )
       && !query_continuous() ) {
      return 0;
   }
   return int_query_static_auto_load();
}
void init_static_arg( mapping map )
{
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_static_arg( map[ "::" ] );
   }
   _melt_level = map[ "melt_level" ];
   _melt_result = map[ "melt_result" ];
   _original_melt_level = map[ "original melt level" ];
   _melt_rate = map[ "melt rate" ];
   _melt_counter = map[ "melt counter" ];
   _callout_id = map[ "callout id" ];
}
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "melt_level" : _melt_level,
             "melt_result" : _melt_result,
             "original melt level" : _original_melt_level,
             "melt rate" : _melt_rate,
             "melt counter" : _melt_counter,
             "callout id" : _callout_id ]);
}
void init_dynamic_arg( mapping map, object )
{
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   }
   _melt_level = map[ "melt_level" ];
   _melt_result = map[ "melt_result" ];
   _original_melt_level = map[ "original melt level" ];
   _melt_rate = map[ "melt rate" ];
   _melt_counter = map[ "melt counter" ];
   _callout_id = map[ "callout id" ];
}
int query_liquid() {
   return 0;
}
void set_liquid() {
}
void do_decay() {
   return;
}
int query_decays() {
   return 0;
}
int query_decay_speed() {
   return 0;
}
int query_decay_level() {
   return 0;
}
void set_decay_speed( int decay ) {
  return( ::set_decay_speed( 1 ) );
}
int do_cure() {
   return 0;
}
int query_cured() {
   return 0;
}
int do_dry() {
   return 0;
}
int query_dried() {
   return 0;
}
int query_rotten() {
   return 0;
}
void set_splashable() {
   return;
}

==================================================
FILE: mineral.c
==================================================

#include <mineral.h>
#define HANDLER "/obj/handlers/cmr_handler"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
#define DEFAULT_MARKET "Ankh-Morpork"
inherit "/obj/food";
nosave string mineral;
void create() {
   ::create();
   set_decay_speed(0);
   remove_help_file("food");
   add_help_file("mineral");
}
varargs void make_mineral( string word, int number, string *inputs ) {
   string adjective, material_adjective, noun, *args;
   mineral = word;
   set_value_info( "material", 1 );
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   set_weight( number );
   switch( number ) {
      case 0 .. PEBBLE :
         adjective = "small";
         noun = "pebble";
         break;
      case PEBBLE + 1 .. STONE :
         adjective = "medium sized";
         noun = "stone";
         break;
      case STONE + 1 .. ROCK :
         adjective = "large";
         noun = "rock";
         break;
      default:
         adjective = "huge";
         noun = "boulder";
   }
   if ( !pointerp( inputs ) )
      args = allocate( 10 );
   else
      args = inputs + ({ 0, 0, 0, 0, 0 });
   if ( !args[ 0 ] ) {
      set_name( noun );
      add_plural( noun +"s" );
   } else {
      set_name( args[ 0 ] );
      if ( !args[ 3 ] )
         add_plural( pluralize( args[ 0 ] ) );
      else
         add_plural( args[ 3 ] );
   }
   if ( !args[ 1 ] ) {
      set_short(material_adjective +" "+ noun);
      set_main_plural(material_adjective +" "+ pluralize( noun ));
   } else {
      set_short( args[ 1 ] );
      if ( !args[ 4 ] )
         set_main_plural( pluralize( args[ 1 ] ) );
      else
         set_main_plural( args[ 4 ] );
   }
   if ( !args[ 2 ] )
      set_long( "This is "+ add_a( adjective ) +" lump of $mineral$.\n" );
   else
      set_long( args[ 2 ] );
   add_adjective( ({ adjective }) + explode( material_adjective, " " ) );
}
string long( string words, int dark ) {
   return replace( ::long( words, dark ), "$mineral$",
         (string)HANDLER->identify_material( mineral, this_player(), 1 ) );
}
string *parse_command_adjectiv_id_list() {
   return explode( (string)HANDLER->identify_material( mineral,
         this_player(), 0 ), " " ) + ::parse_command_adjectiv_id_list();
}
string query_mineral() { return mineral; }
string query_material() { return mineral; }
void init() {
   ::init();
   this_player()->add_command( "pulverise", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "chip", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "smash", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "sprinkle", this_object(),
         "<direct:object:me> [on] <indirect:object>" );
   this_player()->add_command( "sprinkle", this_object(),
         "<direct:object:me>" );
}
int do_eat() {
   if ( (string)this_player()->query_race_ob() != "/std/races/troll" ) {
      this_player()->add_failed_mess( this_object(),
            "What do you think you are, a troll?\n", ({ }) );
      return 0;
   }
   return ::do_eat();
}
int check_tool( object *tools, string *needed ) {
   string word;
   if ( sizeof( tools ) > 1 ) {
      write( "You only need to use one tool at a time.\n" );
      return 0;
   }
   if ( !sizeof( tools ) ) {
      write( "You need to use a tool of some sort.\n" );
      return 0;
   }
   if ( member_array( tools[ 0 ],
         (object *)this_player()->query_holding() ) == -1 ) {
      write( "You need to use a tool that you are holding.\n" );
      return 0;
   }
   foreach ( word in needed ) {
      if ( tools[ 0 ]->id( word ) )
         return 1;
   }
   write( "You need to use a tool appropriate to the job.\n" );
   return 0;
}
int do_pulverise( object *tools ) {
   string material_adjective;
   if ( !check_tool( tools, ({ "hammer" }) ) )
      return 0;
   if ( query_continuous() ) {
      write( "The "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" has already been pulverised.\n" );
      return 0;
   }
   if ( query_weight() > PEBBLE ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is too large to pulverise.\n" );
      return 0;
   }
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   set_name("powder");
   set_short(material_adjective +" powder");
   set_main_plural(material_adjective +" powder" );
   add_plural( "powder" );
   add_property( "determinate", "some " );
   add_adjective( ({ "some", "pinch", "pinches", "handful",
         "handfuls", "of" }) );
   set_long( "This is $pile_size$ of "+ material_adjective +
         " powder, $amount_size$.\n" );
   set_weight_unit( ({ 1, 50 }) );
   set_medium_alias( "Powdered" + capitalize(mineral) );
   set_amount_types( ([ "pinch": ({ 1, "pinches" }),
         "handful": ({ 50, "handfuls" }) ]) );
   set_pile_types( ({ 50, "small", 100, "medium", "large" }) );
   set_continuous();
   set_amount( roll_MdN( 5, 10 ) * query_weight() );
   remove_property("encoded destination");
   move( environment() );
   this_player()->add_succeeded( tools[ 0 ] );
   return 1;
}
int do_chip( object *tools ) {
   object chip;
   if ( query_continuous() )
      return 0;
   if ( !check_tool( tools, ({ "pick", "pickaxe", "hammer" }) ) )
      return 0;
   if ( query_weight() == 1 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is already a chip.\n" );
      return 0;
   }
   set_weight( query_weight() - 1 );
   chip = clone_object( MINERAL );
   chip->make_mineral( mineral, 1 );
   chip->move( environment() );
   this_player()->add_succeeded( tools[ 0 ] );
   return 1;
}
int do_smash( object *tools ) {
   int i, j, largest, number, size;
   object debris, remains;
   if ( query_continuous() )
      return 0;
   if ( !check_tool( tools, ({ "pick", "pickaxe" }) ) )
      return 0;
   if ( query_weight() < ROCK / 2 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is too small to smash.\n" );
      return 0;
   }
   largest = this_player()->query_max_weight();
   if ( largest >= query_weight() )
      largest = query_weight();
   else {
      remains = clone_object( MINERAL );
      remains->make_mineral( mineral, query_weight() - largest );
      remains->move( environment() );
   }
   tools[ 0 ]->hit_weapon( largest, "blunt" );
   number = 2 + random( 4 );
   for ( i = 0; i < 8; i++ ) {
      largest /= number;
      for ( j = 1; j < number; j++ ) {
         size = ( 3 * largest + random( largest ) ) / 4;
         if ( size ) {
            debris = clone_object( MINERAL );
            debris->make_mineral( mineral, size );
            debris->move( environment() );
          }
       }
   }
   this_player()->add_succeeded( tools[0] );
   move( "/room/rubbish" );
   return 1;
}
int do_sprinkle(object *obs) {
    if (!query_continuous())
      return notify_fail(
        "You should pulverise the stuff before you sprinkle it.\n");
   if (!sizeof(obs)) {
     obs=({ environment(this_player()) });
     this_player()->add_succeeded_mess(this_object(),
       "$N $V $D everywhere.\n",({ }));
   } else {
     this_player()->add_succeeded_mess(this_object(),
       "$N $V $D on $I.\n",({ obs[0] }));
   }
   obs[0]->add_effect("/std/effects/other/powdered",
                      (string)HANDLER->query_material_adjective( mineral ) +
                      " powder" );
   call_out("move",0,"/room/rubbish");
   return 1;
}
mixed *stats() {
   return ::stats() + ({
      ({ "mineral", mineral, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "mineral" : mineral,
   ]);
}
void init_static_arg( mapping map ) {
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   if ( !undefinedp( map[ "mineral" ] ) )
      mineral = map[ "mineral" ];
   set_decay_speed(0);
}
mapping query_static_auto_load() {
   if ( ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/mineral" )
         || query_continuous() )
      return int_query_static_auto_load();
   return ([ ]);
}
void set_decay_level( int level ) {
   ::set_decay_level( 0 );
   return;
}

==================================================
FILE: money.c
==================================================

#include <money.h>
#include <move_failures.h>
#include <obj_parser.h>
#define COIN_WEIGHT 10
#define DEF_VALUE 1
#define USE_VAULT DEF_VALUE
inherit "/std/object";
private nosave int no_join;
private nosave int _already_joined;
private mixed *money_array;
private nosave string _long;
int query_value_in(string where);
void create() {
   ::create();
   set_name( "coin" );
   add_alias( MONEY_ALIAS );
   add_plural( "coins" );
   set_main_plural( "coins" );
   add_property( "determinate", "" );
   add_property( "no one", 1 );
   add_property( "money", 1 );
   money_array = ({ });
}
int query_collective() { return 1; }
mapping query_dynamic_auto_load() {
   if (!_already_joined) {
      return ([
         "::" : ::query_dynamic_auto_load(),
         "money array" : money_array,
      ]);
   }
   add_alias(MONEY_ALIAS);
}
void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   money_array = map[ "money array" ];
   if (sizeof(money_array) < 2)  call_out("dest_me", 0);
   short_d = _long = 0;
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
}
int query_merger() { return 1; }
int query_no_join() { return no_join; }
int query_already_joined() { return _already_joined; }
void reset_already_joined() { _already_joined = 0; }
void set_already_joined() { _already_joined = 1; }
void set_no_join() {
#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Called set_no_join\n");
#endif
   no_join = 1;
   call_out( "merge_coins", 0 );
}
void force_no_join()  { no_join = 1; }
void reset_no_join() { no_join = 0; }
int query_number_coins() {
   int i;
   int tot;
   if (_already_joined) {
      return 0;
   }
   for ( i = 1; i < sizeof( money_array ); i += 2 ) {
      tot += money_array[ i ];
   }
   return tot;
}
void fixup_money_weight() {
   set_weight( 1 + query_number_coins() / COIN_WEIGHT );
}
int group_object() { return ( query_number_coins() > 1 ); }
void check_adjectives() {
   int i;
   string* bits;
   set_adjectives( ({ }) );
   set_aliases( ({ }) );
   set_plurals( ({ }) );
   if ( !sizeof( money_array )) {
     if(file_name(environment()) != MONEY_VAULT) {
       _already_joined = 0;
#ifdef DEBUGGER
      if (find_player(DEBUGGER) == this_player())
          tell_creator(DEBUGGER, "MOVING %O to rubbish room\n", this_object());
#endif
#ifdef USE_VAULT
       MONEY_VAULT->add_to_list(this_object());
#else
       move("/room/rubbish");
#endif
     }
     return;
   }
   add_alias( MONEY_ALIAS );
   add_plural( "coins" );
   add_plural("money");
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      bits = explode(lower_case(money_array[ i ]), " ");
      if (sizeof(bits) > 1) {
         add_adjective(bits[0..<2] );
      } else {
         add_adjective(bits);
      }
      if (MONEY_HAND->query_origin_of(money_array[i]) == "default")
         add_adjective(({ "provincial", "default" }));
      add_alias(MONEY_HAND->query_aliases_for(money_array[i]));
      add_adjective(MONEY_HAND->query_adjectives_for(money_array[i]));
      add_plural( (string)MONEY_HAND->query_plural_for( money_array[ i ] ) );
   }
   fixup_money_weight();
}
mixed *query_money_array() {
   if (!_already_joined) {
      return money_array;
   }
   return ({ });
}
varargs int adjust_money( mixed amount, string type ) {
   int i;
   int ret;
   if ( pointerp( amount ) ) {
      for ( i = 0; i < sizeof( amount ); i += 2 ) {
         adjust_money( amount[ i + 1 ], amount[ i ] );
      }
      fixup_money_weight();
      return 1;
   }
   if ( !stringp( type ) || !intp( amount ) || _already_joined) {
      return 0;
   }
   short_d = _long = 0;
   if ( ( i = member_array( type, money_array ) ) == -1 ) {
      money_array += ({ type, amount });
      ret = 1;
   } else {
      money_array[ i + 1 ] += amount;
      if ( money_array[ i + 1 ] <= 0 ) {
         money_array = delete( money_array, i, 2 );
         ret = 0;
      } else {
         ret = 1;
      }
   }
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
   fixup_money_weight();
   if (ret) {
      return money_array[ i + 1 ];
   }
   return 0;
}
void set_money_array( mixed *new_array ) {
   short_d = _long = 0;
   money_array = new_array;
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
   fixup_money_weight();
}
string *half_symbol_short()  {
   int i;
   int value;
   string *retval;
   string *zones = ({ });
   for (i = 0; i < sizeof(money_array); i += 2)
      zones |= ({ MONEY_HAND->query_origin_of(money_array[i]) });
   retval = allocate(sizeof(zones));
   for (i = 0; i < sizeof(zones); i++)  {
      value = query_value_in(zones[i]);
      retval[i] = MONEY_HAND->money_value_string(value, zones[i]);
   }
   return retval;
}
string *half_short( int full ) {
   int i;
   string *retval;
   retval = ({ });
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      if ( money_array[ i + 1 ] < 1 ) {
         continue;
      }
      if ( !full && ( money_array[ i + 1 ] > 12 ) ) {
         retval += ({ "some "+ (string)MONEY_HAND->query_main_plural_for(
               money_array[ i ] ) });
         continue;
      }
      if ( money_array[ i + 1 ] == 1 ) {
         retval += ({ "one "+
               (string)MONEY_HAND->query_short_for( money_array[ i ] ) });
         continue;
      }
      retval += ({ money_array[ i + 1 ] +" "+
            (string)MONEY_HAND->query_main_plural_for( money_array[ i ] ) });
   }
   return retval;
}
string short( int dark ) {
   string *retval;
   if ( short_d ) {
      return short_d;
   }
   retval = half_short( 0 );
   if ( !sizeof( retval ) ) {
      return 0;
   }
   if ( sizeof( retval ) == 1 ) {
      short_d = retval[ 0 ];
   } else {
      short_d = query_multiple_short( retval );
   }
   return short_d;
}
string long( string word, int dark ) {
   int i;
   mixed *details;
   if (dark < -1 || dark > 1) {
      return "It is too dark to see anything about the coins.\n";
   }
   if ( _long ) {
      return _long;
   }
   if ( !sizeof( money_array ) ) {
      return "This is some money that isn't money.\n";
   }
   _long = "";
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      details = (mixed *)MONEY_HAND->query_details_for( money_array[ i ] );
      if ( money_array[ i + 1 ] == 1 ) {
         _long += "The "+ (string)MONEY_HAND->query_short_for(
               money_array[ i ] ) +" shows ";
      } else {
         _long += "The "+ (string)MONEY_HAND->query_main_plural_for(
               money_array[ i ] ) +" show ";
      }
      _long += details[ 2 ] +" on the reverse, and "+ details[ 3 ] +
            " on the obverse.\n";
   }
   return _long;
}
string query_long_details( string word, int dark, object looker) {
   if (dark < -1 || dark > 1) {
      return "It is too dark to see anything about the coins.\n";
   }
   return long(word, dark);
}
object new_money_object(mixed number, string type) {
   int i;
   object money;
   object env;
   object per;
#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Creating new money object from %O\n", this_object());
#endif
   if (!sizeof(money_array) || _already_joined) {
      return 0;
   }
   if (pointerp(number))  {
#ifdef USE_VAULT
      money = MONEY_VAULT->get_money_ob();
#else
      money = clone_object(MONEY_OBJECT);
#endif
      money->set_no_join();
      money->adjust_money(number);
      for (i = 1; i < sizeof(number); i += 2)
         number[i] = -number[i];
      adjust_money(number);
   }
   else  {
      if (!type || type == "") {
         return 0;
      }
      if ((i = member_array(type, money_array)) == -1) {
         return 0;
      }
      if (number > money_array[i + 1]) {
         return 0;
      }
#ifdef USE_VAULT
      money = MONEY_VAULT->get_money_ob();
#else
      money = clone_object(MONEY_OBJECT);
#endif
      money->set_no_join();
      money->adjust_money(number, type);
      adjust_money(-number, type);
   }
   if (money->move(environment()) != MOVE_OK) {
      env = environment();
      do {
        env = environment(env);
      } while (env && money->move(env) != MOVE_OK);
      per = environment();
      while (per && !living(per)) {
         per = environment(per);
      }
      if (money && env)
        tell_object(per, "Oops, the money " + money->the_short() +
                    " has found life in your inventory too heavy and "
                    "has gone to " + env->the_short() + ".\n");
   }
   return money;
}
object merge_coins() {
   object money;
   if (_already_joined)   return this_object();
   remove_alias( MONEY_ALIAS );
   if(environment()) {
     money = present( MONEY_ALIAS, environment() );
   }
   add_alias( MONEY_ALIAS );
   if ( objectp( money ) &&
        money != this_object())
   {
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(this_object());
#else
      move("/room/rubbish");
#endif
      money->adjust_money( money_array );
      money->fixup_money_weight();
      _already_joined = 1;
#ifdef DEBUGGER
      if (find_player(DEBUGGER) == this_player())
         tell_creator(DEBUGGER, "Merging %O and %O\n", this_object(), money);
#endif
      return money;
   }
#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Merge coins returning %O\n", this_object());
#endif
   return this_object();
}
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   if (_already_joined)
     return MOVE_INVALID_DEST;
   if(objectp(dest) && environment(dest) && !living(dest) &&
      !dest->query_corpse() && !dest->query_accept_money())
     return MOVE_INVALID_DEST;
   i = ::move( dest, messin, messout );
   if ( i != MOVE_OK ) {
      return i;
   }
   if((file_name(environment()) == MONEY_VAULT))
     return MOVE_OK;
   if ( ( file_name( environment() ) == "/room/rubbish" ) || no_join ) {
      reset_no_join();
      return MOVE_OK;
   }
   merge_coins();
   return MOVE_OK;
}
public int find_best_fit( mixed word ) {
   int i;
   int best;
   int best_rating;
   int rating;
   string against;
   string *words;
   if ( !word || ( word == "" ) ) {
      return 0;
   }
   if (stringp(word)) {
      words = explode( lower_case( word ), " " ) - ({ "coin", "coins" });
   } else {
      words = word;
   }
   best = -1;
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      rating = 0;
      against = "X "+ replace( money_array[ i ] +" "+
            (string)MONEY_HAND->query_plural_for( money_array[ i ] ),
            " coins", "" ) +" X";
      foreach( word in words ) {
         if ( sscanf( against, "%*s "+ word +" %*s" ) == 2 ) {
            rating++;
         }
      }
      if ( rating > best_rating ) {
         best_rating = rating;
         best = i;
      }
   }
   return best;
}
object query_parse_id( mixed *arr ) {
   int i;
   string *bits;
   object money;
#ifdef DEBUG
   debug_printf("%O", arr );
#endif
   if ( ( arr[ 0 ] < 0 ) || !sizeof( money_array ) ) {
      return 0;
   }
   if ( arr[ 0 ] == 0 ) {
      bits = explode( arr[ 1 ], " " );
      if ( sizeof( bits ) == 1 ) {
         if ( bits[ 0 ] == "coins" ) {
            return this_object();
         }
      }
      if ( member_array( bits[ sizeof( bits ) - 1 ], query_plurals() ) == -1 ) {
         return this_object();
      }
      i = find_best_fit( arr[ 1 ] );
      if ( i == -1 ) {
         return 0;
      }
      money = new_money_object( money_array[ i + 1 ], money_array[ i ] );
      return money;
   }
   i = find_best_fit( arr[ 1 ] );
   if ( i == -1 ) {
      i = 0;
   }
   if ( arr[ 0 ] > money_array[ i + 1 ] ) {
      return 0;
   }
   money = new_money_object( arr[ 0 ], money_array[ i ] );
   return money;
}
mixed* parse_match_object(string* input, object viewer,
                          class obj_match_context context) {
   int ret;
   int found;
   int num;
   int i;
   int j;
   int success;
   object money;
   mixed *matched;
   string where;
   string *bits;
   string name;
   if (!sizeof(money_array)) {
      return 0;
   }
   ret = ::is_matching_object(input, viewer, context);
   if (!ret) {
      return 0;
   }
   if (sizeof(input) == 1 &&
       !context->number_included &&
       !context->ordinal &&
       (input[<1] == "coins" || input[<1] == "money" ||
        input[<1] == "all" || input[<1] == "thing" ||
        input[<1] == "one")) {
      return ({ OBJ_PARSER_MATCH_PLURAL, ({ this_object() }) });
   }
   else if (sizeof(input) >= 2  &&
            member_array(input[0], query_adjectives()) > -1  &&
            (input[<1] == "coins"  ||  input[<1] == "money"))
   {
      success = 0;
      name = lower_case(input[0]);
      if (name == "provincial"  ||  name == "default")  {
         success = 1;
         where = "default";
      }
      else for (i = 0; i < sizeof(money_array); i += 2)  {
         bits = explode(lower_case(money_array[i]), " ");
         if (member_array(name, bits) > -1)  {
            where = MONEY_HAND->query_origin_of(money_array[i]);
            if (!where)
               return 0;
            if (where != "default")
               success = 1;
            break;
         }
      }
      if (success)  {
         matched = MONEY_HAND->filter_legal_money_to_array(money_array,
                                                           where);
         if (sizeof(matched[0]) == 0)
            return 0;
         for (j = 1; j < sizeof(matched[0]); j+= 2)
           num += matched[0][j];
         if (!update_parse_match_context(context, num, ret))
            return 0;
         money = new_money_object(matched[0], "");
         if (!money)
            return 0;
         return ({ ret, ({ money }) });
      }
   }
   found = find_best_fit(input);
   if (found == -1) {
      return 0;
   }
   num = money_array[found + 1];
   num = update_parse_match_context(context, num, ret);
   if (!num) {
      return 0;
   }
   money = new_money_object( num, money_array[found]);
   if (!money) {
      return 0;
   }
   return ({ ret, ({ money }) });
}
int do_not_sell() { return 1; }
int query_value() { return 0; }
int query_value_in( string where ) {
   return (int)MONEY_HAND->query_total_value( money_array, where );
}
int query_money( string type ){
   int i;
   i = member_array( type, money_array );
   if (i == -1 ) {
      return 0;
   }
   return money_array[i + 1];
}
mixed *stats() {
  return ::stats() +
    ({ ({ "value" , query_multiple_short(half_short(1)) }) });
}

==================================================
FILE: monster.c
==================================================

#include <config.h>
#include <living.h>
#include <map.h>
#include <monster.h>
#include <move_failures.h>
#include <player.h>
#include <skills.h>
#include <wander.h>
#include <route.h>
#include <combat.h>
#define SPELL_INCLUDE_CLASS
#include <top_ten_tables.h>
#define SOUL_OBJECT "/obj/handlers/soul"
inherit "/std/living/mon_actions";
inherit "/std/living/living";
inherit "/std/living/response_mon";
inherit "/global/events";
inherit "/global/guild-race";
nosave string cap_name;
nosave mixed *chat_string;
nosave mixed *achat_string;
private nosave mixed *_combat_actions;
nosave mixed _move_after;
nosave mixed *throw_out;
nosave int chat_chance;
nosave int achat_chance;
nosave int aggressive;
nosave int join_fight_type;
nosave int follow_speed;
nosave int virtual_move;
nosave int moves;
nosave string race;
nosave string guild;
nosave string join_fight_mess;
nosave string true_location;
nosave mixed *enter_commands;
nosave string *move_zones;
private nosave mixed *_queued_commands;
private nosave mixed *doing_story;
nosave object last_attacked;
private nosave string *following_route;
private nosave int added_language;
private nosave function cmd_func = 0;
private nosave int cannot_change_position;
private nosave int always_return_to_default_position;
private nosave mapping _spell_actions;
void do_move_after(int running_away);
void do_route_move();
private void _next_queued_command();
void start_attack( object who );
#if !efun_defined(add_action)
protected mixed _process_input(string);
protected mixed command(string);
void command_override(function func);
int drunk_check(string str);
#endif
void create() {
    do_setup++;
    events::create();
    living::create();
    mon_actions::create();
    response_mon::create();
    do_setup--;
    reset_get();
    follow_speed = 3;
    doing_story = ({ ({ }), ({ }) });
    chat_string = ({ 0, ({ }) });
    achat_string = ({ 0, ({ }) });
    move_zones = ({ });
    _spell_actions = ([ ]);
    _combat_actions = ({ });
    enter_commands = ({ });
    known_commands = ({ });
    _queued_commands = ({ });
    following_route = ({ });
    enable_commands();
    living_commands();
    parser_commands();
    communicate_commands();
    command_commands();
    add_property("npc",1);
    set_rows( 24 );
    set_cols( 200 );
    always_return_to_default_position = 5;
#ifdef OLD_SOUL
    add_action("*", "soul_commqz", -2);
#endif
    set_con( 13 );
    set_dex( 13 );
    set_int( 13 );
    set_str( 13 );
    set_wis( 13 );
    set_max_hp( 10000 );
    set_hp( 100000 );
    set_max_gp( 10000 );
    set_gp( 10000 );
    if ( !do_setup )
        this_object()->setup();
    if(clonep())
        call_out(function() {
              if(!environment()) {
                  move(find_object("/room/rubbish"));
              }
          }, 60);
}
void setup_nationality(string nationality, string region) {
   set_nationality(nationality);
   set_nationality_region(region);
   if (!load_object(nationality)) {
      debug_printf("Bad nationality, %O\n", nationality);
   } else {
      if (!nationality->query_region_description(region)) {
         debug_printf("Bad region %O in nationality, %O\n", region,
                      nationality);
      }
      add_language(nationality->query_language());
      set_language(nationality->query_language());
      set_default_language(nationality->query_language());
   }
}
void dest_me() {
    living::dest_me();
}
int soul_commqz(string str) {
    string verb, bit;
    if (sscanf(str, "%s %s", verb, bit) == 2)
        return (int)SOUL_OBJECT->soul_command(verb, bit);
    return (int)SOUL_OBJECT->soul_command(str, "");
}
int query_sp() { return 50; }
int adjust_sp( int number ) { return 50; }
string query_cap_name() {
    return cap_name;
}
void set_cap_name(string s) { cap_name = s; }
int soul_com_force(string str) {
    if (file_name(previous_object()) != SOUL_OBJECT)
        return 0;
    command(str);
    return 1;
}
void set_name(string n) {
    if (query_name() && query_name() != "object")
        return;
    ::set_name(n);
    cap_name = capitalize(query_name());
    add_plural(pluralize(query_name()));
    set_short( query_name() );
    set_long("You see nothing special.\n");
    set_living_name(n);
}
string long(string str, int dark) {
    string s;
    if (dark < -1) {
      s = "You can only make out a rough shape in the glare.\n";
    } else if (dark > 1) {
      s = "You can only make out a rough shape in the gloom.\n";
    } else {
       s = query_long();
    }
    if(!dark) {
        s += capitalize(query_pronoun())+" "+health_string()+".\n";
        s += capitalize(query_pronoun()) + " is " +
            this_object()->query_position_short() + ".\n";
        s += calc_extra_look();
        s += query_living_contents(0);
    }
    return s;
}
int set_race(string str) {
    race = str;
    return 1;
}
string query_race() { return race; }
string query_guild() { return guild; }
string query_class() { return guild; }
string query_profession() { return guild; }
int set_class(string str) {
    guild = str;
}
int set_guild(string str) {
    guild = str;
}
int set_profession(string str) {
    guild = str;
}
void init_equip() { command("equip"); }
int do_command( string words ) {
    if ( this_object()->query_property( PASSED_OUT_PROP ) ) {
        return -1;
    }
    if ( stringp( words ) ) {
        return command( words );
    }
    printf( "Invalid parameter to do_command: %O for monster %O in %O.\n",
      words, this_object(), environment() );
    return -1;
}
void delete_queued_commands() {
  _queued_commands = ({ });
}
mixed *query_queued_commands() {
  return _queued_commands;
}
private void _next_queued_command() {
  mixed next;
  if (!sizeof(_queued_commands)) return;
  if(this_object()->query_casting_spell()){
    call_out( (: _next_queued_command :), 2 );
    return;
  }
  next = _queued_commands[0];
  if (intp( next )) {
    _queued_commands = _queued_commands[1..];
    if (!sizeof(_queued_commands)) return;
    next = _queued_commands[0];
  }
  while (stringp( next )) {
    if (this_object()->queue_commands()) {
      call_out( (: _next_queued_command :), 2 );
      return;
    }
    do_command( next );
    _queued_commands = _queued_commands[1..];
    if (!sizeof(_queued_commands)) return;
    next = _queued_commands[0];
  }
  call_out( (: _next_queued_command :), next );
}
int delay_command( string words, int interval ) {
    if ( this_object()->query_property( PASSED_OUT_PROP ) ) {
        return -1;
    }
    if ( stringp( words ) ) {
      if (!sizeof(_queued_commands)) {
        call_out( (: _next_queued_command :), interval );
      }
      _queued_commands = _queued_commands + ({ interval, words });
      return 1;
    }
    printf( "Invalid parameter to delay_command: %O for monster %O in %O.\n",
      words, this_object(), environment() );
    return -1;
}
varargs int queue_command( string words, int interval ) {
    if ( this_object()->query_property( PASSED_OUT_PROP ) ) {
        return -1;
    }
    if ( stringp( words ) ) {
      if (undefinedp(interval)) interval=2;
      if (!sizeof(_queued_commands)) {
        _queued_commands = ({ words, interval });
        _next_queued_command();
        return 1;
      }
      _queued_commands = _queued_commands + ({ words, interval });
      return 1;
    }
    printf( "Invalid parameter to queue_command: %O for monster %O in %O.\n",
      words, this_object(), environment() );
    return -1;
}
varargs void init_command(string str, int tim) {
    call_out("do_command", tim, str);
}
void init() {
  set_heart_beat( 1 );
  if (environment() && aggressive && this_player() &&
      file_name( environment() )[1..4] != "room" &&
      !environment()->no_attack() &&
      this_player()->query_visible(this_object()))
    start_attack(this_player());
}
void start_attack( object who ) {
  if(!who || !aggressive ) {
    return;
  }
  if ( !who->query_visible( this_object() ) ||
       who->query_auto_loading() ||
       file_name(who) == DEATH ||
       who->query_property( "guest" ) ||
       ( userp( who ) && !interactive( who ) ) ||
       who->query_property( "no attack" ) ) {
    return;
  }
  if(((aggressive > 1) || interactive(who)) &&
     (!interactive(who) || !who->query_auto_loading()))
    this_object()->attack_ob( who );
}
varargs int adjust_hp( int number, object attacker, object weapon,
                         string attack ) {
    set_heart_beat( 1 );
    return ::adjust_hp( number, attacker, weapon, attack );
}
int adjust_gp( int number ) {
    set_heart_beat( 1 );
    return ::adjust_gp( number );
}
int check_anyone_here() {
    object thing;
    if ( !environment() ) {
        return 0;
    }
    if ( file_name( environment() )[1..4] == "room" ) {
        return 0;
    }
    if ( environment()->query_linked() ) {
        return 1;
    }
    foreach( thing in all_inventory( environment() ) ) {
        if ( interactive( thing ) || thing->query_slave() ) {
            return 1;
        }
    }
    return 0;
}
void set_throw_out( int hps, int chance, string their_mess,
  string everyone_mess ) {
    throw_out = ({ hps, chance, their_mess, everyone_mess });
}
mixed *query_throw_out() { return throw_out; }
int run_away() {
    if ( query_property( "run away" ) == -1 ) {
        return 0;
    }
    do_command("lose all");
    become_flummoxed();
    if ( sizeof( following_route ) ) {
        do_route_move();
        return 1;
    }
    if ( query_property( "run away" ) ) {
        this_object()->do_move_after( 1 );
        return 1;
    }
    return ::run_away();
}
string expand_string(string in_str, object on) {
    string *str, ret;
    int i, add_dollar;
    object liv, *obs, ob;
    in_str = "/global/events"->convert_message( in_str );
    str = explode(in_str, "$");
    ret = "";
    for ( i = 0; i < sizeof( str ); i++ ) {
        if ( i % 2 == 0 ) {
            if (add_dollar) {
                ret += "$";
            }
            ret += str[i];
            add_dollar = 1;
            ob = 0;
        } else switch (str[i][0]) {
        case 'm' :
            ob = this_object();
        case 'l' :
          if(!ob) {
            if(!liv) {
              obs = all_inventory(environment()) - ({ this_object() });
              obs = filter_array(obs, (: living($1) &&
                                       $1->query_visible(this_object()) :));
              if (sizeof(obs))
                liv = obs[random(sizeof(obs))];
            }
            if (!liv) {
              break;
            }
            ob = liv;
          }
        case 'a' :
            if ( !ob ) {
                obs = (object *)this_object()->query_attacker_list();
                if ( !sizeof( obs ) )
                    break;
                ob = obs[ random( sizeof( obs ) ) ];
            }
        case 'o' :
            if (!ob) {
                if (!on) {
                    obs = all_inventory(environment());
                    obs = filter_array( obs, (: !living( $1 ) :) );
                    if (sizeof(obs)) {
                        on = obs[random(sizeof(obs))];
                    }
                }
                ob = on;
            }
            switch (str[ i ][ 1 .. ]) {
            case "theshort" :
                ret += (string)ob->the_short();
                add_dollar = 0;
                break;
            case "ashort" :
                ret += (string)ob->a_short();
                add_dollar = 0;
                break;
            case "oneshort":
                ret += (string)ob->one_short();
                add_dollar = 0;
                break;
            case "possshort" :
                ret += (string)ob->poss_short();
                add_dollar = 0;
                break;
            case "name" :
                ret += (string)ob->query_name();
                add_dollar = 0;
                break;
            case "cname" :
                ret += (string)ob->query_cap_name();
                add_dollar = 0;
                break;
            case "gender" :
                ret += (string)ob->query_gender_string();
                add_dollar = 0;
                break;
            case "poss" :
                ret += (string)ob->query_possessive();
                add_dollar = 0;
                break;
            case "obj" :
                ret += (string)ob->query_objective();
                add_dollar = 0;
                break;
            case "gtitle" :
                ret += (string)ob->query_gender_title();
                add_dollar = 0;
                break;
            case "pronoun" :
                ret += (string)ob->query_pronoun();
                add_dollar = 0;
                break;
            default :
                if (add_dollar) {
                    ret += "$";
                }
                ret += str[i];
                add_dollar = 1;
                break;
            }
            ob = 0;
            break;
        default :
            if (add_dollar) {
                ret += "$";
            }
            ret += str[i];
            add_dollar = 1;
            ob = 0;
            break;
        }
    }
    if (strlen(ret) && ret[strlen(ret)-1] == '$') {
        return ret[0..strlen(ret)-2];
    }
    return ret;
}
void expand_mon_string( mixed str ) {
    string *args;
    if ( functionp( str ) ) {
        evaluate( str, this_object() );
    } else {
        if( !stringp( str ) && environment( this_object() ) ) {
            tell_room(environment(this_object()),
              "%^RED%^"+ this_object()->the_short()+
              " says: please bugreport me, I have a bad load_chat.%^RESET%^\n",
              ({ }) );
        }
        switch ( str[ 0 ] ) {
        case '#' :
            args = explode(str[ 1..], ":");
            switch (sizeof(args)) {
            case 1 :
                call_other( this_object(), args[0] );
                break;
            case 2 :
                call_other( this_object(), args[0], args[1] );
                break;
            case 3 :
                call_other( this_object(), args[0], args[1], args[2] );
                break;
            case 4 :
                call_other( this_object(), args[0], args[1], args[2],
                  args[3] );
                break;
            default :
                call_other( this_object(), args[0], args[1], args[2],
                  args[3], args[4] );
                break;
            }
            break;
        case ':' :
        case '\'' :
        case '"' :
            init_command( expand_string( str, 0 ), 1 );
            break;
        case '@' :
            init_command( expand_string( str[ 1 .. ], 0 ), 1 );
            break;
        default :
            tell_room( environment(), expand_string( str, 0 ) +"\n" );
        }
    }
}
int query_ok_turn_off_heart_beat() {
   return 1;
}
void heart_beat() {
  int i, j;
  if(base_name(environment()) == "/room/rubbish") {
    set_heart_beat(0);
    return;
  }
  ::heart_beat();
  RACE_OB->monster_heart_beat( race, guild, race_ob, guild_ob );
  if ( ( hp == max_hp ) && ( gp == max_gp ) ) {
    if (query_ok_turn_off_heart_beat()) {
      if ( !check_anyone_here() ||
           ( !sizeof( achat_string ) && !sizeof( chat_string ) ) ) {
        set_heart_beat( 0 );
        return;
      }
    }
  }
  remove_property( "done follow" );
  this_object()->do_spell_effects( 0 );
  if ( check_anyone_here() ) {
    if ( this_object()->query_fighting() ) {
      if ( sizeof( doing_story[ 1 ] ) ) {
        if( !intp(doing_story[ 1 ][ 0 ] ) ) {
          expand_mon_string( doing_story[ 1 ][ 0 ] );
          doing_story[ 1 ] = doing_story[ 1 ][ 1 .. ];
        } else if( random( 1000 ) < doing_story[ 1 ] [ 0 ]) {
          expand_mon_string( doing_story[ 1 ][ 1 ] );
          if ( sizeof( doing_story[ 1 ] ) == 2 ) {
            doing_story[ 1 ] = ({});
          } else {
            doing_story[ 1 ] = ({ doing_story[ 1 ] [ 0 ] }) +
              doing_story[ 1 ][ 2 .. ];
          }
        }
      } else if ( ( random( 1000 ) < achat_chance )
                  && sizeof( achat_string[ 1 ] ) ) {
        i = random( achat_string[ 0 ] + 1 );
        while ( ( i -= achat_string[ 1 ][ j ] ) > 0 )
          j += 2;
        if ( pointerp( achat_string[ 1 ][ j + 1 ] ) ) {
          if( intp(achat_string[ 1 ][ j + 1 ][ 0 ]) ) {
            if( random(1000) < achat_string[ 1 ][ j + 1 ][ 0 ] ) {
              expand_mon_string( achat_string[ 1 ][ j + 1 ][ 1 ] );
              doing_story[ 1 ] = ({ achat_string[ 1 ][ j + 1 ][ 0 ] })+
                achat_string[ 1 ][ j + 1 ][ 2 .. ];
            } else {
              doing_story[ 1 ] = achat_string[ 1 ][ j + 1 ];
            }
          } else {
            expand_mon_string( achat_string[ 1 ][ j + 1 ][ 0 ] );
            doing_story[ 1 ] = achat_string[ 1 ][ j + 1 ][ 1 .. ];
          }
        } else
          expand_mon_string( achat_string[ 1 ][ j + 1 ] );
      }
    } else {
      if ( sizeof( doing_story[ 0 ] ) ) {
        if( !intp( doing_story[ 0 ][ 0 ] ) ) {
          expand_mon_string( doing_story[ 0 ][ 0 ] );
          doing_story[ 0 ] = doing_story[ 0 ][ 1 .. ];
        } else if( random( 1000 ) < doing_story[ 0 ][ 0 ]) {
          expand_mon_string( doing_story[ 0 ][ 1 ] );
          if ( sizeof( doing_story[ 0 ] ) == 2 ) {
            doing_story[ 0 ] = ({});
          } else {
            doing_story[ 0 ] = ({ doing_story[ 0 ] [ 0 ] }) +
              doing_story[ 0 ][ 2 .. ];
          }
        }
      } else if ( ( random( 1000 ) < chat_chance )
                  && sizeof( chat_string[ 1 ] ) ) {
        i = random( chat_string[ 0 ] + 1 );
        while ( ( i -= chat_string[ 1 ][ j ] ) > 0 )
          j += 2;
        if ( pointerp( chat_string[ 1 ][ j + 1 ] ) ) {
          if( intp( chat_string[ 1 ][ j + 1 ][ 0 ]) ) {
            if(random( 1000) < chat_string[ 1 ][ j + 1 ][ 0 ]) {
              expand_mon_string( chat_string[ 1 ][ j + 1 ][ 1 ] );
              doing_story[ 0 ] = ({ chat_string[ 1 ][ j + 1 ][ 0 ] }) +
                chat_string[ 1 ][ j + 1 ][ 2 .. ];
            } else {
              doing_story[ 0 ] = chat_string[ 1 ][ j + 1 ];
            }
          } else {
            expand_mon_string( chat_string[ 1 ][ j + 1 ][ 0 ] );
            doing_story[ 0 ] = chat_string[ 1 ][ j + 1 ][ 1 .. ];
          }
        } else
          expand_mon_string( chat_string[ 1 ][ j + 1 ] );
      }
    }
  }
}
int clean_up( int parent ) {
  if(query_property("unique") || check_anyone_here())
    return 1;
  if(parent) {
    log_file("CLEANUP", "%s %s cleaned up.\n", ctime(time()),
             file_name(this_object()));
  }
  move( "/room/rubbish" );
  return 1;
}
int rand_num(int no, int type) {
    int i, val;
    for (i=0;i<no;i++)
        val = random(type)+1;
    return val;
}
void set_random_stats(int no, int type) {
    set_str(rand_num(no, type));
    set_dex(rand_num(no, type));
    set_int(rand_num(no, type));
    set_con(rand_num(no, type));
    set_wis(rand_num(no, type));
}
void basic_setup(string race, string guild, int level)
{
    this_object()->set_race(race);
    this_object()->set_guild(guild);
    this_object()->set_level(level);
}
void set_level( int i ) { RACE_OB->set_level( i, race, guild ); }
int give_money(int base, int rand, string type) {
    if (!type)
        type = "copper";
    return adjust_money(base+random(rand), type);
}
void load_chat(int chance, mixed *c_s) {
    int i;
    chat_string = ({ 0, ({ }) });
    for (i=0;i<sizeof(c_s);i+=2) {
        chat_string[1] += ({ c_s[i], c_s[i+1] });
        chat_string[0] += c_s[i];
    }
    chat_chance = chance;
}
void set_chat_chance(int i) { chat_chance = i; }
int query_chat_chance() { return chat_chance; }
void set_chat_string(string *chat) { chat_string = chat; }
string *query_chat_string() { return chat_string; }
void add_chat_string(mixed weight, mixed chat) {
    int i;
    if (pointerp(weight)) {
        for (i=0;i<sizeof(weight);i+=2) {
            add_chat_string(weight[i], weight[i+1]);
        }
    } else {
        if (member_array(chat, chat_string[1]) == -1) {
            chat_string[1] += ({ weight, chat });
            chat_string[0] += weight;
        }
    }
}
void remove_chat_string(mixed chat) {
    int i;
    if (pointerp(chat)) {
        for (i=0;i<sizeof(chat);i++) {
            remove_chat_string(chat[i]);
        }
    } else {
        if ((i = member_array(chat, chat_string[1])) != -1) {
            chat_string[0] -= chat_string[1][i-1];
            chat_string[1] = delete(chat_string[1], i-1, 2);
        }
    }
}
void load_a_chat(int chance, mixed *c_s) {
    int i;
    achat_string = ({ 0, ({ }) });
    for (i=0;i<sizeof(c_s);i+=2) {
        achat_string[1] += ({ c_s[i], c_s[i+1] });
        achat_string[0] += c_s[i];
    }
    achat_chance = chance;
}
void set_achat_chance(int i) { achat_chance = i; }
int query_achat_chance() { return achat_chance; }
void set_achat_string(string *chat) { achat_string = chat; }
string *query_achat_string() { return achat_string; }
void add_achat_string(mixed weight, mixed chat) {
    int i;
    if (pointerp(weight))
        for (i=0;i<sizeof(weight);i+=2)
            add_achat_string(weight[i], weight[i+1]);
    else
    if (member_array(chat, achat_string[1]) == -1) {
        achat_string[1] += ({ chat });
        achat_string[0] += weight;
    }
}
void remove_achat_string(mixed chat) {
    int i;
    if (pointerp(chat))
        for (i=0;i<sizeof(chat);i++)
            remove_achat_string(chat[i]);
    else
    if ((i = member_array(chat, achat_string[1])) != -1) {
        achat_string[0] -= achat_string[1][i-1];
        achat_string[1] = delete(achat_string[1], i-1, 1);
    }
}
void add_move_zone(mixed zone) {
    int i;
    if (pointerp(zone))
        for (i=0;i<sizeof(zone);i++)
            add_move_zone(zone[i]);
    else if (member_array(zone, move_zones) != -1)
        return;
    else
        move_zones += ({ zone });
}
void set_move_zones(string *zones) {
    int i;
    for (i=0;i<sizeof(zones);i++)
        add_move_zone(zones[i]);
}
void remove_move_zone(mixed zone) {
    int i;
    if (pointerp(zone))
        for (i=0;i<sizeof(zone);i++)
            remove_move_zone(zone[i]);
    else {
        if ((i=member_array(zone, move_zones)) == -1)
            return ;
        move_zones = delete(move_zones, i, 1);
    }
}
string *query_move_zones() { return move_zones; }
void set_move_after(int after, int rand) {
    _move_after = ({ after, rand });
    if (after != 0 && rand != 0) {
        do_move_after(0);
    }
}
mixed query_move_after() {
   return copy( _move_after );
}
int add_enter_commands(mixed str) {
    if (stringp(str)) {
        enter_commands += ({ str });
    } else if (pointerp(str)) {
        enter_commands += str;
    } else if (functionp(str)) {
        enter_commands += ({ str });
    }
    return 1;
}
string *query_enter_commands() { return enter_commands; }
void reset_enter_commands() { enter_commands = ({ }); }
varargs int move( mixed dest, string messin, string messout ) {
    int result;
    object before;
    before = environment();
    result = living::move( dest, messin, messout );
    if ( result == MOVE_OK ) {
        me_moveing( before );
        if ( virtual_move )
            true_location = file_name( environment() );
    }
    return result;
}
void room_look() {
    int i;
    ::room_look();
    for ( i = 0; i < sizeof( enter_commands ); i++ ) {
        if ( functionp( enter_commands[ i ] ) ) {
            call_out( enter_commands[ i ], 2 * i + 1, this_object() );
            continue;
        }
        if ( enter_commands[ i ][ 0 .. 0 ] == "#" )
            call_out( enter_commands[ i ][ 1 .. 99 ], 2 * i + 1 );
        else
            init_command( enter_commands[ i ], 2 * i + 1 );
    }
}
void do_move_after (int running_away ) {
    if (sizeof(following_route)) {
        do_route_move();
    } else {
        WANDER_HANDLER->move_after( running_away );
    }
}
void event_fight_in_progress(object me, object him) {
  mixed action;
  int i;
  if(sizeof(this_object()->query_attacker_list())) {
    for(i=0; i<sizeof(_combat_actions); i+= 3) {
      if(_combat_actions[i] > random(100)) {
        action = _combat_actions[i+2];
        if(stringp(action))
          this_object()->do_command(action);
        else if(functionp(action))
          evaluate(action, me, him);
        else if(pointerp(action) && sizeof(action) == 1 && stringp(action[0]))
          call_other(this_object(), action[0], me, him);
        else if(pointerp(action) && sizeof(action) == 2)
          call_other(action[0], action[1], this_object(), me, him);
      }
    }
  }
  if(him == this_object() && this_object()->query_property("see_caster") &&
     !userp(me) &&
     (random(him->query_property("see_caster"))) < (him->query_int()))
    this_object()->attack_ob(me->query_owner());
  if(!join_fight_mess || !me || !him)
    return;
  if(him == this_object())
    return;
  if(!join_fight_type && !interactive(him))
    return;
  if(member_array(him, (object *)this_object()->query_attacker_list()) == -1) {
    if(!him->query_property("no attack")) {
      if(join_fight_mess)
        expand_mon_string(join_fight_mess);
      this_object()->attack_ob(him);
    }
  }
}
void set_join_fights(string str) { join_fight_mess = str; }
string query_join_fights() { return join_fight_mess; }
void set_join_fight_type(int i) { join_fight_type = i; }
int query_fight_type() { return join_fight_type; }
void event_exit( object me, string mess, object to ) {
  mixed *bing;
  int i, j, k;
  string *zones, fname;
  object *attacker_list, ob;
  events::event_exit( me, mess, to );
  living::event_exit( me, mess, to );
  if (!_move_after || sizeof(following_route))
    return ;
  if ( !to || !me->query_visible(this_object()))
    return;
  attacker_list = this_object()->query_attacker_list();
  if(attacker_list && sizeof(attacker_list)) {
    if (member_array(me, attacker_list) == -1)
      return;
    attacker_list -= ({ me });
    foreach(ob in attacker_list) {
      if(ob && environment(ob) == environment())
        return;
    }
  } else {
    return;
  }
  bing = (mixed *)environment()->query_dest_dir( this_object() );
  if( !bing ) {
    return ;
  }
  fname = file_name( to );
  if ((i = member_array(fname, bing)) == -1) {
    return ;
  }
  if (!this_object()->query_property("unrestricted follow")) {
    zones = (string *)to->query_zones();
    if (move_zones && (j = sizeof(move_zones))) {
      while (j--) {
        if (member_array(move_zones[j], zones) != -1) {
          k = 1;
          break;
        }
      }
      if (!k)
        return;
    } else
      return;
  }
  remove_call_out("do_follow_move");
  call_out("do_follow_move", 4 + random(follow_speed), bing[i-1]);
}
void do_follow_move(string dir) {
  if (sizeof(following_route))
    return ;
  this_object()->adjust_action_defecit((ACTIONS_PER_HB / (COMBAT_SPEED + 1)));
  do_command(dir);
}
void add_combat_action( int chance, string name, mixed action ) {
    int i;
    i = member_array( name, _combat_actions );
    if ( i == -1 ) {
        _combat_actions += ({ chance, name, action });
    } else {
        _combat_actions[ i - 1 ] = chance;
        _combat_actions[ i + 1 ] = action;
    }
}
int remove_combat_action( string name ) {
    int i;
    i = member_array( name, _combat_actions );
    if ( i == -1 )
        return 0;
    _combat_actions = delete( _combat_actions, i - 1, 3 );
    return 1;
}
mixed *query_combat_actions() { return copy( _combat_actions ); }
void do_combat_action( object player,
                       object target,
                       mixed action ) {
   object place;
   if ( !target ) {
      return;
   }
   place = environment( target );
   if ( place != environment( player ) ) {
      return;
   }
   if ( stringp( action ) ) {
      do_command( action );
      return;
   }
   if (functionp(action)) {
      evaluate(action, player, target);
   }
   if ( pointerp(action) && sizeof(action) == 1 && stringp( action[ 0 ] ) ) {
      call_other( this_object(), action[ 0 ], player, target );
      return;
   }
   if (pointerp(action) && sizeof(action) == 2) {
      call_other( action[ 0 ], action[ 1 ], this_object(), player, target );
   }
}
void combat_actions_call_back( object player, object target ) {
  int i;
  object thing;
  object *things;
  mixed *actions;
  if ( !player || !target ) {
    return;
  }
  thing = environment( player );
  if ( thing != environment( target ) ) {
    return;
  }
  things = filter_array( all_inventory( thing ), (: living( $1 ) ==
                                                  !userp( $1 ) :) );
  foreach ( thing in things ) {
    actions = (mixed *)thing->query_combat_actions();
    for(i=0; i<sizeof(actions); i += 3) {
      if(actions[i] > random(100)) {
        call_out( "do_combat_action", 1, player, target, actions[ i + 2 ] );
      }
    }
  }
}
void add_spell_action(string spell_object, int chance,
                     string name, mixed action) {
   if (!_spell_actions[spell_object]) {
      _spell_actions[spell_object] = ([ ]);
   }
   _spell_actions[spell_object][name] = ({ chance, action });
}
int remove_spell_action(string name) {
   string spell;
   mapping bits;
   int ret;
   foreach (spell, bits in _spell_actions) {
      if (bits[name]) {
         map_delete(bits, name);
         ret = 1;
      }
   }
   return ret;
}
mapping query_spell_actions() {
   return _spell_actions;
}
void do_spell_action( object caster,
                      object* targets,
                      mixed action,
                      mixed args ) {
   if ( stringp( action ) ) {
      do_command( action );
      return;
   }
   if (functionp(action)) {
      evaluate(action, caster, targets);
   }
   if ( pointerp(action) && sizeof(action) == 1 && stringp( action[ 0 ] ) ) {
      call_other( this_object(), action[ 0 ], caster, targets, args );
      return;
   }
   if (pointerp(action) && sizeof(action) == 2) {
      call_other( action[ 0 ], action[ 1 ], this_object(), caster, targets,
                  args );
   }
}
mixed query_race_ob() { return race_ob; }
void set_race_ob(mixed r) { race_ob = r; }
mixed query_guild_ob() { return guild_ob; }
void set_guild_ob(mixed g) { guild_ob = g; }
int query_follow_speed() { return follow_speed; }
void set_follow_speed(int f) { follow_speed = f; }
int query_aggressive() { return aggressive; }
void set_aggressive(int a) {
    aggressive = a;
    if (a && !join_fight_mess) {
        join_fight_mess = this_object()->one_short()+" joins in the fight.\n";
    }
}
int query_level() {
    if (!guild_ob) return 1;
    return (int)guild_ob->query_level(this_object());
}
int query_death_xp() {
    int amount;
    if ( query_property( "dead" ) || query_property( "unique" ) ) {
        return 0;
    }
    amount = (int)TOP_TEN_HANDLER->calculate_rating( this_object() );
    return amount / 2;
}
mixed *stats() {
    mixed *bing;
    int i;
    bing = ({ });
    for (i=0;i<sizeof(move_zones);i++)
        bing += ({ ({ "move zone "+i, move_zones[i] }) });
    if (!query_move_after())
        return ::stats() + ({
          ({ "guild", query_guild() }),
          ({ "guild ob", query_guild_ob() }),
          ({ "race", query_race() }),
          ({ "race ob", query_race_ob() }),
          ({ "join_fights", query_join_fights() }),
          ({ "follow speed", query_follow_speed() }),
          ({ "level", query_level() }),
          ({ "chat chance", query_chat_chance() }),
          ({ "achat chance", query_achat_chance() }),
          ({ "aggressive", query_aggressive() }),
          ({ "route", (sizeof(following_route)?implode(following_route, ", "):
              "not going anywhere") }),
        }) + bing;
    return ::stats() + ({
      ({ "race", query_race() }),
      ({ "race ob", query_race_ob() }),
      ({ "guild", query_guild() }),
      ({ "guild ob", query_guild_ob() }),
      ({ "join fights", query_join_fights() }),
      ({ "follow_speed", query_follow_speed() }),
      ({ "level", query_level() }),
      ({ "chat chance", query_chat_chance() }),
      ({ "achat chance", query_achat_chance() }),
      ({ "aggressive", query_aggressive() }),
      ({ "move after-fix", query_move_after()[0] }),
      ({ "move after-rand", query_move_after()[1] }),
      ({ "route", (sizeof(following_route)?implode(following_route, ", "):
          "not following anyone") }),
    }) + bing;
}
string expand_nickname(string str) { return str; }
void event_enter( object dest, string mess, object from ) {
    if( environment( this_object() ) &&
      file_name( environment( this_object() ) )[ 1 .. 4 ] == "room" )
        return;
    if(check_anyone_here() && (moves > 2)){
        moves = 0;
        do_move_after(0);
    }
    living::event_enter( dest, mess, from );
    events::event_enter( dest, mess, from );
}
void event_person_say( object thing, string start, string mess, string lang,
                       string accent) {
    response_mon::event_person_say(thing, start, mess, lang);
}
void event_whisper( object thing, string start, string mess, object *obs,
  string lang, object me) {
    response_mon::event_whisper( thing, mess, obs, lang, me);
}
varargs void event_soul( object thing, string mess, mixed avoid, string verb,
  string last, mixed at ) {
    response_mon::event_soul( thing, mess, avoid, verb, last, at );
    events::event_soul( thing, mess, avoid );
}
void real_room( string check_room ) {
    if ( check_room == true_location ) {
        move_object( true_location );
    }
}
#if !efun_defined(add_action)
int query_virtual_move() { return virtual_move; }
#else
int query_virtual_move() { return 0; }
#endif
void set_virtual_move( int number ) {
    if(virtual_move && !number && file_name(environment()) == "/room/virtual"){
        object ob = load_object(true_location);
        if(ob)
            move(ob);
    }
    virtual_move = number;
    if ( virtual_move && environment() )
        true_location = file_name( environment() );
}
string query_true_location() { return true_location; }
void set_true_location( string word ) {
    if(word == "/room/virtual"){
        if(true_location)
            return;
        word = file_name(environment());
        if(word == "/room/virtual"){
            move("/room/rubbish");
            true_location = "/room/rubbish";
        }
    }
    true_location = word;
}
int cleaning_room() {
    if ( virtual_move ) {
        true_location = file_name( environment() );
        "/room/virtual"->force_load();
        move_object( "/room/virtual" );
        return 1;
    }
    return 0;
}
void do_move( string move ) {
    if (1 || check_anyone_here()) {
        moves = 0;
    }
    if (moves++ < 3) {
        string tmp;
        command(move);
        tmp = file_name(environment());
        if(tmp == "/room/virtual")
            tmp = true_location;
        true_location = tmp;
    } else {
        WANDER_HANDLER->delete_move_after(this_object());
    }
}
string get_next_route_direction() {
    string direc;
    if (!sizeof(following_route)) {
        return 0;
    }
    direc = following_route[0];
    following_route = following_route[1..];
    return direc;
}
int query_last_route_direction() { return ( sizeof(following_route) ? 1 : 0 ); }
string *query_following_route() { return following_route; }
void do_route_move() {
    if (!sizeof(following_route)) {
        return ;
    }
    do_command(get_next_route_direction());
}
protected void got_the_route(string *route, int delay, string dest) {
    following_route = route;
    if (sizeof(route)) {
        WANDER_HANDLER->move_me_please(delay, dest);
        do_route_move();
    } else {
        this_object()->stopped_route();
    }
}
varargs void move_me_to(string dest, int delay) {
    string *dest_dir, *start_dir;
    if (!environment() || !file_name(environment()))
        return ;
    if(!delay)
      delay = 10;
    if (!MAP->static_query_short( dest ) ||
      !MAP->static_query_short( file_name(environment()) ) ) {
       if (!sizeof( dest_dir = dest->query_dest_dir( this_object() ) ) ||
           !sizeof( start_dir =
               environment()->query_dest_dir( this_object() ) ) )
       {
            move( dest, "$N wanders in.\n", "$N wanders off.\n" );
        } else {
            move( dest,
              replace_string( query_msgin(), "$F",
                dest_dir[random(sizeof(dest_dir)/2)*2]),
              replace_string( query_msgout(), "$T",
                start_dir[random(sizeof(start_dir)/2)*2]));
        }
        call_out( "stopped_route", 1 );
        return;
    }
    ROUTE_HANDLER->get_route(dest, file_name(environment()),
      (: got_the_route($1, $(delay), $(dest)) :));
}
string identify( object thing, object *places ) {
    do_command( "'Please bug me!  I'm using identify()!" );
    return file_name( thing );
}
int query_time_left() { return 1; }
int ignore_identifier() { return 1; }
void add_language(string str) {
    ::add_language(str);
    added_language = 1;
}
void set_cannot_change_position(int flag) {
    cannot_change_position = flag;
}
int query_cannot_change_position() {
    return cannot_change_position;
}
void set_position(string new_pos) {
    if (always_return_to_default_position) {
        if (new_pos != query_position() &&
          this_player() != this_object()) {
            call_out("return_to_default_position",
              always_return_to_default_position, 0);
        }
    }
    ::set_position(new_pos);
}
void set_always_return_to_default_position(int tim) {
    always_return_to_default_position = tim;
}
int query_always_return_to_default_position() {
    return always_return_to_default_position;
}
mapping int_query_static_auto_load() {
    return ([
      "::" : ::int_query_static_auto_load(),
      "cap name" : cap_name,
      "race" : race,
      "guild" : guild,
    ]);
}
mixed query_static_auto_load() {
    if ( base_name(this_object()) + ".c" == __FILE__ )
        return int_query_static_auto_load();
    return ([ ]);
}
mapping query_dynamic_auto_load() {
    return ([
      "::" : ::query_dynamic_auto_load(),
      "chat string"                       : chat_string,
      "achat string"                      : achat_string,
      "combat actions"                    : _combat_actions,
      "move after"                        : _move_after,
      "throw out"                         : throw_out,
      "chat chance"                       : chat_chance,
      "achat chance"                      : achat_chance,
      "aggressive"                        : aggressive,
      "join fight type"                   : join_fight_type,
      "join fight mess"                   : join_fight_mess,
      "follow speed"                      : follow_speed,
      "virtual move"                      : virtual_move,
      "moves"                             : moves,
      "true location"                     : true_location,
      "enter commands"                    : enter_commands,
      "move zones"                        : move_zones,
      "doing story"                       : doing_story,
      "last attacked"                     : last_attacked,
      "following route"                   : following_route,
      "added language"                    : added_language,
      "cannot change position"            : cannot_change_position,
      "always return to default position" : always_return_to_default_position,
      "level"                             : query_level(),
    ]);
}
void init_static_arg(mapping args) {
    if (args["::"])
        ::init_static_arg(args["::"]);
    if (!undefinedp(args["cap name"]))
        cap_name = args["cap name"];
    if (!undefinedp(args["race"]))
        race = args["race"];
    if (!undefinedp(args["guild"]))
        guild = args["guild"];
}
void init_dynamic_arg( mapping args, object ob ) {
    if (args["::"])
        ::init_static_arg(args["::"]);
    if (!undefinedp(args["chat string"]))
        chat_string = args["chat string"];
    if (!undefinedp(args["achat string"]))
        achat_string = args["achat string"];
    if (!undefinedp(args["combat actions"]))
        _combat_actions = args["combat actions"];
    if (!undefinedp(args["move after"]))
        _move_after = args["move after"];
    if (!undefinedp(args["throw out"]))
        throw_out = args["throw out"];
    if (!undefinedp(args["chat chance"]))
        chat_chance = args["chat chance"];
    if (!undefinedp(args["achat chance"]))
        achat_chance = args["achat chance"];
    if (!undefinedp(args["aggressive"]))
        aggressive = args["aggressive"];
    if (!undefinedp(args["join fight type"]))
        join_fight_type = args["join fight type"];
    if (!undefinedp(args["join fight mess"]))
        join_fight_mess = args["join fight mess"];
    if (!undefinedp(args["follow speed"]))
        follow_speed = args["follow speed"];
    if (!undefinedp(args["virtual move"]))
        virtual_move = args["virtual move"];
    if (!undefinedp(args["moves"]))
        moves = args["moves"];
    if (!undefinedp(args["true location"]))
        true_location = args["true location"];
    if (!undefinedp(args["enter commands"]))
        enter_commands = args["enter commands"];
    if (!undefinedp(args["move zones"]))
        move_zones = args["move zones"];
    if (!undefinedp(args["doing story"]))
        doing_story = args["doing story"];
    if (!undefinedp(args["last attacked"]))
        last_attacked = args["last attacked"];
    if (!undefinedp(args["following route"]))
        following_route = args["following route"];
    if (!undefinedp(args["added language"]))
        added_language = args["added language"];
    if (!undefinedp(args["cannot change position"]))
        cannot_change_position = args["cannot change position"];
    if (!undefinedp(args["always return to default position"]))
        always_return_to_default_position =
        args["always return to default position"];
    if (!undefinedp(args["level"]))
        set_level(args["level"]);
}
int attack_permission( object ob1, object ob2, string stringy ) { return 0; }
#if !efun_defined(add_action)
protected mixed _process_input(string str) {
    object ob = this_player();
    if(str == "")
        return 0;
    _notify_fail(0);
    efun::set_this_player(this_object());
    if(!this_object()->drunk_check(str))
        if(!this_object()->exit_command(str))
            if(!this_object()->cmdAll(str))
                if(!this_object()->new_parser(str))
                    if(!this_object()->lower_check(str)){
                        efun::set_this_player(ob);
                        return 0;
                    }
    efun::set_this_player(ob);
    return "bing";
}
int drunk_check(string str) {
   if(cmd_func){
     object owner = function_owner(cmd_func);
     if(owner && owner == environment(this_player())){
       int res = evaluate(cmd_func, str);
       if(res)
         return res;
     } else cmd_func = 0;
   }
   return 0;
}
void command_override(function func) {
  if(!functionp(func))
    error("command_override needs a function!");
  cmd_func = func;
}
protected mixed command(string cmd){
  int time = eval_cost();
  if(_process_input(cmd))
    return eval_cost() - time + 1;
  return 0;
}
#endif
int _living(){return 1;}
void event_hide_invis( object hider, int adding, string type, int quiet ) {
   if ( aggressive &&
        !adding &&
        environment() &&
        file_name( environment() )[1..4] != "room" )
   {
      start_attack(hider);
   }
}

==================================================
FILE: multiple_scabbard.c
==================================================

#include <move_failures.h>
inherit "/obj/scabbard";
int capacity, throwable;
int query_clothing() { return 1; }
int query_throwable() { return throwable; }
int query_capacity() { return capacity; }
string query_pocket_mess() { return "$ob_short$"; }
void set_throwable(int i) { throwable = i; }
void set_capacity(int i) { capacity = i; }
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_no_types_in_long(1);
   if( !do_setup )
      this_object()->setup();
}
void throw( object * knives, object * targets ) {
   ( "cmds/living/th_row" )->cmd( ({ knives, targets }), 0, "at" );
}
int do_hurl( object * knives, object * targets, int targeted ) {
   object knife, target;
   if( this_player()->query_property( "dead" ) ) {
      add_failed_mess( "You're dead!\n" );
      return -1;
   }
   if( this_object()->query_worn_by() != this_player() ) {
      add_failed_mess( "You must be wearing " + this_object()->the_short()
        + " to hurl weapons from it.\n" );
      return targeted ? -1 : 0;
   }
   if( sizeof( targets ) > 1 ) {
      add_failed_mess( "You can only throw at one target at a time.\n" );
      return -1;
   }
   target = targets[0];
   if( target == this_player() ) {
      add_failed_mess( "Don't be silly.\n" );
      return -1;
   }
   if( target->query_property( "dead" ) ) {
      add_failed_mess( target->the_short(1) + " is dead.\n" );
      return -1;
   }
   if( pk_check( this_player(), target ) ) {
      add_failed_mess( "You really shouldn't do that.\n" );
      return 0;
   }
   if( sizeof( knives ) > 1 ) {
      add_failed_mess( "You can only throw one weapon at a time.\n" );
      return 0;
   }
   knife = knives[0];
   if( knife->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You can't draw " + knife->the_short() + " from "
        + the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if( this_player()->query_free_limbs() < 1 ) {
      knife->move( this_object() );
      add_failed_mess( "You need a free hand.\n" );
      return -1;
   }
   if( !sizeof( knife->hold_item( this_player() ) ) ) {
      knife->move( this_object() );
      add_failed_mess( "You cannot hold " + knife->the_short() + ".\n" );
      return -1;
   }
   add_succeeded_mess( "$N snatch$es " + knife->a_short() + " from $D.\n" );
   call_out( "throw", 0, knives, targets );
   return 1;
}
int test_add( object thing, int flag, int noprint ) {
   int foo;
   if(flag)
      return 0;
   if( !environment( thing ) )
      return ::test_add( thing, flag );
   if( sizeof( all_inventory( this_object() ) ) >= capacity ) {
      if( !noprint )
         write( the_short() + " is already full.\n" );
      return 0;
   }
   foo = test_type_ok( thing, flag );
   if(foo)
      return foo;
   if( !noprint )
      write( thing->the_short() + " doesn't fit very well in "
        + the_short() + ".  " + sheath );
   return 0;
}
void init() {
   if( query_throwable() ) {
      add_command( "hurl",
        "<indirect:object:direct-obs'weapon'> at <indirect:living:here>",
        (: do_hurl( $1[0], $1[1], 0 ) :) );
      add_command( "hurl",
        "<indirect:object:direct-obs'weapon'> at <indirect:living:here> "
          "from <direct:object:me>",
        (: do_hurl( $1[0], $1[1], 1 ) :) );
   }
}

==================================================
FILE: package.c
==================================================

inherit "/obj/baggage";
int query_value() {
  int value;
  object ob;
  value = ::query_value();
  foreach(ob in all_inventory())
    value += ob->query_value();
  return value;
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

==================================================
FILE: peddler.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <virtual.h>
#define MAX_PROP "max per reset"
#define TYPE "item shop type"
#define NUM_SOLD "number removed this reset"
#define DISPLAY "display in shop"
inherit "/obj/monster";
inherit "/std/shops/inherit/clone_on_demand";
private string _none_left_mess;
private string _out_of_item_mess;
private string _show_item_mess;
private string _missing_punter_mess;
private string _dont_sell_mess;
private string _all_out_mess;
private string _list_mess;
private string _list_item_mess;
private string _no_stock_mess;
private string _too_poor_mess;
private string _too_heavy_mess;
private string _in_combat_mess;
private string _busy_mess;
private int busy;
void create() {
    _none_left_mess      = "I'm afraid I don't have any of those.";
    _out_of_item_mess    = "We are right out of $item$.";
    _show_item_mess      = "$item$ is priced at $cost$.  Let me show it to "
        "you.";
    _missing_punter_mess = "Hey... Where'd the fellow go?  Anyway...";
    _dont_sell_mess      = "I'm afraid I don't have any $item$.";
    _all_out_mess        = "I'm afraid I have no $item$ left.";
    _list_mess           = "I have the following items for sale:";
    _list_item_mess      = "I have $num_left$ $display$ for $cost$.";
    _no_stock_mess       = "I am afraid I have nothing for sale.";
    _too_poor_mess       = "I'm afraid you can't afford to buy $item$.";
    _too_heavy_mess      = "Well, here's $item$, but you can't carry it at "
        "the moment.  I'll put it on the floor.";
    _in_combat_mess      = "Can't you see I'm a bit preoccupied right "
                           "now?";
    _busy_mess           = "Sorry, I can only handle one purchase at a "
                           "time!" ;
    monster::create();
}
void init() {
    object cont = query_cont();
    ::init();
    if( cont ) {
        this_player()->add_command( "browse", this_object(),
                                "<indirect:object:" + file_name(cont) +
                                "> {from|of} <direct:living:here>" );
        this_player()->add_command( "buy", this_object(),
                                "<indirect:object:" + file_name(cont) +
                                "> from <direct:living:here>" );
        this_player()->add_command( "list", this_object(),
                                "goods {from|of} <direct:living:here>" );
    }
}
void check_cont() {
    object cont;
    ::check_cont();
    cont = query_cont();
    cont->set_name( "peddler_store" );
}
int query_cost( object thing, object buyer ) {
   if( thing->query_property("cost here") ) {
        return (int)thing->query_property("cost here");
    }
    else {
       return (int)thing->query_value_at( this_object() );
    }
}
string cost_string( object thing, string place, object buyer ) {
    return (string)MONEY_HAND->money_value_string(
        query_cost( thing, buyer ), place );
}
int do_browse( mixed indirect_obs, string dir_match, string indir_match,
    string *words ) {
    int num_left;
    int i;
    string place;
    object *things;
    string custom_string;
    if( this_object()->query_fighting() ) {
        queue_command( "sayto " + file_name(this_player()) + " " +
            _in_combat_mess, 2 );
        this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
            "about browsing an item.\n", ({ }) );
        return 1;
    }
    place = query_property( "place" );
    if ( !place || ( place == "" ) ) {
        place = "default";
    }
    check_cont();
    things = indirect_obs;
    if( !sizeof( things ) ) {
        queue_command( "sayto " + file_name(this_player()) + " " +
            _none_left_mess, 2 );
    }
    else {
        for ( i = 0; i < sizeof( things ); i++ ) {
            num_left = things[i]->query_property( MAX_PROP ) -
                things[i]->query_property( NUM_SOLD );
            if (num_left <= 0) {
                custom_string = replace( _out_of_item_mess, ({
                    "$item$", things[i]->one_short()
                }) );
                queue_command( "sayto " + file_name(this_player()) +
                    custom_string);
                continue;
            }
            custom_string = replace( _show_item_mess, ({
                "$item$", "$C$" +
                    strip_colours((string)things[i]->the_short()),
                "$cost$", cost_string( things[i], place,
                    this_player() )
            }) );
            queue_command( "sayto " + file_name(this_player()) + " " +
                custom_string, 4 * i + 2 );
            queue_command( "whisper " +
                things[i]->one_short()+":\n"+things[i]->long() + " to " +
                file_name(this_player()) );
        }
    }
    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
        "about "+ query_multiple_short(things) +".\n", ({ }) );
    return 1;
}
int do_buy( mixed indirect_obs, string dir_match, string indir_match,
      string *words ) {
    int i, num_left;
    object *things;
    string custom_string;
    if(busy) {
      do_command("'" + _busy_mess);
      this_player()->add_succeeded_mess( this_object(), "$N confuse$s "
                     "$D, who is busy making business.\n", ({ }));
      return 1;
    }
    busy = 1;
    check_cont();
    things = indirect_obs;
    if ( !sizeof( things ) ) {
        custom_string = replace( _dont_sell_mess, ({
            "$item$", indir_match
        }) );
        queue_command( "sayto " + file_name(this_player()) + " " +
            custom_string);
    }
    else {
        if( this_object()->query_fighting() ) {
           queue_command( "sayto " + file_name(this_player()) + " " +
                          _in_combat_mess, 2 );
           this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
               "about buying "+ query_multiple_short(things) +".\n", ({ }) );
           busy = 0;
           return 1;
        }
        for ( i = 0; i < sizeof( things ); ++i ) {
            num_left = (int)things[ i ]->query_property( MAX_PROP ) -
                (int)things[ i ]->query_property( NUM_SOLD );
            if ( num_left < 1 ) {
                custom_string = replace( _all_out_mess, ({
                    "$item$", strip_colours((string)things[i]->query_plural())
                }) );
                init_command( "sayto " + file_name(this_player()) + " " +
                    custom_string, 2 * i + 2 );
                busy = 0;
                continue;
            }
            call_out( "sell_thing", 2 * i, this_player(), things[ i ] );
        }
    }
    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D "
        "about buying "+ query_multiple_short(things) +".\n", ({ }) );
    return 1;
}
int do_list() {
    int num_left;
    string place;
    object thing;
    int first;
    object cont;
    string display;
    string custom_string;
    if( this_object()->query_fighting() ) {
        queue_command( "sayto " + file_name(this_player()) + " " +
            _in_combat_mess, 2 );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }
    place = query_property( "place" );
    if ( !place || ( place == "" ) ) {
        place = "default";
    }
    check_cont();
    cont = query_cont();
    thing = first_inventory( cont );
    first = 1;
    while ( thing ) {
        num_left = (int)thing->query_property( MAX_PROP ) -
            (int)thing->query_property( NUM_SOLD );
        if ( num_left < 1 ) {
            thing = next_inventory( thing );
            continue;
        }
        if (first) {
            queue_command( "sayto " + file_name(this_player()) + " " +
                _list_mess);
            first = 0;
        }
        display = (string)thing->query_property( DISPLAY );
        if ( !stringp( display )  && thing->short()) {
            if( num_left > 1 ) {
                display = (string)thing->query_plural();
            }
            else {
                display = (string)thing->a_short();
            }
        }
        else {
            if( num_left > 1 ) {
                display = pluralize( display );
            }
        }
        custom_string = replace( _list_item_mess, ({
            "$num_left$", (num_left > 1 ? query_num (num_left) : ""),
            "$display$", display,
            "$cost$", cost_string( thing, place, this_player() ) +
                 (num_left > 1 ? " each" : "" )
        }) );
        queue_command( "sayto " + file_name( this_player() ) +
                    " " + custom_string );
        thing = next_inventory( thing );
    }
    if ( first ) {
        queue_command( "say " + _no_stock_mess);
    }
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
}
void sell_thing( object player, object thing ) {
    int value;
    string item_name, place;
    object copy;
    string custom_string;
    if ( !player ) {
        busy = 0;
        return;
    }
    if ( environment( player ) != environment( this_object() ) ) {
        busy = 0;
        return;
    }
    if ( !thing ) {
        busy = 0;
        return;
    }
    place = query_property( "place" );
    if ( !place || ( place == "" ) ) {
        place = "default";
    }
    value = (int)player->query_value_in( place );
    if ( place != "default" ) {
        value += (int)player->query_value_in( "default" );
    }
    if ( (int)this_object()->query_cost( thing, player ) > value ) {
        custom_string = replace( _too_poor_mess, ({
            "$item$", (string)thing->a_short()
        }) );
        queue_command( "sayto " + file_name(player) + " " +
                       custom_string );
        busy = 0;
        return;
    }
    copy = (object)this_object()->create_real_object( thing );
    if ( !copy ) {
        switch ( (string)thing->query_property( TYPE ) ) {
            case "armour" :
            case "weapon" :
            case "armoury item":
                copy = ARMOURY->request_item( item_name,
                    80 + random( 20 ) );
                break;
            case "object" :
                copy = clone_object( item_name );
                break;
        }
    }
    if ( !copy ) {
        copy = clone_object( explode( file_name( thing ), "#" )[ 0 ] );
    }
    if ( !copy ) {
        busy = 0;
        return;
    }
    thing->add_property( NUM_SOLD, (int)thing->query_property( NUM_SOLD ) +
        1 );
    player->pay_money( (mixed *)MONEY_HAND->create_money_array(
        (int)this_object()->query_cost( copy, player ), place ), place );
    tell_object( player, "You pay "+ the_short() +" "+
        cost_string( copy, place, player ) +".\n" );
    tell_room( environment(), (string)player->one_short() +
        " gives "+ the_short() +" some money.\n", player );
    if ( (int)copy->move( player ) != MOVE_OK ) {
        custom_string = replace( _too_heavy_mess, ({
            "$item$", (string)copy->the_short()
        }) );
        queue_command( "sayto " + file_name(player) + " " + custom_string );
        copy->move( environment() );
        queue_command( ":puts "+ (string)copy->a_short() +" on the ground." );
    }
    else {
        tell_room( environment(), the_short() +" gives "+
            (string)player->one_short() +" "+ (string)copy->a_short() +
            ".\n" );
    }
    busy = 0;
}
void event_enter(object ob, string mess, object from) {
    if (ob->query_food_object()) { ob->set_decay_speed(0); }
}
void event_exit(object ob, string message, object to) {
    if (ob->query_food_object()) { ob->set_decay_speed(8000); }
}
void dest_me() {
  if(query_cont())
    log_file("PEDDLER", "Cont: %s\n", file_name(query_cont()));
    clone_on_demand::dest_me();
    monster::dest_me();
}
void set_none_left_mess(string s) {
    _none_left_mess = s;
}
void set_out_of_item_mess(string s) {
    _out_of_item_mess = s;
}
void set_show_item_mess(string s) {
    _show_item_mess = s;
}
void set_missing_punter_mess(string s) {
    _missing_punter_mess = s;
}
void set_dont_sell_mess(string s) {
    _dont_sell_mess = s;
}
void set_all_out_mess(string s) {
    _all_out_mess = s;
}
void set_list_mess(string s) {
    _list_mess = s;
}
void set_list_item_mess(string s) {
    _list_item_mess = s;
}
void set_no_stock_mess(string s) {
    _no_stock_mess = s;
}
void set_too_poor_mess(string s) {
    _too_poor_mess = s;
}
void set_too_heavy_mess(string s) {
    _too_heavy_mess = s;
}
void set_in_combat_mess(string s) {
    _in_combat_mess = s;
}
void set_busy_mess(string s) {
    _busy_mess = s;
}

==================================================
FILE: ring.c
==================================================

#include <artifacts.h>
#include <tasks.h>
inherit "/obj/armour";
inherit "/std/basic/artifact";
int query_magic_ring() { return 1; }
void create() {
   ::create();
   set_type( "ring" );
   set_damage_chance( 8 );
   set_artifact_type( "ring" );
   add_property( "shop type", "jewellers" );
   add_alias( "jewellery" );
   add_plural("jewellery");
}
void set_weight( int number ) {
   armour::set_weight( number );
   setup_armour( 250 * number );
   add_ac( "blunt", "blunt", 5 * weight );
   add_ac( "sharp", "sharp", 2 * weight );
}
string long( int word, int dark ) {
  return artifact::long( word, dark ) + armour::long( word, dark );
}
void init() {
  this_player()->add_command( "twist", this_object() );
}
int do_twist() {
  int outcome;
  if ( query_worn_by() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be "+
        "wearing $D to $V it.\n", ({ }) );
    return 0;
  }
  outcome = (int)TASKER->perform_task(this_player(), RING_SKILL,
                                      level, TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to use $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
  if ( outcome == AWARD ) {
    write( "%^YELLOW%^" +
          ({ "A piece of lore concerning rings becomes clearer for "+
        "you.\n", "You manage to grasp one of the principles of magic "+
        "rings more firmly.\n", "A sudden flash of insight allows you "+
        "to understand the ring a little better.\n" })[ random( 3 ) ] +
          "%^RESET%^");
  }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( 0, this_player(), this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D but "+
          "nothing happens!\n", ({ }) );
    return 1;
  }
  zapper->zap( 0, this_player(), this_object() );
  return 1;
}
mixed *stats() {
  return armour::stats() + artifact::stats();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : armour::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/ring" )
    return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    armour::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    armour::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
}

==================================================
FILE: roommak.c
==================================================

inherit "/std/object";
mixed *exits,
      *items;
string de_long,
       de_short;
int de_light;
void setup() {
  set_name("maker");
  add_adjective("room");
  set_short("Room maker");
  set_long("It is a small wooden rod about 30 centimeters long with deep "+
           "burn marks along the sides.  It has what looks like a small "+
           "lens stuck in the end and three buttons along its length.\n");
}
void init() {
  if (this_player()->query_creator()) {
    add_action("do_new", "new");
    add_action("do_set", "set");
    add_action("do_add", "add");
    add_action("do_setup", "setup");
    add_action("do_modify", "modify");
    add_action("do_map", "map");
  }
}
int do_new(string str) {
  if (!str) {
    notify_fail("Syntax: new <name>\n");
    return 0;
  }
}

==================================================
FILE: salve.c
==================================================

#include <drinks.h>
inherit "/obj/food";
mapping apply_effects;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  apply_effects = ([ ]);
  if ( !do_setup )
    this_object()->setup();
}
void init() {
  this_player()->add_command( "apply", this_object(), "<direct:object> to <indirect:object>");
}
mapping query_apply_effects() { return apply_effects; }
void set_apply_effects( mapping map ) { apply_effects = map; }
int add_apply_effect( string word, int number ) {
  if ( apply_effects[ word ] )
    apply_effects[ word ] += number;
  else
    apply_effects[ word ] = number;
  return apply_effects[ word ];
}
void remove_apply_effect( string word ) {
  if ( !undefinedp( apply_effects[ word ] ) )
    apply_effects = m_delete( apply_effects, word );
}
void being_joined_by( object thing ) {
  int i, that, this;
  string *words;
  mapping new_effects;
  that = (int)thing->query_amount();
  this = query_amount();
  if ( !( this + that ) )
    return;
  new_effects = (mapping)thing->query_apply_effects();
  words = m_indices( apply_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    if ( new_effects[ words[ i ] ] ) {
      new_effects[ words[ i ] ] *= that;
      new_effects[ words[ i ] ] += this * apply_effects[ words[ i ] ];
    } else
      new_effects[ words[ i ] ] = this * apply_effects[ words[ i ] ];
  words = m_indices( new_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    new_effects[ words[ i ] ] /= this + that;
  apply_effects = new_effects;
}
int do_apply(object *indir, string dir_s, string indir_s, mixed *args) {
    string *words;
    int i;
    if (environment(this_object()) != this_player()) {
        write("You aren't holding the " + dir_s + ".\n");
        return 0;
    }
    if (sizeof(indir) != 1) {
        write("You can only " + query_verb() + " to one thing at a time.\n");
        return 0;
    }
    if (living(indir[0])) {
        words = m_indices( apply_effects );
        for (i = 0; i < sizeof(words); i++) {
            indir[0]->add_effect(words[i], apply_effects[words[i]] * query_amount());
        }
    }
    this_player()->add_succeeded(indir[0]);
    move("/room/rubbish");
    return 1;
}
mapping query_static_auto_load() {
  if ( ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/salve" )
      && !query_continuous() )
    return 0;
return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "apply_effects" : apply_effects + ([ ]),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  apply_effects = map[ "apply_effects" ];
}
mixed *stats() {
  int i;
  string *words;
  mixed *args;
  args = ::stats();
  words = m_indices( apply_effects );
  for ( i = 0; i < sizeof( words ); i++ )
    args += ({ ({ "apply effect#"+ i, words[ i ] +" ("+
        apply_effects[ words[ i ] ] +")" }) });
  return args;
}

==================================================
FILE: scabbard.c
==================================================

#include <move_failures.h>
#include <virtual.h>
inherit "/std/container";
inherit "/std/basic/wearable";
string sheath;
string * types;
int _no_types_in_long;
void create() {
   do_setup++;
   container::create();
   wearable::create();
   do_setup--;
   sheath = "";
   types = ({ });
   _no_types_in_long = 0;
   add_alias( "scabbard" );
   add_plural( "scabbards" );
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   if ( !do_setup )
      this_object()->setup();
}
int query_scabbard() { return 1; }
string *query_types() { return types; }
void set_types( string *words ) {
   types = words;
   switch ( sizeof( types ) ) {
      case 0 :
         sheath = "";
         return;
      case 1 :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +".\n";
         return;
      case 2 :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +" or "+
               types[ 1 ] +".\n";
         return;
      default :
         sheath = "It could sheathe "+ add_a( types[ 0 ] ) +", "+
               implode( types[ 2 .. ], ", " ) +" or "+ types[ 1 ] +
               ".\n";
   }
}
int test_type_ok( object thing, int flag ) {
  foreach( string word in types ) {
    if( thing->full_id( word ) )
      return ::test_add( thing, flag );
  }
  return 0;
}
varargs int test_add( object thing, int flag, int noprint ) {
   int foo;
   if(flag)
      return 0;
   if( !environment( thing ) )
      return ::test_add( thing, flag );
   if( first_inventory( this_object() ) ) {
      if( !noprint )
         write( the_short() + " already holds " +
           first_inventory( this_object() )->a_short() + ".\n" );
      return 0;
   }
   foo = test_type_ok( thing, flag );
   if(foo)
      return foo;
   if( !noprint )
      write( thing->the_short() + " doesn't fit very well in "
        + the_short() + ".  " + sheath );
   return 0;
}
string long( string word, int dark ) {
   string foo = _no_types_in_long ? "" : sheath;
   if ( dark == 2 || dark == -2) {
      return container::long( word, dark );
   }
   return container::long( word, dark ) + foo +
         query_contents( "$C$"+ the_short() +" contains: " ) +
         wearable::long( word, dark );
}
int query_ac( string type, int amount ) {
   do_damage( type, amount );
}
void setup_scabbard( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
}
int query_value() {
   return modify_value( container::query_value() );
}
int query_full_value() { return container::query_value(); }
int drop(mixed dest) {
   if ( worn_by )
      if ( living( worn_by ) )
         return 1;
   return container::drop(dest);
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = container::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
}
void dest_me() {
   set_worn_by( 0 );
   container::dest_me();
}
void break_me() {
   if ( worn_by )
      all_inventory()->move( environment( worn_by ), "$N fall$s from "+
            a_short() +"." );
   else
      all_inventory()->move( environment(), "$N fall$s out of "+
            a_short() +"." );
   ::break_me();
}
mixed *stats() {
   return container::stats() + wearable::stats();
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/scabbard" )
      return ([ ]);
   return ([
      "::" : container::int_query_static_auto_load(),
      "wear" : wearable::query_static_auto_load(),
      "types" : types,
      "_no_types_in_long" : _no_types_in_long,
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : container::query_dynamic_auto_load(),
      "wear" : wearable::query_dynamic_auto_load()
   ]);
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      container::init_static_arg( map[ "::" ] );
   if ( map[ "wear" ] )
      wearable::init_static_arg( map[ "wear" ] );
   if ( pointerp( map[ "types" ] ) )
      set_types( map[ "types" ] );
   if ( map[ "_no_types_in_long" ] )
      _no_types_in_long = map[ "_no_types_in_long" ];
}
void init_dynamic_arg( mapping map, object ob ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] )
      container::init_dynamic_arg( map[ "::" ], ob );
   if ( map[ "wear" ] )
      wearable::init_dynamic_arg( map[ "wear" ], ob );
   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
}
int no_types_in_long() {
   return _no_types_in_long;
}
int set_no_types_in_long( int val ) {
   _no_types_in_long = val ? 1 : 0;
   return _no_types_in_long;
}

==================================================
FILE: service_provider.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/obj/monster";
#define SERVICE  0
#define BROWSE   1
#define FUNCTION 2
#define COST     3
#define ALIASES  4
private int parsing_function( mixed *array , string words );
int _busy;
mixed *_service_array = ({ });
void set_busy()   { _busy = 1; }
void reset_busy() { _busy = 0; }
varargs int check_busy( object player )
{
    if( _busy || sizeof( query_queued_commands() ) )
    {
        if( player ) {
            tell_object( player, query_short() +" is busy at the moment."+
            "  " + capitalize( query_pronoun() )+ " will be with you " +
            "shortly.\n" );
        }
    return 1;
    } else
        return 0;
}
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) this_object()->setup();
}
void init()
{
    ::init();
    this_player()->add_command( "inquire", this_object(),
        "[a] <string> {from|of} <direct:living:here>", "do_browse" );
    this_player()->add_command( "browse", this_object(),
        "[a] <string> {from|of} <direct:living:here>" );
    this_player()->add_command( "request", this_object(),
        "[a] <string> from <direct:living:here>" );
    this_player()->add_command( "list", this_object(),
        "services [available] {from|of} <direct:living:here>" );
}
varargs int add_service( string service , string browse_info ,
    string func, int cost, string *aliases )
{
    string *alias_array;
    if( !service || !browse_info || !func ||
        !function_exists( func , this_object() , 1 ) )
            return 0;
    alias_array = !sizeof(aliases) ? ({ }) : aliases ;
    _service_array += ({ ({ service , browse_info , func , cost ,
        alias_array }) });
    return 1;
}
int remove_service( string service )
{
    mixed *things;
    things = filter( _service_array, (: $1[SERVICE]==$(service) :) );
    switch( sizeof(things) ) {
        case 1: _service_array -= things; return 0; break;
        default: return 0; break;
    }
    return 0;
}
int do_browse( mixed indirect_obs, string dir_match, string indir_match,
    string *words )
{
    string place;
    mixed *things;
    object player;
    player = this_player();
    if ( check_busy( player ) ) return 0;
    place = query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";
    things =
        filter( _service_array ,(:parsing_function( $1, $(words)[0]):) );
    if( !sizeof( things ) ) {
        init_command( "say I'm afraid I don't offer that service.", 2 );
    } else {
        init_command("say A " + things[0][SERVICE] + " costs " +
            MONEY_HAND->money_value_string( things[0][COST], place ) +
            ".  " + things[0][1], 2 );
    }
    player->add_succeeded_mess( this_object(), "$N ask$s $D "+
          "about "+ words[ 0 ] +".\n", ({ }) );
    return 1;
}
int do_request( mixed indirect_obs, string dir_match, string indir_match,
      string *words )
{
    mixed *things;
    object player;
    int value;
    string place;
    player = this_player();
    place = query_property("place");
    if ( !place || place == "" )
        place = "default";
    if ( check_busy( player ) ) return 0;
    things =
        filter( _service_array , (: parsing_function($1,$(words)[0]) :));
    if ( !sizeof( things ) )
        init_command( "say I'm afraid I don't offer that service.", 2 );
    else {
        value = player->query_value_in("default") +
            ( place == "default" ? 0 : player->query_value_in( place ) );
        if( things[0][COST] > value )
            init_command("say And just how do you propose to pay "+
                "for a "+things[0][SERVICE]+"?" , 2 );
        else {
            init_command("say Certainly, "+
                ( player->query_gender() == 1 ? "Sir" : "Ma'am" )+
                "!");
            tell_object( player , "You hand "+query_short()+" the "+
                "necessary money.\n");
            player->pay_money( MONEY_HAND->
                create_money_array(things[0][COST], place ), place );
            call_out( things[0][FUNCTION] , 4 , player, things[0] );
        }
    }
    player->add_succeeded_mess( this_object(), "$N ask$s $D "+
        "about having a "+ words[ 0 ] +".\n", ({ }) );
   return 1;
}
int do_list()
{
    string place, list;
    int i,number;
    number = sizeof( _service_array );
    place = query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";
    list = "I am currently offering the following: ";
    if( number > 3 ) {
        for( i=0 ; i < (number-2) ; i++ ) {
            list += ( "a "+_service_array[i][SERVICE]+" for "+
                MONEY_HAND->money_value_string(
                    _service_array[i][COST], place )+", " );
        }
    }
    if( number > 1 ) {
        list += ( "a " + _service_array[<2][SERVICE] + " for " +
            MONEY_HAND->money_value_string(
                _service_array[<2][COST], place ) +" and " );
    }
    if( number > 0 ) {
        list += ( _service_array[<1][SERVICE] + " for " +
            MONEY_HAND->money_value_string(
                _service_array[<1][COST], place ) +"." );
    }
    if( number == 0 )
        list = "I am not currently offering any services.";
    init_command("say "+ list, 2);
    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D what "+
         "services "+ (string)this_object()->query_pronoun() +" has "+
         "on offer.\n", ({ }) );
   return 1;
}
private int parsing_function( mixed *array , string word )
{
    if ( array[SERVICE] == word ) return 1;
    if ( member_array( word, array[ALIASES] ) != -1 ) return 1;
    return 0;
}

==================================================
FILE: shield.c
==================================================

#include <move_failures.h>
#include <virtual.h>
#define AC_LIMIT 100
#undef INFORM
inherit "/obj/armour";
inherit "/std/basic/holdable";
int no_limbs;
nosave int held_in;
void create() {
   do_setup++;
   armour::create();
   add_alias( ({ "armour", "shield" }) );
   add_plural( ({ "armours", "shields" }) );
   add_help_file("armour");
   if ( !query_property( "shop type" ) )
      add_property( "shop type", "armoury" );
   do_setup--;
   if ( !do_setup )
      this_object()->setup();
}
int query_no_limbs() { return no_limbs; }
void set_no_limbs( int number ) { no_limbs = number; }
mixed set_holder( object thing, int number ) {
   if (!::set_holder(thing, number))  return 0;
   if(!thing) {
     worn_by = 0;
     held_in = 0;
   } else {
     worn_by = thing;
     held_in = number;
   }
   return 1;
}
int query_wearable() { return 0; }
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   if ( worn_by && ( worn_by != dest ) )
      if ( !sizeof( (int *)worn_by->set_unhold( this_object() ) ) )
         return MOVE_NO_UNHOLD;
   flag = armour::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by )
      set_worn_by( 0 );
   return flag;
}
void dest_me() {
   set_worn_by( 0 );
   armour::dest_me();
}
mixed *stats() {
   return armour::stats() + ({ ({ "no_limbs", no_limbs }) });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : armour::int_query_static_auto_load(),
      "no limbs" : no_limbs,
   ]);
}
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([
      "::" : armour::query_dynamic_auto_load(),
   ]);
   return map;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
   if ( map[ "::" ] )
      armour::init_static_arg( map[ "::" ] );
   if ( map[ "no limbs" ] )
      no_limbs = map[ "no limbs" ];
}
void replace_me(){
  object receipt;
  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}
void init_dynamic_arg( mapping map, object ) {
   if ( map[ "::" ] )
      armour::init_dynamic_arg( map[ "::" ] );
}

==================================================
FILE: shovel.c
==================================================

inherit "/obj/weapon";
string *patterns = ({
  "with <direct:object> in <string>",
  "with <direct:object> in <indirect:object>",
  "with <direct:object>",
  "[in] <string> with <direct:object>",
  "[in] <indirect:object> with <direct:object>"
});
void init(){
  this_player()->add_command("dig", this_object(), patterns);
}
int do_dig( object *things, string dir_match, string
            indir_match, mixed *args, string pattern) {
  object *obj, indir;
  string indir_s;
  if (!objectp(environment(this_player()))) {
    return 0;
  }
  obj=this_player()->query_holding();
  if(member_array(this_object(), obj) == -1){
    this_player()->add_failed_mess(this_object(), "You must hold the $D to "
                                   "dig with it.\n", ({}));
    return 0;
  }
  if (pattern == patterns[4]) {
    if (!objectp(indir = things[0])) {
      return 0;
    }
    indir_s = args[0];
  } else if (pattern == patterns[3]) {
    indir_s = args[0];
    indir = 0;
  } else if (pattern == patterns[2]) {
    indir_s = 0;
    indir = 0;
  } else if (pattern == patterns[1]) {
    if (!objectp(indir = things[0])) {
      return 0;
    }
    indir_s = args[1];
  } else if (pattern == patterns[0]) {
    indir_s = args[1];
    indir = 0;
  } else {
    return 0;
  }
  return environment(this_player())->dig(indir, indir_s);
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/shovel" )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: shut.c
==================================================

#include <network.h>
#define OFFLER_SHADOW "/std/shadows/misc/offler_shadow"
#undef CONVERTER
#undef AUTO_RESURRECT
inherit "/std/container";
int time_of_crash, time_of_last_shout;
void setup() {
  if (file_name(this_object()) != "/obj/shut") {
    write("This object can't be cloned.\n");
    dest_me();
    return;
    }
  set_name("offler");
  set_living_name("offler");
  add_adjective( ({ "offler", "the", "crocodile" }));
  add_alias("god");
  enable_commands();
  set_short( "Offler" );
  add_property( "determinate", "" );
  set_long("The Crocodile God.  He looks big, green, and, well "+
           "like this really.\n");
  add_alias("shut");
  reset_get();
}
#define ishout(str) user_event("say", "%^BOLD%^%^RED%^Offler the Crocodile God shouts: "+str+"%^RESET%^\n", 0)
void heart_beat() {
   int time_to_crash;
   if (!time_of_crash) return;
   time_to_crash = time_of_crash - time();
   if (time_to_crash < 1) {
      call_out("end_it_all",0);
      set_heart_beat(0);
      return;
   }
   if (time_to_crash < 10)  {
      ishout( "Game weboot in "+ time_to_crash +" thecondth." );
      return;
   }
   if (time_to_crash < 60 && time_to_crash % 10 < 2) {
      ishout( "Game ith webooting in "+ time_to_crash +
            " thecondth.  Go away!" );
      return;
   }
   if (time_to_crash % 60 > 5)
      return;
   time_to_crash /= 60;
   if (time_to_crash == time_of_last_shout)
      return;
   time_of_last_shout = time_to_crash;
   if (time_to_crash > 30) {
      return ;
   }
   if(time_to_crash == 1) {
      ishout( "Game ith webooting in one minute.  Quit now!" );
      return;
   }
   if (time_to_crash < 10 || !(time_to_crash % 10)) {
      ishout( "Game ith webooting in "+ time_to_crash +" minuteth." );
      return;
   }
}
void shut(int minutes, string reason) {
   object *players;
   int i;
   string fname;
   if (!intp(minutes)) {
      write("Bad argument\n");
      return;
   }
   fname = file_name(previous_object());
   if (minutes <= 0) {
      write("No time given\n");
      return;
   }
#ifdef CONVERTER
   if (!CONVERTER->ok_to_shut()) {
      dest_me();
      return;
   }
#endif
   players = users();
   for (i=0;i<sizeof(players);i++) {
     if ( !players[ i ] )
       continue;
     if (players[i]->query_creator())
     tell_object(players[i], "%^BOLD%^%^RED%^Offler the Crocodile God wishes "
                 "you to know:  The mud is rebooting in "+
                 number_as_string( minutes ) + " minutes.%^RESET%^\n" );
   }
   set_long("He is firmly concentrating on counting.\n");
   if (time_of_crash)
     write( "There was already a reboot scheduled, set for "+
           (time_of_crash - time()) + " seconds.\n");
   move("/d/am/buildings/drum/mendeddrum",
      "Offler the Crocodile God appears in a puff of smoke.",
      "Offler the Crocodile God appears in a puff of smoke.");
   time_of_crash = time() + minutes*60;
   time_of_last_shout = minutes;
   set_heart_beat(1);
#ifdef AUTO_RESURRECT
   call_out( "check_ghosts", 60 );
#endif
   if(file_name(previous_object()) == "/obj/handlers/garbage")
     log_file("REBOOT", "Shutdown requested automatically at "+ctime(time())+
              "\n");
   else if(this_player())
     log_file("REBOOT", "Shutdown at "+ctime(time())+" requested by " +
              this_player()->query_cap_name()+" for " + reason + "\n");
   else
     log_file("REBOOT", "Shutdown at "+ctime(time())+" requested by " +
              file_name(previous_object()) + " for " + reason + "\n");
}
string long(string str, int dark) {
  ::long(str, dark);
  if ( time_of_crash && this_player() && this_player()->query_creator() )
     return ::long(str,dark)+
            "Game reboot will be in " + ( time_of_crash - time() ) +
            " seconds.\n";
  return ::long(str,dark);
}
void end_it_all() {
   int i;
   object *obs;
   ishout( "Thutdown now!" );
   obs = users();
   for (i=0;i<sizeof(obs);i++) {
      call_out("force_quit", i, obs[i]);
   }
   call_out("blue", 10);
}
void force_quit( object ob ) {
   if ( !objectp( ob ) )
      return;
   ob->stop_all_fight();
   if(ob->query_login_ob()) {
     ob->dest_me();
     return;
   }
   if ( !environment( ob ) )
     ob->move( "/d/am/buildings/drum/mendeddrum" );
   if(environment(ob) &&
      file_name( environment( ob ) ) != "/room/departures" ) {
     ob->quit_alt();
   }
   if (environment(ob) &&
       file_name( environment( ob ) ) != "/room/departures" ) {
     ob->quit();
   }
}
void blue() {
  if (sizeof(users()) > 0 &&
      time() - time_of_crash < 240)
    call_out("blue", 10);
  else {
    SERVICES_D->eventShutdown(1);
    shutdown(0);
  }
}
int query_time_to_crash() {
   if ( !time_of_crash ) {
      call_out( "dest_me", 1 );
      return 9999;
   }
   set_heart_beat( 1 );
   return time_of_crash - time();
}
int query_unambushable() { return 1; }
void do_ambushed() {
   write( "Bad mistake...\n" );
   this_player()->run_away();
}
#ifdef AUTO_RESURRECT
void person_died( string word, int number ) {
   object thing;
   thing = find_player( word );
   if ( !thing )
      return;
   switch ( number ) {
      case 0 :
         break;
      case 1 :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Well, "+
               "weally!  Thilly mortal, of all the timeth to die!\n" );
         break;
      case 2 :
         tell_object( thing, "$I$5=Offler tells you: Don't wowwy, I'll "+
               "welieve the chap with the thythe of you thith time.\n" );
         break;
      case 3 :
         thing->remove_ghost();
         clone_object( OFFLER_SHADOW )->setup_shadow( thing );
         break;
      default :
         tell_object( thing, "$I$5=Offler tells you exclaiming: And behave "+
               "yourthelf until I'm done, for goodneth' thake!\n" );
         return;
   }
   call_out( "person_died", 3, word, number + 1 );
}
void person_dead( object thing, int number ) {
   if ( !thing )
      return;
   if ( thing->query_property( "noregen" ) ) {
      call_out( "person_dead", 3, thing, number );
      return;
   }
   switch ( number ) {
      case 0 :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Well, "+
               "weally!  Can't have you wunning awound detheathed!\n" );
         break;
      case 1 :
         thing->remove_ghost();
         clone_object( OFFLER_SHADOW )->setup_shadow( thing );
         break;
      default :
         tell_object( thing, "$I$5=Offler tells you exclaiming: Now behave "+
               "yourthelf until I'm done, for goodneth' thake!\n" );
         return;
   }
   call_out( "person_dead", 3, thing, number + 1 );
}
void check_ghosts() {
   object thing;
   foreach( thing in users() ) {
      if ( !thing ) {
          continue;
      }
      if ( !thing->query_property( "dead" ) ) {
         continue;
      }
      if ( (int)thing->query_deaths() > (int)thing->query_max_deaths() ) {
         continue;
      }
      call_out( "person_dead", 3, thing, 0 );
   }
}
#endif

==================================================
FILE: staff.c
==================================================

#include <artifacts.h>
#include <tasks.h>
inherit "/obj/weapon";
inherit "/std/basic/artifact";
int query_magic_staff() { return 1; }
void create() {
  weapon::create();
  set_artifact_type( "staff" );
  set_no_limbs( 2 );
}
void set_weight( int number ) {
  weapon::set_weight( number );
  new_weapon( 80 * number );
    add_attack( "thwack", 50, ({ weight / 3, 4, weight }), "blunt",
         "blunt", 0 );
    add_attack( "prod", 50, ({ weight / 2, 4, weight / 2 }), "blunt",
         "blunt", 0 );
}
string long( int word, int dark ) {
  return artifact::long( word, dark ) + weapon::long( word, dark );
}
void init() {
  this_player()->add_command( "invoke", this_object() );
}
int do_invoke() {
  int outcome;
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to $V it.\n", ({ }) );
    return 0;
  }
  outcome = (int)TASKER->perform_task(this_player(), STAFF_SKILL, level,
                                      TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to $V $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
  if ( outcome == AWARD ) {
    write("%^YELLOW%^"+
          ({ "A piece of lore concerning staves becomes clearer for "+
             "you.\n", "You manage to grasp one of the principles of magic "+
             "staves more firmly.\n", "A sudden flash of insight allows you "+
             "to understand the staff a little better.\n" })[ random( 3 ) ] +
          "%^RESET%^");
  }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( environment( this_player() ), this_player(),
        this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D but "+
          "nothing happens!\n", ({ }) );
    return 1;
  }
  zapper->zap( environment( this_player() ), this_player(), this_object() );
  return 1;
}
mixed *stats() {
  return weapon::stats() + artifact::stats();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : weapon::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/staff" )
      return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) )
      return;
  if ( map[ "::" ] )
    weapon::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
}

==================================================
FILE: state_changer.c
==================================================

#include <tasks.h>
#include <effect.h>
#define STATE_CHANGE "/obj/handlers/state_change"
inherit "/obj/vessel";
object *add_list = ({ });
int query_busy();
int do_action( object *obs );
string parse_message( string message );
string query_classification();
string command;
string process;
string start_mess;
string interim_mess;
string end_mess;
int duration;
int base_bonus;
string skill;
string fail_process;
string end_mess_fail;
string end_mess_abort;
string command_mess;
function start_func;
function end_func;
function fail_func;
int gp_cost;
string gp_type = "other";
string running_inv_mess;
void create() {
    ::create();
    set_stuck( 1 );
    set_leak_rate( 0 );
    set_weight( 100 );
    set_max_weight( 5000 );
    set_max_volume( 5000 );
    set_hide_cond( 1 );
    this_object()->add_extra_look(this_object());
}
void set_command( string _command ) { command = _command; }
void set_process( string _process ) { process = _process; }
void set_fail_process( string _process ) { fail_process = _process; }
void set_start_message( string message ) { start_mess = message; }
void set_interim_message( string message ) { interim_mess = message; }
void set_end_message( string message ) { end_mess = message; }
void set_fail_message( string message ) { end_mess_fail = message; }
void set_abort_message( string message ) { end_mess_abort = message; }
void set_duration( int _duration ) { duration = _duration; }
void set_command_mess( string message ) { command_mess = message; }
void set_start_func( function f ) { start_func = f; }
void set_end_func( function f ) { start_func = f; }
void set_fail_func( function f) { fail_func = f; }
void set_skill( string _skill, int _base_bonus ) {
    skill = _skill;
    base_bonus = _base_bonus;
}
void set_gp_cost( int gp ) { gp_cost = gp; }
void set_gp_type( string type ) { gp_type = type; }
void set_running_inv_mess( string mess ) { running_inv_mess = mess; }
void init() {
  ::init();
  if ( command ) {
    add_command( command, "all in <direct:object>", (: do_action( $1 ) :) );
  }
}
int do_action( object *obs ) {
int *tmp;
  if ( gp_cost ) {
      if ( this_player()->query_specific_gp( gp_type ) < gp_cost )
          return notify_fail( "You are too tired to "+ command +" with the "+ this_object()->the_short() + ".\n" );
      this_player()->adjust_gp( -gp_cost );
  }
  if ( sizeof( tmp = this_object()->effects_matching( query_classification() ) ) )
    return notify_fail( this_object()->the_short() + " is already being used by "+
      this_object()->arg_of( tmp[0] )->query_short() +"!\n" );
  if ( !sizeof( all_inventory( this_object() ) ) )
    return notify_fail( "There is nothing to "+ command + ".\n" );
  if ( functionp( start_func ) ) {
    if ( !evaluate( start_func ) ) {
        debug_printf( "Stopped at start_func\n" );
        return notify_fail( "" );
    }
  }
  this_object()->add_effect( file_name( this_object() ), this_player() );
  if ( stringp( start_mess ) )
      tell_room( environment(), parse_message(start_mess) );
  if ( stringp( command_mess ) ) {
      this_player()->add_succeeded_mess( this_object(), parse_message( command_mess ),
          all_inventory( this_object() ) );
    debug_printf( "Setting asm to %s.\n", parse_message( command_mess ) );
  }
  else
      this_player()->add_succeeded_mess( this_object(), "$N "+ command +"$s $I "
        "in $D.\n", all_inventory( this_object() ) );
  return 1;
}
object beginning(object apparatus, object tp, int id) {
    apparatus->submit_ee(0, duration, EE_REMOVE);
    apparatus->submit_ee("show_message", ({ 30, 30 }), EE_CONTINUOUS);
    return tp;
}
object show_message(object apparatus, object tp, int id) {
  if ( stringp( interim_mess ) )
      tell_room(environment(), parse_message(interim_mess) );
  if ( !sizeof( all_inventory() ) )
    submit_ee( 0, 0, EE_REMOVE );
  return tp;
}
object end(object apparatus, object tp, int id) {
 object ob;
 int temp;
 int l_bonus = base_bonus;
  if ( functionp( end_func ) ) {
    if ( !evaluate( end_func ) ) {
        debug_printf( "Stopped at start_func\n" );
        return tp;
    }
  }
  if ( !sizeof( all_inventory() ) ) {
    debug_printf( "Aborted due to lack of inventory!\n" );
    if ( stringp( end_mess_abort ) )
      tell_room( environment(), parse_message(end_mess_abort) );
    return tp;
  }
  foreach( object i in all_inventory() ) {
      if ( temp = i->query_property( process + " modifier" ) ) {
          l_bonus += temp;
          debug_printf( "%s difficulty will be modified by %d (%O).\n",
             process, temp, ob );
      }
  }
  if ( skill ) {
      switch( TASKER->perform_task( tp, skill, l_bonus, TM_COMMAND ) ) {
        case AWARD:
          tell_object( tp, "%^YELLOW%^You learn something new about "+ process +"ing!%^RESET%^\n" );
        case SUCCEED:
          tell_room( environment(), parse_message(end_mess) );
          foreach( object i in all_inventory() ) {
            if (!i)
              continue;
              ob = STATE_CHANGE->transform( i, process, tp );
              debug_printf( "Transforming: %O to %O.\n", i, ob );
              if ( ob ) {
                add_list += ({ ob });
                i->move( "/room/rubbish" );
                ob->move( this_object() );
              }
           }
           break;
        default:
            if ( stringp( end_mess ) )
                tell_room( environment(), parse_message(end_mess_fail) );
            if ( functionp( fail_func ) )
                evaluate( fail_func );
            foreach( object i in all_inventory() ) {
              if (!i)
                continue;
              ob = STATE_CHANGE->transform( i, fail_process, tp );
              debug_printf( "Transforming: %O to %O.\n", i, ob );
              if ( ob ) {
                add_list += ({ ob });
                i->move( "/room/rubbish" );
                ob->move( this_object() );
              }
           }
           break;
      }
  }
  else {
    if ( stringp( end_mess ) )
        tell_room( environment(), parse_message(end_mess) );
    foreach( object i in all_inventory() ) {
      if (!i)
        continue;
      ob = STATE_CHANGE->transform( i, process, tp );
      debug_printf( "Transforming: %O to %O.\n", i, ob );
      if ( ob ) {
        add_list += ({ ob });
        i->move( "/room/rubbish" );
      }
      add_list->move( this_object() );
      add_list = ({ });
    }
  }
  return tp;
}
string query_classification() { return "state.changing."+ process; }
string extra_look( object ob ) {
  return "";
}
string parse_message( string message ) {
  message = replace( message, "$inventory$", query_multiple_short( all_inventory() ) );
  debug_printf( "message is: %s.\n" , message );
  return message;
}
int test_add(object ob, int flag) {
    debug_printf( "Testing add of: %O (%O) in state changer.\n", ob, environment( ob ) );
    if ( member_array( ob, add_list ) != -1 ) {
       return ::test_add( ob, flag );
    }
    if ( query_busy() ) {
        tell_object( this_player(), "It might not be wise to add anything to "+
            this_object()->the_short() + " while it is in use!\n" );
        return 0;
    }
    return ::test_add( ob, flag );
}
int test_remove( object ob, int flag, mixed dest ) {
    if ( dest && base_name( dest ) == "/room/rubbish" )
        ::test_remove( ob, flag, dest );
    debug_printf( "Testing remove of: %O (%O) in state changer.\n", ob, environment( ob ) );
    if ( query_busy() ) {
        tell_object( this_player(), "It might not be wise to take anything from "+
            this_object()->the_short() + " while it is in use!\n" );
        return 0;
    }
    return ::test_remove( ob, flag, dest );
}
string long( string word, int dark ) {
  if ( query_busy() ) {
    if ( stringp( running_inv_mess ) )
      return query_long() + parse_message( running_inv_mess );
    else
      return ::long( word, dark );
  }
  return ::long( word, dark );
}
int do_empty(object *dest, string me, string him, string prep) {
  if ( query_busy() ) {
    add_failed_mess( "You can't empty "+ this_object()->short() +" while it is being used.\n" );
    return 0;
  }
  return ::do_empty( dest, me, him, prep );
}
int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {
  if ( query_busy() ) {
    add_failed_mess( "You can't fill anything from "+ this_object()->short()
      +" while it is being used.\n" );
    return 0;
  }
  return  ::do_fill( to, args_b, args_a, args );
}
int query_busy() { return !!sizeof( this_object()->effects_matching( query_classification() ) ); }

==================================================
FILE: surf_save.c
==================================================

inherit "/std/surface";
mapping details;
nosave string save_file;
void do_load() {
   if ( save_file ) {
      all_inventory( this_object() ) -> dest_me();
      if ( file_size( save_file + ".o" ) > 0 ) {
	 unguarded((: restore_object, save_file :));
	 if ( sizeof( details ) ) init_dynamic_arg( details );
      }
   }
}
void create() {
   save_file = "";
   details = ([ ]);
   ::create();
}
int test_remove( object ob, int flag) {
   if ( find_call_out( "do_save" ) == -1 )
      call_out( "do_save", 0 );
   return 1;
}
int test_add( object ob, int flag) {
   if ( find_call_out( "do_save" ) == -1 )
      call_out( "do_save", 0 );
   return 1;
}
void do_save() {
   if ( save_file ) {
      details = ([ ]);
      details = query_dynamic_auto_load();
      unguarded((: save_object, save_file :));
   }
}
void check_euid() {
   if ( previous_object() )
     seteuid( geteuid( previous_object() ) );
}
void set_save_file( string file ) {
   save_file = file;
   do_load();
}

==================================================
FILE: vessel.c
==================================================

#define REACTION_HANDLER ("/obj/handlers/reaction")
#define TASTE_AMT 200
#include <tasks.h>
#include <move_failures.h>
#include <volumes.h>
inherit "/obj/baggage";
private int leak_rate;
private int hb_count;
private int sub_query_contents;
private int volume;
private int max_volume;
private int cont_volume;
private int is_liquid;
private nosave int* _fraction;
private nosave object* _liquids;
int drink_amount(int drinking, object player);
private int query_fighting(object player);
void set_leak_rate(int i) { leak_rate = i; }
int query_leak_rate() { return leak_rate; }
void set_max_volume(int v) { max_volume = v; }
int query_max_volume() { return max_volume; }
string *leak_verb = ({ " drips slowly",
                       " drips",
                       " dribbles",
                       " trickles slowly",
                       " trickles",
                       " trickles rapidly",
                       " pours sluggishly",
                       " pours",
                       " streams",
                       " gushes",
                       " fountains"
                     });
string *drink_pat = ({ "[from] <direct:object>",
                       "<fraction> {of|from} <direct:object>"
                   });
string *splash_pat = ({ "[from] <direct:object> {on|to|onto} <indirect:living>",
                       "<fraction> {of|from} <direct:object> {on|to|onto} "
                       "<indirect:living>"
                   });
string *apply_pat = ({ "[from] <direct:object> {on|to} <indirect:living>",
                       "<fraction> {of|from} <direct:object> {on|to} "
                       "<indirect:living>"
                   });
string *pour_pat = ({ "<direct:object> {from|into} <indirect:object>",
                      "<fraction> of <direct:object> {from|into} <indirect:object>"
                  });
string *fill_pat = ({ "<indirect:object> <fraction> full {from|into} <direct:object>",
                      "<indirect:object> <fraction> up {from|into} <direct:object>",
                      "<indirect:object> {from|into} <direct:object>"
                  });
void create() {
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) {
      this_object()->setup();
    }
    add_help_file("vessel");
}
void init() {
    ::init();
    add_command("drink", drink_pat);
    add_command("quaff", drink_pat);
    add_command("splash", splash_pat);
    add_command("rub", apply_pat);
    add_command("apply", apply_pat);
    add_command("pour", pour_pat);
    add_command("taste", "<direct:object>");
    add_command("sip", "<direct:object>");
    add_command("fill", fill_pat);
    add_command("empty", "<direct:object>");
}
string *fullness_adjectives() {
   if (!max_volume) return ({ "totally", "empty" });
   switch (100 * volume / max_volume) {
   case 0..4: return ({ "totally", "empty" });
   case 5..13: return ({ "empty" });
   case 65..94: return ({ "full" });
   case 95..100: return ({ "totally", "full" });
   default: return ({ });
   }
}
mixed stats() {
  return ::stats() + ({
      ({ "leak_rate", leak_rate }),
      ({ "volume", volume }),
      ({ "cont_volume", cont_volume }),
      ({ "liquid", is_liquid }),
      ({ "max_volume", max_volume })
    });
}
int cmp_amount_r(object a, object b) {
    return ((int)b->query_amount() - (int)a->query_amount());
}
int cmp_weight_r(object a, object b) {
    if (a->query_weight() || b->query_weight())
      return ((int)b->query_weight() - (int)a->query_weight());
    return cmp_amount_r(a, b);
}
private void figure_out_liquids() {
   _liquids = filter(all_inventory(this_object()), (: $1->query_liquid() :));
   _liquids = sort_array(_liquids, "cmp_amount_r", this_object());
}
string query_liquid_desc() {
    object *contents, *solids = ({});
    int i;
    string desc, *shorts;
    mixed *others;
    contents = all_inventory(this_object());
    if( !sizeof( contents ) ) {
       return (string) 0;
    }
    figure_out_liquids();
    solids = contents - _liquids;
    if (sizeof(_liquids)) {
       _liquids = sort_array(_liquids, "cmp_amount_r", this_object());
       others = unique_array(_liquids->a_short(),
                          (: "/global/events"->convert_message($1) :));
       shorts = ({ });
       for (i = 0; i < sizeof(others); i++) {
          shorts += ({ others[i][0] });
       }
       desc = shorts[0];
       if (sizeof(shorts) > 1) {
          desc += ", mixed with ";
          if (sizeof(shorts) > 4) {
             desc += "other liquids";
          } else {
             desc += query_multiple_short(shorts[1..]);
          }
       }
    } else {
       desc = "";
    }
    if (!sizeof(solids)) {
        return desc;
    }
    solids = sort_array(solids, "cmp_weight_r", this_object());
    others = unique_array(solids,
                          (: $1->query_continuous()?
                           this_player()->convert_message($1->a_short()) :
                           $1 :) );
    for (i = 0; i < sizeof(others); i++) {
       if( arrayp( others ) ) {
          others[i] = others[i][0];
       } else {
          tell_creator( "gruper", "others is %O.\n", others );
       }
    }
    if (sizeof(_liquids)) {
       desc += ", with ";
    }
    if (sizeof(others) > 10) {
        desc += "various undissolved substances";
    } else {
        desc += query_multiple_short(others);
    }
    if (sizeof(_liquids)) {
       desc += " floating in it";
    }
    return desc;
}
string query_fullness_desc() {
   int full;
   full = (100 * volume) / max_volume;
   if( full < 1 && query_liquid_desc() ) {
      full = 1;
   }
   switch (full) {
      case 0:       return "";
      case 1..12:   return "It is almost empty.";
      case 13..37:  return "It is about one-quarter full.";
      case 38..62:  return "It is about half full.";
      case 63..87:  return "It is about three-quarters full.";
      case 88..95:  return "It is almost full.";
      case 96..100: return "It is completely full.";
      default:      return "Its capacity defies the laws of physics.  "
                           "Please submit a bug report.";
    }
}
varargs string query_contents(string str, object *obs ) {
    string s, c;
    if ( query_liquid_desc() ) {
        c = "\n"+ query_fullness_desc() +"\n";
    } else {
        c = "";
    }
    s = query_liquid_desc();
    if (sub_query_contents) {
        if (s) {
            return str + capitalize(s) + "." + c;
        }
        return ::query_contents(str, obs) + c;
    }
    return ::query_contents(str, obs);
}
string short(int dark) {
  object *inv;
  if(query_opaque())
    return ::short(dark);
  inv = all_inventory(this_object());
  if(!sizeof(inv))
    return ::short(dark);
  return ::short(dark) + " of " +
    "/global/events"->convert_message(query_multiple_short(map(inv,
    (: $1->query_short() :))));
}
string long(string str, int dark) {
    string ret;
    sub_query_contents = 1;
    ret = ::long(str, dark);
    sub_query_contents = 0;
    return ret;
}
int query_cont_volume() { return cont_volume; }
int query_liquid() { return is_liquid; }
void calc_liquid() {
    if (sizeof(filter(all_inventory(), (: $1->query_liquid() :)))) {
      is_liquid = 1;
    } else {
      is_liquid = 0;
    }
}
int query_volume() { return volume; }
int query_volume_left() {
  if (!query_max_weight()) {
    return max_volume - volume;
  }
  return max_volume - volume - (max_volume*query_loc_weight())/query_max_weight();
}
int add_volume(int vol) {
   if ((vol <= 0) || !max_volume || (vol + volume <= max_volume)) {
      volume += vol;
      if (previous_object()->query_continuous()) {
          cont_volume += vol;
      }
      return 1;
    }
    return 0;
}
int add_weight(int n) {
    int v;
    if (this_player() && (this_player()->query_name() == "pinkfish")) {
      tell_creator("pinkfish", "vessel::add_weight(%O)\n", n);
    }
    if (previous_object()->query_continuous()) {
       return (::add_weight(n));
    }
      v = n*200;
    if (max_volume && (v + volume > max_volume)) {
       return 0;
    }
    if (::add_weight(n)) {
        volume += v;
        return 1;
    }
    return 0;
}
int remove_volume(int vol_lost)
{
    int amt_lost, i, orig_cv;
    object *contents;
    if (!cont_volume) {
        return 0;
    }
    orig_cv = cont_volume;
    contents = all_inventory(this_object());
    for (i = 0; i < sizeof(contents); i++) {
        if (contents[i]->query_continuous()) {
            amt_lost = -to_int((int)contents[i]->query_amount()
                               * (to_float(vol_lost) / orig_cv));
            if (!amt_lost) {
                amt_lost++;
            }
            contents[i]->adjust_amount(amt_lost);
        }
    }
    return vol_lost;
}
int xfer_volume(int vol_xferred, object dest) {
    int vol_to_go;
    int i;
    int amt_xferred;
    int tmp;
    int orig_cv;
    object *contents;
    object copy;
    string file_path;
    mapping map;
    vol_to_go = vol_xferred;
    if (!cont_volume) {
        return 0;
    }
    orig_cv = cont_volume;
    contents = filter(all_inventory(this_object()),
                      (: $1->query_continuous() :));
    for (i = 0; i < sizeof(contents) && vol_to_go > 0; i++) {
        if (i == sizeof(contents) - 1) {
            amt_xferred = vol_to_go;
        } else {
            amt_xferred = to_int((int)contents[i]->query_amount()
                                 * (to_float(vol_xferred) / orig_cv));
        }
        if (!amt_xferred) {
            amt_xferred++;
        }
        file_path = explode( file_name(contents[i]), "#" )[ 0 ];
        copy = clone_object(file_path);
        map = (mapping)contents[i]->query_dynamic_auto_load();
        copy->init_dynamic_arg( map );
        map = (mapping)contents[i]->query_static_auto_load();
        if (map) {
            copy->init_static_arg( map );
        }
        copy->set_amount(amt_xferred);
        tmp = copy->move(dest);
        if (tmp == MOVE_OK) {
            vol_to_go -= amt_xferred;
            contents[i]->adjust_amount(-amt_xferred);
        } else {
            copy->dest_me();
        }
    }
    return vol_to_go;
}
void heart_beat() {
    int lost, off;
    if (leak_rate == 0 || !is_liquid) {
        set_heart_beat(0);
        return;
    }
    if (hb_count--) return ;
    hb_count = 10;
    lost = leak_rate;
    if (lost > cont_volume)
      lost = cont_volume;
    off = lost/100;
    if (off > 10)
        off = 10;
    if ( interactive( environment() ) )
        tell_object( environment(), "$C$Some " + query_multiple_short( map( all_inventory(),
        (: $1->query_short() :) ) ) + leak_verb[off] + " out of the "+ short(1) + ".\n" );
    else
      tell_room( environment(), "$C$Some " + query_multiple_short( map( all_inventory(),
        (: $1->query_short() :) ) ) + leak_verb[off] + " out of the "+ short(1) + ".\n" );
  (void)remove_volume(lost);
  if (!cont_volume) {
    set_heart_beat(0);
  }
}
int do_pour(object *to, mixed *args_b, mixed *args_a, mixed *args) {
    int m, n, volume_needed, their_volume, their_max, ovf, xfer_result;
    if (query_fighting(this_player())) {
       add_failed_mess("You cannot attempt to do this while in combat.\n");
       return 0;
    }
    if (environment(this_object()) != this_player()) {
        add_failed_mess("You aren't carrying $D.\n");
        return 0;
    }
    if (sizeof(args) == 5) {
        sscanf(args[0] + " " + args[1], "%d %d", m, n);
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    if (query_locked()) {
        add_failed_mess("$C$$D $V$0=is,are$V$ locked!\n");
        return 0;
    }
    if (query_closed()) {
        if (do_open()) {
            write("You open the " + short(0) + ".\n");
        } else {
            add_failed_mess("You cannot open $D.\n");
            return 0;
        }
    }
    if (cont_volume <= 0) {
        add_failed_mess("$C$$D has nothing to pour!\n");
        return 0;
    }
    if (sizeof(to) > 1) {
        add_failed_mess("You can only pour into one object at a time.\n");
        return 0;
    }
    their_volume = (int)to[0]->query_volume();
    their_max = (int)to[0]->query_max_volume();
    if (their_max <= 0) {
        add_failed_mess("$C$" + to[0]->the_short(0) +
            " doesn't look like it can be filled!\n");
        return 0;
    }
    if (their_volume >= their_max) {
        add_failed_mess("The " + to[0]->short(0)
              + " $V$0=is,are$V$ full to the brim already.\n");
        their_volume = their_max;
    }
    if ((m == 1) && (n == 1)) {
        volume_needed = volume;
    } else {
        volume_needed = max_volume * m / n;
    }
    if (volume < volume_needed) {
        add_failed_mess("$C$$D $V$0=is,are$V$ less than " + m + "/" + n +
              " full.\n");
        return 0;
    }
    if (volume_needed > 120) {
        volume_needed += random(240) - 120;
    }
    if (volume_needed > (their_max - their_volume)) {
        volume_needed = their_max - their_volume;
        ovf = 1;
    }
    if (volume_needed > cont_volume) {
        add_failed_mess("You drain the " + short(0) + " into the "
              + to[0]->short(0) + " but it $V$0=is,are$V$ not enough.\n");
        volume_needed = cont_volume;
        this_player()->add_succeeded(to[0]);
    } else {
        this_player()->add_succeeded(to[0]);
    }
    xfer_result = xfer_volume( volume_needed, to[0] );
    if (xfer_result < volume_needed) {
        this_player()->add_succeeded_mess(this_object(), "$N $V $D into $I.\n", ({to[0]}));
    }
    else {
        add_failed_mess( "You were unable to $V $D into $I.\n", ({to[0]}));
        return 0;
    }
    if (ovf) {
        this_player()->add_succeeded_mess(this_object(), "$N $V $D into $I, " +
            "spilling some in the process.\n", ({to[0]}));
    }
    return 1;
}
int do_fill(object *to, mixed *args_b, mixed *args_a, mixed *args) {
    int m;
    int n;
    int i;
    int run_out;
    int volume_needed;
    int their_volume;
    int their_max;
    int amount_not_poured;
    int ok;
    if (query_fighting(this_player())) {
       add_failed_mess("You cannot attempt to do this while in combat.\n");
       return 0;
    }
    if (sizeof(args) == 4) {
        sscanf(args[1] + " " + args[2], "%d %d", m, n);
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    if (query_closed() &&
        query_locked()) {
        add_failed_mess("$C$$D $V$0=is,are$V$ locked!\n");
        return 0;
    }
    if (query_closed()) {
        if (do_open()) {
            write("You open the " + short(0) + ".\n");
        } else {
            add_failed_mess("You cannot open $D.\n");
            return 0;
        }
    }
    if (cont_volume <= 0) {
        add_failed_mess("$C$$D has nothing to pour!\n");
        return 0;
    }
    run_out = 0;
    for (i = 0; i < sizeof(to) && !run_out; i++) {
        if ((environment(this_object()) != this_player()) &&
            (environment(to[i]) != this_player())) {
            write("You're not carrying " + the_short() + " or " +
                  to[i]->the_short() + ".\n");
            continue;
        }
        if (to[i]->query_closed()) {
            add_failed_mess("$I $V$0=is,are$V$ closed.\n", to[i..i]);
            continue;
        }
        their_volume = (int)to[i]->query_volume();
        their_max = (int)to[i]->query_max_volume();
        if (their_max <= 0) {
            add_failed_mess("$I doesn't look like it can be filled!\n",
                            to[i..i]);
            continue;
        }
        if (their_volume >= their_max) {
            add_failed_mess("$I $V$0=is,are$V$ full to the brim already.\n", to[i..i]);
            continue;
        }
        volume_needed = their_max * m / n;
        if (their_volume >= volume_needed) {
            add_failed_mess("$I $V$0=is,are$V$ more than " + m + "/" + n +
                  " full already.\n", to[i..i]);
            continue;
        }
        if (volume_needed > 120) {
            volume_needed += random(240) - 120;
        }
        if (volume_needed > their_max) {
            volume_needed = their_max;
        }
        ok++;
        volume_needed -= their_volume;
        if (volume_needed > cont_volume) {
            add_failed_mess("You drain " + the_short() + " into "
                  + to[i]->the_short() + " but it $V$0=is,are$V$ not enough.\n");
            volume_needed = cont_volume;
            run_out = 1;
            this_player()->add_succeeded(to[i]);
        } else {
            this_player()->add_succeeded(to[i]);
        }
        amount_not_poured = xfer_volume(volume_needed, to[i]);
        if (amount_not_poured) {
           ok--;
        }
    }
    if (!ok) {
       add_failed_mess("You cannot seem to do anything useful with this "
                       "container, it seems unwilling to accept what you "
                       "offer.\n");
    }
    return ok;
}
private int query_fighting(object player) {
   object ob;
   if (!player || !environment(player)) {
      return 0;
   }
   if (player->query_fighting()) {
      return 1;
   }
   foreach (ob in all_inventory(environment(player))) {
      if (living(ob)) {
         if (ob->query_attacker_list() &&
             member_array(this_player(), ob->query_attacker_list()) != -1) {
            return 1;
         }
      }
   }
   if (environment(ob)->query_mirror_room()) {
      foreach (ob in all_inventory(environment(player)->query_mirror_room())) {
         if (living(ob)) {
            if (member_array(this_player(), ob->query_attacker_list()) != -1) {
               return 1;
            }
         }
      }
   }
}
int is_fighting_bottle_smashed(object player,
                               object me) {
   object* fighting;
   object ob;
   object weapon;
   string skill;
   string my_skill;
   int bonus;
   int stopped;
   stopped = 0;
   if (query_fighting(player)) {
      fighting = filter(player->query_attacker_list(),
                        (: environment($1) == $2 :), environment(player));
      if (query_holder()) {
         bonus = 0;
         bonus += -10 * player->query_free_limbs();
      } else {
         bonus = 20;
      }
      if (sizeof(fighting)) {
         bonus += (sizeof(fighting) - 1) * 20;
      }
      if (player->query_free_limbs() < 2 &&
          !query_holder()) {
         bonus += 50 - player->query_free_limbs() * 25;
      }
      foreach (ob in fighting) {
         if (sizeof(ob->query_holding() - ({ 0 }))) {
            weapon = (ob->query_holding() - ({ 0 }))[0];
            skill = weapon->query_weapon_type();
            if (skill == "mixed" ||
                (skill != "sharp" && skill != "blunt" && skill != "pierce")) {
               skill = ({ "sharp", "blunt", "pierce" })[random(3)];
            }
            skill = "fighting.combat.melee." + skill;
         } else {
            skill = "fighting.combat.melee.unarmed";
         }
         my_skill = "fighting.combat.special.unarmed";
         switch (player->query_combat_response()) {
         case "parry" :
            my_skill = "fighting.combat.parry.melee";
            break;
         case "dodge" :
            my_skill = "fighting.combat.dodging.melee";
            break;
         case "neutral" :
            my_skill = "fighting.combat." +
            (({ "parry", "dodging" })[random(2)]) + ".melee";
         }
         switch (TASKER->compare_skills(player,
                                       my_skill,
                                       ob,
                                       skill,
                                       -bonus,
                                       TM_FREE,
                                       TM_FREE)) {
         case OFFAWARD :
            if (player->query_combat_response() == "dodge") {
               tell_object(player,
                           "%^YELLOW%^You nimbly dodge an attack to avoid "
                           "getting " +
                           me->poss_short() +
                           " smashed out of your hand and feel better about "
                           "attempting it next time.\n%^RESET%^");
            } else {
               tell_object(player,
                           "%^YELLOW%^You nimbly parry an attack to avoid "
                           " getting " +
                           me->poss_short() +
                           " smashed out of your hand and feel better about "
                           "attempting it next time.\n%^RESET%^");
            }
         case OFFWIN :
            tell_room(environment(player),
                      player->the_short() + " avoids getting " +
                      me->poss_short() + " smashed by " +
                      query_multiple_short(({ ob })) + ".\n",
                               ({ player }));
            tell_object(player,
                        "You avoid getting " + me->poss_short() +
                        " smashed by " + query_multiple_short(({ ob })) +
                        ".\n");
            do_damage("crush", 20 + random(50));
            break;
         case DEFAWARD :
            tell_object(ob,
                        "%^YELLOW%^You feel much more able to smash "
                        "bottles out of peoples hands than "
                        "before.\n%^RESET%^");
         case DEFWIN :
            if (!query_holder() &&
                me->move(environment(player)) == MOVE_OK) {
               tell_room(environment(player),
                   ob->the_short() + " smashes " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n",
                   ({ player, me }));
               tell_object(player,
                   ob->the_short() + " smashes " + the_short() + " out of " +
                   "your hands onto the ground "
                   "causing some of the liquid to splash out.\n");
               tell_object(me,
                   ob->the_short() + " smash " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n");
            } else {
               tell_room(environment(player),
                   ob->the_short() + " smashes " + the_short() + " away "
                   "from " + player->the_short() + "'s mouth causing "
                   "some of the liquid to splash out.\n", ({ player, me }));
               tell_object(player,
                   ob->the_short() + " smashes " + the_short() + " away "
                   "from " + "your mouth causing some of the liquid to "
                   "splash out.\n");
               tell_object(me,
                   ob->the_short() + " smash " + the_short() + " out of " +
                   player->the_short() + "'s hands onto the ground "
                   "causing some of the liquid to splash out.\n");
            }
            stopped = 1;
            break;
         }
         if (stopped) {
            break;
         }
      }
   }
   return stopped;
}
private string consumed_desc( int consumed_amount ) {
   string amount_desc;
   object* contents;
   string* contents_descs = ({ });
   string contents_desc;
   contents = all_inventory( this_object() );
   if( !consumed_amount || !sizeof( contents ) )
      return "nothing much";
   switch( consumed_amount ) {
   case 1..30:
      amount_desc = "a teaspoon";
      break;
   case 31..80:
      amount_desc = "a tablespoon";
      break;
   case 81..140:
      amount_desc = "an ounce";
      break;
   case 141..800:
      amount_desc = "a few ounces";
      break;
   case 801..1200:
      amount_desc = "a cup";
      break;
   case 1201..2000:
      amount_desc = "a couple of cups";
      break;
   case 2001..3500:
      amount_desc = "a pint";
      break;
   case 3501..7000:
      amount_desc = "a couple of pints";
      break;
   case 7001..15000:
      amount_desc = "several pints";
      break;
   case 15001..25000:
      amount_desc = "about a gallon";
      break;
   default:
      amount_desc = "several gallons";
   }
   contents = filter( contents, (: $1->query_liquid() :) );
   foreach( string* frog in unique_array( contents->short(), (: $1 :) ) ) {
      if( sizeof( frog ) > 1 ) {
         contents_descs += ({ pluralize( frog[0] ) });
      } else {
         contents_descs += ({ frog[0] });
      }
   }
   contents_desc = query_multiple_short( contents_descs );
   return amount_desc +" of "+ contents_desc;
}
int drink_amount(int drinking,
                 object player) {
   int cap_amount;
   int amt_to_drink;
   int amount_can_be_drunk;
   object* contents;
   object ob;
   int orig_cv;
   amt_to_drink = drinking;
   if (amt_to_drink > cont_volume) {
      amt_to_drink = cont_volume;
   }
   if (max_volume / 20 > VOLUME_WINE) {
      cap_amount = max_volume / 20;
   } else {
      cap_amount = VOLUME_WINE;
   }
   if (amt_to_drink < cap_amount) {
      if (query_fighting(player)) {
         amt_to_drink += random(2 * (cap_amount - amt_to_drink)) -
                         cap_amount - amt_to_drink;
         if (amt_to_drink < VOLUME_MINIMUM_DRINKABLE * 2) {
            amt_to_drink = VOLUME_MINIMUM_DRINKABLE * 2;
         }
      } else {
         amt_to_drink += random((cap_amount - amt_to_drink) / 6) -
                         (cap_amount - amt_to_drink) / 12;
      }
   }
   if (amt_to_drink < VOLUME_MINIMUM_DRINKABLE) {
      amt_to_drink = VOLUME_MINIMUM_DRINKABLE;
   }
   if (amt_to_drink < (max_volume / 100)) {
      amt_to_drink = max_volume / 100;
   }
   if( amt_to_drink > cont_volume ) {
      amt_to_drink = cont_volume;
   }
   amount_can_be_drunk = (8000 - (int)this_player()->query_volume(2)) *
     (int)this_player()->query_con() / 12;
   if (amt_to_drink > amount_can_be_drunk) {
       write("You drink some of the liquid, "
             "but simply cannot fit it all in.\n");
       amt_to_drink = amount_can_be_drunk;
   }
   if (is_fighting_bottle_smashed(this_player(), this_object())) {
      amt_to_drink *= (1 + random(15));
      if (amt_to_drink > volume) {
         amt_to_drink = volume;
      }
      orig_cv = cont_volume;
      foreach (ob in all_inventory(this_object())) {
         if (ob->query_continuous()) {
            if (amt_to_drink == cont_volume) {
               ob->adjust_amount(-ob->query_amount());
            } else {
               ob->adjust_amount(-(ob->query_amount() * amt_to_drink / orig_cv));
            }
         }
      }
      add_succeeded_mess("");
      do_damage("crush", 50 + random(300));
      return 1;
   }
   contents = all_inventory(this_object());
   if( sizeof( contents[0]->query_eat_mess() ) ) {
      add_succeeded_mess( contents[0]->query_eat_mess() );
   } else {
      add_succeeded_mess("$N $V "+ consumed_desc( amt_to_drink ) +
                         " from $D.\n");
   }
   if (amt_to_drink - drinking > (max_volume / 40) &&
       amt_to_drink - drinking > VOLUME_MINIMUM_DRINKABLE) {
      add_succeeded_mess(({ "Whoops!  You seemed to have gulped "
                            "too much down.\n",
                            "" }));
   }
   orig_cv = cont_volume;
   foreach (ob in contents) {
       if (ob->query_continuous()) {
           if (amt_to_drink == orig_cv) {
               ob->consume(this_player(), ob->query_amount());
           } else {
               ob->consume(this_player(),
                           ob->query_amount() * amt_to_drink / orig_cv);
           }
       }
   }
   return 1;
}
int do_drink(object *dest, mixed me, mixed him, mixed args, string pattern)
{
    int amt_to_drink;
    int m;
    int n;
    if (sizeof(dest)) {
        add_failed_mess("Drinking is a very simple operation "
              "- please don't complicate matters.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        add_failed_mess("You aren't carrying $D.\n");
        return 0;
    }
    if (!ensure_open()) {
       return 0;
    }
    if (!is_liquid) {
        add_failed_mess("$C$$D $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    if (pattern == drink_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ( n > 100 ) {
          add_failed_mess( "You can't drink with that much precision!\n" );
          return 0;
        }
        if ((m > n) || (m < 0) || (n <= 0)) {
            add_failed_mess("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    if (_fraction) {
        m = _fraction[0];
        n = _fraction[1];
    }
    if ((m == 1) && (n == 1)) {
        amt_to_drink = cont_volume;
    } else {
        amt_to_drink = (max_volume*m)/n;
        if (amt_to_drink > volume) {
            add_failed_mess("$C$$D $V$0=is,are$V$ less than " + m + "/" + n +
                  " full.\n");
            return 0;
        }
        if (amt_to_drink > cont_volume) {
            amt_to_drink = cont_volume;
        }
    }
    if (!drink_amount(amt_to_drink, this_player())) {
       return 0;
    }
    switch ((this_player()->query_volume(2) + 100) / 200) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        break;
      case 5:
        write("You feel mildly full of liquid.\n");
        break;
      case 6:
        write("You feel very full of liquid.\n");
        break;
      case 7:
        write("You feel all the liquid sloshing around inside you.\n");
        break;
      case 8:
        write("You are awash with liquid.\n");
        break;
      case 9:
        write("You are full to the brim with liquid.\n");
        break;
      default:
        write("You feel you would burst if you drank any more.\n");
        break;
    }
    return 1;
}
int do_quaff(object *dest, mixed me, mixed him, mixed args, string pattern) {
   return do_drink(dest, me, him, args, pattern);
}
int do_empty(object *dest, string me, string him, string prep)
{
   if (environment(this_object()) != this_player()) {
       add_failed_mess("You are not carrying $D.\n");
       return 0;
   }
   if (sizeof(dest)) {
       write("Passing on to pour ... bad move.\n");
   }
   if (!ensure_open()) {
      add_failed_mess("$C$$D $V$0=is,are$V$ not open.\n");
      return 0;
   }
   if (cont_volume == 0 &&
       !sizeof(all_inventory())) {
       add_failed_mess("$C$$D $V$0=is,are$V$ already empty.\n");
       return 0;
   }
   (void)remove_volume(cont_volume);
   all_inventory()->move(environment(this_player()));
   return 1;
}
int check_splashable(object ob, object splasher, object splashee){
  return ob->query_splashable(splasher, splashee);
}
int do_splash(object *dest, mixed me, mixed him, mixed args, string pattern) {
    int amt_to_splash, i, m, n, orig_cv;
    object *contents;
    if (!sizeof(dest)) {
        add_failed_mess("Splash it on who?\n");
        return 0;
    }
    if(sizeof(dest) >1){
        add_failed_mess("You may only splash one person at a time.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) return 0;
    if (!is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    if (pattern == splash_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ((m > n) || (m < 0) || (n <= 0)) {
            notify_fail("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    contents = filter( all_inventory(this_object()), (:check_splashable:),
          this_player(), dest[0]);
    if( !sizeof(contents) ){
       add_failed_mess("You can't splash anything in $D.\n");
       return 0;
    }
    orig_cv = cont_volume;
    if ( m == n ){
        amt_to_splash = cont_volume;
    } else {
        amt_to_splash = (max_volume*m)/n;
        if (amt_to_splash > volume) {
            add_failed_mess("The " + short(0) + " $V$0=is,are$V$ less than "
               + m + "/" + n + " full.\n");
            return 0;
        }
        if (amt_to_splash > cont_volume) {
            amt_to_splash = cont_volume;
        }
    }
    if(this_player() == dest[0]){
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto "+this_player()->query_objective() +
                     "self.\n", ({}));
    }else{
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto $I.\n", dest);
    }
    for (i = 0; i < sizeof(contents); i++) {
        if (amt_to_splash == cont_volume) {
           contents[i]->consume(dest[0],
           contents[i]->query_amount(), "splash");
        } else {
           contents[i]->consume(dest[0],
              (int)contents[i]->query_amount()
              * amt_to_splash / orig_cv, "splash");
        }
    }
    return 1;
}
int check_applicable(object ob, object applier, object appliee){
  return ob->query_applicable(applier, appliee);
}
int do_rub(object *dest, mixed me, mixed him, mixed args, string pattern) {
    int amt_to_apply, i, m, n, orig_cv;
    object *contents;
    if (!sizeof(dest)) {
        add_failed_mess("Rub it on who?\n");
        return 0;
    }
    if(sizeof(dest) >1){
        add_failed_mess("You may only rub stuff on one person at a time.\n");
        return 0;
    }
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) return 0;
    if (!is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    if (pattern == apply_pat[1]) {
        m = to_int(args[0]);
        n = to_int(args[1]);
        if ((m > n) || (m < 0) || (n <= 0)) {
            notify_fail("Interesting fraction you have there!\n");
            return 0;
        }
    } else {
        m = 1;
        n = 1;
    }
    contents = filter( all_inventory(this_object()), (:check_applicable:),
        this_player(), dest[0]);
    if( !sizeof(contents) ){
       add_failed_mess("You can't rub anything in $D on $I.\n",dest);
    }
    orig_cv = cont_volume;
    if ( m == n ){
        amt_to_apply = cont_volume;
    } else {
        amt_to_apply = (max_volume*m)/n;
        if (amt_to_apply > volume) {
            add_failed_mess("The " + short(0) + " $V$0=is,are$V$ less than "
               + m + "/" + n + " full.\n");
            return 0;
        }
        if (amt_to_apply > cont_volume) {
            amt_to_apply = cont_volume;
        }
    }
    if (this_player() == dest[0]){
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto "+this_player()->query_objective()+"self.\n", ({}));
    } else {
       this_player()->add_succeeded_mess(this_object(),
                     "$N $V " + query_multiple_short(contents) +
                     " from $D onto $I.\n", dest);
    }
    for (i = 0; i < sizeof(contents); i++) {
        if (amt_to_apply == cont_volume) {
           contents[i]->consume(dest[0],
                          contents[i]->query_amount(),"apply");
        } else {
           contents[i]->consume(dest[0],
              (int)contents[i]->query_amount()
              * amt_to_apply / orig_cv, "apply");
        }
    }
    return 1;
}
int do_apply(object *dest, mixed me, mixed him, mixed args, string pattern){
   return do_rub(dest, me, him, args, pattern);
}
int do_taste() {
    int amount_tasted;
    if (environment(this_object()) != this_player()) {
        write("You aren't carrying the " + short(0) + ".\n");
        return 0;
    }
    if (!ensure_open()) {
       return 0;
    }
    if (!cont_volume || !is_liquid) {
        add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
        return 0;
    }
    amount_tasted = VOLUME_SHOT;
    if (cont_volume < amount_tasted) {
        amount_tasted = cont_volume;
    }
    if (amount_tasted < max_volume / 100) {
       amount_tasted = max_volume / 100;
    }
    return drink_amount(amount_tasted, this_player());
}
int do_sip() {
   int amount_tasted;
   if (environment(this_object()) != this_player()) {
      write("You aren't carrying the " + short(0) + ".\n");
      return 0;
   }
   if (!ensure_open()) {
      return 0;
   }
   if (!cont_volume || !is_liquid) {
      add_failed_mess("The " + short(0) + " $V$0=is,are$V$ bone dry!\n");
      return 0;
   }
   amount_tasted = VOLUME_SHOT * 2;
   if (cont_volume < amount_tasted) {
      amount_tasted = cont_volume;
   }
   if (amount_tasted < max_volume / 70) {
      amount_tasted = max_volume / 70;
   }
   return drink_amount(amount_tasted, this_player());
}
int do_smell() {
   if (!ensure_open()) {
      return 0;
   }
   write("Smelling isn't implemented yet.  Sorry.\n");
   return 1;
}
protected int handle_restore_inventory(object ob) {
   int ret;
   ret = ::handle_restore_inventory(ob);
   if (ret == MOVE_OK) {
      return MOVE_OK;
   }
   if (ob->query_liquid()) {
      ob->set_amount( query_max_volume() - query_volume() );
      ret = ::handle_restore_inventory(ob);
      if (ret == MOVE_OK) {
         return MOVE_OK;
      }
   }
   return ret;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp, "leak rate" : leak_rate,
           "max volume" : max_volume,
          ]);
}
mapping query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/vessel" ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["leak rate"]))
    leak_rate = args["leak rate"];
  if (!undefinedp(args["max volume"]))
    max_volume = args["max volume"];
}
int test_add(object ob, int flag) {
    int new_vol;
    if ( !::test_add( ob, flag ) ) {
        return 0;
    }
    if (ob->query_continuous()) {
        new_vol = ob->query_amount();
    } else if (ob->query_property("density")) {
        new_vol = (int)ob->query_weight()*(int)ob->query_property("density");
    } else {
        new_vol = 0;
    }
    if ((new_vol + volume) > max_volume) {
        return 0;
    }
    return 1;
}
void event_enter(object ob, string message, object from) {
    int ob_vol, ob_cont;
    if (environment(ob) == this_object()) {
        if (ob->query_continuous() ) {
            ob_vol = ob->query_amount();
            ob_cont = 1;
        } else if (ob->query_property("density")) {
            ob_vol = (int)ob->query_weight()*
              (int)ob->query_property("density");
        } else {
            ob_vol = 0;
        }
        if (ob->query_liquid()) {
           is_liquid = 1;
           _liquids = ({ });
        }
#ifdef DEBUG
        debug_printf("Increasing volume by " + ob_vol + ".\n");
#endif
        volume += ob_vol;
        if (ob_cont) cont_volume += ob_vol;
        REACTION_HANDLER->check_reaction(ob);
        if (leak_rate > 0) {
            set_heart_beat(1);
        }
    }
}
void event_exit(object ob, string mess, object to) {
    int ob_vol, ob_cont;
    if (environment(ob) == this_object()) {
        if (ob->query_continuous()) {
            ob_vol = ob->query_amount();
            ob_cont = 1;
        } else if (ob->query_property("density")) {
            ob_vol = (int)ob->query_weight()*
              (int)ob->query_property("density");
        } else {
            ob_vol = 0;
        }
#ifdef DEBUG
        debug_printf("Decreasing volume by " + ob_vol + ".\n");
#endif
        volume -= ob_vol;
        if (ob_cont) cont_volume -= ob_vol;
        if (volume <= 0) is_liquid = 0;
    }
}
void break_me() {
  object *liquid;
   liquid = filter(all_inventory(), (: $1->query_liquid() :));
   if (sizeof(liquid)) {
      tell_room(environment(),
         query_multiple_short(liquid) + " splashes all over the place "
         "as " + the_short() + " breaks.\n");
       liquid->move("/room/rubbish");
   }
   ::break_me();
}
mixed* parse_match_object(string* input, object player,
                          class obj_match_context context) {
   int result;
   result = ::is_matching_object(input, player, context);
   if (result) {
      _fraction = context->fraction;
      if (update_parse_match_context(context, 1, result)) {
         return ({ result, ({ this_object() }) });
      }
   }
   return 0;
}
string *parse_command_adjectiv_id_list() {
   string *ret;
   ret =  fullness_adjectives() + ::parse_command_adjectiv_id_list();
   if (is_liquid && !query_opaque()) {
      object liquid;
      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_adjectiv_id_list();
      }
      return ret;
   }
   return ret;
}
string* parse_command_id_list() {
   if (is_liquid && !query_opaque()) {
      string* ret;
      object liquid;
      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      ret = ::parse_command_id_list();
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_id_list();
      }
      return ret;
   }
   return ::parse_command_id_list();
}
string* parse_command_plural_id_list() {
   if (is_liquid && !query_opaque()) {
      string* ret;
      object liquid;
      if (!sizeof(_liquids)) {
         figure_out_liquids();
      }
      _liquids -= ({ 0 });
      ret = ::parse_command_plural_id_list();
      foreach (liquid in _liquids) {
         ret += liquid->parse_command_plural_id_list();
      }
      return ret;
   }
   return ::parse_command_plural_id_list();
}
int query_vessel() { return 1; }

==================================================
FILE: virtual_room.c
==================================================

inherit "/std/room";
#include <virtual_room.h>
nosave mixed  *reset_definitions;
nosave object *reset_objects;
void add_cloned_object( int flag, int delay, mixed clone_info,
                       string entry_mess ) {
   if ( functionp( clone_info ) )
      clone_info = bind( clone_info, this_object() );
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
}
mixed *query_cloned_objects() {
   return reset_objects + ({ });
}
mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
}
private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
}
protected void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
}
void reset() {
   int i;
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] ||
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 ) {
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            } else {
               make_object( i );
            }
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 ) {
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            } else {
               make_object( i );
            }
         }
      }
   }
}

==================================================
FILE: wand.c
==================================================

#include <artifacts.h>
#include <tasks.h>
inherit "/obj/weapon";
inherit "/std/basic/artifact";
int query_magic_wand() { return 1; }
void create() {
  weapon::create();
  set_artifact_type( "wand" );
}
void set_weight( int number ) {
  weapon::set_weight( number );
  new_weapon( 80 * number );
   add_attack( "prod", 90, ({ 0, 5, weight }), "blunt", "blunt", 0 );
}
string long( int word, int dark ) {
  return artifact::long( word, dark ) + weapon::long( word, dark );
}
void init() {
  this_player()->add_command( "zap", this_object(), "<direct:object> at <indirect:object>" );
  this_player()->add_command( "zap", this_object(), "<indirect:object> with <direct:object>" );
}
int do_zap( object *things ) {
  int outcome;
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to $V it.\n", ({ }) );
    return 0;
  }
  if( ( sizeof( things ) > 1 ) ||
      ( sizeof( filter( things, (: $1->query_amount() > 1 :)) ) )
    ){
    this_player()->add_failed_mess( this_object(), "You can only zap $D "+
        "at one object at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot zap $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  outcome = (int)TASKER->perform_task(this_player(), WAND_SKILL, level,
                                      TM_FREE);
  if ( outcome == FAIL ) {
    this_player()->add_failed_mess( this_object(), "You failed "+
        "to $V $D.\n", ({ }) );
    return 0;
  }
  if ( !charges ) {
    this_player()->add_failed_mess( this_object(), "It appears that there "+
        "are no charges in $D.\n", ({ }) );
    return 0;
  }
   if ( outcome == AWARD ) {
      write( "%^YELLOW%^"+ ({ "A piece of lore concerning wands becomes "
            "clearer for you", "You manage to grasp one of the principles "
            "of magic wands more firmly", "A sudden flash of insight allows "
            "you to understand the wand a little better" })[ random( 3 ) ] +
            ".%^RESET%^\n" );
   }
  charges--;
  if ( random( 100 ) < level / 10 ) {
    if ( !zapper->failed_zap( things[ 0 ], this_player(), this_object() ) )
      this_player()->add_succeeded_mess( this_object(), "$N $V $D at $I but "+
          "nothing happens!\n", things );
    return 1;
  }
  zapper->zap( things[ 0 ], this_player(), this_object() );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
}
mixed *stats() {
  return weapon::stats() + artifact::stats();
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : weapon::query_dynamic_auto_load(),
    "artifact" : artifact::query_dynamic_auto_load(),
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/wand" )
    return ([ ]);
  return ([
    "::" : int_query_static_auto_load(),
    "artifact" : artifact::query_static_auto_load(),
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_dynamic_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_dynamic_arg( map[ "artifact" ] );
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    weapon::init_static_arg( map[ "::" ] );
  if ( map[ "artifact" ] )
    artifact::init_static_arg( map[ "artifact" ] );
}

==================================================
FILE: weapon.c
==================================================

inherit "/std/object";
inherit "/std/weapon_logic";
inherit "/std/basic/condition";
inherit "/std/basic/holdable";
#include "weapon.h"
#include "money.h"
#include <move_failures.h>
#include <virtual.h>
string *un_modifyable;
mixed *wield_func;
void create() {
   set_damage_chance( 25 );
   un_modifyable = ({ });
   weapon_logic::create();
   holdable::create();
   condition::create();
   object::create();
   add_alias("weapon");
   add_plural("weapons");
   if (!query_property("shop type")) {
      add_property("shop type", "armoury");
   }
   add_help_file("weapon");
}
string short(int dark) {
   string str;
   str = "";
   return ::short(dark)+str;
}
void set_wield_func(string func, mixed ob) {
   if (!func) {
      wield_func = 0;
   } else {
      wield_func = ({ func, ob });
   }
}
int query_weapon() { return 1; }
string long(string s, int dark) {
   return ::long(s, dark)+cond_string();
}
void new_weapon( int new_condition ) {
   set_cond( new_condition );
   set_max_cond( new_condition );
   set_lowest_cond( new_condition );
}
int held_this_item(int held, object holder, mixed arg) {
  int weight;
  object weapon;
  if(held == 1 && interactive(holder)) {
    weight = this_object()->query_weight();
    foreach(weapon in holder->query_weapons())
      weight += weapon->query_weight();
    weight -= holder->query_str();
    switch(weight) {
    case 76..10000:
      tell_object(holder, "You struggle to hold " +
                  query_multiple_short(holder->query_holding() +
                                       ({ this_object() }) - ({ 0 })) +
                  ".\n");
      break;
    case 50..75:
      tell_object(holder, "You struggle slightly to hold " +
                  query_multiple_short(holder->query_holding() +
                                       ({ this_object() }) - ({ 0 })) +
                  ".\n");
      break;
    default:
    }
  }
  if (wield_func) {
    if (!held) {
      return call_other(wield_func[1], wield_func[0], 0);
    } else if (held == 1) {
      return call_other(wield_func[1], wield_func[0], holder);
    }
  }
  return 1;
}
varargs int move( mixed dest, string messin, string messout ) {
   int ret;
   int limb;
   object holder;
   limb = query_my_limb();
   holder = query_holder();
   ret = holdable::move(dest);
   if (ret != MOVE_OK) {
      return ret;
   }
   ret = object::move( dest, messin, messout );
   if (ret != MOVE_OK && holder) {
      holder->set_hold(this_object(), limb);
   }
   return ret;
}
void dest_me() {
  holdable::dest_me();
  object::dest_me();
}
int modify_damage(int val, string name) {
  int tmp;
  tmp = val + (val * query_enchant()) /
    (query_max_enchant() + query_enchant());
  if(member_array(name, un_modifyable) != -1)
    return tmp;
  tmp = ( tmp * query_cond() ) / query_max_cond();
  if(tmp < val / 10)
    return val / 10;
  return tmp;
}
void hit_weapon( int amount, string type ) {
   if ( member_array( type, un_modifyable) != -1 )
      return;
   do_damage( type, amount );
}
int add_immune(string name) {
   if (member_array(name, un_modifyable) != -1)
      return 0;
   un_modifyable += ({ name });
   return 1;
}
int remove_immune(string name) {
   int i;
   if ((i = member_array(name, un_modifyable)) == -1)
      return 0;
   un_modifyable = delete(un_modifyable, i, 1);
   return 1;
}
int query_value() {
   return ( ::query_value() * ( 10 + ( 90 * query_cond() ) /
                               query_max_cond() ) ) / 100;
}
int query_full_value() { return ::query_value(); }
mixed *query_money_array() {
   return (mixed *)MONEY_HAND->create_money_array(query_value());
}
int query_money(string type) {
   int i;
   mixed *m_a;
   m_a = (mixed *)MONEY_HAND->create_money_array(query_value());
   if ((i=member_array(type, m_a)) == -1)
      return 0;
   return m_a[i+1];
}
mixed *stats() {
   return
      object::stats() +
      condition::stats() +
      weapon_logic::stats();
}
void break_me() {
   if ( query_holder() ) {
      tell_object( query_holder(), "%^RED%^$C$"+ the_short() +" breaks!%^RESET%^\n" );
      tell_room( environment( query_holder() ), poss_short() +
                 " breaks!\n", query_holder() );
      query_holder()->set_unhold( this_object() );
   }
   ::break_me();
}
void player_wield(int pos) {
  if (!environment()) {
    return;
  }
  this_object()->hold_item( environment(), pos );
}
mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/weapon" )
      return int_query_static_auto_load();
   return 0;
}
mapping int_query_static_auto_load() {
   mapping tmp;
   tmp = object::int_query_static_auto_load();
   return ([ "::" : tmp,
      "attack names" : attack_names,
      "attack data" : attack_data,
      "attack types" : attack_types,
      "hold" : holdable::query_static_auto_load(),
      "condition" : condition::query_static_auto_load()
          ]);
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([
      "::" : object::query_dynamic_auto_load(),
      "condition" : condition::query_dynamic_auto_load(),
      "hold" : holdable::query_dynamic_auto_load(),
           ]);
   return map;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) return ;
   if ( map[ "::" ] ) {
      object::init_static_arg( map[ "::" ] );
   }
   if ( map[ "attack names" ] ) {
      attack_names = map[ "attack names" ];
   }
   if ( map[ "attack data" ] ) {
      attack_data = map[ "attack data" ];
   }
   if ( map[ "attack types" ] ) {
      attack_types = map[ "attack types" ];
   }
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_static_arg( map[ "condition" ] );
   }
   if (map["no limbs"]) {
      holdable::init_static_arg(map);
   } else {
      holdable::init_static_arg(map["hold"]);
   }
}
void replace_me(){
  object receipt;
  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}
void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_dynamic_arg( map[ "condition" ] );
   }
   holdable::init_dynamic_arg(map["hold"], 1);
   if( virt_name = query_property( VIRTUAL_NAME_PROP) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
}

==================================================
FILE: potions/potion.c
==================================================

inherit "/std/object";
#include <tasks.h>
#define SKILL_WGT 0
#define SKILL_MAX 1
#define SKILL_LVL 2
#define SKILL_ADV 3
#define REAGENTS "/obj/reagents/"
int min_level, max_level, advance_chance, backfire_chance, rel_strength;
mapping skills = allocate_mapping(1);
string *skill_str, reagent_alias, backfire_alias, potion_verb, recipe;
string chant;
void set_min_level(int l) { min_level = l; }
void set_max_level(int l) { max_level = l; }
int query_min_level() { return min_level; }
int query_max_level() { return max_level; }
void set_advance_chance(int c) { advance_chance = c; }
int query_advance_chance() { return advance_chance; }
void set_backfire_chance(int c) { backfire_chance = c; }
int query_backfire_chance() { return backfire_chance; }
void set_reagent_alias(string s) { reagent_alias = s; }
string query_reagent_alias() { return reagent_alias; }
void set_backfire_alias(string s) { backfire_alias = s; }
string query_backfire_alias() { return backfire_alias; }
void set_rel_strength(int s) { rel_strength = s; }
int query_rel_strength() { return rel_strength; }
void set_potion_verb(string s) { potion_verb = s; }
string query_potion_verb() { return potion_verb; }
void set_recipe(string s) { recipe = s; }
string query_recipe() { return recipe; }
void set_chant(string s) { chant = s; }
string query_chant() { return chant; }
void set_skills(mixed s) {
    int i;
    for (i = 0; i < (sizeof(s)); i++) {
        skills[s[i][0]] = ({s[i][SKILL_WGT+1], s[i][SKILL_MAX+1],
                            s[i][SKILL_LVL+1], 0});
    }
    skill_str = keys(skills);
}
mapping query_skills() { return skills; }
object clone_reagent(string given_verb) {
    int result, i, sum, x;
    string s;
    object ob;
    if (potion_verb != given_verb) return 0;
    for (i = 0; i < sizeof(skill_str); i++) {
        s = skill_str[i];
        skills[s][SKILL_ADV] = 0;
        if (skills[s][SKILL_LVL]) {
            if ((x = (int)this_player()->query_skill(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        } else {
            if ((x = (int)this_player()->query_skill_bonus(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        }
        sum += x * skills[s][SKILL_WGT];
    }
    result = TASKER->attempt_task(min_level, sum, advance_chance,
                          (max_level - min_level));
    if ((result == FAIL) || (result == BARF)) {
        if (random(100) < backfire_chance) {
            ob = clone_object(REAGENTS+"brew_reagent.ob");
            ob->set_medium_alias(backfire_alias);
            ob->set_amount(sum*rel_strength/min_level);
            return ob;
        }
        return 0;
    }
    if (result == AWARD) {
        for (i = 0; i < sizeof(skill_str); i++) {
            s = skill_str[i];
            if (skills[s][SKILL_ADV]) {
                this_player()->add_skill_level(s, 1, 0);
            }
        }
    }
    ob = clone_object(REAGENTS+"brew_reagent.ob");
    ob->set_medium_alias(reagent_alias);
    ob->set_amount(sum*rel_strength/min_level);
    return ob;
}

==================================================
FILE: fungi/blue_nightcap.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "blue capped" );
  set_type( "mushroom" );
  set_extra( "The shape of it reminds you of someone wearing a nightcap." );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/tranquil_sleep", 60 +
        random( 60 ) );
  ::next_stage();
}

==================================================
FILE: fungi/fire_mushroom.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "red stalked" );
  set_type( "mushroom" );
  set_extra( "It seems to be gently smoking." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ swells and suddenly releases a cloud of smoke.\n",
    "There is a flash at the base of the $type$ and with a small roar, it "+
        "rockets into the sky.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/basic_charging", 20 +
        random( 11 ) );
  ::next_stage();
}
int query_charging_power() {
  int denominator, numerator, wholes;
  mapping eat_effects;
  eat_effects = query_eat_effects();
  if ( !query_continuous() )
    return eat_effects[ "/std/effects/ingested/basic_charging" ] *
      (int)this_object()->query_weight();
  denominator = query_weight_unit()[ 1 ];
  numerator = eat_effects[ "/std/effects/ingested/basic_charging" ] *
    query_amount() * query_weight_unit()[ 0 ];
  wholes = numerator / denominator;
  numerator %= denominator;
  if ( random( denominator ) < numerator )
    wholes++;
  return wholes;
}

==================================================
FILE: fungi/glow_toadstool.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "yellow spotted" );
  set_type( "toadstool" );
  set_extra( 0 );
}
void next_stage() {
  if ( stage == 8 ) {
    tell_room( environment(), "The yellow spots on the toadstool begin to "+
        "glow.\n" );
    set_light( 5 );
    set_long( query_long() +"The yellow spots are glowing.\n" );
  }
  ::next_stage();
}

==================================================
FILE: fungi/magic_mushroom.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "checkered" );
  set_type( "mushroom" );
  set_extra( "The checks are nice pastel shades of peach and mauve." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ jumps up and down very quickly, and then burps.\n",
    "You hear a small voice say: Goodbye, cruel world!\nThe $type$ "+
        "falls over and disintegrates.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/hallucination", 150 +
        random( 150 ) );
  ::next_stage();
}

==================================================
FILE: fungi/rust_fungus.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "rust" );
  set_type( "fungus" );
  set_extra( "It looks like a lump of rust, only soft and a bit squishy." );
  set_messages( ({
    "A small $type$ sprouts on the metal.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ silently releases a red dust into the air.\n",
    "The $type$ collapses in on itself and falls apart.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/strength_boost", 2000 +
        random( 1000 ) );
  ::next_stage();
}

==================================================
FILE: reagents/.generic_liquid.ob_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/reagents/generic_liquid.ob#1" );
  call_other( clone, "add_adjective",  "some"  );
  call_other( clone, "add_alias",  "liquid"  );
  call_other( clone, "set_amount_types",  ([ "drop": ({ 1, "drops" }),              "teaspoon": ({ 20, "teaspoons" }),              "tablespoon": ({ 60, "tablespoons" }),              "ounce": ({ 120, "ounces" }),              "cup": ({ 960, "cups" }),              "pint": ({ 2400, "pints" }),                          "quart": ({ 4800, "quarts" }),                          "gallon": ({ 19200, "gallons" }) ])  );
  call_other( clone, "add_adjective",  ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",                "tablespoons", "ounce", "ounces", "cup", "cups", "pint",                "pints", "quart", "quarts", "gallon", "gallons", "of" })  );
  call_other( clone, "set_pile_types",  ({ 50, "small", 100, "medium", "large" })  );
  call_other( clone, "set_continuous",   );
  call_other( clone, "set_liquid",   );
  call_other( clone, "add_property",  "determinate", "" );
   return clone;
}

==================================================
FILE: b_day/card.c
==================================================

#define DEMON "/obj/b_day/demon"
#include <player_handler.h>
inherit "/std/object";
int creator_status, is_open = 0;
int opened_before = 0;
string owner_name, owner_language;
string* colour_array = ({
  "%^RED%^", "%^BOLD%^%^RED%^",
  "%^MAGENTA%^", "%^BOLD%^%^MAGENTA%^",
  "%^ORANGE%^", "%^YELLOW%^",
  "%^GREEN%^", "%^BOLD%^%^GREEN%^",
  "%^WHITE%^", "%^BOLD%^%^WHITE%^",
  "%^CYAN%^", "%^BOLD%^%^CYAN%^"
  });
void setup_card(string name, string language, int status);
mapping init_query_static_auto_load() {
  return ([ "::" : ::int_query_static_auto_load(),
          "owner_name":owner_name,
          "owner_language":owner_language,
          "is_open":is_open,
          "opened_before":opened_before]);
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] ) {
    ::init_static_arg( map[ "::" ] );
  }
  if ( !undefinedp( map[ "owner_name" ] ) ) {
    owner_name = map[ "owner_name" ];
  }
  if ( !undefinedp( map[ "owner_language" ] ) ) {
    owner_language = map[ "owner_language" ];
  }
  if ( !undefinedp( map[ "is_open" ] ) ) {
    is_open = map[ "is_open" ];
  }
  if ( !undefinedp( map[ "opened_before" ] ) ) {
    opened_before = map[ "opened_before" ];
  }
}
mapping query_static_auto_load()
{
  if ( explode( file_name( this_object() ), "#" )[ 0 ] ==
       "/obj/b_day/card" ) {
    return init_query_static_auto_load();
  }
  return 0;
}
mixed *query_read_mess()
{
  if(!is_open) {
    return ({ ({ "The card is addressed to " + owner_name +
                   ".  Maybe you should open it?  Then again, if "
                   "you're not " + owner_name + ", maybe you "
                   "shouldn't.\n",
                   0, owner_language, 1 }) });
  }
  return ::query_read_mess();
}
void set_closed_mesg()
{
    set_long("The closed card has been carefully handmade from pink "
        "cardboard. There is a rather vague illustration of a "
        "non-identifiable piece of flora on the front.\n");
}
void set_open_mesg()
{
    set_long("The open card has been carefully handmade from pink "
        "cardboard.\n");
}
void setup_card(string own_name, string own_language, int cre_status)
{
  string *wizards, list;
  int i;
  owner_name = own_name;
  owner_language = own_language;
  creator_status = cre_status;
  set_short(owner_name + "'s birthday card");
  add_adjective( ({ owner_name, owner_name + "'s"}) );
  wizards = get_dir("/w/");
  if(creator_status) {
    int start = member_array(lower_case(owner_name), wizards);
    wizards = wizards[0..start-1] + wizards[start+1..];
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
      "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += colour_array[random(sizeof(colour_array))] +
          capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += "%^RESET%^.\n\n";
        else if(i == sizeof(wizards)-2) list += "%^RESET%^ and ";
        else list += ",%^RESET%^ ";
      }
    }
    list += "... and thanks for all your work and time, and let's hope "
      "next year will be even more magical and fun, fun, fun!\n";
  } else {
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
        "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += ".\n";
        else if(i == sizeof(wizards)-2) list += " and ";
        else list += ", ";
      }
    }
  }
  add_read_mess(list, "various hands", owner_language, 1);
}
void setup()
{
  set_name("card");
  set_short("birthday card");
  add_adjective("birthday");
  set_main_plural("birthday cards");
  add_property("determinate", "");
  add_property("no recycling", 1);
  set_closed_mesg();
  if(owner_name && owner_language) {
    setup_card(owner_name, owner_language, creator_status);
  }
}
void init()
{
    this_player()->add_command("open", this_object());
    this_player()->add_command("close", this_object());
}
int do_open()
{
    object demon;
    if(is_open) {
        write("It is already open.\n");
        return 1;
    }
    if(lower_case(owner_name) != this_player()->query_name()) {
      add_succeeded_mess( ({
        "*** POP ***\n"
          "An Origami Demon peers out from the card, sees you're not "
          + owner_name + ", mutters about that not being very "
          "low-temperature, and vanishes back into the card.\n",
        "*** POP ***\n"
          "An Origami Demon peers out from " + owner_name + "'s "
          "birthday card at " + this_player()->query_cap_name() +
          ", smirks and crawls back into the card.\n"
      }) );
      return 1;
    }
    is_open = 1;
    set_open_mesg();
    if(opened_before) return 1;
    opened_before = 1;
    demon = clone_object(DEMON);
    demon->move(environment(this_player()));
    demon->set_owner(owner_name);
    demon->add_language(owner_language);
    demon->set_language(owner_language);
    add_succeeded_mess( ({
      "*** POP ***\n"
        "An Origami Demon explodes from your card as you open it!\n",
      "*** POP ***\n"
        "An Origami Demon explodes from " + owner_name + "'s birthday "
        "card as " + owner_name +" opens it!\n"
    }) );
    call_out("start_demon", 2, demon);
    return 1;
}
void start_demon(object thing) {
  thing->do_the_act(0);
}
int do_close()
{
    if(!is_open) {
        write("It is not open for you to close!\n");
        return 1;
    }
    is_open = 0;
    set_closed_mesg();
    return 1;
}
mixed *stats()
{
  return ::stats() + ({ ({ "owner name",owner_name }),
                          ({ "owner language",owner_language }), });
}

==================================================
FILE: b_day/demon.c
==================================================

#define SONG "/obj/b_day/happy"
inherit "/obj/monster";
int line;
object owner;
string owner_name;
string* act_lines = ({
  ":takes a deep breath...",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday, dear $N\"",
  ":pauses for breath...",
  "sing \"Happy Birthday to yoooou.\"",
  "sing \"The End!\"",
  "hug $n in a way that only a tiny paper "
    "demon could",
  ":waves a minute pointed hand.",
  ":frowns, then folds itself into nothingness..."
});
void setup()
{
  set_name("demon");
  set_short("origami demon");
  add_adjective("tiny");
  add_adjective("pink");
  add_adjective("paper");
  add_adjective("origami");
  set_main_plural("origami demons");
  add_plural("demons");
  set_long("This is a tiny, pink, paper demon. Looking closely you see "
           "that it has been made by someone with a black belt in "
           "Origami!\n");
  set_race("demon");
  set_level(1);
  line = 1;
}
void set_owner(string person_name)
{
  owner = find_living(lower_case(person_name));
  owner_name = person_name;
}
void do_the_act(int i)
{
  string line_to_act;
  if(i >= sizeof(act_lines)) {
    dest_me();
    return;
  }
  if(environment(owner) != environment()) {
    tell_room(environment(), "The origami demon rustles after "
              + owner_name + ".\n");
    move(environment(owner));
    tell_room(environment(), "The origami demon rustles in.\n" );
    do_command("'Hey "+owner_name+"! I hadn't finished!\n");
    return;
  }
  line_to_act = act_lines[i];
  line_to_act = replace(line_to_act, ({"$N", owner_name,
                                       "$n", lower_case(owner_name) }));
  if(!strlen(line_to_act)) {
    set_heart_beat(0);
    dest_me();
    return;
  }
  do_command(line_to_act);
  i++;
  if(owner) {
    call_out("do_the_act", 2, i);
  }
  return;
}
void attack_by( object thing ){
  if( !thing) return;
  if( environment( thing ) != environment() ) return;
  this_object()->stop_fight (thing);
  thing->stop_fight (this_object());
  init_command("say Meanie!  Shame on you!  I shall finish what I "
               "started and then I shall be off.  You don't really "
               "deserve this, you know.", 1);
  return;
}

==================================================
FILE: examples/exa1.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("first simple room");
  set_long("This is a simple room, have fun with it. To read the code " +
           "simply type 'more here'. For help with more, type 'h' in it.\n");
  set_light(90);
  add_exit("east", ROOM + "exa2", "door");
  set_zone("examples");
}

==================================================
FILE: examples/exa2.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("second simple room");
  set_long("This is the second example room. It introduces items, and " +
           "aliasing - again use 'more here' to look at it. Over by the " +
           "north wall you can see a table.\n");
  set_light(90);
 add_item("table",
          "The table is one step away from being firewood. Upon it rests " +
          "a blotter.\n");
 add_item( ({ "north wall", "wall" }),
          "It is very flat and is holding up rather a ricketty table.\n");
 add_item("blotter",
          "It is covered in random ink blots.\n");
  add_exit("west", ROOM + "exa1", "door");
  add_exit("east", ROOM + "exa3", "door");
  set_zone("examples");
}

==================================================
FILE: examples/exa3.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("third simple room");
  set_long("This is the third example room. Will you ever get to the end? " +
           "Directly above your head is a plaque, nailed to the wall.\n");
  set_light(90);
  add_sign("The plaque is made of bronze.\n",
           "'Don't read me, I'm only an example sign you know!'\n",
           0,
           "plaque");
  add_exit("west", ROOM + "exa2", "door");
  add_exit("east", ROOM + "exa4", "door");
  set_zone("examples");
}
void reset()
{
  object bar;
  if(sizeof(match_objects_for_existence("copper bar", ({ this_object() }) )))
    return;
  bar = clone_object("/std/object");
  bar->set_name("bar");
  bar->add_adjective("copper");
  bar->set_main_plural("copper bars");
  bar->add_plural("bars");
  bar->set_short("copper bar");
  bar->set_long("This is just a treasure thingie to show you how to use " +
                  "such fun things.\n");
  bar->set_weight(80);
  bar->set_value(2000);
  bar->move(this_object());
}

==================================================
FILE: examples/path.h
==================================================

#define ROOM "/obj/examples/"

==================================================
FILE: examples/response_mon.c
==================================================

inherit "/w/pinkfish/tmp/response_mon";
object weapc;
string *tale;
void setup() {
    set_name("guard");
    add_adjective(({ "big", "gate" }));
    set_short("Big gate guard");
    set_long("This is one of the common guards of Amber.  "+
     "He looks quite big, maybe you shouldn't upset him...\n");
    set_race("human");
    set_class("fighter");
    set_level(45);
    set_al(250);
    set_gender(1);
    tale = ({ "There once was a frog with 5 legs.\n",
              "This frog was very very unhappy.\n",
              "All other frogs made fun of him.\n",
              "And no lady frog wanted to marry him.\n",
              "One day, a womble appeared, and bit one of his legs off.\n",
              "Since then the frog had 4 legs, and lived happily ever after.\n"
            });
    set_respond_to_with(([ ({ "help", "me" }) : "'I can't help you." ,
                         ({ ({ "hi","hello","greetings" }) }) :
                                      ({ "'Hello $hcname$.",
                                         "emote salutes you." }),
                            ({ ({ "remove","unwield","unhold" }),
                               ({ "axe","weapon" }) }) :
                                       "#remov",
                            ({ ({ "wield","hold" }),
                               ({ "axe","weapon" }) }) :
                                       "#wiel",
                            ({ "tell" , "story" }) :
                                      "#story" ]));
  weapc = clone_object("/obj/weapons/axe.wep");
  weapc->move(this_object());
  do_equip();
}
int remov() {
  init_command("unhold axe");
}
int wiel() {
 init_command("hold axe");
}
void story(object tpl) {
  command("'Very well, "+tpl->query_cap_name()+ " I will tell you a story.\n");
  set_stop_responding(1);
  call_out("tell_story",2,0);
}
void tell_story(int arg) {
  remove_call_out("tell_story");
  if (arg == sizeof(tale)) {
    set_stop_responding(0);
    return ;
  }
  command("'"+tale[arg]);
  call_out("tell_story",2,arg+1);
}

==================================================
FILE: scabbards/.belt_loop.sca_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/belt_loop.sca#1" );
  call_other( clone, "set_name", "loop"  );
  call_other( clone, "add_adjective", ({ "belt", "belt loop" })  );
  call_other( clone, "add_alias", "belt loop"  );
  call_other( clone, "set_short", "belt loop"  );
  call_other( clone, "set_long", "This loop is made from the finest leather, designed to "         "hold axes or hammers safely.\n"  );
  call_other( clone, "set_weight", 8  );
  call_other( clone, "set_value", 800  );
  call_other( clone, "set_type", "belt scabbard"  );
  call_other( clone, "add_property", "no recycling", 1  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "axe","hammer" }) );
   return clone;
}

==================================================
FILE: scabbards/.dagger_scabbard.sca_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/dagger_scabbard.sca#1" );
  call_other( clone, "set_name", "scabbard"  );
  call_other( clone, "add_adjective", "dagger"  );
  call_other( clone, "set_short", "dagger scabbard"  );
  call_other( clone, "set_long", "Similar in design to the scabbard made for longer bladed weapons."         "  In fact you could say they were the same, except for the size.\n"  );
  call_other( clone, "set_weight", 3  );
  call_other( clone, "set_value", 30  );
  call_other( clone, "set_type", "small scabbard"  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "dagger", "knife" }) );
   return clone;
}

==================================================
FILE: media/sand.c
==================================================

inherit "/obj/cont_medium";
void setup()
{
  set_name("sand");
  set_short("sand");
  set_main_plural( "sand" );
  add_adjective( ({ "some", "grain", "pinch", "measure", "handful",
    "hatful", "beach", "of" }) );
  set_long("This is some lovely soft sand, the type that you'd find on "
    "a beach.\n");
  add_property("determinate", "some ");
  set_weight_unit( ({ 1, 1000 }) );
  set_value_scale( 0.00001 );
  set_medium_alias("BeachAndDesertSand");
  set_pile_name("pile");
  set_continuous();
  set_amount_types( ([
    "grain": ({ 1, "grains" }),
    "pinch": ({ 40, "pinches" }),
    "measure": ({ 200, "measures" }),
    "handful": ({ 10000, "handfuls" }),
    "hatful": ({ 50000, "hatfuls" }),
    "beach": ({ 1000000, "beaches" }),
    ]) );
  set_pile_types( ({
    40, "tiny",
    10000, "small",
    50000, "medium",
    200000, "large",
    "huge"
    }) );
  set_amount(12000);
}

==================================================
FILE: handlers/applications_handler.c
==================================================

#include <board.h>
#include <mail.h>
#include <player.h>
#include <playerinfo.h>
#include <player_handler.h>
#include <applications.h>
#include <library.h>
int find_application (string, string);
int find_type (string);
void mail_message(int, int);
string post_application (int);
int complete_application (int);
nosave class application_type *types = ({ });
class application *applications = ({ });
mapping domain_lockout = ([
     "liaison"      : 0,
     "am"           : 0,
     "ram"          : 0,
     "sur"          : 0,
     "klatch"       : 0,
     "forn"         : 0,
     "cwc"          : 0,
     "playtesters"  : 0
   ]);
void load_me() {
  unguarded ((: restore_object (APPLY_SAVE_FILE) :));
}
void save_me() {
  unguarded ((: save_object (APPLY_SAVE_FILE) :));
}
mapping query_vouches_for_all (string name) {
  mapping tmp = ([ ]);
  for (int i = 0; i < sizeof (applications); i++) {
    if (!undefinedp(applications[i]->vouches[name])) {
      tmp[applications[i]->name + " (" + applications[i]->type + ")"]
        = applications[i]->vouches[name];
    }
  }
  return tmp;
}
varargs void add_application_type (string t, int v, string b, int g, int q, int a,
  int ti, string *qu, string intro, string responsibility) {
  class application_type tmp;
  tmp = new (class application_type, type: t, vouches_required: v, board: b,
    gl_requirement: g, qp_requirement: q, age_requirement: a, questions: qu,
    intro_text: intro, timeout: ti, responsibility: responsibility);
  types += ({ tmp });
}
int toggle_domain_lock (string dom) {
  object ob = load_object ("/d/" + dom + "/master");
  if (ob->query_lord() != this_player()->query_name()) {
    return -1;
  }
  if (domain_lockout[dom]) {
    domain_lockout[dom] = 0;
  }
  else {
    domain_lockout[dom] = 1;
  }
  save_me();
}
int query_applications_accepted(string dom) {
  return (undefinedp (domain_lockout[dom]) ? -1 : domain_lockout[dom]);
}
string query_responsibility (string type) {
  int i;
  object ob;
  string dom;
  i = find_type (type);
  if (i == -1) {
    dom = type;
    type = "creator";
    i = find_type (type);
  }
  else {
    dom = type;
  }
  if (undefinedp (types[i]->responsibility)) {
    ob = load_object ("/d/" + dom + "/master");
    if (!ob) {
      tell_creator ("drakkos", "%s.\n", dom, type);
      return 0;
    }
    return ob->query_lord();
  }
  else {
    ob = load_object ("/d/" + types[i]->responsibility+ "/master");
    if (!ob) {
      return "No-one";
    }
    return ob->query_lord();
  }
}
mapping query_domain_status() {
  return copy (domain_lockout);
}
int add_application (string t, string n, string te, string dom) {
  class application tmp;
  int i;
  i = find_application (n, t);
  if (i != -1) {
    return 0;
  }
  tmp = new (class application, type: t, name: n, text: te, time: time(),
    domain: dom, vouches: ([ ]));
  applications += ({ tmp });
  i = find_application (n, t);
  complete_application (i);
  save_me();
  return 1;
}
void create() {
  seteuid (geteuid());
  load_me();
  add_application_type ("creator", 2, "applications", 150, 0,  5 * DAY, 14 * DAY,
    ({
      "Why do you want to be a Creator on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if "
        "so what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?",
      "What is your programming experience? Can you code in C or, more "
        "specifically, the variant of C known as LPC which the mud uses?",
      "What are you interested in creating on "
        "" + mud_name() + "?  Do you have any particular ideas or projects on "
        "which you would like to eventually work?",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to recommend "
        "you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
        "To the best of your knowledge, is the information you have "
        "submitted in this application complete and correct?"
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
  add_application_type ("liaison", 2, "applications", 150, 0,  5 * DAY, 14 * DAY,
   ({
      "Why do you want to be a Liaison on " + mud_name() + "?",
      "What experience do you already have from " + mud_name() + " which is relevant "
        "to this position?",
      "What experience do you have from the Roundworld (real life) which is "
        "relevant to this position?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?  Also, please specify the approximate times that you "
        "usually log on and off (in Seattle time).",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to "
        "recommend you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?",
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
  add_application_type ("playtester", 3, "playtesters", 150, 0,  15 * DAY,
    14 * DAY,
    ({
      "Why do you want to be a playtester on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "What qualities do you feel you can bring to the role?",
      "Do you have any experience in a similar position in real life or "
        "on another MUD?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?",
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n",
      "playtesters");
}
int find_application (string name, string type) {
  for (int i = 0; i < sizeof (applications); i++) {
    if (applications[i]->name == name && applications[i]->type == type) {
      return i;
    }
  }
  return -1;
}
int find_type(string type) {
  for (int i = 0; i < sizeof (types); i++) {
    if (types[i]->type == type) {
      return i;
    }
  }
  return -1;
}
void reset() {
  int j;
  class application *tmp = ({ });
  for (int i = 0; i < sizeof (applications); i++) {
    j = find_type (applications[i]->type);
    if (applications[i]->time + types[j]->timeout < time()) {
      tmp += ({ applications[i] });
      mail_message (0, i);
    }
  }
  if (sizeof (tmp)) {
    applications -= tmp;
    save_me();
  }
}
int delete_vouch (string who, string name, string position) {
  int i = find_application (name, position);
  if (i == -1) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[who])) {
    return 0;
  }
  map_delete (applications[i]->vouches, who);
  save_me();
  return 1;
}
int delete_application (string t, string n) {
  int i = find_application (n, t);
  if (i == -1) {
    return 0;
  }
  applications -= ({ applications[i] });
  save_me();
  return 1;
}
private int complete_application (int i) {
  int vouches = sizeof (keys (applications[i]->vouches));
  int j;
  j = find_type (applications[i]->type);
  if (vouches >= types[j]->vouches_required) {
    post_application (i);
    delete_application (applications[i]->type, applications[i]->name);
    save_me();
    return 1;
  }
  return 0;
}
int number_of_vouches (string name, string type) {
  int i = find_application (name, type);
  if (i == -1) {
    return 0;
  }
  return sizeof (keys (applications[i]->vouches));
}
string query_vouch (string t, string p, string n) {
  int i = find_application (p, t);
  if (i == -1) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[n])) {
    return "You have no vouch for this player in this position.\n";
  }
  return applications[i]->vouches[n];
}
int make_vouch (string t, string p, string n, string v) {
  int i = find_application (p, t);
  int newv = 1;
  if (i == -1) {
    return -1;
  }
  if (n == applications[i]->name) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[n])) {
    newv = 2;
  }
  applications[i]->vouches[n] = v;
  complete_application (i);
  save_me();
  return newv;
}
string* query_questions (string type) {
  int i = find_type (type);
  return types[i]->questions;
}
string query_intro_text (string type) {
  int i = find_type (type);
  return types[i]->intro_text;
}
int valid_application (string name, string type) {
  int i = find_type (type);
  object ob = find_player (name);
  if (ob->query_level() < types[i]->gl_requirement) {
    return 0;
  }
  if (-1 * ob->query_time_on() >= types[i]->age_requirement) {
    return 0;
  }
  if (LIBRARY->query_quest_points (name) < types[i]->qp_requirement) {
    return 0;
  }
  return 1;
}
string application_requirements (string type) {
  int i = find_type (type);
  string ret = "";
  if (i == -1) {
    return "Applications of that category are not handled by this "
      "system.";
  }
  ret += "Applications for a " + types[i]->type + " position have the "
    "following requirements:\n\n";
  ret += "You need to be at least " +
      query_time_string (types[i]->age_requirement) + " old.\n";
  ret += "You need to be at least guild level " + types[i]->gl_requirement + ".\n";
  ret += "You need to have at least " + types[i]->qp_requirement + " quest points.\n";
  ret += "You need to have " + types[i]->vouches_required + " vouches.\n";
  ret += "You have " + query_time_string (types[i]->timeout) + " to obtain your "
    "vouches.\n\n";
  ret += "Your application will not be posted for consideration until you have "
    "all your vouches completed.\n";
  return ret;
}
mapping query_application_vouches (string type, string name) {
  int i = find_application (type, name);
  if (i == -1) {
    return 0;
  }
  else {
    return applications[i]->vouches;
  }
}
string format_application (int i) {
  string post;
  post = "%^BOLD%^Application:%^RESET%^\n"
         "=-=-=-=-=-=-\n\n" +
         "Age: " + query_time_string(-1 * PLAYER_HANDLER->test_age
         (applications[i]->name)) + "\n" +
         "Application made: " + ctime (applications[i]->time) + "\n\n"
         + applications[i]->text + "\n\n";
  post += "\n\n%^BOLD%^Vouches:%^RESET%^\n"
          "=-=-=-=-\n";
  foreach (string v, string t in applications[i]->vouches) {
    post += "\n\n%^CYAN%^" + capitalize (v) + " (" + query_time_string (-1 *
      PLAYER_HANDLER->test_age (v)) + "):%^RESET%^\n\n" + t;
  }
  return post;
}
private string post_application (int i) {
  string post = "";
  int j = find_type (applications[i]->type);
  class reply_type rep;
  object ob, player;
  string response;
  post = format_application (i);
  rep= new(class reply_type);
  rep->type = B_REPLY_NAMED;
  rep->data = query_responsibility((applications[i]->domain ? applications[i]->domain :
    applications[i]->type));
  ob = load_object ("/d/" + (applications[i]->domain ?
    applications[i]->domain : types[j]->responsibility) + "/master");
  BOARD_HAND->add_message( types[j]->board, capitalize( applications[i]->name),
    capitalize( applications[i]->name ) + "'s " + (applications[i]->type == "creator" ?
       applications[i]->domain + " domain" : capitalize (applications[i]->type)) +
       " application", post, 0, rep );
  AUTO_MAILER->auto_mail( query_responsibility((applications[i]->domain ?
    applications[i]->domain : applications[i]->type)),
    applications[i]->name,
    "Application to " + capitalize( applications[i]->domain),
    "", post, 0, 0 );
  player = find_player (applications[i]->name);
  if (ob) {
    if (function_exists ("creator_application_callback", ob)) {
        response = call_other (ob, "creator_application_callback",
        applications[i]->name, post);
     }
    if (sizeof (response)) {
      tell_object (player, response);
    }
  }
  if (applications[i]->type == "creator" ||  applications[i]->type ==
    "liaison") {
    PLAYERINFO_HANDLER->add_entry( this_object(),
      applications[i]->name, "misc", "Applied to "
        + applications[i]->domain + " domain." );
  }
  else {
    PLAYERINFO_HANDLER->add_entry( player,
      player->query_name(), "misc", "Applied as a "
        + applications[i]->type+ "." );
  }
  mail_message (1, i);
  save_me();
  return post;
}
private void mail_message(int i, int j) {
  string ret = "";
  string mail;
  mail = "Greetings... this is an automated message from the "
    "" + mud_name() + " applications handler.\n\n$message$\n\n";
  switch (i) {
    case 0:
      ret = "You have not received the required number of vouches for "
        "your application for a " + applications[j]->type + " position "
        "within the specified time-frame.  Your application has been "
        "expired and if you wish to pursue further employment on the MUD "
        "you will need to resubmit an application.\n";
    break;
    case 1:
      ret = "You have received the required number of vouches for your "
        "application for a " + applications[j]->type + " position on the "
        "MUD.  Your application has been posted for consideration.  Thank "
        "you for your interest in pursuing employment within the MUD.\n";
    break;
  }
  mail = replace (mail, ({"$message$", ret}));
  AUTO_MAILER->auto_mail( applications[j]->name, "Applications Procedure",
    "Your " + applications[j]->type + " application", "",
    mail, 0, 0, 1 );
}
string list_applications() {
  string *ret = ({ });
  ret += ({"\n"});
  ret += ({"\n\n/---------------------------------------------------------------------------\\"});
  ret += ({sprintf ("| %|12s | %|12s | %|24s | %|2s  | %|10s |",
  "Type", "Name", "Made At", "V", "Domain") });
  ret += ({"|---------------------------------------------------------------------------|"});
  for (int i = 0; i < sizeof (applications); i++) {
    ret += ({sprintf ("| %|12s | %|12s | %|s | %|2d  | %|10s |",
    capitalize (applications[i]->type),
      capitalize (applications[i]->name), ctime (applications[i]->time),
        sizeof (applications[i]->vouches),
        capitalize ((applications[i]->type == "creator" ? applications[i]->domain :
        ""))) });
  }
  ret += ({"\\---------------------------------------------------------------------------/"});
  return implode (ret, "\n");
}
string *query_types() {
  return map (types, (: $1->type :));
}
int fix_name (string n, string n2) {
  int i;
  int c = 0;
  for (int j =0; j < sizeof (types); j++) {
    i = find_application (n, types[j]->type);
    if (i != -1) {
      applications[i]->name = n2;
      c++;
    }
  }
  return c;
}
string query_name() {
  return "Applications Handler";
}

==================================================
FILE: handlers/armoury.c
==================================================

#include <move_failures.h>
#include <armoury.h>
#define MAX_RECYCLE 6
inherit "/std/room/basic_room";
#define DEFAULT_RECYCLE_AREA "default"
#define SAVE "/save/armoury"
#define TYPES ({"armours", "clothes", "weapons", "plants", "foods", "scabbards", "jewelleries", "misc" })
private nosave int _total_requests;
private mapping _smalls;
private mapping _armour_list;
private mapping _weapon_list;
private mapping _clothing_list;
private mapping _jewellery_list;
private mapping _scabbard_list;
private mapping _food_list;
private mapping _misc_list;
private mapping _plant_list;
private mapping _areas;
private mapping forbidden;
private void rehash_all();
int rehash(string place);
string* walk_directory (string);
void save_me() {
   unguarded( (: save_object(SAVE, 3) :));
}
void load_me() {
   unguarded( (: restore_object(SAVE, 1) :));
}
void setup() {
   set_short( "" + mud_name() + " Armoury" );
   add_property( "determinate", "the " );
   set_light( 50 );
   set_long( "You are in the " + mud_name() + " Armoury.  From here you can list "
         "all of the \"weapons\", \"armour\", \"clothing\", \"jewellery\", "
         "\"food\", \"plants\", \"misc\" "
         "and \"scabbards\" that are available, and \"request\" one of "
         "them.  The armoury stores its list of items in mappings, which "
         "can be updated with \"rehash\".  The list of forbidden items "
         "can be listed out or added to with \"forbid\".\n" );
   _smalls = ([ ]);
   _areas = ([ ]);
   _armour_list = _weapon_list = _clothing_list = _plant_list = _misc_list =
      _jewellery_list = _scabbard_list = _food_list = ([ ]);
   load_me();
   rehash_all();
}
object *query_smalls(string area) {
   if (!area) {
      area = DEFAULT_RECYCLE_AREA;
   }
   return _smalls[area];
}
mapping query_area(string domain) {
  if (_areas[domain]) {
      return _areas[domain];
  }
  return ([ ]);
}
int request(string, int, string);
int forbid(string);
void init() {
   string comm;
   ::init();
   add_command("rehash", "{foods|clothes|weapons|armours|misc|jewelleries|"
                         "scabbards|plants}",
                (:rehash($4[0]) :));
   add_command("rehash", "domain <string'domain'>",
                (:rehash($4[0]) :));
   add_command("request", "<string'item name'> <number'percent'>",
                (:request($4[0], $4[1], 0):));
   add_command("request", "<string'item name'> <number'percent'> in <string'area'>",
               (:request($4[0], $4[1], $4[2]):));
   add_command("forbid", "", (:forbid, "":));
   add_command("forbid", "<string'name'>", (:forbid($4[0]):));
   foreach(comm in ({"weapons", "armour", "clothing", "jewellery", "plant",
                     "misc", "scabbards", "food", })) {
      add_command(comm, "", (:call_other(this_object(), $(comm)):));
   }
}
mapping make_list(string base_dir, string *extensions) {
  string *dirs, dir, extension, file_name;
  mapping list;
  dirs = walk_directory (base_dir);
  list = ([ ]);
  foreach(dir in dirs) {
    foreach(extension in extensions) {
      foreach(file_name in unguarded((: get_dir, dir+"*"+extension :))) {
        if (file_name[0] != '.') {
          list[ replace_string(explode(file_name, ".")[0], "_", " ") ] =
                    dir + "" + file_name;
        }
      }
    }
  }
  return list;
}
int clean_up(int i) { return 0; }
object choose_small_item(string area) {
  object ob;
  if(!area)
    area = DEFAULT_RECYCLE_AREA;
  if(!_smalls || !_smalls[area] || !arrayp(_smalls[area]) || !_smalls[area][0])
    return 0;
  ob = clone_object(_smalls[area][0]);
  _smalls[area] = _smalls[area][1..];
  return ob;
}
object request_item(string word, int percent, string area) {
  int add_area;
  object thing;
  string filename;
  if(!word) {
    return 0;
  }
  if (!area) {
    area = DEFAULT_RECYCLE_AREA;
  }
  if (_areas[area] &&
      _areas[area][word]) {
    filename = _areas[area][word];
    add_area = 1;
  } else if(_weapon_list[word]) {
    filename = _weapon_list[word];
  } else if(_armour_list[word]) {
    filename = _armour_list[word];
  } else if(_clothing_list[word]) {
    filename = _clothing_list[word];
  } else if(_jewellery_list[word]) {
    filename = _jewellery_list[word];
  } else if(_scabbard_list[word]) {
    filename = _scabbard_list[word];
  } else if(_misc_list[word]) {
    filename = _misc_list[word];
  } else if(_plant_list[word]) {
    filename = _plant_list[word];
  } else if(_food_list[word]) {
    filename = _food_list[word];
  } else {
    if(base_name(previous_object()) != "/cmds/creator/req_uest") {
      printf( "No file for item \"%s\".\n", word );
      log_file( "ARMOURY", "%s No file for %s (%s)\n", ctime(time())[4..9],
                word, file_name( previous_object() ) );
    }
    return 0;
  }
  if(file_size( filename ) > 0)
    thing = clone_object(filename);
  if(!thing) {
    printf( "Cannot find item \"%s\".\n", word );
    log_file( "ARMOURY", "Cannot find %s (%s)\n", word,
              file_name( previous_object() ) );
    return 0;
  }
  _total_requests++;
  if(!_smalls[area])
    _smalls[area] = ({ });
  if(sizeof(_smalls[area]) < 20 &&
     thing->query_weight() < roll_MdN(5, 20) &&
     thing->query_value() < random(4000) &&
     !thing->query_liquid() &&
     !sizeof((mapping)thing->query_value_info()) &&
     strsrch(filename, "_pt") == -1 &&
     strsrch(filename, "_dev") == -1 &&
     !thing->query_property("no recycling")) {
    _smalls[area] += ({ filename });
  }
  if (add_area)
    thing->add_property(ARMOURY_RECYCLING_AREA_PROP, area);
  thing->set_percentage( percent );
  return thing;
}
string remap_file_path(string path) {
   string* bits;
   mapping list;
   string new_fname;
   bits = explode(path, "/");
   if (bits[0] != "obj") {
      return path;
   }
   switch (bits[1]) {
   case "armours" :
      list = _armour_list;
      break;
   case "weapons" :
      list = _weapon_list;
      break;
   case "clothes" :
      list = _clothing_list;
      break;
   case "jewellery" :
      list = _jewellery_list;
      break;
   case "scabbards" :
      list = _scabbard_list;
      break;
   case "food" :
      list = _food_list;
      break;
   case "misc" :
      list = _misc_list;
      break;
   case "plants" :
      list = _plant_list;
      break;
   }
   if (list) {
      new_fname = list[replace_string(explode(bits[<1], ".")[0], "_", " ")];
      if (new_fname) {
         return new_fname;
      }
   }
   return path;
}
int rehash(string thing) {
  string special;
  int found;
  switch (thing) {
  case "armours" :
     _armour_list=make_list("/obj/armours/", ({".arm", ".c"}));
     break;
  case "clothes" :
     _clothing_list=make_list("/obj/clothes/", ({".clo", ".c"}));
     break;
  case "weapons" :
     _weapon_list = make_list("/obj/weapons/", ({".wep", ".c"}));
     break;
  case "scabbards" :
     _scabbard_list = make_list( "/obj/scabbards/", ({ ".sca", ".c" }));
     break;
  case "jewellery" :
  case "jewelleries" :
     _jewellery_list = make_list( "/obj/jewellery/", ({ ".arm", ".clo", ".c" }));
     break;
  case "food" :
  case "foods" :
     _food_list = make_list( "/obj/food/", ({ ".ob", ".food", ".c" }));
     break;
  case "misc" :
     _misc_list = make_list( "/obj/misc/", ({ ".ob", ".c" }));
     break;
  case "plants" :
     _plant_list = make_list( "/obj/plants/", ({ ".ob", ".food", ".c" }));
     break;
  default :
    if (file_size("/d/" + thing + "/items") == -2) {
      _areas[thing] = make_list( "/d/" + thing + "/items/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca",
                                     ".ob", ".food" }));
      found = 1;
    }
    if (file_size("/d/" + thing + "/armoury") == -2) {
      foreach (special in get_dir("/d/" + thing + "/armoury")) {
         if (file_size("/d/" + thing + "/armoury/" + special + "/") == -2) {
           _areas[special] = make_list( "/d/" + thing + "/armoury/" + special + "/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca" }));
         }
      }
       return 0;
    }
  }
  save_me();
  write("Rehash of " + thing + " complete.\n");
  return 1;
}
int rehash_specific_dir(string dir) {
   return rehash(explode(dir, "/")[1]);
}
private void rehash_all() {
  string thing;
  int i;
  foreach(thing in TYPES + "/secure/master"->query_domains()) {
    i += 5;
    call_out("rehash", i, thing);
  }
}
string *query_types() { return TYPES + keys(_areas); }
mapping query_items(string type, string filter) {
  mapping items;
  string item;
  switch(type) {
  case "armours":
    items = _armour_list;
    break;
  case "weapons":
    items = _weapon_list;
    break;
  case "clothes":
    items = _clothing_list;
    break;
  case "jewellery":
  case "jewelleries":
    items = _jewellery_list;
    break;
  case "scabbards":
    items = _scabbard_list;
    break;
  case "food":
  case "foods":
    items = _food_list;
    break;
  case "misc":
    items = _misc_list;
    break;
  case "plants":
    items = _plant_list;
    break;
  default:
    if(member_array(type, "/secure/master"->query_domains()) != -1 &&
       _areas[type])
      items = _areas[type];
    else
      return 0;
  }
  items = copy (items);
  if (sizeof (filter)) {
    foreach(item in keys(items))
      if(strsrch(item, filter) == -1)
        map_delete(items, item);
  }
  return items;
}
int request( string word, int percentage, string area ) {
  object thing;
  thing = request_item( word, percentage, area );
  if ( !thing ) {
    add_failed_mess(word + " not found.\n");
    return 0;
  }
  if ( (int)thing->move( this_player() ) != MOVE_OK ) {
    write( (string)thing->a_short() +" has been placed in here.\n" );
    thing->move( this_object() );
  } else
    write( (string)thing->a_short() +
          " has been placed in your inventory.\n" );
  return 1;
}
mixed stats() {
  string tmp;
  mixed *ret;
  ret = ({ });
  foreach(tmp in keys(_areas)) {
    ret += ({ tmp, sizeof(_areas[tmp]) });
  }
  return ::stats() + ({
    ({ "item requests", _total_requests, }),
      ({ "armours", sizeof(_armour_list) }),
      ({ "clothes", sizeof(_clothing_list) }),
      ({ "weapons", sizeof(_weapon_list) }),
      ({ "scabbards", sizeof(_scabbard_list) }),
      ({ "jewellery", sizeof(_jewellery_list) }),
      ({ "food", sizeof(_food_list) }),
      ({ "misc", sizeof(_misc_list) }),
      ({ "plants", sizeof(_plant_list) }),
      ret });
}
string* walk_directory (string dir) {
  string *tmp, *dirs = ({ }), *tmp2;
  mixed *file;
  tmp = get_dir(dir, -1);
  if (sizeof (tmp))
    dirs += ({dir});
  foreach(file in tmp) {
    if(file[1] == -2) {
      tmp2 = walk_directory (dir + file [0] + "/");
      if (sizeof (tmp2))
        dirs += tmp2;
    }
  }
  return dirs;
}

==================================================
FILE: handlers/artifact_handler.c
==================================================

#define SAVE_FILE "/save/artifacts"
#define SAVE_DIR "/save/artifacts/"
mapping artifacts;
void create() {
   seteuid( (string)"/secure/master"->
         creator_file( file_name( this_object() ) ) );
   artifacts = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
mapping query_artifacts() { return artifacts; }
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
int query_artifact( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return 1;
}
void add_artifact( string name, string file, int max, int min, int bonus,
                   int value ) {
  artifacts[ name ] = ({ file, max, min, bonus, value });
  save_me();
}
void remove_artifact( string name ) {
  if ( !artifacts[ name ] )
    return;
  artifacts = m_delete( artifacts, name );
  save_me();
}
string query_artifact_file( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 0 ];
}
int query_artifact_max( string name ) {
  if ( !artifacts[ name ] )    return 0;
  return artifacts[ name ][ 1 ];
}
int query_artifact_min( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 2 ];
}
int query_artifact_bonus( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 3 ];
}
int query_artifact_value_info( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 4 ];
}
int query_artifact_level( string name, int bonus ) {
  int number;
  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 1 ] - artifacts[ name ][ 2 ];
  number *= number;
  number /= bonus - artifacts[ name ][ 3 ] + artifacts[ name ][ 1 ] -
      artifacts[ name ][ 2 ];
  number += artifacts[ name ][ 2 ];
  return number;
}
int query_artifact_value( string name, int bonus ) {
  int number;
  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 4 ] * artifacts[ name ][ 1 ];
  number /= query_artifact_level( name, bonus );
  return number;
}
void diagnose_artifact( object thing, object person, object) {
   int charges;
   string type;
   if ( !thing || !person )
      return;
   type = (string)thing->query_artifact_type();
   if ( !stringp( type ) ) {
      tell_object( person, "There doesn't seem to be anything special about "+
            (string)thing->the_short() +".\n" );
      return;
   }
   charges = (int)thing->query_charges();
   tell_object( person, (string)thing->the_short() +" is a level "+
         (int)thing->query_level() +" magic "+ type +".  It has "+
         ( charges == 1 ? "one charge" : query_num( charges ) +" charges" ) +
         " remaining.\n" );
}
string query_wand_name() { return "wand of artifact probing"; }
void zap( object thing, object person, object wand ) {
  call_out( "diagnose_artifact", 0, thing, person, wand );
}
int query_known( string person, string artifact ) {
  int i;
  string *list;
  if ( !artifacts[ artifact ] )
    return 0;
  if ( unguarded((: file_length, SAVE_DIR + person :)) < 1 )
    return 0;
  list = explode( unguarded((: read_file, SAVE_DIR + person :)), "\n" );
  for ( i = 0; i < sizeof( list ); i++ ) {
    if ( list[ i ] == artifact )
      return 1;
  }
  return 0;
}
void add_known( string person, string artifact ) {
  if ( query_known( person, artifact ) )
    return;
  unguarded((: write_file, SAVE_DIR + person, artifact +"\n" :));
}

==================================================
FILE: handlers/attack_messages.c
==================================================

mapping weapon_mess;
void create() {
  weapon_mess = ([
    "blunt" : ({
      0, "$N swing$s at $I with $D",
        20, "$N tap$s $I in the $z with $D",
        60, "$N hit$s $I in the $z with $D",
        100, "$N bruise$s $P $z with $D",
        140, "$N hit$s $I hard in the $z with $D",
        180, "$N smash$es $I in the $z with $D",
        220, "$N crush$es $P $z with $D",
        5000, "$N mash$es $P $z with $D",
        }),
    "blunt-tail" : ({
      0, "$N swing$s $p tail at $I",
        20, "$N tap$s $I in the $z with $p tail",
        60, "$N slap$s $I in the $z with $p tail",
        100, "$N bruise$s $P $z with $p tail",
        140, "$N hit$s $I hard in the $z with $p tail",
        180, "$N bash$es $I in the $z with $p tail",
        220, "$N smash$es $p tail into $P $z",
        5000, "$N send$s $I reeling with a powerful blow to the $z with $p tail"
        }),
    "blunt-hoof" : ({
      0, "$N kick$s out at $I",
        20, "$N tap$s $I in the $z with $p hoof",
        60, "$N kick$s $I in the $z with $p hoof",
        100, "$N bruise$s $P $z with $p hoof",
        140, "$N hit$s $I hard in the $z with $p hoof",
        180, "$N smash$es $I in the $z with $p hoof",
        220, "$N crush$es $p hoof into $P $z",
        5000, "$N mash$es $P $z with $p hoof"
        }),
    "blunt-wrestle" : ({
      0, "$N grab$s for $I",
        25, "$N grapple$s with $I",
        50, "$N catch$es $I in an arm lock",
        75, "$N grab$s $I around the neck",
        100, "$N poke$s $I in the face",
        125, "$N throw$s $I to the ground",
        150, "$N fling$s $I over $p shoulder",
        175, "$N punch$es $I in the stomach",
        200, "$N twist$s $P arm painfully",
        225, "$N thump$s $P head hard",
        250, "$N kick$s $I in the back",
        275, "$N jump$s up and down on $I",
        5000, "$N slam$s $P head against the ground"
        }),
    "blunt-hands" : ({
      0, "$N punch$es at $I",
        10, "$N poke$s $I in the $z",
        40,"$N tickle$s $I in the $z",
        70, "$N jab$s $I in the $z",
        100, "$N hit$s $I in the $z with an uppercut",
        130, "$N hit$s $I in the $z with a cross",
        160, "$N hit$s $I in the $z with a vicious hook",
        5000, "$N beat$s $P $z to a pulp",
        }),
    "blunt-feet" : ({
      0, "$N kick$s out at $I",
        10, "$N poke$s $I",
        40, "$N tickle$s $I in the $z with $p toes",
        70, "$N kick$s $I in the $z",
        100, "$N viciously boot$s $I in the $z",
        130, "$N kick$s $I in the $z",
        160, "$N viciously kick$s $I in the $z",
        5000, "$N kick$s $P $z into a bloody mess"
        }),
    "blunt-pommel": ({
      0, "$N strike$s at $I with the pommel of $D",
        20, "$N tap$s $I in the $z with the pommel of $D",
        60, "$N knock$s $P $z with the hilt of $D",
        100, "$N bruise$s $P $z with the pommel of $D",
        140, "$N bash$es $I in the $z with the hilt of $D",
        180, "$N beat$s $I in the $z with the pommel of $D",
        220, "$N smash$es the hilt of $D into $P $z",
        5000, "$N smash$es $I in the $z with the pommel of $D",
        }),
    "blunt-cane" : ({
      0, "$N strike$s at $I with $D",
        20, "$N tap$s $P $z with $D",
        60, "$N knock$s $P $z with $D",
        100, "$N strike$s $I lightly in the $z with $D",
        140, "$N strike$s $I in the $z with $D",
        180, "$N strike$s $I hard in the $z with $D",
        220, "$N batter$s $P $z with $D",
        5000, "$N bludgeon$s $P $z with $D",
        }),
    "blunt-self" : ({
      0, "$N swing$s at $I",
        20, "$N tap$s $I in the $z",
        60, "$N hit$s $I in the $z",
        100, "$N bruise$s $P $z",
        140, "$N hit$s $I hard in the $z",
        180, "$N smash$es $I in the $z",
        220, "$N crush$es $P $z",
        5000, "$N mash$es $P $z",
        }),
    "sharp" : ({
      0, "$N slash$es at $I with $D",
        20, "$N snick$s $P $z with $D",
        60, "$N scratch$es $P $z with $D",
        100, "$N nick$s $P $z with $D",
        140, "$N cut$s $P $z with $D",
        180, "$N slice$s $P $z with $D",
        220, "$N hack$s $P $z with $D",
        5000, "$N chop$s up $P $z with $D"
        }),
    "sharp-claws" : ({
      0, "$N rake$s at $I with $p claws",
        10, "$N snick$s $P $z with $p claws",
        40, "$N scratch$es $P $z with $p claws",
        70, "$N nick$s $P $z with $p claws",
        100, "$N claw$s $P $z",
        130, "$N slice$s $P $z up with $p claws",
        160, "$N hack$s $P $z up with $p claws",
        5000, "$N cut$s $P $z into small pieces with $p claws",
        }),
    "sharp-chew" : ({
      0, "$N bite$s at $I",
        10, "$N chew$s on $P $z",
        40, "$N munch$es on $P $z",
        70, "$N gash$es $P $z with $p teeth",
        100, "$N rip$s flesh off $P $z",
        130, "$N tear$s deeply into $P $z",
        160, "$N rip$s $P $z to pieces with $p teeth",
        5000,  "$N rend$s huge chunks of flesh from $P $z",
        }),
    "sharp-slice": ({
      0, "$N slice$s at $I with $D",
        20, "$N just manage$s to slice $P $z with $D",
        60, "$N slice$s $D across $P $z",
        100, "$N shred$s $P $z with $D",
        140, "$N slice$s $D into $P $z",
        180, "$N take$s a sliver off $P $z with $D",
        220, "$N slice$s $D deeply into $P $z",
        5000, "$N neatly fillet$s $P $z with $D",
        }),
    "sharp-chop": ({
      0, "$N swing$s $D at $I",
        20, "$N attempt$s to chop $P $z with $D",
        60, "$N chop$s at $P $z with $D",
        100, "$N chop$s $P $z with $D",
        140, "$N chop$s $D into $P $z",
        180, "$N hack$s into $P $z with $D",
        220, "$N chop$s $D deeply into $P $z",
        5000, "$N chop$s $P $z into pieces with $D",
        }),
    "pierce": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N pierce$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N skewer$s $P $z with $D",
        220, "$N run$s $I through the $z with $D",
        5000, "$N make$s a kebab of $P $z with $D",
        }),
    "pierce-spike": ({
      0, "$N swing$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N spike$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N ventilate$s $P $z with $D",
        220, "$N perforate$s $P $z with $D",
        5000, "$N make$s a mess of $P $z with $D",
        }),
    "pierce-beak" : ({
      0, "$N pecks at $I with $p beak",
        10, "$N snick$s $P $z",
        40, "$N scratch$es $P $z with $p beak",
        70, "$N peck$s $P $z",
        100, "$N viciously peck$s $P $z",
        130, "$N gouge$s a hole in $P $z with $p beak",
        160, "$N slice$s $P $z with $p beak",
        5000, "$N slice$s $P $z into small bits with $p beak",
        }),
    "pierce-stab": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely stab$s $I in the $z with $D",
        60, "$N stab$s $I in the $z with $D",
        100, "$N messily stab$s $I in the $z with $D",
        140, "$N stab$s $I deeply in the $z with $D",
        180, "$N perforate$s $P $z with $D",
        220, "$N pierce$s $P $z with $D",
        5000, "$N stab$s $D right through $P $z",
        }),
    "pierce-horns": ({
      0, "$N attempt$s to gore $I with $p horns",
        20, "$N prod$s $I in the $z with $p horns",
        60, "$N poke$s $I in the $z with $p horns",
        100, "$N butt$s $I in the $z with $p horns",
        140, "$N pierce$s $I deeply in the $z with $p horns",
        180, "$N ram$s $I in the $z with $p horns",
        220, "$N gore$s $P $z with $p horns",
        5000, "$N impale$s $P $z on $p horns",
        }),
    "pierce-tusks": ({
      0, "$N attempt$s to gore $I with $p tusks",
        20, "$N prod$s $P $z with $p tusks",
        60, "$N poke$s $I in the $z with $p tusks",
        100, "$N jab$s $p tusks into $P $z",
        140, "$N pierce$s $P $z with $p tusks",
        180, "$N stab$s $p tusks deeply into $P $z",
        220, "$N gore$s $P $z with $p tusks",
        5000, "$N impale$s $P $z on $p tusks",
        }),
    "pierce-bite" : ({
      0, "$N attempt$s to bite $I",
        10, "$N nip$s $I in the $z",
        40, "$N nibble$s at $P $z",
        70, "$N bite$s $I in the $z",
        100, "$N sink$s $p teeth into $P $z",
        130, "$N bite$s into $P $z",
        160, "$N sink$s $p teeth deep into $P $z",
        5000, "$N bite$s deeply into $P $z, splintering $P bones",
        }),
    "fire" : ({
      20, "$N smoke$s $I",
        60, "$N toast$s $I",
        100, "$N scorch$es $I",
        140, "$N crisp$s $I",
        180, "$N singe$s $I",
        220, "$N fry$s $I",
        260, "$N roast$s $I",
        300, "$N melt$s $I",
        340, "$N char$s $I",
        380, "$N burn$s $I",
        420, "$N incinerate$s $I",
        460, "$N cremate$s $I",
        5000, "$N vapourise$s $I",
        }),
    ]);
}
string parse_string(string mess, object him, object me, object wep,
                    string zone) {
   return replace( replace( mess, ({
      "$mposs$ $D", (string)wep->poss_short() }) ),
         ({ "$hname$", (string)him->query_name(),
            "$mname$", (string)me->query_name(),
            "$hcname$", (string)him->the_short(),
            "$mcname$", (string)me->the_short(),
            "$hposs$", (string)him->query_possessive(),
            "$mposs$", (string)me->query_possessive(),
            "$hpname$", (string)him->poss_short(),
            "$mpname$", (string)me->poss_short(),
            "$hpron$", (string)him->query_pronoun(),
            "$mpron$", (string)me->query_pronoun(),
            "$hobj$", (string)him->query_objective(),
            "$mobj$", (string)me->query_objective(),
            "$wname$", (string)wep->query_name(),
            "$wcname$", (string)wep->short(0),
            "$zname$", zone})
   );
}
mixed query_message( int dam, string type, object him, object me,
                     string name, object wep, string zone) {
  int j;
  mixed ind;
  string tmp;
  if(!zone) {
    zone = "body";
  } else {
    if(zone[sizeof(zone)]-1 == 's')
      zone = zone[0..<2];
  }
  ind = wep->query_attack_message(name, type);
  if (!ind) {
    if(type == "unarmed") {
      switch(name) {
      case "bite":
      case "beak":
      case "stab":
      case "horns":
      case "tusks":
        type = "pierce";
        break;
      case "claws":
      case "chew":
      case "slice":
      case "chop":
        type = "sharp";
        break;
      default:
        type = "blunt";
      }
    }
    ind = weapon_mess[type+"-"+name];
    if(!ind) {
      ind = weapon_mess[type];
      if (!ind) {
        return 0;
      }
    }
  }
  while (j < sizeof(ind) && dam > ind[j]) {
    j += 2;
  }
  if (j >= sizeof(ind)) {
    j = sizeof(ind)-2;
  }
  ind = ind[j+1];
  if (stringp(ind)) {
    tmp = replace(ind,
                  ({ "$N", (string)me->the_short(),
                       "$p ", (string)me->query_possessive() +" ",
                       "$r", (string)me->query_pronoun(),
                       "$o", (string)me->query_objective(),
                       "$z", zone,
                       "$D", wep->poss_short(),
                       "$I", him->the_short(),
                       "$P", (string)him->the_poss_short(),
                       "$O", (string)him->query_objective(),
                       "$es", "es", "$s", "s" }) );
    ind = ({ replace( ind, ({ "$N", "you", "$p ", "your ",
                                "$r", "you", "$o", "you",
                                "$es", "", "$s", "",
                                "$D", wep->poss_short(),
                                "$z", zone,
                                "$I",  him->the_short(),
                                "$P", him->the_poss_short(),
                                "$O", him->query_objective(),
                                }) ),
               tmp,
               tmp });
    return ind;
  }
  return ({
    parse_string(ind[0], him, me, wep, zone),
      parse_string(ind[1], him, me, wep, zone),
      parse_string(ind[2], him, me, wep, zone)});
}
