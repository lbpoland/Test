# Total Tokens: 24699
# Total Files Merged: 20
# Total Characters: 82386

ceipt.c
==================================================

#include <am_time.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <virtual.h>
#define TO this_object()
#define TP this_player()
inherit "/obj/misc/paper" ;
private int    _expired ;
private int    _expired_sold ;
private int    _expiry_time ;
private int    _item_value, _obplural ;
private int    _timestamp;
private mixed  _static_save;
private string _obname, _obpath, _obshort ;
private string _shop_path, _virt_name ;
object do_kiss();
void setup() {
    set_name( "receipt" );
    set_short( "pawned item receipt" ) ;
    add_adjective( ({ "pawned", "item" }) );
    set_long( "This is a small slip of paper, with a black border.\n" );
    set_main_plural( "pawned item receipts" ) ;
    add_plural( "receipts" );
    add_adjective( "pawned" ) ;
    set_value( 0 ) ;
    set_weight( 1 );
    _obname = "unknown object";
    _obpath = "***";
    _timestamp = time();
}
void init() {
    add_command( "reclaim", "<direct:object:me'receipt'>" ) ;
}
void reset() {
    object item ;
    if ( ( ! _expired ) && time() > _expiry_time ) {
        _expired = 1 ;
        set_short( "expired pawned item receipt" ) ;
        add_adjective( "expired" ) ;
        if ( ! _expired_sold ) {
            _expired_sold = 1 ;
            item = do_kiss() ;
            if ( item ) {
                item->move( _shop_path->query_store_room() ) ;
            }
        }
    }
}
void set_obshort( string s ) {
  _obshort = s;
}
string query_obshort() {
  return _obshort;
}
void set_expiry_time( int time ) {
    _expiry_time = time ;
}
int query_expiry_time() {
    return _expiry_time ;
}
void set_item_value( int value ) {
    _item_value = value ;
}
int query_item_value() {
    return _item_value ;
}
void set_shop_path( mixed shop ) {
    if ( objectp( shop ) ) {
        _shop_path = base_name( shop ) ;
        return ;
    }
    _shop_path = shop ;
    return ;
}
string query_shop_path() {
    return _shop_path ;
}
void set_obname( string name ) {
    _obname = name;
}
void set_object( string path ) {
    _obpath = path;
}
void set_virtobname( string name ) {
    _virt_name = name;
}
string query_obname() {
    return _obname;
}
string query_obpath() {
    return _obpath;
}
int query_timestamp() {
    return _timestamp;
}
string query_virt_obname() {
    return _virt_name;
}
mixed query_static_save() {
  return _static_save;
}
int query_pawned_item_receipt() {
    return 1 ;
}
void set_static_save( mixed args ) {
  mixed p;
  _static_save = args;
  if (_obname != "unknown object") {
    return;
  }
  p = args[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}
void set_object_plural( object ob ) {
  if ( ob->query_collective() && ob->query_amount() > 1 ) {
    _obplural = 1;
  } else {
    _obplural = 0;
  }
}
int query_object_plural() {
  return _obplural;
}
string query_correct_short( object ob ) {
    if ( ! ob ) {
      return 0;
    }
    set_object_plural( ob );
    if ( _obplural ) {
      return pluralize( ob->query_short() );
    }
    return ob->query_short();
}
void setup_receipt( object ob ) {
   mixed* bits;
   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_obshort( query_correct_short( ob ) );
   set_object(bits[1]);
   set_static_save(bits[2]);
}
string pluralize_sentence( string text, int plural ) {
  if ( plural ) {
    return replace( text, ({
      "$o", "them",
      "$r", "they",
      "$ve", "ve"
    }) );
  }
  return replace( text, ({
    "$o", "it",
    "$r", "it",
    "$ve", "s"
  }) );
}
string query_details() {
    if ( _expired ) {
        return pluralize_sentence(
          "This is a receipt for your pawned " + query_obshort() + ".\n"
          "Sadly, you have left it too long to collect $o and $r ha$ve "
          "expired, so the shop will put $o up for sale.  Better hurry to "
          + _shop_path->the_short() + " sharpish and try to buy $o back!",
          _obplural );
    }
    return pluralize_sentence(
      "This is a receipt for your pawned " + query_obshort() + ".\n"
      "You must reclaim $o from " + _shop_path->the_short() + " before "
      + AM_TIME_HANDLER->query_am_time( _expiry_time ) + " or $r will "
      "be sold.", _obplural );
}
mixed *query_read_mess() {
  string lang;
  if ( _shop_path ) {
    lang = _shop_path->query_language();
  } else {
    lang = "general";
  }
  return ::query_read_mess()
    + ({ ({ (: query_details() :), "neat printing", lang, 0 }) });
}
mapping query_dynamic_auto_load()
{
   return ([
     "::"         : ::query_dynamic_auto_load(),
     "obname"     : _obname,
     "obpath"     : _obpath,
     "obvalue"    : value,
     "virt"       : _virt_name,
     "timestamp"  : _timestamp,
     "static"     : _static_save,
     "been sold"  : _expired_sold,
     "expired"    : _expired,
     "expires on" : _expiry_time,
     "item value" : _item_value,
     "item short" : _obshort,
     "item plural": _obplural,
     "shop path"  : _shop_path
  ]);
}
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
       add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   _expired = arg["expired"] ;
   _expired_sold = arg["been sold"] ;
   _expiry_time = arg["expires on"] ;
   _item_value = arg["item value"] ;
   _obshort = arg["item short"];
   _obplural = arg["item plural"];
   _shop_path = arg["shop path"] ;
   ::init_dynamic_arg(arg["::"]);
   if ( _expired ) {
       set_short( "expired pawned item receipt" ) ;
       add_adjective( "expired" ) ;
       set_main_plural( "expired pawned item receipts" ) ;
       add_plural( "pawned item receipts" ) ;
   }
}
mixed *stats() {
  mixed *stuff;
  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
      ({ "been sold", _expired_sold }),
      ({ "expired", _expired }),
      ({ "expires on", _expiry_time }),
      ({ "item short", _obshort }),
      ({ "item value", _item_value }),
      ({ "item plural", _obplural }),
      ({ "shop path", _shop_path })
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
  return stuff;
}
object do_kiss() {
    object thing;
    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 0;
    }
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 0;
       }
    }
    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
            move("/room/rubbish");
            return thing;
        } else {
            write("The receipt whispers: I'm going to need some "
                  "creator help.\n");
            thing->dest_me();
        }
    } else {
         write("The receipt whispers: Sorry, I'm still broken.  "
               "Try again some other time, or contact a creator.\n");
    }
    return 0;
}
int do_reclaim() {
    int cost, i ;
    object change, item ;
    string change_str, place ;
    if ( ! query_pawned_item_receipt() ) {
        add_failed_mess( "$D is not a pawned item receipt.\n" ) ;
        return 0 ;
    }
    if ( base_name( environment( TP ) ) != _shop_path ) {
        add_failed_mess(
            "This is not the right place for you to reclaim $D.  "
            "Try a pawn shop.\n" ) ;
        return 0 ;
    }
    if ( ! environment( TP )->is_open( TP, 0 ) ) {
        return 0;
    }
    if ( _expired ) {
        add_failed_mess( "Oh dear, your receipt has expired.  With luck, your "
            + query_obshort() + " will be available for sale in the shop.\n" ) ;
        return 0 ;
    }
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }
    cost = ( ( 100 + _shop_path->query_pawn_markup() ) * _item_value ) / 100 ;
    debug_printf( "cost = %d, _item_value = %d, markup = %d",
        cost, _item_value, _shop_path->query_pawn_markup() ) ;
    if ( TP->query_value_in( place ) < cost ) {
        add_failed_mess( "You don't have enough money to reclaim $D.  "
            "It would cost you "
            + MONEY_HAND->money_value_string( cost, place ) + "\n" ) ;
        return 0 ;
    }
    change = MONEY_HAND->pay_amount_from( cost, TP, place ) ;
    if ( change ) {
        change->move( TP ) ;
        change_str = change->short() ;
    }
    item = do_kiss();
    if ( ! item ) {
        add_failed_mess(
          "Oh dear, your item doesn't seem to be here any more.  "
          "Please contact a liaison.\n" );
        return 0;
    }
    i = item->move( TP );
    if ( i != MOVE_OK ) {
        tell_object( TP, "You're too heavily burdened to accept "
          + item->the_short() + ", so it is placed on the floor for you.\n" );
        item->move( environment(TP) );
    }
    add_succeeded_mess( ({
        "$N $V " + item->the_short() + " for "
          + MONEY_HAND->money_value_string( cost, place )
          + ( change_str ? " and receive " + change_str + " in change" : "" )
          + ".\n",
        "$N $V $D and receives " + item->the_short() + " in exchange.\n"
    }) ) ;
    return 1 ;
}

==================================================
FILE: misc/perfume_bottle.c
==================================================

#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
int squirts;
string glass, scent, scent_plural;
void create() {
   object::create();
   holdable::create();
}
void setup() {
   set_name( "bottle" );
   set_short( "perfume bottle" );
   add_adjective( "perfume" );
   set_value( 4000 );
   set_weight( 2 );
   squirts = 12;
}
void set_glass( string word ) {
   set_short( word +" perfume bottle" );
   add_adjective( word );
   set_main_plural( word +" perfume bottles" );
   glass = word;
}
void set_scent( string words ) { scent = words; }
void set_scent_plural( string words ) { scent_plural = words; }
string long( string word, int dark ) {
   string words;
   words = "This is a perfume bottle made out of "+ glass +" crystal.  "+
         "It is ";
   switch( squirts ) {
      case 0 :
         return words +"empty.\n";
      case 1 .. 3 :
         words += "about a quarter full";
         break;
      case 4 .. 6 :
         words += "about half full";
         break;
      case 7 .. 9 :
         words += "about three-quarters full";
         break;
      default :
         words += "almost full";
   }
   words += " of "+ scent +" perfume which can be sprayed onto "+
         "someone.\n";
   return words;
}
void init() {
   this_player()->add_command( "spray", this_object(), "<direct:object> at <indirect:object>" );
}
int do_spray( object *things ) {
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You can only spray $D "+
        "at one person at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot spray $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  if ( !living( things[ 0 ] ) ) {
    this_player()->add_failed_mess( this_object(), "SI would probably not "+
        "benefit from being sprayed.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !squirts ) {
    this_player()->add_failed_mess( this_object(), "There is no perfume in "+
        "$D to spray at $I.\n", ({ things[ 0 ] }) );
    return 0;
  }
  squirts--;
  things[ 0 ]->add_effect( "/std/effects/other/perfume", ({ 300, scent,
      scent_plural }) );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "squirts" : squirts
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] !=
      "/obj/misc/perfume_bottle" )
    return 0;
  return ([
    "::" : int_query_static_auto_load(),
    "glass" : glass,
    "scent" : scent,
    "scent_plural" : scent_plural
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  squirts = map[ "squirts" ];
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( map[ "glass" ] )
    set_glass( map[ "glass" ] );
  if ( map[ "scent" ] )
    scent = map[ "scent" ];
  if ( map[ "scent_plural" ] )
    scent_plural = map[ "scent_plural" ];
}
void dest_me() {
   holdable::dest_me();
   object::dest_me();
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}

==================================================
FILE: misc/plate.c
==================================================

inherit "/std/surface";
void init() {
  this_player()->add_command( "eat", this_object(),
    "<indirect:object:direct-obs> {from|on} <direct:object:me>" );
  this_player()->add_command( "eat", this_object(),
    "from <direct:object:me>" );
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_long( "This is a nice plate for keeping food on.\n" );
  if ( ! do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int do_eat( object *obs, string dir, string indir, mixed *args ) {
  object ob;
  object *food;
  if( sizeof( obs ) )
    food = copy( obs );
  else
    food = all_inventory();
  if( sizeof( food ) ) {
    food = filter( food, (: $1->query_edible() :) );
  } else {
    this_player()->add_failed_mess( this_object(),
      "There's nothing on $D\n", ({ }) );
    return 0;
  }
  if( !sizeof( food ) ) {
    if( sizeof( obs ) )
      this_player()->add_failed_mess( this_object(),
        "You can't eat $I on $D!\n", obs );
    else
      this_player()->add_failed_mess( this_object(),
        "There's nothing edible on $D\n", ({ }) );
    return 0;
  }
  foreach( ob in food ) {
    ob->do_eat();
  }
  return 1;
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}

==================================================
FILE: misc/present.c
==================================================

#include <move_failures.h>
#define PAPER_LONG "This is a lovely big piece of " + _colour + " " + _type + " paper.  It looks like it could be used to wrap up something as a present.  Try \"wrap <objects> in paper\".\n"
#define PRESENT_LONG "This lovely piece of " + _colour + " paper has been used to wrap up something as a present.  Try \"unwrap\".\n"
inherit "/obj/baggage";
int do_wrap( object *things );
int do_unwrap();
private int wrapped;
private string _colour;
private string _type;
void setup() {
   set_name( "wrappingpaper" );
   set_short( "piece of wrapping paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of wrapping paper" );
   add_plural( ({ "pieces of wrapping paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   set_weight( 2 );
   set_max_weight( 225 );
   set_value( 600 );
   set_stuck(1);
   add_property( "writeable", 1 );
   add_property( "paper", 1);
}
void set_colour( string word ) {
   if( _colour ) {
      return;
   }
   _colour = word;
   if (!_colour) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _colour, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
void set_type( string word ) {
   if( _type ) {
      return;
   }
   _type = word;
   if (!_type) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _type, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
#ifdef MY_TEST_FUNC
int test_remove( object thing, int flag ) {
   if( ( query_verb() == "get" ) || ( query_verb() == "take" ) ) {
      return !wrapped;
   }
   return 1;
}
int test_add( object thing, int flag ) {
   if( ( query_verb() == "put" ) || ( query_verb() == "give" ) ) {
      return 0;
   }
   return 1;
}
#endif
void init() {
   add_command( "wrap", "<indirect:object:me> in <direct:object'present'>" );
   add_command( "unwrap", "<direct:object:'present'>", (: do_unwrap :) );
   add_command( "open", "<direct:object:'present'>", (: do_unwrap :) );
}
int do_wrap( object *things ) {
   object *valid, *failed;
   things -= ({ this_object() });
   if( wrapped ) {
      add_failed_mess( "The paper has already been used to wrap something.\n" );
      return 0;
   }
   if( !( sizeof( things ) ) ) {
      add_failed_mess( "You must wrap something!\n" );
      return 0;
   }
   valid = filter( things, (: !living( $1 ) &&
                              $1->move( this_object() ) == MOVE_OK :) );
   failed = things - valid;
   if( sizeof( failed ) ) {
      tell_object( this_player(), "You could not wrap " +
         query_multiple_short( failed ) + " in " + the_short() + ".\n" );
   }
   if( sizeof( valid ) ) {
      wrapped = 1;
      remove_alias( "paper" );
      remove_adjective( "piece of" );
      remove_adjective( "wrapping" );
      remove_plural( "pieces of wrapping paper" );
      remove_plural( "pieces of paper" );
      remove_plural( "papers" );
      call_out( "set_short", 1, _colour + " present" );
      add_alias( "present" );
      set_main_plural( _colour + " presents" );
      add_plural( "presents" );
      set_long( PRESENT_LONG );
      add_succeeded_mess( "$N $V $I in $D.\n", valid );
   } else {
      add_succeeded_mess( "" );
   }
   return 1;
}
int do_unwrap() {
   int i;
   object *things;
   if( !wrapped ) {
      write( "There is nothing wrapped in the paper.\n" );
      return 0;
   }
   wrapped = 0;
   things = all_inventory();
   write( "You open the present and find "+ query_multiple_short( things ) +
      " inside.\n" );
   for( i = 0; i < sizeof( things ); i++ ) {
      if( things[ i ]->move( environment() ) ) {
         if( environment( environment() ) ) {
            things[ i ]->move( environment( environment() ) );
            write( "The " + things[ i ]->short() + " falls onto the " +
               "floor as you unwrap the present.\n" );
         }
      }
   }
   remove_alias( "present" );
   remove_plural( "presents" );
   call_out( "set_short", 1, "piece of " + _colour + " " + _type + " paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   add_plural( ({ "pieces of " + _type + " paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   add_succeeded_mess("$N unwrap$s $D.\n");
   return 1;
}
mixed *stats() {
    return ::stats() + ({
      ({ "colour", _colour }),
      ({ "type", _type }),
      ({ "wrapped", wrapped }),
    });
}
mapping query_static_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "::": ::int_query_static_auto_load(),
    ]);
}
void init_static_arg( mapping args ) {
    _colour = args[ "colour" ];
    ::init_static_arg( args[ "::" ] );
}
mapping query_dynamic_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "wrapped": wrapped,
      "::": ::query_dynamic_auto_load(),
    ]);
}
void init_dynamic_arg( mapping args ) {
    _colour = args[ "colour"  ];
    _type   = args[ "type"    ];
    wrapped = args[ "wrapped" ];
    ::init_dynamic_arg( args[ "::" ] );
    if(!_colour) {
        _colour = "plain";
    }
    if(!_type) {
        _type = "wrapping";
    }
}
int query_closed() {
    return 1;
}
string long_status() {
    return "";
}

==================================================
FILE: misc/press_credentials.c
==================================================

inherit "/obj/clothing";
private string _owner = "someone";
private string _paper;
void set_owner_stuff();
void update_stuff();
void setup() {
   add_property("press credentials",1);
   set_name( "badge" );
   set_short( "press credentials badge" );
   add_adjective( ({ "press", "credentials" }) );
   add_alias( "badge" );
   add_property( "nosteal", 1 );
   add_alias( "credentials" );
   set_type( "badge" );
   setup_clothing( 1000 );
   set_weight( 1 );
   reset_drop();
   set_wear_remove_func(base_name(this_object()), "wear_badge");
}
void init() {
   if( _owner == "someone" ) {
      update_stuff();
   }
   if( this_player()->query_name() == lower_case(_owner) ) {
      add_command( "show", "<direct:object:me'credentials'>");
   }
}
void wear_badge(object ob, object player) {
   if (!ob) {
      if (player) {
         player->remove_title("newspaper");
      }
   } else if (_paper) {
      player->set_title("newspaper", "Reporter for " + _paper);
   }
}
void set_owner_stuff() {
   set_long( "This is a small badge with a hand-drawn picture of " +
     _owner + " on it, underneath the logo of " + _paper + ".  "
     "Emblazoned along the bottom are the words \"Official Reporter\".\n");
   if (query_worn_by()) {
      query_worn_by()->set_title("newspaper", "Reporter for " + _paper);
   }
}
int do_show() {
   add_succeeded_mess( ({ "With a practiced flick of your wrist, you display "
     "your press credentials to the room.\n", "With a practiced flick of $p "
     "wrist, $N whips out $p press credentials for " + _paper +
     " and shows them to "
     "everybody.\n" }) );
   return 1;
}
void set_paper_name(string paper) {
   _paper = paper;
}
string query_paper_name() {
   return _paper;
}
void update_stuff() {
   object ob;
   ob = environment();
   if( ob && living( ob ) ) {
      _owner = ob->query_cap_name();
   }
   set_owner_stuff();
}
mapping query_dynamic_auto_load() {
   return ([
     "::" : ::query_dynamic_auto_load(),
     "cred owner" : _owner,
     "paper" : _paper
   ]);
}
void init_dynamic_arg( mapping map ) {
   _paper = map["paper"];
   _owner = map["cred owner"];
   ::init_dynamic_arg( map[ "::" ] );
   set_owner_stuff();
}

==================================================
FILE: misc/quest_info_utils.c
==================================================

#include <library.h>
string _quest_name;
void set_quest_name(string quest_name)
{
   _quest_name = quest_name;
}
void set_quest_param(mixed player, string key, mixed value)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      info = ([ ]);
   info[key] = value;
   LIBRARY->set_player_quest_info(player, _quest_name, info);
}
mixed query_quest_param(mixed player, string key)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      return 0;
   return info[key];
}
void clear_quest_info(mixed player)
{
   if (!stringp(player))
      player = player->query_name();
   LIBRARY->set_player_quest_info(player, _quest_name, 0);
}

==================================================
FILE: misc/quill.c
==================================================

#include <language.h>
inherit "/obj/weapon";
int do_scribble( object *things, string mess);
object writing_on;
string type;
void setup() {
   set_name( "quill" );
   set_long( "This is a nice, long, feathery quill.  You could \"write\" "
         "on things with it.\n");
   set_weight( 3 );
   set_value( 1000 );
   new_weapon( 240 );
   add_help_file("quill");
   set_damage_chance( 100 );
   add_attack( "stab", 90, ({ 10, 2, 10 }), "pierce", "sharp", 0 );
   add_property( "paper writer", 1 );
   type = "ink";
}
void init() {
   add_command( "write", "on <indirect:object> with <direct:object>" );
   add_command( "write", "with <direct:object> on <indirect:object>" );
   add_command( "sign", "<indirect:object> with <direct:object>");
   add_command( "scribble",
                "<string'message'> on <indirect:object> with <direct:object>",
                (: do_scribble($1, $4[0]) :));
}
int do_scribble( object *things, string mess) {
   string language;
   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }
   if (things[0]->is_current_page_torn_out()) {
      add_failed_mess( "The page of " + things[0]->the_short() +
            " you were writing on appears to have been torn out.\n" );
      return 0;
   }
   things[0]->add_read_mess( mess, type, language, 0 );
   add_succeeded_mess("$N $V something on $I.\n", things);
   return 1;
}
int do_write( object *things ) {
   string language;
   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }
   if ( writing_on ) {
      add_failed_mess("You are already writing on $I with $D.\n", ({ writing_on }) );
      return 0;
   }
   add_succeeded_mess("$N start$s writing on $I with $D.\n", things );
   writing_on = things[ 0 ];
   call_out( "begin_writing", 0, this_player() );
   return 1;
}
void begin_writing( object writer ) {
   if ( !writer ) {
      writing_on = 0;
      return;
   }
   writer->do_edit( 0, "end_writing" );
}
void end_writing( string words ) {
   string language;
   if ( !words || ( words == "" ) ) {
      write( "You don't write anything on "+
            (string)writing_on->the_short() +".\n" );
      say( (string)this_player()->the_short() +" doesn't "+
            "write anything after all.\n" );
      writing_on = 0;
      return;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      write( "You seem to have changed to using a non-written language.\n" );
      say( (string)this_player()->the_short() +" seems "+
            "linguistically-challenged.\n" );
      writing_on = 0;
      return;
   }
   if ( !writing_on ) {
      write( "You seem to have lost what you were writing on.\n" );
      say( (string)this_player()->the_short() +" looks around "+
            "in puzzlement.\n" );
      return;
   }
   if ( member_array( environment( writing_on ), ({ environment(),
         environment( this_player() ) }) ) == -1 ) {
      write( (string)writing_on->the_short() +
            " seems to have run away from you.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }
   if (writing_on->is_current_page_torn_out()) {
      write( "The page of " + (string)writing_on->the_short() +
            " you were writing on appears to have been torn out.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }
   writing_on->add_read_mess( words, type, language, 0 );
   write( "You finish writing on "+
         (string)writing_on->the_short() +".\n" );
   say( (string)this_player()->the_short() +" finishes writing "+
         "on "+ (string)writing_on->a_short() +".\n" );
   writing_on = 0;
}
int do_sign(object* things) {
   object ob;
   string language;
   if ( query_wielded() != this_player() ) {
      add_failed_mess( "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V $I with $D when you're not "
            "using a language that can be written.\n", things );
      return 0;
   }
   things[ 0 ]->add_read_mess(this_player()->short(0, 1), "cursive, "
        "signed by", language, 0);
   add_succeeded_mess("$N $V $I with $D.\n", things);
   return 1;
}
int do_copy( mixed *in_dir, string direct, string indirect, mixed *args ) {
    mixed src_mess, mess;
    string lang, cur_lang;
    int i, c, siz, perr;
    if ( !present(direct, this_player()) ) return 0;
    if ( query_wielded() != this_player() ) {
        this_player()->add_failed_mess( this_object(), "You need to be "
                                       "holding $D to $V with it.\n", ({ }) );
        return 0;
    }
    if ((sizeof(in_dir) != 2) ||
        (sizeof(in_dir[0]) != 1) || (sizeof(in_dir[1]) != 1)) {
        this_player()->add_failed_mess(this_object(),
                                       "You can only $V to/from one object "
                                       "at a time.\n", ({ }));
        return 0;
    }
    if ( !in_dir[1][0]->query_property( "writeable" ) ) {
        this_player()->add_failed_mess( this_object(), "You can't write on "
                                       "$I.\n", in_dir[1] );
        return 0;
    }
    if ( sizeof(args) == 4 ) {
        if ( !LANGUAGE_HAND->query_language_written(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               args[3] + " is not a written language.\n",
                               ({ }));
            return 0;
        }
        if ( LANGUAGE_HAND->query_language_magic(args[3])) {
            this_player()->add_failed_mess(this_object(),
                               "You can't write " + args[3] + " like this.\n",
                               ({ }));
            return 0;
        }
        if ( !this_player()->query_language(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               "You don't know " + args[3] + ".\n", ({ }));
            return 0;
        }
        cur_lang = args[3];
    }
    src_mess = in_dir[0][0]->query_read_mess();
    if (!sizeof(src_mess)) {
        write("There is nothing written on " + in_dir[0][0]->the_short() +
              ".\n");
        this_player()->add_failed_mess(this_object(),
                                       "There is nothing written on $I.\n",
                                       in_dir[0]);
        return 0;
    }
    for (i = 0; i < sizeof(src_mess); i++) {
        mess = src_mess[i][0];
        lang = src_mess[i][2];
        siz = src_mess[i][3];
        if (LANGUAGE_HAND->query_language_magic(lang)) {
            mess = "A series of unintelligible scribbles.";
            lang = "common";
        } else if (!this_player()->query_language(lang) && stringp(mess)) {
            perr = this_player()->query_int() + this_player()->query_dex()
              - 20;
            for (c = random(perr); c < sizeof(mess); c += random(perr)+1) {
                if ((mess[c] >= 'a') && (mess[c] <= 'z')) {
                    mess[c] = 'a' + random(26);
                } else if ((mess[c] >= 'A') && (mess[c] <= 'Z')) {
                    mess[c] = 'A' + random(26);
                }
            }
        } else if ( stringp(cur_lang) ) {
            lang = cur_lang;
        }
        in_dir[1][0]->add_read_mess(mess, type, lang, siz);
    }
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V the writing on $I with $D.\n",
                                      in_dir[0]);
    return 1;
}

==================================================
FILE: misc/s_badge.c
==================================================

#include <mail.h>
#define DOMAIN explode( theres[ i ], "/" )[ 1 ]
#define LORD capitalize( (string)( "/d/"+ DOMAIN +"/master" )->query_lord() )
#define MASTER "/secure/master"
#define HANDLER "/obj/handlers/playtesters"
#define PROTECTION_EFFECT "/d/playtesters/effects/pt_protection"
inherit "/obj/armour";
mapping routes;
int access_mail(string str);
int list_destinations();
int list_transits();
int do_goto(string destination);
void setup() {
   set_name( "badge" );
   set_short( "bejewelled gold badge" );
   add_adjective( "gold" );
   set_long( "This bejewelled gold badge is the mark of a Senior Playtester."
           "  It has a drawing of a womble on the front; it seems to be using"
           " a magnifying glass to examine something.  On the back is "
           "engraved a scroll with some words on it.\n" );
   setup_armour( 100 );
   set_damage_chance( 0 );
   set_type( "badge" );
   reset_drop();
   call_out( (: add_wear_effect :), 0, PROTECTION_EFFECT );
   routes = ([
      "/d/klatch/djel/city/port/riverwalk09" : ({
         "/d/klatch/djel/city/port/pier1",
       }),
      "/d/klatch/djel/city/port/pier1" : ({
        "/d/klatch/djel/city/port/riverwalk09",
       }),
       "/d/am/isle_gods/siege/siege4" : ({
           "/d/am/isle_gods/buildings/parlour/parlor",
       }),
       "/d/am/ninth/ninth1" : ({
          "/d/am/blood/blood01",
       }),
       "/d/ram/ohulan/market/market_c" : ({
         "/d/ram/rambling_trail",
       }),
      "/d/klatch/djel/city/roads/widder35" : ({
         "/d/klatch/ephebe/desert/roads/road5",
       }),
      "/d/am/gates/hubwards" : ({
         "/d/sur/beta/topography/Sto_Plains/s_caravan/entrance",
      }),
    ]);
   set_read_mess( "This badge allows the bearer to move into certain areas "
         "to be playtested from certain entry locations (near to where the "
         "areas will be eventually connected).  To see the possible "
         "destinations from your current room, use the command "
         "\"destinations\", and to move into one of them, use the command "
         "\"goto <label>\" where <label> will be A, B, C, etc..  You can "
         "get a list of all transit points with \"transits\", although no "
         "guarantee is made that each item on this list will be "
         "recognisable.  Please report any problems with rooms not "
         "loading to the relevant domain Lord or Liaison(s)." );
}
void init() {
   string word;
   if ( !environment() )
      return;
   if ( !living( environment() ) )
      return;
   if ( !environment()->query_creator() ) {
      word = (string)environment()->query_name();
      if ( !HANDLER->query_playtester( word ) ) {
         tell_object( environment(), "You are not a playtester.  "
               "The playtester's badge disappears in a flurry of fluff.\n" );
         set_drop();
         move( "/room/rubbish" );
         return;
      }
      if ( HANDLER->query_senior_playtester( word ) ) {
         add_command( "mail", "", (: access_mail(0) :) );
         add_command( "mail", "<string>", (: access_mail($4[0]) :) );
      }
   }
   add_command("destinations", "", (: list_destinations() :) );
   add_command("transits", "", (: list_transits() :) );
   add_command("goto", "<string>", (: do_goto($4[0]) :) );
}
int access_mail( string words ) {
   return (int)MAIL_TRACK->mail( words );
}
int list_destinations() {
  int i;
  string here, *theres;
  object there;
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) )
    return notify_fail( "You cannot use the badge to move from here.\n" );
  write( "From here you can use the badge to move to:\n" );
  for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
        write( sprintf( "%c: %s cannot be found; please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%c: %s will not load, please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "%c: %s\n", 65 + i, (string)there->a_short() ) );
  }
  return 1;
}
int list_transits() {
   int i;
   string *theres;
   object there;
   theres = keys( routes );
   if ( !sizeof( theres ) )
      return notify_fail( "There are no transit points at the moment.\n" );
   write( "You can use the badge to move from:\n" );
   for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
        write( sprintf( "%s cannot be found; please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%s will not load, please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "   %s\n", (string)there->a_short() ) );
  }
  return 1;
}
int do_goto( string destination ) {
  int i;
  string here, *theres;
  object there;
  i = destination[ 0 ] - 65;
  if ( ( i < 0 ) || ( i > 25 ) ) {
    notify_fail( "The destination label needs to be a capital letter "+
        "between A and Z.\n" );
    return 0;
  }
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) ) {
    notify_fail( "You cannot use the badge to move from here.\n" );
    return 0;
  }
   if ( i >= sizeof( theres ) )
      return notify_fail( "That is not a valid label from here.\n" );
  if ( !( there = find_object( theres[ i ] ) ) ) {
    if ( file_size( theres[ i ] +".c" ) < 0 ) {
      write( theres[ i ] +" cannot be found; please contact "+ LORD +".\n" );
      return 1;
    }
    catch( theres[ i ]->force_load() );
    if ( !( there = find_object( theres[ i ] ) ) ) {
      write( theres[ i ] +" will not load; please contact "+ LORD +".\n" );
      return 1;
    }
  }
  write( "Moving you to "+ (string)there->the_short() +"...\n" );
  this_player()->move_with_look( there, "$N appear$s in a flurry of fluff "
             "that only $N could muster.", "$N disappear$s in a flurry of fluff." );
  return 1;
}

==================================================
FILE: misc/shell.c
==================================================

#include "potion_attrs.h"
#include "library.h"
inherit "/std/object";
#define MY_ROOM "/d/sur/Sto_Plains/n_caravan/picnic_area"
object *demons, cauldron, coin;
void setup() {
  set_weight(10);
  set_value(5);
  set_name("shell");
  add_adjective("sea");
  add_alias("seashell");
  set_short("sea shell");
  set_long("A large conch shell.  It looks like it has been hollowed "+
           "out so that it can be played.  Perhaps if you blew into "+
           "it it might work.\n");
}
void init() {
  this_player()->add_command("blow", this_object());
}
int finish_quest();
int do_blow(object *indir, string s1, string s2, string prep) {
  if (sizeof(indir)) {
    write("Blow "+short(0)+" "+prep+" "+indir->short(0)+"????\n");
    return 0;
  }
  if (file_name(environment(this_player())) == MY_ROOM)
    return finish_quest();
  add_succeeded_mess("$N $V $D and make$s a horrible noise.\n");
  return 1;
}
int finish_quest() {
  object *obs, *obs2, *obs3, ob, fish, frisbee, ladle;
  mixed *attrs;
  string failure;
  int i, j;
  write("The "+short(0)+" blows amazing loudly.\n");
  say(this_player()->one_short()+" blows the "+short(0)+
      " amazingly loudly.\n");
  if (demons) {
    write("Demons glare at you.\n");
    say("Demons glare at "+this_player()->one_short()+".\n");
    return 1;
  }
  obs = all_inventory(environment(this_player()));
  obs3 = obs;
  obs = map_array(obs, "bingle_bit", this_object());
  if ((i=member_array("ladle", obs)) == -1) {
    failure = "no ladle";
  } else {
    ladle = obs3[i];
  }
  if ((i=member_array("frisbee", obs)) == -1) {
    failure = "no frisbee";
  } else {
    frisbee = obs3[i];
  }
  if ((i=member_array("cauldron", obs)) == -1) {
    failure = "no caldron";
  } else {
    cauldron = obs3[i];
      obs2 = match_objects_for_existence("cauldrons", environment(this_player()));
    for (i=0;i<sizeof(obs2);i++) {
      if ((int)obs2[i]->query_volume() < 100 ||
          (int)obs2[i]->query_volume() < (int)obs2[i]->query_max_volume() / 2) continue;
      attrs = (mixed *)obs2[i]->query_misc_attrs();
      if (pointerp(attrs)) attrs = attrs[POTION_NAMES];
      if (pointerp(attrs) && sizeof(attrs) && attrs[0][0] == "yucky ankh water") {
        j++;
      }
    }
    if (!j) {
      failure = "no cauldron full of anhk river water";
    }
  }
  if ((i = member_array("coin", obs)) == -1) {
    failure = "no coin";
  } else {
    coin = obs3[i];
  }
  if ((i=member_array("fish", obs)) == -1) {
    failure = "no fish";
  } else {
    fish = obs3[i];
  }
      obs2 = match_objects_for_existence("toadstools", environment(this_player()));
  obs2 = filter_array(obs2, "bongle_array", this_object());
  if (sizeof(obs2) < 4) {
    failure = "not enough toadstools to sit on";
  }
  if (failure) {
    write("A bunch of hungry looking demons show up.\n");
    write("They look around the clearing.\n");
    write("Mutter to themselves about there being "+failure+".\n");
    write("Demon glares at you.\n");
    say("A bunch of hungry looking demons show up.\n");
    say("They look around the clearing.\n");
    say("Mutter to themselves about there being "+failure+".\n");
    say("Demon glares at "+this_player()->one_short()+".\n");
    return 1;
  }
  demons = allocate(4);
  for (i=0;i<sizeof(demons);i++) {
    demons[i] = clone_object("/std/container");
    demons[i]->set_name("demon");
    demons[i]->reset_get();
    demons[i]->set_long("A small demon with a manic look in his eyes "+
                        "cooking soup.\n");
    demons[i]->move(environment(this_player()));
    obs2[i]->move(demons[i]);
  }
  coin->reset_get();
  cauldron->reset_get();
  fish->dest_me();
  ladle->move(demons[2]);
  frisbee->move(demons[1]);
  say("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  call_out("do_finish_it", 10);
  write("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  return 1;
}
void do_finish_it() {
  object *obs;
  int i, j;
  say("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily.  You hear one of the say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  write("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily and leave.  You hear one of the "+
        "demons say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  cauldron->dest_me();
  coin->dest_me();
  obs = all_inventory(environment(demons[0]));
  for (i=0;i<sizeof(obs);i++)
    if (interactive(obs[i])) {
      if (!LIBRARY->set_quest(obs[i]->query_name(), "feeding frenzy"))
        continue;
      obs[i]->adjust_xp(5000);
    }
  for (i=0;i<sizeof(demons);i++) {
    obs = all_inventory(demons[i]);
    for (j=0;j<sizeof(obs);j++)
      obs[j]->dest_me();
    demons[i]->dest_me();
  }
  demons = 0;
}
mixed bingle_bit(object ob) {
  return (mixed)ob->query_property("feeding_frenzy");
}
int bongle_array(object ob) {
  return (int)ob->query_property("feeding_frenzy") != 0;
}

==================================================
FILE: misc/shop_owners_guide.c
==================================================

inherit "/std/book_dir";
void setup() {
  set_name("book");
  set_short("brilliant vermillion book");
  add_adjective(({"brilliant", "vermillion"}));
  add_alias("guide");
  set_long("This is a brilliant vermillion coloured book with lots of "
           "pictures of money on the front cover.\n");
  set_read_mess("                   DIY\n\n"
                "          A guide for shop owners.\n");
  set_main_plural("brilliant vermillion books");
  set_weight(10);
  set_value(10);
  set_book_language( "general");
  set_book_dir("/save/books/shop_owner/page");
  set_open_page(0);
  set_ignore_saved_pages(1);
}
int do_tear() {
  return 0;
}
int query_binding_force() {
  return 100;
}

==================================================
FILE: misc/suggestion_box.c
==================================================

inherit "/std/object";
int do_fill();
string _savedir, _savefile;
void setup() {
  set_short( "suggestion box" );
  set_long( "This is a suggestion box.  It is sitting on a pole which puts"
	    " the box at a convienient height for writing.  It has a pile "
	    "of small papers on it on which you can write suggestions.  "
	    "There is a slot in the top for stuffing the suggestion in "
	    "when you're done.\n" );
  set_name( "box" );
  set_main_plural( "boxes" );
  set_read_mess( "\nPlease fill in a suggestion form", "common" );
  add_property( "there", "sitting in the middle of the floor" );
  set_weight( 1000 );
  reset_get();
}
void init() {
  add_command( "fill", "in a suggestion form", (: do_fill() :) );
}
void set_save_file ( string file ) {
  _savefile = file;
  return;
}
void set_save_dir ( string dir ) {
  _savedir = dir;
  return;
}
string query_save_file () {
  return _savefile;
}
string query_save_dir () {
  return _savedir;
}
int do_fill() {
  tell_object( this_player(), "Please fill in your suggestion below.\n" );
  this_player()->do_edit( 0, "end_suggestion", this_object() );
  add_succeeded_mess( ({"", "$N fill$s in a suggestion form and stuff$s "
			  "it in the box.\n" }) );
  return 1;
}
void end_suggestion( string text ) {
  string player, file;
  if( _savefile ) {
    file = _savefile;
  } else if( _savedir ) {
    player = previous_object()->query_name();
    file = sprintf( query_save_dir() + "/%s-%d.txt", player, time() );
  }
  debug_printf( "File: %s", file );
  if( !(unguarded( (: write_file, file, text :) ) ) ) {
    tell_object( previous_object(), "Sorry, your suggestion was not recorded."
		 "  Please use the 'bug object' command to bug report the "
		 "suggestion box.\n" );
    return;
  }
  tell_object( previous_object(), "You fill in a suggestion form and stuff "
	       "it in the box.\n" );
}

==================================================
FILE: misc/teddy.c
==================================================

#define TP this_player()
#define TPCAP this_player()->one_short()
#define TO this_object()
inherit "std/object";
void setup(){
   set_name("bear");
   set_short("teddy bear");
   add_alias("teddy");
   add_adjective("teddy");
   set_long("This is a cute and cuddly teddy bear.  Just the sort to give "
     +"someone you love to remind them of you.  It looks very soft and "
     +"huggable.\n");
   set_weight(10);
   set_value(25);
   set_main_plural("teddy bears");
   add_plural(({"bears", "teddys"}));
}
void init() {
   TP->add_command("hug", TO);
   TP->add_command("cuddle", TO);
}
int do_hug() {
   write("You hug the teddy bear close to you and feel all warm and fuzzy "
     "inside.\n");
   say(TP->one_short()+ " hugs the teddy bear close and smiles happily.\n");
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}
int do_cuddle() {
  do_hug();
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}

==================================================
FILE: misc/terrain_shovel.c
==================================================

#include <dirs.h>
#include <terrain.h>
inherit "/std/object";
void setup() {
   set_name( "shovel" );
   set_short( "ceremonial shovel" );
   add_adjective( "ceremonial" );
   set_long( "This is a small ceremonial shovel, carried by those "+
         "responsible for the care, upkeep and expansion of "+
         "dungeons.\n" );
}
void init() {
   if ( this_player()->query_creator() ) {
      add_action( "do_add", "add" );
      add_action( "do_remove", "remove" );
      add_action( "do_visit", "visit" );
   }
}
int do_add( string words ) {
   int i, distance, level, *new_co_ord, *old_co_ord, *vector;
   string direc, file, terrain, type;
   object room, *things;
   if ( !words )
      return notify_fail( "Add what?\n" );
   if ( sscanf( words, "%s %s %s", type, file, direc ) != 3 )
      return notify_fail( "Syntax: add fixed|floating <file> <direction>\n" );
   i = member_array( direc, STD_ORDERS );
   if ( i == -1 )
      return notify_fail( capitalize( direc ) +" is not a valid "+
            "direction.\n" );
   room = environment( this_player() );
   if ( room->query_exit( direc ) )
      return notify_fail( "There is already an exit to the "+
            direc +".\n" );
   vector = STD_ORDERS[ i + 1 ];
   if ( file_size( file +".c" ) < 0 )
      return notify_fail( capitalize( file ) +" does not exist.\n" );
   file->force_load();
   if ( !find_object( file ) )
      return notify_fail( capitalize( file ) +" will not load.\n" );
   distance = (int)file->query_room_size() +
         (int)room->query_room_size();
   old_co_ord = (int *)room->query_co_ord();
   if ( sizeof( old_co_ord ) != 3 )
      return notify_fail( "Environment does not have coordinates.\n" );
   new_co_ord = allocate( 3 );
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = old_co_ord[ i ] - distance * vector[ i ];
   terrain = (string)room->query_property( "terrain name" );
   if ( !terrain )
      return notify_fail( "Environment is not in the terrain "+
            "handling system.\n" );
   switch( type ) {
      case "fixed" :
         i = (int)TERRAIN_MAP->add_fixed_location( terrain,
               file, new_co_ord );
         break;
      case "floating" :
         i = (int)TERRAIN_MAP->add_floating_location( terrain,
               file, new_co_ord, level );
         break;
      default :
         return notify_fail( "Type must be fixed or floating.\n" );
   }
   if ( !i )
      return notify_fail( "Failed to add "+ file +" ("+ type +
            ") to "+ terrain +" at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
   write( "Added "+ file +" ("+ type +") to "+ terrain +" at "+
         new_co_ord[ 0 ] +", "+ new_co_ord[ 1 ] +", "+
         new_co_ord[ 2 ] +".\n" );
   if ( type == "fixed" )
      file->dest_me();
   TERRAIN_MAP->clear_connections( terrain );
   TERRAIN_MAP->delete_cloned_location( terrain, file_name( room ) );
   things = all_inventory( room );
   things->move( "/room/void" );
   room->dest_me();
   room = (object)TERRAIN_MAP->find_location( terrain, old_co_ord );
   things->move( room );
   return 1;
}
int do_remove() {
   write( "This function has not been written yet.\n" );
   return 1;
}
int do_visit( string words ) {
   int x, y, z;
   string terrain;
   object room;
   if ( !words )
      return notify_fail( "Visit where?\n" );
   if ( sscanf( words, "%s %d %d %d", terrain, x, y, z ) != 4 )
      return notify_fail( "Syntax: visit <terrain> <x co-ord> "+
            "<y co-ord> <z co-ord>\n" );
   room = (object)TERRAIN_MAP->find_location( terrain, ({ x, y, z }) );
   if ( !objectp( room ) )
      return notify_fail( "There is no location at ("+ x +","+ y +","+ z +
            ") in \""+ terrain +"\".\n" );
   this_player()->move_with_look( room, "There is a strange smell, like "+
         "freshly broken earth, and $N appear$s.", "With a squelch, "+
         "$N vanish$s." );
   return 1;
}

==================================================
FILE: misc/tin_of_paint.c
==================================================

inherit "/obj/vessel";
#define VOLUME 5000
private nosave string _colour;
varargs int do_paint(string, object);
void setup() {
  set_name( "tin" );
  set_short( "tin of paint" );
  set_main_plural( "tins of paint");
  add_adjective( ({ "tin", "of"}));
  add_alias(({"paint"}));
  set_long( "A tin of paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
  set_leak_rate( 0 );
  set_max_volume( VOLUME );
  set_value( 30 );
  set_weight( 10 );
  set_max_weight( 30 );
}
void setup_attribs() {
  set_short( "tin of " + _colour + " paint" );
  set_main_plural( "tins of " + _colour + " paint");
  add_adjective( ({ _colour}));
  set_long( "A tin of " + _colour + " paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
}
void make_tin( string colour ) {
  object liquid;
  liquid = clone_object( "/obj/reagents/generic_liquid.ob" );
  liquid->set_name( "paint" );
  liquid->set_short( colour + " paint" );
  liquid->add_adjective(({colour }));
  liquid->set_amount( VOLUME );
  liquid->set_continuous();
  liquid->set_long( "This is " + colour + " paint, it's thick and gloopy.\n");
  liquid->set_pile_name( "puddle" );
  liquid->add_eat_effect( "/std/effects/ingested/poison", 10 );
  liquid->move( this_object() );
  set_closed();
  _colour = colour;
  setup_attribs();
}
void init() {
  ::init();
  this_player()->add_command("paint", this_object(),
           "<indirect:object:here'cardinal direction'> with <direct:object'paint'>",
                        (: do_paint( $4[0] ) :));
  this_player()->add_command("paint", this_object(),
                        "<string'part'> on <indirect:object:here> with <direct:object'paint'>",
                        (: do_paint( $4[0], $1[0] ) :));
  this_player()->add_command("paint", this_object(),
            "<indirect:object:here> help",
            (: do_paint( 0, $1[0] ) :));
}
varargs int do_paint(string indirect, object target) {
  object *obs;
  if(!indirect && target) {
      if(function_exists("what_to_paint", target))
          printf(target->what_to_paint());
      else
          printf("Help: paint " + target->short() + " with paint\n");
      return 1;
  }
  obs = match_objects_for_existence("paint", this_object());
  if(!query_volume() || !sizeof(obs)) {
    this_player()->add_failed_mess(this_object(), "$D appears to be empty.\n",
                                   ({ }));
    return 0;
  }
  if(query_closed()) {
    this_player()->add_failed_mess(this_object(), "$D is closed.\n", ({ }));
    return 0;
  }
  if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
                    (: $1->id("paint brush") :)))) {
    this_player()->add_failed_mess(this_object(), "You must be holding a "
                                   "paint brush to paint the walls.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->test_occupier(this_player()->query_name())) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  if(target) {
      if(!target->query_short()) return 0;
          if(!function_exists("decorate_part", target)) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                indirect + " on the " + target->query_short() + "!\n", ({ }));
                  return 0;
          }
          if(!target->decorate_part( indirect, obs[0]->query_short() )) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                                                        indirect + ".\n", ({ }));
                  return 0;
          }
          this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " on the " + target->query_short() +
                                                                        " with the brush using light, smooth strokes.\n", ({ }));
          return 1;
  }
  if(!function_exists("decorate_surface", environment(this_player()))) {
    this_player()->add_failed_mess(this_object(), "You can't $V the walls "
                                   "here.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->
     decorate_surface(indirect, "covered with " + obs[0]->query_short())) {
    this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                   indirect + ".\n", ({ }));
    return 0;
  }
  remove_volume(query_volume());
  this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " with $D using "
                                    "broad, smooth strokes.\n", ({ }));
  return 1;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
          "colour" : _colour,
          ]);
}
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["colour"]))
    _colour = args["colour"];
  if(_colour)
    setup_attribs();
}

==================================================
FILE: misc/top_clubs.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top club table" );
   set_long("This is a table listing those clubs that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "club", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   string *g_sorted;
   mapping g_info;
   stuff = TOP_TEN_HANDLER->query_club_info();
   str = "The club with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         ;
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the club must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_families.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top family table" );
   set_long("This is a table listing those families that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "family", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   mapping g_info;
   string *g_sorted;
   stuff = TOP_TEN_HANDLER->query_family_info();
   str = "The family with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         "Most average relationships: " +
         club_name(stuff[TOP_TEN_MOST_RELATIONSHIPS]) + "\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the family must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_ten_tables.c
==================================================

#include <top_ten_tables.h>
inherit "/std/object";
string generate_list( mixed *args );
string generate_table_message();
nosave string table_name;
nosave string language = "morporkian";
void setup() {
   table_name = 0;
   set_name( "table" );
   set_short( "top ten table" );
   set_long( "This is a perfectly rectangular wooden board, "
     "nailed to another piece of wood.\n" );
   add_adjective( ({ "top", "ten", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out( "setup_read_mess", 5 );
   call_out("dest_me", 30);
}
string query_table_name() { return table_name; }
void set_table_name( string word ) { table_name = word; }
void set_language( string lang ) {
  language = lang;
}
void setup_read_mess() {
   add_read_mess((: generate_table_message() :), 0, language, 0);
}
string generate_table_message() {
   string long;
   mixed *args;
   long = "\nHigh Score Table: ";
   args = (mixed *)TOP_TEN_HANDLER->query_ordered_table( table_name );
   if ( !table_name ) {
      long += "All Players";
      if ( !sizeof( args ) )
         return long +": There is no overall top ten at present.\n";
   } else {
      if ( file_size( "/std/guilds/"+ table_name +".c" ) < 0 )
         return "*Barf!* Can't find /std/guilds/"+ table_name +".\n";
      long += capitalize( (string)( "/std/guilds/"+ table_name )->
                     query_name() ) + "' Guild";
      if ( !sizeof( args ) )
         return long +": There is no top ten for this guild at present.\n";
   }
   return sprintf( "%|*s\n", table_name ? 40 : 50, long ) +
          sprintf( "%|*s\n", table_name ? 40 : 50, "Sorted by rating" ) +
          sprintf( "%|*s\n\n", table_name ? 40 : 50,
                   "-=- " + ctime(time()) + " -=-" ) +
          generate_list(args) + "\n";
}
string convert_age( int number ) {
   if ( number > 86400 )
      return ( number / 86400 ) +"D";
   if ( number > 3600 )
      return ( number / 3600 ) +"h";
   if ( number > 60 )
      return ( number / 60 ) +"m";
   return number +"s";
}
string generate_list( mixed *args ) {
   int i, number, sum;
   string format, list;
   if ( table_name )
      format = "  %2d. %-13s: level %4d  %5s";
   else
      format = "  %2d. %-23s: level %4d  %5s";
   format += "\n";
   list = "";
   number = sizeof( args );
   sum = 0;
   for ( i = 0; i < number; i++ )  {
      list += sprintf( format, i + 1, capitalize( args[ i ][ TOP_TEN_NAME ] ),
            args[ i ][ TOP_TEN_LEVEL ],
            convert_age( args[ i ][ TOP_TEN_AGE ] ) );
      if ( i > 0  &&  i < number - 1 )  {
         sum += args[i][TOP_TEN_RATING];
      }
   }
   return list;
}

==================================================
FILE: misc/torch.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
#define BRIGHTNESS 30
#define MAX_FUEL 2000
#define FUEL_PER_TICK ( FUEL_TIME * 2 )
private int amount_of_fuel;
private int is_lit;
int finish_it();
void setup_shorts();
void create() {
   object::create();
   holdable::create();
}
void setup() {
   amount_of_fuel = MAX_FUEL;
   set_name( "torch" );
   add_plural( "torches" );
   setup_shorts();
   add_help_file("torch");
   set_long( function() {
      string str;
      if ( is_lit && amount_of_fuel) {
         call_out( (: setup_shorts() :), 2 );
         str = "This is a fire burning out of control on the end "
            "of a stick of wood.  There is a lot of smoke coming "
            "off the fire, of the kind that, no matter which "
            "way you turn, will go up your nose.";
         switch ( amount_of_fuel / ( MAX_FUEL / 10 ) ) {
          case 10 :
          case 9  :
            return str+"  The torch looks brand new, it will burn for "
               "ages yet.\n";
          case 8 :
          case 7 :
          case 6 :
            return str+"  Not yet burning for very long, this torch is "
               "pretty happy with itself.  It doesn't seem "
               "to care about its short life span.\n";
          case 5 :
          case 4 :
            return str+"  The torch is happily burning.  It is in the "
               "prime of its life.\n";
          case 3 :
            return str+"  The torch has a little way to go yet, as it is "
               "now burning the light wood.\n";
          case 2 :
            return str+"  It looks like this torch won't "
               "last much longer.  Buying a new one would "
               "probably be a good investment.\n";
          case 1 :
          case 0 :
            return str+"  The torch is spluttering, there are huge "
               "amounts of smoke coming off it.  It looks like "
               "it is about to go out.\n";
         }
      }
      if ( amount_of_fuel >= MAX_FUEL )
         return "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end of it, and it looks as "
         "though it might be possible to light them.  The dirty rags "
         "have some sort of stuff covering them, probably "
         "to make them burn better.\n";
      if ( amount_of_fuel > MAX_FUEL / 2 )
         return "Someone has cut down a tree, chopped it up into smaller "
         "chunks and then wrapped the end in some rags.  "
         "The rags are blackened and it looks like someone set "
         "fire to them.  Perhaps you can too?\n";
      str = "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end.  ";
      if ( !amount_of_fuel )
         return str +"The end is completely blackened.  You would "
         "have to be extremely clever to get this torch "
         "going again.\n";
      switch (amount_of_fuel/(MAX_FUEL/10)) {
       case 5 :
       case 4 :
         return str +"The end has been blackened quite a bit, "
            "but it looks like there is a fair bit of "
            "go still left in it.\n";
       case 3 :
       case 2 :
         return str +"A few rags here and there cling to a meager "
            "existence.  You could set fire to them and "
            "make their life hell for a little while, but "
            "not for very long.\n";
       case 1 :
       case 0 :
         return str +"You can just see the remains of some rags "
            "attached to the blackened and burnt end of "
            "the torch.  It will last only for a short while "
            "longer.\n";
      }
      return "Whoops.  Tell a creator if you see this.\n";
   }
            );
   is_lit = 0;
   set_weight( 6 );
   set_value( 50 );
}
void set_fuel(int f) {
   amount_of_fuel = f;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   setup_shorts();
}
void init() {
  this_player()->add_command( "light", this_object() );
  this_player()->add_command( "extinguish", this_object() );
  this_player()->add_command( "dowse", this_object() );
}
void setup_shorts() {
   if ( is_lit && amount_of_fuel) {
      set_short( "lit torch" );
      set_main_plural( "lit torches" );
      remove_adjective( ({ "lightable", "burnt", "out" }) );
      add_adjective( "lit" );
   } else if ( amount_of_fuel > 0 ) {
      set_short( "lightable torch" );
      set_main_plural( "lightable torches" );
      remove_adjective( ({ "lit", "burnt", "out" }) );
      add_adjective( "lightable" );
   } else {
      set_short( "burnt torch" );
      set_main_plural( "burnt torches" );
      remove_adjective( ({ "lit", "lightable" }) );
      add_adjective( ({ "burnt", "out" }) );
   }
}
int do_light() {
   if (environment(this_object()) != this_player()) {
      this_player()->add_failed_mess( this_object(),
                                     "You are not carrying $D.\n", ({ }) );
      return 0;
   }
   if (amount_of_fuel <= 0) {
      this_player()->add_failed_mess( this_object(), "$D is burnt out.\n",
                                     ({ }) );
      return 0;
   }
   if (is_lit) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if (!query_holder() &&
       !sizeof( this_object()->hold_item( this_player(), -1 ) ) ) {
     this_player()->add_failed_mess( this_object(), "Unable to hold $D, "
         "your arms are probably full.\n", ({ }) );
      return 0;
   }
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( "setup_shorts", 2);
   return 1;
}
void out_of_fuel() {
   is_lit = amount_of_fuel = 0;
   set_light( 0 );
   set_value( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   tell_room( environment(), one_short() +" splutters violently "
     "for the last time before it crumbles to dust.\n" );
   call_out( "finish_it", 2 );
}
void do_warning() {
   tell_room( environment(), poss_short() +" starts to sputter and smoke a "
             "lot as it is now burning the light wood.  It is on its last "
             "legs.\n");
   return;
}
void consume_fuel() {
   amount_of_fuel -= FUEL_PER_TICK;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   switch ( amount_of_fuel ) {
    case (200-FUEL_PER_TICK) .. 200:
      do_warning();
      break;
    case 0:
      out_of_fuel();
      break;
    default:
   }
}
int do_extinguish(object *, string, string, string) {
   if ( !is_lit && objectp( this_player() ) ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }) );
      return 0;
   } else if ( !is_lit ) {
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   call_out( "setup_shorts", 2);
   return 1;
}
int do_dowse() {
   return do_extinguish(({ }), 0, 0, 0);
}
void dest_me() {
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   holdable::dest_me();
   object::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , amount_of_fuel, }),
    ({ "is lit", is_lit, }),
   });
}
mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "amount of fuel" : amount_of_fuel,
            "hold" : holdable::query_dynamic_auto_load(),
            "is lit" : is_lit,
          ]);
}
int held_this_item(int type, object holder, mixed arg) {
   if (!type) {
      if (holder && is_lit) {
         tell_object( holder,
                     "You extinguish the "+ short() +" as you put it down.\n");
         tell_room( environment(holder ),
                   holder->short() +" extinguishes the "+
                   short() +" as "+ holder->query_pronoun()
                   +" puts it down.\n", ({ holder }));
      }
      do_extinguish( ({ }), "", "", "");
   } else if (type == 2) {
      if (arg && holder && amount_of_fuel > 0) {
         set_light( BRIGHTNESS );
         FUEL_HANDLER->add_burner( this_object() );
         is_lit = 1;
      } else {
         is_lit = 0;
      }
      setup_shorts();
   }
   return 1;
}
void init_dynamic_arg( mapping arg ) {
   amount_of_fuel = arg["amount of fuel"];
   is_lit = arg["is lit"];
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
}
void init_static_arg(mapping arg) {
}
mapping query_static_auto_load() {
   return 0;
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}
void self_light() {
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( (: setup_shorts() :), 2);
   return;
}
  int finish_it () {
    this_object()->move( "/room/rubbish" );
    return 1;
}
int query_torch() {
  return 1;
}
int query_lit() {
  return is_lit;
}
int query_fuel() {
  return amount_of_fuel;
}

==================================================
FILE: misc/trap.c
==================================================

#include <move_failures.h>
#include <tasks.h>
inherit "/std/object";
int difficulty;
string trigger;
string description;
mixed message;
mixed effect;
void create() {
  add_help_file("door_trap");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void make_trap(int diff, string trig, string desc, mixed mess, mixed eff) {
  difficulty = diff;
  trigger = trig;
  description = desc;
  message = mess;
  effect = eff;
}
void init() {
  this_player()->add_command("rig", this_object(),
           "<indirect:object:here> with <direct:object:me>");
}
int do_rig(mixed *in_dir, string direct, string indirect, mixed *args,
             string) {
  object ob;
  object other;
  if(sizeof(in_dir) > 1) {
    this_player()->add_failed_mess(this_object(), "A trap can only be rigged "
                                   "on a single item.\n");
    return 0;
  }
  if(!difficulty) {
    this_player()->add_failed_mess(this_object(), "$D appears to be "
                                   "broken.\n");
    return 0;
  }
  ob = in_dir[0];
  if(ob->query_trap_difficulty() && ob->query_trap_armed()) {
    this_player()->add_failed_mess(this_object(),
                                   "$I already has an armed trap on it.\n",
                                   ({ in_dir[0] }));
    return 0;
  }
  if(!function_exists("setup_trap", ob, 0)) {
    this_player()->add_failed_mess(this_object(), "$I cannot be $Ved with "
                                   "$D.\n", ({ ob }));
    return 0;
  }
  if((trigger == "pick" || trigger == "unlock") &&
     (!ob->query_key() || ob->query_key() == "generic_key")) {
    this_player()->add_failed_mess(this_object(), "$I doesn't have a lock "
                                   "so $Vging it with $D which is triggered "
                                   "by " + trigger + "ing makes no sense.\n",
                                   ({ ob }));
    return 0;
  }
  switch(TASKER->perform_task(this_player(), "covert.items.traps", difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about rigging "
          "traps.%^RESET%^\n");
  case SUCCEED:
    difficulty +=
      random(this_player()->query_skill_bonus("covert.items.traps") / 10);
    break;
  default:
    if(random(difficulty) >
       this_player()->query_skill_bonus("covert.items.traps") ||
       difficulty >
       this_player()->query_skill_bonus("covert.items.traps") * 2) {
      if(arrayp(message)) {
        write(message[0]);
        say(message[1], this_player());
      } else
        write(message);
      if(intp(effect)) {
        if(effect > this_player()->query_hp())
          this_player()->do_death();
        else
          this_player()->adjust_hp(-(effect));
      } else if(arrayp(effect)) {
        switch(sizeof(effect)) {
        case 1:
          this_player()->add_effect(effect[0]);
          break;
        case 2:
          this_player()->add_effect(effect[0], effect[1]);
          break;
        default:
          this_player()->add_effect(effect[0], effect[1..]);
        }
      } else
        this_player()->add_effect(effect);
      this_object()->move("/room/rubbish");
      this_player()->add_succeeded_mess(this_object(), "As $N attempt$s to "
                                        "$V $D it goes off!\n");
      return 1;
    } else {
      difficulty -= random(difficulty -
                    this_player()->query_skill_bonus("covert.items.traps"));
    }
  }
  ob->setup_trap(difficulty, trigger, description, message, effect);
  if(function_exists("query_my_room", ob)) {
    other = load_object( (string)( ob->query_dest() ) );
    other = other->query_door_control( (string)( ob->query_other_id() ) );
    other->setup_trap(difficulty, trigger, description, message, effect);
    environment(this_player())->update_doors();
  }
  this_player()->add_succeeded_mess(this_object(), "$N carefully $V $I "
                                    "with $D.\n",
                                    ({ ob }));
  call_out("break_me", 1);
  return 1;
}
void break_me() {
  object ob;
  ob = clone_object("/std/object");
  ob->set_name("trap");
  ob->set_short("busted trap");
  ob->set_long("A broken trap.\n");
  ob->set_value(0);
  ob->set_weight(this_object()->query_weight());
  ob->move(environment());
  if(this_object()->move("/room/rubbish") != MOVE_OK)
    this_object()->dest_me();
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
            "difficulty" : difficulty,
            "trigger" : trigger,
            "description" : description,
            "message" : message,
            "effect" : effect
            ]);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping map) {
  if(!mapp(map))
    return;
  if(!undefinedp(map["::"]))
    ::init_static_arg(map["::"]);
  if(!undefinedp(map["difficulty"]))
    difficulty = map["difficulty"];
  if(!undefinedp(map["trigger"]))
    trigger = map["trigger"];
  if(!undefinedp(map["description"]))
    description = map["description"];
  if(!undefinedp(map["message"]))
    message = map["message"];
  if(!undefinedp(map["effect"]))
    effect = map["effect"];
}

==================================================
FILE: misc/tray.c
==================================================

#include <move_failures.h>
inherit "/std/surface";
inherit "/std/basic/holdable";
inherit "/std/basic/wearable";
void create() {
  wearable::create();
  holdable::create();
  surface::create();
}
void setup() {
  set_name( "tray" );
  set_short( "wooden tray" );
  set_long( "This is a small wooden tray, similar in style to the ones used by "
    "many vendors and travelling salespeople. Only a small quantity of items will "
    "fit on top of it.\n" );
  add_adjective(({ "small", "wooden" }));
  set_material("wood");
  set_weight(5);
  set_max_weight(40);
  set_no_limbs(2);
  set_type("sash");
  set_cond(1000);
  set_max_cond(1000);
  add_wear_effect( "/std/effects/attached/single_shoulder" );
}
string long( string word, int dark ) {
  return surface::long() + wearable::long();
}
varargs int move( mixed dir, string messin, string messout ) {
  if ( holdable::move( dir, messin, messout ) == MOVE_OK ) {
	  return surface::move( dir, messin, messout );
  }
  return MOVE_NO_UNHOLD;
}
mapping query_static_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_static_auto_load();
  map["surface"] = surface::query_static_auto_load();
  map["wearable"] = wearable::query_static_auto_load();
  return map;
}
void init_static_arg( mapping map ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_static_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_static_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_static_arg( map["wearable"] );
}
void dest_me() {
  holdable::dest_me();
  surface::dest_me();
}
mapping query_dynamic_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_dynamic_auto_load();
  map["surface"] = surface::query_dynamic_auto_load();
  map["wearable"] = wearable::query_dynamic_auto_load();
  return map;
}
varargs void init_dynamic_arg( mapping map, mixed new_arg ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_dynamic_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_dynamic_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_dynamic_arg( map["wearable"] );
}
mixed stats() {
	return surface::stats() + wearable::stats();
}
