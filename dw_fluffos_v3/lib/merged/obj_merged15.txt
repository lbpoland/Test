# Total Tokens: 18553
# Total Files Merged: 6
# Total Characters: 61861

wbiehelpers.c
==================================================

#include <playerinfo.h>
#include <player_handler.h>
#include <mail.h>
#define PI_TYPE "misc"
#define SAVE_FILE "/save/newbiehelpers"
#define TO this_object()
#define TP this_player()
private mapping admin;
private mapping helpers;
private mapping applicants;
private int minimum_apply_age, minimum_vouch_age;
protected void log_message( string message );
protected void load_file();
protected void save_file();
void create() {
    admin = ([ ]);
    helpers = ([ ]);
    applicants = ([ ]);
    minimum_apply_age = 0;
    minimum_vouch_age = 0;
    load_file();
}
string query_list( object lister ) {
    string list_mess, person;
    if( !sizeof( admin ) ) {
        list_mess = "There are no newbie helpers admin at present.\n";
    }
    else {
        list_mess = "Current newbie helpers admin:\n";
        foreach( person in keys(admin) ) {
            list_mess += "    $C$" + person + "\n";
        }
    }
    list_mess += "\n";
    if( !sizeof( helpers ) ) {
        list_mess += "There are no newbie helpers at present.\n";
    }
    else {
        list_mess += "Current newbie helpers:\n";
        foreach( person in keys(helpers) ) {
            list_mess += "    $C$" + person + "\n";
        }
    }
    if( admin[lister->query_name()] ) {
        list_mess += "\n";
        if( !sizeof( applicants ) ) {
            list_mess += "There are no outstanding newbie helper "
                "applications at present.\n";
        }
        else {
            list_mess += "Current applications to newbie helpers:\n";
            foreach( person in keys(applicants) ) {
                list_mess += "    $C$" + person + "\n";
            }
        }
    }
    return list_mess;
}
private string helper_info( string name, object tp ) {
    string helper_mess, *vouches;
    helper_mess = "Details for $C$" + name + ":\n";
    helper_mess += "    Hired by $C$" + helpers[name]["employer"] +
        ", " + ctime(helpers[name]["time"]) + ".\n";
    if( helpers[name] ) {
        vouches = helpers[name]["vouches"];
        if( !vouches || !sizeof(vouches) ) {
            helper_mess += "    No vouches.\n";
        }
        else {
            helper_mess += "    Vouches were: " +
                query_multiple_short( map( vouches, (: "$C$" + $1 :) ) ) +
                ".\n";
        }
        if( !helpers[name]["guild"] || helpers[name]["guild"] == "unknown" ) {
            helper_mess += "    Guild: Unknown.\n";
        }
        else {
            helper_mess += "    Guild: " + helpers[name]["guild"] +
                ".\n";
        }
        if( !helpers[name]["nationality"] ||
            helpers[name]["nationality"] == "unknown" ) {
            helper_mess += "    Nationality: Unknown.\n";
        }
        else {
            helper_mess += "    Nationality: " + helpers[name]["nationality"]
                + ".\n";
        }
    }
    if( admin[name] ) {
        helper_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
    return helper_mess;
}
private string applicant_info( string name, object tp ) {
    string app_mess, voucher;
    mapping vouches;
    app_mess = "Details for $C$" + name + ":\n";
    app_mess += "    Applied: " +
        ctime(applicants[name]["time"]) + ".\n";
    app_mess += "    Age: " + query_time_string(applicants[name]["age"],-1) +
        ".\n";
    app_mess += "    Guild: " + applicants[name]["guild"] + ".\n";
    app_mess += "    Nationality: " + applicants[name]["nationality"] + ".\n";
    vouches = applicants[name]["vouches"];
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        app_mess += "    Vouches:\n";
        foreach( voucher in keys(vouches) ) {
            app_mess += "        $C$" + voucher + " (" +
                query_time_string(
                    applicants[name]["vouches"][voucher]["age"], -1
                ) + " old)\n";
        }
    }
    app_mess += "\n";
    app_mess += "    $C$" + name + "'s application:$I$8=\n\n";
    app_mess += applicants[name]["statement"] + "$I$0=\n\n";
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        foreach( voucher in keys(vouches) ) {
            app_mess += "    Vouch by $C$" + voucher + " made " +
                ctime(applicants[name]["vouches"][voucher]["time"]) +
                ":$I$8=\n\n";
            app_mess += applicants[name]["vouches"][voucher]["statement"] +
                "$I$0=\n\n";
        }
    }
    if( admin[name] ) {
        app_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
    return app_mess;
}
string query_check_player( object checker, string player ) {
    if( !helpers[player] && !admin[player] && !applicants[player] ) {
        return "$C$" + player + " is not registered with the newbie "
            "helpers handler.\n";
    }
    if( !admin[checker->query_name()] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }
    TP->add_succeeded_mess(TO, "", ({ }) );
    if( helpers[player] ) {
        return helper_info( player, TP );
    }
    if( applicants[player] ) {
        return applicant_info( player, TP );
    }
    return "$C$" + player + " is just an admin.\n";
}
int add_helper( object adder, string player ) {
    string *player_vouches, player_guild, player_nationality, name;
    name = adder->query_name();
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;
    }
    if( !PLAYER_HANDLER->test_user(player) ) {
        tell_object( TP, "There is no player $C$" + player + "!\n" );
        return 0;
    }
    if( helpers[player] ) {
        tell_object( TP, "$C$" + player + " is already a newbie "
            "helper.\n" );
        return 0;
    }
    if( applicants[player] ) {
        player_vouches = keys( applicants[player]["vouches"] );
        player_guild = applicants[player]["guild"];
        player_nationality = applicants[player]["nationality"];
        map_delete( applicants, player );
            AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
                "application", "", "Hello,\n\nI am pleased to inform you "
                "that your newbie helpers application was successful, and "
                "that you have now been hired as a newbie helper.  This was "
                "an automatic mail.\n\n$C$" + name, 0, 0);
    }
    else {
        player_vouches = ({ });
        player_guild = "unknown";
        player_nationality = "unknown";
    }
    helpers[player] = ([ ]);
    helpers[player]["time"] = time();
    helpers[player]["employer"] = name;
    helpers[player]["vouches"] = player_vouches;
    helpers[player]["guild"] = player_guild;
    helpers[player]["nationality"] = player_nationality;
    save_file();
    log_message( player + " added as a helper by " + name );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Added as a newbiehelper.", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
    return 1;
}
string remove_helper( object remover, string player, string reason ) {
    string name;
    name = remover->query_name();
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;
    }
    if( !helpers[player] ) {
        return "$C$" + player + " is not a newbie helper.\n";
    }
    map_delete( helpers, player );
    save_file();
    log_message( player + " removed as a helper by " + name + ", reason: " +
        reason );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Removed as a newbiehelper (" + reason + ").", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
    return "You remove $C$" + player + "'s helper status.\n";
}
void submit_vouch(string statement, mixed args) {
    string name, player;
    object voucher;
    voucher = args[0];
    player = args[1];
    name = voucher->query_name();
    applicants[player]["vouches"][name] = ([ ]);
    applicants[player]["vouches"][name]["time"] = time();
    applicants[player]["vouches"][name]["age"] = -voucher->query_time_on();
    applicants[player]["vouches"][name]["statement"] = statement;
    save_file();
    log_message( name + " submits a vouch for " + player );
}
string no_vouch_reason( object voucher, string applicant ) {
    string name;
    name = voucher->query_name();
    if( !applicants[applicant] ) {
        return "$C$" + applicant + " isn't applying to be a newbie helper, "
            "so you can't vouch for them.\n";
    }
    if( applicants[applicant]["vouches"][name] ) {
        return "You already have already vouched for $C$" + applicant + " on "
            "this application, you cannot vouch again.\n";
    }
    if( applicant == name ) {
        return "You cannot vouch for yourself!\n";
    }
    if( -voucher->query_time_on() < minimum_vouch_age ) {
        return "You cannot vouch for $C$ " + applicant + " as you are too "
            "young to vouch.  You need to be " +
            query_time_string( minimum_vouch_age, -1 ) + " old before you "
            "can vouch on people's applications to be a newbie helper.\n";
    }
    return 0;
}
void submit_application(string statement, object player) {
    string name;
    name = player->query_name();
    applicants[name] = ([ ]);
    applicants[name]["time"] = time();
    applicants[name]["age"] = -player->query_time_on();
    applicants[name]["statement"] = statement;
    applicants[name]["vouches"] = ([ ]);
    applicants[name]["guild"] =
        (load_object(player->query_guild_ob()))->query_short();
    if( player->query_nationality() ) {
        applicants[name]["nationality"] = "$C$" +
            (load_object(player->query_nationality()))->query_name();
        }
    else {
        applicants[name]["nationality"] = "unknown";
    }
    save_file();
    log_message( name + " submits an application to newbiehelpers" );
}
string no_apply_reason( object player ) {
    string name;
    name = player->query_name();
    if( helpers[name] ) {
        return "You are already a newbie helper, why are you applying "
            "again?\n";
    }
    if( applicants[name] ) {
        return "You already have a newbie helper application open, you "
            "should wait to hear back about it.\n";
    }
    if( -player->query_time_on() < minimum_apply_age ) {
        return "You cannot apply to be a newbie helper as you are too "
            "young.  You need to be " +
            query_time_string( minimum_apply_age, -1 ) + " before you can "
            "apply to be a newbie helper.\n";
    }
    return 0;
}
void reject_application( object rejecter, string player, string reason,
    string mail ) {
    string name;
    name = rejecter->query_name();
    if( !admin[name] ) {
        return;
    }
    if( !applicants[player] ) {
        return;
    }
    AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
        "application", "", mail, 0, 0);
    map_delete( applicants, player );
    save_file();
    log_message( name + " rejects " + player + "'s application, reason: " +
        reason );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Rejected as a newbiehelper (" + reason + ").", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
}
string no_reject_reason( object rejecter, string player ) {
    string name;
    name = rejecter->query_name();
    if( !admin[name] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }
    if( !applicants[player] ) {
        return "$C$" + player + " isn't applying to be a newbie helper, so "
            "you can't reject them.\n";
    }
    return 0;
}
int query_helper( string name ) {
    if( helpers[name] ) {
        return 1;
    }
    else {
        return 0;
    }
}
int add_admin( string name ) {
    if( !admin[TP->query_name()] ) {
        return 0;
    }
    if( !admin[name] ) {
        admin[name] = 1;
        save_file();
        log_message( name + " added as admin by " + TP->query_name() );
        return 1;
    }
    else {
        return 0;
    }
}
int remove_admin( string name ) {
    if( !admin[TP->query_name()] ) {
        return 0;
    }
    if( !admin[name] ) {
        return 0;
    }
    else {
        map_delete(admin, name);
        save_file();
        log_message( name + " removed from admin by " + TP->query_name() );
        return 1;
    }
}
int query_admin( string name ) {
    if( admin[name] ) {
        return 1;
    }
    else {
        return 0;
    }
}
int query_can_chat( object who ) {
    if( query_helper( who->query_name() ) ||
        query_admin( who->query_name() ) ||
        who->query_creator() ) {
        return 1;
    }
    return 0;
}
string query_name() { return "Newbiehelpers Handler"; }
protected void log_message( string message ) {
    log_file("/log/NEWBIEHELPERS", ctime(time()) + ": " + message + "\n");
}
protected void save_file() {
    unguarded( (: save_object, SAVE_FILE, 1 :) );
}
protected void load_file() {
    if (file_size(SAVE_FILE + ".o") > 0)
        unguarded( (: restore_object, SAVE_FILE, 1 :) );
}

==================================================
FILE: handlers/news_handler.c
==================================================

#include <board.h>
#include <login_handler.h>
#define BOARD_NAME "announcements"
#define DELAY_TIME 30
int has_unread_announcements( string player ) {
    mapping news_rc;
    mixed subjects;
    news_rc = BOARD_HAND->query_newsrc( player );
    if ( !news_rc ) {
        news_rc = ([ ]);
    }
    subjects = BOARD_HAND->get_subjects( BOARD_NAME );
    if ( !sizeof( subjects ) ) {
        return 0;
    }
    return subjects[ <1 ][ B_TIME ] > news_rc[ BOARD_NAME ];
}
void show_message( mixed person ) {
    object player;
    if ( stringp( person ) ) {
        player = find_player( person );
    }
    else {
        player = person;
    }
    if ( !player ) {
        return;
    }
    if ( has_unread_announcements( player->query_name() ) ) {
        tell_object( player, "\nThere are %^YELLOW%^NEW%^RESET%^ "
            "announcements!  You can read them with \"news\".\n\n" );
    }
}
void login_event(mixed person, string type) {
    if ( type == LOGIN || type == RECONNECT ) {
        if ( objectp( person ) ) {
            person = person->query_name();
        }
        call_out( (: show_message :), DELAY_TIME, person );
    }
}
void broadcast_announcement() {
    foreach( object user in users() ) {
        if ( interactive( user ) ) {
            show_message( user );
        }
    }
}

==================================================
FILE: handlers/newspaper.c
==================================================

#include <room/newspaper.h>
#include <nroff.h>
#include <autodoc.h>
#include <login_handler.h>
#define SAVE_DIR "/save/newspaper/"
class edition {
   int date_published;
   class article* articles;
   class advert* adverts;
   string headline;
   int num_sold;
   int num_web_hits;
   int total_revenue;
}
class paper {
   class edition* published_editions;
   string dir_name;
   string long;
   string description;
   string office;
   int paper_cost;
   string language;
}
private mapping _papers;
private mapping _areas;
private mapping _xp;
private mapping _inform;
void load_me();
void save_me();
void create() {
   _papers = ([ ]);
   _areas = ([ ]);
   _xp = ([ ]);
   _inform = ([ ]);
   seteuid(getuid());
   load_me();
   if (!_inform) {
      _inform = ([ ]);
   }
}
int is_paper(string paper) {
   return classp(_papers[paper]);
}
void add_paper(string name, string long, string desc, string office,
    string language) {
   if (is_paper(name)) {
      return ;
   }
   _papers[name] = new(class paper);
   _papers[name]->published_editions = ({ });
   _papers[name]->dir_name = replace_string(lower_case(name), " ", "_");
   _papers[name]->long = long;
   _papers[name]->description = desc;
   _papers[name]->office = office;
   _papers[name]->paper_cost = 5 * 4;
   _papers[name]->language = language;
   save_me();
}
string* query_all_papers() {
   return keys(_papers);
}
int query_current_edition_num(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return sizeof(_papers[paper]->published_editions) + 1;
}
int query_last_edition_num(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return sizeof(_papers[paper]->published_editions);
}
int is_valid_edition(string paper, int edition) {
   if (!is_paper(paper)) {
      return 0;
   }
   if (edition > 0 && edition <= sizeof(_papers[paper]->published_editions)) {
      return 1;
   }
   return 0;
}
int query_edition_date(string paper, int edition) {
   if (!is_paper(paper)) {
      return 0;
   }
   if (!is_valid_edition(paper, edition)) {
      return 0;
   }
   return _papers[paper]->published_editions[edition - 1]->date_published;
}
class article* query_edition_articles(string paper, int edition) {
   if (!is_paper(paper)) {
      return ({ });
   }
   if (!is_valid_edition(paper, edition)) {
      return ({ });
   }
   return copy(_papers[paper]->published_editions[edition - 1]->articles);
}
class advert* query_edition_adverts(string paper, int edition) {
   if (!is_paper(paper)) {
      return ({ });
   }
   if (!is_valid_edition(paper, edition)) {
      return ({ });
   }
   return copy(_papers[paper]->published_editions[edition - 1]->adverts);
}
string query_paper_office(string paper) {
   if (!is_paper(paper)) {
      return  0;
   }
   return _papers[paper]->office;
}
void set_paper_office(string paper, string office) {
   if (!is_paper(paper)) {
      return  0;
   }
    _papers[paper]->office = office;
   save_me();
}
string query_paper_headline(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  "No news is good news.";
   }
   return _papers[paper]->published_editions[edition - 1]->headline;
}
void set_paper_headline(string paper, int edition, string headline) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }
   _papers[paper]->published_editions[edition - 1]->headline = headline;
   save_me();
}
int query_edition_revenue(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }
   return _papers[paper]->published_editions[edition - 1]->total_revenue;
}
void add_edition_revenue(string paper, int edition, int revenue) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }
   _papers[paper]->published_editions[edition - 1]->total_revenue += revenue;
   save_me();
}
void add_edition_web_hit(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }
   _papers[paper]->published_editions[edition - 1]->num_web_hits++;
   _papers[paper]->published_editions[edition - 1]->total_revenue += NEWSPAPER_WEB_HIT_REVENUE;
   save_me();
}
void add_edition_paper_sold(string paper, int edition, int cost) {
   if (!is_valid_edition(paper, edition)) {
tell_creator("pinkfish", "Not valid edition %O %O\n", paper, previous_object());
      return  ;
   }
tell_creator("pinkfish", "Updating num sold %O %O\n", paper, edition);
   _papers[paper]->published_editions[edition - 1]->num_sold++;
   _papers[paper]->published_editions[edition - 1]->total_revenue += cost;
   save_me();
}
int query_edition_num_sold(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }
   return _papers[paper]->published_editions[edition - 1]->num_sold;
}
int query_edition_num_web_hits(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }
   return _papers[paper]->published_editions[edition - 1]->num_web_hits;
}
int is_paper_area(string area) {
   return pointerp(_areas[area]);
}
void add_paper_area(string area) {
   if (is_paper_area(area)) {
      return ;
   }
   _areas[area] = ({ });
}
void add_paper_to_area(string paper, string area) {
   if (!is_paper(paper) || !is_paper_area(area)) {
      return ;
   }
   _areas[area] += ({ paper });
   save_me();
}
string* query_papers_in_area(string area) {
   if (_areas[area]) {
      return _areas[area];
   }
   return ({ });
}
void set_article_text(class article art, string text) {
   unguarded( (:
      write_file(SAVE_DIR + $(art->file_name), save_variable(({ $(art), $(text) })), 1) :) );
}
void add_newspaper_inform(string paper, string ob) {
   if (!_inform[paper]) {
      _inform[paper] = ({ });
   }
   if (!stringp(ob)) {
      return ;
   }
   if (member_array(ob, _inform[paper]) != -1) {
      return ;
   }
   _inform[paper] += ({ ob });
   save_me();
}
void remove_newspaper_inform(string paper, string ob) {
   if (!_inform[paper]) {
      return ;
   }
   _inform[paper] -= ({ ob });
   save_me();
}
string* query_newspaper_informs(string paper) {
   if (!_inform[paper]) {
      return ({ });
   }
   return _inform[paper];
}
string query_article_text(class article art) {
   string str;
   string* bits;
   str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      return bits[1];
   }
   return "Error reading the article text.";
}
string query_article_text_html(class article art) {
   string str;
   string* bits;
   str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      switch (art->type & NEWSPAPER_ARTICLE_TYPE_MASK) {
      case NEWSPAPER_ARTICLE_TYPE_PLAIN :
         bits[1] = replace_string(bits[1], "\n\n", "<p>");
         bits[1] = replace_string(bits[1], "\n", "<br>");
         return bits[1];
      case NEWSPAPER_ARTICLE_TYPE_HTML :
         bits[1] = replace_string(bits[1], "<pre>", "</font><pre>");
         bits[1] = replace_string(bits[1], "</pre>",
                                  "</pre>\n<font face=\"helvetica,arial\">");
         return bits[1];
      }
      return bits[1];
   }
   return "Error reading the article text.";
}
string convert_html(string input) {
   return AUTODOC_NROFF->convert_html(input);
}
string query_article_text_plain(class article art) {
   string str;
   string fluff;
   string* bits;
   switch (art->type & NEWSPAPER_ARTICLE_TYPE_MASK) {
   case NEWSPAPER_ARTICLE_TYPE_SECTION :
      return "";
   case NEWSPAPER_ARTICLE_TYPE_PLAIN :
      str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
      if (str) {
         bits = restore_variable(str);
         return bits[1];
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_HTML :
      fluff = unguarded( (: NROFF_HAND->cat_file(SAVE_DIR + $(art->file_name) + ".nroff", 1) :) );
      if (!fluff) {
         str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
         if (str) {
            bits = restore_variable(str);
            bits[1] = convert_html(bits[1]);
            unguarded( (: write_file(SAVE_DIR + $(art->file_name) + ".proc",
                                     $(bits[1]), 1) :) );
            unguarded( (: NROFF_HAND->create_nroff(SAVE_DIR + $(art->file_name) + ".proc",
                                SAVE_DIR + $(art->file_name) + ".nroff") :) );
            str = unguarded( (: NROFF_HAND->cat_file(SAVE_DIR + $(art->file_name) + ".nroff") :) );
            return str;
         }
      } else {
         return fluff;
      }
   }
   return "Error reading the article text.";
}
string query_paper_long(string paper) {
   if (!is_paper(paper)) {
      return "This is a very transperant and unhappy newspaper.\n";
   }
   return _papers[paper]->long;
}
void set_paper_description(string paper, string description) {
   if (!is_paper(paper)) {
      return ;
   }
   _papers[paper]->description = description;
   save_me();
}
string query_paper_description(string paper) {
   if (!is_paper(paper)) {
      return "This is a very transperant and unhappy newspaper.\n";
   }
   return _papers[paper]->description;
}
void set_paper_long(string paper, string long) {
   if (!is_paper(paper)) {
      return ;
   }
   _papers[paper]->long = long;
   save_me();
}
void set_paper_cost(string paper, int cost) {
   if (!is_paper(paper)) {
      return ;
   }
   _papers[paper]->paper_cost = cost;
   save_me();
}
int query_paper_cost(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return _papers[paper]->paper_cost;
}
int publish_paper(string paper,
                  string headline,
                  class article* articles,
                  string* text,
                  class advert* adds,
                  string* editors) {
   string paper_dir;
   string tmp;
   class paper fluff;
   class article article;
   class edition womble;
   int i;
   int edition;
   int total_xp;
   int type;
   if (!is_paper(paper)) {
      return 0;
   }
   fluff = _papers[paper];
   edition = sizeof(fluff->published_editions) + 1;
   paper_dir = SAVE_DIR + fluff->dir_name;
   unguarded( (: mkdir($(paper_dir)) :));
   paper_dir += "/" + edition;
   unguarded( (: mkdir($(paper_dir)) :));
   foreach (article in articles) {
      article->file_name = fluff->dir_name + "/" + edition + "/" +
                           article->file_name;
      type = article->type & NEWSPAPER_ARTICLE_TYPE_MASK;
      if ((type == NEWSPAPER_ARTICLE_TYPE_PLAIN ||
           type == NEWSPAPER_ARTICLE_TYPE_HTML) &&
           !(article->type & NEWSPAPER_ARTICLE_NO_XP_FLAG)) {
         _xp[lower_case(article->author)] += NEWSPAPER_XP_PER_ARTICLE;
         total_xp += NEWSPAPER_XP_PER_ARTICLE;
      }
   }
   total_xp = total_xp * 10 / 100;
   total_xp += NEWSPAPER_XP_EDITOR;
   if (sizeof(editors)) {
      foreach (tmp in editors) {
         _xp[tmp] += total_xp / sizeof(editors);
      }
   }
   for (i = 0; i < sizeof(articles); i++) {
      set_article_text(articles[i], text[i]);
   }
   womble = new(class edition);
   womble->articles = articles;
   womble->adverts = adds;
   womble->date_published = time();
   womble->headline = headline;
   fluff->published_editions += ({ womble });
   save_me();
   foreach (tmp in query_newspaper_informs(paper)) {
      call_out((: $1->event_publish_paper($2) :), 2, tmp, paper);
   }
   return 1;
}
void load_me() {
   string paper;
   class paper fluff;
   class paper rabbit;
   unguarded( (: restore_object(SAVE_DIR + "main", 1) :) );
   foreach (paper, fluff in _papers) {
      if (sizeof(fluff) == 6) {
         rabbit = new(class paper);
         rabbit->published_editions = fluff->published_editions;
         rabbit->dir_name = fluff->dir_name;
         rabbit->long = fluff->long;
         rabbit->description = fluff->description;
         rabbit->office = fluff->office;
         rabbit->paper_cost = 5 * 4;
         rabbit->language = "general";
         _papers[paper] = rabbit;
         fluff = rabbit;
      } else if( sizeof( fluff ) == 7 ) {
         rabbit = new(class paper);
         rabbit->published_editions = fluff->published_editions;
         rabbit->dir_name = fluff->dir_name;
         rabbit->long = fluff->long;
         rabbit->description = fluff->description;
         rabbit->office = fluff->office;
         rabbit->paper_cost = 5 * 4;
         rabbit->language = fluff->language;
         _papers[paper] = rabbit;
         fluff = rabbit;
      }
   }
}
void save_me() {
   unguarded( (: save_object(SAVE_DIR + "main") :) );
}
mixed* stats() {
   string paper;
   string person;
   class paper data;
   mixed* ret;
   int last;
   int xp;
   ret = ({ });
   foreach (paper, data in _papers) {
      last = query_last_edition_num(paper);
      ret += ({ ({ paper + ": office", data->office }),
                ({ paper + ": dir name", data->dir_name }),
                ({ paper + ": last issue", last }),
                ({ paper + ": current issue", query_current_edition_num(paper) }),
                ({ paper + ": num sold", query_edition_num_sold(paper, last) }),
                ({ paper + ": num web hits", query_edition_num_web_hits(paper, last) }),
                ({ paper + ": revenue", query_edition_revenue(paper, last) }),
              });
   }
   foreach (person, xp in _xp) {
      ret += ({ ({ person + ": xp", xp }) });
   }
   return ret;
}
void player_login_check(string player, string bing) {
   object play;
   int xp;
   if (bing != LOGIN) {
      return ;
   }
   xp = _xp[player];
   if (xp) {
      play = find_player(player);
      play->adjust_xp(xp);
      map_delete(_xp, player);
      save_me();
      tell_object(play, "%^YELLOW%^You feel like the experience of writing "
                        "an article has made you a better person.\n%^RESET%^");
   }
}
void set_language_for( string paper, string language ) {
    if( is_paper( paper ) )
        _papers[ paper ]->language = language;
}
string query_language_for( string paper ) {
    if( is_paper( paper ) ) {
        if( !undefinedp( _papers[ paper ]->language ) )
            return _papers[ paper ]->language;
        return "general";
    }
    return 0;
}

==================================================
FILE: handlers/nmoney_handler.c
==================================================

#include <money.h>
#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#undef USE_VAULT
mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_all_values() { return copy( values ); }
string *query_all_places() {
   return keys(values);
}
mixed *query_values() { return copy( values[ "default" ] ); }
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
}
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;
   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
}
void add_type( string where, string type, int value ) {
   int i;
   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
}
void remove_type( string where, string type ) {
   int i;
   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
}
mapping query_details() { return copy( details ); }
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
}
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
}
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
}
mapping query_symbols() { return copy( symbols ); }
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
}
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
}
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
}
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
}
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
}
string *query_aliases_for( string type ) {
   string *ret;
   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
}
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
}
string *query_adjectives_for( string type ) {
   string *ret;
   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   return ret;
}
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
}
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
}
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
}
string query_main_plural_for( string type ) {
   string *type_exp;
   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
}
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
}
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
}
string money_string( mixed mon_array ) {
   int i;
   string ret;
   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 );
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
}
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
}
varargs string money_value_string( int value, string where ) {
   string symboliser;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
}
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;
   if (!where) {
      where = "default";
   }
   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = values[ where ];
   if (!value && stuff) {
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
}
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
}
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;
   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
}
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }
      value *= query_value( type, where );
   }
   if (!value) {
      return 0;
   }
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   if ( value > total ) {
      return 0;
   }
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];
   ret = ({ });
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }
   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }
   return ({ ret, value, mon_array });
}
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;
   if (!type) {
     return 0;
   }
   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
}
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;
   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }
      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }
   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }
   if (sizeof(change_array) == 0) {
      return 0;
   }
#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;
}
varargs object make_new_amount( int value, string where ) {
   object money;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
}
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   m_array = (mixed *)money->query_money_array();
   money->dest_me();
   return filter_legal_money_array(m_array, where);
}
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   int i;
   object good, no_good;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });
   if (sizeof(m_array) == 0) {
      return ({ 0, 0 });
   }
   if (!(poss_values = values[where])) {
      poss_values = ({ });
   }
   if (!where || where == "") {
     where = "default";
   }
   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }
   if (sizeof(good_array) == 0) {
      good = 0;
   }
   else  {
#ifdef USE_VAULT
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(good_array);
   }
   if (sizeof(no_good_array) == 0) {
      no_good = 0;
   }
   else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(no_good_array);
   }
   return ({ good, no_good });
}
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;
   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;
}
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[0]) < m_array[1]) {
            return NO_MATCH;
         }
      }
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      m_array = ({ });
      foreach (thing in things)  {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#endif
      }
   }
   monies = filter_legal_money_array(m_array, place);
   if (monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#endif
   }
   else
      m_array = ({ });
   if (monies[0])  {
      m_array2 = copy(monies[0]->query_money_array());
      for (i = 0; i < sizeof(m_array2); i += 2)
         m_array2[i + 1] = -m_array2[i + 1];
      merge_money_arrays(m_array, m_array2);
      this_player()->adjust_money(m_array);
      return monies[0];
   }
   else return NO_LEGAL;
}
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;
   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
}
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
  tmp = values(query_all_values());
  foreach( elem in tmp ){
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}
string query_origin_of( string type ){
  string elem, *places;
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  places = query_all_places();
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  types = query_valid_types();
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
int smallest_value_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r];
}
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;
   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
}

==================================================
FILE: handlers/non_refuelling_lantern.c
==================================================

#include <fuel_handler.h>
inherit "/std/object";
#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
int  fuel_left;
int  is_lit;
void create(){
  ::create();
}
string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
  return ::short( 0 );
}
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
}
int do_dowse() {
   return do_extinguish();
}
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}
void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}
void out_of_fuel() {
   object env;
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else
      say( poss_short() +" burns out.\n" );
}
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
   }
}
string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
  return ::pretty_plural(thing);
}
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
}
void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
}
int query_fuel_left() {
    return fuel_left;
}
void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }
    fuel_left = i;
}
int query_max_fuel() {
    return MAX_FUEL;
}

==================================================
FILE: handlers/nquest_handler.c
==================================================

#include <player_handler.h>
#define LIBRARY "/obj/handlers/nlibrary"
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"
inherit "/std/object";
private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }
void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
}
int query_total_qp() { return total_qp; }
int add_quest( string name, int level, string title, string story ) {
   string log_name;
   if ( member_array( name, quest_name ) != -1 )
      return 0;
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 });
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
}
int change_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}
int query_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}
int query_quest_level(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
}
int set_quest_level(string name, int level) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
}
string query_quest_story(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
}
int set_quest_story(string name, string story) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
}
string query_quest_title(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
}
int set_quest_title(string name, string title) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
}
int query_quest_times( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
}
mixed query_quest_done( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
}
int delete_quest(string name) {
   int temp;
   string log_name;
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
}
string *query_quest_names() {
  return quest_name + ({ });
}
int *query_quest_levels() {
  return quest_level + ({ });
}
string *query_quest_titles() {
  return quest_title + ({ });
}
string *query_quest_stories() {
  return quest_story + ({ });
}
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;
   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
}
int query_player_fame(string name){
   int playerqp, rank;
   if (!name){
      return 0;
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   playerqp = (int)LIBRARY->query_quest_points(name);
   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
}
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
}
string *query_player_story(string name){
   string *quests;
   string *story;
   int i;
   story = ({ });
   if (!name){
      return ({ });
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
}
void print_some_stats()  {
   int i;
   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
}
