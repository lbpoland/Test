# Total Tokens: 18089
# Total Files Merged: 7
# Total Characters: 60313

rcel.c
==================================================

#define BASE_PATH "/save/parcels/"
#define SAVE_PATH BASE_PATH + location + "/" + name[0..0]
#define SAVE_FILE BASE_PATH + location + "/" + name[0..0] + "/" + name + ".o"
#define POST_LOG "PARCEL_LOG"
inherit "/global/auto_load";
#undef USE_COMPRESSION
#include <player_handler.h>
class parcel {
  string from;
  string *autoloadinfo;
  int exp_time;
}
mapping parcels;
private nosave string _current_name, _current_location;
nosave class parcel *_parcels;
int test_expire( class parcel temp );
void create() {
  string dir;
  seteuid( master()->creator_file( base_name( this_object() ) ) );
  parcels = ([ ]);
  if(parcels) {
    parcels = copy(parcels);
    parcels = ([ ]);
  }
  _parcels = ({ });
}
private void save_file(string name, string location) {
  string str;
  map_delete(parcels, name);
  if(sizeof(keys(parcels)))
    unguarded( (: save_object, SAVE_PATH, 2 :));
  if(file_size(SAVE_PATH) == -1)
    unguarded( (: mkdir, SAVE_PATH :) );
  if(_parcels != ({ })) {
    str = save_variable(_parcels);
#ifdef USE_COMPRESSION
    if(!ungarded( (: write_buffer, SAVE_FILE + ".gz", 0, compress(str) :) ))
#else
    if(!unguarded((: write_file, SAVE_FILE, str, 1 :) ))
#endif
      log_file(POST_LOG, "%s: error writing to %s\n",
               ctime(time()), SAVE_FILE);
  } else {
    if(file_size(SAVE_FILE) > 0)
      unguarded( (: rm, SAVE_FILE :));
    if(file_size(SAVE_FILE+".gz") > 0)
      unguarded( (: rm, SAVE_FILE + ".gz" :));
  }
}
private void load_file( string name, string location ) {
  if(_current_name == name && _current_location == location)
    return;
#ifdef USE_COMPRESSION
  if(file_size(SAVE_FILE + ".gz") > 0) {
    _parcels = restore_variable(uncompress(read_file(SAVE_FILE)));
  } else
#endif
  if(file_size(SAVE_FILE) > 0) {
    debug_printf("%s", SAVE_FILE);
    _parcels = restore_variable(unguarded( (: read_file, SAVE_FILE :) ));
  } else if (file_size(SAVE_PATH+ ".o.gz") > 0) {
    unguarded( (: restore_object, SAVE_PATH+".o.gz" :));
    _parcels = parcels[name];
  } else if(file_size(SAVE_PATH+".o") > 0) {
    unguarded( (: restore_object, SAVE_PATH :) );
    _parcels = parcels[name];
  } else {
    parcels = ([ ]);
    _parcels = ({ });
  }
  _current_name = name;
  _current_location = location;
}
public int deposit(string to, string from, string location, object *obs) {
  class parcel temp;
  object boxy;
  string obsstuff, tmp;
  obsstuff = "/global/events"->convert_message(query_multiple_short (obs));
  if(!PLAYER_HANDLER->test_user(to))
    return 0;
#ifndef __DISTRIBUTION_LIB__
    if("/secure/alist"->query_alt(from, to) == 100) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her alt " + capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(from, to) > 40) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her POSSIBLE alt "+ capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  load_file(to, location );
  if(undefinedp(_parcels) || !arrayp(_parcels))
    _parcels = ({ });
  boxy = clone_object("/obj/baggage");
  boxy->set_name("boxy");
  boxy->set_max_weight(100000);
  obs->move( boxy );
  temp = new( class parcel,
              from : from,
              exp_time: time() + ( 14 * 24 * 60 * 60));
  temp->autoloadinfo = create_auto_load( ({ boxy }), 0 );
  _parcels += ({ temp });
  save_file(to, location);
  boxy->dest_me();
  log_file (POST_LOG, "%s: %s deposited %s at %s for %s.\n", ctime(time()),
      from, obsstuff, location, to);
}
public int collect(string name, string location, object target, int copy) {
  class parcel temp;
  object *box_array = ({ });
  object *obs = ({ });
  string tmp;
  load_file(name, location );
  if(!_parcels || _parcels == ({ }))
    return 0;
  foreach(temp in _parcels) {
    box_array += load_auto_load_to_array(temp->autoloadinfo, this_player());
#ifndef __DISTRIBUTION_LIB__
    obs = all_inventory(box_array[<1]);
    if("/secure/alist"->query_alt(name, temp->from) == 100) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her alt " + capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(name, temp->from) > 40) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her POSSIBLE alt "+ capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  }
  foreach( object box in box_array ) {
    obs += all_inventory (box);
    all_inventory( box )->move( target );
    box->dest_me();
  }
  if ( !copy )
    _parcels = ({ });
  log_file (POST_LOG, "%s: %s collected %s at %s.\n", ctime(time()),
            name, "/global/events"->convert_message(query_multiple_short(obs)),
            location);
  save_file(name, location);
  return 1;
}
class parcel *queryparcels_for(string name, string location) {
  load_file(name, location);
  return _parcels;
}
void do_migrate(int letter, string location) {
  string name;
  class parcel temp2;
  tell_creator("ceres", "Processing %c in %s\n", letter, location);
  load_file(sprintf("%c", letter), location);
  foreach(name, temp2 in parcels) {
    _parcels = filter(temp2, (: test_expire :));
    save_file(name, location);
  }
  if(!sizeof(keys(parcels))) {
    name = BASE_PATH + location + "/" + sprintf("%c", letter) + ".o.gz";
    unguarded((: rm, name :));
  }
  if(letter < 'z') {
    letter++;
    call_out("do_migrate", 15 + random(30), letter, location);
  }
}
int test_expire(class parcel temp ) {
  if ( temp->exp_time > time() )
    return 1;
  return 0;
}
void player_refreshed(mixed name, int total ) {
  string location;
  string *dirs = map( filter( get_dir( BASE_PATH, -1 ),
                              (: $1[1] == -2 :) ), (: $1[0] :) );
  if (objectp(name))
    name = name->query_name();
  foreach(location in dirs) {
    load_file(name, location);
    map_delete(parcels, name);
    save_file(name, location);
  }
}

==================================================
FILE: handlers/pattern_compiler.c
==================================================

#include <user_parser.h>
#define PATTERN_CACHE_SIZE 200
nosave mapping patterns;
nosave mapping pattern_short;
nosave string *pattern_order;
nosave int hits, reqs, cache_callout;
nomask mixed *compile_pattern(string str);
void create() {
   patterns = ([ "" : ({ 100 }) ]);
   pattern_short = ([ "" : "" ]);
}
void clean_cache() {
  int i;
  for(i=0; i<(sizeof(pattern_order)-PATTERN_CACHE_SIZE); i++) {
    map_delete(patterns, pattern_order[i]);
    map_delete(pattern_short, pattern_order[i]);
  }
  pattern_order = pattern_order[i..];
  cache_callout = 0;
}
nomask mixed *query_pattern(string pattern) {
  if (!patterns[pattern]) {
    patterns[pattern] = compile_pattern(pattern);
  }
  return patterns[pattern];
}
nomask mixed *compile_pattern(string str) {
   mixed *pattern;
   mixed *bits;
   int i;
   int failed;
   int type;
   int weight;
   mixed env;
   string short;
   string short_bit;
   int pos;
   int pos2;
   int j;
   int k;
   bits = explode(str, " ") - ({ 0, "" });
   pattern = ({ });
   short = "";
   for (i = 0; i < sizeof(bits) && !failed; i++) {
      switch (bits[i][0]) {
      case '<' :
         pos = strsrch(bits[i], "'");
         if (pos != -1) {
             pos2 = strsrch(bits[i][pos + 1..], "'", pos + 1);
             if (pos2 == -1) {
                for (j = i + 1; j < sizeof(bits); j++) {
                   pos2 = strsrch(bits[j], "'");
                   if (pos2 != -1) {
                      break;
                   }
                }
                if (j < sizeof(bits)) {
                   for (k = i + 1; k <= j; k++) {
                      bits[i] += " " + bits[k];
                   }
                   bits[j] = bits[i];
                   i = j;
                   pos2 = strsrch(bits[i], "'", -1);
                }
             } else {
                pos2 += pos + 1;
             }
             if (pos2 != -1) {
                short_bit = bits[i][pos+1..pos2-1];
                bits[i] = bits[i][0..pos-1] + bits[i][pos2+1..];
             } else {
                short_bit = 0;
             }
         } else {
             short_bit = 0;
         }
         bits[i] = bits[i][1..<2];
         bits[i] = explode(bits[i], ":");
         if (!bits[i]) {
            bits[i] = ({ "" });
         }
         switch (bits[i][0]) {
         case "direct" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of direct (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                   short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ DIRECT_OBJECT, type, env });
            break;
         case "indirect" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               case "wiz-present" :
                  type = WIZ_PRESENT_TARGET;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of indirect (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                  short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ INDIRECT_OBJECT, type, env });
            break;
         case "string" :
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "small" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 6;
                  pattern += ({ SHORT_STRING });
                  break;
               case "long" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 5;
                  pattern += ({ STRING });
                  break;
               case "quoted" :
                  if (!short_bit) {
                     short += "\"<string>\" ";
                  } else {
                     short += "\"<" + short_bit + ">\" ";
                  }
                  weight += 8;
                  pattern += ({ QUOTED_STRING });
                  break;
               default :
                  printf("Invalid type of string (%s).\n", bits[i][1]);
                  failed = 1;
                  break;
               }
            } else {
               if (!short_bit) {
                  short += "<string> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               weight += 5;
               pattern += ({ STRING });
            }
            break;
         case   "number" :
            if (!short_bit) {
               short += "<number> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ NUMBER });
            break;
         case "word" :
            if (!short_bit) {
               short += "<word> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 7;
            pattern += ({ SINGLE_WORD });
            break;
         case "fraction" :
            if (!short_bit) {
               short += "<fraction> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ FRACTION });
            break;
         default :
            weight += 10;
            bits[i] = implode(bits[i], ":");
            if (master()->query_word_list(bits[i])
                  || this_player()->query_word_list(bits[i])) {
               if (!short_bit) {
                  short += "<"+bits[i]+"> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               pattern += ({ WORD_LIST, bits[i] });
            } else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
            }
            break;
         }
         break;
      case '{' :
         weight += 10;
         if (bits[i][<1] == '}') {
            pattern += ({ WORD_LIST, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != '}'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ WORD_LIST_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      case '[' :
         weight += 4;
         if (bits[i][1] == '<') {
            if (MASTER->query_word_list(bits[i][2..<3])
                  || this_player()->query_word_list(bits[i][2..<3]))
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            }
            short += bits[i]+" ";
         } else if (bits[i][1] == '{') {
            if (bits[i][<1] == ']') {
               pattern += ({ OPTIONAL, explode(bits[i][2..<3], "|") });
               short += bits[i]+" ";
            } else {
               int old = i;
               string elm, *res;
               for (++i; bits[i][<1] != ']'; i++);
               res = ({});
               foreach (elm in explode(implode(bits[old..i], " ")[2..<3], "|"))
                  res += ({ explode(elm, " ") });
               pattern += ({ OPTIONAL_SPACES, res });
               short += implode(bits[old..i], " ")+" ";
            }
         } else if (bits[i][<1] == ']') {
            pattern += ({ OPTIONAL, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != ']'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ OPTIONAL_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      default :
         weight += 10;
         short += bits[i]+" ";
         pattern += ({ WORD_LIST, ({ bits[i] }) });
         break;
      }
   }
   if (failed) {
      return 0;
   }
   pattern_short[str] = short;
   return ({ weight }) + pattern;
}
string query_short_pattern(string str) {
  reqs++;
  if(!pattern_short[str])
    compile_pattern(str);
  else
    hits++;
  return pattern_short[str];
}
mixed *stats() {
  return  ({
    ({ "patterns", sizeof(keys(pattern_short)), }),
        ({ "requests", reqs, }),
          ({ "cache hit percent", (hits * 100) / reqs, }),
            });
}

==================================================
FILE: handlers/peopler.c
==================================================

#include <peopler.h>
#define MULTIPLAYER "/obj/handlers/multiplayer"
string *de_names,
       *abbrev,
       *var_names;
void create() {
  de_names = DE_NAMES;
  abbrev = ABBREV;
  var_names = ({
      "dirs",
      "netstat",
      "people",
      "qpeople",
      "terms",
      "netdups",
    });
}
object *get_people(string str) {
  object *ob;
  int i;
  string s1;
  ob = users();
  for(i = 0; i<sizeof(ob); i++) {
    if (str && (sscanf(ob[i]->query_name(),str+"%s", s1) != 1)) {
      ob = ob[0..i - 1] + ob[i+1..];
      i--;
    }
  }
  return ob;
}
private string create_title(mixed *bits) {
  int i, pos;
  string str;
  str = "";
  for (i=0;i<sizeof(bits);i+=2) {
    if ((pos = (bits[i]&~MASK)) == STRING)
      str += bits[i+1];
    else
      if (strlen(de_names[pos]) > bits[i+1])
        str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", "");
      else
        switch (bits[i]&MASK) {
          case CENTER :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"|s", de_names[pos]);
            break;
          case RIGHT :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", de_names[pos]);
            break;
          default :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"-s", de_names[pos]);
            break;
        }
  }
  return str;
}
private string review_thingy(mixed *bing) {
  int i;
  string str;
  str = "";
  for (i = 0; i < sizeof(bing); i += 2) {
    if (bing[i] == STRING) {
      str += bing[i+1];
    } else {
      switch (bing[i]&MASK) {
        case CENTER :
          str += "%|"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        case RIGHT :
          str += "%"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        default :
          str += "%-"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
      }
    }
  }
  return str;
}
private void print_entrys(object *obs, mixed *format, int with_dups,
                          string constraint) {
  int age, j;
  mixed g;
  string form, str, mess, *not_allowed;
  object ob, env, *dups;
  mapping per_ip;
  reset_eval_cost();
  if (with_dups) {
    per_ip = unique_mapping(obs, (: query_ip_number($1) :));
  }
  mess = sprintf("%s\n", create_title(format));
  foreach(ob in obs) {
    str = "";
    for (j=0;j<sizeof(format);j+=2) {
      switch (format[j]&MASK) {
        case RIGHT :
          form = "%"+format[j+1]+"."+format[j+1];
          break;
        case CENTER :
          form = "%|"+format[j+1]+"."+format[j+1];
          break;
        default :
          form = "%-"+format[j+1]+"."+format[j+1];
          break;
      }
      switch (format[j]&~MASK) {
        case STRING :
          str += format[j+1];
          break;
        case C_NAME :
          str += sprintf(form+"s", capitalize( (string)ob->query_name() ) );
          break;
        case GENDER :
          str += sprintf(form+"s", ob->query_gender_string());
          break;
        case NAME :
          str += sprintf(form+"s", (ob->query_in_editor()?"*":"")+
              ( ob->query_invis() ? "("+ (string)ob->query_name() +")" :
              (string)ob->query_name() ) );
          break;
        case GUILD :
          if(ob)
            str += sprintf(form+"s",
                           ((g=(object)ob->query_guild_ob())?
                            g->query_name():"No guild"));
          else
            str += sprintf(form+"s", "Broken guild");
          break;
        case LEVEL :
          str += sprintf(form+"s", ""+ ob->query_level());
          break;
        case ROWS :
          str += sprintf(form+"s", ""+ ob->query_rows());
          break;
        case COLS :
          str += sprintf(form+"s", ""+ ob->query_cols());
          break;
        case TERMINAL :
          str += sprintf(form+"s",
                         ((g = ob->query_term_name()) ?
                          g + (g == "network" ? " (" +
                               ob->query_cur_term() + ")" : "") : ""));
          break;
        case IP_NUMBER :
          str += sprintf(form+"s", query_ip_number(ob));
          break;
        case IP_NAME :
          str += sprintf(form+"s",
                           (query_ident(ob)?query_ident(ob)+"@":"")+
                           query_ip_name(ob));
          break;
        case TYPE :
          str += sprintf(form+"s", ob->query_object_type()+"");
          break;
        case AGE :
          age = (int)ob->query_time_on();
          if (age < -86400)
            str += sprintf(form+"s", (age/-86400)+"D");
          else if (age < -3600)
            str += sprintf(form+"s", (age/-3600)+"h");
          else if (age < -60)
            str += sprintf(form+"s", (age/-60)+"m");
          else
            str += sprintf(form+"s", (age/-1)+"s");
          break;
        case ROOM :
          env = environment(ob);
          str += sprintf(form+"s",env?file_name(env):"No environment");
          break;
        case EUID :
          env = environment(ob);
          str += sprintf(form+"s",env?geteuid(env):"No environment");
          break;
        case UID :
          env = environment(ob);
          str += sprintf(form+"s",env?getuid(env):"No environment");
          break;
        case CFILE :
          env = environment(ob);
          str += sprintf(form+"s",env?"/secure/master"->creator_file(env)
                         :"No environment");
          break;
        case CUR_DIR :
          str += sprintf(form+"s", (ob->query_current_path()?
                                    ob->query_current_path():"No dir"));
          break;
        case ND_ALLOWED :
          dups = per_ip[query_ip_number(ob)] - ({ ob });
          not_allowed = MULTIPLAYER->check_allowed(ob, dups);
          str += sprintf(form+"s", (sizeof(not_allowed) ?
                                    query_multiple_short(not_allowed) :
                                    ""));
          break;
      }
    }
    if(!constraint || strsrch(str, constraint) != -1)
      mess += sprintf("%s\n", str);
  }
  this_player()->more_string( mess );
}
int do_command(mixed *pattern, string constraint, function sort_func,
               int only_duplicates) {
   object *obs;
   object *tmpobs;
   int i;
   obs = get_people("");
   if (!sizeof(obs)) {
      notify_fail("Nobody seems to start with '" + constraint + "'.\n");
      return 0;
   }
   if (!sort_func) {
      sort_func = (: strcmp($1->query_name(), $2->query_name()) :);
   }
   obs = sort_array(obs, sort_func);
   if (only_duplicates) {
      tmpobs = ({ });
      for (i = 1; i <sizeof(obs); i++) {
         if (!evaluate(sort_func, obs[i - 1], obs[i])) {
            if (member_array(obs[i - 1], tmpobs) == -1) {
               tmpobs += obs[i - 1..i];
            } else {
               tmpobs += ({ obs[i] });
            }
         }
      }
      if (!sizeof(tmpobs)) {
         notify_fail("Unable to find any duplicates.\n");
         return 0;
      }
      obs = tmpobs;
   }
   print_entrys(obs, pattern, only_duplicates, constraint);
   return 1;
}
int review() {
  mixed *bing;
  bing = (mixed *)this_player()->query_property("people list");
  if (!bing)
    bing = P_DEFAULT;
  write("People : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("qpeople list");
  if (!bing)
    bing = QP_DEFAULT;
  write("Qpeople: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netstat list");
  if (!bing)
    bing = N_DEFAULT;
  write("Netstat: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("term list");
  if (!bing)
    bing = T_DEFAULT;
  write("Terms  : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("dir list");
  if (!bing)
    bing = D_DEFAULT;
  write("Dirs   : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netdup list");
  if (!bing)
    bing = ND_DEFAULT;
  write("Netdups: "+review_thingy(bing)+"\n");
}
private mixed *create_review(string str) {
  string *bits, rest;
  int i, bing, width, tmp;
  mixed *ret;
  bits = explode("$"+str, "%");
  bits[0] = bits[0][1..];
  if (!strlen(bits[0]))
    ret = ({ });
  else
    ret = ({ STRING, bits[0] });
  for (i=1;i<sizeof(bits);i++) {
    bing = RIGHT;
    rest = bits[i];
    if (rest[0] == '|') {
      bing = CENTER;
      rest = rest[1..];
    } else if (rest[0] == '-') {
      bing = 0;
      rest = rest[1..];
    }
    if (sscanf(rest, "%d%s", width, rest) == 2) {
      tmp = member_array(rest[0..0], abbrev);
      if (tmp == -1) {
        write("Unknown thingy '"+rest[0..0]+"'\n");
        return 0;
      }
      ret += ({ tmp+bing, width });
      rest = rest[1..];
      if (strlen(rest))
        ret += ({ STRING, rest });
    } else {
      ret += ({ STRING, bits[i] });
    }
  }
  return ret;
}
private void list_matches() {
  int i;
  for (i=0;i<sizeof(de_names);i++) {
    if (i == STRING) continue;
    printf("%s: %s\n", abbrev[i], de_names[i]);
  }
}
int set_var(string str) {
  string name, type;
  mixed *bing;
  if (str == "help") {
    write("The non helpful help.\nThis is the list of things that go after "+
          "the %'s in the value.\n");
    list_matches();
    return 1;
  }
  if (!str || sscanf(str, "%s %s", name, type) != 2) {
    notify_fail("Syntax: "+query_verb()+" <var_name> <value>\n"+
                "        "+query_verb()+" help\n");
    return 0;
  }
  if (member_array(name, var_names) == -1) {
    notify_fail("You cannot set the var "+name+", it has to be one of "+
                implode(var_names[0..<2], ", ")+" or " + var_names[<1] +
                ".\n");
    return 0;
  }
  bing = create_review(type);
  if (!bing)
    return 1;
  this_player( 1 )->add_property( name +" list", bing );
  write("Ok, set var "+name+" to "+type+".\n");
  return 1;
}

==================================================
FILE: handlers/philosophies.c
==================================================

#define SAVE_FILE "/save/philosophies"
#define SAVE_DIR "/save/philosophies/"
#define PHILOSOPHY_TYPE 0
#define PHILOSOPHY_BONUS 1
#define PHILOSOPHY_NEEDED 2
#define PHILOSOPHY_EFFECT 3
#define PHILOSOPHY_ARGUMENTS 4
nosave string current_person, current_philosophies;
mapping philosophies;
void create() {
  seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   philosophies = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_philosophies() { return philosophies; }
string *query_philosophy_names() { return keys( philosophies ); }
int query_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return 1;
}
void add_philosophy( string name, string type, int bonus, string needed,
      string effect ) {
   philosophies[ name ] = ({ type, bonus, needed, effect, ([ ]) });
   save_me();
}
void remove_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   map_delete( philosophies, name );
   save_me();
}
string query_philosophy_type( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_TYPE ];
}
int query_philosophy_bonus( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_BONUS ];
}
string query_philosophy_needed( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_NEEDED ];
}
string query_philosophy_effect( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_EFFECT ];
}
mapping query_philosophy_all_arguments( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return copy( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ] );
}
mixed query_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ];
}
void add_philosophy_argument( string name, string argument, mixed args ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( !undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] = args;
   save_me();
}
void remove_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   map_delete( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ], argument );
   save_me();
}
string *query_all_known( string person ) {
   string *oldstuff, *newstuff = ({}), key;
  if ( person != current_person ) {
     if(unguarded((: file_length, SAVE_DIR + person[0..0]+"/"+person :)) < 1) {
       current_philosophies = "";
     } else {
       current_philosophies = unguarded((:read_file,
         SAVE_DIR+person[0..0]+"/"+person:));
     }
  }
  oldstuff = explode(current_philosophies, "\n");
  foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
          newstuff += ({ key });
      }
  }
  current_person = person;
  return newstuff;
}
int query_known( string person, string argument ) {
  if(person != current_person) {
    current_philosophies = "";
    if( unguarded( (: file_length,
		    SAVE_DIR + person[0..0]+"/"+person :) ) < 1 ) {
      current_person = person;
      return 0;
    }
    current_person = person;
    current_philosophies =
      unguarded( (: read_file, SAVE_DIR +  person[0..0]+"/"+person :) );
  }
  return (member_array(argument,explode(current_philosophies ,"\n")) != -1);
}
void add_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !query_known( person, argument ) ) {
      if( !current_philosophies ) {
         current_philosophies = "";
      }
      current_philosophies += argument +"\n";
   }
   current_person = person;
   oldstuff = explode(current_philosophies, "\n");
   foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
       newstuff += ({ key });
     }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int remove_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   oldstuff = query_all_known( person );
   current_person = person;
   current_philosophies = "";
   foreach ( key in oldstuff ) {
      if ( member_array( key, newstuff ) == -1 &&
        key != argument ) {
          newstuff += ({ key });
          current_philosophies += sprintf( "%s\n", key );
       }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int reset_known( string person ) {
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   current_person = person;
   current_philosophies = "";
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}

==================================================
FILE: handlers/player_council.c
==================================================

inherit "/obj/handlers/inherit/player_council";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
void load_me();
void save_me();
void create() {
   player_council::create();
   load_me();
}
void save_me() {
   unguarded( (: save_object(NOMIC_SYSTEM_SAVE_FILE) :) );
}
void load_me() {
   unguarded( (: restore_object(NOMIC_SYSTEM_SAVE_FILE, 1) :) );
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/player_handler.c
==================================================

inherit "/global/family";
inherit "/std/living/nationality";
#include <alias.h>
#include <player.h>
#include <login_handler.h>
#include <access.h>
#define MAX_CACHE_SIZE MAX_PLAYERS
#define CACHE_TIMEOUT 900
#define INACTIVE_LIMIT 1209600
#define ILLEGAL ({ "black", "blood", "cyber", "dark", "penis", "cock", "pussy",\
  "fuck", "shit", "death", "deth", "dragon", "fish", "hell", "mage", "pink", "lord",\
  "shadow", "evil", "killer", "slayer" })
private int gender;
private int creator;
private int time_on;
private int last_log_on;
private string last_on_from;
private int activity_counter;
private int start_time;
private string password;
private string deity;
private string guild_ob;
private string cap_name;
private mapping aliases;
private mapping map_prop;
private mapping new_skills;
private mapping player_info;
private mixed *guild_data;
private int _flags;
private string home_dir;
string player_ob;
class player_record {
  int cached;
  int touched;
  int deleting;
  int appealing;
  int gender;
  int creator;
  int active;
  int level;
  string cap_name;
  mapping map_prop;
  mapping player_info;
  string deity;
  string guild;
  mixed *guild_data;
  int age;
  int last;
  int flags;
  string last_on_from;
  int start_time;
  string family_name;
  string player_title;
  string password;
  mixed *project;
  mixed *plan;
  mixed *reference;
  mixed *signature;
  string home_dir;
  string nationality;
  string nationality_region;
  mixed nationality_data;
}
nosave mapping player_cache;
nosave string prev, prev_find, prev_name;
nosave int prev_count, prev_finds, delay;
int requests,
  cache_hits;
void create() {
  seteuid("Root");
  player_ob = "/global/player";
  player_cache = ([ ]);
}
object my_find_player(string player) {
  string *funs, stack = "";
  object *obs;
  int i;
  if(prev_name == player)
    return find_player(player);
  prev_name = player;
  if (base_name(previous_object()) == prev_find && delay > time() - 60 &&
      prev_name == player) {
    prev_finds++;
  } else {
    prev_finds = 1;
    delay = time();
    prev_find = base_name(previous_object());
  }
  if(!(prev_finds % 25)) {
    obs = call_stack(1);
    funs = call_stack(2);
    for(i=0; i<sizeof(obs); i++) {
      if(clonep(obs[i]))
        stack += base_name(obs[i]) + "#" + obs[i]->query_name();
      else
        stack += base_name(obs[i]);
      stack += "->" + funs[i] + "()\n";
    }
    log_file("GARBAGE", "%s %s checked %d players in %d seconds.\n%s",
             ctime(time())[4..18], prev_find, prev_finds, time() - delay,
             stack);
  }
  return find_player(player);
}
void clean_cache() {
  string name;
  foreach(name in keys(player_cache)) {
    if (player_cache[name]->cached < time() - CACHE_TIMEOUT) {
      map_delete(player_cache, name);
    }
  }
}
void remove_cache_entry(string name) {
  map_delete(player_cache, name);
}
private int validate_name(string name) {
  if (!stringp(name) || !name || name == "logon" || name[0] == '.' ||
      (sscanf(name, "%*s %*s") == 2) || strlen(name) < 2) {
    return 0;
  }
  if (sizeof(explode(name, "..")) > 1) {
    return 0;
  }
  return 1;
}
string query_player_file_name(string name) {
#ifdef USE_RAMDISK
  if(PLAYER_RAM_DIR) {
    if(file_size(PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz") == -1) {
      if(file_size(PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz") > -1) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz" :));
      } else if((file_size(PLAYER_SAVE_DIR+name[0..0]+"/"+name+".o") >-1)) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
        unguarded((: compress_file,
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
      }
    }
    return PLAYER_RAM_DIR + name[0..0] + "/" + name;
  }
#endif
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_player_ram_file_name(string name) {
  return PLAYER_RAM_DIR + name[0..0] + "/" + name;
}
string query_player_disk_file_name(string name) {
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_delete_player_file_name(string name) {
   return PLAYER_SAVE_DIR + DELETE_DIR + "/" + name;
}
string query_appeal_player_file_name(string name) {
   return PLAYER_SAVE_DIR + APPEAL_DIR + "/" + name;
}
int load_player(string name) {
  class player_record tmp;
  mixed *file;
  int diff, deleting, appealing;
  string tstr, fname;
  object loaded_guild_ob;
  if (!validate_name(name)) {
    return 0;
  }
  requests++;
  if (player_cache[name]) {
    if (10 * (time() - player_cache[name]->cached) <
        (time() - player_cache[name]->touched)) {
      cache_hits++;
      return 1;
    }
  }
  if(file = unguarded((: get_dir, query_player_ram_file_name(name) + ".o.gz",
                       -1 :)))
    fname = query_player_ram_file_name(name);
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o.gz", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if(!file || !sizeof(file) || file[0][1] < 0)
    return 0;
  if(player_cache[name] && player_cache[name]->touched == file[0][2]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }
  gender = 0;
  creator = 0;
  time_on = 0;
  last_log_on = 0;
  last_on_from = 0;
  activity_counter = 0;
  start_time = 0;
  password = 0;
  deity = 0;
  guild_ob = 0;
  cap_name = 0;
  player_info = ([ ]);
  aliases = ([ ]);
  new_skills = ([ ]);
  map_prop = ([ ]);
  guild_data = 0;
  if (base_name(previous_object()) == prev && delay > time() - 60) {
    prev_count++;
  } else {
    prev_count = 1;
    delay = time();
    prev = base_name(previous_object());
  }
  if (!(prev_count % 25)) {
    tstr = prev;
    if (tstr == "/secure/login" && sizeof(previous_object(-1)) > 1) {
      tstr = base_name(previous_object(-1)[1]);
    }
    log_file("GARBAGE", "%s %s loaded %d player files in %d seconds.\n",
             ctime(time())[4..18], tstr, prev_count, time() - delay);
  }
#ifdef DEBUG
  string ob;
  if (base_name(previous_object()) != "/secure/login") {
    ob = base_name(previous_object());
  } else {
    ob = base_name(previous_object(-1)[1]);
  }
  log_file("CDEBUG", "%s: %O:%O\n", ob, call_stack(1), call_stack(2));
#endif
  if(!unguarded((: restore_object, fname, 1 :)))
    return 0;
  if(fname == query_appeal_player_file_name(name)) {
    appealing = file[0][2];
  } else if(fname == query_delete_player_file_name(name)) {
    deleting = file[0][2];
  }
  tmp = new (class player_record,
             cached: time(),
             touched: file[0][2],
             deleting: deleting,
             appealing: appealing,
             gender: gender,
             creator: creator,
             active: 0,
             level: 0,
             cap_name: cap_name,
             player_info: player_info,
             map_prop: map_prop,
             deity: deity,
             guild: guild_ob,
             guild_data: guild_data,
             flags: _flags,
             age: time_on,
             last: last_log_on,
             last_on_from: last_on_from,
             start_time: start_time,
             family_name: query_family_name(),
             player_title: query_player_title(),
             nationality: query_nationality(),
             nationality_region: query_nationality_region(),
             nationality_data: query_nationality_data(),
             password: password);
  if(aliases) {
    if (aliases[".project"])
      tmp->project = aliases[".project"][0..1023];
    if (aliases[".plan"])
      tmp->plan = aliases[".plan"][0..1023];
    if (aliases[".reference"])
      tmp->reference = aliases[".reference"][0..1023];
    if (aliases[".signature"])
      tmp->signature = aliases[".signature"][0..240];
  }
  diff = (time() - last_log_on) / (3600 * 24 * 7);
  diff *= 10;
  tmp->active = (activity_counter - diff) > -50 ? 1 : 0;
  if (guild_ob) {
    loaded_guild_ob = load_object( guild_ob );
    if ( loaded_guild_ob ) {
        tmp->level = (int) guild_ob->query_level(this_object());
    }
    else {
        tmp->level = 0;
    }
  }
  player_cache[name] = tmp;
  if ((sizeof(player_cache) > MAX_CACHE_SIZE) &&
      (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);
  return 1;
}
string make_string(mixed *al, int max) {
  string str;
  int i;
  int lines;
  str = ALIAS_CMD->alias_string(al);
  sscanf(str, "%s $*$", str);
  str = replace(str, sprintf("%c", 7), "^G");
  str = replace(str, ({ "@@", "@ @ ", "\\;", "$escaped$", ";", "\n",
                          "$escaped$", ";" }));
  for (i = lines = 0; i < sizeof(str) && i < max*80 && lines < max; i++) {
    if (str[i] == '\n' || str[i] == ';') {
      lines++;
    }
  }
  return str[0..i - 1];
}
int test_user(string str) {
  if (player_cache[str])
    return 1;
  if (!validate_name(str))
    return 0;
  return file_size(query_player_disk_file_name(str) + ".o.gz") > 0 ||
    file_size(query_player_disk_file_name(str) + ".o") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o.gz") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o") > 0;
}
int test_deleting(string str) {
  if (player_cache[str])
    return player_cache[str]->deleting;
  if (!validate_name(str))
    return 0;
  if (file_size(query_delete_player_file_name(str) + ".o") > 0)
    return stat(query_delete_player_file_name(str) + ".o")[1];
  if(file_size(query_delete_player_file_name(str) + ".o.gz") > 0)
    return stat(query_delete_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_appealing(string str) {
  if (player_cache[str])
    return player_cache[str]->appealing;
  if (!validate_name(str))
    return 0;
  if (file_size(query_appeal_player_file_name(str) + ".o") > 0)
    return stat(query_appeal_player_file_name(str) + ".o")[1];
  if(file_size(query_appeal_player_file_name(str) + ".o.gz") > 0)
    return stat(query_appeal_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_gender(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_gender();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->gender;
}
varargs int test_active(string player, int noload) {
  mixed *file;
  if (find_player(player)) {
    map_delete(player_cache, player);
    return 1;
  }
  if (noload) {
    if (player_cache[player])
      return player_cache[player]->active;
    file =
      unguarded((: stat,
                 query_player_disk_file_name(player) + ".o" :));
    if (!file || !sizeof(file)) {
      file =
        unguarded((: stat,
                   query_player_disk_file_name(player) + ".o.gz" :));
    }
    return (sizeof(file) && file[1] > time() - INACTIVE_LIMIT);
  }
  if (!load_player(player))
    return 0;
  return player_cache[player]->active;
}
string query_cap_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_cap_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->cap_name;
}
int test_level(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_level();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->level;
}
mixed query_guild_data() {
    return guild_data;
}
int query_skill(string skill) {
  if (mapp(new_skills)) {
    return new_skills[skill];
  }
  return 0;
}
int test_banished(string name) {
  return file_size(BANISH_DIR + name[0..0] + "/" + name + ".o") != -1;
}
varargs int test_valid(string name) {
  string *bits, bit, tname;
  name = lower_case(name);
  tname = replace(name, ({ "'", "", "_", " " }));
  bits = explode(tname, " ");
  name = replace(name, ({ "'", " ", "_", " " }));
  bits += explode(name, " ");
  foreach(bit in bits) {
    if (bit == "the" || bit == "von" || bit == "sto" || bit == "here" ||
    bit == "there" || bit == "time") {
      continue;
    }
    if (test_banished(bit))
      return 0;
  }
  name = replace(name, ({ " ", "" }));
  if (test_banished(name))
    return 0;
  foreach(bit in ILLEGAL) {
    if (strsrch(name, bit) != -1)
      return 0;
  }
  return 1;
}
string test_real_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_real_name();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["real_name"];
}
string test_email(string str) {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..12] != "/secure/login" &&
     file_name(previous_object())[0..13] != "/secure/nlogin")
    return "";
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_email();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["email"];
}
string test_birthday(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_birthday();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["birthday"];
}
string test_location(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_where();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["location"];
}
string test_homepage(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_homepage();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["homepage"];
}
string test_desc(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_desc();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["desc"];
}
mixed test_player_killer(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_player_killer();
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->flags & PLAYER_KILLER_FLAG;
}
mixed test_property(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_property(str);
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->map_prop[str];
}
void special_add_property(string pname, string prop, mixed val) {
  if(player_cache[pname])
    player_cache[pname]->map_prop[prop] = val;
}
string test_deity(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_deity();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->deity;
}
string test_guild(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_ob();
  }
  if (!load_player(word))
    return "";
  return player_cache[word]->guild;
}
mixed *test_guild_data(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_data();
  }
  if (!load_player(word))
    return ({ });
  return player_cache[word]->guild_data;
}
int test_age(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_time_on();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->age;
}
int test_last(string word, int noload) {
  mixed *file;
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_last_log_on();
  }
  if (noload) {
    if (player_cache[word]) {
      return player_cache[word]->last;
    }
    word = replace(word, ({ "/", "", "\\", "" }) );
    file =
      unguarded((: stat, query_player_ram_file_name(word) + ".o" :));
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_player_disk_file_name(word)+".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o.gz" :));
    }
    if (!sizeof(file))
      return 0;
    return file[1];
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last;
}
string test_last_on_from(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return query_ip_name(find_player(word)) + " (" +
      query_ip_number(find_player(word)) + ") ";
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last_on_from;
}
int test_start_time(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_start_time();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->start_time;
}
int test_creator(string str) {
  str = lower_case (str);
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_creator();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->creator;
}
string test_home_dir(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_home_dir();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->home_dir;
}
string test_family(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_family_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->family_name;
}
string test_player_title(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_player_title();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->player_title;
}
int test_password(string name, string pass) {
  if (!load_player(name)) {
    return 0;
  }
  if (find_player(name) && player_cache[name]->password == "") {
    if(file_size(query_player_ram_file_name(name) + ".o.gz") > 0)
      unguarded((: restore_object, query_player_ram_file_name(name), 1 :));
    else
      unguarded((: restore_object, query_player_disk_file_name(name), 1 :));
    player_cache[name]->password = password;
  }
  return crypt(pass, player_cache[name]->password) ==
    player_cache[name]->password;
}
string get_password(string name) {
  if(file_name(previous_object()) != "/secure/ftp_auth")
    return "x";
  if(!load_player(name))
    return "x";
  if(find_player(name) && player_cache[name]->password == "") {
    unguarded((: restore_object,
               query_player_disk_file_name(name), 1 :));
  }
  return player_cache[name]->password;
}
string query_signature(string name) {
  string sig;
  if (find_player(name)) {
    map_delete(player_cache, name);
    sig =
      make_string(find_player(name)->query_player_alias(".signature"),
                  3);
  } else {
    if (!load_player(name))
      return "";
    sig = make_string(player_cache[name]->signature, 3);
  }
  if (sig && sig != "")
    sig = "\n--\n" + strip_colours(sig);
  return sig;
}
string query_project(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".project"))
      return make_string(find_player(name)->query_player_alias(".project"), 5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->project, 5);
}
string query_plan(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".plan"))
      return make_string(find_player(name)->query_player_alias(".plan"),
                         5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->plan, 5);
}
string query_reference(string name) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".reference"))
      return make_string(find_player(name)->
                         query_player_alias(".reference"), 20);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->reference, 20);
}
string test_nationality(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality();
  }
  if (!load_player(str)) {
    return 0;
  }
  return ((class player_record)player_cache[str])->nationality;
}
string test_nationality_region(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_region();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_region;
}
string test_nationality_data(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_data();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_data;
}
int test_ip_allowed(string name, string ip) {
  string *ips;
  if(ip == "127.0.0.1")
    return 1;
  if(find_player(name)) {
    map_delete(player_cache, name);
    ips = find_player(name)->query_rhosts();
  } else if (load_player(name))
    ips = player_cache[name]->player_info["allowed_ips"];
  if(!ips || !sizeof(ips))
    return 1;
  while(strlen(ip)) {
    if(member_array(ip, ips) != -1)
      return 1;
    ip = implode((string *)explode(ip, ".")[0..<2], ".");
  }
  return 0;
}
mixed *stats() {
  int percentage;
  if (requests)
    percentage = (cache_hits * 100) / requests;
  return ({ ({ "cache size", sizeof(player_cache) }),
              ({ "requests", requests }),
              ({ "cache hits", cache_hits }),
              ({ "cache misses", requests - cache_hits }),
              ({ "percentage hits", percentage }), });
}
nomask int query_prevent_shadow(object ob) { return 1; }

==================================================
FILE: handlers/player_shop.c
==================================================

#include <player_shop.h>
#include <mail.h>
#define REFRESH_HANDLER "/obj/handlers/refresh"
#define save_me() unguarded((:write_file, "/save/player_shops", \
                  save_variable(_shops), 1:));
private nosave mapping _shops = 0;
void create()
{
    seteuid("Root");
    if (file_size("/save/player_shops") > 0)
    {
        _shops = restore_variable(unguarded((:read_file,
              "/save/player_shops":)));
    }
}
int add_shop(string short_name, string office_path)
{
    string savedir;
    object ob;
    if (!(ob = find_object(office_path)))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    if (_shops)
    {
        if (_shops[short_name])
        {
            tell_object(this_player(), "Shop already exists.\n");
            return 0;
        }
        _shops += ([short_name:""]);
    }
    else
    {
        _shops = ([short_name:""]);
    }
    _shops[short_name] = office_path;
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    savedir = sprintf("/save/player_housing/%s/",
      lower_case(geteuid(ob)));
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/player_shops");
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/%s", short_name);
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    save_me();
    return 1;
}
int remove_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    map_delete(_shops, short_name);
    save_me();
    return 1;
}
int update_shop(string short_name, string office_path)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    if (!find_object(office_path))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    _shops[short_name] = office_path;
    save_me();
    return 1;
}
string query_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
        return "";
    if (!find_object(_shops[short_name]))
        return "No such file "+ _shops[short_name]+ ".";
    return _shops[short_name];
}
mapping query_shops() { return copy(_shops); }
void auto_mail(string to, string from, string sub, string cc, string body)
{
    if (_shops)
    {
        foreach (string shop in keys(_shops))
        {
            if (_shops[shop] == file_name(previous_object()))
            {
                return MAILER->do_mail_message(to, from, sub, cc, body, 0, 0, 1);
            }
        }
    }
    unguarded((: write_file, "/log/CHEAT",
        "Illegal access to AUTO_MAILER.\n" "Backtrace: " +
        back_trace() :));
}
