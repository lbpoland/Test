# Total Tokens: 25251
# Total Files Merged: 7
# Total Characters: 84185

ilosophies.c
==================================================

#define SAVE_FILE "/save/philosophies"
#define SAVE_DIR "/save/philosophies/"
#define PHILOSOPHY_TYPE 0
#define PHILOSOPHY_BONUS 1
#define PHILOSOPHY_NEEDED 2
#define PHILOSOPHY_EFFECT 3
#define PHILOSOPHY_ARGUMENTS 4
nosave string current_person, current_philosophies;
mapping philosophies;
void create() {
  seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   philosophies = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_philosophies() { return philosophies; }
string *query_philosophy_names() { return keys( philosophies ); }
int query_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return 1;
}
void add_philosophy( string name, string type, int bonus, string needed,
      string effect ) {
   philosophies[ name ] = ({ type, bonus, needed, effect, ([ ]) });
   save_me();
}
void remove_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   map_delete( philosophies, name );
   save_me();
}
string query_philosophy_type( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_TYPE ];
}
int query_philosophy_bonus( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_BONUS ];
}
string query_philosophy_needed( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_NEEDED ];
}
string query_philosophy_effect( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_EFFECT ];
}
mapping query_philosophy_all_arguments( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return copy( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ] );
}
mixed query_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ];
}
void add_philosophy_argument( string name, string argument, mixed args ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( !undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] = args;
   save_me();
}
void remove_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   map_delete( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ], argument );
   save_me();
}
string *query_all_known( string person ) {
   string *oldstuff, *newstuff = ({}), key;
  if ( person != current_person ) {
     if(unguarded((: file_length, SAVE_DIR + person[0..0]+"/"+person :)) < 1) {
       current_philosophies = "";
     } else {
       current_philosophies = unguarded((:read_file,
         SAVE_DIR+person[0..0]+"/"+person:));
     }
  }
  oldstuff = explode(current_philosophies, "\n");
  foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
          newstuff += ({ key });
      }
  }
  current_person = person;
  return newstuff;
}
int query_known( string person, string argument ) {
  if(person != current_person) {
    current_philosophies = "";
    if( unguarded( (: file_length,
		    SAVE_DIR + person[0..0]+"/"+person :) ) < 1 ) {
      current_person = person;
      return 0;
    }
    current_person = person;
    current_philosophies =
      unguarded( (: read_file, SAVE_DIR +  person[0..0]+"/"+person :) );
  }
  return (member_array(argument,explode(current_philosophies ,"\n")) != -1);
}
void add_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !query_known( person, argument ) ) {
      if( !current_philosophies ) {
         current_philosophies = "";
      }
      current_philosophies += argument +"\n";
   }
   current_person = person;
   oldstuff = explode(current_philosophies, "\n");
   foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
       newstuff += ({ key });
     }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int remove_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   oldstuff = query_all_known( person );
   current_person = person;
   current_philosophies = "";
   foreach ( key in oldstuff ) {
      if ( member_array( key, newstuff ) == -1 &&
        key != argument ) {
          newstuff += ({ key });
          current_philosophies += sprintf( "%s\n", key );
       }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int reset_known( string person ) {
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   current_person = person;
   current_philosophies = "";
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}

==================================================
FILE: handlers/player_council.c
==================================================

inherit "/obj/handlers/inherit/player_council";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
void load_me();
void save_me();
void create() {
   player_council::create();
   load_me();
}
void save_me() {
   unguarded( (: save_object(NOMIC_SYSTEM_SAVE_FILE) :) );
}
void load_me() {
   unguarded( (: restore_object(NOMIC_SYSTEM_SAVE_FILE, 1) :) );
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/player_handler.c
==================================================

inherit "/global/family";
inherit "/std/living/nationality";
#include <alias.h>
#include <player.h>
#include <login_handler.h>
#include <access.h>
#define MAX_CACHE_SIZE MAX_PLAYERS
#define CACHE_TIMEOUT 900
#define INACTIVE_LIMIT 1209600
#define ILLEGAL ({ "black", "blood", "cyber", "dark", "penis", "cock", "pussy",\
  "fuck", "shit", "death", "deth", "dragon", "fish", "hell", "mage", "pink", "lord",\
  "shadow", "evil", "killer", "slayer" })
private int gender;
private int creator;
private int time_on;
private int last_log_on;
private string last_on_from;
private int activity_counter;
private int start_time;
private string password;
private string deity;
private string guild_ob;
private string cap_name;
private mapping aliases;
private mapping map_prop;
private mapping new_skills;
private mapping player_info;
private mixed *guild_data;
private int _flags;
private string home_dir;
string player_ob;
class player_record {
  int cached;
  int touched;
  int deleting;
  int appealing;
  int gender;
  int creator;
  int active;
  int level;
  string cap_name;
  mapping map_prop;
  mapping player_info;
  string deity;
  string guild;
  mixed *guild_data;
  int age;
  int last;
  int flags;
  string last_on_from;
  int start_time;
  string family_name;
  string player_title;
  string password;
  mixed *project;
  mixed *plan;
  mixed *reference;
  mixed *signature;
  string home_dir;
  string nationality;
  string nationality_region;
  mixed nationality_data;
}
nosave mapping player_cache;
nosave string prev, prev_find, prev_name;
nosave int prev_count, prev_finds, delay;
int requests,
  cache_hits;
void create() {
  seteuid("Root");
  player_ob = "/global/player";
  player_cache = ([ ]);
}
object my_find_player(string player) {
  string *funs, stack = "";
  object *obs;
  int i;
  if(prev_name == player)
    return find_player(player);
  prev_name = player;
  if (base_name(previous_object()) == prev_find && delay > time() - 60 &&
      prev_name == player) {
    prev_finds++;
  } else {
    prev_finds = 1;
    delay = time();
    prev_find = base_name(previous_object());
  }
  if(!(prev_finds % 25)) {
    obs = call_stack(1);
    funs = call_stack(2);
    for(i=0; i<sizeof(obs); i++) {
      if(clonep(obs[i]))
        stack += base_name(obs[i]) + "#" + obs[i]->query_name();
      else
        stack += base_name(obs[i]);
      stack += "->" + funs[i] + "()\n";
    }
    log_file("GARBAGE", "%s %s checked %d players in %d seconds.\n%s",
             ctime(time())[4..18], prev_find, prev_finds, time() - delay,
             stack);
  }
  return find_player(player);
}
void clean_cache() {
  string name;
  foreach(name in keys(player_cache)) {
    if (player_cache[name]->cached < time() - CACHE_TIMEOUT) {
      map_delete(player_cache, name);
    }
  }
}
void remove_cache_entry(string name) {
  map_delete(player_cache, name);
}
private int validate_name(string name) {
  if (!stringp(name) || !name || name == "logon" || name[0] == '.' ||
      (sscanf(name, "%*s %*s") == 2) || strlen(name) < 2) {
    return 0;
  }
  if (sizeof(explode(name, "..")) > 1) {
    return 0;
  }
  return 1;
}
string query_player_file_name(string name) {
#ifdef USE_RAMDISK
  if(PLAYER_RAM_DIR) {
    if(file_size(PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz") == -1) {
      if(file_size(PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz") > -1) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz" :));
      } else if((file_size(PLAYER_SAVE_DIR+name[0..0]+"/"+name+".o") >-1)) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
        unguarded((: compress_file,
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
      }
    }
    return PLAYER_RAM_DIR + name[0..0] + "/" + name;
  }
#endif
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_player_ram_file_name(string name) {
  return PLAYER_RAM_DIR + name[0..0] + "/" + name;
}
string query_player_disk_file_name(string name) {
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_delete_player_file_name(string name) {
   return PLAYER_SAVE_DIR + DELETE_DIR + "/" + name;
}
string query_appeal_player_file_name(string name) {
   return PLAYER_SAVE_DIR + APPEAL_DIR + "/" + name;
}
int load_player(string name) {
  class player_record tmp;
  mixed *file;
  int diff, deleting, appealing;
  string tstr, fname;
  object loaded_guild_ob;
  if (!validate_name(name)) {
    return 0;
  }
  requests++;
  if (player_cache[name]) {
    if (10 * (time() - player_cache[name]->cached) <
        (time() - player_cache[name]->touched)) {
      cache_hits++;
      return 1;
    }
  }
  if(file = unguarded((: get_dir, query_player_ram_file_name(name) + ".o.gz",
                       -1 :)))
    fname = query_player_ram_file_name(name);
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o.gz", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if(!file || !sizeof(file) || file[0][1] < 0)
    return 0;
  if(player_cache[name] && player_cache[name]->touched == file[0][2]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }
  gender = 0;
  creator = 0;
  time_on = 0;
  last_log_on = 0;
  last_on_from = 0;
  activity_counter = 0;
  start_time = 0;
  password = 0;
  deity = 0;
  guild_ob = 0;
  cap_name = 0;
  player_info = ([ ]);
  aliases = ([ ]);
  new_skills = ([ ]);
  map_prop = ([ ]);
  guild_data = 0;
  if (base_name(previous_object()) == prev && delay > time() - 60) {
    prev_count++;
  } else {
    prev_count = 1;
    delay = time();
    prev = base_name(previous_object());
  }
  if (!(prev_count % 25)) {
    tstr = prev;
    if (tstr == "/secure/login" && sizeof(previous_object(-1)) > 1) {
      tstr = base_name(previous_object(-1)[1]);
    }
    log_file("GARBAGE", "%s %s loaded %d player files in %d seconds.\n",
             ctime(time())[4..18], tstr, prev_count, time() - delay);
  }
#ifdef DEBUG
  string ob;
  if (base_name(previous_object()) != "/secure/login") {
    ob = base_name(previous_object());
  } else {
    ob = base_name(previous_object(-1)[1]);
  }
  log_file("CDEBUG", "%s: %O:%O\n", ob, call_stack(1), call_stack(2));
#endif
  if(!unguarded((: restore_object, fname, 1 :)))
    return 0;
  if(fname == query_appeal_player_file_name(name)) {
    appealing = file[0][2];
  } else if(fname == query_delete_player_file_name(name)) {
    deleting = file[0][2];
  }
  tmp = new (class player_record,
             cached: time(),
             touched: file[0][2],
             deleting: deleting,
             appealing: appealing,
             gender: gender,
             creator: creator,
             active: 0,
             level: 0,
             cap_name: cap_name,
             player_info: player_info,
             map_prop: map_prop,
             deity: deity,
             guild: guild_ob,
             guild_data: guild_data,
             flags: _flags,
             age: time_on,
             last: last_log_on,
             last_on_from: last_on_from,
             start_time: start_time,
             family_name: query_family_name(),
             player_title: query_player_title(),
             nationality: query_nationality(),
             nationality_region: query_nationality_region(),
             nationality_data: query_nationality_data(),
             password: password);
  if(aliases) {
    if (aliases[".project"])
      tmp->project = aliases[".project"][0..1023];
    if (aliases[".plan"])
      tmp->plan = aliases[".plan"][0..1023];
    if (aliases[".reference"])
      tmp->reference = aliases[".reference"][0..1023];
    if (aliases[".signature"])
      tmp->signature = aliases[".signature"][0..240];
  }
  diff = (time() - last_log_on) / (3600 * 24 * 7);
  diff *= 10;
  tmp->active = (activity_counter - diff) > -50 ? 1 : 0;
  if (guild_ob) {
    loaded_guild_ob = load_object( guild_ob );
    if ( loaded_guild_ob ) {
        tmp->level = (int) guild_ob->query_level(this_object());
    }
    else {
        tmp->level = 0;
    }
  }
  player_cache[name] = tmp;
  if ((sizeof(player_cache) > MAX_CACHE_SIZE) &&
      (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);
  return 1;
}
string make_string(mixed *al, int max) {
  string str;
  int i;
  int lines;
  str = ALIAS_CMD->alias_string(al);
  sscanf(str, "%s $*$", str);
  str = replace(str, sprintf("%c", 7), "^G");
  str = replace(str, ({ "@@", "@ @ ", "\\;", "$escaped$", ";", "\n",
                          "$escaped$", ";" }));
  for (i = lines = 0; i < sizeof(str) && i < max*80 && lines < max; i++) {
    if (str[i] == '\n' || str[i] == ';') {
      lines++;
    }
  }
  return str[0..i - 1];
}
int test_user(string str) {
  if (player_cache[str])
    return 1;
  if (!validate_name(str))
    return 0;
  return file_size(query_player_disk_file_name(str) + ".o.gz") > 0 ||
    file_size(query_player_disk_file_name(str) + ".o") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o.gz") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o") > 0;
}
int test_deleting(string str) {
  if (player_cache[str])
    return player_cache[str]->deleting;
  if (!validate_name(str))
    return 0;
  if (file_size(query_delete_player_file_name(str) + ".o") > 0)
    return stat(query_delete_player_file_name(str) + ".o")[1];
  if(file_size(query_delete_player_file_name(str) + ".o.gz") > 0)
    return stat(query_delete_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_appealing(string str) {
  if (player_cache[str])
    return player_cache[str]->appealing;
  if (!validate_name(str))
    return 0;
  if (file_size(query_appeal_player_file_name(str) + ".o") > 0)
    return stat(query_appeal_player_file_name(str) + ".o")[1];
  if(file_size(query_appeal_player_file_name(str) + ".o.gz") > 0)
    return stat(query_appeal_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_gender(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_gender();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->gender;
}
varargs int test_active(string player, int noload) {
  mixed *file;
  if (find_player(player)) {
    map_delete(player_cache, player);
    return 1;
  }
  if (noload) {
    if (player_cache[player])
      return player_cache[player]->active;
    file =
      unguarded((: stat,
                 query_player_disk_file_name(player) + ".o" :));
    if (!file || !sizeof(file)) {
      file =
        unguarded((: stat,
                   query_player_disk_file_name(player) + ".o.gz" :));
    }
    return (sizeof(file) && file[1] > time() - INACTIVE_LIMIT);
  }
  if (!load_player(player))
    return 0;
  return player_cache[player]->active;
}
string query_cap_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_cap_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->cap_name;
}
int test_level(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_level();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->level;
}
mixed query_guild_data() {
    return guild_data;
}
int query_skill(string skill) {
  if (mapp(new_skills)) {
    return new_skills[skill];
  }
  return 0;
}
int test_banished(string name) {
  return file_size(BANISH_DIR + name[0..0] + "/" + name + ".o") != -1;
}
varargs int test_valid(string name) {
  string *bits, bit, tname;
  name = lower_case(name);
  tname = replace(name, ({ "'", "", "_", " " }));
  bits = explode(tname, " ");
  name = replace(name, ({ "'", " ", "_", " " }));
  bits += explode(name, " ");
  foreach(bit in bits) {
    if (bit == "the" || bit == "von" || bit == "sto" || bit == "here" ||
    bit == "there" || bit == "time") {
      continue;
    }
    if (test_banished(bit))
      return 0;
  }
  name = replace(name, ({ " ", "" }));
  if (test_banished(name))
    return 0;
  foreach(bit in ILLEGAL) {
    if (strsrch(name, bit) != -1)
      return 0;
  }
  return 1;
}
string test_real_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_real_name();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["real_name"];
}
string test_email(string str) {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..12] != "/secure/login" &&
     file_name(previous_object())[0..13] != "/secure/nlogin")
    return "";
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_email();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["email"];
}
string test_birthday(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_birthday();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["birthday"];
}
string test_location(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_where();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["location"];
}
string test_homepage(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_homepage();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["homepage"];
}
string test_desc(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_desc();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["desc"];
}
mixed test_player_killer(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_player_killer();
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->flags & PLAYER_KILLER_FLAG;
}
mixed test_property(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_property(str);
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->map_prop[str];
}
void special_add_property(string pname, string prop, mixed val) {
  if(player_cache[pname])
    player_cache[pname]->map_prop[prop] = val;
}
string test_deity(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_deity();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->deity;
}
string test_guild(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_ob();
  }
  if (!load_player(word))
    return "";
  return player_cache[word]->guild;
}
mixed *test_guild_data(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_data();
  }
  if (!load_player(word))
    return ({ });
  return player_cache[word]->guild_data;
}
int test_age(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_time_on();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->age;
}
int test_last(string word, int noload) {
  mixed *file;
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_last_log_on();
  }
  if (noload) {
    if (player_cache[word]) {
      return player_cache[word]->last;
    }
    word = replace(word, ({ "/", "", "\\", "" }) );
    file =
      unguarded((: stat, query_player_ram_file_name(word) + ".o" :));
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_player_disk_file_name(word)+".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o.gz" :));
    }
    if (!sizeof(file))
      return 0;
    return file[1];
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last;
}
string test_last_on_from(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return query_ip_name(find_player(word)) + " (" +
      query_ip_number(find_player(word)) + ") ";
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last_on_from;
}
int test_start_time(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_start_time();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->start_time;
}
int test_creator(string str) {
  str = lower_case (str);
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_creator();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->creator;
}
string test_home_dir(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_home_dir();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->home_dir;
}
string test_family(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_family_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->family_name;
}
string test_player_title(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_player_title();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->player_title;
}
int test_password(string name, string pass) {
  if (!load_player(name)) {
    return 0;
  }
  if (find_player(name) && player_cache[name]->password == "") {
    if(file_size(query_player_ram_file_name(name) + ".o.gz") > 0)
      unguarded((: restore_object, query_player_ram_file_name(name), 1 :));
    else
      unguarded((: restore_object, query_player_disk_file_name(name), 1 :));
    player_cache[name]->password = password;
  }
  return crypt(pass, player_cache[name]->password) ==
    player_cache[name]->password;
}
string get_password(string name) {
  if(file_name(previous_object()) != "/secure/ftp_auth")
    return "x";
  if(!load_player(name))
    return "x";
  if(find_player(name) && player_cache[name]->password == "") {
    unguarded((: restore_object,
               query_player_disk_file_name(name), 1 :));
  }
  return player_cache[name]->password;
}
string query_signature(string name) {
  string sig;
  if (find_player(name)) {
    map_delete(player_cache, name);
    sig =
      make_string(find_player(name)->query_player_alias(".signature"),
                  3);
  } else {
    if (!load_player(name))
      return "";
    sig = make_string(player_cache[name]->signature, 3);
  }
  if (sig && sig != "")
    sig = "\n--\n" + strip_colours(sig);
  return sig;
}
string query_project(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".project"))
      return make_string(find_player(name)->query_player_alias(".project"), 5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->project, 5);
}
string query_plan(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".plan"))
      return make_string(find_player(name)->query_player_alias(".plan"),
                         5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->plan, 5);
}
string query_reference(string name) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".reference"))
      return make_string(find_player(name)->
                         query_player_alias(".reference"), 20);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->reference, 20);
}
string test_nationality(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality();
  }
  if (!load_player(str)) {
    return 0;
  }
  return ((class player_record)player_cache[str])->nationality;
}
string test_nationality_region(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_region();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_region;
}
string test_nationality_data(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_data();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_data;
}
int test_ip_allowed(string name, string ip) {
  string *ips;
  if(ip == "127.0.0.1")
    return 1;
  if(find_player(name)) {
    map_delete(player_cache, name);
    ips = find_player(name)->query_rhosts();
  } else if (load_player(name))
    ips = player_cache[name]->player_info["allowed_ips"];
  if(!ips || !sizeof(ips))
    return 1;
  while(strlen(ip)) {
    if(member_array(ip, ips) != -1)
      return 1;
    ip = implode((string *)explode(ip, ".")[0..<2], ".");
  }
  return 0;
}
mixed *stats() {
  int percentage;
  if (requests)
    percentage = (cache_hits * 100) / requests;
  return ({ ({ "cache size", sizeof(player_cache) }),
              ({ "requests", requests }),
              ({ "cache hits", cache_hits }),
              ({ "cache misses", requests - cache_hits }),
              ({ "percentage hits", percentage }), });
}
nomask int query_prevent_shadow(object ob) { return 1; }

==================================================
FILE: handlers/player_shop.c
==================================================

#include <player_shop.h>
#include <mail.h>
#define REFRESH_HANDLER "/obj/handlers/refresh"
#define save_me() unguarded((:write_file, "/save/player_shops", \
                  save_variable(_shops), 1:));
private nosave mapping _shops = 0;
void create()
{
    seteuid("Root");
    if (file_size("/save/player_shops") > 0)
    {
        _shops = restore_variable(unguarded((:read_file,
              "/save/player_shops":)));
    }
}
int add_shop(string short_name, string office_path)
{
    string savedir;
    object ob;
    if (!(ob = find_object(office_path)))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    if (_shops)
    {
        if (_shops[short_name])
        {
            tell_object(this_player(), "Shop already exists.\n");
            return 0;
        }
        _shops += ([short_name:""]);
    }
    else
    {
        _shops = ([short_name:""]);
    }
    _shops[short_name] = office_path;
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    savedir = sprintf("/save/player_housing/%s/",
      lower_case(geteuid(ob)));
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/player_shops");
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/%s", short_name);
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    save_me();
    return 1;
}
int remove_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    map_delete(_shops, short_name);
    save_me();
    return 1;
}
int update_shop(string short_name, string office_path)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    if (!find_object(office_path))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    _shops[short_name] = office_path;
    save_me();
    return 1;
}
string query_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
        return "";
    if (!find_object(_shops[short_name]))
        return "No such file "+ _shops[short_name]+ ".";
    return _shops[short_name];
}
mapping query_shops() { return copy(_shops); }
void auto_mail(string to, string from, string sub, string cc, string body)
{
    if (_shops)
    {
        foreach (string shop in keys(_shops))
        {
            if (_shops[shop] == file_name(previous_object()))
            {
                return MAILER->do_mail_message(to, from, sub, cc, body, 0, 0, 1);
            }
        }
    }
    unguarded((: write_file, "/log/CHEAT",
        "Illegal access to AUTO_MAILER.\n" "Backtrace: " +
        back_trace() :));
}

==================================================
FILE: handlers/playerinfo.c
==================================================

#include <playerinfo.h>
#include <player_handler.h>
#include <refresh.h>
#include <applications.h>
#include <newbiehelpers.h>
#define SAVE_DIR         "/save/playerinfo"
#define SAVE_FILE        ( SAVE_DIR + "/handler_data" )
#define NO_ACCESS_LOG    6
#define LIAISON_WAND       "/d/liaison/items/wand"
#define LIAISON_SCEPTRE    "/d/liaison/items/mort_sceptre"
#define LIAISON_PEN        "/d/liaison/items/quota_pen"
#define LIAISON_INTERVIEW  "/d/liaison/utils/interview"
#define MULTIPLAY          "/obj/handlers/multiplayer"
#define GAG                "/cmds/creator/gag"
#define UNGAG              "/cmds/creator/ungag"
#define METEOR             "/cmds/creator/meteor"
#define FRY                "/cmds/creator/fry"
#define REPORT_COMMAND     "/cmds/creator/playerinfo"
#define ADD_COMMAND        "/cmds/creator/addevent"
#define DELETE_COMMAND     "/cmds/creator/delevent"
#define ADDALT_COMMAND     "/cmds/creator/addalt"
#define DELALT_COMMAND     "/cmds/creator/delalt"
#define FAMILY_COMMAND     "/cmds/creator/family"
#define SUSPENDER          "/secure/bastards"
#define SHOWHELP_COMMAND   "/cmds/creator/show_help"
#define PATRICIAN_PALACE   "/d/am/patrician/patrician"
#define REFRESH_HANDLER    "/obj/handlers/refresh"
#define PRISON             "/d/sur/beta/prison/dungeon"
#define FETCH_COMMAND      "/cmds/creator/fetch"
#define REARRANGE_COMMAND  "/cmds/guild-race/rearrange"
#define PATRICIAN_PT       "/d/playtesters/handlers/applications"
#define PATRICIAN_COMPLAIN "/d/am/patrician/pat_complaints"
#define RUN_HANDLER        "/obj/handlers/guild_things/run"
#define BANISH_COMMAND     "/secure/cmds/creator/banish"
#define FAIRY_GODMOTHER    "/obj/handlers/fairy_godmothers"
#define CACHE_SIZE 150
#define CL_CREATOR      "%^CYAN%^"
#define CL_EVENT        "%^RED%^"
#define CL_RESET        "%^RESET%^"
#define CL_HEADER       "%^RED%^"
#define DEBOUNCE_PERIOD (60*30)
#define TIMEOUT_PERIOD  (60*60*24)
#define ONE_WEEK           ( 60 * 60 * 24 * 7 )
nosave inherit "/std/object";
mapping          query_timeouts();
protected string filename(string name);
string *         query_events();
protected int    query_debounced(string event);
protected int    query_lord_only(string event);
int              query_source_ok(string event, string source);
protected int    query_deleter_ok(string event, object deleter);
protected int    query_can_add(string e, object p);
protected int    query_can_delete(string e, object p);
protected int    query_can_handle_alts(object p);
protected void   do_debouncing(string player, class dbentry entry);
protected void   do_timeout();
protected void   load_player(string player);
protected void   save_player(string player);
void             player_remove(string player);
int              add_entry(object creator, string player, string event,
                   string comment, mixed *extra);
int              delete_entry(object creator, string player, string event,
                   int n);
protected string query_header(string player);
protected string query_entry(int idx, class dbentry e,
                   string display_name);
string           query_access_log(object source, string player, int lastn);
string           query_event(object source, string player, string event);
string           add_alt(object creator, string player, string alt);
string           delete_alt(object creator, string player, string alt);
mapping          query_alerts();
int              query_alerts_for( string player );
int              is_alert( string player, int idx );
int              acknowledge_alert( object creator, string player,
                   string event, int idx, string update, mixed * extra );
void             clear_alerts_for( string player );
int              increment_alerts_for( string player );
int              decrement_alerts_for( string player );
void             correct_alts_for( string player );
void player_deleted(mixed player, int deleted);
void fix_alts(mixed player);
class source {
   string *add;
   string *delete;
}
private class playerinfo    dossier;
private nosave mapping      timeouts    = ([ "replace" : (60*60*24*30) ]);
private int local_time;
private nosave mapping _sources;
nosave mapping _alerts;
nosave string * _lordonly;
private nosave int correcting_alts;
private nosave int no_recurse;
private nosave mapping _dossier_cache;
private nosave int _dossier_cache_hits;
private nosave int _dossier_total;
void save_handler_data() {
   mapping vars = ([ ]);
   string tmp;
   vars["alerts"] = _alerts;
   tmp = save_variable( vars );
   unguarded( (: write_file, SAVE_FILE, tmp, 1 :) );
}
void load_handler_data() {
   mapping vars;
   string tmp;
   if( file_size( SAVE_FILE ) <= 0 )
      return;
   tmp = unguarded( (: read_file, SAVE_FILE :) );
   vars = restore_variable( tmp );
   _alerts = vars["alerts"];
}
void create() {
    ::create();
    _sources = ([
        "cheat":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "discipline":   new(class source,
                            add : ({ ADD_COMMAND, PRISON, REPORT_COMMAND,
                                     BANISH_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "email":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "family":       new(class source,
                            add : ({ FAMILY_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "gag":          new(class source,
                            add : ({ GAG, UNGAG,
                                     ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "harassment":   new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "meteor":       new(class source,
                            add : ({ METEOR, FRY }),
                            delete : ({ DELETE_COMMAND })),
        "misc":         new(class source,
                            add : ({ ADD_COMMAND, APPLICATIONS_HANDLER,
                                     REARRANGE_COMMAND, PATRICIAN_PT,
                                     PATRICIAN_COMPLAIN, RUN_HANDLER,
                                     REPORT_COMMAND, NEWBIEHELPERS_HANDLER,
                                     LIAISON_SCEPTRE,
                                     LIAISON_PEN, FAIRY_GODMOTHER,
                                     LIAISON_INTERVIEW }),
                            delete : ({ DELETE_COMMAND })),
        "multiplay":    new(class source,
                            add : ({ MULTIPLAY, ADD_COMMAND,
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "replace":      new(class source,
                            add : ({ LIAISON_WAND,
                                     ADD_COMMAND, FETCH_COMMAND,
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "showhelp":     new(class source,
                            add : ({ SHOWHELP_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "suspend":      new(class source,
                            add : ({ SUSPENDER }),
                            delete : ({ })),
        "alert":        new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "refresh":      new(class source,
                            add : ({ REFRESH_HANDLER }),
                            delete : ({ DELETE_COMMAND })),
        "delete":      new(class source,
                           add : ({ REFRESH_HANDLER }),
                           delete : ({ DELETE_COMMAND }))
    ]);
    _alerts = ([ ]);
    _lordonly = ({ });
    _dossier_cache = ([ ]);
    _dossier_cache_hits = 0;
    _dossier_total = 0;
    seteuid("Room");
    load_handler_data();
}
mapping query_timeouts() {
    return timeouts;
}
string query_name() {
    return "playerinfo handler";
}
protected string filename(string name) {
    string p = lower_case(name);
    return sprintf("%s/%c/%s.o",SAVE_DIR,p[0],p);
}
string *query_events() {
    return keys(_sources);
}
protected int query_debounced(string event) {
    return (event == "replace" || event == "multiplay" ||
            event == "gag" || event == "misc" ||
            event == "discipline" || event == "showhelp" ||
            event == "suspend");
}
protected int query_lord_only(string event) {
    return ( member_array( event, _lordonly ) >= 0 ) ? 1 : 0;
}
int query_source_ok(string event, string source) {
    string *reqd;
    reqd = _sources[event]->add;
    if(reqd == 0) {
        return 1;
    }
    if(sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(source,reqd) >= 0;
}
protected int query_deleter_ok(string event, object deleter) {
    string *reqd;
    reqd = _sources[event]->delete;
    if (reqd == 0) {
        return 1;
    }
    if (sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(base_name(deleter),reqd) >= 0;
}
protected int query_can_add(string e, object p) {
    if(member_array(e,query_events()) < 0)
        return 0;
    if(!interactive(p))
        return 1;
    return !(query_lord_only(e) && !p->query_lord());
}
protected int query_can_delete(string e, object p) {
    if( !interactive(p) ) {
        return 1;
    }
    if( e == "misc" || e == "replace" ) {
        return master()->query_senior( p->query_name() ) ||
               "/d/liaison/master"->query_deputy( p->query_name() );
    }
    return p->query_lord();
}
protected int query_can_handle_alts(object p) {
    if( !interactive(p) ) {
        return 1;
    }
    return master()->query_senior( p->query_name() ) ||
           "/d/liaison/master"->query_deputy( p->query_name() );
}
protected void do_debouncing(string player, class dbentry entry) {
    int             n;
    class dbentry   last;
    if (query_debounced(entry->event)) {
        n = sizeof(dossier->data);
        if ( n ) {
            last = dossier->data[ n - 1 ];
            if( entry->event == last->event &&
                entry->creator == last->creator &&
                entry->time - last->time <= DEBOUNCE_PERIOD)
            {
                last->comment += entry->comment;
                last->time = entry->time;
                if(last->extra != 0) {
                    if(entry->extra == 0) {
                        entry->extra = ({ });
                    }
                    last->extra += entry->extra;
                }
                return;
            }
        }
    }
    dossier->data += ({ entry });
    return;
}
protected void do_timeout() {
    function not_timed_out = function(class dbentry p)
    {
        int life = timeouts[p->event];
        if(life == 0)
            return 1;
        return local_time <= (p->time + life);
    };
    local_time = time();
    dossier->data = filter(dossier->data, not_timed_out);
    dossier->last_check = time();
}
protected void load_player(string player) {
    string  p = lower_case(player);
    string  fn = filename(p);
    class playerinfo tmp;
    mixed result;
    _dossier_total++;
    if ( !undefinedp(_dossier_cache[ player ] ) ) {
        dossier = _dossier_cache[ player ];
        _dossier_cache_hits++;
        return;
    }
    if( dossier != 0 && dossier->name == p ) {
        return;
    }
    if(file_size(fn) > 0) {
        result = unguarded( (: restore_object, fn, 0 :) );
    } else {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }
    if (!classp(dossier)) {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }
    if(sizeof(dossier) == 5) {
      tmp = new(class playerinfo,
                name: dossier->name,
                last_check: dossier->last_check,
                alts: copy(dossier->alts),
                data: copy(dossier->data),
                main_alt: dossier->main_alt,
                old_alts: ({ }));
      dossier = tmp;
    }
    if(!dossier->old_alts)
      dossier->old_alts = ({ });
    if(!correcting_alts) {
        correct_alts_for( dossier->name );
    }
    _dossier_cache[ player ] = dossier;
}
protected void save_player(string player) {
    if( time() - dossier->last_check >= TIMEOUT_PERIOD ) {
        do_timeout();
    }
    unguarded( (: save_object, filename(player) :) );
}
void player_remove(string player) {
    string alt, new_main;
    string * alts;
    if ( !player ) {
        return;
    }
    player = lower_case( player );
    correcting_alts = 1;
    load_player( player );
    if ( sizeof( dossier->alts ) ) {
        alts = copy( dossier->alts );
        new_main = alts[0];
        alts -= ({ new_main });
        load_player( new_main );
        dossier->main_alt = 0;
        dossier->alts = uniq_array( alts + ({ player }) );
        save_player( new_main );
        foreach( alt in alts ) {
            load_player( alt );
            dossier->main_alt = new_main;
            save_player( alt );
        }
    }
    correcting_alts = 0;
    unguarded( (: rm, filename(player) :) );
    clear_alerts_for(player);
}
int add_entry(object creator, string player, string event, string comment,
  mixed *extra) {
    class dbentry   new_entry;
    if(!query_can_add(event,creator))
        return 0;
    if(!query_source_ok(event,base_name(previous_object())))
        return 0;
    if(!PLAYER_HANDLER->test_user(lower_case(player)))
        return 0;
    if(comment[<1..<1] != "\n") {
        comment += "\n";
    }
    load_player(player);
    new_entry = new(class dbentry,
            time:       time(),
            creator:    capitalize(creator->query_name()),
            event:      event,
            comment:    (comment == 0 ? "" : comment),
            extra:      extra);
    do_debouncing(player, new_entry);
    save_player(player);
    if( event == "alert" )
        increment_alerts_for(player);
    return 1;
}
int delete_entry(object creator, string player, string event, int n) {
   int idx = n - 1;
   class dbentry * data;
   class dbentry fluff;
   if( !query_can_delete( event, creator ) )
      return 0;
   if( !query_deleter_ok( event, previous_object() ) )
      return 0;
   load_player(player);
   if( ( idx < 0 ) || ( idx >= sizeof( dossier->data ) ) )
      return 0;
   fluff =  dossier->data[idx];
   if( fluff->event != event )
      return 0;
   data = copy( dossier->data );
   data = data[0 .. (idx - 1)] + data[(idx + 1) .. <1];
   dossier->data = data;
   save_player(player);
   log_file("DELETE", ctime(time()) + ": " + event + " added by " +
            fluff->creator + "\n");
   if( event == "alert" )
      decrement_alerts_for(player);
   return 1;
}
protected string query_header( string player ) {
  string aka, alts, str;
  string *tmp, *tmp2;
  aka = alts = str = "";
  if( sizeof( dossier->alts ) > 0 )
    alts = " aka " +
      query_multiple_short(map(dossier->alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :)));
  if(sizeof(dossier->old_alts) > 0)
    alts += " (and was " +
      query_multiple_short(map(dossier->old_alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :))) + ")";
  if( dossier->main_alt ) {
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      fix_alts(player);
      load_player(player);
    }
    aka = " (alt of " + CL_HEADER + capitalize(dossier->main_alt) + CL_RESET;
    load_player(dossier->main_alt);
    tmp = copy(dossier->alts);
    tmp2 = copy(dossier->old_alts);
    if(!tmp) {
      tmp = ({ });
      dossier->alts = ({ });
      save_player( dossier->name );
    }
    load_player(player);
    tmp -= ({ player });
    if(sizeof(tmp))
      aka += ", aka " +
        query_multiple_short(map(tmp, (: CL_HEADER+capitalize($1)+CL_RESET :)));
    if( arrayp( tmp2 ) ) {
      tmp2 -= ({ player });
      if(sizeof(tmp2)) {
        aka += " and was " +
          query_multiple_short(map(tmp2, (: CL_HEADER+capitalize($1)+CL_RESET:)));
      }
    }
    aka += ")";
  }
  return sprintf( "Report for: %s%s%s\n\n",
                  CL_HEADER + capitalize(player) + CL_RESET, alts, aka );
}
protected string query_entry( int idx, class dbentry e,
                              string display_name ) {
   string  date      = ctime( e->time );
   string  creator   = e->creator;
   string  event     = e->event;
   string  *comments = explode( e->comment, "\n" );
   string  line, str;
   int     lines = 0;
   if( display_name )
      display_name = sprintf( "%-31s ",
        "(" + CL_CREATOR + display_name + CL_RESET + ")" );
   else
      display_name = "";
   str = sprintf( "%2d. %s%s %s%|14s%s (by %s%s%s)\n",
     idx + 1, display_name, date, CL_EVENT, event, CL_RESET,
     CL_CREATOR, creator, CL_RESET );
   foreach( line in comments ) {
      if( sizeof(line) != 0 ) {
         str += sprintf( "    %s\n", line );
         lines++;
      }
   }
   if( !lines ) {
      str += sprintf( "    (no comments)\n" );
   }
   return str;
}
varargs string query_dossier( object source, string player, int lastn ) {
   int             i;
   class dbentry   * list;
   string          msg, str;
   mapping         log;
   load_player(player);
   str = query_header(player);
   list = dossier->data;
   if ( sizeof( dossier ) == NO_ACCESS_LOG ) {
    dossier = new ( class playerinfo,
        name: dossier->name,
        last_check: dossier->last_check,
        alts: dossier->alts,
        data: dossier->data,
        main_alt: dossier->main_alt,
        old_alts: dossier->old_alts,
        access_log: ([ ]) );
   }
   if ( mapp( dossier->access_log ) )
     log = dossier->access_log;
   else
     log = ([ ]);
   if( !lastn ||
       sizeof(list) <= lastn ||
       source->query_property(VERBOSE_PI) )
   {
      i = 0;
   } else {
      i = sizeof(list) - lastn;
      msg = "%^RED%^NOTE:%^RESET%^ Only displaying this player's most "
        "recent " + lastn + " entries.  Use 'playerinfo "
        + player + " verbose' to see their entire dossier.\n";
      str += msg + "\n";
   }
   for( ; i < sizeof( list ); i++ ) {
      str += query_entry( i, list[i], 0 );
   }
   if( msg ) {
      str += "\n" + msg;
   }
   log = filter( log, (: $2 > time() - ONE_WEEK :) );
   if ( interactive( source ) )
     log[ source->query_name() ] = time();
  dossier->access_log = log;
  save_player( player );
  return str;
}
string query_event( object source, string player, string event ) {
   int             i;
   class dbentry   *list;
   string          str;
   load_player(player);
   str = query_header(player);
   list = dossier->data;
   for( i = 0; i < sizeof(list); i++ ) {
      if( list[i]->event == event )
         str += query_entry( i, list[i], 0 );
   }
   return str;
}
string query_interleaved( object source, string player, string event ) {
   class playerinfo * dossiers;
   class dbentry * stuff;
   string str;
   string * alts;
   int i, size, done, earliest, earliestt, count;
   int * earliests;
   load_player(player);
   if( dossier->main_alt ) {
      player = dossier->main_alt;
      load_player(player);
   }
   str = query_header(player);
   alts = ({ player }) + copy( dossier->alts );
   size = sizeof(alts);
   if( size == 1 ) {
      if(event) {
        str = query_event( source, player, event );
      } else {
        str = query_dossier( source, player );
      }
      return str;
   }
   dossiers = allocate(size);
   earliests = allocate(size);
   for( i = 0; i < size; i++ ) {
     load_player( alts[i] );
     if( sizeof( dossier->data ) ) {
       dossiers[i] = copy(dossier);
     } else {
       dossiers[i] = 0;
     }
     earliests[i] = 0;
   }
   count = 0;
   while( !done ) {
      done = 1;
      earliestt = 0;
      for( i = 0; i < size; i++ ) {
         if( !dossiers[i] ) {
            continue;
         }
         done = 0;
         stuff = dossiers[i]->data;
         if( !earliestt || stuff[ earliests[i] ]->time < earliestt ) {
            earliest = i;
            earliestt = stuff[ earliests[i] ]->time;
         }
      }
      if(done) {
         continue;
      }
      stuff = dossiers[earliest]->data;
      if( !event ||
          stuff[ earliests[earliest] ]->event == event )
      {
         str += query_entry( count, stuff[ earliests[earliest] ],
                             alts[earliest] );
         count++;
      }
      earliests[earliest]++;
      if( earliests[earliest] >= sizeof(stuff) ) {
         dossiers[earliest] = 0;
      }
   }
   return str;
}
string query_alt_of(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return 0;
  load_player(player);
  return dossier->main_alt;
}
string *query_alts(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return ({ });
  load_player(player);
  return dossier->alts;
}
string add_alt(object creator, string player, string alt) {
  class dbentry new_entry;
  int is_deleted;
  string *alts, tmp;
  if((base_name(previous_object()) != "/cmds/player/register") &&
     !query_can_handle_alts(this_player()))
    return "You are not allowed to add players' alts.\n";
  alt = lower_case(alt);
  if(!find_player(alt) && !PLAYER_HANDLER->test_user(alt)) {
    if(!creator)
      return "No such player: " + capitalize(alt) + ".\n";
    if(file_size(filename(alt)) == -1)
      return "No such player and no record for: " + capitalize(alt) + ".\n";
    is_deleted = 1;
  }
  load_player(alt);
  if(dossier->main_alt && PLAYER_HANDLER->test_user(dossier->main_alt) &&
     !is_deleted)
    return capitalize(alt) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";
  if(sizeof(dossier->alts)) {
    if(is_deleted)
      return capitalize(alt) + " already has alts.\n";
    else {
      alts = dossier->alts + dossier->old_alts;
    }
  }
  player = lower_case(player);
  if(!find_player(player) && !PLAYER_HANDLER->test_user(player))
    return "No such player: "+ capitalize(player) +".\n";
  correcting_alts = 1;
  load_player(player);
  if(dossier->main_alt == alt) {
    correcting_alts = 0;
    return capitalize(player) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";
  }
  if(dossier->alts && member_array(alt, dossier->alts) != -1) {
    correcting_alts = 0;
    return capitalize(alt) + " is already an alt of " +
      capitalize(player) + ".\n";
  }
  if(!dossier->alts)
    dossier->alts = ({ });
  dossier->alts += ({ alt });
  if(alts) {
    foreach(tmp in alts) {
      if(PLAYER_HANDLER->test_user(tmp))
        dossier->alts += ({ tmp });
      else
        dossier->old_alts += ({ tmp });
    }
  }
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered " + capitalize(alt) +
                              " as an alt.\n",
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
  load_player(alt);
  dossier->main_alt = player;
  dossier->alts = ({ });
  dossier->old_alts = ({ });
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered as an alt of " + player + ".\n",
                  extra:      0);
  do_debouncing(alt, new_entry);
  save_player(alt);
  correcting_alts = 0;
  return "Added " + capitalize(alt) + " as an alt of " + capitalize(player) +
    ".\n";
}
string delete_alt(object creator, string player, string alt) {
  string ret;
  class dbentry new_entry;
  if(!query_can_handle_alts(this_player()))
    return "You are not allowed to delete players' alts.\n";
  player = lower_case(player);
  alt = lower_case(alt);
  load_player(player);
  if(!dossier->alts || member_array(alt, dossier->alts) == -1)
    ret = capitalize(alt) + " was not an alt of " + capitalize(player);
  else {
    dossier->alts -= ({ alt });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed " + capitalize(alt) + " as an alt.\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(player);
  }
  load_player(alt);
  if(dossier->main_alt != player) {
    if(ret)
      return capitalize(alt) + " is not an alt of " + capitalize(player) +
        ".\n";
    else
      ret = capitalize(player) + " was not the main player for " +
        capitalize(alt);
  } else {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    dossier->old_alts = ({ });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed as an alt of " + capitalize(player) +
                    ".\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(alt);
  }
  if(ret)
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts (" + ret + ").\n";
  else
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts.\n";
}
mapping query_alerts() {
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts;
}
int query_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts[player];
}
int is_alert( string player, int idx ) {
   load_player( player );
   if( sizeof(dossier->data) < idx ) {
      return 0;
   }
   return ( dossier->data[ idx - 1 ] )->event == "alert";
}
int acknowledge_alert( object creator, string player, string event,
   int idx, string update, mixed * extra ) {
   class dbentry entry;
   string previnfo;
   player = lower_case(player);
   if( !query_can_add( event, creator ) )
      return 0;
   if( !query_source_ok( "alert", base_name( previous_object() ) ) )
      return 0;
   if( !query_source_ok( event,  base_name( previous_object() ) ) )
      return 0;
   if( !PLAYER_HANDLER->test_user(player) )
      return 0;
   if( member_array( event, keys(_sources) ) < 0 )
      return 0;
   idx--;
   load_player( player );
   entry = dossier->data[idx];
   previnfo = sprintf( "Originally added by %s%s%s at %s:\n%s\n---\n",
     CL_CREATOR, entry->creator, CL_RESET, ctime( entry->time ),
     entry->comment );
   entry->time    = time();
   entry->creator = capitalize( creator->query_name() );
   entry->event   = lower_case( event );
   entry->comment = previnfo + update;
   dossier->data[idx] = entry;
   if( event != "alert" ) {
      decrement_alerts_for(player);
   }
   save_player( player );
   return 1;
}
void clear_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   map_delete( _alerts, player );
   save_handler_data();
}
int increment_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   if( !PLAYER_HANDLER->test_user(player) ) {
      return 0;
   }
   if( undefinedp( _alerts[player] ) ) {
      _alerts[player] = 1;
   } else {
      _alerts[player] = _alerts[player] + 1;
   }
   save_handler_data();
   return _alerts[player];
}
int decrement_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   if( undefinedp( _alerts[player] ) ) {
      return 0;
   }
   _alerts[player] = _alerts[player] - 1;
   if(_alerts[player] <= 0 ) {
      map_delete( _alerts, player );
   }
   save_handler_data();
   return _alerts[player];
}
string * query_online_alerts() {
   if ( !_alerts ) {
      _alerts = ([ ]);
      return ({ });
   }
   return filter( keys(_alerts), (: find_player($1) :) );
}
private void correct_alts_for(string player) {
  string main;
  string *alts, *tmp, alt;
  if(!player)
    return;
  player = lower_case(player);
  correcting_alts = 1;
  load_player(player);
  main = dossier->main_alt;
  alts = copy(dossier->alts);
  if(main && !no_recurse) {
    if(sizeof(alts)) {
      dossier->alts = ({ });
      save_player(player);
    }
    if((!PLAYER_HANDLER->test_user(player) ||
        !PLAYER_HANDLER->test_user(main))) {
      correcting_alts = 0;
      no_recurse = 1;
      correct_alts_for(main);
      load_player(player);
    }
    return;
  }
  if(!PLAYER_HANDLER->test_user(player)) {
    if(!sizeof(alts)) {
      if(this_player()->query_name("ceres"))
        write("No alts for : " + player + "\n");
      correcting_alts = 0;
      return;
    }
    tmp = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp)) {
      main = tmp[0];
    }
  }
  if(main) {
    dossier->main_alt = main;
    dossier->alts = ({ });
    save_player(player);
  }
  if(main)
    load_player(main);
  if(sizeof(alts)) {
    tmp = filter(alts, (: !find_player($1) &&
                        !PLAYER_HANDLER->test_user($1) :));
    tmp = uniq_array(dossier->old_alts + tmp);
  } else
    alts = ({ });
  alts = uniq_array(alts + dossier->alts) - ({ main });
  alts = filter(alts, (: find_player($1) || PLAYER_HANDLER->test_user($1) :));
  if(main && (alts != dossier->alts || tmp != dossier->old_alts)) {
    dossier->alts = copy(alts);
    dossier->old_alts = copy(tmp);
    save_player(main);
    foreach(alt in alts) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
    foreach(alt in tmp) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
  }
  load_player(player);
  correcting_alts = 0;
}
void reregister_parent( string player ) {
   string main;
   string * alts;
   if ( !player ) {
      return;
   }
   player = lower_case(player);
   correcting_alts = 1;
   load_player( player );
   main = dossier->main_alt;
   if ( main ) {
      load_player(main);
      alts = dossier->alts;
      if ( !alts || !sizeof( alts ) ) {
         dossier->alts = ({ player });
      } else if ( member_array( player, alts ) == -1 ) {
         dossier->alts = alts + ({ player });
      } else {
         return;
      }
      save_player( main );
   }
}
void player_refreshed(mixed player, int totally) {
  class dbentry new_entry;
  string comment;
  if(objectp(player))
    player = player->query_name();
  switch (totally) {
  case PARTIAL_REFRESH:
    comment = "They did a partial refresh.";
    break;
  case TOTAL_REFRESH:
    comment = "They did a total and complete refresh.  (Even refreshed their "
      "breath)";
    break;
  default:
    comment = "They did some weird sort of unknown refresh.";
    break;
  }
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "refresh",
                  comment:    comment,
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
}
void player_deleted(mixed player, int deleted) {
  class dbentry new_entry;
  string *tmp, *tmp2, alt, main;
  if(objectp(player))
    player = player->query_name();
  if(file_size(filename(player)) == -1)
    return;
  clear_alerts_for(player);
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "delete",
                  comment:    "Player deleted",
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
  if(dossier->main_alt) {
    main = dossier->main_alt;
    dossier->main_alt = 0;
    save_player(player);
    load_player(main);
    dossier->alts -= ({ player });
    dossier->old_alts += ({ player });
    save_player(main);
    return;
  }
  if(dossier->alts && sizeof(dossier->alts)) {
    tmp = filter(dossier->alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp))
      main = tmp[0];
    tmp2 = dossier->old_alts;
    load_player(main);
    dossier->main_alt = 0;
    if(sizeof(tmp) > 1)
      dossier->alts = copy(tmp[1..]);
    dossier->old_alts = copy(tmp2 + ({ player }));
    save_player(main);
    foreach(alt in dossier->alts) {
      load_player(alt);
      dossier->main_alt = main;
      save_player(alt);
    }
    return;
  }
}
void player_created(string player) {
  if(file_size(filename(player)) == -1)
    return;
  load_player(player);
  if(dossier->main_alt) {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    save_player(player);
  }
  return;
}
void fix_alts(mixed player) {
  string *alts, alt, main;
  if(objectp(player))
    player = player->query_name();
  if(file_size(filename(player)) == -1)
    return;
  load_player(player);
  if(dossier->main_alt) {
    main = dossier->main_alt;
    load_player(dossier->main_alt);
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      if(sizeof(alts))
        main = alts[0];
    }
  } else {
    main = player;
  }
  alts = ({});
  if( dossier->alts ) {
     alts = alts + dossier->alts;
  }
  if( dossier->old_alts ) {
     alts = alts + dossier->old_alts;
  }
  alts = uniq_array( alts + ({ player }));
  alts -= ({ main });
  dossier->main_alt = 0;
  dossier->alts = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
  dossier->old_alts = filter(alts, (: !PLAYER_HANDLER->test_user($1) :));
  foreach(alt in alts) {
    load_player(alt);
    dossier->main_alt = main;
    dossier->alts = 0;
    dossier->old_alts = 0;
    save_player(alt);
  }
}
void reset() {
    if ( sizeof( _dossier_cache ) > CACHE_SIZE ) {
        _dossier_cache = ([ ]);
    }
}
string query_access_history( string player ) {
  mapping history;
  string ret = "";
  load_player(player);
  history = dossier->access_log;
  ret += sprintf( "Access log for player %s:\n", capitalize( player ) );
  foreach( string name in sort_array( keys( history ),
                                      (: $(history)[$2] - $(history)[$1] :) ))
    ret += sprintf( "%12s:\t%s.\n", capitalize(name),
                    query_time_string( time() - history[name], 2 ) + " ago");
  return ret;
}
mixed *stats() {
    return ({
        ({ "cache hits", _dossier_cache_hits }),
        ({ "total requests", _dossier_total }),
        ({ "cache hit %", to_int(_dossier_cache_hits * 100.0 /
                                 _dossier_total) }),
        ({ "current cache size", sizeof( _dossier_cache ) })
    });
}

==================================================
FILE: handlers/playtesters.c
==================================================

#include <board.h>
#include <project_management.h>
#include <player_handler.h>
#include <playtesters.h>
#include <login.h>
#define SAVE_FILE "/save/playtesters"
#define LEVEL 150
#define NORMAL_PLAYTESTER 1
#define SENIOR_PLAYTESTER 2
#define BUG_SKIP 10
private int count = 0;
private nosave int updating = 0;
private string* months = ({});
private mapping pts = ([]);
private mapping playtesters = ([]);
private mapping ages = ([]);
private mapping guilds = ([]);
private mapping bugs = ([]);
private mapping leave = ([]);
private mapping tmp_pts = ([ ]);
private mapping _jump_points;
private string *executives = ({ });
int query_leave (string);
void save_file() {
    unguarded( (: save_object, SAVE_FILE :) );
}
void create() {
   seteuid( master()->creator_file( file_name( this_object() ) ) );
   months = ({ });
   pts = ([ ]);
   ages = ([ ]);
   guilds = ([ ]);
   bugs = ([ ]);
   playtesters = ([ ]);
   leave = ([ ]);
   tmp_pts = ([ ]);
   _jump_points = ([ ]);
   executives = ({ });
   if ( file_size( SAVE_FILE + ".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE, 1 :) );
   call_out( "reset", 2 );
}
string* query_playtesters() {
    return copy( keys( pts ) );
}
int query_playtester( string name ) {
  return !undefinedp( pts[ name ] );
}
int check_playtester( string ) {
    log_file( "PLAYTESTERS", file_name( previous_object() ) + " using "
              "deprecated check_playtester() call\n" );
    return 0;
}
int query_tester( mixed person ) {
    object ob;
    string str;
    if ( stringp( person ) ) {
        ob = find_player( person );
        if ( !ob ) {
            return 0;
        }
        str = person;
    } else if ( objectp( person ) ) {
        ob = person;
        str = person->query_name();
    } else {
        return 0;
    }
    return ( ob->query_creator() ||
             ob->query_property( "test character" ) ||
             query_playtester( str ) );
}
protected int get_age_raw( string name ) {
    int fu = PLAYER_HANDLER->test_age( name );
    if ( fu < 0 )
        fu = -fu;
    return fu;
}
int get_age_cached( string name ) {
    if ( ages[ name ] < 0 )
        ages[ name ] = -ages[ name ];
    return ages[ name ];
}
int get_age_uncached( string name ) {
    if ( find_player( name ) )
        ages[ name ] = find_player( name )->query_time_on();
    return get_age_cached( name );
}
int get_age_uncached_offline( string name ) {
    ages[ name ] = get_age_raw( name );
    return get_age_cached( name );
}
int query_senior_playtester( string name ) {
    return ( pts[ name ] == SENIOR_PLAYTESTER );
}
int add_playtester( string name ) {
    if ( pts[ name ] )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " added as a playtester by %s\n", this_player()->query_name() );
    pts[ name ] = NORMAL_PLAYTESTER;
    ages[ name ] = get_age_uncached_offline( name );
    guilds[ name ] = PLAYER_HANDLER->test_guild( name );
    bugs[ name ] = ([ ]);
    if (tmp_pts[name]) {
      if (tmp_pts[name] == SENIOR_PLAYTESTER) {
        pts[name] = SENIOR_PLAYTESTER;
      }
      map_delete (tmp_pts, name);
    }
    PT_APPLICATION_HANDLER->delete_applicant (name);
    save_file();
    return 1;
}
int add_senior_playtester( string name ) {
    if ( pts[ name ] != NORMAL_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to senior playtester by %s\n",
              this_player()->query_name() );
    pts[ name ] = SENIOR_PLAYTESTER;
    save_file();
    return 1;
}
int remove_senior_playtester( string name, string reason ) {
    if ( pts[ name ] != SENIOR_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " demoted from senior playtester; Reason: " + reason +
              " by "+ this_player()->query_name() + "\n" );
    pts[ name ] = NORMAL_PLAYTESTER;
    save_file();
    return 1;
}
int remove_playtester( string name, string reason ) {
    string str;
    if ( !query_playtester( name ) )
        return 0;
    str = ctime( time() ) +": "+ name + " removed as a playtester";
    if ( reason ) {
        str += "; Reason: " + reason;
    }
    str += " by "+ this_player()->query_name() + "\n" ;
    log_file( "PLAYTESTERS", str + "\n" );
    map_delete( pts, name );
    map_delete( ages, name );
    map_delete( guilds, name );
    map_delete( bugs, name );
    PROJECT_HANDLER->clear_playtesting_projects (({name }));
    save_file();
    return 1;
}
string reason_invalid_playtester(string name) {
    if ( !PLAYER_HANDLER->test_user( name ) ) {
        return "not a user";
    }
    if ( PLAYER_HANDLER->test_creator( name ) ) {
        return "currently a creator";
    }
    if ( PLAYER_HANDLER->test_level( name ) < LEVEL ) {
        return "level is too low";
    }
    return 0;
}
int valid_playtester( string name ) {
    return ( !stringp( reason_invalid_playtester( name ) ) );
}
int hire_playtester( object thing ) {
    string name;
    if ( !objectp( thing ) )
        return 0;
    name = thing->query_name();
    if ( !stringp( name ) )
        return 0;
    if ( !valid_playtester( name ) )
        return 0;
    return add_playtester( name );
}
void adjust_quota( string name, int amount ) {
    string* bits;
    string right_now;
    int* bing;
    int age;
    bits = explode( ctime( time() ), " " ) - ({ "" });
    right_now = bits[ 1 ] + " " + bits[ 4 ];
    if (!bugs[name][right_now]) {
      bugs[name][right_now] = 0;
    }
    bing = bugs[ name ][ right_now ];
    age = get_age_uncached( name );
    if ( arrayp( bing ) && ( sizeof( bing ) == 3 ) ) {
        bing[ 0 ] += amount;
        bing[ 1 ] += age - bing[ 2 ];
        bing[ 2 ] = age;
    } else {
        bing = ({ amount, 0, age });
    }
    bugs[ name ][ right_now ] = bing;
    save_file();
}
protected void check_playtesters_one( string name ) {
    if ( !valid_playtester( name ) ) {
        remove_playtester( name, reason_invalid_playtester( name ) +
                           " [automatic]" );
    } else {
        adjust_quota( name, 0 );
    }
}
void check_playtesters( string* who ) {
    string* bits;
    string right_now;
    if ( sizeof( who ) ) {
        check_playtesters_one( who[ 0 ] );
        if ( sizeof( who ) > 1 ) {
            call_out( "check_playtesters", random( 10 ) + 5, who[ 1.. ] );
        } else {
            bits = explode( ctime( time() ), " " ) - ({ "" });
            right_now = bits[ 1 ] + " " + bits[ 4 ];
            if ( member_array( right_now, months ) < 0 ) {
                months += ({ right_now });
                save_file();
            }
        }
    }
}
void reset() {
    if ( !updating )
        call_out( "check_playtesters", 30, copy( keys( pts ) ) );
    updating++;
    updating %= 12;
}
void report_made( string name, string type, string file, string text ) {
    int post = 0;
    if ( !query_playtester( name ) )
        return;
    if ( regexp( type, "IDEA" ) ) {
        post = 1;
    } else if ( regexp( type, "BUG" ) ) {
        count = ( count + 1 ) % BUG_SKIP;
        post = ( count == 0 );
    }
    if ( post ) {
        BOARD_HAND->add_message( "playtester_bugs", capitalize( name ),
                                 type + " for " + file,
                                 sprintf( "%75-=s", text ) );
    }
    adjust_quota( name, 1 );
}
string query_show_list() {
    string result;
    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        if ( query_senior_playtester( name ) ) {
            result += "S ";
        } else {
            result += "  ";
        }
        if ( stringp( leave[ name ] ) )
            result += sprintf( "%-14s", "[" + name + "]" );
        else
            result += sprintf( " %-12s ", name );
        foreach ( string month in months[ <5.. ] ) {
            if ( sizeof( bugs[ name ][ month ] ) >= 2 )
                result += sprintf( "   %4d %4d", bugs[ name ][ month ][ 0 ],
                                   ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            else
                result += "   ---- ----";
        }
        result += "\n";
    }
    return result;
}
string query_show_list_colour() {
    string result;
    string colour;
    int online, reports;
    string temp;
    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        reports = 0;
        online = 0;
        if ( query_senior_playtester( name ) ) {
            temp = "S ";
        } else {
            temp = "  ";
        }
        temp += sprintf( "%%s%-12s%%%%^RESET%%%%^", name );
        foreach ( string month in months[ <5.. ] ) {
	          if (query_leave (name)) {
                    colour = "%%^WHITE%%^";
	          }
            else if ( sizeof( bugs[ name ][ month ] ) >= 2 ) {
                reports += bugs[ name ][ month ][ 0 ];
                online += bugs[ name ][ month ][ 1 ];
                if ( bugs[ name ][ month ][ 1 ] == 0 )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^MAGENTA%%^" :
                               "%%^BOLD%%^%%^MAGENTA%%^" );
                else if ( bugs[ name ][ month ][ 0 ] >=
                     ( bugs[ name ][ month ][ 1 ] / 7200 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^GREEN%%^" :
                               "%%^BOLD%%^%%^GREEN%%^" );
                else if ( bugs[ name ][ month ][ 0 ] <
                          ( bugs[ name ][ month ][ 1 ] / 24000 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^RED%%^" :
                               "%%^BOLD%%^%%^RED%%^" );
                else
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^ORANGE%%^" :
                               "%%^YELLOW%%^" );
                temp += sprintf( "   %s%4d %4d%%%%^RESET%%%%^",
                                 colour,
                                 bugs[ name ][ month ][ 0 ],
                                 ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            } else
                temp += "   ---- ----";
        }
        temp += "\n";
        if ( online == 0 )
            colour = ( stringp( leave[ name ] ) ?
                       "%^BOLD%^%^WHITE%^" :
                       "%^BOLD%^%^MAGENTA%^" );
        else if ( reports >= ( online / 7200 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^GREEN%^" :
                       "%^BOLD%^%^GREEN%^" );
        else if ( reports < ( online / 24000 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^RED%^" :
                       "%^BOLD%^%^RED%^" );
        else
            colour = ( stringp( leave[ name ] ) ?
                       "%^ORANGE%^" :
                       "%^YELLOW%^" );
        result += sprintf( temp, colour );
    }
    return result;
}
mapping query_playtester_guilds() {
    mapping r = ([]);
    foreach ( string pt, string guild in guilds ) {
        if ( arrayp( r[ guild ] ) )
            r[ guild ] += ({ pt });
        else
            r[ guild ] = ({ pt });
    }
    return r;
}
mapping query_guilds() {
    return copy( guilds );
}
void update_guilds() {
  string guild;
    foreach( string player, mapping data in playtesters ) {
        if ( !sizeof (data[ "guild" ]) ) {
            guild = PLAYER_HANDLER->test_guild( player );
            if (!sizeof (guild)) {
              guild = "/std/guilds/standard";
            }
            data[ "guild" ] = guild;
        }
    }
    save_file();
}
mixed query_pt_data( string name ) {
    if ( !undefinedp( playtesters[ name ] ) )
        return copy( playtesters[ name ] );
    return 0;
}
mapping query_bugs( string name ) {
    return copy( bugs[ name ] );
}
string* query_months() {
    return copy( months );
}
int set_leave( string name, string reason ) {
    if ( pts[ name ] ) {
        leave[ name ] = reason;
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " marked as "
                  "on leave: " + reason + "\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
}
int reset_leave( string name ) {
    if ( leave[ name ] ) {
        map_delete( leave, name );
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " no longer "
                  "marked as on leave\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
}
int query_leave( string name ) {
    return stringp( leave[ name ] );
}
#ifdef PLAYTESTERS_HANDLER_OLD_STYLE_CONVERSION
void transfer_data_callout( string* pts ) {
    string pt;
    mixed bing;
    int lastage;
    int nowage;
    if ( sizeof( pts ) ) {
        pt = pts[ 0 ];
        nowage = get_age_uncached_offline( pt );
        lastage = nowage - playtesters[ pt ][ "age" ];
        guilds[ pt ] = PLAYER_HANDLER->test_guild( pt );
        ages[ pt ] = nowage;
        bugs[ pt ] = ([ ]);
        foreach ( string s in keys( playtesters[ pt ] ) -
                  ({ "senior", "age", "current age", "guild" }) ) {
            bing = playtesters[ pt ][ s ];
            if ( arrayp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing[ 0 ], bing[ 1 ], nowage });
            } else if ( intp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing, lastage, nowage });
            }
        }
        tell_creator( "arienne", "Done " + pt + "!\n" );
        if ( sizeof( pts ) > 1 ) {
            call_out( "transfer_data_callout", 5, pts[ 1.. ] );
        } else {
            save_file();
            tell_creator( "arienne", "Done the transfer!\n" );
        }
    }
}
void transfer_data_to_new_system() {
    foreach ( string pt in keys( playtesters ) ) {
        if ( playtesters[ pt ][ "senior" ] )
            pts[ pt ] = SENIOR_PLAYTESTER;
        else
            pts[ pt ] = NORMAL_PLAYTESTER;
    }
    call_out( "transfer_data_callout", 5, copy( keys( playtesters ) ) );
}
#endif
mapping query_jump_points() {
   if (!_jump_points) {
      _jump_points = ([ ]);
   }
   return copy(_jump_points);
}
void add_jump_point(string from, string to) {
   if (!_jump_points[from]) {
      _jump_points[from] = ({ });
   }
   _jump_points[from] += ({ to });
   save_file();
}
void remove_jump_point_from(string from) {
   map_delete(_jump_points, from);
   save_file();
}
void remove_jump_point(string from, string to) {
   if (_jump_points[from]) {
      _jump_points[from] -= ({ to });
      if (!sizeof(_jump_points[from])) {
         map_delete(_jump_points, from);
      }
      save_file();
   }
}
string* query_jump_destination(string from) {
   return _jump_points[from];
}
int add_pt_exec( string name ) {
    if ( undefinedp (pts[ name ]))
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to playtester executive by %s\n",
              this_player()->query_name() );
    executives += ({ name });
    save_file();
    return 1;
}
int remove_pt_exec( string name ) {
    if ( !undefinedp (pts[ name ]))
        return 0;
    if (member_array (name, executives) == -1) {
      return 0;
    }
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " removed from playtester executive by %s\n",
              this_player()->query_name() );
    executives -= ({ name });
    save_file();
    return 1;
}
int query_pt_exec(string name) {
  if (member_array (name, executives) == -1) {
    return 0;
  }
  return 1;
}
int query_exec_access (string name) {
  if (master()->query_senior(name)) {
    return 1;
  }
  if (query_pt_exec (name)) {
    return 1;
  }
  if (query_senior_playtester (name)) {
    return 1;
  }
  if (load_object ("/d/playtesters/master")->query_deputy (name)) {
    return 1;
  }
  return 0;
}

==================================================
FILE: handlers/potion.c
==================================================

inherit "/std/object";
mapping paths = allocate_mapping(10);
mapping potions = allocate_mapping(10);
#define POTION_DIR "/obj/potions/"
string *directories = ({
    POTION_DIR,
});
void create() {
    string dir, s, dummy, title, path, index;
    int d, i;
    seteuid("Room");
    for (d = 0; d < sizeof(directories); d++) {
        dir = directories[d];
        index = dir + "index";
        i = 1;
        if (file_size(index) > 0) {
            while (s = read_file(index, i++, 1)) {
                if ((s == "") || (sscanf(s, "#%s", dummy))) {
                    continue;
                }
                if (sscanf(s, "\"%s\"%*s\"%s\"", title, path) != 3) {
                    continue;
                }
                paths[title] = path;
                potions[title] = 0;
            }
        }
    }
    ::create();
}
int query_min_level(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return -1;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_min_level();
}
string query_chant(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return 0;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_chant();
}
object query_potion(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
       return 0;
    }
    if (!potions[s]) {
       potions[s] = clone_object(paths[s]);
    }
    return potions[s];
}
mixed clone_reagent(string s) {
    object pot;
    string potion;
    potion = this_player()->expand_nickname(s);
    if (undefinedp(paths[potion])) {
      return -1;
    }
    pot = query_potion(s);
    printf("Verb = %O\n", query_verb());
    return pot->clone_reagent(query_verb());
}
mapping query_paths() {
    return paths;
}
mapping query_potions() {
    return potions;
}
