# Total Tokens: 17713
# Total Files Merged: 13
# Total Characters: 59083

s.c
==================================================

#include <skills.h>
#include <tasks.h>
#include <tune.h>
#undef LOGGING
varargs int calc_bonus( int lvl, string skill, int use_base_stats );
varargs int stat_modify( int bonus, string skill, int use_base_stats );
mixed recursive_skill_add(mixed skil, string *path, int avr, int lvl, int exp,
                           mixed standard);
private void convert_skills(mixed *skills, string path);
int query_skill(string skill);
mapping new_skills;
nosave mapping _bonus_cache,
               _stat_cache,
               _teach_offer;
mapping _last_info;
mapping query_skills() { return copy( new_skills ); }
void set_skills( mapping map ) { new_skills = map; }
int calc_level(string *path);
void create() {
  _bonus_cache = ([ ]);
  _teach_offer = ([ ]);
  _stat_cache = ([ ]);
  new_skills = ([ ]);
  if(!_last_info)
    _last_info = ([ "time" : time() ]);
}
int not_there( string skill ) {
   return undefinedp(new_skills[skill]);
}
mapping query_bonus_cache() { return copy(_bonus_cache); }
mapping query_stat_cache() { return copy(_stat_cache); }
void zap_stat_cache() {
   int i;
   string word, *list, stat;
   stat = this_object()->stats_to_zap();
   if ( !stat ) {
      return;
   }
   if ( find_call_out( "reset_all2" ) == -1 ) {
      call_out( "reset_all2", 1 );
   }
   foreach( i in stat ) {
      list = _stat_cache[ i ];
      if ( !list )
         continue;
      foreach( word in list ) {
         map_delete( _stat_cache, word );
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( word ) {
      word->set_unarmed_attacks( this_object() );
   }
}
void totaly_zap_bonus_cache() {
   _bonus_cache = ([ ]);
}
protected void totaly_zap_stat_cache() {
   _stat_cache = ([ ]);
}
varargs int query_skill_bonus( string skill, int use_base_stats ) {
#ifdef 0
   int tmp, lvl;
   string *path;
   object guild, race;
#endif
  if (!stringp(skill) || !strlen(skill)) {
    return 0;
  }
  if (!new_skills) {
    new_skills = ([ ]);
  }
  if (skill[0] == '.') {
    skill = skill[1..];
  }
  TASKER->set_control( ({ this_object(), skill }) );
  if ( _bonus_cache[ skill ] )
     return stat_modify( _bonus_cache[ skill ], skill, use_base_stats );
  return calc_bonus( query_skill(skill), skill, use_base_stats );
#ifdef 0
  lvl = query_skill(skill);
  guild = (object)this_object()->query_guild_ob();
  race = (object)this_object()->query_race_ob();
  if (race) {
    tmp = (int)race->query_skill_bonus(lvl, skill);
  }
  if (guild) {
    tmp += (int)guild->query_skill_bonus(lvl, skill);
  }
  return calc_bonus( lvl + tmp, skill, use_base_stats );
#endif
}
int query_skill(string skill) {
   string *path;
   if (!new_skills) {
      new_skills = ([ ]);
   }
   if (!stringp(skill)) {
      return 0;
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   TASKER->set_control( ({ this_object(), skill }) );
   if ( not_there( skill ) ) {
      int i;
      path = (string *)SKILL_OB->query_skill_tree(skill);
      if (path) {
         for (i=0;i<sizeof(path);i++) {
            if ( !not_there( path[ i ] ) ) {
               return new_skills[path[i]];
            }
         }
      }
   } else {
      return new_skills[skill];
   }
   return 0;
}
mapping query_complete_skill_branch( string branch ) {
  string *skills = SKILL_OB->query_all_children( branch );
  if ( !arrayp( skills ) || !sizeof( skills ) )
    return ([ ]);
  return allocate_mapping( skills, (: query_skill( $1 ) :) );
}
protected void flatten_it(string skill) {
   int value;
   int i;
   string *same;
   reset_eval_cost();
   value = new_skills[skill];
   same = (mixed *)SKILL_OB->query_immediate_children(skill);
   for (i=0;i<sizeof(same);i++) {
      if ( not_there( same[ i ] ) ) {
         new_skills[same[i]] = value;
      }
      flatten_it(same[i]);
   }
   if (sizeof(same)) {
      map_delete(new_skills, skill);
   }
}
int tm_check_ok(string skill, object exp) {
  string *history, *bits, *abits;
  int i, j, last, delay;
  if ( !_last_info ) {
    _last_info = ([ "time" : time() ]);
  }
#ifdef LOGGING
  if(base_name(previous_object()) != "/obj/handlers/taskmaster" &&
     base_name(previous_object()) != "/std/effects/fighting/combat" &&
     base_name(previous_object()) != "/std/shadows/misc/team" &&
     base_name(previous_object()) != "/std/shadows/other/group" &&
     base_name(previous_object()) != "/global/player" &&
     base_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "Object %s gave skill increase without using "
              "the taskmaster.\n", base_name(previous_object()));
   }
#endif
  history = this_object()->get_history();
  if(sizeof(history)) {
    for(i=0; i<sizeof(history) && history[i]; i++)
      ;
    last = i - 1;
    if(!this_object()->is_alias(history[last]))
      last -= this_object()->query_queued_commands();
    if(last > 0 && sizeof(history[last]) > 1 && skill[<7..] != ".points") {
      for(i=0; i<sizeof(history) && history[i]; i++) {
        if(history[last] == history[i]) {
          j++;
        }
      }
      if(j > 5 || j * 100 / i > 30) {
#ifdef BAD_TM
        log_file(BAD_TM, "%s %s in %s by %O too many attempts at %s [%s]\n",
                 ctime(time())[4..18], this_object()->query_name(), skill,
                 exp, history[last], history[i-1]);
#endif
        if(!_last_info["skill"] || _last_info["skill"][0] != skill)
          _last_info["skill"] = ({ skill, 2 });
        else
          _last_info["skill"][1] += 1;
        _last_info["time"] = time();
        if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
          _last_info["object"] = ({ base_name(exp), 2 });
        else
          _last_info["object"][1] += 1;
        if(!_last_info["env"] || _last_info["env"][0] != environment())
          _last_info["env"] = ({ environment(), 2 });
        else
          _last_info["env"][1] += 1;
        return 0;
      }
    }
  }
  delay = 30 + random(this_object()->query_level()) +
    random(this_object()->query_skill(skill));
  if(_last_info["object"] && base_name(exp) == _last_info["object"][0])
    delay *= _last_info["object"][1];
  if(this_object()->query_level() * 2 < this_object()->query_skill(skill))
    delay *= 2;
  if(_last_info["env"] && environment(this_object()) == _last_info["env"][0]) {
    delay *= _last_info["env"][1];
  }
  bits = explode(skill, ".");
  if(_last_info["skill"])
    abits = explode(_last_info["skill"][0], ".");
  else
    abits = ({ });
  for(i=0; i<sizeof(bits) && i<sizeof(abits) && bits[i] == abits[i]; i++)
    ;
  if(i && _last_info["skill"])
    delay *= (i * _last_info["skill"][1]);
  else
    delay = 60;
  if(_last_info["time"] > (time() - delay)) {
#ifdef BAD_TM
    log_file(BAD_TM, "%s %s in %s by %O last %d secs ago, delay %d.\n",
             ctime(time())[4..18], this_object()->query_name(), skill,
             exp, (time() - _last_info["time"]), delay);
#endif
    if(!_last_info["skill"] || _last_info["skill"][0] != skill)
      _last_info["skill"] = ({ skill, 2 });
    else
      _last_info["skill"][1] += 1;
    _last_info["time"] = time();
    if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
      _last_info["object"] = ({ base_name(exp), 2 });
    else
      _last_info["object"][1] += 1;
    if(!_last_info["env"] || _last_info["env"][0] != environment())
      _last_info["env"] = ({ environment(), 2 });
    else
      _last_info["env"][1] += 1;
    return 0;
  }
  if(!_last_info["skill"] || _last_info["skill"][0] != skill)
    _last_info["skill"] = ({ skill, 2 });
  else
    _last_info["skill"][1] += 1;
  _last_info["time"] = time();
  if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
    _last_info["object"] = ({ base_name(exp), 2 });
  else
    _last_info["object"][1] += 1;
  if(!_last_info["env"] || _last_info["env"][0] != environment())
    _last_info["env"] = ({ environment(), 2 });
  else
    _last_info["env"][1] += 1;
  return 1;
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string guild, *recursive_skills, *same_level, *bits, *tree;
   int i;
   reset_eval_cost();
   if (!stringp(skill) || !intp(lvl) || lvl > 1000) {
      return 0;
   }
   if (!new_skills || (!mapp(new_skills))) {
      new_skills = ([ ]);
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   recursive_skills = (string *)SKILL_OB->query_related_skills(skill);
   if (!recursive_skills) {
      return 0;
   }
   bits = explode(skill, ".");
   if ( not_there( skill ) && !SKILL_OB->query_only_leaf(skill)) {
      int tmp_lvl, j;
      if (sizeof(bits) > 1) {
         tmp_lvl = 0;
         for (i=sizeof(bits)-1;!tmp_lvl && i>=0;i--) {
            if ( !not_there( implode( bits[ 0 .. i ], "." ) ) ) {
               tmp_lvl = new_skills[implode(bits[0..i], ".")];
               break;
            }
         }
         if (i>=0) {
            for (;i<sizeof(bits);i++) {
               same_level = (string *)
                 SKILL_OB->query_immediate_children(implode(bits[0..i], "."));
               for ( j = 0; j < sizeof( same_level ); j++ ) {
                  new_skills[ same_level[ j ] ] = tmp_lvl;
                  map_delete( _bonus_cache, same_level[ j ] );
               }
            }
         } else {
            tmp_lvl = 0;
         }
      }
   }
   for (i=0;i<sizeof(recursive_skills);i++) {
      if ( !not_there( recursive_skills[ i ] ) ) {
         new_skills[recursive_skills[i]] += lvl;
         if (new_skills[recursive_skills[i]] < 0) {
            new_skills[recursive_skills[i]] = 0;
         }
      }
      map_delete(_bonus_cache, recursive_skills[i]);
   }
   if ( not_there( skill ) ) {
      new_skills[skill] = lvl;
   }
   tree = (string *)SKILL_OB->query_skill_tree(skill);
   for (i=1;i<sizeof(tree);i++) {
      int total, j;
      same_level = (string *)SKILL_OB->query_immediate_children(tree[i]);
      if (sizeof(same_level)) {
         total = 0;
         for (j=0;j<sizeof(same_level);j++) {
            if ( not_there( same_level[ j ] ) ) {
               new_skills[ same_level[ j ] ] = new_skills[ tree[ i ] ];
               map_delete( _bonus_cache, same_level[ j ] );
            }
            total += new_skills[same_level[j]];
         }
         new_skills[tree[i]] = total/sizeof(same_level);
         map_delete( _bonus_cache, tree[ i ] );
      }
   }
   if ( interactive( this_object() ) &&
         ( guild = (string)this_object()->query_guild_ob() ) ) {
      if ( stringp( guild ) ) {
         guild->skills_advanced( this_object(), skill, new_skills[ skill ] );
      }
  }
  if((lvl == 1) && userp(this_object()) && (!exp || objectp(exp))) {
    if(!exp)
      exp = previous_object();
    if(!tm_check_ok(skill, exp)) {
      new_skills[skill] -= 1;
      return 0;
    } else {
      TASKER->award_made( (string)this_object()->query_name(),
                          base_name( exp ), skill, new_skills[ skill ] );
    }
  }
  if ( find_call_out( "reset_all" ) == -1 ) {
    call_out( "reset_all", 1 );
  }
  if(interactive(this_object()) && !this_object()->query_auto_loading())
     this_object()->save();
  return 1;
}
varargs int stat_modify( int lvl, string skill, int use_base_stats ) {
   int i, stat;
   string stat_bonus;
   float bonus;
   bonus = 0.0;
   if ( !_stat_cache[ skill ] || use_base_stats ) {
      stat_bonus = (string)SKILL_OB->query_skill_stat(skill);
      foreach ( i in stat_bonus ) {
         switch( i ) {
            case 'C' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_con();
               else
                  stat = (int)this_object()->query_con();
               break;
            case 'D' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_dex();
               else
                  stat = (int)this_object()->query_dex();
               break;
            case 'I' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_int();
               else
                  stat = (int)this_object()->query_int();
               break;
            case 'S' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_str();
               else
                  stat = (int)this_object()->query_str();
               break;
            case 'W' :
            default :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_wis();
               else
                  stat = (int)this_object()->query_wis();
         }
         if (stat > 0) {
            bonus += (log(stat) / 9.8) - 0.25;
         } else if (stat < 0) {
            bonus -= (log(-stat) / 9.8) + 0.25;
         } else {
            bonus -= 0.25;
         }
         if ( !_stat_cache[ i ] ) {
            _stat_cache[ i ] = ({ skill });
         } else {
            _stat_cache[ i ] |= ({ skill });
         }
      }
      if ( !use_base_stats ) {
         _stat_cache[ skill ] = ({ bonus, stat_bonus });
      }
   } else {
      bonus = _stat_cache[ skill ][ 0 ];
      stat_bonus = _stat_cache[ skill ][ 1 ];
   }
   i = strlen( stat_bonus );
   if ( i ) {
      stat = to_int(lvl + ( lvl * bonus ));
      if (stat < 0) {
         return 0;
      }
      return stat;
   }
   return lvl;
}
varargs int calc_bonus( int lvl, string skill, int use_base_stats ) {
   if (lvl > 60) {
      lvl = 170 + ((lvl-60) >> 1);
   } else if (lvl > 40) {
      lvl = 150 + (lvl-40);
   } else if (lvl > 20) {
      lvl = 100 + ( ((lvl-20)*5) >> 1);
   } else {
      lvl = lvl * 5;
   }
   if ( !use_base_stats ) {
      _bonus_cache[ skill ] = lvl;
   }
   return stat_modify( lvl, skill, use_base_stats );
}
int query_skill_successful(string str, int mod) {
  return (query_skill_bonus(str, 0) + mod >= random(200));
}
void add_teach_offer(object ob, string skill, int num, int lvl, int xp) {
  _teach_offer[ob] = ({ skill, num, lvl, xp });
}
mapping query_teach_offer() { return copy(_teach_offer); }
void stop_teaching_skills(int left, mixed bing) {
   object ob;
   if (left > 0) {
      if (bing[O_OTHER_PER] == this_object()) {
         say(this_object()->short() + " stops teaching themselves some "
             "skills.\n");
      } else if (previous_object() == this_object()) {
         ob = bing[O_OTHER_PER];
         tell_object(ob, this_object()->short() + " interupts your "
                         "training.\n");
      } else {
         ob = this_object();
         tell_object(ob, bing[O_OTHER_PER]->short() + " interupts your "
                         "training.\n");
      }
      say(bing[O_OTHER_PER]->short() + " stops teaching some skills to " +
          this_object()->short() + ".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
      this_object()->adjust_time_left(-((int)this_object()->query_time_left()));
      this_object()->set_interupt_command(0);
      return ;
   }
   if (previous_object() != this_object()) {
      return ;
   }
   if(this_object()->query_xp() < bing[O_XP]) {
      write("Something has gone wrong. :(\n");
      return;
   }
   if (this_object() != bing[O_OTHER_PER]) {
      bing[O_OTHER_PER]->adjust_xp(bing[O_XP]/10);
   }
   this_object()->adjust_xp(-bing[O_XP]);
   add_skill_level(bing[O_SKILL], bing[O_NUM], bing[O_XP]);
   if (this_object() != bing[O_OTHER_PER]) {
      tell_object(this_object(), "You finish learning " + bing[O_NUM] +
                  " levels of "
                  + bing[O_SKILL] + " from " + bing[O_OTHER_PER]->short() +
                  ".\n");
      tell_object(bing[O_OTHER_PER], this_object()->short() + " finishes " +
                  "learning " + bing[O_NUM] + " levels of "
                  +bing[O_SKILL] + " from you.\n");
      say(this_object()->short() + " finishes learning some skills "+
          "from "+bing[O_OTHER_PER]->short()+".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   } else {
      tell_object(this_object(), "You finish teaching yourself " + bing[O_NUM] +
                  " levels of " + bing[O_SKILL] + ".\n");
      say(this_object()->short() + " finishes learning some skills "
          "from " + this_object()->query_objective() + "self.\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   }
}

==================================================
FILE: living/spells.c
==================================================

#include <spells.h>
class spell_process {
   mapping spells;
   mapping process;
}
private mixed spells;
void create() {
   spells = ([ ]);
}
string help_spell(string str) {
   if (!mapp(spells)) {
     spells = ([ ]);
   }
   if (!m_sizeof(spells)) {
      return 0;
   }
   if (!spells[str]) {
      return 0;
   }
   return (string)spells[str][S_OBJECT]->help(str);
}
mapping query_spells() {
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   return spells;
}
mapping query_spells_nocase() {
  mapping lc_spells = ([]);
  filter( this_object()->query_spells(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_spells );
  return lc_spells;
}
int add_spell(string name, mixed ob, mixed func) {
   int i;
   mapping tmp;
   if (pointerp(spells)) {
      tmp = ([ ]);
      for (i=0;i<sizeof(spells);i+=2)
         tmp[spells[i]] = spells[i+1];
      spells = tmp;
   }
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   spells[name] = ({ ob, func });
   return 1;
}
int remove_spell(string name) {
  string spell, name_lc;
  if ( !name ) {
      map_delete( spells, 0 );
      return 1;
  }
  name_lc = lower_case(name);
  foreach (spell in keys(spells)) {
     if (lower_case(spell) == name_lc) {
        map_delete(spells, spell);
     }
  }
  return 1;
}
mixed query_spell( string word ) {
   mapping tmp_spells;
   string test_spell;
   if ( !mapp( spells ) ) {
      return 0;
   }
   tmp_spells = query_spells_nocase();
   test_spell = lower_case(this_object()->expand_nickname(word));
   return tmp_spells[test_spell];
}
protected void reset_spells() {
   spells = ([ ]);
}

==================================================
FILE: living/stats.c
==================================================

#include <move_failures.h>
#include <skills.h>
#include <living.h>
#include <config.h>
#define BASE 20
#define ORD1T 1
#define ORD1B 1
#define ORD2T 1
#define ORD2B 5
#define SCALING_DATA ({ 650, 150, 10, 5 })
#define DIVISOR 700
#define DEATH_WAIT_TIME 5
#define INIT_GP_INC -20
int Con, Dex, Int, Str, Wis,
    contmp, dextmp, inttmp, strtmp, wistmp,
    height, base_weight;
nosave int conbon, dexbon, intbon, strbon, wisbon, no_check;
nosave string to_zap;
nosave int gp_inc = INIT_GP_INC, hp_inc;
mixed query_property(string name);
string stats_to_zap() {
   string temp;
   temp = to_zap;
   to_zap = 0;
   return temp;
}
void zap_stat( string word ) {
   string dummy;
   if ( !to_zap ) {
      to_zap = word;
      if ( find_call_out( "zap_stat_cache" ) == -1 )
         call_out( "zap_stat_cache", 1 );
   }
   if ( sscanf( to_zap, "%s"+ word +"%s", dummy, dummy ) != 2 )
      to_zap += word;
}
int query_no_check() { return no_check; }
void set_no_check( int i ) { no_check = i; }
int hp_base() {
  int base;
  base = 150 + 10 * (int)this_object()->query_con();
  if ( base < 5 ) base = 5;
  return base;
}
int hp_gradient() { return 4; }
int scaled_weight() {
  int i, actual, scaled;
  actual = (int)this_object()->query_weight(1);
  if ( actual < SCALING_DATA[ 0 ] )
    return actual;
  scaled += SCALING_DATA[ 0 ];
  actual -= SCALING_DATA[ 0 ];
  i = 1;
  while ( actual && ( ( i * SCALING_DATA[ 2 ] ) < 100 ) ) {
    if ( actual >= SCALING_DATA[ 1 ] ) {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * SCALING_DATA[ 1 ] )
          / 100;
      scaled += ( SCALING_DATA[ 3 ] * SCALING_DATA[ 1 ] ) / 1000;
      actual -= SCALING_DATA[ 1 ];
    } else {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * actual ) / 100;
      scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
      actual = 0;
    }
    i += 1;
  }
  if ( actual )
    scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
  return scaled;
}
void reset_hp() {
  int new_max, skill_bon;
  string report;
  if ( no_check )
    return;
  skill_bon = (int)this_object()->query_skill_bonus( "other.health" );
  new_max = hp_base() + skill_bon * hp_gradient();
  if ( !base_weight ) {
    if ( (string)this_object()->query_name() == "object" )
      return;
    report = file_name( this_object() ) +" ("+
        (string)this_object()->query_name() +"): race object is "+
        (string)this_object()->query_race_ob();
    if ( environment() ) {
      if ( file_name( environment() ) == "/room/void" )
        return;
      report += "; in "+ file_name( environment() );
      this_object()->move( "/room/void", "$N gets booted into the void for "+
          "being a bad NPC." );
    }
    report += ".\n";
    log_file( "BAD_NPC", ctime(time()) + " " + report );
    return;
  }
   new_max = ( new_max * scaled_weight() ) / DIVISOR;
   if ( new_max < 1 )
      this_object()->set_max_hp( 1 );
   else
      this_object()->set_max_hp( new_max );
}
void reset_gp() {
   string guild_ob;
   if ( no_check )
      return;
   guild_ob = (string)this_object()->query_guild_ob();
   if (!guild_ob) {
      guild_ob = query_property("backup guild");
   }
   if ( !guild_ob ) {
      this_object()->set_max_gp( 50 +
            (int)this_object()->query_skill_bonus( "other.points" ) );
   } else {
      guild_ob->set_gp( this_object() );
   }
}
void calc_inc_rates() {
   string guild_ob;
   hp_inc = sqrt((int)this_object()->stat_modify(100, "other.health")) - 7;
   guild_ob = (string)this_object()->query_guild_ob();
   if ( !guild_ob ) {
     guild_ob = query_property("backup guild");
     if (!guild_ob) {
       guild_ob = CONFIG_DEFAULT_GUILD;
     }
   }
   gp_inc = sqrt((int)this_object()->stat_modify(100,
         (string)guild_ob->query_gp_skill())) - 7;
   if(hp_inc < 0) {
     hp_inc = 0;
   }
   if(gp_inc < 0) {
     gp_inc = 0;
   }
}
int *query_inc_rates() { return ({ gp_inc, hp_inc }); }
void heart_beat() {
   int hp;
   int calling_death;
   hp = this_object()->query_hp();
   if ( hp < 0 ) {
       calling_death = this_object()->query_callingdeath();
        if ( calling_death ) {
           if ( time() > calling_death + DEATH_WAIT_TIME ) {
                this_object()->do_death();
            }
        } else {
            this_object()->do_death();
        }
   }
   else {
      if ( gp_inc == INIT_GP_INC ) {
         calc_inc_rates();
      }
      this_object()->adjust_gp( gp_inc );
      this_object()->adjust_hp( hp_inc );
   }
}
void reset_carry_cap() {
   int i, hst_num, hst_wei, new_cap, old_loc, tot_str;
   object *contents, *dropped;
   if ( no_check ) return;
   old_loc = (int)this_object()->query_loc_weight();
   tot_str = Str + strtmp + strbon;
   new_cap = BASE;
   new_cap += ( ORD1T * tot_str ) / ORD1B;
   new_cap += ( ORD2T * tot_str * tot_str ) / ORD2B;
   new_cap = ( new_cap * (int)this_object()->query_weight(1) ) / 100;
   if ( !new_cap )
      new_cap = 1;
   this_object()->set_max_weight( new_cap );
   if ( new_cap >= old_loc ) return;
   this_object()->dest_hide_shadow();
   contents = all_inventory( this_object() ) -
      (object *)this_object()->query_armours();
   dropped = ({ });
   while ( ( old_loc > new_cap ) && sizeof( contents ) ) {
      hst_num = 0;
      hst_wei = 0;
      for ( i = 0; i < sizeof( contents ); i++ )
         if ( (int)contents[ i ]->query_complete_weight() > hst_wei ) {
            hst_wei = (int)contents[ i ]->query_complete_weight();
            hst_num = i;
         }
      if ( (int)contents[ hst_num ]->move( environment() ) == MOVE_OK ) {
         dropped += ({ contents[ hst_num ] });
         old_loc -= hst_wei;
      }
      contents = delete( contents, hst_num, 1 );
   }
   if ( sizeof( dropped ) ) {
      tell_room( environment(), capitalize( (string)this_object()->short() ) +
                " drops "+ query_multiple_short( dropped ) +" under strain.\n",
                this_object() );
      tell_object( this_object(), "Your fading strength makes you drop "+
                  query_multiple_short( dropped ) +".\n" );
   }
   this_object()->update_loc_weight();
   this_object()->calc_burden();
   if ( new_cap >= old_loc ) return;
   return;
}
void check_stats_zero() {
   if ( Int + inttmp + intbon <= 0 ||
        Wis + wistmp + wisbon <= 0 ) {
      this_object()->add_property( PASSED_OUT, 1, 500 );
      tell_object( this_object(), "You fall asleep.\n" );
   }
}
void reset_all() { zap_stat( "CDISW" ); }
void reset_all2() {
   no_check = 0;
   reset_hp();
   reset_gp();
   reset_carry_cap();
   calc_inc_rates();
   check_stats_zero();
   this_object()->do_burden_call();
}
int query_con() { return Con + contmp + conbon; }
int query_dex() { return Dex + dextmp + dexbon; }
int query_int() { return Int + inttmp + intbon; }
int query_str() { return Str + strtmp + strbon; }
int query_wis() { return Wis + wistmp + wisbon; }
int query_real_con() { return Con; }
int query_real_dex() { return Dex; }
int query_real_int() { return Int; }
int query_real_str() { return Str; }
int query_real_wis() { return Wis; }
int check( int number ) { return ( number <= 28 ); }
int set_con( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Con != number )
    zap_stat( "C" );
  Con = number;
  return Con;
}
int set_dex( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Dex != number )
    zap_stat( "D" );
  Dex = number;
  return Dex;
}
int set_int( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Int != number )
    zap_stat( "I" );
  Int = number;
  return Int;
}
int set_str( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Str != number )
    zap_stat( "S" );
  Str = number;
  return Str;
}
int set_wis( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Wis != number )
    zap_stat( "W" );
  Wis = number;
  return Wis;
}
int adjust_con( int number ) {
  if ( check( number + Con ) ) {
    Con += number;
    if ( number )
      zap_stat( "C" );
  }
  return Con;
}
int adjust_dex( int number ) {
  if ( check( number + Dex ) ) {
    Dex += number;
    if ( number )
      zap_stat( "D" );
  }
  return Dex;
}
int adjust_int( int number ) {
  if ( check( number + Int ) ) {
    Int += number;
    if ( number )
      zap_stat( "I" );
  }
  return Int;
}
int adjust_str( int number ) {
  if ( check( number + Str ) ) {
    Str += number;
    if ( number )
      zap_stat( "S" );
  }
  return Str;
}
int adjust_wis( int number ) {
  if ( check( number + Wis ) ) {
    Wis += number;
    if ( number )
      zap_stat( "W" );
  }
  return Wis;
}
int query_tmp_con() { return contmp; }
int query_tmp_dex() { return dextmp; }
int query_tmp_int() { return inttmp; }
int query_tmp_str() { return strtmp; }
int query_tmp_wis() { return wistmp; }
int adjust_tmp_con( int number ) {
  contmp += number;
  if ( number )
    zap_stat( "C" );
   if ( contmp && !dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return contmp;
}
int adjust_tmp_dex( int number ) {
  dextmp += number;
  if ( number )
    zap_stat( "D" );
   if ( !contmp && dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return dextmp;
}
int adjust_tmp_int( int number ) {
  inttmp += number;
  if ( number )
    zap_stat( "I" );
   if ( !contmp && !dextmp && inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return inttmp;
}
int adjust_tmp_str( int number ) {
  strtmp += number;
  if ( number )
    zap_stat( "S" );
   if ( !contmp && !dextmp && !inttmp && strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return strtmp;
}
int adjust_tmp_wis( int number ) {
  wistmp += number;
  if ( number )
    zap_stat( "W" );
   if ( !contmp && !dextmp && !inttmp && !strtmp && wistmp )
      call_out( "update_tmps", 900 );
  return wistmp;
}
int query_bonus_con() { return conbon; }
int query_bonus_dex() { return dexbon; }
int query_bonus_int() { return intbon; }
int query_bonus_str() { return strbon; }
int query_bonus_wis() { return wisbon; }
int adjust_bonus_con( int number ) {
  conbon += number;
  if ( number )
    zap_stat( "C" );
  return conbon;
}
int adjust_bonus_dex( int number ) {
  dexbon += number;
  if ( number )
    zap_stat( "D" );
  return dexbon;
}
int adjust_bonus_int( int number ) {
  intbon += number;
  if ( number )
    zap_stat( "I" );
  return intbon;
}
int adjust_bonus_str( int number ) {
  strbon += number;
  if ( number )
    zap_stat( "S" );
  return strbon;
}
int adjust_bonus_wis( int number ) {
  wisbon += number;
  if ( number )
    zap_stat( "W" );
  return wisbon;
}
void update_tmps() {
  if ( contmp ) {
    zap_stat( "C" );
    contmp = contmp / 2;
  }
  if ( dextmp ) {
    zap_stat( "D" );
    dextmp = dextmp / 2;
  }
  if ( inttmp ) {
    zap_stat( "I" );
    inttmp = inttmp / 2;
  }
  if ( strtmp ) {
    zap_stat( "S" );
    strtmp = strtmp / 2;
  }
  if ( wistmp ) {
    zap_stat( "W" );
    wistmp = wistmp / 2;
  }
   if ( contmp || dextmp || inttmp || strtmp || wistmp )
      call_out( "update_tmps", 900 );
}
int query_height() { return height; }
void set_height( int number ) {
  if ( number > 0 ) height = number;
}
int query_base_weight() { return base_weight; }
void set_base_weight( int number ) {
   if ( number > 0 )
      base_weight = number;
}
int query_weight(int) {
  int adjust_weight;
  adjust_weight = ( ( ( Con + 3 * Str ) / 4 ) - 13 ) * ( base_weight / 30 );
  return base_weight + adjust_weight;
}
mixed *stats() {
  return ({
    ({ "Con", Con + conbon + contmp }),
    ({ "Dex", Dex + dexbon + dextmp }),
    ({ "Int", Int + intbon + inttmp }),
    ({ "Str", Str + strbon + strtmp }),
    ({ "Wis", Wis + wisbon + wistmp }),
    ({ "tmp Con", contmp }),
    ({ "tmp Dex", dextmp }),
    ({ "tmp Int", inttmp }),
    ({ "tmp Str", strtmp }),
    ({ "tmp Wis", wistmp }),
    ({ "bonus Con", conbon }),
    ({ "bonus Dex", dexbon }),
    ({ "bonus Int", intbon }),
    ({ "bonus Str", strbon }),
    ({ "bonus Wis", wisbon }),
    ({ "hp rate", hp_inc }),
    ({ "gp rate", gp_inc }),
    ({ "height", height }),
  });
}

==================================================
FILE: outsides/basic.c
==================================================

#include <terrain_map.h>
#define CREATOR "Ceres"
inherit TERRAIN_MAP_OUTSIDE_BASE;
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}

==================================================
FILE: outsides/desert.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <move_failures.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  ::create();
  set_climate("Bw");
  add_item("sand", "There is a lot of sand here, tons of it just lying "
     "about the place.");
  add_item("rock", "There are small rocks here and there in the sand.");
  room_chat(({120, 240, ({"Grains of sand are blown about in the slight "
          "breeze."})}));
  add_property("rock size", 2+random(5));
  add_property("track type", "desert");
  add_property("sand object", "/obj/media/sand");
}
string query_terrain_map_colour() { return "%^ORANGE%^"; }
int do_get_rock(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    rock = clone_object(query_property("rock object"));
  else {
    if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
      rock_size = 3;
    if ( !rock_size ) return 0;
    rock = clone_object( "/obj/mineral" );
    if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
      rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                     "slate" })[ random( 6 ) ];
    rock->make_mineral(rock_type, 1 + random(rock_size));
  }
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
int do_get_sand(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  object sand;
  sand = clone_object(query_property("sand object"));
  if (!sand) return 0;
  if (sand->move(this_player()) == MOVE_OK) {
    this_player()->add_succeeded_mess(sand, "$N $V $D.\n", ({ }) );
    return 1;
  }
  sand->dest_me();
  return 0;
}

==================================================
FILE: outsides/mountain.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  ::create();
  add_property("climate", ({-10, 0, 0 }) );
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Very occasionally there are beautiful "+
                           "snowdrops nestled in the shadow of a boulder.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There are only a few stunted trees here clinging "+
             "to life on the steep slopes.  New leaves poke cautiously "+
             "from their gnarled branches");
    add_item(({"floor", "ground", "earth"}), "The ground is mostly covered "+
             "by hardy grass interspersed by small shrubs, however there "+
             "are large patches of bare rock or gravel.  "+
             "Here and there larger rocks protrude from the ground.");
    room_chat(({120, 240, ({"A bird of prey swoops overhead.",
                            "A small insect flies past your face."})}));
    add_property("flower type", "snowdrop");
    break;
  case "summer":
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is largely "+
             "covered with a hardy grass interspersed with small shrubs, "+
             "however there are large patches of bare rock and gravel.  Here "+
             "and there larger rocks protrude from the ground.");
    add_item("tree", "There are a few small trees clinging to life in this "+
             "harsh environment.");
    room_chat(({120, 240, ({"The wind whistles through the mountain passes.",
                            "A bird of prey swoops overhead.",
                            "An insect brushes against your face."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("tree", "There are a few trees dotted around their bare "+
             "branches making them look like ghouhlish skeletons.");
    room_chat(({120, 240, ({"The cold wind whistles over the mountains."
                            })}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_item("shrub", "Dotted here and there these hardy plants struggle "+
           "to survive on the thin soil.");
  add_item("grass", "A particularly wiry kind of grass obviously suited "+
           "to the harsh conditions and thins soil.");
  add_property("rock size", 5+random(20));
  add_property("track type", "mountain");
}
mixed do_get_rock(string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral(rock_type, 1 + random(rock_size));
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  printf("Verb: %s\n", verb);
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->add_plural( capitalize( flower_type ) );
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}

==================================================
FILE: outsides/plain.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  set_climate("Aw");
  add_zone("plain");
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There is the occasional tree here and there covered "
             "with new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}),
             "The ground is mostly grassy "
             "with the occasional clump of wild flowers.");
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                              "Bees buzz busily from flower to flower.",
                              "A butterfly alights on a nearby flower.",
                              "A bird takes off from a tree and flies low "
                              "across the fields."})}));
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.  "
               "The grass is long and sways gently in the breeze.  Here and "
               "there amongst the grass are wild flowers and other plants.");
    add_item("tree", "There are a few trees which are in their full "
             "foliage right now.");
    add_item(({"flower", "plant"}),
             ({"long", "Some pretty flowers.",
                 "get", ({this_object(), "do_get_flower"}),
                 "pick", ({this_object(), "do_get_flower"}),
                   "smell", "The flowers smell wonderful."
                     }));
    room_chat(({120, 240,
                  ({"The wind stirs the grass which sways reminding "
                      "you of waves on an ocean.",
                      "A small animal rustles in the long grass.",
                      "A butterfly alights on a nearby flower.",
                      "A bee buzzes around looking for nectar."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.");
    add_item("tree", "The occasional trees are gold and brown as their "
             "leaves die before winter.");
    room_chat(({120, 240, ({"A squirrel rushes up a nearby tree trunk.",
                              "A bird of prey soars high overhead looking "
                              "for something to eat."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy "+
               "apart from the occasional hardy shrub.");
    add_item("tree", "Dotted here and there are skeletal trees bare of "
             "leaves waiting for spring.");
    room_chat(({120, 240, ({"Somewhere a small animal forages in the "
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                        "get",  ({ this_object(), "do_get_rock" }) }) );
  if (!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "buttercup", "daisy"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "
                         "time.");
  flower->add_plural( pluralize( flower_type ) );
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}

==================================================
FILE: outsides/road.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property("track type", "road");
  add_zone("road");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
string query_terrain_map_colour() { return "%^RED%^"; }
string query_terrain_map_character() { return "#"; }

==================================================
FILE: outsides/woodland.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  add_zone("woodland");
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful.\n"
                         }));
    add_item("tree", "There are trees everywhere here, you have "+
             "to pick your way between them.  They are budding with "+
             "new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}), "The ground is covered "+
             "by a beautiful carpet of flowers interspersed with small "+
             "shrubs.");
    add_item("shrub", "Dotted here and there among the carpet of flowers "+
             "are small shrubs, some thorny, all green.");
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                            "Bees buzz busily from flower to flower.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_property("flower type", "bluebell");
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "You can barely see the "+
             "ground because of the waist-high ferns.  Dotted among the "+
             "ferns are small shrubs.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs, some thorny, all green.");
    add_item("fern", "Everywhere you look there are ferns growing "+
                         "almost waist high between the trees.");
    add_item("tree", "The trees are in their full foliage right now.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees making "+
                              "a sound like falling rain.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is littered "+
             "with dead leaves and the stems of dying ferns.");
    add_item("tree", "You are surrounded by trees, they are resplendent "+
             "with their autumn colours of red, gold and brown.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs many with brightly coloured berries.");
    add_item(({"berry", "berries"}),
               ({"long", "There are a variety of berries hanging from the "+
                   "shrubs here.",
                 "get", ({this_object(), "do_get_berry"}),
                 "pick", ({this_object(), "do_get_berry"})}));
    add_item(({"leaf", "leaves"}),
             ({"long", "The ground is littered with dead leaves.",
               "get", ({this_object(), "do_get_leaf"})}));
    add_item("fern", "Here and there are the stems of ferns which have "+
             "died back and will survive the coming winter underground.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees causing "+
                              "some to fall gently to earth.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_extra_look(this_object());
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("shrub", "Dotted here and there among the trees are small "+
             "shrubs trying to survive the winter.");
    add_item("tree", "There are bare trees everywhere here waiting for the "+
             "coming of spring.");
    room_chat(({120, 240, ({"The wind stirs the dry branches of the trees "+
                              "causing them to rustle eerily.",
                            "Somewhere a small animal forages in the "+
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_property("track type", "woodland");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
string query_terrain_map_colour() { return "%^GREEN%^"; }
string extra_look() {
  string extra;
  extra = ::extra_look();
  switch((string)WEATHER->query_season()) {
  case "spring":
    return extra + "Spring flowers are everywhere you look.\n";
  case "autumn":
    return extra + "The ground is littered with fallen leaves.\n";
    break;
  default:
    return extra;
  }
}
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->set_main_plural(flower_type + "s");
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}
mixed do_get_berry( string verb, object *dest ) {
  object berry;
  string berry_type;
  if ((int)query_property("noflowers"))
    return 0;
  berry_type = ({"blackberry", "raspberry", "blueberry", "strawberry",
                 "blackcurrant"})[random(5)];
   berry = clone_object( "/obj/food" );
  berry->set_name(berry_type);
  berry->set_short(berry_type);
  berry->set_long("This is a lovely, plump "+berry_type+" it looks good "+
                  "enough to eat.\n");
  berry->add_alias("berry");
  if (!(berry->move(this_player()))) return 1;
  berry->dest_me();
  return 0;
}
mixed do_get_leaf( string verb, object *dest ) {
  object leaf;
  string leaf_type;
  if ((int)query_property("noflowers"))
    return 0;
  leaf_type = ({"maple", "oak", "sycamore", "ash", "silver birch"})[random(5)];
  leaf = clone_object("/std/object");
  leaf->set_name("leaf");
  leaf->set_short(leaf_type+" leaf");
  leaf->set_long("This is a dead "+leaf_type+" leaf.  Its natural green "+
                 "has turned to shades of gold, red and brown.\n");
  leaf->add_adjective(leaf_type);
  if (!(leaf->move(this_player()))) return 1;
  leaf->dest_me();
  return 0;
}

==================================================
FILE: creator/workroom.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
object button, bookcase, board;
void setup() {
  set_short("workroom of "+ CREATOR);
  add_property( "determinate", "the ");
  set_light(100);
  set_long("This is the workroom of "+CREATOR+".  You can see a small "
     "wooden desk sulking in the corner of the room, it has a "
     "beautifully carved wooden rolly chair in front of it.  It "
     "looks like this was just newly created, there is a smell "
     "of paint and leather in the air.\n");
  add_item("chair",
        ({ "long", "The teak rolly chair has amazing carvings of dragons "
                   "and ... other things on it.  They almost seem alive, "
                   "you especially don't note the way the dragon "
                   "blinks at you.",
                   "position",
                   "the teak rolly chair" }) );
  add_item("desk", "The desk is made of mahogany with a touch of "
     "mountain ash.  The top has two little basket things "
     "on it labelled \"in\" and \"out\".  The in basket "
     "is rather small." );
  add_item( "dragon", "I told you, you don't notice it winking at you." );
  add_item("in basket", "The in basket is full of small yellow forms "
     "with large red letters on them saying "
     "\"Important read me first\" and then not "
     "appearing to actually have any thing else on "
     "them." );
  add_item( "out basket", "The out basket is completely empty." );
  add_item("basket", "There are two baskets sitting on top of the desk.  "
     "They have the words \"in\" and \"out\" written "
     "on them." );
  add_item("paint", "You look around to see the source of the paint "
     "smell and you can't find it.  The walls? of the room "
     "ummm seem to be well shall we just twisting in a "
     "confused mish mash of shapes, you are sure they are "
     "not threatening." );
  add_item("wall", "The walls are made up of a cloudy substance, white "
     "in nature that is roiling around the place where "
     "you are standing.  Great magic must be holding it "
     "back, every now and then you see a demonic head "
     "push its way out of the cloud roll its eyes and fade "
     "back into the cloud." );
  add_item("cloud", "The cloud is white coloured with a few flashes "
     "of light bursting in it." );
  add_item("demon", "The demonic heads that pop out are pretty nasty "
     "looking, they disapear with a snarl of strain." );
  add_exit("common", "/w/common", "door");
  add_exit("drum", CONFIG_START_LOCATION, "path");
  add_exit("learning", "/d/learning/main", "path");
  modify_exit( ({ "common", "drum", "learning" }),
      ({ "function", "check_player" }) );
  add_alias("north", "drum");
  add_alias("south", "common");
  "/w/common"->add_exit(CREATOR, "/w/"+CREATOR+"/workroom", "door");
}
void reset() {
  if (!button) {
    button = clone_object("/obj/misc/button");
    button->move(this_object());
  }
  if (!board) {
    board = clone_object("/obj/misc/board_mas");
    board->move(this_object() );
  }
  if (!bookcase) {
    bookcase = clone_object("/obj/cont_save");
    bookcase->set_name( "bookcase" );
    bookcase->set_short( "oaken bookcase" );
    bookcase->add_adjective( "wooden" );
    bookcase->add_adjective( "oak" );
    bookcase->add_adjective( "oaken" );
    bookcase->add_property( "there", "standing against the wall" );
    bookcase->set_long( "This bookcase is made from oak and "
      "varnished to bring out the glow.  It has 2 "
      "shelves, upon which you can see some books, and "
      "other objects.\n" );
    bookcase->set_weight( 2000 );
    bookcase->set_max_weight( 4000 );
    bookcase->reset_get();
    bookcase->check_euid();
    bookcase->set_save_file( "/w/"+CREATOR+"/creator_kit" );
    bookcase->move( this_object() );
  }
}
object *query_non_destable()  {
  return ({ bookcase, board });
}
int check_player( string verb, object player, string special ) {
    if ( interactive( player ) ) {
        return 1;
    }
    notify_fail( "" );
    return 0;
}

==================================================
FILE: races/amphibian.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard amphibian" );
   set_height( 40 );
   set_weight( 600 );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "skull", "left eye", "right eye" }),
      "skull", "skull", ({ "head", 15, 0, "brain" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "brain", "brain", ({ "skull", 5, 0 }),
      "torso", "guts", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 10, 0 }),
      "liver", "liver", ({ "guts", 5, 0 }),
      "left kidney", "kidney", ({ "guts", 5, 0 }),
      "right kidney", "kidney", ({ "guts", 5, 0 }),
      "spleen", "spleen", ({ "guts", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "right front leg", "leg", ({ 0, 200, 0 }),
      "left front leg", "leg", ({ 0, 200, 0 }),
      "right back leg", "leg", ({ 0, 200, 0 }),
      "left back leg", "leg", ({ 0, 200, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull" });
   unrottable = ({ "skull" });
   set_skin( "skin" );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
   if( !do_setup )
      this_object()->setup();
}
int lives_in_water() { return 1; }

==================================================
FILE: races/ape.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "ape" );
   set_long( "The apes are any members of the family Pongidae of large "
      "semi-erect primates, including the chimpanzee, gorilla, orangutan "
      "and gibbon.\n" );
   set_weight( 2500 );
   set_height( 175 );
   set_stats( ({ 4, 4, 0, 4, 0 }) );
}
int query_eat( string type ) { return 1; }
string query_desc( object thing ) {
   if( (int)thing->query_gender() == 1 )
      return "He is your average hairy young male ape.\n";
   return "She is your average hairy young female ape.\n";
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", 15 + level / 10 );
   thing->add_ac( "sharp", "sharp", 10 + level / 15 );
   thing->add_ac( "pierce", "pierce", 12 + level / 12 );
   thing->reset_all();
}
int query_dark( int light ) {
   if( light < 10 ) return 1;
   if( light > 200 ) return 2;
   return 0;
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 10 + ( 3 * sqrt( number ) ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->add_attack( "hands", 75, ({ 2 * number, 8, number }),
      "blunt", "unarmed", "unarmed_hands" );
   thing->add_attack( "feet", 25, ({ 3 * number, 10, number }),
      "blunt", "unarmed", 0 );
}

==================================================
FILE: races/arachnid.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "A creature like scorpion, spider, daddy longlegs, mite, "
      "tick, and certain other invertebrate animals.  This file should "
      "be inherited by a more specialised race object." );
   bits = ({
      "cephalothorax", "head", ({ 0, 200, 0,
         "middle right upper eye", "middle right lower eye",
         "middle left upper eye", "middle left lower eye",
         "right upper eye", "right lower eye",
         "left upper eye", "left lower eye", "brain", "ganglion",
         "left fang", "right fang", "stomach", "mandible" }),
      "middle right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "brain", "brain", ({ "cephalothorax", 25, 0 }),
      "ganglion", "ganglion", ({ "cephalothorax", 50, 0 }),
      "left fang", "fang", ({ "cephalothorax", 25, 0 }),
      "right fang", "fang", ({ "cephalothorax", 25, 0 }),
      "stomach", "stomach", ({ "cephalothorax", 50, 0 }),
      "mandible", "mandible", ({ "cephalothorax", 25, 0 }),
      "abdomen", "abdomen", ({ 0, 500, 0, "lung", "stomach",
         "heart", "right front leg", "right middle front leg",
         "left front leg", "left middle front leg", "right back leg",
         "right middle back leg", "left back leg", "left middle back leg" }),
      "left middle back leg", "leg", ({ "abdomen", 25, 0 }),
      "left back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle back leg", "leg", ({ "addomen", 25, 0 }),
      "right back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "right front leg", "leg", ({ "abdomen", 25, 0 }),
      "left middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "left front leg", "leg", ({ "abdomen", 25, 0 }),
      "lung", "lung", ({ "abdomen", 100, 0 }),
      "stomach", "stomach", ({ "abdomen", 100, 0 }),
      "heart", "heart", ({ "abdomen", 100, 0 }),
      "pedicel", "pedicel", ({ 0, 100, 0 })
   });
   inedible = ({ "left fang", "right fang", "mandible" });
   unrottable = ({ "left fang", "right fang", "mandible" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
   if( !do_setup )
      this_object()->setup();
}
