




==================================================
FILE: /lib/obj/handlers/clothing_handler.c
==================================================

#include <clothing.h>
mapping _types;
mapping _equivilants;
mapping _zones;
string *_zone_level;
protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding);
protected void add_clothing_zone(string zone, string *types);
private int fixup_types(string type, string *types);
protected void add_equivilant_type(string name, string equiv);
private void check_clothing_types();
string *query_clothing_zone(string zone);
string *query_clothing_cannot_remove(string type);
string can_wear_or_remove(object thing, object player);
void create() {
   _types = ([ ]);
   _equivilants = ([ ]);
   _zones = ([ ]);
   _zone_level = ({ });
   add_clothing_type("bandaid", ({ }), ({ }));
   add_clothing_type("wig",
       ({ "hood", "helmet", "coif", "hat", "all covering" }),
       ({ "hood", "helmet", "coif", "hat", "all covering" }));
   add_clothing_type("hat",
       ({ "hood", "helmet", "all covering" }),
       ({ "hood", "helmet", "all covering" }));
   add_clothing_type("helmet",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering" }));
   add_clothing_type("hood",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("earring",
       ({ "coif", "all covering" }),
       ({ "hood", "coif", "all covering" }));
   add_clothing_type("moustache",
       ({ "coif", "mask", "all covering" }),
       ({ "coif", "mask", "all covering" }));
   add_clothing_type("glasses",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("nosering",
       ({ "mask", "coif", "all covering" }),
       ({ "mask", "coif", "all covering" }));
   add_clothing_type("mask",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("headband",
       ({ "hat", "hood", "helmet", "coif", "all covering" }),
       ({ "hat", "hood", "helmet", "coif", "all covering" }));
   add_clothing_type("scarf",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type("necklace",
       ({ "coif", "all covering" }),
       ({ "cloak", "coif", "all covering" }));
   add_clothing_type("collar",
       ({ "hood", "all covering" }),
       ({ "hood", "all covering"}));
   add_clothing_type( "shoulder",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
          "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
          "all covering" }));
   add_clothing_type( "bra",
       ({ "cloak", "cape", "sash", "robe",  "tabard", "breastplate",
          "hauberk", "haubergon", "byrnie", "jacket","jumper", "waistcoat",
          "shirt", "undershirt", "all covering", "long dress", "mini dress" }),
       ({ "cloak", "robe", "tabard", "breastplate", "hauberk", "haubergon",
           "byrnie", "jacket", "jumper", "waistcoat", "shirt", "undershirt",
           "all covering", "long dress", "mini dress" }));
   add_clothing_type("undershirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "waistcoat",
          "shirt", "harness", "all covering" }),
       ({ "cloak", "robe", "tabard", "breastplate", "haubergon", "hauberk",
          "byrnie", "jacket", "jumper", "shirt", "long dress", "mini dress",
          "all covering" }));
   add_clothing_type("shirt",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "waistcoat",
          "harness", "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("waistcoat",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket", "jumper", "harness",
          "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("harness",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("jumper",
       ({ "cloak", "cape", "sash", "robe", "breastplate", "haubergon",
          "hauberk", "byrnie", "tabard", "jacket",  "all covering" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "jacket",
          "all covering" }));
   add_clothing_type("jacket",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "all covering" }));
   add_clothing_type("tabard",
       ({ "cloak", "cape", "sash", "robe", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("robe",
       ({ "cloak", "cape", "sash", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cloak",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("sash",
       ({ "cloak", "cape", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("cape",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("armband",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("glove",
       ({ "all covering" }),
       ({ "all covering" }));
   add_clothing_type("bracelet",
       ({ "glove", "all covering" }),
       ({ "cloak", "glove", "all covering" }));
   add_clothing_type("ring",
       ({ "glove", "all covering" }),
       ({ "glove", "all covering" }));
   add_clothing_type("box",
       ({ "cloak", "robe", "all covering" }),
       ({ "cloak", "robe", "skirt", "all covering" }));
   add_clothing_type("apron",
       ({ "cloak", "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("underwear",
       ({ "harness", "trousers", "greave", "hauberk", "haubergon",
          "byrnie", "belt", "trousers", "all covering" }),
       ({ "cloak", "robe", "skirt", "trousers", "all covering",
          "long dress", "mini dress" }));
   add_clothing_type("garter",
       ({ "greave", "hauberk", "trousers", "all covering"}),
       ({ "cloak", "robe", "greave", "hauberk", "trousers", "skirt",
          "all covering", "long dress", "mini dress"}));
   add_clothing_type("skirt",
       ({ "belt", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("trousers",
       ({ "greave", "hauberk", "belt" }),
       ({ "cloak", "hauberk", "robe", "all covering" }));
   add_clothing_type("belt",
       ({"hauberk", "haubergon", "byrnie", "all covering" }),
       ({ "cloak", "robe", "hauberk", "haubergon", "byrnie", "all covering" }));
   add_clothing_type("sock",
       ({ "overshoe", "boot", "chausse", "all covering" }),
       ({ "cloak", "overshoe", "boot", "chausse", "all covering",
          "long dress", "trousers" }));
   add_clothing_type("anklet",
       ({ }),
       ({ "cloak", "overshoe", "chausse", "all covering" }));
   add_clothing_type("boot",
       ({ "overshoe" }),
       ({ "overshoe", "all covering" }));
   add_clothing_type("overshoe",
       ({ }),
       ({ "all covering" }));
   add_clothing_type("long dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("mini dress",
       ({ "cloak", "cape", "sash", "robe", "tabard", "breastplate",
          "haubergon", "hauberk", "byrnie", "jacket",  "jumper", "harness",
          "all covering","belt" }),
       ({ "cloak", "robe", "haubergon", "hauberk", "byrnie", "jacket",
          "jumper", "all covering" }));
   add_clothing_type("small shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("large shield",
       ({"all covering" }),
       ({ "all covering" }));
   add_clothing_type("badge",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("scabbard",
       ({ "all covering" }),
       ({ "cloak", "all covering" }));
   add_clothing_type("small scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("belt scabbard",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("coif",
       ({ "hood", "scarf", "mask", "helmet", "hat", "all covering"}),
       ({ "hood", "all covering"}));
   add_clothing_type("byrnie",
       ({ "cloak", "breastplate", "backplate", "tabard", "small scabbard",
          "belt scabbard", "robe", "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("haubergon",
       ({ "cloak", "breastplate", "backplate", "tabard", "vambrace",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering"}));
   add_clothing_type("hauberk",
       ({ "cloak", "tabard", "vambrace", "greave", "breastplate", "backplate",
          "small scabbard", "belt scabbard", "robe", "cape", "sash",
          "all covering"}),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("chausse",
       ({ "boot", "overshoe", "all covering"}),
       ({ "boot", "overshoe", "all covering"}));
   add_clothing_type("breastplate",
       ({ "cloak", "small scabbard", "belt scabbard", "robe", "tabard",
          "cape", "sash", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("backplate",
       ({ "cloak", "cape", "sash", "robe", "tabard", "all covering"}),
       ({ "cloak", "cape", "sash", "robe", "all covering"}));
   add_clothing_type("vambrace",
       ({ "glove", "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("greave",
       ({ "all covering" }),
       ({ "cloak", "robe", "all covering" }));
   add_clothing_type("all covering", ({}), ({}));
   add_clothing_zone("head",
       ({ "hood", "helmet", "coif", "hat", "wig", "headband", "moustache",
          "glasses", "mask" }));
   add_clothing_zone("neck",
       ({ "cloak", "hood", "coif", "cape", "scarf", "collar" }));
   add_clothing_zone("chest",
       ({ "cloak", "sash", "robe", "breastplate", "haubergon", "hauberk",
          "byrnie", "tabard", "jacket","jumper", "shirt", "undershirt",
          "shoulder", "bra","shield", "large shield", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("back",
       ({ "cloak", "cape", "sash", "robe", "hauberk", "haubergon", "byrnie",
          "jacket", "jumper", "shirt", "undershirt", "backplate",
          "long dress", "mini dress", "waistcoat" }));
   add_clothing_zone("abdomen",
       ({ "large shield", "robe", "breastplate", "byrnie", "hauberk",
          "skirt", "box", "trousers", "underwear", "long dress",
          "mini dress", "apron", "waistcoat" }));
   add_clothing_zone("arms",
       ({ "cloak", "small shield", "shield", "large shield", "robe",
          "vambrace", "hauberk", "haubergon", "jacket", "armband",
          "jumper", "shirt", "long dress" }));
   add_clothing_zone("hands",
       ({ "glove", "small shield", "shield", "large shield" }));
   add_clothing_zone("legs",
       ({ "cloak", "robe", "greave", "hauberk", "skirt", "trousers",
          "long dress" }));
   add_clothing_zone("feet",
       ({ "overshoe", "boot", "chausse", "sock", "anklet" }));
   add_equivilant_type("shoe", "boot");
   add_equivilant_type("sandal", "boot");
   add_equivilant_type("clog", "boot");
   add_equivilant_type("sabaton", "boot");
   add_equivilant_type("turban", "helmet");
   add_equivilant_type("gorget", "collar");
   add_equivilant_type("stocking", "sock");
   add_equivilant_type("coat", "cloak");
   add_equivilant_type("overall", "long dress");
   call_out((: check_clothing_types() :), 2);
}
object* query_items_blocking(object thing, object player) {
   int i;
   int j;
   int k;
   string *stuff;
   object *blocking;
   mixed junk;
   mixed main_types;
   object *wearing;
   main_types = thing->query_type();
   if (stringp(main_types)) {
      main_types = ({ main_types });
   }
   wearing = player->query_wearing() - ({ thing });
   blocking = ({ });
   for (k=0;k<sizeof(main_types);k++) {
      stuff = query_clothing_cannot_remove(main_types[k]);
      if (!sizeof(wearing) || !stuff) {
         return ({ });
      }
      for (i = 0; i < sizeof(wearing); i++) {
         junk = wearing[i]->query_type();
         if (stringp(junk)) {
            junk = ({ junk });
         }
         for (j = 0; j < sizeof(junk); j++) {
            if (member_array(junk[j], stuff) != -1 &&
                 member_array(wearing[i], blocking) == -1) {
               blocking += ({ wearing[i] });
               break;
            }
         }
      }
   }
   return blocking;
}
string can_wear_or_remove( object thing, object player ) {
   object *blocking;
   blocking = query_items_blocking(thing, player);
   if (sizeof(blocking)) {
     return "when you are wearing "+ query_multiple_short(blocking);
   }
   return 0;
}
protected void add_clothing_type(string name,
                                 string *not_remove,
                                 string *hiding) {
   _types[name] = new (class clothing_type, _hiding : hiding,
                                           _not_remove : not_remove);
}
class clothing_type query_clothing_type(string name) {
   return _types[name];
}
string *query_clothing_cannot_remove(string type) {
   class clothing_type bing;
   bing = _types[type];
   if (bing) {
      return bing->_not_remove;
   }
   return 0;
}
string *query_clothing_hiding(string type) {
   class clothing_type bing;
   bing = _types[type];
   if (bing) {
      return bing->_hiding;
   }
   return ({ });
}
int query_clothing_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int min_depth;
   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      min_depth = 100000;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth < min_depth && depth > 0) {
            min_depth = depth;
         }
      }
      return min_depth;
   }
   return 0;
}
int query_clothing_maximum_depth(mixed type) {
   class clothing_type bing;
   int depth;
   string str;
   int max_depth;
   if (stringp(type)) {
      bing = _types[type];
      if (bing) {
         return bing->_depth;
      }
   } else if (pointerp(type)) {
      max_depth = 0;
      foreach (str in type) {
         depth = query_clothing_depth(str);
         if (depth > max_depth) {
            max_depth = depth;
         }
      }
      return max_depth;
   }
   return 0;
}
mapping query_all_clothing_types() {
   return _types;
}
private void check_clothing_types() {
   string ty;
   class clothing_type bits;
   string *stuff;
   string bing;
   string type;
   int rank;
tell_creator("presto", "called check_clothing_types\n");
   foreach (ty, bits in _types) {
      foreach (bing in bits->_not_remove) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the not remove "
                  " for " + ty + ".\n");
         }
      }
      foreach (bing in bits->_hiding) {
         if (!query_clothing_type(bing)) {
            write("Unknown clothing type " + bing + " in the hiding "
                  " for " + ty + ".\n");
         }
      }
   }
   rank = 1;
   foreach (bing in _zone_level) {
      stuff = query_clothing_zone(bing);
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth &&
             (sizeof(bits->_not_remove) == 0  ||
             bits->_not_remove[0] == "all covering")) {
            bits->_depth = rank;
            rank = fixup_types(type, stuff);
         }
      }
      foreach (type in stuff) {
         bits = _types[type];
         if (!bits->_depth) {
tell_creator("presto", "setting depth of %O to %d\n", type, rank + 1);
            bits->_depth = rank++;
         }
      }
   }
}
private int fixup_types(string type, string *types) {
   string bing;
   class clothing_type base;
   class clothing_type bits;
   int depth;
   base = _types[type];
   depth = base->_depth + 1;
   foreach (bing in types) {
      bits = _types[bing];
      if (!bits->_depth &&
          member_array(type, bits->_not_remove) != -1) {
         bits->_depth = depth;
         depth = fixup_types(bing, types);
      }
   }
   return depth;
}
protected void add_clothing_zone(string zone, string *types) {
   string ty;
   foreach (ty in types) {
      if (!query_clothing_type(ty)) {
         write("Incorrect clothing type " + ty + " in zone " + zone + ".\n");
      }
   }
   _zones[zone] = types;
   _zone_level += ({ zone });
}
protected void add_zone_coverage(string type, string *zones) {
  string zone;
  if(!query_clothing_type(type))
    write("Incorrect clothing type " + type + "\n");
  foreach(zone in zones)
    if(member_array(type, zones) != -1)
      _zones[zone] += ({ type });
}
mapping query_all_clothing_zones() {
   return _zones;
}
string *query_clothing_zone(string zone) {
   return _zones[zone];
}
string query_zone_name(string type) {
   string zone;
   string *stuff;
   foreach (zone, stuff in _zones) {
      if (member_array(type, stuff) != -1) {
         return zone;
      }
   }
   return 0;
}
string *query_zone_names(string type) {
   string zone;
   string *stuff;
   string *zones;
   if(_equivilants[type])
     type = _equivilants[type];
   zones = ({ });
   foreach (zone, stuff in _zones) {
     if (member_array(type, stuff) != -1 && zone) {
       zones += ({ zone });
     }
   }
   return zones;
}
int query_zone_level(string zone) {
   int i;
   i = member_array(zone, _zone_level);
   return i * 100;
}
protected void add_equivilant_type(string name, string equiv) {
   if (!query_clothing_type(equiv)) {
      write("Incorrect clothing type " + equiv + " in equivilant listing.\n");
   }
   _equivilants[name] = equiv;
}
mapping query_all_equivilant_types() {
   return _equivilants;
}
string query_equivilant_type(string type) {
   return _equivilants[type];
}
int query_valid_type(string type) {
   if (query_clothing_type(type) ||
       query_equivilant_type(type)) {
      return 1;
   }
   return 0;
}

==================================================
FILE: /lib/obj/handlers/club_handler.c
==================================================

inherit "/obj/handlers/inherit/club_inherit";
void create() {
   ::create();
   setup_call_check_clubs(0, 1);
}
void dest_me() {
   save_cache();
   destruct(this_object());
}

==================================================
FILE: /lib/obj/handlers/clusters.c
==================================================

#if !efun_defined(db_exec)
#define OLD
#else
#include <db.h>
#endif
#include <map.h>
#define SIZE 7
#define LEVEL(x) load(x)->level
#include <config.h>
nosave int maxnum = 0;
nosave int lasttime = 0;
nosave int count = 0;
nosave mapping used = ([ ]);
nosave mixed *todo= ({ });
nosave mapping cache = ([ ]);
nosave int setup_done = 1;
nosave int db;
nosave int setup_start_time;
class cluster{
  mixed *members;
  int level;
  int cluster_number;
  int this_cluster;
  mixed *contacts;
}
#ifndef OLD
private int get_cluster(mixed);
private mixed cdb_fetch(int fd, int row){
  mixed stuff = db_fetch(fd, row);
  if(arrayp(stuff)){
    mixed tmp, ret = ({});
    foreach(tmp in stuff){
      if(stringp(tmp)){
        int i;
        sscanf(tmp, "%d", i);
        if(i || tmp == "0")
          tmp = i;
      }
      ret += ({tmp});
    }
    stuff = ret;
  }
  return stuff;
}
#endif
private class cluster load(int x){
  mixed rows;
  class cluster tmp = new(class cluster);
  if(cache[x])
    return cache[x];
#ifdef OLD
  cache[x] = restore_variable(unguarded((: read_file(sprintf("/save/clusters/%d",
                                                           (int)$(x))) :)));
#else
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", x);
  if(stringp(rows) || !rows)
    return 0;
  tmp->members = ({});
  rows++;
  while(--rows)
    tmp->members += cdb_fetch(db, rows);
  rows = db_exec(db, "select level, in_cluster from cluster_list where cluster_number = %d", x);
  if(stringp(rows)){
    db_close(db);
    db = db_connect("localhost","discworld",CONFIG_DB_USER);
    return 0;
  }
  rows = cdb_fetch(db, 1);
  tmp->level = rows[0];
  tmp->cluster_number = rows[1];
  tmp->this_cluster = x;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", x);
  if(stringp(rows))
    return 0;
  tmp->contacts = ({});
  rows++;
  while(--rows)
    tmp->contacts += cdb_fetch(db, rows);
  cache[x] = tmp;
#endif
  return cache[x];
}
private void save(class cluster x){
#ifdef OLD
  unguarded((:write_file(sprintf("/save/clusters/%d", $(x->this_cluster)),
                           save_variable($(x)), 1):));
#else
  db_exec(db, "insert into cluster_list values (%d, %d, %d)", x->this_cluster,
          x->level, x->cluster_number);
  map(x->members, (:db_exec(db, "insert into cluster_members values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
  map(x->contacts, (:db_exec(db, "insert into cluster_contacts values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
#endif
  cache[x->this_cluster] = x;
}
private void make_clusters(mixed);
nosave function fix_contacts;
nosave function fix_room_contacts;
private void create(){
#ifndef OLD
  db = db_connect("localhost","discworld",CONFIG_DB_USER);
  map(({"cluster_members", "cluster_list", "cluster_contacts"}),
      (:db_exec(db, "delete from %s;", $1):));
#endif
  fix_room_contacts = function(int i){
    class cluster fixing = load(i);
    if((sizeof(fixing->contacts)) && intp(fixing->contacts[0])){
      error(sprintf("%d in two or more clusters", i));
      return;
    }
    fixing->contacts = uniq_array(map(fixing->contacts,
#ifdef OLD
                                      (:MAP->query_cluster($1):)
#else
                                      (:cache[$1]:)
#endif
                                      ));
  save(fixing);
  };
  fix_contacts = function (int i){
    class cluster fixing = load(i);
    reset_eval_cost();
    if(fixing->level){
      if((sizeof(fixing->contacts)) && (fixing->level ==
                                        LEVEL(fixing->contacts[0]))){
        error(sprintf("%d in two or more clusters", i));
        return;
      }
      fixing->contacts = uniq_array(map(fixing->contacts,
                                        (:load($1)->cluster_number:)));
      save(fixing);
      if(fixing->level > 1){
        map(fixing->members, (:efun::call_out((fix_contacts), 0, $1):));
        return;
      }
      map(fixing->members, fix_room_contacts);
    }
  };
#ifdef OLD
  unguarded(function(){
    string file, *files=get_dir("/save/clusters/");
    foreach(file in files)
      rm(sprintf("/save/clusters/%s", file));
  });
#endif
}
private void make_clusters(mixed start){
  int count = 0, depth = -1, oldmax = maxnum, level = (stringp(start)? 0 :
                                                       load(start)->level + 1);
  class cluster current;
  mixed *list;
  function qdd, real;
  if(stringp(start)){
    qdd = function(string room){
      function f = function(string there, string room){
        mixed tmp;
        return member_array(room,
                            (tmp = MAP->qdd(there), tmp? tmp : ({}))) + 1;
      };
      string *qdd = MAP->qdd(room);
      return filter(allocate(sizeof(qdd) / 2, (:$(qdd)[$1 * 2 + 1]:)), f, room);
    };
    real = (:$1:);
  } else {
    qdd = (:load($1)->contacts:);
    if(stringp(load(start)->contacts[0]))
      real = (:cache[$1]:);
    else
      real = (:load($1)->cluster_number:);
  }
  current = new (class cluster, members:({start}),
                 level:level,
                 this_cluster:++maxnum,
                 contacts:({}));
  list = ({start});
  if(used[start])
    error(sprintf("%O already in a cluster", start));
  used[start] = 1;
  while(++depth < sizeof(list) || sizeof(todo)){
    mixed *exits;
    mixed exit;
    if(depth < sizeof(list))
      exits = (*qdd)(list[depth]);
    else {
      count = SIZE + 1;
      exits = ({});
    }
    foreach(exit in exits) {
      if(!used[exit = (*real)(exit)]) {
        current->members += ({exit});
        list += ({exit});
        used[exit] = 1;
        if(++count > SIZE)
          break;
      }
    }
    if(count > SIZE || !(((1 + depth) < sizeof(list)) || sizeof(todo))){
      mixed tmp, *contacts = ({});
      count = 0;
      foreach(tmp in current->members){
        reset_eval_cost();
        if(stringp(tmp)){
#ifdef OLD
          MAP->set_cluster(tmp, current->this_cluster)
#endif
          ;
          cache[tmp] = current->this_cluster;
        }
        else{
          class cluster clust;
          clust = load(tmp);
          clust->cluster_number = current->this_cluster;
          cache[tmp] = clust;
        }
        exits = (*qdd)(tmp);
        if(exits){
          function add_non_member, convert_and_add;
          add_non_member = (: (member_array($2, $(current->members)) == -1)?
                            ($1 | ({ $2 })) :
                            $1
                           :);
          convert_and_add = (:evaluate($(add_non_member), $1,
                                      evaluate($(real), $2)):);
          contacts = implode(exits, convert_and_add, contacts);
        }
      }
      current->contacts = contacts;
      if(sizeof(contacts) || current->level > 1)
        cache[current->this_cluster] = current;
      else
        maxnum--;
      todo = filter(todo + list + contacts, (:!used[$1]:));
      depth = -1;
      if(sizeof(todo)){
        list = ({todo[0]});
        todo = todo[1..];
        if(used[list[0]])
          error("corrupt todo list");
        used[list[0]] = 1;
        current = new (class cluster, members:({list[0]}),
                       level:level,
                       this_cluster:++maxnum,
                       contacts:({}));
      } else
        list = ({ });
    }
  }
  if((maxnum - oldmax) > SIZE)
    make_clusters(current->this_cluster - 1);
  else {
    int i;
    for(i = oldmax + 1; i <= maxnum; i++)
      if(LEVEL(i))
        efun::call_out(fix_contacts, 0, i);
      else
        efun::call_out(fix_room_contacts, 0, i);
  }
  used = ([]);
  efun::call_out((:cache = ([]), setup_done = 1:), 2);
}
#ifndef OLD
private int get_cluster(mixed thing){
  if(stringp(thing)){
    mixed exret = db_exec(db, "select cluster_number from cluster_members where member = '%s'",
                          db_escape(thing));
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  } else if(intp(thing)){
    mixed exret = db_exec(db, "select in_cluster from cluster_list where cluster_number = %d",
                          thing);
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  }
  return 0;
}
#endif
private int query_top_cluster(string room){
  int ret;
#ifdef OLD
  ret = MAP->query_cluster(room);
  if(ret && unguarded((:file_size(sprintf("/save/clusters/%d", $(ret))):)) > 0)
    while(load(ret)->cluster_number){
      int last = ret;
      ret = load(ret)->cluster_number;
      if(last == ret)
        return ret;
    }
#else
  ret = get_cluster(room);
  if(ret){
    int last = ret;
    ret = get_cluster(ret);
    while(ret){
      last = ret;
      ret = get_cluster(ret);
    }
    return last;
  }
#endif
  else{
    setup_start_time = time();
    setup_done = 0;
    make_clusters(room);
  }
  return ret;
}
#ifndef OLD
private mixed *get_members(int clust){
  mixed rows;
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
private mixed *get_contacts(int clust){
  mixed rows;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
#endif
private mixed *find_places(int start, int end, int *places){
  int found = 0, depth = 0;
  int *key;
  int *exits, bing, *result, ob, exit;
  mapping search = ([]);
  if(start == end){
#ifdef OLD
    return load(start)->members;
#else
    return get_members(start);
#endif
  }
  key = ({ start });
  search[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
#ifdef OLD
      exits = load(ob)->contacts;
#else
      exits = get_contacts(ob);
#endif
      foreach(exit in exits) {
        if ((!search[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && ++depth >= sizeof(key))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
#ifdef OLD
    result += load(bing)->members;
#else
    result += get_members(bing);
#endif
    bing = search[bing];
  }
#ifdef OLD
  result += load(bing)->members;
#else
  result += get_members(bing);
#endif
  return result;
}
private mixed find_route(mixed start, mixed end, string *places){
  int found = 0, i, depth = 0;
  string *key;
  string *exits, bing, *result, ob;
  mapping route = ([]), search = ([]);
  int t = real_time();
  if(start == end)
    return ({});
  key = ({ start });
  route[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
      exits = MAP->qdd(ob);
      for (i = 1; i < sizeof(exits); i += 2) {
        mixed exit = exits[i];
        if ((!route[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          route[exit] = exits[i - 1];
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && (++depth >= sizeof(key) || (real_time() - t) > 4))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
    result = ({route[bing]}) + result;
    bing = search[bing];
  }
  return result;
}
nosave int debugging = 0;
private void debug(int *clusters){
  int cluster;
  if(debugging)
    error("read the error trace");
  debugging = 1;
  reset_eval_cost();
  while(intp(load(clusters[0])->members[0]))
    clusters = implode(clusters, (:$1 + load($2)->members:), ({}));
  foreach(cluster in clusters){
    string *rooms = load(cluster)->members;
    string room, room2;
    reset_eval_cost();
    foreach(room in rooms)
      foreach(room2 in rooms)
        if(!this_object()->get_route(room, room2))
          error("cluster error");
  }
}
string* get_route(string start, string end, function callback){
  mixed *places = ({}), *oldplaces;
  int sip = 0;
  int from, to;
  int level;
  if(lasttime != time()){
    lasttime = time();
    count = 0;
  } else {
    if(count++ > 10) {
      return ({});
    }
  }
  if(!setup_done){
    if((time()-setup_start_time) < 5)  {
      return 0;
    }
#ifndef OLD
#endif
    catch(unguarded(function(){
      cp("/log/runtime", "/w/wodan/clusterruntime");
      cp("/log/catch", "/w/wodan/clustercatch");
    }));
    tell_creator("wodan", "would have dested");
    setup_done = 1;
    return 0;
  }
  if(!stringp(start)){
    start = base_name(start);
    if(!stringp(start))
      error("illegal start point");
  }
  if(!stringp(end)){
    end = base_name(end);
    if(!stringp(end))
      error("illegal end point");
  }
  if(catch(from = query_top_cluster(start))){
#ifndef OLD
    db_close(db);
    db = db_connect("localhost","discworld", CONFIG_DB_USER);
#endif
    return 0;
  }
  if(!setup_done) {
    return 0;
  }
  if(from) {
    level = LEVEL(from);
  }
  to = query_top_cluster(end);
  if(!to || (level != LEVEL(to))) {
    return ({});
  }
  while (level) {
#ifdef OLD
    from = MAP->query_cluster(start);
    to = MAP->query_cluster(end);
#else
    from = get_cluster(start);
    to = get_cluster(end);
#endif
    while((from != to) && (LEVEL(from) < level)){
      from = load(from)->cluster_number;
      to = load(to)->cluster_number;
    }
    level = LEVEL(from);
    if(!level){
      if(!sip) {
        break;
      }
      error("wrong level");
    }
    oldplaces = places;
    places = find_places(from, to, places);
    if(!places){
      if(!sip) {
        return ({});
      }
      debug(oldplaces);
      error("this can't happen, honest!");
    }
    sip = 1;
    level--;
  }
#ifdef OLD
  from = MAP->query_cluster(start);
  to = MAP->query_cluster(end);
#else
  from = get_cluster(start);
  to = get_cluster(end);
#endif
  oldplaces = places;
  places = find_places(from, to, places);
  if(!places){
    if(!sip) {
      return ({});
    }
    debug(oldplaces);
    error("this can't happen, honest!!");
  }
  cache = ([]);
  return find_route(start, end, places);
}
#ifndef OLD
void dest_me(){
  db_close(db);
  destruct(this_object());
}
#endif

==================================================
FILE: /lib/obj/handlers/cmr_handler.c
==================================================

#include <cmr.h>
#include <colour.h>
#include <library.h>
#define SAVE_FILE "/save/cmr_handler"
inherit "/std/object";
string *colour_names;
mapping colour_details;
string *material_names;
mapping material_details;
void load_cmr_handler();
void save_cmr_handler();
void create();
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh );
int *query_colour_details( string word );
int delete_colour( string word );
string *query_colour_names();
string identify_colour( string word, object player );
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh );
int *query_material_details( string word );
int delete_material( string word );
string *query_material_names();
string identify_material( string word, object player, int article );
string query_material_adjective( string word );
void load_cmr_handler() {
  if ( file_size( SAVE_FILE +".o" ) > 0 )
    unguarded((: restore_object, SAVE_FILE :));
}
void save_cmr_handler() {
  unguarded((: save_object, SAVE_FILE :));
}
void create() {
  colour_names = ({ });
  colour_details = ([ ]);
  material_names = ({ });
  material_details = ([ ]);
  ::create();
  load_cmr_handler();
}
string add_colour( string word, int fine, int crude, int qp_thresh,
                int sp_thresh ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp != -1 ) return "colour already exists";
  colour_names += ({ word });
  colour_details += ([ word : ({ fine, crude, qp_thresh, sp_thresh }) ]);
  save_cmr_handler();
  return "the colour "+ word +", a shade of "+ ( ( fine == crude )?
         "pure ":MODIFIERS[fine] ) + COLOURS[crude] +", with thresholds of "+
         qp_thresh +" xp and "+ sp_thresh +" sp";
}
int *query_colour_details( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return ({ -1 });
  return colour_details[word];
}
int delete_colour( string word ) {
  int temp;
  temp = member_array( word, colour_names );
  if ( temp == -1 ) return 0;
  colour_names -= ({ word });
  colour_details = m_delete( colour_details, word );
  save_cmr_handler();
  return 1;
}
string *query_colour_names() { return colour_names + ({ }); }
string identify_colour( string word, object player ) {
  int temp, *args;
  temp = member_array( word, colour_names );
  if ( temp == -1 )
    return "unknown colour";
  args = allocate( 4 );
  args = colour_details[word];
  if ( !player )
    return word;
  switch ( ( ( LIBRARY->query_quest_points(player->query_name()) ) > args[2] )+
           ( ( player->query_max_gp() ) > args[3] ) ) {
  case 0:
    return COLOURS[args[1]];
  case 1:
    return ( ( ( args[0] == args[1] )?"pure ":MODIFIERS[args[0]] ) +
             COLOURS[args[1]] );
  default:
    return word;
  }
}
string add_material( string word, int colour, int type, int skill_reqd,
                  int skill_thresh ) {
  int temp;
  string text;
  temp = member_array( word, material_names );
  if ( temp != -1 ) return "material already exists";
  material_names += ({ word });
  material_details += ([ word : ({ colour, type, skill_reqd,
                         skill_thresh }) ]);
  save_cmr_handler();
  if ( !skill_reqd )
    text = " that is always recognised";
  else
    if ( skill_reqd == LEARNT )
      text = " that is recognised through knowledge";
    else
      text = " that has a threshold of "+ skill_thresh +" in "+
             SKILLS[skill_reqd];
  return word +", a"+ ( ( colour == COL_ORANGE )?"n ":" " ) +
         COLOURS[colour] +" "+ MATERIALS[type] + text;
}
int *query_material_details( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return ({ -1 });
  return material_details[word];
}
int delete_material( string word ) {
  int temp;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return 0;
  material_names -= ({ word });
  material_details = m_delete( material_details, word );
  save_cmr_handler();
  return 1;
}
string *query_material_names() { return material_names + ({ }); }
string identify_material( string word, object player, int article ) {
  int temp, *args;
  string prefix;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "unknown material";
  args = allocate( 4 );
  args = material_details[word];
  prefix = ( ( article )?"a"+ ( ( args[0] == COL_ORANGE )?"n ":" " ):"" );
   if ( !args[ 2 ] || !player )
      return word;
  if ( args[2] == LEARNT )
    if ( member_array( word,
        (string *)CMR_LIBRARY->query_known_materials( player->query_name() ) )
        == -1 )
      return prefix + COLOURS[ args[ 0 ] ] +" "+
          MATERIALS[ args[ 1 ] ];
    else
      return word;
  if ( ( player->query_skill_bonus( SKILLS[args[2]] ) ) > args[3] )
    return word;
  else return prefix + COLOURS[args[0]] +" "+ MATERIALS[args[1]];
}
string query_material_adjective( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "an unknown material";
  args = allocate( 4 );
  args = material_details[word];
  return COLOURS[args[0]] +" "+ MATERIAL_ADJECTIVES[args[1]];
}
string query_material_ansi_colour( string word ) {
  int temp, *args;
  temp = member_array( word, material_names );
  if ( temp == -1 ) return "";
  args = allocate( 4 );
  args = material_details[word];
  return ANSI_COLOURS[args[0]];
}

==================================================
FILE: /lib/obj/handlers/cmr_library.c
==================================================

#define RESTORE_PATH "/save/cmr_library/"
inherit "/std/object";
string player_name, *materials;
void init_data( string pname ) {
  player_name = pname;
  materials = ({ });
}
int get_data_file( string pname ) {
  if ( player_name != pname ) {
    if ( file_size( RESTORE_PATH + pname +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + pname :));
    else {
      init_data( pname );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
string *query_known_materials( string pname ) {
  get_data_file( pname );
  if ( !materials ) {
    return ({ });
  }
  return materials + ({ });
}
int query_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( !materials ) return 0;
  return ( member_array( material, materials ) != -1 );
}
int add_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( member_array( material, materials ) != -1 ) {
    return 0;
  }
  materials += ({ material });
  save_data_file( player_name );
  return 1;
}

==================================================
FILE: /lib/obj/handlers/co_ordinate_handler.c
==================================================

#include <dirs.h>
class room_data {
   string other;
   string direction;
   int* coords;
   int last_update;
}
private mapping _rooms = ([ ]);
private nosave mapping _dirs;
int setup_room(string path);
void create() {
   mixed* bits;
   int i;
   bits = STD_ORDERS;
   _dirs = ([ ]);
   for (i = 0; i < sizeof(bits); i += 2) {
      _dirs[bits[i]] = bits[i + 1];
   }
}
private void setup_specific_room(string path, string new_path, string dir) {
   int* delta;
   int* co_ord;
   int k;
   class room_data data;
   delta = new_path->query_room_size_array() + path->query_room_size_array();
   co_ord = copy( _rooms[new_path]->coords);
   for ( k = 0; k < 3; k++ ) {
     co_ord[ k ] += _dirs[dir][ k ] *
                    ( delta[ k ] + delta[ k + 3 ] );
   }
   data = new(class room_data);
   data->other = new_path;
   data->coords = co_ord;
   data->direction = dir;
   data->last_update = _rooms[new_path]->last_update;
   _rooms[path] = data;
}
int* query_room_co_ords(string path) {
   class room_data data;
   data = _rooms[path];
   if (data) {
      if (!_rooms[data->other]) {
         map_delete(_rooms, path);
      } else {
         if (data->last_update != _rooms[data->other]->last_update) {
            setup_specific_room(path, data->other, data->direction);
         }
         return data->coords;
      }
   }
   if (setup_room(path)) {
      data = _rooms[path];
      return data->coords;
   }
   return 0;
}
int setup_room(string path) {
   string* bits;
   int i;
   string new_path;
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }
   bits = path->query_dest_dir();
   for (i = 0; i < sizeof(bits); i += 2) {
      if (find_object(bits[i+1])) {
         new_path = file_name(find_object(bits[i+1]));
      } else {
         new_path = bits[i+1];
      }
      if (_rooms[new_path]) {
         setup_specific_room(path, new_path, bits[i]);
         return 1;
      }
   }
   return 0;
}
void setup_fixed_room(string path, int* coords) {
   class room_data data;
tell_creator("pinkfish", "%O %O %O\n", path, path->query_property("location"),
               path->query_terrain_handler());
   if (path->query_property("location") != "outside" ||
       !path->query_terrain_handler()) {
      return 0;
   }
   if (_rooms[path]) {
      data = _rooms[path];
      if (data->coords[0] == coords[0] &&
          data->coords[1] == coords[1] &&
          data->coords[2] == coords[2]) {
         return ;
      }
   } else {
      data = new(class room_data);
   }
   data->coords = coords;
   data->last_update = time();
   _rooms[path] = data;
}
mapping query_rooms() {
   return _rooms;
}

==================================================
FILE: /lib/obj/handlers/colour.c
==================================================

#include <colour.h>
string calc_colour( int red, int green, int blue, int whitener ) {
   int main_hue;
   string result;
   result = "";
   if ( whitener > -1 ) {
      switch ( red + green + blue ) {
         case 0 .. 4 :
            return "colourless";
         case 5 .. 29 :
            result += "faint ";
            break;
         case 30 .. 154 :
            break;
         default :
            result += "intense ";
      }
   }
   return result;
}

==================================================
FILE: /lib/obj/handlers/complaints_handler.c
==================================================

#include <board.h>
#define SAVEFILE "/save/complaints/complaints_handler.o"
#define BOARD "complaints"
int _complaintNumber;
void save_file() {
    unguarded( (: save_object( SAVEFILE ) :) );
}
void load_file() {
    unguarded( (: restore_object( SAVEFILE ) :) );
}
void create() {
    seteuid( getuid() );
    _complaintNumber = 1;
    load_file();
}
int do_submit_complaint( string str ) {
    int ret = 0;
    if ( str ) {
        ret = BOARD_HAND->
            add_message( BOARD, "Anonymous",
                         "Anonymous complaint #" + _complaintNumber,
                         sprintf( "%-=78s\n", str ) );
        _complaintNumber++;
        save_file();
    }
    return ret;
}
int board_access_check( int type, string, object previous, string name ) {
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
    case B_ACCESS_DELETE :
        return 0;
    }
}

==================================================
FILE: /lib/obj/handlers/converter.c
==================================================

mixed *mail;
nosave string *names;
nosave int no_more;
int query_busy(string name);
void create() {
  seteuid("mailer");
  names = ({ });
  no_more = 0;
}
int ok_to_shut() {
  no_more = 1;
  return (sizeof(names) == 0);
}
void convert_it(string pname) {
  int i, bing;
  if (no_more) {
    write("Can't start converting mail, try again after the reboot.\n");
    return;
  }
  if (query_busy(pname)) {
    write("Argh ! Already busy converting mail for "+pname+".\n");
    return;
  }
  mail = ({ });
  if (file_size("/save/post/"+pname+".o") == -1)
    return;
  unguarded((: restore_object, "/save/post/"+pname :));
  bing = sizeof(mail);
  if (!bing) {
    unguarded((: rm, "/save/post/"+pname+".o" :));
    return;
  }
  write("Converting mail for "+pname+".\n");
  names += ({ pname });
  for (i = 0; i < bing; i++) {
    reset_eval_cost();
    call_out("do_it", (i+1)*3, (mail[i] + ({ pname })));
  }
  call_out("reset_busy", (i+1)*3, pname);
  unguarded((: rm, "/save/post/"+pname+".o" :));
}
void do_it(mixed *arg) {
  object handler = clone_object("/obj/handlers/folder_handler");
  handler->add_it((["to" : ({ arg[6] }),
    "cc" : ({ }), "from" : arg[1], "subject" : arg[3], "body" :
    "From "+arg[1]+" "+ctime(arg[0])+
    "\nDate: "+ctime(arg[0])+
    "\nFrom: "+arg[1]+
    "\nTo: "+arg[2]+
    "\nSubject: "+arg[3]+
    "\nCc: "+(arg[4]?arg[4]:"")+"\n\n"+
    arg[5] ]), 1);
}
int query_busy(string name) {
  return (member_array(name, names) != -1);
}
void reset_busy(string name) {
  names -= ({ name });
  if (no_more && !sizeof(names)) {
    "/obj/shut"->shut(2);
  }
}

==================================================
FILE: /lib/obj/handlers/corpse_handler.c
==================================================

#include <player_handler.h>
#define CORPSE_SAVE_DIR "/save/corpses/"
#define CORPSE_RAM_DIR "/save/ramdisk/corpses/"
#define CORPSE_SAVE_FILE "/save/corpses/main"
#define CORPSE_OBJECT "/obj/corpse"
private mapping _corpses;
private nosave mapping _to_save;
private nosave int _save_things_id;
private int _corpse_id;
class corpse_data {
   int id;
}
void create() {
   seteuid(getuid());
   _corpses = ([ ]);
   _corpse_id = 1;
   _to_save = ([ ]);
   unguarded( (: restore_object(CORPSE_SAVE_FILE,  1) :));
   call_out("check_corpses", 10);
}
private void save_me() {
   unguarded( (: save_object(CORPSE_SAVE_FILE,  3) :));
}
private class corpse_data find_corpse_data(string name, int id) {
   class corpse_data corpse;
   if (!_corpses[name]) {
      return 0;
   }
   foreach (corpse in _corpses[name]) {
      if (corpse->id == id) {
         return corpse;
      }
   }
   return 0;
}
private class corpse_data find_corpse_ob_data(object ob) {
   string name;
   int id;
   name = ob->query_ownership();
   id = ob->query_corpse_id();
   return find_corpse_data(name, id);
}
object* find_player_corpses(string player) {
   object* corpses;
   corpses = filter( children( "/obj/corpse" ),
             (: $1 && $1->query_property( "player" ) &&
                $1->query_ownership() == $2 :), player );
   return corpses;
}
private void really_save_corpses() {
  object ob, player;
  class corpse_data corpse;
  string data;
  string fname;
  foreach (ob, corpse in _to_save) {
    if(!ob)
      continue;
    data = ob->query_save_data();
    if (stringp(data)) {
#ifdef USE_RAMDISK
      fname = CORPSE_RAM_DIR + corpse->id;
#else
      fname = CORPSE_SAVE_DIR + corpse->id;
#endif
      unguarded((: write_file($(fname), $(data), 1) :));
    } else {
      tell_creator("pinkfish", "Bad corpse save %O %O\n", ob, data);
    }
    player = find_player(ob->query_owner());
    if(player)
      player->save_me();
  }
  _to_save = ([ ]);
}
void save_corpse(object ob) {
   class corpse_data corpse;
   if (!ob->query_property("player") || !ob->query_ownership()) {
      return ;
   }
   corpse = find_corpse_ob_data(ob);
   if (!corpse) {
      tell_creator("pinkfish", "Cannot find the corpse to save %O [%O].\n",
                   ob, ob->query_ownership());
      return ;
   }
   _to_save[ob] = corpse;
   if (_save_things_id) {
      remove_call_out(_save_things_id);
   }
   _save_things_id = call_out((: really_save_corpses :), 2);
}
object create_corpse(string name, int id) {
   class corpse_data corpse;
   string data, fname;
   object ob;
   corpse = find_corpse_data(name, id);
#ifdef USE_RAMDISK
   if(unguarded( (: file_size(CORPSE_RAM_DIR + $(corpse->id)) :)) > 0)
     fname = CORPSE_RAM_DIR + corpse->id;
#endif
   if(!fname)
     fname = CORPSE_SAVE_DIR + corpse->id;
   data = unguarded( (: read_file($(fname)) :));
   if (data) {
     ob = clone_object(CORPSE_OBJECT);
     ob->setup_corpse_from_save(data, name, id);
     return ob;
   }
   return 0;
}
void check_corpses() {
   class corpse_data* corpses;
   string name;
   object* obs;
   int i;
   int j;
   foreach (name, corpses in _corpses) {
      obs = find_player_corpses(name);
      for (i = 0; i < sizeof(corpses); i++) {
         for (j = 0; j < sizeof(obs); j++) {
            if (obs[j]->query_corpse_id() == corpses[i]->id) {
               corpses = corpses[0..i -1] + corpses[i+1..];
               i--;
            }
         }
      }
      if (sizeof(corpses)) {
         for (i = 0; i < sizeof(corpses); i++) {
            create_corpse(name, corpses[i]->id);
         }
      }
   }
}
int query_next_corpse_id() {
   int id;
   id = _corpse_id++;
   save_me();
   return id;
}
void register_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;
   tell_creator("Registering %O (%O)\n", ob, ob->query_ownership());
   name = ob->query_ownership();
   if(PLAYER_HANDLER->test_creator(name)) {
     tell_creator("pinkfish", "Not registering creator corpse %O (%O)\n",
                  ob, ob->query_ownership());
     return;
   }
   id = ob->query_corpse_id();
   corpse = find_corpse_ob_data(ob);
   if (corpse) {
      save_corpse(ob);
      return ;
   }
   corpse = new(class corpse_data);
   corpse->id = id;
   if (!_corpses[name]) {
      _corpses[name] = ({ corpse });
   } else {
      _corpses[name] += ({ corpse });
   }
   save_me();
   save_corpse(ob);
}
void deregister_corpse(object ob) {
   string name;
   int id;
   class corpse_data corpse;
   int i;
   if (!ob->query_property("player")) {
      return ;
   }
   name = ob->query_ownership();
   id = ob->query_corpse_id();
   for (i = 0; i < sizeof(_corpses[name]); i++) {
      corpse = _corpses[name][i];
      if (corpse->id == id) {
         _corpses[name] = _corpses[name][0..i-1] + _corpses[name][i+1..];
         if (!sizeof(_corpses[name])) {
            map_delete(_corpses, name);
         }
         save_me();
         unguarded( (: rm(CORPSE_SAVE_DIR + $(id)) :));
#ifdef USE_RAMDISK
         unguarded( (: rm(CORPSE_RAM_DIR + $(id)) :));
#endif
         return ;
      }
   }
}
mixed *stats() {
  return ({ ({ "corpses", keys(_corpses) }) });
}

==================================================
FILE: /lib/obj/handlers/cpi_handler.c
==================================================

#define RESTORE_PATH "/save/cpi_indices/"
#define STOCK_EXCHANGE find_object( "/d/am/am/gomerchants" )
inherit "/std/object";
string material_name;
mapping prices;
void setup() {
  set_name( "board" );
  set_short( "price board" );
  set_long( "This is a large board with many small, wooden flaps attached "+
            "to it.  Painted onto the flaps are numbers and letters, and "+
            "the display is occasionally changed by means of a small imp "+
            "that seems to live inside somewhere.  The board lists the "+
            "purchasing prices of almost everything from gold and silk "+
            "to beef and chicken livers at various places where the "+
            "Merchants' Guild does business.\n" );
  add_adjective( "price" );
  set_main_plural( "price boards" );
  add_plural( "boards" );
  reset_get();
}
int look_up(string);
void init() {
  add_command("find", "<word'thing'>", (:look_up($4[0]):));
}
void imp_effect( string phrase ) {
  tell_room( STOCK_EXCHANGE, "A tiny door opens in the board, a warty imp "+
            "climbs out, clambers across the surface and "+ phrase +
            ".  The imp scowls a bit for the look of the thing, and then "+
            "disappears back inside the board.\n" );
}
void init_data( string word ) {
  material_name = word;
  prices = ([ ]);
}
int get_data_file( string word ) {
  if ( material_name != word ) {
    if ( file_size( RESTORE_PATH + word +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + word :));
    else {
      init_data( word );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
int query_price( string word1, string word2 ) {
   if ( !stringp( word1 ) )
      return 0;
   get_data_file( word1 );
   if ( !prices )
      return 0;
   return prices[ word2 ];
}
int add_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] != 0 ) return 0;
  prices += ([ word2 : number ]);
  imp_effect( "adds the price of "+ word1 +" in "+ word2 +" to the lists" );
  save_data_file( material_name );
  return 1;
}
int modify_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices[word2] = number;
  imp_effect( "updates the price of "+ word1 +" in "+ word2 );
  save_data_file( material_name );
  return 1;
}
int remove_price( string word1, string word2 ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices = m_delete( prices, word2 );
  imp_effect( "removes the price of "+ word1 +" in "+ word2 +
              " from the lists" );
  save_data_file( material_name );
  return 1;
}
int look_up( string word ) {
  int i;
  get_data_file( word );
  if ( !m_sizeof( prices ) ) {
    notify_fail( "You can't find any prices for "+ word +" on the board.\n" );
    return 0;
  }
  if ( m_sizeof( prices ) == 1 ) {
    write( "The only price on the board for "+ word +" is "+
              m_values( prices )[0] +" in "+ m_indices( prices )[0] +".\n" );
  } else {
    write( "You find the following price list for "+ word +":\n\n" );
    for ( i = 1; i < m_sizeof( prices ); i++ ) {
      printf( "%6-s %7d %4|s %40-s \n", "", m_values( prices )[i], "in",
                m_indices( prices )[i] +"," );
    }
    printf( "%6-s %7d %4|s %40-s \n", "  and ", m_values( prices )[0], "in",
              m_indices( prices )[0] +"." );
  }
  return 1;
}
string *query_available_datatypes()
{
  return get_dir(RESTORE_PATH);
}

==================================================
FILE: /lib/obj/handlers/data.c
==================================================

#include <data.h>
#include <function.h>
#define CALLOUT_DELAY 0
#define DEBUG !
#define DC_DELIM 0
#define DC_ARRAY 1
#define DC_MAPPING 2
#define DC_OF 3
#define DC_CLASS 4
#define DC_STRING 5
#define DC_ITEM 6
#define DC_NUMBER 7
#define DC_GREY 8
#define MAX_SUBF_SIZE 16000
#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')
#ifdef DEBUG
#  define Error(s) write(s); log_file( "DATA_COMPILER", s);
#else
#  define Error(s) ;
#endif
string std_euid;
void create() {
    std_euid = "/secure/master"->creator_file(file_name(this_object()));
    seteuid(std_euid);
}
int tmp_file_no;
private string strip_string( string str ) {
    int     i, j;
    if (!str || str == "") return "";
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i <= j; i++ ) ;
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
    return str[ i..j ];
}
private mixed cleanup_assoc( mixed parse ) {
    int j;
    for (j = 0; j < sizeof(parse[0]); j++) {
        if ((parse[1][j] == DC_DELIM) || (parse[1][j] == DC_OF)) {
            parse[0][j] = 0;
            parse[1][j] = 0;
        }
    }
    parse[0] -= ({ 0 });
    parse[1] -= ({ 0 });
    return parse;
}
mixed compile_data( string *path ) {
    string tmp_name, data = "", file_data = "", s1, tmp_val, base, keyword;
    string *segments, *ind, *val, cur_index;
    int i, j, t, debug_file, class_pending, stat, subfunc_cnt,
        subfunc_char_cnt, data_keyword_found, allocated_data;
    int *index_types;
    mixed parse, index_max;
    if (!sizeof(path))
      return 0;
    tmp_name = path[0] + "_dc.c";
    if( find_object( tmp_name ) )
        tmp_name->dest_me();
    if (file_size(tmp_name) > 0) {
        if ((stat = seteuid("Root")) == 0) {
        }
        stat = unguarded((: rm, tmp_name :));
        if (!stat) {
            Error("Error: couldn't remove old .c file (" +
                  geteuid(this_object()) + ", " +
                  "secure/master"->valid_seteuid(this_object(), "Root") +
                  ")\n");
            seteuid(std_euid);
            return 0;
        }
    }
    seteuid(std_euid);
    for (i = 0; i < sizeof(path); i++) {
        if (file_size(path[i]) <= 0)
          continue;
        data += read_file( path[i] );
    }
    if (!data) {
        Error("Error: file(s) not found.\n");
        return 0;
    }
    segments = explode( "$\n" + data, "\n#" );
    if( !segments ) {
        Error( "prop_to_fun() : Nothing but comments?\n" );
        return 0;
    }
    segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
    for( i = 1; i < sizeof( segments ); i++ ) {
        if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
            segments[ i ] = "";
        }
    }
    data = implode( segments, "\n" );
    segments = explode( strip_string( data ), "::" );
    if (sizeof( segments ) % 2) {
      segments += ({""});
    }
    ind = allocate( sizeof( segments ) / 2 );
    val = allocate( sizeof( segments ) / 2 );
    allocated_data = 0;
    for( i = 0; i < sizeof( ind ); i++ ) {
        ind[ i ] = segments[ i * 2 ];
        val[ i ] = strip_string( segments[ i * 2 + 1 ] );
        if( ind[ i ][ 0..0 ] == "#" ) {
            ind[ i ] = lower_case( ind[ i ] );
            if( ind[ i ] == "#debug" ) {
                sscanf( val[ i ], "%d", debug_file );
            } else if( ind[ i ] == "#include" ) {
                tmp_val = val[i];
                file_data += "#include " + replace( tmp_val, " ", "" ) + "\n";
            }
        }
    }
    for( i = 0; i < sizeof( ind ); i++ ) {
        keyword = lower_case( ind[ i ] );
        if( keyword[ 0..0 ] == "#" ) {
            continue;
        }
        subfunc_char_cnt += sizeof(ind[i]) + sizeof(val[i]);
        if (keyword == "data") {
            if (data_keyword_found) {
                Error("Error: more than one data keyword found.\n");
                return 0;
            }
            data_keyword_found = 1;
            file_data += "void dest_me() { destruct( this_object() ); }\n\n";
            parse = reg_assoc(val[i],
                              ({ "array", "mapping", "of", "class +[^\t ]+",
                                 "[^\t ]+" }),
                              ({ DC_ARRAY, DC_MAPPING, DC_OF, DC_CLASS,
                                 DC_GREY }),
                              DC_DELIM);
            parse = cleanup_assoc( parse );
            for (j = 0; (j < sizeof(parse[0])) && !index_max; j++) {
                switch (parse[1][j]) {
                  case DC_ARRAY:
                    break;
                  case DC_MAPPING:
                    break;
                  case DC_CLASS:
                    base = implode(parse[0][j..], " ");
                    file_data += base + " item;\n";
                  case DC_GREY:
                    index_types = parse[1][0..j-1];
                    index_max = allocate(sizeof(index_types));
                    break;
                  default:
                    Error("Error: data parse error 1 (" + parse[0][j] + ")\n");
                    return 0;
                }
            }
            if (index_types[0] == DC_MAPPING)
              file_data += "mapping data = ([ ]);\n\n";
            else
              file_data += "mixed data;\n\n";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    index_max[j] = -1;
                    break;
                  case DC_MAPPING:
                    break;
                  default:
                    Error("Error: illegal index type found ("
                          + index_types[j] + ")\n");
                    return 0;
                }
            }
            file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
            subfunc_cnt++;
            continue;
        }
        if (keyword[0..3] == "item") {
            if (class_pending) {
                file_data += "  data" + cur_index + " = item;\n";
                class_pending = 0;
            }
            if (subfunc_char_cnt > MAX_SUBF_SIZE) {
                file_data += "}\n\n";
                file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
                subfunc_cnt++;
                subfunc_char_cnt = 0;
            }
            parse = reg_assoc( ind[i], ({ "\"[^\"]*\"", "item", "[0-9]+",
                                      "[^,\t ]+"}),
                              ({ DC_STRING, DC_ITEM, DC_NUMBER, DC_GREY }));
            parse = cleanup_assoc( parse );
            cur_index = "";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    if (parse[1][j+1] != DC_NUMBER) {
                        if (parse[0][j+1] == "i") {
                            parse[0][j+1] = index_max[j] + "";
                        } else if (parse[0][j+1] == "i++") {
                            parse[0][j+1] = index_max[j] + "";
                            index_max[j]++;
                        } else if (parse[0][j+1] == "++i") {
                            index_max[j]++;
                            parse[0][j+1] = index_max[j] + "";
                        } else {
                          Error("Error: illegal index for array (" +
                                  parse[0][j+1] + ")\n");
                            return 0;
                        }
                    }
                    if ((t = to_int(parse[0][j+1])) > index_max[j]) {
                        file_data += "  data" + cur_index
                          + " = allocate(" + (t-index_max[j]) + ");\n";
                        index_max[j] = t;
                        allocated_data = 1;
                    }
                    break;
                  case DC_MAPPING:
                    if (j) {
                        file_data += "  if (!mapp(data" + cur_index + "))"
                          + " data" + cur_index + " = ([]);\n";
                    }
                    break;
                  default:
                    Error("Error: illegal index type found (" + index_types[j]
                          + ")\n");
                    return 0;
                }
                cur_index += "[" + parse[0][j+1] + "]";
            }
            if (strip_string(val[i]) != "") {
                file_data += "  data" + cur_index + " = " + val[i] + ";\n";
            }
            continue;
        }
        if (keyword[0..1] == "->") {
            if (!class_pending) {
                file_data += "  item = new( " + base + " );\n";
                class_pending = 1;
            }
            file_data += "  item->" + ind[i][2..] + " = " + val[i] + ";\n";
            continue;
        }
        if (keyword == "quote") {
            file_data += val[i] + "\n";
            continue;
        }
    }
    if (class_pending) {
        file_data += "  data" + cur_index + " = item;\n";
    }
    file_data += "}\n\n";
    file_data += "mixed data_return() {\n";
    if ( !allocated_data ) {
        for (j = 0; j < sizeof(index_types); j++) {
            switch (index_types[j]) {
                case DC_ARRAY:
                    file_data += "  data = allocate(" + (to_int(index_max[j]) + 1) + ");\n";
                break;
            }
        }
    }
    for (i = 0; i < subfunc_cnt; i++) {
        file_data += "  data_return_" + i + "();\n";
    }
    file_data += "  return data;\n}\n";
    seteuid("Root");
    unguarded((: write_file, tmp_name, file_data, 1 :));
    seteuid(std_euid);
    return tmp_name->data_return();
}
class data_node {
   int type;
   mixed value;
}
class queue_node {
   string name;
   class data_node data;
}
class compile_data {
   string file_name;
   function call_back;
   int current_line;
   int look_for;
   int last_chunk_compile;
   int file_len;
   class queue_node* depths;
}
private nosave class compile_data* _to_compile = ({ });
void start_compile();
void parse_chunk(class compile_data data, string chunk);
#define DATA_UNKNOWN 0
#define DATA_CHILDREN 1
#define DATA_NUMBER 2
#define DATA_STRING 3
#define DATA_LIST 4
#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define START_LIST 5
#define END_NUMBER 6
#define ARGUMENT_VALUE 7
#define ARGUMENT_NAME 8
#define REST_OF_ARGUMENT 9
#define END_STRING_LIST 10
#define END_NUMBER_LIST 11
#define END_LIST 12
#define CHUNK_SIZE 10
void compile_file(string fname, function call_back) {
   class compile_data data;
   if (file_size(fname) == -1) {
      tell_object(this_player(), "The file "+
                         fname+" does not exist.\n");
      return ;
   }
   if (file_size(fname) == -2) {
      tell_object(this_player(), "The file "+
                         fname+" is a directory exist.\n");
      return ;
   }
   data = new(class compile_data);
   data->file_name = fname;
   data->call_back = call_back;
   data->look_for = OPEN_BRACKET;
   _to_compile += ({ data });
   start_compile();
}
void start_compile() {
   class compile_data data;
   if (!sizeof(_to_compile) || _to_compile[0]->last_chunk_compile) {
      return ;
   }
   data = _to_compile[0];
   data->last_chunk_compile = time();
   data->current_line = 1;
   data->look_for = OPEN_BRACKET;
   data->file_len = file_length(data->file_name);
   data->depths = ({ new(class queue_node,
                  data : new(class data_node, type : 0, value : ([ ]) )) });
   call_out("compile_chunk", CALLOUT_DELAY);
}
void compile_chunk() {
   string chunk;
   int end;
   class compile_data data;
   data = _to_compile[0];
   data->last_chunk_compile = time();
   if (data->current_line > data->file_len ||
       functionp(data->call_back) & FP_OWNER_DESTED) {
      call_out("start_compile", CALLOUT_DELAY);
      _to_compile = _to_compile[1..];
      if (!(functionp(data->call_back) & FP_OWNER_DESTED)) {
         evaluate(data->call_back, data->file_name, data->depths[0]->data->value);
      }
      return ;
   }
   if (data->current_line+CHUNK_SIZE > data->file_len) {
      end = data->file_len+1;
   } else {
      end = data->current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, data->file_name, data->current_line,
                               end-data->current_line :));
   data->current_line = end;
   call_out("compile_chunk", CALLOUT_DELAY);
   parse_chunk(data, chunk);
}
mixed to_diceint(string str) {
   class data_dice dice;
   string s1;
   if (strsrch(str, "d") != -1) {
      dice = new(class data_dice);
      if (sscanf(str, "%dd%s", dice->number, s1) == 2) {
         if (strsrch(s1, "+")) {
            if (sscanf(s1, "%d+%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            }
         } else if (strsrch(s1, "-")) {
            if (sscanf(s1, "%d-%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            } else {
               dice->modifier = - dice->modifier;
            }
         } else {
            dice->die = to_int(s1);
         }
      }
      return dice;
   }
   return to_int(str);
}
void parse_chunk(class compile_data data, string chunk) {
   string *bits;
   string s1;
   string s2;
   string s3;
   int pos;
   int chunk_size;
   int start;
   class data_node node;
   while (sscanf(chunk, "%s#%s\n%s", s1, s2, s3) == 3) {
      chunk = s1 + s3;
   }
   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (data->look_for) {
         case OPEN_BRACKET :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            if (chunk[pos] == ')') {
               data->look_for = END_BRACKET;
               break;
            }
            if (chunk[pos] == '(') {
               chunk = chunk[pos+1..];
               chunk_size = strlen(chunk);
               pos = 0;
               node = new(class data_node, type : 0);
               data->depths += ({ new(class queue_node, data : node) });
               data->look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;
         case ARGUMENT_NAME :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            while (pos < chunk_size && chunk[pos] != ' ' &&
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            data->depths[<1]->name = chunk[start..pos-1];
            data->look_for = ARGUMENT_VALUE;
            break;
         case ARGUMENT_VALUE :
         case START_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Error, found a bracket inside a list.\n");
                     pos = chunk_size;
                     break;
                  }
                  data->look_for = OPEN_BRACKET;
                  data->depths[<1]->data->type = DATA_CHILDREN;
                  data->depths[<1]->data->value = ([ ]);
                  break;
               case '"' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_STRING_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_STRING;
                     data->depths[<1]->data->value = "";
                  }
                  pos++;
                  data->depths[<1]->data->type = DATA_STRING;
                  break;
               case '0'..'9' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_NUMBER_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_NUMBER;
                     data->depths[<1]->data->value = "";
                  }
                  data->depths[<1]->data->type = DATA_NUMBER;
                  break;
               case '}' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_BRACKET;
                     pos++;
                     data->depths[<1]->data->type = DATA_LIST;
                  } else {
                     debug_printf("End of list without a start of list.\n");
                     pos = chunk_size;
                  }
                  break;
               case '{' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Cannot have nested lists.\n");
                     pos = chunk_size;
                  } else {
                     data->look_for = START_LIST;
                  }
                  data->depths[<1]->data->value = ({ });
                  data->depths[<1]->data->type = DATA_LIST;
                  pos++;
                  break;
               default :
                 if(chunk[pos] = 't')
                  if(chunk[pos..pos+3] == "true" || chunk[pos..pos+2] == "yes") {
                    if(chunk[pos..pos+3] == "true")
                      pos += 3;
                    else
                      pos += 2;
                    data->depths[<1]->data->value = 1;
                    data->depths[<1]->data->type = DATA_NUMBER;
                    data->look_for = END_BRACKET;
                    break;
                  }
                  debug_printf("Unknown data type %s in %s\n",
                               chunk[pos..pos+5], chunk);
                  pos = chunk_size;
                  break;
            }
            break;
         case END_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ',' :
                  pos++;
                  data->look_for = START_LIST;
                  break;
               case '}' :
                  data->look_for = START_LIST;
                  break;
               default :
                  debug_printf("Expected , or } not %s\n", chunk[pos..pos+5]);
                  pos = chunk_size;
                  break;
            }
            break;
         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               if (arrayp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] += ({
                       data->depths[<1]->data->value });
               } else if (sizeof(data->depths) == 2) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({
                       data->depths[<1]->data->value });
               } else if (!undefinedp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({
                       data->depths[<2]->data->value[data->depths[<1]->name],
                       data->depths[<1]->data->value });
               } else {
                  data->depths[<2]->data->value[data->depths[<1]->name] = data->depths[<1]->data->value;
               }
               data->depths = data->depths[0..<2];
               chunk = s2;
               chunk_size = strlen(s2);
               pos = 0;
               data->look_for = OPEN_BRACKET;
            }
            break;
         case END_NUMBER_LIST :
         case END_NUMBER :
            start = pos;
            while (pos < chunk_size && ((chunk[pos] >= '0' &&
                      chunk[pos] <= '9') ||
                      chunk[pos] == 'd' || chunk[pos] == '+' ||
                      chunk[pos] == '-')) {
               pos++;
            }
            if (data->look_for == END_NUMBER) {
               data->depths[<1]->data->value += chunk[start..pos - 1];
            } else {
               data->depths[<1]->data->value[<1] += chunk[start..pos - 1];
            }
            if (pos < chunk_size) {
               if (data->look_for == END_NUMBER) {
                  data->depths[<1]->data->value = to_diceint(data->depths[<1]->data->value);
                  data->look_for = END_BRACKET;
               } else {
                  data->depths[<1]->data->value[<1] = to_diceint(data->depths[<1]->data->value[<1]);
                  data->look_for = END_LIST;
               }
            }
            break;
         case END_STRING_LIST :
         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1, "\n", "");
                     data->look_for = END_BRACKET;
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1, "\n", "")+"\"";
                     data->look_for = END_LIST;
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               if (data->look_for == END_STRING) {
                  data->depths[<1]->data->value += replace(chunk, "\n", "");
               } else {
                  data->depths[<1]->data->value[<1] += chunk;
               }
               pos = chunk_size;
            }
            break;
         default :
            debug_printf("Horrible error "+data->look_for+" (" +
                         data->file_name + ") " + data->current_line + " " +
                         chunk[pos..] + "\n");
            pos = chunk_size;
            break;
      }
   }
}

==================================================
FILE: /lib/obj/handlers/english_handler.c
==================================================

float *freq=({ 0.070012, 15.782218, 0.011949, 43.328090, 0.021800, 31.780955,
                 0.041222, 22.534301, 0.081093, 11.110506, 0.016799, 34.952377,
                 0.019235, 35.094824, 0.031751, 21.939816, 0.055348, 15.959625,
                 0.001028, 116.456628, 0.007624, 57.669862, 0.029144,
                 22.558570, 0.028764, 31.148966, 0.047194, 18.490345, 0.054178,
                 15.319177, 0.014415, 36.228697, 0.001335, 116.456628,
                 0.047561, 18.817823, 0.050139, 17.975454, 0.058789, 13.617099,
                 0.020638, 32.978418, 0.005222, 63.346619, 0.011713, 42.180909,
                 0.001264, 116.456628, 0.014661, 40.185678, 0.000530,
                 116.456628, 0.171614, 40.0, 0.000666, 116.456628,
                 0.084311, 10.304674
});
int FreqTest( string line ) {
  int len,i,ch;
  float badness,term;
  int *let;
  let=allocate(29);
  i = len = strlen(line);
  while (i--) {
    ch = line[i];
    if ((ch>=65 && ch<65+26) || (ch>=97 && ch<97+26)) let[(ch&31)-1]++;
    else if (ch==' ') let[26]++;
    else if (ch>='0' && ch<='9') let[27]++;
    else let[28]++;
  }
  badness = 0.0;
  for (i=0;i<29;i++) {
    term = to_float((to_float(let[i]) - freq[i<<1] * len) * freq[(i<<1)+1]);
    badness += (term>0 ? term : -term);
  }
  badness /= (29.0*len);
  i = 100 - 50*badness*badness;
  if (i<1) i=1;
  return i;
}
int ProfaneTest( string strin ) {
  int i,profane=0;
  string str,s;
  if (sizeof(strin)<1) return 0;
  strin=lower_case(strin)+" ";
  str="";
  for (i=0;i<sizeof(strin);i++) {
    if (strin[i]>='a' && strin[i]<='z') str+=strin[i..i];
  }
  if (sizeof(str)<2) return 0;
  s=str[0..0];
  for (i=1;i<sizeof(str);i++) {
    if (s[<1]!=str[i]) s+=str[i..i];
  }
  if (regexp(s,"bastard|tit|shaft|viag")
     || regexp(str,"poo|ass|butt")) profane+=25;
  if (regexp(s,"arse|sex|sux|crap|testic|fart|orgasm|orgy|turd|porn|niple|nazi|jesus|christ|satan|sperm|smeg|toilet|genital")
     || regexp(str,"piss|root|buttw|assho")
     || regexp(strin,"butt |ass ")) profane+=50;
  if (regexp(s,"netsex|arse|shit|screw|urine|rectum|tampon|vibrator|rectal|scatol|semen|suck|lick|dyke|dike|wank|mutha|prost|fag|feck|gay|homo|fuq|horny|blowjob|cuni")
     || regexp(str,"phall|hooter|poof")) profane+=100;
  if (regexp(s,"anal|rape|rapist|fuck|fuk|fuch|kuck|cunt|kunt|whor|slut|clit|masturb|masterb|penis|cock|dick|pusy|bitch|vagina")) profane+=200;
  return profane;
}

==================================================
FILE: /lib/obj/handlers/error_handler.c
==================================================

inherit "/obj/handlers/inherit/error_handler";
void create() {
  seteuid("Root");
   ::create();
}
void setup_error_handler(string user, string db, string password) {
   ::setup_error_handler(user, db, password);
}

==================================================
FILE: /lib/obj/handlers/error_tracker.c
==================================================

inherit "/std/dom/error_tracker_master";
void create() {
    set_domain( "mudlib" );
    set_name( "The Mudlib's Lord of the Whinge" );
    set_other_dirs( ({
        "/std%",
        "/obj%",
        "/global%",
        "/cmds%",
        "/mudlib%",
        "/include%",
        "/net%",
        "/soul%",
        "/room%",
        "/www%",
      }) );
    set_period( 604800 );
    ::create();
}
# Total Tokens: 23895
# Total Files Merged: 15
# Total Characters: 79692

