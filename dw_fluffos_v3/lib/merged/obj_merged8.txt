# Total Tokens: 15349
# Total Files Merged: 16
# Total Characters: 51209

mushroom.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "checkered" );
  set_type( "mushroom" );
  set_extra( "The checks are nice pastel shades of peach and mauve." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ jumps up and down very quickly, and then burps.\n",
    "You hear a small voice say: Goodbye, cruel world!\nThe $type$ "+
        "falls over and disintegrates.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/hallucination", 150 +
        random( 150 ) );
  ::next_stage();
}

==================================================
FILE: fungi/rust_fungus.c
==================================================

inherit "/obj/fungus";
void setup() {
  set_adjs( "rust" );
  set_type( "fungus" );
  set_extra( "It looks like a lump of rust, only soft and a bit squishy." );
  set_messages( ({
    "A small $type$ sprouts on the metal.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ silently releases a red dust into the air.\n",
    "The $type$ collapses in on itself and falls apart.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/strength_boost", 2000 +
        random( 1000 ) );
  ::next_stage();
}

==================================================
FILE: reagents/.generic_liquid.ob_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/reagents/generic_liquid.ob#1" );
  call_other( clone, "add_adjective",  "some"  );
  call_other( clone, "add_alias",  "liquid"  );
  call_other( clone, "set_amount_types",  ([ "drop": ({ 1, "drops" }),              "teaspoon": ({ 20, "teaspoons" }),              "tablespoon": ({ 60, "tablespoons" }),              "ounce": ({ 120, "ounces" }),              "cup": ({ 960, "cups" }),              "pint": ({ 2400, "pints" }),                          "quart": ({ 4800, "quarts" }),                          "gallon": ({ 19200, "gallons" }) ])  );
  call_other( clone, "add_adjective",  ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",                "tablespoons", "ounce", "ounces", "cup", "cups", "pint",                "pints", "quart", "quarts", "gallon", "gallons", "of" })  );
  call_other( clone, "set_pile_types",  ({ 50, "small", 100, "medium", "large" })  );
  call_other( clone, "set_continuous",   );
  call_other( clone, "set_liquid",   );
  call_other( clone, "add_property",  "determinate", "" );
   return clone;
}

==================================================
FILE: b_day/card.c
==================================================

#define DEMON "/obj/b_day/demon"
#include <player_handler.h>
inherit "/std/object";
int creator_status, is_open = 0;
int opened_before = 0;
string owner_name, owner_language;
string* colour_array = ({
  "%^RED%^", "%^BOLD%^%^RED%^",
  "%^MAGENTA%^", "%^BOLD%^%^MAGENTA%^",
  "%^ORANGE%^", "%^YELLOW%^",
  "%^GREEN%^", "%^BOLD%^%^GREEN%^",
  "%^WHITE%^", "%^BOLD%^%^WHITE%^",
  "%^CYAN%^", "%^BOLD%^%^CYAN%^"
  });
void setup_card(string name, string language, int status);
mapping init_query_static_auto_load() {
  return ([ "::" : ::int_query_static_auto_load(),
          "owner_name":owner_name,
          "owner_language":owner_language,
          "is_open":is_open,
          "opened_before":opened_before]);
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] ) {
    ::init_static_arg( map[ "::" ] );
  }
  if ( !undefinedp( map[ "owner_name" ] ) ) {
    owner_name = map[ "owner_name" ];
  }
  if ( !undefinedp( map[ "owner_language" ] ) ) {
    owner_language = map[ "owner_language" ];
  }
  if ( !undefinedp( map[ "is_open" ] ) ) {
    is_open = map[ "is_open" ];
  }
  if ( !undefinedp( map[ "opened_before" ] ) ) {
    opened_before = map[ "opened_before" ];
  }
}
mapping query_static_auto_load()
{
  if ( explode( file_name( this_object() ), "#" )[ 0 ] ==
       "/obj/b_day/card" ) {
    return init_query_static_auto_load();
  }
  return 0;
}
mixed *query_read_mess()
{
  if(!is_open) {
    return ({ ({ "The card is addressed to " + owner_name +
                   ".  Maybe you should open it?  Then again, if "
                   "you're not " + owner_name + ", maybe you "
                   "shouldn't.\n",
                   0, owner_language, 1 }) });
  }
  return ::query_read_mess();
}
void set_closed_mesg()
{
    set_long("The closed card has been carefully handmade from pink "
        "cardboard. There is a rather vague illustration of a "
        "non-identifiable piece of flora on the front.\n");
}
void set_open_mesg()
{
    set_long("The open card has been carefully handmade from pink "
        "cardboard.\n");
}
void setup_card(string own_name, string own_language, int cre_status)
{
  string *wizards, list;
  int i;
  owner_name = own_name;
  owner_language = own_language;
  creator_status = cre_status;
  set_short(owner_name + "'s birthday card");
  add_adjective( ({ owner_name, owner_name + "'s"}) );
  wizards = get_dir("/w/");
  if(creator_status) {
    int start = member_array(lower_case(owner_name), wizards);
    wizards = wizards[0..start-1] + wizards[start+1..];
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
      "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += colour_array[random(sizeof(colour_array))] +
          capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += "%^RESET%^.\n\n";
        else if(i == sizeof(wizards)-2) list += "%^RESET%^ and ";
        else list += ",%^RESET%^ ";
      }
    }
    list += "... and thanks for all your work and time, and let's hope "
      "next year will be even more magical and fun, fun, fun!\n";
  } else {
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
        "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += ".\n";
        else if(i == sizeof(wizards)-2) list += " and ";
        else list += ", ";
      }
    }
  }
  add_read_mess(list, "various hands", owner_language, 1);
}
void setup()
{
  set_name("card");
  set_short("birthday card");
  add_adjective("birthday");
  set_main_plural("birthday cards");
  add_property("determinate", "");
  add_property("no recycling", 1);
  set_closed_mesg();
  if(owner_name && owner_language) {
    setup_card(owner_name, owner_language, creator_status);
  }
}
void init()
{
    this_player()->add_command("open", this_object());
    this_player()->add_command("close", this_object());
}
int do_open()
{
    object demon;
    if(is_open) {
        write("It is already open.\n");
        return 1;
    }
    if(lower_case(owner_name) != this_player()->query_name()) {
      add_succeeded_mess( ({
        "*** POP ***\n"
          "An Origami Demon peers out from the card, sees you're not "
          + owner_name + ", mutters about that not being very "
          "low-temperature, and vanishes back into the card.\n",
        "*** POP ***\n"
          "An Origami Demon peers out from " + owner_name + "'s "
          "birthday card at " + this_player()->query_cap_name() +
          ", smirks and crawls back into the card.\n"
      }) );
      return 1;
    }
    is_open = 1;
    set_open_mesg();
    if(opened_before) return 1;
    opened_before = 1;
    demon = clone_object(DEMON);
    demon->move(environment(this_player()));
    demon->set_owner(owner_name);
    demon->add_language(owner_language);
    demon->set_language(owner_language);
    add_succeeded_mess( ({
      "*** POP ***\n"
        "An Origami Demon explodes from your card as you open it!\n",
      "*** POP ***\n"
        "An Origami Demon explodes from " + owner_name + "'s birthday "
        "card as " + owner_name +" opens it!\n"
    }) );
    call_out("start_demon", 2, demon);
    return 1;
}
void start_demon(object thing) {
  thing->do_the_act(0);
}
int do_close()
{
    if(!is_open) {
        write("It is not open for you to close!\n");
        return 1;
    }
    is_open = 0;
    set_closed_mesg();
    return 1;
}
mixed *stats()
{
  return ::stats() + ({ ({ "owner name",owner_name }),
                          ({ "owner language",owner_language }), });
}

==================================================
FILE: b_day/demon.c
==================================================

#define SONG "/obj/b_day/happy"
inherit "/obj/monster";
int line;
object owner;
string owner_name;
string* act_lines = ({
  ":takes a deep breath...",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday, dear $N\"",
  ":pauses for breath...",
  "sing \"Happy Birthday to yoooou.\"",
  "sing \"The End!\"",
  "hug $n in a way that only a tiny paper "
    "demon could",
  ":waves a minute pointed hand.",
  ":frowns, then folds itself into nothingness..."
});
void setup()
{
  set_name("demon");
  set_short("origami demon");
  add_adjective("tiny");
  add_adjective("pink");
  add_adjective("paper");
  add_adjective("origami");
  set_main_plural("origami demons");
  add_plural("demons");
  set_long("This is a tiny, pink, paper demon. Looking closely you see "
           "that it has been made by someone with a black belt in "
           "Origami!\n");
  set_race("demon");
  set_level(1);
  line = 1;
}
void set_owner(string person_name)
{
  owner = find_living(lower_case(person_name));
  owner_name = person_name;
}
void do_the_act(int i)
{
  string line_to_act;
  if(i >= sizeof(act_lines)) {
    dest_me();
    return;
  }
  if(environment(owner) != environment()) {
    tell_room(environment(), "The origami demon rustles after "
              + owner_name + ".\n");
    move(environment(owner));
    tell_room(environment(), "The origami demon rustles in.\n" );
    do_command("'Hey "+owner_name+"! I hadn't finished!\n");
    return;
  }
  line_to_act = act_lines[i];
  line_to_act = replace(line_to_act, ({"$N", owner_name,
                                       "$n", lower_case(owner_name) }));
  if(!strlen(line_to_act)) {
    set_heart_beat(0);
    dest_me();
    return;
  }
  do_command(line_to_act);
  i++;
  if(owner) {
    call_out("do_the_act", 2, i);
  }
  return;
}
void attack_by( object thing ){
  if( !thing) return;
  if( environment( thing ) != environment() ) return;
  this_object()->stop_fight (thing);
  thing->stop_fight (this_object());
  init_command("say Meanie!  Shame on you!  I shall finish what I "
               "started and then I shall be off.  You don't really "
               "deserve this, you know.", 1);
  return;
}

==================================================
FILE: examples/exa1.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("first simple room");
  set_long("This is a simple room, have fun with it. To read the code " +
           "simply type 'more here'. For help with more, type 'h' in it.\n");
  set_light(90);
  add_exit("east", ROOM + "exa2", "door");
  set_zone("examples");
}

==================================================
FILE: examples/exa2.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("second simple room");
  set_long("This is the second example room. It introduces items, and " +
           "aliasing - again use 'more here' to look at it. Over by the " +
           "north wall you can see a table.\n");
  set_light(90);
 add_item("table",
          "The table is one step away from being firewood. Upon it rests " +
          "a blotter.\n");
 add_item( ({ "north wall", "wall" }),
          "It is very flat and is holding up rather a ricketty table.\n");
 add_item("blotter",
          "It is covered in random ink blots.\n");
  add_exit("west", ROOM + "exa1", "door");
  add_exit("east", ROOM + "exa3", "door");
  set_zone("examples");
}

==================================================
FILE: examples/exa3.c
==================================================

#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("third simple room");
  set_long("This is the third example room. Will you ever get to the end? " +
           "Directly above your head is a plaque, nailed to the wall.\n");
  set_light(90);
  add_sign("The plaque is made of bronze.\n",
           "'Don't read me, I'm only an example sign you know!'\n",
           0,
           "plaque");
  add_exit("west", ROOM + "exa2", "door");
  add_exit("east", ROOM + "exa4", "door");
  set_zone("examples");
}
void reset()
{
  object bar;
  if(sizeof(match_objects_for_existence("copper bar", ({ this_object() }) )))
    return;
  bar = clone_object("/std/object");
  bar->set_name("bar");
  bar->add_adjective("copper");
  bar->set_main_plural("copper bars");
  bar->add_plural("bars");
  bar->set_short("copper bar");
  bar->set_long("This is just a treasure thingie to show you how to use " +
                  "such fun things.\n");
  bar->set_weight(80);
  bar->set_value(2000);
  bar->move(this_object());
}

==================================================
FILE: examples/path.h
==================================================

#define ROOM "/obj/examples/"

==================================================
FILE: examples/response_mon.c
==================================================

inherit "/w/pinkfish/tmp/response_mon";
object weapc;
string *tale;
void setup() {
    set_name("guard");
    add_adjective(({ "big", "gate" }));
    set_short("Big gate guard");
    set_long("This is one of the common guards of Amber.  "+
     "He looks quite big, maybe you shouldn't upset him...\n");
    set_race("human");
    set_class("fighter");
    set_level(45);
    set_al(250);
    set_gender(1);
    tale = ({ "There once was a frog with 5 legs.\n",
              "This frog was very very unhappy.\n",
              "All other frogs made fun of him.\n",
              "And no lady frog wanted to marry him.\n",
              "One day, a womble appeared, and bit one of his legs off.\n",
              "Since then the frog had 4 legs, and lived happily ever after.\n"
            });
    set_respond_to_with(([ ({ "help", "me" }) : "'I can't help you." ,
                         ({ ({ "hi","hello","greetings" }) }) :
                                      ({ "'Hello $hcname$.",
                                         "emote salutes you." }),
                            ({ ({ "remove","unwield","unhold" }),
                               ({ "axe","weapon" }) }) :
                                       "#remov",
                            ({ ({ "wield","hold" }),
                               ({ "axe","weapon" }) }) :
                                       "#wiel",
                            ({ "tell" , "story" }) :
                                      "#story" ]));
  weapc = clone_object("/obj/weapons/axe.wep");
  weapc->move(this_object());
  do_equip();
}
int remov() {
  init_command("unhold axe");
}
int wiel() {
 init_command("hold axe");
}
void story(object tpl) {
  command("'Very well, "+tpl->query_cap_name()+ " I will tell you a story.\n");
  set_stop_responding(1);
  call_out("tell_story",2,0);
}
void tell_story(int arg) {
  remove_call_out("tell_story");
  if (arg == sizeof(tale)) {
    set_stop_responding(0);
    return ;
  }
  command("'"+tale[arg]);
  call_out("tell_story",2,arg+1);
}

==================================================
FILE: scabbards/.belt_loop.sca_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/belt_loop.sca#1" );
  call_other( clone, "set_name", "loop"  );
  call_other( clone, "add_adjective", ({ "belt", "belt loop" })  );
  call_other( clone, "add_alias", "belt loop"  );
  call_other( clone, "set_short", "belt loop"  );
  call_other( clone, "set_long", "This loop is made from the finest leather, designed to "         "hold axes or hammers safely.\n"  );
  call_other( clone, "set_weight", 8  );
  call_other( clone, "set_value", 800  );
  call_other( clone, "set_type", "belt scabbard"  );
  call_other( clone, "add_property", "no recycling", 1  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "axe","hammer" }) );
   return clone;
}

==================================================
FILE: scabbards/.dagger_scabbard.sca_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/dagger_scabbard.sca#1" );
  call_other( clone, "set_name", "scabbard"  );
  call_other( clone, "add_adjective", "dagger"  );
  call_other( clone, "set_short", "dagger scabbard"  );
  call_other( clone, "set_long", "Similar in design to the scabbard made for longer bladed weapons."         "  In fact you could say they were the same, except for the size.\n"  );
  call_other( clone, "set_weight", 3  );
  call_other( clone, "set_value", 30  );
  call_other( clone, "set_type", "small scabbard"  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "dagger", "knife" }) );
   return clone;
}

==================================================
FILE: media/sand.c
==================================================

inherit "/obj/cont_medium";
void setup()
{
  set_name("sand");
  set_short("sand");
  set_main_plural( "sand" );
  add_adjective( ({ "some", "grain", "pinch", "measure", "handful",
    "hatful", "beach", "of" }) );
  set_long("This is some lovely soft sand, the type that you'd find on "
    "a beach.\n");
  add_property("determinate", "some ");
  set_weight_unit( ({ 1, 1000 }) );
  set_value_scale( 0.00001 );
  set_medium_alias("BeachAndDesertSand");
  set_pile_name("pile");
  set_continuous();
  set_amount_types( ([
    "grain": ({ 1, "grains" }),
    "pinch": ({ 40, "pinches" }),
    "measure": ({ 200, "measures" }),
    "handful": ({ 10000, "handfuls" }),
    "hatful": ({ 50000, "hatfuls" }),
    "beach": ({ 1000000, "beaches" }),
    ]) );
  set_pile_types( ({
    40, "tiny",
    10000, "small",
    50000, "medium",
    200000, "large",
    "huge"
    }) );
  set_amount(12000);
}

==================================================
FILE: handlers/applications_handler.c
==================================================

#include <board.h>
#include <mail.h>
#include <player.h>
#include <playerinfo.h>
#include <player_handler.h>
#include <applications.h>
#include <library.h>
int find_application (string, string);
int find_type (string);
void mail_message(int, int);
string post_application (int);
int complete_application (int);
nosave class application_type *types = ({ });
class application *applications = ({ });
mapping domain_lockout = ([
     "liaison"      : 0,
     "am"           : 0,
     "ram"          : 0,
     "sur"          : 0,
     "klatch"       : 0,
     "forn"         : 0,
     "cwc"          : 0,
     "playtesters"  : 0
   ]);
void load_me() {
  unguarded ((: restore_object (APPLY_SAVE_FILE) :));
}
void save_me() {
  unguarded ((: save_object (APPLY_SAVE_FILE) :));
}
mapping query_vouches_for_all (string name) {
  mapping tmp = ([ ]);
  for (int i = 0; i < sizeof (applications); i++) {
    if (!undefinedp(applications[i]->vouches[name])) {
      tmp[applications[i]->name + " (" + applications[i]->type + ")"]
        = applications[i]->vouches[name];
    }
  }
  return tmp;
}
varargs void add_application_type (string t, int v, string b, int g, int q, int a,
  int ti, string *qu, string intro, string responsibility) {
  class application_type tmp;
  tmp = new (class application_type, type: t, vouches_required: v, board: b,
    gl_requirement: g, qp_requirement: q, age_requirement: a, questions: qu,
    intro_text: intro, timeout: ti, responsibility: responsibility);
  types += ({ tmp });
}
int toggle_domain_lock (string dom) {
  object ob = load_object ("/d/" + dom + "/master");
  if (ob->query_lord() != this_player()->query_name()) {
    return -1;
  }
  if (domain_lockout[dom]) {
    domain_lockout[dom] = 0;
  }
  else {
    domain_lockout[dom] = 1;
  }
  save_me();
}
int query_applications_accepted(string dom) {
  return (undefinedp (domain_lockout[dom]) ? -1 : domain_lockout[dom]);
}
string query_responsibility (string type) {
  int i;
  object ob;
  string dom;
  i = find_type (type);
  if (i == -1) {
    dom = type;
    type = "creator";
    i = find_type (type);
  }
  else {
    dom = type;
  }
  if (undefinedp (types[i]->responsibility)) {
    ob = load_object ("/d/" + dom + "/master");
    if (!ob) {
      tell_creator ("drakkos", "%s.\n", dom, type);
      return 0;
    }
    return ob->query_lord();
  }
  else {
    ob = load_object ("/d/" + types[i]->responsibility+ "/master");
    if (!ob) {
      return "No-one";
    }
    return ob->query_lord();
  }
}
mapping query_domain_status() {
  return copy (domain_lockout);
}
int add_application (string t, string n, string te, string dom) {
  class application tmp;
  int i;
  i = find_application (n, t);
  if (i != -1) {
    return 0;
  }
  tmp = new (class application, type: t, name: n, text: te, time: time(),
    domain: dom, vouches: ([ ]));
  applications += ({ tmp });
  i = find_application (n, t);
  complete_application (i);
  save_me();
  return 1;
}
void create() {
  seteuid (geteuid());
  load_me();
  add_application_type ("creator", 2, "applications", 150, 0,  5 * DAY, 14 * DAY,
    ({
      "Why do you want to be a Creator on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if "
        "so what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?",
      "What is your programming experience? Can you code in C or, more "
        "specifically, the variant of C known as LPC which the mud uses?",
      "What are you interested in creating on "
        "" + mud_name() + "?  Do you have any particular ideas or projects on "
        "which you would like to eventually work?",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to recommend "
        "you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
        "To the best of your knowledge, is the information you have "
        "submitted in this application complete and correct?"
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
  add_application_type ("liaison", 2, "applications", 150, 0,  5 * DAY, 14 * DAY,
   ({
      "Why do you want to be a Liaison on " + mud_name() + "?",
      "What experience do you already have from " + mud_name() + " which is relevant "
        "to this position?",
      "What experience do you have from the Roundworld (real life) which is "
        "relevant to this position?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "How many of the " + mud_name() + " books have you read?  How many do you "
        "own?",
      "Have you been into trouble with the Creators here on " + mud_name() + "?  "
        "Have you been suspended or banned from a MUD?  If so, why?",
      "Are you now, or have you been, a creator (or similar) on any other "
        "mud/mush/talker/etc.?",
      "How much time (in hours per week) do you think you can commit to "
        "" + mud_name() + "?  Also, please specify the approximate times that you "
        "usually log on and off (in Seattle time).",
      "Do you already know anyone who is a Creator here, who you "
        "have talked to about your application and has agreed to "
        "recommend you?  If so, who?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?",
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n");
  add_application_type ("playtester", 3, "playtesters", 150, 0,  15 * DAY,
    14 * DAY,
    ({
      "Why do you want to be a playtester on " + mud_name() + "?",
      "Do you have (or have you had) other characters on " + mud_name() + ", and if so "
        "what are their names?",
      "What qualities do you feel you can bring to the role?",
      "Do you have any experience in a similar position in real life or "
        "on another MUD?",
      "Do you have anything else you'd like to tell us?",
      "To the best of your knowledge, is the information you have submitted "
        "in this application complete and correct?",
    }),
    "You will be asked a number of questions.  There is no need "
      "to enter all your information during the first question, as you "
      "will be given plenty of opportunities to answer questions "
      "throughout your application.  If you would like to see what "
      "questions you will be asked, please read the list of questions.\n\n"
      "Please answer all the questions given, and you will get an "
      "opportunity at the end to let us know anything else about you "
      "that seems relevant.\n\n"
    "You will also be asked if the information you are submitting is "
      "true - lying on your creator application in an attempt to gain "
      "promotion under false pretenses is a serious offence... if you "
      "have withheld information that is pertinent to your application, "
      "or have willfully misrepresented the facts then you may find "
      "yourself subject to dismissal.  Please make an effort to be "
      "thorough and honest in your answers - in the long run, it will "
      "be much better for you than hiding anything you think may reflect "
      "badly on your application.\n",
      "playtesters");
}
int find_application (string name, string type) {
  for (int i = 0; i < sizeof (applications); i++) {
    if (applications[i]->name == name && applications[i]->type == type) {
      return i;
    }
  }
  return -1;
}
int find_type(string type) {
  for (int i = 0; i < sizeof (types); i++) {
    if (types[i]->type == type) {
      return i;
    }
  }
  return -1;
}
void reset() {
  int j;
  class application *tmp = ({ });
  for (int i = 0; i < sizeof (applications); i++) {
    j = find_type (applications[i]->type);
    if (applications[i]->time + types[j]->timeout < time()) {
      tmp += ({ applications[i] });
      mail_message (0, i);
    }
  }
  if (sizeof (tmp)) {
    applications -= tmp;
    save_me();
  }
}
int delete_vouch (string who, string name, string position) {
  int i = find_application (name, position);
  if (i == -1) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[who])) {
    return 0;
  }
  map_delete (applications[i]->vouches, who);
  save_me();
  return 1;
}
int delete_application (string t, string n) {
  int i = find_application (n, t);
  if (i == -1) {
    return 0;
  }
  applications -= ({ applications[i] });
  save_me();
  return 1;
}
private int complete_application (int i) {
  int vouches = sizeof (keys (applications[i]->vouches));
  int j;
  j = find_type (applications[i]->type);
  if (vouches >= types[j]->vouches_required) {
    post_application (i);
    delete_application (applications[i]->type, applications[i]->name);
    save_me();
    return 1;
  }
  return 0;
}
int number_of_vouches (string name, string type) {
  int i = find_application (name, type);
  if (i == -1) {
    return 0;
  }
  return sizeof (keys (applications[i]->vouches));
}
string query_vouch (string t, string p, string n) {
  int i = find_application (p, t);
  if (i == -1) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[n])) {
    return "You have no vouch for this player in this position.\n";
  }
  return applications[i]->vouches[n];
}
int make_vouch (string t, string p, string n, string v) {
  int i = find_application (p, t);
  int newv = 1;
  if (i == -1) {
    return -1;
  }
  if (n == applications[i]->name) {
    return 0;
  }
  if (undefinedp (applications[i]->vouches[n])) {
    newv = 2;
  }
  applications[i]->vouches[n] = v;
  complete_application (i);
  save_me();
  return newv;
}
string* query_questions (string type) {
  int i = find_type (type);
  return types[i]->questions;
}
string query_intro_text (string type) {
  int i = find_type (type);
  return types[i]->intro_text;
}
int valid_application (string name, string type) {
  int i = find_type (type);
  object ob = find_player (name);
  if (ob->query_level() < types[i]->gl_requirement) {
    return 0;
  }
  if (-1 * ob->query_time_on() >= types[i]->age_requirement) {
    return 0;
  }
  if (LIBRARY->query_quest_points (name) < types[i]->qp_requirement) {
    return 0;
  }
  return 1;
}
string application_requirements (string type) {
  int i = find_type (type);
  string ret = "";
  if (i == -1) {
    return "Applications of that category are not handled by this "
      "system.";
  }
  ret += "Applications for a " + types[i]->type + " position have the "
    "following requirements:\n\n";
  ret += "You need to be at least " +
      query_time_string (types[i]->age_requirement) + " old.\n";
  ret += "You need to be at least guild level " + types[i]->gl_requirement + ".\n";
  ret += "You need to have at least " + types[i]->qp_requirement + " quest points.\n";
  ret += "You need to have " + types[i]->vouches_required + " vouches.\n";
  ret += "You have " + query_time_string (types[i]->timeout) + " to obtain your "
    "vouches.\n\n";
  ret += "Your application will not be posted for consideration until you have "
    "all your vouches completed.\n";
  return ret;
}
mapping query_application_vouches (string type, string name) {
  int i = find_application (type, name);
  if (i == -1) {
    return 0;
  }
  else {
    return applications[i]->vouches;
  }
}
string format_application (int i) {
  string post;
  post = "%^BOLD%^Application:%^RESET%^\n"
         "=-=-=-=-=-=-\n\n" +
         "Age: " + query_time_string(-1 * PLAYER_HANDLER->test_age
         (applications[i]->name)) + "\n" +
         "Application made: " + ctime (applications[i]->time) + "\n\n"
         + applications[i]->text + "\n\n";
  post += "\n\n%^BOLD%^Vouches:%^RESET%^\n"
          "=-=-=-=-\n";
  foreach (string v, string t in applications[i]->vouches) {
    post += "\n\n%^CYAN%^" + capitalize (v) + " (" + query_time_string (-1 *
      PLAYER_HANDLER->test_age (v)) + "):%^RESET%^\n\n" + t;
  }
  return post;
}
private string post_application (int i) {
  string post = "";
  int j = find_type (applications[i]->type);
  class reply_type rep;
  object ob, player;
  string response;
  post = format_application (i);
  rep= new(class reply_type);
  rep->type = B_REPLY_NAMED;
  rep->data = query_responsibility((applications[i]->domain ? applications[i]->domain :
    applications[i]->type));
  ob = load_object ("/d/" + (applications[i]->domain ?
    applications[i]->domain : types[j]->responsibility) + "/master");
  BOARD_HAND->add_message( types[j]->board, capitalize( applications[i]->name),
    capitalize( applications[i]->name ) + "'s " + (applications[i]->type == "creator" ?
       applications[i]->domain + " domain" : capitalize (applications[i]->type)) +
       " application", post, 0, rep );
  AUTO_MAILER->auto_mail( query_responsibility((applications[i]->domain ?
    applications[i]->domain : applications[i]->type)),
    applications[i]->name,
    "Application to " + capitalize( applications[i]->domain),
    "", post, 0, 0 );
  player = find_player (applications[i]->name);
  if (ob) {
    if (function_exists ("creator_application_callback", ob)) {
        response = call_other (ob, "creator_application_callback",
        applications[i]->name, post);
     }
    if (sizeof (response)) {
      tell_object (player, response);
    }
  }
  if (applications[i]->type == "creator" ||  applications[i]->type ==
    "liaison") {
    PLAYERINFO_HANDLER->add_entry( this_object(),
      applications[i]->name, "misc", "Applied to "
        + applications[i]->domain + " domain." );
  }
  else {
    PLAYERINFO_HANDLER->add_entry( player,
      player->query_name(), "misc", "Applied as a "
        + applications[i]->type+ "." );
  }
  mail_message (1, i);
  save_me();
  return post;
}
private void mail_message(int i, int j) {
  string ret = "";
  string mail;
  mail = "Greetings... this is an automated message from the "
    "" + mud_name() + " applications handler.\n\n$message$\n\n";
  switch (i) {
    case 0:
      ret = "You have not received the required number of vouches for "
        "your application for a " + applications[j]->type + " position "
        "within the specified time-frame.  Your application has been "
        "expired and if you wish to pursue further employment on the MUD "
        "you will need to resubmit an application.\n";
    break;
    case 1:
      ret = "You have received the required number of vouches for your "
        "application for a " + applications[j]->type + " position on the "
        "MUD.  Your application has been posted for consideration.  Thank "
        "you for your interest in pursuing employment within the MUD.\n";
    break;
  }
  mail = replace (mail, ({"$message$", ret}));
  AUTO_MAILER->auto_mail( applications[j]->name, "Applications Procedure",
    "Your " + applications[j]->type + " application", "",
    mail, 0, 0, 1 );
}
string list_applications() {
  string *ret = ({ });
  ret += ({"\n"});
  ret += ({"\n\n/---------------------------------------------------------------------------\\"});
  ret += ({sprintf ("| %|12s | %|12s | %|24s | %|2s  | %|10s |",
  "Type", "Name", "Made At", "V", "Domain") });
  ret += ({"|---------------------------------------------------------------------------|"});
  for (int i = 0; i < sizeof (applications); i++) {
    ret += ({sprintf ("| %|12s | %|12s | %|s | %|2d  | %|10s |",
    capitalize (applications[i]->type),
      capitalize (applications[i]->name), ctime (applications[i]->time),
        sizeof (applications[i]->vouches),
        capitalize ((applications[i]->type == "creator" ? applications[i]->domain :
        ""))) });
  }
  ret += ({"\\---------------------------------------------------------------------------/"});
  return implode (ret, "\n");
}
string *query_types() {
  return map (types, (: $1->type :));
}
int fix_name (string n, string n2) {
  int i;
  int c = 0;
  for (int j =0; j < sizeof (types); j++) {
    i = find_application (n, types[j]->type);
    if (i != -1) {
      applications[i]->name = n2;
      c++;
    }
  }
  return c;
}
string query_name() {
  return "Applications Handler";
}

==================================================
FILE: handlers/armoury.c
==================================================

#include <move_failures.h>
#include <armoury.h>
#define MAX_RECYCLE 6
inherit "/std/room/basic_room";
#define DEFAULT_RECYCLE_AREA "default"
#define SAVE "/save/armoury"
#define TYPES ({"armours", "clothes", "weapons", "plants", "foods", "scabbards", "jewelleries", "misc" })
private nosave int _total_requests;
private mapping _smalls;
private mapping _armour_list;
private mapping _weapon_list;
private mapping _clothing_list;
private mapping _jewellery_list;
private mapping _scabbard_list;
private mapping _food_list;
private mapping _misc_list;
private mapping _plant_list;
private mapping _areas;
private mapping forbidden;
private void rehash_all();
int rehash(string place);
string* walk_directory (string);
void save_me() {
   unguarded( (: save_object(SAVE, 3) :));
}
void load_me() {
   unguarded( (: restore_object(SAVE, 1) :));
}
void setup() {
   set_short( "" + mud_name() + " Armoury" );
   add_property( "determinate", "the " );
   set_light( 50 );
   set_long( "You are in the " + mud_name() + " Armoury.  From here you can list "
         "all of the \"weapons\", \"armour\", \"clothing\", \"jewellery\", "
         "\"food\", \"plants\", \"misc\" "
         "and \"scabbards\" that are available, and \"request\" one of "
         "them.  The armoury stores its list of items in mappings, which "
         "can be updated with \"rehash\".  The list of forbidden items "
         "can be listed out or added to with \"forbid\".\n" );
   _smalls = ([ ]);
   _areas = ([ ]);
   _armour_list = _weapon_list = _clothing_list = _plant_list = _misc_list =
      _jewellery_list = _scabbard_list = _food_list = ([ ]);
   load_me();
   rehash_all();
}
object *query_smalls(string area) {
   if (!area) {
      area = DEFAULT_RECYCLE_AREA;
   }
   return _smalls[area];
}
mapping query_area(string domain) {
  if (_areas[domain]) {
      return _areas[domain];
  }
  return ([ ]);
}
int request(string, int, string);
int forbid(string);
void init() {
   string comm;
   ::init();
   add_command("rehash", "{foods|clothes|weapons|armours|misc|jewelleries|"
                         "scabbards|plants}",
                (:rehash($4[0]) :));
   add_command("rehash", "domain <string'domain'>",
                (:rehash($4[0]) :));
   add_command("request", "<string'item name'> <number'percent'>",
                (:request($4[0], $4[1], 0):));
   add_command("request", "<string'item name'> <number'percent'> in <string'area'>",
               (:request($4[0], $4[1], $4[2]):));
   add_command("forbid", "", (:forbid, "":));
   add_command("forbid", "<string'name'>", (:forbid($4[0]):));
   foreach(comm in ({"weapons", "armour", "clothing", "jewellery", "plant",
                     "misc", "scabbards", "food", })) {
      add_command(comm, "", (:call_other(this_object(), $(comm)):));
   }
}
mapping make_list(string base_dir, string *extensions) {
  string *dirs, dir, extension, file_name;
  mapping list;
  dirs = walk_directory (base_dir);
  list = ([ ]);
  foreach(dir in dirs) {
    foreach(extension in extensions) {
      foreach(file_name in unguarded((: get_dir, dir+"*"+extension :))) {
        if (file_name[0] != '.') {
          list[ replace_string(explode(file_name, ".")[0], "_", " ") ] =
                    dir + "" + file_name;
        }
      }
    }
  }
  return list;
}
int clean_up(int i) { return 0; }
object choose_small_item(string area) {
  object ob;
  if(!area)
    area = DEFAULT_RECYCLE_AREA;
  if(!_smalls || !_smalls[area] || !arrayp(_smalls[area]) || !_smalls[area][0])
    return 0;
  ob = clone_object(_smalls[area][0]);
  _smalls[area] = _smalls[area][1..];
  return ob;
}
object request_item(string word, int percent, string area) {
  int add_area;
  object thing;
  string filename;
  if(!word) {
    return 0;
  }
  if (!area) {
    area = DEFAULT_RECYCLE_AREA;
  }
  if (_areas[area] &&
      _areas[area][word]) {
    filename = _areas[area][word];
    add_area = 1;
  } else if(_weapon_list[word]) {
    filename = _weapon_list[word];
  } else if(_armour_list[word]) {
    filename = _armour_list[word];
  } else if(_clothing_list[word]) {
    filename = _clothing_list[word];
  } else if(_jewellery_list[word]) {
    filename = _jewellery_list[word];
  } else if(_scabbard_list[word]) {
    filename = _scabbard_list[word];
  } else if(_misc_list[word]) {
    filename = _misc_list[word];
  } else if(_plant_list[word]) {
    filename = _plant_list[word];
  } else if(_food_list[word]) {
    filename = _food_list[word];
  } else {
    if(base_name(previous_object()) != "/cmds/creator/req_uest") {
      printf( "No file for item \"%s\".\n", word );
      log_file( "ARMOURY", "%s No file for %s (%s)\n", ctime(time())[4..9],
                word, file_name( previous_object() ) );
    }
    return 0;
  }
  if(file_size( filename ) > 0)
    thing = clone_object(filename);
  if(!thing) {
    printf( "Cannot find item \"%s\".\n", word );
    log_file( "ARMOURY", "Cannot find %s (%s)\n", word,
              file_name( previous_object() ) );
    return 0;
  }
  _total_requests++;
  if(!_smalls[area])
    _smalls[area] = ({ });
  if(sizeof(_smalls[area]) < 20 &&
     thing->query_weight() < roll_MdN(5, 20) &&
     thing->query_value() < random(4000) &&
     !thing->query_liquid() &&
     !sizeof((mapping)thing->query_value_info()) &&
     strsrch(filename, "_pt") == -1 &&
     strsrch(filename, "_dev") == -1 &&
     !thing->query_property("no recycling")) {
    _smalls[area] += ({ filename });
  }
  if (add_area)
    thing->add_property(ARMOURY_RECYCLING_AREA_PROP, area);
  thing->set_percentage( percent );
  return thing;
}
string remap_file_path(string path) {
   string* bits;
   mapping list;
   string new_fname;
   bits = explode(path, "/");
   if (bits[0] != "obj") {
      return path;
   }
   switch (bits[1]) {
   case "armours" :
      list = _armour_list;
      break;
   case "weapons" :
      list = _weapon_list;
      break;
   case "clothes" :
      list = _clothing_list;
      break;
   case "jewellery" :
      list = _jewellery_list;
      break;
   case "scabbards" :
      list = _scabbard_list;
      break;
   case "food" :
      list = _food_list;
      break;
   case "misc" :
      list = _misc_list;
      break;
   case "plants" :
      list = _plant_list;
      break;
   }
   if (list) {
      new_fname = list[replace_string(explode(bits[<1], ".")[0], "_", " ")];
      if (new_fname) {
         return new_fname;
      }
   }
   return path;
}
int rehash(string thing) {
  string special;
  int found;
  switch (thing) {
  case "armours" :
     _armour_list=make_list("/obj/armours/", ({".arm", ".c"}));
     break;
  case "clothes" :
     _clothing_list=make_list("/obj/clothes/", ({".clo", ".c"}));
     break;
  case "weapons" :
     _weapon_list = make_list("/obj/weapons/", ({".wep", ".c"}));
     break;
  case "scabbards" :
     _scabbard_list = make_list( "/obj/scabbards/", ({ ".sca", ".c" }));
     break;
  case "jewellery" :
  case "jewelleries" :
     _jewellery_list = make_list( "/obj/jewellery/", ({ ".arm", ".clo", ".c" }));
     break;
  case "food" :
  case "foods" :
     _food_list = make_list( "/obj/food/", ({ ".ob", ".food", ".c" }));
     break;
  case "misc" :
     _misc_list = make_list( "/obj/misc/", ({ ".ob", ".c" }));
     break;
  case "plants" :
     _plant_list = make_list( "/obj/plants/", ({ ".ob", ".food", ".c" }));
     break;
  default :
    if (file_size("/d/" + thing + "/items") == -2) {
      _areas[thing] = make_list( "/d/" + thing + "/items/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca",
                                     ".ob", ".food" }));
      found = 1;
    }
    if (file_size("/d/" + thing + "/armoury") == -2) {
      foreach (special in get_dir("/d/" + thing + "/armoury")) {
         if (file_size("/d/" + thing + "/armoury/" + special + "/") == -2) {
           _areas[special] = make_list( "/d/" + thing + "/armoury/" + special + "/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca" }));
         }
      }
       return 0;
    }
  }
  save_me();
  write("Rehash of " + thing + " complete.\n");
  return 1;
}
int rehash_specific_dir(string dir) {
   return rehash(explode(dir, "/")[1]);
}
private void rehash_all() {
  string thing;
  int i;
  foreach(thing in TYPES + "/secure/master"->query_domains()) {
    i += 5;
    call_out("rehash", i, thing);
  }
}
string *query_types() { return TYPES + keys(_areas); }
mapping query_items(string type, string filter) {
  mapping items;
  string item;
  switch(type) {
  case "armours":
    items = _armour_list;
    break;
  case "weapons":
    items = _weapon_list;
    break;
  case "clothes":
    items = _clothing_list;
    break;
  case "jewellery":
  case "jewelleries":
    items = _jewellery_list;
    break;
  case "scabbards":
    items = _scabbard_list;
    break;
  case "food":
  case "foods":
    items = _food_list;
    break;
  case "misc":
    items = _misc_list;
    break;
  case "plants":
    items = _plant_list;
    break;
  default:
    if(member_array(type, "/secure/master"->query_domains()) != -1 &&
       _areas[type])
      items = _areas[type];
    else
      return 0;
  }
  items = copy (items);
  if (sizeof (filter)) {
    foreach(item in keys(items))
      if(strsrch(item, filter) == -1)
        map_delete(items, item);
  }
  return items;
}
int request( string word, int percentage, string area ) {
  object thing;
  thing = request_item( word, percentage, area );
  if ( !thing ) {
    add_failed_mess(word + " not found.\n");
    return 0;
  }
  if ( (int)thing->move( this_player() ) != MOVE_OK ) {
    write( (string)thing->a_short() +" has been placed in here.\n" );
    thing->move( this_object() );
  } else
    write( (string)thing->a_short() +
          " has been placed in your inventory.\n" );
  return 1;
}
mixed stats() {
  string tmp;
  mixed *ret;
  ret = ({ });
  foreach(tmp in keys(_areas)) {
    ret += ({ tmp, sizeof(_areas[tmp]) });
  }
  return ::stats() + ({
    ({ "item requests", _total_requests, }),
      ({ "armours", sizeof(_armour_list) }),
      ({ "clothes", sizeof(_clothing_list) }),
      ({ "weapons", sizeof(_weapon_list) }),
      ({ "scabbards", sizeof(_scabbard_list) }),
      ({ "jewellery", sizeof(_jewellery_list) }),
      ({ "food", sizeof(_food_list) }),
      ({ "misc", sizeof(_misc_list) }),
      ({ "plants", sizeof(_plant_list) }),
      ret });
}
string* walk_directory (string dir) {
  string *tmp, *dirs = ({ }), *tmp2;
  mixed *file;
  tmp = get_dir(dir, -1);
  if (sizeof (tmp))
    dirs += ({dir});
  foreach(file in tmp) {
    if(file[1] == -2) {
      tmp2 = walk_directory (dir + file [0] + "/");
      if (sizeof (tmp2))
        dirs += tmp2;
    }
  }
  return dirs;
}

==================================================
FILE: handlers/artifact_handler.c
==================================================

#define SAVE_FILE "/save/artifacts"
#define SAVE_DIR "/save/artifacts/"
mapping artifacts;
void create() {
   seteuid( (string)"/secure/master"->
         creator_file( file_name( this_object() ) ) );
   artifacts = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
mapping query_artifacts() { return artifacts; }
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
int query_artifact( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return 1;
}
void add_artifact( string name, string file, int max, int min, int bonus,
                   int value ) {
  artifacts[ name ] = ({ file, max, min, bonus, value });
  save_me();
}
void remove_artifact( string name ) {
  if ( !artifacts[ name ] )
    return;
  artifacts = m_delete( artifacts, name );
  save_me();
}
string query_artifact_file( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 0 ];
}
int query_artifact_max( string name ) {
  if ( !artifacts[ name ] )    return 0;
  return artifacts[ name ][ 1 ];
}
int query_artifact_min( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 2 ];
}
int query_artifact_bonus( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 3 ];
}
int query_artifact_value_info( string name ) {
  if ( !artifacts[ name ] )
    return 0;
  return artifacts[ name ][ 4 ];
}
int query_artifact_level( string name, int bonus ) {
  int number;
  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 1 ] - artifacts[ name ][ 2 ];
  number *= number;
  number /= bonus - artifacts[ name ][ 3 ] + artifacts[ name ][ 1 ] -
      artifacts[ name ][ 2 ];
  number += artifacts[ name ][ 2 ];
  return number;
}
int query_artifact_value( string name, int bonus ) {
  int number;
  if ( !artifacts[ name ] )
    return 0;
  number = artifacts[ name ][ 4 ] * artifacts[ name ][ 1 ];
  number /= query_artifact_level( name, bonus );
  return number;
}
void diagnose_artifact( object thing, object person, object) {
   int charges;
   string type;
   if ( !thing || !person )
      return;
   type = (string)thing->query_artifact_type();
   if ( !stringp( type ) ) {
      tell_object( person, "There doesn't seem to be anything special about "+
            (string)thing->the_short() +".\n" );
      return;
   }
   charges = (int)thing->query_charges();
   tell_object( person, (string)thing->the_short() +" is a level "+
         (int)thing->query_level() +" magic "+ type +".  It has "+
         ( charges == 1 ? "one charge" : query_num( charges ) +" charges" ) +
         " remaining.\n" );
}
string query_wand_name() { return "wand of artifact probing"; }
void zap( object thing, object person, object wand ) {
  call_out( "diagnose_artifact", 0, thing, person, wand );
}
int query_known( string person, string artifact ) {
  int i;
  string *list;
  if ( !artifacts[ artifact ] )
    return 0;
  if ( unguarded((: file_length, SAVE_DIR + person :)) < 1 )
    return 0;
  list = explode( unguarded((: read_file, SAVE_DIR + person :)), "\n" );
  for ( i = 0; i < sizeof( list ); i++ ) {
    if ( list[ i ] == artifact )
      return 1;
  }
  return 0;
}
void add_known( string person, string artifact ) {
  if ( query_known( person, artifact ) )
    return;
  unguarded((: write_file, SAVE_DIR + person, artifact +"\n" :));
}
