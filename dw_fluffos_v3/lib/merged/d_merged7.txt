# Total Tokens: 17496
# Total Files Merged: 22
# Total Characters: 58386

/chars/dog.c
==================================================

inherit "/obj/monster";
#include "path.h"
string colour, type;
void check_for_hidden();
void test_rabid_attack();
void test_urinate();
void pat_me( object per );
void sic_em( object per, string mess );
string query_colour() { return colour; }
void setup() {
   colour = ({ "light brown", "black", "grey", "mottled", "white", "patched",
         "dark brown", "black and white", "fluorescent yellow" })[ random( 9 ) ];
  set_name("dog");
  set_race("dog");
  set_gender(1 + random(2));
  set_level( 1 + random( 1 + random( 3 ) ) );
  add_adjective("hairy");
  add_adjective(explode(colour, " "));
}
void set_type(string type) {
   set_short( type +" "+ colour +" dog" );
   set_main_plural( type +" "+ colour +" dogs" );
   add_adjective( type );
   if ( type == "small" ) {
      set_long("The small "+colour+" dog is very hairy.  It looks a "
                 "bit sad and lost in the streets of Pumpkin.  "
                 "You are sure it would prefer a cat flap and a nice "
                 "hot meal every night, or is that you?\n");
   } else {
      add_skill_level( "fighting", random( 10 + random( 30 ) ) );
      add_skill_level( "other.health", random( 10 + random( 30 ) ) );
      set_main_plural("large "+colour+" dogs");
      add_adjective("large");
      set_long("The large "+colour+" dog confidently walks the streets, "
                 "insolently not moving aside for the warriors and heroes "
                 "stalking the streets.\n");
   }
   add_enter_commands( "#check_for_hidden" );
   if ( !random( 3 ) )
     add_effect( "/std/effects/disease/flea_infestation", 10000 );
  if (!random(6)) {
    set_wimpy(10);
    load_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl",
       1, "#test_rabid_attack",
    }) );
    load_a_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl" }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                             query_name() }), "bite $hname$");
  } else {
    set_wimpy( 70 );
    load_chat( 5, ({
       1, (type=="small"?":whines pathetically.":"@growl"),
       1, (type=="small"?"@stare hungrily at $lname":
                             "@stare int at $lname"),
       1, (type=="small"?"@bite $lname ankles":"@stare rud at $lname"),
       1, "#test_urinate",
    }) );
    load_a_chat( 50, ({
       1, "@bite $aname ?",
       1, "@growl",
       1, "@bark",
    }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                                query_name() }), "#pat_me" );
    add_respond_to_with( ({ "@say", ({ "get", "sic" }), }), "#sic_em" );
  }
  add_effect("/std/effects/npc/eat_edible", 0);
  add_effect("/std/effects/npc/i_died", ({ HOSPITAL, "regen_after_death" }));
  add_property("monster_type", type);
  add_property("animal type", type);
}
void bark_at_hidden(object per) {
  mapping hide_invis;
  if (per) {
    hide_invis = per->query_hide_invis();
    if (environment(per) == environment() &&
        hide_invis["hiding"]) {
      do_command("bark loudly");
      if (!random(4))
        do_command("bark loudly at "+
                 per->query_name());
      else
        do_command("bark loudly");
      call_out("bark_at_hidden", 2, per);
    }
  }
}
void check_for_hidden() {
  object *obs, mine;
  int i;
  mapping hide_invis;
  function fun;
  mine = query_property("following");
  obs = all_inventory(environment(this_object()));
  for (i=0;i<sizeof(obs);i++) {
    hide_invis = query_hide_invis();
    if (living(obs[i]) && hide_invis["hiding"] &&
        obs[i] != mine && obs[i]->query_visible(this_object())) {
      call_out("bark_at_hidden", 0, obs[i]);
      break;
    }
  }
}
void test_rabid_attack() {
  int i;
  object *obs;
  obs = filter_array(all_inventory(environment()),
                     (: living($1) && $1 != $2 &&
                        (!$1->query_property("player") ||
                         $1->query_level() > 5) :),
                      this_object());
  if (sizeof(obs))
    attack_ob(obs[0]);
}
void test_urinate() {
  object *obs, *liv, blue, mine;
  int i;
  liv = ({ });
  mine = query_property("following");
  obs = all_inventory(environment());
  check_for_hidden();
  for (i=0;i<sizeof(obs);i++) {
    if (living(obs[i]) && obs[i] != mine &&
        obs[i] != this_object()) {
      liv += obs[i..i];
    }
  }
  if (sizeof(liv)) {
    blue = liv[random(sizeof(liv))];
    tell_room(environment(),
              the_short() + " urinates on " + blue->the_short() + "'s leg.\n",
              ({ blue }));
    tell_object(blue, capitalize(the_short()) + " urinates on your leg.\n");
    blue->add_effect("/std/effects/other/dog_urinate", 120);
  }
}
void i_like_them(object them) {
  if(!them || environment() != environment(them))
    return ;
  call_out("i_like_them", 60+random(240), them);
  if (query_property("excited")) {
    do_command("bounce excit");
  } else switch (random(5)) {
    case 0 :
      do_command("nuzzle "+them->query_name());
      break;
    case 1 :
      do_command("stare pitifully at "+them->query_name());
      break;
    case 2 :
      do_command("smile "+them->query_name());
      break;
    case 3 :
      do_command("eye "+them->query_name());
      break;
    case 4 :
      do_command("drool "+them->query_name());
      break;
  }
}
void pat_me(object per) {
  object ob;
  ob = query_property("following");
  if (objectp(ob) &&
      environment(ob) == environment()) {
    init_command("nuzzle "+per->query_name());
  } else if (environment() == environment(per) &&
   (query_property("monster type") == "small dog" ||
   !random(5))) {
    init_command("follow "+per->query_name());
    init_command("protect "+per->query_name());
    add_property("following", per);
    call_out("i_like_them", 60+random(240), per);
  } else {
    init_command("ignore "+per->query_name());
  }
}
void periodic_excited() {
  if (query_property("excited")) {
    if (query_property("excited") > 1) {
      switch (random(4)) {
        case 0 :
          do_command("growl");
          break;
        case 1 :
          do_command("bark");
          break;
        case 2 :
          do_command("caper");
          break;
        case 3 :
          do_command("bounce excit");
          break;
      }
    } else if (!random(2))
      do_command("bounce excit");
    else
      do_command("caper");
    call_out("periodic_excited", 10+random(10));
  }
}
void sic_em(object per, string mess) {
   string *bing;
   object mine;
   object *obs;
   int lvl;
   bing = explode(replace(mess, "!", ""), " ");
   mine = query_property("following");
   if (bing[0] == "get" && per == mine) {
      obs = match_objects_for_existence(bing[1], environment());
      obs = filter_array(obs, (: living($1) :));
      if ( sizeof( obs ) ) {
	 lvl = query_property( "excited" );
	 add_property( "excited", lvl+1 );
	 call_out( function( object npc ) {
	    int lvl;
	    lvl = npc->query_property("excited");
	    if (lvl > 0)
	       npc->add_property("excited", lvl - 1);
	    else
	       npc->remove_property("excited");
	 }, 120, this_object());
	 if (!lvl) {
	    call_out("periodic_excited", 10+random(10));
	 }
	 switch (lvl) {
	  case 0 :
	    init_command("bounce excit");
	    break;
	  case 1 :
	    init_command("growl "+obs[0]->query_name());
	    break;
	  default :
	    call_out((: attack_ob($2) :), 0, obs[0]);
	    break;
	 }
      }
   }
}

==================================================
FILE: dist/pumpkin/chars/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is Fruitbat Avenue at the junction with Crumpet Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat2", "road");
  add_exit("north", CRUMPT + "crumpt8", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just west of "
           "Crumpt Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat3", "road");
  add_exit("west", FRUITBAT + "fruitbat1", "road");
  add_exit("south", FRUITBAT + "general_store", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just south of the "
           "vault.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat4", "road");
  add_exit("west", FRUITBAT + "fruitbat2", "road");
  add_exit("north", FRUITBAT + "walrus_vault_entry", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is east end of Fruitbat Avenue at the junction "
           "with Squash Square.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash4", "road");
  add_exit("west", FRUITBAT + "fruitbat3", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/general_store.c
==================================================

#include "path.h"
inherit "/std/shops/general_shop";
void setup() {
   set_short("Elephant's Stamp");
   set_long(
"A huge picture of an elephant covers tha back room of the shop.  You can "
"see the elephant guarding a huge pile of goods.\n");
   add_exit("north", FRUITBAT + "fruitbat2", "door");
   set_light(70);
   set_store_room(FRUITBAT + "storeroom");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/fruitbat/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/fruitbat/storeroom.c
==================================================

inherit "/std/shops/storeroom";
void setup() {
   set_short("Elephant's Storeroom");
   set_light(70);
   set_long("Lots of stored stuff.\n");
 }

==================================================
FILE: dist/pumpkin/fruitbat/walrus_vault.c
==================================================

#include "path.h"
inherit "/std/shops/vault";
void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");
   set_light(70);
   set_vault_name("walrus");
   set_vault_exit("south", FRUITBAT + "walrus_vault_entry", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/fruitbat/walrus_vault_entry.c
==================================================

#include "path.h"
inherit "/std/shops/vault_entry";
object _npc;
void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");
   set_light(70);
   set_vault_name("walrus");
   set_visit_cost(400);
   set_open_cost(4000);
   add_exit("south", FRUITBAT + "fruitbat3", "door");
   set_vault_exit("north", FRUITBAT + "walrus_vault", "door");
   add_property("place", "Pumpkin");
}
void reset() {
   set_proprietor(_npc);
}

==================================================
FILE: admin/common.c
==================================================

#include <config.h>
#define DOM_TITLE "the domain of admin"
#define LORD "pinkfish"
#define DOMAIN "admin"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", CONFIG_START_ROOM, "door");
  modify_exit( "drum", ({ "one way", 1 }) );
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs adorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}

==================================================
FILE: admin/master.c
==================================================

#define LORD "pinkfish"
#define DOMAIN "admin"
#define LOGS "/d/admin/log/"
#define BACKUP_COUNT 9
inherit "/std/dom/base_master";
void create() {
   string file;
   int i;
   ::create();
   foreach ( file in unguarded( (: get_dir, LOGS +"*.log" :) ) ) {
     if( ( unguarded( (: file_size, LOGS + file :) ) > 1024000) ||
         ( file != "ENTER.log" &&
           unguarded( (: file_size, LOGS + file :) ) > 64000 ) ) {
       file = explode( file, "." )[ 0 ];
       if(file_size(LOGS+file+"."+BACKUP_COUNT) > 0)
         unguarded( (: rm, LOGS + file +"."+ BACKUP_COUNT :) );
       for(i=(BACKUP_COUNT-1); i>0; i--)
         if(file_size(LOGS+file+"."+i) > 0)
           unguarded( (: rename, LOGS+file+"."+i, LOGS+file+"."+(i+1) :) );
       unguarded( (: rename, LOGS+file+".log", LOGS+file+"."+"1" :) );
     }
   }
}
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}
int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}
int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "\nThe admin domain is made up of the active Trustees of "
    "Discworld.  Their role is to ensure the smooth running of the game.  "
    "They carry the ultimate responsibility for Discworld, how it operates "
    "and its policies and rules.\n\n";
}

==================================================
FILE: admin/room/access_control.c
==================================================

#include <access.h>
#include "path.h"
inherit "/std/room/basic_room";
#define LOGIN "/secure/login"
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8
int do_read(string euid, string path);
int do_write(string euid, string path);
int do_grant(string euid, string path);
int do_lock(string path);
int do_noread(string euid, string path);
int do_nowrite(string euid, string path);
int do_nogrant(string euid, string path);
int do_unlock(string path);
int do_summary(string str);
int do_tidy();
void setup() {
  set_light(100);
  set_short("file-access control room");
  add_property("determinate", "the ");
  set_long(
    "You are in a room full of filing cabinets.  There are filing "
    "cabinets everywhere, they are all packed full of papers and look "
    "in a horrible mess.\n"
"Available commands:\n"
"  read    <euid> <path>     : add read permission to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n" );
  add_exit("east", ROOM+"domain_control", "corridor");
}
void init() {
  ::init();
  this_player()->add_command("read",    this_object(),
    "<string'euid'> <string'path'>", (: do_read($4[0], $4[1]) :) );
  this_player()->add_command("write",   this_object(),
    "<string'euid'> <string'path'>", (: do_write($4[0], $4[1]) :) );
  this_player()->add_command("grant",   this_object(),
    "<string'euid'> <string'path'>", (: do_grant($4[0], $4[1]) :) );
  this_player()->add_command("lock",    this_object(),
    "<string'path'>",                (: do_lock($4[0]) :) );
  this_player()->add_command("noread",  this_object(),
    "<string'euid'> <string'path'>", (: do_noread($4[0], $4[1]) :) );
  this_player()->add_command("nowrite", this_object(),
    "<string'euid'> <string'path'>", (: do_nowrite($4[0], $4[1]) :) );
  this_player()->add_command("nogrant", this_object(),
    "<string'euid'> <string'path'>", (: do_nogrant($4[0], $4[1]) :) );
  this_player()->add_command("unlock",  this_object(),
    "<string'path'>",                (: do_unlock($4[0]) :) );
  this_player()->add_command("summary", this_object(),
    "<string'path or euid'>",        (: do_summary($4[0]) :) );
  this_player()->add_command("tidy",    this_object(),
    "",                              (: do_tidy() :) );
}
int do_read(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_read("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_read("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to add read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_read_permission(euid, path);
}
int do_write(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_write("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_write("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to add write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_write_permission(euid, path);
}
int do_grant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_grant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_grant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to add grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_grant_permission(euid, path);
}
int do_lock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_lock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_lock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->lock_path(path);
}
int do_noread(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_noread("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_noread("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to remove read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_read_permission(euid, path);
}
int do_nowrite(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nowrite("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_nowrite("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to remove write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_write_permission(euid, path);
}
int do_nogrant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nogrant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_nogrant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to remove grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_grant_permission(euid, path);
}
int do_unlock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_unlock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_unlock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->unlock_path(path);
}
int list_before( string first, string second ) {
   if ( first < second )
      return -1;
   if ( first > second )
      return 1;
   return 0;
}
int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!LOGIN->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str;
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  paths = sort_array( m_indices( perms ), "list_before", this_object() );
  if (!sizeof(paths))
    ret = "No permissions set.\n";
  else
    ret = sprintf("%11-s    Path\n", "Euid");
  for (i=0;i<sizeof(paths);i++) {
    euids = m_indices(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
}
int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;
   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !LOGIN->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
}

==================================================
FILE: admin/room/cloner_control.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
#define CLONER "/global/cloner"
int do_add(string from, string to);
int do_remove(string from);
int do_list(string matching);
void setup() {
  set_light(100);
  set_short("Cloner Room");
  set_long("This room is used to look at or add filename mappings for the "+
     "cloner object.  It's a very, very, very, very boring room.\n\n"+
     "  add <from> <to> - adds a mapping.\n"+
     "  remove <from> - removes a mapping.\n"+
     "  list [str] - lists mappings which contain the optional string "+
     "str.\n");
  add_exit("southwest" , ROOM+"development" , "door");
}
void init() {
  ::init();
  if (!this_player()) return;
  this_player()->add_command("add", this_object(),
    "<string:small'from object'> <string:small'to object'>",
    (: do_add($4[0], $4[1]) :)
    );
  this_player()->add_command("remove", this_object(),
    "<string:small'from object'>",
    (: do_remove($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "<string:small'matching'>",
    (: do_list($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "",
    (: do_list("") :)
    );
}
int do_add(string from, string to) {
  CLONER->add_mapping(from, to);
  return 1;
}
int do_remove(string str) {
  CLONER->remove_mapping(str);
  return 1;
}
int do_list(string from) {
  this_player()->more_string(CLONER->list_mappings(from));
  return 1;
}

==================================================
FILE: admin/room/development.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
object board;
void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("development");
    board->move(this_object());
  }
}
void setup() {
  set_light(80);
  set_short("Mud Development Office");
  set_long(
    "You are in the Development Office of the mud. Maps and charts of the "+
    "world adorn the panelled walls. Forms sit on a table near the door "+
    "for registration of new projects. A few bored looking clerks rustle "+
    "some papers and try to look busy.\n");
  add_item("clerk", "They seem more interested in coffee than work.\n");
  add_item("map", "Type 'list' to see available maps, and 'read' to look "+
           "at one.\n");
  add_exit("west", "w/common", "door");
  add_exit("east", ROOM+"quest_room", "door");
  add_exit("north", ROOM+"mail_room", "door");
  add_exit("south", ROOM+"domain_control", "corridor");
  add_exit("northeast", ROOM+"cloner_control", "door");
   add_exit( "southeast", ROOM +"terrain", "door" );
}
void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}

==================================================
FILE: admin/room/domain_control.c
==================================================

#include "access.h"
#include "path.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"
int do_list(string arg);
int do_create(string dom, string lord);
int do_list_all();
int do_deputy(string cre, string dom);
int do_undeputy(string cre, string dom);
int do_create(string dom, string lord);
int do_project(string cre, string dom, string project);
int do_add(string cre, string dom);
int do_delete(string cre, string dom);
void setup() {
  set_light(100);
  set_short("domain-control room");
  add_property("determinate", "the ");
  set_long("You float in nothingness, before a vast turtle, its shell pocked "
    "by asteroid craters. In all directions stars twinkle in the black "
    "curtain of space.\n"
"Available commands:\n"
"  list                         : list all domains.\n"
"  list <domain>                : list members of a domain.\n"
"  create <domain>              : create a domain (you are lord).\n"
"  create <domain> <lord>       : create a domain for someone else.\n"
"  add <creator> <domain>       : add a creator to a domain you own.\n"
"  delete <creator> <domain>    : remove a creator from a domain you own.\n"
"  project <cre> <dom> <proj>   : Set the creators project.\n"
"  deputy <cre> <dom>           : Appoint creator as a deputy.\n"
"  undeputy <cre> <dom>         : Remove creator as a deputy.\n"
);
  add_item("turtle", "On its back you can see four elephants, and they bear " +
    "the weight of the disc upon their wide backs.\n");
  add_item("elephants", "The four great elephants labour endlessly in the " +
    "task of turning the disc upon their backs.\n");
  add_item("disc", "The whole discworld, from hub to rim, rides upon the " +
    "elephant's backs.\n");
  add_alias("elephant", "elephants");
  add_exit("north", ROOM+"development", "corridor");
  add_exit("south", ROOM+"site_control", "corridor");
  add_exit("west", ROOM+"access_control", "corridor");
  seteuid("Admin");
}
void init() {
  ::init();
  add_command("list", "", (: do_list_all() :) );
  add_command("list", "<word>", (: do_list($4[0]) :) );
  add_command("create", "<word>", (: do_create($4[0], 0) :) );
  add_command("create", "<word> <word>", (: do_create($4[0], $4[1]) :) );
  add_command("add", "<word> <word>", (: do_add($4[0], $4[1]) :) );
  add_command("delete", "<word> <word>", (: do_delete($4[0], $4[1]) :) );
  add_command("project", "<word> <word> <string>",
                         (: do_project($4[0], $4[1], $4[2]) :) );
  add_command("deputy", "<word> <word>", (: do_deputy($4[0], $4[1]) :) );
  add_command("undeputy", "<word> <word>", (: do_undeputy($4[0], $4[1]) :) );
}
int do_list_all() {
  int i, num;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  write("Current domains:\n");
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    members = (string *)mast->query_members();
    printf( "%15s has %2d %-7s and is owned by %s.\n", domains[ i ],
      num = sizeof( (string *)mast->query_members() ),
      ( ( num == 1 ) ? "member" : "members" ),
      capitalize( (string)mast->query_lord() ) );
  }
  return 1;
}
int do_list(string arg) {
  int i, cols;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  if(member_array(arg, domains) == -1) {
    notify_fail("No such domain as " + arg + ".\n");
    return 0;
  } else {
    mast = "/d/" + arg + "/master";
    write(capitalize((string)mast->query_lord()) + " is the lord of " +
      arg + ".\nMembers         Project\n");
    members = (string *)mast->query_members();
    cols = (int)this_player()->query_cols();
    for (i=0;i<sizeof(members);i++)
      printf("%-15s %*-=s\n", members[i], cols-16,
                             mast->query_project(members[i]) +
             (mast->query_deputy(members[i])?" (deputy)":""));
  }
  return 1;
}
int do_create(string dom, string lord) {
  if (this_player() != this_player(1))
    return 0;
  if(!MASTER->high_programmer(geteuid(previous_object()))) {
    notify_fail("You lack the Power of Change on this scale!\n");
    return 0;
  }
  if (!lord) {
    lord = (string)this_player()->query_name();
  }
  if (!MASTER->create_domain(dom, lord)) {
    notify_fail("Failed to create domain " + dom + " with the lord " + lord
                + ".\n");
    return 0;
  }
  write("You create the domain " + dom + " with " + capitalize(lord) +
    " as its lord.\n");
  return 1;
}
int do_add(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if (!mast->add_member(cre)) {
    notify_fail("Failed to add " + capitalize(cre) + " to domain " +
      dom + ".\n");
    return 0;
  }
  write("Creator " + capitalize(cre) + " now added to domain " + dom + ".\n");
  return 1;
}
int do_delete(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->remove_member(cre)) {
    notify_fail("Failed to remove " + capitalize(cre) + " from domain " +
       dom + "\n");
    return 0;
  }
  write("Member " + capitalize(cre) + " removed from domain " + dom + ".\n");
  return 1;
}
int do_project(string cre, string dom, string project) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if (!mast->set_project(cre, project)) {
    notify_fail("Failed to set the project " + project + " for " +
                capitalize(cre) + " in the domain " + dom + "\n");
    return 0;
  }
  write("Project for " + capitalize(cre) + " set to " + project +
        " in the domain " + dom + ".\n");
  return 1;
}
int do_deputy(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->add_deputy(cre)) {
    notify_fail("Failed to add the deputy " +
                capitalize(cre) + " to the domain " + dom + "\n");
    return 0;
  }
  write("Deputy " + capitalize(cre) + " added to "
        "the domain " + dom + ".\n");
  return 1;
}
int do_undeputy(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->remove_deputy(cre)) {
    notify_fail("Failed to remove the deputy " +
                capitalize(cre) + " from the domain " + dom + "\n");
    return 0;
  }
  write("Deputy " + capitalize(cre) + " removed from "
        "the domain " + dom + ".\n");
  return 1;
}

==================================================
FILE: admin/room/mail_room.c
==================================================

inherit "/std/room/basic_room";
#include "path.h"
#include <mail.h>
#define NAME (string)this_player()->query_name()
#define HIGHLORD() (master()->high_programmer(NAME))
int do_add(string list, string name);
varargs int do_list(string str);
int do_create(string str);
int do_remove(string list, string names);
void setup() {
  set_short("Mail control room");
  set_long(
"This is the mail control room.  You can see several frogs hopping around "
"looking important, sorting mail into nice little boxes, putting them in "
"their backpacks and hopping off into the distance.  Over to the west of "
"the room is a small control panel, with odd levers and lots of strange "
"buttons.\n");
  set_light(100);
  add_exit("south", ROOM + "development", "door");
  add_item("important looking post office frog",
           "They are rushing around in a seemless unending hurry.  They are "
           "all wearing nice little hats that have the post office symbol on "
           "them.");
  add_item("box",
           "There are several nice boxes around the room.  They all appear "
           "to be labeled in some arcane script.  If you squint at them they "
           "form interesting patterns.");
  add_item("backpack",
           "Every frog has its own backback.  Some are full, some are empty, "
           "but they all have them.  The regulation backback is about big "
           "enough to contain over a hundred letters.  Some of them look "
           "battered and worn as if they have seen many years of service.");
  add_item("control panel",
           "It is covered with odd levers and buttons.  Some of them are "
           "labeled in a readable script.  They are \"add\", \"list\", "
           "\"listcreate\" and \"remove\".");
}
void init() {
  ::init();
  if (!this_player()) return;
  this_player()->add_command(
    "add", this_object(),
    "<string:small'list'> <string:long'names'>",
    (: do_add($4[0], $4[1]) :) );
  this_player()->add_command(
    "list", this_object(),
    "<string:small'list'>",
    (: do_list($4[0]) :) );
  this_player()->add_command(
    "list", this_object(),
    "",
    (: do_list() :) );
  this_player()->add_command(
    "remove", this_object(),
    "<string:small'list'> <string:long'names'>",
    (: do_remove($4[0], $4[1]) :) );
  this_player()->add_command(
    "listcreate", this_object(),
    "<string:small'list'>",
    (: do_create($4[0]) :) );
}
int do_add(string list, string name) {
  string *names;
  if (!MAIL_TRACK->query_list(list)) {
    notify_fail("The mailing list \"" + list + "\" does not exist.\n");
    return 0;
  }
  if (!(MAIL_TRACK->query_controller(list, NAME) || HIGHLORD())) {
    notify_fail("You have to be a controller of a list to be able to add a "
                "member.\n");
    return 0;
  }
  names = explode(replace(lower_case(name), " ", ","), ",") - ({ "" });
  if (!sizeof(names)) {
    notify_fail("It helps if you tell me who to add.\n");
    return 0;
  }
  foreach (name in names) {
    if (name[0] == '*') {
      name = name[1..];
      if (!"/secure/login"->test_user(name)) {
        write("The player \"" + name + "\" does not exist.\n");
      } else if (MAIL_TRACK->add_controller(list, name)) {
        write("Added " + name + " as a controller of \"" + list + "\".\n");
      } else {
        write("Failed to add " + name + " as a controller of \"" +
              list + "\".\n");
      }
    } else if (!"/secure/login"->test_user(name) &&
               !MAIL_TRACK->query_list(name)) {
      write("The player \"" + name + "\" does not exist.\n");
    } else if (MAIL_TRACK->add_member(list, name)) {
      write("Added " + name + " to the mailing list.\n");
    } else {
      write("Failed to add " + name + " to the mailing list.\n");
    }
  }
  return 1;
}
varargs int do_list(string str) {
  string *strs, *cont, creator;
  if (!str) {
    strs = MAIL_TRACK->query_mailing_lists();
    write("$I$5=Current mailing lists: " + query_multiple_short(strs) + ".\n");
  } else {
    strs = MAIL_TRACK->query_members(str);
    cont = MAIL_TRACK->query_controllers(str);
    if (!sizeof(strs)) {
      notify_fail("The mailing list \""+str+"\" does not exist.\n");
      return 0;
    }
    if ((creator = MAIL_TRACK->query_creator(str))) {
      write("The list \"" + str + "\" was created by " + creator + ".\n");
    }
    if (sizeof(cont)) {
      write("$I$5=Controllers of list \"" + str + "\": " +
            query_multiple_short(cont) + ".\n");
    }
    write("$I$5=Members of list \"" + str + "\": " +
          query_multiple_short(strs) + ".\n");
  }
  return 1;
}
int do_remove(string list, string name) {
  string *names;
  if (!MAIL_TRACK->query_list(list)) {
    notify_fail("The mailing list \""+list+"\" does not exist.\n");
    return 0;
  }
  if (!(MAIL_TRACK->query_controller(list, NAME) || HIGHLORD())) {
    notify_fail("You have to be a controller of a list to be able to "+
                "remove a member.\n");
    return 0;
  }
  names = explode(replace(lower_case(name), " ", ","), ",") - ({ "" });
  if (!sizeof(names)) {
    notify_fail("It helps if you tell me who to remove.\n");
    return 0;
  }
  foreach (name in names) {
    if (name[0] == '*') {
      name = name[1..];
      if (MAIL_TRACK->remove_controller(list, name)) {
        write("Removed " + name + " as a controller of \"" + list + "\".\n");
      } else {
        write("Failed to remove " + name + " as a controller of \"" +
              list + "\".\n");
      }
    } else if (MAIL_TRACK->query_controller(list, name) && (name != NAME)) {
      write("Could not remove " + name + ", because " + name + " is a "
            "controller of \"" + list + "\".\n");
    } else if (MAIL_TRACK->remove_member(list, name)) {
      write("Removed " + name + " from the mailing list.\n");
    } else {
      write("Could not remove " + name + " from the mailing list.\n");
    }
  }
  return 1;
}
int do_create(string str) {
  if (MAIL_TRACK->query_list(str)) {
    notify_fail("The list \"" + str + "\" already exists.\n");
    return 0;
  }
  if (sscanf(str, "%*s %*s") == 2 || sscanf(str, "%*s,%*s")) {
    notify_fail("The mailing list name cannot have spaces or commas in it.\n");
    return 0;
  }
  if (MAIL_TRACK->create_list(str, this_player()->query_name())) {
    write("Created the mailing list \""+str+"\".\n");
    return 1;
  }
  notify_fail("Failed to create the mailing list.\n");
  return 0;
}

==================================================
FILE: admin/room/meeting.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
object floor, sign;
string log_bing, chair;
void setup() {
  set_short("Meeting room");
  set_long(
"A large oak table dominates this room.  There are some heavy ornate "+
"looking candle sticks in the center of the table.  The table is "+
"sourounded by large expensive looking teak chairs, at one end of the "+
"table are some larger more expensive looking ones.  There is a small "+
"hammer sitting in the middle of the room.  You can see a small sign on "+
"the wall.\n");
  set_light(70);
  add_item("oak table",
           "A large heavy looking oak table.  It was built to last. "+
           "It looks very old, you can tell by all the worn marks "+
           "at the places around the table where people sit.\n");
  add_item("teak chair",
           "The chairs are overly ornate and obviously in a very good "+
           "condition for their age.  The large chairs at the end are "+
           "obviously not well used (you can tell, all the dust).\n");
  add_item("candle stick",
           "The candle sticks are made of silver, however if you try "+
           "and take them, you notice they are attached to the table "+
           "somehow.  The candles seemed to have been carved into the "+
           "shape of a small chicken holding a torch.\n");
  add_item(({ "hammer", "gavel" }),
           "The gavel looks like ones fo those things so common in "+
           "meeting rooms.  You could bang it around a little maybe, "+
           "it might help if you had it though.\n");
  log_bing = 0;
  sign = add_sign("A small sign with not much written on it.\n",
                  "There is no current chair of the meeting.\n");
}
void reset() {
  if (floor)
    return ;
  floor = clone_object("/std/object");
  floor->set_name("floor");
  floor->set_short( "floor" );
  floor->add_property( "determinate", "the " );
  floor->set_long(
"This is the floor of the meeting.  It gives you the right to speak "+
"during the meeting.  Please give this to the next person to speak "+
"after you have finished.\n");
  floor->move(this_object());
}
void init() {
  string str;
  ::init();
  str = previous_object()->query_name();
  if (interactive(previous_object()) && (previous_object()->query_lord()
      || str == chair)) {
    add_action("appoint", "appoint");
    add_action("bang", "bang");
    add_action("recover", "recover");
    add_action("do_log", "log");
  }
}
int appoint(string str) {
  object ob;
  if (chair && (string)this_player()->query_name() != chair) {
    notify_fail("The chair has already been apointed.\n");
    return 0;
  }
  if (!(ob = find_player(str))) {
    notify_fail("Sorry, cannot find "+str+" to be the chair.\n");
    return 0;
  }
  chair = str;
  say(this_player()->one_short()+" just appointed "+str+" as the "+
        "chair of the meeting.\n", ob);
  write("Ok, "+str+" is now the chair of the meeting.\n");
  tell_object(ob, this_player()->one_short()+
        " just appointed you the chair of the meeting.\n");
  if (environment(ob) == this_object())
    ob->move(this_object());
  sign->set_read_mess("The chair of the meeting is "+str+".\n");
  return 1;
}
int bang(string str) {
  if ((string)this_player()->query_name() != chair) {
    notify_fail("Only the chair can bang the gavel.\n");
    return 0;
  }
  tell_room(this_object(),
            this_player()->one_short()+" bangs the gavel loudly.  STOP "+
            "STOP!\n");
  return 1;
}
int recover() {
  if (!floor)
    reset();
  floor->move(this_player());
  write("Floor recovered.\n");
  say(this_player()->one_short()+" has recovered the floor.\n");
  return 1;
}
int do_log(string str) {
  if (log_bing && !str) {
    write("Stopped logging.\n");
    log_bing = str;
    return 1;
  }
  if (!str) {
    notify_fail("Syntax: log <file_name>\n"+
                "        log by itself to stop logging.\n");
    return 0;
  }
  if (log_bing)
    write("Stopped loggin to "+log_bing+" and started logging to "+str+".\n");
  else
    write("Logging to "+str+".\n");
  log_bing = str;
  return 1;
}
void event_person_say(object ob, string start, string rest) {
  if (log_bing)
    log_file(log_bing, start+rest+"\n");
}
void event_say(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}
void event_soul(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}
void dest_me() {
  if (floor)
    floor->dest_me();
  ::dest_me();
}

==================================================
FILE: admin/room/path.h
==================================================

#define ROOM "/d/admin/room/"

==================================================
FILE: admin/room/playroom.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
object board;
void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("playerhelp");
    board->move(this_object());
  }
}
void setup() {
  set_light(60);
  set_short("Player Help Room");
  set_long(
"You are in a strange room with hundreds of frozen statues in the likenesses "+
"of many players on the DiscWorld.  They all seem to be begging, and "+
"looking at you with mournful eyes.\n");
  add_item(({"player","statue"}),
"They all look as if they are asking you questions, but without "+
"moving their lips.  Some of them look genuinly hopeless, but most "+
"have the look of treachery and deceit.  Quite a few of them have many "+
"faces looking in several directions.  Beware them all.\n");
  add_exit("east", "/w/common", "door");
}
void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}
void event_enter(object ob) {
  if (!ob->query_creator() && !ob->query_property("demon")) {
      tell_object(ob, "Whoops!  You don't seem to be a creator.\n");
      call_out("do_move", 2, ob);
   }
}
void do_move(object ob) {
   tell_object( ob, "A trap door opens in the floor and you fall through!\n" );
   ob->move_with_look( "/d/am/am/mendeddrum", "$N fall$s through a trap "+
         "door in the ceiling.", "A trap door opens in the floor and "+
         "$N fall$s through." );
}

==================================================
FILE: admin/room/quest_room.c
==================================================

#include "quest_handler.h"
#include "path.h"
inherit "/std/room/basic_room";
int level;
string  old_quest;
string  story;
string  title;
int do_create( string quest );
int do_delete( string quest );
int do_help( string what );
int do_level( string new_level );
int do_list();
int do_name( string new_name );
int do_story( string new_story );
int do_title( string new_title );
void  remove_quest( string answer );
void  init();
void  setup();
int
do_create( string quest )
{
    if ( !quest )
    {
  write( "Syntax is: create <quest>, where <quest> will be the name of "
       + "the new quest.\n" );
  return 1;
    }
    if ( !level )
    {
  write( "You must set the quest level first.\n" );
  return 1;
    }
    if ( !story )
    {
  write( "You must set the quest story first.\n" );
  return 1;
    }
    if ( !title )
    {
  write( "You must set the quest title first.\n" );
  return 1;
    }
    if ( QUEST_HANDLER->add_quest( quest , level , title , story ) )
    {
  tell_room( this_object() , "Quest \"" + quest + "\" added.\n" );
  level = 0;
  story = 0;
  title = 0;
    }
    else
  tell_room( this_object() , "Quest failed to add.\n" );
    return 1;
}
int
do_delete( string quest )
{
    string  *quests;
    if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
      return 1;
      quests = (mixed*) QUEST_HANDLER->query_quest_names();
    if ( quest )
    {
        if ( member_array( quest, quests ) == -1 )
  {
      write( "Quest not found.\n" );
      return 1;
  }
  old_quest = quest;
  write( "\nYou should not remove someone else's quest!!!\n\n"
       + "Are your sure you want to remove this quest? (y/n) > " );
  input_to( "remove_quest" );
  return 1;
    }
    write( "Syntax: remove <quest>, where <quest> is the name of an "
   + "existing quest.\n" );
    return 1;
}
int
do_help( string what )
{
    if ( what != "room" )  return 0;
    write( "Quest room help:\n\n"
   + "  create <string> - Use current settings to create a new quest\n"
   + "                    whose name is <string>.\n"
   + "  delete <string> - Delete the quest whose name is <string>.\n"
   + "                    This option available only to Lords.\n"
   + "  help room       - Generate this help screen.\n"
   + "  level <int>     - Set the level of difficulty to <int>.\n"
   + "  list            - List the current quests.\n"
   + "  story <string>  - Set the quest story to <string>.\n"
   + "  title <string>  - Set the string that is added to the player's\n"
   + "                    title to <string>.\n"
   );
    return 1;
}
int
do_level( string new_level )
{
    if ( new_level )
    {
  sscanf( new_level , "%d" , level );
  tell_room( this_object() , "Quest level set to " + level + ".\n" );
    }
    else
  write( "Syntax: level <new_level>, where new_level is an integer "
       + "indicating how difficult the quest is.\n" );
    return 1;
}
int do_list() {
  int i;
  string list;
  mixed *names;
  if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
    return 1;
  list = "These are the Discworld quests:\n\n";
  names = (mixed *)QUEST_HANDLER->query_quest_names();
  for ( i = 0; i < sizeof( names ); i++ ) {
    list += "Quest "+ ( i + 1 ) +"  \""+ names[ i ] +"\", level "+
        (int)QUEST_HANDLER->query_quest_level( names[ i ] ) +"\n    title: "+
        (string)QUEST_HANDLER->query_quest_title( names[ i ] ) +"\n    story: "+
        (string)QUEST_HANDLER->query_quest_story( names[ i ] ) +"\n";
    if ( i < sizeof( names ) - 1 )
      list += "\n";
   }
  reset_eval_cost();
  this_player()->more_string( list, "Quest List", 1 );
  return 1;
}
int
do_story( string new_story )
{
    if ( new_story )
    {
  story = new_story;
  tell_room( this_object() , "Quest story set to:\n" + story + "\n" );
    }
    else
  write( "Syntax: story <new_story>, where new_story is a string that "
       + "describes the quest.\n" );
    return 1;
}
int
do_title( string new_title )
{
    if ( new_title )
    {
  title = new_title;
  tell_room( this_object() , "Quest title set to \"" + title + "\".\n" );
    }
    else
  write( "Syntax: title <new_title>, where new_title is the title that "
       + "is appended to the players name for \"who\".\n" );
    return 1;
}
void
init()
{
#ifdef 0
    string  euid;
    object  tp;
    tp   = this_player();
    euid = geteuid( tp );
    if ( ( "/secure/master"->god( euid )             )
      || ( "/secure/master"->high_programmer( euid ) )
      || ( "/secure/master"->query_lord( euid )      )
      || ( tp->query_creator()                       )
      || ( tp->query_app_creator()                   ) )
    {
  add_action( "do_create" , "create" );
  add_action( "do_help"   , "help"   );
  add_action( "do_level"  , "level"  );
  add_action( "do_story"  , "story"  );
  add_action( "do_title"  , "title"  );
  if ( ( "/secure/master"->god( euid )             )
    || ( "/secure/master"->high_programmer( euid ) )
    || ( "/secure/master"->query_lord( euid )      ) )
  {
      add_action( "do_delete" , "delete" );
      add_action( "do_list"   , "list"   );
  }
  level = 0;
  story = 0;
  title = 0;
  do_help( "room" );
  tell_room( this_object() , "\nQuest settings have been reset to "
         + "nulls by init().\n\n" );
    }
    ::init();
#endif
}
void remove_quest( string answer ) {
    answer = lower_case( answer );
    if ( answer == "y" )
    {
  if ( QUEST_HANDLER->delete_quest( old_quest ) )
      tell_room( this_object() , "Quest \"" + old_quest
             + "\" deleted.\n" );
  else
      tell_room( this_object() , "Quest \"" + old_quest + "\" was not "
             + "deleted.\n" );
  return;
    }
    tell_room( this_object() , "Quest \"" + old_quest
           + "\" was not deleted.\n" );
    return;
}
void
setup()
{
    set_short( "Quest Room" );
    set_long("Don't use this room, get a lord to use the quests command instead. This room will break the quests!\n");
    set_light( 100 );
    add_exit( "west" , ROOM+"development" , "corridor" );
}
