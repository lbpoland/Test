# Total Tokens: 12404
# Total Files Merged: 9
# Total Characters: 41378

================================================

#include <clubs.h>
#include <player.h>
class family_information {
   string name;
   string* adjectives;
   string id;
   string* titles;
   string cur_title;
   string* clubs;
   string force_title;
   int force_timeout;
}
#define FAMILY_CLASS_SIZE 8
private class family_information _family_name;
string query_name();
int set_family_name(string name);
int add_player_title(string title);
void remove_player_title(string title);
private class family_information create_family_info() {
   class family_information bing;
   bing = new(class family_information);
   bing->adjectives = ({ });
   bing->titles = ({ "mr", "miss", "mrs", "ms" });
   bing->clubs = ({ });
   return bing;
}
protected void setup_default_titles() {
   if (!_family_name) {
       return;
   }
   _family_name->titles = ({ "mr", "miss", "mrs", "ms" });
}
private void update_adjectives() {
   if (!_family_name) {
      return ;
   }
   _family_name->adjectives = ({ });
   _family_name->id = 0;
   if (_family_name &&
       _family_name->name) {
      _family_name->adjectives = explode(lower_case(_family_name->name), " ")[0..<2];
      _family_name->id = explode(lower_case(_family_name->name), " ")[<1];
   }
   if (_family_name &&
       _family_name->cur_title) {
      _family_name->adjectives += explode(_family_name->cur_title, " ");
   }
}
void check_family_name() {
   class family_information frog;
   string bing;
   if (!classp(_family_name) &&
       _family_name) {
      bing = (string)_family_name;
      _family_name = create_family_info();
      set_family_name(bing);
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 5) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = ({ });
      _family_name = frog;
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 6) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = _family_name->clubs;
      _family_name = frog;
   }
   if (_family_name &&
       _family_name->name) {
      if (!CLUB_HANDLER->is_family(_family_name->name) ||
          !CLUB_HANDLER->is_member_of(_family_name->name, query_name())) {
         _family_name->name = 0;
      }
   }
   if (_family_name &&
       strlen(_family_name->cur_title) > 20) {
      tell_object(this_object(),
                  "%^YELLOW%^Your title is too long!  Resetting.\n%^RESET%^");
      _family_name->cur_title = 0;
   }
   if (_family_name &&
       _family_name->cur_title) {
      if (member_array(lower_case(_family_name->cur_title),
                       _family_name->titles) == -1) {
         tell_object(this_object(),
                  "%^YELLOW%^Your title is invalid!  Resetting.\n%^RESET%^");
         _family_name->cur_title = 0;
      }
   }
   update_adjectives();
   if (_family_name && _family_name->clubs) {
       _family_name->clubs = filter(_family_name->clubs,
           (: CLUB_HANDLER->is_club($1) :));
   }
}
int set_family_name(string name) {
   if (name && (!CLUB_HANDLER->is_family(name) ||
                !CLUB_HANDLER->is_member_of(name, query_name()))) {
      return 0;
   }
   if (!classp(_family_name)) {
      _family_name = create_family_info();
   }
   if (_family_name->name) {
      CLUB_HANDLER->remove_member(_family_name->name, query_name());
   }
   if (name) {
      _family_name->name = CLUB_HANDLER->query_club_name(name);
   } else {
      _family_name = 0;
   }
   update_adjectives();
   return 1;
}
string query_family_name() {
   if (stringp(_family_name)) {
      return (string)_family_name;
   }
   if (_family_name) {
      return _family_name->name;
   }
   return 0;
}
string query_player_title() {
   check_family_name();
   if (_family_name && classp(_family_name) &&
       _family_name->force_title) {
      if (-this_object()->query_time_on() > _family_name->force_timeout) {
         _family_name->force_title = 0;
      } else {
         return capitalize(_family_name->force_title);
      }
   }
   if (_family_name && classp(_family_name) &&
       _family_name->cur_title) {
      return capitalize(_family_name->cur_title);
   }
   return 0;
}
string* query_all_player_titles() {
   if (!_family_name) {
      _family_name = create_family_info();
   }
   return _family_name->titles;
}
int set_player_title(string title) {
   string* bits;
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (strlen(title) > 20) {
      return 0;
   }
   if (!title ||
       member_array(lower_case(title), _family_name->titles) != -1) {
      if (title) {
         bits = explode(title, " ");
         _family_name->cur_title = implode(map(bits, (: capitalize($1) :)), " ");
      } else {
         _family_name->cur_title = 0;
      }
      update_adjectives();
      return 1;
   }
   return 0;
}
int set_forced_title(string title, int timeout) {
   _family_name->force_title = title;
   _family_name->force_timeout = -this_object()->query_time_on() + timeout;
   tell_object(this_object(), "%^CYAN%^You feel that other peoples perception "
               "of you has changed and you title is being "
               "misinterpreted.%^RESET%^\n");
   return 1;
}
string query_forced_title() {
   return _family_name->force_title;
}
int add_player_title(string title) {
   title = lower_case(title);
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (member_array(title, _family_name->titles) == -1) {
      _family_name->titles += ({ title });
      return 1;
   }
   return 0;
}
void remove_player_title(string title) {
   title = lower_case(title);
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (member_array(title, _family_name->titles) != -1) {
      _family_name->titles -= ({ title });
   }
   if (_family_name->cur_title == title) {
      _family_name->cur_title = 0;
   }
}
int add_player_club(string club) {
   class family_information frog;
   if (!club) {
      return 0;
   }
   club = CLUB_HANDLER->normalise_name(club);
   if (!CLUB_HANDLER->is_club(club)) {
      return 0;
   }
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 5) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = ({ });
      _family_name = frog;
   }
   if (member_array(club, _family_name->clubs) == -1) {
      _family_name->clubs += ({ club });
      return 1;
   }
   return 0;
}
void remove_player_club(string club) {
   if (!club) {
      return 0;
   }
   club = CLUB_HANDLER->normalise_name(club);
   if (!_family_name) {
      return ;
   }
   _family_name->clubs -= ({ club });
}
string* query_player_clubs() {
   if (!_family_name) {
      return ({ });
   }
   return _family_name->clubs;
}
string *parse_command_id_list() {
   if (_family_name &&
       _family_name->id) {
      return ({ _family_name->id });
   }
   return ({ });
}
string *parse_command_plural_id_list() {
   if (_family_name &&
       _family_name->id) {
      return ({ pluralize(_family_name->id) });
   }
   return ({ });
}
string *parse_command_adjectiv_id_list() {
   if (_family_name) {
      return _family_name->adjectives;
   }
   return ({ });
}

==================================================
FILE: finger.c
==================================================

#include <player.h>
#include <mail.h>
#include <clothing.h>
private mapping player_info;
private string password;
private nosave string tmppassword;
string query_name();
private int change_password();
private int change_password2(mixed pass);
private int change_password3(string pass);
private int change_password4(string pass);
int add_command(string command, object ob, mixed format, function func);
void finger_commands() {
   add_command("password", this_object(), "", (: change_password() :));
   add_command("passwd", this_object(), "", (: change_password() :));
}
void set_desc(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   if (!str) {
      map_delete(player_info, "desc");
   } else {
      player_info["desc"] = str;
   }
}
string query_desc() {
   if (!player_info  ||  undefinedp(player_info["desc"])) {
      return "";
   }
   return player_info["desc"] + "%^RESET%^";
}
void set_zone_desc(string zone, string desc) {
   if (!player_info["zone desc"]) {
      player_info["zone desc"] = ([ ]);
   }
   if (!desc) {
      map_delete(player_info["zone desc"], zone);
   } else {
      player_info["zone desc"][zone] = desc;
   }
}
string query_zone_desc(string zone) {
   if (!player_info["zone desc"]) {
      return 0;
   }
   return player_info["zone desc"][zone];
}
string* query_zone_desc_names() {
   if (!player_info["zone desc"]) {
      return ({ });
   }
   return keys(player_info["zone desc"]);
}
string query_main_zone_desc(object* wearing) {
   object bing;
   string zone;
   string type;
   string eq_type;
   string str;
   mixed types;
   mapping covered;
   if (!sizeof(player_info["zone desc"])) {
      return "";
   }
   covered = ([ ]);
   foreach (bing in wearing) {
      types = bing->query_type();
      if (!arrayp(types)) {
         types = ({ types });
      }
      foreach (type in types) {
         eq_type = CLOTHING_HANDLER->query_equivilant_type(type);
         if (eq_type) {
            foreach (zone in CLOTHING_HANDLER->query_zone_names(eq_type)) {
               covered[zone] = 1;
            }
         } else {
            foreach (zone in CLOTHING_HANDLER->query_zone_names(type)) {
               covered[zone] = 1;
            }
         }
      }
   }
   str = "";
   foreach (zone in query_zone_desc_names()) {
      if (!covered[zone]) {
         str += " " + replace_string(query_zone_desc(zone), "$NEW_LINE$", "\n");
      }
   }
   return str;
}
void set_password(string pass) {
   if (file_name(previous_object())[0..12] == "/secure/login" ||
       file_name(previous_object())[0..13] == "/secure/nlogin") {
      password = pass;
   }
}
private int change_password() {
   if (password) {
      write("Please enter your old password : ");
      input_to((: change_password2 :),1);
      return 1;
   }
   change_password2(0);
   return 1;
}
private int change_password2(mixed pass) {
   string str;
   if (password) {
      str = crypt(pass,password);
      if (str != password) {
         write("\nIncorrect.\n");
         return 1;
      }
   }
   write("\nEnter new Password : ");
   input_to((: change_password3 :),1);
   return 1;
}
private int change_password3(string pass) {
   tmppassword = pass;
   if(sizeof(pass) < 6) {
     write("\nPassword is too short, must be at least 6 characters.\n");
     write("Enter new Password :");
     input_to((: change_password3 :),1);
     return 1;
   }
   write("\nPlease enter again : ");
   input_to((: change_password4 :),1);
   return 1;
}
private int change_password4(string pass) {
   if (tmppassword != pass) {
      write("\nIncorrect.\n");
      return 1;
   }
   password = crypt(pass,password);
   write("\nOk.\n");
   return 1;
}
string *query_rhosts() {
  if(!player_info)
    return 0;
  return player_info["allowed_ips"];
}
void set_rhosts(string *ips) {
  if(file_name(previous_object())[0..18] != "/cmds/player/access" &&
     file_name(previous_object())[0..19] != "/cmds/lord/authorise")
    return ;
  if(!player_info)
    player_info = ([ ]);
  player_info["allowed_ips"] = ips;
}
string query_real_name() {
   if (!player_info) {
      return 0;
   }
   return player_info["real_name"];
}
void set_real_name(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   player_info["real_name"] = str;
}
string query_where() {
   if (!player_info) {
      return "";
   }
   return player_info["location"];
}
void set_where(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   player_info["location"] = str;
}
string query_birthday() {
   if (!player_info) {
      return UNKNOWN_BIRTHDAY;
   }
   if (!player_info["birthday"]) {
      return UNKNOWN_BIRTHDAY;
   }
   return player_info["birthday"];
}
void set_birthday(string i) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["birthday"] = i;
}
int query_is_birthday_today() {
   string cmonth;
   string dummy;
   string bmonth;
   int cdate;
   int bdate;
   if (sscanf(ctime(time()), "%s %s %d %s", dummy, cmonth, cdate, dummy)!=4) {
      return 0;
   }
   if (sscanf(query_birthday(), "%d%s of %s", bdate, dummy, bmonth) !=3) {
      return 0;
   }
   if (cmonth == bmonth[0..2] && cdate == bdate) {
      return 1;
   }
}
string query_email() {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..27] != "/obj/handlers/player_handler" &&
     file_name(previous_object())[0..28] != "/obj/handlers/options_handler") {
    return "";
   }
   if (!player_info) {
      return "";
   }
   return player_info["email"];
}
nomask void set_email(string str) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["email"] = str;
}
string query_homepage() {
   if (!player_info) {
      player_info = ([ ]);
   }
   return player_info["homepage"];
}
nomask void set_homepage(string str) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["homepage"] = str;
}
int finger_set() {
   if (!player_info ||
      player_info == ([ ]) ||
      sizeof(keys(player_info)) == 1) {
      return 0;
   }
   return 1;
}

==================================================
FILE: friends.c
==================================================

#include <player.h>
#include <player_handler.h>
#include <cmds/friends.h>
private mapping _friends;
void create() {
   _friends = ([ ]);
}
int is_friend(string person) {
   if (!_friends) {
     _friends = ([ ]);
   }
   return stringp(_friends[person]);
}
string query_friend_tag(string person) {
  if(!interactive(previous_object()))
     return _friends[person];
  if(previous_object()->query_name())
    log_file("CHEAT", "%s query_friend_tag called on %s by %s\n",
             ctime(time()), this_object()->query_name(),
             previous_object()->query_name());
  else
    log_file("CHEAT", "%s query_friend_tag called on %s by %s\n",
             ctime(time()), this_object()->query_name(),
             file_name(previous_object()));
  return "";
}
void add_friend(string person, string tag) {
   if (strlen(tag) > PLAYER_MAX_FRIEND_TAG_LEN) {
      return ;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      return ;
   }
   _friends[person] = tag;
}
void remove_friend(string person) {
   map_delete(_friends, person);
}
string* query_friends() {
   if (file_name(previous_object()) == FRIENDS_CMD) {
      return keys(_friends);
   }
   if(previous_object()->query_name())
     log_file("CHEAT", "%s query_friends called on %s by %s\n",
              ctime(time()), this_object()->query_name(),
              previous_object()->query_name());
   else
     log_file("CHEAT", "%s query_friends called on %s by %s\n",
              ctime(time()), this_object()->query_name(),
              file_name(previous_object()));
   return ({ });
}

==================================================
FILE: guild-race.c
==================================================

#include <player.h>
#include <command.h>
string race_ob, guild_ob,  *known_commands;
mixed *guild_data;
nosave string _race;
void race_guild_commands() {
  string command;
  string *bing;
  string *paths = ({ });
  if (!known_commands) {
    known_commands = ({ "skills", "rearrange", "gp", "newbie" });
  }
  foreach (command in known_commands) {
    bing = CMD_D->GetPaths(command);
    if (sizeof(bing)) {
      bing = filter(bing, (: $1[0..15] == "/cmds/guild-race" :));
      paths += bing;
    }
  }
  this_object()->AddSearchPath(paths);
  if (guild_ob) {
    catch(guild_ob->start_player(this_object()));
  }
  catch(race_ob->start_player(this_object()));
  this_object()->query_limbs();
}
string query_gtitle() {
  string tmp;
  if (guild_ob)
    if (catch((tmp = (string)guild_ob->query_title(this_object()))))
        tmp = "Has a broken guild";
  return tmp;
}
void set_race_ob(string str) {
  string frog;
  if(sscanf(str, "/%s", frog)==1)
    str = extract(str, 1);
  if (str[0..strlen("std/races")-1]!="std/races") {
    write("Illegal path to set_race_ob.\n");
    return;
  }
  if(str[0..strlen("std/races/god")-1] == "std/races/god" &&
     !"/secure/master"->god(geteuid())) {
    write("The heavens rumble and the earth shakes.  You stop.\n");
  }
  else
    race_ob = str;
}
string query_race_ob() { return race_ob; }
void set_guild_ob( string str ) {
  if(str) {
    if(str[0..10] != "/std/guilds") {
      tell_object(this_object(), "Attempt to set invalid guild object " +
                  str + "\n");
      return;
    } else if(!find_object(str)) {
      tell_object(this_object(), "No such object "+ str +"\n");
      return;
    }
  }
  guild_ob = str;
}
 string query_guild_ob() {
   if ( !guild_ob ) {
      return 0;
   }
   if(guild_ob[0..10] != "/std/guilds")
     return 0;
   return guild_ob;
}
void set_guild_data(mixed *dat) { guild_data = dat; }
mixed *query_guild_data() {
  return guild_data;
}
string query_race() {
  if(!_race)
    _race = (string)race_ob->query_name();
  return _race;
}
string help_command(string str) {
  class command cmd = new(class command, verb : str);
  string path;
  mixed func;
  if ((member_array(str, known_commands) != -1 ||
       this_object()->query_creator()) &&
      CMD_D->HandleStars(cmd)) {
    path =  CMD_D->GetPaths(cmd->verb)[0] + "/" + cmd->verb;
    func = path->help_function();
    if (func) {
       return func;
    }
    return path->help();
  }
  return 0;
}
string *query_known_commands() { return copy(known_commands); }
int query_known_command( string word ) {
   return ( member_array( word, known_commands ) != -1 );
}
int add_known_command(string str) {
  string *paths;
  if (member_array(str, known_commands) != -1) {
    return 0;
  }
  if (!CMD_D->IsGRCommand(str)) {
    return 0;
  }
  paths = CMD_D->GetPaths(str);
  paths = filter(paths, (: $1[0..15] == "/cmds/guild-race" :));
  if (sizeof(paths)) {
    this_object()->AddSearchPath(paths);
  }
  known_commands += ({ str });
  if ( interactive( this_object() ) )
    log_file( "ADD_KNOWN_COMMAND", "%s: %s was added to %s by: %O.\n", ctime( time() ),
        str, this_player()->query_name(), map( previous_object( -1 ), (: ({ $1,  $1->query_name() }) :) ) );
  return 1;
}
int remove_known_command(string str) {
  int i;
  i = member_array(str, known_commands);
  if (i == -1) {
    return 0;
  }
  known_commands = known_commands[0..i-1] + known_commands[i+1..];
  return 1;
}

==================================================
FILE: history.c
==================================================

#define COLS (int)this_object()->query_cols()
nosave string *history;
nosave int hoffset, numoff;
nosave int in_alias_command;
nosave string ignore_history;
void history_commands() {}
string substitute_history(string arg) {
  string s1, s2;
  if (sscanf(arg, "%s^%s", s1, s2) != 2)
    return arg;
  sscanf(s2, "%s^", s2);
  if (hoffset)
    return replace(history[hoffset-1], s1, s2);
  else
    return replace(history[sizeof(history)-1], s1, s2);
}
protected string expand_history( string arg ) {
   int num, i;
   if (arg[0] == '.' || strlen(arg) == 0) {
      if (hoffset) {
         return history[hoffset-1]+arg[1..strlen(arg)];
      } else {
         return history[sizeof(history)-1]+arg[1..strlen(arg)];
      }
   }
   if (sscanf(arg,"%d",num)==1) {
      num = num % sizeof(history);
      if (num<0) {
         num += hoffset;
         if (num<0) {
            num += sizeof(history);
         }
      }
      return history[num];
   }
   for (i=hoffset-1;i>=0;i--) {
      if (stringp(history[i])) {
         if (strsrch(history[i],arg)==0) {
            return history[i];
         }
      }
   }
   for (i=sizeof(history)-1;i>hoffset;i--) {
      if (stringp(history[i])) {
         if (strsrch(history[i],arg)==0) {
            return history[i];
         }
      }
   }
   return arg;
}
void ignore_from_history(string str) {
  ignore_history = str;
}
void add_history( string arg ) {
   if (ignore_history) {
      if (ignore_history == arg) {
         ignore_history = 0;
         return ;
      }
      ignore_history = 0;
   }
   if (arg == "" || arg[0] == '.' || arg[0] == '^')
      return;
   if (in_alias_command)
      return;
   if (!history) {
      history = allocate(40);
      numoff = -40;
   }
   history[hoffset++] = arg;
   if (hoffset>=sizeof(history)) {
      numoff += sizeof(history);
      hoffset = 0;
   }
}
nomask int print_history( string arg ) {
   int i, from, to, num;
   if(this_player()!=this_object()) {
      if(!interactive(this_player())) {
         return 0;
      }
      if(!(master()->query_lord(geteuid(this_player()))) &&
         !master()->is_liaison_deputy(geteuid(this_player()))) {
         return 0;
      }
   }
  if(this_object()!=this_player(1)) {
   user_event( this_object(), "inform",
               "Print history called on " + this_object()->query_name() +
               " by " + this_player()->query_name(),
               "calls", this_player());
  }
   from = hoffset;
   num = sizeof(history);
   if (!arg) {
      arg = "";
   }
   if (sscanf(arg,"%d,%d",from,to)==2) {
      num = to-from;
      if (num<0) {
         from = from+num;
         num = -num;
      }
   } else if (sscanf(arg,",%d",to)==1) {
      from = hoffset+1+num;
      num = from - (to%sizeof(history))+sizeof(history);
   } else if (sscanf(arg,"%d,",from)==1) {
      from = from % sizeof(history);
      num = from - hoffset;
      if (num<0) {
         num += sizeof(history);
      }
   } else if (sscanf(arg,"%d",num)!=1) {
         num = sizeof(history);
   }
   if(sizeof(history)) {
     from = from % sizeof(history);
   } else {
     from = 0;
   }
   if (num>sizeof(history)) {
     num = sizeof(history);
   }
   if (num <= 0) {
     add_failed_mess("Range out of bounds.\n");
     return 0;
   }
   for (i=from;i<sizeof(history);i++,num--) {
     if (history[i]) {
       printf( "%s%-=*s\n", sprintf( "% 4d", i + numoff ) +": ", COLS - 6,
               history[ i ] );
     }
     if (!num) {
       return 1;
     }
   }
   for (i=0;i<from;i++,num--) {
     if (history[i]) {
       printf( "%s%-=*s\n", sprintf( "% 4d", i + numoff + sizeof( history ) ) +
               ": ", COLS - 6, history[ i ] );
     }
     if (!num) {
       return 1;
     }
   }
   return 1;
}
nomask protected string *get_history() {
  return history;
}

==================================================
FILE: le.c
==================================================

private nosave int line;
private nosave string *cfile, cfile_name, last_search;
protected int le(string s);
int add_command(string str, object ob, string format, function funct);
void create() {
  seteuid("PLAYER");
}
private void print_line() {
   if (line > sizeof(cfile)) {
      line = sizeof(cfile);
   }
   if (!line) {
      write("No line.\n");
      return;
   }
   write(extract("   ", 0, 3 - strlen(line + "")) + line + ":" + cfile[line-1] + "\n");
}
protected void le_commands() {
   add_command("le", this_object(), "<string>", (: le($4[0]) :));
}
protected int le(string s) {
   int j;
   string sB;
   if (!pointerp(cfile)) { cfile = ({ }); line = 0; }
   if (!s || s == "") { print_line(); return 1; }
   if (sscanf(s, "%d", j)) { line = j; print_line(); return 1; }
   switch (s[0]) {
   case 'd':
      if (!line) { notify_fail("Not on a line.\n"); return 0; }
      cfile = delete(cfile, line-1, 1);
      print_line();
      return 1;
   case 'N':
      cfile = ({ });
      line = 0;
      cfile_name = 0;
      write("Line editor cleared.\n");
      return 1;
   case '/':
      s = extract(s, 1);
      if (s == "") {
         s = last_search;
      }
      last_search = s;
      {
         int i, s1, s2;
         for (i = line+1; i<= sizeof(cfile); i++) {
            if (sscanf(cfile[i-1], "%s"+s+"%s", s1, s2)) { line = i; print_line(); return 1; }
         }
         write("Search failed.\n");
         return 1;
      }
   case '>':
      s = extract(s, 1);
      {
         string *tmp1, *tmp2;
         tmp1 = (line > 1) ? cfile[0..line-2] : ({ });
         tmp2 = (line <= sizeof(cfile)) ? cfile[line-1..sizeof(cfile)-1] : ({ });
         cfile = tmp1 + ({ s }) + tmp2;
      }
      line++;
      print_line();
      return 1;
   case 'r':
      {
         string sA;
         sA = extract(s, 1);
         while (sA[0] == ' ') sA = extract(sA,1);
         sB = this_player()->get_path(sA);
         if (!sB) sB = sA;
         if (file_size(sB) < 0) { notify_fail("File doesn't exist.\n"); return 0; }
         sA = read_file(sB);
         cfile = explode(sA, "\n");
         line = 1;
      }
      write("Read file "  + sB + ": " + sizeof(cfile) + " lines.\n");
      cfile_name = sB;
      print_line();
      return 1;
   case '+':
      if (line < sizeof(cfile)) line++;
      print_line();
      return 1;
   case '-':
      if (line > 1) line --;
      print_line();
      return 1;
   case 'w':
      if (s == "w") {
         if (!cfile_name) { notify_fail("No file name.\n"); return 0; }
      } else {
         s = extract(s,1);
         while (s[0] == ' ') s = extract(s, 1);
         if (this_player()->get_path(s)) s = this_player()->get_path(s);
         cfile_name = s;
      }
      rm(cfile_name);
      write_file(cfile_name, implode(cfile, "\n"));
      write("Tried to write file " + cfile_name + ": " + sizeof(cfile) + " lines.\n");
      return 1;
   case 'z':
      {
         int q;
         q = 20;
         while (q-- && line <= sizeof(cfile)) { print_line(); line++; }
         line --;
      }
      return 1;
   }
}

==================================================
FILE: line_ed.c
==================================================

#include "ed.h"
#include <player_handler.h>
private nosave string *_lines;
private nosave mixed _end_func;
private nosave object _ed_ob = 0;
private nosave int _insertion_point;
private string editor;
private nosave string _filename;
private nosave int _in_editor;
private void main_bit(string str);
int set_editor(string name);
private void editor_do_quit(string str);
private void editor_loop(string str);
private void editor_insert(string str);
private void editor_delete(string str);
private void editor_modify(string str);
private void editor_check_quit(string str);
private void editor_modify2(string str, int range1, int range2);
private void editor_modify3(string str, int range1, int range2,
                            string modify_string);
protected void create()  {
  editor = "menu";
}
protected void editor_commands()  {
  add_command("editor", "{menu|magic|ed|command}", (: set_editor($4[0]) :));
}
varargs int do_edit(string str, mixed end_f, object end_o, string fname,
                    mixed extra)  {
  if (!end_f) {
    printf("Someone has stuffed up - there is no end function.\n");
    return 0;
  } else {
    _end_func = end_f;
  }
  if (!end_o) {
    end_o = previous_object();
  }
  if (!str) {
    str = "";
  }
  if (!strlen(fname)) {
    _filename = TMP_FILE;
  } else {
    _filename = fname;
  }
  if (!functionp(end_f)) {
    if (extra) {
      _end_func = (: call_other($(end_o), $(end_f), $1, $(extra)) :);
    } else {
      _end_func = (: call_other($(end_o), $(end_f), $1) :);
    }
  } else {
    if (extra) {
      _end_func = (: evaluate($(end_f), $1, $(extra)) :);
    } else {
      _end_func = (: evaluate($(end_f), $1) :);
    }
  }
  switch (editor) {
  case "menu":
    _lines = explode(str, "\n") - ({ 0 });
    printf("Enter your text.  Use ** on a line by itself to exit.\n");
    _insertion_point = sizeof(_lines);
    printf("%-2d] ", _insertion_point + 1);
    _in_editor = 1;
    input_to((: editor_loop :));
    return 1;
  case "ed":
    if (strlen(str) && (_filename == TMP_FILE))
      write_file(_filename, str);
    _in_editor = 1;
    ed(_filename, "editor_finish_ed", !this_object()->query_creator());
    return 1;
  case "magic":
    if (strlen(str) && (_filename == TMP_FILE))
      write_file(_filename, str);
    _in_editor = 1;
    _ed_ob = new(PRESTOS_ED, _filename, _filename != TMP_FILE);
    return 1;
  case "command":
    _lines = explode(str, "\n") - ({ 0 });
    printf("Enter your text.  Use ** on a line by itself to exit or "
           "~h for help.\n");
    _insertion_point = sizeof(_lines);
    printf("%-2d] ", _insertion_point + 1);
    _in_editor = 1;
    input_to((: editor_loop :));
    return 1;
  }
}
private void main_bit(string str) {
  int i;
  string s;
  if (str != "") {
    while (str[0] == ' ') {
      str = str[1..];
    }
    switch (str[0]) {
    case 'i':
    case 'I':
      printf("Insert before line: ");
      input_to((: editor_insert :));
      return;
    case 'd':
    case 'D':
      printf("Delete (line no, or n..m ie 1..2): ");
      input_to((: editor_delete :));
      return;
    case 'l':
    case 'L':
      if (!sizeof(_lines))  {
        main_bit("");
      } else {
        s = "";
        for (i = 0; i < sizeof(_lines); i++)
          s += sprintf("%3d: %s\n", i + 1, _lines[i]);
        this_object()->set_finish_func("end_of_edit_more");
        this_object()->more_string(s);
      }
      return;
    case 'm':
    case 'M':
      printf("Modify which line (line no, or n..m ie 1..2): ");
      input_to((: editor_modify :));
      return;
    case 'c':
    case 'C':
      _insertion_point = sizeof(_lines);
      printf("Okay, back into insertion mode.  Use ** on a line "
             "by itself to exit.\n%-2d] ", _insertion_point + 1);
      input_to((: editor_loop :));
      return;
    case 'e':
    case 'E':
      printf("Entering ed... Use \"q\" to quit, \"x\" to save and "
             "quit, \"Q\" to quite without saving changes and \"h\" "
             "for help.\n");
      write_file(_filename, implode(_lines, "\n"));
      ed(_filename, "editor_exit_ed", !this_object()->query_creator());
      return;
    case 's':
    case 'S':
      printf("Quitting and saving.\n");
      editor_do_quit(implode(_lines, "\n"));
      return;
    case 'q':
    case 'Q':
      printf("Are you sure you want to quit? (Y/N) ");
      input_to((: editor_check_quit :));
      return;
    case 'h':
    case 'H':
      s = read_file(ED_HELP_FILE);
      this_object()->set_finish_func("end_of_edit_more");
      this_object()->more_string(s);
      return;
    default:
      printf("I do not understand you.  Try %s for help.\n",
             (editor == "command" ? "~h" : "h" ));
      main_bit("");
      return;
    }
  }
  if (editor == "menu") {
    printf(sizeof(_lines) +" lines - Choose from IDLMCESQ or H for help.");
    input_to((: main_bit :));
  }
  else {
    printf("%-2d] ", _insertion_point + 1);
    input_to((: editor_loop :));
  }
  return;
}
void end_of_edit_more()  {
  this_object()->set_finish_func(0);
  main_bit("");
}
private void editor_delete(string str)  {
  int num1, num2, tmp;
  if (sscanf(str, "%d..%d", num1, num2) == 2)  {
    if (num1 > num2)  {
      tmp = num1;
      num1 = num2;
      num2 = tmp;
    }
    if ((num1 < 1) || (num2 > (sizeof(_lines) + 1))) {
      printf("Out of bounds.\n");
      main_bit("");
    }
    printf("Deleting from line %d to line %d.\n", num1, num2);
    _lines = delete(_lines, num1 - 1, num2 - num1 + 1);
    printf("Okay.\n");
    main_bit("");
    return;
  }
  if (sscanf(str, "%d", num1) == 1)  {
    if ((num1 < 1) || (num1 > (sizeof(_lines) + 1)))  {
      printf("Line number out of range.\n");
      main_bit("");
      return;
    }
    printf("Deleting line %d.\n", num1);
    _lines = delete(_lines, num1 - 1, 1);
    printf("Okay.\n");
    main_bit("");
    return;
  }
  printf("Error: invalid data %s.\n", str);
  main_bit("");
  return;
}
private void editor_insert(string str)  {
  int num;
  if (sscanf(str, "%d", num) != 1)  {
    printf("Error: must be a number.\n");
    main_bit("");
    return;
  }
  if ((num < 1) || (num > (sizeof(_lines) + 1))) {
    printf("Error: number out of bounds.\n");
    main_bit("");
    return;
  }
  _insertion_point = num - 1;
  printf("Inserting before line %d.  Entering insertion mode.  Use ** on a "
         "line by itself to exit\n%-2d] ", num, num);
  input_to((: editor_loop :));
  return;
}
private void editor_loop(string str) {
  if ((strlen(str) > 1) && (str[0] == '~') && (editor == "command")) {
    main_bit(str[1..]);
    return;
  }
  if (str == "**") {
    if (editor == "menu") {
      main_bit("");
    } else if (sizeof(_lines)) {
      editor_do_quit(implode(_lines, "\n"));
    } else {
      editor_do_quit(0);
    }
    return;
  }
  _lines = _lines[0.._insertion_point - 1] + ({ str }) +
    _lines[_insertion_point..];
  ++_insertion_point;
  printf("%-2d] ", _insertion_point + 1);
  input_to((: editor_loop :));
  return;
}
private void editor_modify(string str)  {
  int num1, num2, tmp;
  if (sscanf(str, "%d..%d", num1, num2) == 2)  {
    if (num1 > num2)  {
      tmp = num1;
      num1 = num2;
      num2 = tmp;
    }
    if ((num1 < 1) || (num2 > (sizeof(_lines) + 1))) {
      printf("Error: number out of bounds.\n");
      main_bit("");
    }
    printf("Modifying from line %d to line %d.\n", num1, num2);
    printf("Text to change? ");
    input_to((: editor_modify2 :), 0, num1, num2);
    return;
  }
  if (sscanf(str, "%d", num1) == 1)  {
    if ((num1 < 1) || (num1 > (sizeof(_lines) + 1)))  {
      printf("Error: line number out of range.\n");
      main_bit("");
      return;
    }
    printf("Modifying line %d.\n", num1);
    printf("Text to change? ");
    input_to((: editor_modify2 :), 0, num1, num1);
    return;
  }
  printf("Error: invalid data %s.\n", str);
  main_bit("");
  return;
}
private void editor_modify2(string str, int range1, int range2)  {
  if (!strlen(str))  {
    printf("Aborting.\n");
    main_bit("");
    return;
  }
  printf("Change to: ");
  input_to((: editor_modify3 :), 0, range1, range2, str);
  return;
}
private void editor_modify3(string str, int range1, int range2,
                            string modify_string) {
  int i;
  printf("Changing all occurrences of \"%s\" to \"%s\" from line %d to "
         "line %d.\n", modify_string, str, range1, range2);
  for (i = range1 - 1; (i < range2) && (i < sizeof(_lines)); i++) {
    _lines[i] = replace_string(_lines[i], modify_string, str);
      printf("%3d: %s\n", i + 1, _lines[i]);
  }
  printf("Done.\n");
  main_bit("");
  return;
}
void editor_exit_ed()  {
  string str;
  str = read_file(_filename);
  if ((file_size(_filename) >= 0) && !rm(_filename))
    log_file(LOG_FILE, "ed: couldn't rm %s\n", _filename);
  _lines = explode("#" + str, "\n");
  _lines[0] = _lines[0][1..];
  main_bit("");
  return;
}
void editor_finish_ed()  {
  string str;
  str = read_file(_filename);
  if ((file_size(_filename) >= 0) && (_filename == TMP_FILE) &&
      !rm(_filename)) {
    log_file(LOG_FILE, "ed: couldn't rm %s\n", _filename);
  }
  if (!str)  {
    printf("Aborted.\n");
    editor_do_quit(0);
    return;
  }
  if (_filename == TMP_FILE)  {
    editor_do_quit(str);
  } else {
    editor_do_quit(0);
  }
  return;
}
void editor_do_quit(string str)  {
  _lines = ({ });
  if ((editor == "magic") && (_filename == TMP_FILE) &&
      (file_size(_filename) >= 0) && !rm(_filename))  {
    printf("magic: couldn't remove %s\n" , _filename);
    str = 0;
  }
  _in_editor = 0;
  if (_ed_ob) {
    destruct(_ed_ob);
  }
  evaluate(_end_func, str);
}
private void editor_check_quit(string str)  {
  if ((str != "") && (str[0] != 'y') && (str[0] != 'Y')) {
    printf("Returning to the editor.\n");
    main_bit("");
    return;
  }
  printf("Quitting.\n");
  editor_do_quit(0);
  return;
}
int set_editor(string str)  {
  editor = str;
  printf("Editor set to %s.\n", str);
  return 1;
}
string append_signature() {
  return PLAYER_HANDLER->query_signature(this_object()->query_name());
}
void editor_check_do_quit()  {
  if (_in_editor)  {
    printf("Saving what you are editing.\n");
    if (editor != "ed") {
      editor_do_quit(implode(_lines, "\n"));
    } else {
      editor_finish_ed();
    }
  }
}
string query_editor() {
  return editor;
}
int query_in_editor() {
  return _in_editor;
}

==================================================
FILE: log.c
==================================================

private nosave mapping last_error;
void logging_commands() {
}
void set_last_error(mapping err) {
  last_error = err;
}
mapping get_last_error() {
  return (mapp(last_error)?last_error:0);
}

==================================================
FILE: lord.c
==================================================

#define CREATOR_DOC "/doc/creator/concepts/creator_doc.txt"
#include <command.h>
#include <mail.h>
inherit "/global/wiz_file_comm";
protected int do_dismiss(string str, string reason);
protected int employ(string str);
protected int new_domain(string dom, string director);
private int do_heart_beat();
protected int do_qsnoop(object *obs);
protected int bulk_delete( string word );
protected int clean_up_files( string word );
protected int do_hexec(string);
void create() {
  ::create();
}
void move_player_to_start(string bong, int bing, string c_name, string ident,
                          int go_invis) {
  ::move_player_to_start(bong, bing, c_name, ident, go_invis);
  cat("doc/CREATORNEWS");
  cat("doc/DIRECTORNEWS");
#ifndef NEW_DRIVER
  enable_wizard();
#endif
   switch ( query_invis() ) {
      case 3 :
         tell_object( this_object(),
               "===> You are currently Trustee invisible! <===\n" );
         break;
      case 2 :
         tell_object( this_object(),
               "===> You are currently Director invisible! <===\n" );
         break;
      case 1:
         tell_object( this_object(),
               "===> You are currently invisible! <===\n" );
         break;
   }
  add_command("qsnoop", this_object(), "<indirect:player>", (: do_qsnoop($1)
                                                             :));
  add_command("qsnoop", this_object(), "", (: do_qsnoop :));
  add_command("employ", this_object(), "<word>", (: employ($4[0]) :));
  add_command("dismiss", this_object(), "<word> <string>", (: do_dismiss($4[0], $4[1]) :));
  add_command("new_domain", this_object(), "<word> <word>",
              (: new_domain($4[0], $4[1]) :) );
  add_command("heart_beat", this_object(), "", (: do_heart_beat() :) );
  add_command("bulk_delete", this_object(),
              "{a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z}",
              (: bulk_delete($4[0]) :) );
  add_command("clean_up_files",  this_object(), "<word>",
              (: clean_up_files($4[0]) :) );
  AddSearchPath(({ DIR_LORD_CMDS, DIR_SECURE_LORD_CMDS }));
}
protected mixed process_input(string input){
  if(input == "end_it_all")
    shutdown(0);
  if(input[0..4] == "hexec")
    return do_hexec(input[5..]);
  return ::process_input(input);
}
protected int end_it_all() {
  shutdown(0);
  return 1;
}
private int do_heart_beat() {
  heart_beat();
  return 1;
}
int query_creator() {
  return 1;
}
nomask int query_director() {
  return 1;
}
nomask int query_lord() {
  return 1;
}
protected int employ(string str) {
  string doc;
  if (GetForced()) {
    return 0;
  }
  switch (master()->employ_creator( lower_case(str) )) {
    case 2 :
      if(file_size(CREATOR_DOC) > 0) {
        doc = read_file(CREATOR_DOC);
        AUTO_MAILER->auto_mail(lower_case(str), this_player()->query_name(),
          "Documents for new creators", "", doc, 0, 0);
      }
      return 1;
    case 1 :
      return 1;
    default :
      return 0;
  }
}
protected int do_dismiss(string str, string reason) {
  if (GetForced()) {
    return 0;
  }
   return (int)master()->dismiss_creator( str + " " + reason);
}
protected int new_domain(string dom, string director) {
  if (GetForced()) {
    return 0;
  }
  return (int)master()->create_domain(dom, director);
}
string query_object_type(object) {
  if (master()->query_trustee(geteuid(this_object())))
    return "T";
  return "D";
}
void event_enter(object me, string s1, object from) {
  if ((!s1 || s1 == "") && interactive(me)) {
    if (environment() == environment(me))
      event_inform(me, me->query_cap_name()+" invisibly enters the room",
                   "enter");
    else
      event_inform(me, me->query_cap_name()+" invisibly enters your inventory",
                   "enter");
  }
  ::event_enter(me, s1, from);
}
void event_exit(object me, string s1, object from) {
  if ((!s1 || s1 == "") && interactive(me)) {
    if (environment() == environment(me))
      event_inform(me, me->query_cap_name()+" invisibly exits the room",
                   "enter");
    else
      event_inform(me, me->query_cap_name()+" invisibly exits your inventory",
                   "enter");
  }
  ::event_exit(me, s1, from);
}
protected int do_hexec(string junk) {
  if (GetForced()) {
    return 0;
  }
  write_file("/w/"+query_name()+"/exec_thing.c", "void create() { "+junk+"; }");
  catch(("/w/"+query_name()+"/exec_thing")->bingle());
  destruct(find_object("/w/"+query_name()+"/exec_thing"));
  rm("/w/"+query_name()+"/exec_thing.c");
  return 1;
}
varargs int adjust_xp(int number, int shared) {
  if (objectp(previous_object())) {
    event_inform(previous_object(),
                 (string)previous_object()->query_name() + " (" +
                 file_name(previous_object()) +") gives you " +
                 number + " xp", "xp");
  }
  return ::adjust_xp(number, shared);
}
protected int bulk_delete( string word ) {
  if (GetForced()) {
    return 0;
  }
  word = lower_case(word);
  return (int)"/secure/bulk_delete"->delete_files(word);
}
protected int clean_up_files( string word ) {
  if (GetForced()) {
    return 0;
  }
  return (int)"/secure/bulk_delete"->clean_up_files(word);
}
protected int do_qsnoop(object *obs) {
  object targ;
  if (GetForced()) {
    return 0;
  }
  if (!obs || !sizeof(obs)) {
    snoop(this_object(), 0);
    write("Ok, qsnoop cancelled.\n");
    return 1;
  }
  targ = obs[0];
  if(!snoop(this_object(), targ)) {
    notify_fail("You fail to qsnoop " + targ->query_cap_name() + ".\n");
    return 0;
  }
  write("Ok, qsnooping "+targ->query_cap_name() + ".\n");
  return 1;
}
