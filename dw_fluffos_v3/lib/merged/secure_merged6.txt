# Total Tokens: 18112
# Total Files Merged: 30
# Total Characters: 60457

.c
==================================================

void crash(string crash_mess, object command_giver, object current_object) {
  object thing, *things;
  string crashtxt;
  reset_eval_cost();
  log_file("CRASH", "\n"+ ctime(time()) +":\n");
  if (current_object)
    log_file("CRASH", "current object: "+ file_name(current_object) +
             " ("+ current_object->query_name() +")\n");
  if (command_giver)
    log_file("CRASH", "command giver: "+ file_name(command_giver) +
             " ("+ (string)command_giver->query_name() +")\n");
  if (query_verb())
    log_file("CRASH", "command given: "+ query_verb() +"\n");
  log_file("CRASH", "crash reason: "+ crash_mess +"\n");
  things = users();
  log_file("CRASH", "["+ implode((string *)things->query_name(), ", ") +
           "]\n");
  flush_log_files();
  crashtxt = "Wodan "+({"says: I wonder what this button does...",
                        "says: Ceres, look out for that wire....",
                        "says: Wow, look at the uptime.",
                        "whispers: I don't think we should be doing this on my desk..",
                        "shouts: Look at all that xp!"})[random(5)];
  foreach (thing in things) {
    reset_eval_cost();
    efun::tell_object(thing, crashtxt + "\n("+ crash_mess +")\n");
    catch(thing->quit());
  }
}

==================================================
FILE: master/create_dom_creator.c
==================================================

#include <quest_handler.h>
#include <player_handler.h>
#include <player_handler.h>
#define BACKUP_DIR "/save/creators/"
int employ_creator( string name );
int create_domain( string name , string lord );
int dismiss_creator( string str );
int eligible_creator( object player );
void backup_vaults(string, int);
void backup_bank(string, int);
void backup_quest_library(string, int);
int create_domain(string name, string lord) {
  string file;
  object *interactives;
  if (!( master()->high_programmer(previous_object(-1)) &&
        sizeof((interactives = filter(previous_object(-1),
                                      (: interactive($1) :))) ))) {
    write("Cheat!\n");
    return 0;
  }
  if ( master()->high_programmer(capitalize(name))) {
    write("Invalid name....\n");
    return 0;
  }
  if (file_size("/d/"+name) != -1) {
    write("Domain already exists (or invalid).\n");
    return 0;
  }
  if (sizeof(explode(name, "/")) > 1) {
    write("Invalid to have a / in the domain name.\n");
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator(lord)) {
    write("The lord must exist.... and be a creator already.\n");
    return 0;
  }
  mkdir("/d/"+name);
  master()->add_lord(lord);
  file = read_file("/std/dom/master.c");
  write_file("/d/"+name+"/master.c", "#define LORD \""+lord+"\"\n");
  write_file("/d/"+name+"/master.c", "#define DOMAIN \""+name+"\"\n");
  write_file("/d/"+name+"/master.c", file);
  file = read_file("/std/dom/common.c");
  write_file("/d/"+name+"/common.c",
             "#define DOM_TITLE \"the domain of "+name+"\"\n");
  write_file("/d/"+name+"/common.c", "#define LORD \""+lord+"\"\n");
  write_file("/d/"+name+"/common.c", "#define DOMAIN \""+name+"\"\n");
  write_file("/d/"+name+"/common.c", file);
  file = read_file("/std/dom/loader.c");
  write_file("/d/"+name+"/loader.c", "#define DOMAIN \""+name+"\"\n");
  write_file("/d/"+name+"/loader.c", file);
  save_object("/secure/master");
  write("Created domain "+name+".\n");
  write_file("/log/PROMOTIONS", "Domain "+name+" created with a lord of "+
             lord+" by "+geteuid(interactives[0])+" at "+ctime(time())+"\n");
  return 1;
}
int employ_creator(string name) {
  object *interactives;
  string fname;
  if (!( master()->query_lord(previous_object(-1)) &&
        sizeof((interactives = filter(previous_object(-1),
                                      (: interactive($1) :))))))
    return 0;
  if (!PLAYER_HANDLER->test_user(name)) {
    write("User does not exist.\n");
    return 1;
  }
  if (file_size("/save/creators/"+ name + "/save_file.o") > 0) {
    write( "Player file has already been backed up.\n" );
    return 1;
  }
  fname = PLAYER_HANDLER->query_player_file_name(name);
  if (file_size(fname + ".o.gz") > 0) {
    unguarded((: uncompress_file, fname + ".o.gz" :));
  }
  mkdir (BACKUP_DIR + name);
  unguarded((: cp, fname + ".o",
               "/save/creators/" + name + "/save_file.o" :));
  backup_vaults(name, 0);
  backup_bank(name, 0);
  backup_quest_library(name, 0);
  if (find_player(name)) {
    find_player(name)->set_creator(1);
    find_player(name)->save();
    tell_object( find_player( name ), "You have been employed by "+
                 capitalize( geteuid( interactives[0] ) ) +".\n" );
    tell_object( find_player( name ), "Quit and log back in to get the "
                 "creator commands.\n" );
    tell_object( find_player( name ), "Be sure to look over the "
                 "directories, especially /doc.  \"help create\" will give "
                 "you a brief list of commands.\n" );
    tell_object( find_player( name ), "Womble on, mighty frog.\n" );
  } else {
    unguarded((: write_file, fname + ".o",
                 "creator 1\nhome_dir \"/w/"+ name +"\"\n" :));
  }
  unguarded((: compress_file, fname + ".o.gz" :));
  if ( file_size( "/w/"+ name ) == -1 ) {
    unguarded((: mkdir, "/w/"+ name :));
    unguarded((: write_file, "/w/"+ name +"/workroom.c",
                 "#define CREATOR \""+ name +"\"\n" :));
    unguarded((: write_file, "/w/"+ name +"/workroom.c",
                 read_file( "/std/creator/workroom.c" ) :));
    unguarded((: cp, "/std/creator/creator_kit.o", "/w/" + name +
                 "/creator_kit.o" :));
  }
  unguarded((: write_file, "/log/EMPLOYMENT",
               sprintf( "%s: %s employed by %s\n", ctime( time() ), name,
                        (string)interactives[0]->query_name() ) :));
  write( capitalize( name ) +" employed.\n" );
  PLAYER_HANDLER->remove_cache_entry(name);
  return 2;
}
int dismiss_creator(string str) {
  string name;
  string reason;
  string fname;
  string save_file;
  object *interactives;
  if (!( master()->query_lord(previous_object(-1)) &&
        sizeof((interactives = filter(previous_object(-1),
                                      (: interactive($1) :))))))
    return 0;
  if (sscanf(str, "%s %s", name, reason) != 2) {
    notify_fail("You need to give a reason!\n");
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator(name)) {
    return notify_fail(name + " is not a creator!\n");
  }
  if ( master()->query_lord(name)) {
    write( "Cannot dismiss Lords.\n" );
    return 0;
  }
  unguarded((: write_file, "/log/DISMISSALS",
               sprintf( "%s: %s dismissed by %s\nreason: %s\n",
                        ctime( time() ), name,
                        (string)interactives[0]->query_name(), reason ) :));
  fname = PLAYER_HANDLER->query_player_file_name(name);
  if (find_player(name)) {
    find_player(name)->set_creator(0);
    find_player(name)->save();
    tell_object(find_player(name),
                "You have been dismissed by "+
                capitalize( (string)interactives[0]->query_name() ) +".\n" );
    find_player(name)->quit();
    if (file_size(fname + ".o.gz") != -1) {
       unguarded((: uncompress_file, fname + ".o.gz" :));
    }
  } else {
    if (file_size(fname + ".o.gz") != -1) {
       unguarded((: uncompress_file, fname + ".o.gz" :));
    }
    unguarded((: write_file, fname+".o",
                 "creator 0\nhome_dir 0\n" :));
    unguarded((: compress_file, fname+".o" :));
  }
  write( capitalize( name ) +" dismissed.\n" );
  save_file = "/save/creators/" + name + "/save_file.o";
  if (file_size (save_file) == -1) {
    save_file = BACKUP_DIR + name + ".o";
  }
  backup_vaults (name, 1);
  backup_bank (name, 1);
  backup_quest_library (name, 1);
  if (file_size(save_file) > 0) {
    unguarded((: write_file, save_file, "last_log_on "+time()+"\n" :));
    unguarded((: cp, save_file, fname+".o" :));
    unguarded((: rm, save_file :));
    unguarded((: rm, fname+".o.gz" :));
    unguarded((: compress_file, fname+".o" :));
  }
  if(file_size("/w/"+name) == -2) {
    unguarded((: rename, "/w/"+name, "/w/.old_creators/"+name :) );
  }
  rm (save_file);
  rmdir (BACKUP_DIR + name);
  PLAYER_HANDLER->remove_cache_entry(name);
  return 1;
}
int eligible_creator( object player ) {
  int age, level;
  string age_str, reasoning;
  reasoning =
    "  You do not have a *right* to create here.  In order to enhance your\n"
    "chances to be employed, you should demonstrate by your actions that you\n"
    "are worthy.\n"
    "  If our Creators find lots of your bug, typo, and idea reports in their\n"
    "directories, then your chances are improved.  If you have been a trouble-\n"
    "maker here, your chances are very slim.  Harrassing the Lords for a\n"
    "position will not help your chances either.\n"
    "  Having access to a MUD's file system is a great responsibility.  It\n"
    "cannot be given out to strangers who have not demonstrated their trust-\n"
    "worthiness.  After investing a fair amount of your time and energy in\n"
    "playing at DiscWorld, you are less likely to try to hurt it.  This is\n"
    "why we cannot give out instant creatorships unless we know you from\n"
    "elsewhere.  Please try to be understanding about our policy.\n\n";
  age   = - ( (int) player->query_time_on() );
  level = (int)player->query_level();
  if ( ( level >= 150 ) && ( age > 432000 ) ) {
    write("  You have achieved the *minimum* requirements necessary to apply "
          "for a\n"
          "creatorship at " + mud_name() + ".  You must now pass a review of the Lords "
          "to be\naccepted.\n"+ reasoning );
    return 1;
  }
  age_str = "";
  if ( age >  86400 )
    age_str += sprintf( "%d day" , age/86400 );
  if ( age > 172800 )
    age_str += "s";
  if ( age%86400 > 3600) {
    if ( age > 86400 )
      age_str += " and ";
    age_str += sprintf( "%d hour" , (age%86400)/3600 );
  }
  if ( age%86400 > 7200)  age_str += "s";
  write("  The *minimum* requirements to apply for a creatorship on " + mud_name() + " "
        "are\nto be level 150 in your guild and at least five "
        "days old .\nYou are level " + level + ", and your age is "+
        age_str + ".\n" + reasoning );
  return 0;
}
private void backup_vaults(string name, int restore) {
  string base = "/save/vaults/";
  string creator_dir = BACKUP_DIR + name + "/vaults/";
  string *vaults, *tmp;
  string file;
  if (!restore) {
    vaults = get_dir (base);
    mkdir (creator_dir);
    foreach (string vault in vaults) {
      file = base + vault + "/" + name + ".o";
      if (file_size (file) != -1) {
        cp (file, creator_dir + "/" + vault + ".o");
      }
    }
  }
  else {
    if (file_size (creator_dir) == -1) {
      return;
    }
    vaults = get_dir (base);
    foreach (string vault in vaults) {
      file = base + vault + "/" + name + ".o";
      if (file_size (file) != -1) {
        rm (file);
      }
    }
    vaults = get_dir (creator_dir);
    foreach (string vault in vaults) {
      tmp = explode (vault, ".");
      cp (creator_dir + vault, base  + tmp[0] + "/" + name  + ".o");
      rm (creator_dir + vault);
    }
    rmdir (creator_dir);
  }
}
private void backup_bank (string name, int restore) {
  string base = "/save/bank_accounts/";
  string bank_file = base + name[0..0] + "/" + name + ".o";
  string bank_dir = BACKUP_DIR + name + "/bank_account";
  string saved_file;
  if (!restore) {
    mkdir (bank_dir);
    if (file_size (bank_file) == -1) {
      return;
    }
    cp (bank_file, bank_dir);
  }
  else {
    saved_file = bank_dir + "/" + name + ".o";
    if (file_size (bank_dir) == -1) {
      return;
    }
    rm (bank_file);
    if (file_size (saved_file) == -1) {
      return;
    }
    cp (saved_file, bank_file);
    rm (saved_file);
    rmdir (bank_dir);
  }
}
private void backup_quest_library (string name, int restore) {
  string base = "/save/library/";
  string library_file = base + name[0..0] + "/" + name + ".o";
  string library_dir = BACKUP_DIR + name + "/quest_library";
  string saved_file;
  if (!restore) {
    mkdir (library_dir);
    if (file_size (library_file) == -1) {
      return;
    }
    cp (library_file, library_dir);
  }
  else {
    saved_file = library_dir + "/" + name + ".o";
    if (file_size (library_dir) == -1) {
      return;
    }
    rm (library_file);
    if (file_size (saved_file) == -1) {
      return;
    }
    cp (saved_file, library_file);
    rm (saved_file);
    rmdir (library_dir);
  }
}

==================================================
FILE: master/creator_file.c
==================================================

varargs mixed creator_file(string file, int author) {
  string *str;
  if (!file || !stringp(file)) return "NOONE";
  str = explode(file, "/") - ({ "" });
  if (sizeof(str)<2) return 0;
  switch (str[0]) {
   case "secure" :
     return get_root_uid();
   case "obj" :
     if (sizeof(str) > 2 && str[1] == "secure")
       return "ims";
   case "global" :
   case "std" :
   case "cmds" :
   case "room" :
     return get_bb_uid();
   case "net" :
     return "Network";
  case "www" :
    if (sizeof(str) > 2 && str[1] == "secure")
      return "Root";
    return "WWW";
   case "tmp" :
     if (str[1] != "mon-shad")
       return 0;
     return "monster";
   case "failsafe" :
     return "failsafe";
   case "d" :
     if (sizeof(str) < 3)
       return 0;
     if (!author || member_array(query_domains(), str) == -1)
       return capitalize(str[1]);
     return ("/d/"+str[1]+"/master")->author_file(str);
   case "w" :
     if (sizeof(str) < 3)
       if (str[1] == "common" || str[1] == "development" ||
           str[1] == "meeting")
         return "womble-frog";
       else
         return 0;
     return str[1];
  }
}
mixed author_file(mixed bing) {
  return creator_file(bing, 1);
}
mixed domain_file(mixed bing) {
  string str;
  str = creator_file(bing);
  if (!str) return str;
  if (str[0] >= 'A' && str[0] <= 'Z') return str;
  return "Creator";
}

==================================================
FILE: master/dest_env.c
==================================================

void destruct_environment_of(object ob) {
  object env;
  env = environment(ob);
  if (env) {
      string *a;
      a = (string *)env->query_dest_dir();
      if (catch(ob->move_player(a[0], a[1], "stumbles"))) {
          ob->move_player("void", "/room/void", "is sucked into the");
      }
  }
}

==================================================
FILE: master/directory_assignments.c
==================================================

#include <player_handler.h>
#include <error_handler.h>
private mapping _directory_assignments = ([ ]);
int query_leader(string name);
string* query_assigned_to_directory(string dir) {
   string *bits;
   string str;
   int i;
   bits = explode(dir, "/") - ({ "" });
   switch (bits[0]) {
   case "w" :
      if (sizeof(bits) > 1 && file_size("/d/" + bits[1]) == -2) {
         return ({ bits[1] });
      }
   case "d" :
      if (sizeof(bits) > 1 && file_size("/d/" + bits[1]) == -2) {
         return ("/d/" + bits[1] + "/master")->query_assigned_to_directory(bits);
      }
   default :
      i = sizeof(bits) - 1;
      do {
         str = "/" + implode(bits[0..<i], "/");
         i--;
      } while (i >= 0 && !_directory_assignments[str]);
      if (_directory_assignments[str]) {
         return _directory_assignments[str];
      }
      return ({ });
   }
}
int assign_people_to_directory(string dir, string* people) {
   string* new_people;
   string* dirs;
   if ( !sizeof( filter( previous_object( -1 ), (: interactive( $1 ) :) ) ) ) {
      user_event( "inform", this_player()->query_name() +
            " illegally attempted to call assign_person_to_directory( "+ dir +
            ", " + query_multiple_short(people) +
            " )", "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
            ": illegal attempt to call assign_person_to_directory( "+ dir +
            ", " + query_multiple_short(people) +
            " ).\n"+ back_trace() :));
      return 0;
   }
   new_people = filter(people, (: PLAYER_HANDLER->test_creator( $1 ) ||
                                  $1 == ERROR_ASSIGNED_NO_ONE :));
   if ( sizeof(new_people) == sizeof(people) &&
        query_leader( previous_object(-1) ) &&
        file_size(dir) == -2) {
      dirs = explode(dir, "/") - ({ "" });
      if (sizeof(dirs) > 1 && dirs[0] == "d" &&
          file_size("/d/" + dirs[1]) == -2) {
         return ("/d/" + dirs[1] + "/master")->assign_people_to_directory(dir, people);
      } else {
         if (!_directory_assignments) {
            _directory_assignments = ([ ]);
         }
         if (sizeof(people) == 1 && people[0] == ERROR_ASSIGNED_NO_ONE) {
            people = ({ });
         }
         if (sizeof(people)) {
            if (sizeof(_directory_assignments[dir])) {
               ERROR_HANDLER->do_update_directory_assignment(_directory_assignments[dir][0], people[0], dir, (: 1 :));
            } else {
               ERROR_HANDLER->do_update_directory_assignment(ERROR_ASSIGNED_NO_ONE, people[0], dir, (: 1 :));
            }
            _directory_assignments[dir] = people;
         } else {
            map_delete(_directory_assignments, dir);
         }
         save_object("/secure/master");
      }
      return 1;
   }
   debug_printf("Bad pumpkins. %O %O\n", new_people, people);
   return 0;
}
mapping query_directory_assignments() {
   if (!_directory_assignments) {
      return ([ ]);
   }
   return copy(_directory_assignments);
}

==================================================
FILE: master/ed_stuff.c
==================================================

int save_ed_setup(object wiz, int setup) {
  wiz->set_ed_setup(setup);
  return 1;
}
int retrieve_ed_setup(object wiz) {
  return (int)wiz->query_ed_setup();
}
string make_path_absolute(string str) {
  if (this_player()) {
    return (string)this_player()->get_path(str);
  }
}
string get_save_file_name(string file, object who) {
  string *file_ar;
  if (!objectp(who))
    return 0;
  file_ar = explode(file,"/") - ({ "" });
  file = file_ar[<1];
  write("File saved in \"/w/.dead_ed_files/" +
        who->query_name() + "-" + file + "\"\n");
  return "/w/.dead_ed_files/" + who->query_name() + "-" + file;
}

==================================================
FILE: master/file_exists.c
==================================================

int file_exists( string path ) {
  if ( file_size( path ) < 0 )
    return 0;
  return 1;
}

==================================================
FILE: master/logging.c
==================================================

#include <type.h>
#include <runtime_config.h>
string get_wiz_name(mixed file) {
  if (!previous_object())
    return "root";
  if (objectp(file))
    file = file_name(file);
  file = explode(file, "/") - ({ "" });
  if (file[0] == "w") {
    if (file_size("/w/" + file[1]) != -2) {
      return "root";
    } else {
      return file[1];
    }
  }
  if (file[0] == "d") {
    return "dom";
  }
  return "root";
}
string get_dom_name(mixed file) {
  if (objectp(file))
    file = file_name(file);
  file = explode(file, "/") - ({ "" });
  if (file[0] == "d" && sizeof(file) >= 2)
    return file[1];
}
string get_prg_name(mixed file) {
  if (objectp(file))
    file = file_name(file);
  file = explode(file, "/") - ({ "" });
  if (file[0] == "w")
    return file[1];
  return "root";
}
int different(string fn, string pr) {
  sscanf(fn, "%s#%*d", fn);
  fn += ".c";
  return (fn != pr) && (fn != ("/" + pr));
}
string trace_line(object obj, string prog, string file, int line) {
  string ret;
  string objfn = obj ? file_name(obj) : "<none>";
  ret = objfn;
  if (different(objfn, prog))
    ret += sprintf(" (%s)", prog);
  if (file != prog)
    ret += sprintf(" in %s:%d\n", file, line);
  else
    ret += sprintf(" at line %d\n", line);
  return ret;
}
string printable_arg(mixed arg) {
  switch (typeof(arg)) {
  case ARRAY:
  case MAPPING:
  case CLASS:
  case STRING:
    if((strlen(typeof(arg)) + strlen(save_variable(arg)) + 4) <  __MAX_STRING_LENGTH__)
      return "(" + typeof(arg) + ") " + save_variable(arg);
    else
      return sprintf("(%s) <too large>", typeof(arg));
  default:
    return sprintf("(%s) %O", typeof(arg), arg);
  }
}
string trace_args(mixed *args) {
  string *tmp;
  if (!sizeof(args))
    return " (void)";
  tmp = map(args, (: printable_arg($1) :));
  return "\n(\n    "+implode(tmp, ",\n    ")+"\n)";
}
string trace_locals(mixed *args) {
  string *tmp;
  if (!sizeof(args))
    return " none.";
  tmp = map(args, (: printable_arg($1) :));
  return "\n    " + implode(tmp, ",\n    ");
}
varargs string standard_trace(mapping mp, int flag) {
  string ret;
  mapping *trace;
  int i, n;
  ret = mp["error"] + "Object: " +
    trace_line(mp["object"], mp["program"], mp["file"], mp["line"]);
  ret += "Arguments were:" + trace_args(mp["arguments"]) +
    "\nLocals were:" + trace_locals(mp["locals"]) + "\n";
  ret += "\n\n";
  trace = mp["trace"];
  n = sizeof(trace);
  for (i=0; i<n; i++) {
    ret += sprintf("(%d) '%s' in %s", i + 1, trace[i]["function"],
                   trace_line(trace[i]["object"], trace[i]["program"],
                              trace[i]["file"], trace[i]["line"]));
    if (!flag && (strlen(ret) + strlen(trace_args(trace[i]["arguments"])) +
                  strlen(trace_locals(trace[i]["locals"])) +
                  20) < __MAX_STRING_LENGTH__) {
      ret += "Arguments were:" + trace_args(trace[i]["arguments"]) +
        "\nLocals were:" + trace_locals(trace[i]["locals"]) + "\n";
    }
  }
  return ret;
}
#define MAX_SIZE 50000
void error_handler(mapping error, int caught) {
  string file, ret, path, name, obname;
  object ob;
  ret = "--------------------\n"+ctime(time()) + ":  " + standard_trace(error);
  if (caught) {
    file = "catch";
  } else {
    file = "runtime";
  }
  sscanf(error["error"], "%*sError in loading object '%s'", obname);
  if (!obname) {
    ob = error["object"];
    if (!ob) {
      obname = error["program"];
    } else {
      obname = file_name(ob);
    }
  }
  name = get_wiz_name(obname);
  switch (name) {
  case "root":
    path = "/log/" + file;
    break;
  case "dom":
    if (obname[0..17] == "/d/am/short/flats/") {
       path = "/d/am/short/flats/" + file;
    } else {
       switch (obname[0..9]) {
       case "/d/am/elm/" :
       case "/d/am/lame" :
          path = "/d/am/short/flats/" + file;
          break;
       default :
          break;
       }
    }
    path = "/d/"+get_dom_name(obname)+"/"+file;
    break;
  default:
    path = "/w/"+name+"/"+file;
    tell_creator(name, "A runtime error occured in the file %O"
                 ", logged to %s.\n", obname, path);
  }
  if (member_array("init_dynamic_arg", call_stack(2)) != -1 ||
      member_array("query_dynamic_auto_load", call_stack(2)) != -1) {
    path = "/d/admin/log/auto_" + file;
  }
  if (file_size(path) > MAX_SIZE) {
    unguarded((: rm, path+".old" :));
    unguarded((: rename, path, path+".old" :));
  }
  unguarded((: write_file, path, ret :));
  if (this_player(1) && find_object("/secure/simul_efun")) {
    this_player(1)->set_last_error(error);
    if (!caught) {
      if (this_player(1)->query_creator()) {
        tell_object(this_player(1), error["error"]+
                    "Object: "+trace_line(error["object"], error["program"],
                                          error["file"], error["line"])+
                    "\nTrace written to "+ path +"\n");
      } else {
        tell_object(this_player(1),
                    "A runtime error occurred.\nPlease use "
                    "the \"bug\" command to report it, "
                    "describing what you tried to do when it happened.\n");
      }
    }
  }
}
void log_error(string file, string message) {
  string name, efile, epath, colour;
  if (sscanf(message, "%*sWarning:%*s") == 2) {
    if(sscanf(message, "%*sTrying to put%*s") == 2) {
      efile = "type-error";
      colour = "%^RED%^";
    } else {
      efile = "warnings";
      colour = "%^CYAN%^";
    }
  } else {
    efile = "error-log";
    colour = "%^RED%^";
  }
  if (this_player(1) && this_player(1)->query_creator()) {
    tell_object(this_player(1), colour+message+"%^RESET%^");
  }
  name = get_wiz_name(file);
  switch (name) {
  case "root":
    epath = "/log/" + efile;
    break;
  case "dom":
    epath = "/d/"+get_dom_name(file)+"/"+efile;
    break;
  default:
    epath = "/w/"+name+"/"+efile;
    break;
  }
  if (file_size(epath) > MAX_SIZE) {
    unguarded((: rm, epath+".old" :));
    unguarded((: rename, epath, epath+".old" :));
  }
  unguarded((: write_file, epath, message :));
}
void do_log(string person, string text) {
  if (file_name(previous_object()) != "/std/smart_log")
    return;
  if (file_size("/w/"+person) != -2)
    return;
  unguarded((: rm, "/w/"+person+"/"+PLAYER_ERROR_LOG :));
  unguarded((: write_file, "/w/"+person+"/"+PLAYER_ERROR_LOG, text :));
}
void forward_error(string file, string text) {
  if (!((file_name(previous_object()) == "/secure/cmds/creator/errors") ||
        (file_name(previous_object()) == "/www/secure/errors")))
    return;
  unguarded((: write_file, file, text :));
}

==================================================
FILE: master/parse_command.c
==================================================

string *parse_command_id_list() {
  return ({ "one", "thing" });
}
string *parse_command_plural_id_list() {
  return ({ "ones", "things", "them" });
}
string *parse_command_adjectiv_id_list() {
  return ({ "the", "a", "an" });
}
string *parse_command_prepos_list() {
  return ({ "in", "on", "at", "along", "upon", "by", "under", "behind",
            "with",
            "beside", "into", "onto", "inside", "within", "from" });
}
string parse_command_all_word() {
  return "all";
}
string *query_word_list(string word) {
  switch (word) {
    case "preposition" :
      return parse_command_prepos_list();
    default :
      return 0;
  }
}

==================================================
FILE: master/permission.c
==================================================

int add_senior( string word ) {
   if ( !sizeof( filter( previous_object( -1 ), (: interactive( $1 ) :) ) ) ) {
      user_event( "inform", this_player()->query_name() +
            " illegally attempted to call add_senior( "+ word +
            " )", "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
            ": illegal attempt to call add_senior( "+ word +
            " ).\n"+ back_trace() :));
      return 0;
   }
   if ( PLAYER_HANDLER->test_user( word ) &&
        query_leader( previous_object(-1) ) ) {
      write_file( "/log/PROMOTIONS", ctime( time() ) +": "+ word +
            " was promoted to Senior by "+ geteuid( this_interactive() ) +
            "\n" );
      if ( ( positions[ word ] != TRUSTEE ) &&
            ( positions[ word ] != DIRECTOR ) )
         positions[ word ] = SENIOR;
      save_object( "/secure/master" );
      return 1;
   }
   return 0;
}
int remove_senior(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_senior("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call remove_senior("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (query_leader(previous_object(-1)) &&
      positions[str] == SENIOR) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Senior by "+geteuid(this_interactive())+
               "\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int add_director(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call add_director("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+
               ": Illegal attempt to call add_director("+str+
               ").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (PLAYER_HANDLER->test_user(str) &&
      query_trustee(previous_object(-1))) {
    write_file("/log/PROMOTIONS", ctime(time())+": "+str+
               " was promoted to Leader by "+ geteuid(this_interactive())+
               "\n");
    if (positions[str] != TRUSTEE)
      positions[str] = DIRECTOR;
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int remove_director(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_director("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+
               ": Illegal attempt to call remove_director("+str+
               ").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (query_trustee(previous_object(-1)) &&
      positions[str] == DIRECTOR) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Leader by "+geteuid(this_interactive())+
               "\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int add_trustee(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call add_tristee("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_trustee("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (PLAYER_HANDLER->test_user(str) &&
      query_trustee(previous_object(-1))) {
    write_file("/log/PROMOTIONS", ctime(time())+": "+str+
               " was promoted to Administrator by "+
               geteuid(this_interactive())+"\n");
    positions[str] = TRUSTEE;
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int remove_trustee(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_trustee("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call remove_trustee("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (query_trustee(previous_object(-1)) &&
      positions[str] == TRUSTEE) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Administrator by "+
               geteuid(this_interactive())+"\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
varargs mixed creator_file(string path, int author);
nomask protected int check_domain(mixed ob, string func, string path, int mask) {
  object master_ob;
  string master, domain, *bits = explode(path, "/") - ({ "", "." });
  int ret;
  if (sizeof(bits) < 2)
    return (mask & READ_MASK);
  domain = bits[1];
  if (objectp(ob))
    ob = geteuid(ob);
  if (ob == creator_file(path))
    return 1;
  master = "/d/" + domain + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master]) {
    return (mask & READ_MASK);
  }
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master))) {
    checked_master[master] = 1;
  }
  if (master_ob) {
    ret = master_ob->check_permission(ob, bits, mask);
    if (ret == -1) {
      return 0;
    }
    if ((sizeof(bits) > 2) && (bits[2] != "master.c") &&
        (bits[2] != "master.o") && (bits[2] != "master") && query_senior(ob)) {
      return 1;
    }
    return (ret || (mask & READ_MASK?master_ob->valid_read(bits, ob, func):
            master_ob->valid_write(bits, ob, func)));
  }
  return (mask & READ_MASK);
}
nomask protected int check_creator(mixed ob, string func, string path, int mask) {
  string master, creator, *bits = explode(path, "/") - ({ "", "." });
  object master_ob;
  if (sizeof(bits) < 2)
    return (mask & READ_MASK);
  creator = bits[1];
  if (objectp(ob))
    ob = geteuid(ob);
  if (mask & GRANT_MASK) {
    if (ob == creator) {
      return 1;
    } else {
      return 0;
    }
  }
  if ((mask & READ_MASK) && sizeof(bits) >= 3 && bits[2] == "mbox" &&
      file_size(sprintf("/w/%s/mbox", bits[1])) != -2)
    return ob == bits[1];
  if ((mask & READ_MASK) || (ob == creator_file(path)))
    return 1;
  master = "/w/" + creator + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master])
    return 0;
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master)))
    checked_master[master] = 1;
  if (master_ob)
    return (master_ob->check_permission(ob, bits, mask) ||
            master_ob->valid_write(bits, ob, func));
  return 0;
}
private int check_permission(mixed ob, string func, string path,
                             mapping perms, int mask) {
  string tmp, euid;
  int i;
  mixed *stack;
  if (perms && sizeof(perms) && !undefinedp(perms["all"]) &&
      (perms["all"] & mask))
    return 1;
  if(path[0..21] == "/save/boards/lordboard" &&
     base_name(ob) != "/obj/handlers/board_handler") {
    catch(log_file("/d/admin/log/LORDBOARD",
                   "%s: ob %s player %s prev %s\n",
                   ctime(time())[4..18], base_name(ob),
                   this_player()->query_name(),
                   base_name(previous_object())));
  }
  if (unguarded_ob == ob) {
    if ((tmp = base_name(ob)) == "/global/player" ||
        tmp == "/global/playtester" ||
        tmp == "/global/creator" ||
        tmp == "/global/lord") {
      if((path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name())
         ||
         (path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o") ||
         (path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o.gz") ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()) ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o") ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o.gz"))
        return 1;
      else i = sizeof(stack = ({ ob }) + previous_object(-1));
    } else if (tmp == path)
      return 1;
    else
      i = sizeof(stack = ({ ob }));
  } else if (unguarded_ob && base_name(ob) == "/secure/simul_efun") {
    if (unguarded_ob == previous_object(1))
      i = sizeof(stack = ({ previous_object(1) }));
    else
      i = sizeof(stack = ({ ob }) + previous_object(-1));
  } else if (unguarded_ob) {
    stack = previous_object(-1);
    for (i = 0; i < sizeof(stack) && stack[i] != unguarded_ob; i++)
      ;
    i = sizeof(stack = ({ ob }) + stack[0..i]);
  } else
    i = sizeof(stack = ({ ob}) + previous_object(-1));
  while (i--) {
    if (!stack[i])
      return 0;
    if (stack[i] == this_object())
      continue;
    if (objectp(stack[i])) {
      if (file_name(stack[i]) == "/secure/simul_efun")
        continue;
      if (!(euid = geteuid(stack[i])))
        return 0;
    } else
      euid = stack[i];
    if (euid == get_root_uid())
      continue;
    if (query_director(euid) && (mask & READ_MASK))
      continue;
    if (query_trustee(euid))
      continue;
    if (perms) {
      if (!undefinedp(perms[euid]) && (perms[euid] & mask))
        continue;
      if (!undefinedp(perms["all"]) && (perms["all"] & LOCK_MASK))
        return 0;
    }
    if (path[0..2] == "/w/") {
      if (check_creator(stack[i], func, path, mask))
        continue;
    } else if(path[0..2] == "/d/") {
      if (check_domain(stack[i], func, path, mask))
        continue;
    } else {
      return (mask & READ_MASK);
    }
    return 0;
  }
  return 1;
}
mixed permission_match_path(mapping m, string path) {
  string p, *bits;
  int i, size;
  mapping found = ([]);
  if (!sizeof(m)) {
    return 0;
  }
  bits = explode(path, "/") - ({ "", "." });
  p = "";
  if (!undefinedp(m["/"])) {
    found += m["/"];
  }
  size = sizeof(bits);
  for (i = 0; i <= size; i++) {
    if (!undefinedp(m[p])) {
      mapping old = copy(found);
      if (sizeof((found += m[p])) != (sizeof(old) + sizeof(m[p]))) {
        string euid;
        int mask;
        found = old;
        foreach (euid, mask in m[p]) {
          if (!undefinedp(found[euid]))
            found[euid] |= mask;
          else
            found[euid] = mask;
        }
      }
    }
    if (i < size)
      p = p + "/" + bits[i];
  }
  if (sizeof(found)) {
    return found;
  } else {
    return 0;
  }
}
int valid_grant(object euid, string path, int mask) {
  string domain, master, director;
  int result;
  object master_ob;
  if (path[0] != '/')
    path = "/" + path;
  result = check_permission(euid, 0, path,
                            permission_match_path(permissions, path),
                            GRANT_MASK);
  if (!result || (mask & (READ_MASK|WRITE_MASK)))
    return result;
  if (sscanf(path, "/d/%s/%*s", domain) != 2 &&
      sscanf(path, "/d/%s", domain) != 1)
    return 0;
  master = "/d/" + domain + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master])
    return 0;
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master))) {
    checked_master[master] = 1;
    return 0;
  }
  director = master->query_director();
  if(!director)
    director = master->query_lord();
  return (query_director(previous_object(-1) + ({ euid })) &&
          (member_array(director, map(previous_object(-1),
                                  (: geteuid($1) :))) != -1));
}
mapping query_permissions() {
  string *doms, master;
  int i;
  mapping blue, tmp;
  object master_ob;
  doms = get_dir("/d/");
  doms -= ({ "lost+found" });
  blue = ([ ]);
  for (i=0;i<sizeof(doms);i++) {
    master = "/d/"+doms[i]+"/master";
    if (!(master_ob = find_object(master)) && checked_master[master])
      continue;
    if (!master_ob && !checked_master[master] &&
        catch(master_ob = load_object(master))) {
      checked_master[master] = 1;
      continue;
    }
    tmp = (mapping)master_ob->query_access();
    if (mapp(tmp))
      blue += tmp;
  }
  return permissions + blue;
}
protected int add_permission(string euid, string path, int mask) {
  string *bits, master;
  object master_ob;
  if (path[0..2] == "/d/") {
    bits = explode(path, "/");
    if (sizeof(bits) >= 2) {
      master = "/d/"+bits[1]+"/master";
      if (!(master_ob = find_object(master)) && checked_master[master])
        return 0;
      if (!master_ob && !checked_master[master] &&
          catch(master_ob = load_object(master))) {
        checked_master[master] = 1;
        return notify_fail("Failed to load master file.\n");
      }
      if ((mask & LOCK_MASK) &&
          !sizeof(filter(previous_object(-1),
                      (: $(master_ob)->query_lord() == geteuid($1) :))))
        return notify_fail("You are not the leader of $C$" + bits[1] +
                           ".\n");
      return (int)master_ob->add_permission(euid, path, mask);
    }
  }
  if (!permissions[path]) {
    permissions[path] = ([ euid : mask ]);
  } else {
    permissions[path][euid] |= mask;
  }
  unguarded((: save_object, "/secure/master" :));
  return 1;
}
int add_read_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_interactive()->query_cap_name()+
                " illegally attempted to call add_read_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call add_read_permission("+euid+", "+path+").\nBacktrace: "+
               back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, READ_MASK)) {
    write("Added read permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int add_write_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call add_write_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_write_permission("+euid+", "+path+").\n"
                 "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, WRITE_MASK)) {
    write("Added write permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int add_grant_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call add_grant_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_grant_permission("+euid+", "+path+").\n"
                 "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, GRANT_MASK)) {
    write("Added grant permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int lock_path(string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event("inform", this_player(1)->query_cap_name()+
               " illegally attempted to call lock_path("+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call lock_path("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission("all", path, LOCK_MASK)) {
    write("Restricted access for all to "+path+".\n");
    return 1;
  }
  return 0;
}
protected int remove_permission(string euid, string path, int mask) {
  string *bits, master;
  object master_ob;
  if (path[0..2] == "/d/") {
    bits = explode(path, "/");
    if (sizeof(bits) >= 2) {
      master = "/d/"+bits[1]+"/master";
      if (!(master_ob = find_object(master)) && checked_master[master])
        return 0;
      if (!master_ob && !checked_master[master] &&
          catch(master_ob = load_object(master))) {
        checked_master[master] = 1;
        return notify_fail("Failed to load master file.\n");
      }
      if ((mask & LOCK_MASK) &&
          !sizeof(filter(previous_object(-1),
                         (: $(master_ob)->query_lord() == geteuid($1) :))))
        return notify_fail("You are not the lord of $C$" + bits[1] + ".\n");
      return (int)master_ob->remove_permission(euid, path, mask);
    }
  }
  if (!permissions[path] || !permissions[path][euid]) {
    notify_fail("The euid \""+euid+"\" does not have any permissions to "
                "remove in "+path+".\n");
    return 0;
  }
  permissions[path][euid] &= ~mask;
  if (!permissions[path][euid]) {
    if (m_sizeof(permissions[path]) == 1) {
      map_delete(permissions, path);
    } else {
      map_delete(permissions[path], euid);
    }
  }
  unguarded((: save_object, "/secure/master" :));
  return 1;
}
int remove_read_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
      base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_read_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_read_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, READ_MASK)) {
    write("Removed read permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int remove_write_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_write_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_write_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, WRITE_MASK)) {
    write("Removed write permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int remove_grant_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_grant_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_grant_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, GRANT_MASK)) {
    write("Removed grant permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int unlock_path(string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event("inform", this_player(1)->query_cap_name()+
               " illegally attempted to call unlock_path("+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call unlock_path("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission("all", path, LOCK_MASK)) {
    write("Removed access restrictions for all to "+path+".\n");
    return 1;
  }
  return 0;
}

==================================================
FILE: master/preload.c
==================================================

protected string *load_file(string fname) {
  string *bits;
  string str;
  str = read_file("/secure/config/"+fname);
  if (!str)
    return ({ });
  bits = explode(str, "\n");
  bits = filter(bits, (: $1[0] != '#' :));
  return bits;
}
string *epilog() {
  return load_file("preload");
}
void preload(string file) {
  mixed e;
  printf("Preloading: "+file+".\n");
  if ((e = catch(load_object(file)))) {
    printf("            "+e+"\n");
  }
}

==================================================
FILE: master/query_pl_level.c
==================================================

int query_player_level( string what ) {
   if ( !this_player() )
      return 0;
   switch ( what ) {
      case "error messages" :
         return 1;
      case "trace" :
      case "wizard" :
         return (int)this_player()->query_creator();
   }
}

==================================================
FILE: master/simul_efun.c
==================================================

string get_simul_efun() {
  string fname;
  fname = "/secure/simul_efun";
  if (catch(call_other(fname, "??"))) {
    write("Failed to load " + fname + "\n");
    shutdown();
    return 0;
  }
  return fname;
}

==================================================
FILE: master/snoop.c
==================================================

int valid_snoop(object snooper, object snoopee, object pobj) {
  string verb;
  verb = this_player()->query_current_verb();
  if (snooper == snoopee) {
    tell_object(snooper, "You can't snoop yourself.\n");
    return 0;
  }
  if (snoopee && query_snoop(snoopee)) {
    tell_object(snooper,
                snoopee->query_cap_name()+" is already being snooped.\n");
    return 0;
  }
  if (snooper->query_snoopee()) {
    user_event( snooper->query_cap_name()+" stops " + verb + "ing "+
                snooper->query_snoopee()->query_name(), "snoop");
    if (!snooper->query_property("quiet snoop")) {
      tell_object((object)snooper->query_snoopee(),
                  snooper->query_cap_name()+" stops snooping you.\n");
    } else {
      snooper->remove_property("quiet snoop");
    }
    snooper->set_snoopee(0);
  }
  if (!snoopee) {
    return 1;
  }
  if (!snooper->query_creator())
    return 0;
  if (pobj == this_object()) {
    user_event( snooper->query_cap_name()+" starts qsnooping "+
                snoopee->query_name(), "snoop");
    return 1;
  }
  if (verb == "qsnoop" && query_lord(geteuid(snooper)) &&
      !query_lord(geteuid(snoopee))) {
    tell_object(snooper, "You are quiet snooping "+
                snoopee->query_cap_name()+"\n");
    snooper->add_property("quiet snoop", 1);
  } else {
    tell_object(snoopee, "You are being snooped by "+
                snooper->query_cap_name()+".\n");
  }
  unguarded( (: write_file("/d/admin/log/SNOOP", ctime(time()) + " " +
           (string)$(snooper)->query_cap_name() + " " +
           $(verb) + "s " + (string)$(snoopee)->query_cap_name() + ".\n") :) );
  snooper->set_snoopee(snoopee);
  if (verb == "qsnoop") {
    tell_object(snooper, "Please share with us the reason why you are " +
                "quiet snooping?\n: ");
    input_to("snoop_reason");
    snoop_list[snooper] = snoopee;
    return 0;
  }
  user_event( snooper->query_cap_name()+" starts " + verb + "ing "+
              snoopee->query_name(), "snoop");
  return 1;
}
void snoop_reason(string str) {
  object snooper;
  snooper = this_player();
  if (this_player(1) != this_player()) {
    write("Can't force people...\n");
    return ;
  }
  if (!high_programmer(geteuid(this_player()))) {
    write("Not a high programmer.\n");
    return ;
  }
  if (!snoop_list[snooper]) {
    write("The snoopee has just logged out.\n");
    return ;
  }
  if(!str) {
    write("Snoop canceled.\n");
    unguarded( (: write_file("/d/admin/log/SNOOP", "  Chickened out.\n") :) );
    return;
  }
  unguarded( (: write_file("/d/admin/log/SNOOP", "  Reason: " + $(str) +
                           "\n") :) );
  if (snoop(snooper, snoop_list[snooper]))
    write("Snoop suceeded,\n");
  else
    write("Snoop failed.\n");
}

==================================================
FILE: master/valid_binary.c
==================================================

int valid_save_binary(string fname) {
  string *bits;
  bits = explode(fname, "/");
  switch (bits[0]) {
    case "global" :
    case "std" :
    case "secure" :
    case "cmds" :
    case "d" :
    case "www" :
      return 1;
    case "obj" :
        return 1;
  }
  return 0;
}

==================================================
FILE: master/valid_bind.c
==================================================

private nosave object _simul_efun;
int valid_bind(object binder, object old_owner, object new_owner) {
   string *womble;
   string fname;
   if(!objectp(_simul_efun)) {
     _simul_efun = find_object("/secure/simul_efun");
   }
   if(binder == _simul_efun) {
      return 1;
   }
   if(file_name(new_owner)[0..7] == "/secure/") {
      return 0;
   }
   if(interactive(new_owner)) {
      return 0;
   }
   womble = explode(file_name(old_owner), "/");
   if (sizeof(womble) < 1) {
      return 0;
   }
   fname = womble[<1];
   if (fname[0] != '.') {
      return 0;
   }
   return old_owner == binder;
}

==================================================
FILE: master/valid_copy.c
==================================================

int valid_copy(string path, mixed euid, string func) {
  object master_ob;
  string *bits = explode(path, "/") - ({ "", "." });
  mapping perms;
  perms = permission_match_path(permissions, path);
  if(sizeof(bits) < 2 || bits[0] == "open" || bits[0] == "doc" ||
     bits[0] == "log" || bits[0] == "mudlib" || bits[0] == "w")
    return check_permission(euid, func, path, perms, READ_MASK);
  master_ob = find_object("/d/" + bits[1] + "/master");
  if((master_ob && master_ob->copy_with_read(path, euid, func)) ||
     (!master_ob && master()->query_senior(euid)))
    return check_permission(euid, func, path, perms, READ_MASK);
  else
    return check_permission(euid, func, path, perms, WRITE_MASK);
}

==================================================
FILE: master/valid_database.c
==================================================

mixed valid_database(object ob, string action, mixed *info){
  string obname = base_name(ob);
  switch (obname){
  case "/obj/handlers/clusters":
  case "/obj/handlers/map":
  case "/cmds/creator/osql":
  case "/cmds/errors_base":
    return -1;
  default:
    return 0;
  }
}

==================================================
FILE: master/valid_exec.c
==================================================

int valid_exec(string name) {
  if (name == "secure/login.c")
    return 1;
  if(name == "secure/nlogin.c")
    return 1;
  return 0;
}

==================================================
FILE: master/valid_hide.c
==================================================

int valid_hide(object ob) {
  return query_lord(geteuid(ob));
}

==================================================
FILE: master/valid_ident.c
==================================================

int valid_ident(string euid) {
  return high_programmer(euid);
}

==================================================
FILE: master/valid_link.c
==================================================

int valid_link(string from, string to) {
  return 0;
}

==================================================
FILE: master/valid_override.c
==================================================

int valid_override(string file, string func, string filename) {
  string *bing;
  bing = explode(file, "/") - ({ "", "." });
  switch (bing[0]) {
    case "secure" :
      return 1;
    case "std" :
    case "obj" :
    case "simul_efun" :
    case "global" :
    case "cmds" :
      return (func != "snoop");
    default :
      return 0;
  }
}

==================================================
FILE: master/valid_read.c
==================================================

#define FILE_STATS 1
private nosave mapping read_stats;
int valid_read(string path, mixed euid, string func) {
  mapping perms;
  string prev;
  if (euid == master())
    return 1;
  if ((func == "file_size") || (func == "stat"))
    return 1;
  if (path[0] != '/')
    path = "/" + path;
  if (path[<1] == 'c' && base_name(euid)[0..2] == "/w/")
    return 0;
#ifdef FILE_STATS
  if(!read_stats)
    read_stats = ([ ]);
  if(previous_object()) {
    prev = base_name(previous_object());
    if(!read_stats[prev])
      read_stats[prev] = ([ path : 1 ]);
    else
      read_stats[prev][path] += 1;
  }
#endif
  perms = (mapping)permission_match_path(permissions, path);
  return check_permission(euid, func, path, perms, READ_MASK);
}
mapping query_read_stats() { return copy(read_stats); }

==================================================
FILE: master/valid_seteuid.c
==================================================

int valid_euid(string str) {
  string *domains;
  switch (str) {
  case "all":
  case "Handlers":
  case "Mailer":
  case "Network":
  case "Room":
  case "Spell":
  case "WWW":
    return 1;
  default:
    domains = unguarded((: get_dir, "/d/" :));
    domains -= ({ "lost+found" });
    domains = map(domains, (: capitalize($1) :));
    if (member_array(str, domains) != -1) {
      return 1;
    }
    return 0;
  }
}
int valid_seteuid(object ob, string euid) {
  string crea;
  if (euid == "tmp") {
      return 1;
  }
   if ( !objectp( ob ) )
      return 0;
  crea = creator_file(file_name(ob));
  if (crea == "Root" || crea == "Room") {
      return 1;
  }
  return (euid == crea) || !euid;
}

==================================================
FILE: master/valid_shadow.c
==================================================

int valid_shadow(object ob) {
  if (previous_object() == ob)
    return 0;
  return (!ob->query_prevent_shadow(previous_object()) &&
          !sscanf(file_name(ob), "/secure/%*s") &&
          !sscanf(file_name(ob), "/obj/handlers/%*s") &&
          !function_exists("heart_beat" , previous_object(), 1) &&
          !sscanf(file_name(ob), "/cmds/%*s"));
}

==================================================
FILE: master/valid_socket.c
==================================================

int valid_socket(object ob, string func, mixed *info) {
  string fname;
  fname = file_name(ob);
  if (func != "external") {
    switch (explode(fname, "/")[0]) {
      case "net" :
      case "secure" :
        return 1;
    }
  } else {
    if (fname[0..11] == "/secure/cmds" ||
        fname[0..19] == "/secure/rcs_handler")
      return 1;
  }
  return 0;
}

==================================================
FILE: master/valid_to_c.c
==================================================

int valid_compile_to_c() {
  if (previous_object() == this_object())
    return 1;
  if (previous_object() != find_object("/secure/cmds/creator/compile"))
    return 0;
  if (!interactive(previous_object(1)))
    return 0;
  if (!this_object()->query_lord(previous_object(-1)))
    return 0;
  return 1;
}

==================================================
FILE: master/valid_write.c
==================================================

#define WRITE_FILE_STATS 1
private nosave mapping write_stats;
int valid_write(string path, mixed euid, string func) {
  mapping perms;
  string tmp;
  string *bits, rcspath;
  string prev;
  if (path && (path[<2..] == ",v")) {
    return 0;
  }
  if (func == "remove_file" && path[0..13] == "/save/players/") {
     if (objectp(euid)) {
        log_file("/d/admin/log/DELETE_PLAYER", "Deleting " +
                path + " by " + file_name(previous_object()) +
                "->" + call_stack(2)[0] + "\n");
     } else {
        log_file("/d/admin/log/DELETE_PLAYER", "Deleting " +
                path + " by " + euid + " (" + file_name(previous_object()) +
                "->" + call_stack(2)[0] + ")\n");
     }
  }
  if (euid == master())
    return 1;
  if (path[0] != '/')
    path = "/" + path;
#ifdef WRITE_FILE_STATS
  if(!write_stats)
    write_stats = ([ ]);
  if(previous_object()) {
    prev = base_name(previous_object());
    if(!write_stats[prev])
      write_stats[prev] = ([ path : 1 ]);
    else
      write_stats[prev][path] += 1;
  }
#endif
  bits = explode(path, "/");
  if(euid &&
     (file_size(path) > 0) &&
     (!previous_object() ||
        file_name(previous_object()) != "/secure/cmds/creator/rcso_ut") &&
     (!objectp(euid) || file_name(euid) != "/secure/ftpd") &&
     path[<2..] != ".o" &&
     (bits[0] != "log" && bits[0] != "save" && bits[0] != "players") ) {
    if(sizeof(bits) > 2) {
      rcspath = "/" + implode(bits[0..sizeof(bits)-2], "/") + "/RCS/";
    } else if(sizeof(bits) == 2) {
      rcspath = "/" + bits[0] + "/RCS/";
    } else
      rcspath = "/";
    rcspath += bits[sizeof(bits)-1] + ",v";
    if(file_size(rcspath) > 0) {
#ifdef DEBUG
      if(stringp(euid))
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%s](string)\n", rcspath, euid ));
      else if(objectp(euid))
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%s](object)\n", rcspath, file_name(euid )));
      else
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%O](unknown)\n", rcspath, euid ));
#endif
      tmp = read_file(rcspath, 4, 1);
      if(tmp == "locks\n") {
        string lockname ;
        tmp = read_file(rcspath, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        if((objectp(euid) && euid->query_name() != lockname) ||
           (stringp(euid) && euid != lockname)) {
          int i, ok;
          object *stack;
          stack = previous_object(-1);
          i = sizeof(stack);
          while(--i) {
            if(geteuid(stack[i]) == lockname) {
              ok = 1;
            }
          }
          if(!ok) {
#ifdef DEBUG
          if(objectp(euid))
            tell_object(find_player("ceres"), sprintf("Write denied to %O or %O Locked by %s\n", euid, previous_object(-1), lockname));
          else
            tell_object(find_player("ceres"), sprintf("Write denied to %s or %O Locked by %s\n", euid, previous_object(-1), lockname));
#endif
          return 0;
          } else {
#ifdef DEBUG
            tell_object(find_player("ceres"), "Write allowed to "+geteuid(stack[i])+" Locked by:"+lockname +" on file "+path+"\n");
#endif
          }
        } else {
#ifdef DEBUG
          if(objectp(euid))
            tell_object(find_player("ceres"), sprintf("Write allowed by %O Locked by %s\n", euid, lockname));
          else
            tell_object(find_player("ceres"), sprintf("Write allowed by %s Locked by %s\n", euid, lockname));
#endif
        }
      } else {
#ifdef DEBUG
          tell_object(find_player("ceres"), "No locks found\n");
#endif
          return 0;
      }
    }
  }
  perms = permission_match_path(permissions, path);
  return check_permission(euid, func, path, perms, WRITE_MASK);
}
mapping query_write_stats() { return copy(write_stats); }
void reset() {
  write_stats = ([ ]);
  read_stats = ([ ]);
}

==================================================
FILE: master/virtual_objects.c
==================================================

#include "/include/virtual.h"
object compile_object(string path) {
   string* bits;
   if (file_size(path) > 0) {
      return (object)SERVER->create_virtual_object(path);
   }
   bits = explode(path, ":");
   if (sizeof(bits) > 1) {
      if (file_size(bits[0]) > 0 ||
          file_size(bits[0] + ".c") > 0) {
         return bits[0]->create_virtual_object(bits[1..] ...);
      }
   }
}
