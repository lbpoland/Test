# Total Tokens: 15387
# Total Files Merged: 18
# Total Characters: 51333

ercial.c
==================================================

inherit "/obj/monster";
#include <money.h>
private object _sell_to;
private string* _furniture;
private string _commercial_type;
int do_list(int force);
void setup() {
   set_name("spulluf");
   set_gender(1 + random(2) );
   set_long("A nice happy person with a nice smile.\n");
   add_property("demon", 1);
   set_race( "human" );
   set_level( 1 );
   add_help_file("spulluf");
   add_respond_to_with(({ "@say", "browse" }), "#do_browse");
   add_respond_to_with(({ "@say", "buy" }), "#do_buy");
   _furniture = ({
        "/obj/furnitures/commercial/smithy",
        "/obj/furnitures/commercial/money_changer",
        "/obj/furnitures/commercial/blackjack",
        "/obj/furnitures/commercial/small_shop",
        "/obj/furnitures/commercial/pickler",
        "/obj/furnitures/commercial/blackboard",
        "/obj/furnitures/commercial/newspaper_box",
        "/obj/furnitures/commercial/newspaper_archive_box",
        "/obj/furnitures/commercial/bank_master",
        "/obj/furnitures/commercial/bank_franchise_small",
        "/obj/furnitures/commercial/postal",
        "/obj/furnitures/commercial/poll_data",
      });
}
string query_money_place() {
   return environment()->query_property("place");
}
void set_commercial_type(string commercial_type) {
   _commercial_type = commercial_type;
}
void do_start_speil(object sellto) {
   setup_nationality(sellto->query_nationality(), sellto->query_nationality_region());
   _sell_to = sellto;
   queue_command("sayto " + file_name(_sell_to) +
                 " Hello!  So you are looking at some commercial "
                 "furniture?");
}
int do_list(int force) {
   string furn;
   string place;
   int num;
   int size;
   object ob;
   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   if (!force && this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }
   queue_command("sayto " + file_name(_sell_to) +
                 " I have the following items available.");
   num = 0;
   place = query_money_place();
   foreach (furn in _furniture) {
      if (!_commercial_type ||
          furn->query_commercial_type() == _commercial_type) {
         queue_command("sayto " + file_name(_sell_to) +
                    sprintf(" %c) %s costs %s (%d square yards)",
                            num + 'A', furn->the_short(),
                            MONEY_HAND->money_value_string(furn->query_value(), place),
                            furn->query_commercial_size()));
         num++;
      }
   }
   foreach (ob in all_inventory(environment())) {
      size += ob->query_commercial_size();
   }
   queue_command("sayto " + file_name(_sell_to) +
                  " The size of your shop is " +
                  environment()->query_property_size() +
                  " square yards and you have " +
                  (environment()->query_property_size() - size) +
                  " square yards of empty space.");
   return 1;
}
string strip_spaces(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void leave_room() {
   move("/room/rubbish", "$N shuffles away.");
}
int do_browse(string str) {
   mapping options;
   mapping values;
   string option_name;
   string thing;
   string* bits;
   string place;
   int cost;
   int pos;
   string* furns;
   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   place = query_money_place();
   if (this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }
   str = lower_case(str);
   pos = str[0] - 'a';
   if (_commercial_type) {
      furns = filter(_furniture, (: $1->query_commercial_type() == _commercial_type :));
   } else {
      furns = _furniture;
   }
   if (strlen(str) > 1 || pos < 0 || pos >= sizeof(furns)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, I do not understand which thing "
                    "you want to browse.\n");
      return 1;
   }
   queue_command("sayto " + file_name(_sell_to) + " " +
                 furns[pos]->the_short() + " costs " +
                 MONEY_HAND->money_value_string(furns[pos]->query_value(), place) +
                 " and takes up " + furns[pos]->query_commercial_size() +
                 " square yards.");
   if (furns[pos]->query_weekly_upkeep_cost()) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Costs " +
                    MONEY_HAND->money_value_string(furns[pos]->query_weekly_upkeep_cost(), place) +
                    " per week in upkeep.");
   }
   queue_command("sayto " + file_name(_sell_to) +
                 " " +
                 furns[pos]->long()[0..<2]);
   thing = furns[pos]->query_commercial_information();
   if (thing) {
      queue_command("sayto " + file_name(_sell_to) +
                    " " + thing);
   }
   options = furns[pos]->query_commercial_options();
   if (options) {
      queue_command("sayto " + file_name(_sell_to) +
                    " You have the following options for " +
                    furns[pos]->the_short());
      foreach (option_name, values in options) {
         bits = ({ });
         foreach (thing, cost in values) {
            bits += ({ "'" + thing + "' costs " +
                       MONEY_HAND->money_value_string(cost, place) });
         }
         queue_command("sayto " + file_name(_sell_to) +
                       " The options for '" + option_name  + "' are " +
                       query_multiple_short(bits));
      }
   }
   return 1;
}
int do_buy(string str, string options) {
   string place;
   string* bits;
   string name;
   string value;
   string thing;
   string option_name;
   string my_option;
   int pos;
   int size;
   int cost;
   int total_cost;
   int bad_option;
   int found;
   mapping option_types;
   object ob;
   string* furns;
   mapping values;
   mapping option_values;
   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   place = query_money_place();
   if (this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 0;
   }
   str = lower_case(str);
   pos = str[0] - 'a';
   if (_commercial_type) {
      furns = filter(_furniture, (: $1->query_commercial_type() == _commercial_type :));
   } else {
      furns = _furniture;
   }
   if (strlen(str) > 1 || pos < 0 || pos >= sizeof(furns)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, I do not understand which thing "
                    "you want to buy.\n");
      return 1;
   }
   if (furns[pos]->disallow_sale_here(environment())) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, this room disallows the purchase of that item.");
      return 0;
   }
   bits = explode(options, ",");
   option_types = ([ ]);
   foreach (thing in bits) {
      if (sscanf(thing, "%s=%s", name, value) == 2) {
         name = strip_spaces(name);
         value = strip_spaces(value);
         option_types[lower_case(name)] = lower_case(value);
      }
   }
   foreach (ob in all_inventory(environment())) {
      size += ob->query_commercial_size();
   }
   if (size + furns[pos]->query_commercial_size() >
       environment()->query_property_size()) {
      queue_command("sayto " + file_name(_sell_to) +
                    " The item " + furns[pos]->the_short() +
                    " is too big to fit into " + environment()->the_short());
      return 0;
   }
   option_values = furns[pos]->query_commercial_options();
   if (option_values) {
      foreach (option_name, values in option_values) {
         my_option = option_types[lower_case(option_name)];
         if (!my_option) {
            queue_command("sayto " + file_name(_sell_to) +
                    " The option '" + option_name + "' needs to be "
                    "specified.");
            bad_option = 1;
         } else {
            foreach (thing, cost in values) {
               if (lower_case(thing) == my_option) {
                  total_cost += cost;
                  found = 1;
                  option_types[lower_case(option_name)] = thing;
               }
            }
            if (!found) {
               queue_command("sayto " + file_name(_sell_to) +
                       " The option " + option_name + " has options "
                       "of " + query_multiple_short(keys(values)) + ".");
               bad_option = 1;
            }
         }
      }
   }
   if (bad_option) {
      return 0;
   }
   total_cost += furns[pos]->query_value();
   if (this_player()->query_value_in(place) < total_cost) {
      queue_command("sayto " + file_name(_sell_to) +
              " You do not have the " +
              MONEY_HAND->money_value_string(total_cost, place) +
              " to buy " + furns[pos]->the_short() + ".");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(total_cost, place),
                            place);
   ob = clone_object(furns[pos]);
   foreach (name, thing in option_types) {
      ob->set_commercial_option(name, thing, environment());
   }
   ob->move(environment());
   return 1;
}
int do_dismiss() {
   if (_sell_to && this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }
   queue_command("sayto " + file_name(this_player()) +
                 " Goodbye, see you next time.");
   call_out("leave_room", 5);
   return 1;
}
int do_trash(object* obs) {
   object* ok;
   object* bad;
   ok = filter(obs, (: $1->query_commercial_furniture() :));
   if (!sizeof(ok)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " None of " + query_multiple_short(obs) + " are "
                    "commercial items, so I cannot remove them.");
      return 0;
   }
   bad = filter(ok, (: !$1->can_trash_furniture() :));
   if (sizeof(bad)) {
      this_player()->add_failed_mess(this_object(),
                      "The items $I are unable to be trashed.  Perhaps they "
                      "still have something in them?\n");
      return 0;
   }
   write("Are you sure you want to trash " + query_multiple_short(ok) +
         "; this will get rid of them completely? ");
   input_to("complete_trash", 0, ok);
   this_player()->add_succeeded_mess(this_object(), "", ({ }));
   return 1;
}
void complete_trash(string str, object* obs) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting trash.\n");
   }
   queue_command("sayto " + file_name(_sell_to) + " Trashing " +
                 query_multiple_short(obs) + " for you.\n");
   obs->move("/room/rubbish", "", the_short() + " points at $N and it rips "
             "apart then vanishes.");
}
void init() {
   ::init();
   this_player()->add_command("trash", this_object(),
                              "<indirect:object> with <direct:object>",
                              (: do_trash :));
   this_player()->add_command("dismiss", this_object(),
                              "<direct:object>",
                              (: do_dismiss() :));
   this_player()->add_command("list", this_object(),
                              "<direct:object>",
                              (: do_list(0) :));
   this_player()->add_command("list", this_object(),
                              "{on|from} <direct:object>",
                              (: do_list(0) :));
   this_player()->add_command("browse", this_object(),
                              "<string'name'> on <direct:object>",
                              (: do_browse($4[0]) :));
   this_player()->add_command("buy", this_object(),
                              "<string'name'> {on|from} <direct:object>",
                              (: do_buy($4[0], "") :));
   this_player()->add_command("buy", this_object(),
                              "<string'name'> with <string'options'> {on|from} <direct:object>",
                              (: do_buy($4[0], $4[1]) :));
}

==================================================
FILE: monster/greco.c
==================================================

#define ITEM_TRACKER ("/obj/handlers/item_tracker")
inherit "/obj/monster";
object my_player;
mixed total_als;
object *save_obs;
object *unhandled_obs;
object *done_obs;
int grecos_day_off;
void setup() {
  seteuid("Root");
  if (!grecos_day_off) {
    set_name("greco");
    set_short("Greco the Departure Gecko");
    set_long("A small mottled grey gecko whose job it is to record all of "
             "the baggage of players so they can be restocked when they "
             "come back.  Greco is currently scribbling in "
             + query_possessive() + " notebook furiously.\n");
  } else {
    set_name("gumboot");
    set_short("Gumboot");
    set_long("A big black lizard who looks rather confused about what "
             + query_pronoun() + " is supposed to be doing.  Nevertheless, "
             + query_pronoun() + " is trying to look busy, scrawling "
             "something into a huge log book.\n");
  }
  add_property("determinate", "");
  add_property("no_attack", 1);
  set_gender(1+random(2));
  basic_setup("gnome", "warrior", 30);
  set_language("general");
}
void set_grecos_day_off(int day_off) {
  grecos_day_off = day_off;
  setup();
}
int query_grecos_day_off() {
  return grecos_day_off;
}
void get_rid_of(object player, int verbose) {
  int i;
  catch(set_grecos_day_off("/obj/monster/greco"->query_grecos_day_off()));
  if (verbose) {
    if (!grecos_day_off) {
      tell_object(player, "Greco the Departure Gecko starts inspecting "
                          "all your items and scribbling on a "
                          "notepad.\n");
    } else {
      tell_object(player, "This is Greco's day off.\nGumboot, Greco's "
                          "distant relative, is here to take your "
                          "information.  Gumboot looks very confused "
                          "and sticks the pencil in "+
                          query_possessive()+" ear.\n");
    }
  }
  my_player = player;
  unhandled_obs = save_obs = all_inventory(player);
  total_als = ({ });
  done_obs = ({ });
  for (i = 0; i < sizeof(save_obs); i++)
    call_out("get_ob_al", 1, save_obs[i], verbose);
  call_out("finish_player", 2, verbose);
}
void get_ob_al(object ob, int verbose)
{
  mixed *als;
  unhandled_obs -= ({ ob });
  als = my_player->fragile_auto_str_ob(ob);
  done_obs += ({ ob });
  if (sizeof(als) == 0) return;
  total_als += als;
}
void handle_dead_ob(object ob) {
  int value;
  mixed *als;
  string obname;
  catch(ob->move("/room/broken"));
  value = 1000;
  catch(value = ob->query_value());
  obname = "unknown object";
  catch(obname = ob->short(1));
  catch("/obj/misc/al_receipt"->set_object(file_name(ob)));
  "/obj/misc/al_receipt"->set_obname(obname);
  "/obj/misc/al_receipt"->set_value(value);
  als = "/global/auto_load"->
    fragile_auto_str_ob(find_object("/obj/misc/al_receipt"));
  als[0] = 1;
  if (!undefinedp(als[2][1]["::"]["cloned by"])) {
    als[2][1]["::"]["cloned by"] = "greco";
  }
  log_file("GRECO", "%s: %s - Broken object at logout: %O\n",
           ctime(time()), my_player?my_player->query_name():"0", ob);
  total_als += als;
}
void finish_player(int verbose) {
  int i, one_more;
  object *missing_obs;
  if (find_call_out("get_ob_al") != -1) {
    call_out("finish_player", 2, verbose);
    return;
  }
  if ( sizeof( unhandled_obs ) ) {
    call_out("finish_player", 2, verbose);
    return;
  }
  missing_obs = save_obs - done_obs;
  if (sizeof(missing_obs)) {
    one_more = sizeof(missing_obs);
    if (!grecos_day_off) {
      do_command("'"+(one_more==1?"One":"Some")+
                 " of your objects "+(one_more==1?"is":"are")+" broken and "
                 "will not save properly, so I will give you "+
                 (one_more==1?"a receipt for it.  This":
                              "receipts for them.  These")+
                 " can either be "
                 "sold for something vaguely like the replacement value of "
                 "the object or taken to a creator as proof of ownership "
                 "so you can ask very nicely to have it replaced.");
    } else {
      do_command("'Ummm.  I think some of these things of yours might "
                 "be broken.  Ummmm.....  Here, have some of these "
                 "receipt things.  Give them to a creator and they will "
                 "help you in trying to replace them.  Ummmm....  "
                 "Good luck.");
    }
    for (i = 0; i < sizeof(missing_obs); i++)
      handle_dead_ob(missing_obs[i]);
  }
  my_player->save_with_auto_load(total_als);
  if (verbose) {
    if (!grecos_day_off) {
      do_command( "smile brightly" );
      do_command( "'Well, everything seems to be in order.  Bye bye!" );
      do_command( "wave" );
      switch (random(3)) {
      case 0:
        tell_object(my_player, "You clamber aboard the giant spider.  It "
                    "opens the door, releases a thread of silk out into space "
                    "and, after a brief pause, climbs out after it possibly "
                    "never to be seen again ...\n");
        say(my_player->short(1) + " clambers aboard the giant spider.  It "
            "opens the door, releases a thread of silk out into space and, after "
            "a brief pause, climbs out after it.\n", my_player);
        break;
      case 1:
        tell_object(my_player, "The giant bird grabs you in its talons and leaps "
                    "out of the now open door to fly at great speed into the "
                    "black unknown ...\n");
        say(my_player->short(1) + " is grabbed by the talons of the giant bird "
            "and dragged out a door into the blackness of space.\n", my_player);
        break;
      case 2:
        tell_object(my_player, "You are thrown on to the back of the chimera.  "
                    "Clinging desperately to its mane you follow the beast out "
                    "into the inky depths.\n");
        say(my_player->short(1) + " is thrown onto the back of the chimera and "
            "dragged out into the inky depths.\n", my_player);
        break;
      }
    } else {
      do_command("smile strangely");
      do_command("'Well.  Uhhhh.  Thats it.");
      do_command("'I...  Umm.  Hope.");
      switch (random(3)) {
        case 0 :
          tell_object(my_player,
             "You clamber about a giant spider.  Gumboot starts to walk out "
             "the door and stands on one of it's feet.  You are flung from "
             "the back of the giant spider out through the door and "
             "floating meaninglessly through space.  You hope you will "
             "be seen again...\n");
          say(my_player->short(1)+" clambers aboard the giant spider.  It "
             "moves towards the door when something happens.  "+
             my_player->short(1)+" gets flung out through the door.\n");
          break;
        case 1 :
          tell_object(my_player,
             "The giant bird grabs you in it's talons and leaps out towards "
             "the now open door.\nGumboot exclaims: Wait!  I forgot to get your "
             "name!\nThe bird pauses confused and you thud into the side of "
             "the door and tumble backwards out into space, you try not "
             "notice the huge rents in your shoulder from where the talons "
             "ripped about your flesh.  Just a flesh wound.\n");
          say(my_player->short(1)+" is grabbed by the talons of the giant "
             "bird.  As they are heading for the door, Gumboot yells "
             "something at them, the bird gets disconcerted and rams "+
             my_player->short(1)+" into the door.  They tumble out into "
             "space a red line of blood showing their path.\n");
          break;
        case 2 :
          tell_object(my_player,
             "You are thrown towards the back of a chimera, you completely "
             "fail to get a hold on the mane and falls off it onto the "
             "floor.  The chimera steps backwards, convenient impaling you "
             "on a foot.  It then leaps through the door, you clutch your "
             "stomach hoping it is not permanent.\n");
          say(my_player->short(1)+" is thrown at a chimera, they don't catch "
             "hold of it, but they get impaled on it's foot when it steps "
             "back.  The chimera with a look of satisfaction dives through "
             "the door.\n");
          break;
      }
    }
  }
  tell_object(my_player, "Do come again!\n");
  foreach( object saved_ob in done_obs ) {
     reset_eval_cost();
     catch(saved_ob->set_tracked_item_status_reason("PLAYER_QUIT"));
     catch(saved_ob->dest_me());
     if ( saved_ob ) {
         catch(saved_ob->dwep());
     }
  }
  reset_eval_cost();
  catch( ITEM_TRACKER->save_all_item_states_delete_cache( my_player->query_name() ));
  catch(my_player->effects_quiting());
  catch(my_player->dest_me());
  if ( my_player ) {
    catch( my_player->dwep() );
  }
  if (my_player) {
    say(short(1) + " sighs deeply.\n");
  }
  move( "/room/rubbish", "$N appear$s.",
        "$N disappear$s in a puff of smoke." );
}

==================================================
FILE: monster/path.h
==================================================

#define PATH "/obj/monster/"

==================================================
FILE: monster/godmother/granny.c
==================================================

inherit "/obj/monster";
#include <panic.h>
#include <armoury.h>
void finish_up();
int state, start_time, prodded;
object lost;
string safeplace;
void setup() {
  start_time = time();
  set_name( "godmother" );
  set_short( "fairy godmother" );
  add_adjective( "fairy" );
  set_long( "This fairy godmother isn't quite what you expected.  She is "
    "tall and forbidding; not in the slightest bit cuddly or smiley.  She "
    "looks slightly uncomfortable and is currently glaring at her wand, "
    "which appears to be malfunctioning.  If you cross her, you might find "
    "yourself turned into a wombat or worse.\n" );
  set_race( "human" );
  set_guild( "witch" );
  set_level( 300 );
  set_gender( 2 );
  set_language("general");
  set_response_mon_understand_anything(1);
  add_property( "anchor", 1);
  ARMOURY->request_item("hobnailed boots", 100)->move( this_object() );
  ARMOURY->request_item("antique black dress", 100)->move( this_object() );
  ARMOURY->request_item("witchs pointy hat", 100)->move( this_object() );
  ARMOURY->request_item("black witches cloak", 100)->move( this_object() );
  init_equip();
  add_respond_to_with(({ "yes" }), "#yes_response");
  add_respond_to_with(({ "@nod" }), "#yes_response");
  add_respond_to_with(({ "no" }), "#no_response");
  add_respond_to_with(({ "@shake" }), "#no_response");
  add_respond_to_with(({ "@think", "somewhere", "safe" }), "#think_safe");
  add_respond_to_with(({ "@think", "safe" }), "#think_safe");
  add_respond_to_with(({ "@think", "safety" }), "#think_safe");
  add_respond_to_with(({ "@womble" }), "#think_mended_drum");
}
void do_panic(object pl) {
  string home;
  string nationality;
  nationality = pl->query_nationality();
  if ( !nationality ) {
      queue_command( "say Oops.. you haven't got a nationality, I can't "
        "send you home!");
      finish_up();
      return;
  }
  home = nationality->query_default_start_location();
  safeplace = home->query_short();
  queue_command( "say I hope you're not foreign.  You know, where "
    "you gabble at me in heathen lingo and eat foreign muck and "
    "worship objects." );
  queue_command( "say So.  You want some help to get back to the "
    + safeplace + "?" );
  queue_command( "glare "+pl->query_name() );
  lost = pl;
  start_time = time();
}
int query_waiting() { return time()-start_time; }
void yes_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Right then.  Close your eyes and concentrate." );
  queue_command( "say Think of somewhere safe." );
  prodded = 0;
  call_out("check_think", 30);
}
void no_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say So why did you call me up then?", 1 );
  queue_command( "roll eyes "+lost->query_name() );
  queue_command( "pinch "+lost->query_name()+" cheek" );
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
}
void think_safe(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Now the world will just rearrange itself "
    "to suit you." );
  PANIC_HANDLER->finish_panic(lost, PANIC_OK);
  lost = 0;
}
void check_think() {
  if(!lost)
    return;
  if (prodded < 3 ) {
    queue_command( "say Come on, I haven't got all day.  Just think of "
      "safety." );
    queue_command( "tap" );
    prodded ++ ;
    call_out("check_think", 60);
  } else {
    queue_command( "say Young people of today..." );
    queue_command( "mutter no manners" );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void event_exit(object ob, string message, object to) {
  if (ob == lost) {
    queue_command("hrmph");
    queue_command("tell "+lost->query_name()+" Thats right!  Just walk "
      "out on me.");
    queue_command("glare "+lost->query_name() );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void event_fight_in_progress(object attacker, object attackee) {
  if (attackee == this_object()) {
    attacker->adjust_tmp_str(-4);
    attacker->adjust_tmp_con(-4);
    attacker->adjust_tmp_dex(-4);
    attacker->adjust_tmp_int(-4);
    attacker->adjust_tmp_wis(-4);
    queue_command( "say What is this travesty!  Attacking your fairy "
               "godmother, Well I never." );
    queue_command( "say "+attacker->one_short()+" I here by curse you!" );
    queue_command( "say Don't expect me to help you again." );
    queue_command( "glare "+attacker->query_name() );
    attacker->add_property("attacked godmother", time());
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void hurry_up() {
  if (!lost) {
    queue_command( "blink" );
    queue_command( "say Where'd that bugger go?  Oh well.");
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  else  check_think();
}
void finish_up() {
  if (lost) {
    queue_command( "say Well.  You took too long.  What a complete "
      "waste of time." );
    queue_command( "glare " + lost->query_name() );
    lost = 0;
  }
  else  {
    queue_command( "peer" );
    queue_command( "say Damn, they buggered off somewhere.  I hate "
      "it when they do that." );
    queue_command( "scowl" );
  }
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
}
void event_dest(object ob) {
  if (ob == lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void dest_me() {
  if (lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  ::dest_me();
}
int unambushable() {
  return 1;
}

==================================================
FILE: monster/godmother/magrat.c
==================================================

inherit "/obj/monster";
#include <panic.h>
#include <armoury.h>
void finish_up();
int state, start_time, prodded;
object lost;
string safeplace;
void setup() {
  start_time = time();
  set_name("garlick");
  set_short("fairy godmother");
  add_alias("godmother");
  add_adjective("fairy");
  set_long( "In the realm of Fairy Godmothers, this one must certainly "
    "take honours in a Division Yet To Be Announced.  Grimly determined "
    "to do things properly, she has woven wild flowers in her "
    "windswept, golden locks, powdered her face to a fashionable pallor "
    "and has attired herself in numerous fluttering shawls, bangles, "
    "and a vivid green gown.  The overall effect is that of a maypole "
    "with a flower box emptied over its head that happens to jingle like "
    "a tinker's wagon with a broken wheel.  With one hand she clutches her "
    "regulation wand and with the other she dabs at her red and dripping "
    "nose with a damp scrap of lace.\n");
  set_race("human");
  set_guild("witch");
  set_level(200);
  set_gender(2);
  set_language("general");
  set_response_mon_understand_anything(1);
  add_property( "anchor", 1);
  ARMOURY->request_item("startling green dress", 100)->move( this_object() );
  ARMOURY->request_item("spiderweb shawl", 100)->move( this_object() );
  ARMOURY->request_item("pumps", 50)->move( this_object() );
  init_equip();
  add_respond_to_with(({ "yes" }), "#yes_response");
  add_respond_to_with(({ "@nod" }), "#yes_response");
  add_respond_to_with(({ "no" }), "#no_response");
  add_respond_to_with(({ "@shake" }), "#no_response");
}
void do_panic(object pl) {
  string home;
  string nationality;
  nationality = pl->query_nationality();
  if ( !nationality ) {
      queue_command( "say Oops.. you haven't got a nationality, I can't "
        "send you home!");
      finish_up();
      return;
  }
  home = nationality->query_default_start_location();
  safeplace = home->query_short();
  queue_command( "say Umm.  Hi.  You are lost?  Would you like me to get "
             "you back to " + safeplace + "?" );
  queue_command( "emote waves her wand around a bit." );
  tell_room(environment(),
            "A puff of smoke drifts away from where something else used to "
            "be.  Now residing there is a pumpkin.\n");
  ARMOURY->request_item("pumpkin", 100)->move(environment());
  queue_command( "say Whoops." );
  lost = pl;
  start_time = time();
  prodded = 0;
  call_out("do_prod", 30);
}
int query_waiting() { return time()-start_time; }
void yes_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Oh, ahhh.  Good." );
  queue_command( "peer wor" );
  tell_object( lost, the_short() + " waves her wand in your direction.\n");
  tell_room( environment(), the_short() + " waves her wand in " +
    lost->the_short() + "'s direction.\n", lost );
  PANIC_HANDLER->finish_panic(lost, PANIC_OK);
  ARMOURY->request_item("pumpkin", 100)->move(lost);
  ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
  lost = 0;
}
void no_response(object ob) {
  if(ob != lost)
    return;
  queue_command( "say Oh, I must have got lost somewhere then." );
  queue_command( "wave" );
  queue_command( "say Oh dear." );
  ARMOURY->request_item("pumpkin", 100)->move(lost);
  ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
}
void do_prod() {
  if(!lost)
    return;
  if (prodded < 3 ) {
    queue_command( "say Umm....so....what do you think?  Do you want "
      "my help?" );
    queue_command( "expect "+lost->query_name() );
    prodded ++ ;
    call_out("do_prod", 60);
  } else {
    queue_command( "say Oh well.  I guess it wasn't me you wanted after all" );
    queue_command( "sigh" );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void event_exit(object ob, string message, object to) {
    if (ob == lost) {
    queue_command( "say Bye..." );
    queue_command( "wave" );
    queue_command( "say Whoops." );
    queue_command( "tell "+lost->query_name()+" Sorry to have bothered you." );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
    lost = 0;
  }
}
void hurry_up() {
  if (!lost) {
    queue_command( "blink twice" );
    queue_command( "say I guess my help wasn't wanted, then..." );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  else do_prod();
}
void event_fight_in_progress(object attacker, object attackee) {
  if (attackee == this_object()) {
    queue_command( "say Look, this is really not very nice." );
    queue_command( "frown" );
    queue_command( "say I know the art of self defence you know!" );
    set_hp(query_max_hp(), attacker);
    attackee->adjust_tmp_str(-2);
    attackee->adjust_tmp_dex(-2);
    attackee->adjust_tmp_wis(-2);
    attackee->adjust_tmp_int(-2);
    attackee->adjust_tmp_con(-2);
    attackee->add_property("attacked godmother", time());
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void finish_up() {
  queue_command( "shuffle" );
  queue_command( "say Umm.  I have to go." );
  queue_command( "smile appol" );
  queue_command( "wave" );
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
}
void dest_me() {
  if (lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  ::dest_me();
}
int unambushable() {
    return 1;
}

==================================================
FILE: monster/transport/camel.c
==================================================

#include <npc/transport.h>
inherit "/obj/monster/transport/camel_base";
void setup() {
   set_race("camel");
   set_level(20);
   set_name("camel");
   set_long( "A ratty old camel with seemingly more knees than it should "
             "have.\n");
   set_inside_long( "Nothing smells worse than a camel.  Not even something "
                    "from Dibbler's tray.\n");
   set_value(40000 * 12);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type( "camel" );
   set_default_mount_difficulty(150);
   set_default_direction_difficulty(150);
   set_wander_time( 60 + random(20) );
   set_gender( 1 + random(2) );
   set_transport_speed(1);
   set_maximum_exhaustion(400);
  set_transport_colour("off-yellow");
}

==================================================
FILE: monster/transport/camel_base.c
==================================================

#include <npc/transport.h>
#include <broadcaster.h>
inherit TRANSPORT_INHERIT;
private int _quiet;
void set_quiet( int quiet ) {
   _quiet = quiet;
}
int query_quiet() {
   return _quiet;
}
void hear_name( object player, string mess ) {
   string *bits;
   string str;
   int allowed;
   if ( !player ) {
      return ;
   }
   if ( is_allowed_to_use( player->query_name() ) ) {
      bits = explode( mess, " " ) - ({ "" });
      foreach ( str in bits ) {
         switch ( str ) {
         case "follow" :
            do_command( "follow " + player->query_name() );
            break;
         case "stop" :
            do_command( "unfollow " + player->query_name() );
            break;
         case "stay" :
            do_command( "unfollow all" );
            break;
         case "quiet" :
            set_quiet(1);
            break;
         case "speak" :
         case "talk" :
            set_quiet(0);
            break;
         }
      }
      allowed = 1;
   }
   if ( !query_quiet() ) {
      if ( allowed ) {
        if( player->query_visible( this_object() ) )
          do_command( "slook " + player->query_name() );
      }
      switch ( random(3) ) {
      case 0:
         do_command( "spit" );
         break;
      case 1:
         do_command( ":ruminates." );
         break;
      case 2:
         do_command( ":looks thoughtful." );
         break;
      }
   }
}
void event_person_shout( object thing, string start, string mess, string lang,
                         int *co_ord, int range ) {
   if ( !environment() )
      return;
   if ( environment()->query_property( "shout zone" ) !=
        environment( this_player() )->query_property( "shout zone" ) ||
        !thing ) {
      return;
   }
   mess = lower_case( mess );
   if ( is_allowed_to_use( thing->query_name() ) ) {
      if ( strsrch( mess, lower_case( query_transport_name() ) )  != -1 ) {
         if (strsrch( mess, "come here" ) != -1) {
            if ( !query_quiet() ) {
               do_command( "grumble" );
            }
            add_effect( "/std/effects/npc/goto_destination",
                        environment(thing) );
         }
      }
   }
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "quiet" : query_quiet() ]);
}
void setup_responses() {
  add_respond_to_with( explode(
                       lower_case( query_transport_base_name() ), " " ),
                       (: hear_name :) );
  BROADCASTER->npc_hear_shouts( this_object() );
}
void init_dynamic_arg( mapping map ) {
   ::init_dynamic_arg( map["::"] );
   if ( map["quiet"] ) {
      set_quiet( map["quiet"] );
   }
   if ( query_transport_name() ) {
      setup_responses();
      set_short( query_transport_name() );
      add_adjective( explode( lower_case( query_transport_name() ), " " )
                     - ({ "the" }) );
      add_property( "determinate", "" );
      add_alias( explode( lower_case( query_transport_name() ), " " )
                 - ({ "the" }) );
   }
}
int do_name( string name ) {
   if ( ::do_name( name ) ) {
      setup_responses();
      set_short( query_transport_name() );
      return 1;
   }
   return 0;
}

==================================================
FILE: monster/transport/horse.c
==================================================

#include <npc/transport.h>
inherit "/obj/monster/transport/horse_base";
void setup() {
   set_race("horse");
   set_level(20);
   set_name("horse");
   set_gender( query_mount_gender() );
   set_long( "A nice dark dashing horse, " + query_pronoun() + " looks "
             "strong and happy as its brown eyes stare into your own.\n" );
   set_inside_long( "You can see the horses hair and ear's flicking at the "
                    "slightest sounds.  The smell of horse is quite "
                    "strong.\n" );
   set_value(40000 * 10);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type("horse");
   set_default_mount_difficulty(100);
   set_default_direction_difficulty(100);
   set_wander_time( 40 + random(10) );
   set_transport_speed(2);
   set_maximum_exhaustion(300);
}

==================================================
FILE: monster/transport/horse_base.c
==================================================

#include <npc/transport.h>
#include <broadcaster.h>
inherit TRANSPORT_INHERIT;
private int _quiet;
void set_quiet( int quiet ) {
   _quiet = quiet;
}
int query_quiet() {
   return _quiet;
}
void hear_name( object player, string mess ) {
   string *bits;
   string str;
   int allowed;
   if ( !player ) {
      return ;
   }
   if ( is_allowed_to_use( player->query_name() ) ) {
      bits = explode( mess, " " ) - ({ "" });
      foreach ( str in bits ) {
         switch ( str ) {
         case "follow" :
            do_command( "follow " + player->query_name() );
            break;
         case "stop" :
            do_command( "unfollow " + player->query_name() );
            break;
         case "stay" :
            do_command( "unfollow all" );
            break;
         case "quiet" :
            set_quiet(1);
            break;
         case "speak" :
         case "talk" :
            set_quiet(0);
            break;
         }
      }
      allowed = 1;
   }
   if ( !query_quiet() ) {
      if ( allowed ) {
         do_command( "nuzzle " + player->query_name() );
      }
      switch ( random(3) ) {
      case 0:
         do_command( "whicker" );
         break;
      case 1:
         do_command( "nicker" );
         break;
      case 2:
         do_command( "whinny" );
         break;
      }
   }
}
void event_person_shout( object thing, string start, string mess, string lang,
                         int *co_ord, int range ) {
   if( !environment() )
    return;
   if ( environment()->query_property( "shout zone" ) !=
        environment( this_player() )->query_property( "shout zone" ) ||
        !thing ) {
      return;
   }
   mess = lower_case( mess );
   if ( is_allowed_to_use( thing->query_name() ) ) {
      if ( strsrch( mess, lower_case( query_transport_name() ) )  != -1 ) {
         if (strsrch( mess, "come here" ) != -1) {
            if ( !query_quiet() ) {
               do_command( "whicker" );
            }
            add_effect( "/std/effects/npc/goto_destination",
                        environment(thing) );
         }
      }
   }
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "quiet" : query_quiet() ]);
}
void setup_responses() {
  add_respond_to_with( explode(
                       lower_case( query_transport_base_name() ), " " ),
                       (: hear_name :) );
  BROADCASTER->npc_hear_shouts( this_object() );
}
void init_dynamic_arg( mapping map, object ob ) {
   ::init_dynamic_arg( map["::"] );
   if ( map["quiet"] ) {
      set_quiet( map["quiet"] );
   }
}
int do_name( string name ) {
   if ( ::do_name( name ) ) {
      setup_responses();
      return 1;
   }
   return 0;
}

==================================================
FILE: monster/transport/warhorse.c
==================================================

#include <npc/transport.h>
inherit "/obj/monster/transport/horse_base";
void setup() {
   set_race("horse");
   set_level(50);
   set_name("horse");
   add_adjective("war");
   set_gender( query_mount_gender() );
   set_long( "This horse has an air of calmness about " + query_objective() + ", "
             + query_pronoun() + " just stands there and looks very calm.\n" );
   set_inside_long( "You can see the horses mane and " + query_objective() + " "
                    "looking calmly as possible into the distance.\n");
   set_value(40000 * 10);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type("horse");
   set_default_mount_difficulty(100);
   set_default_direction_difficulty(20);
   set_wander_time( 50 + random(10) );
   set_transport_speed(3);
   set_maximum_exhaustion(600);
   adjust_bonus_str(5);
   adjust_bonus_con(5);
}

==================================================
FILE: reactions/base.hdr_dc.c
==================================================

#include <reaction.h>
void dest_me() { destruct( this_object() ); }
class reaction item;
mapping data = ([ ]);
mixed data_return_0() {
  if (!mapp(data["TeaLeaf"])) data["TeaLeaf"] = ([]);
  item = new( class reaction );
  item->ratio = 1.0/100;
  item->result = "/obj/reagents/weak_black_tea.ob";
  item->result_amt = 1.0;
  item->func = ({ });
  data["TeaLeaf"]["Water"] = item;
  if (!mapp(data["BatGuano"])) data["BatGuano"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 0.8, 1.2 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1;
  item->func = ({ (:
   $3->set_decay_speed(0),
   $3->set_medium_alias( "GuanoSolution" ),
   $3->set_name( "guano_solution" ),
   $3->add_alias( "sludge" ),
   $3->set_short( "thick brown sludge" ),
   $3->add_adjective( ({ "thick", "brown" }) ),
   $3->set_long( "This is some thick brown sludge, streaked through with "
     "white.  The smell is... prominent.\n" )
:) })
;
  data["BatGuano"]["Water"] = item;
  if (!mapp(data["BlueHealingWater"])) data["BlueHealingWater"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 1.0, 1.0 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1.0;
  item->func = ({
        (: $3->set_name( "ooze" ) :),
        (: $3->add_alias( "green ooze" ) :),
        (: $3->set_short( "thick green ooze" ) :),
        (: $3->set_main_plural( "thick green oozes" ) :),
        (: $3->add_plural( "oozes" ) :),
        (: $3->add_adjective( "green" ) :),
        (: $3->set_long( "This is a thick, green "
                        "mush, $amount_size$.  It smells "
                        "terrible, and is bubbling slightly.\n" ) :),
        (: $3->set_medium_alias( "ThickGreenOoze" ) :),
        (: $3->add_eat_effect( "/std/effects/ingested/drunk", 50 ) :),
    });
  data["BlueHealingWater"]["BrewedComfreyYarrowTea"] = item;
  if (!mapp(data["BlueHealingWater"])) data["BlueHealingWater"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 1.0, 1.0 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1.0;
  item->func = ({
        (: $3->set_name( "ooze" ) :),
        (: $3->add_alias( "green ooze" ) :),
        (: $3->set_short( "thick green ooze" ) :),
        (: $3->set_main_plural( "thick green oozes" ) :),
        (: $3->add_plural( "oozes" ) :),
        (: $3->add_adjective( "green" ) :),
        (: $3->set_long( "This is a thick, green "
                        "mush, $amount_size$.  It smells "
                        "terrible, and is bubbling slightly.\n" ) :),
        (: $3->set_medium_alias( "ThickGreenOoze" ) :),
        (: $3->add_eat_effect( "/std/effects/ingested/drunk", 50 ) :),
    });
  data["BlueHealingWater"]["ComfreyYarrowTea"] = item;
}
mixed data_return() {
  data_return_0();
  return data;
}

==================================================
FILE: reactions/blue_water.rcn_dc.c
==================================================

}
mixed data_return() {
  return data;
}

==================================================
FILE: furnitures/chairs/chintz_chair.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
  set_name( "chair" );
  set_short( "overstuffed chintz chair" );
  add_adjective( ({ "overstuffed", "chintz" }) );
  set_long("This is the type of fat, comfortable chair typically found "
    "in the parlours of fat, comfortable ladies.  The fabric covering "
    "it is bright yellow decorated with a rather aggressive-looking "
    "rose and cabbage design.\n");
  set_allowed_positions(({ "sitting", "meditating", "lounging" }));
  set_allowed_room_verbs(([
    "sitting" : "sits",
  ]));
  set_weight(400);
  set_value(6000);
}

==================================================
FILE: furnitures/cupboards/pine_kitchen_cupboards.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("cupboard");
    set_short("set of white pine kitchen cupboards");
    add_adjective( ({ "set", "of", "white", "pine", "kitchen" }) );
    set_long("This is a set of kitchen cupboards made from white "
        "pine.  Four sets of doors hide the shelves within, and fluted "
        "columns with triple crowned tops make the structure a little "
        "less plain.  A simple design which still "
        "manages to radiate elegance, this set of cupboards is practial "
        "and functional, but still manages to be pleasing to the senses.\n");
    set_weight(250);
    set_max_weight(100);
    set_value(80000);
    set_allowed_room_verbs((["hanging" : "hangs" ]));
}

==================================================
FILE: furnitures/sideboards/marquetry_sideboard.c
==================================================

inherit "/std/room/furniture/surface";
void setup() {
  set_name( "sideboard" );
  set_short( "marquetry sideboard" );
  add_alias( "table" );
  add_adjective( ({ "marquetry"}) );
  set_long("This is a long table specifically designed to rest "
    "against a wall.  The marquetry effect on the top surface has been "
    "arranged to represent the Assassins' Guild coat of arms. \n");
  set_allowed_positions(({ "sitting", "lying", "squatting", "standing"}));
  set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands"]));
  set_weight(360);
  set_max_weight(200);
  set_value(100000);
  set_allow_use_internals(1);
}

==================================================
FILE: furnitures/commercial/bank_franchise_small.c
==================================================

inherit "/std/room/furniture/bank_franchise";
void setup() {
   set_name( "counter" );
   set_short( "small bank counter" );
   add_alias("bank");
   add_adjective( ({ "small", "bank" } ));
   set_long( "A heavily armoured and hardwood counter "
             "with a safe embedded into the surface.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(400000);
   set_commercial_size(10);
   set_maximum_total_difference(200000);
}

==================================================
FILE: furnitures/commercial/bank_master.c
==================================================

inherit "/std/room/furniture/bank_master";
void setup() {
   set_name( "counter" );
   set_short( "master bank counter" );
   add_alias("bank");
   add_adjective( ({ "master", "bank" } ));
   set_long( "A heavily armoured and hardwood counter "
             "with a safe embedded into the surface.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(16000000);
   set_commercial_size(91);
   set_shop_use_types(({ "bank", "withdraw", "deposit" }));
}

==================================================
FILE: furnitures/commercial/blackboard.c
==================================================

#include <language.h>
#define DEFAULT_LANGUAGE "morporkian"
#define BOARD_TAG "blackboard"
inherit "/std/room/furniture/commercial";
int do_write( string language );
void setup() {
    set_name ("blackboard");
    set_short ("blackboard");
    add_alias (({"board", "sign"}));
    set_long ("The residue of faded chalk-dust and long forgotten "
        "doodles lies heavily on the blackboard.  The grain of the "
        "board is worn and slightly mottled with age, hinting at "
        "a long and dignified history of classrooms and university "
        "lecterns.  Or perhaps just hinting at cheap wood and "
        "bad upkeep.\n");
    set_allowed_room_verbs( (["standing" : "stands",
                            "hanging"  : "hangs"]) );
    set_commercial_size(1);
    set_weight(2000);
    set_value(240000);
}
void init() {
    add_command ("write", "[on] <direct:object'blackboard'> in <string'language'>",
        (: do_write($4[1]) :) );
    add_command ("clean", "<direct:object>");
}
string query_readable_message(object player, int ignore_labels) {
    if (!sizeof(query_read_mess())) {
        return "A few random letters that escaped cleaning can be seen on "
            "the blackboard";
    }
    return ::query_readable_message(player, ignore_labels);
}
int do_clean() {
    if (!is_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot clean "
            +  capitalize (query_owner()) + "'s blackboard!\n", ({ }));
        return 0;
    }
    set_read_mess( 0 );
    return 1;
}
string find_words( string language ) {
    string words;
    words = implode( map( filter( query_read_mess(),
        (: $1[READ_LANG] == $(language) :) ), (: $1[READ_MESS] :) ), "\n" );
    return words;
}
int do_write(string language)
{
    string existing_text;
    if (!is_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot write on "
            +  capitalize (query_owner()) + "'s blackboard!\n", ({ }));
        return 0;
    }
    language = lower_case( language );
    if ( !this_player()->query_skill(
        LANGUAGE_HAND->query_language_written_skill(language)) ) {
        this_player()->add_failed_mess(this_object(), "You can't write in " +
           language + ".\n" );
        return -1;
    }
    existing_text = find_words( language );
    this_player()->do_edit(existing_text, "blackboard_text",
        this_object(), 0, language);
    this_player()->add_succeeded_mess (this_object(), "$N find$s a handy "
        "piece of chalk and start$s to write on the blackboard.\n", ({ }));
    return 1;
}
void blackboard_text(string text, string language)
{
    if (!text)
    {
        tell_room (environment (this_object()), this_player()->one_short()
            + " steps back from the blackboard without making any "
            "changes.\n", this_player());
        tell_object (this_player(), "Okay, nothing has been changed.\n");
        return;
    }
    set_read_mess( filter( query_read_mess(),
        (: $1[READ_LANG] != $(language) :) ) );
    add_read_mess( text, "chalk", language );
    tell_room(environment (this_object()), this_player()->one_short()
            + " finishes writing on the blackboard.\n", this_player());
}
void init_dynamic_arg(mapping map) {
   string my_words;
   commercial::init_dynamic_arg(map, player);
   my_words = query_auto_load_value(map, BOARD_TAG, "words");
   if ( stringp(my_words) ) {
       add_read_mess(my_words, "chalk", DEFAULT_LANGUAGE);
   }
     set_read_mess( filter( query_read_mess(), (: $1[READ_LANG] != "common" :) ) );
}
