# Total Tokens: 25227
# Total Files Merged: 40
# Total Characters: 84213

dland.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  add_zone("woodland");
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful.\n"
                         }));
    add_item("tree", "There are trees everywhere here, you have "+
             "to pick your way between them.  They are budding with "+
             "new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}), "The ground is covered "+
             "by a beautiful carpet of flowers interspersed with small "+
             "shrubs.");
    add_item("shrub", "Dotted here and there among the carpet of flowers "+
             "are small shrubs, some thorny, all green.");
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                            "Bees buzz busily from flower to flower.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_property("flower type", "bluebell");
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "You can barely see the "+
             "ground because of the waist-high ferns.  Dotted among the "+
             "ferns are small shrubs.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs, some thorny, all green.");
    add_item("fern", "Everywhere you look there are ferns growing "+
                         "almost waist high between the trees.");
    add_item("tree", "The trees are in their full foliage right now.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees making "+
                              "a sound like falling rain.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is littered "+
             "with dead leaves and the stems of dying ferns.");
    add_item("tree", "You are surrounded by trees, they are resplendent "+
             "with their autumn colours of red, gold and brown.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs many with brightly coloured berries.");
    add_item(({"berry", "berries"}),
               ({"long", "There are a variety of berries hanging from the "+
                   "shrubs here.",
                 "get", ({this_object(), "do_get_berry"}),
                 "pick", ({this_object(), "do_get_berry"})}));
    add_item(({"leaf", "leaves"}),
             ({"long", "The ground is littered with dead leaves.",
               "get", ({this_object(), "do_get_leaf"})}));
    add_item("fern", "Here and there are the stems of ferns which have "+
             "died back and will survive the coming winter underground.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees causing "+
                              "some to fall gently to earth.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_extra_look(this_object());
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("shrub", "Dotted here and there among the trees are small "+
             "shrubs trying to survive the winter.");
    add_item("tree", "There are bare trees everywhere here waiting for the "+
             "coming of spring.");
    room_chat(({120, 240, ({"The wind stirs the dry branches of the trees "+
                              "causing them to rustle eerily.",
                            "Somewhere a small animal forages in the "+
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_property("track type", "woodland");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
string query_terrain_map_colour() { return "%^GREEN%^"; }
string extra_look() {
  string extra;
  extra = ::extra_look();
  switch((string)WEATHER->query_season()) {
  case "spring":
    return extra + "Spring flowers are everywhere you look.\n";
  case "autumn":
    return extra + "The ground is littered with fallen leaves.\n";
    break;
  default:
    return extra;
  }
}
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->set_main_plural(flower_type + "s");
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}
mixed do_get_berry( string verb, object *dest ) {
  object berry;
  string berry_type;
  if ((int)query_property("noflowers"))
    return 0;
  berry_type = ({"blackberry", "raspberry", "blueberry", "strawberry",
                 "blackcurrant"})[random(5)];
   berry = clone_object( "/obj/food" );
  berry->set_name(berry_type);
  berry->set_short(berry_type);
  berry->set_long("This is a lovely, plump "+berry_type+" it looks good "+
                  "enough to eat.\n");
  berry->add_alias("berry");
  if (!(berry->move(this_player()))) return 1;
  berry->dest_me();
  return 0;
}
mixed do_get_leaf( string verb, object *dest ) {
  object leaf;
  string leaf_type;
  if ((int)query_property("noflowers"))
    return 0;
  leaf_type = ({"maple", "oak", "sycamore", "ash", "silver birch"})[random(5)];
  leaf = clone_object("/std/object");
  leaf->set_name("leaf");
  leaf->set_short(leaf_type+" leaf");
  leaf->set_long("This is a dead "+leaf_type+" leaf.  Its natural green "+
                 "has turned to shades of gold, red and brown.\n");
  leaf->add_adjective(leaf_type);
  if (!(leaf->move(this_player()))) return 1;
  leaf->dest_me();
  return 0;
}

==================================================
FILE: creator/workroom.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
object button, bookcase, board;
void setup() {
  set_short("workroom of "+ CREATOR);
  add_property( "determinate", "the ");
  set_light(100);
  set_long("This is the workroom of "+CREATOR+".  You can see a small "
     "wooden desk sulking in the corner of the room, it has a "
     "beautifully carved wooden rolly chair in front of it.  It "
     "looks like this was just newly created, there is a smell "
     "of paint and leather in the air.\n");
  add_item("chair",
        ({ "long", "The teak rolly chair has amazing carvings of dragons "
                   "and ... other things on it.  They almost seem alive, "
                   "you especially don't note the way the dragon "
                   "blinks at you.",
                   "position",
                   "the teak rolly chair" }) );
  add_item("desk", "The desk is made of mahogany with a touch of "
     "mountain ash.  The top has two little basket things "
     "on it labelled \"in\" and \"out\".  The in basket "
     "is rather small." );
  add_item( "dragon", "I told you, you don't notice it winking at you." );
  add_item("in basket", "The in basket is full of small yellow forms "
     "with large red letters on them saying "
     "\"Important read me first\" and then not "
     "appearing to actually have any thing else on "
     "them." );
  add_item( "out basket", "The out basket is completely empty." );
  add_item("basket", "There are two baskets sitting on top of the desk.  "
     "They have the words \"in\" and \"out\" written "
     "on them." );
  add_item("paint", "You look around to see the source of the paint "
     "smell and you can't find it.  The walls? of the room "
     "ummm seem to be well shall we just twisting in a "
     "confused mish mash of shapes, you are sure they are "
     "not threatening." );
  add_item("wall", "The walls are made up of a cloudy substance, white "
     "in nature that is roiling around the place where "
     "you are standing.  Great magic must be holding it "
     "back, every now and then you see a demonic head "
     "push its way out of the cloud roll its eyes and fade "
     "back into the cloud." );
  add_item("cloud", "The cloud is white coloured with a few flashes "
     "of light bursting in it." );
  add_item("demon", "The demonic heads that pop out are pretty nasty "
     "looking, they disapear with a snarl of strain." );
  add_exit("common", "/w/common", "door");
  add_exit("drum", CONFIG_START_LOCATION, "path");
  add_exit("learning", "/d/learning/main", "path");
  modify_exit( ({ "common", "drum", "learning" }),
      ({ "function", "check_player" }) );
  add_alias("north", "drum");
  add_alias("south", "common");
  "/w/common"->add_exit(CREATOR, "/w/"+CREATOR+"/workroom", "door");
}
void reset() {
  if (!button) {
    button = clone_object("/obj/misc/button");
    button->move(this_object());
  }
  if (!board) {
    board = clone_object("/obj/misc/board_mas");
    board->move(this_object() );
  }
  if (!bookcase) {
    bookcase = clone_object("/obj/cont_save");
    bookcase->set_name( "bookcase" );
    bookcase->set_short( "oaken bookcase" );
    bookcase->add_adjective( "wooden" );
    bookcase->add_adjective( "oak" );
    bookcase->add_adjective( "oaken" );
    bookcase->add_property( "there", "standing against the wall" );
    bookcase->set_long( "This bookcase is made from oak and "
      "varnished to bring out the glow.  It has 2 "
      "shelves, upon which you can see some books, and "
      "other objects.\n" );
    bookcase->set_weight( 2000 );
    bookcase->set_max_weight( 4000 );
    bookcase->reset_get();
    bookcase->check_euid();
    bookcase->set_save_file( "/w/"+CREATOR+"/creator_kit" );
    bookcase->move( this_object() );
  }
}
object *query_non_destable()  {
  return ({ bookcase, board });
}
int check_player( string verb, object player, string special ) {
    if ( interactive( player ) ) {
        return 1;
    }
    notify_fail( "" );
    return 0;
}

==================================================
FILE: races/amphibian.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard amphibian" );
   set_height( 40 );
   set_weight( 600 );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "skull", "left eye", "right eye" }),
      "skull", "skull", ({ "head", 15, 0, "brain" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "brain", "brain", ({ "skull", 5, 0 }),
      "torso", "guts", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 10, 0 }),
      "liver", "liver", ({ "guts", 5, 0 }),
      "left kidney", "kidney", ({ "guts", 5, 0 }),
      "right kidney", "kidney", ({ "guts", 5, 0 }),
      "spleen", "spleen", ({ "guts", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "right front leg", "leg", ({ 0, 200, 0 }),
      "left front leg", "leg", ({ 0, 200, 0 }),
      "right back leg", "leg", ({ 0, 200, 0 }),
      "left back leg", "leg", ({ 0, 200, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull" });
   unrottable = ({ "skull" });
   set_skin( "skin" );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
   if( !do_setup )
      this_object()->setup();
}
int lives_in_water() { return 1; }

==================================================
FILE: races/ape.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "ape" );
   set_long( "The apes are any members of the family Pongidae of large "
      "semi-erect primates, including the chimpanzee, gorilla, orangutan "
      "and gibbon.\n" );
   set_weight( 2500 );
   set_height( 175 );
   set_stats( ({ 4, 4, 0, 4, 0 }) );
}
int query_eat( string type ) { return 1; }
string query_desc( object thing ) {
   if( (int)thing->query_gender() == 1 )
      return "He is your average hairy young male ape.\n";
   return "She is your average hairy young female ape.\n";
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", 15 + level / 10 );
   thing->add_ac( "sharp", "sharp", 10 + level / 15 );
   thing->add_ac( "pierce", "pierce", 12 + level / 12 );
   thing->reset_all();
}
int query_dark( int light ) {
   if( light < 10 ) return 1;
   if( light > 200 ) return 2;
   return 0;
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 10 + ( 3 * sqrt( number ) ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->add_attack( "hands", 75, ({ 2 * number, 8, number }),
      "blunt", "unarmed", "unarmed_hands" );
   thing->add_attack( "feet", 25, ({ 3 * number, 10, number }),
      "blunt", "unarmed", 0 );
}

==================================================
FILE: races/arachnid.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "A creature like scorpion, spider, daddy longlegs, mite, "
      "tick, and certain other invertebrate animals.  This file should "
      "be inherited by a more specialised race object." );
   bits = ({
      "cephalothorax", "head", ({ 0, 200, 0,
         "middle right upper eye", "middle right lower eye",
         "middle left upper eye", "middle left lower eye",
         "right upper eye", "right lower eye",
         "left upper eye", "left lower eye", "brain", "ganglion",
         "left fang", "right fang", "stomach", "mandible" }),
      "middle right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "brain", "brain", ({ "cephalothorax", 25, 0 }),
      "ganglion", "ganglion", ({ "cephalothorax", 50, 0 }),
      "left fang", "fang", ({ "cephalothorax", 25, 0 }),
      "right fang", "fang", ({ "cephalothorax", 25, 0 }),
      "stomach", "stomach", ({ "cephalothorax", 50, 0 }),
      "mandible", "mandible", ({ "cephalothorax", 25, 0 }),
      "abdomen", "abdomen", ({ 0, 500, 0, "lung", "stomach",
         "heart", "right front leg", "right middle front leg",
         "left front leg", "left middle front leg", "right back leg",
         "right middle back leg", "left back leg", "left middle back leg" }),
      "left middle back leg", "leg", ({ "abdomen", 25, 0 }),
      "left back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle back leg", "leg", ({ "addomen", 25, 0 }),
      "right back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "right front leg", "leg", ({ "abdomen", 25, 0 }),
      "left middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "left front leg", "leg", ({ "abdomen", 25, 0 }),
      "lung", "lung", ({ "abdomen", 100, 0 }),
      "stomach", "stomach", ({ "abdomen", 100, 0 }),
      "heart", "heart", ({ "abdomen", 100, 0 }),
      "pedicel", "pedicel", ({ 0, 100, 0 })
   });
   inedible = ({ "left fang", "right fang", "mandible" });
   unrottable = ({ "left fang", "right fang", "mandible" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
   if( !do_setup )
      this_object()->setup();
}

==================================================
FILE: races/badger.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "badger" );
   set_long( "A big black white and grey burowing animal.\n" );
   set_height( 30 );
   set_weight( 500 );
   set_desc( "small brown meateater" );
   set_stats( ({ 2, -2, -2, 2, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 3 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "chew" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number )/2 }),
      "chew", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/base.c
==================================================

#define QUEST_AVE 140
#define QUEST_MAX 570
#define BASE 50
#define SCALE 10
#define NORM 15
#define EXPERT 20
#define A_TYPES ([ \
      "claws" : "sharp", \
      "chew" : "sharp", \
      "beak" : "pierce", \
      "bite" : "pierce", \
      "horn" : "pierce", \
      "hands" : "blunt", \
      "feet" : "blunt", \
      "tail" : "blunt", \
      "hoof" : "blunt", \
      "wrestle" : "blunt", \
   ])
inherit "/std/object";
private int height;
private int *sight;
private int *stats;
private string desc;
private string skin;
string *inedible;
string *unrottable;
string *pluckable;
private string *limbs;
private mixed *acs;
private mixed *attacks;
private mapping _fixed_bits;
mixed *bits;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   sight = ({ 5, 20, 200, 300 });
   stats = allocate( 5 );
   desc = "a small non-descript thing";
   inedible = ({  });
   unrottable = ({  });
   pluckable = ({  });
   acs = ({ });
   attacks = ({ });
   bits = ({ });
   if ( !do_setup )
      this_object()->setup();
}
int query_height() { return height; }
void set_height( int number ) { height = number; }
int *query_sight() { return copy(sight); }
void set_sight( int *numbers ) { sight = numbers; }
int query_dark( int light ) {
   if ( light < sight[ 0 ] ) {
      return -2;
   }
   if ( light < sight[ 1 ] ) {
      return -1;
   }
   if ( light > sight[ 3 ] ) {
      return 2;
   }
   if ( light > sight[ 2 ] ) {
      return 1;
   }
   return 0;
}
int *query_stats() { return copy(stats); }
void set_stats( int *numbers ) { stats = numbers; }
string query_skin() { return skin; }
void set_skin( string word ) { skin = word; }
string query_desc( object thing ) {
   return capitalize( (string)thing->query_pronoun() ) +" is "+ desc +".\n";
}
void set_desc( string words ) { desc = words; }
string *query_limbs() {
   if ( !limbs ) {
      this_object()->find_limbs();
   }
   return copy(limbs);
}
void find_limbs() {
   int i;
   string limb;
   limbs = ({ });
   for ( i = 0; i < sizeof( bits ); i += 3 ) {
     if ( sscanf( bits[ i ], "%s hand", limb ) == 1 ) {
       limbs += ({ bits[ i ] });
     }
   }
}
mixed *query_acs() { return copy(acs); }
void add_ac( string ac_name, string ac_type, mixed ac_amount ) {
   acs += ({ ac_name, ac_type, ac_amount });
}
mixed *query_attacks() { return copy(attacks); }
void add_attack( string attack_name, int attack_chance, int *attack_data ) {
   attacks += ({ attack_name, attack_chance, attack_data });
}
mixed *query_bits() { return bits; }
mixed *query_bit( string word ) {
   int i;
   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return ({ });
   }
   return bits[ i .. i + 2 ];
}
private void fixup_bits() {
   string* str_bits;
   string pl;
   int i;
   if (_fixed_bits) {
      return ;
   }
   _fixed_bits = ([ ]);
   for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
      str_bits = explode(bits[i], " ");
      pl = pluralize(str_bits[<1]);
      if (!_fixed_bits[str_bits[<1]]) {
         _fixed_bits[str_bits[<1]] = ({ });
      }
      _fixed_bits[str_bits[<1]] += ({ ({ str_bits[0..<2], i, 0 }) });
      if (!_fixed_bits[pl]) {
         _fixed_bits[pl] = ({ });
      }
      _fixed_bits[pl] += ({ ({ str_bits[0..<2], i, 1 }) });
   }
}
private string *query_old_possible_bits( string word ) {
   int i;
  int j;
  string *possibles;
  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if ( ( bits[ i ] == word ) ||
          ( bits[ i + 1 ] == word ) ||
          !word) {
       if (arrayp( bits[i+2][2] )) {
         for ( j = 0; j < bits[i + 2][2][1]; j++) {
           possibles += ({ bits[ i ] });
         }
       } else {
         possibles += ({ bits[ i ] });
       }
     }
   }
   return possibles;
}
string *query_possible_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;
  if(!word) {
    return query_old_possible_bits( word );
  }
  fixup_bits();
  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (!bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
}
string *query_possible_plural_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;
  fixup_bits();
  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
}
void add_bit( string bit_short, string bit_name, mixed *bit_array ) {
   int i;
   i = member_array( bit_short, bits );
   if ( !( i % 3 ) ) {
      bits[ i ] = bit_short;
      bits[ i + 1 ] = bit_name;
      bits[ i + 2 ] = bit_array;
      return;
   }
   bits += ({ bit_short, bit_name, bit_array });
}
void remove_bit( string word ) {
   int i;
   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return;
   }
   bits = delete( bits, i, 3 );
}
int modifier( int number ) {
   return ( number * ( roll_MdN( 20, 21 ) - 220 ) ) / 2000;
}
void start_player( object thing ) {
   if ( !thing->query_base_weight() ) {
      thing->set_base_weight( 1 + weight + modifier( weight ) );
   }
   if ( !thing->query_height() ) {
      thing->set_height( 1 + height + modifier( height ) );
   }
   thing->adjust_bonus_con( stats[ 0 ] );
   thing->adjust_bonus_dex( stats[ 1 ] );
   thing->adjust_bonus_int( stats[ 2 ] );
   thing->adjust_bonus_str( stats[ 3 ] );
   thing->adjust_bonus_wis( stats[ 4 ] );
   thing->reset_all();
   if ( skin ) {
      thing->set_skin( skin );
   }
}
int query_number_worn( string type ) {
   switch ( type ) {
      case "armband" :
         return 2;
      case "badge" :
         return 15;
      case "bracelet" :
         return 4;
      case "earring" :
        return 2;
      case "garter" :
         return 2;
      case "shoulder" :
         return 2;
      case "necklace" :
         return 5;
      case "ring" :
         return 8;
      case "sash" :
         return 2;
      case "shirt" :
         return 2;
      case "belt scabbard" :
         return 2;
      case "small scabbard" :
         return 2;
      case "bandaid" :
         return 5;
      default :
         return 1;
   }
}
int query_number_wielded( string type ) { return 1; }
int query_skill_bonus( int number, string word ) { return 0; }
int player_start( object thing ) { return 1; }
int player_quit( object thing ) { return 1; }
void set_level( object thing, int level ) {
   int i;
   if ( !thing ) {
      return;
   }
   for ( i = sizeof( acs ) - 3; i > -1; i -= 3 ) {
      thing->add_ac( acs[ i ], acs[ i + 1 ], acs[ i + 2 ] );
   }
}
int *calc_attack( int *data, int number ) {
   int base;
   int num;
   int rand;
   int rating;
   int scale;
   base =  data[ 0 ] * ( BASE + SCALE * number );
   num = data[ 1 ];
   rand = data[ 2 ] * ( BASE + SCALE * number );
   rating = QUEST_AVE * ( base + num * rand ) +
         QUEST_MAX * ( base + ( num * ( 1 + rand ) ) / 2 );
   scale = BASE + SCALE * NORM;
   rating /= scale;
   rating = ( ( BASE + SCALE * EXPERT ) * rating + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
   if ( rating > scale ) {
      scale = ( rating + scale ) / 2;
   }
   return ({ base / scale, num, rand / scale });
}
void set_unarmed_attacks( object thing ) {
   int i, number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   for ( i = sizeof( attacks ) - 3; i > -1; i -= 3 ) {
      thing->remove_attack( attacks[ i ] );
      thing->add_attack( attacks[ i ], attacks[ i + 1 ],
            calc_attack( attacks[ i + 2 ], number ), A_TYPES[ attacks[ i ] ],
            "unarmed", "unarmed_"+ attacks[ i ] );
   }
}
int query_eat( string bit ) {
  if (member_array( bit, inedible) == -1) {
    return 1;
  }
  return 0;
}
int query_unrottable( string bit ) {
  if (member_array( bit, unrottable) == -1) {
    return 0;
  }
  return 1;
}
int query_pluckable( string bit ) {
  if (member_array( bit, pluckable) == -1) {
    return 0;
  }
  return 1;
}
string *query_all_inedible() {
   return inedible;
}
string *query_all_unrottable() {
   return unrottable;
}
string *query_all_pluckable() {
   return pluckable;
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg",
              "stomach", "stomach",
              "right front leg", "right front leg",
              "left rear leg", "left rear leg",
              "right rear leg", "right rear leg",});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "feet":
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  default:
    return zone;
  }
}
string map_armour_zone(string zone) {
  switch(zone) {
  case "thorax":
  case "body":
  case "breast":
  case "trunk":
    return "chest";
  case "tail":
    return "back";
  case "stomach":
    return "abdomen";
  case "left arm":
  case "right arm":
  case "left front leg":
  case "right front leg":
  case "left petral fin":
  case "right petral fin":
  case "left wing":
  case "right wing":
  case "branches":
    return "arms";
  case "left hand":
  case "right hand":
  case "left middle leg":
  case "right middle leg":
  case "left front paw":
  case "right front paw":
    return "hands";
  case "left leg":
  case "right leg":
  case "left back leg":
  case "right back leg":
  case "left rear leg":
  case "right rear leg":
  case "dorsal fin":
    return "legs";
  case "left foot":
  case "right foot":
  case "left rear paw":
  case "left rear paw":
  case "left rear foot":
  case "left rear foot":
  case "left claw":
  case "right claw":
  case "root":
    return "feet";
  default:
    return zone;
  }
}

==================================================
FILE: races/bat.c
==================================================

inherit "/std/races/rodent_base";
void setup() {
   set_name( "bat" );
   set_long( "This is a small flying rodent." );
   set_desc( "a small, flying rodent" );
   set_height( 20 );
   set_weight( 40 );
   remove_bit( "torso" );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );
   add_bit( "torso", "torso", ({ 0, 20, 0,
      "heart", "liver", "left kidney", "right kidney", "spleen",
      "right lung", "left lung", "right wing", "left wing" }) );
   add_bit( "right wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left leg", "leg", ({ 0, 5, 0 }) );
   add_bit( "right leg", "leg", ({ 0, 5, 0 }) );
   set_sight( ({ -20, 0, 80, 120 }) );
   set_stats( ({ 0, 14, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 4;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 75, ({ 0, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 0, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/bear.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "bear" );
   set_desc( "a furry bear" );
   set_height( 200 );
   set_weight( 8000 );
   set_stats( ({ 6, 4, -2, 8, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ 2 * number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 8, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/beetle.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_name( "beetle" );
   set_desc( "a hard-carapaced insect that scuttles along the ground" );
   set_height( 5 );
   set_weight( 2 );
   add_bit( "left wing cover", "cover", ({ "thorax", 1, 0 }) );
   add_bit( "right wing cover", "cover", ({ "thorax", 1, 0 }) );
   inedible += ({ "left wing cover", "right wing cover" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/bird.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "bird" );
   set_long( "A general, unspecified bird.\n" );
   set_height( 15 );
   set_weight( 60 );
   set_stats( ({ 0, 14, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int weight;
   object thing;
   thing = args[ 1 ];
   if ( !thing )
     return;
   weight = (thing->query_weight() / 20);
   thing->add_ac( "blunt", "blunt", weight / 2 );
   thing->add_ac( "pierce", "pierce", weight );
   thing->add_ac( "sharp", "sharp", weight );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/bird_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "a general, unspecified bird.  This should not be used since "
      "it is a base race" );
   bits = ({
      "head", 0, ({ 0, 150, 0,
         "left eye", "right eye", "beak", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({"head", 1, 0 }),
      "beak", 0, ({ "head", 20, 0 }),
      "skull", "cranium", ({ "head", 30, 0, "brain" }),
      "brain", 0, ({ "skull", 10, 0 }),
      "neck", 0, ({ 0, 25, 0, "gizzard" }),
      "gizzard", "gullet", ({ "neck", 5, 0 }),
      "torso", "body", ({ 0, 500, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas", "wishbone",
         "body feather" }),
      "heart", 0, ({ "torso", 50, 0 }),
      "liver", 0, ({ "torso", 25, 0 }),
      "left kidney", "kidney", ({ "torso", 15, 0 }),
      "right kidney", "kidney", ({ "torso", 15, 0 }),
      "left lung", "lung", ({ "torso", 25, 0 }),
      "right lung", "lung", ({ "torso", 25, 0 }),
      "spleen", 0, ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "pancreas", 0, ({ "torso", 15, 0 }),
      "wishbone", 0, ({ "torso", 5, 0 }),
      "body feather", "feather", ({ "torso", 1, ({"/std/bit", 6}) }),
      "tail", 0, ({ 0, 50, 0, "tail feather" }),
      "tail feather", "feather", ({ "tail", 1, ({"/std/bit", 4}) }),
      "left wing", "wing", ({ 0, 150, 0,
         "left wing feather" }),
      "left wing feather", "feather", ({ "left wing", 1,
         ({"/std/bit", 5}) }),
      "right wing", "wing", ({ 0, 150, 0,
         "right wing feather" }),
      "right wing feather", "feather", ({ "right wing", 1,
         ({"/std/bit", 5}) }),
      "left leg", "leg", ({ 0, 100, 0, "left claw" }),
      "left claw", "claw", ({ "left leg", 25, 0 }),
      "right leg", "leg", ({ 0, 100, 0, "right claw" }),
      "right claw", "claw", ({ "right leg", 25, 0 })
   });
   inedible = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   unrottable = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   pluckable = ({ "body feather", "left wing feather", "right wing feather",
      "tail feather" });
   set_skin( "feathers" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "breast", "breast", "breast", "breast", "back",
              "left wing", "left wing", "left wing", "left wing",
              "right wing", "right wing", "right wing", "right wing",
              "stomach", "stomach", "stomach",
              "left leg", "left leg", "left claw",
              "right leg", "right leg", "right claw" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return "breast";
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "wing";
  case "feet":
    return (random(2) ? "left " : "right ") + "claw";
  default:
    return zone;
  }
}

==================================================
FILE: races/bufonid.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "bufonid" );
   set_long( "The bufonids are rare species of humanoid toad-like beings.  "
      "It is rumoured that they were created by wizards as part of a "
      "heinous series of experiments of unknown intent and subsequently "
      "escaped from their creators.  Little is known of them, except that "
      "they keep themselves well hidden from humans.\n" );
   set_height( 150 );
   set_weight( 1800 );
   set_desc( "a strange creature, with webbed feet and warty green skin, "
      "that gives you the impression of being a humanoid toad" );
   remove_bit( "left ear" );
   remove_bit( "right ear" );
   remove_bit( "nose" );
   remove_bit( "scalp" );
   remove_bit( "teeth" );
   add_ac( "blunt", "blunt", 15 );
   add_ac( "pierce", "pierce", 12 );
   add_ac( "sharp", "sharp", 10 );
   add_attack( "hands", 75, ({ 40, 5, 10 }) );
   add_attack( "feet", 25, ({ 30, 5, 20 }) );
   set_stats( ({ 2, 2, 0, 2, 0 }) );
}

==================================================
FILE: races/cabbage.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "cabbage" );
   set_long("A green, leafy vegetable.  Probably full of vitamins and "+
      "minerals, and plenty of roughage.\n" );
   set_height( 20 );
   set_weight( 40 );
   set_desc( "a cute little green-fronded cabbage.  Awww" );
   set_skin( "fronds" );
   bits = ({
      "frond", "frond", ({ 0, 100, ({"/std/bit", 10}) }),
      "stalk", "stalk", ({ 0, 500, 0 })
   });
   inedible = ({ });
   unrottable = ({ });
   set_stats( ({ -4, -4, -6, -4, -6 }) );
}
void player_heart_beat( string word, object brassica ) {
   object *caterpillars;
   if( !environment( brassica ) ) {
      return;
   }
   caterpillars = match_objects_for_existence( "caterpillar",
      environment( brassica ) );
   if( !sizeof( caterpillars ) ) {
      return;
   }
   if( brassica->caterpillars_here( caterpillars ) ) {
      return;
   }
   brassica->do_command( "gibber" );
   brassica->run_away();
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "fronds" );
   thing->add_attack( "fronds", 160, ({ 4 * number, 5, 3 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack_message( "fronds", "sharp", ({
      50, "$N scratch$es $P $z with a frond.\n",
      100, "$N jab$s a sharp frond into $P $z.\n",
      140, "$N chew$s on $P $z.\n",
      180, "$N slash$es $P $z with $p fronds.\n",
      230, "$N climb$s onto %I and cuts $P $z with a sharp frond.\n",
      0, "$N bite$s $P $z off!\n" }) );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/camel.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "camel" );
   set_long( "The camel is an animal living in desert regions.  It has two "
      "humps, a mean temper and a good eye for numbers.  They are usually "
      "named things like \"You Bastard\", \"Evil-smelling Bugger\" and so "
      "on, something that might seem strange to anyone who hasn't "
      "actually met one of the beasts.\n" );
   set_height( 170 );
   set_weight( 12000 );
   set_desc( "a camel that looks less interested in you than in sand" );
   add_bit( "tail", "tail", ({ 0, 18, 0 }) );
   add_bit( "fore hump", "hump", ({ 0, 75, 0 }) );
   add_bit( "aft hump", "hump", ({ 0, 50, 0 }) );
   inedible += ({ "tail" });
   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );
   add_attack( "bite", 50, ({ 40, 8, 10 }) );
   add_attack( "feet", 50, ({ 60, 10, 40 }) );
   set_stats( ({ 4, 2, 10, 6, 8 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/carnivore.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_weight( 700 );
   set_height( 50 );
   set_desc( "your standard carnivore.  This should not be used as it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "nose", "skull", "left ear", "right ear",
         "tongue" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "skull", "cranium", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 20, 0 }),
      "left ear", "ear", ({"head", 1, 0 }),
      "right ear", "ear", ({"head", 1, 0 }),
      "nose", "nose", ({ "head", 3, 0 }),
      "teeth", "teeth", ({ "skull", 3, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 48}) }),
      "tongue", "tongue", ({ "head", 2, 0 }),
      "neck", "neck", ({ 0, 15, 0 }),
      "torso", "body", ({ 0, 350, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 10, 0 }),
      "liver", "liver", ({ "torso", 5, 0 }),
      "left kidney", "kidney", ({ "torso", 5, 0 }),
      "right kidney", "kidney", ({ "torso", 5, 0 }),
      "left lung", "lung", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 5, 0 }),
      "intestine", "gut", ({ "torso", 15, 0 }),
      "pancreas", "pancreas", ({ "torso", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 130, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 30, 0, "claw" }),
      "claw", "claw", ({ "left front paw", 1, ({"/std/bit", 4}) }),
      "right front leg", "leg", ({ 0, 130, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 30, 0, "claw" }),
      "claw", "claw", ({ "right front paw", 1, ({"/std/bit", 4}) }),
      "left rear leg", "leg", ({ 0, 275, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 30, 0, "claw" }),
      "claw", "claw", ({ "left rear paw", 1, ({"/std/bit", 4}) }),
      "right rear leg", "leg", ({ 0, 275, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 30, 0, "claw" }),
      "claw", "claw", ({ "right rear paw", 1, ({"/std/bit", 4}) }),
      "tail", "tail", ({ 0, 18, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "claw", "tail", "teeth", "tooth", "skin" });
   unrottable = ({ "skull", "claw", "teeth", "tooth" });
   set_skin( "pelt" );
   set_stats( ({ 6, 10, -2, 6, -4 }) );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg", "left front paw",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front paw",
              "left rear leg", "left rear leg", "left rear paw",
              "right rear leg", "right rear leg", "right rear paw"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front paw";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear paw";
  default:
    return zone;
  }
}

==================================================
FILE: races/cat.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "cat" );
   set_long( "A carnivorous mammal (Felis catus) long domesticated and kept "+
         "by man as a pet or for catching rats and mice.\n" );
   set_height( 20 );
   set_weight( 100 );
   set_desc( "a furry cat, on the hunt for a mouse to play with" );
   set_stats( ({ 0, 10, 2, -2, 2 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 100, ({ number, 5, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 7, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/caterpillar.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_name( "caterpillar" );
   set_long( "The elongated wormlike larva of a butterfly or moth.\n" );
   set_height( 5 );
   set_weight( 2 );
   set_desc( "a caterpillar, crawling along the ground" );
   set_stats( ({ -6, -6, -6, -6, -6 }) );
}
void player_heart_beat( string word, object eater ) {
   int i, time;
   object flowers, *things;
   if( !environment( eater ) ) return;
   if( eater->query_property( "eating" ) ) return;
   things = all_inventory( environment( eater ) ) - ({ eater });
   if( !sizeof( things ) ) return;
   for( i = 0; i < sizeof( things ); i++ ) {
      if( !(int)things[ i ]->id( "flowers" ) ) {
         things -= ({ things[ i ] });
         i--;
      } else {
         if( things[ i ]->query_property( "being eaten" ) ) {
            things -= ({ things[ i ] });
            i--;
         }
      }
   }
   if( !sizeof( things ) ) return;
   flowers = things[ random( sizeof( things ) ) ];
   tell_room( environment( eater ), "The " + (string)eater->query_short() +
      " discovers the " + (string)flowers->query_short() + " and starts to "
      + "munch.\n" );
   eater->add_property( "eating", 1 );
   flowers->add_property( "being eaten", 1 );
   time = (int)flowers->query_weight();
   time += random( time );
   call_out( "done_eating", time, eater, flowers );
}
void done_eating( object eater, object flowers ) {
   if( !eater ) return;
   eater->remove_property( "eating" );
   if( !environment( eater ) ) return;
   if( !flowers ) return;
   if( member_array( flowers, all_inventory( environment( eater ) ) ) == -1 )
      return;
   tell_room( environment( eater ), "The " + (string)eater->query_short() +
      " finishes the " + (string)flowers->query_short() + " and burps " +
      "contentedly.\n" );
   flowers->dest_me();
}

==================================================
FILE: races/chicken.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "chicken" );
   set_long( "Chickens.  That's all there is to say.  Chickens, chickens, "
      "chickens, chickens, chickens.  Thank you.\n" );
   set_weight( 80 );
   set_height( 30 );
   set_desc( "an ordinary brain-dead chicken" );
   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );
   set_stats( ({ 0, 8, -6, -4, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/cockroach.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_desc( "a nasty cockroach, ugh" );
   set_name( "cockroach" );
   set_height( 5 );
   set_weight( 2 );
   add_ac( "blunt", "blunt", 40 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 10 );
   set_stats( ({ -6, 4, -4, -6, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ ( 3 * number ) / 2, 5, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({3 * number, 2, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/cow.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   mixed *new_head;
   set_name( "cow" );
   set_long( "A large hoofed mammal.  Surprise.\n" );
   set_height( 175 );
   set_weight( 16000 );
   set_desc( "a large, hairy quadruped reminding you very much of a cow" );
   new_head = query_bit( "head" );
   new_head[ 2 ] += ({ "left horn", "right horn" });
   remove_bit( "head" );
   add_bit( "head", "head", new_head[ 2 ] );
   add_bit( "left horn", "horn", ({ "head", 10, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 10, 0 }) );
   add_bit( "udders", "udders", ({ 0, 60, 0 }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );
   inedible += ({ "left horn", "right horn", "tail" });
   unrottable += ({ "left horn", "right horn" });
   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );
   add_attack( "bite", 20, ({ 40, 8, 10 }) );
   add_attack( "feet", 50, ({ 60, 10, 40 }) );
   set_stats( ({ 4, -2, -4, 6, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "horns" );
   thing->remove_attack( "hoof" );
   if( number < 10 )
      number = 10;
   thing->add_attack( "horns", 40, ({ 60, 10, 40 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ 40, 8, 10 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/crab.c
==================================================

inherit "/std/races/base";
void setup() {
    set_name( "crab" );
    set_long( "A scuttling crab.\n" );
    set_height( 10 );
    set_weight( 18 );
    set_desc( "a scuttling crab" );
    bits = ({
        "head", "head", ({ 0, 200, 0,
            "left antenna", "right antenna", "left antennule", "right "
            "antennule", "brain", "left eye", "right eye", "left eyestalk",
            "right eyestalk", "jaw", "skull" }),
        "left antenna", "antenna", ({ "head", 2, 0 }),
        "right antenna", "antenna", ({ "head", 2, 0 }),
        "left antennule", "antennule", ({ "head", 1, 0 }),
        "right antennule", "antennule", ({ "head", 1, 0 }),
        "brain", "brain", ({ "head", 50, 0 }),
        "skull", "skull", ({ "head", 50, 0 }),
        "left eye", "eye", ({ "head", 5, 0 }),
        "right eye", "eye", ({ "head", 5, 0 }),
        "left eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "right eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "jaw", "mouth", ({ "head", 25, 0 }),
        "carapace", "carapace", ({ 0, 25, 0 }),
        "thorax", "thorax", ({ 0, 500, 0,
            "left cheliped", "right cheliped", "left second leg",
            "right second leg", "left third leg", "right third leg", "left "
            "fourth leg", "right fourth leg", "left back leg", "right back "
            "leg", "heart", "hepatopancreas", "intestine", "stomach" }),
        "left cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "right cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "left second leg", "leg", ({ "thorax", 50, 0 }),
        "right second leg", "leg", ({ "thorax", 50, 0 }),
        "left third leg", "leg", ({ "thorax", 50, 0 }),
        "right third leg", "leg", ({ "thorax", 50, 0 }),
        "left fourth leg", "leg", ({ "thorax", 50, 0 }),
        "right fourth leg", "leg", ({ "thorax", 50, 0 }),
        "left back leg", "leg", ({ "thorax", 50, 0 }),
        "right back leg", "leg", ({ "thorax", 50, 0 }),
        "heart", "heart", ({ "thorax", 50, 0 }),
        "hepatopancreas", "hepatopancreas", ({ "thorax", 10, 0 }),
        "intestine", "intestine", ({ "thorax", 30, 0 }),
        "stomach", "stomach", ({ "thorax", 30, 0 }),
        "apron", "apron", ({ 0, 100, 0, "left pleopod", "right pleopod" }),
        "left pleopod", "pleopod", ({ "apron", 20, 0 }),
        "right pleopod", "pleopod", ({ "apron", 20, 0 })
    });
    inedible = ({ "jaw", "carapace", "skull" });
    unrottable = ({ "jaw", "carapace", "skull" });
    set_skin( "shell" );
    set_stats( ({ -6, 4, -6, -4, -6 }) );
}
int query_eat( string type ) {
   return ( member_array( type, inedible ) == -1 );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
}
void set_unarmed_attacks( object thing ) {
    int number;
    number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
    number = 4 + sqrt( number );
    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );
    thing->remove_attack( "pincers" );
    thing->add_attack( "pincers", 100, ({ number, 10, number }),
        "unarmed", "unarmed", 0 );
    thing->add_attack_message( "pincers", "unarmed", ({
       20, "$N bat$s $I with $p pincer",
       60, "$N nip$s $P $z with $p pincer",
       100, "$N scratch$es $I deeply with $p pincer",
       140, "$N cut$s $P $z deeply with $p pincer",
       180, "$N dig$s $p pincer into $P $z",
       220, "$N gouge$s $I with $p pincer",
       0, "$N slice$s $P $z up with $p pincer" }) );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/crocodile.c
==================================================

inherit "/std/races/reptile_base";
void setup() {
   set_name( "crocodile" );
   set_long( "Any of several large voracious thick-skinned long-bodied "
      "aquatic reptiles (as of the genus Crocodylus) of tropical and "
      "subtropical waters.\n" );
   set_height( 30 );
   set_weight( 5000 );
   set_desc( "a crocodile, sharp of tooth and vicious of temper." );
   add_ac( "blunt", "blunt", 80 );
   add_ac( "pierce", "pierce", 80 );
   add_ac( "sharp", "sharp", 80 );
   set_stats( ({ 6, 4, -4, 8, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "tail" );
   thing->add_attack( "chew", 75, ({ 3 * number, number, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "tail", 75, ({ number, number, number }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/deer.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "deer" );
   set_long( "A medium-sized hoofed mammal.  Surprise.\n" );
   set_height( 250 );
   set_weight( 4000 );
   bits= ({
      "head", "head", ({ 0, 120, 0,
         "left eye", "right eye", "skull", "brain", "left ear",
         "right ear", "tongue" }),
      "left antler", "antler", ({ "head", 30, 0 }),
      "right antler", "antler", ({ "head", 30, 0 }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "cranium", ({ "head", 45, 0, "teeth" }),
      "brain", "brain", ({ "head", 20, 0 }),
      "left ear", "ear", ({"head", 4, 0 }),
      "right ear", "ear", ({"head", 4, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}) }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "tongue", "tongue", ({ "head", 9, 0 }),
      "neck", "neck", ({ 0, 120, 0 }),
      "torso", "body", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 35, 0 }),
      "liver", "liver", ({ "torso", 35, 0 }),
      "left kidney", "kidney", ({ "torso", 20, 0 }),
      "right kidney", "kidney", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 35, 0 }),
      "right lung", "lung", ({ "torso", 35, 0 }),
      "spleen", "spleen", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 75, 0 }),
      "pancreas", "pancreas", ({ "torso", 20, 0 }),
      "left front leg", "leg", ({ 0, 140, 0, "left front hoof" }),
      "left front hoof", "hoof", ({ "left front leg", 20, 0 }),
      "right front leg", "leg", ({ 0, 140, 0, "right front hoof" }),
      "right front hoof", "hoof", ({ "right front leg", 20, 0 }),
      "left rear leg", "leg", ({ 0, 160, 0, "left rear hoof" }),
      "left rear hoof", "hoof", ({ "left rear leg", 20, 0 }),
      "right rear leg", "leg", ({ 0, 160, 0, "right rear hoof" }),
      "right rear hoof", "hoof", ({ "right rear leg", 20, 0 }),
      "tail", "tail", ({ 0, 15, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "left front hoof", "right front hoof", "left antler", "right antler",
      "left rear hoof", "right rear hoof", "tail", "teeth", "tooth" });
   unrottable = ({ "skull", "left front hoof", "right front hoof", "left antler", "right antler",
      "left rear hoof", "right rear hoof", "teeth", "tooth" });
   set_desc( "a medium-sized, hairy quadruped.  It looks like a deer" );
   add_ac( "blunt", "blunt", 50 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 20 );
   set_skin( "skin" );
   set_stats( ({ 4, 4, -2, 6, -2 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "antlers" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "antlers", 40, ({ number, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ number / 2, 5, number }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/demon.c
==================================================

inherit "/std/races/demonic";
void setup() {
   set_long( "This is one of the denizens of the Underworld.\n" );
   set_name( "demon" );
   set_height( 250 );
   set_weight( 5000 );
   set_desc( "a nasty-looking demon" );
   add_ac( "fire", "fire", 100 );
   set_stats( ({ 10, 0, -2, 10, 4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 75, ({ 2 * number, 8, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 25, ({ 3 * number, 10, number }),
      "pierce", "unarmed", 0 );
}

==================================================
FILE: races/dog.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "dog" );
   set_long( "A street dog. I wouldn't stay too near, it could bite.\n" );
   set_desc( "a nasty dog" );
   set_height( 50 );
   set_weight( 700 );
   set_stats( ({ 4, 10, -2, 6, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", 40 );
   thing->add_ac( "sharp", "sharp", 20 );
   thing->add_ac( "pierce", "pierce", 10 );
   thing->add_skill_level( "other.perception", 200 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ ( 3 * number ) / 2, 5, number } ),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 2, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/duck.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "duck" );
   set_long( "Ducks.  That's all there is to say.  Ducks, ducks, ducks, "
      "ducks, ducks.  Thank you.\n" );
   set_weight( 80 );
   set_height( 30 );
   set_desc( "an ordinary brain-dead duck" );
   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );
   set_stats( ({ 0, 14, -6, -4, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "feet", 75, ({ number, 5, number / 2 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/duckling.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "duckling" );
   set_long( "Awwwwwwww it's SUCH a cute little duckling!\n" );
   set_weight( 10 );
   set_height( 15 );
   set_desc( "an cute ickle duckling" );
   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );
   set_stats( ({ 0, 14, -6, -4, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "feet", 75, ({ number, 5, number / 2 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/elephant.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "elephant" );
   set_long( "This is an elephant.  A large creature with a thick grey "
      "hide.  He seems to weigh a lot so don't let him step on your "
      "toe.\n" );
   set_height( 280 );
   set_weight( 100000 );
   set_desc( "an elephant that looks back at you with small nice eyes" );
   remove_bit( "nose" );
   remove_bit( "head" );
   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "skull", "tongue", "left ear", "right ear",
      "right tusk" "left tusk", "trunk" }) );
   add_bit( "right tusk", "tusk", ({ "head", 20, ({ "/std/bit", 2 }) }) );
   add_bit( "left tusk", "tusk", ({ "head", 20, ({ "/std/bit", 2 }) }) );
   add_bit( "trunk", "trunk", ({ "head", 30, 0 }) );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );
   remove_bit( "left front hoof" );
   remove_bit( "right front hoof" );
   remove_bit( "left rear hoof" );
   remove_bit( "right rear hoof" );
   add_bit( "left front leg", "leg", ({ 0, 150, 0, "left front foot" }) );
   add_bit( "right front leg", "leg", ({ 0, 150, 0, "right front foot" }) );
   add_bit( "left rear leg", "leg", ({ 0, 150, 0, "left rear leg" }) );
   add_bit( "right rear leg", "leg", ({ 0, 150, 0, "right rear leg" }) );
   add_bit( "left front foot", "foot", ({ "left front leg", 30, 0 }) );
   add_bit( "right front foot", "foot", ({ "right front leg", 30, 0 }) );
   add_bit( "left rear foot", "foot", ({ "left rear leg", 30, 0 }) );
   add_bit( "right rear foot", "foot", ({ "right rear leg", 30, 0 }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );
   inedible += ({ "tail", "right tusk", "left tusk" });
   unrottable += ({ "left tusk", "right tusk" });
   add_ac( "blunt", "blunt", ({ 40, 20}) );
   add_ac( "pierce", "pierce", ({ 30, 20 }) );
   add_ac( "sharp", "sharp", ({ 50, 20 }) );
   add_ac( "acid", "acid", 20 );
   add_ac( "fire", "fire", 20 );
   set_stats( ({ 30, -6, -4, 16, -2 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "tusks" );
   thing->remove_attack( "crush" );
   thing->remove_attack( "ram" );
   thing->add_attack( "tusks", 25, ({200, 10, 30}), "pierce", "unarmed", 0 );
   thing->add_attack( "crush", 10, ({300, 10, 50}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "crush", "unarmed", ({
     0, "$N stand$s on $p hind legs and attempt$s to crash down on $I",
      200, "$N stand$s on $p hind legs and crash$es down, striking $I "
       "a glancing blow",
      400, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z",
      5000, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z into a bloody mess" }) );
   thing->add_attack( "ram", 25, ({200, 10, 20}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "ram", "unarmed", ({
     0, "$N charge$s at $I",
      200, "$N charge$s $I and strike$s $I",
      400, "$N charge$s $I and strike$s $P $z hard, making $I stagger "
            "around",
      5000, "$N charge$s $I and strike$s $I to the ground.  $I "
            "stumbles around a little groggily" }) );
   thing->add_attack( "trunk", 50, ({100, 5, 20}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "trunk", "unarmed", ({
     0, "$N swing$s $p trunk at $I",
      200, "$N swing$s $p trunk at $I, hitting $P $z hard",
      400, "$N swing$s $p trunk, which thumps forcefully into $P $z",
      5000, "$N swing$s $p trunk at $I, nearly knocking $I down" }) );
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg", "left front foot",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front foot",
              "left rear leg", "left rear leg", "left rear foot",
              "right rear leg", "right rear leg", "right rear foot"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front foot";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear foot";
  default:
    return zone;
  }
}

==================================================
FILE: races/ferret.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "ferret" );
   set_long( "A small black white and grey animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );
   set_stats( ({ -2, 8, -2, -4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0  );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/fish.c
==================================================

inherit "/std/races/fish_base";
void setup() {
   set_name( "fish" );
   set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" );
   set_height( 15 );
   set_weight( 40 );
   set_desc( "a fish, the kind with fins" );
   set_stats( ({ -2, 14, -4, -4, -6 }) );
}
void check_water( object player ) {
   if( !environment( player )->query_water() )
      call_out( "do_drown", 4, player );
}
void do_drown( object player ) {
   int i;
   if( environment( player )->query_water() )
      return;
   tell_room( environment( player ) , player->one_short() + " gasps for "
      "air.\n" );
   i = player->query_max_hp() / 5;
   if( i < 20 ) i = 20;
   player->adjust_hp( -i );
   call_out( "do_drown", 4, player );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->add_property( "gills", 1 );
   thing->add_property("lives in water", 1);
   thing->add_enter_commands( (: check_water :) );
   thing->set_default_position( ({ "lying" }) );
   thing->return_to_default_position( 0 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 100, ({ 2 * number, 5, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/fish_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard fish.  This should not be used since it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 200, 0,
         "left eye", "right eye", "left gill", "right gill" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left gill", "gill", ({ "head", 50, 0 }),
      "right gill", "gill", ({ "head", 50, 0 }),
      "torso", "guts", ({ 0, 800, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 50, 0 }),
      "liver", "liver", ({ "guts", 50, 0 }),
      "left kidney", "kidney", ({ "guts", 25, 0 }),
      "right kidney", "kidney", ({ "guts", 25, 0 }),
      "spleen", "spleen", ({ "guts", 25, 0 }),
      "genitals", "genitals", ({ 0, 10, 0 }),
      "left petral fin", "fin", ({ 0, 100, 0, }),
      "right petral fin", "fin", ({ 0, 100, 0, }),
      "dorsal petral fin", "fin", ({ 0, 100, 0 }),
      "tail", "tail", ({ 0, 150, 0 })
   });
   inedible = ({ "left petral fin", "right petral fin", "dorsal petral fin",
      "tail" });
   unrottable = ({  });
   set_skin( "scales" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head",
              "body","body", "body", "body", "body", "body",
              "left petral fin", "right petral fin",
              "dorsal fin", "body",
              "body", "body",
              "body", "body",
              "body", "body", "body", "body", "body"
              "body", "body",
              "tail", "tail" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "head":
    return zone;
  case "arms":
    return (random(2) ? "left " : "right ") + "petral fin";
  case "hands":
    return "dorsal fin";
  case "feet":
    return "tail";
  default:
    return "body";
  }
}
int lives_in_water() { return 1; }

==================================================
FILE: races/fox.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "fox" );
   set_long( "A cat-like creature with red fur, hunts small, "
             "animals like mice and rabbits.\n" );
   set_height( 30 );
   set_weight( 400 );
   set_desc( "A small red fox" );
   set_stats( ({ 0, 10, -2, 4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks(object thing) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 100, ({ number / 2, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 2, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/frog.c
==================================================

inherit "/std/races/amphibian";
void setup() {
   set_name( "frog" );
   set_long( "Frogs are amphibians" );
   set_height(10);
   set_weight(10);
   set_desc( "an innocent little froggie" );
   add_ac( "blunt", "blunt", 5 );
   add_ac( "pierce", "pierce", 4 );
   add_ac( "sharp", "sharp", 3 );
   add_attack( "bite", 50, ({ 10, 2, 6 }) );
   set_sight( ({ 5, 20, 200, 300 }) );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/gnome.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "gnome" );
   set_long( "This is the race for gnomes.\n" );
   set_desc( "a short-looking gnome" );
   set_weight( 25 );
   set_height( 20 );
   set_sight( ({ 0, 5, 150, 200 }) );
   set_stats( ({ -2, 8, 0, 6, 0 }) );
}

==================================================
FILE: races/goat.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "goat" );
   set_long( "A cloven-hoofed, horned mammal closely related to the "
      "sheep.\n" );
   set_desc( "a cloven-hoofed, horned mammal" );
   set_weight( 800 );
   set_height( 80 );
   remove_bit( "head" );
   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "nose", "skull", "tongue", "left ear",
      "right ear", "left horn", "right horn" }) );
   add_bit( "left horn", "horn", ({ "head", 5, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 5, 0 }) );
   inedible += ({ "left horn", "right horn" });
   set_stats( ({ 4, 8, 0, 2, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );
   thing->remove_attack( "horns" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "horns", 60, ({ 21, 8, 11 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ 32, 10, 11 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/golem.c
==================================================

inherit "/std/races/humanoid";
#include <armoury.h>
void knock_out( object player, object golem );
void unarmed_hands( int damage, object him, object me, string a_type,
    string a_name );
object make_corpse();
void setup() {
    set_name( "golem" );
    set_long( "Golems are artifical shaped of clay to resemble humanoids and "
        "animated using religious rituals.  If they are actually alive is a "
        "question under constant debate.\n" );
    set_height( 200 );
    set_weight( 40000 );
    set_desc( "a tall, human-shaped creature made of clay" );
    add_property( "no scry", 1 );
    add_ac( "blunt", "pierce", ({150}) );
    add_ac( "pierce", "pierce", ({250}) );
    add_ac( "sharp", "sharp", ({250}) );
    add_ac( "fire", "fire", ({10000}) );
    add_ac( "cold", "cold", ({10000}) );
    add_ac( "acid", "acid", ({10000}) );
    add_ac( "magic", "magic", ({10000}) );
    set_sight( ({ 0, 5, 100, 125 }) );
    set_stats( ({ 30, 10, 0, 40, 0 }) );
}
varargs int query_ac( string type, int damage, string zone, int amount ) {
    object attacker, weapon;
    if( type == "blunt" )
        return amount;
    attacker = (object)previous_object()->query_attacker();
    if( attacker ) {
        weapon = (object)attacker->query_weapon();
        if( weapon && weapon != attacker )
            weapon->adjust_cond( -(int)weapon->query_cond() / 15 );
    }
    return amount;
}
object make_corpse() {
    object corpse, owner;
    owner = previous_object();
    corpse = ARMOURY->request_item( "golem corpse", 100 );
    all_inventory( owner )->move( corpse );
    return corpse;
}
void set_unarmed_attacks( object thing ) {
    if( !thing )
        return;
    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );
    thing->add_attack( "hands", 75, ({ 50, 10, 15 }),
        "blunt", "unarmed", ({ "unarmed_hands", this_object() }) );
}
void unarmed_hands( int damage, object him, object me, string a_type,
    string a_name ) {
    if( damage > 130 || damage >= him->query_hp() ) {
        damage = 0;
        knock_out( him, me );
    }
}
void knock_out( object player, object golem ) {
    object room, target;
    string *all_exits, *no_doors = ({ });
    string exit;
    int i;
    if( !player || !golem )
        return;
    player->stop_all_fight();
    golem->stop_fight( player );
    if( !( room = environment( golem ) ) )
        return;
    all_exits = room->query_dest_dir();
    for( i = 0; i < sizeof( all_exits ); i += 2 )
        if( !room->query_door( all_exits[i], "door" ) )
            no_doors += ({ all_exits[i + 1]  });
    target = load_object( no_doors[ random( sizeof( no_doors ) ) ] );
    tell_object( player,
        golem->the_short() + "' blow lifts you off your feet and hurls "
        "you through the air.\n"
        "You see the world race past you and then the ground approaching very "
        "fast.\n" );
    if( target ) {
        exit = all_exits[ member_array( file_name( target ), all_exits ) - 1 ];
        player->move( target,
            "$N come$s flying through the air from $F in a high arc and "
            "thump$s onto the ground.",
            "$N is lifted off " + player->query_possessive() + " feet by " +
            golem->the_short() + "'s blow and sail$s out of the room "
            "to the " + exit + "." );
    } else
        tell_room( room,
            player->the_short() + " is lifted off " +
            player->query_possessive() + " feet by " +
            golem->the_short() + "'s blow and smashes to the "
            "ground.\n", ({player}) );
    player->set_position( "lying on the ground unconscious" );
    player->add_property( "passed out", 1, ( 150 + random( 150 ) ) );
}
int stone_skinned() {
    return 1;
}

==================================================
FILE: races/guppy.c
==================================================

inherit "/std/races/fish_base";
void setup() {
   set_name( "guppy" );
   set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" );
   set_height( 15 );
   set_weight( 40 );
   set_desc( "a beautiful looking guppy" );
   set_stats( ({ -2, 14, -4, -4, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->add_property( "gills", 1 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/hare.c
==================================================

inherit "/std/races/lagomorpha_base";
void setup() {
   set_name( "hare" );
   set_long( "This is a hare with long ears.\n" );
   set_height( 50 );
   set_weight( 100 );
   set_desc( "a large and meaty hare" );
   set_stats( ({ -2, 8, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 6;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 75, ({ 0, 3, 5 }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/hedgehog.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "hedgehog" );
   set_long( "A snail and worm eating little bugger.\n" );
   set_height( 30 );
   set_weight( 150 );
   set_desc( "A small spiny hedgehog" );
   set_stats( ({ 2, -2, -4, -2, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 100, ({ number / 2, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 2, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
