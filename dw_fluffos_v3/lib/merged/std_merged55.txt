# Total Tokens: 14166
# Total Files Merged: 8
# Total Characters: 47243

se.c
==================================================

#include <player.h>
int alter_corpse( object corpse, object weapon, string attack ) {
  object head;
  string *heads;
  string behead_message = "";
  if (!attack) attack = "attack";
  switch (attack) {
    case "behead" :
      heads =
        this_object()->query_race_ob( this_object() )->query_possible_bits( "head" );
      if (sizeof(heads) == 0)
        break;
      head = corpse->make_bit(heads[random(sizeof(heads))] );
      head->move( environment( corpse ) );
      switch(random(6)) {
        case 0 : behead_message = head->a_short() +
          " drops onto the ground and rolls head over, well, head "
          "for a bit before coming to a rest.\n";
           break;
        case 1 : behead_message = head->a_short() +
          " sails through the air in a graceful arc before landing "
          "with a very soggy *squish*.\n";
          break;
        case 2 : behead_message = head->a_short() +
          " quivers a bit as it remains in place, perched atop its owner's "
          "corpse for a moment, then falls to pieces.\n";
          break;
        case 3 : behead_message = head->a_short() +
          " tips off to the left to hang by a small bit of flesh, before "
          "gravity has something to say about the matter and pulls it "
          "completely off the corpse, landing with a small bounce.\n";
          break;
        case 4 : behead_message = head->a_short() +
          " slides off its owner's corpse, upends, and lands upside "
          "down, helping to keep some of the blood from spilling.\n";
          break;
        case 5 : behead_message = head->a_short() +
          " drops onto the ground like a ball, *bouncy* *bouncy*.\n";
          break;
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        default : behead_message = "oops, the mushrooms have turned.\n";
      }
      tell_room( environment( corpse ), behead_message );
      break;
    default :
      break;
  }
  return 1;
}
object make_corpse() {
   int i;
   object corpse, *armour, *weapons, race;
   race = find_object(this_object()->query_race_ob());
   if(race && function_exists("make_corpse", race))
     return race->make_corpse();
   corpse = clone_object( "/obj/corpse" );
   corpse->set_owner( 0, this_object() );
   corpse->set_ownership( (string)this_object()->query_name() );
   if ( this_object()->query_property( "player" ) ) {
      corpse->add_property( "player", 1 );
   }
   corpse->set_race_name( (string)this_object()->query_race() );
   if ( !this_object()->query_race_ob() ) {
      corpse->set_race_ob( "/std/races/unknown" );
   } else {
      corpse->set_race_ob( (string)this_object()->query_race_ob() );
   }
   corpse->add_adjective( (string *)this_object()->query_adjectives() );
   corpse->add_adjective("dead");
   corpse->remove_adjective("living");
   corpse->start_decay();
   corpse->set_max_weight(this_object()->query_max_weight());
   corpse->set_length(this_object()->query_height() / 2);
   armour = (object *)this_object()->query_armours();
   this_object()->clear_armours();
   weapons = (object *)this_object()->query_weapons();
   all_inventory( this_object() )->set_tracked_item_status_reason( "DIED" );
   all_inventory( this_object() )->move( corpse );
   armour -= ({ 0 });
   for ( i = 0; i < sizeof( armour ); i++ ) {
      if ( environment( armour[ i ] ) != corpse ) {
         armour = delete( armour, i, 1 );
         i--;
      }
   }
   corpse->set_armours( armour );
   armour->set_worn_by( corpse );
   weapons -= ({ 0 });
   for ( i = 0; i < sizeof( weapons ); i++ ) {
      if ( environment( weapons[ i ] ) != corpse ) {
         weapons = delete( weapons, i, 1 );
         i--;
      }
   }
   corpse->set_holding( weapons );
   weapons->set_holder( corpse );
   return corpse;
}
mixed *death_helper(object thing, int death) {
   int shift, my_level, att_wimpy, att_level, xp, txp;
   string *messages;
   object *things, tmp;
   mixed *retval;
   retval = ({ });
   this_object()->remove_property(PASSED_OUT_PROP);
   this_object()->remove_hide_invis( "hiding" );
#ifdef USE_SURRENDER
   _surrender->refusers = ({ });
   _surrender->to = ({ });
#endif
   things = filter(this_object()->query_attacker_list(),
                   (:  living($1) && !$1->query_property("dead") :));
   if(environment()) {
     if (death) {
       messages = this_object()->query_property("death messages");
       if(!messages)
         messages = ({ "$K dealt the death blow to $D.\n",
                         "You killed $D.\n", "$D dies.\n" });
     } else {
       messages = this_object()->query_property( "surrender messages" );
       if (!messages)
         messages = ({ "$K accepted the surrender of $D.\n",
                         "You subdued $D.\n", "$D surrenders.\n" });
     }
     event( ({ environment() }) + deep_inventory( environment() ), "death",
            things, thing, (thing ? messages[0] : messages[2]), messages[1]);
   }
   if(sizeof(things)) {
     foreach(tmp in things) {
#if DEBUG == 2
       int x, y;
       x = tmp->query_al();
#endif
       shift = (int)this_object()->query_al() ;
       if (!death)
         shift -= (shift / 2);
       tmp->adjust_alignment(shift);
#if DEBUG == 2
       y = tmp->query_al();
       if(interactive(tmp))
         log_file("DEATH_ALIGN", "%s %s adjusted from %d to %d by %s [%d]\n",
                  ctime(time()), tmp->query_name(), x, y,
                  this_object()->query_name(), shift);
#endif
     }
     xp = this_object()->query_death_xp();
     if(xp > 0) {
       shift = 50 + xp / sizeof( things );
       debug_printf("%O Death XP: %O", this_object(), xp);
       my_level = this_object()->query_level();
       foreach(tmp in things) {
         att_wimpy = tmp->query_wimpy();
         att_level = tmp->query_level();
         if(att_level <= my_level)
           txp = shift / 2;
         else
           txp = ((shift/2) * my_level) / att_level;
         if(att_wimpy > 0)
           txp -= (txp * att_wimpy) / 100;
         tmp->adjust_xp(txp, 1);
       }
       return ({ ({ things }), shift/2 });
     }
   }
   return ({ });
}
varargs object do_death(object thing, object weapon, string attack) {
  object corpse, ob;
  mixed xp_leftover, sec_life;
#if DEBUG == 2
  combat_debug("Do death called.");
#endif
  this_object()->reset_callingdeath();
  if ( this_object()->query_property( "dead" ) ) {
    if ( !userp( this_object() ) ) {
      if(file_name(environment()) != "/room/rubbish") {
        this_object()->move("/room/rubbish");
      }
      return 0;
    }
    else
      return 0;
  }
  this_object()->end_combat();
  this_object()->add_property("xp before death", this_object()->query_xp());
  xp_leftover = death_helper(thing, 1);
  catch(sec_life = this_object()->second_life());
  if(sec_life) {
    if(xp_leftover && sizeof(xp_leftover) == 2 && xp_leftover[1] > 0) {
      foreach(ob in xp_leftover[0]) {
        ob->adjust_xp(xp_leftover[1], 1);
      }
    }
    this_object()->stop_all_fight();
    if( objectp( sec_life ) ) {
      return sec_life;
    } else {
      return 0;
    }
  }
  this_object()->add_property( "dead", time() );
  catch(DEATH->someone_died( this_object() ) );
  catch(this_object()->effects_thru_death() );
  this_object()->reset_protectors();
  if ( environment() ) {
    corpse = this_object()->make_corpse();
    if (corpse) {
      corpse->move(environment());
      corpse->add_property("XP", xp_leftover, 300);
      debug_printf("Command: %O", this_object()->query_last_action());
      if (!(alter_corpse( corpse, weapon, attack ))) {
      }
    }
  }
  this_object()->move( "/room/rubbish" );
  this_object()->stop_all_fight();
  return corpse;
}

==================================================
FILE: living/crafts.c
==================================================

private mixed _processes;
void create() {
   _processes = ([ ]);
}
mapping query_processes() {
   return _processes;
}
mapping query_processes_nocase() {
  mapping lc_processes = ([]);
  filter( this_object()->query_processes(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_processes );
  return lc_processes;
}
int add_process(string name, string ob) {
   _processes[name] = ob;
   return 1;
}
int remove_process(string name) {
  string process, name_lc;
  name_lc = lower_case(name);
  foreach (process in keys(_processes)) {
     if (lower_case(process) == name_lc) {
        map_delete(_processes, process);
     }
  }
  return 1;
}
string query_process( string word ) {
   return _processes[word];
}
protected void reset_processes() {
   _processes = ([ ]);
}

==================================================
FILE: living/effects.c
==================================================

#include <effect.h>
inherit "/std/basic/effects";

==================================================
FILE: living/force.c
==================================================

#include <player.h>
#define FORCE_COST 1
#define ILLEGAL_FORCE ({ "alias", "unalias", "mv", "mkdir", "call", "rm", \
                         "force", "kill", "gauge", "exec", "promote", \
                         "new_domain", "rmdir", "cd", "history", "echoall", \
                         "shout" })
nosave string fname;
nosave int no_force_me;
protected int no_force(string str);
protected int do_force(object *obs, string str);
void force_commands() {
  fname = base_name(this_object());
  if ((!this_object()->query_property("npc") &&
      master()->query_senior( geteuid(this_object()) ) ) || fname == LORD_OB) {
    add_command("force", "<indirect:distant-living> <string'command'>",
                (: do_force($1, $4[1]) :));
 }
  if (fname == LORD_OB) {
    add_command("noforce", "{on|off}", (: no_force($4[0]) :));
    add_command("noforce", "", (: no_force(0) :));
  }
}
protected int no_force(string str) {
  if (str == "on") {
    no_force_me = 1;
    write("Ok, forcing you disabled.\n");
    return 1;
  }
  if (str == "off") {
    no_force_me = 0;
    write("Ok, forcing you enabled.\n");
    return 1;
  }
  write("Forcing you is currently ");
  if (no_force_me) {
    write("disabled.\n");
  }
  else {
    write("enabled.\n");
  }
  return 1;
}
protected int do_force(object *obs, string str) {
  object ob;
#ifdef PLAYERS_CAN_FORCE
  if (fname == PLAYER_OB && !this_player()->query_property("force")) {
    notify_fail("You do not have the ability to do that yet.\n");
    return 0;
  }
  if (this_player()->adjust_social_points(-FORCE_COST) < 0) {
    notify_fail("Insufficient social points.\n");
    return 0;
  }
#endif
  foreach( ob in obs ) {
    if(!ob->do_force_on_me( str )) {
      write(capitalize( ob->query_name() ) + " didn't want to do that.\n");
    }
  }
  write("Ok.\n");
  return 1;
}
nomask int do_force_on_me(string str) {
  string temp1, temp2;
  object forcer;
  forcer = this_player(1);
  if (!forcer || (this_player() != previous_object())) {
    if (interactive(previous_object())) {
      forcer = previous_object();
    } else {
      log_file("FORCE", "Attempted illegal force from "+
               file_name(previous_object())+"\n");
      return 0;
    }
  }
  log_file("FORCE", ctime(time()) + " " + forcer->query_name() + " " +
                    this_object()->query_name() + " : " + str);
  tell_object(this_object(), forcer->query_cap_name() +
        " tries to force you to " + str + "\n");
  if (no_force_me || (string)this_object()->query_name() == "pinkfish") {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (sscanf(str, "%s %s", temp1, temp2) != 2) {
    temp1 = str;
  }
  if (member_array(temp1, ILLEGAL_FORCE) != -1 &&
      !master()->high_programmer(geteuid(forcer))) {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (function_exists("eventForce", this_object())) {
    command(str);
  } else {
    this_object()->eventForce(str);
  }
  event(users(), "inform", forcer->query_cap_name()+" forces "+
        this_object()->query_name()+" to "+str, "force");
  log_file("FORCE", " (succeeded)\n");
  return 1;
}

==================================================
FILE: living/gender.c
==================================================

int gender;
nosave int womens_day;
int query_female() { return (gender == 2) || womens_day; }
int query_gender() { return (womens_day?2:gender); }
int query_male() { return gender == 1 && !womens_day; }
int query_neuter() { return !gender && !womens_day; }
string query_gender_string() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "male";
    else return "female";
}
string query_gender_title() {
    if (!gender && !womens_day) return "creature";
    else if (gender == 1 && !womens_day) return "sir";
    else return "madam";
}
string query_gender_name() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "man";
    else return "woman";
}
string query_objective() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "him";
    else return "her";
}
string query_possessive() {
    if (!gender && !womens_day)
        return "its";
    else if (gender == 1 && !womens_day)
        return "his";
    else return "her";
}
string query_pronoun() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "he";
    else return "she";
}
void set_gender(mixed arg) {
  if(stringp(arg)) {
    if(arg == "male")
      gender = 1;
    else if(arg == "female")
      gender = 2;
    else
      gender = 0;
  } else {
    gender = arg;
  }
}
void set_womens_day(int bing) {
  womens_day = bing;
}
int query_womens_day() {
    return womens_day;
}
nomask int query_real_gender() {
   return gender;
}

==================================================
FILE: living/health.c
==================================================

#include <drinks.h>
#include <living.h>
#undef POINTS_LOG
#ifdef USE_SURRENDER
#define SURRENDER_SHADOW "/std/shadows/misc/surrender_shadow"
#endif
varargs int adjust_xp( int number, int shared );
int hp, max_hp, gp, max_gp, xp, wimpy, *drink_info;
#ifdef USE_SURENDER
int surrender;
#endif
nosave int max;
nosave int* runaway_callout_handles;
nosave string which;
nosave mapping counts;
mapping verbs;
nosave int callingdeath;
void create() {
   max_hp = 1;
   max_gp = 1;
#ifdef USE_SURRENDER
   surrender = -1;
#endif
   drink_info = allocate( D_SIZEOF );
   counts = ([ ]);
   verbs = ([ ]);
   callingdeath = 0;
   runaway_callout_handles = ({ });
}
int query_hp() { return hp; }
varargs int set_hp( int number, object attacker ) {
   if ( number > max_hp )
      number = max_hp;
   hp = number;
   if ( ( hp < 0 ) && ( find_call_out( "do_death" ) == -1 ) )
      call_out( "do_death", 0, attacker );
   return hp;
}
protected int check_wimpy() {
    int hp;
    hp = this_object()->query_hp();
    if ( hp < 1 )
        return 0;
    if( 100 * hp < this_object()->query_wimpy() *
        this_object()->query_max_hp()) {
        if(find_call_out("run_away") == -1) {
            runaway_callout_handles += ({ call_out("run_away", 0) });
        }
        return 1;
    }
    return 0;
}
#ifdef USE_SURRENDER
protected int check_surrender() {
   int hp;
   object *attackers, *all, shad;
   hp = this_object()->query_hp();
   if (hp < 1)
      return 0;
   if (hp * 100 < this_object()->query_surrender() *
       this_object()->query_max_hp()) {
     attackers = filter(this_object()->query_attacker_list(),
                        (: $1 && !$1->query_property("dead") &&
                         environment($1) == environment($2) :),
                        this_object());
     all = attackers + ({ this_object() });
     all->event_surrender(this_object(), attackers);
     shad = clone_object(SURRENDER_SHADOW);
     if (shad) {
       shad->setup_shadow(this_object(), attackers);
     }
     return 1;
   }
   return 0;
}
#endif
void reset_callingdeath() {
  callingdeath = 0;
}
int query_callingdeath() {
    return callingdeath;
}
varargs int adjust_hp(int number, object attacker, object weapon,
                      string attack) {
    int i;
    hp += number;
    if ( hp > max_hp )
        hp = max_hp;
    if (hp <= 0 && !callingdeath) {
        callingdeath = time();
        call_out("do_death", 0, attacker, weapon, attack);
        for( i=0; i<sizeof(runaway_callout_handles); i++ ) {
            remove_call_out( runaway_callout_handles[i] );
        }
        runaway_callout_handles = ({ });
    }
    if (hp > 0 && number < 0 && attacker && attacker != this_object()) {
#ifdef USE_SURRENDER
        if(this_object()->query_surrender() >= this_object()->query_wimpy()) {
            if (!check_surrender())
                check_wimpy();
        }
        else {
            if (!check_wimpy())
                check_surrender();
        }
#else
        check_wimpy();
#endif
    }
    return hp;
}
varargs string health_string(int flag, int ref health_level) {
   int level;
   string ret;
   if ( this_object()->query_property( "dead" ) )  {
      ret = "appears to be dead";
      level = 0;
   }
   else if ( hp < max_hp / 10 )  {
      ret = "is in very bad shape";
      level = 1;
   }
   else if ( hp < max_hp / 5 )  {
      ret = "is in bad shape";
      level = 2;
   }
   else if ( hp < max_hp / 2 )  {
      ret = "is not in good shape";
      level = 3;
   }
   else if ( hp < ( max_hp - 200 ) )  {
      ret = "is slightly hurt";
      level = 4;
   }
   else  {
      ret = "is in good shape";
      level = 5;
   }
   if (!undefinedp(flag))   health_level = level;
   return ret;
}
int query_max_hp() { return max_hp; }
int set_max_hp( int number ) {
  int old_hp;
  old_hp = hp;
  if ( max_hp == hp )
    hp = number;
  else
    if ( max_hp )
      hp = ( hp * number ) / max_hp;
    else
      hp = number;
  max_hp = number;
  if ( hp > max_hp )
    hp = max_hp;
  if ( ( hp < 0 ) && ( old_hp > 0 ) )
    hp = max_hp;
  return max_hp;
}
int query_gp() { return gp; }
int query_specific_gp( string gp_type ) {
   int now;
   if ( !gp_type )
      return 0;
   max = (int)this_object()->query_skill_bonus( gp_type
         +".points" ) + 50;
   if ( max >= max_gp )
      max = max_gp;
   now = gp + max - max_gp;
   which = gp_type;
   if ( find_call_out( "clear_gp_info" ) == -1 )
      call_out( "clear_gp_info", 1 );
   return now;
}
void clear_gp_info() { which = 0; }
int set_gp( int number ) {
   gp = number;
   if ( gp > max_gp )
      gp = max_gp;
   return gp;
}
int adjust_gp( int number ) {
  int tmp, diff;
  string guild_ob, current_verb;
  mixed *bits;
  if ( gp + number < 0 )
    return -1;
  gp += number;
  if ( gp > max_gp )
    gp = max_gp;
  tmp = number;
  if((number < 0) && stringp(which)) {
    if (number > ( GP_ADVANCE_MOD * max ) / MIN_TIMES)
      number = (GP_ADVANCE_MOD * max) / MIN_TIMES;
    counts[ which ] -= number;
    if (counts[ which ] > GP_ADVANCE_MOD * max) {
      counts[ which ] = 0;
      number = this_object()->query_skill(which +".points");
      if(!random(to_int(exp(number/150.0))) &&
         this_object()->add_skill_level( which +".points", 1,
                                         this_object())) {
        tell_object( this_object(), "%^YELLOW%^You find yourself "
                     "more able to concentrate on this task than you "
                     "thought.%^RESET%^\n" );
      }
#ifdef POINTS_LOG
      log_file( "POINTS", time() +" "+
                (string)this_object()->query_name() +" gets "+
                which +" ("+ max +")\n" );
#endif
    }
    number = tmp;
    guild_ob = this_object()->query_guild_ob();
    if(guild_ob && member_array(query_verb(), guild_ob->query_commands()) != -1)
      number *= -10;
    else
      number *= -4;
    if(query_verb() == "pray" || query_verb() == "berserk" ||
       query_verb() == "spellcheck" || query_verb() == "octograve")
      number /= 2;
    current_verb = query_verb();
    if(current_verb == "cast" || current_verb == "perform") {
      current_verb = this_object()->query_current_cmd();
    }
    if(verbs[current_verb]) {
      bits = verbs[current_verb];
      diff = time() - bits[0];
      if(diff > 300)
        bits[1] /= 2;
      if(bits[1] < 1)
        bits[1] = 1;
      if(bits[1] > 1 && bits[2] == environment())
        bits[1] += 1;
      if(bits[1] < 10)
         number /= (random(bits[1]) + 1);
      else
        number = 0;
      verbs[current_verb] = ({ time(), bits[1]+1, environment() });
    } else {
      verbs[current_verb] = ({ time(), 1, environment() });
    }
    if(number)
      adjust_xp(number, 1);
#ifdef GUILD_XP
    log_file("GUILD_XP", "%s Gave %s %d points for %s [%s, %d]\n",
             ctime(time()), this_object()->query_name(), number,
             current_verb, verbs[current_verb][0], verbs[current_verb][1]);
#endif
  }
  return gp;
}
int query_max_gp() { return max_gp; }
int set_max_gp( int number ) {
  if ( max_gp ) gp = ( gp * number ) / max_gp;
  else gp = number;
  max_gp = number;
  if ( gp > max_gp ) gp = max_gp;
  return max_gp;
}
int query_xp() { return xp; }
varargs int adjust_xp( int number, int shared ) {
  if(number > 0 && (xp > 10000000 || xp + number > 10000000))
    return xp;
  if(number > 10000 && previous_object() &&
     explode(file_name(previous_object()), "/")[0] == "w")
    log_file("/d/admin/log/CHEAT", ctime(time()) + " " +
             file_name(previous_object()) +
             " gave " + number + " Xp for " + this_object()->query_name() +
             "\n");
   xp += number;
   return xp;
}
int query_wimpy() { return wimpy < 30 ? wimpy : 30; }
int set_wimpy( int number ) {
  if ( ( number < 0 ) || ( number > 30 ) ) return -1;
  return wimpy = number;
}
#ifdef USE_SURRENDER
int query_surrender() {
  if (surrender == -1) {
    if (wimpy > 94)
      return 100;
    else
      return wimpy + 5;
  } else
    return surrender;
}
int set_surrender( int number ) {
  if ( ( number < 0 ) || ( number > 100 ) ) return -1;
  return surrender = number;
}
#endif
int *query_drink_info() { return drink_info; }
int query_volume( int type ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ];
}
int adjust_volume( int type, int amount ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ] += amount;
}
void update_volumes() {
  int i, delta;
  delta = (int)this_object()->query_con();
  for ( i = 0; i < sizeof( drink_info ); i++ ) {
    if ( drink_info[ i ] > delta ) {
      drink_info[ i ] -= delta;
      if(this_object()->query_personal_temp() >  0 && i == D_DRINK)
  this_object()->adjust_personal_temp(-(delta/3));
      else if(this_object()->query_personal_temp() <  0 && i == D_FOOD)
  this_object()->adjust_personal_temp(delta/3);
    } else
      if ( drink_info[ i ] < -delta )
        drink_info[ i ] += delta;
      else
        drink_info[ i ] = 0;
  }
}
mapping query_counts() { return counts; }

==================================================
FILE: living/holding.c
==================================================

nosave mixed *_using;
nosave mixed *_weapons;
#define START_VALUE "1"
int *set_hold(object ob, int location, int limbs);
int *set_unhold(object ob);
private int sub_hold(object ob, int pos, int first);
void create()
{
   _weapons = ({ });
}
string *query_limbs()
{
   string race_ob;
   string *limbs;
   race_ob = this_object()->query_race_ob();
   if (!race_ob) {
      _using = ({ });
      return ({ });
   }
   limbs = race_ob->query_limbs();
   if (!_using) {
      _using = allocate(sizeof(limbs));
   }
   return limbs;
}
string* query_using_array() {
   return copy(_using);
}
object *query_holding()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   _using =
      map(_using, (: $1 ? (environment($1) == this_object()? $1 : 0) : 0 :));
   return copy(_using);
}
string* query_holding_limbs(object ob) {
   string* ret;
   int i;
   object* holding;
   string* limbs;
   ret = ({ });
   holding = query_holding();
   limbs = query_limbs();
   for (i = 0; i < sizeof(holding); i++) {
      if (holding[i] == ob) {
         ret += ({ limbs[i] });
      }
   }
   return ret;
}
int query_free_limbs()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   return
      sizeof(filter(_using, (: !$1 || environment($1) != this_object() :)));
}
object *query_weapons()
{
   return filter(_weapons, (: $1 :));
}
int *set_unhold(object ob)
{
   int *pos;
   if (!objectp(ob)) {
      return ({ });
   }
   if (member_array(ob, _using) == -1) {
      return ({ });
   }
   if (!ob->set_holder(0)) {
      return ({ });
   }
   pos = find_member(ob, _using);
   if (ob->query_weapon()) {
      _weapons = filter(_weapons, (: $1 != $(ob) :));
   }
   if (ob->query_armour()) {
      this_object()->remove_armour(ob);
   }
   _using = map(_using, (: $1 == $(ob) ? 0 : $1 :));
   this_object()->do_burden_call();
   return pos;
}
int *set_hold(object ob, int pos, int limbs)
{
   int limb_count;
   int *free = ({ });
   int *used = ({ });
   int total = 0;
   int temp = 0;
   int ok;
   int failed;
   if (environment(ob) != this_object()) {
      debug_printf("Bad environment");
      return ({ });
   }
   limb_count = sizeof(this_player()->query_limbs());
   if (!arrayp(_using)) {
      query_limbs();
   }
   if (pos == -1) {
      total = ob->query_no_limbs();
      if (total > this_object()->query_free_limbs()) {
         debug_printf("Too many limbs");
         return ({ });
      }
      free = find_member(0, _using);
      if (!sizeof (free)) {
        return ({ });
      }
      pos = free[0];
   }
   if (objectp(_using[pos]) && environment(_using[pos]) == this_object()) {
      return ({ });
   }
   ok = sub_hold(ob, pos, 1);
   if (ok) {
      used += ({ pos });
   } else {
      return ({ });
   }
   if(limbs)
     total = limbs - 1;
   else
     total = ob->query_no_limbs() - 1;
   free = find_member(0, _using);
   temp = 0;
   while (temp < total && temp < sizeof(free)) {
      if (temp > limb_count) {
         set_unhold(ob);
         return ({ });
      }
      sub_hold(ob, free[temp], 0);
      if (ok) {
         used += ({ free[temp] });
         temp++;
      } else {
         failed = 1;
      }
   }
   if (failed) {
      set_unhold(ob);
      return ({ });
   } else {
     this_object()->do_burden_call();
      return used;
   }
}
private int sub_hold(object ob,
                     int pos,
                     int first)
{
   int success;
   if (environment(ob) != this_object()) {
      return 0;
   }
   if (first) {
      success = ob->set_holder(this_object(), pos);
      if (!success) {
         return 0;
      }
   }
   _using[pos] = ob;
   if (ob->query_weapon()) {
      if (member_array(ob, _weapons) == -1) {
         _weapons += ({ ob });
      }
   }
   return 1;
}

==================================================
FILE: living/living.c
==================================================

#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger", "errors", "quit"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }
