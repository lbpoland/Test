# Total Tokens: 17419
# Total Files Merged: 39
# Total Characters: 58175

p_topics/objects/container_save.c
==================================================

#include "path.h"
inherit "/std/room";
object shelf, wardrobe;
void setup() {
   set_short("room of shelf and wardrobe examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of how to make shelves, "
            "wardrobes and such that'll save the content for you.\n"
            "To make a shelf, which is characterized by having a surface "
            "you can put things on, you make a clone of /obj/surf_save, "
            "configure it like all cloned objects, and call set_save_file( "
            "file_name ) do tell what file should be used to save the "
            "objects that are put on it.  If the savefile isn't in /save/ "
            "you should call check_euid() on the shelf before calling "
            "set_save_file().\n"
            "Making a wardrobe, you do the same, except you that it is "
            "/obj/cont_save you should clone.\n"
            "Note that since these are fixed parts of the room, and not "
            "something that is put here, I clone them directly in reset() "
            "instead of doing a call_out() to a function that makes them.\n" );
   set_light( 100 );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "check_euid", "set_save_file" }) );
   add_property( "keywords",
                ({ "shelf", "wardrobe", "save" }) );
}
void reset() {
   if (!shelf) {
      shelf = clone_object("/obj/surf_save");
      shelf->set_name( "shelf" );
      shelf->set_short( "oaken shelf" );
      shelf->add_adjective( "wooden" );
      shelf->add_adjective( "oak" );
      shelf->add_adjective( "oaken" );
      shelf->add_property( "there", "hanging from the wall" );
      shelf->set_long( "This shelf is made from oak and "
                      "varnished to bring out the glow.\n" );
      shelf->set_weight( 2000 );
      shelf->set_max_weight( 2000 );
      shelf->reset_get();
      shelf->check_euid();
      shelf->set_save_file( SAVEPATH+"/oak_shelf" );
      shelf->move( this_object() );
   }
   if (!wardrobe) {
      wardrobe = clone_object("/obj/cont_save");
      wardrobe->set_name( "wardrobe" );
      wardrobe->set_short( "oaken wardrobe" );
      wardrobe->add_adjective( "wooden" );
      wardrobe->add_adjective( "oaken" );
      wardrobe->add_adjective( "oak" );
      wardrobe->set_long( "This wardrobe is made from oak and "
                         "varnished to bring out the glow.\n" );
      wardrobe->set_weight( 2000 );
      wardrobe->set_max_weight( 2000 );
      wardrobe->reset_get();
      wardrobe->check_euid();
      wardrobe->set_save_file( SAVEPATH+"/wardrobe" );
      wardrobe->move( this_object() );
   }
}

==================================================
FILE: learning/help_topics/objects/path.h
==================================================

#include <learning.h>
#define PATH HELP + "objects/"

==================================================
FILE: learning/help_topics/objects/vessel.c
==================================================

#include "path.h"
inherit "/std/room";
object wine_bottle, glass, cup;
void setup() {
   set_short("room of vessel and liquid examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of using vessels.  "
            "There should be a wine bottle, a wine glass, and a "
            "coffee cup in here.  There are also a few usage notes "
            "on the wall (\"read note1\", \"read note2\", etc).\n" );
   set_light( 100 );
   add_item( "note1",
            ({ "long", "This note describes how to use the vessels.",
               "read", "The vessels all have the following commands: "
                   "pour, fill, drink, empty.  There are a few others, "
                  "but they're mainly carry-overs from the old "
                  "container code, and probably don't work correctly.  "
                  "Try pouring from one object to another, drinking, etc.  "
                  "Try mixing equal parts of wine and Klatchian coffee.  "
                  "Use the \"stat\" command to check on the volumes (eg, "
                  "\"stat bottle\", \"stat all in cup\").  If you want "
                  "to start over with a fresh vessel, dest it and "
                  "\"call reset() here\".\n"
            }) );
   add_item( "note2",
            ({ "long", "This is a little note on liquid units of measure.",
               "read", "The base unit for a liquid is the drop.  Four "
                  "drops is roughly 1 cc, and 200 drops of water weighs "
                  "one Discworld weight unit.  Here are some common "
                  "amounts (I believe these are all British measures, "
                  "but I could have made an error):\n"
                  "    1 teaspoon =      20 drops\n"
                  "    1 tablespoon =    60 drops\n"
                  "    1 ounce =        120 drops\n"
                  "    1 cup =          960 drops\n"
                  "    1 pint =        2400 drops\n"
                  "    1 quart =       4800 drops\n"
                  "    1 gallon =     19200 drops\n"
            }) );
   add_item( "note3",
            ({ "long", "This is a note on adding effects to food, "
                  "especially liquids.",
               "read", "To add an effect to food so that it will be "
                  "applied to the player when consumed, use "
                  "add_eat_effect(<effect>, <arg>).  <arg> (which "
                  "should be an integer) is multiplied by the weight "
                  "of the amount consumed; for liquids, this is generally "
                  "200 drops per weight unit.\n\n"
                  "For example, the wine in the wine bottle adds the "
                  "drunk effect; a final <arg> of 3900 for this effect "
                  "will last 10 minutes on a player with constitution 13 "
                  "(trust me on this).  If we want one pint (2400 drops) "
                  "of wine to have this effect, the <arg> to "
                  "add_eat_effect() should be 3900/(2400/200), or "
                  "325.\n"
            }) );
   add_item( "note4",
            ({ "long", "This is a note on using continuous objects.",
               "read", "Continuous objects (those derived from "
                  "/obj/cont_medium, such as /obj/food) are a way "
                  "to have multiple identical instances of an item "
                  "without having to have a clone for each one.  Each "
                  "unique continuous object is identified by its "
                  "\"medium alias\".  The medium alias must be a single "
                  "word without embedded spaces; by convention, it is "
                  "made by concatenating a series of capitalized words "
                  "that describe it, such as \"RedWine\" or "
                  "\"GroundPurpleMushroom\".  All objects with a common "
                  "medium alias in the same environment are combined "
                  "into a single object.  Also, the reaction handler "
                  "uses the medium alias to identify objects that "
                  "react with one another.\n"
            }) );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "make_bottle", "add_eat_effect", "set_medium_alias",
                   "set_max_weight", "set_max_volume" }) );
   add_property( "keywords",
                ({ "bottle", "vessel", "liquid" }) );
}
void reset() {
   call_out( "check_vessels", 3 );
}
void check_vessels() {
   object wine, coffee;
   if ( !wine_bottle || ( environment( wine_bottle ) != this_object() ) ) {
      wine_bottle = clone_object( "/obj/bottle" );
      wine_bottle->make_bottle( "green", 600 );
      wine_bottle->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again." );
      wine = clone_object( "/obj/reagents/generic_liquid.ob" );
      wine->set_name( "wine" );
      wine->set_short( "red wine" );
      wine->set_long( "This is a deep red wine, $amount_size$.\n");
      wine->set_medium_alias( "RedWine" );
      wine->add_adjective( "red" );
      wine->add_eat_effect( "/std/effects/ingested/drunk", 325 );
      wine->set_amount( 2400 );
      wine->move( wine_bottle );
   }
   if ( !glass || ( environment( glass ) != this_object() ) ) {
      glass = clone_object( "/obj/vessel" );
      glass->set_name( "glass" );
      glass->set_short( "wine glass" );
      glass->set_long( "This is a fine crystal wine glass.\n" );
      glass->set_weight( 4 );
      glass->set_max_weight( 8 );
      glass->set_max_volume( 480 );
      glass->add_adjective( ({ "crystal", "wine" }));
      glass->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again.");
   }
   if ( !cup || ( environment( cup ) != this_object() ) ) {
      cup = clone_object( "/obj/vessel" );
      cup->set_name( "cup" );
      cup->set_short( "coffee cup" );
      cup->set_long( "This is a delicate china coffee cup.  The intricate "
                    "artwork on the side depicts some sort of sexual "
                    "orgy.  Why it's on a coffee cup is beyond me.\n" );
      cup->set_weight( 4 );
      cup->set_max_weight( 8 );
      cup->set_max_volume( 960 );
      cup->add_adjective( ({ "china", "coffee" }) );
      cup->move( this_object(), "Jeremy walks into the room and "
                "leaves $N before walking out again." );
      coffee = clone_object( "/obj/reagents/generic_liquid.ob" );
      coffee->set_name( "coffee" );
      coffee->set_short( "coffee" );
      coffee->set_long( "This is some Klatchian coffee, $amount_size$.  "
                       "It is very dark and aromatic.\n" );
      coffee->set_medium_alias( "KlatchianCoffee" );
      coffee->add_adjective( "klatchian" );
      coffee->add_eat_effect( "/std/effects/ingested/knurd", 325 );
      coffee->set_amount( 960 );
      coffee->move( cup );
   }
}

==================================================
FILE: learning/functions/function_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string function_chosen;
void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", PATH +"functions", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return function_chosen;
}
void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s",
                     exit_letter,
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/functions/path.h
==================================================

#include <learning.h>
#define PATH FUNCTIONS

==================================================
FILE: learning/examples/player_houses/npcs/surface_decorator.c
==================================================

inherit "/std/npc/surface_decorator";
void setup() {
    set_name( "worker" );
    set_short( "construction worker" );
    add_property( "determinate", "a " );
    add_adjective( "construction" );
    add_property( "unique", 1 );
    setup_nationality( "/std/nationality/agatean", "Bes Pelargic" );
    basic_setup( "human", "warrior", 30 );
    set_gender( 1 );
    set_long("This is a construction worker.  You can use him to "
        "decorate surfaces in player housing to the exact specifications "
        "that you will set later in this file.  He is slightly grubby, "
        "is covered in dust and paint, and likes to do wolf whistles.\n");
    add_property( "place", "Counterweight Continent" );
    add_allowed_surface( "floor" );
    add_allowed_surface( "wall" );
    add_fitted_surface( "plush green carpet", "covered with plush "
        "green carpet", 1000 );
    add_fitted_surface( "plush red carpet", "covered with plush "
        "red carpet", 1000 );
    add_fitted_surface( "plush yellow carpet", "covered with plush "
        "yellow carpet", 1000 );
    add_fitted_surface( "plush blue carpet", "covered with plush "
        "blue carpet", 1000 );
    set_under_construction_mess( "covered in dust, plaster and carpet bits" );
    add_allowed_domain( "/w/una" );
    add_allowed_domain( "/d/cwc/Bes_Pelargic" );
    set_responses( ({
        "'I don't fit those kinds of surfaces matey!",
        "'I've never heard of those sort of carpets, arrrrr.",
        "'Arr, you don't own this place, mister!",
        "'I can't be decoratin' these here surfaces, shogun!  You should "
        "take me to a house!",
        "'Arr matey, something went horribly wrong!",
        "'Arrrr matey, all done!",
        "'You don't have enough money to pay for the $decor$!  It "
        "will cost you $amount$, guv!",
        "'I can fit $allowed$ with any of the following:",
        "'Cor blimey mister, I haven't got any stock.",
        "'Okey doke, I'll have it done in a jiffy guv'nor!",
        "'What?  Who sed dat?",
        "'I've already got this great job with $employer$, mate!",
        "'Righty-o, you just take me to the room you want spiffied "
        "up and ask me to fit something!",
        "'Sorry matey, bad karma over that way."
    }) );
}

==================================================
FILE: learning/examples/terrain_map/basic/entrance.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("field entrance");
  set_long("You are at the entrance to a large grassy field.\n");
  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
  add_exit("north", __DIR__ + "path:2:0", "road");
}

==================================================
FILE: learning/examples/terrain_map/basic/field.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("grassy field");
  set_long("This is a large grassy field.\n");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}

==================================================
FILE: learning/examples/terrain_map/basic/field_handler.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_HANDLER_BASE;
string query_map_file() { return __DIR__ + "field"; }
void  setup_handler()
{
   add_obstacle_type("*", "A tall fence blocks your way to the $D.",
                "fence", "A tall, unclimable wooden fence.");
   add_room_type(".", __DIR__ + "field");
   add_road_type(",", __DIR__ + "path",
            "The path meanders $D.",
            "A small path meanders its way across the field to the $D.",
            "path",
            "The path has been trampled down by the hooves of time.");
   add_feature("bigtree", 4, 1, 1, 1, 4,
                ({ "A giant tree towers over you to the $D.",
                   "A little way to the $D, you can see a huge tree.",
                   "You can just make out a large tree, a way off in an "
                   "$Derly direction." }),
                   "tree", "A fairly large, and quite beautiful tree." );
   set_feature_chats("bigtree",
                     ({ "The branches on the tree to the $D "
                        "sway slightly in the breeze." }) );
   add_exit_at(2, 0, "south", __DIR__ + "entrance", "road");
}

==================================================
FILE: learning/examples/terrain_map/basic/path.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("trampled path");
  set_long("This path meanders through a large grassy field.\n");
  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}

==================================================
FILE: learning/examples/npcs/barley.c
==================================================

inherit "/obj/monster";
void setup() {
    set_name( "barley" );
    set_short( "Barley" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Barley is a friendly, talkative NPC.  He chats and emotes."
    "  Also, he will occasionally give out quest hints.  If you try and"
    " kill him, he will become more animated.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  3, "'I say this quite often.",
                  3, ":does this quite often.",
                  3, "Chats can appear without the NPC name in them.",
                  1, "'I only give out quest hints 10% of the time."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
}

==================================================
FILE: learning/examples/npcs/cuthbert.c
==================================================

#include <armoury.h>
#define TO this_object()
inherit "/obj/monster";
object cape, trousers;
void setup() {
    set_name( "cuthbert" );
    set_short( "Cuthbert" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Cuthbert is a fashion victim.  Not content with off the peg "
    "stuff, he wants clothing unique to him.  Fair enough, let's give him"
    " some.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
         ARMOURY->request_item( "short sword",
         70+random(30))->move( TO );
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move( TO );
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move( TO );
   trousers = clone_object( "/obj/clothing" );
   trousers->set_name( "britches" );
   trousers->add_adjective(({"pair", "of"}));
   trousers->set_short( "pair of britches" );
   trousers->add_alias("trousers");
   trousers->set_long( "These are funky purple flaired britches, made of camel"
   "skin with beaver fur lining.\n" );
   trousers->set_value( 100 );
   trousers->set_weight( 7 );
   trousers->set_type( "trousers" );
   trousers->add_pocket( "side", 100 );
   trousers->add_pocket( "side", 100 );
   trousers->set_damage_chance( 10 );
   trousers->set_max_cond( 800 );
   trousers->set_cond( 600 + random( 200 ) );
   trousers->move( TO );
         cape = clone_object( "/obj/clothing" );
   cape->set_name( "cape" );
   cape->set_short( "orange cape" );
   cape->add_adjective("orange");
   cape->set_long( "Orange velvet has been made into a large cape.  It is bright "
   "and garish.\n" );
   cape->set_value( 100 );
   cape->set_weight( 7 );
   cape->set_type( "cape" );
   cape->set_damage_chance( 10 );
   cape->set_max_cond( 800 );
   cape->set_cond( 600 + random( 200 ) );
   cape->move( TO );
      init_equip();
         give_money( 10, 30, "Ankh-Morpork pence" );
}

==================================================
FILE: learning/examples/npcs/macgrew.c
==================================================

#include <armoury.h>
#define TO this_object()
inherit "/obj/monster";
void setup() {
    set_name( "macgrew" );
    set_short( "MacGrew" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("MacGrew is a warm, armed NPC.  He models some of the latest "
    "fashions, but beware of mentioning them in the long() because he may "
    "have them stolen, or broken.  Let players look at him.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
         ARMOURY->request_item( "short sword",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move(this_object());
         init_equip();
         give_money( 10, 30, "Ankh-Morpork pence" );
}

==================================================
FILE: learning/examples/npcs/path.h
==================================================

#define PATH "/d/learning/examples/npcs/"

==================================================
FILE: learning/examples/npcs/pugh2.c
==================================================

inherit "/obj/monster";
void setup() {
    set_name( "pugh" );
    set_short( "Pugh" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("This is Pugh.  He exists in a separate file, so can easily be "
    "loaded in a variety of locations at once.  Essentially, he is identical"
    " to Pugh in the other room.\n");
    basic_setup ("human", "warrior", 10);
    set_gender( 1 );
}

==================================================
FILE: learning/examples/npcs/rat.c
==================================================

inherit "/obj/monster";
void setup() {
    string *name_adjectives = ({ "furry", "manky",
      "flea-ridden", "obnoxious", "sharp-toothed", "stinky", "dirty, stinking",
      "brown", "beady-eyed", "corpse-eating" });
    string adjective;
    adjective = name_adjectives[random(sizeof(name_adjectives))];
    set_name("rat");
    add_alias("rodent");
    set_gender(1 + random(2));
    set_short(adjective + " rat");
    add_adjective(adjective);
    set_long("The learning domain is full of rats.  This one appears "
    "not to have eaten for some hours and has a look"
    " of hunger in " + query_possessive()
      + " eyes.\n");
    basic_setup ("rat", "fighter", 2 + random(5));
}

==================================================
FILE: learning/examples/npcs/room1.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "cloned NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room holds a very simple NPC.  He is a fighter.  His "
    "code is within the room code.  If he's not here, type update, and"
    ", like magic, he should appear.  If he doesn't, panic.\n");
    add_exit("onwards", PATH +"room2", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( "/obj/monster" );
    npc -> set_name("pugh");
    npc -> set_short("Pugh");
    npc -> add_property("determinate", "");
    npc -> add_alias( ({"npc", "warrior", "man"}) );
    npc -> set_long("This is Pugh.  He was cloned here, and "
    "this is his world.  Welcome to it.\n");
    npc -> basic_setup("human", "warrior", 10);
    npc -> set_gender( 1 );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room2.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "seperate file NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here is cloned from another file, and brought here."
    "  This method means the same NPC can easily be loaded into a variety "
    "of locations, without the need to repeat much code.  The npc file is "
    "in /d/learning/examples/npcs/pugh2.c.\n");
    add_exit("backwards", PATH +"room1", "door");
    add_exit("onwards", PATH +"room3", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"pugh2" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room3.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "variable NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room clones an NPC from a single file.  However, the NPC"
    " has built in variety.  Its description changes randomly.  Typing "
    "update will bring a new version of the NPC here, each time it"
    " will be different.\n");
    add_exit("backwards", PATH +"room2", "door");
    add_exit("onwards", PATH +"room4", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"rat" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room4.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "chatting NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here gets to talk a little bit.  He has both random"
    " chats, and chats for use in combat which make him more entertaining.  "
    "Some chats appear more often than others.\n");
    add_exit("backwards", PATH +"room3", "door");
    add_exit("onwards", PATH +"room5", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"barley" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room5.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "room with a non-naked NPC" );
    add_property( "determinate", "the " );
    set_long( "We ought to clothe our NPCs and give them weapons, else how "
    "will the poor darlings survive the winter, and fend off attackers?  "
    "The easiest way is to give them items which already exist on the MUD"
    " via the armoury.\n");
    add_exit("backwards", PATH +"room4", "door");
    add_exit("onwards", PATH +"room6", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"macgrew" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room6.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "room with a fashion-victim NPC" );
    add_property( "determinate", "the " );
    set_long( "The NPC is here is not content with last year's fashion.  "
    "He wants new, exciting clothes, to be unique to him.  He has some "
    "standard stuff, but he has things which are unique to him.\n");
    add_exit("backwards", PATH +"room5", "door");
    add_exit("onwards", PATH +"room7", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"cuthbert" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/handlers/quit.c
==================================================

#include <learning.h>
#define SAVE_FILE SAVEPATH +"search_quit"
inherit "/std/room/basic_room";
mapping locations;
void setup() {
   set_short( "quit handler of the search rooms" );
   set_light( 50 );
   set_long( "You are in the quit_handler of the search rooms of the learning "
            "domain.  In normal use, people only end up in the quit_handler "
            "if something goes wrong, since the event_enter() function will "
            "send them on to the correct place immediately.\n" );
   add_exit( "back", ENTRANCE, "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded( (: restore_object, SAVE_FILE :) );
   call_out( "check_names", 2 );
}
void save_this() { unguarded( (: save_object, SAVE_FILE :) ); }
void check_names() {
   string word;
   foreach ( word in keys( locations ) )
      if ( !"/secure/login"->test_user( word ) )
         locations = m_delete( locations, word );
   save_this();
}
void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         (string *)place->query_keywords();
   if ( !locations[ (string)player->query_name() ] ) {
      locations[ (string)player->query_name() ] =
          (string)place->query_marker();
   }
   save_this();
}
void remove_from_list( object player ) {
   string word;
   word = (string)player->query_name();
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
}
void event_enter( object player, string words, object from ) {
   string location, word;
   if( from ) {
      return;
   }
   word = (string)player->query_name();
   if ( !locations[ word ] ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   if ( pointerp( locations[ word ] ) ) {
      location = (string)SEARCH->find_room( locations[ word ] );
   } else {
      location = (string)SEARCH->find_function_room( locations[ word ] );
   }
   player->move( location, "$N enter$s the game." );
}

==================================================
FILE: learning/handlers/request.c
==================================================

#include <learning.h>
#define SAVE SAVEPATH +"request"
mixed *requests;
void create() {
   seteuid( (string)master()->get_bb_uid() );
   unguarded( (: restore_object, SAVE :) );
   if( !requests ) requests = ({ });
}
void save_me() {
   unguarded( (: save_object, SAVE :) );
}
string query_list() {
   int i;
   string ret;
   mixed request;
   if ( !sizeof( requests ) ) {
      return "There are no requests at the moment.\n";
   }
   ret = "$P$Requests$P$The following requests have been made:\n";
   foreach( request in requests ) {
      if ( !request[ 1 ] ) {
         ret += sprintf( "%4d. $C$%s asked for %s.\n", i,
                        request[ 0 ], request[ 2 ] );
      } else {
         ret += sprintf( "%4d. $C$%s asked for %s.\n       Claimed by $C$%s\n", i,
                        request[ 0 ], request[ 2 ],
                        request[ 1 ]);
      }
   }
   return ret;
}
void add_request( string name, string words ) {
   requests += ({ ({ name, 0, words }) });
   save_me();
}
int claim_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      requests[ number ][ 1 ] = name;
      save_me();
      return 1;
   }
   return 0;
}
int remove_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      if ( requests[ number ][ 0 ] == name || name == CURRENT_LORD ) {
         requests = delete( requests, number, 1 );
         save_me();
         return 1;
      }
   }
   return 0;
}

==================================================
FILE: learning/handlers/search.c
==================================================

#include <learning.h>
#define SAVE SAVEPATH +"search"
mapping rooms,
        objects,
        keywords,
        functions;
string *directories;
nosave string word;
void create() {
   seteuid( (string)master()->get_bb_uid() );
   unguarded( (: restore_object, SAVE :) );
}
mixed get_keywords( string *words ) {
   string *found_words, *found_rooms, *found_objects, key, *value;
   if( sizeof( words ) ) {
      found_objects = keys( keywords );
      foreach( word in words ) {
         if( objects[ word ] ) {
            found_objects = filter_array( found_objects,
                (: member_array( $1, objects[ word ] ) != -1 :) );
         } else {
            found_objects = ({ });
         }
      }
      found_rooms = keys( keywords );
      foreach( word in words ) {
         if( rooms[ word ] ) {
            found_rooms = filter_array( found_rooms,
                (: member_array( $1, rooms[ word ] ) != -1 :) );
         } else {
            found_rooms = ({ });
         }
      }
      found_words = ({ });
      foreach( word in found_rooms ) {
         found_words -= keywords[ word ];
         found_words += keywords[ word ];
      }
      foreach( word in found_objects ) {
         found_words -= keywords[ word ];
         found_words += keywords[ word ];
      }
      found_words -= words;
   } else {
      found_rooms = ({ });
      foreach( key, value in rooms ) {
         found_rooms -= value;
         found_rooms += value;
      }
      found_objects = ({ });
      foreach( key, value in objects ) {
         found_objects -= value;
         found_objects += value;
      }
      found_words = keys( rooms );
      found_words -= keys( objects );
      found_words += keys( objects );
   }
   return ({ found_words, found_rooms, found_objects });
}
void update_info_for( string file ) {
   string *words, word;
   object obj;
   if( !catch( file->force_load() ) ) {
      obj = find_object( file );
      words = obj->query_property( "commented functions" );
      if( words ) {
         functions[ file ] = words;
      }
      words = obj->query_property( "keywords" );
      if( words ) {
         keywords[ file ] = words;
         if( function_exists( "add_exit", obj ) ) {
            foreach ( word in words ) {
               if( rooms[ word ] ) {
                  rooms[ word ] -= ({ file });
                  rooms[ word ] += ({ file });
               } else {
                  rooms[ word ] = ({ file });
               }
            }
         } else {
            foreach ( word in words ) {
               if( objects[ word ] ) {
                  objects[ word ] -= ({ file });
                  objects[ word ] += ({ file });
               } else {
                  objects[ word ] = ({ file });
               }
            }
         }
      }
      if( !directories ) {
         unguarded( (: save_object, SAVE :) );
      }
   }
}
void update_search( string room ) {
   object *obs;
   int i;
   obs = all_inventory( find_object( room ) );
   i = sizeof( obs );
   while( i--  ) {
      if ( userp( obs[ i ] ) ) {
         obs[ i ]->move( "/room/void" );
      } else {
         obs = delete( obs, i, 1 );
      }
   }
   room->dest_me();
   room->force_load();
   obs->move( room );
}
void collect_one() {
   string dir, file, *funcs;
   mixed dirs, file_info;
   dir = directories[ 0 ];
   dirs = get_dir( dir, -1 );
   if( dirs ) {
      foreach ( file_info in dirs ) {
         if( file_info[ 1 ] == -2 ) {
            if( file_info[ 0 ] != "old" ) {
               directories = directories + ({ dir + file_info[ 0 ] +"/" });
            }
         } else {
            if( ( sizeof( file_info[ 0 ] ) > 2 ) &&
                ( file_info[ 0 ][ <2 .. <1 ] == ".c" ) ) {
               update_info_for( dir + file_info[ 0 ][ 0 .. <3 ] );
            }
         }
      }
   }
   directories = directories[ 1 .. <1 ];
   if( find_call_out( "collect_one" ) == -1 && sizeof( directories ) ) {
      call_out( "collect_one", 3 );
   } else if( !sizeof( directories ) ) {
      tell_object( find_living( "olorin" ), "Collect finished.\n" );
      directories = 0;
      unguarded( (: save_object, SAVE :) );
      update_search( LEARNING +"search" );
      update_search( LEARNING +"functions" );
   }
}
void collect() {
   rooms=([ ]);
   objects=([ ]);
   functions=([ ]);
   keywords=([ ]);
   directories=({ "/d/learning/" });
   collect_one();
}
int query_collecting() {
   if( directories ) {
      return 1;
   } else {
      return 0;
   }
}
string find_room( string *words ) {
   object thing, *things;
   string word_mark;
   if( !sizeof( words ) )
     return LEARNING +"search";
   word_mark = implode( sort_array( words, 1 ), ", " );
   things = children( SEARCH_ROOM ) - ({ find_object( SEARCH_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word_mark )
        return file_name( thing );
   }
   thing = clone_object( SEARCH_ROOM );
   thing->set_marker( word_mark, words );
   return file_name( thing );
}
string find_function_room( string word ) {
   object thing, *things;
   if( !word )
     return LEARNING +"functions";
   things = children( FUNCTION_ROOM ) - ({ find_object( FUNCTION_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word )
        return file_name( thing );
   }
   thing = clone_object( FUNCTION_ROOM );
   thing->set_marker( word );
   return file_name( thing );
}
string *query_functions() {
   string *functions_found, key, *value;
   functions_found = ({ });
   foreach ( key, value in functions ) {
      functions_found -= value;
      functions_found += value;
   }
   return sort_array( functions_found, 1 );
}
string *query_rooms_with_function( string word ) {
   string *rooms_found, key, *value;
   rooms_found = ({ });
   foreach ( key, value in functions ) {
      if ( member_array( word, value ) != -1 )
        rooms_found += ({ key });
   }
   return uniq_array(rooms_found);
}

==================================================
FILE: learning/newbie/introduction/examples/.advanced_item_4.food_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/advanced_item_4.food#1" );
  call_other( clone, "set_name", "sandwich"  );
  call_other( clone, "set_short", "monkey sandwich"  );
  call_other( clone, "add_adjective", ({ "monkey" })  );
  call_other( clone, "set_value", 0  );
  call_other( clone, "set_weight", 1  );
  call_other( clone, "set_long", "This is a monkey sandwich.  Made from real monkey.  Mmm!\n"  );
  call_other( clone, "add_eat_effect",  "/std/effects/ingested/poison", 600 );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/.simple_object.clo_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/clothing.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_object.clo#1" );
  call_other( clone, "set_name",  "dungarees"  );
  call_other( clone, "set_short",  "pair of waterproof dungarees"  );
  call_other( clone, "set_long",  "This is a pair of waterproof dungarees.  Luckily they "     "are also ooze proof.\n"  );
  call_other( clone, "add_adjective",  ({"pair of", "waterproof"})  );
  call_other( clone, "set_weight",  45  );
  call_other( clone, "set_value",  4000  );
  call_other( clone, "setup_clothing",  50000  );
  call_other( clone, "set_type",  "robe" );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/.simple_weapon.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_weapon.wep#1" );
  call_other( clone, "set_name",  "mop"  );
  call_other( clone, "set_short",  "dirty mop"  );
  call_other( clone, "set_long",  "This is a dirty mop, dripping with ooze.\n"  );
  call_other( clone, "add_adjective",  "dirty"  );
  call_other( clone, "set_weight",  20  );
  call_other( clone, "set_value",  2000  );
  call_other( clone, "new_weapon", 10000  );
  call_other( clone, "add_attack",  "prod", 50, ({ 5, 6, 6 }), "blunt", "blunt", 0  );
  call_other( clone, "add_attack",  "whack", 50, ({ 10, 10, 5 }), "blunt", "blunt", 0 );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_1.c
==================================================

inherit "/obj/baggage";
void setup() {
    set_name("bag");
    set_short("little green bag");
    set_long("This is a little green bag.\n");
    add_adjective(({"little", "green"}));
    set_weight(5);
    set_max_weight(20);
}
int test_add(object ob, int flag) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    }
    else {
        return ::test_add(ob, flag);
    }
}
int test_remove(object ob, int flag, mixed dest) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    }
    else {
        return ::test_remove(ob, flag, dest);
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_2.c
==================================================

inherit "/obj/clothing";
void setup() {
    set_name("trousers");
    set_short("pair of flourescent pink flared trousers");
    add_adjective(({"pair of", "flourescent", "pink", "flared"}));
    set_long("This is a pair of extremely stylish, extremely "
    "tasteful, flourescent pink flared trousers.\n");
    set_weight(10);
    set_value(0);
    set_type("trousers");
    add_alias("flares");
    set_main_plural("pairs of flourescent pink flared trousers");
    add_plural("trousers");
    setup_clothing(10000);
    add_pocket("left", 20);
    add_pocket("right", 20);
    set_wear_remove_func(base_name(this_object()), "do_wear_stuff");
}
void do_wear_stuff(object ob) {
    if(this_player()->query_name() != "drakkos") {
        if(!ob) {
            tell_object(this_player(), "You heave a sigh of relief as "
                "you remove the ghastly garment.\n");
        }
        else {
            tell_object(this_player(), "Ye gods, are you really going "
            "to wear those hideous things?!\n");
        }
    }
    else {
        if(!ob) {
            tell_object(this_player(), "Awww, why are you taking off your "
                "super-cool slacks?\n");
        }
        else {
            tell_object(this_player(), "You feel Real Cool as you slip "
                "into your fabulous flares!\n");
        }
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_3.c
==================================================

inherit "/obj/weapon";
void setup() {
    set_name("ruler");
    set_short("wooden ruler");
    add_adjective("wooden");
    set_long("This is a thick, wooden ruler, with the inches "
        "inked out in black.\n");
    set_weight(1);
    set_value(0);
    new_weapon(5000);
    add_attack("rap", 50,({ 25, 10, 5 }), "blunt", "blunt", "do_shame");
    add_attack_message( "rap", "blunt",
   ({
    0,({ "You rap $hcname$ smartly across the knuckles with your "
        "ruler.\n",
        "$mcname$ raps you smartly across the knuckles with $mposs$ "
            "ruler.\n",
        "$mcname$ raps $hcname$ smartly across the knuckles with "
            "$mposs$ ruler.\n"})
    }));
    set_wield_func( "test_creator", base_name( this_object() ) );
}
int test_creator(object ob)  {
    if(!ob) {
        return 1;
    }
    if(ob->query_corpse()) {
        return 1;
    }
    if(ob->query_creator()) {
        tell_object(ob, "You have been deemed worthy, leetle creator!\n");
        return 1;
    }
    else {
        tell_object(ob, "You have been deemed unworthy, leetle player!\n");
        return 0;
    }
}
void do_shame( int damage, object attack_ob, object attack_by, string
    type, string name ) {
    tell_object(attack_ob, "Your knuckles %^BOLD%^sting!%^RESET%^\n");
    tell_object(attack_by, "You feel strangely satisfied as " +
        attack_ob->one_short() + " whimpers in pain!\n");
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_npc.c
==================================================

#include <armoury.h>
inherit "/obj/monster";
void do_bunny(object, object);
void do_maintain(object, object);
void setup() {
    set_name("gnome");
    set_short("laughing gnome");
    set_long("This is a little, friendly looking gnome.  Well... "
        "friendly looking aside from the vicious sharp teefs and the "
        "wicked razor-like claws.  He has laughter lines all over "
        "his face, tho', so he can't be all bad.\n");
    add_property("unique", 1);
    basic_setup("gnome", "wizard", 50);
    set_gender("male");
    set_int(23);
    set_str(18);
    set_wis(18);
    add_skill_level("magic", 100);
    add_skill_level("fighting", 50);
    load_chat(20,({
        1, "' Ha ha ha!.",
        1, "' He he he!.",
        2 , "' I'm the laughing gnome, and you can't catch me!",
        1 , "#charm_women",
    }) );
    load_a_chat(20,({
        2, ": bares his teeth.",
        1, "' I'll get my brother Fred onto you!.",
        2 , "' I'll call out the Gnome Guard!",
    }) );
    add_spell("bunnies", "/obj/spells/fire_bunny", "cast_spell");
    add_spell("flowers", "/obj/spells/flowers", "cast_spell");
    add_spell("shield", "/obj/spells/small_shield", "cast_spell");
    add_combat_action(25, "bunny_them",(: do_bunny :));
    add_combat_action(25, "maintain_me",(: do_maintain :));
    add_attack( "claws", 88,({ 10, 8, 20 }), "sharp", "sharp", 0 );
    add_attack( "teeth", 88,({ 5, 5, 25 }), "pierce", "pierce", 0 );
    add_attack_message( "claws", "sharp",
   ({
    100,
       ({ "You slice $hcname$ with your claws.\n",
            "$mcname$ slices you with $mposs$ claws.\n",
            "$mcname$ slices $hcname$ with $mposs$ claws.\n"}),
    200,
       ({ "You rip $hcname$ apart with your claws.\n",
            "$mcname$ rips you apart with $mposs$ claws.\n",
            "$mcname$ rips $hcname$ apart with $mposs$ claws.\n"}),
    0,
       ({ "You scratch $hcname$ viciously with your claws.\n",
            "$mcname$ scratches you viciously with $mposs$ claws.\n",
            "$mcname$ scratches $hcname$ viciously with $mposs$ claws.\n"})
    }));
    add_attack_message( "teeth", "pierce",
   ({
    100,
       ({ "You nibble $hcname$ with your teeth.\n",
            "$mcname$ nibbles you with $mposs$ teeth.\n",
            "$mcname$ nibbles $hcname$ with $mposs$ teeth.\n"}),
    200,
       ({ "You chew on $hcname$ with your teeth.\n",
            "$mcname$ chews on you with $mposs$ teeth.\n",
            "$mcname$ chews on $hcname$ with $mposs$ teeth.\n"}),
    0,
       ({ "You sink your teeth into $hcname$.\n",
            "$mcname$ sinks $mposs$ teeth into you.\n",
            "$mcname$ sinks $mposs$ teeth into $hcname$.\n"})
    }));
}
void charm_women() {
    object player;
    foreach(player in all_inventory(environment(this_object()))) {
        if(interactive(player) && player->query_gender() == 2) {
            queue_command("cast flowers");
            queue_command("give flowers to " + player->query_name());
            queue_command("bow with a flourish");
            return;
        }
    }
}
void do_bunny(object attacker, object target) {
    object carrot,torch;
    if(target != this_object() ) {
        if(!sizeof(match_objects_for_existence("carrot", this_object()))) {
            carrot =ARMOURY->request_item ("carrot");
            carrot->move(this_object());
        }
        if(!sizeof(match_objects_for_existence("torch", this_object()))) {
            torch = ARMOURY->request_item ("torch");
            torch->move(this_object());
        }
        do_command("cast bunnies on " + target->query_name());
    }
}
void do_maintain(object attacker, object target) {
    object temp;
    if(!sizeof(match_objects_for_existence("shields", this_object()))) {
        temp = ARMOURY->request_item("wooden djelian shield", 100);
        temp->move(this_object());
    }
    do_command("cast shield on " + this_object()->query_name());
}
void adjust_hp(int number) {
    return;
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_1.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("market square");
    set_day_long("This is a lovely market square, where people mill about "
        "doing the kind of things you would expect people to do in a lovely "
        "market square.  Brightly coloured stalls stand in the corners of "
        "the market.  They seem to do good business judging by the steady "
        "stream of consumers ducking under the flaps.\n");
    set_night_long("The darkness settles on this market square like a thick "
        "black blanket.  The stalls, undoubtedly merry and brightly coloured "
        "during the day, lie dormant and unusued.  The silence is "
        "deafening.\n");
    add_property("climate",({20, 20, 10}));
    set_light(80);
    add_zone("my rooms");
    set_linker(({PATH + "advanced_room_2", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
    add_day_item(({"people", "consumers"}), "The people mill around happily, "
        "browsing the goods and talking with the stallowners.");
    add_night_item(({"people", "consumers"}), "They're all tucked up in "
        "bed.  Only crazed retrobrates like you are awake at this time of "
        "night.");
    add_day_item("stall", "The stalls are brightly coloured and really "
        "quite merry.");
    add_night_item("stall", "The stalls lie dormant in the night.  Creepy!");
    room_day_chat(({120,240,({
        "People mill around happily.",
        "The brightly coloured stalls attract the eye.",
    })}));
    room_night_chat(({120,240,({
        "The only sound is the chirping of the crickets.",
        "The stalls loom ominously in the darkness.",
    })}));
    add_exit("north", PATH + "advanced_room_3", "road");
    add_exit("south", PATH + "advanced_room_2", "road");
    add_exit("east", "/w/drakkos/workroom", "road");
    add_exit("west", PATH + "simple_room", "road");
    modify_exit("east",({"look", "You get the feeling that peeking into a "
        "creator's workroom is very rude!", "function", "test_creator"}));
}
int do_search(string str) {
    if(!sizeof(str)) {
        return -1;
    }
    if(str == "shards") {
        tell_object(this_player(), "You search through the shards, but "
            "succeed only in cutting your hand slightly.  Ouch!\n");
        this_player()->adjust_hp(-100);
        if(this_player()->query_hp() < 0) {
            this_player()->attack_by(this_object());
        }
    return 1;
    }
    else {
        notify_fail("Try searching something else, perhaps?\n");
        return 0;
    }
}
string query_death_reason() {
    return "a nasty cut in the newbie creator tutorial room";
}
int test_creator(string str, object ob, string special_mess) {
    if(!ob->query_creator()) {
        notify_fail ("");
        tell_object (ob, "You are not a creator!  You may not pass!\n");
        return 0;
    }
    else {
        tell_object(ob, "You feel a tingle down your spine as you take the "
            "exit.\n");
        return 1;
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_2.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");
    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
    set_light(80);
    add_zone("my rooms");
    add_item("road", "I *said*, there's nothing interesting at all here.");
    add_exit("north", PATH + "advanced_room_1", "road");
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_3.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");
    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_2"}),
        "onto", "on", "the newbie creator marketplace");
    set_light(80);
    add_zone("my rooms");
    add_item("road", "I *said*, there's nothing interesting at all here.");
    add_exit("south", PATH + "advanced_room_1", "road");
}

==================================================
FILE: learning/newbie/introduction/examples/path.h
==================================================

#define PATH "/d/learning/newbie/introduction/examples/"

==================================================
FILE: learning/newbie/introduction/examples/simple_npc.c
==================================================

inherit "/obj/monster";
void setup() {
  set_name("blob");
  set_short("grey blob");
  set_long("This is a grey blob.  It is grey.  It is also quite "
      "blobby.\n");
  basic_setup("human", "warrior", 10);
  set_gender("male");
  add_adjective(({"oozing", "grey"}));
  set_main_plural("grey blobses");
  add_alias("porridge");
  add_respond_to_with(({ "@say",({"blob", "grey"}),
      }), "say Yes, I am a grey blob.");
  add_respond_to_with(({ "@say",({"ooze", "blue", "cardboard"}),
     ({"porridge", "bing", "womble"}),
      }), "' Yes, I'm oozing quite nicely, like grey "
          "blobs do.  Like porridge!");
  add_respond_to_with(({ "@thank", ({ "you", "blob" }) }),
      "' Aw, shucks. T'weren't nuthin'.");
  add_respond_to_with(({ ({"@gnaw", "@bite", "@chew"}), ({ "you",
    "blob" }) }),
      ({"' What did you do that for?!",  "scream", "cry", "weep"}));
  load_chat(20,({ 2, ": oozes around.",
      1, "' I'm very grey.",
      2 , "' I'm a blob.",
      2 , "@bing",
  }) );
  load_a_chat(20,({ 2, ": oozes all over you.",
      1, "' Lemme alone!.",
      2 , ": sobs bitter, slimy tears.",
  }) );
}

==================================================
FILE: learning/newbie/introduction/examples/simple_object.c
==================================================

inherit "/obj/clothing";
void setup() {
    set_name("dungarees");
    set_short("pair of waterproof dungarees");
    add_adjective(({"pair of", "waterproof"}));
    set_long("This is a pair of waterproof dungarees.  Luckily they "
        "are also ooze proof.\n");
    add_adjective(({"pair of", "waterproof"}));
    set_weight(45);
    set_value(4000);
    setup_clothing(50000);
    set_type("robe");
}

==================================================
FILE: learning/newbie/introduction/examples/simple_room.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
    set_short("blobby lair");
    set_long("This is where the grey blob lives.  All around lie "
        "frogs, and wombles, and strange oozy things.  It's a "
        "very nice lair, as lairs go.\n");
    add_property("determinate", "a ");
    set_light(50);
    add_item(({"frog", "pinkfish", "toad"}),({"long", "The frogs are very "
        "nice.  Very froggy.", "position", "one of the poor leetle "
        "frogs."}));
    add_item(({"womble", "uncle bulgaria"}),({"long", "It's Uncle "
        "Bulgaria!", "pet", "You pet Uncle Bulgaria.  He growls and "
        "chews the nails off your hand.\n", "snuggle", "Uncle Bulgaria gnaws "
        "on your teeth.\n"}));
    add_item("strange oozy things", "Ewww!");
    add_zone("my rooms");
    add_sign("This is a nice sign.\n", "Do Notte Feed Thee Blob!",
        "nice sign", "sign", "common");
    room_chat(({120,240,({
        "A thick blob of goo oozes over one of the frogs.",
        "The womble bings quietly.",
        "The frogs ribbit in abstract contemplation.",
    })}));
    add_exit("east", PATH + "advanced_room_1", "road");
}
void reset() {
    call_out("after_reset", 3);
}
void after_reset() {
    object ob = find_object
        (PATH + "simple_npc");
    if(!ob) {
        ob=load_object(PATH + "simple_npc");
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
    else if(!environment(ob)) {
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
}
