# Total Tokens: 23399
# Total Files Merged: 16
# Total Characters: 78042


==================================================

#include <money.h>
#include <move_failures.h>
#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"
nosave inherit "/std/room/basic_room";
int total_account, total_made;
nosave int account_cost, percentage;
nosave string bank_name, place;
int do_withdraw(int num, string type);
int do_deposit(string str);
nosave string save_file;
void create() {
  account_cost = 0;
  percentage = 90;
  total_account = 0;
  total_made = 0;
  bank_name = "Bing's First";
  place = "default";
  add_help_file("bank");
  ::create();
}
void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<number> <string>",
               (: do_withdraw($4[0], $4[1]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
  ::init();
}
int query_account_cost() { return account_cost; }
void set_account_cost( int number ) { account_cost = number; }
int query_percentage() { return percentage; }
void set_percentage( int number ) { percentage = number; }
int query_total_account() { return total_account; }
int query_total_made() { return total_made; }
string query_bank_name() { return bank_name; }
void set_bank_name( string word ) { bank_name = word; }
string query_place() { return place; }
string query_money_place() { return query_place(); }
void set_place( string word ) { place = word; }
string query_save_file() { return save_file; }
void set_save_file( string word ) {
  save_file = word;
  if ( file_size( save_file +".o" ) > 0 )
    unguarded((: restore_object, save_file :));
}
void do_save() {
   if ( !save_file ) {
      return;
   }
   unguarded( (: save_object, save_file :) );
}
int get_account() {
  int amount;
  if ( amount = (int)this_player()->query_property( "bank "+ OLD_BANK ) ) {
    HANDLER->adjust_account( NAME, bank_name, amount );
    this_player()->remove_property( "bank "+ OLD_BANK );
    total_account += amount;
    do_save();
  }
  return (int)HANDLER->query_account( NAME, bank_name );
}
int set_account( int amount ) {
  HANDLER->set_account( NAME, bank_name, amount );
}
int do_balance() {
  int amount;
  amount = get_account();
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     this_player()->add_succeeded_mess(this_object(),
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }), ({ }) );
    return 1;
  }
  this_player()->add_succeeded_mess(this_object(),
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount, place ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }), ({ }) );
  return 1;
}
int do_withdraw( int number, string type ) {
  int amount;
  int best;
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( number <= 0 ) {
    notify_fail( "You must withdraw something.\n" );
    return 0;
  }
  money = clone_object( MONEY_OBJECT );
  money->set_money_array( (mixed *)MONEY_HAND->query_values_in( place ) );
  if ( ( best = (int)money->find_best_fit( type ) ) == -1 ) {
    notify_fail( "That currency is not legal tender here.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  type = ( (mixed *)money->query_money_array() )[ best ];
  amount = number * ( (mixed *)money->query_money_array() )[ best + 1 ];
  if ( ( amount > total ) ||
       ( amount < 0 ) ) {
    notify_fail( "You don't have enough money in your account.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  money->set_money_array( ({ type, number }) );
  set_account( total - amount );
  total_account -= amount;
  do_save();
  this_player()->add_succeeded_mess(this_object(),
   ({ "You withdraw "+ (string)money->short() +".\n" +
      "You have "+ (string)MONEY_HAND->money_value_string( get_account(),
                                                           place ) +
        " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
       }), ({ }) );
  if ( (int)money->move( this_player() ) != MOVE_OK ) {
    write( "You are too heavily burdened to collect the money, so the teller "+
      "puts it on the counter for you.\n" );
    money->move( this_object() );
  }
  this_player()->save();
  return 1;
}
int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;
   total = get_account();
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only deposit money.\n" );
         default :
            return notify_fail( "You can only deposit legal tender.\n" );
      }
   }
   if (!place) {
      place = "default";
   }
   tender = MONEY_HAND->filter_legal_tender( money, place);
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
     amount = legal->query_value_in(place);
     if (place != "default") {
       amount += legal->query_value_in("default");
     }
     if(amount < 200) {
       if( legal->move( this_player() ) != MOVE_OK ) {
          legal->move( environment( this_player() ) );
          tell_object( this_player(), "You lose hold of some coins and "
             "they tumble to the floor.\n" );
          tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
       }
       if(illegal)
         if( illegal->move( this_player() ) != MOVE_OK ) {
            illegal->move( environment( this_player() ) );
            tell_object( this_player(), "You lose hold of some coins and "
               "they tumble to the floor.\n" );
            tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
         }
       add_failed_mess("That is too small an amount to deposit.\n");
       return 0;
     }
     tmp = ( amount * ( 100 - percentage ) ) / 100;
     total_made += tmp;
     amount = amount - tmp;
     set_account( total + amount );
     total_account += amount;
     do_save();
   }
   if (illegal) {
      if( illegal->move( this_player() ) != MOVE_OK ) {
         illegal->move( environment( this_player() ) );
         tell_object( this_player(), "You lose hold of some coins and "
            "they tumble to the floor.\n" );
         tell_room( environment( this_player() ), this_player()->one_short() +
            "accidentally drops some coins.\n", this_player() );
       }
   }
   if (legal) {
      howmuch = legal->the_short();
      legal->move( "/room/rubbish" );
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }
   write( "You give the teller "+ howmuch +".\n" );
   write( "After expenses, this leaves "+ (string)MONEY_HAND->
          money_value_string( amount, place ) +".\n" );
   this_player()->add_succeeded_mess(this_object(),
       ({  "$N $V "+words+".\n"
           "This gives a total of " +
           MONEY_HAND->money_value_string(total + amount, place ) +
           " in your account.\n",
           "$N deposit$s some money into $p account.\n" }), ({ }) );
   return 1;
}
int do_open() {
  int amount;
  object money;
  if ( get_account() >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( account_cost ) {
    if ( !( money = present( MONEY_ALIAS, this_player() ) ) ) {
      notify_fail( "You do not have any money.\n" );
      return 0;
    }
    amount = (int)money->query_value_in( place );
    if ( place != "default" )
      amount += (int)money->query_value_in( "default" );
    if ( amount < account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      account_cost, place ) +" to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  return 1;
}
int check_open( string word ) {
  object money;
  word = lower_case( word );
  if (word [ 0 ] ==  110 ) {
    write( "Okay, not opening an account.\n" );
    return 1;
  }
  if ( word[ 0 ] !=  121 ) {
    write( "Do you want to open an account? Answer \"yes\" or \"no\".\n" );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  write( "You now have an account here.\n" );
  money = present( MONEY_ALIAS, this_player() );
  MONEY_HAND->pay_amount_from( account_cost, money, place );
  total_made += account_cost;
  do_save();
  this_player()->save();
  return 1;
}
int do_close() {
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, place ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
      total_made += total;
    }
    total_account -= total;
  } else
    write( "You close your account.\n" );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  set_account( -1 );
  do_save();
  this_player()->save();
  return 1;
}
mixed *stats() {
  return ::stats() + ({
    ({ "account cost", account_cost }),
    ({ "percentage", percentage }),
    ({ "total accounts", total_account }),
    ({ "total made", total_made }),
    ({ "bank name", bank_name }),
    ({ "place", place }),
    ({ "save file", save_file }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = (int)HANDLER->query_account( player_name, bank_name ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      HANDLER->adjust_account( player_name, bank_name, -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  total_account -= total;
  amount = total / 3;
  total_made += 2 * amount;
  do_save();
  mon_array = (mixed *)MONEY_HAND->create_money_array( amount / number, place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}

==================================================
FILE: shops/bank_franchise.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_franchise";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
string query_franchise() {
   return file_name(this_object());
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_franchise::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_franchise::init();
}

==================================================
FILE: shops/bank_master.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_master";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_master::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_master::init();
}

==================================================
FILE: shops/binding.c
==================================================

inherit "/std/room/basic_room";
#include <money.h>
#include <language.h>
private int _cost_per_book;
private int _cost_per_page;
void create() {
   _cost_per_book = 4000;
   _cost_per_page = 400;
}
void init() {
   add_command("bind", "<object:indirect:me'pages'> into book");
}
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
}
int do_bind(object *obs) {
   object *magic;
   object *paper;
   object *fail;
   object ob;
   object book;
   string place;
   int cost;
   foreach (ob in obs) {
      if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      }
   }
   if (sizeof(fail) || sizeof(magic)) {
      if (sizeof(magic)) {
         add_failed_mess("Cannot bind up $I with magic stuff into "
                         "a book.\n", magic);
      }
      if (sizeof(fail)) {
         add_failed_mess("$I are not pieces of paper and cannot be "
                         "bound into a book.\n", fail);
      }
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _cost_per_book + _cost_per_page * sizeof(paper);
   if (this_player()->query_value(place) > cost) {
      add_failed_mess("You do not have enough money, you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to bind $I into a book.\n", paper);
      return 0;
   }
   book = clone_object("/std/book");
   foreach (ob in paper) {
      book->add_page_after(ob, book->query_num_pages() + 1);
   }
   book->move(this_player());
   this_player()->pay_money( MONEY_HAND->create_money_array(cost, place),
                             place);
   return 1;
}

==================================================
FILE: shops/book_shop.c
==================================================

#include <shops/craft_shop.h>
inherit CRAFT_SHOP_INHERIT;
#define READ_PAGE_PROPERTY "browse page"
int browse_pages(object *obs);
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables);
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables);
void init() {
   string storeroom;
   ::init();
   storeroom = file_name(query_controller()->query_sell_list());
   add_command("browse", "page of <indirect:object:" + storeroom + ">",
               (: browse_pages($1) :) );
   set_extra_sell_check((: choose_which_page :));
}
int browse_pages(object *obs) {
   object *real_obs;
   object ob;
   int number;
   string mess;
   string read;
   object *no_pages;
   object *ok;
   int i;
   if (!check_open(this_player(), "browse")) {
      return 0;
   }
   real_obs = query_controller()->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse page$P$";
   no_pages = ({ });
   ok = ({ });
   for (i = 0; i < sizeof(obs); i++) {
      ob = real_obs[i];
      number = ob->query_property(READ_PAGE_PROPERTY);
      if (undefinedp(number)) {
         number = random(ob->query_num_pages() - 1) + 1;
         ob->add_property(READ_PAGE_PROPERTY, number);
         query_controller()->update_craft_object(obs[i], real_obs[i]);
      }
      if (number > ob->query_num_pages()) {
         no_pages += ({ ob });
      } else {
         ob->set_open_page(number);
         mess += ob->the_short() + ":\n" + ob->long();
         read = ob->query_readable_message();
         if (read) {
            mess += "You read " +
                    replace(ob->query_read_short(this_player()), "$name$",
                            ob->a_short()) + ":\n" +
                    ob->query_readable_message();
         }
         ok += ({ ob });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess(({ mess, "$N browses a page of $I.\n" }), ok);
      return 1;
   } else {
      add_failed_mess("There are not enough pages in $I to open to " +
                      " page " + number + ".\n", no_pages);
      return 0;
   }
}
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables) {
   write("Which page of " + query_multiple_short(sellables) +
         " would you like to let people browse (0 for the cover only)? ");
   input_to((: finish_choose :), 0, end_func, value, name, sellables);
}
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables) {
   int page;
   object *invalid;
   if (page_num == "quit" ||
       page_num == "q") {
      write("Aborting sale.\n");
      return ;
   }
   if (sscanf(page_num, "%d", page) != 1) {
      write("Need to actually enter a number.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   if (page < 0) {
      write("Need to specify a page number greator than zero.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   invalid = filter(sellables, (: $1->query_num_pages() < $(page) :) );
   if (sizeof(invalid)) {
      write("Page Number " + page + " is larger the number of pages in " +
            query_multiple_short(invalid) + ".\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   sellables->add_property(READ_PAGE_PROPERTY, page);
   sellables->set_open_page(0);
   evaluate(end_func, value, name, sellables);
}

==================================================
FILE: shops/bureau_de_change.c
==================================================

#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
int standard, buy_only;
string place;
mapping exchanges;
int do_buy(object *obs, string country);
int query_standard() { return standard; }
void set_standard( int number ) { standard = number; }
int query_buy_only() { return buy_only; }
void set_buy_only() { buy_only = 1; }
string query_place() { return place; }
void set_place( string word ) { place = word; }
mapping query_exchanges() { return exchanges; }
void set_exchanges( mapping map ) { exchanges = map; }
string exchanges_list() {
    int i, value, smallest;
    string list, *places;
    if ( !sizeof( exchanges ) )
         return "There are no exchanges to be made here.";
    list = "";
    places = keys( exchanges );
    for ( i = 0; i < sizeof( places ); i++ ) {
         list += places[ i ] +":\n      $I$+20,+10="+
                  (string)MONEY_HAND->money_value_string( standard, place ) +
                  " will buy: ";
         value = ( exchanges[ places[ i ] ][ 0 ] * standard ) / 100;
         smallest = MONEY_HAND->smallest_value_in( places[ i ] );
         if (value % smallest != 0)  value += smallest - (value % smallest);
         list += (string)MONEY_HAND->money_value_string( value, places[ i ] );
         if ( buy_only ) {
             list += ".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         } else {
             list += ";$I$-20,-10=\n$I$+20,+10=      for "+
                      (string)MONEY_HAND->money_value_string( standard,
                      place ) +", sell: ";
             value = ( 100 * standard ) / exchanges[ places[ i ] ][ 1 ];
             list += (string)MONEY_HAND->money_value_string( value,
                      places[ i ] ) +".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         }
    }
    return list;
}
void create() {
   do_setup++;
   ::create();
   do_setup--;
   standard = 100;
   place = "default";
   exchanges = ([ ]);
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   ::init();
   add_command("buy", "[from] <string'" + implode(keys(exchanges), "|") +
       "'> with <indirect:object:me>",  (: do_buy( $1, $4[0] ) :) );
   if ( !buy_only ){
      add_command("sell" ,"<indirect:object:me'stuff'>",
                        (:this_object()->sell($1):));
   }
   add_command("list", "", (:this_object()->list():));
}
int do_buy(object *things, string country) {
   int     value;
   int     smallest;
   object  thing;
   object  money;
   mixed  *change;
   mixed  *monies;
   mixed  *no_value;
   string  word;
   change = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money"))  {
         change = MONEY_HAND->merge_money_arrays(change,
                                                 thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   if (sizeof(change) == 0) {
      return notify_fail("You can only use money to buy currency here.  "
                         "Sorry.\n");
   }
   if (undefinedp(exchanges[country])) {
      foreach (word in keys(exchanges)) {
         if (lower_case(country) == lower_case(word)) {
            country = word;
            break;
         }
      }
      if (country != word) {
         add_failed_mess("You cannot exchange that currency here.  Only " +
              query_multiple_short(keys(exchanges)) + " currency can be "
              "purchased at this shop.\n");
         this_player()->adjust_money(change);
         return 0;
      }
   }
   if (country == place) {
      this_player()->adjust_money(change);
      return notify_fail("You cannot buy currency from " + country +
            " here, since you're currently in " + country + ".\n");
   }
   monies = MONEY_HAND->filter_legal_money_to_array(change, place);
   no_value = monies[1];
   if (sizeof(monies[0]) != 0  &&  place != "default")  {
      monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
      if (sizeof(monies[0]) != 0)
         no_value = MONEY_HAND->merge_money_arrays(no_value, monies[0]);
      monies[0] = monies[1];
   }
   if (sizeof(no_value) != 0)  {
      this_player()->adjust_money(no_value);
      write("Sorry, but you cannot use " +
            MONEY_HAND->money_string(no_value) + " to buy currency here.\n");
   }
   if (sizeof(monies[0]) == 0) {
      return notify_fail("Sorry, but you didn't offer any acceptable money "
                         "to buy currency.\n");
   }
   value = (MONEY_HAND->query_total_value(monies[0], place) *
           exchanges[country][0]) / 100;
   smallest = MONEY_HAND->smallest_value_in(country);
   if (value % smallest != 0)  value += smallest - (value % smallest);
   change = MONEY_HAND->create_money_array(value, country);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(monies[0]);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(monies[0]) + " is not worth anything "
            "in " + country + ".\n");
   }
   write("OK, you bought "+ MONEY_HAND->money_string(change) + " with " +
         MONEY_HAND->money_string(monies[0]) + ".\n");
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }
   say(this_player()->one_short() + " exchanges some currency.\n");
   return 1;
}
int sell(object *things) {
   int value;
   int test_val;
   int first;
   string *places;
   string  a_place;
   object thing;
   object money;
   mixed *monies;
   mixed *change;
   mixed *m_array_a;
   mixed *m_array_b;
   mixed *m_array_c;
   m_array_a = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money")) {
         m_array_a = MONEY_HAND->merge_money_arrays(m_array_a,
                         thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   if (sizeof(m_array_a) == 0) {
      return notify_fail("You can only sell currency here.  Sorry.\n");
   }
   places = m_indices(exchanges);
   m_array_b = ({ });
   m_array_c = ({ });
   first = 1;
   foreach (a_place in places)  {
      monies = MONEY_HAND->filter_legal_money_to_array(m_array_a, a_place);
      m_array_a = monies[1];
      if (sizeof(monies[0]) != 0)  {
         if (first  &&  a_place != "default")   {
            monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
            if (sizeof(monies[0]) != 0)
               m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
            monies[0] = monies[1];
            first = 0;
         }
         test_val = MONEY_HAND->query_total_value(monies[0], a_place) *
                    exchanges[a_place][1] / 100;
         if (test_val)   {
            value += test_val;
            m_array_b = MONEY_HAND->merge_money_arrays(m_array_b, monies[0]);
         }
         else
            m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
      }
      if (sizeof(m_array_a) == 0)
         break;
   }
   if (sizeof(m_array_c) != 0)
      m_array_a = MONEY_HAND->merge_money_arrays(m_array_a, m_array_c);
   if (sizeof(m_array_a) != 0) {
      write("Sorry, but you cannot sell " +
            MONEY_HAND->money_string(m_array_a) + " here.\n");
      this_player()->adjust_money(m_array_a);
   }
   if (sizeof(m_array_b) == 0) {
      return notify_fail( "Sorry, but you aren't offering to sell any "
            "acceptable coinage.\n");
   }
   change = MONEY_HAND->create_money_array(value, place);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(m_array_b);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(m_array_b) + " is not "
            "worth anything in " + place + ".\n");
   }
   write("OK, you sold " + MONEY_HAND->money_string(m_array_b) + " for " +
         MONEY_HAND->money_string(change) + ".\n");
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }
   say(this_player()->one_short() + " exchanges some currency.\n");
   return 1;
}
int list() {
   write( exchanges_list() +"\n" );
   return 1;
}

==================================================
FILE: shops/commercial.c
==================================================

inherit "/std/shops/inherit/commercial";

==================================================
FILE: shops/craft_shop.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop";
void create() {
   add_help_file("craft_shop");
   basic_room::create();
   craft_shop::create();
}
void init() {
   basic_room::init();
   craft_shop::init();
}
void dest_me() {
   craft_shop::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/craft_shop_category.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop_category";
void create() {
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   basic_room::create();
   craft_shop_category::create();
}
void init() {
   basic_room::init();
   craft_shop_category::init();
}
void dest_me() {
   craft_shop_category::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/engrave_inherit.c
==================================================

#include <money.h>
#include <shops/engrave.h>
void set_engrave_language(string str);
protected int do_engrave( object *things, string message);
mixed query_property(string name);
private string _lingo = "general";
void create() {
   this_object()->add_help_file("engrave");
}
void engrave_init() {
   add_command( "engrave", "<string> on <indirect:object>",
                (: do_engrave($1, $4[0]) :));
}
protected int engrave_living(object *obs) {
   return 0;
}
protected int engrave_wrong_items(object *obs) {
   return 0;
}
protected int engrave_no_money(object *obs, int cost) {
   return 0;
}
int engrave_objects(object *obs, int cost) {
   return 0;
}
protected int do_engrave( object *things, string message) {
   int cost;
   string coststring;
   string place;
   object *liv;
   object *engravable;
   liv = filter(things, (: living($1) :));
   if (sizeof(liv) && !engrave_living(liv)) {
      add_failed_mess("Cannot engrave messages on $I, they are living things.\n", liv);
   }
   things -= liv;
   if (!sizeof(things)) {
      return 0;
   }
   engravable = filter(things,
                       (: ($1->query_property( "shop type" ) == "jewellers" ||
                         $1->query_property( ENGRAVE_PROP ) == 1 ||
                           $1->query_property( "shop type" ) == "armoury") &&
                          $1->query_short() != "holy blade of Soyin" :) );
   if (!sizeof(engravable)) {
      if (!engrave_wrong_items(things - engravable)) {
         add_failed_mess("Cannot engrave messages on $I.\n",
                         things - engravable);
      }
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   coststring = replace_string(message, " ", "");
   cost = (strlen(coststring) * 80) * sizeof(engravable);
   if ( (int) this_player()->query_value_in( place ) < cost ) {
      if (!engrave_no_money(engravable, cost)) {
         add_failed_mess("Not enough money to engrave $I, you need " +
                         MONEY_HAND->money_value_string(cost, place) + ".\n",
                         engravable);
      }
      return 0;
   }
   if ( engrave_objects( engravable, cost ) ) {
      this_player()->pay_money( ( mixed *)MONEY_HAND->create_money_array( cost,
                                place ), place );
      add_succeeded_mess( ({ "You have the message \"" + message +
                            "\" engraved into $I for " +
                            MONEY_HAND->money_value_string(cost, place)
                            + ".\n", "$N gets $I engraved with a message.\n" }),
                            engravable);
      engravable->add_read_mess( message,
                 "neatly engraved letters", _lingo, 1);
      return 1;
   }
   else return 0;
}
void init() {
  engrave_init();
}
void set_engrave_language(string lang) {
  _lingo = lang;
}

==================================================
FILE: shops/general_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shop.h>
#include <tasks.h>
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/open_shop";
private mixed our_storeroom;
private mixed buy_mess;
private mixed sell_mess;
private mixed list_mess;
private mixed value_mess;
private mixed too_costly_mess;
private mixed not_worthy_mess;
private mixed browse_mess;
private mixed *other_shops;
private int amount_sold;
private int amount_bought;
private int strict_shop;
private int no_steal;
private int sell_stolen;
private int steal_difficulty;
private int min_amount;
private int max_inventory;
private int sell_large;
private mixed shop_type;
private mixed buy_func;
private mixed sell_func;
private mixed value_func;
private mixed too_costly_func;
private mixed cannot_sell_func;
private mixed browse_func;
private mixed list_func;
private nosave string shoplift_handler;
private string original_storeroom;
private int _strict_currency;
private nosave mapping elist = (["north" : "south", "south" : "north",
  "east" : "west", "west" : "east", "up" : "down", "down" : "up"]);
string shop_list(mixed arr, int detail);
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which);
string find_free_exit();
int do_buy(object *ob);
int do_list_these(object *obs);
void do_buy_things( object *obs, int cost, object pl );
void do_parse(mixed arr, mixed ob, object client, string money,
  string extra);
object create_mercenary(object rep);
void event_shoplift(object command_ob, object thief, object victim);
object query_store_room();
int creator_object (object);
void create() {
    buy_mess = ({
      "You buy $ob$ for $money$.\n",
      "$client$ buys $ob$.\n"});
    sell_mess = ({
      "You sell $ob$ for $money$.\n",
      "$client$ sells $ob$.\n"});
    list_mess = "$extra$";
    value_mess = "$ob$ is valued at $money$.\n";
    too_costly_mess = "$ob$ is worth too much to be sold here.\n";
    not_worthy_mess = "$ob$ is not worth enough to be sold here.\n";
    browse_mess = "$ob$ costs $money$, it looks like:\n$extra$";
    other_shops = ({ });
    max_inventory = MAX_INVENTORY;
    min_amount = 50;
    add_help_file("shop");
    _strict_currency = 1;
    ::create();
}
void reset() {
    if(!random(3)) {
        remove_property("inventory_loss");
    }
    call_out("send_out_reps", 2);
}
void set_buy_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        buy_func = func;
    }
}
void set_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        sell_func = func;
    }
}
void set_value_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        value_func = func;
    }
}
void set_too_costly_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        too_costly_func = func;
    }
}
void set_cannot_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        cannot_sell_func = func;
    }
}
void set_browse_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        browse_func = func;
    }
}
void set_list_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        list_func = func;
    }
}
void set_sell_message(mixed str) {
    sell_mess = str;
}
void set_buy_message(mixed str) {
    buy_mess = str;
}
void set_value_message(mixed str) {
    value_mess = str;
}
void set_too_costly_message(mixed str) {
    too_costly_mess = str;
}
void set_not_worthy_message(mixed str) {
    not_worthy_mess = str;
}
void set_browse_message(mixed str) {
    browse_mess = str;
}
void set_list_message(mixed str) {
    list_mess = str;
}
void set_open_condition(mixed str) {
   if (functionp(str)) {
      ::set_open_function(str);
   } else if (intp(str)) {
      ::set_open_function( (: $(str) :) );
   } else if (pointerp(str)) {
      ::set_open_function( (: call_other($(str[0]), $(str[1]), $1) :) );
   } if ( stringp(str) ) {
      ::set_open_function( (: call_other( this_object(), $(str), $1 ) :) );
   }
}
void set_no_steal(int i) {
    no_steal = i;
}
void set_steal_difficulty(int i) {
    steal_difficulty = i;
}
void set_sell_stolen(int i) {
    sell_stolen = i;
    no_steal = 1;
}
void set_sell_large(int i) { sell_large = i; }
mixed query_sell_mess() {
    return sell_mess;
}
mixed query_list_mess() {
    return list_mess;
}
mixed query_value_mess() {
    return value_mess;
}
mixed query_too_costly_mess() {
    return too_costly_mess;
}
mixed query_not_worthy_mess() {
    return not_worthy_mess;
}
mixed query_buy_mess() {
    return buy_mess;
}
mixed query_browse_mess() {
    return browse_mess;
}
int query_no_steal() {
    return no_steal;
}
int query_steal_difficulty(int i) {
    return steal_difficulty;
}
string query_shoplift_response_handler() {
    return shoplift_handler;
}
int query_shop() {
    return 1;
}
object *query_shop_lift_items(string str, object player) {
    return match_objects_for_existence(str, ({ query_store_room() }));
}
object shoplift_success(object ob) {
    return ob;
}
void set_shoplift_response_handler(string word) {
    shoplift_handler = word;
}
void set_min_amount(int i) { min_amount = i; }
void set_max_inventory(int i) { max_inventory = i; }
void init() {
    string room;
    ::init();
    if(stringp(our_storeroom)) {
        room = our_storeroom;
    } else if(our_storeroom) {
        room = file_name(our_storeroom);
    } else {
      tell_room(this_object(),
                "Oh dear, we don't seem to have a storeroom.\n");
    }
    add_command("sell", "<indirect:object:me>");
    add_command("buy", "<indirect:object:"+room+">");
    add_command("list", "[all]");
    add_command("list", "<indirect:object:"+room+">",
      (: do_list_these($1) :));
    add_command("browse", "<indirect:object:"+room+">");
    add_command("value", "<indirect:object:me>");
}
int query_max_amount() {
    return MAX_AMOUNT;
}
int query_min_amount() {
    return min_amount;
}
varargs int query_value(object thing, int sell) {
     if ( thing->query_property("cost here") && !sell ) {
         return (int)thing->query_property("cost here");
     }
     else {
        return (int)thing->query_value_at( this_object() );
     }
}
int scaled_value(int n) {
    int i, tot, *fish;
    fish = PAY_RATES;
    if(n < fish[0]) {
        return n;
    } else {
        tot = fish[0];
        n -= fish[0];
    }
    i = 0;
    while(n && ((i + 1) < sizeof(fish))) {
        if(n >= fish[i]) {
            tot += fish[i + 1] * fish[i] / 100;
            n -= fish[i];
        } else {
            tot += fish[i + 1] * n / 100;
            n = 0;
        }
        i += 2;
    }
    if(n) {
        tot += (n * fish[sizeof(fish) - 1]) / 100;
    }
    return tot;
}
int do_sell(object *in_obs) {
    int i, amt, total_amt;
    string place, filename, *text = ({ });
    object money, *obs, *selling, *cannot, *stolen, storeob, one_item, *cre;
    object thing;
    mixed *m_array;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    in_obs = uniq_array( in_obs );
    obs = filter_array(in_obs, (: !$1->query_keep() :));
    cre = filter (obs, (: creator_object ($1) :));
    if (sizeof (cre) && strsrch (file_name (this_object()),
      "_dev") == -1) {
      if (!this_player()->query_creator()) {
        tell_object (this_player(), "Oh dear, you shouldn't have " +
          query_multiple_short (cre) + "!  They disappear with a flash "
          "of octarine light.\n");
        cre->move ("/room/rubbish");
      }
      else {
        tell_object (this_player(), "Oh dear, you shouldn't be trying to sell " +
          query_multiple_short (cre) + "!\n");
      }
      foreach (thing in cre) {
        if ( thing->query_property( "virtual name" ) ) {
          filename = thing->query_property( "virtual name" );
        } else {
          filename = base_name (thing);
        }
        text += ({filename});
      }
      log_file ("ILLEGAL_OBJECT", sprintf ("%s: %s tried to sell %s at "
        "%s.\n\n", ctime (time()), this_player()->query_name(),
        query_multiple_short (text), file_name (this_object())));
      obs -= cre;
   }
    if(!sizeof(obs)) {
        this_player()->add_failed_mess(this_object(),
          "You previously decided to keep $I.\n", in_obs);
        return 0;
    }
    in_obs = this_player()->query_holding() + this_player()->query_armours();
    cannot = filter(obs, (: member_array($1, $2) != -1 :), in_obs);
    if (sizeof(cannot)) {
        obs -= cannot;
        tell_object(this_player(), "You decide not to sell " +
          query_multiple_short(cannot, "the") + ", because "
          "you are wearing or holding $V$0=it,them$V$.\n");
    }
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) > max_inventory) {
        this_player()->add_failed_mess(this_object(),
          "Sorry, the shop is full up and isn't buying items!\n", ({ }));
        call_out("tidy_inventory", random(20));
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS - 1];
    }
    selling = cannot = stolen = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(!sell_stolen && obs[i]->query_property("stolen")) {
            stolen += ({obs[i]});
            continue;
        } else {
            obs[i]->remove_property("stolen");
        }
        if((this_object()->query_value(obs[i], 1) > 0) &&
          !obs[i]->do_not_sell() &&
          !this_object()->do_not_buy(obs[i]) && (!strict_shop ||
            shop_type == obs[i]->query_property("shop type")) &&
          environment(obs[i]) == this_player()) {
            if(obs[i]->move(our_storeroom)) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                continue;
            }
            amt = (int)this_object()->query_value(obs[i], 1);
            if(!(obs[i]->query_property("sale_value"))) {
                amt = scaled_value( amt );
            }
            if((amt <= (int)this_object()->query_max_amount()) &&
              (amt >= (int)this_object()->query_min_amount())) {
                if(shop_type != obs[i]->query_property("shop type")) {
                    amt = (amt * 90) / 100;
                }
                total_amt += amt;
                selling += ({obs[i]});
                obs[i]->being_sold();
            } else {
                if(obs[i]->short())
                    cannot += ({obs[i]});
                obs[i]->move(this_player());
            }
        } else {
            if(obs[i]->short()) {
                cannot += ({obs[i]});
            }
        }
    }
    if (!sizeof(selling)) {
        if (sizeof(cannot)) {
            if (stringp(cannot_sell_func)) {
                call_other(this_object(), cannot_sell_func, this_player(), cannot);
            } else if (functionp(cannot_sell_func)) {
                evaluate(cannot_sell_func, this_player(), cannot);
            }
            this_player()->add_failed_mess(this_object(),
              "You cannot sell $I.\n", cannot);
        } else if(sizeof(stolen)) {
            if(sizeof(stolen) > 1) {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because they're stolen!\n", stolen);
            } else {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because it's stolen!\n", stolen);
            }
            foreach(one_item in obs) {
                if(one_item->query_property("stolen") == this_player()->query_name()) {
                    event_shoplift(this_object(), this_player(), this_object());
                    break;
                }
            }
        } else {
            this_player()->add_failed_mess(this_object(),
              "You have nothing to sell.\n", ({ }));
        }
        return 0;
    }
    if(this_object()->cannot_afford(total_amt)) {
        selling->move(this_player());
        this_player()->add_failed_mess(this_object(),
          "The shop cannot afford to buy $I from you.\n", selling);
        return 0;
    }
    amount_sold += total_amt;
    m_array = (mixed *)MONEY_HAND->create_money_array(total_amt, place);
    money = clone_object(MONEY_OBJECT);
    money->set_money_array(m_array);
    if(sizeof(cannot)) {
        if(stringp(cannot_sell_func)) {
            call_other(this_object(), cannot_sell_func, this_player(), cannot);
        } else if (functionp(cannot_sell_func)) {
            evaluate(cannot_sell_func, this_player(), cannot);
        }
        write("You cannot sell "+query_multiple_short(cannot)+".\n");
        cannot->move(this_player());
    }
    if(stringp(sell_func)) {
        call_other(this_object(), sell_func, this_player(), obs);
    } else if (functionp(sell_func)) {
        evaluate(sell_func, this_player(), obs);
    }
    do_parse(sell_mess, selling, this_player(),
      (string)MONEY_HAND->money_string(m_array), "");
    if((int)money->move(this_player()) != MOVE_OK) {
        tell_object(this_player(),
          "You're too heavily burdened to accept all that money, "
          "so the shopkeeper puts it on the floor.\n");
        money->move(this_object());
    }
    this_object()->made_transaction(-total_amt, selling);
    return 1;
}
int creator_object( object ob ) {
    string path;
    if ( file_name( ob )[0..2] == "/w/" ) {
        return 1;
    }
    if ( ( path = ob->query_property( "virtual name" ) ) &&
      path[0..2] == "/w/" ) {
        return 1;
    }
    return 0;
}
int do_buy(object *obs) {
    int i, amt, ob_amt, total_cost;
    string place;
    object money, *to_buy, *cannot, *too_much;
    object *creator_obs;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS-1];
    }
    creator_obs = filter( obs, (: creator_object( $1 ) :) );
    if ( sizeof( creator_obs ) && file_name()[0..2] != "/w/" ) {
        tell_object( this_player(), "You cannot buy " +
          query_multiple_short( creator_obs, "the" ) +
          " because they shouldn't be in the game!\n" );
        obs -= creator_obs;
    }
    to_buy = too_much = cannot = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, this_player());
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You have no money.\n", obs);
        return 0;
    }
    amt = money->query_value_in(place);
    if(place != "default" && !_strict_currency ) {
        amt += money->query_value_in("default");
    }
    while(i < sizeof(obs)) {
        ob_amt = this_object()->query_value(obs[i], 0);
        if(ob_amt > amt) {
            if(obs[i]->short()) {
                too_much += ({obs[i]});
            }
            obs = delete(obs, i, 1);
            continue;
        }
        if(obs[i]->move(this_player())) {
            if(!sell_large) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                i++;
                continue;
            } else {
                obs[i]->move(this_object());
            }
        }
        amt -= ob_amt;
        total_cost += ob_amt;
        to_buy += ({obs[i]});
        i++;
    }
    amount_bought += total_cost;
    if(sizeof(cannot)) {
        this_player()->add_failed_mess(this_object(),
          "You cannot pick up $I.\n", cannot);
    }
    if(sizeof(too_much)) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), cannot);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), cannot);
        }
        this_player()->add_failed_mess(this_object(),
          "$I costs too much.\n", too_much);
    }
    if(!sizeof(to_buy)) {
        return 0;
    }
    do_buy_things(to_buy, total_cost, this_player());
    return 1;
}
void do_buy_things(object *obs, int cost, object pl) {
    int i, j;
    string place;
    object money, change;
    mixed m_array, p_array;
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, pl);
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_object(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You don't have any money.\n", obs);
        return 0;
    }
    change = clone_object(MONEY_OBJECT);
    m_array = (int)MONEY_HAND->create_money_array(cost, place);
    for(i = 0; i < sizeof(m_array); i += 2) {
        p_array = (mixed *)MONEY_HAND->make_payment(m_array[i],
          m_array[i + 1], money, place);
        if(!pointerp(p_array)) {
            continue;
        }
        for(j = 0; j < sizeof(p_array[0]); j += 2) {
            money->adjust_money(-p_array[0][j + 1], p_array[0][j]);
        }
        change->adjust_money(p_array[1]);
    }
    do_parse(buy_mess, obs, pl,
      (string)MONEY_HAND->money_string(m_array), "");
    if(stringp(buy_func)) {
        call_other(this_object(), buy_func, pl, obs);
    } else if (functionp(buy_func)) {
        evaluate(buy_func, pl, obs);
    }
    if((int)change->move(pl) != MOVE_OK) {
        tell_object(pl, "You are too heavily burdened to accept "
          "your change, so the shopkeeper puts it on the floor.\n");
        change->move(this_object());
    }
    this_object()->made_transaction(cost, obs);
}
int do_list() {
    object ob;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(objectp(our_storeroom)) {
        ob = our_storeroom;
    } else {
        if ( original_storeroom ) {
            our_storeroom = load_object( original_storeroom );
            ob = our_storeroom;
        }
        else {
            add_failed_mess( "Please notify a creator: the storeroom for "
                "this shop cannot load or has gone missing.\n" );
            return 0;
        }
    }
    if(stringp(list_func)) {
        call_other(this_object(), list_func, this_player());
    } else if (functionp(list_func)) {
        evaluate(list_func, this_player());
    }
    do_parse(list_mess, ({ this_object() }), this_player(), "",
      shop_list(all_inventory(ob), 0));
    return 1;
}
int do_list_these(object *obs) {
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    do_parse(list_mess, ({this_object()}),
      this_player(), "", shop_list(obs, 1));
    return 1;
}
int do_browse(object *obs) {
    int i, value;
    string place;
    if (!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    if(stringp(browse_func)) {
        call_other(this_object(), browse_func, this_player(), obs);
    } else if (functionp(browse_func)) {
        evaluate(browse_func, this_player(), obs);
    }
    for(i = 0; i < sizeof(obs); i++) {
        value = (int)this_object()->query_value(obs[i], 0);
        do_parse(browse_mess, obs[i..i], this_player(),
          (string)MONEY_HAND->money_value_string(value, place),
          (string)obs[i]->long());
    }
    return 1;
}
int do_value(object *obs) {
    int i;
    int val;
    int total;
    string place;
    int obnum;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->do_not_sell() || this_object()->do_not_buy(obs[i]) ||
          (environment(obs[i] ) != this_player()) ||
          (strict_shop &&
            (shop_type != (string)obs[i]->query_property("shop type")))) {
            val = 0;
        } else {
            val = (int)this_object()->query_value(obs[i], 1);
            if (shop_type != (string)obs[i]->query_property("shop type")) {
                val = (val * 90) / 100;
            }
        }
        val = scaled_value(val);
        total += val;
        if(val > (int)this_object()->query_max_amount()) {
            do_parse(too_costly_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else if(val < (int)this_object()->query_min_amount()) {
            do_parse(not_worthy_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else {
            do_parse(value_mess, obs[i..i], this_player(),
              (string)MONEY_HAND->money_value_string(val, place),
              (string)obs[i]->do_not_sell());
            if(stringp(value_func)) {
                call_other(this_object(), value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            } else if (functionp(value_func)) {
                evaluate(value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            }
        obnum++;
        }
    }
    if (obnum > 1) {
        write("This gives you a total value of " +
          MONEY_HAND->money_value_string(total, place) +
          ".\n");
        return 1;
    }
    this_player()->add_failed_mess( this_object(), "None of your items are "
        "suitable for sale here!\n", obs );
    return obnum;
}
string shop_list(mixed arr, int detail) {
    int i, j, value, num;
    string s, mon, place, *shorts, *vals;
    object *list;
    mapping inv, costs;
    mixed ind;
    if(pointerp(arr)) {
        list = arr;
    } else {
        list = all_inventory(this_object());
    }
    inv = ([ ]);
    for(i = 0; i < sizeof(list); i++) {
        s = (string)list[i]->short();
        if(!s || !this_object()->query_value(list[i], 1)) {
            continue;
        }
        if(!stringp(s)) {
            s = "get a creator for this one!";
        }
        if(inv[s]) {
            inv[s] += ({list[i]});
        } else {
            inv[s] = ({list[i]});
        }
    }
    s = "";
    shorts = m_indices(inv);
    if(!sizeof(shorts)) {
        if(detail) {
            return "The shop is all out of what you wanted.\n";
        } else {
            return "The shop is totally out of stock.\n";
        }
    }
    s = "You find on offer:\n";
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(shorts); i++) {
        ind = inv[shorts[i]];
	num = sizeof(ind);
	if(num == 1 && ind[0]->query_collective())
	  num = ind[0]->query_amount();
        switch(num) {
        case 1:
            s += "Our very last " + shorts[i];
            break;
        case 2..5 :
            s += capitalize(query_num(num, 0)+" "+
			    (string)ind[0]->query_plural());
            break;
        default:
            if(detail) {
                s += capitalize(query_num(num, 0) + " " +
                  (string)ind[0]->query_plural());
            } else {
                s += "A large selection of "+
                (string)ind[0]->query_plural();
            }
        }
        if(detail) {
            costs = ([ ]);
            for(j = 0; j < sizeof(ind); j++) {
                value = (int)this_object()->query_value(ind[j], 0);
                mon = (string)MONEY_HAND->money_value_string(value, place);
                if(!costs[mon]) {
                    costs[mon] = ({""+(j + 1)});
                } else {
                    costs[mon] += ({""+(j + 1)});
                }
            }
            if(m_sizeof(costs) == 1) {
                s += " for "+m_indices(costs)[0];
                if(sizeof(m_values(costs)[0]) > 1) {
                    s += " each.\n";
                } else {
                    s += ".\n";
                }
            } else {
                s += ":-\n";
                vals = m_indices(costs);
                for(j = 0; j < sizeof(vals); j++) {
                    s += "  [#"+implode(costs[vals[j]], ",")+"] for "
                    +vals[j]+".\n";
                }
            }
        } else {
            s += ".\n";
        }
    }
    return s;
}
void set_store_room(mixed ob) {
    if(stringp(ob)) {
        original_storeroom = ob;
        our_storeroom = find_object(ob);
        if(!our_storeroom) {
            our_storeroom = load_object(ob);
        }
    }
    else our_storeroom = ob;
}
void guards(object tp) {
    object ob;
    if(environment(tp) != this_object() && environment(tp) != our_storeroom) {
        return;
    }
    while(!random(6)) {
        ob = create_mercenary(0);
        ob->move(environment(tp));
        ob->attack_ob(tp);
    }
}
object query_store_room() {
    return our_storeroom;
}
void do_parse(mixed arr, object *ob, object client,
  string money, string extra) {
    if(stringp(arr)) {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr,
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(), "", ob);
    } else if (functionp(arr)) {
        evaluate(arr, ob, client, money, extra);
    } else {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr[0],
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(),
          ({"", replace(arr[1], ({"$ob$", "$I", "$client$",
                "$N", "$money$", money, "$extra$", extra}))}), ob);
    }
}
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which) {
    if(sizeof(ob)) {
        str = replace(str, "$ob$", query_multiple_short(ob, which));
    } else {
        str = replace(str, "$ob$", call_other(ob, which +"_short"));
    }
    if(client) {
        str = replace(str, "$client$", client->the_short());
    }
    str = replace(str, ({"$money$", money, "$extra$", extra}));
    return str;
}
void add_other_shop(mixed shop) {
    other_shops += ({shop});
}
string query_shop_type() {
    return shop_type;
}
void set_shop_type(string ty) {
    shop_type = ty;
}
void set_strict_shop(int i) {
    strict_shop = i;
}
int query_strict_shop() {
    return strict_shop;
}
object create_rep() {
    object ob;
    ob = clone_object("/obj/monster");
    ob->set_name("rep");
    ob->set_short("sales rep");
    ob->add_adjective("sales");
    ob->set_long("This is tall strong looking sales rep.  He "
      "stares at you with bright piercing eyes.\n");
    ob->add_alias("Sales rep alias");
    ob->set_guild("fighter");
    ob->set_race("human");
    ob->adjust_bon_str(15);
    ob->set_level(60);
    ARMOURY->request_weapon("dagger", 100)->move(ob);
    ARMOURY->request_armour("cloth robe", 100)->move(ob);
    ob->init_equip();
    ob->add_property("rep type", shop_type);
    all_inventory(ob)->add_property("mine", 1);
    return ob;
}
void send_out_reps() {
    int i;
    object ob;
    for(i = 0; i < sizeof(other_shops); i++) {
        ob = (object)this_object()->create_rep();
        ob->add_property("goto destination", other_shops[i]);
        ob->add_property("goto property", "shop");
        ob->move(this_object(),
          "$N stride$s determinedly into the room.");
        ob->add_triggered_action("froggy", "goto_destination",
          file_name(this_object()), "rep_made_it");
    }
}
void rep_made_it(int bing) {
    object *obs, rep;
    int i, cost;
    if(!bing) {
        previous_object()->init_command("'Oh no!  I am utterly lost!");
        previous_object()->init_command("sigh");
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = (previous_object()->query_current_room())->query_stock(shop_type);
    if(!obs) {
        obs = ({ });
    }
    if(!sizeof(obs)) {
        this_object()->none_to_sell();
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]) {
            cost += (int)this_object()->query_value( obs[ i ], 1 ) * 2 / 3;
        }
    }
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    cost += (int)this_object()->query_value(obs[i], 1) * 2 / 3;
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    previous_object()->adjust_value(cost);
}
object create_mercenary(object rep) {
    object ob;
    string nam;
    if(rep) {
        nam = implode(rep->query_adjectives(), " ")+" "+rep->query_name();
    }
    ob = clone_object("/obj/monster");
    ob->set_name("mercenary");
    ob->add_alias("troll");
    ob->add_adjective("troll");
    ob->set_short("troll mercenary");
    ob->set_main_plural("troll mercenaries");
    ob->set_race("troll");
    ob->set_class("fighter");
    ob->set_level(200 + random(200));
    ob->set_long("This is a large, hulking troll.  He looks "
      "quite competent and capable of mashing you with or "
      "without a weapon.\n");
    if(rep) {
        ob->move(environment(rep));
        ob->do_command("follow "+nam);
        ob->do_command("protect "+nam);
        ob->add_property("merchant", rep);
    } else {
        ARMOURY->request_weapon("spiked club", 100)->move(ob);
    }
    ob->set_natural(1);
    ob->init_equip();
    ob->set_join_fights("Troll yells something incomprehensible.\n");
    ob->set_join_fight_type(0);
    return ob;
}
object *query_stock(string type) {
    mapping blue;
    blue = (mapping)our_storeroom->query_shop_type_mapping();
    if(!blue[type]) {
        return ({ });
    }
    return blue[type];
}
void do_rep_buy(mixed *bing) {
    object rep, *obs;
    int cost;
    rep = bing[0];
    obs = bing[1];
    cost = bing[2];
    rep->adjust_money(cost, "brass");
    rep->query_current_room()->do_buy(obs, cost, rep);
    obs->move(present("Sales rep alias", rep->query_current_room()));
    call_out("set_up_return", 5, rep);
}
void set_up_return(object rep) {
    rep->add_property("goto destination", file_name(this_object()));
    rep->add_triggered_action("froggy", "goto_destination",
      this_object(), "rep_came_back");
}
void rep_came_back() {
    int i;
    object *obs, *obs2, rep;
    obs = previous_object()->find_inv_match("all", previous_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->query_property("mine")) {
            continue;
        }
        if(obs[i]->query_property("money")) {
            continue;
        }
        obs[i]->move(our_storeroom);
        obs2 += ({obs[i]});
    }
    if(sizeof(obs2)) {
        tell_room(this_object(), previous_object()->short()+" puts "+
          query_multiple_short(obs2)+" into the stock.\n");
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = all_inventory(this_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if((object)obs[i]->query_property("merchant") == rep) {
            obs2 += ({ obs[i] });
        }
    }
    if(sizeof(obs2)) {
        tell_room(this_object(),
          query_multiple_short(obs2+({previous_object()}), "one")+" go away.\n");
    } else {
        tell_room(this_object(), previous_object()->short()+" goes away.\n");
    }
    obs2->dest_me();
    previous_object()->dest_me();
}
void summon_guards(object tp) {
    object ob;
    int i;
    if(environment(tp) != this_object()) {
        return;
    }
    ob = environment(tp)->create_mercenary(0);
    if(!ob) {
        return;
    }
    ob->move(this_object(),
      "$N charge$s in to protect the shop!");
    ob->attack_ob(tp);
    for(i = 0; i < random(5); i++) {
        ob = create_mercenary(0);
        ob->move(this_object(),
          "$N charge$s in to protect the shop!");
        ob->attack_ob(tp);
    }
}
void set_strict_currency( int new_strict ) {
    _strict_currency = new_strict;
}
int query_strict_currency() {
    return _strict_currency;
}
void event_shoplift(object command_ob, object thief, object victim) {
    if(stringp(shoplift_handler)) {
        if(shoplift_handler != "none") {
            shoplift_handler->handle_shoplift(thief, victim);
        }
    } else if (functionp(shoplift_handler)) {
        evaluate(shoplift_handler, thief, victim);
    } else {
        "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
    }
}
void tidy_inventory() {
    object storeob;
    object *inventory;
    int i, inv_to_leave;
    int count;
    inv_to_leave = max_inventory - (max_inventory / 4);
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) < inv_to_leave)
        return;
    inventory = all_inventory(storeob);
    while(sizeof(inventory) > inv_to_leave) {
        i = random(sizeof(inventory));
        if(inventory[i])
            inventory[i]->dest_me();
        if(count++ > 500)
            break;
        inventory = all_inventory(storeob);
    }
}
void dest_me() {
    if(our_storeroom)
        our_storeroom->dest_me();
    ::dest_me();
}
mixed *stats() {
    return ::stats()+({
      ({"total sold", amount_sold}),
      ({"total bought", amount_bought}),
      ({"shop type", shop_type}),
      ({"shoplift handler", shoplift_handler }),
      ({"strict shop", strict_shop})});
}

==================================================
FILE: shops/general_shop_close.c
==================================================

inherit "/std/shops/general_shop";
inherit "/std/shops/inherit/store_close";
void womble() {
}

==================================================
FILE: shops/item_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/item_shop";
void create() {
  do_setup++;
  basic_room::create();
  item_shop::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
   basic_room::init();
   item_shop::init();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
    basic_room::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen );
}
void dest_me() {
   item_shop::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/item_shop_close.c
==================================================

inherit "/std/shops/item_shop";
inherit "/std/shops/inherit/store_close";
void womble() {
}

==================================================
FILE: shops/item_shop_outside.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/std/room/outside";
inherit "/std/shops/inherit/item_shop";
void create() {
   item_shop::create();
   outside::create();
}
void init() {
   outside::init();
   item_shop::init();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
    outside::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen );
}
void dest_me() {
   item_shop::dest_me();
   outside::dest_me();
}

==================================================
FILE: shops/laundry_entry_inherit.c
==================================================

#include <money.h>
#include <vault.h>
inherit "/std/room";
#define TIME_LIMIT 500
#define LO laundryowner->the_short()
string location, laundry_room;
int visit_cost;
object laundryowner;
void set_location(string str) { location = str; }
void set_visit_cost(int i) { visit_cost = i; }
void set_laundryowner(object ob) { laundryowner = ob; }
void set_laundry_exit(string direc, mixed dest, string type) {
  laundry_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  if(!laundryowner || environment(laundryowner) != this_object())
    return notify_fail("Since the owner of this laundry is missing "
      "you think twice before entering the laundry.\n");
  if( !interactive(thing) )
    return 0;
  owner = (string)thing->query_name();
  if ( !( vroom = find_object( laundry_room ) ) )  {
      laundry_room->load_me();
      vroom = find_object( laundry_room );
  }
  if(sizeof(filter_array(all_inventory(vroom),
                         (: userp( $1 ) :)))) {
    tell_object(thing, LO + " intercepts you.\n");
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing);
    laundryowner->do_command("say No more than one person at a time in "
      "laundry room.  It can be very dangerous!");
    laundryowner->do_command("emote taps his head implying madness.");
    return notify_fail( "" );
  }
  if(query_property(owner)) {
    remove_property(owner);
    tell_object(thing, LO + " opens the round door of the laundry and "
      "signalls you to enter.\n" );
    tell_room(this_object(), LO + " signalls "+
              (string)thing->the_short() +" to enter the laundry through "
                "the small round door of the laundry.\n", thing );
    call_out("check_idler", TIME_LIMIT, thing);
    return 1;
  }
  if ( (int)thing->query_value_in( location ) +
       (int)thing->query_value_in( "default" ) < visit_cost ) {
    tell_object( thing, LO + " intercepts you.\n" );
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    laundryowner->do_command("say Well... I am but a poor man.  I cannot "
      "just let you use my fine, imp-powered laundry for nothing!\n" );
    laundryowner->do_command("emote sniffs.\n" );
    return notify_fail( "" );
  }
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay " + LO + " who signals you to go through "
    "the small, round door of the laundry.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays " + LO + " who signals to "
             + (string)thing->query_objective() + " to move through "
             "a small, round door and enters the laundry.\n", thing );
   return 1;
}
void player_quitting(object who, object env) {
}
