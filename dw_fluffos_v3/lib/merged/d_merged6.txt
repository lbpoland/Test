# Total Tokens: 23576
# Total Files Merged: 17
# Total Characters: 78623

eeting.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
object floor, sign;
string log_bing, chair;
void setup() {
  set_short("Meeting room");
  set_long(
"A large oak table dominates this room.  There are some heavy ornate "+
"looking candle sticks in the center of the table.  The table is "+
"sourounded by large expensive looking teak chairs, at one end of the "+
"table are some larger more expensive looking ones.  There is a small "+
"hammer sitting in the middle of the room.  You can see a small sign on "+
"the wall.\n");
  set_light(70);
  add_item("oak table",
           "A large heavy looking oak table.  It was built to last. "+
           "It looks very old, you can tell by all the worn marks "+
           "at the places around the table where people sit.\n");
  add_item("teak chair",
           "The chairs are overly ornate and obviously in a very good "+
           "condition for their age.  The large chairs at the end are "+
           "obviously not well used (you can tell, all the dust).\n");
  add_item("candle stick",
           "The candle sticks are made of silver, however if you try "+
           "and take them, you notice they are attached to the table "+
           "somehow.  The candles seemed to have been carved into the "+
           "shape of a small chicken holding a torch.\n");
  add_item(({ "hammer", "gavel" }),
           "The gavel looks like ones fo those things so common in "+
           "meeting rooms.  You could bang it around a little maybe, "+
           "it might help if you had it though.\n");
  log_bing = 0;
  sign = add_sign("A small sign with not much written on it.\n",
                  "There is no current chair of the meeting.\n");
}
void reset() {
  if (floor)
    return ;
  floor = clone_object("/std/object");
  floor->set_name("floor");
  floor->set_short( "floor" );
  floor->add_property( "determinate", "the " );
  floor->set_long(
"This is the floor of the meeting.  It gives you the right to speak "+
"during the meeting.  Please give this to the next person to speak "+
"after you have finished.\n");
  floor->move(this_object());
}
void init() {
  string str;
  ::init();
  str = previous_object()->query_name();
  if (interactive(previous_object()) && (previous_object()->query_lord()
      || str == chair)) {
    add_action("appoint", "appoint");
    add_action("bang", "bang");
    add_action("recover", "recover");
    add_action("do_log", "log");
  }
}
int appoint(string str) {
  object ob;
  if (chair && (string)this_player()->query_name() != chair) {
    notify_fail("The chair has already been apointed.\n");
    return 0;
  }
  if (!(ob = find_player(str))) {
    notify_fail("Sorry, cannot find "+str+" to be the chair.\n");
    return 0;
  }
  chair = str;
  say(this_player()->one_short()+" just appointed "+str+" as the "+
        "chair of the meeting.\n", ob);
  write("Ok, "+str+" is now the chair of the meeting.\n");
  tell_object(ob, this_player()->one_short()+
        " just appointed you the chair of the meeting.\n");
  if (environment(ob) == this_object())
    ob->move(this_object());
  sign->set_read_mess("The chair of the meeting is "+str+".\n");
  return 1;
}
int bang(string str) {
  if ((string)this_player()->query_name() != chair) {
    notify_fail("Only the chair can bang the gavel.\n");
    return 0;
  }
  tell_room(this_object(),
            this_player()->one_short()+" bangs the gavel loudly.  STOP "+
            "STOP!\n");
  return 1;
}
int recover() {
  if (!floor)
    reset();
  floor->move(this_player());
  write("Floor recovered.\n");
  say(this_player()->one_short()+" has recovered the floor.\n");
  return 1;
}
int do_log(string str) {
  if (log_bing && !str) {
    write("Stopped logging.\n");
    log_bing = str;
    return 1;
  }
  if (!str) {
    notify_fail("Syntax: log <file_name>\n"+
                "        log by itself to stop logging.\n");
    return 0;
  }
  if (log_bing)
    write("Stopped loggin to "+log_bing+" and started logging to "+str+".\n");
  else
    write("Logging to "+str+".\n");
  log_bing = str;
  return 1;
}
void event_person_say(object ob, string start, string rest) {
  if (log_bing)
    log_file(log_bing, start+rest+"\n");
}
void event_say(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}
void event_soul(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}
void dest_me() {
  if (floor)
    floor->dest_me();
  ::dest_me();
}

==================================================
FILE: admin/room/playroom.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
object board;
void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("playerhelp");
    board->move(this_object());
  }
}
void setup() {
  set_light(60);
  set_short("Player Help Room");
  set_long(
"You are in a strange room with hundreds of frozen statues in the likenesses "+
"of many players on the DiscWorld.  They all seem to be begging, and "+
"looking at you with mournful eyes.\n");
  add_item(({"player","statue"}),
"They all look as if they are asking you questions, but without "+
"moving their lips.  Some of them look genuinly hopeless, but most "+
"have the look of treachery and deceit.  Quite a few of them have many "+
"faces looking in several directions.  Beware them all.\n");
  add_exit("east", "/w/common", "door");
}
void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}
void event_enter(object ob) {
  if (!ob->query_creator() && !ob->query_property("demon")) {
      tell_object(ob, "Whoops!  You don't seem to be a creator.\n");
      call_out("do_move", 2, ob);
   }
}
void do_move(object ob) {
   tell_object( ob, "A trap door opens in the floor and you fall through!\n" );
   ob->move_with_look( "/d/am/am/mendeddrum", "$N fall$s through a trap "+
         "door in the ceiling.", "A trap door opens in the floor and "+
         "$N fall$s through." );
}

==================================================
FILE: admin/room/quest_room.c
==================================================

#include "quest_handler.h"
#include "path.h"
inherit "/std/room/basic_room";
int level;
string  old_quest;
string  story;
string  title;
int do_create( string quest );
int do_delete( string quest );
int do_help( string what );
int do_level( string new_level );
int do_list();
int do_name( string new_name );
int do_story( string new_story );
int do_title( string new_title );
void  remove_quest( string answer );
void  init();
void  setup();
int
do_create( string quest )
{
    if ( !quest )
    {
  write( "Syntax is: create <quest>, where <quest> will be the name of "
       + "the new quest.\n" );
  return 1;
    }
    if ( !level )
    {
  write( "You must set the quest level first.\n" );
  return 1;
    }
    if ( !story )
    {
  write( "You must set the quest story first.\n" );
  return 1;
    }
    if ( !title )
    {
  write( "You must set the quest title first.\n" );
  return 1;
    }
    if ( QUEST_HANDLER->add_quest( quest , level , title , story ) )
    {
  tell_room( this_object() , "Quest \"" + quest + "\" added.\n" );
  level = 0;
  story = 0;
  title = 0;
    }
    else
  tell_room( this_object() , "Quest failed to add.\n" );
    return 1;
}
int
do_delete( string quest )
{
    string  *quests;
    if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
      return 1;
      quests = (mixed*) QUEST_HANDLER->query_quest_names();
    if ( quest )
    {
        if ( member_array( quest, quests ) == -1 )
  {
      write( "Quest not found.\n" );
      return 1;
  }
  old_quest = quest;
  write( "\nYou should not remove someone else's quest!!!\n\n"
       + "Are your sure you want to remove this quest? (y/n) > " );
  input_to( "remove_quest" );
  return 1;
    }
    write( "Syntax: remove <quest>, where <quest> is the name of an "
   + "existing quest.\n" );
    return 1;
}
int
do_help( string what )
{
    if ( what != "room" )  return 0;
    write( "Quest room help:\n\n"
   + "  create <string> - Use current settings to create a new quest\n"
   + "                    whose name is <string>.\n"
   + "  delete <string> - Delete the quest whose name is <string>.\n"
   + "                    This option available only to Lords.\n"
   + "  help room       - Generate this help screen.\n"
   + "  level <int>     - Set the level of difficulty to <int>.\n"
   + "  list            - List the current quests.\n"
   + "  story <string>  - Set the quest story to <string>.\n"
   + "  title <string>  - Set the string that is added to the player's\n"
   + "                    title to <string>.\n"
   );
    return 1;
}
int
do_level( string new_level )
{
    if ( new_level )
    {
  sscanf( new_level , "%d" , level );
  tell_room( this_object() , "Quest level set to " + level + ".\n" );
    }
    else
  write( "Syntax: level <new_level>, where new_level is an integer "
       + "indicating how difficult the quest is.\n" );
    return 1;
}
int do_list() {
  int i;
  string list;
  mixed *names;
  if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
    return 1;
  list = "These are the Discworld quests:\n\n";
  names = (mixed *)QUEST_HANDLER->query_quest_names();
  for ( i = 0; i < sizeof( names ); i++ ) {
    list += "Quest "+ ( i + 1 ) +"  \""+ names[ i ] +"\", level "+
        (int)QUEST_HANDLER->query_quest_level( names[ i ] ) +"\n    title: "+
        (string)QUEST_HANDLER->query_quest_title( names[ i ] ) +"\n    story: "+
        (string)QUEST_HANDLER->query_quest_story( names[ i ] ) +"\n";
    if ( i < sizeof( names ) - 1 )
      list += "\n";
   }
  reset_eval_cost();
  this_player()->more_string( list, "Quest List", 1 );
  return 1;
}
int
do_story( string new_story )
{
    if ( new_story )
    {
  story = new_story;
  tell_room( this_object() , "Quest story set to:\n" + story + "\n" );
    }
    else
  write( "Syntax: story <new_story>, where new_story is a string that "
       + "describes the quest.\n" );
    return 1;
}
int
do_title( string new_title )
{
    if ( new_title )
    {
  title = new_title;
  tell_room( this_object() , "Quest title set to \"" + title + "\".\n" );
    }
    else
  write( "Syntax: title <new_title>, where new_title is the title that "
       + "is appended to the players name for \"who\".\n" );
    return 1;
}
void
init()
{
#ifdef 0
    string  euid;
    object  tp;
    tp   = this_player();
    euid = geteuid( tp );
    if ( ( "/secure/master"->god( euid )             )
      || ( "/secure/master"->high_programmer( euid ) )
      || ( "/secure/master"->query_lord( euid )      )
      || ( tp->query_creator()                       )
      || ( tp->query_app_creator()                   ) )
    {
  add_action( "do_create" , "create" );
  add_action( "do_help"   , "help"   );
  add_action( "do_level"  , "level"  );
  add_action( "do_story"  , "story"  );
  add_action( "do_title"  , "title"  );
  if ( ( "/secure/master"->god( euid )             )
    || ( "/secure/master"->high_programmer( euid ) )
    || ( "/secure/master"->query_lord( euid )      ) )
  {
      add_action( "do_delete" , "delete" );
      add_action( "do_list"   , "list"   );
  }
  level = 0;
  story = 0;
  title = 0;
  do_help( "room" );
  tell_room( this_object() , "\nQuest settings have been reset to "
         + "nulls by init().\n\n" );
    }
    ::init();
#endif
}
void remove_quest( string answer ) {
    answer = lower_case( answer );
    if ( answer == "y" )
    {
  if ( QUEST_HANDLER->delete_quest( old_quest ) )
      tell_room( this_object() , "Quest \"" + old_quest
             + "\" deleted.\n" );
  else
      tell_room( this_object() , "Quest \"" + old_quest + "\" was not "
             + "deleted.\n" );
  return;
    }
    tell_room( this_object() , "Quest \"" + old_quest
           + "\" was not deleted.\n" );
    return;
}
void
setup()
{
    set_short( "Quest Room" );
    set_long("Don't use this room, get a lord to use the quests command instead. This room will break the quests!\n");
    set_light( 100 );
    add_exit( "west" , ROOM+"development" , "corridor" );
}

==================================================
FILE: admin/room/site_control.c
==================================================

#include "path.h"
#include "access.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"
int do_banish(string);
int do_access();
int do_suspend(string);
int do_unsuspend(string);
void setup() {
  set_light(100);
  set_short("site-access control room");
  add_property("determinate", "the ");
  set_long(
    "In front of you teem hundreds of small packages.  They rush around "+
    "yelling out strange numbers and get directed into various parts "+
    "of the maze by large mice with red flags.  Everything happens at "+
    "break neck speed.  Every now and then one of the packages "+
    "spontaneously combusts.\n"+
"Available commands:\n"+
"  ban       :  Ban a site.\n"+
"  access    :  Show the current access of various sites.\n"+
"  suspend   :  Suspend someones access.\n"+
"  unsuspend :  Unsuspend someones access.\n");
  seteuid("Admin");
  add_exit("north", ROOM+"domain_control", "corridor");
}
#if efun_defined(add_action)
#define NUM
#else
#define NUM 1
#endif
void init() {
  ::init();
  if (!interactive(previous_object(NUM))) return 0;
  if ("/secure/master"->query_lord(geteuid(previous_object(NUM))))
    add_command("ban", "<string>", (:do_banish($4[0]):));
  add_command("access", "", (:do_access():));
  add_command("suspend", "<string'person'>", (:do_suspend($4[0]):));
  add_command("unsuspend", "<string'person'>", (:do_unsuspend($4[0]):));
}
int print_access(string bit, mapping bing, int depth, int cols) {
  mixed *bits;
  int i;
  if (this_player() != this_player(1))
    return 0;
  bits = m_indices(bing);
  if (depth == 4) {
    for (i=0;i<sizeof(bits);i++)
      switch (bing[bits[i]][0]) {
        case NO_NEW :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no new characters.\n");
          break;
        case NO_ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no characters.\n");
          break;
        case ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to normal access.\n");
          break;
    }
    return 1;
  }
  for (i=0;i<sizeof(bits);i++)
    print_access(bit+"."+bits[i], bing[bits[i]], depth+1, cols);
  return 1;
}
int do_access() {
  mixed bing;
  if (this_player() != this_player(1))
    return 0;
  bing = (mixed)"/secure/bastards"->query_all_access();
  if (!m_sizeof(bing)) {
    notify_fail("No access control defined.\n");
    return 0;
  }
  write("Current access list:\n");
  print_access("", bing, 0, (int)this_player()->query_cols());
  return 1;
}
int do_banish(string str) {
  string ip, ident, reason;
  int level;
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->high_programmer(geteuid(previous_object())))
    return 0;
  notify_fail("Syntax: banish <ip number> <ident> <level> <reason>\n"+
              "        <level> := 0 delete ident, 1 normal access,\n"+
              "                   2 no new players, 3 No access.\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s %d %s", ip, ident, level, reason) != 4)
    return 0;
  if (!"/secure/bastards"->change_access(explode(ip, "."), ident, level,
                                         reason))
    return 0;
  write("Access permisions changed.\n");
  return 1;
}
int do_suspend(string str) {
  string reason;
  string name;
  int tim;
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  if (!str || sscanf(str, "%s %d %s", name, tim, reason) != 3) {
    notify_fail("Syntax: suspend <name> <time> <reason>\nWhere time is in hours.\n");
    return 0;
  }
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->suspend_person(name, tim*60*60, reason))
    return 0;
  write(name+" suspended until "+ctime(time()+tim*60*60)+"\n");
  return 1;
}
int do_unsuspend(string str) {
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->unsuspend_person(str))
    return 0;
  write(str+" unsuspended.\n");
  return 1;
}

==================================================
FILE: admin/room/terrain.c
==================================================

#include "path.h"
#include <terrain.h>
#define COLS (int)this_player()->query_cols()
inherit "/std/room/basic_room";
int do_help();
int do_terrain(string name);
int do_list(string what);
int do_member(string type, string params);
int do_clear();
int do_add(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level);
int do_remove(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2);
string terrain_name;
object generator;
void setup() {
   set_short( "terrain-maker room" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This room is quite bare, save a notice that has been "
         "taped on the door but its walls have been painted with "
         "scenes of deserts and forests, oceans and mountains, caves and "
         "swamps, and all manner of other types of terrain.\n"
         "Use \"help room\" to list the room's commands.\n" );
   add_exit( "northwest", ROOM +"development", "door" );
   add_sign("The large notice has furled corners and has been taped "
           "and re-taped to the door.\n",
           "Due to the incomprehensible help in this room, this \n"
           "notice was put up to help with the confusion.\n"
           "\n"
           "1.  To get information on a certain terrain, you\n"
           "    need to select that terrain by typing \n"
           "    \"terrain <terrain_name>\".\n"
           "\n"
           "2.  To remove floating or fixed locations within the terrain,\n"
           "    type \"list floating\" or \"list fixed\".\n"
           "\n"
           "    remove floating <path of terrain> <all 6 co ordinates> <level>\n"
           "\n"
           "    remove fixed <path of room>\n"
           "\n"
           "3.  To add a floating location, same as above, only use add.\n"
           "    For both removing and adding, no commas and no .c at the end\n"
           "    of path names.  When removing/adding fixed locations, all\n"
           "    locations must be done one by one.\n", 0, "notice");
}
void reset() {
   if ( !generator ) {
      generator = clone_object( "/obj/handlers/terrain_things/dungeon_maker" );
      generator->move( this_object() );
   }
}
void init() {
  ::init();
  add_command("help", "room", (: do_help() :) );
  add_command("terrain", "<string>", (: do_terrain($4[0]) :) );
  add_command("list", "fixed", (: do_list("fixed") :) );
  add_command("list", "floating", (: do_list("floating") :) );
  add_command("member", "", (: do_member(0,0) :) );
  add_command("member", "fixed <string>",
    (: do_member("fixed", $4[0]) :) );
  add_command("member", "floating <string>",
    (: do_member("floating", $4[0]) :) );
  add_command("add",
    "fixed <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_add(0, $4[0], $4[1], $4[2], $4[3], 0, 0, 0, 0) :) );
  add_command("add",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'> <number'level'>",
    (: do_add(1, $4[0], $4[1], $4[2], $4[3],
                        $4[4], $4[5], $4[6],
                 $4[7]) :) );
  add_command("add",
    "floating <word'file'> <number'x'> <number'y'> <number'z'> "
      "<number'level'>",
    (: do_add(2, $4[0], $4[1], $4[2], $4[3],
                        0, 0, 0,
                 $4[4]) :) );
  add_command("remove",
    "fixed <word'file'>",
    (: do_remove(0, $4[0], 0, 0, 0, 0, 0, 0) :) );
  add_command("remove",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'>",
    (: do_remove(1, $4[0], $4[1], $4[2], $4[3],
		 $4[4], $4[5], $4[6]) :) );
  add_command("remove",
    "floating <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_remove(2, $4[0], $4[1], $4[2], $4[3],
		 0, 0, 0 ) :) );
  add_command("clear", "", (: do_clear() :) );
}
int do_help () {
  write( "Available commands are:\n\n"+
      "     terrain  -  set terrain name\n"+
      "     list     -  list locations in current terrain\n"+
      "     member   -  find locations matching coordinates\n"+
      "     add      -  add a new location\n"+
      "     remove   -  remove an old location\n"+
      "     clear    -  clear all clones and connections\n" );
  return 1;
}
int do_terrain( string name ) {
  if ( !name ) {
    if ( stringp( terrain_name ) )
      write( "Terrain name is "+ terrain_name +".\n" );
    else
      write( "There is no terrain name set.\n" );
    return 1;
  }
  write( "Terrain name set to "+ name +".\n" );
  terrain_name = name;
  return 1;
}
int do_list( string word ) {
  int i, size;
  string list;
  mapping locations;
  mixed indeces, values;
  if ( ( word != "fixed" ) && ( word != "floating" ) ) {
    write( "List what? Options are \"fixed\" and \"floating\".\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if ( !( (int)TERRAIN_MAP->get_data_file( terrain_name ) ) ) {
    write( "There are no locations in the terrain "+ terrain_name +".\n" );
    return 1;
  }
  if ( word == "fixed" ) {
    locations = (mapping)TERRAIN_MAP->query_fixed_locations( terrain_name );
    size = m_sizeof( locations );
    indeces = m_indices( locations );
    values = m_values( locations );
    if ( !size ) {
      write( "There are no fixed locations in the terrain "+ terrain_name
                +".\n" );
      return 1;
    }
    list = "The terrain "+ terrain_name +" has the following fixed location"+
              ( size == 1 ? "" : "s" ) +":\n";
    for ( i = 0; i < size; i++ )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, indeces[ i ] +
          " at ("+ values[ i ][ 0 ] +", "+ values[ i ][ 1 ] +", "+
          values[ i ][ 2 ] +")" );
    this_player()->more_string( list, "Fixed" );
    return 1;
  }
  locations = (mapping)TERRAIN_MAP->query_floating_locations( terrain_name );
  size = sizeof( locations );
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name
              +".\n" );
    return 1;
  }
  list = "The terrain "+ terrain_name +" has the following floating "+
      "location"+ ( size == 1 ? "" : "s" ) +":\n";
  for ( i = 0; i < size; i++ )
    if ( sizeof( locations[ i ][ 1 ] ) == 3 )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " at ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +"), level "+ locations[ i ][ 2 ] );
    else
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " from ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +") to ("+ locations[ i ][ 1 ][ 3 ] +
          ", "+ locations[ i ][ 1 ][ 4 ] +", "+ locations[ i ][ 1 ][ 5 ] +
          "), level "+ locations[ i ][ 2 ] );
  this_player()->more_string( list, "Floating" );
  return 1;
}
int do_member( string type, string parameters ) {
  int i, size, *co_ords;
  string list, location;
  mixed *locations;
  if (!type || !parameters) {
    write( "Syntax: member <fixed|floating> <coord1> ...\n" );
    return 1;
  }
  if ( ( type != "fixed" ) && ( type != "floating" ) ) {
    write( "Syntax: member <fixed|floating> ...\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  co_ords = allocate( 3 );
  if ( type == "fixed" ) {
    if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ],
        co_ords[ 2 ] ) != 3 ) {
      write( "Syntax: member fixed <coord1> <coord2> <coord3>\n" );
      return 1;
    }
    TERRAIN_MAP->get_data_file( terrain_name );
    location = (string)TERRAIN_MAP->member_fixed_locations( co_ords );
    if ( !location ) {
      write( "There is no fixed location in the terrain "+ terrain_name +
          " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
          ").\n" );
      return 1;
    }
    write( "The terrain "+ terrain_name +" has "+ location +" as a fixed "+
        "location at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ], co_ords[ 2 ] )
      != 3 ) {
    write( "Syntax: member floating <coord1> <coord2> <coord3>\n" );
    return 1;
  }
  TERRAIN_MAP->get_data_file( terrain_name );
  locations = (mixed *)TERRAIN_MAP->member_floating_locations( co_ords );
  size = sizeof( locations ) / 2;
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name +
        " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  list = "There "+ ( size == 1 ? "is one floating location" : "are "+
      query_num( size ) +" floating locations " ) +" in the terrain "+
      terrain_name +" at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+
      co_ords[ 2 ] +"):\n";
  for ( i = 0; i < size; i++ )
    list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ 2 * i ] +
        ", level "+ locations[ 2 * i + 1 ] );
  this_player()->more_string( list, "Member" );
  return 1;
}
int do_add(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 0 || floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if (floating == 0) {
    if ( !TERRAIN_MAP->add_fixed_location( terrain_name, file, co_ords ) ) {
      write( "The fixed location "+ file +" in the terrain "+ terrain_name
                +" already exists.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been added to the terrain "+
        terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +").\n" );
    return 1;
  }
  TERRAIN_MAP->add_floating_location( terrain_name, file, co_ords, level );
  if ( sizeof( co_ords ) == 6 )
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
        ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") at level "+ level +".\n" );
  else
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") and level "+ level +".\n" );
  return 1;
}
int do_remove(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else if (floating == 1) {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if ( floating == 0 ) {
    if ( !TERRAIN_MAP->delete_fixed_location( terrain_name, file ) ) {
      write( "There is no fixed location "+ file +" in the terrain "+
          terrain_name +" to remove.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been removed from the terrain "+
        terrain_name +".\n" );
    return 1;
  }
  if ( !TERRAIN_MAP->delete_floating_location( terrain_name, file, co_ords ) ) {
    if ( sizeof( co_ords ) == 6 )
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
          co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
          ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") to remove.\n" );
    else
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
          ", "+ co_ords[ 2 ] +") to remove.\n" );
    return 1;
  }
  if ( sizeof( co_ords ) == 6 )
    write( "The floating location using "+ file +" in the terrain "+
        terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +", "+
        co_ords[ 4 ] +", "+ co_ords[ 5 ] +") has been removed.\n" );
  else
    write( "The floating location using "+ file +" in the terrain "+
      terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
      ", "+ co_ords[ 2 ] +") has been removed.\n" );
  return 1;
}
int do_clear() {
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  TERRAIN_MAP->clear_cloned_locations( terrain_name );
  TERRAIN_MAP->clear_connections( terrain_name );
  write( "Clones and connections cleared for the terrain "+ terrain_name +
      ".\n" );
  return 1;
}

==================================================
FILE: admin/room/we_care/club_room_controller.c
==================================================

#include <clubs.h>
inherit "/std/room/controller/club_room_controller";
#include <room/club_room.h>
void setup() {
   set_save_file("/d/admin/save/club_room");
   set_board_associated(1);
   add_controlled_ownership("main room",
                            CLUB_ROOM_CONTROLLER_DISCUSSED,
                            CLUB_ROOM_OWNED_POSITION,
                            (: CLUB_HANDLER->query_president_position($2) :));
}

==================================================
FILE: admin/room/we_care/main_club_room.c
==================================================

#include "path.h"
inherit "/std/room/club_room";
void setup() {
   set_short("main club room");
   set_long("The main club room.\n");
   set_club_controller(CONTROLLER);
   set_light(70);
   set_leave_exit("south");
   add_exit("south", "/d/admin/room/meeting", "door");
}

==================================================
FILE: admin/room/we_care/owned_room1.c
==================================================

inherit "/std/room/inherit/club_owned_room";
#include "path.h"
void setup() {
   set_short("The first owned room");
   set_long("A room that is owned.\n");
   set_club_controller(CLUB_CONTROLLER);
   set_club_owned_id("main office");
}

==================================================
FILE: admin/obj/bingle.c
==================================================

inherit "/std/object";
void setup() {
  set_name("domainer");
  set_long(
"This object shows you all of the creators who are in each domain and those "+
"that don't have directorys, are not cretors and ones who are not in a "+
"domain at all.\nThe command to view all this is \"info\".\n");
}
void init() {
  add_action("do_info", "info");
}
int do_info(string str) {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;
  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = get_dir("/d/");
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!"/secure/login"->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
    creators -= mem;
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!"/secure/login"->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
}

==================================================
FILE: admin/obj/check.c
==================================================

#define SAVE_FILE "/d/admin/log/"
string *paths, *cloned_by;
int *times;
mapping illegal;
void dest_me()
{
   destruct(this_object());
}
void create()
{
   illegal = ([ ]);
   paths = ({ });
   cloned_by = ({ });
}
void log_file()
{
   int p;
   string *person, *filename;
   filename=m_indices(illegal);
   person=values(illegal);
   if(sizeof(illegal)>0) {
      unguarded((: write_file, SAVE_FILE+"illegal.txt",
                 "\nSearch carried out on "+ctime(time())+" from here.\n" :));
      for(p=0;p<sizeof(illegal);p++) {
         unguarded((: write_file, SAVE_FILE+"illegal.txt",
                    filename[p]+"  -  on player "+person[p]+" - cloned by "+
                    cloned_by[p]+"\n" :));
      }
   }
}
void check_sub_inv(object *things, object owner)
{
int q, r, check;
string *pre_filename, filename, *switcher;
mixed info;
   for(q=0;q<sizeof(things);q++)
   {
      pre_filename=explode(file_name(things[q]),"#");
      filename=pre_filename[0];
      switcher=explode(filename,"/");
      if( (switcher[0]=="w") && (!owner->query_creator() ) )
      {
         illegal=illegal+([filename:owner->query_name()]);
         info = things[q]->stats();
         for(r=0; r<sizeof(info);r++)
         {
            if(info[r][0] == "cloned by")
            {
               cloned_by = cloned_by + ({ info[r][1] });
            }
         }
           destruct(things[q]);
       }
      if ( (!owner->query_creator()) && (sizeof(switcher)>2) && (switcher[0]=="obj") && (switcher[1]=="misc") )
      {
         switch(switcher[2]){
         case "mailer_ob":
         case "board_mas":
            info = things[q]->stats();
            for(r=0; r<sizeof(info);r++)
            {
               if(info[r][0] == "cloned by")
               {
                  cloned_by = cloned_by + ({ info[r][1] });
               }
            }
            illegal=illegal+([filename:owner->query_name()]);
             destruct(things[q]);
            break;
         }
      }
   }
}
void check_inv(object player)
{
int q;
object *things, *contents, owner;
   things=deep_inventory(player);
   owner=player;
   check_sub_inv(things, player);
}
do_seek()
{
   int p;
   object *everyone_on;
   seteuid("Admin");
   everyone_on = users();
   for(p=0;p<sizeof(everyone_on);p++)
   {
      check_inv(everyone_on[p]);
   }
   log_file();
   return 1;
}

==================================================
FILE: admin/obj/inv_check.c
==================================================

#include <playtesters.h>
#include <move_failures.h>
#define FILENAME "/save/inv_check"
int do_seek();
nosave string to_log;
string *forbidden = ({ });
void save_me() {
  unguarded ((: save_object (FILENAME) :));
}
void dest_me() {
   destruct( this_object() );
   save_me();
}
void create() {
  seteuid( "Admin" );
  unguarded ((: restore_object (FILENAME) :));
  do_seek();
}
void log_it() {
   if( sizeof( to_log ) > 0 ) {
      log_file( "ILLEGAL_OBJECT",
               "Illegal objects removed %s\n%s\n",
               ctime( time() ),
               to_log );
   }
}
void check_sub_inv( object *things, string owner, object owner_ob ) {
   string *pre_filename, filename, *switcher;
   object *obs, thing;
   object *contents, *fragile;
   string mess = "";
   object bag;
   obs = ({ });
   foreach ( thing in things ) {
     if ( thing->query_property( "virtual name" ) ) {
       filename = thing->query_property( "virtual name" );
     } else {
       pre_filename = explode( file_name( thing ),"#" );
       filename = pre_filename[ 0 ];
     }
      switcher = explode( filename, "/" );
      if( ( switcher[0]=="w" ) &&
          ( !"/obj/handlers/playtesters"->query_playtester( owner ) ) ) {
         to_log += sprintf("%s in %s, cloned by %s\n",
                           filename, owner,
                           (string)thing->query_cloned_by() );
         obs += ({ thing });
      }
      if ( ( sizeof( switcher ) > 2 ) &&
          ( switcher[ 0 ] == "obj" ) &&
          ( switcher[ 1 ] == "misc" ) ) {
         switch(switcher[2]){
          case "mailer_ob":
            if ( !"/obj/handlers/playtesters"->query_playtester( owner ) &&
                 ( !owner_ob->query_property("allowed mailer")) ) {
               to_log += sprintf("%s in %s, cloned by %s\n",
                                 filename, owner,
                                 (string)thing->query_cloned_by() );
               obs += ({ thing });
            }
            break;
          case "board_mas":
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            break;
         }
      }
      if (sizeof (switcher) ==4 &&
        switcher [0] == "d" &&
        switcher [1] == "liaison" &&
        switcher [2] == "items") {
           to_log += sprintf("%s in %s, cloned by %s\n",
                             filename, owner,
                             (string)thing->query_cloned_by() );
           obs += ({ thing });
      }
      reset_eval_cost();
      if (member_array (filename, forbidden) != -1) {
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            thing->add_property ("no recycling", 1);
            if (function_exists ("query_max_weight", thing)) {
              contents = all_inventory (thing);
            }
      }
   }
   if ( sizeof( obs ) ) {
      tell_object (owner_ob, owner_ob->colour_event ("say", "%^CYAN%^") +
        "A small official looking dwarf walks up to you and says: In "
        "accordance with paragraph 5, sub-paragraph 7 of the Domestic "
        "& Domesticated Animals (Care & Protection) Act, 1673, I hereby "
        "remove from you: "+ (string)query_multiple_short( obs, "one" )
        + ".%^RESET%^");
      if (sizeof (contents)) {
        mess += "\nThe dwarf removes all the inventory from the confiscated "
          "items.";
        fragile = filter (contents, (: $1->query_property("fragile") :));
        if (sizeof (fragile)) {
          mess += "\nHe hands " + query_multiple_short (fragile) + " to "
            "you.\n";
          contents -= fragile;
          fragile->move (owner_ob);
        }
        if (sizeof (contents)) {
          bag = clone_object ("/obj/baggage");
          bag->set_name ("bag");
          bag->set_short ("brown paper bag");
          bag->add_adjective (({"brown", "paper"}));
          bag->set_weight(5);
          bag->set_max_weight (implode (map (contents,
            (: $1->query_complete_weight() :)),(: $1 + $2 :)) + 1);
          bag->set_value (0);
          bag->set_long ("This is a plain, brown, paper bag... the kind grubby "
            "old men are often found in possession of after leaving their "
            "local newsagent.\n");
          contents->move (bag);
          if (bag->move (owner_ob) == MOVE_TOO_HEAVY) {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and leaves it on the ground.";
          }
          else {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and hands it to you.";
          }
        }
      }
      mess += "\nHe scribbles something on a clipboard, then walks away.\n";
      tell_object (owner_ob, mess);
      obs->move( "/room/rubbish" );
      call_out( "check_obs", 7, obs );
   }
}
void check_obs( object* obs ) {
   object thing;
   foreach( thing in obs ) {
      if( thing ) {
   thing->dest_me();
      }
   }
}
void check_inv( object player ) {
   object *things;
   things = deep_inventory( player );
   check_sub_inv( things, (string)player->query_name(), player );
}
int do_seek() {
  object user;
  to_log = "";
  foreach ( user in users() ) {
    if( user && !user->query_property( "guest" ) &&
       !user->query_creator() &&
       !PLAYTESTER_HAND->query_tester (user) &&
       !user->query_property ("test character") ) {
      check_inv( user );
    }
  }
  log_it();
  call_out( "do_seek", 300 );
  return 1;
}
int query_theft_command() { return -1; }
string parse_filename (string str) {
  if (strsrch (str, ".wep") != -1 ||
      strsrch (str, ".clo") != -1 ||
      strsrch (str, ".ob") != -1 ||
      strsrch (str, ".arm") != -1 ||
      strsrch (str, ".food") != -1 ||
      strsrch (str, ".sca") != -1) {
        if (file_size(str) <= 0) {
          return 0;
        }
        else {
          return str;
        }
  }
  else {
    str = explode (str, ".c")[0];
    if (file_size(str + ".c") <= 0 ) {
      return 0;
    }
    else {
      return str;
    }
  }
}
int ban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to ban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) == -1) {
      forbidden += ({ filename });
      printf ("%s added to the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s already banned.\n", filename);
    }
  }
  return 1;
}
int unban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to unban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) != -1) {
      forbidden -= ({ filename });
      printf ("%s removed from the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s not currently banned.\n", filename);
    }
  }
  return 1;
}
string list_banned() {
  if (sizeof (forbidden)) {
    return sprintf ("Objects cloned from the following filenames "
      "will be confiscated by the dwarves:\n%s\n",
      implode (forbidden, "\n"));
  }
  else {
    return "There are no objects currently forbidden.\n";
  }
}
mixed stats()
{
  return ({
    ({ "Time until next tick", query_num (find_call_out ("do_seek"))
      + " seconds"}),
  });
}

==================================================
FILE: liaison/common.c
==================================================

#include <config.h>
#define DOM_TITLE "Liaison Domain"
#define LORD "wyvyrn"
#define DOMAIN "liaison"
#define BOSS_ROOM "/w/wyvyrn/rooms/office"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
   set_dom( DOMAIN );
   set_light( 100 );
   set_short( "Liaison Domain Common room" );
   add_property( "determinate", "the " );
   set_long("The Liaison common room looks like a comfortable place to "
            "come to after a hard day's liaising.  The large pile of stress "
            "balls sat in one corner and the drinks cabinet against a wall "
            "highlight this.  The various evil-looking devices scattered "
            "around the room seem to add character and even a slightly "
            "malicious overtone to the entire place.  There are also a "
            "few chairs scattered around the place providing welcome bum "
            "relief.  One even looks to be occupied.\n"
            "A sign is hanging on the wall.\n");
   add_alias("balls", "ball");
   add_alias("devices", "device");
   add_alias("bottles", "bottle");
   add_alias("chairs", "chair");
   add_alias("whips", "whip");
   add_alias("chains", "chain");
   add_alias("easy chair", "chair");
   add_alias("dolls", "doll");
   add_alias("armrests", "armrest");
   add_alias("cushions", "cushion");
   add_alias("strings", "string");
   add_alias("needles", "needle");
   add_item( ({"ball", "stress ball"}), "The pile of stress balls seems very "
            "inviting, albeit until you get up close and see that they are "
            "actually coated in tough plastic and tied to a pole with string - "
            "effectively ending their usefulness.  They look nice though.");
   add_item("string", "Each piece of string connects a ball to the pole, "
            "stopping the ball moving very far.  Cruel.");
   add_item("pile", "The pile of stress balls seems very inviting, albeit "
            "until you get up close and see that they are actually coated in "
            "tough plastic and tied to a pole with string - effectively "
            "ending their usefulness. They look nice though.");
   add_item("lock", "A big lock that looks completely unpickable, mainly due "
            "to it having no keyhole.  Nothing will unlock it, so you heavy "
            "drinkers are just out of luck.");
   add_item("corner", "A corner of the room. Where two walls, the ceiling "
            "and the floor meet.");
   add_item("pole", "There is a short pole hiding unobtrusively behind the "
            "stress balls and it is only through very close scruitiny that "
            "it is actually noticable at all.  The pole seems to have "
            "lots of strings coming out of it, each of which lead to a "
            "stress ball, limiting the distance it can travel.\n"
            "It is secured to the floor and cannot come out.");
   add_item("device", "Devices of differing shapes and sizes litter most "
            "of the walls - all seemingly to do with harming nasty players. "
            " From the voodoo dolls in one corner to the rack in another, "
            "not to mention the whips and chains.  Serious stuff.");
   add_item("whip", "I told you not to mention them.");
   add_item("chain", "I told you not to mention them.");
   add_item("bottle", "The bottles line the inside of the cabinet, all "
            "different shapes and sizes of bottles.  Green bottles, "
            "blue bottles, red bottles, bottles with caterpillers in, "
            "bottles with toads in, bottles with DUCKs in, bottles "
            "with labels on, bottles with warnings on, bottles with "
            "skulls and crossbones on, so basically, lots of bottles.");
   add_item("cabinet", "The drinks cabinet is leaning idly against a "
            "wall [as much as a drinks cabinet can] and seems to sneer "
            "at you [as much as a drinks cabinet can].  The polished "
            "glass of the cabinet windows show all the drinks that "
            "seem to look smug [as much as bottles can].  The large "
            "lock holding the cabinet shut makes the bottles "
            "completely out of range.\n"
            "If you are really desperate, "
            "clone /w/lucifer/misc/blasterbottle.c and go nuts.");
   add_item("glass", "It's just some glass in the cabinet.  Nothing "
            "special.");
   add_item("chair", "The easy chairs that line the walls are "
            "pretty nondescript: big "
            "deep cushions and fluffy armrests, but that's all "
            "they are - and ever will be: chairs.  "
            "As a profound sense of misery sweeps over you, you "
            "notice one of the chairs is occupied by a rather "
            "despondant looking man.");
   add_item("doll", "The voodoo dolls lie in a messy pile in a "
            "corner of the room, looking particularly morbid with "
            "a hundred different needles sticking out at various "
            "points of their doll bodies.  The faces of the dolls "
            "are hard to make out, seeming to shift from likeness to "
            "likeness as you look at them.  There is a barrier in front "
            "of the dolls, suggesting they shouldn't be touched.");
   add_item("barrier", "A thick looking piece of metal completely blocking "
            "all access to the dolls.  Most probably for the best, too.");
   add_item("needle", "The needles are -unsurprisingly- sharp things "
            "currently embedded into the dolls, no doubt causing extreme "
            "pain.  Well, at least they would if the dolls were real. "
            "Which they aren't.  Which is a good thing.");
   add_item("rack", "The rack is a vicious looking instrument that allows "
            "the human [or non-human] body to be stretched to completely "
            "wrong proportions.  This is something that should be used "
            "with extreme caution.  Happily, it appears not to have been "
            "used yet [there is a still plastic covering on it] and long "
            "may it stay that way.");
   add_item("covering", "Mercifully there is a covering on the rack, "
            "showing it has never been used.  Which is a good thing.");
   add_item("armrest", "It's an armrest.  You rest your arm on it.");
   add_item("wall", "It's a wall.  That's about it.");
   add_item("cushion", "It's a cushion. You rest your bum on it.");
   add_item("man", "The man seated in one of the easy chairs looks "
            "to have resigned himself to a lifetime there, and "
            "from what you can see there appears to be a deep "
            "groove in the chair from his body shape.\n"
            "He notices you looking at him and speaks slowly, like he "
            "has nearly forgotten how: 'Do you know how long Moonchild "
            "will be? I've been waiting here for over 5 years now! I "
            "missed the fall of quest XP and everything - just because "
            "I wanted my items back!'\n"
            "As the man starts to froth at the mouth, you hurriedly turn "
            "your back on him and leave him to his waiting.");
   add_sign("This is a sign.  But then you knew that, or at least we hope "
            "you did.\n",
            "Commands available here are:\n"
            "add <name>   : add <name> as one of your characters.\n"
            "remove <name>: remove <name> as one of your characters.\n"
            "list [<name>]: list characters added for you or <name>.", 0, 0, 0);
   board = clone_object("/obj/misc/board");
   board->set_datafile(DOMAIN);
   board->move(this_object());
   add_exit("office", "/w/wyvyrn/rooms/study", "door");
   add_exit("drum", CONFIG_START_LOCATION, "path");
   add_exit("corridor", "/d/liaison/cre_corridor", "door");
   add_exit("interview", "/d/liaison/utils/interview", "door");
   BOSS_ROOM->add_exit("common", "/d/"+DOMAIN+"/common", "door");
}
void init() {
   this_player()->add_command( "add", this_object(), "<word> <word>" );
   this_player()->add_command( "add", this_object(), "<word>" );
   this_player()->add_command( "remove", this_object(), "<word> <word>" );
   this_player()->add_command( "remove", this_object(), "<word>" );
   this_player()->add_command( "list", this_object(), "" );
   this_player()->add_command( "list", this_object(), "<word>" );
}
int do_add( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->add_member_alias( args[ 0 ],
                                                    args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                args[ 1 ] +" added as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can add aliases to others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->add_member_alias( this_player()->query_name(),
                                                 args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                args[ 0 ] +" added as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                "Couldn't add "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_remove( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->delete_member_alias( args[ 0 ],
                                                       args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                    args[ 1 ] +" removed as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can remove aliases for others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->delete_member_alias(
                 this_player()->query_name(), args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                 args[ 0 ] +" removed as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                 "Couldn't remove "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_list( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   string *names, name;
   int i;
   switch( pattern ) {
    case "<word>":
      name = args[ 0 ];
      break;
    case "":
      name = this_player()->query_name();
      break;
   }
   names = "/d/liaison/master"->member_alias( name );
   name = capitalize( name );
   i = sizeof( names );
   if ( i ) {
      if ( i > 1 ) {
         while ( i-- ) {
            names[ i ] = capitalize( names[ i ] );
         }
         this_player()->add_succeeded_mess( this_object(),
                "Aliases for "+ name +" are "+
                query_multiple_short( names )+".\n" );
      } else {
         this_player()->add_succeeded_mess( this_object(),
                "Alias for "+ name +" is "+
                capitalize( names[ 0 ] )+".\n" );
      }
   } else {
      this_player()->add_succeeded_mess( this_object(),
             "No aliases known for "+ name +".\n" );
   }
   return 1;
}

==================================================
FILE: liaison/cre_corridor.c
==================================================

inherit "/std/room/basic_room";
string do_mirror();
void setup() {
    set_short("Liaison hallway");
    set_light(100);
    add_property("determinate", "the ");
    set_long("This is the homely corridor of the Liaison Domain.  There are "
             "a lot of doors leading off here, hopefully taking the plucky "
             "entrant a-wandering into Liaison workrooms.  Exercise caution "
             "as some Creators prefer you to ask or at least knock first.  "
             "Apart from the doors here there are some paintings of various "
             "people, as well as a large floor to ceiling mirror. Taking "
             "pride of place on one of the walls, however, is an ancient "
             "looking scroll housed in a picture frame.  There is "
             "also a sign here.\n");
    add_item("doors", "Lots of doors.  Tall doors, short doors, red doors, "
             "blue doors, green doors, thin doors, wide doors, old doors, "
             "grimy doors, wooden doors, metal doors and even a padded "
             "red linonium door - kinky.  However, you can only go through "
             "the doors marked in the exits, sorry.");
    add_item("paintings", "Paintings of people who have been important to "
             "the domain.  There's one of Ohdamn, Moonchild, Olorin, Shalla, "
             "Kaea, Nevvyn, Wyvyrn and - strangely enough - You.");
    add_item("painting of ohdamn", "The painting of Ohdamn shows a very "
             "tall man with reddish blond hair.  He appears to be carrying "
             "a box of chocolates and looks to be in the middle of a rousing "
             "love song, which may have something to do with the bottle of "
             "rum in his other hand.");
    add_item(({"mission", "scroll", "statement"}), "It's the liaison "
             "statement of mission!\n"
             "Or mission statement, if you would prefer.\n\n"
             "Our mission in the Liaison Domain is to give continuous "
             "support to the creator and player bases and facilitate "
             "communcation between them.\n"
             "Through a diverse range of activities, we aim to maintain "
             "Discworld MUD as an enjoyable, interesting, in-theme and "
             "safe virtual space.\n"
             "We seek to contribute to Discworld MUD as a visible and helpful "
             "helpful first point of creator contact for players.  Additionally, "
             "we will work within assigned creator areas to assist in the "
             "development and implementation of concepts.\n\n"
             "Impressive, huh?");
    add_alias("mission", "statement");
    add_item("frame", "It's just a frame holding a large scroll in place.");
    add_item("hair", "It's hair.  It's reddish blond and it's Ohdamn's.");
    add_item("rum", "It's rum.  Held very securely by Ohdamn.");
    add_item("chocolates", "They are chocolates.  On Ohdamn's painting.");
    add_item("painting of moonchild", "The painting of Moonchild shows a "
             "looming lady with a big whip and an evil grin.  She appears "
             "to be half in shadows.");
    add_item("whip", "A fearsome looking whip that seems to fit well in "
             "Moonchild's hand.");
    add_item("painting of olorin", "Olorin's picture appears to be only "
             "half done - as if the artist didn't have time to finish it.");
    add_item("painting of shalla", "Shalla's painting depicts a pretty "
             "lady and although she is fully clothed, your attention is "
             "drawn to her socks.  Strange.");
    add_item("socks", "Stop looking - that's illegal in some countries!");
    add_item("painting of kaea", "Kaea's painting shows a young lady with a "
             "silly looking grin on her face and giggling.  Seems to say it "
             "all really...");
    add_item("painting of nevvyn", "The painting of Nevvyn shows a man with a "
             "pint hefted in a salute and a cheeky looking grin on his face.");
    add_item("pint", "A half empty pint in Nevvyn's hand.  Says it all!");
    add_item("painting of wyvyrn", "Wyvyrn's painting depicts a ... well, a "
             "Wyvyrn.  He looks a bit like a dragon and has green wings - but "
             "seems to have the distinct disadvantage of looking cute.");
    add_item("wings", "Wings.  On Wyvyrn.");
    add_alias("painting of me", "painting of you");
    add_item("painting of you", "The painting of you is ... well, blank with the "
             "words 'Your Name Here' on it.  You get the feeling its a rather "
             "cheesy way of saying everyone is important!  If it wasn't so "
             "cheesy it might make you feel better.");
    add_sign("This is an important sign, for viewing along with the "
             "paintings.\n",
             "If you are having problems seeing the paintings, look at "
             "painting of <person>.  "
             "Please note: These paintings are done on collective images.  "
             "Basically, if you don't like your portrait, don't beat Luci "
             "up.  Thanks!");
    add_item("mirror", (: do_mirror() :));
    add_exit("common", "/d/liaison/common", "door");
    add_exit("drum", "/d/am/am/mendeddrum", "path");
}
string do_mirror() {
  string text;
  text = "The mirror is a full length floor to ceiling job, a full length "
    "mirror in the true sense of the word.  It's here to make sure you look "
    "you look your best.  Good job you are checking!\n\n";
  text += this_player()->long(this_player());
  tell_room (this_object(), this_player()->short() + " checks " +
    this_player()->query_objective() + "self in the big mirror.  Poser.\n",
    this_player());
  return text;
}

==================================================
FILE: liaison/master.c
==================================================

#define LORD "wyvyrn"
#define DOMAIN "liaison"
#include <liaison.h>
inherit "/std/dom/base_master";
mapping member_alias;
nosave string* member_cache = 0;
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return "eron";
}
string query_info() {
  if (file_size(LIAISON_DOMAIN_INFO) < 0) {
    return "\nFor information on this domain, please visit "
           "http:
  }
  return "\n"+ unguarded((: read_file(LIAISON_DOMAIN_INFO) :)) +"\n";
}
string *member_alias( string name ) {
   int i;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( undefinedp( members[ name ] ) ) {
      map_delete(member_alias, name);
      return 0;
   }
   if ( !member_alias[ name ] )
      member_alias[ name ] = ({ });
   i = sizeof( member_alias[ name ] );
   while ( i-- )
      member_alias[ name ][ i ] = lower_case( member_alias[ name ][ i ] );
   return member_alias[ name ] + ({ });
}
int add_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !"/secure/login"->test_user( alias ) )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   member_alias[ name ] += ({ alias });
   save_me();
   return 1;
}
int delete_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   save_me();
   return 1;
}
string *query_unsorted_members() {
    return ::query_members();
}
string *query_members() {
    string* temporary_array = ({});
    string* first = ({});
    string* seniors = ({});
    string* newbies = ({});
    if (!member_cache) {
        first = ({ query_lord() })   +
                sort_array(query_deputies(),1);
        temporary_array = ::query_members() - first;
        temporary_array = sort_array( temporary_array, 1 );
        foreach ( string person in temporary_array ) {
          if ( master()->query_senior(person) ) {
              seniors += ({ person });
          }
        }
        temporary_array -= seniors;
        foreach ( string person in temporary_array ) {
          if ( regexp( members[ person ], "^(N|n)ewbie$" ) ) {
              newbies += ({ person });
          }
        }
        temporary_array -= newbies;
        member_cache = first + seniors + temporary_array + newbies;
    }
    return copy(member_cache);
}
string *query_projects() {
    return values(members);
}

==================================================
FILE: liaison/NEWBIE/advancement.c
==================================================

#include "path.h"
inherit PATH + "inside";
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short("Advancement Room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a rather cosy room designed to encourage visitors to "
            "linger a while and read a few of the notices pinned to the "
            "walls.  The air is thick and overly warm, and there is a "
            "pervasive odour of stale tea, mothballs, and elderly ladies who "
            "collect rather more cats and string than they can properly "
            "handle.  "
            "Several overstuffed sofas have been grouped in the centre "
            "of the room along with wobbly occasional tables.  There is "
            "a small cage holding an odd-looking creature in one corner, "
            "and an immense ball of yarn in the other.  A door to the south "
            "leads back to the foyer.\n");
  add_item(({ "floor", "ground" }), "The floor is scuffed, dusty wood.  It "
           "was probably nice at some point.");
  add_item( "wall", "The walls (what can be seen of them under the notices) "
            "have been covered with a gaudy floral paper.");
  add_item(({ "paper", "wallpaper", "floral", "flower" }), "The wallpaper has "
            "a dark, muddy background covered with enormous fantasy flowers "
            "in red, blue, and yellow.");
  add_item( "door", "The plain wooden door has been propped open in an effort "
            "to let some of the stale air out.");
  add_item( "cage", "The cage is a small, rickety bamboo affair with a tiny "
            "door tied closed with a strand of wire.  It contains a strange "
            "creature.");
  add_item( "creature", "The creature is a pale, translucent colour.  It has "
            "long, spindly legs, big teeth, and eyes that glow like lamps "
            "when it is awake.  Even though it is small, you sense it would "
            "not be wise to disturb it.  It is holding a small card.");
  add_item( "wire", "The wire holding the cage door shut is a hopelessly "
            "twisted mass of spun octiron, the magical metal of Discworld.");
  add_item( "card", "The card is stamped 'Demon Local 45, Holywood' in "
            "fading ink.");
  add_item(({"ball", "yarn"}), "A large ball of string.");
  add_item("notice",
           ({ "long", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n",
                "read", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n"}));
  add_item("sofa", ({"long", "Several well-stuffed and well-worn sofas with "
                       "rather dirty, brown upholstery.",
                       "position", "a sofa",
                       "position multiple", 1 }));
  add_item("table", "A number of wobbly occasional tables made from "
           "some indeterminable kind of wood have been placed near the "
           "sofas.");
  sign=add_sign("A handwritten notice marked 'Statistics and Rearrange'.\n",
                "On Discworld your skill bonus typically determines your "
                "ability to perform a task.  Skill bonus is calculated "
                "from your skill level and your statistics.  Different "
                "stats affect different skills.\n"
                "Once you enter Discworld, you may rearrange your stats.  "
                "This should be done to improve your combination of "
                "constitution, dexterity, intelligence, strength and wisdom "
                "(your stats), but you are advised to wait until you have "
                "chosen a guild and have asked other guild members for "
                "advice.  Use the command 'rearrange' to do this, but "
                "consider it well, as you can only rearrange your stats "
                "once.\n", 0, "statistics", "general" );
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'statistics and rearrange'");
  sign=add_sign("A handwritten notice marked 'Guildpoints'.\n",
           "Guildpoints are a measure of your capability to perform guild "
           "commands such as stealing, fighting, casting spells or rituals, "
           "etc.  When you have used all your guild points, you will have to "
           "rest to allow them to regenerate.  For more information, type "
           "in 'help guildpoints'.\n", 0, "guildpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'guild points'");
  sign=add_sign("A handwritten notice marked 'Experience'.\n",
           "In addition to the direct skill advances provided by the "
           "taskmaster, quest completion, using your guild commands "
           "and by doing certain tasks, you are rewarded with "
           "experience points or XP.  These may be spent in advancing skills "
                "from your guild or by learning from other players.\n", 0,
                "experience", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'experience'");
  sign=add_sign("A handwritten notice marked 'Hitpoints'.\n",
           "Hitpoints, or HP determine how much damage you can take in "
           "combat before you die.  The number of hit points you have is "
           "dependent upon your stats (mostly Con) and on your levels of "
           "other.health.  Hitpoints regenerate gradually over time.  "
           "There are also a variety of other ways to be healed.  You "
           "can use 'monitor' to keep track of your hitpoints.  See also "
           "'help wimpy'.\n", 0, "hitpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'hitpoints'");
  sign=add_sign("A handwritten notice marked 'Skills'.\n",
           "To check your skill levels, use the command 'skills', and "
           "to see various statistics about yourself, use 'score'.  Your "
           "stats can also be reviewed using 'score stats'.  The command "
           "'help' will give you a variety of other topics with useful "
           "information.", 0, "skills", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'skills'");
  sign=add_sign("A handwritten notice marked 'advancement'.\n\n",
           "Skills can be advanced in a variety of ways on Discworld.  "
           "The guild you join will allow you to advance your skills "
           "for a certain number of experience points and a small fee.  "
           "When you reach the proper skill level your guild will "
           "teach you the commands that you will need to carry out "
           "your guild duties.\n"
           "You may also have another player teach you skills if they have "
           "a higher skill level than you, or you may teach yourself.  Both "
           "of these methods cost experience points, and it is generally more "
           "expensive to teach yourself.\n"
           "Finally, many of your skills can be advanced simply by performing "
           "tasks that make use of those skills.  For example, your fighting "
           "skills will get better as you participate in more fights.  For "
           "more information on this system, type "
           "'help taskmaster'.\n",0, "advancement", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'advancement'");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "south", "foyer");
}

==================================================
FILE: liaison/NEWBIE/align.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
inherit PATH+"common";
object _wlever;
object _blever;
object _glever;
int do_pull(object lever);
void setup() {
  object sign;
  set_zone("Newbie");
  set_short("alignment room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a small, bare room that is quite empty apart from "
            "a lever stuck onto each of three walls and a small wooden "
            "sign placed in the centre of the room.\n"
            "A door to the east leads back to the foyer.\n");
  add_item(({"west wall", "south wall", "east wall"}),
           "A plain, flat wall with a lever sticking out of it.");
  sign=add_sign("A sign marked 'alignment'.\n",
                FOYER->format_sign(
           "Alignment is how good or evil you are.  This changes gradually "
           "depending on the things you do.  Because it changes so slowly "
           "you can choose to start out with a good, neutral or evil "
           "alignment.  To become evil, pull the black lever, to become "
           "good pull the white lever, and to stay neutral don't pull "
           "either lever, or pull the grey lever if you have already pulled "
           "one of the other ones.\n"),0,"sign","general");
  sign->set_short("sign");
  sign->add_adjective("wooden");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door");
  add_alias( "east", "foyer");
  room_chat(({10, 40, ({"A voice which seems to come from the black lever "
                        "says: Don't be a goody-goody, pull me!",
                        "A voice which seems to come from the white lever "
                        "says: You should be nice, pull me!",
                        "A voice which seems to come from the grey lever "
                        "says: It's all about balance in the end."})}));
}
void init() {
  if (_wlever) {
     this_player()->add_command("pull", _wlever, "<direct:object>",
                              (: do_pull(_wlever) :));
  }
  if (_blever) {
     this_player()->add_command("pull", _blever, "<direct:object>",
                              (: do_pull(_blever) :));
  }
  if (_glever) {
     this_player()->add_command("pull", _glever, "<direct:object>",
                              (: do_pull(_glever) :));
  }
  ::init();
}
void reset() {
  if(!_wlever) {
    _wlever = clone_object("/std/object");
    _wlever->set_name("lever");
      _wlever->add_adjective("white");
    _wlever->set_short("white lever");
    _wlever->set_long("This is a lever which is set into the wall.  It "
                     "radiates a soft white glow.  The closer you stand "
                     "to it the more peaceful you feel.\n");
    _wlever->reset_get();
    _wlever->add_property("there", "on the east wall");
    _wlever->move(this_object());
  }
  if(!_blever) {
    _blever = clone_object("/std/object");
    _blever->set_name("lever");
    _blever->add_adjective("black");
    _blever->set_short("black lever");
    _blever->set_long("This is a lever which is set into the wall.  It "
                     "is pure black and emanates a deep, blood-red glow.  "
                     "The closer you get to it the more angry and hateful "
                     "you feel.\n");
    _blever->reset_get();
    _blever->add_property("there", "on the west wall");
    _blever->move(this_object());
  }
  if(!_glever) {
    _glever = clone_object("/std/object");
    _glever->set_name("lever");
    _glever->add_adjective("grey");
    _glever->set_short("grey lever");
    _glever->set_long("This is a lever which is set into the wall.  It "
                     "is a dull grey and very boring.\n");
    _glever->reset_get();
    _glever->add_property("there", "on the south wall");
    _glever->move(this_object());
  }
}
int do_pull(object lever) {
  int align;
  if(lever == _glever) {
    add_succeeded_mess(({ "$N $V $I and feel an overwhelming urge to do "
          "absolutely nothing about the world's problems.\n",
          "$N $V $I and suddenly looks very apathetic.\n" }),
          ({ _glever }));
    this_player()->set_al(0);
    return 1;
  }
  align = 300 + random(400);
  if(lever == _wlever) {
    align = -align;
  }
  this_player()->set_al(align);
  if(lever == _wlever) {
    add_succeeded_mess(({ "$N $V $I and suddenly feel$s like hugging "
          "everyone.\n",
          "$N $V $I and looks bright and cheery.\n" }),
          ({ _wlever }));
  } else {
    add_succeeded_mess(({ "$N $V $I and get a sudden urge to pull the "
          "wings off butterflies and torture small furry creatures.\n",
          "$N $V $I and a dark scowl crosses $p face.\n" }),
          ({ _blever }));
  }
  return 1;
}

==================================================
FILE: liaison/NEWBIE/assassins.c
==================================================

#include "path.h"
inherit PATH + "inside";
void setup() {
   set_short( "Assassins' gazebo" );
   set_light( 80 );
   add_property("no teleport", 1);
   set_long("This is a very comfortably furnished gazebo.  Obviously assassins "+
            "have excellent taste.  There is no sign at all of anything even "
            "remotely dangerous or threatening.  There is a large plaque on "
            "the wall explaining more about this rather enigmatic "
            "profession. You can view it by typing 'read sign'.\n"
            "A small, black, and elegant looking notice states that this is not "
            "where you actually join this guild.\n" );
   set_zone( "Newbie" );
   add_item("notice", "A small, black, and elegant looking notice that "
            "states that this is not where you actually join the guild.");
   add_item( ({ "furnishing" }), "The room is furnished in an expensive, "
            "although tasteful manner.  On the walls are a variety of "
            "quality oil paintings and the floor is covered with a thick "
            "carpet.  Against one wall is a chaise longue and in a corner "
            "is a well stocked drinks cabinet.");
   add_item("carpet", "A well-made carpet, thick and luxurious.");
   add_item("painting", "A variety of landscapes from some of the Disc's "
            "more notable painters.");
   add_item(({"chaise longue", "chaise", "longue"}),
            "Upholstered in the softest leather "
            "it looks very comfortable.");
   add_item(({"drink", "cabinet"}), "Its most notable feature is that it "
            "is locked.  Behind the glass door you can see a variety of "+
            "bottles, crystal decanters and glasses.");
   add_sign("A plaque entitled 'Guild of Assassins'\n",
            "The guild of assassins provides an excellent all-round "
            "education.  Graduates of the guild (graduation is by "+
            "competitive examination) will be skilled in a wide variety of "
            "subjects and able to move in all social circles.\n"
            "All assassins automatically become player killers (see "
            "'help playerkilling') on graduation.  This is not "+
            "a guild for the faint-hearted.  Becoming an assassin is a "
            "challenge.  Assassins are a proud guild, neither giving nor"
            " asking for information on how to join.\n", 0, 0, "general");
   add_property("no godmother", 1);
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}
