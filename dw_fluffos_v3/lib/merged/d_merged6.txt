# Total Tokens: 24668
# Total Files Merged: 17
# Total Characters: 82270

errain.c
==================================================

#include "path.h"
#include <terrain.h>
#define COLS (int)this_player()->query_cols()
inherit "/std/room/basic_room";
int do_help();
int do_terrain(string name);
int do_list(string what);
int do_member(string type, string params);
int do_clear();
int do_add(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level);
int do_remove(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2);
string terrain_name;
object generator;
void setup() {
   set_short( "terrain-maker room" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This room is quite bare, save a notice that has been "
         "taped on the door but its walls have been painted with "
         "scenes of deserts and forests, oceans and mountains, caves and "
         "swamps, and all manner of other types of terrain.\n"
         "Use \"help room\" to list the room's commands.\n" );
   add_exit( "northwest", ROOM +"development", "door" );
   add_sign("The large notice has furled corners and has been taped "
           "and re-taped to the door.\n",
           "Due to the incomprehensible help in this room, this \n"
           "notice was put up to help with the confusion.\n"
           "\n"
           "1.  To get information on a certain terrain, you\n"
           "    need to select that terrain by typing \n"
           "    \"terrain <terrain_name>\".\n"
           "\n"
           "2.  To remove floating or fixed locations within the terrain,\n"
           "    type \"list floating\" or \"list fixed\".\n"
           "\n"
           "    remove floating <path of terrain> <all 6 co ordinates> <level>\n"
           "\n"
           "    remove fixed <path of room>\n"
           "\n"
           "3.  To add a floating location, same as above, only use add.\n"
           "    For both removing and adding, no commas and no .c at the end\n"
           "    of path names.  When removing/adding fixed locations, all\n"
           "    locations must be done one by one.\n", 0, "notice");
}
void reset() {
   if ( !generator ) {
      generator = clone_object( "/obj/handlers/terrain_things/dungeon_maker" );
      generator->move( this_object() );
   }
}
void init() {
  ::init();
  add_command("help", "room", (: do_help() :) );
  add_command("terrain", "<string>", (: do_terrain($4[0]) :) );
  add_command("list", "fixed", (: do_list("fixed") :) );
  add_command("list", "floating", (: do_list("floating") :) );
  add_command("member", "", (: do_member(0,0) :) );
  add_command("member", "fixed <string>",
    (: do_member("fixed", $4[0]) :) );
  add_command("member", "floating <string>",
    (: do_member("floating", $4[0]) :) );
  add_command("add",
    "fixed <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_add(0, $4[0], $4[1], $4[2], $4[3], 0, 0, 0, 0) :) );
  add_command("add",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'> <number'level'>",
    (: do_add(1, $4[0], $4[1], $4[2], $4[3],
                        $4[4], $4[5], $4[6],
                 $4[7]) :) );
  add_command("add",
    "floating <word'file'> <number'x'> <number'y'> <number'z'> "
      "<number'level'>",
    (: do_add(2, $4[0], $4[1], $4[2], $4[3],
                        0, 0, 0,
                 $4[4]) :) );
  add_command("remove",
    "fixed <word'file'>",
    (: do_remove(0, $4[0], 0, 0, 0, 0, 0, 0) :) );
  add_command("remove",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'>",
    (: do_remove(1, $4[0], $4[1], $4[2], $4[3],
		 $4[4], $4[5], $4[6]) :) );
  add_command("remove",
    "floating <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_remove(2, $4[0], $4[1], $4[2], $4[3],
		 0, 0, 0 ) :) );
  add_command("clear", "", (: do_clear() :) );
}
int do_help () {
  write( "Available commands are:\n\n"+
      "     terrain  -  set terrain name\n"+
      "     list     -  list locations in current terrain\n"+
      "     member   -  find locations matching coordinates\n"+
      "     add      -  add a new location\n"+
      "     remove   -  remove an old location\n"+
      "     clear    -  clear all clones and connections\n" );
  return 1;
}
int do_terrain( string name ) {
  if ( !name ) {
    if ( stringp( terrain_name ) )
      write( "Terrain name is "+ terrain_name +".\n" );
    else
      write( "There is no terrain name set.\n" );
    return 1;
  }
  write( "Terrain name set to "+ name +".\n" );
  terrain_name = name;
  return 1;
}
int do_list( string word ) {
  int i, size;
  string list;
  mapping locations;
  mixed indeces, values;
  if ( ( word != "fixed" ) && ( word != "floating" ) ) {
    write( "List what? Options are \"fixed\" and \"floating\".\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if ( !( (int)TERRAIN_MAP->get_data_file( terrain_name ) ) ) {
    write( "There are no locations in the terrain "+ terrain_name +".\n" );
    return 1;
  }
  if ( word == "fixed" ) {
    locations = (mapping)TERRAIN_MAP->query_fixed_locations( terrain_name );
    size = m_sizeof( locations );
    indeces = m_indices( locations );
    values = m_values( locations );
    if ( !size ) {
      write( "There are no fixed locations in the terrain "+ terrain_name
                +".\n" );
      return 1;
    }
    list = "The terrain "+ terrain_name +" has the following fixed location"+
              ( size == 1 ? "" : "s" ) +":\n";
    for ( i = 0; i < size; i++ )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, indeces[ i ] +
          " at ("+ values[ i ][ 0 ] +", "+ values[ i ][ 1 ] +", "+
          values[ i ][ 2 ] +")" );
    this_player()->more_string( list, "Fixed" );
    return 1;
  }
  locations = (mapping)TERRAIN_MAP->query_floating_locations( terrain_name );
  size = sizeof( locations );
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name
              +".\n" );
    return 1;
  }
  list = "The terrain "+ terrain_name +" has the following floating "+
      "location"+ ( size == 1 ? "" : "s" ) +":\n";
  for ( i = 0; i < size; i++ )
    if ( sizeof( locations[ i ][ 1 ] ) == 3 )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " at ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +"), level "+ locations[ i ][ 2 ] );
    else
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " from ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +") to ("+ locations[ i ][ 1 ][ 3 ] +
          ", "+ locations[ i ][ 1 ][ 4 ] +", "+ locations[ i ][ 1 ][ 5 ] +
          "), level "+ locations[ i ][ 2 ] );
  this_player()->more_string( list, "Floating" );
  return 1;
}
int do_member( string type, string parameters ) {
  int i, size, *co_ords;
  string list, location;
  mixed *locations;
  if (!type || !parameters) {
    write( "Syntax: member <fixed|floating> <coord1> ...\n" );
    return 1;
  }
  if ( ( type != "fixed" ) && ( type != "floating" ) ) {
    write( "Syntax: member <fixed|floating> ...\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  co_ords = allocate( 3 );
  if ( type == "fixed" ) {
    if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ],
        co_ords[ 2 ] ) != 3 ) {
      write( "Syntax: member fixed <coord1> <coord2> <coord3>\n" );
      return 1;
    }
    TERRAIN_MAP->get_data_file( terrain_name );
    location = (string)TERRAIN_MAP->member_fixed_locations( co_ords );
    if ( !location ) {
      write( "There is no fixed location in the terrain "+ terrain_name +
          " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
          ").\n" );
      return 1;
    }
    write( "The terrain "+ terrain_name +" has "+ location +" as a fixed "+
        "location at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ], co_ords[ 2 ] )
      != 3 ) {
    write( "Syntax: member floating <coord1> <coord2> <coord3>\n" );
    return 1;
  }
  TERRAIN_MAP->get_data_file( terrain_name );
  locations = (mixed *)TERRAIN_MAP->member_floating_locations( co_ords );
  size = sizeof( locations ) / 2;
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name +
        " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  list = "There "+ ( size == 1 ? "is one floating location" : "are "+
      query_num( size ) +" floating locations " ) +" in the terrain "+
      terrain_name +" at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+
      co_ords[ 2 ] +"):\n";
  for ( i = 0; i < size; i++ )
    list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ 2 * i ] +
        ", level "+ locations[ 2 * i + 1 ] );
  this_player()->more_string( list, "Member" );
  return 1;
}
int do_add(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 0 || floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if (floating == 0) {
    if ( !TERRAIN_MAP->add_fixed_location( terrain_name, file, co_ords ) ) {
      write( "The fixed location "+ file +" in the terrain "+ terrain_name
                +" already exists.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been added to the terrain "+
        terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +").\n" );
    return 1;
  }
  TERRAIN_MAP->add_floating_location( terrain_name, file, co_ords, level );
  if ( sizeof( co_ords ) == 6 )
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
        ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") at level "+ level +".\n" );
  else
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") and level "+ level +".\n" );
  return 1;
}
int do_remove(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else if (floating == 1) {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if ( floating == 0 ) {
    if ( !TERRAIN_MAP->delete_fixed_location( terrain_name, file ) ) {
      write( "There is no fixed location "+ file +" in the terrain "+
          terrain_name +" to remove.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been removed from the terrain "+
        terrain_name +".\n" );
    return 1;
  }
  if ( !TERRAIN_MAP->delete_floating_location( terrain_name, file, co_ords ) ) {
    if ( sizeof( co_ords ) == 6 )
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
          co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
          ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") to remove.\n" );
    else
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
          ", "+ co_ords[ 2 ] +") to remove.\n" );
    return 1;
  }
  if ( sizeof( co_ords ) == 6 )
    write( "The floating location using "+ file +" in the terrain "+
        terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +", "+
        co_ords[ 4 ] +", "+ co_ords[ 5 ] +") has been removed.\n" );
  else
    write( "The floating location using "+ file +" in the terrain "+
      terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
      ", "+ co_ords[ 2 ] +") has been removed.\n" );
  return 1;
}
int do_clear() {
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  TERRAIN_MAP->clear_cloned_locations( terrain_name );
  TERRAIN_MAP->clear_connections( terrain_name );
  write( "Clones and connections cleared for the terrain "+ terrain_name +
      ".\n" );
  return 1;
}

==================================================
FILE: admin/room/we_care/club_room_controller.c
==================================================

#include <clubs.h>
inherit "/std/room/controller/club_room_controller";
#include <room/club_room.h>
void setup() {
   set_save_file("/d/admin/save/club_room");
   set_board_associated(1);
   add_controlled_ownership("main room",
                            CLUB_ROOM_CONTROLLER_DISCUSSED,
                            CLUB_ROOM_OWNED_POSITION,
                            (: CLUB_HANDLER->query_president_position($2) :));
}

==================================================
FILE: admin/room/we_care/main_club_room.c
==================================================

#include "path.h"
inherit "/std/room/club_room";
void setup() {
   set_short("main club room");
   set_long("The main club room.\n");
   set_club_controller(CONTROLLER);
   set_light(70);
   set_leave_exit("south");
   add_exit("south", "/d/admin/room/meeting", "door");
}

==================================================
FILE: admin/room/we_care/owned_room1.c
==================================================

inherit "/std/room/inherit/club_owned_room";
#include "path.h"
void setup() {
   set_short("The first owned room");
   set_long("A room that is owned.\n");
   set_club_controller(CLUB_CONTROLLER);
   set_club_owned_id("main office");
}

==================================================
FILE: admin/obj/bingle.c
==================================================

inherit "/std/object";
void setup() {
  set_name("domainer");
  set_long(
"This object shows you all of the creators who are in each domain and those "+
"that don't have directorys, are not cretors and ones who are not in a "+
"domain at all.\nThe command to view all this is \"info\".\n");
}
void init() {
  add_action("do_info", "info");
}
int do_info(string str) {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;
  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = get_dir("/d/");
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!"/secure/login"->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
    creators -= mem;
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!"/secure/login"->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
}

==================================================
FILE: admin/obj/check.c
==================================================

#define SAVE_FILE "/d/admin/log/"
string *paths, *cloned_by;
int *times;
mapping illegal;
void dest_me()
{
   destruct(this_object());
}
void create()
{
   illegal = ([ ]);
   paths = ({ });
   cloned_by = ({ });
}
void log_file()
{
   int p;
   string *person, *filename;
   filename=m_indices(illegal);
   person=values(illegal);
   if(sizeof(illegal)>0) {
      unguarded((: write_file, SAVE_FILE+"illegal.txt",
                 "\nSearch carried out on "+ctime(time())+" from here.\n" :));
      for(p=0;p<sizeof(illegal);p++) {
         unguarded((: write_file, SAVE_FILE+"illegal.txt",
                    filename[p]+"  -  on player "+person[p]+" - cloned by "+
                    cloned_by[p]+"\n" :));
      }
   }
}
void check_sub_inv(object *things, object owner)
{
int q, r, check;
string *pre_filename, filename, *switcher;
mixed info;
   for(q=0;q<sizeof(things);q++)
   {
      pre_filename=explode(file_name(things[q]),"#");
      filename=pre_filename[0];
      switcher=explode(filename,"/");
      if( (switcher[0]=="w") && (!owner->query_creator() ) )
      {
         illegal=illegal+([filename:owner->query_name()]);
         info = things[q]->stats();
         for(r=0; r<sizeof(info);r++)
         {
            if(info[r][0] == "cloned by")
            {
               cloned_by = cloned_by + ({ info[r][1] });
            }
         }
           destruct(things[q]);
       }
      if ( (!owner->query_creator()) && (sizeof(switcher)>2) && (switcher[0]=="obj") && (switcher[1]=="misc") )
      {
         switch(switcher[2]){
         case "mailer_ob":
         case "board_mas":
            info = things[q]->stats();
            for(r=0; r<sizeof(info);r++)
            {
               if(info[r][0] == "cloned by")
               {
                  cloned_by = cloned_by + ({ info[r][1] });
               }
            }
            illegal=illegal+([filename:owner->query_name()]);
             destruct(things[q]);
            break;
         }
      }
   }
}
void check_inv(object player)
{
int q;
object *things, *contents, owner;
   things=deep_inventory(player);
   owner=player;
   check_sub_inv(things, player);
}
do_seek()
{
   int p;
   object *everyone_on;
   seteuid("Admin");
   everyone_on = users();
   for(p=0;p<sizeof(everyone_on);p++)
   {
      check_inv(everyone_on[p]);
   }
   log_file();
   return 1;
}

==================================================
FILE: admin/obj/inv_check.c
==================================================

#include <playtesters.h>
#include <move_failures.h>
#define FILENAME "/save/inv_check"
int do_seek();
nosave string to_log;
string *forbidden = ({ });
void save_me() {
  unguarded ((: save_object (FILENAME) :));
}
void dest_me() {
   destruct( this_object() );
   save_me();
}
void create() {
  seteuid( "Admin" );
  unguarded ((: restore_object (FILENAME) :));
  do_seek();
}
void log_it() {
   if( sizeof( to_log ) > 0 ) {
      log_file( "ILLEGAL_OBJECT",
               "Illegal objects removed %s\n%s\n",
               ctime( time() ),
               to_log );
   }
}
void check_sub_inv( object *things, string owner, object owner_ob ) {
   string *pre_filename, filename, *switcher;
   object *obs, thing;
   object *contents, *fragile;
   string mess = "";
   object bag;
   obs = ({ });
   foreach ( thing in things ) {
     if ( thing->query_property( "virtual name" ) ) {
       filename = thing->query_property( "virtual name" );
     } else {
       pre_filename = explode( file_name( thing ),"#" );
       filename = pre_filename[ 0 ];
     }
      switcher = explode( filename, "/" );
      if( ( switcher[0]=="w" ) &&
          ( !"/obj/handlers/playtesters"->query_playtester( owner ) ) ) {
         to_log += sprintf("%s in %s, cloned by %s\n",
                           filename, owner,
                           (string)thing->query_cloned_by() );
         obs += ({ thing });
      }
      if ( ( sizeof( switcher ) > 2 ) &&
          ( switcher[ 0 ] == "obj" ) &&
          ( switcher[ 1 ] == "misc" ) ) {
         switch(switcher[2]){
          case "mailer_ob":
            if ( !"/obj/handlers/playtesters"->query_playtester( owner ) &&
                 ( !owner_ob->query_property("allowed mailer")) ) {
               to_log += sprintf("%s in %s, cloned by %s\n",
                                 filename, owner,
                                 (string)thing->query_cloned_by() );
               obs += ({ thing });
            }
            break;
          case "board_mas":
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            break;
         }
      }
      if (sizeof (switcher) ==4 &&
        switcher [0] == "d" &&
        switcher [1] == "liaison" &&
        switcher [2] == "items") {
           to_log += sprintf("%s in %s, cloned by %s\n",
                             filename, owner,
                             (string)thing->query_cloned_by() );
           obs += ({ thing });
      }
      reset_eval_cost();
      if (member_array (filename, forbidden) != -1) {
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            thing->add_property ("no recycling", 1);
            if (function_exists ("query_max_weight", thing)) {
              contents = all_inventory (thing);
            }
      }
   }
   if ( sizeof( obs ) ) {
      tell_object (owner_ob, owner_ob->colour_event ("say", "%^CYAN%^") +
        "A small official looking dwarf walks up to you and says: In "
        "accordance with paragraph 5, sub-paragraph 7 of the Domestic "
        "& Domesticated Animals (Care & Protection) Act, 1673, I hereby "
        "remove from you: "+ (string)query_multiple_short( obs, "one" )
        + ".%^RESET%^");
      if (sizeof (contents)) {
        mess += "\nThe dwarf removes all the inventory from the confiscated "
          "items.";
        fragile = filter (contents, (: $1->query_property("fragile") :));
        if (sizeof (fragile)) {
          mess += "\nHe hands " + query_multiple_short (fragile) + " to "
            "you.\n";
          contents -= fragile;
          fragile->move (owner_ob);
        }
        if (sizeof (contents)) {
          bag = clone_object ("/obj/baggage");
          bag->set_name ("bag");
          bag->set_short ("brown paper bag");
          bag->add_adjective (({"brown", "paper"}));
          bag->set_weight(5);
          bag->set_max_weight (implode (map (contents,
            (: $1->query_complete_weight() :)),(: $1 + $2 :)) + 1);
          bag->set_value (0);
          bag->set_long ("This is a plain, brown, paper bag... the kind grubby "
            "old men are often found in possession of after leaving their "
            "local newsagent.\n");
          contents->move (bag);
          if (bag->move (owner_ob) == MOVE_TOO_HEAVY) {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and leaves it on the ground.";
          }
          else {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and hands it to you.";
          }
        }
      }
      mess += "\nHe scribbles something on a clipboard, then walks away.\n";
      tell_object (owner_ob, mess);
      obs->move( "/room/rubbish" );
      call_out( "check_obs", 7, obs );
   }
}
void check_obs( object* obs ) {
   object thing;
   foreach( thing in obs ) {
      if( thing ) {
   thing->dest_me();
      }
   }
}
void check_inv( object player ) {
   object *things;
   things = deep_inventory( player );
   check_sub_inv( things, (string)player->query_name(), player );
}
int do_seek() {
  object user;
  to_log = "";
  foreach ( user in users() ) {
    if( user && !user->query_property( "guest" ) &&
       !user->query_creator() &&
       !PLAYTESTER_HAND->query_tester (user) &&
       !user->query_property ("test character") ) {
      check_inv( user );
    }
  }
  log_it();
  call_out( "do_seek", 300 );
  return 1;
}
int query_theft_command() { return -1; }
string parse_filename (string str) {
  if (strsrch (str, ".wep") != -1 ||
      strsrch (str, ".clo") != -1 ||
      strsrch (str, ".ob") != -1 ||
      strsrch (str, ".arm") != -1 ||
      strsrch (str, ".food") != -1 ||
      strsrch (str, ".sca") != -1) {
        if (file_size(str) <= 0) {
          return 0;
        }
        else {
          return str;
        }
  }
  else {
    str = explode (str, ".c")[0];
    if (file_size(str + ".c") <= 0 ) {
      return 0;
    }
    else {
      return str;
    }
  }
}
int ban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to ban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) == -1) {
      forbidden += ({ filename });
      printf ("%s added to the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s already banned.\n", filename);
    }
  }
  return 1;
}
int unban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to unban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) != -1) {
      forbidden -= ({ filename });
      printf ("%s removed from the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s not currently banned.\n", filename);
    }
  }
  return 1;
}
string list_banned() {
  if (sizeof (forbidden)) {
    return sprintf ("Objects cloned from the following filenames "
      "will be confiscated by the dwarves:\n%s\n",
      implode (forbidden, "\n"));
  }
  else {
    return "There are no objects currently forbidden.\n";
  }
}
mixed stats()
{
  return ({
    ({ "Time until next tick", query_num (find_call_out ("do_seek"))
      + " seconds"}),
  });
}

==================================================
FILE: liaison/common.c
==================================================

#include <config.h>
#define DOM_TITLE "Liaison Domain"
#define LORD "wyvyrn"
#define DOMAIN "liaison"
#define BOSS_ROOM "/w/wyvyrn/rooms/office"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
   set_dom( DOMAIN );
   set_light( 100 );
   set_short( "Liaison Domain Common room" );
   add_property( "determinate", "the " );
   set_long("The Liaison common room looks like a comfortable place to "
            "come to after a hard day's liaising.  The large pile of stress "
            "balls sat in one corner and the drinks cabinet against a wall "
            "highlight this.  The various evil-looking devices scattered "
            "around the room seem to add character and even a slightly "
            "malicious overtone to the entire place.  There are also a "
            "few chairs scattered around the place providing welcome bum "
            "relief.  One even looks to be occupied.\n"
            "A sign is hanging on the wall.\n");
   add_alias("balls", "ball");
   add_alias("devices", "device");
   add_alias("bottles", "bottle");
   add_alias("chairs", "chair");
   add_alias("whips", "whip");
   add_alias("chains", "chain");
   add_alias("easy chair", "chair");
   add_alias("dolls", "doll");
   add_alias("armrests", "armrest");
   add_alias("cushions", "cushion");
   add_alias("strings", "string");
   add_alias("needles", "needle");
   add_item( ({"ball", "stress ball"}), "The pile of stress balls seems very "
            "inviting, albeit until you get up close and see that they are "
            "actually coated in tough plastic and tied to a pole with string - "
            "effectively ending their usefulness.  They look nice though.");
   add_item("string", "Each piece of string connects a ball to the pole, "
            "stopping the ball moving very far.  Cruel.");
   add_item("pile", "The pile of stress balls seems very inviting, albeit "
            "until you get up close and see that they are actually coated in "
            "tough plastic and tied to a pole with string - effectively "
            "ending their usefulness. They look nice though.");
   add_item("lock", "A big lock that looks completely unpickable, mainly due "
            "to it having no keyhole.  Nothing will unlock it, so you heavy "
            "drinkers are just out of luck.");
   add_item("corner", "A corner of the room. Where two walls, the ceiling "
            "and the floor meet.");
   add_item("pole", "There is a short pole hiding unobtrusively behind the "
            "stress balls and it is only through very close scruitiny that "
            "it is actually noticable at all.  The pole seems to have "
            "lots of strings coming out of it, each of which lead to a "
            "stress ball, limiting the distance it can travel.\n"
            "It is secured to the floor and cannot come out.");
   add_item("device", "Devices of differing shapes and sizes litter most "
            "of the walls - all seemingly to do with harming nasty players. "
            " From the voodoo dolls in one corner to the rack in another, "
            "not to mention the whips and chains.  Serious stuff.");
   add_item("whip", "I told you not to mention them.");
   add_item("chain", "I told you not to mention them.");
   add_item("bottle", "The bottles line the inside of the cabinet, all "
            "different shapes and sizes of bottles.  Green bottles, "
            "blue bottles, red bottles, bottles with caterpillers in, "
            "bottles with toads in, bottles with DUCKs in, bottles "
            "with labels on, bottles with warnings on, bottles with "
            "skulls and crossbones on, so basically, lots of bottles.");
   add_item("cabinet", "The drinks cabinet is leaning idly against a "
            "wall [as much as a drinks cabinet can] and seems to sneer "
            "at you [as much as a drinks cabinet can].  The polished "
            "glass of the cabinet windows show all the drinks that "
            "seem to look smug [as much as bottles can].  The large "
            "lock holding the cabinet shut makes the bottles "
            "completely out of range.\n"
            "If you are really desperate, "
            "clone /w/lucifer/misc/blasterbottle.c and go nuts.");
   add_item("glass", "It's just some glass in the cabinet.  Nothing "
            "special.");
   add_item("chair", "The easy chairs that line the walls are "
            "pretty nondescript: big "
            "deep cushions and fluffy armrests, but that's all "
            "they are - and ever will be: chairs.  "
            "As a profound sense of misery sweeps over you, you "
            "notice one of the chairs is occupied by a rather "
            "despondant looking man.");
   add_item("doll", "The voodoo dolls lie in a messy pile in a "
            "corner of the room, looking particularly morbid with "
            "a hundred different needles sticking out at various "
            "points of their doll bodies.  The faces of the dolls "
            "are hard to make out, seeming to shift from likeness to "
            "likeness as you look at them.  There is a barrier in front "
            "of the dolls, suggesting they shouldn't be touched.");
   add_item("barrier", "A thick looking piece of metal completely blocking "
            "all access to the dolls.  Most probably for the best, too.");
   add_item("needle", "The needles are -unsurprisingly- sharp things "
            "currently embedded into the dolls, no doubt causing extreme "
            "pain.  Well, at least they would if the dolls were real. "
            "Which they aren't.  Which is a good thing.");
   add_item("rack", "The rack is a vicious looking instrument that allows "
            "the human [or non-human] body to be stretched to completely "
            "wrong proportions.  This is something that should be used "
            "with extreme caution.  Happily, it appears not to have been "
            "used yet [there is a still plastic covering on it] and long "
            "may it stay that way.");
   add_item("covering", "Mercifully there is a covering on the rack, "
            "showing it has never been used.  Which is a good thing.");
   add_item("armrest", "It's an armrest.  You rest your arm on it.");
   add_item("wall", "It's a wall.  That's about it.");
   add_item("cushion", "It's a cushion. You rest your bum on it.");
   add_item("man", "The man seated in one of the easy chairs looks "
            "to have resigned himself to a lifetime there, and "
            "from what you can see there appears to be a deep "
            "groove in the chair from his body shape.\n"
            "He notices you looking at him and speaks slowly, like he "
            "has nearly forgotten how: 'Do you know how long Moonchild "
            "will be? I've been waiting here for over 5 years now! I "
            "missed the fall of quest XP and everything - just because "
            "I wanted my items back!'\n"
            "As the man starts to froth at the mouth, you hurriedly turn "
            "your back on him and leave him to his waiting.");
   add_sign("This is a sign.  But then you knew that, or at least we hope "
            "you did.\n",
            "Commands available here are:\n"
            "add <name>   : add <name> as one of your characters.\n"
            "remove <name>: remove <name> as one of your characters.\n"
            "list [<name>]: list characters added for you or <name>.", 0, 0, 0);
   board = clone_object("/obj/misc/board");
   board->set_datafile(DOMAIN);
   board->move(this_object());
   add_exit("office", "/w/wyvyrn/rooms/study", "door");
   add_exit("drum", CONFIG_START_LOCATION, "path");
   add_exit("corridor", "/d/liaison/cre_corridor", "door");
   add_exit("interview", "/d/liaison/utils/interview", "door");
   BOSS_ROOM->add_exit("common", "/d/"+DOMAIN+"/common", "door");
}
void init() {
   this_player()->add_command( "add", this_object(), "<word> <word>" );
   this_player()->add_command( "add", this_object(), "<word>" );
   this_player()->add_command( "remove", this_object(), "<word> <word>" );
   this_player()->add_command( "remove", this_object(), "<word>" );
   this_player()->add_command( "list", this_object(), "" );
   this_player()->add_command( "list", this_object(), "<word>" );
}
int do_add( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->add_member_alias( args[ 0 ],
                                                    args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                args[ 1 ] +" added as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can add aliases to others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->add_member_alias( this_player()->query_name(),
                                                 args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                args[ 0 ] +" added as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                "Couldn't add "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_remove( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->delete_member_alias( args[ 0 ],
                                                       args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                    args[ 1 ] +" removed as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can remove aliases for others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->delete_member_alias(
                 this_player()->query_name(), args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                 args[ 0 ] +" removed as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                 "Couldn't remove "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_list( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   string *names, name;
   int i;
   switch( pattern ) {
    case "<word>":
      name = args[ 0 ];
      break;
    case "":
      name = this_player()->query_name();
      break;
   }
   names = "/d/liaison/master"->member_alias( name );
   name = capitalize( name );
   i = sizeof( names );
   if ( i ) {
      if ( i > 1 ) {
         while ( i-- ) {
            names[ i ] = capitalize( names[ i ] );
         }
         this_player()->add_succeeded_mess( this_object(),
                "Aliases for "+ name +" are "+
                query_multiple_short( names )+".\n" );
      } else {
         this_player()->add_succeeded_mess( this_object(),
                "Alias for "+ name +" is "+
                capitalize( names[ 0 ] )+".\n" );
      }
   } else {
      this_player()->add_succeeded_mess( this_object(),
             "No aliases known for "+ name +".\n" );
   }
   return 1;
}

==================================================
FILE: liaison/cre_corridor.c
==================================================

inherit "/std/room/basic_room";
string do_mirror();
void setup() {
    set_short("Liaison hallway");
    set_light(100);
    add_property("determinate", "the ");
    set_long("This is the homely corridor of the Liaison Domain.  There are "
             "a lot of doors leading off here, hopefully taking the plucky "
             "entrant a-wandering into Liaison workrooms.  Exercise caution "
             "as some Creators prefer you to ask or at least knock first.  "
             "Apart from the doors here there are some paintings of various "
             "people, as well as a large floor to ceiling mirror. Taking "
             "pride of place on one of the walls, however, is an ancient "
             "looking scroll housed in a picture frame.  There is "
             "also a sign here.\n");
    add_item("doors", "Lots of doors.  Tall doors, short doors, red doors, "
             "blue doors, green doors, thin doors, wide doors, old doors, "
             "grimy doors, wooden doors, metal doors and even a padded "
             "red linonium door - kinky.  However, you can only go through "
             "the doors marked in the exits, sorry.");
    add_item("paintings", "Paintings of people who have been important to "
             "the domain.  There's one of Ohdamn, Moonchild, Olorin, Shalla, "
             "Kaea, Nevvyn, Wyvyrn and - strangely enough - You.");
    add_item("painting of ohdamn", "The painting of Ohdamn shows a very "
             "tall man with reddish blond hair.  He appears to be carrying "
             "a box of chocolates and looks to be in the middle of a rousing "
             "love song, which may have something to do with the bottle of "
             "rum in his other hand.");
    add_item(({"mission", "scroll", "statement"}), "It's the liaison "
             "statement of mission!\n"
             "Or mission statement, if you would prefer.\n\n"
             "Our mission in the Liaison Domain is to give continuous "
             "support to the creator and player bases and facilitate "
             "communcation between them.\n"
             "Through a diverse range of activities, we aim to maintain "
             "Discworld MUD as an enjoyable, interesting, in-theme and "
             "safe virtual space.\n"
             "We seek to contribute to Discworld MUD as a visible and helpful "
             "helpful first point of creator contact for players.  Additionally, "
             "we will work within assigned creator areas to assist in the "
             "development and implementation of concepts.\n\n"
             "Impressive, huh?");
    add_alias("mission", "statement");
    add_item("frame", "It's just a frame holding a large scroll in place.");
    add_item("hair", "It's hair.  It's reddish blond and it's Ohdamn's.");
    add_item("rum", "It's rum.  Held very securely by Ohdamn.");
    add_item("chocolates", "They are chocolates.  On Ohdamn's painting.");
    add_item("painting of moonchild", "The painting of Moonchild shows a "
             "looming lady with a big whip and an evil grin.  She appears "
             "to be half in shadows.");
    add_item("whip", "A fearsome looking whip that seems to fit well in "
             "Moonchild's hand.");
    add_item("painting of olorin", "Olorin's picture appears to be only "
             "half done - as if the artist didn't have time to finish it.");
    add_item("painting of shalla", "Shalla's painting depicts a pretty "
             "lady and although she is fully clothed, your attention is "
             "drawn to her socks.  Strange.");
    add_item("socks", "Stop looking - that's illegal in some countries!");
    add_item("painting of kaea", "Kaea's painting shows a young lady with a "
             "silly looking grin on her face and giggling.  Seems to say it "
             "all really...");
    add_item("painting of nevvyn", "The painting of Nevvyn shows a man with a "
             "pint hefted in a salute and a cheeky looking grin on his face.");
    add_item("pint", "A half empty pint in Nevvyn's hand.  Says it all!");
    add_item("painting of wyvyrn", "Wyvyrn's painting depicts a ... well, a "
             "Wyvyrn.  He looks a bit like a dragon and has green wings - but "
             "seems to have the distinct disadvantage of looking cute.");
    add_item("wings", "Wings.  On Wyvyrn.");
    add_alias("painting of me", "painting of you");
    add_item("painting of you", "The painting of you is ... well, blank with the "
             "words 'Your Name Here' on it.  You get the feeling its a rather "
             "cheesy way of saying everyone is important!  If it wasn't so "
             "cheesy it might make you feel better.");
    add_sign("This is an important sign, for viewing along with the "
             "paintings.\n",
             "If you are having problems seeing the paintings, look at "
             "painting of <person>.  "
             "Please note: These paintings are done on collective images.  "
             "Basically, if you don't like your portrait, don't beat Luci "
             "up.  Thanks!");
    add_item("mirror", (: do_mirror() :));
    add_exit("common", "/d/liaison/common", "door");
    add_exit("drum", "/d/am/am/mendeddrum", "path");
}
string do_mirror() {
  string text;
  text = "The mirror is a full length floor to ceiling job, a full length "
    "mirror in the true sense of the word.  It's here to make sure you look "
    "you look your best.  Good job you are checking!\n\n";
  text += this_player()->long(this_player());
  tell_room (this_object(), this_player()->short() + " checks " +
    this_player()->query_objective() + "self in the big mirror.  Poser.\n",
    this_player());
  return text;
}

==================================================
FILE: liaison/master.c
==================================================

#define LORD "wyvyrn"
#define DOMAIN "liaison"
#include <liaison.h>
inherit "/std/dom/base_master";
mapping member_alias;
nosave string* member_cache = 0;
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return "eron";
}
string query_info() {
  if (file_size(LIAISON_DOMAIN_INFO) < 0) {
    return "\nFor information on this domain, please visit "
           "http:
  }
  return "\n"+ unguarded((: read_file(LIAISON_DOMAIN_INFO) :)) +"\n";
}
string *member_alias( string name ) {
   int i;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( undefinedp( members[ name ] ) ) {
      map_delete(member_alias, name);
      return 0;
   }
   if ( !member_alias[ name ] )
      member_alias[ name ] = ({ });
   i = sizeof( member_alias[ name ] );
   while ( i-- )
      member_alias[ name ][ i ] = lower_case( member_alias[ name ][ i ] );
   return member_alias[ name ] + ({ });
}
int add_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !"/secure/login"->test_user( alias ) )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   member_alias[ name ] += ({ alias });
   save_me();
   return 1;
}
int delete_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   save_me();
   return 1;
}
string *query_unsorted_members() {
    return ::query_members();
}
string *query_members() {
    string* temporary_array = ({});
    string* first = ({});
    string* seniors = ({});
    string* newbies = ({});
    if (!member_cache) {
        first = ({ query_lord() })   +
                sort_array(query_deputies(),1);
        temporary_array = ::query_members() - first;
        temporary_array = sort_array( temporary_array, 1 );
        foreach ( string person in temporary_array ) {
          if ( master()->query_senior(person) ) {
              seniors += ({ person });
          }
        }
        temporary_array -= seniors;
        foreach ( string person in temporary_array ) {
          if ( regexp( members[ person ], "^(N|n)ewbie$" ) ) {
              newbies += ({ person });
          }
        }
        temporary_array -= newbies;
        member_cache = first + seniors + temporary_array + newbies;
    }
    return copy(member_cache);
}
string *query_projects() {
    return values(members);
}

==================================================
FILE: liaison/NEWBIE/advancement.c
==================================================

#include "path.h"
inherit PATH + "inside";
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short("Advancement Room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a rather cosy room designed to encourage visitors to "
            "linger a while and read a few of the notices pinned to the "
            "walls.  The air is thick and overly warm, and there is a "
            "pervasive odour of stale tea, mothballs, and elderly ladies who "
            "collect rather more cats and string than they can properly "
            "handle.  "
            "Several overstuffed sofas have been grouped in the centre "
            "of the room along with wobbly occasional tables.  There is "
            "a small cage holding an odd-looking creature in one corner, "
            "and an immense ball of yarn in the other.  A door to the south "
            "leads back to the foyer.\n");
  add_item(({ "floor", "ground" }), "The floor is scuffed, dusty wood.  It "
           "was probably nice at some point.");
  add_item( "wall", "The walls (what can be seen of them under the notices) "
            "have been covered with a gaudy floral paper.");
  add_item(({ "paper", "wallpaper", "floral", "flower" }), "The wallpaper has "
            "a dark, muddy background covered with enormous fantasy flowers "
            "in red, blue, and yellow.");
  add_item( "door", "The plain wooden door has been propped open in an effort "
            "to let some of the stale air out.");
  add_item( "cage", "The cage is a small, rickety bamboo affair with a tiny "
            "door tied closed with a strand of wire.  It contains a strange "
            "creature.");
  add_item( "creature", "The creature is a pale, translucent colour.  It has "
            "long, spindly legs, big teeth, and eyes that glow like lamps "
            "when it is awake.  Even though it is small, you sense it would "
            "not be wise to disturb it.  It is holding a small card.");
  add_item( "wire", "The wire holding the cage door shut is a hopelessly "
            "twisted mass of spun octiron, the magical metal of Discworld.");
  add_item( "card", "The card is stamped 'Demon Local 45, Holywood' in "
            "fading ink.");
  add_item(({"ball", "yarn"}), "A large ball of string.");
  add_item("notice",
           ({ "long", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n",
                "read", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n"}));
  add_item("sofa", ({"long", "Several well-stuffed and well-worn sofas with "
                       "rather dirty, brown upholstery.",
                       "position", "a sofa",
                       "position multiple", 1 }));
  add_item("table", "A number of wobbly occasional tables made from "
           "some indeterminable kind of wood have been placed near the "
           "sofas.");
  sign=add_sign("A handwritten notice marked 'Statistics and Rearrange'.\n",
                "On Discworld your skill bonus typically determines your "
                "ability to perform a task.  Skill bonus is calculated "
                "from your skill level and your statistics.  Different "
                "stats affect different skills.\n"
                "Once you enter Discworld, you may rearrange your stats.  "
                "This should be done to improve your combination of "
                "constitution, dexterity, intelligence, strength and wisdom "
                "(your stats), but you are advised to wait until you have "
                "chosen a guild and have asked other guild members for "
                "advice.  Use the command 'rearrange' to do this, but "
                "consider it well, as you can only rearrange your stats "
                "once.\n", 0, "statistics", "general" );
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'statistics and rearrange'");
  sign=add_sign("A handwritten notice marked 'Guildpoints'.\n",
           "Guildpoints are a measure of your capability to perform guild "
           "commands such as stealing, fighting, casting spells or rituals, "
           "etc.  When you have used all your guild points, you will have to "
           "rest to allow them to regenerate.  For more information, type "
           "in 'help guildpoints'.\n", 0, "guildpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'guild points'");
  sign=add_sign("A handwritten notice marked 'Experience'.\n",
           "In addition to the direct skill advances provided by the "
           "taskmaster, quest completion, using your guild commands "
           "and by doing certain tasks, you are rewarded with "
           "experience points or XP.  These may be spent in advancing skills "
                "from your guild or by learning from other players.\n", 0,
                "experience", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'experience'");
  sign=add_sign("A handwritten notice marked 'Hitpoints'.\n",
           "Hitpoints, or HP determine how much damage you can take in "
           "combat before you die.  The number of hit points you have is "
           "dependent upon your stats (mostly Con) and on your levels of "
           "other.health.  Hitpoints regenerate gradually over time.  "
           "There are also a variety of other ways to be healed.  You "
           "can use 'monitor' to keep track of your hitpoints.  See also "
           "'help wimpy'.\n", 0, "hitpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'hitpoints'");
  sign=add_sign("A handwritten notice marked 'Skills'.\n",
           "To check your skill levels, use the command 'skills', and "
           "to see various statistics about yourself, use 'score'.  Your "
           "stats can also be reviewed using 'score stats'.  The command "
           "'help' will give you a variety of other topics with useful "
           "information.", 0, "skills", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'skills'");
  sign=add_sign("A handwritten notice marked 'advancement'.\n\n",
           "Skills can be advanced in a variety of ways on Discworld.  "
           "The guild you join will allow you to advance your skills "
           "for a certain number of experience points and a small fee.  "
           "When you reach the proper skill level your guild will "
           "teach you the commands that you will need to carry out "
           "your guild duties.\n"
           "You may also have another player teach you skills if they have "
           "a higher skill level than you, or you may teach yourself.  Both "
           "of these methods cost experience points, and it is generally more "
           "expensive to teach yourself.\n"
           "Finally, many of your skills can be advanced simply by performing "
           "tasks that make use of those skills.  For example, your fighting "
           "skills will get better as you participate in more fights.  For "
           "more information on this system, type "
           "'help taskmaster'.\n",0, "advancement", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'advancement'");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "south", "foyer");
}

==================================================
FILE: liaison/NEWBIE/align.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
inherit PATH+"common";
object _wlever;
object _blever;
object _glever;
int do_pull(object lever);
void setup() {
  object sign;
  set_zone("Newbie");
  set_short("alignment room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a small, bare room that is quite empty apart from "
            "a lever stuck onto each of three walls and a small wooden "
            "sign placed in the centre of the room.\n"
            "A door to the east leads back to the foyer.\n");
  add_item(({"west wall", "south wall", "east wall"}),
           "A plain, flat wall with a lever sticking out of it.");
  sign=add_sign("A sign marked 'alignment'.\n",
                FOYER->format_sign(
           "Alignment is how good or evil you are.  This changes gradually "
           "depending on the things you do.  Because it changes so slowly "
           "you can choose to start out with a good, neutral or evil "
           "alignment.  To become evil, pull the black lever, to become "
           "good pull the white lever, and to stay neutral don't pull "
           "either lever, or pull the grey lever if you have already pulled "
           "one of the other ones.\n"),0,"sign","general");
  sign->set_short("sign");
  sign->add_adjective("wooden");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door");
  add_alias( "east", "foyer");
  room_chat(({10, 40, ({"A voice which seems to come from the black lever "
                        "says: Don't be a goody-goody, pull me!",
                        "A voice which seems to come from the white lever "
                        "says: You should be nice, pull me!",
                        "A voice which seems to come from the grey lever "
                        "says: It's all about balance in the end."})}));
}
void init() {
  if (_wlever) {
     this_player()->add_command("pull", _wlever, "<direct:object>",
                              (: do_pull(_wlever) :));
  }
  if (_blever) {
     this_player()->add_command("pull", _blever, "<direct:object>",
                              (: do_pull(_blever) :));
  }
  if (_glever) {
     this_player()->add_command("pull", _glever, "<direct:object>",
                              (: do_pull(_glever) :));
  }
  ::init();
}
void reset() {
  if(!_wlever) {
    _wlever = clone_object("/std/object");
    _wlever->set_name("lever");
      _wlever->add_adjective("white");
    _wlever->set_short("white lever");
    _wlever->set_long("This is a lever which is set into the wall.  It "
                     "radiates a soft white glow.  The closer you stand "
                     "to it the more peaceful you feel.\n");
    _wlever->reset_get();
    _wlever->add_property("there", "on the east wall");
    _wlever->move(this_object());
  }
  if(!_blever) {
    _blever = clone_object("/std/object");
    _blever->set_name("lever");
    _blever->add_adjective("black");
    _blever->set_short("black lever");
    _blever->set_long("This is a lever which is set into the wall.  It "
                     "is pure black and emanates a deep, blood-red glow.  "
                     "The closer you get to it the more angry and hateful "
                     "you feel.\n");
    _blever->reset_get();
    _blever->add_property("there", "on the west wall");
    _blever->move(this_object());
  }
  if(!_glever) {
    _glever = clone_object("/std/object");
    _glever->set_name("lever");
    _glever->add_adjective("grey");
    _glever->set_short("grey lever");
    _glever->set_long("This is a lever which is set into the wall.  It "
                     "is a dull grey and very boring.\n");
    _glever->reset_get();
    _glever->add_property("there", "on the south wall");
    _glever->move(this_object());
  }
}
int do_pull(object lever) {
  int align;
  if(lever == _glever) {
    add_succeeded_mess(({ "$N $V $I and feel an overwhelming urge to do "
          "absolutely nothing about the world's problems.\n",
          "$N $V $I and suddenly looks very apathetic.\n" }),
          ({ _glever }));
    this_player()->set_al(0);
    return 1;
  }
  align = 300 + random(400);
  if(lever == _wlever) {
    align = -align;
  }
  this_player()->set_al(align);
  if(lever == _wlever) {
    add_succeeded_mess(({ "$N $V $I and suddenly feel$s like hugging "
          "everyone.\n",
          "$N $V $I and looks bright and cheery.\n" }),
          ({ _wlever }));
  } else {
    add_succeeded_mess(({ "$N $V $I and get a sudden urge to pull the "
          "wings off butterflies and torture small furry creatures.\n",
          "$N $V $I and a dark scowl crosses $p face.\n" }),
          ({ _blever }));
  }
  return 1;
}

==================================================
FILE: liaison/NEWBIE/assassins.c
==================================================

#include "path.h"
inherit PATH + "inside";
void setup() {
   set_short( "Assassins' gazebo" );
   set_light( 80 );
   add_property("no teleport", 1);
   set_long("This is a very comfortably furnished gazebo.  Obviously assassins "+
            "have excellent taste.  There is no sign at all of anything even "
            "remotely dangerous or threatening.  There is a large plaque on "
            "the wall explaining more about this rather enigmatic "
            "profession. You can view it by typing 'read sign'.\n"
            "A small, black, and elegant looking notice states that this is not "
            "where you actually join this guild.\n" );
   set_zone( "Newbie" );
   add_item("notice", "A small, black, and elegant looking notice that "
            "states that this is not where you actually join the guild.");
   add_item( ({ "furnishing" }), "The room is furnished in an expensive, "
            "although tasteful manner.  On the walls are a variety of "
            "quality oil paintings and the floor is covered with a thick "
            "carpet.  Against one wall is a chaise longue and in a corner "
            "is a well stocked drinks cabinet.");
   add_item("carpet", "A well-made carpet, thick and luxurious.");
   add_item("painting", "A variety of landscapes from some of the Disc's "
            "more notable painters.");
   add_item(({"chaise longue", "chaise", "longue"}),
            "Upholstered in the softest leather "
            "it looks very comfortable.");
   add_item(({"drink", "cabinet"}), "Its most notable feature is that it "
            "is locked.  Behind the glass door you can see a variety of "+
            "bottles, crystal decanters and glasses.");
   add_sign("A plaque entitled 'Guild of Assassins'\n",
            "The guild of assassins provides an excellent all-round "
            "education.  Graduates of the guild (graduation is by "+
            "competitive examination) will be skilled in a wide variety of "
            "subjects and able to move in all social circles.\n"
            "All assassins automatically become player killers (see "
            "'help playerkilling') on graduation.  This is not "+
            "a guild for the faint-hearted.  Becoming an assassin is a "
            "challenge.  Assassins are a proud guild, neither giving nor"
            " asking for information on how to join.\n", 0, 0, "general");
   add_property("no godmother", 1);
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}

==================================================
FILE: liaison/NEWBIE/choose_land.c
==================================================

#include "path.h"
#include <config.h>
#include <language.h>
#include <money.h>
inherit PATH+"inside";
#define DEBUG 1
#define LOG PATH + "save/CHOICE"
private mapping _nationalities;
private object _sign;
void setup() {
   string name;
   string nationality;
   string region;
  _nationalities = ([
       "pumpkin" : "/std/nationality/pumpkin"
     ]);
  add_property("no teleport", 1);
  add_property("determinate", "");
  add_property("no godmother", 1);
  set_zone( "Newbie" );
  set_short( "Discworld's realm of choice" );
  set_light( 75 );
  set_long("You are on a huge open-air platform far, far above the Disc itself.  "
           "Down below, the water tumbles and falls off the rim of the disc "
           "spilling down and out into a spray of mist over the elephants and "
           "the back of A'tuin, the great star turtle.  There are several "
           "sets of stairs leading down off the platform to the unknown and "
           "a large dial sits in the middle of the room.  A large sign "
           "shimmers and hangs in the air in the middle of the platform.\n");
  add_item(({ "disc", "Disc", "discworld"}),
           "You can see from the sharp spire of Cori "
           "Celesti at the centre, to the surrounding Circle Sea, "
           "the deserts of Klatch, the watery world of Krull, and the "
           "mysterious Counterweight Continent.  A spectacular rimbow "
           "sparkles where the seas pour over the edge of the Disc.  As "
           "you study the map's details, you are sure you saw one of the "
           "elephants move.");
  add_item("rimbow", "It's like a rainbow except that it's caused by the "
           "water pouring off the edge of the disc.");
  add_item("elephant", "These are the four elephants that bear the weight"
           " of the Disc.");
  add_item(({ "floor", "platform" }),
           "The floor is made of some weird black stone that is "
           "semi-transparent, allowing the Disc below you to be "
           "seen through it.");
  add_item(({ "stairs", "stairways" }), "Stairs leading down to the "
           "dark unknown.  They all appear to be crafted of some thin, "
           "spidery metal.");
  add_item("dial", "The dial is a huge heavy looking stone dial, with some "
                   "arrows and numbers carved into the surface.  They say "
                   "'Klatch 4000 miles', 'Ankh-Morpork 3000 miles', "
                   "'Lancre 3500 miles', 'Bes Pelargic 3000 miles'.");
   _sign = add_sign("A huge shimmering sign, the letters are transparent "
      "and it is possible to walk through it.\n",
      FOYER->format_sign(
      "Travellers choose your destination!  Which parts of the world "
      "do you want to explore?\n\n"
      "Look carefully at each of the lands "
      "before you make your choice - it determines the language you "
      "start with and your local accent, as well as where you start.\n\n"
      "The current list of available start nationalities is: " +
      query_multiple_short(keys(_nationalities)) + ".\n\n"
      "You can get 'info' on each nationality, and each region within "
      "a nationality.\n\n"
      "You choose your nationality with 'choose <nationality> <region>'; "
      "for example 'choose morpork Ankh-Morpork'.\n\n"
      "Use 'help here' for more help on 'info' and 'choose'.\n"),
      "shimmering sign", "sign", "general");
   foreach (name, nationality in _nationalities) {
      if (file_size(nationality + ".c") > 0) {
         add_item(name, nationality->query_information());
         foreach (region in nationality->query_regions()) {
            add_item(name + " " + lower_case(region), nationality->query_region_description(region));
         }
      } else {
         printf("Bad nationality %O\n", nationality);
      }
   }
   add_help_file(PATH + "doc/choose_land");
}
string find_region(string nationality, string region) {
   string tmp;
   foreach (tmp in nationality->query_regions()) {
      if (lower_case(tmp) == lower_case(region)) {
         return tmp;
      }
   }
   return 0;
}
void change_nationality(object person, string nationality, string region) {
   string old_nationality;
   int old_speak;
   int old_write;
   int new_speak;
   int new_write;
   string skill_speak;
   string skill_write;
   string lang;
   string guild;
   mixed newbie;
   nationality = _nationalities[nationality];
   old_nationality = this_player()->query_nationality();
#ifdef DEBUG
   debug_printf("Old nationality was %O, new nationality is %O.\n", old_nationality, nationality);
#endif
   lang = nationality->query_language();
   skill_speak = LANGUAGE_HAND->query_language_spoken_skill(lang);
   skill_write = LANGUAGE_HAND->query_language_written_skill(lang);
   old_speak = this_player()->query_skill(skill_speak);
   old_write = this_player()->query_skill(skill_write);
   if (old_speak > 100) {
      old_speak = 100;
   }
   this_player()->add_skill_level(skill_speak, 100 - old_speak);
   if (old_write > 100) {
      old_write = 100;
   }
   this_player()->add_skill_level(skill_write, 100 - old_write);
   if (old_nationality &&
       old_nationality->query_language() != nationality->query_language()) {
      lang = old_nationality->query_language();
      skill_speak = LANGUAGE_HAND->query_language_spoken_skill(lang);
      skill_write = LANGUAGE_HAND->query_language_written_skill(lang);
      new_speak = this_player()->query_skill(skill_speak);
      new_write = this_player()->query_skill(skill_write);
      if (new_speak > 100) {
         new_speak = 100;
      }
      this_player()->add_skill_level(skill_speak, old_speak - new_speak);
      if (new_write > 100) {
         new_write = 100;
      }
      this_player()->add_skill_level(skill_write, old_write - new_write);
   }
   this_player()->set_nationality(nationality);
   this_player()->set_nationality_region(find_region(nationality, region));
   lang = nationality->query_language();
   this_player()->set_default_language(lang);
   this_player()->set_language(lang);
   guild = this_player()->query_guild_ob();
   newbie = this_player()->query_property("not real newbie");
   log_file( LOG , "%s:\n   %s the %s%s chose %s (%s)\n",
      ctime(time()),
      this_player()->query_short(),
      guild ? capitalize(guild[12..<1]) : "Adventurer",
      newbie ? "" : " (newbie)",
      capitalize(this_player()->query_nationality_region()),
      capitalize(this_player()->query_nationality()[17..<1]));
   if (!this_player()->query_property("not real newbie")) {
      int value;
      string currency_area = "";
      mixed* array;
      value = this_player()->query_value_in("Newbie Area");
      currency_area = this_player()->query_nationality()->query_currency_area();
      if (this_player()->query_nationality_region() == "Sto Lat" ) {
         currency_area = "default";
      }
      tell_creator( "wyvyrn" ,
         "[ %s the %s%s picked %s and got money for %s ]\n",
         this_player()->query_short(),
         guild ? capitalize(guild->query_name()[0..<2]) : "Adventurer",
         newbie ? "" : " (newbie)",
         this_player()->query_nationality_region(),
         currency_area);
      array = MONEY_HAND->create_money_array(value, currency_area);
      this_player()->set_money_array(array);
   } else {
      object ob;
      foreach (ob in all_inventory()) {
         if (!living(ob) && ob->query_short() != "shimmering sign") {
            ob->move(nationality->query_region_start_location(region));
         }
      }
      tell_creator( "wyvyrn" ,
         "[ %s the %s%s picked %s and kept their money ]\n",
         this_player()->query_short(),
         guild ? capitalize(guild->query_name()[0..<2]) : "Adventurer",
         newbie ? "" : " (newbie)",
         this_player()->query_nationality_region());
   }
}
int setup_nationality(string direction, object person) {
   string* bits;
   bits = explode(direction, " ");
   change_nationality(person, bits[1], implode(bits[2..], " "));
   return 1;
}
int do_choose(string nat, string region) {
   string region_new;
   string nationality;
   string loc;
   nationality = lower_case(nat);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nat = nationality;
   nationality = _nationalities[nationality];
   region_new = find_region(nationality, region);
   if (!region_new) {
      add_failed_mess("Cannot find the region " + region +
                      " in the nationality " + nat + ".  It must be "
                      "one of " +
                      query_multiple_short(nationality->query_regions()) + ".\n");
      return 0;
   }
#ifdef DEBUG
   debug_printf("Nationality is %O, region is %O, player is %O.\n",
      nationality, region_new, this_player()->query_short());
#endif
   change_nationality(this_player(), nat, region_new);
   loc = nationality->query_region_start_location(region_new);
   this_player()->move_with_look(loc, "$N arrive$s into the world.",
                                 "$N disappears to a better life.");
   this_player()->remove_property("not real newbie");
   if (clonep(this_object())) {
      call_out((: dest_me :), 10);
      if (_sign) {
         _sign->dest_me();
      }
   }
   return 1;
}
int do_info(string nat, string region) {
   string region_new;
   string nationality;
   nationality = lower_case(nat);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nationality = _nationalities[nationality];
   region_new = find_region(nationality, region);
   if (!region_new) {
      add_failed_mess("Cannot find the region " + region +
                      " in the nationality " + nat + ".  It must be "
                      "one of " +
                      query_multiple_short(nationality->query_regions()) + ".\n");
      return 0;
   }
#ifdef DEBUG
   debug_printf("Nationality is %O, region is %O, player is %O.\n",
      nationality, region_new, this_player()->query_short());
#endif
   write(nationality->query_region_description(region_new) + "\n");
   return 1;
}
int do_nationality_info(string nationality) {
   string ret;
   string region;
   nationality = lower_case(nationality);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nationality = _nationalities[nationality];
   ret = nationality->query_information() +
         "Regions you can choose:\n";
   foreach (region in nationality->query_regions()) {
      ret += "  * " + region + "\n";
   }
   write(ret);
   return 1;
}
void init() {
  add_command("info", "<word'nation'>", (: do_nationality_info($4[0]) :));
  add_command("info", "<word'nation'> <string'region'>", (: do_info($4[0], $4[1]) :));
  add_command("choose", "<word'nationality'> <string'region'>", (: do_choose($4[0], $4[1]) :));
}
void fixup_player(object player) {
   object ob;
   ob = clone_object(__FILE__);
   player->move_with_look(ob);
}
string query_quit_handler() {
   return __FILE__;
}

==================================================
FILE: liaison/NEWBIE/combat.c
==================================================

#include "path.h"
#define MAX 100;
inherit PATH+"inside";
object instructor;
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short("Combat Training Room");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  There is a small sign attached to the wall.\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "southwest", "foyer");
  add_exit("one", PATH + "combat_room1", "door");
  add_exit("two", PATH+"combat_room2", "door");
  add_exit("three", PATH+"combat_room3", "door");
  modify_exit("one", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room one.\n"}));
  modify_exit("two", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room two.\n"}));
  modify_exit("three", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room three.\n"}));
}
void reset() {
  if(!sign) {
    sign=add_sign("This is a sign stuck to the wall.  It contains "
                  "instructions on how to use this room.\n",
                  "Welcome to the newbie combat area!  If you would like "
                  "to practise your combat skills just ask Greg.  To do "
                  "this say \"can I practise please\".",
                  0, "sign", "general");
  }
}
void dest_me() {
  if(sign)
    sign->dest_me();
  if(instructor)
    instructor->dest_me();
  ::dest_me();
}
void init() {
  call_out("get_instructor", 0);
}
void get_instructor() {
  if(!instructor)
    instructor = load_object(PATH +"greg");
  if(instructor && environment(instructor) != this_object()) {
    instructor->move( this_object(), "$N marches in from another room.");
  }
}
int check_room(string str, object ob, string special_mess) {
  int room;
  switch(str) {
  case "one":
    room = 0;
    break;
  case "two":
    room = 1;
    break;
  case "three":
    room = 2;
  }
  if(ob == instructor)
    return 1;
  if(!instructor || instructor->query_using(room) != ob) {
    tell_object(ob, "The door slams closed in your face.\n");
    modify_exit("one", ({ "closed", 1}));
    return notify_fail("");
  }
  return 1;
}

==================================================
FILE: liaison/NEWBIE/combat_room1.c
==================================================

#include "path.h"
#define MAX 100;
inherit PATH + "inside";
string *arr0;
object sign, dummy, trainer;
void setup() {
  set_short("Xrazzicaz' Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
  add_property("no godmother", 1);
  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "southeast", "foyer");
}
void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                  "your combat skills assessed.\n", "To assess your "
                  "skills, attack the dummy with the weapon you want to "
                  "test your proficiency in.  Each time you hit the "
                  "dummy, the instructor will comment on your "
                  "performance.  After a number of rounds, the "
                  "instructor will stop you and give you an overall "
                  "performance rating.\n\n"
                  "Don't forget to hold your weapon of choice before "
                  "attacking the training dummy!\n",
                  "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  call_out("get_trainer", 1);
}
void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}
void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  if (trainer) {
    trainer->whichone("xrazzicaz");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}
void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}
string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
}

==================================================
FILE: liaison/NEWBIE/combat_room2.c
==================================================

#include "path.h"
#define MAX 100;
inherit PATH + "inside";
string *arr0;
object sign, dummy, trainer;
void setup() {
  set_short("Zazzifraz' Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
  add_property("no godmother", 1);
  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "northwest", "combat");
}
void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                  "your combat skills assessed.\n", "To assess your "
                  "skills, attack the dummy with the weapon you want to "
                  "test your proficiency in.  Each time you hit the "
                  "dummy, the instructor will comment on your "
                  "performance.  After a number of rounds, the "
                  "instructor will stop you and give you an overall "
                  "performance rating.\n\n"
                  "Don't forget to hold your weapon of choice before "
                  "attacking the training dummy!\n",
                  "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  call_out("get_trainer", 1);
}
void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}
void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  if (trainer) {
    trainer->whichone("zazzifraz");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}
void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}
string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
}
