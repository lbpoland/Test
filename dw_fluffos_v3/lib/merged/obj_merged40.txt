# Total Tokens: 17878
# Total Files Merged: 37
# Total Characters: 59700

paint.c
==================================================

inherit "/obj/vessel";
#define VOLUME 5000
private nosave string _colour;
varargs int do_paint(string, object);
void setup() {
  set_name( "tin" );
  set_short( "tin of paint" );
  set_main_plural( "tins of paint");
  add_adjective( ({ "tin", "of"}));
  add_alias(({"paint"}));
  set_long( "A tin of paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
  set_leak_rate( 0 );
  set_max_volume( VOLUME );
  set_value( 30 );
  set_weight( 10 );
  set_max_weight( 30 );
}
void setup_attribs() {
  set_short( "tin of " + _colour + " paint" );
  set_main_plural( "tins of " + _colour + " paint");
  add_adjective( ({ _colour}));
  set_long( "A tin of " + _colour + " paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
}
void make_tin( string colour ) {
  object liquid;
  liquid = clone_object( "/obj/reagents/generic_liquid.ob" );
  liquid->set_name( "paint" );
  liquid->set_short( colour + " paint" );
  liquid->add_adjective(({colour }));
  liquid->set_amount( VOLUME );
  liquid->set_continuous();
  liquid->set_long( "This is " + colour + " paint, it's thick and gloopy.\n");
  liquid->set_pile_name( "puddle" );
  liquid->add_eat_effect( "/std/effects/ingested/poison", 10 );
  liquid->move( this_object() );
  set_closed();
  _colour = colour;
  setup_attribs();
}
void init() {
  ::init();
  this_player()->add_command("paint", this_object(),
           "<indirect:object:here'cardinal direction'> with <direct:object'paint'>",
                        (: do_paint( $4[0] ) :));
  this_player()->add_command("paint", this_object(),
                        "<string'part'> on <indirect:object:here> with <direct:object'paint'>",
                        (: do_paint( $4[0], $1[0] ) :));
  this_player()->add_command("paint", this_object(),
            "<indirect:object:here> help",
            (: do_paint( 0, $1[0] ) :));
}
varargs int do_paint(string indirect, object target) {
  object *obs;
  if(!indirect && target) {
      if(function_exists("what_to_paint", target))
          printf(target->what_to_paint());
      else
          printf("Help: paint " + target->short() + " with paint\n");
      return 1;
  }
  obs = match_objects_for_existence("paint", this_object());
  if(!query_volume() || !sizeof(obs)) {
    this_player()->add_failed_mess(this_object(), "$D appears to be empty.\n",
                                   ({ }));
    return 0;
  }
  if(query_closed()) {
    this_player()->add_failed_mess(this_object(), "$D is closed.\n", ({ }));
    return 0;
  }
  if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
                    (: $1->id("paint brush") :)))) {
    this_player()->add_failed_mess(this_object(), "You must be holding a "
                                   "paint brush to paint the walls.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->test_occupier(this_player()->query_name())) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  if(target) {
      if(!target->query_short()) return 0;
          if(!function_exists("decorate_part", target)) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                indirect + " on the " + target->query_short() + "!\n", ({ }));
                  return 0;
          }
          if(!target->decorate_part( indirect, obs[0]->query_short() )) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                                                        indirect + ".\n", ({ }));
                  return 0;
          }
          this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " on the " + target->query_short() +
                                                                        " with the brush using light, smooth strokes.\n", ({ }));
          return 1;
  }
  if(!function_exists("decorate_surface", environment(this_player()))) {
    this_player()->add_failed_mess(this_object(), "You can't $V the walls "
                                   "here.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->
     decorate_surface(indirect, "covered with " + obs[0]->query_short())) {
    this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                   indirect + ".\n", ({ }));
    return 0;
  }
  remove_volume(query_volume());
  this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " with $D using "
                                    "broad, smooth strokes.\n", ({ }));
  return 1;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
          "colour" : _colour,
          ]);
}
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["colour"]))
    _colour = args["colour"];
  if(_colour)
    setup_attribs();
}

==================================================
FILE: misc/top_clubs.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top club table" );
   set_long("This is a table listing those clubs that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "club", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   string *g_sorted;
   mapping g_info;
   stuff = TOP_TEN_HANDLER->query_club_info();
   str = "The club with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         ;
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the club must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_families.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top family table" );
   set_long("This is a table listing those families that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "family", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   mapping g_info;
   string *g_sorted;
   stuff = TOP_TEN_HANDLER->query_family_info();
   str = "The family with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         "Most average relationships: " +
         club_name(stuff[TOP_TEN_MOST_RELATIONSHIPS]) + "\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the family must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_ten_tables.c
==================================================

#include <top_ten_tables.h>
inherit "/std/object";
string generate_list( mixed *args );
string generate_table_message();
nosave string table_name;
nosave string language = "morporkian";
void setup() {
   table_name = 0;
   set_name( "table" );
   set_short( "top ten table" );
   set_long( "This is a perfectly rectangular wooden board, "
     "nailed to another piece of wood.\n" );
   add_adjective( ({ "top", "ten", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out( "setup_read_mess", 5 );
   call_out("dest_me", 30);
}
string query_table_name() { return table_name; }
void set_table_name( string word ) { table_name = word; }
void set_language( string lang ) {
  language = lang;
}
void setup_read_mess() {
   add_read_mess((: generate_table_message() :), 0, language, 0);
}
string generate_table_message() {
   string long;
   mixed *args;
   long = "\nHigh Score Table: ";
   args = (mixed *)TOP_TEN_HANDLER->query_ordered_table( table_name );
   if ( !table_name ) {
      long += "All Players";
      if ( !sizeof( args ) )
         return long +": There is no overall top ten at present.\n";
   } else {
      if ( file_size( "/std/guilds/"+ table_name +".c" ) < 0 )
         return "*Barf!* Can't find /std/guilds/"+ table_name +".\n";
      long += capitalize( (string)( "/std/guilds/"+ table_name )->
                     query_name() ) + "' Guild";
      if ( !sizeof( args ) )
         return long +": There is no top ten for this guild at present.\n";
   }
   return sprintf( "%|*s\n", table_name ? 40 : 50, long ) +
          sprintf( "%|*s\n", table_name ? 40 : 50, "Sorted by rating" ) +
          sprintf( "%|*s\n\n", table_name ? 40 : 50,
                   "-=- " + ctime(time()) + " -=-" ) +
          generate_list(args) + "\n";
}
string convert_age( int number ) {
   if ( number > 86400 )
      return ( number / 86400 ) +"D";
   if ( number > 3600 )
      return ( number / 3600 ) +"h";
   if ( number > 60 )
      return ( number / 60 ) +"m";
   return number +"s";
}
string generate_list( mixed *args ) {
   int i, number, sum;
   string format, list;
   if ( table_name )
      format = "  %2d. %-13s: level %4d  %5s";
   else
      format = "  %2d. %-23s: level %4d  %5s";
   format += "\n";
   list = "";
   number = sizeof( args );
   sum = 0;
   for ( i = 0; i < number; i++ )  {
      list += sprintf( format, i + 1, capitalize( args[ i ][ TOP_TEN_NAME ] ),
            args[ i ][ TOP_TEN_LEVEL ],
            convert_age( args[ i ][ TOP_TEN_AGE ] ) );
      if ( i > 0  &&  i < number - 1 )  {
         sum += args[i][TOP_TEN_RATING];
      }
   }
   return list;
}

==================================================
FILE: misc/torch.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
#define BRIGHTNESS 30
#define MAX_FUEL 2000
#define FUEL_PER_TICK ( FUEL_TIME * 2 )
private int amount_of_fuel;
private int is_lit;
int finish_it();
void setup_shorts();
void create() {
   object::create();
   holdable::create();
}
void setup() {
   amount_of_fuel = MAX_FUEL;
   set_name( "torch" );
   add_plural( "torches" );
   setup_shorts();
   add_help_file("torch");
   set_long( function() {
      string str;
      if ( is_lit && amount_of_fuel) {
         call_out( (: setup_shorts() :), 2 );
         str = "This is a fire burning out of control on the end "
            "of a stick of wood.  There is a lot of smoke coming "
            "off the fire, of the kind that, no matter which "
            "way you turn, will go up your nose.";
         switch ( amount_of_fuel / ( MAX_FUEL / 10 ) ) {
          case 10 :
          case 9  :
            return str+"  The torch looks brand new, it will burn for "
               "ages yet.\n";
          case 8 :
          case 7 :
          case 6 :
            return str+"  Not yet burning for very long, this torch is "
               "pretty happy with itself.  It doesn't seem "
               "to care about its short life span.\n";
          case 5 :
          case 4 :
            return str+"  The torch is happily burning.  It is in the "
               "prime of its life.\n";
          case 3 :
            return str+"  The torch has a little way to go yet, as it is "
               "now burning the light wood.\n";
          case 2 :
            return str+"  It looks like this torch won't "
               "last much longer.  Buying a new one would "
               "probably be a good investment.\n";
          case 1 :
          case 0 :
            return str+"  The torch is spluttering, there are huge "
               "amounts of smoke coming off it.  It looks like "
               "it is about to go out.\n";
         }
      }
      if ( amount_of_fuel >= MAX_FUEL )
         return "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end of it, and it looks as "
         "though it might be possible to light them.  The dirty rags "
         "have some sort of stuff covering them, probably "
         "to make them burn better.\n";
      if ( amount_of_fuel > MAX_FUEL / 2 )
         return "Someone has cut down a tree, chopped it up into smaller "
         "chunks and then wrapped the end in some rags.  "
         "The rags are blackened and it looks like someone set "
         "fire to them.  Perhaps you can too?\n";
      str = "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end.  ";
      if ( !amount_of_fuel )
         return str +"The end is completely blackened.  You would "
         "have to be extremely clever to get this torch "
         "going again.\n";
      switch (amount_of_fuel/(MAX_FUEL/10)) {
       case 5 :
       case 4 :
         return str +"The end has been blackened quite a bit, "
            "but it looks like there is a fair bit of "
            "go still left in it.\n";
       case 3 :
       case 2 :
         return str +"A few rags here and there cling to a meager "
            "existence.  You could set fire to them and "
            "make their life hell for a little while, but "
            "not for very long.\n";
       case 1 :
       case 0 :
         return str +"You can just see the remains of some rags "
            "attached to the blackened and burnt end of "
            "the torch.  It will last only for a short while "
            "longer.\n";
      }
      return "Whoops.  Tell a creator if you see this.\n";
   }
            );
   is_lit = 0;
   set_weight( 6 );
   set_value( 50 );
}
void set_fuel(int f) {
   amount_of_fuel = f;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   setup_shorts();
}
void init() {
  this_player()->add_command( "light", this_object() );
  this_player()->add_command( "extinguish", this_object() );
  this_player()->add_command( "dowse", this_object() );
}
void setup_shorts() {
   if ( is_lit && amount_of_fuel) {
      set_short( "lit torch" );
      set_main_plural( "lit torches" );
      remove_adjective( ({ "lightable", "burnt", "out" }) );
      add_adjective( "lit" );
   } else if ( amount_of_fuel > 0 ) {
      set_short( "lightable torch" );
      set_main_plural( "lightable torches" );
      remove_adjective( ({ "lit", "burnt", "out" }) );
      add_adjective( "lightable" );
   } else {
      set_short( "burnt torch" );
      set_main_plural( "burnt torches" );
      remove_adjective( ({ "lit", "lightable" }) );
      add_adjective( ({ "burnt", "out" }) );
   }
}
int do_light() {
   if (environment(this_object()) != this_player()) {
      this_player()->add_failed_mess( this_object(),
                                     "You are not carrying $D.\n", ({ }) );
      return 0;
   }
   if (amount_of_fuel <= 0) {
      this_player()->add_failed_mess( this_object(), "$D is burnt out.\n",
                                     ({ }) );
      return 0;
   }
   if (is_lit) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if (!query_holder() &&
       !sizeof( this_object()->hold_item( this_player(), -1 ) ) ) {
     this_player()->add_failed_mess( this_object(), "Unable to hold $D, "
         "your arms are probably full.\n", ({ }) );
      return 0;
   }
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( "setup_shorts", 2);
   return 1;
}
void out_of_fuel() {
   is_lit = amount_of_fuel = 0;
   set_light( 0 );
   set_value( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   tell_room( environment(), one_short() +" splutters violently "
     "for the last time before it crumbles to dust.\n" );
   call_out( "finish_it", 2 );
}
void do_warning() {
   tell_room( environment(), poss_short() +" starts to sputter and smoke a "
             "lot as it is now burning the light wood.  It is on its last "
             "legs.\n");
   return;
}
void consume_fuel() {
   amount_of_fuel -= FUEL_PER_TICK;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   switch ( amount_of_fuel ) {
    case (200-FUEL_PER_TICK) .. 200:
      do_warning();
      break;
    case 0:
      out_of_fuel();
      break;
    default:
   }
}
int do_extinguish(object *, string, string, string) {
   if ( !is_lit && objectp( this_player() ) ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }) );
      return 0;
   } else if ( !is_lit ) {
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   call_out( "setup_shorts", 2);
   return 1;
}
int do_dowse() {
   return do_extinguish(({ }), 0, 0, 0);
}
void dest_me() {
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   holdable::dest_me();
   object::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , amount_of_fuel, }),
    ({ "is lit", is_lit, }),
   });
}
mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "amount of fuel" : amount_of_fuel,
            "hold" : holdable::query_dynamic_auto_load(),
            "is lit" : is_lit,
          ]);
}
int held_this_item(int type, object holder, mixed arg) {
   if (!type) {
      if (holder && is_lit) {
         tell_object( holder,
                     "You extinguish the "+ short() +" as you put it down.\n");
         tell_room( environment(holder ),
                   holder->short() +" extinguishes the "+
                   short() +" as "+ holder->query_pronoun()
                   +" puts it down.\n", ({ holder }));
      }
      do_extinguish( ({ }), "", "", "");
   } else if (type == 2) {
      if (arg && holder && amount_of_fuel > 0) {
         set_light( BRIGHTNESS );
         FUEL_HANDLER->add_burner( this_object() );
         is_lit = 1;
      } else {
         is_lit = 0;
      }
      setup_shorts();
   }
   return 1;
}
void init_dynamic_arg( mapping arg ) {
   amount_of_fuel = arg["amount of fuel"];
   is_lit = arg["is lit"];
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
}
void init_static_arg(mapping arg) {
}
mapping query_static_auto_load() {
   return 0;
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}
void self_light() {
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( (: setup_shorts() :), 2);
   return;
}
  int finish_it () {
    this_object()->move( "/room/rubbish" );
    return 1;
}
int query_torch() {
  return 1;
}
int query_lit() {
  return is_lit;
}
int query_fuel() {
  return amount_of_fuel;
}

==================================================
FILE: misc/trap.c
==================================================

#include <move_failures.h>
#include <tasks.h>
inherit "/std/object";
int difficulty;
string trigger;
string description;
mixed message;
mixed effect;
void create() {
  add_help_file("door_trap");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void make_trap(int diff, string trig, string desc, mixed mess, mixed eff) {
  difficulty = diff;
  trigger = trig;
  description = desc;
  message = mess;
  effect = eff;
}
void init() {
  this_player()->add_command("rig", this_object(),
           "<indirect:object:here> with <direct:object:me>");
}
int do_rig(mixed *in_dir, string direct, string indirect, mixed *args,
             string) {
  object ob;
  object other;
  if(sizeof(in_dir) > 1) {
    this_player()->add_failed_mess(this_object(), "A trap can only be rigged "
                                   "on a single item.\n");
    return 0;
  }
  if(!difficulty) {
    this_player()->add_failed_mess(this_object(), "$D appears to be "
                                   "broken.\n");
    return 0;
  }
  ob = in_dir[0];
  if(ob->query_trap_difficulty() && ob->query_trap_armed()) {
    this_player()->add_failed_mess(this_object(),
                                   "$I already has an armed trap on it.\n",
                                   ({ in_dir[0] }));
    return 0;
  }
  if(!function_exists("setup_trap", ob, 0)) {
    this_player()->add_failed_mess(this_object(), "$I cannot be $Ved with "
                                   "$D.\n", ({ ob }));
    return 0;
  }
  if((trigger == "pick" || trigger == "unlock") &&
     (!ob->query_key() || ob->query_key() == "generic_key")) {
    this_player()->add_failed_mess(this_object(), "$I doesn't have a lock "
                                   "so $Vging it with $D which is triggered "
                                   "by " + trigger + "ing makes no sense.\n",
                                   ({ ob }));
    return 0;
  }
  switch(TASKER->perform_task(this_player(), "covert.items.traps", difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about rigging "
          "traps.%^RESET%^\n");
  case SUCCEED:
    difficulty +=
      random(this_player()->query_skill_bonus("covert.items.traps") / 10);
    break;
  default:
    if(random(difficulty) >
       this_player()->query_skill_bonus("covert.items.traps") ||
       difficulty >
       this_player()->query_skill_bonus("covert.items.traps") * 2) {
      if(arrayp(message)) {
        write(message[0]);
        say(message[1], this_player());
      } else
        write(message);
      if(intp(effect)) {
        if(effect > this_player()->query_hp())
          this_player()->do_death();
        else
          this_player()->adjust_hp(-(effect));
      } else if(arrayp(effect)) {
        switch(sizeof(effect)) {
        case 1:
          this_player()->add_effect(effect[0]);
          break;
        case 2:
          this_player()->add_effect(effect[0], effect[1]);
          break;
        default:
          this_player()->add_effect(effect[0], effect[1..]);
        }
      } else
        this_player()->add_effect(effect);
      this_object()->move("/room/rubbish");
      this_player()->add_succeeded_mess(this_object(), "As $N attempt$s to "
                                        "$V $D it goes off!\n");
      return 1;
    } else {
      difficulty -= random(difficulty -
                    this_player()->query_skill_bonus("covert.items.traps"));
    }
  }
  ob->setup_trap(difficulty, trigger, description, message, effect);
  if(function_exists("query_my_room", ob)) {
    other = load_object( (string)( ob->query_dest() ) );
    other = other->query_door_control( (string)( ob->query_other_id() ) );
    other->setup_trap(difficulty, trigger, description, message, effect);
    environment(this_player())->update_doors();
  }
  this_player()->add_succeeded_mess(this_object(), "$N carefully $V $I "
                                    "with $D.\n",
                                    ({ ob }));
  call_out("break_me", 1);
  return 1;
}
void break_me() {
  object ob;
  ob = clone_object("/std/object");
  ob->set_name("trap");
  ob->set_short("busted trap");
  ob->set_long("A broken trap.\n");
  ob->set_value(0);
  ob->set_weight(this_object()->query_weight());
  ob->move(environment());
  if(this_object()->move("/room/rubbish") != MOVE_OK)
    this_object()->dest_me();
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
            "difficulty" : difficulty,
            "trigger" : trigger,
            "description" : description,
            "message" : message,
            "effect" : effect
            ]);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping map) {
  if(!mapp(map))
    return;
  if(!undefinedp(map["::"]))
    ::init_static_arg(map["::"]);
  if(!undefinedp(map["difficulty"]))
    difficulty = map["difficulty"];
  if(!undefinedp(map["trigger"]))
    trigger = map["trigger"];
  if(!undefinedp(map["description"]))
    description = map["description"];
  if(!undefinedp(map["message"]))
    message = map["message"];
  if(!undefinedp(map["effect"]))
    effect = map["effect"];
}

==================================================
FILE: misc/tray.c
==================================================

#include <move_failures.h>
inherit "/std/surface";
inherit "/std/basic/holdable";
inherit "/std/basic/wearable";
void create() {
  wearable::create();
  holdable::create();
  surface::create();
}
void setup() {
  set_name( "tray" );
  set_short( "wooden tray" );
  set_long( "This is a small wooden tray, similar in style to the ones used by "
    "many vendors and travelling salespeople. Only a small quantity of items will "
    "fit on top of it.\n" );
  add_adjective(({ "small", "wooden" }));
  set_material("wood");
  set_weight(5);
  set_max_weight(40);
  set_no_limbs(2);
  set_type("sash");
  set_cond(1000);
  set_max_cond(1000);
  add_wear_effect( "/std/effects/attached/single_shoulder" );
}
string long( string word, int dark ) {
  return surface::long() + wearable::long();
}
varargs int move( mixed dir, string messin, string messout ) {
  if ( holdable::move( dir, messin, messout ) == MOVE_OK ) {
	  return surface::move( dir, messin, messout );
  }
  return MOVE_NO_UNHOLD;
}
mapping query_static_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_static_auto_load();
  map["surface"] = surface::query_static_auto_load();
  map["wearable"] = wearable::query_static_auto_load();
  return map;
}
void init_static_arg( mapping map ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_static_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_static_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_static_arg( map["wearable"] );
}
void dest_me() {
  holdable::dest_me();
  surface::dest_me();
}
mapping query_dynamic_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_dynamic_auto_load();
  map["surface"] = surface::query_dynamic_auto_load();
  map["wearable"] = wearable::query_dynamic_auto_load();
  return map;
}
varargs void init_dynamic_arg( mapping map, mixed new_arg ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_dynamic_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_dynamic_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_dynamic_arg( map["wearable"] );
}
mixed stats() {
	return surface::stats() + wearable::stats();
}

==================================================
FILE: misc/wallpaper.c
==================================================

inherit "/std/object";
private nosave string _design;
varargs int do_paper(string indirect, object pot);
void setup() {
    set_name( "wallpaper" );
    set_short( "roll of wallpaper" );
    set_main_plural( "rolls of wallpaper");
    add_adjective( ({ "roll", "of"}));
    add_plural_adjective("rolls");
    add_alias(({"paper"}));
    set_long( "This is a large roll of wallpaper, probably enough to "
        "cover a single wall completely.\n");
    set_value( 480 );
    set_weight( 10 );
}
void make_roll( string design ) {
    _design = design;
    set_short( "roll of " + _design + " wallpaper" );
    set_main_plural( "rolls of " + _design + " wallpaper");
    add_adjective( ({ _design })) ;
    set_long( "This is a large roll of " + _design + " wallpaper.  It "
        "looks like there's just enough of it to cover a single wall "
        "completely.  If you had some wallpaper glue you could probably "
        "paste it to the wall.\n");
}
void init() {
    this_player()->add_command("paste", this_object(),
       "<direct:object> to <indirect:object:here'cardinal direction'> using <indirect:object'pot'>", (: do_paper( $4[1], $1[1][0] ) :));
}
string query_paper_mess() {
    if( _design ) {
        return _design + " wallpaper";
    }
    else {
        return "strangely featureless wallpaper";
    }
}
varargs int do_paper(string indirect, object pot) {
    object *obs;
    if(!indirect && pot) {
        if(function_exists("what_to_paint", pot))
            printf(pot->what_to_paint());
        else
            printf("Help: paste " + pot->short() + " with wallpaper\n");
            return 1;
    }
    obs = match_objects_for_existence("glue", pot);
    if(pot->query_closed()) {
        this_player()->add_failed_mess(this_object(), "$I is "
            "closed.\n", ({ pot }));
        return 0;
    }
    if(!pot->query_volume(obs) || !sizeof(obs)) {
        this_player()->add_failed_mess(this_object(), "$I appears to "
            "be empty.\n", ({ pot }));
        return 0;
    }
    if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
        (: $1->id("brush") :)))) {
        this_player()->add_failed_mess(this_object(), "You must be holding a "
            "paint brush to paint the walls with glue.\n", ({ }));
        return 0;
    }
    if(!environment( this_player() )->test_occupier( this_player()->
        query_name() ) ) {
        this_player()->add_failed_mess(this_object(), "You don't own this "
            "house.\n", ({ }));
        return 0;
    }
    if(!function_exists("decorate_surface", environment(this_player()))) {
        this_player()->add_failed_mess(this_object(), "You can't $V the "
            "walls here.\n", ({ }));
        return 0;
    }
    if(!environment(this_player())->decorate_surface(indirect,
        "papered with " + query_paper_mess())) {
        this_player()->add_failed_mess(this_object(), "You can't $V the $D"
            " to the " + indirect + " using $I for some reason.\n",
            ({ pot }));
        return 0;
    }
    pot->remove_volume(pot->query_volume());
    this_object()->move("/room/rubbish");
    this_player()->add_succeeded_mess(this_object(), "$N $V $D to the " +
        indirect + ", dawbing it with paste from $I and pressing it firmly "
        "against the surface.\n", ({ pot }) );
    return 1;
}
mapping int_query_static_auto_load() {
    mapping tmp;
    tmp = ::int_query_static_auto_load();
    return ([ "::" : tmp,
              "design" : _design,
            ]);
}
mapping query_static_auto_load() {
    if ( base_name(this_object()) + ".c" == __FILE__ )
        return int_query_static_auto_load();
    return ([ ]);
}
void init_static_arg(mapping args) {
    if (args["::"])
    ::init_static_arg(args["::"]);
    if(!undefinedp(args["design"]))
        _design = args["design"];
    if(_design)
        make_roll(_design);
}

==================================================
FILE: misc/wallpaper_glue.c
==================================================

inherit "/obj/vessel";
#define VOLUME 5000
object add_glue();
void setup() {
    set_name("glue");
    set_short("pot of wallpapering glue");
    add_adjective( ({ "pot", "of", "wallpapering", "wallpaper" }) );
    add_alias("pot");
    add_plural("pots");
    set_max_volume(VOLUME);
    set_long("This is a small pot of wallpapering glue, essential "
        "for anybody who's going to be doing anything involving "
        "sticking paper to walls or playing mean tricks on their "
        "friends.\n");
    set_value(480);
    set_closed();
}
object add_glue() {
    object glue;
    glue = clone_object( "/obj/reagents/generic_liquid.ob" );
    glue->set_name( "glue" );
    glue->set_short( "sticky white wallpapering glue" );
    glue->add_adjective( ({ "sticky", "white", "wallpapering",
        "wallpaper"  }));
    glue->set_amount( VOLUME );
    glue->set_continuous();
    glue->set_long( "This is some thick and gloopy wallpapering glue.  "
        "Along with some wallpaper and a brush, you could probably "
        "do some fine home decorating.\n");
    glue->set_pile_name( "puddle" );
    glue->add_eat_effect( "/std/effects/ingested/poison", 10 );
    glue->move( this_object() );
    return glue;
}

==================================================
FILE: misc/watch.c
==================================================

inherit "/obj/clock";
int our_offset,
    their_offset,
    last_time,
    cur_alarm,
    offset_alarm,
    alarm;
mixed *alarms;
string *alarm_write,
       alarm_name;
object our_player;
varargs int get_text(string line);
void setup() {
  set_name("watch");
  add_adjective("demonic");
  add_alias("watch");
  set_main_plural("demonic watches");
  set_short("demonic watch");
  set_long("A small wrist attackable living quaters for a demon "+
           "the demon looks pretty harried about giveing out the "+
           "time all the time, and the pay is lousy..\n");
  set_value(20000);
  our_offset = 0;
  their_offset = 8;
  last_time = time();
  call_out("check_alarm",60);
  alarms = ({ });
}
void init() {
  add_command("time", "");
  add_command("gmt", "<word'offset'>", (:this_object()->set_gmt($4[0]):));
  add_command("use", "<direct:object>", (:this_object()->use():));
  this_player()->add_command("read", this_object());
}
int use(string arg) {
  if (!alarms)
    alarms = ({ });
  printf("%-=80s","You look into the watch and fiddle with several buttons, "+
                  "Finally a light lights up in the top corner say you have "+
                  "the security clearance to modify the settings.\n"+
                  "You can \"set\" an alarm \"remove\" an alarm \"list\" the "+
                  "set alarms. You can \"quit\" also.\n");
  write("What do you wish to do ? ");
  input_to("the_command");
  return 1;
}
int the_command(string arg) {
  string s1;
  int i;
  if (arg == "quit") {
    write("Thank you for using this wonderful watch.\n");
    return 1;
  }
  if (sscanf(arg,"set%s",s1)) {
    int hour, min;
    string name;
    if (sscanf(s1," %s %d:%d%s",name,hour,min,s1)!=4)
      write("Usage: set <name> <hour>:<min> [+]\n");
    else {
      if ((i=member_array(name,alarms))<0)
        alarms += ({ name, hour, min, 0 });
      else
        if (i%4)
          write("Oooooopps, you cannot use that name as an alarm\n");
        else {
          alarms[i+1] = hour;
          alarms[i+2] = min;
        }
      if (s1 == " +") {
        if (i==-1)
          i = sizeof(alarms)-4;
        cur_alarm = i;
        get_text();
        return 1;
      }
    }
  }
  if (sscanf(arg,"remove%s",s1)) {
    string frog;
    if (sscanf(s1," %s",frog)!=1)
      write("Usage: remove <name>\n");
    else
      if ((i=member_array(frog,alarms))<0)
        write("You must remove an existing alarm\n");
      else
        if (i%4)
          write("Ohhh dear.\n");
        else {
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
        }
  }
  if (sscanf(arg,"list%s",s1)) {
    string chicken;
    if (sscanf(s1," %s",chicken)!=1) {
      for (i=0;i<sizeof(alarms);i+=4) {
        write("Alarm "+alarms[i]+" is set for "+alarms[i+1]+":"+alarms[i+2]+"\n");
      }
    } else {
      if ((i=member_array(chicken,alarms))<0)
        write("That alarm does not exist.\n");
      else
        if (i%4)
          write("Bing basicly");
        else
          write("You have set alarm "+chicken+" to go off at "+alarms[i+1]+":"+
                 alarms[i+2]+"\n");
    }
  }
  return 1;
}
varargs int get_text(string line) {
   string text;
  if (!line) {
    text = "";
    write(sprintf("%-=80s","Please enter the text you wish to be displayed "+
          "when the alarm goes off (. to finish)"));
  } else if (line==".") {
    alarms[cur_alarm+3] = text+"\n";
    write("What do you wish to do ? ");
    input_to("the_command");
    return 1;
  } else
    text += line+"\n";
  write("] ");
  input_to("get_text");
  return 1;
}
mixed query_auto_load() {
  mixed ret;
  if (!alarms)
    alarms = ({ });
  ret = ({ their_offset, alarms });
  return ret;
}
void init_arg(mixed *arg) {
  their_offset = arg[0];
  alarms = arg[1];
  if (!alarms)
    alarms = ({ });
}
void check_alarm() {
   int the_time, offset, i;
   int tmp;
   the_time = time();
   offset = (the_time/(3600*24))*3600*24 - our_offset*3600;
   for (i=0;i<sizeof(alarms);i+=4) {
      tmp = offset + (alarms[i+1]-our_offset+their_offset)*3600 + alarms[i+2]*60;
      if (the_time>tmp && tmp>last_time) {
         alarm = 6;
         alarm_name = alarms[i];
         if (alarms[i+3])
         alarm_write = explode(alarms[i+3],"\n");
      else
         alarm_write = ({
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
         });
         offset_alarm = 0;
         set_heart_beat(1);
      }
   }
   last_time = the_time;
   call_out("check_alarm",60);
}
void heart_beat() {
   if (our_player)
     our_player->event_say(this_object(), "The watch goes: "+
                           alarm_write[offset_alarm++]+"\n");
   if (offset_alarm>sizeof(alarm_write))
     set_heart_beat(0);
}
int move(object ob) {
  int i;
  i = ::move(ob);
  our_player = environment();
  return i;
}

==================================================
FILE: misc/wearable_corpse.c
==================================================

inherit "/obj/corpse";
inherit "/std/basic/wearable";
void create() {
  corpse::create();
  wearable::create();
}
string long( string word, int dark ) {
  return corpse::long( word, dark ) + wearable::long( word, dark );
}
void init_static_arg( mapping map ) {
   if ( map[ "corpse" ] )
      corpse::init_static_arg( map[ "corpse" ] );
   if ( map[ "wearable" ] )
      corpse::init_static_arg( map[ "wearable" ] );
}
void init_dynamic_arg( mapping map ) {
 if ( !undefinedp( map[ "corpse" ] ) )
      corpse::init_dynamic_arg( map[ "corpse" ] );
 if ( !undefinedp( map[ "wearable" ] ) )
      wearable::init_dynamic_arg( map[ "wearable" ] );
}
mapping query_static_auto_load() {
   return ([
      "corpse" : corpse::query_static_auto_load(),
      "wearable" : wearable::query_static_auto_load(),
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "corpse" : corpse::query_dynamic_auto_load(),
      "wearable" : wearable::query_dynamic_auto_load()
   ]);
}
mixed *stats() {
	return corpse::stats() + wearable::stats();
}

==================================================
FILE: misc/wearable_pet.c
==================================================

#include <gossip.h>
#include <armoury.h>
#define CHAT_FREQ 200
inherit "/obj/monster";
inherit "/std/basic/wearable";
varargs int wear_remove_function(object);
void expand_mon_string( mixed str ) {
    object room;
    string *args, *stuff;
    if ( functionp( str ) ) {
        evaluate( str, this_object() );
    }
    if(strsrch(str, "$name$") > 0) {
        stuff = GOSSIP_HANDLER->query_random_gossip();
        str = replace(str, ({ "$name$", stuff[0],
            "$mess$", stuff[1] }));
    }
    str = expand_string(str, 0);
    switch( str[0] ) {
    case '#':
        args = explode(str[ 1..], ":");
        switch (sizeof(args)) {
        case 1 :
            call_other( this_object(), args[0] );
            return;
        case 2 :
            call_other( this_object(), args[0], args[1] );
            return;
        case 3 :
            call_other( this_object(), args[0], args[1], args[2] );
            return;
        case 4 :
            call_other( this_object(), args[0], args[1], args[2],
              args[3] );
            return;
        default :
            call_other( this_object(), args[0], args[1], args[2],
              args[3], args[4] );
            return;
        }
    case ':' :
        str = str[1..];
        break;
    case '\'' :
        str = "says " + str;
        break;
    case '"' :
        str = "says loudly " + str;
        break;
    }
    if(living(environment())) {
        room = environment(environment());
        str = capitalize(environment()->poss_short()) +" "
        + this_object()->query_short()  + " " + str;
        tell_room( room,  str +"\n" );
    } else {
        room = environment();
        str = "The " + this_object()->query_short() + " " + str;
        tell_room( room, expand_string( str, 0 ) +"\n" );
    }
}
int check_anyone_here() {
object holder, *people;
    if(!(::check_anyone_here()))
        if ( living(holder = environment(this_object())) ) {
            if(environment(holder) &&
                    sizeof(people = all_inventory(environment(holder))))
            if(sizeof(filter(people, (: userp($1) :))))
                return 1;
            else
                return 0;
    }
    return ::check_anyone_here();
}
varargs int wear_remove_function(object pet, object thing) {
    object *wearing;
    object worn;
    if(pet && thing) {
        wearing = this_player()->query_wearing();
        foreach(worn in wearing) {
            if( (worn != previous_object())
                && inherits("/obj/misc/wearable_pet", worn)) {
                previous_object()->init_command(sprintf("kill %O",worn));
            }
        }
    }
}
void create() {
    wearable::create();
    monster::create();
}
string long(string str, int dark) {
    return monster::long(str, dark);
}
void init_dynamic_arg(mapping map) {
    wearable::init_dynamic_arg(map);
    monster::init_dynamic_arg(map);
}
mapping query_dynamic_auto_load() {
    return
    wearable::query_dynamic_auto_load() +
    monster::query_dynamic_auto_load();
}
void init_static_arg(mapping map) {
    wearable::init_static_arg(map);
    monster::init_static_arg(map);
}
mixed query_static_auto_load() {
    wearable::query_static_auto_load() +
    monster::query_static_auto_load();
}
int query_value() {
    return query_base_value();
}
mixed stats() {
    return wearable::stats() + monster::stats();
}
void break_me() {
    do_death();
}
string cond_string() {
   health_string();
}
int adjust_cond( int i ) {
    adjust_hp( i );
}
varargs int adjust_hp( int number, object attacker, object weapon,
    string attack ) {
    if(::adjust_cond( number ))
      return ::adjust_hp( number, attacker, weapon, attack);
}
int set_max_hp( int number ) {
    set_max_cond(number);
    set_cond(number);
    set_damage_chance( 15 );
    set_lowest_cond(1);
    return ::set_max_hp(number);
}

==================================================
FILE: misc/wedding_ring.c
==================================================

inherit "obj/armour";
string owner, giver;
void setup() {
   set_name( "ring" );
   set_short( "wedding ring" );
   add_adjective( "wedding" );
   set_long( "This is a wedding ring crafted from the purest gold from the "+
      "mines of Rimward Klatch.\n" );
   set_main_plural( "wedding rings" );
   set_type( "ring" );
   add_property( "shop type", "jewellers" );
   add_property( "no recycling", 1 );
   set_weight( 1 );
   setup_armour( 1000 );
   set_percentage( 100 );
   set_damage_chance( 0 );
   owner = giver = "nobody";
   set_wear_remove_func( file_name( this_object() ), "wear_remove" );
}
void do_inscription() {
   string language;
   object player;
   player = find_player( giver );
   if( !player ) {
      player = find_player( owner );
   }
   language = player->query_default_language();
   set_read_mess( "\"For you, "+ capitalize( owner ) +
         ", with eternal love, "+ capitalize( giver ) +".\"", language );
}
string query_owner() { return owner; }
void set_owner( string word ) {
  owner = lower_case( word );
  do_inscription();
}
string query_giver() { return giver; }
void set_giver( string word ) {
  giver = lower_case( word );
  do_inscription();
}
void wear_remove( int wear ) {
   if( environment() != this_player() )
      return;
   if ( living( environment() )  &&  wear ) {
      if ( (string)this_player()->query_name() != owner )
         write( "The ring feels uncomfortable on your finger.\n" );
      else
         write( "You are warmed anew by "+ capitalize( giver ) +"'s love.\n" );
   }
}
mixed *stats() {
   return ::stats() + ({
      ({ "owner", owner }),
      ({ "giver", giver }),
   });
}
void init_dynamic_arg( mapping args ) {
   if ( args[ "::" ] )
      ::init_dynamic_arg( args[ "::" ] );
   if ( args[ "owner" ] )
      owner = lower_case( args[ "owner" ] );
   if ( args[ "giver" ] )
      giver = lower_case( args[ "giver" ] );
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "owner" : owner,
      "giver" : giver
   ]);
}

==================================================
FILE: misc/oddsnends/beeswax_candle.c
==================================================

inherit "/std/lightable";
void setup() {
   set_name( "candle" );
   set_short( "beeswax candle" );
   add_adjective( "beeswax" );
   set_long( "This is a small candle, like you'd "
         "see on a birthday cake.  It is quite soft and "
         "squidgy.\n" );
   set_fuel_messages( ({
         "It is almost burnt to a stub.", 10,
         "It is more than halfway burnt.", 50,
         "It is not yet halfway burnt.", 85,
	 "It is almost new.", 99,
         "It is new.", 100
         }) );
   set_empty_mess( "is burnt to a stub." );
   set_max_fuel( 900 );
   set_fuel( 900 );
   set_brightness( 60 );
   set_value( 24 );
   set_hold_required( 1 );
   add_property( "no recycling", 1 );
   new_weapon( 10 );
   set_weight( 1 );
   set_hide_cond( 1 );
}

==================================================
FILE: misc/oddsnends/book_end.c
==================================================

inherit "/std/object";
void setup(){
    set_name("end");
    set_short("book end");
    set_main_plural("book ends");
    set_long("A glittering book end wrought in iron.  Just the thing"
	     " for Auntie's Hogswatchday present.\n" );
    set_value(35);
    set_weight(40);
}

==================================================
FILE: misc/oddsnends/bottleopener.c
==================================================

inherit "/std/object";
void setup(){
    set_name("opener");
    set_short("bottle opener");
    add_adjective("bottle");
    set_main_plural("bottle openers");
    set_long("This is a multipurpose bottle opener that "
             "works for left- and right-handed people.\n");
    set_value(15);
    set_weight(5);
}

==================================================
FILE: misc/oddsnends/buffing_cloth.c
==================================================

inherit "/std/object";
void setup(){
    set_name("cloth");
    set_short("buffing cloth");
    set_main_plural("buffing cloths");
    add_adjective( "buffing" );
    set_long("This is a small, soft cloth that might be used for polishing"
	     " metal objects.\n" );
    set_value(32);
    set_weight(2);
}

==================================================
FILE: misc/oddsnends/glass.c
==================================================

#include <volumes.h>
inherit "/obj/vessel";
void setup(){
    set_name("glass");
    set_short("glass");
    set_long("This is a limited edition authentic "
             "scumble measure glass, as produced by the "
             "ancient scumble brewers.  It is very exclusive.\n");
    set_max_volume(VOLUME_HALFPINT);
    set_max_weight(10);
    set_leak_rate(0);
    set_value(30);
    set_weight(5);
    set_stuck(1);
}

==================================================
FILE: misc/oddsnends/hair_brush.c
==================================================

inherit "/std/object";
void setup(){
    set_name("brush");
    set_short("stiff hair brush");
    add_adjective("hair");
    add_adjective("stiff");
    set_long("This is a small brush with rather stiff tines "
             "sticking out from it.  It looks like just the thing to "
             "straighten out your hair after a sandstorm.\n");
    set_value(10);
    set_weight(20);
}

==================================================
FILE: misc/oddsnends/nail.c
==================================================

inherit "/std/object";
void setup(){
    set_name("nail");
    set_short("nail");
    set_main_plural("nails");
    set_long("A typical nail for nailing bits of wood together."
	     "  Quite exciting really.\n" );
    set_value(4);
    set_weight(1);
}

==================================================
FILE: misc/oddsnends/paint_brush.c
==================================================

inherit "/std/object";
void setup(){
    set_name("brush");
    set_short("camel hair brush");
    add_adjective("hair");
    add_adjective("camel");
    add_adjective("paint");
    set_long("This is a small paint brush with fine camel hairs sticking "
             "out.  It looks to be better suited to the finer arts than for"
             " painting wagons with.\n");
    set_value(15);
    set_weight(15);
}

==================================================
FILE: misc/oddsnends/picframe.c
==================================================

inherit "/obj/container";
void setup(){
    set_name("frame");
    set_short("picture frame");
    add_adjective("picture");
    set_long("A lovely gold painted picture frame.\n");
    set_value(20);
    set_weight(30);
    set_max_weight(1);
    set_open();
    set_stuck(1);
}

==================================================
FILE: misc/oddsnends/safety_clip.c
==================================================

inherit "/std/object";
void setup(){
    set_name("clip");
    set_short("safety clip");
    add_adjective("safety");
    set_long("This is a high technology item.  "
             "It is designed to be used as a buckle, and "
             "will safeguard you from much harm if used "
             "properly.\n");
    set_value(25);
    set_weight(2);
}

==================================================
FILE: misc/oddsnends/shoehorn.c
==================================================

inherit "/std/object";
void setup(){
    set_name("horn");
    set_short("shoe horn");
    add_adjective("shoe");
    set_long("A normal shoe horn.\n");
    set_value(10);
    set_weight(5);
}

==================================================
FILE: misc/oddsnends/shoelace.c
==================================================

inherit "/std/object";
void setup(){
    set_name("lace");
    set_short("shoe lace");
    add_adjective("shoe");
    add_alias("shoelace");
    set_main_plural("shoe laces");
    add_plural("shoelaces");
    set_long("A bright yellow coloured shoelace, "
             "just the kind of thing a teenage kid would wear.\n");
    set_value(15);
    set_weight(2);
}

==================================================
FILE: misc/oddsnends/small_keyring.c
==================================================

inherit "/obj/misc/keyring";
void setup(){
    set_name("keyring");
    set_short("small keyring");
    set_main_plural("small keyrings");
    add_adjective( "small" );
    set_long("This is a small keyring, suitable for holding a few "
     "small keys.\n" );
    set_weight(1);
    set_max_weight( 10 );
    set_value( 200 );
}

==================================================
FILE: misc/oddsnends/wedge.c
==================================================

inherit "/std/object";
void setup(){
    set_name("wedge");
    set_short("door wedge");
    add_adjective("door");
    set_main_plural("door wedges");
    set_long("A common wooden door wedge.  "
             "You use them to hold a door open.\n");
    set_value(10);
    set_weight(10);
}

==================================================
FILE: misc/shops/item_shop_safe.c
==================================================

inherit "/obj/baggage";
void set_max_float( int );
int query_max_float();
void setup() {
  set_name( "safe" );
  set_short( "cash safe" );
  set_long( "This safe is used to keep the shop's float in.  It's securely set "
    "in the wall.\n" );
  add_adjective( "float" );
  add_property( "there", "in the wall" );
  set_difficulty( 10 );
  reset_get();
  set_closed();
  set_locked();
  set_key( "non-existent key" );
  add_property( "no recycling", 1 );
  set_pick_skill( "covert.lockpick.safes" );
  set_weight( 2000 );
  set_max_weight( 5000 );
  set_value( 120000 );
}
int pick_unlock( object player ){
  this_object()->set_unlocked();
    return 1;
}
int query_accept_money() {
  return 1;
}

==================================================
FILE: misc/locks/basic_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("basic door lock");
   add_adjective( ({ "basic", "door" }));
   set_long("A basic brass door lock.\n");
   add_property("difficulty", 2);
   set_weight(19);
   set_value(20000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/basic_furniture_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("basic furniture lock");
   add_adjective( ({ "basic", "furniture" }));
   set_long("A basic brass furniture lock.\n");
   add_property("difficulty", 1);
   set_weight(19);
   set_value(10000);
}
void set_key_number(int num) {
   add_property("key prop", "furniture_lock_"+num);
   add_property("locktype", "furniture");
}

==================================================
FILE: misc/locks/brass_door_key.c
==================================================

inherit "/std/key";
void set_key_number(int num) {
   set_key("small brass", "door_lock_" + num);
   set_long("A small brass key.  It has a serial number " +
            num + " engraved on it.\n");
   set_value(10);
}
mapping query_static_auto_load() {
   return int_query_static_auto_load();
}
int query_duplicatable_key() {
   return 1;
}

==================================================
FILE: misc/locks/chubby_special_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("chubby special door lock");
   add_adjective( ({ "chubby", "special", "door" }));
   set_long("A chubby special brass door lock.  These high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 8);
   set_weight(19);
   set_value(160000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/chubby_standard_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("chubby standard door lock");
   add_adjective( ({ "chubby", "standard", "door" }));
   set_long("A chubby standard brass door lock.  These "
                     "high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 6);
   set_weight(19);
   set_value(80000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/chubby_ultra_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("chubby ultra door lock");
   add_adjective( ({ "ultra", "chubby", "door" }));
   set_long("A chubby ultra brass door lock.  These high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 10);
   set_weight(19);
   set_value(300000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/flimsy_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("flimsy door lock");
   add_adjective( ({ "flimsy", "door" }));
   set_long("A flimsy brass door lock.\n");
   add_property("difficulty", 1);
   set_weight(19);
   set_value(10000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/furniture_key.c
==================================================

inherit "/std/key";
void set_lock_number(int num) {
   set_key("small furniture", "furniture_lock_" + num);
   set_long("A small key, it looks like it would be "
            "suitable for a piece of furniture.\n");
   set_value(10);
}
void set_key_number( int num ){
  set_lock_number(num);
}
mapping query_static_auto_load() {
   return int_query_static_auto_load();
}
int query_duplicatable_key() {
   return 1;
}

==================================================
FILE: misc/locks/standard_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("standard door lock");
   add_adjective( ({ "standard", "door" }));
   set_long("A standard brass door lock.\n");
   add_property("difficulty", 4);
   set_weight(19);
   set_value(40000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}
