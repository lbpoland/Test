# Total Tokens: 19803
# Total Files Merged: 7
# Total Characters: 66023

ate_change.c
==================================================

#include <state_change.h>
#define PROP "state name"
#define DATA_DIR "/obj/state_change/"
mapping table = ([ ]);
void set_amount_of_ob( object ob, int amount );
mixed query_table() { return table; }
void create() {
    string *files;
    int i;
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    files = ({ "base.hdr" });
    files += get_dir(DATA_DIR + "*.dat");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = DATA_DIR + files[i];
    }
    table += "/obj/handlers/data"->compile_data(files);
}
varargs object transform( object ob, string transformation, object player ) {
    string index, name;
    object ret;
    class state_change c;
    function f;
    int *weight_unit;
    if (!stringp(name = ob->query_property(PROP)))
      if (!stringp(name = ob->query_medium_alias()))
        name = ob->short();
    if ( !player )
      player = this_player();
    index = transformation + ":" + name;
    if (undefinedp(table[index]))
      return 0;
    c = table[index];
    ret = clone_object(c->result);
    foreach (f in c->func)
      evaluate(f, ob, ret, player);
    if (ret->query_continuous()) {
        if ( ob->query_continuous() || ob->query_collective() ) {
            ret->set_amount(to_int(ob->query_amount() * c->factor));
        } else {
            weight_unit = ret->query_weight_unit();
            set_amount_of_ob( ret, to_int( ob->query_weight() * c->factor *
              weight_unit[1] / weight_unit[0] ) );
        }
    } else {
        if ( ob->query_continuous() || ob->query_collective() ) {
            weight_unit = ob->query_weight_unit();
            ret->set_weight(to_int(ob->query_amount() * c->factor *
                                   weight_unit[0] / weight_unit[1]));
        } else {
            ret->set_weight(to_int(ob->query_weight() * c->factor));
        }
    }
    log_file( "STATE_CHANGE", "Changed %d amount of %s to %d amount of %s via %s.\n",
      ob->query_amount(), ob->query_medium_alias(), ret->query_amount(),
      ret->query_medium_alias(), transformation );
    return ret;
}
void set_amount_of_ob( object ob, int amount ) {
  if ( !ob )
      return;
  if ( !amount )
      ob->dest_me();
  ob->set_amount( amount );
  return;
}

==================================================
FILE: handlers/taskmaster.c
==================================================

#include <tasks.h>
#define TIME_PER_USER 1800
#define SAVE_FILES "/save/tasks/"
#define LOG_STATS 2
#undef LOGGING
mapping stats;
nosave int last_save;
nosave int last;
nosave string skill;
nosave mixed *control;
nosave int * critical_chances;
varargs mixed perform_task( object person, string skill, int difficulty,
                         int tm_type, int degree );
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree );
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree );
int is_critical( int margin );
void create() {
   float a, b;
   seteuid( "Root" );
   critical_chances = allocate(100);
   a = 0.93260;
   b = 0.06978;
   for( int i = 0; i < 100; i++ ) {
      critical_chances[i] = a * exp( b * ( i + 1 ) );
   }
}
mapping query_stats( string s_name ) {
  if ( skill != s_name ) {
    skill = s_name;
    if ( file_size( SAVE_FILES + skill +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILES + skill :) );
    else
      stats = 0;
  }
  if ( !stats )
    stats = ([ ]);
  return copy( stats );
}
int query_last() { return last; }
mixed *query_control() { return control; }
void set_control( mixed *args ) { control = args; }
void reset_control() { control = 0; }
void award_made( string p_name, string o_name, string s_name, int level ) {
  user_event( "inform", p_name +" gains a level in "+ s_name +" from "+
              o_name + " at level " + level, "skill" );
#ifdef LOG_STATS
#if LOG_STATS == 1
  query_stats( s_name );
  if ( !stats[ level ] )
    stats[ level ] = ([ ]);
  stats[ level ][ explode( o_name, "#" )[ 0 ] ]++;
#else
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({ 0 , 0 }),  ({ 0, 0 }),  ({ 0, 0 }) , ({0,0})});
  switch(level) {
  case 0..149:
    stats[s_name][0] = ({ stats[s_name][0][0], stats[s_name][0][1]+1 });
    break;
  case 150..299:
    stats[s_name][1] = ({ stats[s_name][1][0], stats[s_name][1][1]+1 });
    break;
  case 300..599:
    stats[s_name][2] = ({ stats[s_name][2][0], stats[s_name][2][1]+1 });
    break;
  default:
    stats[s_name][3] = ({ stats[s_name][3][0], stats[s_name][3][1]+1 });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
#endif
#endif
}
#if LOG_STATS == 2
void skill_checked(string s_name, int level) {
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({0,0}), ({0,0}), ({0,0}), ({0,0}), ({0,0}) });
  switch(level) {
  case 0..49:
    stats[s_name][0] = ({ stats[s_name][0][0]+1, stats[s_name][0][1] });
    break;
  case 50..149:
    stats[s_name][1] = ({ stats[s_name][1][0]+1, stats[s_name][1][1] });
    break;
  case 150..299:
    stats[s_name][2] = ({ stats[s_name][2][0]+1, stats[s_name][2][1] });
    break;
  case 300..599:
    stats[s_name][3] = ({ stats[s_name][3][0]+1, stats[s_name][3][1] });
    break;
  default:
    stats[s_name][4] = ({ stats[s_name][4][0]+1, stats[s_name][4][1] });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
}
#endif
string *query_skill_files() {
  return unguarded( (: get_dir, SAVE_FILES +"*.o" :) );
}
void clear_skill_files() {
  string word;
  foreach ( word in unguarded( (: get_dir, SAVE_FILES +"*.o" :) ) )
    unguarded( (: rm, SAVE_FILES + word :) );
  skill = 0;
}
varargs mixed compare_skills( object offob, string offskill,
                              object defob, string defskill,
                              int modifier, int off_tm_type,
                              int def_tm_type, int degree )
{
  int offbonus, defbonus;
  int perc, chance;
  int success_margin, res, deg;
  if( !offob || !defob || !offskill || !defskill )
    return BARF;
  offbonus = offob->query_skill_bonus(offskill);
  defbonus = defob->query_skill_bonus(defskill);
  if( !defbonus ) {
    defbonus = 1;
  }
  if( !offbonus ) {
    offbonus = 1;
  }
  (offbonus > defbonus) ?
    perc = (50 * offbonus * offbonus) / (offbonus * defbonus) :
    perc = 100 - (50 * defbonus * defbonus) / (offbonus * defbonus);
  perc += modifier;
  if(perc > 99)
    perc = 99;
  if(perc < 1)
    perc = 1;
  chance = random(100);
  success_margin = perc - chance;
  if( success_margin > 0 ) {
    switch( perform_task( offob, offskill, defbonus-modifier,
                          off_tm_type, 0 ) )
    {
    case AWARD:
      res = OFFAWARD;
      break;
    default:
      res = OFFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  } else {
    switch( perform_task( defob, defskill, offbonus-modifier,
                          def_tm_type, 0 ) ) {
    case AWARD:
      res = DEFAWARD;
      break;
    default:
      res = DEFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( -success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( -success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  }
}
varargs mixed perform_task( object person, string skill, int difficulty,
                            int tm_type, int degree ) {
  mixed result;
  int bonus, upper;
  if( !person || !skill )
    return BARF;
  bonus = person->query_skill_bonus( skill );
  switch(tm_type) {
  case TM_FIXED:
    result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_FREE:
    result = attempt_task( difficulty, bonus, 25, 0, degree );
    break;
  case TM_CONTINUOUS:
    result = attempt_task( difficulty, bonus, 50, 0, degree );
    break;
  case TM_COMMAND:
    if( explode( skill, "." )[0] == "covert" )
      result = attempt_task_e
  ( difficulty, bonus, 60, 40, degree );
    else
      result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_RITUAL:
    result = attempt_task_e( difficulty, bonus, 50, 25, degree );
    break;
  case TM_SPELL:
    result = attempt_task_e( difficulty, bonus, 60, 40, degree );
    break;
  case TM_NONE:
    result = attempt_task_e(difficulty, bonus, 1, 0, degree);
    if(classp(result) && ( (class tasker_result)result )->result == AWARD) {
      result->result = SUCCEED;
    } else if( result == AWARD ) {
      result = SUCCEED;
    }
    break;
  default:
#ifdef LOGGING
    if(file_name(previous_object())[0..2] != "/w/")
      log_file("ATTEMPT_TASK",
               "%s Object %s using old perform_task [%d, %d]\n",
               ctime(time()), base_name(previous_object()), tm_type, degree );
#endif
    upper = tm_type;
    if ( !upper )
      upper = 100;
    result = attempt_task( difficulty, bonus, upper, 0, degree );
  }
  if(classp(result) && ( (class tasker_result)result )->result == AWARD ||
     result == AWARD) {
    if(person->advancement_restriction() ||
       !person->add_skill_level(skill, 1, previous_object())) {
      if(classp(result))
        result->result = SUCCEED;
      else
        result = SUCCEED;
    }
  }
  return result;
}
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree )
{
   int margin, success_margin, deg, res;
   float tmp;
#ifdef LOGGING
   if( call_stack(2)[1] != "perform_task" &&
       base_name( previous_object() ) != "/std/effects/fighting/combat" &&
       file_name( previous_object() )[0..2] != "/w/" )
   {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime( time() ), base_name( previous_object() ), call_stack(2) );
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
      skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
#ifdef DEBUG
      if(pointerp(control) && control[0]->query_name() == WATCH_PLAYER &&
         find_player(DEBUG))
      {
         tell_creator( DEBUG, "%^RED%^"
           + sprintf( "TM: %s Skill: %s [%d] [%d] Failed\n",
                      control[0]->query_name(), control[1], bonus, difficulty )
           + "%^RESET%^" );
      }
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if ( !extra )
      margin = 3 * sqrt( difficulty );
   else {
      if ( intp( extra ) )
         margin = extra;
      if ( pointerp( extra ) )
         margin = extra[ 0 ] + extra[ 1 ] * sqrt( difficulty );
   }
   if ( !margin )
      return BARF;
   if ( bonus > difficulty + margin ) {
#ifdef DEBUG
     if(pointerp(control) &&
        WATCH_PLAYER || control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] [%d] Succeeded\n", control[0]->query_name(), control[1], bonus, difficulty, margin) + "%^RESET%^");
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : SUCCEED,
                     degree : ( is_critical(100) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : 100 );
      } else {
         return SUCCEED;
      }
   }
   if(!margin)
     margin = 1;
   success_margin = ( ( 100 * ( bonus - difficulty ) ) / margin ) - random(100);
   if ( success_margin <= 0 ) {
#ifdef DEBUG
     if(pointerp(control) &&
        control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] Failed (2)\n", control[0]->query_name(), control[1], bonus, difficulty) + "%^RESET%^");
#endif
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify(upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
#ifdef DEBUG
   else
     if(find_player(DEBUG))
       tell_object(find_player(DEBUG), sprintf("No control: %O\n",
                                                 previous_object(-1)));
#endif
     if(!margin)
        margin = 1;
   if( random(100) < ( upper * ( difficulty + margin - bonus ) ) / margin )
      res = AWARD;
   else
      res = SUCCEED;
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree )
{
   float fail_chance;
   float tmp;
   int success_margin, deg, res;
#ifdef LOGGING
   if(call_stack(2)[1] != "perform_task" &&
      base_name(previous_object()) != "/std/effects/fighting/combat" &&
      file_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime(time()), base_name(previous_object()), call_stack(2));
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
     skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if( !half )
      half = 6 * sqrt( difficulty );
   if( !half )
      half = 1;
   fail_chance = exp( ( -0.693 * ( bonus - difficulty ) ) / half );
   success_margin = ( random( 1000 ) - ( 1000 * fail_chance ) ) / 10;
   if ( success_margin < 0 ) {
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify( upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - E_MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
   if ( random(1000) < ( upper * fail_chance * 10 )
    &&  bonus < difficulty + ( half * 5 ) ) {
      res = AWARD;
   } else {
      res = SUCCEED;
   }
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
int is_critical( int margin ) {
   if ( margin < 0 ) {
      margin *= -1;
   }
   if ( margin > 100 ) {
      margin = 100;
   }
   if ( margin == 0 ) {
      return 0;
   }
   return random(10000) < critical_chances[ margin - 1 ];
}

==================================================
FILE: handlers/team.c
==================================================

#define CREATOR "Ceres"
#include <login_handler.h>
#define SHADOW "/std/shadows/misc/team"
#define MAX_GROUP_SIZE 5
class group {
  object leader;
  int policy;
  object *members;
  int locked;
}
mapping groups,
        members;
private void check_group(string g_name);
private void disband_group(string g_name, string p_name);
private void tidy_members(string g_name);
void create() {
  members = ([ ]);
  groups = ([ ]);
}
void dest_me() {
  destruct(this_object());
}
void leaving(string p_name, string type) {
  class group record;
  string g_name;
  if((type != "logout") || (!members[p_name]))
    return;
  g_name = members[p_name];
  record = (class group)groups[g_name];
  map_delete(members, p_name);
  if(!record)
    return;
  if((record->leader == 0) || ((record->leader)->query_name() == p_name)) {
     disband_group(g_name, p_name);
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s has left the game, the %s has been "
                             "disbanded.\n", ctime(time()), p_name, g_name));
#endif
  } else {
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left the game while a member of the %s\n",
                             ctime(time()), p_name, g_name));
#endif
    record->members = delete(record->members,
                             member_array(0, record->members), 1);
  }
  return;
}
int new_group(string g_name, object leader, int policy) {
  class group record;
  if(!undefinedp(groups[g_name]))
    return 0;
  record = new(class group);
  record->leader = leader;
  record->policy = policy;
  record->members = ({ leader });
  groups[g_name] = record;
  members[leader->query_name()] = g_name;
  leader->set_title( "TEAM", "Team Leader of "+ g_name );
   clone_object( SHADOW )->setup_shadow( leader );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s created by %s\n", ctime(time()),
                           g_name, leader->query_name()));
#endif
  return 1;
}
int end_group(string g_name) {
  class group record;
  object player;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
   foreach( player in record->members )
      if ( player ) {
         map_delete( members, player->query_name() );
         player->remove_title( "TEAM" );
         player->destruct_team_shadow();
      }
  map_delete(groups, g_name);
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s disbanded\n", ctime(time()), g_name));
#endif
  return 1;
}
int join_group(string g_name, object player) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  record->members += ({ player });
  members[player->query_name()] = g_name;
   player->set_title( "TEAM", "Team Member of "+ g_name );
   clone_object( SHADOW )->setup_shadow( player );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s joined by %s\n", ctime(time()),
                           g_name, player->query_name()));
#endif
  return 1;
}
int leave_group(string g_name, object player) {
  class group record;
  if(player) {
    map_delete(members, player->query_name());
      player->remove_title( "TEAM" );
      player->destruct_team_shadow();
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left by %s\n", ctime(time()), g_name,
                             player->query_name()));
#endif
  }
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  if(member_array(player, record->members) == -1)
    return -1;
  record->members = delete(record->members,
                           member_array(player, record->members), 1);
  return 1;
}
object query_owner(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return record->leader;
}
object *query_members(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = groups[g_name];
  return (object *)record->members;
}
int query_policy(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  return (int)record->policy;
}
string query_group(object player) {
  if(undefinedp(members[player->query_name()]))
    return 0;
  return members[player->query_name()];
}
int test_group(string g_name) {
  if(undefinedp(groups[g_name]))
    return 0;
  return 1;
}
int query_full(string g_name) {
  class group record;
  object member;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = (class group)groups[g_name];
  if(sizeof(record->members) >= MAX_GROUP_SIZE)
    return 1;
  return 0;
}
int query_locked(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return (record->locked);
}
int set_locked(string g_name, int lock) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  record->locked = lock;
  return 1;
}
string *list_groups() {
  string frog;
  foreach (frog in keys(groups)) {
    check_group(frog);
  }
  return keys(groups);
}
private void disband_group(string g_name, string p_name) {
  class group record;
  object person;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members) {
    if(!member)
      break;
    map_delete(members, member->query_name());
    foreach(person in member->query_protectors())
      member->remove_protector(person);
    foreach(person in member->query_followers())
      member->remove_follower(person);
    tell_object(member, p_name+" has left the game and so the "+g_name+
                " has been disbanded.\n");
  }
  map_delete(groups, g_name);
}
private void check_group(string g_name) {
  class group record;
  record = (class group)groups[g_name];
  if (record->leader == 0) {
    disband_group(g_name, "Your leader");
  } else {
    record->members -= ({ 0 });
  }
}
private void tidy_members(string g_name) {
  class group record;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members)
    if(!member)
      record->members -= ({ 0 });
}

==================================================
FILE: handlers/term.c
==================================================

#define ANSI(p) sprintf("%c["+(p)+"m", 27)
#define ESC(p) sprintf("%c"+(p), 27)
#define CHAR(p) sprintf("%c", (p))
#define TERMINAL_DUMB "dumb"
private nosave mapping aliases, terms;
void create() {
  aliases = ([ "xterm-debian" : "xterm",
               "zmud" : "vt220",
               "amiga" : "vt220",
               "linux" : "vt220",
               "xterm-color" : "xterm",
               "vt102" : "vt100",
               "dec-vt100" : "vt100",
               "vt300" : "vt220",
               "vt100a" : "vt100",
               "vt100-ansi" : "vt100",
               "dec-vt220" : "vt220",
               "vt400" : "vt220",
               "vs100" : "xterm",
               "sun-cmd" : "vt220-nc",
               "unknown" : TERMINAL_DUMB,
               "ibm" : TERMINAL_DUMB,
               "iris-ansi-net" : "vt220",
               "network" : TERMINAL_DUMB,
               "vt320" : "vt220",
               "dtterm" : "vt220",
               "screen" : "vt220",
               "dec-vt320" : "vt220",
               "dec-vt100i" : "vt100",
               "ansii" : "ansi",
               "vt100i" : "vt100",
               "vt200-80" : "vt220",
               "ibm-3279-2-e" : TERMINAL_DUMB,
               "ibm-3279-2" : TERMINAL_DUMB,
               "vt200" : "vt220",
               "dec-vt200" : "vt220",
               "hft" : "vt220",
               "mac" : "vt220-nc",
               "vt340" : "vt220",
               "vt340-am" : "vt220",
               "ibm-3278-2" : TERMINAL_DUMB,
               "ibm-3278-2-e" : TERMINAL_DUMB,
               "kterm" : "xterm",
               "sun" : "vt220-nc",
               "sun1" : "vt220-nc",
               "xterms" : "xterm",
               "vs100s" : "xterm",
               "vt52" : TERMINAL_DUMB,
               "vt420" : "vt220",
               "dec-vt420" : "vt220",
               "aixterm-m" : "aixterm",
               "ibm-3151" : "ibm3151",
               "ibm-3278-5" : TERMINAL_DUMB,
               "du" : TERMINAL_DUMB,
               "dialup" : TERMINAL_DUMB,
               "dec-vt52" : TERMINAL_DUMB,
               "vt100-pro" : "vt100",
            ]);
  terms = ([ TERMINAL_DUMB : ([ "RESET" : "",
                         "BOLD" : "",
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "GREEN" : "",
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": "",
                         "UNDERLINE": "",
                         "%" : "%^",
                         ]),
             "ansi" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "ansi-no-flash" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "freedom" : ([ "RESET" : ESC("G0"),
                         "BOLD" : ESC("G@"),
                         "FLASH" : ESC("G2"),
                         "BLACK" : "",
                         "RED" : "",
                         "GREEN" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "BLACK" : "",
                         "WHITE" : "",
                         "B_RED" : ESC("GD"),
                         "B_GREEN" : ESC("GD"),
                         "B_ORANGE" : ESC("G4"),
                         "B_YELLOW" : ESC("G4"),
                         "B_BLUE" : ESC("G4"),
                         "B_CYAN" : ESC("GD"),
                         "B_BLACK" : ESC("GD"),
                         "B_WHITE" : ESC("G4"),
                         "B_MAGENTA" : ESC("G4"),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("G4"),
                         "UNDERLINE" : ESC("G8"),
                         "%" : "%^",
                         ]),
             "ansi-status": ([
                         "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS" : ESC("[23;24r") + ESC(8),
                         "WINDOW" : ESC(7)+ESC("[0;22r")+ESC("[22H\n"),
                         "INITTERM" : ESC("[H")+ESC("[J")+
                                      ESC("[23;24r")+ESC("23H\n"),
                         "ENDTERM" : ESC("[0r")+ESC("[H")+ESC("[J"),
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "xterm": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100" : (["RESET" : ANSI("39;49")+ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "hpterm" : (["RESET" : ESC("&v0S")+ESC("&d@"),
                         "BOLD" : ESC("&dB"),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ESC("&dB"),
                         "GREEN" : ESC("&dD"),
                         "ORANGE" : "",
                         "YELLOW" : ESC("&dB"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "WHITE" : "",
                         "B_RED" : "",
                         "B_GREEN" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLUE" : "",
                         "B_CYAN" : "",
                         "B_BLACK" : "",
                         "B_WHITE" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("&dB"),
                         "UNDERLINE" : ESC("&dD"),
                         "%" : "%^",
                         ]),
           "aixterm" : ([ "RESET" : ANSI("0;10")+ESC("(B"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ANSI(1),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC('p'),
                         "GREEN" : ESC('W'),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC('p'),
                         "UNDERLINE": ESC('W'),
                         "%" : "%^",
                         ]),
           "ibm3151" : ([ "RESET" : ESC("4@"),
                         "BOLD" : ESC("4H"),
                         "FLASH" : ESC("4D"),
                         "BLACK" : "",
                         "RED" : ESC("4H"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC("4A"),
                         "GREEN" : ESC("4B"),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC("4A"),
                         "UNDERLINE": ESC("4B"),
                         "%" : "%^",
                         ]),
             "vt220": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100-nc" : ([ "RESET" : ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI(37),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt220-nc" : ([ "RESET" : ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI("7;4"),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
          ]);
}
mixed set_network_term_type(string str) {
  string type;
  str = lower_case(str);
  if (!terms[str] && !(type = aliases[str])) {
#ifdef DEBUG
    log_file("TERMTYPES", "No entry for \"%s\" (%s).\n", str,
             this_player()->query_name());
#endif
    return 0;
  }
  if (type) {
     return terms[type];
  }
  return terms[str];
}
mapping set_term_type(string str) {
  if (!terms[str] && !(str = aliases[str])) {
    efun::tell_object(this_player(), "No entry for "+str+", using dumb.\n");
    str = TERMINAL_DUMB;
  }
  return terms[str];
}
string *query_term_types() {
  return m_indices(terms);
}
string *query_colour_codes() {
   return keys(terms[TERMINAL_DUMB]);
}

==================================================
FILE: handlers/terrain_handler.c
==================================================

#include <dirs.h>
#include <terrain.h>
#include <map.h>
#undef DEBUG_ROOM_SIZE
#undef DEBUG_CALC_EXITS
#define TP(x) tell_object(find_player("taffyd"), x);
#define BACKUP_TIME_OUT 1000000
inherit "/std/object";
string terrain_name;
mapping fixed_locations;
mixed *floating_locations;
private nosave int in_map;
private nosave mapping size_cache, cloned_locations, float_cache;
private nosave mapping std_types = ([ "north" : "path", "south" : "path",
  "east" : "path", "west" : "path", "northeast" : "hidden",
  "southwest" : "hidden", "southeast" : "hidden",
  "northwest" : "hidden", "up" : "stair", "down" : "stair" ]);
void setup() {
  size_cache = ([ ]);
  cloned_locations = ([ ]);
  float_cache = ([ ]);
  set_name("map");
  set_short("terrain map");
  add_adjective("terrain");
  set_long("This is a large map showing a large expanse of forest, desert, "
           "mountain or ocean.  A few locations of interest are marked on "
           "it, with most of the gaps between them blank or marked "
           "\"Here bee Draggons\" and the like, suggesting that the map-"
           "maker didn't know what was there either.\n" );
  add_adjective("terrain");
}
string member_cloned_locations(int *co_ords) {
  mapping tmp;
  if ((tmp = cloned_locations[terrain_name]) && (tmp = tmp[co_ords[0]]) &&
      (tmp = tmp[co_ords[1]])) {
      return tmp[co_ords[2]];
  }
  return 0;
}
string member_fixed_locations(int *co_ords) {
  int *loc_co_ords;
  string location;
  foreach (location, loc_co_ords in fixed_locations) {
    if ((co_ords[0] == loc_co_ords[0]) && (co_ords[1] == loc_co_ords[1]) &&
        (co_ords[2] == loc_co_ords[2])) {
      return location;
    }
  }
  return 0;
}
private int between(int limit1, int val, int limit2)
{
  if (limit1 < limit2) {
    return ((limit1 <= val) && (val <= limit2));
  } else {
    return ((limit2 <= val) && (val <= limit1));
  }
}
mixed *member_floating_locations(int *co_ords) {
  int *data;
  mixed *right_locations, *location;
  right_locations = ({ });
  foreach (location in floating_locations) {
    data = location[1];
    if (sizeof(data) == 6) {
      if (between(data[0], co_ords[0], data[3]) &&
          between(data[1], co_ords[1], data[4]) &&
          between(data[2], co_ords[2], data[5])) {
        right_locations += ({ location[0], location[2] });
      }
    } else {
      if ((co_ords[0] == data[0]) && (co_ords[1] == data[1]) &&
          (co_ords[2] == data[2])) {
        right_locations += ({ location[0], location[2] });
      }
    }
  }
  return right_locations;
}
string top_floating_location(int *co_ords) {
  int i, highest_level;
  string highest_location;
  mixed *right_locations;
  right_locations = member_floating_locations(co_ords);
  if (!sizeof(right_locations))
    return 0;
  highest_level = right_locations[1];
  highest_location = right_locations[0];
  for (i = 0; i < sizeof(right_locations); i += 2) {
    if (right_locations[i + 1] > highest_level) {
      highest_level = right_locations[i + 1];
      highest_location = right_locations[i];
    }
  }
  if (highest_location == "nothing")
    return 0;
  return highest_location;
}
private void init_data(string word) {
  terrain_name = word;
  fixed_locations = ([ ]);
  floating_locations = ({ });
}
int get_data_file(string word) {
  if (terrain_name != word) {
    if (file_size(RESTORE_PATH + word + ".o") > 0) {
      unguarded((: restore_object, RESTORE_PATH + word :));
    } else {
      init_data(word);
      return 0;
    }
  }
  return 1;
}
private void save_data_file(string word) {
  int number, last;
  string line, *lines;
  if (file_size(RESTORE_PATH + word +".o") > 0) {
    unguarded((: rename, RESTORE_PATH + word +".o",
               RESTORE_PATH +"backups/"+ word +"."+ time() :));
    lines = unguarded((: get_dir, RESTORE_PATH +"backups/"+ word +".*" :));
    if (sizeof(lines) > 3) {
      last = time() - BACKUP_TIME_OUT;
      foreach(line in lines) {
        sscanf(line, word +".%d", number);
        if (number < last)
          unguarded((: rm, RESTORE_PATH +"backups/"+ line :));
      }
    }
  }
  unguarded((: save_object, RESTORE_PATH + word :));
}
mapping query_cloned_locations(string terrain) {
  return cloned_locations[terrain];
}
mapping query_fixed_locations(string word) {
  get_data_file(word);
  return fixed_locations;
}
mixed *query_floating_locations(string word) {
  get_data_file(word);
  return floating_locations;
}
int *query_co_ord(string terrain, string file) {
  get_data_file(terrain);
  return fixed_locations[file];
}
string query_connection(string terrain, int *co_ords, string direc) {
  mapping connection_info, tmp;
  string connections;
  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && (tmp = tmp[co_ords[2]])) {
    return tmp[direc];
  }
  return 0;
}
int query_connected(string terrain, int *co_ords) {
  mapping connection_info, tmp;
  string connections;
  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && tmp[co_ords[2]]) {
    return 1;
  }
  return 0;
}
int add_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
}
private int add_connection(string terrain, int *co_ords, string direc,
                           string file) {
  mapping connection_info, tmp;
  string connections;
  if (!query_connection(terrain, co_ords, direc)) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      unguarded((: mkdir, RESTORE_PATH + terrain :));
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      connection_info = ([ co_ords[1] : ([ co_ords[2] : ([ direc : file ]) ])
                        ]);
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    } else {
      connections = unguarded((: read_file,
                                 RESTORE_PATH + terrain +"/"+ co_ords[0] :));
      connection_info = restore_variable(connections);
      if ((tmp = connection_info[co_ords[1]])) {
        if ((tmp = tmp[co_ords[2]])) {
          tmp[direc] = file;
        } else {
          connection_info[co_ords[1]][co_ords[2]] = ([ direc : file ]);
        }
      } else {
        connection_info[co_ords[1]] = ([ co_ords[2] : ([ direc : file ]) ]);
      }
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    }
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
}
int add_floating_location(string terrain, string file, int *co_ords,
                          int level) {
  get_data_file(terrain);
  if ((sizeof(co_ords) != 6) && (sizeof(co_ords) != 3)) {
    return 0;
  }
  if (member_array(({ file, co_ords, level }), floating_locations) != -1) {
    return 0;
  }
  floating_locations += ({ ({ file, co_ords, level }) });
  save_data_file(terrain_name);
  return 1;
}
private void add_cloned_location(string terrain, string file, int *co_ords) {
  mapping tmp, location_m;
  if (!(location_m = cloned_locations[terrain])) {
    cloned_locations[terrain] = ([ file : co_ords,
                                   co_ords[0] : ([ co_ords[1] :
                                                   ([ co_ords[2] : file ]) ])
                                ]);
  } else {
    location_m[file] = co_ords;
    if ((tmp = location_m[co_ords[0]])) {
      if ((tmp = tmp[co_ords[1]])) {
        tmp[co_ords[2]] = file;
      } else {
        location_m[co_ords[0]][co_ords[1]] = ([ co_ords[2] : file ]);
      }
    } else {
      location_m[co_ords[0]] = ([ co_ords[1] : ([ co_ords[2] : file ]) ]);
    }
  }
}
int modify_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
}
int delete_cloned_location(string terrain, string file) {
  int *co_ords;
  mapping tmp, location_m;
  if (!((location_m = cloned_locations[terrain]) &&
        (co_ords = location_m[file]))) {
    return 0;
  }
  map_delete(location_m, file);
  tmp = location_m[co_ords[0]][co_ords[1]];
  map_delete(tmp, co_ords[2]);
  if (!sizeof(tmp)) {
    tmp = location_m[co_ords[0]];
    map_delete(tmp, co_ords[1]);
    if (!sizeof(tmp)) {
      map_delete(location_m, co_ords[0]);
      if (!sizeof(location_m)) {
        map_delete(cloned_locations, terrain);
      }
    }
  }
  return 1;
}
int delete_fixed_location(string terrain, string file) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  map_delete(fixed_locations, file);
  save_data_file(terrain_name);
  return 1;
}
int delete_floating_location(string terrain, string file, int *co_ords) {
  int i, j, flag_d, flag_m, *data;
  get_data_file(terrain);
  for (i = 0; i < sizeof(floating_locations); i++) {
    if (floating_locations[i][0] == file) {
      data = floating_locations[i][1];
      if (sizeof(data) != sizeof(co_ords)) {
        continue;
      }
      flag_m = 0;
      for (j = 0; j < sizeof(data); j++) {
        if (data[j] != co_ords[j]) {
          flag_m = 1;
          break;
        }
        if (!flag_m) {
          floating_locations = delete(floating_locations, i, 1);
          flag_d = 1;
        }
      }
    }
  }
  save_data_file(terrain_name);
  return flag_d;
}
void clear_cloned_locations(string terrain) {
  map_delete(cloned_locations, terrain);
}
void clear_connections(string terrain) {
  string line, *lines;
  if (file_size(RESTORE_PATH + terrain) != -2) {
    return;
  }
  lines = unguarded((: get_dir, RESTORE_PATH + terrain +"
private int right_co_ords(int *new_co_ords, int *co_ords, int delta,
                          int *vector) {
  int i;
  for (i = 0; i < 3; i++) {
    if (new_co_ords[i] + delta * vector[i] != co_ords[i]) {
      return 0;
    }
  }
  return 1;
}
int get_room_size(string file, int level) {
  int i, number, roomsize, *mapsize;
  string bname, parent, *lines;
  bname = base_name(file);
  if (size_cache[bname]) {
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (cached) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }
  if (find_object(file)) {
    size_cache += ([ bname : file->query_room_size() ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (loaded) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }
  if (!in_map) {
    in_map = 1;
    mapsize = MAP_HANDLER->query_room_size(bname);
    in_map = 0;
  } else {
#ifdef DEBUG_ROOM_SIZE
    TP("GRS says recursion!\n");
#endif
    mapsize = 0;
  }
  if (mapsize) {
    size_cache += ([ bname : mapsize[0] ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (map) %s is %d\n", file, size_cache[bname]));
#endif
    return mapsize[0];
  }
  file = bname + ".c";
  if (file_size(file) < 0) {
    return 10;
  }
  lines = explode(read_file(file), "\n");
  roomsize = 10;
  for (i = 0; i < sizeof(lines); i++) {
    if (level < 4 &&
        sscanf(lines[i], "%*sinherit%*s\"%s\"%*s;", parent) == 4) {
      if (parent[<2..] != ".c") {
        parent += ".c";
      }
      roomsize = get_room_size(parent, level + 1);
    } else if (sscanf(lines[i], "%*sset_room_size(%*s%d%*s", number) == 4) {
      roomsize = number;
      break;
    }
  }
  size_cache += ([ bname : roomsize ]);
#ifdef DEBUG_ROOM_SIZE
  TP(sprintf("GRS says (parsed) %s is %d\n", file, size_cache[bname]));
#endif
  return roomsize;
}
private void add_exit(object place, string direc, string dest) {
  string type;
  type = (string)place->query_exit_type(direc, dest);
  if (!type) {
    type = std_types[direc];
  } else {
    if (type == "none") {
      return;
    }
  }
  place->add_exit(direc, dest, type);
}
private void calculate_exits(object place, int *co_ords) {
  int i, j, k, connected, delta, *new_co_ords;
  string actual, *exit_dirs;
  connected = query_connected(terrain_name, co_ords);
  exit_dirs = (string *)place->query_direc();
  for (i = 0; i < 20; i += 2) {
    if (member_array(STD_ORDERS[i], exit_dirs) != -1) {
      continue;
    }
    actual = query_connection(terrain_name, co_ords, STD_ORDERS[i]);
    if (actual) {
#ifdef DEBUG_CALC_EXITS
      TP(sprintf("actual room %s found\n", actual));
#endif
      add_exit(place, STD_ORDERS[i], actual);
      continue;
    }
    if (connected) {
#ifdef DEBUG_CALC_EXITS
      TP("connected, but no actual room\n");
#endif
      continue;
    }
    new_co_ords = copy(co_ords);
    for (k = 0; k < 3; k++) {
      new_co_ords[k] -= place->query_room_size() * STD_ORDERS[i+1][k];
    }
    reset_eval_cost();
    for (j = 0; j < 100; j++) {
      for (k = 0; k < 3; k++) {
        new_co_ords[k] -= 5 * STD_ORDERS[i+1][k];
      }
      if ((actual = member_fixed_locations(new_co_ords)) ||
          (actual = member_cloned_locations(new_co_ords)) ||
          (actual = top_floating_location(new_co_ords))) {
        delta = (int)place->query_room_size() + get_room_size(actual, 0);
        if (!right_co_ords(new_co_ords, co_ords, delta, STD_ORDERS[i+1])) {
          continue;
        }
#ifdef DEBUG_CALC_EXITS
        TP(sprintf("adding connection for %s\n", actual));
#endif
        add_connection(terrain_name, co_ords, STD_ORDERS[i],
                       base_name(actual));
        add_exit(place, STD_ORDERS[i], actual);
        break;
      }
    }
  }
}
object find_location(string terrain, int *co_ords) {
  string dest_name;
  object destination;
  if (!(get_data_file(terrain)) || (sizeof(co_ords) != 3)) {
    return 0;
  }
  reset_eval_cost();
  if ((dest_name = member_fixed_locations(co_ords))) {
    if (!(destination = find_object(dest_name))) {
      destination = load_object(dest_name);
    }
    return destination;
  }
  if (dest_name = member_cloned_locations(co_ords)) {
    if ((destination = find_object(dest_name))) {
      return destination;
    } else {
      delete_cloned_location(terrain, dest_name);
    }
  }
  if (dest_name = top_floating_location(co_ords)) {
    destination = clone_object(dest_name);
    destination->set_co_ord(co_ords);
    destination->set_terrain(terrain_name);
    calculate_exits(destination, co_ords);
    add_cloned_location(terrain, file_name(destination), co_ords);
    return destination;
  }
  return 0;
}
void setup_location(object place, string terrain) {
  int *co_ords;
  get_data_file(terrain);
  if (!fixed_locations[base_name(place)]) {
    return;
  }
  co_ords = fixed_locations[base_name(place)];
  place->set_co_ord(co_ords);
  calculate_exits(place, co_ords);
}
mixed *stats() {
  return ::stats() + ({
    ({ "roomsize cache size", sizeof(size_cache) }),
      ({ "cloned_locations", sizeof(cloned_locations) }),
        ({ "float_cache", sizeof(float_cache) }),
          ({ "terrain name", terrain_name }),
            ({ "fixed locations", sizeof(fixed_locations) }),
              ({ "floating locations", sizeof(floating_locations) }),
  });
}

==================================================
FILE: handlers/title_handler.c
==================================================

#include <login.h>
private mapping _pending;
private mapping _titles;
private nosave string* _allowed_multiple;
#define SAVE_FILE "/save/titles"
void load_me();
void save_me();
class blob {
   string ob;
   string func;
}
void create() {
   _pending = ([ ]);
   _titles = ([ ]);
   load_me();
   _allowed_multiple = ({ "very reverend", "mostly reverend",
                          "reverend mother", "mad granny",
                          "mad nanny", "mad mr", "mad ms", "mad miss",
                          "mad mrs" });
}
int is_allowed_multiple_title(string title) {
   return member_array(lower_case(title), _allowed_multiple) != -1;
}
string* query_allowed_multiple_titles() {
   return _allowed_multiple;
}
void add_title_to_player(string person, string title) {
   object ob;
   ob = find_player(person);
   if (ob) {
      ob->add_player_title(title);
      return ;
   }
   if (!_pending[person]) {
      _pending[person] = ({ });
   }
   _pending[person] += ({ title });
   save_me();
}
string* query_pending_titles(string person) {
   if (_pending[person]) {
      return _pending[person];
   }
   return ({ });
}
void add_controlled_title(string title, string ob, string func) {
   class blob fluff;
   fluff = new(class blob);
   fluff->ob = ob;
   fluff->func = func;
   _titles[title] = fluff;
   save_me();
}
protected class blob query_controlled_title(string title) {
   return _titles[title];
}
void check_player(object player) {
   string* titles;
   string title;
   if (!player) {
      return ;
   }
   if (_pending[player->query_name()]) {
      foreach (title in _pending[player->query_name()]) {
         player->add_player_title(title);
      }
      map_delete(_pending, player->query_name());
      save_me();
   }
   titles = player->query_all_player_titles();
   foreach (title in titles) {
      if (_titles[title]) {
         if(!find_object(_titles[title]->ob) ||
            !call_other(_titles[title]->ob, _titles[title]->func,
                        player->query_name())) {
           player->remove_player_title(title);
         }
      }
   }
}
void login_handler_call(string person, string type) {
   if (type == LOGIN) {
      call_out((: check_player(find_player($1)) :), 2, person);
   }
}
void save_me() {
   unguarded((: save_object(SAVE_FILE) :));
}
void load_me() {
   unguarded((: restore_object(SAVE_FILE, 1) :));
}

==================================================
FILE: handlers/tokeniser.c
==================================================

#include "tokenise.h"
mapping token;
void create() {
  token = ([
           '+' : TOK_PLUS,
           '-' : TOK_MINUS,
           '*' : TOK_MULT,
           '/' : TOK_DIV,
           '(' : TOK_OBRAC,
           ')' : TOK_CBRAC,
           '{' : TOK_SARRAY,
           '}' : TOK_EARRAY,
           '[' : TOK_SMAPPING,
           ']' : TOK_EMAPPING,
           ':' : TOK_COLON,
           ',' : TOK_COMMA,
           '.' : TOK_DOT,
           '\t' : TOK_TAB,
           '=' : TOK_ASSIGN,
#ifdef BOOLEAN
           '>' : TOK_GREATOR,
           '<' : TOK_LESS,
           "==" : TOK_EQUAL,
           ">=" : TOK_GREATOREQ,
           "<=" : TOK_LESSEQUAL,
#endif
           "->" : TOK_CALL,
           ".." : TOK_DOTDOT,
           ]);
}
mixed tokenise(string inp) {
  string *bits, *cur;
  int pos, num;
  int start_pos;
  cur = ({ });
  while (pos < strlen(inp))
    switch (inp[pos++]) {
      case ' ' :
      case '\t' :
        break;
      case '\'' :
      case '"' :
      case '`' :
        bits = explode("#"+inp[pos-1..]+"#", inp[pos-1..pos-1]);
        if (!bits || sizeof(bits) < 2) {
          write("Error processing the string.\n");
          return 0;
        }
        pos += strlen(bits[1])+1;
        cur += ({ ({ bits[1] }) });
        break;
      case '.' :
      case '0' :
      case '1' :
      case '2' :
      case '3' :
      case '4' :
      case '5' :
      case '6' :
      case '7' :
      case '8' :
      case '9' :
        start_pos = pos;
        while ((inp[pos] >= '0' && inp[pos] <= '9') || (inp[pos] == '.')) {
          pos++;
        }
        if (strsrch(inp[start_pos..pos], ".") != -1) {
          sscanf(inp[start_pos-1..pos], "%f", num);
        } else {
          sscanf(inp[start_pos-1..pos], "%d", num);
        }
        cur += ({ ({ num }) });
        break;
      case '+' :
      case '*' :
      case ':' :
      case ',' :
      case '{' :
      case '}' :
      case '(' :
      case ')' :
      case '[' :
      case ']' :
        cur += ({ token[inp[pos-1]] });
        break;
      case '>' :
      case '<' :
      case '=' :
      case '-' :
      case '/' :
      case '.' :
        if (inp[pos-1] != '/') {
          if ((num = token[inp[pos-1..pos]])) {
            cur += ({ num });
            pos++;
            break;
          }
          num = token[inp[pos-1]];
          if (num) {
            cur += ({ num });
            break;
          }
        } else {
          if (sizeof(cur) && !stringp(cur[sizeof(cur)-1])) {
            cur += ({ token[inp[pos-1]] });
            break;
          }
        }
      default :
        num = pos-1;
        while (pos < strlen(inp) && (!token[inp[pos++]] || inp[pos-1] == '/'));
        if (pos == num+1)
          break;
        if (token[inp[pos-1]])
          pos--;
        cur += ({ inp[num..pos-1] });
        break;
    }
  return cur;
}
