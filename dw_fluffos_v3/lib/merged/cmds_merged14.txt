# Total Tokens: 15715
# Total Files Merged: 18
# Total Characters: 52438

.c
==================================================

#define COST 50
inherit "/cmds/base";
mixed cmd() {
   if ( this_player()->query_blinded() ) {
      add_failed_mess( "How can you watch anything?  You're blind.\n" );
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess( "Dead people don't watch. It is rude!\n");
      return 0;
   }
   if ( sizeof( (int *)this_player()->effects_matching( "mind.alertness" ) ) ) {
      add_failed_mess( "You are already alert and watching "
        "your surroundings.\n" );
      return 0;
   }
   if ( this_player()->query_specific_gp( "other" ) < COST ) {
      add_failed_mess( "You can't concentrate enough to watch "
        "your surroundings.\n" );
      return 0;
   }
   this_player()->adjust_gp( -COST );
   this_player()->add_effect( "/std/effects/other/alertness", 60 +
     (int)this_player()->query_skill_bonus( "other.perception" ) / 2 );
   return 1;
}
int stop_watching() {
   int *enums, id;
   enums = this_player()->effects_matching( "mind.alertness" );
   if ( sizeof( enums ) ) {
      foreach( id in enums ) {
         this_player()->delete_effect( id );
      }
   }
   else {
      add_succeeded_mess( ({ "You are not currently watching!\n", "" }) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "stop", (: stop_watching() :),
     "", (: cmd() :) });
}

==================================================
FILE: living/wea_r.c
==================================================

#include <clothing.h>
#include <tasks.h>
inherit "/cmds/base";
#define TP this_player()
#define SKILL "covert.manipulation.sleight-of-hand"
mapping add_to_failed(mapping failed, string word, object thing);
int cmd(object *things) {
  int i;
  string result;
  string stuff;
  string *reasons;
  object *okay;
  object *blocking;
  object *total_blocking;
  object ob;
  object tmp;
  mapping failed;
  mapping hide_invis;
  int hiding, sneaking, difficulty, light, my_light;
  okay = ({ });
  failed = ([ ]);
  things = sort_array(things, (: CLOTHING_HANDLER->query_clothing_depth($2->query_type()) -
                                 CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :) );
  total_blocking = ({ });
  foreach (ob in things) {
    if (environment(ob) != this_player())  {
      failed = add_to_failed(failed, "not carrying", ob);
      continue;
    }
    if ( !ob->query_wearable() ) {
      failed = add_to_failed( failed, "cannot wear", ob);
      continue;
    }
    if (member_array(ob, TP->query_wearing()) != -1) {
      failed = add_to_failed(failed, "already wearing", ob);
      continue;
    }
    if (ob->cannot_be_worn()) {
      failed = add_to_failed(failed, "cannot wear", ob);
      continue;
    }
    blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player());
if (this_player() == find_player("presto"))
printf("blocking == %O\n", blocking);
    if (sizeof(blocking)) {
       total_blocking += blocking;
       foreach (tmp in blocking) {
          TP->remove_armour(tmp);
       }
    }
    result = CLOTHING_HANDLER->can_wear_or_remove(ob, this_player());
if (this_player() == find_player("presto"))
printf("ob == %s, result == %s\n", ob->short(), result);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    result = TP->wear_armour(ob, 0);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    okay += ({ ob });
  }
  if (total_blocking) {
    foreach (tmp in total_blocking) {
      TP->wear_armour(tmp);
    }
  }
  result = "";
  if (sizeof(failed)) {
    reasons = keys(failed);
    for (i = 0; i < sizeof(reasons); i++) {
      stuff = query_multiple_short(failed[reasons[i]], "the");
      switch (reasons[i]) {
      case "cannot wear" :
        if (!sizeof(okay)) {
           result += capitalize(stuff) +" cannot be worn.\n";
        }
        break;
      case "already wearing" :
        result += "You are already wearing "+ stuff +".\n";
        break;
      case "already holding" :
        result += "You cannot wear "+ stuff +" as you do not "
          "have enough free limbs.\n";
        break;
      case "oh dear" :
        result += "I'm not sure why you can't wear "+ stuff +
          "; something has probably gone wrong, so please "
          "contact a creator.\n";
        break;
      case "not carrying":
        result += "You aren't carrying " + stuff + ".\n";
        break;
      default :
        result += "You cannot put on "+ stuff +" "+ reasons[i] +".\n";
      }
    }
  }
  if (!sizeof(okay)) {
    return notify_fail(result);
  }
  stuff = query_multiple_short(okay);
  if (sizeof(total_blocking)) {
     tell_room(environment(TP), TP->one_short() + " removes " +
               query_multiple_short(total_blocking) + " so " +
               TP->query_pronoun() + " can wear "+
               stuff +".\n" + TP->one_short() + " wears " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
     write("You remove " +
               query_multiple_short(total_blocking) + " so you can wear "+
               stuff +".\nYou wear " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
  } else {
    hide_invis = ( mapping )this_player()->query_hide_invis();
    hiding = hide_invis[ "hiding" ] ? 1 : 0;
    sneaking = this_player()->query_sneak_level() ? 1 : 0;
    if( hiding || sneaking ) {
      my_light = this_player()->query_light();
      light = environment( this_player() )->query_light();
      difficulty = light + ( 4 * my_light ) / ( light + 1 );
      if( sizeof( total_blocking ) ) {
        difficulty += 50 * sizeof( total_blocking );
      }
      difficulty += okay[0]->query_complete_weight();
      debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                    difficulty, SKILL, this_player()->
                    query_skill_bonus( SKILL ) );
      switch( TASKER->perform_task( this_player(), SKILL, difficulty,
        TM_FREE ) ) {
        case AWARD :
          write( "%^YELLOW%^" + ({
            "You discover something that lets your fingers move more "
              "nimbly.",
            "You find yourself capable of deceiving the eye with greater "
              "ease than before.",
            "You realise how to deceive the eye more effectively."
          })[ random(3) ] + "%^RESET%^\n" );
        case SUCCEED :
          add_succeeded_mess( ({ "$N $V " + stuff + ", managing to stay "
            "unnoticed.\n",
            "" }) );
          break;
        default :
          this_player()->add_succeeded_mess( this_object(), "$N "
            "unsuccessfully tr$y to " + query_verb() + " " + stuff +
            " while staying unnoticed.\n", ({ }) );
          break;
      }
    } else {
      this_player()->add_succeeded_mess( this_object(), "$N $V " + stuff +
        ".\n", ({ }) );
    }
  }
  return 1;
}
mapping add_to_failed(mapping failed, string word, object thing) {
  if (!failed[word]) {
    failed += ([ word : ({ thing }) ]);
  } else {
    failed[word] += ({ thing });
  }
  return failed;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/whi_sper.c
==================================================

inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd( object *others, string last ) {
  class message mess;
  if (sizeof(others) == 1 && others[0] == this_player()) {
     add_failed_mess("Whispering to yourself?  Neat trick.\n");
     return 0;
  }
  mess = build_message(last, others, "whisper");
  mess->type = "whisper";
  return say_it_to(mess, others, 1, "whisper");
}
mixed *query_patterns() {
   return ({ "<string'message'> to <indirect:living>", (: cmd($1, $4[0]) :),
             "<indirect:living> <string'message'>", (: cmd($1, $4[1]) :) });
}

==================================================
FILE: living/wi_eld.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  if (!interactive(this_player()))
    return "/cmds/living/ho_ld"->cmd(str);
  return notify_fail("Use hold; see help hold for more details.\n");
}

==================================================
FILE: living/withdraw.c
==================================================

#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int withdraw_offer(object *sell_to) {
   object *removed;
   object ob;
   removed = ({ });
   foreach (ob in sell_to) {
      if (ob->query_respond_command("sell", this_player())) {
         ob->remove_respond_command("sell", this_player());
         removed += ({ ob });
      }
   }
   if (sizeof(removed)) {
      add_succeeded_mess("$N withdraw$s $p offer of sale to $I.\n", removed);
      return 1;
   }
   add_failed_mess("You cannot withdraw your offer of sale to $I since "
                   "you have not offered to sell them anything in the "
                   "first place.\n", sell_to);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer {from|to} <indirect:living>",
             (: withdraw_offer($1) :) });
}

==================================================
FILE: living/wring.c
==================================================

inherit "/cmds/base";
int cmd(object *things)  {
   object *towels;
   int    *enums;
   int     wetness;
   int     success;
   string  str;
   towels = filter(things,
                   (: $1->id("towel")  ||  $1->query_property("dryer") :));
   things -= towels;
   str = "";
   if (sizeof(towels) == 1)  {
      enums = towels[0]->effects_matching("object.wet");
      if (sizeof(enums)) {
         wetness = towels[0]->arg_of(enums[0]);
      }
      if (wetness < 36 - this_player()->query_str())  {
         str = "You can't wring any more moisture out of " +
               towels[0]->one_short();
         success = 0;
      } else  {
         towels[0]->add_effect("/std/effects/object/wet",
            -wetness / ((36 - this_player()->query_str()) / 4));
         str = "You wring some moisture out of " +
               towels[0]->one_short();
         success = 1;
      }
   } else if (sizeof(towels))  {
      str = "You can only wring out one thing at a time";
      success = 0;
   }
   if (sizeof(things))  {
      if (success) {
         str += ", but you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      } else {
         str += ", and you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      }
   } else {
      str += ".\n";
   }
   write(str);
   return 1;
}
mixed *query_patterns()  {
   return ({ "[out] <indirect:object:me'towel'>", (: cmd($1) :) });
}

==================================================
FILE: creator/auto_doc.c
==================================================

inherit "/cmds/base";
#include <autodoc.h>
int cmd(string str) {
   string *files;
   string file;
   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->recreate_documentation(file)) {
         write("Recreating documentation for " + file + ".\n");
      } else {
         write("Unable to recreate documentation for " + file + ".\n");
      }
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
 }

==================================================
FILE: creator/jumps.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }
   return load_object(str);
}
int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;
   from_ob = find_location(from);
   to_ob = find_location(to);
   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }
   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}
int do_path_list() {
   string str;
   string from;
   string* dest;
   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}
int do_remove_jump(string from, string to) {
   string* dests;
   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}

==================================================
FILE: creator/mem_stat.c
==================================================

#include <creator.h>
#define OBJ_LIMIT 50
#define TP this_player()
inherit "/cmds/base";
string help();
mixed cmd(string str) {
  int memtotal, limit, i = TP->query_cols() -7 -1, j;
  string ret, str2, str3;
   object *objlist;
  if (!str || str == "")
    return notify_fail(help());
  while (strlen(str) && str[0] == ' ')
    str = str[1..];
  if (sscanf(str, "-%s%d %s", str3, limit, str2) == 3) {
    if (str3[0..0] != "l")
      return notify_fail("Error: Only valid character following '-' is 'l' at "
                         "this time.\n");
    str = str2;
  }
  seteuid(geteuid(TP));
  objlist = WIZ_PRESENT->wiz_present(str, TP);
  if (!arrayp(objlist) || sizeof(objlist) < 1) {
    mixed *filelist;
    str = TP->get_path(str);
    notify_fail("Unable to find any objects or files corresponding"
                " to the given name.\n");
    if (sizeof(filelist = TP->get_files(str)) > 0) {
      filelist = filter(filelist, (: (sizeof($1) > 2) &&
                                   ($1[sizeof($1) - 2..] == ".c") :));
      if (sizeof(filelist) < 1)
        return 0;
      filelist = filter(filelist, (: find_object($1) :));
      objlist = map(filelist, (: find_object($1) :));
    } else
      return 0;
  }
  ret = sprintf("%-"+ i +"s %-7s\n", "Object name", "Memory");
  ret += sprintf("%-"+ i +"s %-7s\n", "------------", "-------");
  if (!limit)
    limit = OBJ_LIMIT;
  if (limit > sizeof(objlist))
    limit = sizeof(objlist);
  if (limit == 1)
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   WIZ_PRESENT->desc_f_object(objlist[sizeof(objlist) - 1]),
                   memory_info(objlist[sizeof(objlist) - 1]));
  else
    for (j = 0; j < limit; j++)
      ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                     WIZ_PRESENT->desc_f_object(objlist[j]),
                     memory_info(objlist[j]));
  if (sizeof(objlist) > 1) {
    for (j = 0; j < sizeof(objlist); j++)
      memtotal += memory_info(objlist[j]);
    ret += sprintf("%-"+ i +"."+ i +"s %7.7s\n",
                   "", "=======");
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   "Total memory used for all "+ sizeof(objlist) +
                   " object(s):", memtotal);
  }
  TP->more_string(ret);
  return 1;
}
string help() {
  return "Usage: memstat [-l<number>] [<filename(s)>|<wiz_present syntax>]\n\n"
"Memstat lists the guestimated amount of memory the specified object(s) use. "
"Using the -l option, a maximum amount of objects to be listed may be "
"specified otherwise a default limit of "+ OBJ_LIMIT +" objects are listed. "
"Paths including wildcards are taken as a way of specifying more than one "
"file.\n";
}
mixed *query_patterns() {
    return ({ "<string>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: creator/mudinfo.c
==================================================

inherit "/cmds/base";
#ifndef __COMPILER__
#define __COMPILER__     "probably gcc"
#define __OPTIMIZATION__ "bugged driver?"
#endif
#define WIDTH 15
#define PAD(x,y)      sprintf("%-*s: %s\n", WIDTH, x,"" + y)
varargs string pretty_time(int tim, int len);
private nosave int num_obs;
mixed cmd(string str) {
   mapping r;
   float cpu;
   string name, cc, tmp;
   int *ltype;
   name = capitalize(mud_name()) + "   (" + query_host_name() + " " +
          __PORT__ + ")";
   cc = __COMPILER__ + "   (" + __OPTIMIZATION__ + ")";
   r = rusage();
   cpu = ((r["utime"] + r["stime"]) / uptime() / 10.0);
   num_obs = 0;
   objects((: num_obs++ :));
   ltype = implode(users(), (:$1[compressedp($2)]++, $1:), ({0,0}));
   tmp = PAD("Mud name", name) +
         PAD("Driver", __VERSION__) +
         PAD("Architecture", __ARCH__) +
         PAD("Compiler", cc) +
         PAD("Driver uptime", pretty_time(uptime(), 4)) +
         PAD("Avg Cpu usage", sprintf("%4.2f%%",cpu)) +
         PAD("Load Average", query_load_average()) +
         PAD("No of users", sizeof(users())) +
         PAD("Using MCCP", ltype[1]) +
         PAD("Plain telnet", ltype[0]) +
         PAD("Named Livings", sizeof(named_livings())) +
         PAD("Objects", num_obs) +
         PAD("Call Outs", sizeof(call_out_info()) + " pending.") +
         PAD("Memory usage", memory_info());
   tell_object(this_player(), tmp);
   return 1;
}
varargs string pretty_time(int tim, int len) {
   int num;
   string *bits, tmp;
   if(!len)
     len = 99999;
   bits = ({ });
   if(tim >= 60*60*24 && sizeof(bits) < len)
      bits += ({ (num=tim/(60*60*24))+" day"+(num==1?"":"s") });
   if(tim >= 60*60 && tim%(60*60*24) && sizeof(bits) < len)
      bits += ({ (num=(tim/(60*60))%24)+" hour"+(num==1?"":"s") });
   if(tim >= 60 && tim%(60*60) && sizeof(bits) <len)
      bits += ({ (num=(tim/60)%60)+" minute"+(num==1?"":"s") });
   if(tim%60 && sizeof(bits) <len)
      bits += ({ (num=tim%60)+" second"+(num==1?"":"s") });
   for(len =0; len<sizeof(bits); len++)
      if(sscanf(bits[len],"%d %s", num, tmp) == 2 && num == 0)
         bits[len] = 0;
   return implode(bits, ", ");
}

==================================================
FILE: creator/playerskills.c
==================================================

#include <skills.h>
private string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)pl->query_skill_bonus( tp ) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
private int real_cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );
      this_player()->more_string( result, "Skills" );
    tell_object( pl, this_player()->query_cap_name() + " is checking "
        "your skills.\n" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
   this_player()->more_string( result, "Skills" );
   tell_object( pl, this_player()->query_cap_name() + " is checking your "
       "skills.\n" );
   return 1;
}
private void check_response( string txt, object *indirect_obs, string skill ) {
    int result;
    if ( upper_case( txt ) == "Y" ) {
        result = real_cmd( indirect_obs, skill );
        return;
    }
    tell_object( this_player(), "Not viewing skills.\n" );
}
private int cmd( object *indirect_obs, string skill ) {
   if ( !sizeof( filter( indirect_obs, (: userp :) ) ) ) {
      check_response( "Y", indirect_obs, skill );
      return 1;
   }
   tell_object( this_player(), "Are you sure you wish to view " +
      query_multiple_short( indirect_obs ) + "'s skills?  You should ask "
      "$V$0=" + indirect_obs[0]->query_possessive() + ",their$V$ "
   "permission first.\n" );
   tell_object( this_player(), "Enter 'Y' to view " +
      query_multiple_short( indirect_obs ) + "'s skill tree.\n" );
   input_to( (: check_response :), 0, indirect_obs, skill );
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:wiz-present> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:wiz-present>",
            (: cmd($1, 0) :) });
}

==================================================
FILE: creator/pquests.c
==================================================

#include <quest_handler.h>
#include <library.h>
inherit "/cmds/base";
string quest_text(string quest);
int cmd( string player, int sorted ) {
    string *quests, text;
    int i, size;
    if ( !player ) {
        quests = QUEST_HANDLER->query_quest_names();
        text = "$P$Quest list$P$\nTotal quests on " + mud_name() + " :-\n\n";
    }
    else {
        quests = LIBRARY->query_quests(player);
        if (!quests) {
            add_failed_mess( "That player has not done any "
                "quests.\n" );
            return 0;
        }
    if ( sorted )
        quests = sort_array( quests, 1 );
        text = "$P$Quest list$P$\nQuests done for player " + player + " :-\n\n";
    }
    size = sizeof(quests);
    for ( i = 0; i < size; i++ ) {
        text += sprintf("%d. %s (%s) %s\n", i + 1, quests[i],
            QUEST_HANDLER->query_quest_title (quests[i]),
            quest_text( quests[i] ) );
    }
    tell_object( this_player(), text );
    return 1;
}
string quest_text(string quest) {
    switch ( QUEST_HANDLER->query_quest_status(quest) ) {
        case 0:
            return "(inactive)";
        case 1:
            return "";
        default:
            return "(broken)";
    }
}
mixed *query_patterns() {
    return ({ "", (: cmd(0, 0) :),
        "<string'player'>", (: cmd($4[0], 0) :),
        "<string'player'> sorted", (: cmd($4[0], 1) :)
    });
}

==================================================
FILE: creator/prof.c
==================================================

#include <housing.h>
inherit "/cmds/base";
#define MAX 500
int last_got;
mixed *data, *tot;
int total(mapping *info) {
  int ret;
  mapping item;
  foreach(item in info)
    ret += item["self"];
  return ret;
}
int cmd(string thing) {
  int i, j;
  mapping stuff;
  object ob;
  mixed foo;
  string ret;
  if(last_got < time() - 900) {
    data = map(objects((: !clonep($1) :)),
               (: ({ $1, function_profile($1) }) :));
    tot = allocate(sizeof(data));
    for(i=0; i<sizeof(data); i++) {
      tot[i] = ({ data[i][0], total(data[i][1]) });
    }
    for(i=0; i<24; i++) {
      reset_eval_cost();
      for (j = i; j < sizeof(tot); j++)
        if (tot[i][1] < tot[j][1]) {
          foo = tot[i];
          tot[i] = tot[j];
          tot[j] = foo;
        }
    }
    last_got = time();
  }
  ret = "";
  if(!thing) {
    for (i = 0; i < 50 && i<sizeof(tot); i++) {
      if(tot[i][1])
        ret += sprintf("%60-O %i\n", tot[i][0], tot[i][1]);
    }
  } else {
    ob = find_object(thing);
    if(!ob)
      return notify_fail("No such object.\n");
    ret += sprintf("%30-s %10s %10s %10s\n", "function", "calls", "self", "children");
    i = 0;
    for(j=0; j<sizeof(data); j++)
      if(data[j][0] == ob) {
        i = 1;
        break;
      }
    if(!i)
      return notify_fail("No such object in data.\n");
    foreach(stuff in data[j][1]) {
      ret += sprintf("%30-s %10d %10d %10d\n", stuff["name"], stuff["calls"],
             stuff["self"], stuff["children"]);
    }
  }
  write("$P$Profile$P$" + ret);
  return 1;
}

==================================================
FILE: creator/pstat.c
==================================================

inherit "/cmds/base";
int cmd( object *indirect_obs ) {
    object ob;
    mapping prop;
    string *sorted, property;
    string txt;
    txt = "$P$Properties$P$";
    foreach( ob in indirect_obs ) {
        prop = filter( ob->query_properties(), (: $2 :) );
        sorted = sort_array( keys( prop ), 1 );
        foreach( property in sorted ) {
            txt += sprintf( "$I$0,5=(%s): %O$I$0,-5=\n", property, prop[ property ] );
        }
    }
    tell_object( this_player(), txt );
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd( $1 ) :) });
}

==================================================
FILE: creator/ptest_ers.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
#include <project_management.h>
string query_applicant_text();
varargs int cmd(string check, string name, string reason) {
  int i;
  string *names, *projects;
  string ret = "";
  class project *tmp, *tmp2;
  switch (check) {
    case "ptinfo":
      ret = PLAYTESTER_HAND->query_show_list_colour();
      tell_object (this_player(), ret);
      return 1;
    break;
    case "assign":
      i = PROJECT_HANDLER->find_project (name);
      if (i == -1) {
        this_player()->add_failed_mess (this_object(), "There is no project "
          "of that ID.\n", ({ }));
        return 0;
      }
      else {
        names = PROJECT_HANDLER->assign_pts_to_project (i);
        if (!sizeof (names)) {
          this_player()->add_failed_mess (this_object(), "Something went "
            "wrong!\n", ({ }));
            return 0;
        }
        else {
          tell_object (this_player(), sprintf ("$I$5=You assign %s to project %s.\n",
          query_multiple_short (map (names, (: capitalize ($1) :))), name));
        return 1;
      }
    }
    break;
    case "allassign":
      tmp = PROJECT_HANDLER->get_playtesting_projects();
      tmp2 = filter (tmp, (: sizeof ($1->guild_specific) :));
      tmp -= tmp2;
      if (!sizeof (tmp) && !sizeof (tmp2)) {
          this_player()->add_failed_mess (this_object(), "There are no "
            "projects currently in playtesting.\n", ({ }));
          return 0;
      }
      else {
        for (int c = 0; c < 2; c++) {
          if (c == 0) {
            projects = map (tmp2, (: $1->id :));
          }
          else {
            projects = map (tmp, (: $1->id :));
          }
          foreach (string p in projects) {
            names = PROJECT_HANDLER->assign_pts_to_project (p);
            if (!sizeof (names)) {
              continue;
            }
            ret += sprintf ("$I$5=You assign %s to project %s.\n",
              query_multiple_short (map (names, (: capitalize ($1) :))), p);
          }
        }
        tell_object (this_player(), ret);
        return 1;
    }
    break;
    case "add":
      i = PLAYTESTER_HAND->add_playtester (name);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N add$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot add this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;
    case "remove":
      i = PLAYTESTER_HAND->remove_playtester (name, reason);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N remove$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;
    case "shortlist":
      PT_APPLICATION_HANDLER->set_shortlist (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
      return 1;
    break;
    case "investigate":
        PT_APPLICATION_HANDLER->set_considering (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
        return 1;
    break;
    case "delete":
      i =  PT_APPLICATION_HANDLER->delete_applicant (name);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N delete$s someone "
          "as from the application process.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player from the application process.\n", ({ }));
        return 0;
      }
    break;
    case "holiday":
      i =  PLAYTESTER_HAND->query_leave(name);
      if (i) {
        PLAYTESTER_HAND->reset_leave(name);
        this_player()->add_succeeded_mess (this_object(), "$N reset$s someones "
          "playtester leave.\n", ({ }));
        return 1;
      }
      else {
        PLAYTESTER_HAND->set_leave(name, reason);
        this_player()->add_succeeded_mess (this_object(), "$N set$s someone "
          "as on leave.\n", ({ }));
        return 1;
      }
    break;
  }
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "add <word>", (: cmd ("add", $4[0]) :),
      "remove <word'name'> <string'reason'>", (: cmd ("remove", $4[0], $4[1]) :),
      "holiday <word> <string>", (: cmd ("holiday", $4[0], $4[1]) :),
      "shortlist <word>", (: cmd ("shortlist", $4[0]) :),
      "investigate <word>", (: cmd ("investigate", $4[0]) :),
      "delete <word>", (: cmd ("delete", $4[0]) :),
      "assign all", (: cmd ("allassign", "all") :),
      "assign <word>", (: cmd ("assign", $4[0]) :),
      "info", (: cmd ("ptinfo") :)
      });
  return patterns;
}

==================================================
FILE: creator/ptguilds.c
==================================================

#include <player.h>
string format_guild_list( string guild_path, string *members ) {
    return "Members of the " + (guild_path->query_short()
      ? guild_path->query_short() : "Misc.") + ": " +
        query_multiple_short( sort_array( map( members,
           (: capitalize( $1 ) :) ), 1 ) ) + ".";
}
int cmd( string guild ) {
    mapping data;
    string txt;
    string *members;
    data = PLAYTESTER_HAND->query_playtester_guilds();
    txt = "Playtester listing by Guild\n\n";
    if ( guild && ( members = data[ guild ] ) ) {
        txt = format_guild_list( guild, members );
    }
    else {
        txt += implode( values( map( data,
            (: format_guild_list( $1, $2 ) :) ) ), "\n\n" );
    }
    tell_object( this_player(), txt + "\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd(0) :),
              "<string'guild'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/ptobj_ect.c
==================================================

inherit "/cmds/base";
#define PT_ARMOURY "/d/playtesters/palace_rooms/armoury"
mixed *query_patterns() {
    return ({ "info",
                  (: PT_ARMOURY->do_info() :),
              "help",
                  (: PT_ARMOURY->do_info() :),
              "list",
                  (: PT_ARMOURY->do_list_all() :),
              "list commands",
                  (: PT_ARMOURY->do_list_commands() :),
              "list objects",
                  (: PT_ARMOURY->do_list_commands() :),
              "control",
                  (: PT_ARMOURY->do_list_control_all() :),
              "control commands",
                  (: PT_ARMOURY->do_list_control_commands() :),
              "control objects",
                  (: PT_ARMOURY->do_list_control_commands() :),
              "request <string:'item'>",
                  (: PT_ARMOURY->do_request_object( lower_case( $4[ 0 ] ) ) :),
              "add object <word:'path of object'> as <string:'item name'>",
                  (: PT_ARMOURY->do_add_object( $4[ 0 ],
                                                lower_case( $4[ 1 ] ) ) :),
              "remove object <string:'item name'>",
                  (: PT_ARMOURY->do_remove_object( $4[ 0 ] ) :),
              "allow <word:'guilds'> to use object <string:'item name'>",
                  (: PT_ARMOURY->do_allow_object( $4[ 0 ],
                                                  lower_case( $4[ 1 ] ) ) :),
              "add command <string:'command name'>",
                  (: PT_ARMOURY->do_add_command( $4[ 0 ] ) :),
              "remove command <string:'command name'>",
                  (: PT_ARMOURY->do_remove_command( $4[ 0 ] ) :),
              "allow <word:'guilds'> to use command <string:'command name'>",
                  (: PT_ARMOURY->do_allow_command( $4[ 0 ], $4[ 1 ] ) :)
              });
}

==================================================
FILE: creator/qwho.c
==================================================

#include <top_ten_tables.h>
int cmd(string filter, string arg);
string* determine_location( object person ) {
    mixed *areas, *place;
    areas = ({
        ({ "/d/liaison/NEWBIE", ({ "Misc", "The newbie area" }) }),
        ({ "/room/air", ({ "Misc", "The air" }) }),
        ({ "/room/void", ({ "Misc", "The void" }) }),
        ({ "/room/rubbish", ({ "Misc", "The rubbish room" }) }),
        ({ "/room/departures", ({ "Misc", "The departures lounge" }) }),
        ({ "/room/jail", ({ "Misc", "Jail" }) }),
        ({ "/w/", ({ "Misc", "/w dirs" }) }),
        ({ "/d/cwc/utils/interview", ({ "CWC", "Interview room" }) }),
        ({ "/d/cwc/common", ({ "CWC", "Commonroom" }) }),
        ({ "/d/cwc/Brown_Islands", ({ "CWC", "Brown Islands" }) }),
        ({ "/d/cwc/Bes_Pelargic/Bad_Poo-Ning/roads/medina",
            ({ "CWC", "Medina" }) }),
        ({ "/d/cwc/Bes_Pelargic/Sum_Bing/roads/snail",
            ({ "CWC", "The Snail" }) }),
        ({ "/d/cwc/Bes_Pelargic", ({ "CWC", "Bes Pelargic" }) }),
        ({ "/d/cwc/Hunghung", ({ "CWC", "HungHung" }) }),
        ({ "/d/cwc/Isle_of_Tonahamen", ({ "CWC", "Isle of Tonahamen" }) }),
        ({ "/d/cwc/families/mcsweeny", ({ "CWC", "McSweeney Estate" }) }),
        ({ "/d/cwc/Maps", ({ "CWC", "Terrains" }) }),
        ({ "/d/cwc", ({ "CWC", "?" }) }),
        ({ "/d/guilds/assassins/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/thieves/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/BesPelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/Hunghung", ({ "CWC", "HH guilds" }) }),
        ({ "/d/guilds/priests/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/wizards/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/witches/bespelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/underworld/moving_shop/rooms/cwc", ({ "CWC", "F-shop" }) }),
        ({ "/d/am/utils/interview", ({ "AM", "Interview room" }) }),
        ({ "/d/am/shades", ({ "AM", "The Shades" }) }),
        ({ "/d/am/common", ({ "AM", "Commonroom" }) }),
        ({ "/d/am", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/special/player_shops", ({ "AM", "Tarnach's" }) }),
        ({ "/d/guilds/merchants", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/guilds/assassins/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/thieves/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/warriors/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/priests/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/wizards/Ankh-Morpork",
            ({ "AM", "Unseen University" }) }),
        ({ "/d/guilds/witches/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/witches/am", ({ "AM", "AM guilds" }) }),
        ({ "/d/klatch/utils/interview", ({ "Klatch", "Interview room" }) }),
        ({ "/d/klatch/common", ({ "Klatch", "Commonroom" }) }),
        ({ "/d/klatch/djel/city", ({ "Klatch", "KLK" }) }),
        ({ "/d/klatch/djel/necropolis", ({ "Klatch", "Necropolis" }) }),
        ({ "/d/klatch/djel/netherworld", ({ "Klatch", "Netherworld" }) }),
        ({ "/d/klatch/tsort/desert/roads",
            ({ "Klatch", "Tsort desert road" }) }),
        ({ "/d/klatch/tsort/desert", ({ "Klatch", "Tsort desert" }) }),
        ({ "/d/klatch/tsort", ({ "Klatch", "Tsort" }) }),
        ({ "/d/klatch/Maps", ({ "Klatch", "Terrains" }) }),
        ({ "/d/klatch", ({ "Klatch", "?" }) }),
        ({ "/d/guilds/assassins/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/thieves/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/warriors/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Djelibeybi", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Ephebe", ({ "Klatch", "Ephebe guilds" }) }),
        ({ "/d/guilds/wizards/Tsort", ({ "Klatch", "Tsort guilds" }) }),
        ({ "/d/guilds/witches/klk", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/ram/utils/interview", ({ "Ram", "Interview room" }) }),
        ({ "/d/ram/common", ({ "Ram", "Commonroom" }) }),
        ({ "/d/ram/Gloomy_Forest", ({ "Ram", "Gloomy forest" }) }),
        ({ "/d/ram/Lancre_Kingdom", ({ "Ram", "Lancre Kingdom" }) }),
        ({ "/d/ram/Listening_Monks", ({ "Ram", "Listening Monks" }) }),
        ({ "/d/ram/Razorback", ({ "Ram", "Razorback" }) }),
        ({ "/d/ram/Slice", ({ "Ram", "Slice" }) }),
        ({ "/d/ram/Sprite_Caverns", ({ "Ram", "Sprite caverns" }) }),
        ({ "/d/ram/Temple_of_Soyin", ({ "Ram", "Temple of Soyin" }) }),
        ({ "/d/ram/Uberwald", ({ "Ram", "Uberwald" }) }),
        ({ "/d/ram/badass", ({ "Ram", "Bad Ass" }) }),
        ({ "/d/ram/madstoat", ({ "Ram", "Mad Stoat" }) }),
        ({ "/d/ram/ohulan", ({ "Ram", "Ohulan-Cutash" }) }),
        ({ "/d/ram/foothills", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/bridge", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/moorland", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/gorge_road", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/Lower_Valleys", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/lancre_town", ({ "Ram", "Lancre Town" }) }),
        ({ "/d/ram/bandit_camp", ({ "Ram", "Bandit camp" }) }),
        ({ "/d/ram/druid_circle", ({ "Ram", "Druid circle" }) }),
        ({ "/d/ram/mountains", ({ "Ram", "Ramtops" }) }),
        ({ "/d/ram", ({ "Ram", "?" }) }),
        ({ "/d/guilds/assassins/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/thieves/Madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/warriors/Lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/priests/Monks-of-Cool", ({ "Ram", "Monks of Cool" }) }),
        ({ "/d/guilds/priests/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/wizards/Creel-Springs",
            ({ "Ram", "Creel Springs guilds" }) }),
        ({ "/d/guilds/witches/badass", ({ "Ram", "Bad Ass guilds" }) }),
        ({ "/d/guilds/witches/lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/witches/madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/witches/razorback", ({ "Ram", "Razorback guilds" }) }),
        ({ "/d/sur/utils/interview", ({ "Sur", "Interview room" }) }),
        ({ "/d/sur/common", ({ "Sur", "Commonroom" }) }),
        ({ "/d/sur/Maps", ({ "Sur", "Terrains" }) }),
        ({ "/d/sur/Dinky", ({ "Sur", "Dinky" }) }),
        ({ "/d/sur/Sto_Helit", ({ "Sur", "Sto Helit" }) }),
        ({ "/d/sur/StoLat", ({ "Sur", "Sto Lat" }) }),
        ({ "/d/sur/Hillshire", ({ "Sur", "Hillshire" }) }),
        ({ "/d/sur/Holywood", ({ "Sur", "Holywood" }) }),
        ({ "/d/sur/Nowhere", ({ "Sur", "Nowhere" }) }),
        ({ "/d/sur/PekanFord", ({ "Sur", "Pekan Ford" }) }),
        ({ "/d/sur/Sheepridge", ({ "Sur", "Sheepridge" }) }),
        ({ "/d/sur/Scrogden", ({ "Sur", "Scrogden" }) }),
        ({ "/d/sur/items/carriage", ({ "Sur", "Carriage" }) }),
        ({ "/d/sur", ({ "Sur", "?" }) }),
        ({ "/d/guilds/assassins/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/assassins/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/assassins/Sheepridge",
            ({ "Sur", "Sheepridge guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/thieves/Pekan_Ford", ({ "Sur", "PF guilds" }) }),
        ({ "/d/guilds/warriors/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/priests/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/wizards/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/witches/skund", ({ "Sur", "Skund guilds" }) }),
        ({ "/d/guilds/witches/stolat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/forn/utils/interview", ({ "Forn", "Interview room" }) }),
        ({ "/d/forn/common", ({ "Forn", "Commonroom" }) }),
        ({ "/d/forn/genua", ({ "Forn", "Genua" }) }),
        ({ "/d/forn", ({ "Forn", "?" }) }),
        ({ "/d/guilds/assassins/Genua", ({ "Forn", "Genua guilds" }) }),
        ({ "/d/special/utils/interview", ({ "Special", "Interview room" }) }),
        ({ "/d/special/common", ({ "Special", "Commonroom" }) }),
        ({ "/d/special/ctf", ({ "Special", "CTF" }) }),
        ({ "/d/special", ({ "Special", "?" }) }),
        ({ "/d/playtesters/utils/interview", ({ "Playtesters",
            "Interview room" }) }),
        ({ "/d/playtesters/common", ({ "Playtesters", "Commonroom" }) }),
        ({ "/d/playtesters/palace_rooms", ({ "Playtesters", "Palace" }) }),
        ({ "/d/playtesters", ({ "Playtesters", "?" }) }),
        ({ "/d/liaison/utils/interview", ({ "Liaison", "Interview room" }) }),
        ({ "/d/liaison/common", ({ "Liaison", "Commonroom" }) }),
        ({ "/d/liaison", ({ "Liaison", "?" }) }),
        ({ "/d/underworld/common", ({ "Underworld", "Commonroom" }) }),
        ({ "/d/underworld/death", ({ "Underworld", "Death's domain" }) }),
        ({ "/d/underworld/lspace", ({ "Underworld", "L-space" }) }),
        ({ "/d/underworld/moving_shop", ({ "Underworld", "T-shop" }) }),
        ({ "/d/underworld", ({ "Underworld", "?" }) }),
        ({ "/d/guilds/common", ({ "Guilds", "Commonroom" }) }),
        ({ "/d/guilds/assassins", ({ "Guilds", "Assassins" }) }),
        ({ "/d/guilds/thieves", ({ "Guilds", "Thieves" }) }),
        ({ "/d/guilds/warriors", ({ "Guilds", "Warriors" }) }),
        ({ "/d/guilds/priests/rooms", ({ "Guilds", "Passage rooms" }) }),
        ({ "/d/guilds/priests", ({ "Guilds", "Priests" }) }),
        ({ "/d/guilds/wizards", ({ "Guilds", "Wizards" }) }),
        ({ "/room/magic_circle", ({ "Guilds", "Witches' circle" }) }),
        ({ "/d/guilds/witches", ({ "Guilds", "Witches" }) }),
        ({ "/d/guilds", ({ "Guilds", "?" }) }),
        ({ "/d/admin/room/domain_control", ({ "Admin", "Domain control" }) }),
        ({ "/d/admin", ({ "Admin", "?" }) }),
        ({ "/d", ({ "Other", "Unknown /d room" }) }),
    });
    if( !environment(person) ) {
        return ({ "Other", "No environment" });
    }
    foreach( place in areas ) {
        if( strsrch( file_name(environment(person)), place[0] ) == 0 ) {
            return place[1];
        }
    }
    return ({ "Other", "Unknown environment" });
}
int get_guild_id(object person) {
    switch(person->query_guild_ob()) {
        case "/std/guilds/warrior":
            return 0;
        case "/std/guilds/assassin":
            return 1;
        case "/std/guilds/thief":
            return 2;
        case "/std/guilds/wizard":
            return 3;
        case "/std/guilds/priest":
            return 4;
        case "/std/guilds/witch":
            return 5;
        default:
            return 6;
    }
}
mapping get_dist( string filter, string arg ) {
    mapping ps;
    object *people, person;
    string *loc;
    int to_add;
    people = filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) );
    ps = ([ ]);
    foreach( person in people ) {
        loc = determine_location(person);
        if( !ps[loc[0]] ) {
            if( filter == "average" ) {
                ps[loc[0]] = ({ ([ ]), 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]] = ({ ([ ]), 0, 0 });
            }
        }
        ps[loc[0]][1]++;
        if( !ps[loc[0]][0][loc[1]] ) {
            if( filter == "average" ) {
                ps[loc[0]][0][loc[1]] = ({ 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]][0][loc[1]] = ({ 0, 0 });
            }
        }
        ps[loc[0]][0][loc[1]][0]++;
        switch(filter) {
            case "verbosity":
                if( person->query_verbose(arg) ) {
                    ps[loc[0]][2]++;
                    ps[loc[0]][0][loc[1]][1]++;
                }
                break;
            case "average":
                to_add = 0;
                if( arg == "guild level" ) {
                    to_add = person->query_level();
                }
                if( arg == "rating" ) {
                    to_add = (int)TOP_TEN_HANDLER->calculate_rating(person);
                }
                if( arg == "age" ) {
                    to_add = -person->query_time_on();
                }
                if( to_add < ps[loc[0]][2][0] || ps[loc[0]][2][0] == -1 ) {
                    ps[loc[0]][2][0] = to_add;
                }
                ps[loc[0]][2][1] += to_add;
                if( to_add > ps[loc[0]][2][2] ) {
                    ps[loc[0]][2][2] = to_add;
                }
                if( to_add < ps[loc[0]][0][loc[1]][1][0] ||
                    ps[loc[0]][0][loc[1]][1][0] == -1 ) {
                    ps[loc[0]][0][loc[1]][1][0] = to_add;
                }
                ps[loc[0]][0][loc[1]][1][1] += to_add;
                if( to_add > ps[loc[0]][0][loc[1]][1][2] ) {
                    ps[loc[0]][0][loc[1]][1][2] = to_add;
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    if( !ps[loc[0]][2] ) {
                        ps[loc[0]][2] = ({0,0,0,0,0,0,0});
                    }
                    if( !ps[loc[0]][0][loc[1]][1] ) {
                        ps[loc[0]][0][loc[1]][1] = ({0,0,0,0,0,0,0});
                    }
                    to_add = get_guild_id(person);
                    ps[loc[0]][2][to_add]++;
                    ps[loc[0]][0][loc[1]][1][to_add]++;
                }
                break;
            default:
        }
    }
    return ps;
}
int cmd( string filter, string arg, int verbose ) {
    string place, zone, *guilds;
    mapping players, zones;
    int total, i, j;
    string tmp;
    string ret;
    ret = "";
    players = get_dist(filter,arg);
    total = sizeof(filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) ));
    guilds = ({ "Warriors", "Assassins", "Thieves", "Wizards", "Priests",
        "Witches", "Adventurers" });
    tmp = "\n";
    tmp+= sprintf( "%-27s", "Distribution of players:" );
    if( filter == "category" && arg == "guild" ) {
        j = (this_player()->query_cols() - 27) / (sizeof(guilds));
        for( i=0; i<sizeof(guilds); i++ ) {
            tmp += sprintf( "%" + j + ".3s", guilds[i] );
        }
    }
    if( filter == "average" ) {
        if( arg == "age" ) {
            j = (this_player()->query_cols() - 27);
            tmp += sprintf( "%-" + j + "s", "   Average age" );
        }
        else {
            j = (this_player()->query_cols() - 27) / 3;
            tmp += sprintf( "%" + j + "s", "Lowest" );
            tmp += sprintf( "%" + j + "s", "Average" );
            tmp += sprintf( "%" + j + "s", "Highest" );
        }
    }
    tmp += "\n\n";
    ret += tmp;
    foreach( place in keys(players) ) {
        tmp = "%^YELLOW%^";
        tmp+= sprintf( "%-24.24s", place );
        tmp+= sprintf( "%3.1i", players[place][1] );
        switch( filter ) {
            case "verbosity":
                tmp += players[place][2] + "/" +
                    players[place][1] + " verbose " + arg;
                break;
            case "average":
                if( arg == "age" ) {
                    tmp += sprintf( "%-"+ j +"s", "   " + query_time_string(
                        players[place][2][1] / players[place][1] ) );
                }
                else {
                    tmp += sprintf( "%"+ j +".1i", players[place][2][0] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][1] /
                        players[place][1] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][2] );
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    for( i=0; i<sizeof(guilds); i++ ) {
                        tmp += sprintf( "%" + j + ".1i",
                            players[place][2][i] );
                    }
                }
                break;
            default:
                tmp += "   (";
                tmp += sprintf( "%3s",
                    ((100 * players[place][1]) / total + "%") );
                tmp += ")";
                break;
        }
        tmp += "%^RESET%^";
        tmp += "\n";
        ret += tmp;
        if (verbose) {
           zones = players[place][0];
           foreach( zone in keys( zones ) ) {
               tmp = sprintf( "%-24.24s", ("  - " + zone) );
               tmp+= sprintf( "%3.1i", zones[zone][0] );
               switch( filter ) {
                   case "verbosity":
                       tmp += " (" + zones[zone][1] + "/" + zones[zone][0] +
                           " verbose " + arg + ")";
                       break;
                   case "average":
                       if( arg == "age" ) {
                           tmp += sprintf( "%-"+ j +"s", "   " +
                               query_time_string( zones[zone][1][1] /
                               zones[zone][0] ) );
                       }
                       else {
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][1] /
                               zones[zone][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][2] );
                       }
                       break;
                   case "category":
                       if( arg == "guild" ) {
                           for( i=0; i<sizeof(guilds); i++ ) {
                               if( !zones[zone][1][i] ) {
                                   tmp += "%^BLACK%^";
                                   tmp += sprintf( "%" + j + ".1i",
                                        zones[zone][1][i] );
                                   tmp += "%^RESET%^";
                               }
                               else {
                                   tmp += sprintf( "%" + j + ".1i",
                                       zones[zone][1][i] );
                               }
                           }
                       }
                       break;
                   default:
                       tmp += "   (";
                       tmp += sprintf( "%3s",
                           ((100 * zones[zone][0]) / total + "%") );
                       tmp += ")";
                       break;
               }
               tmp += "\n";
               ret += tmp;
           }
        }
        if (verbose) {
           ret += "\n";
        }
    }
    ret += "Total = " + total + "\n";
    write("$P$Distribution$P$" + ret);
    return 1;
}
mixed *query_patterns() {
    return ({
        "by domain", (: cmd(0, 0, 0) :),
        "by guild level",  (: cmd("average", "guild level", 0) :),
        "by rating",  (: cmd("average", "rating", 0) :),
        "by age",  (: cmd("average", "age", 0) :),
        "by guild",  (: cmd("category", "guild", 0) :),
        "verbose by domain", (: cmd(0, 0, 1) :),
        "verbose by guild level",  (: cmd("average", "guild level", 1) :),
        "verbose by rating",  (: cmd("average", "rating", 1) :),
        "verbose by age",  (: cmd("average", "age", 1) :),
        "verbose by guild",  (: cmd("category", "guild", 1) :),
    });
}
