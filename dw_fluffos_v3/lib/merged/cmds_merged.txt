# Total Tokens: 17411
# Total Files Merged: 11
# Total Characters: 58066

=============================================

void create() {
  seteuid(getuid(this_object()));
}
void dest_me() {
  if(this_object())
    destruct(this_object());
}
int clean_up() {
  dest_me();
  return 1;
}
void reset() {
  dest_me();
}

==================================================
FILE: bug_replies.c
==================================================

#include <error_handler.h>
#include <db.h>
#include <nroff.h>
#define HELP_FILE "/doc/helpdir/bug_replies"
class player_data {
   int position;
   int date;
   class error_replies* replys;
}
nosave private mapping _player_replies;
void print_menu_input();
void create() {
   _player_replies = ([ ]);
}
void print_bug_replies(object player) {
   string str;
   class error_replies* replies;
   int i;
   int pos;
   replies = _player_replies[player]->replys;
   if (!sizeof(replies)) {
      tell_object(player, "No bug replies.\n");
      return ;
   }
   pos = _player_replies[player]->position;
   str = "";
   for (i = 0; i < sizeof(replies); i++) {
      if (i == pos) {
         str += ">";
      } else {
         str += " ";
      }
      switch (replies[i]->status) {
      case "NEW" :
         str += "N";
         break;
      case "DELETED" :
         str += "D";
         break;
      default :
         str += " ";
         break;
      }
      str += (i+1) + ") " + replies[i]->sender + " Sub: " +
             replies[i]->subject + "\n";
   }
   player->set_finish_func("finish_more_replies", this_object());
   tell_object(player, "$P$Bug replies$P$" + str);
}
void finish_more_replies() {
   print_menu_input();
}
void print_menu(object player) {
   int len;
   len = sizeof(_player_replies[player]->replys);
   if (len == 0) {
      tell_object(player, "[None] QDRULH?<num>: ");
   } else {
      tell_object(player, "[1-" + len + "] QDRULH?<num>: ");
   }
}
void delete_message(int start_pos, int end_pos) {
   int pos;
   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                           "DELETED",
                                           (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "DELETED";
   }
   if (start_pos != end_pos) {
      write("Delete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Delete error reply " + (pos) + ".\n");
   }
}
void undelete_message(int start_pos, int end_pos) {
   int pos;
   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                        "READ",
                                        (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "READ";
   }
   if (start_pos != end_pos) {
      write("Undelete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Undelete error reply " + (pos) + ".\n");
   }
}
int valid_message(int pos) {
   pos--;
   if (pos < 0 || pos >= sizeof(_player_replies[this_player()]->replys)) {
      return 0;
   }
   return 1;
}
void print_menu_input() {
   print_menu(this_player());
   input_to("bug_replies_menu");
}
void read_message(int pos) {
   class error_replies reply;
   pos--;
   reply = _player_replies[this_player()]->replys[pos];
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string("Date Sent: " + ctime(reply->senddate) + "\n"
         "From: " + reply->sender + "\n"
         "Subject: " + reply->subject + "\n\n" +
         reply->message + "\n");
   if (reply->status == "NEW") {
      ERROR_HANDLER->do_status_error_reply(reply->id, "READ", (: 1 :));
      reply->status = "READ";
   }
}
int read_next_new() {
   int i;
   class error_replies* replies;
   replies = _player_replies[this_player()]->replys;
   for (i = 0; i < sizeof(replies); i++) {
      if (replies[i]->status == "NEW") {
         read_message(i + 1);
         return 1;
      }
   }
   write("No new unread error replies.\n");
   return 0;
}
void finish_editing_message(string mess, int pos) {
   class error_replies reply;
   if (!mess || !strlen(mess)) {
      write("Aborting send of message.\n");
   } else {
      reply = _player_replies[this_player()]->replys[pos];
      ERROR_HANDLER->do_add_error_reply(reply->id,
                             this_player()->query_name(),
                             reply->sender,
                             "Re: " + reply->subject,
                             mess);
      write("Sent message to " + reply->sender + "\n");
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}
int reply_message(int pos) {
   write("Replying to message:\n");
   pos--;
   this_player()->do_edit("", "finish_editing_message", this_object(), 0, pos);
   return 1;
}
void help_command() {
   string nroff_fn;
   string str;
   nroff_fn = HELP_FILE + ".o";
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(HELP_FILE, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string(str);
}
void bug_replies_menu(string inp) {
   int pos;
   int new_pos;
   int end_pos;
   while (strlen(inp) && inp[0] == ' ') {
      inp = inp[1..];
   }
   while (strlen(inp) && inp[<1] == ' ') {
      inp = inp[0..<2];
   }
   end_pos = -1;
   if (!strlen(inp)) {
      if (read_next_new()) {
         return ;
      }
   } else {
      if (inp[0] >= '0' && inp[0] <= '9') {
         while (pos < strlen(inp) && inp[pos] >= '0' && inp[pos] <= '9') {
            pos ++;
         }
         pos = to_int(inp[0..pos-1]);
         if (valid_message(pos)) {
            read_message(pos);
            return ;
         } else {
            write("Message " + pos + " is invalid.\n");
         }
      } else {
         while (pos < strlen(inp) && (inp[pos] < '0' || inp[pos] > '9')) {
            pos++;
         }
         if (pos < strlen(inp)) {
            new_pos = pos + 1;
            while (new_pos < strlen(inp) && inp[new_pos] >= '0' && inp[new_pos] <= '9') {
               new_pos++;
            }
            pos = to_int(inp[pos..new_pos-1]);
            if (inp[new_pos] == '-') {
               end_pos = new_pos + 1;
               while (end_pos < strlen(inp) && inp[end_pos] >= '0' && inp[end_pos] <= '9') {
                  end_pos++;
               }
               end_pos = to_int(inp[new_pos + 1..end_pos-1]);
            }
         } else {
            pos = -1;
         }
         switch(lower_case(inp)[0]) {
         case 'q' :
            write("Exiting the system.\n");
            map_delete(_player_replies, this_player());
            return ;
         case 'r' :
            if (valid_message(pos)) {
               if (reply_message(pos)) {
                  return ;
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'd' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     delete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'u' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     undelete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'h' :
         case '?' :
            help_command();
            return ;
         case 'l' :
            print_bug_replies(this_player());
            return ;
         }
      }
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}
void bug_replies_result(int type, mixed* data, object player) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error retrieving replies.\n");
   } else {
      _player_replies[player] = new(class player_data, date : time(),
                                    replys : data);
      print_bug_replies(player);
   }
}
int bug_replies(int only_new) {
  _player_replies[this_player()] = new(class player_data, date : time(),
                                replys : ({ }));
   if (ERROR_HANDLER->do_error_replies(this_player()->query_name(), only_new,
                             (: bug_replies_result($1, $2, $(this_player()) ) :))) {
      input_to("bug_replies_menu");
      return 1;
   }
   add_failed_mess("Unable to find the bug replies.\n");
   return 0;
}

==================================================
FILE: guild_base.c
==================================================

inherit "/cmds/base";
#include <nroff.h>
#include <cmds/guild_base.h>
#define NROFF_SOURCE "/doc/known_command/"
nosave string _nroff_fname;
nosave class teach_skill *_teach_skills;
nosave string _command_name;
nosave string _teach_guild;
void create() {
   _teach_skills = ({ });
}
void set_nroff_file(string str) {
   _nroff_fname = str;
}
string query_nroff_file() {
  return _nroff_fname;
}
private string nroff_file(string name, int html) {
   string nroff_fn;
   string str;
   if (name[0] != '/') {
      name = NROFF_SOURCE + name;
   }
   nroff_fn = NROFF_DIR + replace(name, "/", ".");
   if (html) {
      str = NROFF_HAND->html_file(nroff_fn, 1);
   } else {
      str = NROFF_HAND->cat_file(nroff_fn, 1);
   }
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      if (html) {
         str = NROFF_HAND->html_file(nroff_fn, 0);
      } else {
         str = NROFF_HAND->cat_file(nroff_fn, 0);
      }
   }
   return str;
}
function help_function() {
   if (_nroff_fname) {
      return (: nroff_file(_nroff_fname, 0) :);
   }
   return 0;
}
string help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 0);
   }
   return 0;
}
string query_www_help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 1);
   }
   return 0;
}
void add_teach_skill(string skill, int teach, int learn) {
   class teach_skill bing;
   bing = new(class teach_skill);
   bing->skill = skill;
   bing->teach = teach;
   bing->learn = learn;
   _teach_skills += ({ bing });
}
class teach_skill *query_teach_skills() {
   return _teach_skills;
}
void set_command_name(string name) {
   _command_name = name;
}
string query_command_name() {
   return _command_name;
}
void set_teach_guild(string guild) {
   _teach_guild = guild;
}
string query_teach_guild() {
   return _teach_guild;
}
int can_teach_command(object teacher, object student) {
   class teach_skill bing;
   if (!sizeof(_teach_skills) ||
       !_command_name) {
     return 0;
   }
   foreach (bing in _teach_skills) {
      if (teacher->query_skill(bing->skill) < bing->teach) {
         return -1;
      }
      if (student->query_skill(bing->skill) < bing->learn) {
         return -2;
      }
   }
   if (_teach_guild &&
       student->query_guild_ob() != _teach_guild) {
      return -3;
   }
   return 1;
}
int teach_command(object teacher, object student) {
   int ret;
   ret = can_teach_command(teacher, student);
   if (ret == 1) {
      student->add_known_command(_command_name);
   }
   return ret;
}

==================================================
FILE: position_base.c
==================================================

inherit "/cmds/base";
#include <position.h>
string position;
string up_down;
string position_type;
int query_position_command() {
   return 1;
}
string query_up_down() {
   return up_down;
}
string query_position() {
   return position;
}
string query_position_type() {
   return position_type;
}
void setup_position(string pos, string up, string type) {
   position = pos;
   up_down = up;
   position_type = type;
}
int position(object person, int silent) {
   string pos_type;
   if (person->query_position() == position_type) {
      if (person == this_player()) {
         add_failed_mess("You are already "+position_type+".\n");
      }
      return 0;
   }
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   if (!silent) {
      if (up_down != "") {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position+" " + up_down +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
                      person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$ "  + up_down +
                      " " + pos_type + " " +
                      person->query_position_on_short() + ".\n",
                      ({ person }));
         } else {
            tell_object(person, "You " + position+" " + up_down + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + "," +
                      position+"$V$ " +
                      up_down + ".\n",
                      ({ person }));
         }
      } else {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                             "$V$ " + pos_type + " " +
                             person->query_position_on_short() + ".\n",
               ({ person }));
         } else {
            tell_object(person, "You " + position + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$.\n",
               ({ person }));
         }
      }
   }
   person->set_position(position_type);
   return 1;
}
int position_floor(object person, int silent) {
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   if (person->query_position_on()) {
      if (!silent) {
         if (up_down != "") {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + " " + up_down + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + up_down + ".\n",
                ({ person }));
         } else {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$.\n",
                ({ person }));
         }
      }
      person->set_position(position_type);
      person->set_position_on(0);
      person->set_position_type(0);
      person->set_position_multiple(0);
      return 1;
   }
   return position(person, 0);
}
string *query_position_strings(object person) {
   string bit;
   string bit_other;
   switch (person->query_position_type()) {
      case AT_TYPE :
      case BESIDE_TYPE :
         bit = "move away from";
         bit_other = "moves away from";
         break;
      case ON_TYPE :
      default :
         bit = "get off";
         bit_other = "gets off";
         break;
   }
   return ({ bit, bit_other });
}
int position_object(object *obs, string pos_type, object person) {
   int i;
   int mult;
   string rabbit;
   string *pos_strings;
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   pos_strings = query_position_strings(person);
   for (i = 0; i < sizeof(obs); i++) {
      if (obs[i]->query_property(CAN_POSITION_PROPERTY)) {
         mult = obs[i]->query_property(MULTIPLE_POSITION_PROPERTY);
         if (person->query_position_on()) {
            if (person->query_position_on() == obs[i] &&
                person->query_position_type() == pos_type) {
               if (person->query_position() != position_type) {
                  return position(person, 0);
               }
               if (person == this_player()) {
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
               }
               return 0;
            }
            tell_object(person, "You " + pos_strings[0] + " " +
                person->query_position_on_short() +
                " and " + position + " " + pos_type+" "+
                obs[i]->a_short()+".\n");
            tell_room(environment(person),
                person->one_short() + " " + pos_strings[1] + " " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + pos_type + " " +
                obs[i]->a_short() + ".\n",
                ({ person }));
            person->set_position(position_type);
            person->set_position_on(obs[i]);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
         tell_object(person, "You " + position + " " + pos_type +
                             " " + obs[i]->a_short()+".\n");
         tell_room(environment(person),
                   person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                   "$V$ " + pos_type + " " +
                   obs[i]->a_short() + ".\n",
                   ({ person }));
         person->set_position(position_type);
         person->set_position_on(obs[i]);
         person->set_position_type(pos_type);
         person->set_position_multiple(mult);
         return 1;
      } else  {
         rabbit = obs[i]->query_position_string(position_type);
         if (rabbit) {
            mult = obs[i]->query_position_multiple(position_type);
            if (person->query_position_on()) {
               if (person->query_position_on() == rabbit &&
                   person->query_position_type() == pos_type) {
                  if (person->query_position() != position_type) {
                     return position(person, 0);
                  }
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
                  return 0;
               }
               tell_object(person, "You " + pos_strings[0] +  " " +
                   person->query_position_on_short() +
                   " and " + position + " " + pos_type + " " +
                   rabbit + ".\n");
               tell_room(environment(person),
                         person->one_short() + " " + pos_strings[1] + " " +
                         person->query_position_on_short() +
                         " and $V$0=" + pluralize(position) + ","+position+"$V$ " +
                         pos_type + " " +
                         rabbit + ".\n",
                         ({ person }));
               person->set_position(position_type);
               person->set_position_on(rabbit);
               person->set_position_type(pos_type);
               person->set_position_multiple(mult);
               return 1;
            }
            tell_object(person, "You "+position+" " + pos_type + " " +
                                 rabbit + ".\n");
            tell_room(environment(person),
                person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                      "$V$ "+pos_type + " " +rabbit + ".\n",
                      ({ person }));
            person->set_position(position_type);
            person->set_position_on(rabbit);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
      }
   }
   return 0;
}
mixed *query_patterns() {
   return ({ "", (: position(this_player(), 0) :),
             "on [the] floor", (: position_floor(this_player(), 0) :),
             "{on|at|in|beside} <indirect:object>",
                    (: position_object($1, $4[0], this_player()) :) });
}

==================================================
FILE: report_base.c
==================================================

#include <creator.h>
#include <log.h>
#include <command.h>
#include <spells.h>
#include <user_parser.h>
#include <soul.h>
#include <error_handler.h>
inherit "/cmds/base";
inherit "/cmds/bug_replies";
class errors {
   int type;
   string file;
   string error;
   string extra;
}
#define ROOM_BUG    1
#define OBJECT_BUG  2
#define RITUAL_BUG  3
#define SPELL_BUG   4
#define HELP_BUG    5
#define COMMAND_BUG 6
#define GENERAL_BUG 7
#define WEB_BUG     8
#define SYNONYMS "/doc/SYNONYMS"
int bug_command(string str);
int bug_spell(string str);
int bug_ritual(string str);
int bug_object(object * obj,
               string str);
int bug_help(string str);
int bug_man(string str);
int bug_room();
int bug_general();
int bug_soul(string str);
private nosave mapping _globals;
private nosave string _error_type;
private nosave int _use_last_error;
void create()
{
   bug_replies::create();
   _globals = ([ ]);
}
void set_error_type(string type)
{
   _error_type = type;
}
void set_use_last_error(int error)
{
   _use_last_error = error;
}
int query_use_last_error()
{
   return _use_last_error;
}
int bug_room()
{
   if (environment(this_player())) {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:file_name(environment
             (this_player
              ())));
  } else {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:"/d/mudlib/void");
   }
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_special(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/d/special/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}
int bug_misc(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/obj/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}
int bug_general()
{
   string dir;
   string *bits;
   string file;
   if (!environment(this_player())) {
      dir = "/d/am/fluff";
   } else {
      dir = file_name(environment(this_player()));
   }
   bits = explode(dir, "/");
   if (bits[0] == "d") {
      file = implode(bits[0..1], "/") + "/general";
   } else {
      file = file_name(environment(this_player()));
   }
 _globals[this_player()] = new (class errors, type: GENERAL_BUG, error: "GENERAL " + _error_type, file:file);
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_command(string str)
{
   int i;
   string dir;
   string file;
   string *bits;
   mixed *junk,
    *coms;
   class command cmd;
   class errors bing;
   class command_data cmd_data;
   class command_class cmd_class;
   mapping temp;
   bing = new (class errors);
   coms = ({ });
   junk = actions_defined(this_player(), 0, 12);
   for (i = 0; i < sizeof(junk); i += 2) {
      if (junk[i] == str) {
         coms += ({ junk[i], junk[i + 1][0], junk[i + 1][1] });
      }
   }
   if (sizeof(coms) > 3) {
      return notify_fail("More than one commands with the name \"" + str +
                         "\" found.  Please be more specific.\n");
   }
   if (sizeof(coms)) {
      bing->file = function_exists((string) coms[2], (object) coms[1]);
      if (!(bing->file)) {
         bing->file = base_name((object) coms[1]);
         str += " (protected method, so it might not be in this file)";
      }
   } else {
    cmd = new (class command, verb:str);
      if (CMD_D->HandleStars(cmd) &&
          sizeof((coms = (mixed *) CMD_D->GetPaths(cmd->verb) &
                  (mixed *) this_player()->GetSearchPath()))) {
         bing->file = coms[0] + "/" + cmd->verb;
      } else {
         if ((cmd_class = this_player()->query_parse_command(str))) {
            temp = cmd_class->patterns;
            cmd_data = temp[keys(temp)[0]];
            bing->file = base_name(cmd_data->calls[0]);
         } else {
            if ((coms = SOUL_OBJECT->query_soul_command(str))) {
               bing->file = "/soul/" + str[0..0] + "/" + str;
            } else if (_error_type == "IDEA") {
               dir = file_name(environment(this_player()));
               bits = explode(dir, "/");
               if (bits[0] == "d") {
                  file = implode(bits[0..1], "/") + "/general";
               } else {
                  file = file_name(environment(this_player()));
               }
               bing->file = file;
            } else {
               return notify_fail("Command " + str + " not found.\n");
            }
         }
      }
   }
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_help(string str)
{
   mixed *stuff;
   class errors bing;
   string tmp;
   bing = new (class errors);
   tmp = "/cmds/player/help"->query_synonym(str);
   if (strlen(tmp))
      str = tmp;
   if (str && str != "") {
      stuff = "/cmds/player/help"->query_help_on(str);
      if (!sizeof(stuff)) {
         if (!SOUL_OBJECT->query_soul_command(str)) {
            notify_fail("Could not find the help file '" + str +
                        "'.  If you wish "
                        "to suggest a new command use 'idea help'\n");
            return 0;
         } else {
            bing->file = "/soul/" + str;
         }
      } else {
         sscanf(stuff[0][0], "%*s (%s)", bing->file);
      }
   } else {
     bing->file = "/cmds/player/help";
   }
   bing->error = "HELP " + _error_type + " " + str;
   bing->type = HELP_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_soul(string str)
{
   class errors bing;
   string tmp;
   bing = new (class errors);
   if (str)  {
      tmp = sprintf("/soul/%c/%s.s", str[0], str);
      if (file_size(tmp) < 1)  {
         notify_fail("No such soul command \"" + str + "\".\n");
         return 0;
      }
      else return bug_command(str);
   }
   bing->file = "/soul/ideas";
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_ritual(string str)
{
   mapping junk;
   class errors bing;
   string sname;
   mixed* data;
   string file;
   str = this_player()->expand_nickname(str);
   bing = new (class errors);
   junk = this_player()->query_spells();
   foreach (sname, data in junk) {
      if (lower_case(sname) == lower_case(str)) {
         if (sizeof(data) <= S_OBJECT) {
            file = file_name(environment(this_player()));
         } else {
            file = data[S_OBJECT];
         }
      }
   }
   if (!file) {
      notify_fail("Ritual " + str + " not found.\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = file;
   bing->error = "RITUAL " + _error_type + " " + str;
   bing->type = RITUAL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_web(string url)
{
   class errors bing;
   bing = new (class errors);
   bing->file = "/www/fluff";
   bing->error = "OBJECT " + _error_type + " " + url;
   bing->type = WEB_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit("Url: " + url + "\n\n", "end_of_edit");
   return 1;
}
int bug_spell_file(string file, string name)
{
   class errors bing;
   bing = new (class errors);
   bing->file = file;
   bing->error = "SPELL " + _error_type + " " + name;
   bing->type = SPELL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_spell(string str)
{
   mapping junk;
   string file;
   string sname;
   mixed data;
   if (str == "wizards" || str == "witches") {
      file = "/obj/spells/" + str;
   } else {
      str = this_player()->expand_nickname(str);
      junk = this_player()->query_spells();
      foreach (sname, data in junk) {
         if (lower_case(sname) == lower_case(str) && arrayp(data)) {
            file = data[S_OBJECT];
         }
      }
      if (!file) {
         notify_fail("Spell " + str + " not found.\n");
         map_delete(_globals, this_player());
         return 0;
      }
   }
   bug_spell_file(file, str);
   return 1;
}
int bug_object_new(string name)
{
   string info;
   class errors bing;
   bing = new (class errors);
   bing->file = base_name(environment(this_player()));
   bing->error = "OBJECT " + _error_type + " " + name;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_object(object * obj,
               string str)
{
   string info;
   class errors bing;
   string name;
   string short;
   string* bits;
   bing = new (class errors);
   if (sizeof(obj) > 1) {
      notify_fail("More than one object can be identified with the name " +
                  str + "\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = base_name(obj[0]);
   switch (bing->file) {
   case "/std/room/basic/item":
      bing->file = base_name(environment(this_player()));
      info = sprintf("Room item %s.\n\n", str);
      break;
   case "/std/bit" :
      bing->file = "/std/races/happy_bit";
      break;
   case "/std/book" :
   case "/obj/armour":
   case "/obj/baggage":
   case "/obj/clothing":
   case "/obj/container":
   case "/obj/food":
   case "/obj/monster":
   case "/obj/weapon":
   case "/std/object":
      if (obj[0]->query_property("virtual name")) {
         bing->file = obj[0]->query_property("virtual name");
         info = sprintf("VObject: %s, Object: %s\nName: %s, Short: %s\n\n",
                        obj[0]->query_property("virtual name"),
                        bing->file,
                        obj[0]->query_name(), obj[0]->query_short());
         break;
      } else {
         bing->file = base_name(environment(this_player()));
      }
   default:
      bits = explode(bing->file, "/");
      name = bits[0];
      if (name == "obj" || name == "std") {
         if (sizeof(bits) == 2 ||
             (bits[1] != "food" && bits[1] != "armours" &&
             bits[1] != "weapons" && bits[1] != "amulets" &&
             bits[1] != "monster" && bits[1] != "music" &&
             bits[1] != "plants" && bits[1] != "rings" &&
             bits[1] != "furnitures" && bits[1] != "jewellery" &&
             bits[1] != "wands")) {
            bing->file = base_name(environment(this_player()));
         }
      }
      if (pointerp(obj[0]->query_name()))  {
         name = (obj[0]->query_name())[0];
      } else {
         name = obj[0]->query_name();
      }
      if (!name) {
         name = "<Bad name>";
      }
      short = obj[0]->query_short();
      if (!short) {
         short = "<Bad short>";
      }
      info = sprintf("Name: %s, Short: %s\n\n", name, short);
      break;
   }
   bing->error = "OBJECT " + _error_type + " " + str;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
void end_of_edit(string body)
{
   if (strlen(body)) {
      int ending;
      string name,
        trace = 0;
      mapping last_error;
      class errors bing;
      bing = _globals[this_player()];
      if (bing->extra) {
         body = bing->extra + body;
      }
      if (body[<1] != '\n') {
         ending = 1;
      }
      if (environment(this_player())) {
         if (ending) {
            body += "\n";
            ending = 0;
         }
         body += sprintf("\nEnvironment: %s (%s)\n",
                         file_name(environment(this_player())),
                         environment(this_player())->short());
      }
      if (_use_last_error) {
         last_error = (mapping) this_player()->get_last_error();
         if (mapp(last_error)) {
            trace = (string) master()->standard_trace(last_error, 1);
            this_player()->set_last_error(0);
         }
      }
      if (ending) {
         body += "\n";
      }
      name = (string) this_player()->query_name();
      SMART_LOG->smart_log(bing->error, name, body, trace, bing->file);
      printf("Thank you for your %s report.\n", lower_case(_error_type));
   } else {
      printf("Not saving %s report, aborting.\n", lower_case(_error_type));
   }
   map_delete(_globals, this_player());
}
int clean_up()
{
   return 0;
}
void reset()
{
}
mixed *query_patterns()
{
   return ({ "command <string'name'>", (: bug_command($4[0]) :),
             "replies", (: bug_replies(0) :),
             "replies new", (: bug_replies(1) :),
             "web <string'url'>", (: bug_web($4[0]) :),
             "spell <string'name'>", (: bug_spell($4[0]) :),
             "spell {generic|wizards|witches}", (: bug_spell_file("/obj/spells/" + $4[0], $4[0]) :),
             "spell new", (: bug_spell_file("/obj/spells/generic", "generic") :),
             "object new",
             (: bug_object_new("new") :),
             "object name <string'name'>",
             (: bug_object_new($4[0]) :),
             "object <indirect:object:me-here'name of NPC or item'>",
             (: bug_object($1, $4[0]) :),
             "ritual <string'name'>", (: bug_ritual($4[0]) :),
             "ritual generic", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "ritual new", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "help <string'subject'>", (: bug_help($4[0]) :),
             "help", (: bug_help("") :),
             "soul <string'soul command'>", (: bug_command($4[0]) :),
             "soul new", (: bug_soul(0) :),
             "room", (: bug_room() :),
             "special {" +
               implode(filter(get_dir("/d/special/"),
                              (: file_size("/d/special/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_special($4[0]) :),
             "misc {" +
               implode(filter(get_dir("/obj/"),
                              (:  file_size("/obj/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_misc($4[0]) :) });
}

==================================================
FILE: speech.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
#include <cmds/options.h>
#define TP this_player()
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)
#define REPLACEMENTS (["ne1":"anyone",\
                       "u":"you",\
                       "r":"are", \
                       "NE1":"anyone",\
                       "U":"you",\
                       "R":"are", \
                       "ur":"you are",\
                       "teh":"the", \
                       "some1":"someone"])
class message {
   string text;
   string emote;
   string language;
   string type;
   string notify_mess;
   int status;
}
varargs string query_word_type(string str, string def) {
  int i;
  if (!str || strlen(str) < 1)
    return "";
  for (i = strlen(str) - 1; i >= 0 && str[i] == ' '; i--);
  if (i < 0) {
    return "discombobulate";
  }
  switch (str[i]) {
  case '!':
    return "exclaim";
  case '?':
    return "ask";
  default:
    if (def)
      return def;
    else
      return "say";
  }
}
string mangle_tell(string mess, object dest) {
  int i;
  string ret;
  if (!TP || !environment(TP))
    return mess;
  if (environment(TP)->query_property("reverse_tell") &&
      !dest->query_creator() && !TP->query_creator()) {
    for (i = 0; i < strlen(mess); i++)
      ret = mess[i..i] + ret;
    return ret;
  }
  return mess;
}
string drunk_speech(string str) {
  return replace(str, ({ "S", "sh", "r", "rr", "ing", "in'", "x", "xsh",
                           "S", "SH", "R", "RR" }));
}
string de_eight(string arg) {
  object g;
  string replace_num;
  g = (object) TP->query_guild_ob();
  if (g && ((string) g->query_name() == "wizards") && !TP->query_creator()) {
    arg = "@ " + arg + "@";
    replace_num = ({ " seven plus one", " nine minus one",
                       " two to the power of three",
                       " four times two" })[random(4)];
    arg = implode(explode(arg, " eight"), replace_num);
    replace_num = ({ "(7+1)", "(9-1)", "(2^3)", "(4*2)" })[random(4)];
    arg = implode(explode(arg, "8"), replace_num);
    arg = arg[2.. < 2];
  }
  return arg;
}
string fix_shorthand(string mess) {
  string *bits, name, value;
  mixed *tmp;
  int index, i;
  bits = explode(mess, " ");
  foreach(name, value in REPLACEMENTS) {
    tmp = regexp(bits, "(^|[^A-Za-z]+)"+name+"($|[^A-Za-z]+)", 1);
    if(sizeof(tmp)) {
      for(i=0; i<sizeof(tmp); i+=2) {
        index = tmp[i+1]-1;
        bits[index] = replace(bits[index], name, value);
      }
    }
  }
  return implode(bits, " ");
}
void my_mess(string fish, string erk) {
  int bing;
  if (!interactive(TP)) {
    return;
  }
  bing = strlen(fish);
  if (bing > 15) {
    bing = 15;
  }
  efun::tell_object(TP, TP->fix_string(sprintf("%s%s\n", fish, erk),
                                       (int) TP->query_cols(), bing));
}
class message build_message(string arg, mixed target, string word_type) {
  string lang;
  string s1;
  string emotion;
  string word;
  string *langs;
  int i;
  class message mess;
  int done;
  mess = new (class message);
  if (!arg || arg == "" || arg == " ") {
    mess->status = NO_MESSAGE;
    return mess;
  }
  while (!done && (!lang || !emotion)) {
    switch (arg[0]) {
    case '#':
      if(word_type == "tell") {
        done = 1;
        continue;
      }
      if (arg[1] == '\'' && sscanf(arg, "#'%s' %s", lang, arg) == 2)
        continue;
      if (sscanf(arg, "%s %s", lang, arg) == 2) {
        lang = lang[1..];
        langs = LANGUAGE_HAND->query_languages();
        if (member_array(lang, langs) == -1) {
          for (i = 0; i < sizeof(langs); i++) {
            if (TP->query_skill(LANGUAGE_HAND->
                                query_language_spoken_skill(langs[i])) > 1 ||
                TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
              if (langs[i][0..strlen(lang)-1] == lang) {
                lang = langs[i];
              }
            }
          }
        }
      } else {
        done = 1;
      }
      break;
    case '@':
      if (sscanf(arg, "%s %s", emotion, arg) == 2) {
        emotion = emotion[1..] + " ";
      } else {
        done = 1;
      }
      break;
    default:
      done = 1;
    }
  }
  if (!emotion)
    emotion = "";
  if(lang == "general" && interactive(TP) && !TP->query_creator()) {
    mess->status = NOT_KNOWN;
    return mess;
  }
  if(!lang)
    lang = (string) TP->query_current_language();
  mess->language = lang;
  if(!LANGUAGE_HAND->query_language_spoken(lang)) {
    mess->status = NOT_SPOKEN;
    return mess;
  }
  if(word_type == "shout" && !LANGUAGE_HAND->query_language_distance(lang)) {
    mess->status = NOT_DISTANCE;
    return mess;
  }
  if(word_type != "tell" &&
     !TP->query_skill(LANGUAGE_HAND->query_language_spoken_skill(lang)) &&
     !LANGUAGE_HAND->query_language_always_spoken(lang)) {
    mess->status = NOT_KNOWN;
    return mess;
  }
  if (!interactive(TP)) {
    arg = TP->convert_message(arg);
    arg = TP->fit_message(arg);
  }
  arg = replace(arg, ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                            "[D", "", "%^", " " }));
  if(TP->query_property(SHORTHAND_PROP))
    arg = LANGUAGES->fix_shorthand(arg);
  if(word_type != "tell") {
    if(TP->query_volume(D_ALCOHOL))
      arg = drunk_speech(arg);
    s1 = TP->mangle_speech(arg);
    if (stringp(s1))
      arg = s1;
    if(TP && environment(TP) &&
       function_exists("mangle_speech", environment(TP)))
      arg = (string) environment(TP)->mangle_speech(word_type, arg, target);
    arg = de_eight(arg);
  }
  word = query_word_type(arg, word_type);
  mess->text = arg;
  mess->type = word;
  mess->emote = emotion;
  mess->status = MESSAGE_OK;
  if (target)
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$ $target$: ";
  else
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$: ";
  return mess;
}
int say_it(class message mess) {
  string accent;
  if (!environment(TP))
    write("You are in limbo, noone can hear you.\n");
  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  TP->remove_hide_invis("hiding");
  accent = TP->query_nationality_accent_ob();
  TP->comm_event(environment(TP), "person_say",
                 mess->notify_mess, mess->text, mess->language, accent);
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    my_mess("You " + mess->emote + mess->type + " in " +
            capitalize(mess->language) + ": ", mess->text);
  } else {
    my_mess("You " + mess->emote + mess->type + ": ", mess->text);
  }
  TP->adjust_time_left(-5);
  return 1;
}
int say_it_to(class message mess, mixed targets, int priv, string event) {
  string lstr;
  string extra;
  string accent;
  if (!environment(TP)) {
    write("You are in limbo, noone can hear you.\n");
  }
  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  if (!sizeof(targets)) {
    return 0;
  }
  targets -= ({ this_player() });
  TP->remove_hide_invis("hiding");
  this_player()->adjust_time_left(-5);
  accent = TP->query_nationality_accent_ob();
  switch (mess->type) {
  case "exclaim":
  case "whisper":
  case "say":
    extra = "to ";
    break;
  default:
    extra = "";
  }
  switch (priv) {
  case 2:
    break;
  case 1:
    TP->comm_event_to(environment(this_player()), event,
                      (string) this_player()->one_short(1) +
                      " " + mess->emote + mess->type + "s " +
                      extra, mess->text, targets, mess->language,
                      this_player(), accent);
    break;
  case 0:
    TP->comm_event(environment(TP), event,
                   "$one_short:" + file_name(TP) + "$ " + mess->emote +
                   "$V$0=" + mess->type + "s," + mess->type + "$V$ " +
                   extra + query_multiple_short(targets, "the") + ": ",
                   mess->text, mess->language, accent);
    break;
  }
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    lstr = " in " + cap_words(mess->language);
  } else {
    lstr = "";
  }
  write("You " + mess->emote + mess->type + " " + extra +
        query_multiple_short(targets, "the") + lstr + ": " +
        mess->text + "\n");
  return 1;
}

==================================================
FILE: template.c
==================================================

inherit "/cmds/base";
mixed cmd(string args) {
  return 0;
}
string help() {
  return "No help defined for this command, bug a creator about it!\n";
}

==================================================
FILE: theft_base.c
==================================================

#include <thief.h>
#include <obj_parser.h>
#include <player.h>
#define SKILL "covert.manipulation.stealing"
#define PERCEPTION "other.perception"
inherit "/cmds/guild_base";
int query_theft_command() { return 1; }
int victim_checks(object thief, object victim) {
  if(thief == victim)
    return notify_fail("Be serious!\n");
  if(thief->query_property("dead"))
    return notify_fail("Be serious, you're dead!\n");
  if(thief->query_auto_loading())
    return notify_fail("You don't have all your equipment yet..\n");
  if(victim->query_auto_loading())
    return notify_fail( "Be sporting; "+ (string)victim->the_short() +
                        " doesn't have "+ (string)victim->query_possessive() +
                        " equipment yet.\n" );
  if(userp(victim) && !interactive(victim))
    return notify_fail( "You can't " + query_verb() +
                        " from a net dead statue.\n");
  if(victim->query_property("nosteal"))
    return notify_fail("You cannot " + query_verb() + " from " +
                       victim->the_short() + ".\n");
  if(victim->query_sanctuary())
    return notify_fail("You can't snatch from someone who is protected.\n");
  if(pk_check(thief, victim))
    return notify_fail("You feel it would be wrong to " + query_verb() +
                       " from "+ victim->short()+".\n");
  if(victim->query_creator() && !thief->query_creator() ) {
    notify_fail("Stop trying to steal from creators.\n");
    thief->adjust_tmp_dex(-10);
    return 0;
  }
  return 1;
}
mixed get_item(object thief, mixed location, string str) {
  class obj_match result;
  result = (class obj_match)match_objects_in_environments(str, location, 0, thief);
  if(result->result != OBJ_PARSER_SUCCESS)
    return notify_fail("Pssst, they don't have one of those.\n");
  result->objects = filter(result->objects,
                           (: environment($1) == $(location) :));
  if(!sizeof(result->objects))
    return notify_fail("Pssst, they don't have one of those.\n");
  if(sizeof(result->objects) != 1)
    return notify_fail("You can only " + query_verb() +
                       " one thing at a time.\n");
  return result->objects[0];
}
int combat_checks(object thief, object victim) {
  if(thief->query_fighting()) {
    notify_fail("You can't attempt to " + query_verb() +
                " while in battle.\n");
    return 2;
  }
  if(member_array(thief, victim->query_attacker_list()) != -1) {
    notify_fail("You cannot attempt to " + query_verb() + " from someone "
                "that is fighting you.\n");
    return 1;
  }
  return 0;
}
int item_checks(object victim, object item, int wielded_ok, int worn_ok) {
  if(item->query_liquid() && item->query_food_object())
    return notify_fail("You cannot " + query_verb() + " liquids!\n");
  if(item->query_property("nosteal") ||
     (!wielded_ok && item->query_wielded() == victim) ||
     (!worn_ok && item->query_worn_by() == victim))
    return notify_fail("You cannot " + query_verb() + " " +
                       item->the_short() + " from " +
                       victim->the_short() + ".\n");
#ifdef QUOTA_CHECK
  if(!check_player_quota(victim, item))
    return notify_fail("A quick reveals that " + query_verb() + "ing " +
                       item->the_short() + " would exceed " +
                       victim->query_possessive() + "'s theft quota.\n");
#endif
  return 1;
}
int calc_value(object ob) {
  int value;
  object tmp, *inv;
  string name;
  sscanf( file_name( ob ), "%s#%*d", name );
  if( name = "/obj/package" ) {
    value = 0;
  }
  else {
    value = ob->query_value();
  }
  inv = deep_inventory(ob);
  if(sizeof(inv))
    foreach(tmp in inv)
      value += tmp->query_value();
  return value;
}
int check_player_quota(object victim, object ob) {
  object *things, thing;
  int quota, reported, valid, value;
  value = 0;
  things = ({ ob });
  things += deep_inventory(ob);
  foreach(thing in things) {
    if(thing->query_property("money") ) {
      value += thing->query_value_in("Ankh-Morpork");
    } else {
      value += thing->query_value();
    }
  }
  quota = QUOTA->query_player_quota(victim->query_name());
  reported = QUOTA->query_player_reported(victim->query_name());
  valid = QUOTA->query_player_valid(victim->query_name());
  if((quota - (reported + valid)) < value)
    return 0;
  return 1;
}
int steal_item(object thief, object victim, object item) {
  object *stolen;
  string sh;
  if(item->move(thief))
    return notify_fail( "You cannot " + query_verb() + " " +
                        item->the_short()+" from "+
                        (string)victim->the_short() +".\n");
  stolen = ({ item });
  stolen += deep_inventory(item);
  tell_object(thief, "You steal "+query_multiple_short(stolen, "the" )+
              " from "+ victim->the_short() +".\n" );
  if( environment(thief)->query_theft_handler() &&
      regexp(environment(thief)->query_theft_handler(), "/d/am/") &&
        thief->query_name() == "wobin" )
      stolen = THEFT_INSURANCE->check_items(stolen, victim, thief);
  event( environment( thief ), "theft", thief, victim, stolen );
  event( stolen, "theft", thief, victim );
  item->event_ward( thief, victim );
  if(thief->query_property("player") &&
     query_ip_number(thief) == query_ip_number(victim) &&
     sizeof(PLAYER_MULTIPLAYER_HANDLER->check_allowed(thief, ({victim})))) {
    sh = capitalize(thief->query_name())+ " stole " +
      query_multiple_short(stolen) +
      " from " + victim->query_name() + " while logged in from the same IP "
      "address.";
    user_event("inform", sh, "multiplayer");
    sh = victim->convert_message(sh);
    log_file("MULTIPLAYERS", ctime(time()) + ": " + sh + "\n");
  }
  return 1;
}

==================================================
FILE: lord/jumps.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }
   return load_object(str);
}
int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;
   from_ob = find_location(from);
   to_ob = find_location(to);
   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }
   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}
int do_path_list() {
   string str;
   string from;
   string* dest;
   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}
int do_remove_jump(string from, string to) {
   string* dests;
   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}

==================================================
FILE: lord/nskills.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
int new_skill_value(int sk) {
	float f = 1000.0;
	float k = 0.3;
	if(sk == 0)
		return 0;
	return to_int(f * log( 1.0 + sk/(f + sk * k) ) + 0.5);
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      if(tp[0..14] != ".other.language" && tp[0..13] != "other.language") {
        sk = new_skill_value(sk);
      }
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)new_skill_value(pl->query_skill_bonus( tp )) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
int cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );
		 this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
     result += "New guild level: " +
		   (pl->query_guild_ob())->query_new_level(pl) + "\n";
   this_player()->more_string( result, "Skills" );
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}
mixed *query_patterns() {
  return ({ "<indirect:any-living> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:any-living>",
            (: cmd($1, 0) :) });
}

==================================================
FILE: lord/ptest_ers.c
==================================================

#include <player.h>
#define LOGIN "/secure/login"
inherit "/cmds/base";
int main_menu( string cmd, string name, string reason ) {
   string str;
   switch ( cmd[ 0 ] ) {
      case 'L' :
      case 'l' :
         str = PLAYTESTER_HAND->query_show_list();
         str += "\n\nSee: 'ptesters H' for help.\n";
         this_player()->more_string(str, "Playtester");
         return 1;
      case 'A' :
      case 'a' :
         if ( !name ) {
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if (!PLAYTESTER_HAND->valid_playtester( name ) ) {
            printf( capitalize( name ) + " cannot be made a play tester "
                    "because: " + PLAYTESTER_HAND->reason_invalid_playtester(name) +
                    ".\n");
            break;
         }
         if ( (int)PLAYTESTER_HAND->add_playtester( name ) ) {
            printf( capitalize( name ) +" is now a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is already a playtester.\n" );
         }
         break;
      case 'S' :
      case 's' :
         if ( !name ) {
            return 0;
         }
         if ( !PLAYTESTER_HAND->query_playtester( name ) ) {
            printf( capitalize( name ) +" is not yet a playtester.\n" );
         } else {
            if ( (int)PLAYTESTER_HAND->add_senior_playtester( name ) ) {
               printf( capitalize( name ) +" is now a senior playtester.\n" );
            } else {
               printf( capitalize( name ) +" is already a senior playtester.\n" );
            }
         }
         break;
      case 'R' :
      case 'r' :
         if ( !name ) {
            return 0;
         }
         if ( !reason) {
            notify_fail("You need to supply a reason when deleting someone.\n");
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if ( (int)PLAYTESTER_HAND->remove_playtester( name, reason ) ) {
            printf( capitalize( name ) +" is no longer a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is not a playtester.\n" );
         }
         break;
      default :
      case 'H' :
      case 'h' :
      case '?' :
         printf( "\nPlaytesters editor commands:\n\n"
               "Q        : quit the playtester editor\n"
               "L        : list playtesters\n"
               "A <name> : add a new playtester\n"
               "S <name> : promote someone to senior playtester\n"
               "R <name> : remove an existing playtester\n"
               "H        : get this list of commands\n\n" );
         break;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: main_menu("L", 0, 0) :),
             "{l|h|?}", (: main_menu($4[0], 0, 0) :),
             "{a|s|h|r|?} <word>", (: main_menu($4[0], $4[1], 0) :),
             "r <word> <string>", (: main_menu("r", $4[0], $4[1]) :) });
}
