# Total Tokens: 15830
# Total Files Merged: 7
# Total Characters: 52782

==============================================

void create() {
  seteuid(getuid(this_object()));
}
void dest_me() {
  if(this_object())
    destruct(this_object());
}
int clean_up() {
  dest_me();
  return 1;
}
void reset() {
  dest_me();
}

==================================================
FILE: bug_replies.c
==================================================

#include <error_handler.h>
#include <db.h>
#include <nroff.h>
#define HELP_FILE "/doc/helpdir/bug_replies"
class player_data {
   int position;
   int date;
   class error_replies* replys;
}
nosave private mapping _player_replies;
void print_menu_input();
void create() {
   _player_replies = ([ ]);
}
void print_bug_replies(object player) {
   string str;
   class error_replies* replies;
   int i;
   int pos;
   replies = _player_replies[player]->replys;
   if (!sizeof(replies)) {
      tell_object(player, "No bug replies.\n");
      return ;
   }
   pos = _player_replies[player]->position;
   str = "";
   for (i = 0; i < sizeof(replies); i++) {
      if (i == pos) {
         str += ">";
      } else {
         str += " ";
      }
      switch (replies[i]->status) {
      case "NEW" :
         str += "N";
         break;
      case "DELETED" :
         str += "D";
         break;
      default :
         str += " ";
         break;
      }
      str += (i+1) + ") " + replies[i]->sender + " Sub: " +
             replies[i]->subject + "\n";
   }
   player->set_finish_func("finish_more_replies", this_object());
   tell_object(player, "$P$Bug replies$P$" + str);
}
void finish_more_replies() {
   print_menu_input();
}
void print_menu(object player) {
   int len;
   len = sizeof(_player_replies[player]->replys);
   if (len == 0) {
      tell_object(player, "[None] QDRULH?<num>: ");
   } else {
      tell_object(player, "[1-" + len + "] QDRULH?<num>: ");
   }
}
void delete_message(int start_pos, int end_pos) {
   int pos;
   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                           "DELETED",
                                           (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "DELETED";
   }
   if (start_pos != end_pos) {
      write("Delete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Delete error reply " + (pos) + ".\n");
   }
}
void undelete_message(int start_pos, int end_pos) {
   int pos;
   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                        "READ",
                                        (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "READ";
   }
   if (start_pos != end_pos) {
      write("Undelete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Undelete error reply " + (pos) + ".\n");
   }
}
int valid_message(int pos) {
   pos--;
   if (pos < 0 || pos >= sizeof(_player_replies[this_player()]->replys)) {
      return 0;
   }
   return 1;
}
void print_menu_input() {
   print_menu(this_player());
   input_to("bug_replies_menu");
}
void read_message(int pos) {
   class error_replies reply;
   pos--;
   reply = _player_replies[this_player()]->replys[pos];
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string("Date Sent: " + ctime(reply->senddate) + "\n"
         "From: " + reply->sender + "\n"
         "Subject: " + reply->subject + "\n\n" +
         reply->message + "\n");
   if (reply->status == "NEW") {
      ERROR_HANDLER->do_status_error_reply(reply->id, "READ", (: 1 :));
      reply->status = "READ";
   }
}
int read_next_new() {
   int i;
   class error_replies* replies;
   replies = _player_replies[this_player()]->replys;
   for (i = 0; i < sizeof(replies); i++) {
      if (replies[i]->status == "NEW") {
         read_message(i + 1);
         return 1;
      }
   }
   write("No new unread error replies.\n");
   return 0;
}
void finish_editing_message(string mess, int pos) {
   class error_replies reply;
   if (!mess || !strlen(mess)) {
      write("Aborting send of message.\n");
   } else {
      reply = _player_replies[this_player()]->replys[pos];
      ERROR_HANDLER->do_add_error_reply(reply->id,
                             this_player()->query_name(),
                             reply->sender,
                             "Re: " + reply->subject,
                             mess);
      write("Sent message to " + reply->sender + "\n");
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}
int reply_message(int pos) {
   write("Replying to message:\n");
   pos--;
   this_player()->do_edit("", "finish_editing_message", this_object(), 0, pos);
   return 1;
}
void help_command() {
   string nroff_fn;
   string str;
   nroff_fn = HELP_FILE + ".o";
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(HELP_FILE, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string(str);
}
void bug_replies_menu(string inp) {
   int pos;
   int new_pos;
   int end_pos;
   while (strlen(inp) && inp[0] == ' ') {
      inp = inp[1..];
   }
   while (strlen(inp) && inp[<1] == ' ') {
      inp = inp[0..<2];
   }
   end_pos = -1;
   if (!strlen(inp)) {
      if (read_next_new()) {
         return ;
      }
   } else {
      if (inp[0] >= '0' && inp[0] <= '9') {
         while (pos < strlen(inp) && inp[pos] >= '0' && inp[pos] <= '9') {
            pos ++;
         }
         pos = to_int(inp[0..pos-1]);
         if (valid_message(pos)) {
            read_message(pos);
            return ;
         } else {
            write("Message " + pos + " is invalid.\n");
         }
      } else {
         while (pos < strlen(inp) && (inp[pos] < '0' || inp[pos] > '9')) {
            pos++;
         }
         if (pos < strlen(inp)) {
            new_pos = pos + 1;
            while (new_pos < strlen(inp) && inp[new_pos] >= '0' && inp[new_pos] <= '9') {
               new_pos++;
            }
            pos = to_int(inp[pos..new_pos-1]);
            if (inp[new_pos] == '-') {
               end_pos = new_pos + 1;
               while (end_pos < strlen(inp) && inp[end_pos] >= '0' && inp[end_pos] <= '9') {
                  end_pos++;
               }
               end_pos = to_int(inp[new_pos + 1..end_pos-1]);
            }
         } else {
            pos = -1;
         }
         switch(lower_case(inp)[0]) {
         case 'q' :
            write("Exiting the system.\n");
            map_delete(_player_replies, this_player());
            return ;
         case 'r' :
            if (valid_message(pos)) {
               if (reply_message(pos)) {
                  return ;
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'd' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     delete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'u' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     undelete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'h' :
         case '?' :
            help_command();
            return ;
         case 'l' :
            print_bug_replies(this_player());
            return ;
         }
      }
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}
void bug_replies_result(int type, mixed* data, object player) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error retrieving replies.\n");
   } else {
      _player_replies[player] = new(class player_data, date : time(),
                                    replys : data);
      print_bug_replies(player);
   }
}
int bug_replies(int only_new) {
  _player_replies[this_player()] = new(class player_data, date : time(),
                                replys : ({ }));
   if (ERROR_HANDLER->do_error_replies(this_player()->query_name(), only_new,
                             (: bug_replies_result($1, $2, $(this_player()) ) :))) {
      input_to("bug_replies_menu");
      return 1;
   }
   add_failed_mess("Unable to find the bug replies.\n");
   return 0;
}

==================================================
FILE: errors_base.c
==================================================

#include <db.h>
#include <log.h>
#include <config.h>
private class _report {
  int row;
  string newstatus;
  string newdir;
  string newtype;
  int changed;
}
private class _bugs {
  int fd;
  mapping errors;
  int *rows;
  string *fieldnames;
  int changed;
}
#define FD ((class _bugs)globvars[key])->fd
#define ERRORS ((class _bugs)globvars[key])->errors
#define ROWS ((class _bugs)globvars[key])->rows
#define FIELDNAMES ((class _bugs)globvars[key])->fieldnames
#define CHANGED ((class _bugs)globvars[key])->changed
private nosave mapping globvars;
protected varargs mixed get_row(mixed key, int row, int nomap);
protected varargs string init_errors(mixed key, string user, int replace) {
  string ret;
  if (!mapp(globvars)) {
    globvars = ([ ]);
  } else {
    if (!(replace || undefinedp(globvars[key]))) {
      return "key already in use";
    }
    if (globvars[key]) {
      catch(db_close(FD));
    }
  }
  globvars[key] = new(class _bugs);
  if ((ret = catch(FD = db_connect("localhost", "errors", user)))) {
    map_delete(globvars, key);
    return ret;
  }
  return 0;
}
protected string finish_errors(mixed key) {
  string ret;
  if (!classp(globvars[key])) {
    return "unknown key";
  }
  ret = catch(db_close(FD));
  map_delete(globvars, key);
  return ret;
}
protected varargs mixed sql_query(mixed key, string query, mixed *args ...) {
  string error;
  mixed ret;
  ERRORS = 0;
  ROWS = 0;
  FIELDNAMES = 0;
  error = catch(ret = db_exec(FD, query, args ...));
  if (error) {
    return error;
  }
  if (stringp(ret)) {
    return ret;
  }
  if (ret) {
    ROWS = allocate(ret + 1, (: $1 :));
  }
  return ret;
}
protected varargs mixed get_fields(mixed key, string directory,
                                   string fields, string type) {
  string query, temp;
  mixed ret;
  if (!strlen(type)) {
    type = "OPEN";
  }
  ERRORS = 0;
  ROWS = 0;
  FIELDNAMES = 0;
  fields += ", Directory";
  query = sprintf("SELECT %s FROM errors WHERE Directory = '%s' AND "
                  "Status = '%s' ORDER BY DirEntryDate;", fields, directory,
                  type);
  temp = catch(ret = db_exec(FD, query));
  if (temp) {
    return temp;
  }
  if (stringp(ret)) {
    return ret;
  }
  if (ret) {
    ROWS = allocate(ret + 1, (: $1 :));
  }
  return ret;
}
protected mixed get_forwards(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping forwards;
  int fd;
  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  query = sprintf("SELECT ForwardDate, Forwarder, OldDirectory FROM forwards "
                  "WHERE Id = %d ORDER BY ForwardDate;", ret["Id"]);
  err = catch(ret = db_exec(fd, query));
  if (err) {
    catch(db_close(fd));
    return err;
  }
  if (stringp(ret)) {
    catch(db_close(fd));
    return ret;
  }
  if (ret) {
    err = catch {
      int *dates, i;
      string *forwarders, *dirs;
      mixed *vals;
      dates = allocate(ret);
      forwarders = allocate(ret);
      dirs = allocate(ret);
      for (i = 0; i < ret; i++) {
        vals = db_fetch(fd, i + 1);
        dates[i] = vals[0];
        forwarders[i] = vals[1];
        dirs[i] = vals[2];
      }
      forwards = allocate_mapping(3);
      forwards["ForwardDate"] = dates;
      forwards["Forwarder"] = forwarders;
      forwards["OldDirectory"] = dirs;
    };
    if (err) {
      catch(db_close(fd));
      return err;
    }
  }
  catch(db_close(fd));
  return forwards;
}
protected mixed get_comments(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping comments;
  int fd;
  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  query = sprintf("SELECT CommentDate, Commenter, Comment FROM comments "
                  "WHERE Id = %d ORDER BY CommentDate;", ret["Id"]);
  err = catch(ret = db_exec(fd, query));
  if (err) {
    catch(db_close(fd));
    return err;
  }
  if (stringp(ret)) {
    catch(db_close(fd));
    return ret;
  }
  if (ret) {
    err = catch {
      int *dates, i;
      string *commenters, *texts;
      mixed *vals;
      dates = allocate(ret);
      commenters = allocate(ret);
      texts = allocate(ret);
      for (i = 0; i < ret; i++) {
        vals = db_fetch(fd, i + 1);
        dates[i] = vals[0];
        commenters[i] = vals[1];
        texts[i] = vals[2];
      }
      comments = allocate_mapping(3);
      comments["CommentDate"] = dates;
      comments["Commenter"] = commenters;
      comments["Comment"] = texts;
    };
    if (err) {
      catch(db_close(fd));
      return err;
    }
  }
  catch(db_close(fd));
  return comments;
}
protected varargs mixed get_row(mixed key, int row, int nomap) {
  mixed *res;
  string ret, *keys;
  mapping rowvals;
  if (!arrayp(FIELDNAMES)) {
    ret = catch(res = db_fetch(FD, 0));
    if (ret)
      return ret;
    keys = res;
    FIELDNAMES = res;
  } else {
    keys = FIELDNAMES;
  }
  if (!nomap) {
    row = ROWS[row];
  }
  ret = catch(res = db_fetch(FD, row));
  if (ret)
    return ret;
  if (sizeof(keys) != sizeof(res)) {
    return "Database engine lost results(?)\n";
  }
  rowvals = allocate_mapping(keys, res);
  return rowvals;
}
protected int set_status(mixed key, int row, string status) {
  int realrow = ROWS[row];
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  if (!classp(ERRORS[realrow])) {
    ERRORS[realrow] = new(class _report, row : realrow);
  }
  ((class _report)ERRORS[realrow])->newstatus = status;
  ((class _report)ERRORS[realrow])->changed = 1;
  ROWS = delete(ROWS, row, 1);
  CHANGED = 1;
  return 1;
}
protected int set_type(mixed key, int row, string type) {
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  row = ROWS[row];
  if (!classp(ERRORS[row])) {
    ERRORS[row] = new(class _report, row : row);
  }
  ((class _report)ERRORS[row])->newtype = type;
  ((class _report)ERRORS[row])->changed = 1;
  CHANGED = 1;
  return 1;
}
protected int forward_bug(mixed key, int row, string directory) {
  int realrow = ROWS[row];
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  if (!classp(ERRORS[realrow])) {
    ERRORS[realrow] = new(class _report, row : realrow);
  }
  while (directory[<1] == '/') {
    directory = directory[0..<2];
  }
  ((class _report)ERRORS[realrow])->newdir = directory;
  ((class _report)ERRORS[realrow])->changed = 1;
  ROWS = delete(ROWS, row, 1);
  CHANGED = 1;
  return 1;
}
protected string comment_bug(mixed key, int row, string who, string comment) {
  string query, err;
  int fd;
  mixed ret;
  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  comment = db_escape(comment);
  query = sprintf("INSERT LOW_PRIORITY INTO comments VALUES "
                  "(%d, %d, '%s', '%s');",
                  ret["Id"], time(), who, comment);
  err = catch(ret = db_exec(fd, query));
  if (stringp(ret)) {
    err = ret;
  }
  catch(db_close(fd));
  return err;
}
private string save_status(mixed key, int *ids, string user, string status) {
  string query, ret, err;
  mixed res;
  ret = "";
  if (sizeof(ids)) {
    if (sizeof(ids) == 1) {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id = %d;", status,
                      time(), user, ids[0]);
    } else {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id IN (%s);", status,
                      time(), user, implode(ids, (: "" + $1 + ", " + $2 :)));
    }
    err = catch(res = db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  return ret;
}
protected string save_changes(mixed key, string user) {
  class _report *reports, report;
  string query, *queries, ret, err;
  int *ids_fixed, *ids_denied, *ids_fixing, *ids_considering, *ids_open, ftime;
  mixed res, row;
  if (!CHANGED) {
    return 0;
  }
  reports = filter(values(ERRORS), (: ((class _report)$1)->changed :));
  ids_fixed = ids_denied = ids_fixing = ids_considering = ids_open = queries = ({ });
  ret = "";
  foreach (report in reports) {
    row = get_row(key, report->row, 1);
    if (stringp(row)) {
      ret += row;
      continue;
    }
    switch (report->newstatus) {
    case "FIXED":
      ids_fixed += ({ row["Id"] });
      break;
    case "DENIED":
      ids_denied += ({ row["Id"] });
      break;
    case "FIXING":
      ids_fixing += ({ row["Id"] });
      break;
    case "CONSIDERING":
      ids_considering += ({ row["Id"] });
      break;
    case "OPEN":
      ids_open += ({ row["Id"] });
      break;
    case 0:
    case "":
      if (report->newdir) {
        ftime = time();
        query = sprintf("UPDATE LOW_PRIORITY errors SET Directory = '%s', "
                        "DirEntryDate = %d WHERE Id = %d;",
                        report->newdir, ftime, row["Id"]);
        queries += ({ query });
        query = sprintf("INSERT LOW_PRIORITY INTO forwards VALUES "
                        "(%d, %d, '%s', '%s');",
                        row["Id"], ftime, user, row["Directory"]);
        queries += ({ query });
      }
      if (report->newtype) {
        query = sprintf("UPDATE LOW_PRIORITY errors SET Type = '%s' "
                        "WHERE Id = %d;", report->newtype, row["Id"]);
        queries += ({ query });
      }
      break;
    default:
      ret += sprintf("Unknown report status: %s\n", report->newstatus);
      break;
    }
  }
  ret += save_status(key, ids_fixed, user, "FIXED");
  ret += save_status(key, ids_denied, user, "DENIED");
  ret += save_status(key, ids_fixing, user, "FIXING");
  ret += save_status(key, ids_considering, user, "CONSIDERING");
  ret += save_status(key, ids_open, user, "OPEN" );
  foreach (query in queries) {
    err = catch(db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  if (ret == "") {
    ret = 0;
  }
  return ret;
}

==================================================
FILE: errors_base2.c
==================================================

#include <db.h>
#include <log.h>
#include <config.h>
private class report {
  int row;
  string newstatus;
  string newdir;
  string newtype;
  int changed;
}
private class bugs {
  mixed* errors;
  string user;
  int changed;
}
private nosave mapping _globvars;
protected varargs mixed get_row(mixed key, int row, int nomap);
protected varargs string init_errors(mixed key, string user, int replace) {
  string ret;
  if (!mapp(_globvars)) {
    _globvars = ([ ]);
  } else {
    if (!(replace || undefinedp(_globvars[key]))) {
      return "key already in use";
    }
  }
  _globvars[key] = new(class bugs);
  _globvars[key]->user = user;
  _globvars[key]->errors = ([ ]);
  return 0;
}
protected string finish_errors(mixed key) {
  string ret;
  if (!classp(_globvars[key])) {
    return "unknown key";
  }
  map_delete(_globvars, key);
  return ret;
}
void event_finished_get_fields(string key) {
}
private void finished_get_fields(mixed key, int type, mixed* data) {
   _globvars[key]->errors = data;
   event_finished_get_fields(key);
}
protected void get_fields(mixed key, string directory,
                          string fields, string type) {
  string query;
  string temp;
  mixed ret;
  if (!strlen(type)) {
    type = "OPEN";
  }
  _globvars[key]->errors = ({ });
  fields += ", Directory";
  query = sprintf("SELECT %s FROM errors WHERE Directory = '%s' AND "
                  "Status = '%s' ORDER BY DirEntryDate;", fields, directory,
                  type);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_fields($(key), $1, $2) :));
}
void event_finish_get_forwards(mixed key, int row) {
}
protected void finish_get_forwards(mixed key, int row, int type, mixed* data) {
   _globvars[key]->forwards[row] = data;
   event_finish_get_forwards(key, row);
}
protected void get_forwards(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping forwards;
  ret = _globvars[key]->errors[row];
  if (_globvars[key]->forwards[row]) {
     return _globvars[key]->forwards[row];
  }
  query = sprintf("SELECT ForwardDate, Forwarder, OldDirectory FROM forwards "
                  "WHERE Id = %d ORDER BY ForwardDate;", ret["Id"]);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_forwards($(key), $(row),
                                     $1, $2) :));
}
void event_finish_get_comments(mixed key, int row) {
}
protected void finish_get_comments(mixed key, int row, int type, mixed* data) {
   _globvars[key]->comments[row] = data;
   event_finish_get_comments(key, row);
}
protected void get_comments(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping comments;
  int fd;
  ret = _globvars[key]->errors[row];
  if (_globvars[key]->comments[row]) {
     return _globvars[key]->comments[row];
  }
  query = sprintf("SELECT CommentDate, Commenter, Comment FROM comments "
                  "WHERE Id = %d ORDER BY CommentDate;", ret["Id"]);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_comments($(key), $(row),
                                     $1, $2) :));
}
protected void get_row(mixed key, int row) {
  mixed *res;
  string ret, *keys;
  mapping rowvals;
  return _globvars[key]->errors[row];
}
protected int set_status(mixed key, int row, string status) {
  int realrow = ROWS[row];
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newstatus = status;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
}
protected int set_type(mixed key, int row, string type) {
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newtype = status;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
}
protected int forward_bug(mixed key, int row, string directory) {
  int realrow = ROWS[row];
  while (directory[<1] == '/') {
    directory = directory[0..<2];
  }
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newdir = directory;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
}
protected string comment_bug(mixed key, int row, string who, string comment) {
  string query, err;
  int fd;
  mixed ret;
  query = sprintf("INSERT LOW_PRIORITY INTO comments VALUES "
                  "(%d, %d, '%s', '%s');",
                  ret["Id"], time(), who, comment);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query);
  return 0;
}
private string save_status(mixed key, int *ids, string user, string status) {
  string query, ret, err;
  mixed res;
  ret = "";
  if (sizeof(ids)) {
    if (sizeof(ids) == 1) {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id = %d;", status,
                      time(), user, ids[0]);
    } else {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id IN (%s);", status,
                      time(), user, implode(ids, (: "" + $1 + ", " + $2 :)));
    }
    MYSQL_HANDLER->make_sql_request("errors", USER, "", query);
  }
  return ret;
}
protected string save_changes(mixed key, string user) {
  class _report *reports, report;
  string query, *queries, ret, err;
  int *ids_fixed, *ids_denied, *ids_fixing, *ids_considering, *ids_open, ftime;
  mixed res, row;
  if (!CHANGED) {
    return 0;
  }
  reports = filter(values(ERRORS), (: ((class _report)$1)->changed :));
  ids_fixed = ids_denied = ids_fixing = ids_considering = ids_open = queries = ({ });
  ret = "";
  foreach (report in reports) {
    row = get_row(key, report->row, 1);
    if (stringp(row)) {
      ret += row;
      continue;
    }
    switch (report->newstatus) {
    case "FIXED":
      ids_fixed += ({ row["Id"] });
      break;
    case "DENIED":
      ids_denied += ({ row["Id"] });
      break;
    case "FIXING":
      ids_fixing += ({ row["Id"] });
      break;
    case "CONSIDERING":
      ids_considering += ({ row["Id"] });
      break;
    case "OPEN":
      ids_open += ({ row["Id"] });
      break;
    case 0:
    case "":
      if (report->newdir) {
        ftime = time();
        query = sprintf("UPDATE LOW_PRIORITY errors SET Directory = '%s', "
                        "DirEntryDate = %d WHERE Id = %d;",
                        report->newdir, ftime, row["Id"]);
        queries += ({ query });
        query = sprintf("INSERT LOW_PRIORITY INTO forwards VALUES "
                        "(%d, %d, '%s', '%s');",
                        row["Id"], ftime, user, row["Directory"]);
        queries += ({ query });
      }
      if (report->newtype) {
        query = sprintf("UPDATE LOW_PRIORITY errors SET Type = '%s' "
                        "WHERE Id = %d;", report->newtype, row["Id"]);
        queries += ({ query });
      }
      break;
    default:
      ret += sprintf("Unknown report status: %s\n", report->newstatus);
      break;
    }
  }
  ret += save_status(key, ids_fixed, user, "FIXED");
  ret += save_status(key, ids_denied, user, "DENIED");
  ret += save_status(key, ids_fixing, user, "FIXING");
  ret += save_status(key, ids_considering, user, "CONSIDERING");
  ret += save_status(key, ids_open, user, "OPEN" );
  foreach (query in queries) {
    err = catch(db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  if (ret == "") {
    ret = 0;
  }
  return ret;
}

==================================================
FILE: guild_base.c
==================================================

inherit "/cmds/base";
#include <nroff.h>
#include <cmds/guild_base.h>
#define NROFF_SOURCE "/doc/known_command/"
nosave string _nroff_fname;
nosave class teach_skill *_teach_skills;
nosave string _command_name;
nosave string _teach_guild;
void create() {
   _teach_skills = ({ });
}
void set_nroff_file(string str) {
   _nroff_fname = str;
}
string query_nroff_file() {
  return _nroff_fname;
}
private string nroff_file(string name, int html) {
   string nroff_fn;
   string str;
   if (name[0] != '/') {
      name = NROFF_SOURCE + name;
   }
   nroff_fn = NROFF_DIR + replace(name, "/", ".");
   if (html) {
      str = NROFF_HAND->html_file(nroff_fn, 1);
   } else {
      str = NROFF_HAND->cat_file(nroff_fn, 1);
   }
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      if (html) {
         str = NROFF_HAND->html_file(nroff_fn, 0);
      } else {
         str = NROFF_HAND->cat_file(nroff_fn, 0);
      }
   }
   return str;
}
function help_function() {
   if (_nroff_fname) {
      return (: nroff_file(_nroff_fname, 0) :);
   }
   return 0;
}
string help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 0);
   }
   return 0;
}
string query_www_help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 1);
   }
   return 0;
}
void add_teach_skill(string skill, int teach, int learn) {
   class teach_skill bing;
   bing = new(class teach_skill);
   bing->skill = skill;
   bing->teach = teach;
   bing->learn = learn;
   _teach_skills += ({ bing });
}
class teach_skill *query_teach_skills() {
   return _teach_skills;
}
void set_command_name(string name) {
   _command_name = name;
}
string query_command_name() {
   return _command_name;
}
void set_teach_guild(string guild) {
   _teach_guild = guild;
}
string query_teach_guild() {
   return _teach_guild;
}
int can_teach_command(object teacher, object student) {
   class teach_skill bing;
   if (!sizeof(_teach_skills) ||
       !_command_name) {
     return 0;
   }
   foreach (bing in _teach_skills) {
      if (teacher->query_skill(bing->skill) < bing->teach) {
         return -1;
      }
      if (student->query_skill(bing->skill) < bing->learn) {
         return -2;
      }
   }
   if (_teach_guild &&
       student->query_guild_ob() != _teach_guild) {
      return -3;
   }
   return 1;
}
int teach_command(object teacher, object student) {
   int ret;
   ret = can_teach_command(teacher, student);
   if (ret == 1) {
      student->add_known_command(_command_name);
   }
   return ret;
}

==================================================
FILE: position_base.c
==================================================

inherit "/cmds/base";
#include <position.h>
string position;
string up_down;
string position_type;
int query_position_command() {
   return 1;
}
string query_up_down() {
   return up_down;
}
string query_position() {
   return position;
}
string query_position_type() {
   return position_type;
}
void setup_position(string pos, string up, string type) {
   position = pos;
   up_down = up;
   position_type = type;
}
int position(object person, int silent) {
   string pos_type;
   if (person->query_position() == position_type) {
      if (person == this_player()) {
         add_failed_mess("You are already "+position_type+".\n");
      }
      return 0;
   }
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   if (!silent) {
      if (up_down != "") {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position+" " + up_down +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
                      person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$ "  + up_down +
                      " " + pos_type + " " +
                      person->query_position_on_short() + ".\n",
                      ({ person }));
         } else {
            tell_object(person, "You " + position+" " + up_down + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + "," +
                      position+"$V$ " +
                      up_down + ".\n",
                      ({ person }));
         }
      } else {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                             "$V$ " + pos_type + " " +
                             person->query_position_on_short() + ".\n",
               ({ person }));
         } else {
            tell_object(person, "You " + position + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$.\n",
               ({ person }));
         }
      }
   }
   person->set_position(position_type);
   return 1;
}
int position_floor(object person, int silent) {
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   if (person->query_position_on()) {
      if (!silent) {
         if (up_down != "") {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + " " + up_down + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + up_down + ".\n",
                ({ person }));
         } else {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$.\n",
                ({ person }));
         }
      }
      person->set_position(position_type);
      person->set_position_on(0);
      person->set_position_type(0);
      person->set_position_multiple(0);
      return 1;
   }
   return position(person, 0);
}
string *query_position_strings(object person) {
   string bit;
   string bit_other;
   switch (person->query_position_type()) {
      case AT_TYPE :
      case BESIDE_TYPE :
         bit = "move away from";
         bit_other = "moves away from";
         break;
      case ON_TYPE :
      default :
         bit = "get off";
         bit_other = "gets off";
         break;
   }
   return ({ bit, bit_other });
}
int position_object(object *obs, string pos_type, object person) {
   int i;
   int mult;
   string rabbit;
   string *pos_strings;
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   pos_strings = query_position_strings(person);
   for (i = 0; i < sizeof(obs); i++) {
      if (obs[i]->query_property(CAN_POSITION_PROPERTY)) {
         mult = obs[i]->query_property(MULTIPLE_POSITION_PROPERTY);
         if (person->query_position_on()) {
            if (person->query_position_on() == obs[i] &&
                person->query_position_type() == pos_type) {
               if (person->query_position() != position_type) {
                  return position(person, 0);
               }
               if (person == this_player()) {
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
               }
               return 0;
            }
            tell_object(person, "You " + pos_strings[0] + " " +
                person->query_position_on_short() +
                " and " + position + " " + pos_type+" "+
                obs[i]->a_short()+".\n");
            tell_room(environment(person),
                person->one_short() + " " + pos_strings[1] + " " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + pos_type + " " +
                obs[i]->a_short() + ".\n",
                ({ person }));
            person->set_position(position_type);
            person->set_position_on(obs[i]);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
         tell_object(person, "You " + position + " " + pos_type +
                             " " + obs[i]->a_short()+".\n");
         tell_room(environment(person),
                   person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                   "$V$ " + pos_type + " " +
                   obs[i]->a_short() + ".\n",
                   ({ person }));
         person->set_position(position_type);
         person->set_position_on(obs[i]);
         person->set_position_type(pos_type);
         person->set_position_multiple(mult);
         return 1;
      } else  {
         rabbit = obs[i]->query_position_string(position_type);
         if (rabbit) {
            mult = obs[i]->query_position_multiple(position_type);
            if (person->query_position_on()) {
               if (person->query_position_on() == rabbit &&
                   person->query_position_type() == pos_type) {
                  if (person->query_position() != position_type) {
                     return position(person, 0);
                  }
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
                  return 0;
               }
               tell_object(person, "You " + pos_strings[0] +  " " +
                   person->query_position_on_short() +
                   " and " + position + " " + pos_type + " " +
                   rabbit + ".\n");
               tell_room(environment(person),
                         person->one_short() + " " + pos_strings[1] + " " +
                         person->query_position_on_short() +
                         " and $V$0=" + pluralize(position) + ","+position+"$V$ " +
                         pos_type + " " +
                         rabbit + ".\n",
                         ({ person }));
               person->set_position(position_type);
               person->set_position_on(rabbit);
               person->set_position_type(pos_type);
               person->set_position_multiple(mult);
               return 1;
            }
            tell_object(person, "You "+position+" " + pos_type + " " +
                                 rabbit + ".\n");
            tell_room(environment(person),
                person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                      "$V$ "+pos_type + " " +rabbit + ".\n",
                      ({ person }));
            person->set_position(position_type);
            person->set_position_on(rabbit);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
      }
   }
   return 0;
}
mixed *query_patterns() {
   return ({ "", (: position(this_player(), 0) :),
             "on [the] floor", (: position_floor(this_player(), 0) :),
             "{on|at|in|beside} <indirect:object>",
                    (: position_object($1, $4[0], this_player()) :) });
}

==================================================
FILE: report_base.c
==================================================

#include <creator.h>
#include <log.h>
#include <command.h>
#include <spells.h>
#include <user_parser.h>
#include <soul.h>
#include <error_handler.h>
inherit "/cmds/base";
inherit "/cmds/bug_replies";
class errors {
   int type;
   string file;
   string error;
   string extra;
}
#define ROOM_BUG    1
#define OBJECT_BUG  2
#define RITUAL_BUG  3
#define SPELL_BUG   4
#define HELP_BUG    5
#define COMMAND_BUG 6
#define GENERAL_BUG 7
#define WEB_BUG     8
#define SYNONYMS "/doc/SYNONYMS"
int bug_command(string str);
int bug_spell(string str);
int bug_ritual(string str);
int bug_object(object * obj,
               string str);
int bug_help(string str);
int bug_man(string str);
int bug_room();
int bug_general();
int bug_soul(string str);
private nosave mapping _globals;
private nosave string _error_type;
private nosave int _use_last_error;
void create()
{
   bug_replies::create();
   _globals = ([ ]);
}
void set_error_type(string type)
{
   _error_type = type;
}
void set_use_last_error(int error)
{
   _use_last_error = error;
}
int query_use_last_error()
{
   return _use_last_error;
}
int bug_room()
{
   if (environment(this_player())) {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:file_name(environment
             (this_player
              ())));
  } else {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:"/d/mudlib/void");
   }
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_special(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/d/special/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}
int bug_misc(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/obj/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}
int bug_general()
{
   string dir;
   string *bits;
   string file;
   if (!environment(this_player())) {
      dir = "/d/am/fluff";
   } else {
      dir = file_name(environment(this_player()));
   }
   bits = explode(dir, "/");
   if (bits[0] == "d") {
      file = implode(bits[0..1], "/") + "/general";
   } else {
      file = file_name(environment(this_player()));
   }
 _globals[this_player()] = new (class errors, type: GENERAL_BUG, error: "GENERAL " + _error_type, file:file);
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_command(string str)
{
   int i;
   string dir;
   string file;
   string *bits;
   mixed *junk,
    *coms;
   class command cmd;
   class errors bing;
   class command_data cmd_data;
   class command_class cmd_class;
   mapping temp;
   bing = new (class errors);
   coms = ({ });
   junk = actions_defined(this_player(), 0, 12);
   for (i = 0; i < sizeof(junk); i += 2) {
      if (junk[i] == str) {
         coms += ({ junk[i], junk[i + 1][0], junk[i + 1][1] });
      }
   }
   if (sizeof(coms) > 3) {
      return notify_fail("More than one commands with the name \"" + str +
                         "\" found.  Please be more specific.\n");
   }
   if (sizeof(coms)) {
      bing->file = function_exists((string) coms[2], (object) coms[1]);
      if (!(bing->file)) {
         bing->file = base_name((object) coms[1]);
         str += " (protected method, so it might not be in this file)";
      }
   } else {
    cmd = new (class command, verb:str);
      if (CMD_D->HandleStars(cmd) &&
          sizeof((coms = (mixed *) CMD_D->GetPaths(cmd->verb) &
                  (mixed *) this_player()->GetSearchPath()))) {
         bing->file = coms[0] + "/" + cmd->verb;
      } else {
         if ((cmd_class = this_player()->query_parse_command(str))) {
            temp = cmd_class->patterns;
            cmd_data = temp[keys(temp)[0]];
            bing->file = base_name(cmd_data->calls[0]);
         } else {
            if ((coms = SOUL_OBJECT->query_soul_command(str))) {
               bing->file = "/soul/" + str[0..0] + "/" + str;
            } else if (_error_type == "IDEA") {
               dir = file_name(environment(this_player()));
               bits = explode(dir, "/");
               if (bits[0] == "d") {
                  file = implode(bits[0..1], "/") + "/general";
               } else {
                  file = file_name(environment(this_player()));
               }
               bing->file = file;
            } else {
               return notify_fail("Command " + str + " not found.\n");
            }
         }
      }
   }
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_help(string str)
{
   mixed *stuff;
   class errors bing;
   string tmp;
   bing = new (class errors);
   tmp = "/cmds/player/help"->query_synonym(str);
   if (strlen(tmp))
      str = tmp;
   if (str && str != "") {
      stuff = "/cmds/player/help"->query_help_on(str);
      if (!sizeof(stuff)) {
         if (!SOUL_OBJECT->query_soul_command(str)) {
            notify_fail("Could not find the help file '" + str +
                        "'.  If you wish "
                        "to suggest a new command use 'idea help'\n");
            return 0;
         } else {
            bing->file = "/soul/" + str;
         }
      } else {
         sscanf(stuff[0][0], "%*s (%s)", bing->file);
      }
   } else {
     bing->file = "/cmds/player/help";
   }
   bing->error = "HELP " + _error_type + " " + str;
   bing->type = HELP_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_soul(string str)
{
   class errors bing;
   string tmp;
   bing = new (class errors);
   if (str)  {
      tmp = sprintf("/soul/%c/%s.s", str[0], str);
      if (file_size(tmp) < 1)  {
         notify_fail("No such soul command \"" + str + "\".\n");
         return 0;
      }
      else return bug_command(str);
   }
   bing->file = "/soul/ideas";
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_ritual(string str)
{
   mapping junk;
   class errors bing;
   string sname;
   mixed* data;
   string file;
   str = this_player()->expand_nickname(str);
   bing = new (class errors);
   junk = this_player()->query_spells();
   foreach (sname, data in junk) {
      if (lower_case(sname) == lower_case(str)) {
         if (sizeof(data) <= S_OBJECT) {
            file = file_name(environment(this_player()));
         } else {
            file = data[S_OBJECT];
         }
      }
   }
   if (!file) {
      notify_fail("Ritual " + str + " not found.\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = file;
   bing->error = "RITUAL " + _error_type + " " + str;
   bing->type = RITUAL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_web(string url)
{
   class errors bing;
   bing = new (class errors);
   bing->file = "/www/fluff";
   bing->error = "OBJECT " + _error_type + " " + url;
   bing->type = WEB_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit("Url: " + url + "\n\n", "end_of_edit");
   return 1;
}
int bug_spell_file(string file, string name)
{
   class errors bing;
   bing = new (class errors);
   bing->file = file;
   bing->error = "SPELL " + _error_type + " " + name;
   bing->type = SPELL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_spell(string str)
{
   mapping junk;
   string file;
   string sname;
   mixed data;
   if (str == "wizards" || str == "witches") {
      file = "/obj/spells/" + str;
   } else {
      str = this_player()->expand_nickname(str);
      junk = this_player()->query_spells();
      foreach (sname, data in junk) {
         if (lower_case(sname) == lower_case(str) && arrayp(data)) {
            file = data[S_OBJECT];
         }
      }
      if (!file) {
         notify_fail("Spell " + str + " not found.\n");
         map_delete(_globals, this_player());
         return 0;
      }
   }
   bug_spell_file(file, str);
   return 1;
}
int bug_object_new(string name)
{
   string info;
   class errors bing;
   bing = new (class errors);
   bing->file = base_name(environment(this_player()));
   bing->error = "OBJECT " + _error_type + " " + name;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_object(object * obj,
               string str)
{
   string info;
   class errors bing;
   string name;
   string short;
   string* bits;
   bing = new (class errors);
   if (sizeof(obj) > 1) {
      notify_fail("More than one object can be identified with the name " +
                  str + "\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = base_name(obj[0]);
   switch (bing->file) {
   case "/std/room/basic/item":
      bing->file = base_name(environment(this_player()));
      info = sprintf("Room item %s.\n\n", str);
      break;
   case "/std/bit" :
      bing->file = "/std/races/happy_bit";
      break;
   case "/std/book" :
   case "/obj/armour":
   case "/obj/baggage":
   case "/obj/clothing":
   case "/obj/container":
   case "/obj/food":
   case "/obj/monster":
   case "/obj/weapon":
   case "/std/object":
      if (obj[0]->query_property("virtual name")) {
         bing->file = obj[0]->query_property("virtual name");
         info = sprintf("VObject: %s, Object: %s\nName: %s, Short: %s\n\n",
                        obj[0]->query_property("virtual name"),
                        bing->file,
                        obj[0]->query_name(), obj[0]->query_short());
         break;
      } else {
         bing->file = base_name(environment(this_player()));
      }
   default:
      bits = explode(bing->file, "/");
      name = bits[0];
      if (name == "obj" || name == "std") {
         if (sizeof(bits) == 2 ||
             (bits[1] != "food" && bits[1] != "armours" &&
             bits[1] != "weapons" && bits[1] != "amulets" &&
             bits[1] != "monster" && bits[1] != "music" &&
             bits[1] != "plants" && bits[1] != "rings" &&
             bits[1] != "furnitures" && bits[1] != "jewellery" &&
             bits[1] != "wands")) {
            bing->file = base_name(environment(this_player()));
         }
      }
      if (pointerp(obj[0]->query_name()))  {
         name = (obj[0]->query_name())[0];
      } else {
         name = obj[0]->query_name();
      }
      if (!name) {
         name = "<Bad name>";
      }
      short = obj[0]->query_short();
      if (!short) {
         short = "<Bad short>";
      }
      info = sprintf("Name: %s, Short: %s\n\n", name, short);
      break;
   }
   bing->error = "OBJECT " + _error_type + " " + str;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
void end_of_edit(string body)
{
   if (strlen(body)) {
      int ending;
      string name,
        trace = 0;
      mapping last_error;
      class errors bing;
      bing = _globals[this_player()];
      if (bing->extra) {
         body = bing->extra + body;
      }
      if (body[<1] != '\n') {
         ending = 1;
      }
      if (environment(this_player())) {
         if (ending) {
            body += "\n";
            ending = 0;
         }
         body += sprintf("\nEnvironment: %s (%s)\n",
                         file_name(environment(this_player())),
                         environment(this_player())->short());
      }
      if (_use_last_error) {
         last_error = (mapping) this_player()->get_last_error();
         if (mapp(last_error)) {
            trace = (string) master()->standard_trace(last_error, 1);
            this_player()->set_last_error(0);
         }
      }
      if (ending) {
         body += "\n";
      }
      name = (string) this_player()->query_name();
      SMART_LOG->smart_log(bing->error, name, body, trace, bing->file);
      printf("Thank you for your %s report.\n", lower_case(_error_type));
   } else {
      printf("Not saving %s report, aborting.\n", lower_case(_error_type));
   }
   map_delete(_globals, this_player());
}
int clean_up()
{
   return 0;
}
void reset()
{
}
mixed *query_patterns()
{
   return ({ "command <string'name'>", (: bug_command($4[0]) :),
             "replies", (: bug_replies(0) :),
             "replies new", (: bug_replies(1) :),
             "web <string'url'>", (: bug_web($4[0]) :),
             "spell <string'name'>", (: bug_spell($4[0]) :),
             "spell {generic|wizards|witches}", (: bug_spell_file("/obj/spells/" + $4[0], $4[0]) :),
             "spell new", (: bug_spell_file("/obj/spells/generic", "generic") :),
             "object new",
             (: bug_object_new("new") :),
             "object name <string'name'>",
             (: bug_object_new($4[0]) :),
             "object <indirect:object:me-here'name of NPC or item'>",
             (: bug_object($1, $4[0]) :),
             "ritual <string'name'>", (: bug_ritual($4[0]) :),
             "ritual generic", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "ritual new", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "help <string'subject'>", (: bug_help($4[0]) :),
             "help", (: bug_help("") :),
             "soul <string'soul command'>", (: bug_command($4[0]) :),
             "soul new", (: bug_soul(0) :),
             "room", (: bug_room() :),
             "special {" +
               implode(filter(get_dir("/d/special/"),
                              (: file_size("/d/special/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_special($4[0]) :),
             "misc {" +
               implode(filter(get_dir("/obj/"),
                              (:  file_size("/obj/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_misc($4[0]) :) });
}
