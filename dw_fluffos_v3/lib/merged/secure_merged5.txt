# Total Tokens: 21585
# Total Files Merged: 26
# Total Characters: 72021

/diff.c
==================================================

inherit "/cmds/base";
#include <creator.h>
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define FILE files[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, num = 0;
  string last = "";
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});
    foreach(bit in bits){
      mixed *st;
      if (bit[0] == '-'){
        continue;
      }
      bit = this_player()->get_path(bit)[1..];
      if (bit == "")
        return notify_fail("Your wombles just expired.\n");
      if (!master()->valid_read(bit, this_player(), 0))
        return notify_fail("Permission denied: " + bit + " .\n");
      if(sizeof(st = unguarded((:stat, bit:)))){
        if(stringp(st[0]))
          return notify_fail("Can't use diff on directories.\n");
      }
      arg += " " + last;
      last = bit;
      num ++;
    }
  }
  if (num == 2)
    arg += " " + last;
  last = "/" + last;
  if (num > 3)
    return notify_fail("Can't compare more than two files");
  if (num == 3 && file_size(last) > 0)
    return notify_fail("File " + last + " exists.\n");
  fd = external_start(7, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  if (fd == -1)
    return notify_fail("diff failed somehow.\n");
  TP = this_player();
  if (num == 3 && master()->valid_write(last, this_player(), 0))
    FILE = last;
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "diff: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if (FILE)
    write_file(FILE, RET);
  else {
    if(RET == "")
      RET = "those files are the same";
    TP->more_string(RET);
  }
  map_delete(ret, fd);
  map_delete(files, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/du.c
==================================================

#define MAX_FILES 1000
inherit "/cmds/base";
mapping _counts = ([ ]);
protected int rec_du(string path) {
  string *files;
  int i, size, tot;
  if (path[strlen(path)-1] != '/') {
    path += "/";
  }
  files = get_dir(path+"*");
  _counts[this_player()] += sizeof(files);
  for (i=0;i<sizeof(files);i++) {
    if (files[i] == "." || files[i] == "..") {
      continue;
    }
    size = file_size(path+files[i]);
    if (size > 0) {
      tot += size;
    } else if (size == -2 && (_counts[this_player()] < MAX_FILES)) {
      printf("%-30s %5d\n", path+files[i], (size = rec_du(path+files[i])));
      tot += size*1024;
    }
  }
  return (tot+1023)/1024;
}
int cmd( string path ) {
    if ( !path )
        return 0;
    _counts[this_player()] = 0;
    if ( master()->valid_read( path, geteuid( this_player() ) ) ) {
      printf( "%-30s %5d\n", "Total:", rec_du( path ) );
      if(_counts[this_player()] >= MAX_FILES)
        printf("Note: count truncated due to file limit\n");
      return 1;
    }
    add_failed_mess( "You must have read access to a path to use "
                     "du on it.\n" );
    return 0;
}
mixed *query_patterns() {
    return ({ "", (: cmd( this_player()->query_path() ) :),
        "<string'path'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: cmds/creator/dup_licate.c
==================================================

#include <creator.h>
inherit "/cmds/base";
protected int do_duplicate(object *ov) {
   string pname, dummy;
   int i;
   object dup;
   mixed static_arg, dynamic_arg;
   for (i = 0; i < sizeof(ov); i++) {
      if (!ov[i]) {
         continue;
      }
      pname = file_name(ov[i]);
      if (sscanf(pname, "%s#%d", pname, dummy) != 2) {
        write("Can't duplicate " + ov[i]->short() + " (not a clone).\n");
        continue;
      } else {
         static_arg = ov[i]->query_static_auto_load();
         dynamic_arg = ov[i]->query_dynamic_auto_load();
         dup = clone_object(pname);
         if (dup && ov[i]) {
            ov[i] = dup;
            if (static_arg) {
              ov[i]->init_static_arg(copy(static_arg));
            }
            if (dynamic_arg) {
              ov[i]->init_dynamic_arg(copy(dynamic_arg));
            }
         }
         ov[i]->add_property("cloned by", this_player()->query_name());
      }
     if (!ov[i]) {
        printf("I seem to have lost your object.\n");
        return 1;
     }
     if (!ov[i]->move(this_player())) {
       write(ov[i]->short() + " duplicated and put in you.\n");
     } else if (!ov[i]->move(environment(this_player()))) {
       write(ov[i]->short() + " duplicated and put in here.\n");
     } else if (!ov[i]->move("/room/broken")) {
       write(ov[i]->short() + " duplicated and put in /room/broken.\n");
     } else {
       write("Couldn't find anyplace to put " + ov[i]->short() + "!\n");
       ov[i]->move("/room/rubbish");
     }
   }
   return 1;
}
mixed cmd(string str) {
  object *val;
  notify_fail("No such object.\n");
  val = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(val)) {
    notify_fail("No matching objects\n");
    return 0;
  }
  return do_duplicate(val);
}

==================================================
FILE: cmds/creator/ed.c
==================================================

#include <creator.h>
inherit "/cmds/base";
object *people = ({ });
mixed cmd(string str) {
  string *filenames, spam;
  object *things;
  people += ({ this_player() });
  if ( this_player()->query_editor() == "magic" )  {
    if ( !str )  str = " ";
    this_player()->do_edit( 0, "fini_editor", 0, str );
    return 1;
  }
  if (!str) {
    this_player()->set_in_editor("(hidden)");
    ed("frog", "fini_editor");
    return 1;
  }
  if (sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    spam = file_name(things[0]);
    sscanf(spam, "%s#%*d", spam);
    if (file_size(spam) < 0)
      filenames = ({ spam+".c" });
    else
      filenames = ({ spam });
  } else
    filenames = this_player()->get_files(str);
  if (!sizeof(filenames)) {
    str = this_player()->get_path(str);
  } else {
    if (sizeof(filenames) > 0) {
      str = filenames[0];
      if (sizeof(filenames) > 1) {
        int loop;
        loop = 0;
        while(loop < sizeof(filenames) && file_size(filenames[loop]) < 0)
          loop++;
        if(loop >= sizeof(filenames)) {
          printf("No such file.\n");
          people -= ({ this_player() });
          return 0;
        }
        else {
          str = filenames[loop];
        }
        printf("Ambiguous, using : %s\n", str);
      }
    }
  }
  if (file_size(str) == -2) {
    printf("directory\n");
    people -= ({ this_player() });
    return 0;
  }
  this_player()->set_in_editor(str);
  printf("Editing: %s ", str);
  if (!master()->valid_write(str, geteuid(), "frog"))
    printf("[read only]\n");
  else
    printf("\n");
  ed(str, "fini_editor");
  return 1;
}
void fini_editor() {
  if (objectp(this_player()))  {
    people -= ({ this_player() });
    this_player()->set_in_editor(0);
  }
}
int clean_up()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::clean_up();
   }
   return 1;
}
void reset()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::reset();
   }
   return;
}

==================================================
FILE: cmds/creator/exe_c.c
==================================================

#include <cmds/options.h>
inherit "/cmds/base";
#define LOG_FILE "/d/admin/log/EXEC.log"
mixed do_exec(string str, string ref suc) {
  mixed ret;
  string file;
  string wiz_dir;
  string file_header;
  object ob;
  if (!this_player()) {
    suc = "fail";
    return 0;
  }
  wiz_dir = "/w/" + this_player()->query_name();
  if (file_size(wiz_dir) != -2) {
    suc = "fail";
    return notify_fail("Directory: " + wiz_dir + " does not exist.\n");
  }
  file = wiz_dir + "/exec_tmp";
  if (ob = find_object(file)) {
    file->dest_me();
    if(ob)
      destruct(ob);
  }
  if (file_size(file + ".c") > 0) {
    rm(file+".c");
  }
  unguarded((: write_file(LOG_FILE, ctime(time()) + " - " +
                          this_player()->query_name() + ": " + $(str) +
                          "\n") :));
  file_header = this_player()->query_property(OPTION_EXEC_INCLUDE);
  if (file_header) {
     write_file(file + ".c", "#include \"" + file_header + "\"\n\n");
  }
  write_file(file + ".c",
             "void dest_me() { destruct(this_object()); }\n"
             "mixed do_call() {\n" + str + ";\n}\n");
  suc = catch(ret = file->do_call());
  if ((ob = find_object(file))) {
    ob->dest_me();
  }
  rm(file + ".c");
  return ret;
}
int cmd(string str) {
  string err;
  mixed ret = do_exec(str, ref err);
  if (err == "fail")
    return 0;
  if (err == 0) {
    this_player()->more_string(sprintf("\nReturns: %O\n", ret),
                               "Exec results");
  } else {
    printf("Exec failed: %s", err);
  }
  return 1;
}

==================================================
FILE: cmds/creator/find.c
==================================================

#include <creator.h>
#define WIZ WIZ_PRESENT
#define EXTRACT_CODE 1
#define LINE_NUMBERS 2
#define FIND_ALL 4
inherit "/cmds/base";
int file_exists(string str) { return (file_size(str) > -1); }
mixed cmd(string str) {
  string func, thing, s, ping;
  object *obs, fish, user = this_player();
  object *list;
  mixed *fnd;
  int i, flags;
  int k;
  notify_fail("Usage: find [-a] [-d] [-n] function() <object(s)>\n");
  if (!str)
     return 0;
  while (sscanf(str, "-%s %s", s, str) == 2)
    switch (s) {
    case "d":
        flags |= EXTRACT_CODE;
        flags &= ~FIND_ALL;
        break;
    case "n":
        flags |= (LINE_NUMBERS | EXTRACT_CODE);
        flags &= ~FIND_ALL;
        break;
    case "a":
        flags = FIND_ALL;
        break;
      default:
        return notify_fail("Unknown option '"+ s +"'.\n");
    }
  if (sscanf(str, "%s() %s", func, thing) != 2)
     if(sscanf(str, "%s %s", func, thing) != 2)
        return 0;
  obs = WIZ -> wiz_present(thing, user);
  if (!sizeof(obs))
    return notify_fail("Can't find " + thing + ".\n");
  s = "";
  fnd = ({ });
  for (i = 0; i < sizeof(obs); i++) {
     if (flags & FIND_ALL)
        list = ({ obs[i] }) + map(deep_inherit_list(obs[i]),
               (: find_object($1) :));
     else list = ({ obs[i] });
     for (k = 0; k < sizeof(list); k++)  {
        if ((ping = function_exists(func, list[k], 1))  &&
            member_array(ping, fnd) == -1)
        {
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() found in " + ping + "\n";
           fnd += ({ func, ping });
        } else if (!(flags & FIND_ALL))
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() not found.\n";
        fish = list[k];
        while (fish = shadow(fish, 0))
           if (function_exists(func, fish, 1)) {
              s += "      Shadowed by " + file_name(fish) + "\n";
              fnd += ({ func, base_name(fish) });
           }
     }
  }
  if ((flags & FIND_ALL)  &&  !sizeof(fnd))
     s += "*** " + func + "() not found.\n";
  if ((flags & EXTRACT_CODE) && sizeof(fnd)) {
    if (sizeof(fnd) > 2)
      s += "Can only extract code from one object at a time.\n";
    else {
      mixed tmp;
      int j = 0;
      int startline;
      ping = fnd[1] +".c";
      func = fnd[0];
      i = 0;
      if (!file_exists(ping))
        return notify_fail("The file for "+ thing +" doesn't exist.\n");
      tmp = read_file(ping);
      if(!strlen(tmp))
        return notify_fail("Could not read file.\n");
      tmp = reg_assoc(tmp,  ({"\n[a-z_ \t]*[\\* ][ \t]*" + func +
                    "[ \t]*\\([a-zA-Z0-9, _\\*\n\t]*(...)?[ \t]*\\)[ \t\n]*{"
                                , "\n}"})
                      , ({1, 2}));
      while(tmp[1][j] != 1)
        j++;
      if(flags & LINE_NUMBERS){
        startline = sizeof(explode(implode(tmp[0][0..j], ""), "\n"));
      }
      j++;
      while(tmp[0][j][i] != '\n'){
        if(tmp[0][j][i] == '}'){
          tmp = tmp[0][j - 1][1..] + tmp[0][j][0..i];
          if(flags & LINE_NUMBERS)
            tmp = implode(explode(tmp, "\n"),
                           (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                           ({startline, ""}))[1];
          user->more_string(sprintf("%s%s", s, tmp), 0, 1);
          return 1;
        }
        i++;
      }
      tmp = implode(tmp[0][j-1..j+1], "");
      if(flags & LINE_NUMBERS)
        tmp = implode(explode(tmp, "\n"),
                      (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                      ({startline, ""}))[1];
      s += tmp;
    }
  }
  user->more_string(s, 0, 1);
  return 1;
}

==================================================
FILE: cmds/creator/finde_rrors.c
==================================================

#include <log.h>
#include <board.h>
#include <mail.h>
inherit "/cmds/base";
#define HELPER "/obj/handlers/finderror_helper"
#define ERROR_CMD "/cmds/creator/errors"
private void finished_count_errors( object player, int status, mixed data ) {
    int *count;
    string *paths;
    mapping errors = ([ ]);
    int *total = ({ 0, 0, 0 });
    string txt;
    foreach( mapping direc in data ) {
        count = errors[ direc[ "Directory" ] ];
        if ( undefinedp( count ) ) {
            count = ({ 0, 0, 0 });
        }
        switch( direc[ "Type" ] ) {
            case "BUG":
                count[ 0 ] = direc[ "COUNT(Id)" ];
                total[ 0 ] += count[ 0 ];
            break;
            case "TYPO":
                count[ 1 ] = direc[ "COUNT(Id)" ];
                total[ 1 ] += count[ 1 ];
            break;
            case "IDEA":
            default:
                count[ 2 ] = direc[ "COUNT(Id)" ];
                total[ 2 ] += count[ 2 ];
        }
        errors[ direc[ "Directory" ] ] = count;
    }
    paths = sort_array( keys( errors ), 1 );
    txt = "$P$finderrors$P$BUGS TYPO IDEA\n";
    foreach( string key in paths ) {
        txt += sprintf( "%4d %4d %4d %s\n", errors[ key ][ 0 ],
            errors[ key ][ 1 ], errors[ key ][ 2 ], key );
    }
    txt += "-------------\n";
    txt += sprintf( "%4d %4d %4d\n",
        total[ 0 ], total[ 1 ], total[ 2 ] );
    tell_object( player, txt );
}
private int count_errors() {
    int result;
    result = HELPER->query_dirs_count( this_player(),
        (: finished_count_errors :) );
    if ( result ) {
        add_succeeded_mess( ({ "Retrieving error count, this may take several "
            "seconds.\n", "" }) );
        return 1;
    }
    add_failed_mess(  "You have no finderrors directories defined.  "
        "Add them with 'finderrors add'\n" );
    return -1;
}
private void finished_next_dir( object player, int status, mixed data ) {
    if ( sizeof( data ) != 1 || !mapp( data[0] ) ) {
        tell_object( player, "Unable to find the next directory "
            "with errors.\n" );
    }
    else {
        ERROR_CMD->errors_in_dir(data[0]["Directory"], 0);
    }
}
private int get_next_error() {
    HELPER->query_next_dir( this_player(), (: finished_next_dir :) );
    add_succeeded_mess( ({ "Retrieving error count, this may take several "
        "seconds.\n", "" }) );
    return 1;
}
private int list_error_directories() {
    string *dirs;
    dirs = HELPER->query_directories( this_player()->query_name() );
    if ( sizeof( dirs ) ) {
        tell_object( this_player(), "$P$finderrors list$P$" +
            implode( dirs, "\n" ) + "\n" );
        add_succeeded_mess( "" );
        return 1;
    }
    else {
        add_failed_mess( "No directories have been added to finderrors.\n" );
        return -1;
    }
}
private int add_directory( string directory, int recursive ) {
    if ( directory[ <1 ] != '/' ) {
        directory += "/";
    }
    if ( file_size( directory ) != -2 ) {
        add_failed_mess( directory + " is not a directory.\n" );
        return -1;
    }
    HELPER->add_directory( this_player(), directory, recursive );
    return 1;
}
private int remove_directory( string directory, int recursive ) {
    int result;
    result = HELPER->remove_directory( this_player(), directory, recursive );
    if ( result ) {
        add_succeeded_mess( "Directory removed successfully.\n" );
        return 1;
    }
    add_failed_mess( "Could not remove directory.  Was it on your "
        "finderrors list?\n" );
    return -1;
}
public mixed *query_patterns() {
    return ({
              "add <word>", (: add_directory( $4[ 0 ], 0 ) :),
              "add <word> recursive", (: add_directory( $4[ 0 ], 1 ) :),
              "remove <word>", (: remove_directory( $4[ 0 ], 0 ) :),
              "remove <word> recursive", (: remove_directory( $4[ 0 ], 1 ) :),
              "list", (: list_error_directories :),
              "count", (: count_errors :),
              "", (: get_next_error :) });
}

==================================================
FILE: cmds/creator/gr_ep.c
==================================================

inherit "/cmds/base";
#include <creator.h>
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
string *check_perms(string *done, string file){
  mixed perm=master()->valid_read(file, this_player()->query_name(), "cat");
  if(!perm)
    return done;
  if(intp(perm))
    perm = file;
  return done + ({perm});
}
mixed cmd(string arg) {
  int fd, search = 0, nfiles = 0;
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});
    foreach(bit in bits){
      string *files, file;
      if (bit[0] == '-'){
        if( ( bit == "-r" || bit == "--recursive" || bit== "-d=recurse" ||
       bit == "--directories=recurse" || bit == "-recursive" ||
        bit == "-directories=recurse" ) && !this_player()->query_lord() )
          continue;
        arg += (" " + bit);
        continue;
      }
      if(!search){
        search = 1;
        arg += (" " + bit);
      } else {
        files = this_player()->get_files(bit);
        files = implode(files, (:check_perms:), ({}));
        foreach(file in files){
          arg += (" " + file[1..]);
          nfiles++;
        }
      }
    }
  }
  if(nfiles || !search)
    fd = external_start(6, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  else
    return notify_fail("Grep needs at least one file.\n");
  if (fd == -1)
    return notify_fail("grep failed somehow.\n");
  TP = this_player();
  RET = "";
  write("grep started.\n");
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "grep: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "grep finished.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/harass.c
==================================================

string info = "";
mapping busy = ([]);
void create(){
  seteuid("Root");
}
void receive_snoop(string bing){
  info += bing;
}
string query_result(){ return info; }
void remind(){
  if(busy[this_player()]){
    write("Type harass again to stop logging.\n");
    call_out((:remind:), 60);
  }
}
mixed *query_patterns(){
  return ({"", function(){
      if(busy[this_player()]){
        string result = busy[this_player()]->query_result();
        unguarded((:write_file,sprintf("/d/liaison/secure/harass/%s%d",
                                       this_player()->query_name(), time()),
                   $(result):));
        destruct(busy[this_player()]);
        map_delete(busy, this_player());
        write("Log written.\n");
        return 1;
      } else {
        busy[this_player()] = clone_object(__FILE__);
        if(efun::snoop(busy[this_player()], this_player())){
          write("Started logging.\nType harass again to stop.\n");
          call_out((:remind:), 60);
          return 1;
        } else {
          destruct(busy[this_player()]);
          map_delete(busy, this_player());
          write("Failed.\n");
          return 1;
        }
      }
    }
  });
}

==================================================
FILE: cmds/creator/indent.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 4
mapping globals = ([]), ret = ([]), cmds = ([]);
#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
mixed cmd(string arg) {
  int nfiles = 0;
  int fd;
  string bit;
  string *bits;
  object *things;
  if (!arg) {
    return notify_fail("rcsin: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  foreach(bit in bits) {
    string files = "", file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0) {
          file += ".c";
        }
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcsin: no such file "+arg+".\n");
  }
  fd = external_start(CMD_NUM, explode(arg, " "),
                      "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff;
  int i;
  if (RET != "") {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  <--  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0..2] == "ci:") {
          i += 2;
      }
      else {
          i += 3;
      }
    }
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/lo_ad.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string *filenames, err, fname, *failed, *succ, ret, load_err;
  int size;
  if (!str) {
    return notify_fail("Load what?\n");
  }
  filenames = this_player()->get_cfiles(str);
  if (!sizeof(filenames)) {
    return notify_fail("No such object.\n");
  }
  failed = succ = ({ });
  load_err = "";
  foreach (fname in filenames) {
    if (file_size(fname) < 0) {
      failed += ({ fname });
      continue;
    }
    if ((err = catch(fname->load_up_with_yellow()))) {
      load_err += sprintf("Failed to load %s, error: %s", fname, err);
    } else {
      succ += ({ fname });
    }
  }
  ret = "";
  if ((size = sizeof(failed))) {
    ret += sprintf("%s %s not %sregular file%s.\n",
                   query_multiple_short(failed), (size == 1 ? "is" : "are"),
                   (size == 1 ? "a " : ""), (size == 1 ? "" : "s"));
  }
  if (strlen(load_err)) {
    ret += load_err;
  }
  if (sizeof(succ)) {
    ret += sprintf("$I$5=$C$Loaded %s.\n", query_multiple_short(succ));
  }
  this_player()->show_message("$P$Load$P$" + ret);
  return 1;
}

==================================================
FILE: cmds/creator/locks.c
==================================================

#include <creator.h>
int cmd(string){
  string *bits, rcspath, *files, path, tmp;
  files = get_dir(this_player()->query_current_path()+"/");
  write("locked files in this directory:\n");
  foreach(path in files) {
    path = this_player()->query_current_path() + "/" + path;
    bits = explode(path, "/");
    if(sizeof(bits) > 2) {
      rcspath = "/" + implode(bits[0..sizeof(bits)-2], "/") + "/RCS/";
    } else if(sizeof(bits) == 2) {
      rcspath = "/" + bits[0] + "/RCS/";
    } else
      rcspath = "/";
    rcspath += bits[sizeof(bits)-1] + ",v";
    if(file_size(rcspath) > 0) {
      tmp = read_file(rcspath, 4, 1);
      if(tmp == "locks\n") {
        string lockname ;
        tmp = read_file(rcspath, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        printf("%s locked by %s\n", path, lockname);
      }
    }
  }
  return 1;
}
string help() {
  return "Displays the files that are locked in your current directory.";
}

==================================================
FILE: cmds/creator/ls.c
==================================================

#include <ls.h>
#include <autodoc.h>
inherit "/cmds/base";
#define CREATOR (master()->author_file(sprintf("%s/%s", str, direc[i][0]))? \
                master()->author_file(sprintf("%s/%s", str, direc[i][0])): \
                "Root")
#define DOMAIN  (master()->domain_file(sprintf("%s/%s", str, direc[i][0]))? \
                master()->domain_file(sprintf("%s/%s", str, direc[i][0])): \
                "Root")
#define CREATOR_D (master()->author_file(sprintf("%s/%s/.", str, direc[i][0]))? \
                master()->author_file(sprintf("%s/%s/.", str, direc[i][0])): \
                "Root")
#define DOMAIN_D (master()->domain_file(sprintf("%s/%s/.", str, direc[i][0]))? \
                master()->domain_file(sprintf("%s/%s/.", str, direc[i][0])): \
                "Root")
int ls(string str, int mask);
int check_dots(mixed arg);
mixed cmd(string str) {
  string *bits, path;
  int mask, i;
  mask = (MASK_C|MASK_F);
  if (str) {
      if ( this_player()->query_property( LS_COMMAND_NICKNAME_PROPERTY ) ) {
         str = this_player()->expand_nickname( str );
      }
    bits = explode(str, " ") - ({"", 0});
    while (sizeof(bits) && bits[0][0] == '-') {
      i = strlen(bits[0]);
      while (i--) {
        if (bits[0][i] == '-') continue;
        switch (bits[0][i]) {
        case 't':
          mask |= MASK_T;
          break;
        case 'l':
          mask |= MASK_L;
          break;
        case 'C':
          mask |= MASK_C;
          break;
        case 'a':
          mask |= MASK_A;
          break;
        case 'd':
          mask |= MASK_D;
          break;
        case 'o':
          mask |= MASK_O;
          break;
        case 'F':
          mask |= MASK_F;
          break;
        case '1':
          mask &= ~MASK_C;
          break;
        case 'v':
          write("ls version 2.6 (c) 1995-1998 Turrican@Discworld\n");
          return 1;
        case 'h':
          printf("Usage: ls [OPTION]... [PATH]...\n\n"
                 "  -a      do not hide entries \"..\" and \".\"\n"
                 "  -d      list directory entries instead of contents\n"
                 "  -h      display this help and exit\n"
                 "  -l      use a long listing format\n"
                 "  -o      colorize entries according to type\n"
                 "  -v      print version information and exit\n"
                 "  -C      list entries by columns\n"
                 "  -F      append a character to entries according to type\n"
                 "  -1      list one file per line\n"
                 "  -t      sort by date\n"
            );
          return 1;
        default :
          printf("Unknown option -%c\nTry `ls -h' for more information.\n",
                 bits[0][i]);
          return 1;
        }
      }
      bits = delete(bits, 0, 1);
    }
    str = implode(bits, " ");
  }
  if (!str) {
    path = this_player()->query_path();
  } else {
    path = this_player()->get_path(str);
  }
  if (!path) {
    return notify_fail("No current directory.\n");
  }
  if (master()->valid_read(path+"/", geteuid(this_player()), "get_dir")) {
    ls(path, mask);
  } else {
    return notify_fail("$I$0=ls: "+ str + ": Permission denied.\n");
  }
  return 1;
}
string dir_entry(string path, string name, int size, int mask) {
  string tmp;
  tmp = "";
  if(size == -2) {
    if(mask & MASK_F)
      name += "/";
    return "   - " + name;
  }
  if (find_object(path+name)) {
    if (mask & MASK_F) {
      tmp += "*";
    }
  }
  if ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path + name)) {
    tmp += "@";
  }
  name += tmp;
  size = (size / 1024) + 1;
  if (size < 1000) {
    return "    "[0..3-strlen(size+"")]+size+" "+name;
  }
  return size + " "+name;
}
int ls(string str, int mask) {
  string *bit, *bing, bong, path;
  int i, j, k, size;
  mixed *direc;
  path = str;
  if (file_size(str) == -2 && str[strlen(str)-1] != '/' &&
      !(mask & MASK_D)) {
    path += "/";
  }
  if (mask & MASK_A) {
    path += "*";
  }
  direc = get_dir(path, -1);
  if(arrayp(direc)) {
    if (!(mask & MASK_A)) {
      direc = filter(direc, (: check_dots($1) :));
    }
  }
  if (!direc) {
    printf("No files.\n");
    return 0;
  }
  if (!sizeof(direc)) {
    if (file_size(str) == -2) {
      printf("No files.\n");
    } else {
      printf("ls: %s: No such file or directory.\n", str);
    }
    return 0;
  }
  if (file_size(path) == -2) {
    if (path[strlen(path)-1] != '/') {
      path += "/";
    }
  } else {
    bit = explode(path, "/");
    bit = bit[0..sizeof(bit)-2];
    path = "/"+implode(bit,"/")+"/";
  }
  if(path == "
    path = "/";
  bing = allocate(sizeof(direc));
  j = sizeof(direc);
  if (!(mask & MASK_C) && !(mask & MASK_L)) {
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    if (!(mask & MASK_F) && !(mask & MASK_O)) {
      bong = sprintf("%-=*s\n", this_player()->query_cols(),
        implode(direc, "\n"));
      bing = explode(bong, "\n");
    } else for (i=0; i < j; i++) {
      if (direc[i][1] == -2 || direc[i][0] == "..") {
        if (mask & MASK_O) {
          bing[i] = sprintf("%s%-=*s", "%^GREEN%^",
            (int)this_player()->query_cols()+8, direc[i][0]+"%^RESET%^"+
            (mask & MASK_F?"/":""));
        } else  {
          bing[i] = sprintf("%-=*s", this_player()->query_cols(),
            direc[i][0]+"/");
        }
      } else if (find_object(path+direc[i][0])) {
        if (mask & MASK_O) {
          bing[i] = sprintf("%s%-=*s", "%^MAGENTA%^",
            (int)this_player()->query_cols()-1, direc[i][0]+"%^RESET%^"+
            (mask & MASK_F?"*":"")+
            ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
             ?"@":""));
        } else {
          bing[i] = sprintf("%-=*s", this_player()->query_cols(),
            direc[i][0]+"*"+
            ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
             ?"@":""));
        }
      } else {
        bing[i] = sprintf("%-=*s", this_player()->query_cols(), direc[i][0]+
          ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
           ?"@":""));
      }
    }
    bong = implode(bing, "\n");
  } else if (!(mask & MASK_L)) {
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    j = sizeof(direc);
    for(i=0; i<j; i++)
      bing[i] = dir_entry(path, direc[i][0], direc[i][1],mask)+"\n";
    bong = sprintf( "%#-*s\n", this_player()->query_cols(),
                    implode(bing, ""));
    if (mask & MASK_O) {
      i = j;
      while (i--) {
        if (direc[i][1] == -2 || direc[i][0] == "..") {
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s%s", "%^GREEN%^", direc[i][0], "%^RESET%^"));
        } else if (find_object(path+direc[i][0])) {
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s%s", "%^MAGENTA%^", direc[i][0], "%^RESET%^"));
        } else {
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s", "%^RESET%^", direc[i][0]));
        }
      }
    }
  } else {
    string tmp, tmp2;
    mixed *stats;
    int *count, current_time;
    if ( file_size( str ) == -2 && !(mask & MASK_D)) {
        if ( str[ strlen( str ) - 1 ] == '/' ) {
            str += "*";
        } else {
            str += "
    direc = get_dir( str, -1 );
    if (!(mask & MASK_A)) {
      direc = filter_array(direc, (: check_dots($1) :));
    }
    if (!direc || !(size = sizeof(direc))) {
        return 0;
    }
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    bit = allocate(size);
    count = allocate(size);
    i = strsrch(str, '/', -1);
    if (i >= 0) {
        str = str[0..i];
    }
    current_time = time();
    for (i = 0; i < size; i++) {
      reset_eval_cost();
      tmp2 = ctime((direc[i])[2]);
      if ((direc[i])[2] + (6 * 30 * 24 * 60 * 60) < current_time ||
          (direc[i])[2] - ( 60 * 60) > current_time ) {
        tmp = sprintf("%s  %s", tmp2[4..9], tmp2[20..23]);
      } else {
        tmp = tmp2[4..15];
      }
      j = (direc[i])[1];
      if (j == -2) {
        count[i] = 1;
        bit[i] = sprintf("%-=*s", (this_player()->query_cols()+
          (mask & MASK_O?17:0)),
          sprintf("drwxr%cx%c%c%c %3d %-11.11s %-11.11s      0 %12s %s%s%s%s",
          (master()->valid_write(sprintf("%s%s/fl.uff",str,direc[i][0]),
          DOMAIN_D, "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s%s/fl.uff",str,direc[i][0]),
          "NOBODY", "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'x':'-'),
          0+(direc[i][0] == ".." &&
          str == "/"?2:0),
          CREATOR_D, DOMAIN_D, tmp, (mask & MASK_O?"%^GREEN%^":""),
          (direc[i])[0], (mask & MASK_O?"%^RESET%^":""),
          (mask & MASK_F?"/":"")));
      } else {
        count[i] = 0;
        stats = stat(str + (direc[i])[0]);
        bit[i] = sprintf("%-=*s", (this_player()->query_cols()+
          ((mask & MASK_O) && (k = sizeof(stats)) > 1 && stats[2]?19:0)),
          sprintf("-rw%c%c%c-%c%c-   1 %-11.11s %-11.11s %6d %12s %s%s%s%s%s",
          k > 1 && stats[2] ? 'x' : '-',
          (master()->valid_read(sprintf("%s/%s",str,direc[i][0]),
          DOMAIN, "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s/%s",str,direc[i][0]),
          DOMAIN, "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s/%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s/%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'w':'-'),
          CREATOR, DOMAIN, j, tmp,
          ((mask & MASK_O) && k > 1 && stats[2]?"%^MAGENTA%^":""),
          (direc[i])[0], ((mask & MASK_O) && k > 1 &&
          stats[2]?"%^RESET%^":""),
          (k > 1 && stats[2] && (mask & MASK_F)?"*":""),
          ((mask & MASK_F) &&
           AUTODOC_HANDLER->is_autodoc_file(str + direc[i][0])?"@":"")));
      }
      bong = implode(bit, "\n");
    }
  }
  this_player()->more_string( bong, str, 1 );
}
int check_dots(mixed arg) {
  return arg[0][0] != '.';
}
int is_dir(mixed arg, string path) {
  return (file_size(this_player()->get_path(sprintf("%s/%s", path, arg)))
          == -2);
}

==================================================
FILE: cmds/creator/mylocks.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd(string person)  {
   string *locked;
   string who_string;
   if(person == "verify") {
     locked = RCS_HANDLER->query_locks( this_player() );
     locked = sort_array( locked, 1 );
     call_out("verify_lock", 1, this_player(), locked);
     write("Verifying\n");
     return 1;
   }
   if (!person  ||  file_size(person) == -2)  {
      who_string = "You have ";
      locked = RCS_HANDLER->query_locks( this_player() );
      if (person)
         locked = filter(locked, (: strsrch($1, $(person)) == 0 :));
   }
   else  {
      who_string = capitalize( person ) + " has ";
      locked = RCS_HANDLER->query_locks( person );
   }
   if ( !sizeof( locked ) ) {
      add_failed_mess( who_string + "no files locked.\n" );
      return -1;
   }
   locked = sort_array( locked, 1 );
   write( who_string + "the following files locked:\n" +
     implode(locked, "\n") + "\n");
   return 1;
}
void verify_lock(object pl, string *locks) {
  string file, lockline, *bits;
  int remove;
  file = locks[0];
  bits = explode(file, "/");
  file = "/" + (string)implode(bits[0..<2], "/") + "/RCS/" + bits[<1] + ",v";
  if(file_size(file) < 0)
    remove = 1;
  else {
    lockline = read_file(file, 4, 1);
    if (strsrch(lockline, "locks; strict:") == -1) {
      bits = explode(read_file(file, 5, 1), ":");
      if(bits[0][0] != '\t')
        remove = 1;
    }
  }
  if(remove) {
    tell_object(pl, "Removing non-existant lock for " + locks[0] + "\n");
    RCS_HANDLER->remove_lock(pl->query_name(), locks[0]);
  }
  if(sizeof(locks) > 1)
    call_out("verify_lock", 1, this_player(), locks[1..]);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
     "<string'creator|directory|verify'>", (: cmd($4[0] ) :) });
}

==================================================
FILE: cmds/creator/printe_rrors.c
==================================================

#include <log.h>
#include <board.h>
#include <error_handler.h>
#include <db.h>
inherit "/cmds/base";
void finish_details(string player, int result, mixed results);
int cmd(string str) {
  string player, ret;
  class error_query query;
  if (str) {
    if (str[0] != '/')  {
      str = this_player()->query_path() + "/" + str;
    }
    if (str[<1] == '0') {
      str = str[0..<2];
    }
    if (str[<1] == '/') {
      str = str[0..<2];
    }
    player = this_player()->query_name();
    write_file("/w/" + player + "/print_errors.txt", "", 1);
    write("%^YELLOW%^Starting to collect bugreports, this may take a "
          "while.%^RESET%^\n");
    query = new(class error_query);
    query->recursive = 1;
    query->dir = str;
    query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                       ERROR_STATUS_FIXING });
    ERROR_HANDLER->do_query_multiple_bug_details(query,
                  (: finish_details($(player), $1, $2) :));
    return 1;
  } else
    return notify_fail("Usage:\nprinterrors <path>\n note that this will "
                       "overwrite any previous print_errors.txt file\n");
}
protected string get_bug(class error_complete complete) {
  string ret;
  class error_details error;
  class error_forward forward;
  class error_comment comment;
  error = complete->details;
  ret = sprintf("%s %s %s\n", error->summary->category,
                              error->summary->type, error->summary->status);
  ret += sprintf("Filename       : %s\n", error->summary->filename);
  ret += sprintf("Directory      : %s\n", error->summary->directory);
  ret += sprintf("Made by        : %s\n", capitalize(error->summary->reporter));
  ret += sprintf("at             : %s\n\n", ctime(error->summary->entry_date));
  foreach (forward in complete->forwards) {
    ret += sprintf("Forwarded by   : %s\n", capitalize(forward->forwarder));
    ret += sprintf("from           : %s\n", forward->old_directory);
    ret += sprintf("at             : %s\n", ctime(forward->date));
  }
  ret += error->report;
  if (error->runtime && (error->runtime != "")) {
    ret += "[RUNTIME]\n" + error->runtime;
  }
  foreach (comment in complete->comments) {
      ret += sprintf("\nComment by     : %s\n", capitalize(comment->commenter));
      ret += sprintf(  "at             : %s\n", ctime(comment->date));
      ret += comment->comment;
  }
  ret +=
"------------------------------------------------------------------------------";
  return ret;
}
void finish_details(string player, int result, mixed results) {
   class error_complete* details;
   string str;
   if (result != DB_SUCCESS) {
      tell_creator(player, "Failed to return the results " + results);
      return ;
   }
   details = results;
   foreach (class error_complete detail in details) {
      str = get_bug(detail);
      unguarded( (: write_file("/w/" + $(player) + "/print_errors.txt", $(str)) :) );
   }
   tell_creator(player, "Finished gathering the details.\n");
}

==================================================
FILE: cmds/creator/rcsbatchin.c
==================================================

#include <creator.h>
inherit "/cmds/base";
#define CMD_NUM 5
mapping globals = ([]);
mapping ret = ([]);
mapping cmds = ([]);
mapping comments = ([ ]);
mapping locks = ([ ]);
mapping completed = ([ ]);
#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
#define COMMENT comments[TP]
void ask_about_file(object player);
void get_answer(string answer, object player);
void start_input(object player);
int cmd() {
   locks[this_player()] = RCS_HANDLER->query_locks(this_player());
   if (sizeof(locks[this_player()]) == 0)  {
      printf("You don't have any files locked.\n");
      map_delete(locks, this_player());
      return 1;
   }
   ask_about_file(this_player());
   return 1;
}
void check_complete(object player)  {
   if (!completed[player])
      call_out("check_complete", 1, player);
   else  {
      map_delete(completed, player);
      ask_about_file(player);
   }
}
void ask_about_file(object player)  {
   string tmp;
   tmp = sprintf("Check in %s? (y/N/q)\n", locks[player][0]);
   tell_object(player, tmp);
   input_to("get_answer", 0, player);
}
void start_input(object player)  {
   unguarded((:input_to((: get_answer :), 0, $(player)) :));
}
void get_answer(string answer, object player)  {
   string  arg;
   string *tmp;
   if (answer == "y"  ||  answer == "Y")  {
      tmp = explode(locks[player][0], "/");
      if (file_size("/" + implode(tmp[0 .. <2], "/") + "/RCS/" + tmp[<1] +
                    ",v") > 0)
      {
         arg = locks[player][0][1 .. ];
         tell_object(player, "Enter a comment.\n");
         CMDS = arg;
         player->do_edit("", "do_ci", this_object(), "", player);
         return;
      }
      else  {
         arg = sprintf("ERROR: No RCS file for %s\n", locks[player][0]);
         tell_object(player, arg);
         if (sizeof(locks[player]) > 1)  {
            locks[player] = locks[player][1 .. ];
            ask_about_file(player);
         }
         else
            map_delete(locks, player);
      }
   }
   else if (answer == "q"  ||  answer == "Q")  {
      map_delete(locks, player);
      return;
   }
   else if (sizeof(locks[player]) > 1)  {
      locks[player] = locks[player][1 .. ];
      ask_about_file(player);
   }
   else
      map_delete(locks, player);
}
void do_ci(string comment, object player) {
   int fd;
   string *cmd = allocate(3);
   if (!comment) {
      tell_object(player, "No comment given, skipping.\n");
      if (sizeof(locks[player]) > 1)  {
         locks[player] = locks[player][1 .. ];
         ask_about_file(player);
      }
      else
         map_delete(locks, player);
   }
   else  {
      cmd[0] = "-w" + player->query_name();
      cmd[1] = "-u";
      cmd[2] = "-m" + comment;
      cmd += explode(CMDS, " ");
#ifdef DEBUG
      tell_object(player, "CMD: %O\n", cmd);
#endif
      fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                          "close_call_back");
      TP = player;
      RET = "";
      COMMENT = comment;
      if (sizeof(locks[player]) > 1)  {
         completed[player] = 0;
         tell_object(player, "Checking in... please wait\n");
         call_out("check_complete", 1, player);
      }
   }
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}
void close_call_back(int fd) {
   string  file;
   string *file_stuff;
   string *bits;
   string  log;
   string  lname;
   int     i;
   object  master;
   if (RET != "") {
      TP->more_string(RET);
      file_stuff = explode(RET, "\n");
      i = 0;
      while (i + 2 < sizeof(file_stuff))  {
         if (file_stuff[i + 2] == "done")  {
            sscanf(file_stuff[i], "%*s  <--  %s", file);
            RCS_HANDLER->remove_lock(TP, file);
            if (file[0] == 'w')
               lname = "";
            else if (file[0] == 'd') {
               bits = explode(file, "/");
               if (sizeof(bits) >= 2 &&
                   member_array(bits[1],
                                "/secure/master"->query_domains()) != -1)
               {
                  master = find_object("/d/" + bits[1] + "/master");
                  if (!master)
                     TP->tell_object("No master object for domain: " +
                                     bits[1] + ".\n");
                  else
                     lname = master->query_changelog(file);
               }
               if (!lname)
                  lname = "/d/" + explode(file, "/")[1] + "/ChangeLog";
            }
            else
               lname = "/log/ChangeLog";
            if (lname != "") {
               log = TP->fix_string(sprintf(" * %s %s %s\n%s\n",
                                            ctime(time())[4 .. ],
                                            file, TP->query_name(),
                                            COMMENT), 80, 21);
               log_file(lname, log);
            }
            i += 3;
         }
         else if (sscanf(file_stuff[i], "%*sNo such file or directory"))
            ++i;
         else if (file_stuff[i + 1][0 .. 2] == "ci:")
            i += 2;
         else
            i += 3;
      }
   }
   else
      tell_object(TP, "rcsin completed.\n");
   if (sizeof(locks[TP]) > 1)  {
      locks[TP] = locks[TP][1 .. ];
      completed[TP] = 1;
   }
   else  {
      map_delete(completed, TP);
      map_delete(locks, TP);
   }
   map_delete(comments, TP);
   map_delete(ret, fd);
   map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsc_reate.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 5
mapping globals = ([]), ret = ([]);
string cmd_str;
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  string *files;
  int nfiles = 0;
  string bit, *bits;
  int add_comments;
  string tmp;
  if (!arg) {
    return notify_fail("rcscreate: No arguments.\n");
  }
  notify_fail("rcscreate: no such file "+arg+".\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach (bit in bits) {
    string  file;
    if (bit[0] == '-') {
      if (bit[1] == 'c') {
        add_comments = 1;
      } else {
        arg += (" " + bit);
      }
      continue;
    }
    files = this_player()->get_files(bit);
    foreach (file in files) {
      if (master()->valid_write(file, geteuid(this_player()), "cmd")) {
        string dir, *tmpbits;
        tmpbits = explode(file, "/");
        if (tmpbits[<1] == "RCS" ||
            tmpbits[<1] == "." ||
            tmpbits[<1] == ".." ||
            tmpbits[<1] == "ERROR_REPORTS") {
          continue;
        }
        if (sizeof(tmpbits) > 1) {
          dir = "/" + implode(tmpbits[0..<2], "/") + "/RCS";
        } else {
          dir = "/RCS";
        }
        if (file_size(dir) == -1) {
          write("No directory "+dir+", creating one.\n");
          mkdir(dir);
        }
        if (add_comments) {
          tmp = read_file(file);
          if ( file[ strsrch( file, ".", -1 ) .. ] == ".c"  ||
               file[ strsrch( file, ".", -1 ) .. ] == ".h" )  {
            tmp = replace_string(tmp, "\n", "");
            tmp = replace_string(tmp, "\n", "");
            write_file(file,
                       "\n"
                       "\n\n" + tmp);
          }
          else  {
            tmp = replace_string( tmp, "#  -*- LPC -*-  #\n", "" );
            tmp = replace_string( tmp, "# -*- LPC -*- #\n", "" );
            write_file( file,
                        "#  -*- LPC -*- #\n"
                        "#\n"
                        "# $", 1 );
            write_file( file,
                        "Locker$\n"
                        "# $");
            write_file(file, "Id$\n"
                        "#\n"
                        "#\n"
                        "#\n\n" + tmp );
          }
        }
        arg += (" " + file[1..]);
        nfiles++;
      } else {
        notify_fail("You do not have write access to "+file+"\n");
      }
    }
  }
  if (!nfiles) {
    return 0;
  }
  printf("Enter a comment.\n");
  cmd_str = arg;
  this_player()->do_edit(0, "do_ci");
  return 1;
}
void do_ci(string comment) {
  int fd;
  string *cmd = allocate(4);
  if (!comment) {
    printf("No comment given, aborting.\n");
    return;
  }
  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-i";
  cmd[2] = "-u";
  cmd[3] = "-t-" + comment;
  cmd += explode(cmd_str, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
}
void read_call_back(int fd, mixed mess) {
  mess = replace_string(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcscreate: Write_call_back called.\n");
}
void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcscreate completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsco_mment.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 8
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
class rcscomment_args {
  object player;
  string arg;
  string revision;
}
mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits;
  object *things;
  string* files;
  string file;
  if (!arg) {
    return notify_fail("rcscomment: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  foreach(bit in bits) {
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    files = this_player()->get_files(bit);
    if (sizeof(files)) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcscomment: no such file "+arg+".\n");
  }
  printf("Enter a revision number: ");
  input_to("get_rev", 0, new(class rcscomment_args, player : this_player(),
                             arg : arg));
  return 1;
}
protected void get_rev(string revision, class rcscomment_args args) {
  if (!strlen(revision)) {
    printf("No revision given, aborting.\n");
    return;
  }
  args->revision = revision;
  printf("Enter a comment.\n");
  args->player->do_edit(0, "do_comment", 0, 0, args);
}
void do_comment(string comment, class rcscomment_args args) {
  int fd;
  string *cmd = allocate(2);
  if (!strlen(comment)) {
    printf("No comment given, aborting.\n");
    return;
  }
  cmd[0] = sprintf("-w%s", args->player->query_name());
  cmd[1] = sprintf("-m%s:%s", args->revision, comment);
  cmd += explode(args->arg, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = args->player;
  RET = "";
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcscomment: write_call_back() called.\n");
}
void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcscomment completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsd_iff.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 2
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg)
    return notify_fail("rcsdiff: No arguments.\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach(bit in bits){
    string *files = ({}), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles)
    return notify_fail("No such file: "+arg+"\n");
  cmd =  arg;
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsdiff: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "rcsdiff completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsf_orce.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#include <mail.h>
#include <player_handler.h>
#define CMD_NUM 5
class rcsforce_args {
   object player;
   string *cmd;
   string locker;
   string filen;
}
private mapping _globals = ([ ]);
private mapping _ret = ([ ]);
private mapping _lockers = ([ ]);
#define TP _globals[fd]
#define RET _ret[fd]
#define LCK _lockers[fd]
private void do_ci(string text,
                   class rcsforce_args args);
mixed cmd(string arg)
{
   int nfiles = 0;
   string bit;
   string *bits;
   string file;
   string locker;
   string filen;
   string *cmd = allocate(3);
   if (!arg) {
      return notify_fail("rcsforce: No arguments.\n");
   }
   bits = explode(arg, " ");
   arg = "";
   bits -= ({ "", 0 });
   foreach(bit in bits) {
      string *files;
      if (bit[0] == '-') {
         arg += (" " + bit);
         continue;
      }
      files = (string *) this_player()->get_files(bit);
      if (sizeof(files)) {
         filen = file = files[0];
         arg += (" " + file[1..]);
         nfiles++;
      }
   }
   if (!nfiles) {
      return notify_fail("rcsforce: no such file " + arg + ".\n");
   }
   bits = explode(file, "/");
   file =
      "/" + (string) implode(bits[0.. < 2], "/") + "/RCS/" + bits[<1] + ",v";
   if (file_size(file) < 0) {
      return notify_fail("That file is not in RCS.\n");
   }
   if (strsrch(read_file(file, 4, 1), "locks; strict:") != -1) {
      return notify_fail("That file is not locked.\n");
   } else {
      bits = explode(read_file(file, 5, 1), ":");
      locker = bits[0][1..];
   }
   if (!master()->query_senior(this_player()->query_name()) &&
       PLAYER_HANDLER->test_creator(locker)) {
      if (file[0..2] == "/d/") {
         bits = explode(file, "/");
         if (!("/d/" + bits[1] + "/master")->can_rcsforce(file,
                                             this_player()->query_name(),
                                             locker)) {
            return 0;
         }
      } else {
         return 0;
      }
   }
   cmd[0] = "-w" + locker;
   cmd[1] = "-u";
   cmd[2] = "-m Forcibly unlocked by " + this_player()->query_name();
   cmd += explode(arg, " ");
#ifdef DEBUG
   printf("CMD: %O\n", cmd);
#endif
   if (PLAYER_HANDLER->test_creator(locker)) {
      printf("Edit mail? (y/[n]): ");
    input_to("edit_mail", 0, new (class rcsforce_args, player: this_player(), cmd: cmd, locker: locker, filen:filen));
   } else {
      int fd;
      write("Not sending mail to " + locker + " since they are not a creator "
            "any more.\n");
      fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                       "close_call_back");
      TP = this_player();
      RET = "";
      LCK = locker;
   }
   return 1;
}
protected void edit_mail(string choice,
                         class rcsforce_args args)
{
   if (!strlen(choice) || lower_case(choice) == "n") {
      printf("No.\n");
      do_ci(0, args);
      return;
   }
   if (lower_case(choice) != "y") {
      printf("Invalid choice. Please answer y or n. (y/[n]): ");
      input_to("edit_mail", 0, args);
   } else {
      printf("Yes. Entering editor.\n");
      args->player->do_edit(0, "do_ci", this_object(), 0, args);
   }
}
void do_ci(string text,
           class rcsforce_args args)
{
   int fd;
   AUTO_MAILER->auto_mail(args->locker, args->player->query_name(),
                          "Automatic RCSForce Mail", "",
                          sprintf("Your file: %s, has been forcibly "
                                  "unlocked by: %s.\nEnjoy.\n\n"
                                  "Automatic RCSForce Mailer.\n", args->filen,
                                  args->player->query_name()) +
                          (strlen(text) ? "\n" + text : ""));
   fd =
      external_start(CMD_NUM, args->cmd, "read_call_back", "write_call_back",
                     "close_call_back");
   TP = args->player;
   RET = "";
   LCK = args->locker;
}
void read_call_back(int fd,
                    mixed mess)
{
   mess = replace(mess, "/home/atuin/lib", "");
   RET += mess;
}
void write_call_back(int fd)
{
   tell_object(TP, "rcsforce: write_call_back() called.\n");
}
void close_call_back(int fd)
{
   string file,
    *file_stuff;
   int i;
   if (RET != "") {
      TP->more_string(RET);
      file_stuff = explode(RET, "\n");
      i = 0;
      while (i + 2 < sizeof(file_stuff)) {
         if (file_stuff[i + 2] == "done") {
            sscanf(file_stuff[i], "%*s  <--  %s", file);
            RCS_HANDLER->remove_lock(LCK, file);
            i += 3;
         } else {
            if (file_stuff[i + 1][0..2] == "ci:") {
               i += 2;
            } else {
               i += 3;
            }
         }
      }
   } else {
      tell_object(TP, "rcsforce completed.\n");
   }
   map_delete(_ret, fd);
   map_delete(_globals, fd);
   map_delete(_lockers, fd);
}

==================================================
FILE: cmds/creator/rcsi_n.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 5
mapping globals = ([]), ret = ([]), cmds = ([]), comments = ([ ]);
#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
#define COMMENT comments[TP]
mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits, *tmp, *notin;
  object *things;
  if (!arg) {
    return notify_fail("rcsin: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  notin = ({ });
  foreach(bit in bits) {
    string *files = ({ }), file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        tmp = explode(file, "/");
        if(file_size("/" + implode(tmp[0..<2], "/") + "/RCS/" + tmp[<1]+",v") >
           0) {
          nfiles++;
          arg += (" " + file[1..]);
        } else {
          notin += ({ file });
        }
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        tmp = explode(file, "/");
        if(file_size("/" + implode(tmp[0..<2], "/") + "/RCS/" + tmp[<1]+",v") >
           0) {
          nfiles++;
          arg += (" " + file[1..]);
        } else {
          notin += ({ file });
        }
      }
    }
  }
  if(!nfiles) {
    if(sizeof(notin))
      return notify_fail("rcsin: file not in RCS " +
                         query_multiple_short(notin) + ".\n");
    else
      return notify_fail("rcsin: no such file "+arg+".\n");
  }
  if(sizeof(notin))
    write("rcsin: file not in RCS " + query_multiple_short(notin) + ".\n");
  printf("Enter a comment.\n");
  CMDS = arg;
  this_player()->do_edit(0, "do_ci");
  return 1;
}
void do_ci(string comment) {
  int fd;
  string *cmd = allocate(3);
  if (!comment) {
    printf("No comment given, aborting.\n");
    return;
  }
  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-u";
  cmd[2] = "-m"+comment;
  cmd += explode(CMDS, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  COMMENT = comment;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff, *bits, log, lname;
  int i;
  object master;
  if (RET != "") {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  <--  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        if(file[0] == 'w')
          lname = "";
        else if(file[0] == 'd') {
          bits = explode(file, "/");
          if(sizeof(bits) >= 2 &&
             member_array(bits[1], "/secure/master"->query_domains()) != -1) {
            master = find_object("/d/" + bits[1]+"/master");
            if(!master)
              TP->tell_object("No master object for domain: " + bits[1] +
                              ".\n");
            else
              lname = master->query_changelog(file);
          }
          if(!lname)
            lname = "/d/" + explode(file, "/")[1] + "/ChangeLog";
        } else
          lname = "/log/ChangeLog";
        if(lname != "") {
          log = TP->fix_string(sprintf(" * %s %s %s\n%s\n",
                                       ctime(time())[4..],
                                       file, TP->query_name(),
                                       COMMENT), 80, 21);
          log_file(lname, log);
        }
        i += 3;
      } else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      } else if (file_stuff[i + 1][0..2] == "ci:") {
          i += 2;
      } else {
          i += 3;
      }
    }
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
  map_delete(comments, TP);
}

==================================================
FILE: cmds/creator/rcsl_og.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 1
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg)
    return notify_fail("rcslog: No arguments.\n");
  notify_fail("rcslog: No such file "+arg+"\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach(bit in bits){
    string *files = ({ }), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles)
    return 0;
  cmd =  arg;
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcslog: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "rcslog completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsloc_ks.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define DEBUG 1
#define CMD_NUM 5
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits, file, locker, *files, fname;
  object *things;
  if (!arg) {
    return notify_fail("rcslocks: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  files = ({ });
  foreach(bit in bits) {
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcslocks: no such file "+arg+".\n");
  }
  foreach(fname in files) {
    string lockline;
    bits = explode(fname, "/");
    file = "/" + (string)implode(bits[0..<2], "/") + "/RCS/" + bits[<1] + ",v";
    if (file_size(file) < 0) {
      write("File " + fname + " is not on RCS.\n");
    } else {
      lockline = read_file(file, 4, 1);
      if (strsrch(lockline, "locks; strict:") == -1) {
        bits = explode(read_file(file, 5, 1), ":");
        if(bits[0][0] == '\t') {
          locker = bits[0][1..];
          write("File " + fname + " locked by " + locker + ".\n");
        }
        else write(fname + " is not locked.\n");
      }
    }
  }
  return 1;
}

==================================================
FILE: cmds/creator/rcso_ut.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 3
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  int force;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg) {
    return notify_fail("rcsout: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  if (bits[0] == "-f") {
    force = 1;
    bits = bits[1..];
  }
  foreach(bit in bits){
    string *files = ({ }), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
      int i;
      files = uniq_array(map(things, (: base_name($1) :)));
      for (i = 0; i < sizeof(files); i++) {
        if (file_size(files[i]) <= 0) {
          files[i] += ".c";
        }
      }
    }
    files += this_player()->get_files(bit);
    if (!sizeof(files)) {
      file = this_player()->get_path(bit);
      if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
        arg += (" " + file[1..]);
        nfiles++;
      } else {
        notify_fail("You do not have write access to "+file+"\n");
      }
    } else {
      foreach(file in uniq_array(files)) {
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else {
          notify_fail("You do not have write access to "+file+"\n");
        }
      }
    }
  }
  if(!nfiles) {
    return 0;
  }
  if (force) {
     cmd = " -l -f -w" + this_player()->query_name() +arg;
  } else  {
     cmd = " -l -w" + this_player()->query_name() +arg;
  }
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsout: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff;
  int i;
  if(RET != "")  {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  -->  %s", file);
        RCS_HANDLER->add_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0 .. 2] == "co:")  i += 2;
      else i += 3;
    }
  }
  else
    tell_object(TP, "rcsout completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsr_elease.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 3
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg)
    return notify_fail("rcsrelease: No arguments.\n");
  notify_fail("No such file: "+arg+"\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach(bit in bits){
    string *files = ({}), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else
          notify_fail("You do not have write access to "+file+"\n");
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else
          notify_fail("You do not have write access to "+file+"\n");
      }
    }
  }
  if(!nfiles)
    return 0;
  cmd = " -f -u -w" + this_player()->query_name() +arg;
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsrelease: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff;
  int i;
  if(RET != "")  {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  -->  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0..2] == "co:") {
          i += 2;
      }
      else {
          i += 3;
      }
    }
  }
  else
    tell_object(TP, "rcsrelease completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsre_vert.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 8
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int nfiles, fd;
  string bit, *bits, *cmd;
  object *things;
  if (!arg) {
    return notify_fail("rcsrevert: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  foreach(bit in bits) {
    string *files, file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcsrevert: no such file "+arg+".\n");
  }
  cmd = allocate(3);
  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-u";
  cmd[2] = "-l";
  cmd += explode(arg, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsrevert: write_call_back() called.\n");
}
void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}
