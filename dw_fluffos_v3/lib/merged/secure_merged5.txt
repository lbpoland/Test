# Total Tokens: 15597
# Total Files Merged: 38
# Total Characters: 52090

uery_number_and_ctime_elapsed.c
==================================================

string number_as_string(int n);
#if !efun_defined(query_num)
string query_num(int n, int limit) {
  string ret;
  int i;
  if (limit && n>limit) return "many";
  if (n < 0) return "many";
  if (n > 99999) return "many";
  ret = 0;
  if ((i = n/1000)) {
    n = n%1000;
    if (!n)
      return number_as_string(i) + " thousand";
    ret = number_as_string(i) + " thousand";
  }
  if ((i = n/100)) {
    n = n%100;
    if (ret) {
      if (!n)
        return ret + " and " + number_as_string(i) + " hundred";
      ret += ", " + number_as_string(i) + " hundred";
    } else {
      if (!n)
        return number_as_string(i) + " hundred";
      ret = number_as_string(i) + " hundred";
    }
  }
  if (ret)
    return ret + " and " + number_as_string(n);
  return number_as_string(n);
}
#endif
string number_as_string(int n) {
  string ret;
  if (!n) return "zero";
  if (n<20 && n>9) return ({ "ten", "eleven", "twelve", "thirteen",
                             "fourteen", "fifteen", "sixteen", "seventeen",
                             "eighteen", "nineteen" })[n-10];
  ret = ({ "", "", "twenty", "thirty", "forty", "fifty", "sixty",
           "seventy", "eighty", "ninety"})[n/10];
  if ((n = n%10)&&(ret!="")) ret += "-";
  return ret + ({ "", "one", "two", "three", "four", "five", "six",
                  "seven", "eight", "nine"})[n];
}
string word_ordinal(int num)  {
   string word = "";
   int    part;
   switch (part = num % 100)  {
       case 0:
           word = "th";
           break;
       case 1 .. 12:
           word = ({
                  "first",   "second", "third", "fourth", "fifth",    "sixth",
                  "seventh", "eighth", "ninth", "tenth",  "eleventh", "twelfth"
                  })[part - 1];
           break;
       case 13 .. 19:
           word = query_num(num % 100, 99999) + "th";
           break;
       default:
           if (part % 10 == 0)  {
               word = ({
                      "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth",
                      "seventieth", "eightieth", "ninetieth"
                      })[part / 10 - 2];
           }
           else  {
               word = ({
                      "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
                      "eighty", "ninety"
                      })[part / 10 - 2] + "-" + word_ordinal(part % 10);
           }
           break;
    }
    num = (num / 100) * 100;
    if (num != 0)   {
        if (part > 0)  word = query_num(num, 99999) + " and " + word;
        else word = query_num(num, 99999) + word;
    }
    return word;
}
varargs string ctime_elapsed( int time_elapsed, int mode ) {
    int sec, min, hour, day;
    string seconds, minutes, hours, days;
    string *retval;
    sec = time_elapsed % 60;
    min = (time_elapsed / 60) % 60;
    hour = (time_elapsed / (60 * 60)) % 24;
    day = time_elapsed / (60 * 60 * 24);
    if ( mode ) {
        seconds = query_num( sec, 99999 );
        minutes = query_num( min, 99999 );
        hours = query_num( hour, 99999 );
        days = query_num( day, 99999 );
    }
    else {
        seconds = sec + "";
        minutes = min + "";
        hours = hour + "";
        days = day + "";
    }
    retval = ({ });
    if (day > 0) {
        retval += ({ days + " day" });
        if (day > 1) {
            retval[<1] += "s";
        }
    }
    if (hour > 0) {
        retval += ({ hours + " hour" });
        if (hour > 1) {
            retval[<1] += "s";
        }
    }
    if (min > 0) {
        retval += ({ minutes + " minute" });
        if (min > 1) {
            retval[<1] += "s";
        }
    }
    if (sec > 0) {
        retval += ({ seconds + " second" });
        if (sec > 1) {
            retval[<1] += "s";
        }
    }
    if (sizeof(retval) == 0) {
        return "0 seconds";
    }
    if (sizeof(retval) == 1) {
        return retval[0];
    }
    return implode(retval[0..<2], ", ") + " and " + retval[<1];
}
string query_times(int num) {
  string retval;
  switch(num) {
  case 0:
    retval = "";
    break;
  case 1:
    retval = "once";
    break;
  case 2:
    retval = "twice";
    break;
  default:
    retval = query_num(num, 0) + " times";
  }
  return retval;
}

==================================================
FILE: simul_efun/roll_MdN.c
==================================================

int roll_MdN( int dice, int sides ) {
   int roll;
   if ( ( dice > 0 ) && ( sides > 0 ) ) {
      while ( dice ) {
         roll += 1 + random( sides );
         dice--;
      }
   }
   return roll;
}

==================================================
FILE: simul_efun/shuffle.c
==================================================

mixed *shuffle( mixed *args ) {
   int i, j;
   mixed temp;
   if ( !pointerp( args ) )
      return ({ });
   if ( sizeof( args ) < 2 )
      return args;
   for ( i = 0; i < sizeof( args ); i++ ) {
      j = random( i + 1 );
      if ( i == j )
         continue;
      temp = args[ i ];
      args[ i ] = args[ j ];
      args[ j ] = temp;
   }
   return args;
}

==================================================
FILE: simul_efun/snoop_simul.c
==================================================

int snoop(object sno, object snop) {
  if ("/secure/master"->valid_snoop(sno, snop, previous_object())) {
    if (!snop)
    efun::snoop(sno);
    else
      efun::snoop(sno, snop);
    return 1;
  }
  return 0;
}

==================================================
FILE: simul_efun/sqrt.c
==================================================

mixed sqrt( mixed number ) {
  if (floatp(number))
    return efun::sqrt(number);
  if (!intp(number))
    error("Bad argument 1 to sqrt()\nExpected: int or float Got: "+
          typeof(number)+ ".\n");
  if ( number < 0 )
    return -1;
  return to_int(efun::sqrt(to_float(number)));
}

==================================================
FILE: simul_efun/str_inven.c
==================================================

mixed *query_strange_inventory(mixed *arr) {
  mixed *inv, desc;
  object ob;
  int i;
  inv = ({ });
  foreach (ob in arr) {
    if (!(desc = (string)ob->short()) || (desc == ""))
      continue;
    if ((i = member_array(desc, inv)) >= 0)
      inv[i+1] += ({ ob });
    else
      inv += ({ desc, ({ ob }) });
  }
  return inv;
}

==================================================
FILE: simul_efun/strip_colours.c
==================================================

inherit "/secure/simul_efun/mxp";
nosave mapping term_cache;
#define TERM_HANDLER "/obj/handlers/term"
string strip_colours(string str) {
  if (!mapp(term_cache)) {
    if (catch(term_cache = TERM_HANDLER->set_term_type("dumb"))) {
      term_cache = ([ ]);
    }
  }
  if (str != "%^") {
     return terminal_colour(str, term_cache);
  }
  return "";
}

==================================================
FILE: simul_efun/tell_creator.c
==================================================

varargs void tell_creator(mixed cre, string fmt, mixed args ...) {
  if (stringp(cre)) {
#if efun_defined(find_player)
    cre = efun::find_player(cre);
#else
    cre = "/obj/handlers/livings"->find_player(cre);
#endif
  }
  if (objectp(cre) && cre->query_creator()) {
    if (sizeof(args)) {
      tell_object(cre, sprintf(fmt, args ...));
    } else {
      tell_object(cre, fmt);
    }
  }
}

==================================================
FILE: simul_efun/thing_to_string.c
==================================================

string mapping_to_string( mapping map );
string array_to_string( mixed *args ) {
   int i;
   args = copy(args);
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( args[ i ] ) ) {
         args[ i ] = array_to_string( args[ i ] );
         continue;
      }
      if ( mapp( args[ i ] ) ) {
         args[ i ] = mapping_to_string( args[ i ] );
         continue;
      }
      args[ i ] = sprintf( "%O", args[ i ] );
   }
   return "({ "+ implode( args, ", " ) +" })";
}
string mapping_to_string( mapping map ) {
   int i;
   mixed *args;
   if( !mapp( map ) ) {
      return sprintf( "%O", map );
   }
   args = keys( map );
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               array_to_string( map[ args[ i ] ] ) );
         continue;
      }
      if ( mapp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               mapping_to_string( map[ args[ i ] ] ) );
         continue;
      }
      args[ i ] = sprintf( "%O : %O", args[ i ], map[ args[ i ] ] );
   }
   return "([ "+ implode( args, ", " ) +" ])";
}

==================================================
FILE: simul_efun/unguarded.c
==================================================

#include <origin.h>
mixed unguarded(function f) {
  object master_ob = master();
  if (!master_ob) {
    master_ob = previous_object();
  }
  if (origin() == ORIGIN_LOCAL) {
    return master_ob->apply_unguarded(f, 1);
  } else {
    return master_ob->apply_unguarded(f);
  }
return 1;
}

==================================================
FILE: simul_efun/uniq_array.c
==================================================

mixed *uniq_array(mixed *arr){
  return keys(allocate_mapping(arr, 1));
}

==================================================
FILE: simul_efun/virtual.c
==================================================

#include "virtual.h"
object garbage_handler;
object clone_object(string str, mixed *args ...) {
  object ob;
  if (sizeof(args) == 0)
    ob = efun::clone_object(str);
  else
    ob = efun::clone_object(str, args ...);
  if (!ob && file_size(str) > 0) {
    ob = SERVER->create_virtual_object(str, 1);
  }
  if (ob)  {
    if(!garbage_handler)
      catch(garbage_handler = load_object("/obj/handlers/garbage"));
    if(garbage_handler)
      catch(garbage_handler->cloned(ob));
  }
  return ob;
}

==================================================
FILE: items/bomb.c
==================================================

inherit "/std/object";
void setup() {
  set_name( "bomb" );
  set_short( "bomb of departure" );
  set_long( "This is a handy creator object to get rid of annoying swine.\n" );
  set_main_plural( "bombs" );
  reset_drop();
}
void reset() {
  call_out( "detonate", 2 );
}
void detonate() {
  environment( this_object() )->quit();
  call_out( "detonate", 15 );
}
void init_dynamic_arg( mapping args ) {
  ::init_dynamic_arg( args );
  call_out( "detonate", 15 );
}

==================================================
FILE: items/clean.c
==================================================

#include "standard.h"
inherit "/std/object";
setup()
{
  set_name("test");
  set_short("test");
}
init()
{
  ::init();
  add_action("purge","purge");
}
#define DAYS60 5184000
#define DAYS90 7776000
int purge(string str)
{
  mixed *s, *dir, *let;
  int i,j,t;
  string tmp;
  let = ({"a","b","c","d","e","f","g","h","i","j","k","l",
                  "m","n","o","p","q","r","s","t","u","v","w","x",
                  "y","z", });
  seteuid("Root");
  t=time();
  for (j=0;j<26;j++)
  {
    dir=get_dir("/players/"+let[j]+"/*.o");
    for (i=0;i<sizeof(dir);i++)
    {
      s=stat("/players/"+let[j]+"/"+dir[i]);
      if ( sizeof(s) && ((t-(int)s[1]) > DAYS60))
      {
        sscanf(dir[i],"%s.o",tmp);
        if (!"/secure/master"->query_promoted(tmp))
        {
          log_file("EXPIRED",dir[i]+" unused for > 60 days, moved\n");
          rename("/players/"+let[j]+"/"+dir[i],"/players/OLD/"+dir[i]);
        }
        else
          log_file("EXPIRED",dir[i]+" unused for > 60 days, promoted, not moved\n");
      }
    }
  }
  "/obj/handlers/library"->clean_library();
  "/room/bankmain"->clean_bank();
  "/obj/handlers/mail_track"->clean_post();
  return 1;
}

==================================================
FILE: cmds/lord/cleanup.c
==================================================

inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd(string mess) {
	if("/secure/bulk_delete"->delete_files(mess))
		write("Ok.\n");
	else
		return notify_fail("Sorry.\n");
}

==================================================
FILE: cmds/lord/hl_ord.c
==================================================

#define HIST "/obj/handlers/hist_handler"
mixed cmd() {
  int i;
  mixed *hist;
  if (!master()->query_lord((string)geteuid(this_player())))
    return 0;
  seteuid(geteuid(this_player()));
  hist = HIST->query_lord_history();
  if (!pointerp(hist) || !sizeof(hist))
    return notify_fail("Nobody said anything on the lord channel.\n");
  write("The lord channel history is:\n");
  for (i=0;i<sizeof(hist);i++) {
    if (sizeof(hist[i]) > 2) {
      efun::tell_object(this_player(),
           this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
           ctime(hist[i][2])[11..18], hist[i][0],
           (int)this_player()->query_cols()-strlen(hist[i][0])-11,
           hist[i][1])));
    }
    else
      efun::tell_object(this_player(),
           this_player()->fix_string(sprintf("%s%-=*s\n",
           hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
           hist[i][1])));
    }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: cmds/creator/;_.c
==================================================

#include <parser.h>
inherit "/cmds/base";
mixed cmd(string str) {
  mixed res;
  PARSER->init_expr(str);
  res = PARSER->expr();
  printf("Returns: %O\n", ((pointerp(res) && sizeof(res) == 1)?res[0]:res));
  PARSER->finish_expr();
  return 1;
}

==================================================
FILE: cmds/creator/banish.c
==================================================

#include <player_handler.h>
#define LIAISON "/d/liaison/master"
inherit "/cmds/base";
int cmd(string str)
{
  string str1, temp1, ban;
  if (this_player() != this_player(1)) {
    return 0;
  }
  if (this_player()->GetForced()) {
    return 0;
  }
  if(!master()->query_senior(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail( "Only Liaison domain "
        "deputies, Senior Creators and above can banish player names.\n" );
  }
  notify_fail("Syntax : banish <name> <reason>\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s", str, str1) != 2)
    return 0;
  str = lower_case(str);
  if (sscanf(str,"%s.",temp1))
    return 0;
  if (sscanf(str, "%s/", temp1))
    return 0;
  if (file_size("/banish/"+str[0..0]+"/"+str+".o") >= 0)
  {
    notify_fail("That name is already banished.\n");
    return 0;
  }
  PLAYER_HANDLER->remove_cache_entry(str);
  if (PLAYER_HANDLER->test_user(str))
    return notify_fail("That is a player.  You must rm or mv the player "
                       "file first.\n");
  ban = "Banished by : "+(string)this_player()->query_name()+"\n";
  ban += ctime(time())+"\n";
  ban += "Banish Reason : " + str1 + "\n";
  unguarded((: write_file, "/banish/"+str[0..0]+"/"+str+".o", ban :));
  write(str + " banished.\n");
  return 1;
}
string *query_patterns() {
  return ({ "", (: cmd(0) :), "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: cmds/creator/ca_ll.c
==================================================

#include <creator.h>
#include <parser.h>
#define LMASTER "/d/liaison/master"
inherit "/cmds/base";
mixed cmd(string str) {
  mixed *args, file, f;
  mixed retobj;
  string *s, s1, s2;
  string fn,os, obvarname;
  string *argv;
  object *ov;
  object fish, shad, ob;
  notify_fail("USAGE : call [obvar=]lfun(arg[,arg[,arg...]]) object[s]\n");
  if (!str)
    return 0;
  obvarname = (string)0;
  sscanf(str, "%s=%s", obvarname, str);
  s = explode("&"+str+"&", ")");
  if (sizeof(s) < 2 || sscanf(s[0], "%s(%s", s1, s2) != 2)
    return 0;
  fn = replace(s1[1..], " ", "");
  s[0] = s2;
  args = PARSER->parse_args(implode(s, ")"), ")");
  if (!args) return 1;
  argv = args[0];
  os = args[1][0..<2];
  while (strlen(os) && os[0] == ' ')
    os = os[1..];
  notify_fail("Can't find object "+os+".\n");
  ov = WIZ_PRESENT->wiz_present(os, this_player());
  ov = filter( ov, (: reference_allowed( $1, $( this_player() ) ) :) );
  if (!sizeof(ov)) return 0;
  if (sizeof(argv) < 6) argv += allocate(6 - sizeof(argv));
  foreach (ob in ov) {
    fish = ob;
    while (shad = shadow(fish, 0)) {
      fish = shad;
      if (f = function_exists(fn, fish)) file = f;
    }
    if (!file) file = function_exists(fn, ob);
    if (file) {
  if ( ( ob != this_player() && ob->query_property( "player" ) ) ) {
        unguarded((: write_file,
                   (LMASTER->query_member(this_player()->query_name()) ?
                    "/d/admin/log/CALL_LIAISONS.log" :
                    "/d/admin/log/CALL_CREATORS.log" ),
                   sprintf("%s: %s (%O) called %s(%s) on %s (%O)\n",
                           ctime(time()),
                           this_player()->query_name(), this_player(),
                           fn, implode(argv - ({0}), ", "),
        ob->query_name(), ob) :));
        user_event("inform", sprintf("%s called %s(%s) on %s",
            this_player()->query_name(), fn, implode(argv - ({0}), ", "),
            ob->query_name()), "calls");
      }
      retobj = call_other(ob,fn,argv...);
      printf("*** function on '%s' found in %s ***\n",
          WIZ_PRESENT->desc_object(ob), file);
      write(sprintf("$P$Call result$P$Returned: %O\n", retobj));
      if (obvarname) {
        if (objectp(retobj)) this_player()->set_obvar(obvarname, retobj);
      }
    } else
      printf("*** function on '%s' Not found ***\n",
          WIZ_PRESENT->desc_object(ob));
    file = 0;
  }
  return 1;
}

==================================================
FILE: cmds/creator/cat.c
==================================================

inherit "/cmds/base";
mixed cmd(string str, int LINE_NUMBERS) {
   string *filenames, *lines;
   int loop, i, w;
   if( !str )  {
      notify_fail("Cat what file ?\n");
      return 0;
   }
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail(str + ": No such file.\n");
      return 0;
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      if(sizeof(filenames) > 1) {
         write("FILE : " + filenames[loop] + "\n");
      }
      if(LINE_NUMBERS) {
         str = read_file( filenames[loop] );
         if (str)  {
            lines = explode( str , "\n" );
            w = sizeof( sprintf( "%d", sizeof( lines ) ) );
            for( i = 0; i < sizeof( lines ); i++ )
               lines[i] = sprintf( "%*d: %s", w, (i+1), lines[i] );
            printf("%s\n", implode(lines, "\n"));
         }
         else write(filenames[loop] + ": No such file.\n");
      }
      else cat(filenames[loop]);
   }
   return 1;
}
mixed *query_patterns()  {
   return ({ "-n <string'file'>", (: cmd($4[0], 1) :),
              "<string'file'>", (: cmd($4[0], 0) :) });
}

==================================================
FILE: cmds/creator/cl_one.c
==================================================

#include <creator.h>
inherit "/cmds/base";
mixed cmd(string str) {
    object ob;
    string err, *filenames, obvarname;
    int loop, mov;
    if (!str) {
        notify_fail("Clone what ?\n");
        return 0;
    }
    obvarname = (string)0;
    sscanf(str, "%s=%s", obvarname, str);
    filenames = this_player()->get_cfiles(str);
    if (!sizeof(filenames))  {
        notify_fail("No such file.\n");
        return 0;
    }
    for(loop = 0; loop < sizeof(filenames); loop++) {
       str = filenames[loop];
       if (file_size(str) < 0 && file_size(str + ".c") < 0) {
          notify_fail("No such file.\n");
          return 0;
       }
       ob = clone_object(str);
       if (obvarname) this_player()->set_obvar(obvarname, ob);
       if (ob) {
          err = catch((mov = (int)ob->move(this_player())));
          this_player()->handle_error(err, "move(this_player())");
          if (err || mov) {
             err = catch(ob -> move(environment(this_player())));
             this_player()->handle_error(err, "move(environment())");
          }
          printf("Ok.  Object %O cloned and put in "+
             (environment(ob)==this_player() ? "you" :
              (environment(ob)==environment(this_player()) ? "here" : WIZ_PRESENT->desc_object(environment(ob))))+
             ".\n", ob);
          say((string)this_player()->query_cap_name() + " fetches " +
            (string)ob->one_short() + " from another dimension.\n");
       } else {
          printf("Failed to clone.\n");
       }
    }
    return 1;
}

==================================================
FILE: cmds/creator/compile.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string bit, *bits, error_str;
  if (str)
    bits = this_player()->get_files(str);
  if (!str || !sizeof(bits))
    return notify_fail("Syntax: compile <files>\n");
#ifdef __RUNTIME_LOADING__
  foreach (bit in bits) {
    error_str = catch(generate_source(bit));
    if (!error_str)
      printf("Compiled %s Ok.\n", bit);
    else
      printf("Error compiling %s: %s\n", bit, error_str);
  }
#else
  error_str = catch(generate_source(bits));
  if (!error_str)
    printf("Compiled %@s OK.\n", bits);
  else
    printf("Error compiling %@s: %s\n", bits, error_str);
#endif
  return 1;
}

==================================================
FILE: cmds/creator/cp.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string *filenames, dest, *fnames, dstr;
  int loop, fs;
  if(!str)
    return notify_fail("Usage : cp file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
                                               "/"));
  filenames = filter(filenames, (:$1[<1] != '.':));
  if(!sizeof(filenames)) {
    notify_fail("Usage : cp file [file|dir...]\n");
    return 0;
  }
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if(!dest) {
    write("No destination\n");
    return 1;
  }
  for(loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(!master()->valid_copy(str, geteuid(this_player()), ""))
      return notify_fail("Permission denied.\n");
    fs = file_size(dest);
    if(fs == -2) {
      string *names;
      names = explode(str, "/");
      fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      if(fs != -1) {
        write("file exists " + dest + "/" + names[sizeof(names) - 1] + "\n");
        continue;
      }
      dstr = dest + "/" + names[sizeof(names) - 1];
    } else {
      if(fs != -1) {
        write("File exists : " + dest + "\n");
        continue;
      }
      dstr = dest;
    }
    switch(cp(str, dstr)) {
    case 1:
      write(str + " copied to " + dstr + ".\n");
      break;
    case -1:
      write(str + " is unreadable.\n");
      break;
    case -2:
      write(dstr + " is unreadable.\n");
      break;
    case -3:
      write("I/O error copying " + str + " to " + dstr + ".\n");
      break;
    }
  }
  return 1;
}

==================================================
FILE: cmds/creator/cp2.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
    string *filenames, dest, *fnames;
    int loop, fs;
    int show_ok;
    string src;
    if(!str)
        return notify_fail("Usage : cp file [file|dir...]\n");
    show_ok = 0;
    fnames = explode(str, " ");
    filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
        "/"));
    filenames = filter(filenames, (:$1[<1] != '.':));
    if(!sizeof(filenames)) {
        notify_fail("Usage : cp file [file|dir...]\n");
        return 0;
    }
    dest = fnames[sizeof(fnames) - 1];
    dest = this_player()->get_path(dest);
    if(!dest) {
        write("No destination\n");
        return 1;
    }
    for(loop = 0; loop < sizeof(filenames); loop++) {
        src = filenames[loop];
        if(!master()->valid_copy(src, geteuid(this_player()), ""))
            return notify_fail("Permission denied.\n");
        if ( file_size( src ) == -1 ) {
            write("No such file : " + str + "\n");
            continue;
        }
        fs = file_size(dest);
        if (fs > -1) {
            write("File exists : " + dest + "\n");
            continue;
        }
        switch ( cp( src, dest ) ) {
        case 1:
            show_ok = 1;
            break;
        case -1:
            write( src + " is unreadable.\n" );
            break;
        case -2:
            write( dest + " is unreadable.\n" );
            break;
        case -3:
            write( "An I/O error has occurred copying " +
              src + " to " + dest + "\n" );
            break;
        default:
            write( "Unable to copy " + src + " to " + dest + "\n" );
        }
    }
if ( show_ok ) {
    write( "Ok.\n" );
}
return 1;
}

==================================================
FILE: cmds/creator/dbxframe.c
==================================================

inherit "/cmds/base";
string print_vars(mixed *vars) {
  string *result = allocate(sizeof(vars));
  int i;
  for (i=0; i<sizeof(vars); i++) {
    if (mapp(vars[i]))
      result[i] = "([ ... ])";
    else if (functionp(vars[i]))
      result[i] = "(: ... :)";
    else if (intp(vars[i])) {
      if (vars[i]) result[i]=vars[i]+"";
      else if (nullp(vars[i])) result[i]="NULL";
      else if (undefinedp(vars[i])) result[i]="UNDEFINED";
      else result[i]="0";
    }
    else if (stringp(vars[i]))
      result[i] = "\""+vars[i]+"\"";
    else if (pointerp(vars[i]))
      result[i] = "({ ... })";
    else if (floatp(vars[i]))
      result[i] = vars[i]+"";
    else if (bufferp(vars[i]))
      result[i] = "<BUFFER>";
  }
  return implode(result, ", ");
}
int cmd(string str) {
  mapping frame;
  object ob;
  string who;
  int num;
  string file;
  if (!str || (sscanf(str, "%d", num) != 1 &&
               sscanf(str, "%s %d", who, num) != 2)) {
    write("dbxframe [<who>] <frame>\n");
    return 1;
  }
  if (who) {
    who = this_player()->expand_nickname(who);
    ob = find_player(who);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  }
  else ob = this_player();
  frame = ob->get_last_error();
  if (!frame) {
    write("No error.\n");
    return 1;
  }
  if (num < 1 || num > sizeof(frame["trace"]))
    return notify_fail("No such frame.\n");
  num--;
  frame = frame["trace"][num];
  file = frame["file"];
  if (file[0] != '/') {
    file = "/" + file;
  }
  printf("------%s:%i - %s(%s)\n", file, frame["line"],
         frame["function"],print_vars(frame["arguments"]));
  printf("locals: %s\n", print_vars(frame["locals"]));
  printf("----------------------------------------------------------------\n");
  write(sprintf("%s%%^YELLOW%%^=>%s%%^RESET%%^%s",
         read_file(file, frame["line"]-5, 5),
         read_file(file, frame["line"], 1),
         read_file(file, frame["line"]+1, 5)));
  return 1;
}

==================================================
FILE: cmds/creator/di_scard.c
==================================================

#include <creator.h>
inherit "/cmds/base";
void ask_discard(object *obs);
mixed cmd(string str) {
  string *file_names, err;
  object *no_dis, discard_obj;
  file_names = this_player()->get_cfiles(str);
  no_dis = ({ });
  if (!sizeof(file_names)) {
    add_failed_mess("No such object: " + str + "\n");
    return 0;
  }
  foreach (str in file_names) {
    discard_obj = find_object(str);
    if (!discard_obj) {
      printf("%s is not loaded.\n", str);
      continue;
    }
    err = catch(discard_obj->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (discard_obj) {
      no_dis += ({ discard_obj });
    }
  }
  if (sizeof(no_dis)) {
    ask_discard(no_dis);
    return 1;
  }
  write("Ok.\n");
  return 1;
}
void ask_discard(object *obs) {
  if (!arrayp(obs) || !sizeof(obs)) {
    printf("Nothing left to be discarded.\n");
    return;
  }
  printf("%s has a violent objection to being dested.\n"
         "Are you sure you want to do this? ",
         WIZ_PRESENT->desc_object(obs[0]));
  input_to("no_discard", 0, obs);
}
void no_discard(string s, object *obs) {
   string err, name;
   name = (string)WIZ_PRESENT->desc_object(obs[0]);
   if (this_player()->affirmative(s)) {
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
         printf("%s REALLY doesn't want to be discarded.\n", name);
         catch(destruct(obs[0]));
         if (obs[0]) {
            printf("%s didn't destruct.\n", name);
            return;
         }
      }
   }
   printf("%s discarded.\n", name);
   ask_discard(obs[1..]);
}
mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: cmds/creator/diff.c
==================================================

inherit "/cmds/base";
#include <creator.h>
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define FILE files[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, num = 0;
  string last = "";
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});
    foreach(bit in bits){
      mixed *st;
      if (bit[0] == '-'){
        continue;
      }
      bit = this_player()->get_path(bit)[1..];
      if (bit == "")
        return notify_fail("Your wombles just expired.\n");
      if (!master()->valid_read(bit, this_player(), 0))
        return notify_fail("Permission denied: " + bit + " .\n");
      if(sizeof(st = unguarded((:stat, bit:)))){
        if(stringp(st[0]))
          return notify_fail("Can't use diff on directories.\n");
      }
      arg += " " + last;
      last = bit;
      num ++;
    }
  }
  if (num == 2)
    arg += " " + last;
  last = "/" + last;
  if (num > 3)
    return notify_fail("Can't compare more than two files");
  if (num == 3 && file_size(last) > 0)
    return notify_fail("File " + last + " exists.\n");
  fd = external_start(7, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  if (fd == -1)
    return notify_fail("diff failed somehow.\n");
  TP = this_player();
  if (num == 3 && master()->valid_write(last, this_player(), 0))
    FILE = last;
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "diff: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if (FILE)
    write_file(FILE, RET);
  else {
    if(RET == "")
      RET = "those files are the same";
    TP->more_string(RET);
  }
  map_delete(ret, fd);
  map_delete(files, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/du.c
==================================================

#define MAX_FILES 1000
inherit "/cmds/base";
mapping _counts = ([ ]);
protected int rec_du(string path) {
  string *files;
  int i, size, tot;
  if (path[strlen(path)-1] != '/') {
    path += "/";
  }
  files = get_dir(path+"*");
  _counts[this_player()] += sizeof(files);
  for (i=0;i<sizeof(files);i++) {
    if (files[i] == "." || files[i] == "..") {
      continue;
    }
    size = file_size(path+files[i]);
    if (size > 0) {
      tot += size;
    } else if (size == -2 && (_counts[this_player()] < MAX_FILES)) {
      printf("%-30s %5d\n", path+files[i], (size = rec_du(path+files[i])));
      tot += size*1024;
    }
  }
  return (tot+1023)/1024;
}
int cmd( string path ) {
    if ( !path )
        return 0;
    _counts[this_player()] = 0;
    if ( master()->valid_read( path, geteuid( this_player() ) ) ) {
      printf( "%-30s %5d\n", "Total:", rec_du( path ) );
      if(_counts[this_player()] >= MAX_FILES)
        printf("Note: count truncated due to file limit\n");
      return 1;
    }
    add_failed_mess( "You must have read access to a path to use "
                     "du on it.\n" );
    return 0;
}
mixed *query_patterns() {
    return ({ "", (: cmd( this_player()->query_path() ) :),
        "<string'path'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: cmds/creator/dup_licate.c
==================================================

#include <creator.h>
inherit "/cmds/base";
protected int do_duplicate(object *ov) {
   string pname, dummy;
   int i;
   object dup;
   mixed static_arg, dynamic_arg;
   for (i = 0; i < sizeof(ov); i++) {
      if (!ov[i]) {
         continue;
      }
      pname = file_name(ov[i]);
      if (sscanf(pname, "%s#%d", pname, dummy) != 2) {
        write("Can't duplicate " + ov[i]->short() + " (not a clone).\n");
        continue;
      } else {
         static_arg = ov[i]->query_static_auto_load();
         dynamic_arg = ov[i]->query_dynamic_auto_load();
         dup = clone_object(pname);
         if (dup && ov[i]) {
            ov[i] = dup;
            if (static_arg) {
              ov[i]->init_static_arg(copy(static_arg));
            }
            if (dynamic_arg) {
              ov[i]->init_dynamic_arg(copy(dynamic_arg));
            }
         }
         ov[i]->add_property("cloned by", this_player()->query_name());
      }
     if (!ov[i]) {
        printf("I seem to have lost your object.\n");
        return 1;
     }
     if (!ov[i]->move(this_player())) {
       write(ov[i]->short() + " duplicated and put in you.\n");
     } else if (!ov[i]->move(environment(this_player()))) {
       write(ov[i]->short() + " duplicated and put in here.\n");
     } else if (!ov[i]->move("/room/broken")) {
       write(ov[i]->short() + " duplicated and put in /room/broken.\n");
     } else {
       write("Couldn't find anyplace to put " + ov[i]->short() + "!\n");
       ov[i]->move("/room/rubbish");
     }
   }
   return 1;
}
mixed cmd(string str) {
  object *val;
  notify_fail("No such object.\n");
  val = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(val)) {
    notify_fail("No matching objects\n");
    return 0;
  }
  return do_duplicate(val);
}

==================================================
FILE: cmds/creator/ed.c
==================================================

#include <creator.h>
inherit "/cmds/base";
object *people = ({ });
mixed cmd(string str) {
  string *filenames, spam;
  object *things;
  people += ({ this_player() });
  if ( this_player()->query_editor() == "magic" )  {
    if ( !str )  str = " ";
    this_player()->do_edit( 0, "fini_editor", 0, str );
    return 1;
  }
  if (!str) {
    this_player()->set_in_editor("(hidden)");
    ed("frog", "fini_editor");
    return 1;
  }
  if (sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    spam = file_name(things[0]);
    sscanf(spam, "%s#%*d", spam);
    if (file_size(spam) < 0)
      filenames = ({ spam+".c" });
    else
      filenames = ({ spam });
  } else
    filenames = this_player()->get_files(str);
  if (!sizeof(filenames)) {
    str = this_player()->get_path(str);
  } else {
    if (sizeof(filenames) > 0) {
      str = filenames[0];
      if (sizeof(filenames) > 1) {
        int loop;
        loop = 0;
        while(loop < sizeof(filenames) && file_size(filenames[loop]) < 0)
          loop++;
        if(loop >= sizeof(filenames)) {
          printf("No such file.\n");
          people -= ({ this_player() });
          return 0;
        }
        else {
          str = filenames[loop];
        }
        printf("Ambiguous, using : %s\n", str);
      }
    }
  }
  if (file_size(str) == -2) {
    printf("directory\n");
    people -= ({ this_player() });
    return 0;
  }
  this_player()->set_in_editor(str);
  printf("Editing: %s ", str);
  if (!master()->valid_write(str, geteuid(), "frog"))
    printf("[read only]\n");
  else
    printf("\n");
  ed(str, "fini_editor");
  return 1;
}
void fini_editor() {
  if (objectp(this_player()))  {
    people -= ({ this_player() });
    this_player()->set_in_editor(0);
  }
}
int clean_up()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::clean_up();
   }
   return 1;
}
void reset()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::reset();
   }
   return;
}

==================================================
FILE: cmds/creator/exe_c.c
==================================================

#include <cmds/options.h>
inherit "/cmds/base";
#define LOG_FILE "/d/admin/log/EXEC.log"
mixed do_exec(string str, string ref suc) {
  mixed ret;
  string file;
  string wiz_dir;
  string file_header;
  object ob;
  if (!this_player()) {
    suc = "fail";
    return 0;
  }
  wiz_dir = "/w/" + this_player()->query_name();
  if (file_size(wiz_dir) != -2) {
    suc = "fail";
    return notify_fail("Directory: " + wiz_dir + " does not exist.\n");
  }
  file = wiz_dir + "/exec_tmp";
  if (ob = find_object(file)) {
    file->dest_me();
    if(ob)
      destruct(ob);
  }
  if (file_size(file + ".c") > 0) {
    rm(file+".c");
  }
  unguarded((: write_file(LOG_FILE, ctime(time()) + " - " +
                          this_player()->query_name() + ": " + $(str) +
                          "\n") :));
  file_header = this_player()->query_property(OPTION_EXEC_INCLUDE);
  if (file_header) {
     write_file(file + ".c", "#include \"" + file_header + "\"\n\n");
  }
  write_file(file + ".c",
             "void dest_me() { destruct(this_object()); }\n"
             "mixed do_call() {\n" + str + ";\n}\n");
  suc = catch(ret = file->do_call());
  if ((ob = find_object(file))) {
    ob->dest_me();
  }
  rm(file + ".c");
  return ret;
}
int cmd(string str) {
  string err;
  mixed ret = do_exec(str, ref err);
  if (err == "fail")
    return 0;
  if (err == 0) {
    this_player()->more_string(sprintf("\nReturns: %O\n", ret),
                               "Exec results");
  } else {
    printf("Exec failed: %s", err);
  }
  return 1;
}

==================================================
FILE: cmds/creator/find.c
==================================================

#include <creator.h>
#define WIZ WIZ_PRESENT
#define EXTRACT_CODE 1
#define LINE_NUMBERS 2
#define FIND_ALL 4
inherit "/cmds/base";
int file_exists(string str) { return (file_size(str) > -1); }
mixed cmd(string str) {
  string func, thing, s, ping;
  object *obs, fish, user = this_player();
  object *list;
  mixed *fnd;
  int i, flags;
  int k;
  notify_fail("Usage: find [-a] [-d] [-n] function() <object(s)>\n");
  if (!str)
     return 0;
  while (sscanf(str, "-%s %s", s, str) == 2)
    switch (s) {
    case "d":
        flags |= EXTRACT_CODE;
        flags &= ~FIND_ALL;
        break;
    case "n":
        flags |= (LINE_NUMBERS | EXTRACT_CODE);
        flags &= ~FIND_ALL;
        break;
    case "a":
        flags = FIND_ALL;
        break;
      default:
        return notify_fail("Unknown option '"+ s +"'.\n");
    }
  if (sscanf(str, "%s() %s", func, thing) != 2)
     if(sscanf(str, "%s %s", func, thing) != 2)
        return 0;
  obs = WIZ -> wiz_present(thing, user);
  if (!sizeof(obs))
    return notify_fail("Can't find " + thing + ".\n");
  s = "";
  fnd = ({ });
  for (i = 0; i < sizeof(obs); i++) {
     if (flags & FIND_ALL)
        list = ({ obs[i] }) + map(deep_inherit_list(obs[i]),
               (: find_object($1) :));
     else list = ({ obs[i] });
     for (k = 0; k < sizeof(list); k++)  {
        if ((ping = function_exists(func, list[k], 1))  &&
            member_array(ping, fnd) == -1)
        {
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() found in " + ping + "\n";
           fnd += ({ func, ping });
        } else if (!(flags & FIND_ALL))
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() not found.\n";
        fish = list[k];
        while (fish = shadow(fish, 0))
           if (function_exists(func, fish, 1)) {
              s += "      Shadowed by " + file_name(fish) + "\n";
              fnd += ({ func, base_name(fish) });
           }
     }
  }
  if ((flags & FIND_ALL)  &&  !sizeof(fnd))
     s += "*** " + func + "() not found.\n";
  if ((flags & EXTRACT_CODE) && sizeof(fnd)) {
    if (sizeof(fnd) > 2)
      s += "Can only extract code from one object at a time.\n";
    else {
      mixed tmp;
      int j = 0;
      int startline;
      ping = fnd[1] +".c";
      func = fnd[0];
      i = 0;
      if (!file_exists(ping))
        return notify_fail("The file for "+ thing +" doesn't exist.\n");
      tmp = read_file(ping);
      if(!strlen(tmp))
        return notify_fail("Could not read file.\n");
      tmp = reg_assoc(tmp,  ({"\n[a-z_ \t]*[\\* ][ \t]*" + func +
                    "[ \t]*\\([a-zA-Z0-9, _\\*\n\t]*(...)?[ \t]*\\)[ \t\n]*{"
                                , "\n}"})
                      , ({1, 2}));
      while(tmp[1][j] != 1)
        j++;
      if(flags & LINE_NUMBERS){
        startline = sizeof(explode(implode(tmp[0][0..j], ""), "\n"));
      }
      j++;
      while(tmp[0][j][i] != '\n'){
        if(tmp[0][j][i] == '}'){
          tmp = tmp[0][j - 1][1..] + tmp[0][j][0..i];
          if(flags & LINE_NUMBERS)
            tmp = implode(explode(tmp, "\n"),
                           (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                           ({startline, ""}))[1];
          user->more_string(sprintf("%s%s", s, tmp), 0, 1);
          return 1;
        }
        i++;
      }
      tmp = implode(tmp[0][j-1..j+1], "");
      if(flags & LINE_NUMBERS)
        tmp = implode(explode(tmp, "\n"),
                      (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                      ({startline, ""}))[1];
      s += tmp;
    }
  }
  user->more_string(s, 0, 1);
  return 1;
}

==================================================
FILE: cmds/creator/finde_rrors.c
==================================================

#include <log.h>
#include <board.h>
#include <mail.h>
inherit "/cmds/base";
#define HELPER "/obj/handlers/finderror_helper"
#define ERROR_CMD "/cmds/creator/errors"
private void finished_count_errors( object player, int status, mixed data ) {
    int *count;
    string *paths;
    mapping errors = ([ ]);
    int *total = ({ 0, 0, 0 });
    string txt;
    foreach( mapping direc in data ) {
        count = errors[ direc[ "Directory" ] ];
        if ( undefinedp( count ) ) {
            count = ({ 0, 0, 0 });
        }
        switch( direc[ "Type" ] ) {
            case "BUG":
                count[ 0 ] = direc[ "COUNT(Id)" ];
                total[ 0 ] += count[ 0 ];
            break;
            case "TYPO":
                count[ 1 ] = direc[ "COUNT(Id)" ];
                total[ 1 ] += count[ 1 ];
            break;
            case "IDEA":
            default:
                count[ 2 ] = direc[ "COUNT(Id)" ];
                total[ 2 ] += count[ 2 ];
        }
        errors[ direc[ "Directory" ] ] = count;
    }
    paths = sort_array( keys( errors ), 1 );
    txt = "$P$finderrors$P$BUGS TYPO IDEA\n";
    foreach( string key in paths ) {
        txt += sprintf( "%4d %4d %4d %s\n", errors[ key ][ 0 ],
            errors[ key ][ 1 ], errors[ key ][ 2 ], key );
    }
    txt += "-------------\n";
    txt += sprintf( "%4d %4d %4d\n",
        total[ 0 ], total[ 1 ], total[ 2 ] );
    tell_object( player, txt );
}
private int count_errors() {
    int result;
    result = HELPER->query_dirs_count( this_player(),
        (: finished_count_errors :) );
    if ( result ) {
        add_succeeded_mess( ({ "Retrieving error count, this may take several "
            "seconds.\n", "" }) );
        return 1;
    }
    add_failed_mess(  "You have no finderrors directories defined.  "
        "Add them with 'finderrors add'\n" );
    return -1;
}
private void finished_next_dir( object player, int status, mixed data ) {
    if ( sizeof( data ) != 1 || !mapp( data[0] ) ) {
        tell_object( player, "Unable to find the next directory "
            "with errors.\n" );
    }
    else {
        ERROR_CMD->errors_in_dir(data[0]["Directory"], 0);
    }
}
private int get_next_error() {
    HELPER->query_next_dir( this_player(), (: finished_next_dir :) );
    add_succeeded_mess( ({ "Retrieving error count, this may take several "
        "seconds.\n", "" }) );
    return 1;
}
private int list_error_directories() {
    string *dirs;
    dirs = HELPER->query_directories( this_player()->query_name() );
    if ( sizeof( dirs ) ) {
        tell_object( this_player(), "$P$finderrors list$P$" +
            implode( dirs, "\n" ) + "\n" );
        add_succeeded_mess( "" );
        return 1;
    }
    else {
        add_failed_mess( "No directories have been added to finderrors.\n" );
        return -1;
    }
}
private int add_directory( string directory, int recursive ) {
    if ( directory[ <1 ] != '/' ) {
        directory += "/";
    }
    if ( file_size( directory ) != -2 ) {
        add_failed_mess( directory + " is not a directory.\n" );
        return -1;
    }
    HELPER->add_directory( this_player(), directory, recursive );
    return 1;
}
private int remove_directory( string directory, int recursive ) {
    int result;
    result = HELPER->remove_directory( this_player(), directory, recursive );
    if ( result ) {
        add_succeeded_mess( "Directory removed successfully.\n" );
        return 1;
    }
    add_failed_mess( "Could not remove directory.  Was it on your "
        "finderrors list?\n" );
    return -1;
}
public mixed *query_patterns() {
    return ({
              "add <word>", (: add_directory( $4[ 0 ], 0 ) :),
              "add <word> recursive", (: add_directory( $4[ 0 ], 1 ) :),
              "remove <word>", (: remove_directory( $4[ 0 ], 0 ) :),
              "remove <word> recursive", (: remove_directory( $4[ 0 ], 1 ) :),
              "list", (: list_error_directories :),
              "count", (: count_errors :),
              "", (: get_next_error :) });
}

==================================================
FILE: cmds/creator/gr_ep.c
==================================================

inherit "/cmds/base";
#include <creator.h>
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
string *check_perms(string *done, string file){
  mixed perm=master()->valid_read(file, this_player()->query_name(), "cat");
  if(!perm)
    return done;
  if(intp(perm))
    perm = file;
  return done + ({perm});
}
mixed cmd(string arg) {
  int fd, search = 0, nfiles = 0;
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});
    foreach(bit in bits){
      string *files, file;
      if (bit[0] == '-'){
        if( ( bit == "-r" || bit == "--recursive" || bit== "-d=recurse" ||
       bit == "--directories=recurse" || bit == "-recursive" ||
        bit == "-directories=recurse" ) && !this_player()->query_lord() )
          continue;
        arg += (" " + bit);
        continue;
      }
      if(!search){
        search = 1;
        arg += (" " + bit);
      } else {
        files = this_player()->get_files(bit);
        files = implode(files, (:check_perms:), ({}));
        foreach(file in files){
          arg += (" " + file[1..]);
          nfiles++;
        }
      }
    }
  }
  if(nfiles || !search)
    fd = external_start(6, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  else
    return notify_fail("Grep needs at least one file.\n");
  if (fd == -1)
    return notify_fail("grep failed somehow.\n");
  TP = this_player();
  RET = "";
  write("grep started.\n");
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "grep: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "grep finished.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/harass.c
==================================================

string info = "";
mapping busy = ([]);
void create(){
  seteuid("Root");
}
void receive_snoop(string bing){
  info += bing;
}
string query_result(){ return info; }
void remind(){
  if(busy[this_player()]){
    write("Type harass again to stop logging.\n");
    call_out((:remind:), 60);
  }
}
mixed *query_patterns(){
  return ({"", function(){
      if(busy[this_player()]){
        string result = busy[this_player()]->query_result();
        unguarded((:write_file,sprintf("/d/liaison/secure/harass/%s%d",
                                       this_player()->query_name(), time()),
                   $(result):));
        destruct(busy[this_player()]);
        map_delete(busy, this_player());
        write("Log written.\n");
        return 1;
      } else {
        busy[this_player()] = clone_object(__FILE__);
        if(efun::snoop(busy[this_player()], this_player())){
          write("Started logging.\nType harass again to stop.\n");
          call_out((:remind:), 60);
          return 1;
        } else {
          destruct(busy[this_player()]);
          map_delete(busy, this_player());
          write("Failed.\n");
          return 1;
        }
      }
    }
  });
}

==================================================
FILE: cmds/creator/indent.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 4
mapping globals = ([]), ret = ([]), cmds = ([]);
#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
mixed cmd(string arg) {
  int nfiles = 0;
  int fd;
  string bit;
  string *bits;
  object *things;
  if (!arg) {
    return notify_fail("rcsin: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  foreach(bit in bits) {
    string files = "", file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0) {
          file += ".c";
        }
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcsin: no such file "+arg+".\n");
  }
  fd = external_start(CMD_NUM, explode(arg, " "),
                      "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff;
  int i;
  if (RET != "") {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  <--  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0..2] == "ci:") {
          i += 2;
      }
      else {
          i += 3;
      }
    }
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/lo_ad.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string *filenames, err, fname, *failed, *succ, ret, load_err;
  int size;
  if (!str) {
    return notify_fail("Load what?\n");
  }
  filenames = this_player()->get_cfiles(str);
  if (!sizeof(filenames)) {
    return notify_fail("No such object.\n");
  }
  failed = succ = ({ });
  load_err = "";
  foreach (fname in filenames) {
    if (file_size(fname) < 0) {
      failed += ({ fname });
      continue;
    }
    if ((err = catch(fname->load_up_with_yellow()))) {
      load_err += sprintf("Failed to load %s, error: %s", fname, err);
    } else {
      succ += ({ fname });
    }
  }
  ret = "";
  if ((size = sizeof(failed))) {
    ret += sprintf("%s %s not %sregular file%s.\n",
                   query_multiple_short(failed), (size == 1 ? "is" : "are"),
                   (size == 1 ? "a " : ""), (size == 1 ? "" : "s"));
  }
  if (strlen(load_err)) {
    ret += load_err;
  }
  if (sizeof(succ)) {
    ret += sprintf("$I$5=$C$Loaded %s.\n", query_multiple_short(succ));
  }
  this_player()->show_message("$P$Load$P$" + ret);
  return 1;
}

==================================================
FILE: cmds/creator/locks.c
==================================================

#include <creator.h>
int cmd(string){
  string *bits, rcspath, *files, path, tmp;
  files = get_dir(this_player()->query_current_path()+"/");
  write("locked files in this directory:\n");
  foreach(path in files) {
    path = this_player()->query_current_path() + "/" + path;
    bits = explode(path, "/");
    if(sizeof(bits) > 2) {
      rcspath = "/" + implode(bits[0..sizeof(bits)-2], "/") + "/RCS/";
    } else if(sizeof(bits) == 2) {
      rcspath = "/" + bits[0] + "/RCS/";
    } else
      rcspath = "/";
    rcspath += bits[sizeof(bits)-1] + ",v";
    if(file_size(rcspath) > 0) {
      tmp = read_file(rcspath, 4, 1);
      if(tmp == "locks\n") {
        string lockname ;
        tmp = read_file(rcspath, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        printf("%s locked by %s\n", path, lockname);
      }
    }
  }
  return 1;
}
string help() {
  return "Displays the files that are locked in your current directory.";
}
