# Total Tokens: 25017
# Total Files Merged: 19
# Total Characters: 83438

ayer/apply.c
==================================================

#include <applications.h>
#include <board.h>
#include <playerinfo.h>
#include <mail.h>
#include <player.h>
inherit "/cmds/base";
varargs void begin_application (object, string, string);
class applying_player {
   int step;
   object player;
   string domain;
   string next_method;
   string type;
   string *questions;
   string *answers;
}
class vouch_info {
  string applicant;
  string voucher;
  string position;
}
void create() {
  seteuid (geteuid());
}
int do_creator_apply(string domain, string type) {
  int temp;
  if (!domain) {
    domain = type;
  }
  if( this_player()->query_property( "guest" ) ) {
    write( "Only people with permanent characters are allowed to "
      "become Creators.\n" );
    return 1;
  }
  temp = APPLICATIONS_HANDLER->query_applications_accepted( domain );
  if( temp == -1 ) {
    this_player()->add_failed_mess( this_object(), "The domain " +
       domain + " is not a valid domain.\n" );
    return 0;
  }
  if( temp == 0 ) {
    this_player()->add_failed_mess (this_object(), "The domain " +
    domain + " is not currently open for applications.\n");
    return 0;
  }
  if( !APPLICATIONS_HANDLER->valid_application (this_player()->query_name(),
    type ) && !this_player()->query_lord() ) {
      write( "Sorry, you have not fulfilled the requirements yet.\n" );
      return 1;
  }
  if (domain == "liaison") {
    type = "liaison";
  }
  if (strsrch (domain, "playtester") != -1) {
    type = "playtester";
  }
  begin_application (this_player(), type, domain);
  return 1;
}
void confirm (string message,  class applying_player tmp) {
  if (!message || !sizeof (message) || strsrch (message, "no") != -1
    || strsrch (message, "n") != -1) {
    return;
  }
  else {
    call_other (this_object(), tmp->next_method, tmp->player, tmp);
  }
}
string query_application_info (string domain) {
  string ret;
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
    ret = read_file( "/d/" + domain + "/application.txt" );
  }
  return ret;
}
varargs void begin_application (object player, string type, string domain) {
  class applying_player tmp;
  string ret = APPLICATIONS_HANDLER->query_intro_text (type);
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
      ret += "\nPlease read the following information about applying to "
             "$C$" + domain + ": \n\n" ;
      ret += query_application_info (domain);
   }
  tell_object (this_player(), ret + "\n");
  tmp = new (class applying_player);
  tmp->type = type;
  tmp->domain = domain;
  tmp->answers = ({ });
  tmp->step = 1;
  tmp->next_method = "do_questions";
  tmp->player = player;
  tell_object (player, "Do you wish to continue your application?\n");
  this_player()->do_edit( "", "confirm", this_object(), 0,
    tmp);
}
varargs void do_questions (object player, class applying_player tmp) {
  if (tmp->step == 1) {
    tmp->questions = APPLICATIONS_HANDLER->query_questions (tmp->type);
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[0]
    + "%^RESET%^\n");
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void start_asking(string message, class applying_player tmp) {
  object player = tmp->player;
  if (!message || sizeof (message) == 0) {
    tell_object (player, "Your application has been aborted.\n");
    return;
  }
  tmp->answers += ({ message });
  if (tmp->step == sizeof (tmp->questions)) {
    tell_object (player, "Do you wish to submit your application?\n");
    tmp->next_method = "submit_application";
    this_player()->do_edit( "", "confirm", this_object(), 0,
      tmp);
    return;
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[tmp->step]
    + "%^RESET%^\n");
  tmp->step += 1;
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void submit_application (object player, class applying_player tmp) {
  int i;
  string *text = ({ });
  for (int j = 0; j < sizeof (tmp->questions); j++) {
    text += ({ "%^CYAN%^" +sprintf( "%2d) %-=*s", ( j + 1), 70,
      tmp->questions[j] ) + "%^RESET%^\n" });
    text += ({ sprintf( "      %-=*s\n\n", 72, tmp->answers[j] )});
  }
  i = APPLICATIONS_HANDLER->add_application (tmp->type, player->query_name(),
    implode (text, "\n"), tmp->domain);
  if (!i) {
    tell_object (player, "Something has gone wrong!\n");
    return;
  }
  else {
    tell_object (player, "Thank you for your application... it has been "
      "placed in the handler ready for people to vouch.\n");
  }
}
int do_list_types() {
  string ret = "";
  string *types;
  types = APPLICATIONS_HANDLER->query_types();
  ret += "You can apply for the following positions with this command:\n\n";
  foreach (string t in types) {
    ret += t + "\n";
  }
  this_player()->more_string (ret);
  return 1;
}
int do_list_requirements(string type) {
  string ret = APPLICATIONS_HANDLER->application_requirements (type);
  this_player()->more_string (ret);
  return 1;
}
int domain_status() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  foreach (string s, int o in map) {
    ret += (o ? "%^BOLD%^%^CYAN%^" : "") + capitalize (s) + " is " +
           (o ? "open" : "closed") + "%^RESET%^ to "
      "applications and is managed by " +
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n";
  }
  write("$P$Domain Status$P$" + ret);
  return 1;
}
int do_list_questions (string type) {
  string *quest = APPLICATIONS_HANDLER->query_questions (type);
  tell_object (this_player(), "\n\nPlease take time to write your application.  "
     "Preferably, prepare an answer to each of these questions off-line "
     "and copy your response into the editor on the MUD if possible.  "
     "You will be asked these questions one-by-one during the application "
     "process, so you should answer each question thoroughly.  Remember, "
     "this is a formal application to a position of responsibility, so "
     "treat each question seriously.\n\n");
  this_player()->more_string (implode (quest, "\n\n"));
  return 1;
}
int do_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->find_application (name, position);
  class vouch_info tmp;
  tmp = new (class vouch_info);
  if (i == -1) {
    write (capitalize (name) + " has not applied for a "
      + position + " position.\n");
    return 1;
  }
  tell_object (this_player(), "%^BOLD%^Why do you think " + capitalize (name)
    + " would be a suitable " + position + "? %^RESET%^");
  tmp->applicant = name;
  tmp->voucher = this_player()->query_name();
  tmp->position = position;
  this_player()->do_edit( "", "vouch_edit", this_object(), 0,
    tmp);
  return 1;
}
void vouch_edit(string message, class vouch_info tmp) {
  object ob;
  int i;
  string name = tmp->applicant;
  string position = tmp->position;
  ob = find_player (tmp->voucher);
  if (!sizeof (message) || message == "") {
    if (ob) {
      tell_object (ob, "Your vouch has been aborted.\n");
    }
  }
  else {
    i = APPLICATIONS_HANDLER->make_vouch (position, name, tmp->voucher, message);
    switch (i) {
      case 2:
        tell_object (ob, "You submit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 1:
        tell_object (ob, "You resubmit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 0:
        tell_object (ob, "You cannot submit a vouch for yourself.\n");
      break;
      case -1:
        tell_object (ob, "There is no application for " + capitalize (name) +
          " as a " + position + ".\n");
      break;
    }
  }
}
int do_delete_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->delete_vouch (this_player()->query_name(),
    name, position);
  if (i) {
    tell_object (this_player(), "You delete your vouch for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), "You have not vouched for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  return 1;
}
int query_my_vouch (string name, string position) {
  string v = APPLICATIONS_HANDLER->query_vouch (position, name,
    this_player()->query_name());
  if (!v) {
    tell_object (this_player(), "There is no application for "
      + capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), v + "\n");
  }
  return 1;
}
int delete_application (string pos) {
  int i = APPLICATIONS_HANDLER->delete_application (pos,
    this_player()->query_name());
  if (!i) {
    tell_object (this_player(), "You have no pending applications for "
      "that position.\n");
  }
  else {
    tell_object (this_player(), "Your application has been deleted.\n");
  }
  return 1;
}
int do_register() {
   if ( this_player()->query_property( "guest" )==1 ) {
      write ( "You are a guest. Registering as a player killer is not an "
        "option for you.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+
        " (" +query_ip_number(this_player()) + ") (a guest) tried to "
        "register as a player killer.\n");
      return 1;
   }
   if (this_player()->query_player_killer()) {
      add_failed_mess( "You already are a player killer, silly!\n" );
      return 0;
   }
   if (-this_player()->query_time_on() < PKER_MINIMUM_AGE) {
      add_failed_mess( "You are not old enough to be a player killer.  You "
        "must be " + (PKER_MINIMUM_AGE / (60 * 60 * 24)) + " days old to "
        "register as a player killer.\n");
      return 0;
   }
   if (this_player()->query_property(PKER_NOT_ALLOWED)) {
      write( "Due to previous abuses of the playerkiller system, you are "
         "not allowed to become a playerkiller.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+ " (" +query_ip_number(this_player()) +
        ") (not allowed to be a pk) tried to register as a player "
        "killer.\n");
      return 1;
   }
   write( "%^BOLD%^%^YELLOW%^You are hereby registering yourself as "
          "a player killer.\n\n"
          "This means that you can attack and be attacked by other "
          "player killers.  Once you are a registered player killer, "
          "there is NO going back.  Please note, this is NOT a quest "
          "and you will NOT get any experience points from doing "
          "it.%^RESET%^\n");
   write( "Are you sure about this, (Y/N)?\n");
   input_to("register2");
   return 1;
}
void register2(string str)
{
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
      write("You need to type 'y' or 'n'.\n");
      write("Are you sure about this, (Y/N)? ");
      input_to("register2");
      return ;
   }
   if (str[0] == 'n' ||
       str[0] == 'q') {
      write("You have chosen not to register as a playerkiller at this "
         "time.  You may choose to register later if you wish.\n");
   } else {
      write("%^BOLD%^%^YELLOW%^You are now a playerkiller, ready to kill and be killed.%^RESET%^\n");
      this_player()->set_player_killer(1);
      PLAYERINFO_HANDLER->add_entry( this_player(),
        this_player()->query_name(), "misc",
        "Registered as a Player Killer." );
   }
}
int do_query_all_vouches() {
  mapping tmp = APPLICATIONS_HANDLER->query_vouches_for_all
    (this_player()->query_name());
  string *ret = ({ });
  string tmp2;
  if (!sizeof (tmp)) {
    this_player()->add_failed_mess (this_object(), "You have made no "
      "vouches for anyone.\n", ({ }));
    return 0;
  }
  foreach (string n, string v in tmp) {
    tmp2 = "$I$5=%^CYAN%^" + capitalize (n) + "%^RESET%^: " + v;
    ret += ({ tmp2 });
  }
  this_player()->more_string (implode (ret, "\n\n"));
  return 1;
}
private int do_list_applicants() {
  string ret;
  if (!this_player()->query_lord()) {
    return 0;
  }
  ret = APPLICATIONS_HANDLER->list_applications();
  this_player()->more_string (ret);
  return 1;
}
private int do_browse_app (string type, string name) {
  int i = APPLICATIONS_HANDLER->find_application (name, type);
  string ret;
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "There is no "
      +type + " application for " + name + ".\n", ({ }));
    return 0;
  }
  ret = APPLICATIONS_HANDLER->format_application (i);
  this_player()->more_string (ret);
  return 1;
}
int query_my_vouches (string position) {
  mapping i = APPLICATIONS_HANDLER->query_application_vouches
    (this_player()->query_name(), position);
  if (!i) {
    this_player()->add_failed_mess (this_object(), "You currently have no vouches "
      "for a " + position + " application.\n", ({ }));
    return 0;
  }
  else {
    tell_object (this_player(), "The following people have vouched for your " +
      position + " application:  " + query_multiple_short (map (keys (i),
        (: capitalize ($1) :))) + ".\n");
    return 1;
  }
}
mixed* query_patterns() {
   string t = "{" + implode (APPLICATIONS_HANDLER->query_types(), "|")
    + "}";
   mixed *tmp;
   tmp = ({
             "as creator in <word> domain", (: do_creator_apply($4[0], "creator") :),
             "as player killer", (: do_register() :),
             "as playtester", (: do_creator_apply("playtesters", "playtester") :),
             "as liaison", (: do_creator_apply(0, "liaison") :),
             "delete my application as <word'position'>",
              (: delete_application ($4[0]) :),
             "list available positions", (: do_list_types() :),
             "list requirements for " + t + " applications",
              (: do_list_requirements($4[0]) :),
             "list position status", (: domain_status() :),
             "list questions for " + t + " applications",
              (: do_list_questions ($4[0]) :),
             "vouch for <word'name'> as <word'position'>",
              (: do_vouch ($4[0], $4[1]) :),
             "delete vouch for <word'name'> as <word'position'>",
              (: do_delete_vouch ($4[0], $4[1]) :),
             "query vouch for <word'name'> as <word'position'>",
              (: query_my_vouch ($4[0], $4[1]) :),
             "query all my vouches", (: do_query_all_vouches() :),
             "query vouches for my <word> application", (: query_my_vouches($4[0]) :),
  });
  if (this_player()->query_lord()) {
    tmp += ({"browse <word'type'> application for <word'name'>", (: do_browse_app($4[0], $4[1]) :) });
    tmp += ({"list applicants", (: do_list_applicants() :) });
  }
  return tmp;
}
void clean_up() {
  return 0;
}
int application_board_access_check( int type, string board,
                                    object previous, string name ) {
   switch(type) {
      case B_ACCESS_READ :
         return 1;
      case B_ACCESS_WRITE :
         if( file_name(previous) == file_name( this_object() ) )
            return 1;
          if (base_name (previous) == APPLICATIONS_HANDLER) {
            return 1;
          }
         return master()->query_lord(name);
      case B_ACCESS_DELETE :
         return 0;
   }
}
void reset() {
}

==================================================
FILE: /lib/cmds/player/appraise.c
==================================================

#include <volumes.h>
int cmd(object *things);
string query_length_mess(int number) {
    int half_feet;
    switch(number) {
        case 0:
            return "not very";
        case 1:
            return "an inch";
        case 2:
            return "a couple of inches";
        case 3:
            return "three inches";
        case 4:
            return "four inches";
        case 5..7:
            return "about six inches";
        case 8..10:
            return "about nine inches";
        case 11..14:
            return "about a foot";
        case 15..21:
            return "about a foot and a half";
        case 22..27:
            return "about two feet";
        case 28..33:
            return "about two and a half feet";
        default:
            half_feet = (number + 3)/6;
            if( half_feet%2 ) {
                return "about " + query_num(half_feet/2) + " and a half feet";
            }
            else {
                return "about " + query_num(half_feet/2) + " feet";
            }
    }
}
string query_dimensions_mess(object thing) {
    return "is " + query_length_mess(thing->query_length()) + " long and " +
        query_length_mess(thing->query_width()) + " wide.";
}
string query_appearance_mess(object thing) {
    string material_mess;
    if( !sizeof(thing->query_materials()) ) {
        material_mess = "some unidentifiable material";
    }
    else {
        material_mess = query_multiple_short(thing->query_materials());
    }
    if(thing->query_colour()) {
        return "is " + thing->query_colour() + " and is made of " +
            material_mess;
    }
    else {
        return "is made of " + material_mess;
    }
}
string query_type_mess(object thing) {
    if( thing->query_plant() ) {
        return "appears to be some sort of plant";
    }
    if( thing->query_food_object() ) {
        if( thing->query_liquid() ) {
            return "looks drinkable";
        }
        else {
            return "looks edible";
        }
    }
    if( thing->query_furniture() ) {
        return "could be placed as furniture";
    }
    if( thing->query_property("shop type") == "jewellers" ) {
        return "appears to be a piece of jewellery";
    }
    if( thing->query_weapon() ) {
        return "could be used as a weapon";
    }
    if( thing->query_armour() && thing->query_wearable()) {
        return "could be worn as armour";
    }
    if( thing->query_wearable() ) {
        return "looks like you could wear it";
    }
    if (thing->query_no_limbs() > 0) {
        return "looks like you could hold it";
    }
    return 0;
}
string query_container_mess(object thing) {
   int volume;
   int size;
   string str;
   volume = thing->query_max_volume();
   if (thing->query_container()) {
      size = thing->query_max_size();
   }
   if (size || volume) {
      str = "";
      if (size) {
         str += "can hold about " + (size / 9) + " pounds";
      }
      if (volume) {
         if (size) {
            str += " and ";
         }
         str += "can hold about ";
         if (volume > VOLUME_GALLON) {
            str += ((volume + VOLUME_GALLON / 2) / VOLUME_GALLON) + " gallons";
         } else if (volume >= VOLUME_QUART) {
            str += ((volume + VOLUME_QUART / 2) / VOLUME_QUART) + " quarts";
         } else if (volume >= VOLUME_PINT) {
            str += ((volume + VOLUME_PINT / 2) / VOLUME_PINT) + " pints";
         } else if (volume >= VOLUME_GILL) {
            str += ((volume + VOLUME_GILL / 2) / VOLUME_GILL) + " gills";
         } else if (volume >= VOLUME_SHOT) {
            str += ((volume + VOLUME_SHOT / 2) / VOLUME_SHOT) + " shots";
         } else {
            str += "nothing";
         }
      }
      return str;
   }
   return 0;
}
int cmd(object *things) {
    object thing;
    string mess;
    string tmp;
    if(!sizeof(things)) {
        add_failed_mess("For some reason, you "
            "have nothing to appraise.  Please bugrep this.\n", ({ }) );
        return 0;
    }
    if(sizeof(things) > 1) {
        add_failed_mess("You cannot appraise "
            "more than one object at once.\n", ({ }) );
        return 0;
    }
    if (thing == this_player()) {
        if (this_player()->query_name() == "penguin") {
           write("Is that a tuxuedo you are wearing?  No, probably not.\n");
        } else {
           write("You appraise yourself.  " + (random(10) + 1) + " out of 10.\n");
        }
        return 0;
    }
    thing = things[0];
    if(environment(thing) != this_player()) {
        add_failed_mess("You cannot appraise "
            "objects you are not carrying.\n", ({ }) );
        return 0;
    }
    if(living(thing)) {
        write("You appraise " + thing->the_short() + " and mmmm, very "
            "sexy.\n");
        return 1;
    }
    if(thing->query_worn_by()) {
        add_failed_mess("You cannot appraise "
            "$I while you are wearing it.\n", ({ thing }) );
        return 0;
    }
    if( !thing->query_clothing() ) {
        mess = thing->the_short() + " " + query_dimensions_mess(thing);
        mess += "  ";
    }
    else {
        mess = "";
    }
    tmp = query_type_mess(thing);
    if(tmp) {
        mess += "It " + query_appearance_mess(thing);
        mess += " and " + tmp + ".";
    }
    else {
        mess += "It " + query_appearance_mess(thing) + ".";
    }
    tmp = query_container_mess(thing);
    if (tmp) {
       mess += "  It " + tmp + ".";
    }
    if(thing->cond_string() && thing->cond_string() != "") {
        mess += "  " + thing->cond_string();
    }
    else {
        mess += "\n";
    }
    write("$P$Appraise$P$" + mess );
    add_succeeded_mess("");
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me-here'item'>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/player/arguments.c
==================================================

#include <philosophies.h>
inherit "/cmds/base";
int cmd() {
   string *args;
   args = PHILOSOPHY_HANDLER->query_all_known(this_player()->query_name());
   if (!sizeof(args)) {
      write("You do not know any theological arguments.\n");
   } else {
      write("You know the following theological arguments:\n" +
            query_multiple_short(args) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: /lib/cmds/player/birthdays.c
==================================================

inherit "/cmds/base";
int cmd()  {
   object *peeps;
   peeps = filter(users(), (: $1->query_visible(this_player())  &&
                              $1->query_is_birthday_today() :));
   if (sizeof(peeps) == 0)
      return notify_fail("No one has a birthday today.\n");
   if (sizeof(peeps) == 1)
      printf("%s has a birthday today.\n", peeps[0]->short());
   else
      write(query_multiple_short(peeps) + " have a birthday today.\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: /lib/cmds/player/brief.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(string which, string type) {
  string t, disp;
  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types())
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    write(disp + "\n");
  }
  else if(type == "all") {
    foreach(t in TP->query_verbose_types())
      TP->set_verbose(t, which == "verbose");
    write("Ok\n");
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
  } else {
    write("No such option.\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("brief", $4[0]) :),
            "", (: cmd("brief", 0) :),
         });
}

==================================================
FILE: /lib/cmds/player/bright.c
==================================================

inherit "/cmds/base";
#include <dirs.h>
#define THRESHOLDS ({ 10, 30, 200, 300 })
string illumination( int number ) {
   if ( number < 0 ) {
      return "in the darkness that lies beyond darkness";
   }
   if ( number < THRESHOLDS[ 0 ] ) {
      return "in pitch darkness";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "in near darkness";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return "too brightly lit to see";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return "too brightly lit to see clearly";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 5 :
      return "very poorly lit";
   case 6 .. 10 :
      return "poorly lit";
   case 11 .. 20 :
      return "dimly lit";
   case 21 .. 30 :
      return "quite well lit";
   case 31 .. 40 :
      return "well lit";
   case 41 .. 50 :
      return "brightly lit";
   default :
      return "very brightly lit";
   }
}
string intensity(int number, object thing) {
   int flag = (thing == this_player());
   if (number < 0) {
      return (flag?"are":"is") + " dark beyond darkness";
   }
   if (number < THRESHOLDS[0]) {
      return "produce" + (flag?"":"s") + " a faint light";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "produce" + (flag?"":"s") + " a bit of light";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return (flag?"are":"is") + " so bright you can't bear to look";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return (flag?"are":"is") + " so bright it hurts to look";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 24 :
      return "produce" + (flag?"":"s") + " quite a bit of light";
   case 25 .. 49 :
      return (flag?"are":"is") + " very bright";
   default :
      return (flag?"are":"is") + " extremely bright";
   }
}
int check_exists(string file) {
  int retval;
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    retval = 1;
  } else {
    retval = 0;
  }
  return retval;
}
mixed cmd(object *things) {
   int its_light;
   string results;
   string no_light_results;
   object thing;
   object* no_light;
   int result_light;
   results = "";
   if (environment(this_player())->query_light() < THRESHOLDS[0]) {
      results += "Wherever you are, it's ";
   } else {
      results += "$C$"+ environment(this_player())->the_short(1) + " is ";
   }
   results += illumination(environment(this_player())->query_light()) + ".\n";
   if (!things) {
      write(results);
      return 1;
   }
   no_light_results = "";
   no_light = ({ });
   foreach(thing in things) {
      its_light = (int)thing->query_light();
      if (its_light) {
        results += "$C$" + thing->the_short(1) + " " +
          intensity(its_light, thing) + ".\n";
        result_light = 1;
      } else {
         no_light += ({ thing });
      }
   }
   if (sizeof(no_light) && !result_light) {
      write("$C$" + query_multiple_short(no_light, "one", 0, 1) +
            ((sizeof(no_light) == 1  &&  no_light[0] != this_player()) ?
               " produces" : " produce") + " no light at all.\n");
   }
   write(results);
   return 1;
}
int cmd_exit(string arg) {
   object room;
   string other;
   room = environment(this_player());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if(!room->query_exit(arg)) {
     arg = (string)this_player()->find_abs(arg);
   }
   if ( room->query_exit( arg ) ) {
      other = room->query_destination(arg);
      if ( check_exists( other )) {
         object door;
         door = room->query_door_control(arg);
         if(room->query_door_open(arg) ||
            door->query_transparent()) {
            write(other->the_short(1) + " is " +
                       illumination(other->query_light()) + ".\n");
            return 1;
         } else {
            add_failed_mess("The exit " + arg + " is not open.\n");
            return 0;
         }
      } else {
         add_failed_mess("The exit " + arg + " does not exist.\n");
         return 0;
      }
   }
   add_failed_mess("Unable to find the exit " + arg + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "exit <string'exit name'>", (: cmd_exit($4[0]) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: /lib/cmds/player/bug.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("BUG");
   set_use_last_error(1);
}

==================================================
FILE: /lib/cmds/player/bugcheck.c
==================================================

#define WEIRD_OBJECT_LOG "/log/secure/playtesters/bugcheck-weird-objects"
inherit "/cmds/base";
varargs int cmd(object *obs) {
    string* s;
    string txt;
    foreach ( object ob in obs ) {
        if ( stringp( ob->query_property( "virtual name" ) ) )
            s = explode( ob->query_property( "virtual name" ), "/" );
        else
            s = explode( base_name( ob ), "/" );
        switch ( s[ 0 ] ) {
        case "d":
            write(capitalize( ob->the_short() ) +
                         " is a domain thing.  It's probably safe to "
                         "bugrep it directly.\n" );
            break;
        case "w":
            write(capitalize( ob->the_short() ) +
                         "... why do you have a creator item?\n" );
            log_file ("ILLEGAL_OBJECT", "%s: %s tried to bugcheck %s.\n\n",
              ctime(time()), this_player()->query_name(), base_name (ob));
            break;
        case "std":
            write(capitalize( ob->the_short() ) +
                         " is a weird MUD library thing.  If you bugrep "
                         "it, the response might be slow.  It may be a "
                         "better idea to bugrep the room that the object "
                         "was found in.\n" );
            break;
        case "obj":
          switch (s[1]) {
            case "weapons":
            case "armours":
            case "clothes":
            case "food":
            case "jewellery":
              write(capitalize( ob->the_short() ) +
                         " is a Disc-wide item, but belongs to a directory "
                         "that is checked regularly.  Best to make the "
                         "bugrep directly on the item.\n" );
            break;
            default:
              write(capitalize( ob->the_short() ) +
                         " is a fairly general Disc-wide object.  If you "
                         "bugrep it, the response might be slow.  It would "
                         "most likely be a better idea to bugrep the room "
                         "in which the object was found.\n" );
            break;
          }
        break;
        case "global":
          switch (s[1]) {
            case "player":
            case "lord":
            case "playtester":
              if ( ob == this_player() ) {
                  txt = "are";
              }
              else {
                  txt = "is";
              }
              write(capitalize( ob->the_short() ) +
                         " " + txt + " the general " + s[1] + " object... if your "
                         "bugrep is on this, then bugrep this object.  If "
                         "your bugrep is along the frivolous lines of '"
                         + ob->the_short() +" " + txt + " overpowered!', "
                         "then don't "
                         "bugreport it... be sure and raise the issue on the "
                         "nearest bulletin board.\n" );
            break;
          }
        break;
        default:
            write("I've got no idea about " +
                         ob->the_short() + ".  Sorry it didn't work out.\n" );
            log_file( WEIRD_OBJECT_LOG, implode( s, "/" ) + "\n" );
            break;
        }
    }
    return 1;
}
int cmd_room() {
   write("Bug report the room for anything that seems to be odd in the room, "
         "descriptions being wrong, items you look at being wrong.  Anything "
         "odd you see that does not seem to fit anywhere else should also be "
         "reported to the room.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:'thing'>", (: cmd($1) :),
             "here", (: cmd_room :)
    });
}

==================================================
FILE: /lib/cmds/player/bury.c
==================================================

#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
inherit "/cmds/base";
#define TP this_player()
#define GP_INCREMENT 10
#define MAX_BURY_NUMBER 20
mixed cmd(object *obs) {
   string person;
   mixed effs, *xp;
   string* messages;
   object ob, tmp;
   object *sobs;
   object *fobs;
   object *too_many;
   int gp;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   sobs = ({ });
   fobs = ({ });
   too_many = ({ });
   if (TP->query_property("dead")) {
      add_failed_mess("You are a disembodied spirit, how do you expect to bury "
                      "anything at all?\n");
      return 0;
   }
   if(sizeof(filter_array(TP->query_attacker_list(),
                          (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot bury items while in combat.\n");
      return 0;
   }
   if(environment(TP)->query_property("no burial")) {
      add_failed_mess("You cannot bury things here.\n");
      return 0;
   }
   fobs = filter(obs, (: !is_in_me_or_environment($1, this_player()) :));
   obs -= fobs;
   foreach (ob in obs) {
      if (sizeof(sobs) >= MAX_BURY_NUMBER) {
         too_many += ({ ob });
      } else if ((ob->query_owner() == this_player()->query_cap_name()) ||
                 ((ob->get() == MOVE_OK) ||
                  (ob->get() == MOVE_TOO_HEAVY)) &&
                 (ob->query_property("no burial") != 1) &&
                 !ob->ok_to_bury(this_player())) {
        if (ob->query_property("player") != 1 ||
            ob->query_owner() == this_player()->query_name()) {
            effs = ob->effects_matching("mudlib.owned.weapon");
            if(sizeof(effs)) {
               person = ob->arg_of(effs[0]);
               log_file("BURIAL", "%s: %s's %s buried by %s\n", ctime(time()),
                        person, ob->query_short(), TP->query_name());
            }
            environment(this_player())->add_effect(BURY_EFFECT, ob);
            sobs += ({ ob });
            if (ob->query_property("corpse bit") ||
                ob->query_property("money")) {
               gp--;
            } else if(base_name(ob) == "/obj/corpse" &&
                      !ob->query_property("already buried")) {
               gp += GP_INCREMENT;
               ob->add_property("already buried", 1);
               xp = ob->query_property("XP");
               if(xp && sizeof(xp) == 2) {
                 foreach(tmp in xp[0]) {
                   if(tmp)
                     tmp->adjust_xp(xp[1], 1);
                 }
               }
               ob->remove_property("XP");
            }
         } else {
            fobs += ({ ob });
         }
      } else {
         fobs += ({ ob });
      }
   }
   if (!sizeof(sobs)) {
      if (sizeof(fobs)) {
         if (member_array(TP, fobs) == -1) {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs)+".\n");
            return 0;
         } else {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs - ({TP}) +
                                                 ({"yourself"}))+
                            ".\n");
            return 0;
         }
      } else {
         add_failed_mess("You cannot find anything here to bury!\n");
         return 0;
      }
   }
   if (sizeof(too_many)) {
      write("You can only bury up to " + MAX_BURY_NUMBER +
            " items at a time, not burying " +
            query_multiple_short(too_many) + ".\n");
   }
   messages = environment(TP)->query_burial_message();
   if (messages) {
      write(replace_string(messages[0], "$objs$", query_multiple_short(sobs)));
      say(replace(messages[1], ({ "$N", TP->the_short(), "$objs$", query_multiple_short(sobs) })));
   } else if (environment(TP)->query_property("location") != "outside") {
      write("You tidy up the place, clearing away "+
            query_multiple_short(sobs)+".\n");
      say( (string)this_player()->one_short() +
           " tidies up the place, clearing away "+
           query_multiple_short( sobs ) +".\n" );
   } else {
      write("You bury "+query_multiple_short(sobs)+" deep within the earth.\n");
      say( (string)this_player()->one_short() +
           " buries "+ query_multiple_short( sobs ) +
           " deep within the ground.\n" );
   }
   TP->adjust_gp(gp);
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:here>", (: cmd($1) :),
            "",
            (: cmd(match_objects_for_existence("corpse", environment(TP))) :) });
}

==================================================
FILE: /lib/cmds/player/chfn.c
==================================================

inherit "/cmds/base";
#define TP this_player()
#define MAX_EMAIL_LEN 50
int cmd(string str) {
  write("Change finger information.\n");
  write("Pressing return at the prompts will take the default.  The default "
        "is the option in []'s.\n");
  write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
  input_to("real_name");
  return 1;
}
int real_name(string str) {
  string real_name;
  str = strip_colours(str);
  real_name = TP->query_real_name();
  if (str && str != "") {
    if (str == "none") {
      real_name = 0;
    } else {
      real_name = str;
    }
  }
  if (real_name && strlen(real_name) > MAX_EMAIL_LEN) {
    write("Real name is too long, a maximum of " + MAX_EMAIL_LEN + " characters is allowed.\n");
    write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
    input_to("real_name");
    return 1;
  }
  if (real_name && real_name != "") {
    write("Ok real name set to "+real_name+".\n");
  } else {
    write("Real name cleared.\n");
  }
  TP->set_real_name(real_name);
  write("Enter your location (ie Perth, oz, whatever) ["+
        TP->query_where()+"]\n(none for none) : ");
  input_to("get_where");
  return 1;
}
int get_where(string str) {
  string where;
  str = strip_colours(str);
  where = TP->query_where();
  if (str && str != "") {
    if (str == "none") {
      where = 0;
    } else {
      where = str;
    }
  }
  if (where && where != "") {
    write("Ok location set to "+where+".\n");
  } else {
    write("Location cleared.\n");
  }
  if (where && strlen(where) > MAX_EMAIL_LEN) {
     write("Your location is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
     write("Enter your location (ie Perth, oz, whatever) ["+
           TP->query_where()+"]\n(none for none) : ");
     input_to("get_where");
     return 1;
  }
  TP->set_where(where);
  if(TP->query_birthday() == "Unknown") {
    write("Enter your birthday (ddmm) ["+TP->query_birthday()+
          "] (none for none) : ");
    input_to("birthday");
  } else {
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
  }
  return 1;
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}
int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
void birthday(string str) {
  string birth_day;
  birth_day = TP->query_birthday();
  if (str == "") {
    if (birth_day)
      write("Birthday unchanged from "+birth_day+".\n");
    else
      write("Birthday left as blank.\n");
  } else {
    if(birth_day != "Unknown") {
      write("You can't change when you were born! Please ask a Creator or "
        "a Lord to change it if you made an error.\n");
    } else if(!valid_birthday(str)) {
        write("Invalid Birthday.  Birthday cleared.\n");
        birth_day = 0;
    } else {
      birth_day = convert_birthday(str);
      write("Birthday set to " + birth_day + ".\n");
      TP->birthday_gifts();
    }
  }
  TP->set_birthday(birth_day);
  write("What email address do you wish to use.  Set to none to clear.\n");
  write("Putting a : in front of it means that only the creators and lords "
        "can read it.\n");
  write("["+TP->query_email()+"] : ");
  input_to("get_email");
}
void get_email(string str) {
  string email;
  email = TP->query_email();
  str = strip_colours(str);
  if (str == "") {
    if (!email || email == "") {
      write("Email address left blank.\n");
    } else {
      write("Email address left as "+email+".\n");
    }
  } else if (str == "none") {
    email = 0;
    write("Email address cleared.\n");
  } else {
    email = str;
    write("Email address set to "+email+".\n");
  }
  if (email && strlen(email) > MAX_EMAIL_LEN) {
    write("Your email address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators and lords "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
    return ;
  }
  TP->set_email(email);
  write("Please enter your home page (World Wide Web page address), "
        "type 'none' to clear it.\n");
  if (!TP->query_homepage()) {
    write("[none] : ");
  } else {
    write("["+TP->query_homepage()+"] : ");
  }
  input_to("get_home_page");
}
void get_home_page(string str) {
  str = strip_colours(str);
  if (str == "") {
    if (!TP->query_homepage()) {
      write("Home page left as blank.\n");
    } else {
      write("Home page left as "+TP->query_homepage()+"\n");
    }
  } else if (str == "none") {
    TP->set_homepage("");
    write("Home page cleared.\n");
  } else if (strlen(str) <= MAX_EMAIL_LEN) {
    TP->set_homepage(str);
    write("Home page set to "+str+"\n");
  } else {
    write("Your home page address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("Please enter your home page (World Wide Web page address), "
          "type 'none' to clear it.\n");
    if (!TP->query_homepage()) {
      write("[none] : ");
    } else {
      write("["+TP->query_homepage()+"] : ");
    }
    input_to("get_home_page");
    return ;
  }
  TP->save_me();
}

==================================================
FILE: /lib/cmds/player/co_mmands.c
==================================================

inherit "/cmds/base";
int cmd( ) {
  string *cmds;
  write( "Your current commands are:\n"+ sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)this_player()->query_known_commands(), 1 ),
         "\n" ) ) );
  if (this_player()->query_playtester()) {
    cmds = get_dir ("/cmds/playtester/");
    cmds = filter (cmds, (: strsrch ($1, ".c") == (sizeof ($1) - 2) :));
    write( "\n\nYour playtester commands are:\n"+ replace (sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)cmds, 1 ),
         "\n" ) ), ({".c", ""})) );
  }
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: /lib/cmds/player/colo_urs.c
==================================================

#include <colour.h>
#include <clubs.h>
#include <creator.h>
#include <newbiehelpers.h>
inherit "cmds/base";
private string* _colours;
void create() {
  ::create();
  _colours = ({
   "BOLD",
   "FLASH",
   "BLACK",
   "RED",
   "BLUE",
   "CYAN",
   "MAGENTA",
   "ORANGE",
   "YELLOW",
   "GREEN",
   "WHITE",
   "B_RED",
   "B_ORANGE",
   "B_YELLOW",
   "B_BLACK",
   "B_CYAN",
   "B_WHITE",
   "B_GREEN",
   "B_MAGENTA" });
}
int is_valid_colour(string name) {
   if (member_array(name, _colours) != -1) {
      return 1;
   }
   return 0;
}
int show_allowed_colours() {
   write("The allowed colour codes are " +
         query_multiple_short(map(_colours, (: lower_case($1) :)), 0, 0, 1) +
         ".\n");
   return 1;
}
string* query_colour_list(int inform) {
  string* colour_list;
  string* clubs;
  string bing;
  switch (inform) {
  case 0:
    colour_list = USER_COLOUR_LIST;
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      colour_list += ({"newbiehelpers"});
    }
    if(this_player()->query_creator()) {
      colour_list += this_player()->channel_list();
    }
    break;
  case 1 :
    colour_list = this_player()->query_inform_types();
    break;
  case 2 :
    clubs = this_player()->query_player_clubs();
    clubs = filter(clubs, (: !CLUB_HANDLER->is_club($1) :));
    foreach (bing in clubs) {
       this_player()->remove_player_club(bing);
    }
    colour_list = map(this_player()->query_player_clubs(), (: "club_" + $1 :));
    break;
  }
  return colour_list;
}
mixed set_colours(int inform, string event_type, string colour, int force) {
  mapping my_colours;
  string *colour_list;
  string *bad;
  string tmp;
  string name;
  colour_list = query_colour_list(inform);
  if (inform == 2) {
    name = CLUB_HANDLER->query_club_name(event_type);
    event_type = "club_" + event_type;
  } else {
    name = lower_case(event_type);
  }
  if(member_array(event_type, colour_list) == -1) {
    return notify_fail("No such type.\n");
  }
  my_colours = this_player()->query_my_colours();
  if(colour == "default") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to default.\n");
  } else if(colour == "none") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to none.\n");
  } else {
    colour_list = map(explode(colour, " "),
                      (: upper_case($1) :));
    bad = filter(colour_list, (: !is_valid_colour($1) :));
    if (sizeof(bad) && !force) {
       if (sizeof(bad) > 1) {
          add_failed_mess("The colours " + query_multiple_short(bad) +
                          " are not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       } else {
          add_failed_mess("The colour " + query_multiple_short(bad) +
                          " is not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       }
       return 0;
    }
    tmp = "%^" + implode(colour_list, (: $1 + "%^ %^" + $2 :)) + "%^";
    this_player()->set_my_colours(event_type, tmp);
    write(name + " colour set to " + tmp + "[" + colour +
          "]%^RESET%^.\n");
  }
  return 1;
}
private int show_colours(int inform) {
  string *colour_list, event;
  mapping my_colours;
  string name;
  colour_list = query_colour_list(inform);
  my_colours = this_player()->query_my_colours();
  if (!inform) {
    write(sprintf("%-20s %s\n", "Clubs", "<list>"));
    write(sprintf("%-20s %s\n", "Inform", "<list>"));
  }
  foreach(event in colour_list) {
    if (inform == 2) {
       name = CLUB_HANDLER->query_club_name(event[5..]);
    } else {
       name = event;
    }
    if(my_colours[event]) {
      if(my_colours[event] != "") {
        write(sprintf("%-20s %s\n", name, my_colours[event] +
                      "[" + replace(my_colours[event], "%^", "") +
                      "]%^RESET%^"));
      } else {
        write(sprintf("%-20s %s\n", name, "[none]"));
      }
    } else {
      write(sprintf("%-20s %s\n", name, "[default]"));
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 0) :),
            "force <word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 1) :),
            "", (: show_colours(0) :),
            "inform <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 0) :),
            "inform force <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 1) :),
            "club <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 0) :),
            "club force <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 1) :),
            "inform", (: show_colours(1) :),
            "allowed", (: show_allowed_colours() :),
            "clubs", (: show_colours(2) :) });
}

==================================================
FILE: /lib/cmds/player/components.c
==================================================

#define OBJ 0
inherit "/cmds/base";
int cmd( string spell_name ) {
  mapping spells = this_player()->query_spells_nocase();
  string spell_ob;
  string *consumed, *needed;
  string mess;
  if( !sizeof( spells ) ) {
    add_failed_mess( "You don't know any magic spells.\n" );
    return 0;
  }
  spell_name = this_player()->expand_nickname( spell_name );
  spell_name = capitalize( spell_name );
  if( !spells[ lower_case(spell_name) ] ) {
    add_failed_mess( "You don't know a spell named " + spell_name +
        ".\n" );
    return 0;
  }
  spell_ob = spells[ lower_case(spell_name) ][ OBJ ];
  consumed = spell_ob->query_consumables();
  needed   = spell_ob->query_needed();
  if( !sizeof( consumed ) && !sizeof( needed ) ) {
    mess = "You don't need anything to cast " + spell_name;
  } else if( sizeof( consumed ) ) {
    mess = spell_name + " will consume " + query_multiple_short(
           consumed );
    if( sizeof( needed ) ) {
      mess += ".  It also requires " + query_multiple_short(
                 needed ) + " but will not consume " +
                 ( sizeof( needed ) > 1 ? "them" : "it" );
    }
  } else {
    mess = spell_name + " requires " + query_multiple_short( needed ) +
           " but will not consume " + ( sizeof ( needed ) > 1 ?
           "them" : "it" );
  }
  add_succeeded_mess( ({ mess + ".\n", "" }) );
  return 1;
}
mixed *query_patterns() {
  return ({ "[for] <string'spell'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: /lib/cmds/player/con_sider.c
==================================================

#define CREATOR "Ceres"
#include <weapon.h>
#include <cmr.h>
#include <player.h>
inherit "/cmds/base";
int calc_danger(object ob);
string do_compare(int dif);
mixed cmd(object *obs) {
  object ob;
  int level, ok, dif, total, them;
  string out;
  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) < 0) {
     add_failed_mess("It's too dark to consider anyone.\n");
     return 0;
  }
  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) > 0) {
     add_failed_mess("It's too bright to consider anyone.\n");
     return 0;
  }
  if (sizeof(obs) > 1) {
     obs -= ({ this_player() });
  }
  if (sizeof(obs) > 5) {
     add_failed_mess("You can only consider five things at once.\n");
     return 0;
  }
  if (this_player()->query_property("dead"))  {
    add_failed_mess( "You're dead.  You could just about kill a "
                        "conversation.\n" );
    return 0;
  }
  level = calc_danger(previous_object());
  foreach (ob in obs) {
    if (!living(ob)) {
       continue;
    }
    if (ob == previous_object()) {
       if (sizeof(obs) == 1) {
          write("You are exactly equal to yourself, you had better go and "
                "arm yourself with more spiky things and try to not arm "
                "your reflection at the same time.  No problems?\n");
          ok++;
       }
       continue;
    }
    ok++;
    them = calc_danger(ob);
    total += them;
    dif = ((level - them) * 100) / level;
    if ( userp( ob ) && this_player()->query_player_killer() &&
          !ob->query_player_killer() ) {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() +
             " [not a killer]" );
    } else {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() );
    }
    if (userp(ob)) {
       tell_object(ob, this_player()->the_short(1) + " looks you up and down "
                       "carefully checking out your weapons and armour.\n");
    } else {
       ob->event_npc_consider(this_player());
    }
    write( out +"\n" );
  }
  if(!ok) {
    add_failed_mess("You need to consider someone.\n");
    return 0;
  }
  return 1;
}
string do_compare(int dif) {
   string ret;
   int level;
   ret = "$C$$who$";
   level = PLAYER_DRUNK_EFFECT->query_drunk_level(this_player());
   if (level > 4) {
      if (level > 7) {
         return "%^BOLD%^%^GREEN%^Mate!  They looked at you wrong, you "
                "better sort them out before they get more cocky.%^RESET%^";
      }
      return "%^BOLD%^%^GREEN%^You reckon they would be an easy "
             "target.  Why bother with weapons?%^RESET%^";
   }
  if(dif > 320) {
    ret = "%^BOLD%^GREEN%^"+ret+" is too weak to bother attacking";
  } else {
    switch(dif) {
    case 161..320:
      ret = "%^BOLD%^%^GREEN%^"+ret+" is someone you look down on";
      break;
    case 81..160:
      ret = "%^GREEN%^"+ret+" would be an easy target";
      break;
    case 41..80:
      ret = "%^GREEN%^"+ret+" is a lot weaker than you";
      break;
    case 21..40:
      ret = "%^GREEN%^"+ret+" is weaker than you";
      break;
    case 11..20:
      ret = "%^CYAN%^"+ret+" is slightly weaker than you";
      break;
    case -10..10:
      ret = "%^CYAN%^"+ret+" is about equal with you";
      break;
    case -20..-11:
      ret = "%^CYAN%^"+ret+" is slightly tougher than you";
      break;
    case -40..-21:
      ret = "%^RED%^"+ret+" is tougher than you";
      break;
    case -80..-41:
      ret = "%^RED%^"+ret+" is a lot tougher than you";
      break;
    case -160..-81:
      ret = "%^RED%^"+ret+" looks pretty nasty";
      break;
    case -320..-161:
      ret = "%^BOLD%^%^RED%^"+ret+" is into the don't-even-think-about-it "
        "region";
      break;
    default:
      ret = "%^BOLD%^%^RED%^You would have to be utterly insane to attack "
        "$who$";
      break;
    }
   }
   return ret + ".%^RESET%^";
}
int calc_weapon_damage(object weapon) {
  mixed *data;
  int wdam, *damage, i;
  data = (mixed *)weapon->query_attack_data();
  if(sizeof(data)) {
    wdam = 0;
    for ( i = 0; i < sizeof( data ); i += W_ARRAY_SIZE ) {
      if (member_array( data[ i + W_TYPE ], ({ "blunt", "unarmed",
                                               "sharp", "pierce" }) ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      wdam += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
                        ( damage[ F_NUM ] * damage[ F_DIE ] ) / 2 ) ) / 100;
      wdam += damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
    }
  }
  return wdam;
}
int calc_value(mixed arr) {
  if (intp(arr))
    return arr;
  if (!pointerp(arr))
    return 0;
  if (sizeof(arr) == 1)
    return arr[F_FIXED];
  if (sizeof(arr) == 2)
    return arr[F_FIXED]+arr[F_NUM];
  return arr[F_FIXED]+(arr[F_NUM] * arr[F_DIE]);
}
int calc_armour_protection(object armour) {
  int ac, i;
  mapping data;
  mixed *stuff;
  if(!armour->query_armour())
    return 0;
  data = armour->query_armour_class();
  if(!sizeof(data))
     return 0;
  stuff = keys(data);
  for(i=0; i<sizeof(stuff); i++)
    ac += calc_value(data[stuff[i]][0]);
  return ac;
}
int calc_danger(object ob) {
   object weapon;
   object *weapons;
   object armour;
   object rider;
   int wdam;
   int wskill;
   int dskill;
   int ac;
   int hp;
   int trans;
   if (ob->query_transport()) {
      foreach (rider in ob->query_riders()) {
         trans += calc_danger(rider);
      }
   }
  weapons = ob->query_holding();
  if(weapons && sizeof(weapons) > 0 && (weapons[0] != 0) && (weapons[0]->
    query_weapon())) {
    weapon = weapons[0];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else if(weapons && sizeof(weapons) > 1 && (weapons[1] != 0) &&
      (weapons[1]->query_weapon())) {
    weapon = weapons[1];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else {
    weapon = ob;
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  }
  dskill += ob->query_skill_bonus("fighting.combat.dodging.melee");
  wdam = calc_weapon_damage(weapon);
  if(!sizeof(weapon->query_attack_data())) {
    wskill += ob->query_skill_bonus("fighting.combat.melee.unarmed");
    wskill += ob->query_skill_bonus("fighting.combat.special.unarmed") / 2;
  } else {
    wskill += ob->query_skill_bonus("fighting.combat.melee."+
              (string)weapon->query_attack_data()[W_SKILL]);
    wskill += ob->query_skill_bonus("fighting.combat.special.weapon") / 2;
  }
  wskill += ob->query_skill_bonus("fighting.combat.special.tactics");
  wskill += ob->query_specific_gp("fighting");
  hp = ob->query_hp();
  if(ob->query_wearing())
    foreach(armour in ob->query_wearing())
      if(armour)
        ac += calc_armour_protection(armour);
  wdam /= 3;
  hp /= 3;
  dskill /= 2;
  ac /= 6;
  return trans + wdam + wskill + dskill + ac + hp;
}
mixed* query_patterns() {
  return ({ "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/player/cond_ition.c
==================================================

inherit "/cmds/base";
class cond_info {
   object cond_item;
   string cond_string;
   int cond_percent;
}
int compare(float, float);
string cond_colour(int percent)
{
   switch (100 - percent) {
   case 0..50:
      return "";
   case 51..60:
      return "%^CYAN%^";
   case 61..70:
      return "%^GREEN%^";
   case 71..80:
      return "%^YELLOW%^";
   case 81..90:
      return "%^RED%^";
   case 91..100:
      return "%^BOLD%^%^RED%^";
   }
}
int is_valid_environment(object ob) {
   object env;
   env = environment(ob);
   if (env == environment(this_player())) {
      return 1;
   }
   while (env) {
      if (env == this_player()) {
         return 1;
      }
      env = environment(env);
   }
   return 0;
}
int cmd(object *things, int dir, int no_excellent)
{
   int i;
   string list;
   object thing;
   class cond_info *info = ({ });
   class cond_info new_info;
   int dark;
   if (!this_player()->query_property("dead")) {
      dark =
         this_player()->check_dark(environment(this_player())->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   things = filter(things, (: is_valid_environment :));
   if (!sizeof(things)) {
      add_failed_mess("Can only check the condition of things you "
                      "have in your inventory or on the ground.\n");
      return 0;
   }
   if (sizeof(things) == 1) {
      list = things[0]->cond_string();
      if (!list || list == "") {
         list = " has no condition.\n";
      } else {
         if (things[0]->query_is_pair())  list = list[4 .. ];
         else list = list[2..];
      }
      write("$C$" + things[0]->the_short() + list);
      return 1;
   }
   foreach(thing in things) {
      list = thing->cond_string();
      if (list && list != "") {
       if (thing->query_is_pair())  list = list[4 .. ];
       else list = list[2 .. ];
       info += ({ new (class cond_info,
                       cond_item: thing,
                       cond_string: list,
                       cond_percent:(thing->query_cond() * 100) /
                         thing-> query_max_cond()
                    )
            });
      }
   }
   if (!sizeof(info)) {
      add_failed_mess("None of those things has a condition.\n");
      return 0;
   } else if (sizeof(info) == 1) {
      write("$C$" + info[0]->cond_item->the_short() + info[0]->cond_string);
   } else {
      if (dir) {
         info = sort_array
            (info, (: $(dir) * compare($1->cond_percent, $2->cond_percent) :));
      }
      i = 0;
      foreach(new_info in info) {
         if (!no_excellent || new_info->cond_percent <= 90) {
            write(cond_colour(new_info->cond_percent) + "$C$" +
                  new_info->cond_item->the_short() + " (" + (i + 1) + ")" +
                  new_info->cond_string + "%^RESET%^");
            ++i;
         }
      }
      if (!i && no_excellent) {
         write("Everything is in excellent condition.\n");
      }
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object'item(s)'> sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 0) :),
             "<indirect:object'item(s)'>",
             (: cmd($1, 0, 0) :),
             "<indirect:object'item(s)'> damaged",
             (: cmd($1, 0, 1) :),
             "<indirect:object'item(s)'> damaged sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 1) :), });
}
int compare(float first, float second)
{
   if (first > second)
      return 1;
   if (first < second)
      return -1;
   return 0;
}

==================================================
FILE: /lib/cmds/player/count.c
==================================================

#include <money.h>
inherit "/cmds/base";
#define MAX_COUNT_SIZE 50
int is_not_in_other_player(object thing);
int cmd(object *things, int brief)  {
   string  list;
   string *aliases;
   string  message;
   mixed  *stuff;
   object  thing;
   object  money;
   object  sack;
   object *continuous, *collective;
   object *room_items;
   object *tmp;
   object tmp_ob;
   int     i;
   int     total;
   if (this_player()->
       check_dark(environment(this_player())->query_light()) < 0) {
      add_failed_mess("It's too dark to count anything.\n");
      return 0;
   }
   if(sizeof(things) > MAX_COUNT_SIZE)
     return add_failed_mess("You cannot count that many things!\n");
   things = filter(things, (: !is_not_in_other_player($1) :));
   if (!sizeof(things))  {
      write("You can't count things carried by other people.\n");
      return 1;
   }
   money = 0;
   total = 0;
   list = "";
   foreach (thing in things)  {
      aliases = thing->query_alias();
      if (aliases  &&  member_array(MONEY_ALIAS, aliases) > -1)  {
         if (!money) {
            money = clone_object(MONEY_OBJECT);
         }
         money->adjust_money(thing->query_money_array());
         things -= ({ thing });
      }
   }
   if (money)  {
      total += money->query_number_coins();
      if (sizeof(things))  {
         list = implode(money->half_short(1), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list = query_multiple_short(money->half_short(1));
      }
      money->dest_me();
   }
   continuous = filter(things, (: $1->query_continuous() :));
   if (sizeof(continuous))  {
      sack = clone_object("/std/container");
      foreach (thing in continuous) {
         thing->make_medium_clone(thing->query_amount())->move(sack);
      }
      things -= continuous;
      continuous = all_inventory(sack);
      foreach (thing in continuous)  {
         total += thing->query_how_many();
      }
      if (sizeof(things))  {
         list += implode(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list += query_multiple_short(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)));
      }
      sack->dest_me();
   }
   collective = filter(things, (: $1->query_collective() :));
   if (sizeof(collective))  {
     sack = clone_object("/std/container");
     foreach (thing in collective) {
       if (thing) {
          tmp_ob = thing->make_medium_clone(thing->query_amount());
          if (tmp_ob) {
             tmp_ob->move(sack);
          }
       }
     }
     things -= collective;
     collective = all_inventory(sack);
     foreach (thing in collective) {
       total += thing->query_amount();
     }
     if(sizeof(things)) {
       list += implode(map(collective,
                           (: $1->query_amount() + " " +
                            ($1->query_amount() == 1 ? $1->short() :
                             $1->query_plural()) :)),
                       ", ");
       if (sizeof(things) == 1) {
         list += " and ";
       } else {
         list += ", ";
       }
     } else {
       list += query_multiple_short(map(collective,
                                        (: $1->query_amount() + " " +
                                         ($1->query_amount() == 1 ?
                                          $1->short() :
                                          $1->query_plural()) :)));
     }
     sack->dest_me();
   }
   room_items = filter(things, (: strsrch(file_name($1),
                                          "/std/room/basic/item") > -1 :));
   if (sizeof(room_items))  {
      things -= room_items;
      tmp = filter(room_items, (: $1->query_count() :));
      room_items -= tmp;
      if (sizeof(things))  {
         if (sizeof(tmp)) {
            list += implode(map(tmp, (: query_num($1->query_count()) +
                    " " + ($1->query_count() > 1 ? $1->pretty_plural()
                                                 : $1->pretty_short()) :)),
                    ", ");
            foreach (thing in tmp)  {
               total += thing->query_count();
            }
         }
         if (sizeof(room_items)) {
            list += implode(map(room_items, (: "at least one " +
                                               $1->pretty_short() :)), ", ");
            total += sizeof(room_items);
         }
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else  {
         if (sizeof(tmp)) {
            list += query_multiple_short(map(tmp,
                    (: query_num($1->query_count()) + " " +
                    ($1->query_count() > 1 ? $1->pretty_plural()
                                           : $1->pretty_short()) :)), ", ");
            total += sizeof(tmp);
         }
         if (sizeof(room_items)) {
            list += query_multiple_short(map(room_items,
                    (: "at least one " + $1->pretty_short() :)));
            total += sizeof(room_items);
         }
      }
   }
   if (sizeof(things))  {
      list += query_multiple_short(things, "one");
if (this_player() == find_player("presto"))
tell_creator("presto", "list == %s\n", list);
      stuff = this_player()->reform_message(list, ({}));
if (this_player() == find_player("presto"))
printf("test message: %O\n", this_player()->evaluate_message(stuff));
      message = stuff[0];
      for (i = 0; i < sizeof(stuff[1]); i++)  {
         message = replace_string(message, "$" + i + "$",
            this_player()->calc_shorts(stuff[1][i], 1));
      }
      total += sizeof(things);
   } else {
      message = list;
   }
   if (brief) {
      write("You count " + total + " items.\n");
   } else {
      write("You count " + message + " with a total of " +
            query_num(total) + (total > 1 ? " items.\n" : " item.\n"));
   }
   return 1;
}
int is_not_in_other_player(object env)  {
   while ((env = environment(env))  &&  !living(env))
      ;
   if (env  &&  env != this_player())
      return 1;
   else
      return 0;
}
mixed *query_patterns()  {
   return ({ "<indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 0) :),
             "<indirect:object:me'things'> in inventory", (: cmd($1, 0) :),
             "<indirect:object:here'things'> in room", (: cmd($1, 0) :),
             "brief <indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 1) :),
             "brief <indirect:object:me'things'> in inventory", (: cmd($1, 1) :),
             "brief <indirect:object:here'things'> in room", (: cmd($1, 1) :) });
}

==================================================
FILE: /lib/cmds/player/countries.c
==================================================

#define COUNTRIES_NO_SHOW_PROP "don't show on countries list"
mapping common_countries = ([
   "N/A" : ({ 0, "An unresolved address" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "net" : ({ 0, "Network" }),
   "uk" : ({ 0, "United Kingdom" }),
   "au" : ({ 0, "Australia" })
   ]);
mapping all_countries = ([
   "ad" : ({ 0, "Andorra", }),
   "ae" : ({ 0, "United Arab Emirates" }),
   "af" : ({ 0, "Afghanistan" }),
   "ag" : ({ 0, "Antigua and Barbuda" }),
   "ai" : ({ 0, "Anguila" }),
   "al" : ({ 0, "Albania" }),
   "am" : ({ 0, "Armenia" }),
   "an" : ({ 0, "Netherlands Antilles" }),
   "ao" : ({ 0, "Angola" }),
   "aq" : ({ 0, "Antarctica" }),
   "ar" : ({ 0, "Argentina" }),
   "as" : ({ 0, "American Samoa" }),
   "at" : ({ 0, "Austria" }),
   "au" : ({ 0, "Australia" }),
   "aw" : ({ 0, "Aruba" }),
   "az" : ({ 0, "Azerbaijan" }),
   "ba" : ({ 0, "Bosnia and Herzegovina" }),
   "bb" : ({ 0, "Barbados" }),
   "bd" : ({ 0, "Bangladesh" }),
   "be" : ({ 0, "Belgium" }),
   "bf" : ({ 0, "Burkina Faso" }),
   "bg" : ({ 0, "Bulgaria" }),
   "bh" : ({ 0, "Bahrain" }),
   "bi" : ({ 0, "Burundi" }),
   "bj" : ({ 0, "Benin" }),
   "bm" : ({ 0, "Bermuda" }),
   "bn" : ({ 0, "Brunei Darussalam" }),
   "bo" : ({ 0, "Bolivia" }),
   "br" : ({ 0, "Brazil" }),
   "bs" : ({ 0, "Bahamas" }),
   "bt" : ({ 0, "Bhutan" }),
   "bv" : ({ 0, "Bouvet Island" }),
   "bw" : ({ 0, "Botswana" }),
   "by" : ({ 0, "Belarus" }),
   "bz" : ({ 0, "Belize" }),
   "ca" : ({ 0, "Canada" }),
   "cc" : ({ 0, "Cocos (Keeling) Islands" }),
   "cf" : ({ 0, "Central African Republic" }),
   "cg" : ({ 0, "Congo" }),
   "ch" : ({ 0, "Switzerland" }),
   "ci" : ({ 0, "Cote D'Ivoire (Ivory Coast)" }),
   "ck" : ({ 0, "Cook Island" }),
   "cl" : ({ 0, "Chile" }),
   "cm" : ({ 0, "Cameroon" }),
   "cn" : ({ 0, "China" }),
   "co" : ({ 0, "Colombia" }),
   "cr" : ({ 0, "Costa Rica" }),
   "cs" : ({ 0, "Czechoslovakia (former)" }),
   "cu" : ({ 0, "Cuba" }),
   "cv" : ({ 0, "Cape Verde" }),
   "cx" : ({ 0, "Christmas Island" }),
   "cy" : ({ 0, "Cyprus" }),
   "cz" : ({ 0, "Czech Republic" }),
   "de" : ({ 0, "Germany" }),
   "dk" : ({ 0, "Denmark" }),
   "dm" : ({ 0, "Dominica" }),
   "do" : ({ 0, "Dominican Republic" }),
   "dz" : ({ 0, "Algeria" }),
   "ec" : ({ 0, "Ecuador" }),
   "ee" : ({ 0, "Estonia" }),
   "eg" : ({ 0, "Egypt" }),
   "eh" : ({ 0, "Western Sahara" }),
   "er" : ({ 0, "Eritrea" }),
   "es" : ({ 0, "Spain" }),
   "et" : ({ 0, "Ethiopia" }),
   "fi" : ({ 0, "Finland" }),
   "fj" : ({ 0, "Fiji" }),
   "fk" : ({ 0, "Falkland Islands (Malvinas)" }),
   "fm" : ({ 0, "Micronesia" }),
   "fo" : ({ 0, "Faroe Islands" }),
   "fr" : ({ 0, "France" }),
   "fx" : ({ 0, "France, Metropolitan" }),
   "ga" : ({ 0, "Gabon" }),
   "gd" : ({ 0, "Grenada" }),
   "ge" : ({ 0, "Georgia" }),
   "gf" : ({ 0, "French Guiana" }),
   "gh" : ({ 0, "Ghana" }),
   "gi" : ({ 0, "Gibraltar" }),
   "gl" : ({ 0, "Greenland" }),
   "gm" : ({ 0, "Gambia" }),
   "gn" : ({ 0, "Guinea" }),
   "gp" : ({ 0, "Guadeloupe" }),
   "gq" : ({ 0, "Equatorial Guinea" }),
   "gr" : ({ 0, "Greece" }),
   "gs" : ({ 0, "S. Georgia and S. Sandwich Isls." }),
   "gt" : ({ 0, "Guatemala" }),
   "gu" : ({ 0, "Guam" }),
   "gw" : ({ 0, "Guinea-Bissau" }),
   "gy" : ({ 0, "Guyana" }),
   "hk" : ({ 0, "Hong Kong" }),
   "hm" : ({ 0, "Heard and McDonald Islands" }),
   "hn" : ({ 0, "Honduras" }),
   "hr" : ({ 0, "Croatia (Hrvatska)" }),
   "ht" : ({ 0, "Haiti" }),
   "hu" : ({ 0, "Hungary" }),
   "id" : ({ 0, "Indonesia" }),
   "ie" : ({ 0, "Ireland" }),
   "il" : ({ 0, "Israel" }),
   "in" : ({ 0, "India" }),
   "io" : ({ 0, "British Indian Ocean Territory" }),
   "iq" : ({ 0, "Iraq" }),
   "ir" : ({ 0, "Iran" }),
   "is" : ({ 0, "Iceland" }),
   "it" : ({ 0, "Italy" }),
   "jm" : ({ 0, "Jamaica" }),
   "jo" : ({ 0, "Jordan" }),
   "jp" : ({ 0, "Japan" }),
   "ke" : ({ 0, "Kenya" }),
   "kg" : ({ 0, "Kyrgyzstan" }),
   "kh" : ({ 0, "Cambodia" }),
   "ki" : ({ 0, "Kiribati" }),
   "km" : ({ 0, "Comoros" }),
   "kn" : ({ 0, "Saint Kitts and Nevis" }),
   "kp" : ({ 0, "Korea (North)" }),
   "kr" : ({ 0, "Korea (South)" }),
   "kw" : ({ 0, "Kuwait" }),
   "ky" : ({ 0, "Cayman Islands" }),
   "kz" : ({ 0, "Kazakhstan" }),
   "la" : ({ 0, "Laos" }),
   "lb" : ({ 0, "Lebanon" }),
   "lc" : ({ 0, "Saint Lucia" }),
   "li" : ({ 0, "Liechtenstein" }),
   "lk" : ({ 0, "Sri Lanka" }),
   "lr" : ({ 0, "Liberia" }),
   "ls" : ({ 0, "Lesotho" }),
   "lt" : ({ 0, "Lithuania" }),
   "lu" : ({ 0, "Luxembourg" }),
   "lv" : ({ 0, "Latvia" }),
   "ly" : ({ 0, "Libya" }),
   "ma" : ({ 0, "Morocco" }),
   "mc" : ({ 0, "Monaco" }),
   "md" : ({ 0, "Moldovia" }),
   "mg" : ({ 0, "Madagascar" }),
   "mh" : ({ 0, "Marshall Islands" }),
   "mk" : ({ 0, "Macedonia" }),
   "ml" : ({ 0, "Mali" }),
   "mm" : ({ 0, "Myanmar" }),
   "mn" : ({ 0, "Mongolia" }),
   "mo" : ({ 0, "Macau" }),
   "mp" : ({ 0, "Northern Mariana Islands" }),
   "mq" : ({ 0, "Martinique" }),
   "mr" : ({ 0, "Mauritania" }),
   "ms" : ({ 0, "Montserrat" }),
   "mt" : ({ 0, "Malta" }),
   "mu" : ({ 0, "Mauritius" }),
   "mv" : ({ 0, "Maldives" }),
   "mw" : ({ 0, "Malawi" }),
   "mx" : ({ 0, "Mexico" }),
   "my" : ({ 0, "Malaysia" }),
   "mz" : ({ 0, "Mozambique" }),
   "na" : ({ 0, "Namibia" }),
   "nc" : ({ 0, "New Caledonia" }),
   "ne" : ({ 0, "Niger" }),
   "nf" : ({ 0, "Norfolk Islands" }),
   "ng" : ({ 0, "Nigeria" }),
   "ni" : ({ 0, "Nicaragua" }),
   "nl" : ({ 0, "Netherlands" }),
   "no" : ({ 0, "Norway" }),
   "np" : ({ 0, "Nepal" }),
   "nr" : ({ 0, "Nauru" }),
   "nt" : ({ 0, "Neutral Zone" }),
   "nu" : ({ 0, "Niue" }),
   "nz" : ({ 0, "New Zealand (Aotearoa)" }),
   "om" : ({ 0, "Oman" }),
   "pa" : ({ 0, "Panama" }),
   "pe" : ({ 0, "Peru" }),
   "pf" : ({ 0, "French Polynesia" }),
   "pg" : ({ 0, "Papua New Guinea" }),
   "ph" : ({ 0, "Philippines" }),
   "pk" : ({ 0, "Pakistan" }),
   "pl" : ({ 0, "Poland" }),
   "pm" : ({ 0, "St. Pierre and Miquelon" }),
   "pn" : ({ 0, "Pitcairn" }),
   "pr" : ({ 0, "Puerto Rico" }),
   "pt" : ({ 0, "Portugal" }),
   "pw" : ({ 0, "Palau" }),
   "py" : ({ 0, "Paraguay" }),
   "qa" : ({ 0, "Qatar" }),
   "re" : ({ 0, "Reunion" }),
   "ro" : ({ 0, "Romania" }),
   "ru" : ({ 0, "Russian Federation" }),
   "rw" : ({ 0, "Rwanda" }),
   "sa" : ({ 0, "Saudi Arabia" }),
   "sb" : ({ 0, "Solomon Islands" }),
   "sc" : ({ 0, "Seychelles" }),
   "sd" : ({ 0, "Sudan" }),
   "se" : ({ 0, "Sweden" }),
   "sg" : ({ 0, "Singapore" }),
   "sh" : ({ 0, "St. Helena" }),
   "si" : ({ 0, "Slovenia" }),
   "sj" : ({ 0, "Svalbard and Jan Mayen Islands" }),
   "sk" : ({ 0, "Slovak Republic" }),
   "sl" : ({ 0, "Sierra Leone" }),
   "sm" : ({ 0, "San Marino" }),
   "sn" : ({ 0, "Senegal" }),
   "so" : ({ 0, "Somalia" }),
   "sr" : ({ 0, "Suriname" }),
   "st" : ({ 0, "Sao Tome and Principe" }),
   "su" : ({ 0, "USSR (former)" }),
   "sv" : ({ 0, "El Salvador" }),
   "sy" : ({ 0, "Syria" }),
   "sz" : ({ 0, "Swaziland" }),
   "tc" : ({ 0, "Turks and Caicos Islands" }),
   "td" : ({ 0, "Chad" }),
   "tf" : ({ 0, "French Southern Territories" }),
   "tg" : ({ 0, "Togo" }),
   "th" : ({ 0, "Thailand" }),
   "tj" : ({ 0, "Tajikistan" }),
   "tk" : ({ 0, "Tokelau" }),
   "tm" : ({ 0, "Turkmenistan" }),
   "tn" : ({ 0, "Tunisia" }),
   "to" : ({ 0, "Tonga" }),
   "tp" : ({ 0, "East Timor" }),
   "tr" : ({ 0, "Turkey" }),
   "tt" : ({ 0, "Trinidad and Tobago" }),
   "tv" : ({ 0, "Tuvalu" }),
   "tw" : ({ 0, "Taiwan" }),
   "tz" : ({ 0, "Tanzania" }),
   "ua" : ({ 0, "Ukraine" }),
   "ug" : ({ 0, "Uganda" }),
   "uk" : ({ 0, "United Kingdom" }),
   "um" : ({ 0, "US Minor Outlying Islands" }),
   "us" : ({ 0, "United States" }),
   "uy" : ({ 0, "Uruguay" }),
   "uz" : ({ 0, "Uzbekistan" }),
   "va" : ({ 0, "Vatican City State (Holy See)" }),
   "vc" : ({ 0, "Saint Vincent and the Grenadines" }),
   "ve" : ({ 0, "Venezuela" }),
   "vg" : ({ 0, "Virgin Islands (British)" }),
   "vi" : ({ 0, "Virgin Islands (U.S.)" }),
   "vn" : ({ 0, "Viet Nam" }),
   "vu" : ({ 0, "Vanuatu" }),
   "wf" : ({ 0, "Wallis and Futuna Islands" }),
   "ws" : ({ 0, "Samoa" }),
   "ye" : ({ 0, "Yemen" }),
   "yt" : ({ 0, "Mayotte" }),
   "yu" : ({ 0, "Yugoslavia" }),
   "za" : ({ 0, "South Africa" }),
   "zm" : ({ 0, "Zambia" }),
   "zr" : ({ 0, "Zaire" }),
   "zw" : ({ 0, "Zimbabwe" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "gov" : ({ 0, "US Government" }),
   "int" : ({ 0, "International" }),
   "mil" : ({ 0, "US Military" }),
   "net" : ({ 0, "Network" }),
   "org" : ({ 0, "Non-Profit Organization" }),
   "arpa" : ({ 0, "Old Style Arpanet" }),
   "nato" : ({ 0, "NATO Field" })
   ]);
int cmd();
int handle_no_show( int hide );
string resolve_domain_suffix( object player );
int cmd() {
   int left, right, size;
   float percentage;
   object person, *users;
   string suffix, message, country;
   mixed *unsorted, *sorted, *data;
   mapping countries;
   countries = copy( common_countries );
   users = filter( users(), (: $1->query_visible( this_player() ) &&
      !$1->query_property( COUNTRIES_NO_SHOW_PROP ) :) );
   if( !size = sizeof( users ) ) {
      return notify_fail( "No visible players.\n" );
   }
   foreach( person in users ) {
      suffix = resolve_domain_suffix( person );
      if( undefinedp( countries[ suffix ] ) ) {
         if( undefinedp( all_countries[ suffix ] ) ) {
            countries[ "N/A" ][ 0 ] ++;
            continue;
         } else {
            common_countries += ([ suffix : all_countries[ suffix ] ]);
            countries += ([ suffix : copy( all_countries[ suffix ] ) ]);
         }
      }
      countries[ suffix ][ 0 ] ++;
   }
   unsorted = ({ });
   size -= countries[ "N/A" ][ 0 ];
   map_delete( countries, "N/A" );
   foreach( country, data in countries ) {
      if( !data[ 0 ] ) {
         map_delete( common_countries, country );
         continue;
      } else {
         data[ 1 ] += " (%^BOLD%^" + upper_case( country ) + "%^RESET%^)";
         unsorted += ({ data });
      }
   }
   sorted = sort_array( unsorted, -1 );
   message = "\nA total of %^BOLD%^" + query_num( size ) +
      "%^RESET%^ visible " + ( size != 1 ? "users" : "user" ) +
      " with resolvable addresses logged on:\n";
   left = this_player()->query_cols() / 3 * 2;
   left -= 3;
   right = this_player()->query_cols() - left;
   foreach( data in sorted ) {
      percentage = data[ 0 ] * 100.0 / size;
      message += sprintf( "   %-=*'.'s%*-=s\n",
      left, data[ 1 ],
      right, "  " + to_int( percentage + 0.5 ) + "%" );
   }
   this_player()->more_string( message );
   return 1;
}
string resolve_domain_suffix( object player ) {
   string addy, *host;
   addy = query_ip_name( player );
   if( !addy ) {
      return 0;
   }
   host = explode( lower_case( addy ), "." );
   return host[ sizeof( host ) - 1 ];
}
int handle_no_show( int hide ) {
   switch( hide ) {
      case 1:
         if( this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already hidden on the "
               "countries list.\n" );
            return 1;
         }
         this_player()->add_property( COUNTRIES_NO_SHOW_PROP, 1 );
         tell_object( this_player(), "You will no longer be included in "
            "the countries list.\n" );
         return 1;
      case 0:
         if( !this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already visible on "
               "the countries list.\n" );
            return 1;
         }
         this_player()->remove_property( COUNTRIES_NO_SHOW_PROP );
         tell_object( this_player(), "You will now be shown on the "
            "countries list.\n" );
         return 1;
      default:
         return notify_fail( "This shouldn't happen.\n" );
   }
}
mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "hide", (: handle_no_show( 1 ) :),
             "show", (: handle_no_show( 0 ) :)
          });
}

==================================================
FILE: /lib/cmds/player/coverage.c
==================================================

inherit "/cmds/base.c";
#define CLOTHING_HANDLER "/obj/handlers/clothing_handler"
private string _zone_patterns;
int cmd(object *items, int inverse, string bits)  {
   object   armor;
   object  *wearing;
   object  *fail = ({ });
   object  *armors;
   object  *covering;
   string  *types;
   string   equiv_type;
   string   type;
   string  *zones;
   string  *all_zones;
   string  *parts;
   string   zone;
   string   verb;
   string   mess;
   mapping  covered;
   mapping  pot_covered;
   all_zones = keys(CLOTHING_HANDLER->query_all_clothing_zones());
   covered = allocate_mapping(sizeof(all_zones));
   pot_covered = allocate_mapping(sizeof(all_zones));
   foreach (zone in all_zones)  {
      covered[zone] = ({ });
      pot_covered[zone] = ({ });
   }
   if (sizeof(items) == 0)
      armors = this_player()->query_armours();
   else
      armors = items;
   fail = filter(armors,
                 (: !$1->query_armour()  &&  !$1->query_clothing() :));
   armors -= fail;
   wearing = this_player()->query_wearing();
   if (bits)  {
      bits = replace(bits, " ", ",");
      bits = replace(bits, ",and,", ",");
      zones = explode(bits, ",") - ({ "" });
      parts = filter(zones, (: member_array($1, $(all_zones)) != -1 :));
      if (sizeof(parts) == 0)  {
         write("Please choose some combination of " +
               query_multiple_short(all_zones) + ".\n");
         return 1;
      }
   }
   foreach (armor in armors)  {
      if (!arrayp(armor->query_type()))
         types = ({ armor->query_type() });
      else
         types = armor->query_type();
      zones = ({ });
      foreach (type in types)  {
         equiv_type = CLOTHING_HANDLER->query_equivilant_type(type);
         if (equiv_type)
            zones += CLOTHING_HANDLER->query_zone_names(equiv_type);
         else
            zones += CLOTHING_HANDLER->query_zone_names(type);
      }
      if (sizeof(zones))  {
         if (member_array(armor, wearing) > -1)
            foreach (zone in zones)
               covered[zone] += ({ armor });
         else
            foreach (zone in zones)
               pot_covered[zone] += ({ armor });
      }
      else fail += ({ armor });
   }
   if (bits)  {
      covered = filter(covered, (: member_array($1, $(parts)) != -1 :));
      pot_covered = filter(pot_covered,
                           (: member_array($1, $(parts)) != -1 :));
   }
   if (inverse)  {
      zones = filter(all_zones, (: sizeof($(covered)[$1]) == 0 :));
      if (sizeof(zones) > 0)  {
         if (sizeof(zones) > 1  ||
             zones[0] == "arms"  ||  zones[0] == "hands"  ||
             zones[0] == "legs"  || zones[0] == "feet")
            verb = " are";
         else
            verb = " is";
         write("Your " + query_multiple_short(zones) + verb +
               " unprotected.\n");
      }
      else write("You are covered from head to foot.\n");
      return 1;
   }
   zones = sort_array(keys(covered) | keys(pot_covered), 1);
   foreach (zone in zones)  {
      if (zone == "arms"  ||  zone == "hands"  ||
          zone == "legs"  ||  zone == "feet")
         verb = " are";
      else
         verb = " is";
      if (sizeof(covering = covered[zone]) > 0)  {
         if (sizeof(covering) == 1)
            mess = "Your " + zone + verb + " protected by " +
                   covering[0]->one_short();
         else
            mess = "Your " + zone + verb + " protected by " +
                   query_num(sizeof(covering)) + " things, " +
                   query_multiple_short(covering, "one");
         if (sizeof(pot_covered[zone]) > 0)  {
            mess += " and could be protected by " +
                    query_multiple_short(pot_covered[zone], "one") + ".\n";
            pot_covered[zone] = ({ });
         }
         else mess += ".\n";
         write(mess);
      }
      else if (sizeof(covering = pot_covered[zone]) > 0)  {
         write("Your " + zone + " could be protected by " +
               query_multiple_short(covering, "one") + ".\n");
      }
      else if (bits) write("Your " + zone + verb + " unprotected.\n");
   }
   if (sizeof(fail) != 0  &&  sizeof(items) != 0)  {
      if (sizeof(fail) == 1  &&  fail[0] == this_player())
         write("You don't offer any protection.  Perhaps you should invest "
               "in some sonkies?\n");
      else
         write(query_multiple_short(fail, "the") +
               (sizeof(fail) == 1 ? " doesn't" : " don't") +
               " offer any protection.\n");
   }
   else if (sizeof(armors - fail) == 0)
      write("You are completely unprotected.  Good luck!\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd(({ }), 0, 0) :),
             "[by] <indirect:object'armour/clothing'>", (: cmd($1, 0, 0) :),
             "unprotected", (: cmd(({ }), 1, 0) :),
             "of <string'body part(s)'>", (: cmd(({ }), 0, $4[0]) :) });
}

==================================================
FILE: /lib/cmds/player/date.c
==================================================

#include "/cmds/player/time.c";
