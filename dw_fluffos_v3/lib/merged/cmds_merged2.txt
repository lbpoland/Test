# Total Tokens: 15923
# Total Files Merged: 18
# Total Characters: 53135

===============================================

#include <language.h>
#include <player.h>
#include <drinks.h>
#include <cmds/options.h>
#define TP this_player()
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)
#define REPLACEMENTS (["ne1":"anyone",\
                       "u":"you",\
                       "r":"are", \
                       "NE1":"anyone",\
                       "U":"you",\
                       "R":"are", \
                       "ur":"you are",\
                       "teh":"the", \
                       "some1":"someone"])
class message {
   string text;
   string emote;
   string language;
   string type;
   string notify_mess;
   int status;
}
varargs string query_word_type(string str, string def) {
  int i;
  if (!str || strlen(str) < 1)
    return "";
  for (i = strlen(str) - 1; i >= 0 && str[i] == ' '; i--);
  if (i < 0) {
    return "discombobulate";
  }
  switch (str[i]) {
  case '!':
    return "exclaim";
  case '?':
    return "ask";
  default:
    if (def)
      return def;
    else
      return "say";
  }
}
string mangle_tell(string mess, object dest) {
  int i;
  string ret;
  if (!TP || !environment(TP))
    return mess;
  if (environment(TP)->query_property("reverse_tell") &&
      !dest->query_creator() && !TP->query_creator()) {
    for (i = 0; i < strlen(mess); i++)
      ret = mess[i..i] + ret;
    return ret;
  }
  return mess;
}
string drunk_speech(string str) {
  return replace(str, ({ "S", "sh", "r", "rr", "ing", "in'", "x", "xsh",
                           "S", "SH", "R", "RR" }));
}
string de_eight(string arg) {
  object g;
  string replace_num;
  g = (object) TP->query_guild_ob();
  if (g && ((string) g->query_name() == "wizards") && !TP->query_creator()) {
    arg = "@ " + arg + "@";
    replace_num = ({ " seven plus one", " nine minus one",
                       " two to the power of three",
                       " four times two" })[random(4)];
    arg = implode(explode(arg, " eight"), replace_num);
    replace_num = ({ "(7+1)", "(9-1)", "(2^3)", "(4*2)" })[random(4)];
    arg = implode(explode(arg, "8"), replace_num);
    arg = arg[2.. < 2];
  }
  return arg;
}
string fix_shorthand(string mess) {
  string *bits, name, value;
  mixed *tmp;
  int index, i;
  bits = explode(mess, " ");
  foreach(name, value in REPLACEMENTS) {
    tmp = regexp(bits, "(^|[^A-Za-z]+)"+name+"($|[^A-Za-z]+)", 1);
    if(sizeof(tmp)) {
      for(i=0; i<sizeof(tmp); i+=2) {
        index = tmp[i+1]-1;
        bits[index] = replace(bits[index], name, value);
      }
    }
  }
  return implode(bits, " ");
}
void my_mess(string fish, string erk) {
  int bing;
  if (!interactive(TP)) {
    return;
  }
  bing = strlen(fish);
  if (bing > 15) {
    bing = 15;
  }
  efun::tell_object(TP, TP->fix_string(sprintf("%s%s\n", fish, erk),
                                       (int) TP->query_cols(), bing));
}
class message build_message(string arg, mixed target, string word_type) {
  string lang;
  string s1;
  string emotion;
  string word;
  string *langs;
  int i;
  class message mess;
  int done;
  mess = new (class message);
  if (!arg || arg == "" || arg == " ") {
    mess->status = NO_MESSAGE;
    return mess;
  }
  while (!done && (!lang || !emotion)) {
    switch (arg[0]) {
    case '#':
      if(word_type == "tell") {
        done = 1;
        continue;
      }
      if (arg[1] == '\'' && sscanf(arg, "#'%s' %s", lang, arg) == 2)
        continue;
      if (sscanf(arg, "%s %s", lang, arg) == 2) {
        lang = lang[1..];
        langs = LANGUAGE_HAND->query_languages();
        if (member_array(lang, langs) == -1) {
          for (i = 0; i < sizeof(langs); i++) {
            if (TP->query_skill(LANGUAGE_HAND->
                                query_language_spoken_skill(langs[i])) > 1 ||
                TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
              if (langs[i][0..strlen(lang)-1] == lang) {
                lang = langs[i];
              }
            }
          }
        }
      } else {
        done = 1;
      }
      break;
    case '@':
      if (sscanf(arg, "%s %s", emotion, arg) == 2) {
        emotion = emotion[1..] + " ";
      } else {
        done = 1;
      }
      break;
    default:
      done = 1;
    }
  }
  if (!emotion)
    emotion = "";
  if(lang == "general" && interactive(TP) && !TP->query_creator()) {
    mess->status = NOT_KNOWN;
    return mess;
  }
  if(!lang)
    lang = (string) TP->query_current_language();
  mess->language = lang;
  if(!LANGUAGE_HAND->query_language_spoken(lang)) {
    mess->status = NOT_SPOKEN;
    return mess;
  }
  if(word_type == "shout" && !LANGUAGE_HAND->query_language_distance(lang)) {
    mess->status = NOT_DISTANCE;
    return mess;
  }
  if(word_type != "tell" &&
     !TP->query_skill(LANGUAGE_HAND->query_language_spoken_skill(lang)) &&
     !LANGUAGE_HAND->query_language_always_spoken(lang)) {
    mess->status = NOT_KNOWN;
    return mess;
  }
  if (!interactive(TP)) {
    arg = TP->convert_message(arg);
    arg = TP->fit_message(arg);
  }
  arg = replace(arg, ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                            "[D", "", "%^", " " }));
  if(TP->query_property(SHORTHAND_PROP))
    arg = LANGUAGES->fix_shorthand(arg);
  if(word_type != "tell") {
    if(TP->query_volume(D_ALCOHOL))
      arg = drunk_speech(arg);
    s1 = TP->mangle_speech(arg);
    if (stringp(s1))
      arg = s1;
    if(TP && environment(TP) &&
       function_exists("mangle_speech", environment(TP)))
      arg = (string) environment(TP)->mangle_speech(word_type, arg, target);
    arg = de_eight(arg);
  }
  word = query_word_type(arg, word_type);
  mess->text = arg;
  mess->type = word;
  mess->emote = emotion;
  mess->status = MESSAGE_OK;
  if (target)
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$ $target$: ";
  else
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$: ";
  return mess;
}
int say_it(class message mess) {
  string accent;
  if (!environment(TP))
    write("You are in limbo, noone can hear you.\n");
  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  TP->remove_hide_invis("hiding");
  accent = TP->query_nationality_accent_ob();
  TP->comm_event(environment(TP), "person_say",
                 mess->notify_mess, mess->text, mess->language, accent);
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    my_mess("You " + mess->emote + mess->type + " in " +
            capitalize(mess->language) + ": ", mess->text);
  } else {
    my_mess("You " + mess->emote + mess->type + ": ", mess->text);
  }
  TP->adjust_time_left(-5);
  return 1;
}
int say_it_to(class message mess, mixed targets, int priv, string event) {
  string lstr;
  string extra;
  string accent;
  if (!environment(TP)) {
    write("You are in limbo, noone can hear you.\n");
  }
  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  if (!sizeof(targets)) {
    return 0;
  }
  targets -= ({ this_player() });
  TP->remove_hide_invis("hiding");
  this_player()->adjust_time_left(-5);
  accent = TP->query_nationality_accent_ob();
  switch (mess->type) {
  case "exclaim":
  case "whisper":
  case "say":
    extra = "to ";
    break;
  default:
    extra = "";
  }
  switch (priv) {
  case 2:
    break;
  case 1:
    TP->comm_event_to(environment(this_player()), event,
                      (string) this_player()->one_short(1) +
                      " " + mess->emote + mess->type + "s " +
                      extra, mess->text, targets, mess->language,
                      this_player(), accent);
    break;
  case 0:
    TP->comm_event(environment(TP), event,
                   "$one_short:" + file_name(TP) + "$ " + mess->emote +
                   "$V$0=" + mess->type + "s," + mess->type + "$V$ " +
                   extra + query_multiple_short(targets, "the") + ": ",
                   mess->text, mess->language, accent);
    break;
  }
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    lstr = " in " + cap_words(mess->language);
  } else {
    lstr = "";
  }
  write("You " + mess->emote + mess->type + " " + extra +
        query_multiple_short(targets, "the") + lstr + ": " +
        mess->text + "\n");
  return 1;
}

==================================================
FILE: template.c
==================================================

inherit "/cmds/base";
mixed cmd(string args) {
  return 0;
}
string help() {
  return "No help defined for this command, bug a creator about it!\n";
}

==================================================
FILE: theft_base.c
==================================================

#include <thief.h>
#include <obj_parser.h>
#include <player.h>
#define SKILL "covert.manipulation.stealing"
#define PERCEPTION "other.perception"
inherit "/cmds/guild_base";
int query_theft_command() { return 1; }
int victim_checks(object thief, object victim) {
  if(thief == victim)
    return notify_fail("Be serious!\n");
  if(thief->query_property("dead"))
    return notify_fail("Be serious, you're dead!\n");
  if(thief->query_auto_loading())
    return notify_fail("You don't have all your equipment yet..\n");
  if(victim->query_auto_loading())
    return notify_fail( "Be sporting; "+ (string)victim->the_short() +
                        " doesn't have "+ (string)victim->query_possessive() +
                        " equipment yet.\n" );
  if(userp(victim) && !interactive(victim))
    return notify_fail( "You can't " + query_verb() +
                        " from a net dead statue.\n");
  if(victim->query_property("nosteal"))
    return notify_fail("You cannot " + query_verb() + " from " +
                       victim->the_short() + ".\n");
  if(victim->query_sanctuary())
    return notify_fail("You can't snatch from someone who is protected.\n");
  if(pk_check(thief, victim))
    return notify_fail("You feel it would be wrong to " + query_verb() +
                       " from "+ victim->short()+".\n");
  if(victim->query_creator() && !thief->query_creator() ) {
    notify_fail("Stop trying to steal from creators.\n");
    thief->adjust_tmp_dex(-10);
    return 0;
  }
  return 1;
}
mixed get_item(object thief, mixed location, string str) {
  class obj_match result;
  result = (class obj_match)match_objects_in_environments(str, location, 0, thief);
  if(result->result != OBJ_PARSER_SUCCESS)
    return notify_fail("Pssst, they don't have one of those.\n");
  result->objects = filter(result->objects,
                           (: environment($1) == $(location) :));
  if(!sizeof(result->objects))
    return notify_fail("Pssst, they don't have one of those.\n");
  if(sizeof(result->objects) != 1)
    return notify_fail("You can only " + query_verb() +
                       " one thing at a time.\n");
  return result->objects[0];
}
int combat_checks(object thief, object victim) {
  if(thief->query_fighting()) {
    notify_fail("You can't attempt to " + query_verb() +
                " while in battle.\n");
    return 2;
  }
  if(member_array(thief, victim->query_attacker_list()) != -1) {
    notify_fail("You cannot attempt to " + query_verb() + " from someone "
                "that is fighting you.\n");
    return 1;
  }
  return 0;
}
int item_checks(object victim, object item, int wielded_ok, int worn_ok) {
  if(item->query_liquid() && item->query_food_object())
    return notify_fail("You cannot " + query_verb() + " liquids!\n");
  if(item->query_property("nosteal") ||
     (!wielded_ok && item->query_wielded() == victim) ||
     (!worn_ok && item->query_worn_by() == victim))
    return notify_fail("You cannot " + query_verb() + " " +
                       item->the_short() + " from " +
                       victim->the_short() + ".\n");
#ifdef QUOTA_CHECK
  if(!check_player_quota(victim, item))
    return notify_fail("A quick reveals that " + query_verb() + "ing " +
                       item->the_short() + " would exceed " +
                       victim->query_possessive() + "'s theft quota.\n");
#endif
  return 1;
}
int calc_value(object ob) {
  int value;
  object tmp, *inv;
  string name;
  sscanf( file_name( ob ), "%s#%*d", name );
  if( name = "/obj/package" ) {
    value = 0;
  }
  else {
    value = ob->query_value();
  }
  inv = deep_inventory(ob);
  if(sizeof(inv))
    foreach(tmp in inv)
      value += tmp->query_value();
  return value;
}
int check_player_quota(object victim, object ob) {
  object *things, thing;
  int quota, reported, valid, value;
  value = 0;
  things = ({ ob });
  things += deep_inventory(ob);
  foreach(thing in things) {
    if(thing->query_property("money") ) {
      value += thing->query_value_in("Ankh-Morpork");
    } else {
      value += thing->query_value();
    }
  }
  quota = QUOTA->query_player_quota(victim->query_name());
  reported = QUOTA->query_player_reported(victim->query_name());
  valid = QUOTA->query_player_valid(victim->query_name());
  if((quota - (reported + valid)) < value)
    return 0;
  return 1;
}
int steal_item(object thief, object victim, object item) {
  object *stolen;
  string sh;
  if(item->move(thief))
    return notify_fail( "You cannot " + query_verb() + " " +
                        item->the_short()+" from "+
                        (string)victim->the_short() +".\n");
  stolen = ({ item });
  stolen += deep_inventory(item);
  tell_object(thief, "You steal "+query_multiple_short(stolen, "the" )+
              " from "+ victim->the_short() +".\n" );
  if( environment(thief)->query_theft_handler() &&
      regexp(environment(thief)->query_theft_handler(), "/d/am/") &&
        thief->query_name() == "wobin" )
      stolen = THEFT_INSURANCE->check_items(stolen, victim, thief);
  event( environment( thief ), "theft", thief, victim, stolen );
  event( stolen, "theft", thief, victim );
  item->event_ward( thief, victim );
  if(thief->query_property("player") &&
     query_ip_number(thief) == query_ip_number(victim) &&
     sizeof(PLAYER_MULTIPLAYER_HANDLER->check_allowed(thief, ({victim})))) {
    sh = capitalize(thief->query_name())+ " stole " +
      query_multiple_short(stolen) +
      " from " + victim->query_name() + " while logged in from the same IP "
      "address.";
    user_event("inform", sh, "multiplayer");
    sh = victim->convert_message(sh);
    log_file("MULTIPLAYERS", ctime(time()) + ": " + sh + "\n");
  }
  return 1;
}

==================================================
FILE: lord/authorise.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
nosave string var_name = "map_prop ";
nosave string fname;
mapping map_prop;
mapping player_info;
string name;
string password;
string email;
int last_log_on;
string basename;
mixed cmd(string player) {
  if(find_player(player)) {
    find_player(player)->add_property("authorised player", 1);
    return 1;
  }
  if (PLAYER_HANDLER->test_user(player)) {
    if("/cmds/lord/playera_ddproperty"->cmd(player, "authorised player","1")) {
      PLAYER_HANDLER->remove_cache_entry(player);
      return 1;
    }
    return 0;
  }
  write(capitalize(player) + " does not exists.  Do you wish to create them? ");
  input_to("really_create", 0, player);
  add_succeeded_mess("");
  return 1;
}
void really_create(string response, string player) {
   response = lower_case(response);
   if (response[0] != 'y') {
      write("Aborting create.\n");
      return ;
   }
   write("Ok, creating player " + capitalize(player) + ".\n");
   write("What is their authorised email address: ");
   input_to("get_email", 0, player);
}
void get_email(string str, string player) {
  email = str;
  write("What password do you wish to use: ");
  input_to("get_password", 0, player);
}
void get_password(string passw, string player) {
   string save_file_name;
   save_file_name = PLAYER_HANDLER->query_player_file_name(player);
   map_prop = ([ "authorised player" : 1,
                 "new player" : 1,
                 "player" : 1,
                 "authorised email" : email, ]);
   player_info = ([ "email" : ":"+email, ]);
   last_log_on = time();
   name = player;
   password = crypt(passw, 0);
   save_object(save_file_name);
   write("Create player " + capitalize(player) + " with authorisation to login "
         "from nologin sites.\n");
}
int enable(string player, string address) {
  string *ips, file, *bits;
  int i;
  if(!PLAYER_HANDLER->test_user(player))
    return notify_fail("No such user " + player + ".\n");
  basename = "/save/players/" + player[0..0] + "/" + player;
  unguarded ( (: uncompress_file (basename + ".o.gz") :));
  file = unguarded( (: read_file(basename + ".o") :));
  bits = explode(file, "\n");
  for (i = 0; i < sizeof(bits); i++) {
    if (bits[i][0..strlen("player_info")-1] == "player_info") {
      player_info = restore_variable(bits[i][strlen("player_info") + 1..]);
      break;
    }
  }
  ips = player_info["allowed_ips"];
  if(!ips)
    ips = ({ });
  if ( member_array(address, ips ) == -1 )  {
    ips += ({ address });
    player_info["allowed_ips"] = ips;
    if (i < sizeof(bits)) {
      bits[i] = "player_info " + save_variable(player_info);
    } else {
      bits += ({ "player_info " + save_variable(player_info) });
    }
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", implode($(bits), "\n") + "\n") :));
    unguarded ( (: compress_file (basename + ".o") :));
  } else  {
    write( player + " is already allowed to login from  " + address + ".\n" );
  }
  write(player + " is now allowed to login from "+address+".\n");
  return 1;
}
int disable(string player, string address) {
  string *ips, file, *bits;
  int i;
  if(!PLAYER_HANDLER->test_user(player))
    return notify_fail("No such user " + player + ".\n");
  basename = "/save/players/" + player[0..0] + "/" + player;
  unguarded ( (: uncompress_file (basename + ".o.gz") :));
  file = unguarded( (: read_file(basename + ".o") :));
  bits = explode(file, "\n");
  for (i = 0; i < sizeof(bits); i++) {
    if (bits[i][0..strlen("player_info")-1] == "player_info") {
      player_info = restore_variable(bits[i][strlen("player_info") + 1..]);
      break;
    }
  }
  ips = player_info["allowed_ips"];
  if(!ips)
    ips = ({ });
  if ( member_array(address, ips ) != -1 )  {
    ips -= ({ address });
    player_info["allowed_ips"] = ips;
    if (i < sizeof(bits)) {
      bits[i] = "player_info " + save_variable(player_info);
    } else {
      bits += ({ "player_info " + save_variable(player_info) });
    }
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", implode($(bits), "\n") + "\n") :));
    unguarded ( (: compress_file (basename + ".o") :));
  } else  {
    write( player + " is not already allowed to login from  " +address+ ".\n");
  }
  write(player + " is now not allowed to login from "+address+".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "enable <word'player'> <string'address'>",
              (: enable($4[0], $4[1]) :),
              "disable <word'player'> <string'address'>",
              (: disable($4[0], $4[1]) :),
              "<word'player'>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/clubs.c
==================================================

#include <clubs.h>
#include <mail.h>
inherit "/cmds/base";
#define CONTROL_ROOM "/std/room/club_control_room"
#define ELEN 20
nosave string *bad_words = ({ "black", "blood", "cyber", "dark", "penis",
                              "cock", "pussy", "fuck", "shit", "death",
                              "dragon", "fight", "hell", "mage", "pink",
                              "lord", "shadow", "evil", "kill", "slay",
                              "hate", "anti", "bastard" });
private void do_invalid(string extra, int width);
private int do_delete(string extra, string reason, int width);
mixed cmd(string command, string extra, string rest) {
  if (this_player() != this_player(1))
    return 0;
  switch(command) {
  case "invalid":
    do_invalid(extra, this_player()->query_cols());
    break;
  case "delete":
    return do_delete(extra, rest, this_player()->query_cols());
  }
  return 1;
}
private string club_line(string club, int width, int verbose) {
  string tmp, tmp2, member;
  int clubtype, i;
  clubtype = CLUB_HANDLER->query_club_type(club);
  tmp = sprintf("%%^BOLD%%^%%^RED%%^%-9s%%^RESET%%^ %-15s\n",
                CLUB_ARRAY[clubtype]+":", club);
  if(verbose) {
        tmp+= sprintf(" %%^BOLD%%^Club Name:%%^RESET%%^ %s\n",
                  CLUB_HANDLER->query_club_name(club));
    tmp += sprintf(" %%^BOLD%%^Founder:%%^RESET%%^ %s\n"
                   " %%^BOLD%%^Members:%%^RESET%%^\n",
                   CLUB_HANDLER->query_founder(club));
    i = 0;
    tmp2 = "";
    foreach(member in CLUB_HANDLER->query_members(club)) {
      tmp2 += sprintf("%-15s ", member);
      if((i-1 * ELEN) % (width/ELEN) == 0  && tmp2 != "") {
        tmp += this_player()->fix_string("   " + tmp2 + "\n", width, 10);
        tmp2 = "";
      }
      i++;
    }
  }
  return tmp;
}
private int check_dodgy_name(string club) {
  string s1, s2, lname, word;
  lname = lower_case(club);
  lname = replace(lname, ({"'", "", "_", "", " ", ""}) );
  foreach(word in bad_words)
    if ( sscanf( lname, "%s" + word + "%s", s1, s2 ) == 2 )
      return 1;
  return 0;
}
private void do_invalid(string extra, int width) {
  string club, *clubs, tmp, tmp2;
  int ok;
  tmp = "";
  tmp2 = "";
  clubs = sort_array(CLUB_HANDLER->query_clubs(),
                     (: strcmp($1, $2 ) :) );
  foreach(club in clubs) {
    ok = 1;
    switch(CLUB_HANDLER->query_club_type(club)) {
    case CLUB_FAMILY:
      ok = CONTROL_ROOM->is_valid_family_name(club);
      break;
    case CLUB_PERSONAL:
    case CLUB_ELECTED:
      ok = CONTROL_ROOM->is_valid_club_name(club);
      break;
    }
    if(!ok)
      tmp += club_line(club, width, extra == "verbose");
    else if(check_dodgy_name(club))
      tmp2 += club_line(club, width, extra == "verbose");
  }
  if(tmp == "")
    write("No invalid clubs.\n");
  else
    this_player()->more_string(tmp, "Clubs", 1);
  if(tmp2 == "")
    write("No dodgy clubs.\n");
  else
    this_player()->more_string("Dodgy names:\n\n" + tmp2, "Clubs", 1);
}
private int do_delete(string club, string reason, int width) {
  string founder, members, message, cname;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return notify_fail("You must be a lord to delete a club.");
  if(!club)
    return notify_fail("You must give a club name.\n");
  if(!CLUB_HANDLER->is_club(club))
    return notify_fail(club+" is not a current club.\n");
  write("Disbanding: " + club);
  founder = CLUB_HANDLER->query_founder(club);
  members = implode(CLUB_HANDLER->query_members(club), ", ");
  cname = CLUB_HANDLER->query_club_name(club);
  if(CLUB_HANDLER->disband_club(club)) {
    write(" succeeded.\n");
    message = sprintf("The club %s has been deleted by %s for "
                      "%s\n", cname,
                      this_player()->query_name(),
                      reason);
    MAILER->do_mail_message(founder, this_player()->query_name(),
                            "Your club has been deleted.",
                            members, message);
  } else
    write(" failed.\n");
  return 1;
}
mixed *query_patterns() {
  return ({
            "invalid", (: cmd("invalid", "", "") :),
            "invalid <string>", (: cmd("invalid", $4[0], "") :),
            "delete <word> <string>", (: cmd("delete", $4[0], $4[1]) :),
        });
}

==================================================
FILE: lord/conv.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
private string print_access(string bit, mapping bing, int depth, int cols, string filter);
mixed cmd(string ip, string ident, string level, string reason) {
   seteuid("Root");
   if (this_player() != this_player(1))
      return 0;
   switch(level) {
   case "nonew":
      level = "2";
      break;
   case "noacccess":
      level = "3";
      break;
   case "normal":
      level = "1";
      break;
   }
   if (!"/secure/bastards.old"->change_access(explode(ip, "."), ident,
                                                             to_int(level), reason)) {
      write("Error changing permissions.\n");
      return 0;
   }
   write("Access permisions changed.\n");
   printf("User %s at site %s set to %s for %s\n",
             ident, ip, PERM_NAMES[to_int(level)], reason);
   return 1;
}
int access(string filter) {
   mixed bing;
   seteuid("Root");
   if (this_player() != this_player(1))
      return 0;
   bing = (mixed)"/secure/bastards.old"->query_all_access();
   if (!m_sizeof(bing)) {
      notify_fail("No access control defined.\n");
      return 0;
   }
   write("Current access list:\n");
   bing = print_access("", bing, 0, (int)this_player()->query_cols(), filter);
   this_player()->more_string(bing, "site access");
   return 1;
}
private string print_access(string bit, mapping bing, int depth, int cols,
                            string filter) {
   mixed *bits;
   int i;
   string ret;
   string colour;
   ret = "" ;
   if (this_player() != this_player(1)) {
      return 0;
   }
   bits = m_indices(bing);
   if (depth == 4) {
      if(!filter || filter == "" ||
          strsrch(bit, filter) != -1 || strsrch(bits[i], filter) != -1) {
         for (i=0;i<sizeof(bits);i++) {
            switch (bing[bits[i]][0]) {
            case NO_NEW:
               colour = "%^CYAN%^";
               break;
            case NO_ACCESS:
               colour = "%^YELLOW%^";
               break;
            default :
               colour = "";
               break;
            }
            write(replace(bit, ".*", "")[1..] + "\n");
            "/secure/bastards"->change_access(replace(bit, ".*", "")[1..],
                                              bing[bits[i]][0],
                 "/secure/bastards.old"->query_reason(explode(bit, "."), bits[i]));
         }
      }
      return "";
   }
   for (i=0;i<sizeof(bits);i++) {
      ret += print_access(bit+"."+bits[i], bing[bits[i]], depth+1, cols,
                          filter);
   }
   return ret;
}
int help() {
   return notify_fail(
      "Syntax: site access\n"+
      "            site ban <ip number> <ident> <level> <reason>\n"+
      "                         <level> := normal [1] normal access,\n"+
      "                                          nonew [2] no new players, \n"+
      "                                          noaccess [3] no access.\n");
}
mixed *query_patterns() {
   return ({ "ban <word'address'> <word'ident'> <word'level'> "
                     "<string'reason'>",
                     (: cmd($4[0], $4[1], $4[2], implode($4[3..], "")) :),
                     "access <word'address'>", (: access($4[0]) :),
                     "access", (: access("") :),
                     "", (: help() :),
                     "help", (: help() :)
                     });
}

==================================================
FILE: lord/dinfo.c
==================================================

#include <player_handler.h>
string master;
string dinfo( string name, int cols, string option );
string get_last_log( int last_log_on );
mixed cmd(string name, string option) {
  if (!name) {
    return notify_fail("You must give a domain.\n");
  }
  this_player()->more_string(dinfo(name, (int)this_player()->query_cols(),
                                   option), "Domain Info");
  return 1;
}
string dinfo( string name, int cols, string option ) {
  string ret, *members;
  int i;
  if(member_array(name, "/secure/master"->query_domains()) == -1)
    return "No such domain: " + name + "\n";
  master = "/d/"+name+"/master";
  write(master+"\n");
  members = master->query_members();
  switch (option[0..0]) {
  case "n":
    members = sort_array(members, 1);
    break;
  case "p":
    members = sort_array(members,
                         (: strcmp(master->query_project($1),
                                   master->query_project($2)) :));
    break;
  case "l":
    members = sort_array(members,
                         (:PLAYER_HANDLER->test_last($2) -
                          PLAYER_HANDLER->test_last($1):));
    break;
  }
  ret = "The current members of this domain are:";
  for (i=0;i<sizeof(members);i++) {
    ret += sprintf("\n%-12s: Last login: %s\n",
                   capitalize(members[i]),
                   find_player(members[i])?
                     "%^GREEN%^%^BOLD%^Now%^RESET%^"
                     :get_last_log((int)PLAYER_HANDLER->test_last(members[i])),
                   );
    ret += sprintf("              Project   : %-=*s\n", cols-27,
                   master->query_project(members[i]));
  }
  return ret;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}
string get_last_log(int last_log_on) {
    string retval;
    int tmp_time, sec, min, hour, day;
    tmp_time = time()-last_log_on;
    if (!tmp_time) {
      sec = min = hour = day = 0;
    }
    if(tmp_time > 24*60*60) {
      retval = (day = tmp_time/(24*60*60))+" day"+
                (day<2?"":"s")+" ago.";
      if(day > 14)
        retval = "%^RED%^"+retval+"%^RESET%^";
      else if(day > 7)
        retval = "%^YELLOW%^"+retval+"%^RESET%^";
      else
        retval = "%^GREEN%^"+retval+"%^RESET%^";
    } else
      retval = "%^GREEN%^Today%^RESET%^";
    return retval;
}
mixed query_patterns() {
  return ({
    "<string'domain'>", (: cmd($4[0], " ") :),
    "<string'domain'> [by] {n|name|p|project|l|login}",
      (: cmd($4[0], $4[1]) :)
  });
}

==================================================
FILE: lord/dom_ain.c
==================================================

#include <parser.h>
#include <access.h>
#include <player_handler.h>
inherit "/cmds/base";
#define MASTER "/secure/master"
string get_last_log( int last_log_on );
string master;
int list(string arg) {
  int i, num, cols;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = get_dir("/d/");
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  if(arg) {
    if(member_array(arg, domains) == -1) {
      notify_fail("No such domain as " + arg + ".\n");
      return 0;
    } else {
      mast = "/d/" + arg + "/master";
      write(capitalize((string)mast->query_lord()) + " is the lord of " +
        arg + ".\nMembers         Project\n");
      members = (string *)mast->query_members();
      cols = (int)this_player()->query_cols();
      for (i=0;i<sizeof(members);i++)
        printf("%-15s %*-=s\n", members[i], cols-16,
                               mast->query_project(members[i]));
      return 1;
    }
  }
  write("Current domains:\n");
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    members = (string *)mast->query_members(arg);
    printf( "%15s has %2d %-7s and is owned by %s.\n", domains[ i ],
            num = sizeof( (string *)mast->query_members() ),
            ( ( num == 1 ) ? "member" : "members" ),
            capitalize( (string)mast->query_lord() ) );
  }
  return 1;
}
int add_creator(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if(!mast->add_member(cre)) {
    notify_fail("Failed to add " + capitalize(cre) + " to domain " +
      dom + ".\n");
    return 0;
  }
  write("Creator " + capitalize(cre) + " now added to domain " + dom + ".\n");
  return 1;
}
int delete_creator(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if (!mast->remove_member(cre)) {
    notify_fail("Failed to remove " + capitalize(cre) + " from domain " +
       dom + "\n");
    return 0;
  }
  write("Member " + capitalize(cre) + " removed from domain " + dom + ".\n");
  return 1;
}
int do_project(string cre, string dom, string project) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if (!mast->set_project(cre, project)) {
    notify_fail("Failed to set the project " + project + " for " +
                capitalize(cre) + " in the domain " + dom + "\n");
    return 0;
  }
  write("Project for " + capitalize(cre) + " set to " + project +
        " in the domain " + dom + ".\n");
  return 1;
}
#ifdef DISABLED
int do_info() {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;
  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = "/secure/master"->query_domains();
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!PLAYER_HANDLER->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
    creators -= mem;
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!PLAYER_HANDLER->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  cre_not -= ({ ".dead_ed_files", ".old_creators" });
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
}
#endif
int detailed_info( string name, string option ) {
  string ret, *members;
  int i, cols;
  if(member_array(name, "/secure/master"->query_domains()) == -1)
    return notify_fail("No such domain: " + name + "\n");
  cols = this_player()->query_cols();
  master = "/d/"+name+"/master";
  write(master+"\n");
  members = master->query_members();
  switch (option[0..0]) {
  case "n":
    members = sort_array(members, 1);
    break;
  case "p":
    members = sort_array(members,
                         (: strcmp(master->query_project($1),
                                   master->query_project($2)) :));
    break;
  case "l":
    members = sort_array(members,
                         (:PLAYER_HANDLER->test_last($2) -
                          PLAYER_HANDLER->test_last($1):));
    break;
  }
  ret = "The current members of this domain are:";
  for (i=0;i<sizeof(members);i++) {
    ret += sprintf("\n%-12s: Last login: %s\n",
                   capitalize(members[i]),
                   find_player(members[i])?
                     "%^GREEN%^%^BOLD%^Now%^RESET%^"
                     :get_last_log((int)PLAYER_HANDLER->test_last(members[i])),
                   );
    ret += sprintf("              Project   : %-=*s\n", cols-27,
                   master->query_project(members[i]));
  }
  this_player()->more_string(ret, "Domain Info");
  return 1;
}
string get_last_log(int last_log_on) {
    string retval;
    int tmp_time, sec, min, hour, day;
    tmp_time = time()-last_log_on;
    if (!tmp_time) {
      sec = min = hour = day = 0;
    }
    if(tmp_time > 24*60*60) {
      retval = (day = tmp_time/(24*60*60))+" day"+
                (day<2?"":"s")+" ago.";
      if(day > 14)
        retval = "%^RED%^"+retval+"%^RESET%^";
      else if(day > 7)
        retval = "%^YELLOW%^"+retval+"%^RESET%^";
      else
        retval = "%^GREEN%^"+retval+"%^RESET%^";
    } else
      retval = "%^GREEN%^Today%^RESET%^";
    return retval;
}
mixed *query_patterns() {
  return ({
    "list <string'list'>", (: list($4[0]) :),
    "add <word'creator'> <word'domain'>", (: add_creator($4[0], $4[1]) :),
    "delete <word'creator'> <word'domain'>",
      (: delete_creator($4[0], $4[1]) :),
    "project <word'creator'> <word'domain'> <string'project'>",
      (: do_project($4[0], $4[1], implode($4[2..], " ")) :),
#ifdef DISABLED
    "info", (: do_info() :),
#endif
    "info <string'domain'>", (: detailed_info($4[0], " ") :),
    "info <string'domain'> [by] {n|name|p|project|l|login}",
      (: detailed_info($4[0], $4[1]) :) });
}

==================================================
FILE: lord/domainlock.c
==================================================

#include <applications.h>
inherit "/cmds/base";
int domain_check() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  foreach (string s, int o in map) {
    ret += capitalize (s) + " is " + (o ? "open" : "closed") + " to "
      "applications and is managed by " +
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n";
  }
  this_player()->more_string (ret);
  return 1;
}
int cmd( string domain, int status ) {
  int i = APPLICATIONS_HANDLER->query_domain_status()[domain];
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "You do not have "
      "permission to close the " + domain + " domain.\n");
    return 0;
  }
  if (status != i) {
    APPLICATIONS_HANDLER->toggle_domain_lock (domain);
    this_player()->add_succeeded_mess (this_object(), "$N furtively "
      "toggle$s something.\n", ({ }));
    return 1;
  }
  this_player()->add_failed_mess (this_object(), "Your domainlock is "
    "already set to that.\n", ({ }));
  return 0;
}
mixed *query_patterns() {
    return ({ "<string'domain'> on", (: cmd( $4[0], 0 ):),
      "<string'domain'> off", (: cmd( $4[0], 1  ):),
      "list", (: domain_check() :) });
}

==================================================
FILE: lord/invcheck.c
==================================================

#define INV_CHECK "/d/admin/obj/inv_check"
inherit "/cmds/base";
int cmd( string filename, string switch_on) {
    switch (switch_on) {
      case "ban":
        INV_CHECK->ban_object (filename);
      break;
      case "unban":
        INV_CHECK->unban_object (filename);
      break;
      default:
        tell_object (this_player(), INV_CHECK->list_banned());
      break;
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "ban <string'filename'>", (: cmd( $4[0], "ban"):),
      "unban <string'filename'>", (: cmd( $4[0], "unban"  ):),
      "list", (: cmd("", "list"):)});
}

==================================================
FILE: lord/jumps.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }
   return load_object(str);
}
int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;
   from_ob = find_location(from);
   to_ob = find_location(to);
   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }
   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}
int do_path_list() {
   string str;
   string from;
   string* dest;
   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}
int do_remove_jump(string from, string to) {
   string* dests;
   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}

==================================================
FILE: lord/mkdirect_or.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_trustee( previous_object( -1 ) ) )
    return notify_fail("You must be a trustee to add a director.\n");
  if("/secure/master"->add_director(creator)) {
    write(creator + " promoted to directorship.\n");
    return 1;
  } else
    return notify_fail("Call to add_director failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/mkl_ord.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->high_programmer( previous_object( -1 ) ) )
    return notify_fail("You must be a highlord to add a lord.\n");
  if("/secure/master"->add_director(creator)) {
    write(creator + " promoted to director.\n");
    return 1;
  } else
    return notify_fail("Call to add_director failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/mks_enior.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_lord( previous_object( -1 ) ) )
    return notify_fail("You must be a lord to create a senior creator.\n");
  if("/secure/master"->add_senior(creator)) {
    write(creator + " promoted to senior.\n");
    return 1;
  } else
    return notify_fail("Call to add_senior failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/nskills.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
int new_skill_value(int sk) {
	float f = 1000.0;
	float k = 0.3;
	if(sk == 0)
		return 0;
	return to_int(f * log( 1.0 + sk/(f + sk * k) ) + 0.5);
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      if(tp[0..14] != ".other.language" && tp[0..13] != "other.language") {
        sk = new_skill_value(sk);
      }
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)new_skill_value(pl->query_skill_bonus( tp )) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
int cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );
		 this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
     result += "New guild level: " +
		   (pl->query_guild_ob())->query_new_level(pl) + "\n";
   this_player()->more_string( result, "Skills" );
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}
mixed *query_patterns() {
  return ({ "<indirect:any-living> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:any-living>",
            (: cmd($1, 0) :) });
}

==================================================
FILE: lord/playera_ddproperty.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
string var_name = "map_prop ";
string fname;
mixed cmd(string player, string name, mixed value) {
   mixed *args;
   string file;
   string *bits;
   mapping map_prop;
   int i, found;
   seteuid("Root");
   fname = "/save/players/" + player[0..0] + "/" + player;
   map_prop = ([ ]);
   if (!PLAYER_HANDLER->test_user(player))
     return notify_fail("Unable to find player "+player+".\n");
   uncompress_file (fname+".o.gz");
   file = unguarded( (: read_file(fname+".o") :));
   if(!file)
     return notify_fail("Error reading player file " + fname + ".\n");
   bits = explode(file, "\n");
   map_prop = ([ ]);
   for (i = 0; i < sizeof(bits); i++) {
     if (bits[i][0..strlen(var_name)-1] == var_name) {
       map_prop = restore_variable(bits[i][strlen(var_name) + 0..]);
       found = 1;
       break;
     }
   }
   if(!found || !map_prop)
     return notify_fail("Failed to find property mapping.\n");
   if(stringp(args)) {
     args = PARSER->parse_args(value);
     if(!args || !sizeof(args[0]))
       return notify_fail("No useful args...\n");
     map_prop[name] = args[0][0];
     write(sprintf("Added property %s to %s; value = %O\n",
                   name, player, args[0][0]));
   } else {
     map_prop[name] = value;
   }
   if (i < sizeof(bits)) {
     bits[i] = var_name + save_variable(map_prop);
   } else {
     bits += ({ var_name + save_variable(map_prop) });
   }
   unguarded( (: rm(fname + ".old") :) );
   unguarded( (: rename(fname+".o", fname+".old") :) );
   unguarded( (: write_file(fname + ".o",
                            implode($(bits), "\n") + "\n") :));
   compress_file (fname+".o");
   this_player()->add_succeeded_mess (this_object(), "$N manipulate$s "
    "reality a little.\n", ({ }));
   return 1;
}
mixed *query_patterns() {
  return ({ "<word> <string:quoted> <string>", (: cmd($4[0], $4[1], $4[2]) :),
            });
}

==================================================
FILE: lord/playerp_roperty.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mapping map_prop;
mixed cmd(string str) {
   string name;
   string value;
   string player;
   mixed *args;
   if (!str) {
      return notify_fail("You must give a property...\n");
   }
   if (sscanf(str, "%s \"%s\" %s", player, name, value) == 3) {
      seteuid("Root");
      unguarded( (: restore_object("/players/" + $(player[0..0]) +
                                   "/" + $(player)) :));
      if (PLAYER_HANDLER->test_user(player)) {
         args = PARSER->parse_args(value);
         if (args && sizeof(args[0]) > 0) {
            map_prop[name] = args[0][0];
            unguarded( (: write_file("/players/" + $(player[0..0]) +
                               "/" + $(player) + ".o",
                       "map_prop "+save_variable(map_prop)+"\n") :));
            write(sprintf("Added property %s to %s; value = %O\n",
                          name, player, args[0][0]));
         } else {
            write("No useful args...\n");
         }
      } else {
         write("Unable to find player "+player+".\n");
      }
   } else {
      write("Syntax: player_add_property <name> \"<prop>\" <value>\n");
   }
   return 1;
}

==================================================
FILE: lord/ptest_ers.c
==================================================

#include <player.h>
#define LOGIN "/secure/login"
inherit "/cmds/base";
int main_menu( string cmd, string name, string reason ) {
   string str;
   switch ( cmd[ 0 ] ) {
      case 'L' :
      case 'l' :
         str = PLAYTESTER_HAND->query_show_list();
         str += "\n\nSee: 'ptesters H' for help.\n";
         this_player()->more_string(str, "Playtester");
         return 1;
      case 'A' :
      case 'a' :
         if ( !name ) {
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if (!PLAYTESTER_HAND->valid_playtester( name ) ) {
            printf( capitalize( name ) + " cannot be made a play tester "
                    "because: " + PLAYTESTER_HAND->reason_invalid_playtester(name) +
                    ".\n");
            break;
         }
         if ( (int)PLAYTESTER_HAND->add_playtester( name ) ) {
            printf( capitalize( name ) +" is now a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is already a playtester.\n" );
         }
         break;
      case 'S' :
      case 's' :
         if ( !name ) {
            return 0;
         }
         if ( !PLAYTESTER_HAND->query_playtester( name ) ) {
            printf( capitalize( name ) +" is not yet a playtester.\n" );
         } else {
            if ( (int)PLAYTESTER_HAND->add_senior_playtester( name ) ) {
               printf( capitalize( name ) +" is now a senior playtester.\n" );
            } else {
               printf( capitalize( name ) +" is already a senior playtester.\n" );
            }
         }
         break;
      case 'R' :
      case 'r' :
         if ( !name ) {
            return 0;
         }
         if ( !reason) {
            notify_fail("You need to supply a reason when deleting someone.\n");
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if ( (int)PLAYTESTER_HAND->remove_playtester( name, reason ) ) {
            printf( capitalize( name ) +" is no longer a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is not a playtester.\n" );
         }
         break;
      default :
      case 'H' :
      case 'h' :
      case '?' :
         printf( "\nPlaytesters editor commands:\n\n"
               "Q        : quit the playtester editor\n"
               "L        : list playtesters\n"
               "A <name> : add a new playtester\n"
               "S <name> : promote someone to senior playtester\n"
               "R <name> : remove an existing playtester\n"
               "H        : get this list of commands\n\n" );
         break;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: main_menu("L", 0, 0) :),
             "{l|h|?}", (: main_menu($4[0], 0, 0) :),
             "{a|s|h|r|?} <word>", (: main_menu($4[0], $4[1], 0) :),
             "r <word> <string>", (: main_menu("r", $4[0], $4[1]) :) });
}
