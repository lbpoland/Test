# Total Tokens: 98149
# Total Files Merged: 107
# Total Characters: 327470

.c
==================================================

#include <cmds/options.h>
inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  int monitor;
  monitor = TP->query_monitor();
  if(!str) {
    write("Your hit point monitor is set to " + MONITOR_OPTIONS[monitor] +
          ".\n");
    return 1;
  }
  if(member_array(str, MONITOR_OPTIONS) != -1) {
    write("Your hit point monitor is set to " + str + ".\n");
    TP->set_monitor(member_array(str, MONITOR_OPTIONS));
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{" + implode(MONITOR_OPTIONS, "|") + "}", (: cmd($4[0]) :) });
}

==================================================
FILE: player/mudlist.c
==================================================

#define INTERMUD_D "/net/intermud3/intermud"
int cmd(string str) {
  mixed *info;
  string *list;
  mapping borg;
  string mud;
  if( str && str != "") {
    mapping tmp;
    string opt, tmpstr;
    tmp = (mapping)INTERMUD_D->GetMudList();
    if( str[0] != '-' ) str = "-n " + str;
    opt = str[1..1];
    str = str[3..];
    borg = ([]);
    foreach(mud, info in tmp) {
      int x, y, z;
      switch(opt) {
      case "m":
        x = 5;
        break;
      case "d":
        x = 7;
        break;
      case "n":
        x = 0;
        break;
      }
      tmpstr = (x ? info[x] : mud);
      z = strlen(str = replace_string(lower_case(str), " ", ""));
      y = strlen(tmpstr = replace_string(lower_case(tmpstr), " ", ""));
      if( str == tmpstr ) {
        borg = ([ mud : info ]);
        break;
      }
      else if( y > z && tmpstr[0..z-1] == str && info[0] == -1 )
        borg[mud] = info;
    }
  }
  else {
    borg = ([ ]);
    foreach( mud, info in (mapping)INTERMUD_D->GetMudList() )
      if( info[0] == -1 ) borg[mud] = info;
  }
  if( !sizeof(borg) ) {
    write(mud_name()+" does not have any MUD matching "+str+" in "
          "its mudlist.\n");
    return 1;
  }
  else if( sizeof(borg) == 1 ) {
    string msg, svc;
    int val, comma = 0;
    mud = keys(borg)[0];
    msg = "\nDetailed information on %^GREEN%^" + mud + "%^RESET%^:\n";
    msg += "Server: " + borg[mud][7] + " (" + borg[mud][8] + ")\n";
    msg += "BaseLib: " + borg[mud][6] + "\n";
    msg += "Library: " + borg[mud][5] + "\n";
    msg += "Status: " + borg[mud][9] + "\n";
    msg += "Admin E-mail: " + borg[mud][10] + "\n";
    msg += "Services: ";
    foreach(svc, val in borg[mud][11]) {
      if( val == 1 ) {
        if( comma ) msg += ", " + svc;
        else {
          msg += svc;
          comma = 1;
        }
      }
    }
    msg += "\nHost: " + borg[mud][1] + "\n";
    msg += "Telnet port: " + borg[mud][2] + "\n";
    if( borg[mud][11]["http"] )
      msg += "HTTP port (World Wide Web): " + borg[mud][11]["http"]+"\n";
    if( borg[mud][11]["ftp"] )
      msg += "FTP port (File Transfer): " + borg[mud][11]["ftp"] + "\n";
    if( borg[mud][11]["rcp"] )
      msg += "RCP port (Remote Creator): " + borg[mud][11]["rcp"] + "\n";
    write(msg);
    return 1;
  }
  list = ({});
  foreach(mud, info in borg)
    list += ({ sprintf("%:-15s %:-10s %:-15s %:-15s %s %d",
                       mud, info[8], info[7], info[5], info[1], info[2]) });
  list = sort_array(list, 1);
  list = ({ mud_name() + " recognizes " + sizeof(borg)+" muds"
              " matching your query: ", "" }) + list;
  previous_object()->more_string(implode(list, "\n")+"\n", "Mudlist");
  return 1;
}
int alphabet(string a, string b) {
    if((a = lower_case(a)) == (b = lower_case(b))) return 0;
    else if(a > b) return 1;
    else return -1;
}
void help() {
    message("help", "Syntax: <mudlist>\n"
      "        <mudlist -dmn [arg]>\n\n"
      "Without any arguments, it gives a full listing of all muds "
      "with which this mud is capable of communication through "
      "tell, mail, finger, rwho, and other intermud services.  "
      "With arguments, <mudlist> requires one and only one option "
      "which must be one of the following:\n"
      "\t-d [driver]: List only muds using the named driver\n"
      "\t-m [mudlib]: List only muds using the named mudlib\n"
      "\t-n [mudname]: List only the muds with the name given\n\n"
      "Note that the argument need not be complete, for example:\n"
      "\t mudlist -n idea\n"
      "will list IdeaExchange as well as any other mud whose name "
      "begins with the string \"idea\".\n\n"
      "See also: finger, mail, rwho, tell", this_player());
}
void clean_up() {
  destruct(this_object());
}
void reset() {
  destruct(this_object());
}
void dest_me() {
  destruct(this_object());
}

==================================================
FILE: player/news.c
==================================================

#include <board.h>
inherit "/cmds/base";
object board;
string board_name = "announcements";
void do_list(int all);
int do_read(int num);
#define LOGON_LIMIT 10
#define MOST 1
#define ALL 2
#define SOME 0
mixed cmd(string str) {
  int msg;
  switch(str) {
  case "help":
  case "?":
  case "h":
    tell_object( this_player(),
                "Usage:\n"
                "To read next news item type: \"news\".\n"
                "To read a specific news item type: \"news <num>\".\n"
                "To list new news items type: \"news list\".\n"
                "To list all news items type: \"news review\".\n");
    break;
  case "l":
  case "list":
    do_list(MOST);
    break;
  case "r":
  case "review":
    do_list(ALL);
    break;
  default:
    if(str) sscanf(str, "%d", msg);
    do_read(msg);
  }
  return 1;
}
int do_read(int num) {
  mapping news_rc;
  mixed *stuff;
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if ( !news_rc ) {
    news_rc = ([ ]);
  }
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if(!num) {
    num = sizeof(stuff);
    while((num > 0) && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
    }
    if(num == sizeof(stuff)) {
      write("No news is good news.\n");
      return 1;
    }
    num++;
  }
  if(num < 0) {
    num = sizeof(stuff) + num + 1;
  }
  if(( num < 1) || (num > sizeof(stuff))) {
    write("No news item of that number.\n");
    return 1;
  }
  num--;
  if(news_rc[ board_name ] < stuff[ num ][ B_TIME ]) {
    news_rc[ board_name ] = stuff[ num ][ B_TIME ];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  this_player()->more_string( "Note #"+ ( num + 1 ) +" posted at " +
        ctime(stuff[num][B_TIME])[0..9] + " Title: \""+
        stuff[ num ][ B_SUBJECT ][ 0 .. (int)this_player()->query_cols() -
       10 ] +"\"\n\n"+ (string)BOARD_HAND->get_message( board_name, num ),
       "[Note "+ ( num + 1 ) +"]" );
  return 1;
}
string the_date(int i) {
  return ctime(i)[4..9];
}
void do_list(int all) {
  int i, newones;
  mixed *stuff;
  string ret;
  mapping news_rc;
  ret = "";
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (!sizeof(stuff)) {
    tell_object(this_player(), "No news is good news.\n");
    return;
  }
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc) {
    news_rc = ([ ]);
  }
  newones = 0;
  for (i = 0; i < sizeof(stuff); i++) {
    if (news_rc[board_name] < stuff[i][B_TIME]) {
      ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
      newones += 1;
      if (all == SOME) {
        if (newones > LOGON_LIMIT) {
          write("Plus more....\n");
          break;
        }
      }
    } else if(all == ALL) {
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
    }
  }
  if(!newones && all != ALL) {
    ret += "\nNo news is good news.\n";
  }
  if (all == SOME) {
    ret += "\nUse 'news list' for all new news items and 'news review' for all news times.\n";
  }
  this_player()->more_string( ret, "News" );
}

==================================================
FILE: player/nickname.c
==================================================

inherit "cmds/base";
int print_nicknames(mapping map_nicknames);
int add_nickname(string str, mapping map_nicknames);
int print_single_nickname(string str) {
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  str = lower_case(str);
  if(!map_nicknames[str]) {
    add_failed_mess("That nickname does not exist.\n");
    return 0;
  }
  write("Setting for nickname "+str+" is "+map_nicknames[str]+".\n");
  return 1;
}
int print_nicknames(int sorted) {
  int i;
  int cols;
  string str;
  string str_long;
  string str_middle;
  string str_small;
  string bit;
  string *tmp;
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  bit = "";
  str_long = "";
  str_middle = "";
  str_small = "";
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!sizeof(map_nicknames)) {
     write("You do not have any nicknames.\n");
     return 1;
  }
  tmp = sort_array(keys(map_nicknames), 1);
  cols = (int)this_player()->query_cols();
  for (i=0;i<sizeof(tmp);i++) {
    str = tmp[i]+": "+map_nicknames[tmp[i]]+"  ";
    if (strlen(str) > 39 || sorted) {
      str_long += sprintf(tmp[i]+": %-=*s\n", cols - strlen(tmp[i]), map_nicknames[tmp[i]]);
    } else if (strlen(str) > 19) {
      str_middle += str+"\n";
    } else {
      str_small += str+"\n";
    }
  }
  if (strlen(str_middle)) {
    str_long += sprintf("%-#*s\n", cols, str_middle);
  }
  if (strlen(str_small)) {
    str_long += sprintf("%-#*s\n", cols, str_small);
  }
  this_player()->more_string(str_long, "Nicknames");
  return 1;
}
int add_nickname(string s1, string s2) {
  mapping map_nicknames;
  s1 = lower_case(s1);
  s2 = lower_case(s2);
  if( member_array( s1, ({ "a", "an", "the" }) ) != -1 ) {
    add_failed_mess( "Using articles as nicknames confuses the parser.  "
                     "Choose another.\n" );
    return 0;
  }
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!map_nicknames[s1]) {
    map_nicknames[s1] = s2;
    write("Added nickname "+s1+" for "+s2+".\n");
    return 1;
  }
  write("Changed nickname "+s1+" from "+map_nicknames[s1]+" to "+s2+".\n");
  map_nicknames[s1] = s2;
  this_player()->set_nicknames(map_nicknames);
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: print_nicknames(0) :),
             "sorted", (: print_nicknames(1) :),
             "<string'nickname'>", (: print_single_nickname($4[0]) :),
             "<string'nickname'> <string'realname'>", (: add_nickname($4[0], $4[1]) :)
           });
}

==================================================
FILE: player/options.c
==================================================

inherit "/cmds/base";
#include <cmds/options.h>
int cmd_set(string option, string value);
int cmd_display(string option) {
   string *bits;
   string *groups;
   string bing;
   if (sscanf(option, "%s=%s", option, bing) == 2) {
      return cmd_set(option, bing);
   }
   if (OPTION_HANDLER->is_option(this_player(), option)) {
     write(sprintf("%-20s = %s (%s)\n", option,
                   OPTION_HANDLER->query_option_value(this_player(), option),
                   OPTION_HANDLER->query_option_help(this_player(),option)));
      return 1;
   } else if (OPTION_HANDLER->is_option_group(this_player(), option)) {
      bits = OPTION_HANDLER->query_sub_options(this_player(), option);
      if (option == "") {
         write("Top level:\n");
      } else {
         write(option + ":\n");
      }
      bits = sort_array(bits, (: strcmp :));
      groups = filter(bits, (: OPTION_HANDLER->is_option_group(this_player(),
                                               $2 + " " + $1) :), option);
      bits -= groups;
      foreach (bing in groups) {
         write(sprintf("   %-17s <more options>\n", bing));
      }
      foreach (bing in bits) {
         if (OPTION_HANDLER->is_option(this_player(), option + " " + bing)) {
            write(sprintf("$I$30=   %-17s = %-10s <%s>\n", bing,
                    OPTION_HANDLER->query_option_value(this_player(),
                                                     option + " " + bing),
                    implode(OPTION_HANDLER->query_option_values(this_player(),
                                        option + " " + bing), "|")));
         }
      }
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
int cmd_set_all(string option, string value) {
   string* stuff;
   string* ok;
   string* bad;
   string opt;
   if (!OPTION_HANDLER->is_option_group(this_player(), option)) {
      add_failed_mess("The option must be an option group to use the 'all' "
                      "keywork.\n");
      return 0;
   }
   stuff = OPTION_HANDLER->query_sub_options(this_player(), option);
   option += " ";
   ok = ({ });
   bad = ({ });
   foreach (opt in stuff) {
      if (OPTION_HANDLER->is_option(this_player(), option + opt)) {
         if (OPTION_HANDLER->set_option_value(this_player(), option + opt,
                                              value)) {
            ok += ({ option + opt });
         } else {
            bad += ({ option + opt });
         }
      } else {
         bad += ({ option + opt });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("Set " + query_multiple_short(ok) + " to " +
                         value + ".\n");
      return 1;
   }
   add_failed_mess("Unable to set " + query_multiple_short(bad) + " to " +
                   value + ".\n");
   return 0;
}
int cmd_set(string option, string value) {
   string *bits;
   if (!option  ||  option == "")
      return 0;
   bits = explode(option, " ");
   if(!sizeof(bits))
     return 0;
   if (bits[<1] == "all") {
      if (sizeof(bits) > 1) {
         return cmd_set_all(implode(bits[0..<2], " "), value);
      }
      add_failed_mess("Cannot use 'all' as an option by itself.\n");
      return 0;
   }
   if (OPTION_HANDLER->is_option(this_player(), option)) {
      if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
         write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
         return 1;
      } else {
         add_failed_mess("Unable to set option " + option + " to " +
                value +
                ".\n");
         return 0;
      }
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
int cmd_edit(string option) {
   string value;
   if (OPTION_HANDLER->is_option(this_player(), option)) {
      value = OPTION_HANDLER->query_option_value(this_player(), option);
      write("Editing the option " + option + ".\n");
      this_player()->do_edit(value, "finish_edit", this_object(),
                             0, option);
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
void finish_edit(string value, string option) {
   if (!value) {
      write("Aborting.\n");
      return ;
   }
   if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
      write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
   } else {
      write("Unable to set the option " + option + ".\n");
   }
}
mixed *query_patterns() {
   return ({ "<string'option'>",
               (: cmd_display($4[0]) :),
             "",
               (: cmd_display("") :),
             "edit <string'option'>",
                (: cmd_edit($4[0]) :),
             "<string'option'> = <word'value'>",
                (: cmd_set($4[0], $4[1]) :),
             "<string'option'> all = <word'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             "set <string'option'> all <string:quoted'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             });
}

==================================================
FILE: player/perm_it.c
==================================================

inherit "/cmds/base";
int cmd( object player ) {
  object *corpses, corpse;
  int i;
  corpses = filter( children( "/obj/corpse" ),
                    (: $1 && $1->query_property("player" ) :) );
  corpses = filter( corpses,
                    (: $1 && $1->query_ownership() ==
                     $(this_player()->query_name()) :) );
  if( sizeof( corpses ) ) {
    foreach( corpse in corpses ){
      if(member_array(player->query_name(), corpse->query_permitted()) != -1) {
        i++;
      } else {
        corpse->give_permission( player->query_name() );
      }
    }
  } else {
    add_failed_mess("You don't seem to have a corpse!  Why not die and try "
                    "again?%^RESET%^\n");
    return 0;
  }
  if( i == sizeof( corpses ) ){
    write(capitalize(player->query_name()) + " is already permitted to "
          "remove items from your corpse.%^RESET%^\n" );
  } else {
    write(capitalize(player->query_name()) + " is now permitted to "
          "remove items from your corpse.%^RESET%^\n" );
    tell_object(player, "%^BOLD%^%^GREEN%^You now have permission to get "
                "items from " + this_player()->query_cap_name() +
                "'s corpse.%^RESET%^\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}

==================================================
FILE: player/position.c
==================================================

#include <player.h>
#define MAXLEN 30
inherit "/cmds/base";
private string* _bad_words;
void create() {
   _bad_words = ({ "teach", "skill", "finger", "lesson", ":)", ";)",
                   "chainsaw", "0", "1", "2", "3", "4", "5", "6", "7", "8",
                   "9", ":", ";", ",", "'", "*", "%", "!",
                   "@", "~", "`", "#", "$", "^", "&", "(", ")",
                   "_", "-", "=", "+", "{", "}", "[", "]",
                   "<", ".", ">", "?", "/", "\\",
                   ":->", ":-)", ";-)", ";->", "\""});
}
int cmd( string new_pos ) {
  object player = this_player();
  string word, tmp;
  if (!new_pos) {
    write("You are " + player->query_position_short() + ".\n");
    return 1;
  }
  if ( strlen(new_pos) > MAXLEN ) {
    add_failed_mess("Sorry, your position cannot be more than " +
                        MAXLEN + " letters long.\n");
    return 0;
  }
  if ( player->query_sp() < SET_POSITION_COST ) {
    add_failed_mess( NO_POWER );
    return 0;
  }
  new_pos = replace_string(new_pos, "^", "");
  new_pos = replace_string(new_pos, "%", "");
  tmp = lower_case(new_pos);
  foreach(word in _bad_words) {
    if(strsrch(tmp, word) != -1) {
      add_failed_mess("You cannot bring yourself to set that position.\n");
      return 0;
    }
  }
  player->set_position( new_pos );
  player->adjust_sp( - SET_POSITION_COST );
  tell_object( player, "People will now see:\n" +
               player->query_cap_name() + " is " + new_pos + ".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
          "<string'new position'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/pstatus.c
==================================================

broken
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <tune.h>
#include <skills.h>
inherit "/cmds/base";
string find_hp_string( int current, int max );
string find_gp_string( int current, int max );
string find_xp_string( int current );
string find_wimpy_string( int wimpy );
string find_surrender_string( int surr );
string find_align_string( object tp );
string find_death_string( int remaining );
int calc_percent( float x, float y );
int calc_xp_cost( string skill );
int cmd() {
   object me;
   me = this_player();
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if (this_player()->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   switch( me->query_verbose( "score" ) ) {
   case 1:
      printf( "%s.\n%s and %s.\n%s.\n%s.\n%s and %s.\n%s.\n%s.\n",
              "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ),
              capitalize( find_align_string( me ) ),
              capitalize( find_wimpy_string( me->query_wimpy() ) ),
              find_surrender_string( me->query_surrender() ),
              "You are "+ me->burden_string(),
              find_death_string( me->query_max_deaths() - me->query_deaths() ) );
      return 1;
   default:
      printf( "%s and %s.\n%s.\n",
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ) );
      return 1;
   }
}
int cmd_stats() {
   object me;
   int stat;
   string ret;
   me = this_player();
   ret = "";
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if ( stat = ( me->query_tmp_str() + me->query_bonus_str() ) ) {
      if ( stat > 0 ) {
         ret += "You feel stronger then usual.\n";
      } else {
         ret += "You feel weaker then usual.\n";
      }
   }
   if ( stat = ( me->query_tmp_int() + me->query_bonus_int() ) ) {
      if ( stat > 0 ) {
         ret += "You feel smarter then normal.\n";
      } else {
         ret += "You feel less smart then normal.\n";
      }
   }
   if ( stat = ( me->query_tmp_con() + me->query_bonus_con() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more healthy then usual.\n";
      } else {
         ret += "You feel a bit sickly.\n";
      }
   }
   if ( stat = ( me->query_tmp_dex() + me->query_bonus_dex() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more nimble then usual.\n";
      } else {
         ret += "You feel more clumsy than you normally do.\n";
      }
   }
   if ( stat = ( me->query_tmp_wis() + me->query_bonus_wis() ) ) {
      if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
      } else {
         ret += "You feel a bit vague.\n";
      }
   }
   if ( !strlen( ret ) ) {
      ret += "You feel fine.\n";
   }
   printf( "%s", ret );
   return 1;
}
string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are in perfect health";
   case 70..89:
      return "you are slightly wounded";
   case 50..69:
      return "you are moderately wounded";
   case 30..49:
      return "you are seriously wounded";
   case 15..29:
      return "you are critically wounded";
   case 6..14:
      return "you are fatally wounded";
   case 0..5:
      return "you are near death";
   default:
      return "you are broken";
   }
}
string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are full of energy";
   case 70..89:
      return "you are enthusiastic";
   case 50..69:
      return "you are not quite so full of beans";
   case 30..49:
      return "you are weary";
   case 15..29:
      return "you are tired";
   case 6..14:
      return "you are exhausted";
   case 0..5:
      return "you are nearly unconscious";
   default:
      return "you are broken";
   }
}
string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   xptotal /= sizeof( skills );
   tell_creator( find_player( "terano" ), "%s: Current XP is: %d, Avg XP is %d, Ratio is: %d.\n",
                 this_player()->query_name(), current, xptotal, calc_percent( current, xptotal ) );
   switch( calc_percent( current, xptotal ) ) {
   case 0..20:
      return "you don't think you can learn much at the moment";
   case 21..59:
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100:
      return "if you squeezed it, you could gain some insight";
   case 101..300:
      return "you might be able to learn something new, if you found the right teacher";
   case 301..400:
      return "a small amount could be learned with training";
   case 401..800:
      return "a bit of training might be in order";
   case 801..1200:
      return "you could very well learn something new from training";
   case 1201..1500:
      return "you could benefit from training";
   case 1501..2000:
      return "you feel like training might help";
   case 2001..2500:
      return "you should consider training your skills";
   case 2501..4000:
      return "your skills could be greatly improved with training";
   default:
      return "certainly a hearty training session is in order!";
   }
}
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
}
string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
}
string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
}
string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }
   switch ( remaining ) {
   case 0..0:
      return "Death has a special interest in your next appointment";
   case 1..3:
      return "Death is starting to lose patience with you";
   case 4..7:
      return "You and Death are on good terms";
   default:
      return "You have an \"arrangement\" with Death";
   }
}
int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;
   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   if (!total) {
      total = cost;
   }
   return total;
}
int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
}
mixed *query_patterns() {
   return ({ "", (: cmd() :), "stats", (: cmd_stats() :) });
}

==================================================
FILE: player/qalias.c
==================================================

int cmd()
{
   string *aliases, alias_mess, message;
   int cols;
   aliases = keys( this_player()->query_aliases() );
   if( !sizeof( aliases ) )
   {
      tell_object( this_player(), "You have no aliases.\n" );
      return 1;
   }
   message = "\nYou have the following aliases:\n";
   aliases = sort_array( aliases, (: strcmp :) );
   alias_mess = implode( aliases, ", " );
   cols = this_player()->query_cols() - 3;
   message += sprintf( "   %-=*s\n", cols, alias_mess );
   message += "A total of " + sizeof( aliases ) + " aliases.\n";
   tell_object( this_player(), message );
   return 1;
}
mixed *query_patterns()
{
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/qwho.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>
int playercompare(object p1, object p2);
int cmd(string guild_name) {
   int i;
   int countcre;
   int countplay;
   int counttest;
   int countloginq;
   int countlogins;
   int compressed;
   string obtyp;
   string tmp;
   object *arr;
   string nam;
   string cres;
   string plays;
   string testers;
   string *login_q;
   string logins;
   int showmasters;
   mapping user_data;
   object *liaisons;
   string friends;
   int countFriends;
   int totalUsers;
   int totalPlayers;
   int totalCompressed;
   if (this_player()->query_creator()) {
      showmasters = 1;
   } else {
      showmasters = 0;
   }
   countcre = 0;
   countplay = 0;
   counttest = 0;
   compressed = 0;
   cres = "";
   plays = "";
   testers = "";
   logins = "";
   friends = "";
   user_data = unique_mapping( users(),
       (: "/d/liaison/master"->query_member( $1->query_name() ) :) );
   if ( user_data[1] ) {
       liaisons = sort_array( user_data[1], (: playercompare :) );
   }
   else {
       liaisons = ({ });
    }
   if ( user_data[0] ) {
       arr = sort_array( user_data[0], (: playercompare :));
   }
   else {
       arr = ({ });
   }
   arr = liaisons + arr;
   arr = filter(arr, (: (!$1->query_invis() || reference_allowed(this_player(),
     $1)) && !$1->query_login_ob() :) );
   if (guild_name) {
      arr = "/cmds/player/who"->filter_users(arr, guild_name, 1);
      if (!sizeof(arr)) {
         add_failed_mess("Unable to find any members of " +
                         guild_name + ".\n");
         return 0;
      }
   }
   for(i=0;i<sizeof(arr);i++) {
      nam = arr[i]->query_cap_name();
      if (!nam) {
         if (showmasters) {
            nam = "/secure/master";
         } else {
            continue;
         }
      }
      switch (arr[i]->query_invis()) {
      case 0:
         break;
      case 1:
         nam = "[" + nam + "]";
         break;
      case 2:
         nam = "[{" + nam + "}]";
         break;
      case 3:
         nam = "[<" + nam + ">]";
         break;
      default:
         nam = "?" + nam + "?";
         break;
      }
      obtyp = arr[i]->query_object_type();
      switch(obtyp) {
      case "X":
         break;
      case " ":
         break;
      case "C":
         nam += "(%^CYAN%^C%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "S":
         nam += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "T":
         nam += "(%^BOLD%^%^RED%^T%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "D":
         nam += "(%^RED%^D%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      default:
         break;
      }
      if (this_player()->is_friend(arr[i]->query_name())) {
         nam += "(%^GREEN%^F%^RESET%^)";
      }
      if (compressedp(arr[i])) {
          compressed++;
      }
      if (arr[i]->query_creator()) {
         countcre++;
         cres = cres + " " + nam;
      } else if (obtyp == "p") {
         counttest++;
         testers = testers + " " + nam;
      } else if(arr[i]->query_login_ob()) {
         countlogins++;
         logins = logins + " " + nam;
      } else if (this_player()->is_friend(arr[i]->query_name())) {
         countFriends++;
         friends = friends + " " + nam;
      } else {
         countplay++;
         plays = plays + " " + nam;
      }
   }
   if (guild_name) {
      arr = LOGIN_HANDLER->query_login_queue();
      arr = "/cmds/player/who"->filter_users(arr, guild_name);
      login_q = map(arr, (: $1->query_cap_name() :));
   } else {
      login_q = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
   }
   login_q = filter(login_q, (: $1 :));
   login_q = sort_array(login_q, 1);
   countloginq = sizeof(login_q);
   tmp = sprintf("%%^BOLD%%^%d Creator%s:%%^RESET%%^%s\n",
                 countcre, countcre != 1 ? "s" : "", cres);
   write(tmp);
   if (guild_name != "creator" && guild_name != "creators") {
      switch (counttest) {
        case 0:
            break;
        case 1:
           write("%^BOLD%^" + counttest + " Playtester:%^RESET%^" + testers + "\n");
        break;
        default:
           write("%^BOLD%^" + counttest + " Playtesters:%^RESET%^" + testers + "\n");
        break;
     }
      if (countFriends) {
         write("%^GREEN%^" + countFriends + " Friend" +
             (countFriends > 1 ? "s" : "") + ":%^RESET%^" + friends + "\n");
      }
      write("%^BOLD%^" + countplay + " Players:%^RESET%^" + plays + "\n");
      if (countlogins < countloginq) {
         countlogins = countloginq;
      }
      if (countlogins-countloginq) {
         logins = replace(logins, ({ "[", "", "]", ""}));
         if(countloginq) {
            foreach(tmp in login_q) {
               logins = replace(logins, tmp+" ", "");
            }
         }
         write("%^BOLD%^" + (countlogins - countloginq) +
               " Logging in:%^RESET%^" + logins + "\n");
      }
      if(countloginq) {
         write("%^BOLD%^" + countloginq + " Queued:%^RESET%^ " +
               implode(login_q, " ") + "\n");
      }
   } else {
      countlogins = 0;
      counttest = 0;
      countplay = 0;
   }
   totalUsers = countcre + counttest + countplay + countlogins + countFriends;
   totalPlayers = counttest + countplay + countFriends;
   totalCompressed = compressed - countFriends;
   write("%^BOLD%^" + (totalPlayers) + " Players, " +
         totalUsers + " Total%^RESET%^\n" );
   return 1;
}
int playercompare(object p1, object p2) {
   return strcmp(p1->query_name(), p2->query_name());
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string'guild name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/recover.c
==================================================

#include <obj_parser.h>
inherit "/cmds/base";
#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
#include <player.h>
#define MAX_RECOVER 20
int cmd_recover(string name) {
   object* obs;
   object* fail;
   object* ok_me;
   object* ok_here;
   object cont;
   object ob;
   class obj_match omatch;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   if (this_player()->query_property("dead")) {
      add_failed_mess("You're a disembodied spirit, how do you expect to "
                      "recover anything at all?\n");
      return 0;
   }
   cont = BURY_EFFECT->query_buried_container(environment(this_player()));
   if (!cont) {
      add_failed_mess("There is nothing buried here.\n");
      return 0;
   }
   omatch = (class obj_match)match_objects_in_environments(name, cont);
   if (omatch->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(omatch));
      return 0;
   }
   obs = omatch->objects;
   if ( sizeof( obs ) > MAX_RECOVER ) {
      add_failed_mess( "You can only recover " +
        query_num( MAX_RECOVER ) + " items at a time.\n" );
      return 0;
   }
   fail = ({ });
   ok_me = ({ });
   ok_here = ({ });
   if (sizeof(obs)) {
      foreach (ob in obs) {
#ifndef __DISTRIBUTION_LIB__
        if(interactive(this_player()) &&
           PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("recover",
                                                           this_player(),
                                                           ob)) {
          fail += ({ ob });
        } else
#endif
         if (ob->move(this_player()) == MOVE_OK) {
            ok_me += ({ ob });
         } else if (ob->move(environment(this_player())) == MOVE_OK) {
            ok_here += ({ ob });
         } else {
            fail += ({ ob });
         }
      }
      if (!sizeof(ok_me) && !sizeof(ok_here)) {
         add_failed_mess("Unable to recover $I.\n", fail);
         return 0;
      }
      if (sizeof(ok_me)) {
         add_succeeded_mess("$N $V $I.\n", ok_me);
      }
      if (sizeof(ok_here)) {
         add_succeeded_mess("$N $V $I and leave$s " +
                            (sizeof(ok_here) > 1?"them":"it") +
                            " here.\n", ok_here);
      }
      return 1;
   } else {
      ok_me = all_inventory(cont);
      if (sizeof(ok_me)) {
         add_failed_mess("Unable to recover " + name + ", available objects "
                       "are " + query_multiple_short(ok_me) +
                      ".\n");
      } else {
         add_failed_mess("Unable to recover " + name + ".\n");
      }
      return 0;
   }
}
mixed* query_patterns() {
   return ({ "<string'buried object'>", (: cmd_recover($4[0]) :) });
}

==================================================
FILE: player/refer.c
==================================================

#include <login.h>
#include <clubs.h>
inherit "/cmds/base";
int cmd(string str) {
   string ret;
   str = lower_case(str);
   str = (string)this_player()->expand_nickname(str);
   ret = (string)"/secure/finger"->refer_info(str);
   if (ret) {
      this_player()->more_string( this_player()->fit_message(ret),
                                  "refer: "+str );
      return 1;
   }
   add_failed_mess("No one by the name of " + str + " has "
                   "ever visited " + mud_name() + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({"<string'name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/register.c
==================================================

#include <player_handler.h>
#include <playerinfo.h>
inherit "/cmds/base";
int cmd(string alt) {
  string p1;
  string p2;
  alt = lower_case(alt);
  if (!PLAYER_HANDLER->test_user(alt))
    return notify_fail(alt + " is not a player.\n");
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if(!p1 || p1 == "") {
     p1 = this_player()->query_name();
   }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(p1 == p2) {
     add_failed_mess("You and " + alt + " are already registered.\n");
     return 0;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2)) &&
      sizeof(PLAYERINFO_HANDLER->query_alts(p1))) {
     add_failed_mess("Sorry, there is a clash of alts here, you'll need to "
                     "ask a creator for assistance.\n");
     return 0;
   }
  write("Enter your password (this character): ");
  input_to("get_pw", 1, this_player(), alt);
  return 1;
}
void get_pw(string pass, object player, string alt) {
  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  write("\nEnter the password for " + alt + ": ");
  input_to("get_alt_pw", 1, player, alt);
}
void get_alt_pw(string pass, object player, string alt) {
  string result;
  string p1, p2;
  write("\n");
  if(this_player() != player) {
    write("Something has gone wrong, player objects don't match.\n");
    return;
  }
  if (!PLAYER_HANDLER->test_password(alt, pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  p1 = PLAYERINFO_HANDLER->query_alt_of(player->query_name());
  if(!p1 || p1 == "") {
    p1 = player->query_name();
  }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2))) {
     write("Registering " + p1 + " as an alt of " + p2 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p2, p1);
   } else {
     write("Registering " + p2 + " as an alt of " + p1 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p1, p2);
   }
   write(result);
}
int cmd_list() {
   string* alts;
   string p1;
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!p1) {
      p1 = this_player()->query_name();
   }
   alts = (string*)PLAYERINFO_HANDLER->query_alts(p1) |
          (string*)PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!sizeof(alts)) {
      write("No alts registered.\n");
      return 1;
   }
   write("Your registered alts are " + query_multiple_short(alts) + ".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "list", (: cmd_list :),
             "<word'alt-name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/relationship.c
==================================================

#include <clubs.h>
inherit "/cmds/base";
string show_relationship(object from, object to, string rel, object telling);
int do_relationship(string relationship, object *players, int force) {
   object player;
   string family;
   string my_family;
   string their_family;
   string rel;
   class family_response_data frog;
   int ok;
   string *relations;
   my_family = this_player()->query_family_name();
   if (!my_family) {
      add_failed_mess("You must be in a family to form a relationship with "
                      "someone.\n");
      return 0;
   }
   my_family = CLUB_HANDLER->query_club_name(my_family);
   rel = CLUB_HANDLER->query_ungendered_relationship(relationship);
   if (!rel) {
      add_failed_mess("The relationship '" + relationship +
                      "' is not valid.  The valid relationships are " +
                      query_multiple_short(
                              CLUB_HANDLER->query_all_relationships()) +
                      ".\n");
      return 0;
   }
   relationship = rel;
   foreach (player in players) {
      player->check_family_name();
      their_family = player->query_family_name();
      relations = CLUB_HANDLER->query_relationships_to(my_family,
                                                      this_player()->query_name(),
                                                      player->query_name());
      if (!their_family && sizeof(relations)) {
         foreach (rel in relations) {
            CLUB_HANDLER->remove_relationship(my_family,
                                              this_player()->query_name(),
                                              their_family,
                                              player->query_name(),
                                              rel);
         }
      }
      rel = CLUB_HANDLER->query_relationship_gender(relationship,
                                                    player->query_female());
      if (sizeof(relations)) {
         if (member_array(relationship, relations) != -1 &&
             force) {
            family = my_family;
	    tell_object(player, this_player()->the_short() +
                             " offers to use "
                             "the relationship of " + rel + " with "
                             "you in the family " + my_family + " to allow "
                             "you to join the family.  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
            frog = new(class family_response_data);
            frog->family = family;
            frog->relationship = relationship;
            player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                        this_player(),
                                        frog);
            ok++;
            add_succeeded_mess(({
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\nThis will setup the "
                               "relationships of: " +
                               show_relationship(this_player(), player,
                                                 relationship, this_player()) + "\n",
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\n",
                                }),
                               ({ player }));
         } else {
            add_failed_mess("You are already related to $I, you can only force "
                            "them to join your family.\n", ({ player }) );
         }
      } else if (player->query_family_name()) {
         if (!force) {
	    if (!CLUB_HANDLER->is_valid_interfamily_relationship(relationship)) {
	       add_failed_mess("$I is in a family already and '" +
                               rel +
			       "' is not a valid interfamily relationship.\n");
	       continue;
	    }
	    family = player->query_family_name();
	    tell_object(player, this_player()->the_short() +
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you.  This will not cause you to change the "
                             "family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() +
                             " as " + rel + "\n");
	 } else {
            if (!CLUB_HANDLER->is_valid_join_family_relationship(relationship)) {
               add_failed_mess("$I is in a family already and the "
                               "relationship '" + rel +
                               "' is not valid to cause them to join "
                               "your family.\n");
               continue;
            }
            family = my_family;
	    tell_object(player, this_player()->the_short() +
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
	 }
         frog = new(class family_response_data);
         frog->family = family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                     this_player(),
                                     frog);
         ok++;
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      } else {
         tell_object(player, this_player()->the_short() + " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
         frog = new(class family_response_data);
         frog->family = my_family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                     this_player(),
                                     frog);
         ok++;
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      }
   }
   return ok;
}
string show_relationship(object from, object to, string rel, object telling) {
   string opp;
   string from_arg;
   string to_arg;
   opp = CLUB_HANDLER->query_opposite_relationship(rel);
   if (from == telling) {
      from_arg = "are";
   } else {
      from_arg = "is";
   }
   if (to == telling) {
      to_arg = "are";
   } else {
      to_arg = "is";
   }
   return from->the_short() + " " + from_arg + " the " +
          CLUB_HANDLER->query_relationship_gender(rel, from->query_female()) +
          " of " + to->the_short() + " and " +
          to->the_short() + " " + to_arg + " the " +
          CLUB_HANDLER->query_relationship_gender(opp, to->query_female()) +
          " of " + from->the_short() + ".";
}
int list_relationships() {
   string *relationships;
   relationships = CLUB_HANDLER->query_all_relationships();
   relationships = map(sort_array(relationships, 1), (: capitalize($1) :));
   printf("The currently allowed relationships are:\n   %-=*s\n",
          this_player()->query_cols() - 4,
          query_multiple_short(relationships) + ".");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'relationship'> with <indirect:player:here>",
                (: do_relationship($4[0], $1, 0) :),
             "<string'relationship'> with <indirect:player:here> and join family",
                (: do_relationship($4[0], $1, 1) :),
             "list",
               (: list_relationships() :) });
}

==================================================
FILE: player/rem_ote.c
==================================================

#include <library.h>
#include <player.h>
#include <network.h>
#define TELL_REPLY_LOCK_ID "lock fluff"
inherit "/cmds/base";
mixed cmd( object *obs, string words ) {
   object other;
   object *ok;
   object *ignoring;
   object *roleplaying;
   object *net_dead;
   object *fail;
   object *earmuffed;
   object *multiple_earmuffed;
   object *update_list;
   string* prop;
   string me_name;
   string tmp;
   string pad = " ";
   string* ok_string;
   int colour;
   if ( this_player()->query_role_playing() ) {
      add_failed_mess( "You cannot use remotes when you are role playing.\n" );
      return -1;
   }
   if ( this_player()->check_earmuffs( "remote" ) ) {
      if (this_player()->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         if (sizeof(filter(obs, (: !this_player()->is_friend($1->query_name()) :)))) {
            add_failed_mess("One of the people you are trying to remote is not a "
                            "friend (and you have tells earmuffed).\n");
            return -1;
         }
      } else {
         return notify_fail( "You have remote ear muffed.\n" );
      }
   }
   if ( userp( this_player() ) && !this_player()->query_creator() ) {
      if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
            "remote" ) )
         return notify_fail( NOT_ALLOWED );
      if ( environment( this_player() )->query_property( "no remote" ) )
         return 0;
      if ( (int)this_player()->adjust_sp( -REMOTE_COST ) < 0 )
         return notify_fail( NO_POWER );
   }
   ok = ({ });
   ignoring = ({ });
   roleplaying = ({ });
   net_dead = ({ });
   earmuffed = ({ });
   multiple_earmuffed = ({ });
   update_list = ({ });
   if (sizeof(obs) == 0)  {
      prop = this_player()->query_tell_reply_list();
      if (prop)
         obs = map(prop, (: find_player($1) :));
      else  {
         add_failed_mess("No one has told you anything in the last 15 "
                         "minutes.\n");
         return 0;
      }
   }
   if (sizeof(obs) == 1 && obs[0] == this_player()) {
      add_failed_mess("Interesting way of expression emotion, try "
                      "talking to someone else.\n");
      return 0;
   }
   fail = this_player()->query_ignoring(obs);
   if ( sizeof( fail ) )  {
      write( "You are currently ignoring " +
             query_multiple_short(fail) + ", so you ought to leave " +
             (sizeof(fail) > 1 ? "them" : fail[0]->query_objective()) +
             " alone.\n" );
      obs -= fail;
   }
   ok_string = ({ this_player()->query_name() });
   foreach (other in obs) {
      if ( other && other->query_property( "ignoring" ) ) {
         if ( member_array( (string)this_player()->query_name(),
                             other->query_property( "ignoring" ) ) != -1 &&
               !this_player()->query_creator()) {
           ignoring += ({ other });
           other = 0;
         }
      }
      if ( other && other->query_role_playing() &&
          !this_player()->query_creator() ) {
         roleplaying += ({ other });
         other = 0;
      }
      if (other) {
         this_player()->adjust_time_left( -10 );
         if( userp(other) &&
             !interactive( other ) ) {
            net_dead += ({ other });
         } else if( other->check_earmuffs( "remote" ) ) {
            earmuffed += ({ other });
         } else if( other->check_earmuffs( "multiple-remote" ) &&
                    sizeof(obs) > 1) {
            multiple_earmuffed += ({ other });
         } else if (other != this_player()) {
            ok += ({ other });
            ok_string |= ({ other->query_name() });
            prop = other->query_tell_reply_list();
            if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
               if (member_array(this_player()->query_name(), prop) != -1) {
                  other->set_tell_reply_list(prop);
               }
            } else {
               update_list += ({ other });
            }
         }
      }
   }
   update_list->set_tell_reply_list(ok_string);
   if( sizeof( ignoring ) ) {
      write( query_multiple_short(ignoring) +
            ( sizeof( ignoring ) > 1 ? " are":" is" ) +
            " ignoring you and will not have seen your message.\n" );
   }
   if ( sizeof( roleplaying ) ) {
      write( query_multiple_short( roleplaying ) +
            ( sizeof( roleplaying ) > 1 ? " are":" is" ) +
            " currently role playing and will not have seen your message.\n" );
   }
   if( sizeof( earmuffed ) ) {
      write( query_multiple_short( earmuffed ) +
            ( sizeof( earmuffed ) > 1 ? " have":" has" ) +
            " remotes earmuffed and will not have seen your message.\n" );
   }
   if (sizeof( multiple_earmuffed)) {
      write( query_multiple_short( multiple_earmuffed ) +
            ( sizeof( multiple_earmuffed ) > 1 ? " have":" has" ) +
            " multiple-remotes earmuffed and will not have seen your "
            "message.\n" );
   }
   colour = strsrch(words, "%^") != -1;
   words = replace(words, ({"        ", " ",
                              "       ", " ",
                              "      ", " ",
                              "     ", " ",
                              "    ", " ",
                              "   ", " ",
                              "  ", " "}));
   if (colour) {
      words += "%^RESET%^";
   }
   me_name = this_player()->query_short();
   if (this_player()->query_family_name()) {
      me_name += " " + this_player()->query_family_name();
   }
   if (words[0..0] == "'") pad = "";
   if (sizeof(net_dead) || sizeof(ok)) {
     if (sizeof(ok + net_dead) > 1) {
       foreach(other in ok)  {
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                         tmp +
                         "$C$Remotes to " +
                         query_multiple_short(net_dead + ok) + ": " +
                         me_name + pad + words +
                         (colour?"\n" + tmp + "--End of remote--": "") +
                         "%^RESET%^\n");
         other->add_tell_history(me_name + " remotes ", words, 1);
       }
     } else {
       foreach(other in ok)  {
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                       tmp + "$C$" + me_name + pad +
                       words +
                       (colour?"\n" + tmp + "--End of remote--": "") +
                       "%^RESET%^\n");
         other->add_tell_history(me_name + " ", words, 1);
       }
     }
     this_player()->add_tell_history("You remote to " +
                                      query_multiple_short(net_dead + ok, "a", 1) +
                                     ": ",
                                     me_name + pad + words, 1);
     write( "You remote to " + query_multiple_short(net_dead + ok) + ": $C$" +
            me_name + pad + words +"%^RESET%^\n" );
   }
   if( sizeof( net_dead ) ) {
      write( query_multiple_short( net_dead ) +
            ( sizeof( net_dead ) > 1 ? " are":" is" ) +
            " netdead and may not have seen your message.\n" );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player> <string>", (: cmd($1, $4[1]) :),
              "reply <string>",
              (: cmd(({ }), $4[0]) :) });
}

==================================================
FILE: player/removeg_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
int do_leave(string group, object member);
mixed cmd(string str) {
  string group;
  object player, *members, member;
  notify_fail("Syntax: removegroup <member>\n");
  player = find_player(str);
  if(!(group = TEAM_HANDLER->query_group(this_player())))
    return notify_fail("You are not a member of a group.\n");
  if(TEAM_HANDLER->query_owner(group) != player)
    return notify_fail("Sorry, you are not the leader of " + group + ".\n");
  if(member_array(player, TEAM_HANDLER->query_members(group)) == -1)
    return notify_fail("Sorry, " + str + " is not a member of " + group +
                       ".\n");
  members = TEAM_HANDLER->query_members( group );
  if ( !members) {
    TEAM_HANDLER->leave_group(group, this_player());
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no members.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  } else if(!(TEAM_HANDLER->query_owner(group))) {
    TEAM_HANDLER->leave_group( group, member );
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no leader.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  }
  foreach( member in members ) {
    if ( !member )
      continue;
    tell_object(member, player->short()+" is removed from the "
                "group.\n");
  }
  do_leave(group, player);
  return 1;
}
int do_leave(string group, object member) {
   object person;
   if(!TEAM_HANDLER->leave_group(group, member))
      return notify_fail("Ack, something went wrong.\n");
   if ( !sizeof( (object *)TEAM_HANDLER->query_members( group ) ) )
      return 0;
   foreach(person in TEAM_HANDLER->query_members(group)) {
      if(person) {
         member->remove_protector(person);
         person->remove_protector(member);
         member->remove_follower(person);
         person->remove_follower(member);
      }
   }
   return 1;
}

==================================================
FILE: player/resize.c
==================================================

#include <telnet.h>
inherit "/cmds/base";
mixed cmd(string str) {
  printf("%c%c%c", IAC, DO, TELOPT_NAWS);
  write("Okay, resizing your terminal...\n");
  return 1;
}

==================================================
FILE: player/rituals.c
==================================================

#include <spells.h>
inherit "/cmds/base";
int cmd( string words ) {
   string spell, *religious;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   religious = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( sscanf( spells[ spell ][ 0 ], "%*spriest%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*srituals%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*swizard%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*switch%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*sspell%*s" ) == 2 )
         continue;
   }
   if ( !sizeof( religious ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   if ( sizeof( religious ) ) {
      write( "You know the following religious ritual"+
            ( sizeof( religious ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( religious, 1 ), "\n" ) );
   }
   return 1;
}

==================================================
FILE: player/rot13.c
==================================================

inherit "/cmds/base";
string rot13(string str);
int cmd(string str) {
   printf("You rot: \"%s\".\n", rot13(str));
   return 1;
}
string rot13(string str) {
   int i;
   for(i = 0; i < sizeof(str); i++) {
      if(str[i] >= 'A' && str[i] <= 'Z') {
         str[i] = ((13 + str[i] - 'A') % 26) + 'A';
      } else if(str[i] >= 'a' && str[i] <= 'z') {
         str[i] = ((13 + str[i] - 'a') % 26) + 'a';
      } else if(str[i] >= '0' && str[i] <= '9') {
         str[i] = ((5 + str[i] - '0') % 10) + '0';
      }
   }
   return str;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/rpskills.c
==================================================

#include <skills.h>
inherit "/cmds/base";
string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }
    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) ||
              (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero))))
        str += sprintf( "%*'| 's%*'.'-s " + (no_bonus?"\n":"%4s\n"),
              ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ],
              bonus_to_string( (int)this_player()->query_skill_bonus( tp ) ) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         if ((only_leaf || o_l) && (tmp != ""))
           str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
int cmd( string word ) {
   int i;
   string result, *bits;
   mixed *args;
   result = "";
   if ( !"/obj/handlers/playtesters"->query_tester( this_player() ) )
       return 0;
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Proficiency" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Proficiency");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/score.c
==================================================

inherit "/cmds/base";
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <player_handler.h>
#include <clubs.h>
#include <player.h>
#include <nomic_system.h>
#include <tune.h>
#include <skills.h>
#include <combat.h>
#define essify(x,y) (x > 1  ||  x == 0 ? " " y "s" : " " y)
#define LIMIT 150
int score_quests(object ob, int sorted) {
   string *quests;
   mixed *quest_info;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   if(this_player()->query_role_playing()) {
     write("Sorry, you're roleplaying.\n");
     return 1;
   }
   quests = LIBRARY->query_quests( ob->query_name() );
   if ( !sizeof( quests ) ) {
      printf( "You have not completed any quests.\n" );
      return 1;
   }
   quest_info = map(quests, (: ({ QUEST_HANDLER->query_quest_title($1),
                                  QUEST_HANDLER->query_quest_story($1) }) :));
   if (sorted) {
      quest_info = sort_array(quest_info, (: strcmp($1[0], $2[0]) :));
   }
   write( "$P$Quests$P$You have completed the following quests:\n"+
         implode( map_array( map_array( quest_info, (: "     \""+
         $1[0] +"\", in which you "+
         replace( $1[1],
         "was", "were" ) :) ), (: sprintf( $1[ 0 .. 24 ] +"%*-=s",
         $(ob)->query_cols() - 30, $1[ 25 .. ] ) :) ), ",\n" ) +".\n" );
   return 1;
}
int query_verbose(object ob, string verbose)  {
   if (!verbose) {
      return ob->query_verbose("score");
   }
   if (verbose == "verbose") {
      return 1;
   }
   return 0;
}
int score_stats(object ob, string verbose)  {
   string word;
   int stat;
   string ret;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
     write( "You are just a disembodied spirit.  What use does a wispy thing "
            "like you have for a collection of meaningless numbers?\n" );
     return 1;
   }
   if(this_player()->query_role_playing()) {
     ret = "";
     if(stat = (this_player()->query_tmp_str() +
                this_player()->query_bonus_str())) {
       if ( stat > 0 ) {
         ret += "You feel stronger than usual.\n";
       } else {
         ret += "You feel weaker than usual.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_int() +
                   this_player()->query_bonus_int() ) ) {
       if ( stat > 0 ) {
         ret += "You feel smarter than normal.\n";
       } else {
         ret += "You feel less smart than normal.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_con() +
                   this_player()->query_bonus_con() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more healthy than usual.\n";
       } else {
         ret += "You feel a bit sickly.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_dex() +
                   this_player()->query_bonus_dex() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more nimble than usual.\n";
       } else {
         ret += "You feel more clumsy than you normally do.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_wis() +
                   this_player()->query_bonus_wis() ) ) {
       if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
       } else {
         ret += "You feel a bit vague.\n";
       }
     }
     if ( !strlen( ret ) ) {
       ret += "You feel fine.\n";
     }
     printf( "%s", ret );
   } else {
     word = ( ob->query_weight() / 20 ) +"."+ ( ob->query_weight() % 10 );
     if (query_verbose(ob, verbose))  {
       printf( "%-#*s\n", ob->query_cols(),
               "Constitution ... "+ ob->query_con() +"\n"+
               "Dexterity ...... "+ ob->query_dex() +"\n"+
               "Intelligence ... "+ ob->query_int() +"\n"+
               "Strength ....... "+ ob->query_str() +"\n"+
               "Wisdom ......... "+ ob->query_wis() +"\n"+
               "Height ......... "+ ob->query_height() +" cm\n"+
               "Weight ......... "+ word +"kg\n" );
     } else  {
       printf( "%-#*s\n", ob->query_cols(),
               "Con: "+ ob->query_con() +"\nDex: "+ ob->query_dex() +"\n"+
               "Int: "+ ob->query_int() +"\nStr: "+ ob->query_str() +"\n"+
               "Wis: "+ ob->query_wis() +"\nHgt: "+ ob->query_height() +" cm\n"+
               "Wgt: "+ word +"kg\n" );
     }
   }
   return 1;
}
int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
}
string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are in perfect health";
   case 70..89:
      return "you are slightly wounded";
   case 50..69:
      return "you are moderately wounded";
   case 30..49:
      return "you are seriously wounded";
   case 15..29:
      return "you are critically wounded";
   case 6..14:
      return "you are fatally wounded";
   case 0..5:
      return "you are near death";
   default:
      return "you are broken";
   }
}
string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are full of energy";
   case 70..89:
      return "you are enthusiastic";
   case 50..69:
      return "you are not quite so full of beans";
   case 30..49:
      return "you are weary";
   case 15..29:
      return "you are tired";
   case 6..14:
      return "you are exhausted";
   case 0..5:
      return "you are nearly unconscious";
   default:
      return "you are broken";
   }
}
int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;
   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   if (!total) {
      total = cost;
   }
   return total;
}
string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   xptotal /= sizeof( skills );
   switch( calc_percent( current, xptotal ) ) {
   case 0..20:
      return "you don't think you can learn much at the moment";
   case 21..59:
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100:
      return "if you squeezed it, you could gain some insight";
   case 101..300:
      return "you might be able to learn something new, if you found the right teacher";
   case 301..400:
      return "a small amount could be learned with training";
   case 401..800:
      return "a bit of training might be in order";
   case 801..1200:
      return "you could very well learn something new from training";
   case 1201..1500:
      return "you could benefit from training";
   case 1501..2000:
      return "you feel like training might help";
   case 2001..2500:
      return "you should consider training your skills";
   case 2501..4000:
      return "your skills could be greatly improved with training";
   default:
      return "certainly a hearty training session is in order";
   }
}
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
}
string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
}
string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
}
string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }
   switch ( remaining ) {
   case 0..0:
      return "Death has a special interest in your next appointment";
   case 1..3:
      return "Death is starting to lose patience with you";
   case 4..7:
      return "You and Death are on good terms";
   default:
      return "You have an \"arrangement\" with Death";
   }
}
int score_rp(object me, string verbose) {
  if(query_verbose(me, verbose)) {
    printf( "%s.\n%s and %s.\n%s.\n%s.\n%s.\n%s.\n%s.\n",
            "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ),
            capitalize( find_align_string( me ) ),
            capitalize( find_wimpy_string( me->query_wimpy() ) ),
            "You are "+ me->burden_string() + " and " +
               this_player()->query_temp_str(),
            find_death_string( me->query_max_deaths() - me->query_deaths() ) );
  } else {
    printf( "%s and %s.\n%s.\n",
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ) );
  }
  return 1;
}
int score_burden(object me, string verbose) {
  write( sprintf("You are %s (%d%%).\n", me->burden_string(),
          me->query_burden()));
  return 1;
}
int score_normal(object ob, string verbose)  {
   string word;
   string guild_ob;
   string area;
   string* magistrates;
   string* citizens;
   int age, temp1, temp2, temp3, temp4;
   int no_title;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   if(ob->query_role_playing())
     return score_rp(ob, verbose);
   if (query_verbose(ob, verbose))  {
      guild_ob = ob->query_guild_ob();
      if (!guild_ob) {
         guild_ob = "/std/guilds/warrior";
         no_title = 1;
      }
      temp1 = ob->query_hp();
      temp2 = ob->query_gp();
      temp3 = (int)LIBRARY->query_quest_points( ob->query_name() );
      temp4 = ob->query_sp();
      printf( "%-=*s", ob->query_cols(), "You have " +
            temp1 + " (" + ob->query_max_hp() + ") hit" +
            essify(temp1, "point") + ", " +
            temp2 + " (" + ob->query_max_gp() + ") guild" +
            essify(temp2, "point") + ", " +
            temp3 + " (" + (int)QUEST_HANDLER->query_total_qp() + ") quest" +
            essify(temp3, "point") + " and " +
            temp4 + " (" + ob->query_max_sp() + ") social" +
            essify( temp4, "point") + ".\n" );
      if ( guild_ob && find_object( guild_ob ) )  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() + " and you are level " +
               (int)ob->query_level() + " in the " +
               (no_title?"Adventurers' Guild":guild_ob->query_short()) +
               ((ob->query_guild_ob() == "/std/guilds/thief" &&
               !(ob->query_guild_data() == 0)) ?
               ", specialised as a " + ob->query_guild_data() : "") +
               "; your overall rating is " + (int)TOP_TEN_HANDLER->
               calculate_rating( ob ) + ".\n" );
      }  else  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() +".\n" );
      }
      temp1 = ob->query_deaths();
      temp2 = ob->query_max_deaths() - temp1;
      printf( "%-=*s", ob->query_cols(), "You have died " +
            temp1 + essify(temp1, "time") + " and can die " +
            temp2 + essify(temp2, "time") + " before you are completely "
            "dead.\n" );
      if ( ob->query_wimpy() )  {
         printf( "Your wimpy is set to %d%%.\n", ob->query_wimpy() );
      } else  {
         printf( "You are in brave mode.\n" );
      }
#ifdef USE_SURRENDER
      if (ob->query_surrender())  {
         printf("You will surrender at %d%% of your maximum hit points.\n",
            ob->query_surrender());
      } else  {
         printf("You won't surrender.\n");
      }
#endif
      printf( "You are %s (%d%%) and %s.\n", ob->burden_string(),
              ob->query_burden(),
               this_player()->query_temp_str());
      word = ob->query_deity();
#ifndef __DISTRIBUTION_LIB__
      if ( stringp( word ) )  {
         printf( "You are %s, worshipping %s.\n", ob->align_string(),
               capitalize( word ) +", "+ (string)DEITY->query_title( word ) );
      } else  {
         printf( "You are %s, worshipping no god.\n", ob->align_string() );
      }
#endif
      citizens = ({ });
      magistrates = ({ });
      word = ob->query_name();
      foreach (area in NOMIC_HANDLER->query_citizenship_areas()) {
         if (NOMIC_HANDLER->is_magistrate_of(area, word)) {
            magistrates += ({ area });
         } else if (NOMIC_HANDLER->is_citizen_of(area, word)) {
            citizens += ({ area });
         }
      }
      if (sizeof(magistrates)) {
          printf("You are a magistrate of: " +
                 query_multiple_short(magistrates) + ".\n");
      }
      if (sizeof(citizens)) {
          printf("You are a citizen of: " +
                 query_multiple_short(citizens) + ".\n");
      }
      if ( ob->query_property( PKER ) )  {
         printf( "You are registered as a player killer.\n" );
      }
      if ( m_sizeof( ob->query_hide_invis() ) )  {
         printf( "%-=*s\n", ob->query_cols(), "You are " +
               query_multiple_short( m_indices( ob->query_hide_invis() ) +
                                     ({ }) ) + "." );
      }
      printf( "%-=*s", ob->query_cols(), (string)ob->extra_score() );
      age = -ob->query_time_on();
      temp3 = ob->query_no_logins();
      word = sprintf("You are %s old and have logged in %d %s.\n",
                     query_time_string(age, -1),
                     temp3, (temp3 == 1 ? "time" : "times"));
      printf("%-=*s", ob->query_cols(), word);
   } else {
      printf( "%-=*s", ob->query_cols(), "Hp: " + ob->query_hp() + "(" +
            ob->query_max_hp() + ")  Gp: " + ob->query_gp() + "(" +
            ob->query_max_gp() + ")  Xp: "+ ob->query_xp() + "\n" );
   }
   return 1;
}
string create_relationship_text( string relationship, mapping data ) {
    string *relatives;
    int size;
    if ( !( relatives = data[ relationship ] ) )
        return "";
    if ( !size = sizeof( relatives ) )
        return "";
    if ( size == 1 ) {
        return capitalize( relatives[0] ) + " is your " +
            relationship;
    }
    return query_multiple_short( map( sort_array( relatives, 1 ),
        (: capitalize( $1 ) :) ) ) + " are your " +
        pluralize( relationship );
}
int get_gender( string name ) {
    int gender;
    gender = PLAYER_HANDLER->test_gender( name );
    if ( gender )
        gender -= 1;
    return gender;
}
int score_relationships( object ob, int verbose ) {
    string txt, family;
    string *sorted;
    class relationship_data *bing;
    mapping grouped;
    family = ob->query_family_name();
    if ( !family || !CLUB_HANDLER->is_family( family ) ) {
        add_failed_mess( "You're not in a family!\n" );
        return 0;
    }
    bing = CLUB_HANDLER->query_relationships( family, ob->query_name() );
    if ( !sizeof( bing ) ) {
        add_failed_mess( "You have no relatives.\n" );
        return 0;
    }
    grouped = unique_mapping( bing,
        (: CLUB_HANDLER->query_relationship_gender(
           CLUB_HANDLER->query_opposite_relationship( $1->relationship ),
           get_gender( $1->related_to ) )  :) );
    grouped = map( grouped, (: map( $2, (: $1->related_to :) ) :) );
    sorted = sort_array( keys( grouped ), 1 );
    txt = implode( map( sorted,
        (: create_relationship_text( $1, $(grouped) ) :) ), ".\n" );
    tell_object( ob, "$P$Relationships$P$" + txt + ".\n" );
    return 1;
}
int score_align( object ob, int verbose ) {
  int upper, lower, middle, align;
  string god, opinion;
  if (ob->query_property( "dead" )) {
     write( "You're dead.  Things such as 'good' and 'evil' are no longer of
      your concern.\n" );
     return 1;
  }
   if( !ob->query_deity() ) {
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
    }
  else {
    god = ob->query_deity();
    align = ob->query_al();
#ifndef __DISTRIBUTION_LIB__
    lower = DEITY->query_al_lower( god );
    upper = DEITY->query_al_upper( god );
    middle = DEITY->query_al_middle( god );
    opinion = "pleased with";
    if( align <= lower - LIMIT || align >= upper + LIMIT )
      opinion = "very angry with";
    if( ( align < lower && align > lower - LIMIT ) ||
        ( align > upper && align < upper + LIMIT ) )
      opinion = "quite annoyed with";
    if( ( align >= lower && align <= lower + LIMIT ) ||
        ( align <= upper && align >= upper - LIMIT ) )
      opinion = "a little concerned about";
    if( align > middle - ( LIMIT / 2 ) && align < middle + ( LIMIT / 2 ) )
      opinion = "very happy with";
    write( "You are " + ob->align_string() + ".  " + capitalize( god ) +
      " is " + opinion + " you.\n" );
#else
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
#endif
  }
  return 1;
}
int score_fighting( object player, int verbose ) {
    object *attacker_list;
    object *attacker_list_here;
    string ret;
    class tactics tactics;
    attacker_list = player->query_attacker_list() - ({ 0 });
    ret = "";
    if ( attacker_list ) {
       attacker_list_here = filter( attacker_list, (: $1 && living( $1 ) &&
           environment( $1 ) == environment( $(player) ) :) );
       if ( !sizeof( attacker_list ) ) {
           ret += "You are not fighting anything!\n";
       } else {
          attacker_list -= attacker_list_here;
          if (sizeof(attacker_list_here)) {
             ret += "$I$5=You are currently fighting " +
                 query_multiple_short( attacker_list_here ) + " here.\n";
          }
          if (sizeof(attacker_list)) {
             ret += "$I$5=You are currently fighting " +
                 query_multiple_short( attacker_list ) + " (these are "
                 "people you will auto attack on sight).\n" ;
          }
       }
    }
    tactics = (class tactics) this_player()->query_tactics();
    ret += "$I$0=Your current tactics are:\n"
      "   Attitude       :   "+ tactics->attitude +"\n"
      "   Response       :   "+ tactics->response +"\n"
#ifdef USE_SURRENDER
      "   Mercy          :   "+ (tactics->mercy?tactics->mercy:"none") + "\n"
#endif
      "   Focus          :   "+
      (tactics->focus_zone?tactics->focus_zone:"none") + "\n"
#ifdef USE_DISTANCE
      "   Target distance:   "+
      (tactics->ideal_distance?tactics->ideal_distance:"none") + "\n"
#endif
      "   Attack         :   "+ (tactics->attack == "both" ? "both" :
                     (tactics->attack?tactics->attack:"both")) + "\n"
      "   Parry          :   " + (tactics->parry == "both" ? "both" :
                      (tactics->parry?tactics->parry:"both")) + "\n"
      "   Unarmed Parry  :   " + (tactics->parry_unarmed ? "yes" : "no") + "\n";
    write(ret);
    return 1;
}
int score_temperature( object player, int verbose ) {
   return "/cmds/player/temp_erature"->cmd();
}
mixed *query_patterns() {
   return ({
             "quests", (: score_quests(this_player(), 0) :),
             "quests sorted", (: score_quests(this_player(), 1) :),
             "{brief|verbose} stats", (: score_stats(this_player(), $4[0]) :),
             "stats", (: score_stats(this_player(), 0) :),
             "{brief|verbose}", (: score_normal(this_player(), $4[0]) :),
             "relationships", (: score_relationships( this_player(), 0 ) :),
             "temperature", (: score_temperature( this_player(), 0 ) :),
             "burden", (: score_burden( this_player(), 0 ) :),
             "", (: score_normal(this_player(), 0) :),
             "{align|alignment}", (: score_align(this_player(), 0) :),
             "fighting", (: score_fighting( this_player(), 0 ) :) });
}

==================================================
FILE: player/sea_rch.c
==================================================

#include <tasks.h>
#include <player.h>
inherit "/cmds/base";
#define SKILL "other.perception"
#define GP_COST 15
nosave mapping callouts = ([]);
int cmd(string str) {
   if (this_player()->query_specific_gp("other") < GP_COST) {
      add_failed_mess("You are too weary to complete a "
                      "proper search of your surroundings.\n");
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess("Ghosts cannot search!\n");
      return 0;
   }
   if (sizeof(filter(this_player()->query_attacker_list(),
                     (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot search, you are in combat!\n");
      return 0;
   }
   this_player()->adjust_time_left( -ROUND_TIME * 4 );
   if (callouts[this_player()->query_name()]) {
      remove_call_out(callouts[this_player()->query_name()]);
   }
   callouts[this_player()->query_name()] =
      call_out("search_callout", 4*1, this_player(), str);
   this_player()->adjust_gp(-GP_COST);
   write("You start to search around.\n");
   say(this_player()->the_short() + " $V$0=starts,start$V$ to search around.\n");
   return 1;
}
void search_callout(object who, string str) {
   mapping hide_invis;
   int i;
   string *types;
   string* ground;
   mixed see;
   object *found, ob;
   if (who->query_fighting()) {
      write("Oops!  You appear to have entered combat and cannot "
            "finish searching.\n");
      return ;
   }
   if ( function_exists( "do_search", environment( who ) ) ) {
      i = (int)environment( who )->do_search( str );
      switch(i) {
      case 1:
         return;
      case 0:
         if(query_notify_fail())
            write(query_notify_fail());
         return;
      default:
         break;
      }
   }
   if(!str) {
      found = ({ });
      foreach(ob in all_inventory(environment(who))) {
         if(ob->query_visible(who) ||
            ob->query_creator() ||
            pk_assist(this_player(), ob))
           continue;
         hide_invis =  ob->query_hide_invis();
         if(mapp(hide_invis)) {
            types = m_indices( hide_invis );
         } else {
            types = ({});
         }
         if ( !sizeof( types ) ) {
            continue;
         }
         for ( i = 0; i < sizeof( types ); i++ ) {
            if ( hide_invis[ types[ i ] ][ 0 ] == who ) {
               continue;
            }
            see = hide_invis[ types[ i ] ][ 1 ];
            if ( intp( see ) ) {
               see -= random(environment(who)->query_light());
               see /= 2;
               switch(TASKER->perform_task(who, SKILL, see, TM_FREE)) {
               case AWARD:
                  write("%^YELLOW%^"+
                        ({"You feel very perceptive", "You realise "
                             "something new about searching"})[random(2)]+
                             "%^RESET%^.\n");
               case SUCCEED:
                  found += ({ ob });
                  ob->remove_hide_invis(types[i]);
                  break;
               }
               break;
            }
         }
      }
   }
   if(sizeof(found)) {
      write("You search around and find "+query_multiple_short(found)+".\n");
   } else {
      ground = environment(who)->query_default_search_description();
      if (!ground) {
         write( ({
         "You search around for a while, but don't find anything.\n",
         "You scrounge around.  The ground does look interesting, "
            "you decide.\n",
         "You look carefully at everything, but you find nothing.\n",
         "After an intense search, you find nothing.\n" })[ random( 4 ) ] );
      } else {
         write(ground[random(sizeof(ground))]);
      }
   }
   say("$one_short:" + file_name(who) + "$ $V$0=searches,search$V$ around the "
       "place a bit.\n" );
   event(environment(who), "player_search");
   map_delete(callouts, who->query_name());
   return;
}
void interrupt_search(object who) {
   if(callouts[who->query_name()]) {
      remove_call_out(callouts[who->query_name()]);
      tell_object(who, "You stop searching.\n");
      map_delete(callouts, who->query_name());
   }
}
mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :),
             "here", (: cmd(0) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/shields.c
==================================================

#include <armour.h>
#include <combat.h>
inherit "/cmds/base";
string construct_shield_message( object player, int not_self );
int cmd() {
  string mess;
  mess = construct_shield_message(this_player(), 0);
  if( sizeof( mess ) ) {
    tell_object( this_player(), "Arcane protection status:\n" + mess );
  } else {
    tell_object( this_player(), "You do not have any arcane protection.\n" );
  }
  return 1;
}
string construct_shield_message( object player, int not_self ) {
  int i, j;
  string mess;
  mixed *callbacks;
  string *res;
  class armour_callback cb;
  class combat_special cs;
  mess = "";
  callbacks = player->query_armour_callbacks();
  for( i = 0; i < sizeof(callbacks); i++) {
    for(j=0; j < sizeof(callbacks[i]); j++) {
      cb = callbacks[i][j];
      if(cb->callback[0]) {
        res = (cb->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
      }
    }
  }
  callbacks = player->query_specials();
  for(i=0; i<sizeof(callbacks); i++) {
    cs = callbacks[i];
    if(cs->callback[0]) {
      res = (cs->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
    }
  }
  return mess;
}
mixed *query_patterns() {
  return ({ "", (: cmd :) });
}

==================================================
FILE: player/spells.c
==================================================

#include <spells.h>
inherit "/cmds/base";
int cmd() {
   string spell, *magic;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   magic = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( !stringp( spells[ spell ][ S_OBJECT ] ) ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*spriest%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*srituals%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*swizard%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*switch%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*sspell%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
   }
   if ( !sizeof( magic ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   if ( sizeof( magic ) ) {
      write( "You know the following magic spell"+
            ( sizeof( magic ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( magic, 1 ), "\n" ) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/splash.c
==================================================

inherit "/cmds/base";
#include <weather.h>
#define TP this_player()
mixed cmd(object *obs) {
    object env, ob;
    string str;
    env = environment(TP);
    if ( !env->query_baths()  &&  (!env->query_water()  ||  !env->query_surface()) ) {
        if ((string)env->query_property("location") == "inside")
            return notify_fail("You must be outside to do that.\n");
        if (!WEATHER->query_raining(env))
            return notify_fail("It must be raining to splash someone.\n");
    }
    foreach(ob in obs) {
        ob->add_effect("/std/effects/other/wetness", 2 + random(4));
        if(ob == this_player())
            continue;
        tell_object(ob, (string)TP->a_short()+" splashes "+
          query_multiple_short(obs - ({ ob }) + ({ "you" }))+".\n");
    }
    str = query_multiple_short(obs);
    write("You splash "+str+".\n");
    say(TP->a_short()+" splashes "+str+".\n", obs);
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:living>",(: cmd($1) :) });
}

==================================================
FILE: player/start.c
==================================================

inherit "/cmds/base";
int clear_starts() {
  write( "Clearing your list of starting positions...\n" );
  this_player()->reset_starts();
  return 1;
}
int list_starts() {
   int z, i;
   string *starts;
   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;
   if ( z == -1 ) {
      write( "Your starting position is " +
             this_player()->query_start_pos()->the_short() + ".\n");
      return 1;
   }
   if ( !z ) {
      write( "Your starting position is "+ starts[ 1 ] +".\n" );
      return 1;
   }
   write( "Your current starting position is "+ starts[ 1 ] +".\n"+
         "You can also choose your starting position from:\n" );
   for ( i = 1; i <= z; i++ )
      write( sprintf( "% 5d: $I$7=%s\n", i, starts[ 2 * i + 1 ] ) );
   write( "Choose a new starting position using: start <number>\n"+
         "To clear your list of starting positions, use: start clear\n" );
   return 1;
}
int set_start( int num ) {
   string *starts;
   int z;
   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;
   if (sizeof(starts) < 2) {
      add_failed_mess("You only have one starting location.\n");
      return 0;
   }
   if (z == 0) {
      add_failed_mess("You have no starting locations to choose from at all.\n");
      return 0;
   }
   if ( ( num < 1 ) || ( num > z ) ) {
      add_failed_mess( "You must choose a number from 1 to "+ z +".\n" );
      return 0;
   }
   num *= 2;
   write( "Your new starting position is "+ starts[ num + 1 ]  +".\n" );
   this_player()->set_start_location(starts[num]);
   return 1;
}
mixed *query_patterns() {
  return ({ "<number>", (: set_start($4[0]) :),
            "clear", (: clear_starts() :),
            "", (: list_starts() :) });
}

==================================================
FILE: player/stop.c
==================================================

inherit "/cmds/base";
int no_okay;
object tmp;
mixed cmd( string word ) {
   object *atts;
   switch( word ) {
      case "debate" :
      case "debating" :
         this_player()->interrupt_debate();
         break;
      case "spell" :
         this_player()->interrupt_spell();
         break;
      case "ritual" :
         this_player()->interrupt_ritual();
         break;
      case "fight" :
      case "fighting" :
         atts = this_player()->query_attacker_list();
         if ( !sizeof( atts ) ) {
            write( "You are not fighting anyone.\n" );
            return 1;
         }
         if ( (int)this_player()->query_hp() < 0 ) {
            write( "You have already died; stopping now is pointless.\n" );
            return 1;
         }
         write( "Stopping fight.  Please wait.\n" );
         call_out( "stop_fight", 5+random(10), this_player() );
         return 1;
      default:
         no_okay = 1;
         cmd( "debate" );
         cmd( "spell" );
         cmd( "ritual" );
         cmd( "fight" );
         no_okay = 0;
   }
   "/cmds/player/sea_rch"->interrupt_search(this_player());
   if ( !no_okay )
      write( "Okay.\n" );
   return 1;
}
void stop_fight( object who ) {
  object *atts, ob;
  if ( !who )
    return;
  atts = who->query_attacker_list();
  atts -= ({ 0 });
  tmp = who;
  if(atts == ({ }))
    return;
  tell_object( who, "You stop fighting "+
               query_multiple_short( map_array( atts,
         (: $1->query_property( "dead" ) ? (string)$1->a_short() + " (dead anyway)" : $1 :) ) ) +".\n" );
  foreach(ob in atts)
    who->stop_fight(ob);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{debate|debating|spell|ritual|fight|fighting}", (: cmd($4[0]) :) });
}

==================================================
FILE: player/su.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>;
#define TEAM_HANDLER "/obj/handlers/team"
#define TP this_player()
mixed cmd(string str) {
  string from;
  if (!str || str == "")
    return notify_fail("Usage: su <name>\n");
  if ( TP->query_auto_loading() ) {
    printf("You cannot quit yet: your inventory is still being generated.\n" );
    return 1;
  }
  if ( find_object( "/obj/shut" )) {
    write("You cannot su during a reboot.\n");
    return 1;
  }
  if(sizeof(TP->query_attacker_list())) {
    write("You cannot quit while in combat.\n");
    return 1;
  }
  if (TEAM_HANDLER->query_group(this_player()))  {
    "/cmds/player/leaveg_roup"->cmd(0);
  }
  if (environment(this_player()) == find_object("/room/departures"))  {
    write("You can't use su in the departure lounge.\n");
    return 1;
  }
  from = TP->query_name();
  clone_object("/secure/login")->do_su(str);
  seteuid( "Root" );
  if(str == from)
    LOGIN_HANDLER->write_log("Su", TP->query_name(),
                             TP->query_property("guest"), "(to self)");
  else
    LOGIN_HANDLER->write_log("Su", from, TP->query_property("guest"), str);
  return 1;
}
mixed* query_patterns() {
   return ({ "<string'new name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/t_ell.c
==================================================

#include <drinks.h>
#include <player.h>
#include <language.h>
#define TP this_player()
#define TELL_REPLY_LOCK_ID "lock fluff"
#define CUT_THOUGH_PROPERTY "cut earmuffed tells"
#define FAIL_DONT_ASK 0
#define ASK 1
#define CUT_DONT_ASK 2
inherit "/cmds/base";
inherit "/cmds/speech";
void delayed_tell(string yesno,
                  object * recicipients,
                  string message);
#ifdef USE_SMILEYS
string *two_smileys = ({ ":)", ":(", ":P", ":p", ":b", ";)",
                           ";(", ";P", ";p", ";b", "=)", "=("
                           });
string *three_smileys = ({ ":-)", ":-(", ":-P", ":-p", ":-b",
                             ";-)", ";-(", ";-P", ";-p", ";-b", ":o)", ":o(",
                             ":oP", ":op", ":ob", ";o)", ";o(", ";oP", ";op",
                             ";ob", "=-)", "=-(", "=o)", "=o("
                             });
#endif
int cmd(string arg, mixed thing, int silent) {
  class message mess;
  string words,
    word;
  string them_mess,
    extra;
  string *ok_string;
  string *prop;
  object *obs;
  object *net_dead;
  object *multiple_earmuffed;
  object *cannot_see;
  object *ok;
  object *fail;
  object *earmuffed;
  object *roleplaying;
  mixed busy;
  if (pointerp(thing)) {
    words = arg;
    thing -= ({ 0 });
    if (TP && environment(TP) &&
        function_exists("trap_tell", environment(TP)) &&
        member_array(this_object(), previous_object(-1)) == -1) {
      return (int) environment(TP)->trap_tell(words, thing, 0);
    }
  } else if (!objectp(thing)) {
    if (!arg || sscanf(arg, "%s %s", word, words) != 2) {
      return 0;
    }
    word = lower_case(word);
    word = (string) TP->expand_nickname(word);
    if (sizeof(thing = explode(word, ",")) == 1)
      thing = ({ find_player(word) });
    else {
      thing = map(thing, (: find_player :));
    }
    thing -= ({ 0 });
    if (sizeof(thing) == 0) {
      if (TP->query_creator() && sscanf(word, "%*s@%*s") == 2) {
        "/net/daemon/out_tell"->do_tell(word + " " + words);
        return 1;
      }
      add_failed_mess(capitalize(word) + " is not logged in.\n");
      return 0;
    }
    if (environment(TP)) {
      if (function_exists("trap_tell", environment(TP)) &&
          member_array(this_object(), previous_object(-1)) == -1) {
        return environment(TP)->trap_tell(words, thing, 0);
      }
    }
  } else {
    thing = ({ thing }) - ({ 0 });
    words = arg;
  }
  if (TP->check_earmuffs("tell")) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      fail = filter(thing, (: !TP->is_friend($1->query_name()) &&
                            $1 != this_player() :));
      if (sizeof(fail)) {
        add_failed_mess("One of the people ($I) you "
                        "are trying to tell is not a "
                        "friend (and you have tells earmuffed).\n",
                        fail );
        return -1;
      }
    } else {
      add_failed_mess("You have tells ear muffed.\n");
      return -1;
    }
  }
  if(TP->query_role_playing()) {
    add_failed_mess("You cannot send tells as you are currently "
        "role playing.\n");
    return -1;
  }
  mess = build_message(words, thing, "tell");
  switch(mess->status) {
  case NOT_DISTANCE:
    return add_failed_mess("The language " + capitalize(mess->language) +
                           " is not able to used over a distance.\n");
  case NOT_SPOKEN:
    return add_failed_mess(capitalize(mess->language) +
                           " is not a spoken language.\n");
  case NO_MESSAGE:
    return add_failed_mess("No message given.\n");
  }
  obs = thing - ({ this_player() });
  if (!sizeof(obs)) {
    add_failed_mess("Talking to yourself again.  I don't know.\n");
    return 0;
  }
  if (sizeof(obs) > 20) {
    add_failed_mess("You can only tell up to 20 people a message.\n");
    return 0;
  }
  fail = this_player()->query_ignoring(obs);
  if (sizeof(fail)) {
    write("You are currently ignoring " +
          query_multiple_short(fail, 0, 1, 0, 0) + ", so " +
          (sizeof(fail) > 1 ? " they" : fail[0]->query_pronoun()) +
          " couldn't reply anyway.\n");
    obs -= fail;
    if (!sizeof(obs)) {
      return 1;
    }
  }
  fail = this_player()->query_ignored_by(obs);
  if (sizeof(fail)) {
    if (!this_player()->query_creator()) {
      write("You are currently being ignored by " +
            query_multiple_short(fail, 0, 1, 0, 0) + ", so "
            "you cannot tell them anything.\n");
      obs -= fail;
      if (!sizeof(obs)) {
        return 1;
      }
    } else {
      write("Warning!  " + query_multiple_short(fail, 0, 1, 0, 0) +
            " have you on ignore.\n");
    }
  }
  if (!TP->query_creator() && (TP->adjust_sp(-TELL_COST) < 0)) {
    return notify_fail(NO_POWER);
  }
  net_dead = ({ });
  multiple_earmuffed = ({ });
  earmuffed = ({ });
  ok = ({ });
  roleplaying = ({ });
  cannot_see = ({ });
  if (sizeof(obs) > 1 && this_player()->check_earmuffs("multiple-tell")) {
    add_failed_mess("You cannot do a multiple-tell if you have them "
                    "earmuffed yourself.\n");
    return 0;
  }
  foreach(thing in obs) {
    if (sizeof(obs) > 1 && thing->check_earmuffs("multiple-tell")) {
      multiple_earmuffed += ({ thing });
    } else if (thing->check_earmuffs("tell")) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        write("You cut through the ear muffs of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your ear muffs.\n");
        ok += ({ thing });
      } else {
        earmuffed += ({ thing });
      }
    } else if(thing->query_role_playing()) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        write("You cut through the roleplaying mode of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your roleplaying mode.\n");
        ok += ({ thing });
      } else {
        roleplaying += ({ thing });
      }
    } else if (!this_player()->query_invis() ||
               reference_allowed(this_player(), thing)) {
      ok += ({ thing });
    } else {
      cannot_see += ({ thing });
      ok += ({ thing });
    }
  }
  ok_string = map(ok, (: $1->query_name() :)) +
    ({ this_player()->query_name() });
  switch (mess->type) {
  case "exclaim":
    extra = " to";
    break;
  default:
    extra = "";
    break;
  }
  foreach(thing in ok) {
    them_mess = query_multiple_short(map(ok- ({ thing }),
                                         (: $1->short(0, 0) :)) +
                                     ({ "you"  }), 0, 1, 0, 0);
    if ( interactive( this_player() ) ) {
      thing->event_person_tell(TP, capitalize((string) TP->short(0, 0)) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    else {
      thing->event_person_tell(TP, capitalize( TP->the_short()) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    prop = thing->query_tell_reply_list();
    if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
      if (member_array(TP->query_name(), prop) != -1) {
        thing->set_tell_reply_list(prop);
      }
    } else {
      thing->set_tell_reply_list(ok_string);
    }
    if (!interactive(thing) && userp(thing)) {
      net_dead += ({ thing });
    }
  }
  if (!silent) {
    if (sizeof(net_dead)) {
      write("Warning: " +
            query_multiple_short(map(net_dead, (: $1->query_cap_name() :)), 0,
                                 1, 0, 0) + " " +
            (sizeof(net_dead) > 1 ? "are" : "is") + " net dead.\n");
    }
    if (sizeof(multiple_earmuffed)) {
      write(capitalize(query_multiple_short(multiple_earmuffed, 0, 1, 0, 0)) +
            (sizeof(multiple_earmuffed) > 1 ? " have " : " has ") +
            "multiple tells ear muffed.\n");
    }
    if (sizeof(earmuffed)) {
      write(capitalize(query_multiple_short(earmuffed, 0, 1, 0, 0)) +
            (sizeof(earmuffed) > 1 ? " have " : " has ") +
            "tells ear muffed.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    if (sizeof(roleplaying)) {
      write(capitalize(query_multiple_short(roleplaying, 0, 1, 0, 0)) +
            (sizeof(roleplaying) > 1 ? " are " : " is ") +
            "role playing.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    busy = this_player()->query_busy();
    if (busy == 1) {
      write("Warning! You have your busy flag on.\n");
    } else if (pointerp(busy) && sizeof(ok - busy)) {
      write("Warning! You are currently set as busy with " +
            query_multiple_short(busy, 0, 1, 0, 0) + ".\n");
    }
    if (sizeof(cannot_see)) {
      write("Warning! " + query_multiple_short(cannot_see, 0, 1, 0, 0) +
            " cannot see you and will not be able to respond.\n");
    }
    if (sizeof(ok)) {
      them_mess =
        TP->convert_message(query_multiple_short(map(ok, (:
$1->short(0,0) :)), 0, 1, 1, 0));
      my_mess("You " + mess->emote + mess->type + extra + " " +
              them_mess + ": ", mess->text);
      TP->add_tell_history("You " + mess->emote + mess->type + extra +
                           " " + them_mess + ": ", mess->text);
    } else if (TP->query_creator() && !sizeof(earmuffed)) {
      add_failed_mess("It seems no one was listening.\n");
      return -1;
    }
  }
  TP->adjust_time_left(-5);
  return 1;
}
int reply_cmd(string mess) {
  string *rep;
  object *obs;
  rep = this_player()->query_tell_reply_list();
  if (!rep) {
    add_failed_mess
      ("No one has told you anything in the last 15 minutes.\n");
    return 0;
  }
  obs = map(rep, (: find_living($1) :)) - ({ 0 });
  if (!sizeof(obs)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are currenttly online.\n");
    return 0;
  }
  this_player()->set_tell_reply_list(rep);
  return cmd(mess, obs, 0);
}
int replylock_cmd(string names) {
  string *rest;
  string *rep;
  rep = uniq_array(explode(names, ","));
  rep = map(rep, (: this_player()->expand_nickname($1) :));
  rest = filter(rep, (: $1 && find_player($1) && interactive(find_player($1)) :));
  if(!sizeof(rest)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are logged in.  You cannot lock onto someone who is "
                    "not here.\n");
    return 0;
  }
  this_player()->set_tell_reply_list(({ TELL_REPLY_LOCK_ID }) + rest);
  add_succeeded_mess(({ "You lock in " +
                          query_multiple_short(rest, 0, 1, 0, 0) +
                          " in your reply list.\n", "" }));
  return 1;
}
int replylockremove_cmd() {
  this_player()->set_tell_reply_list(0);
  add_succeeded_mess(({ "You remove any possible reply locks.\n", "" }));
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player> <string'message'>",
              (: cmd($4[1], $1, 0) :),
              "reply <string'message'>", (: reply_cmd($4[0]) :),
              "replylock <string'names'>", (: replylock_cmd($4[0]) :),
              "replylock remove", (: replylockremove_cmd() :),
              "<string>", (: cmd($4[0], 0, 0) :) });
}
void delayed_tell(string yesno,
                  object * recicipients,
                  string message) {
  object ob,
    *netdead;
  int disappeared;
  if (!(yesno == "yes" || yesno == "y")) {
    write("Ok, tell aborted.\n");
    return;
  }
  netdead = ({ });
  foreach(ob in recicipients) {
    if (!ob) {
      disappeared++;
      recicipients -= ({ ob });
    } else {
      if (!interactive(ob))
        netdead += ({ ob });
      message = replace(message, "%^", " ");
      ob->event_person_tell(TP, capitalize(TP->query_name()) +
                            " cuts through your ear muffs and tells "
                            + query_multiple_short(recicipients -
                                                   ({ ob }) + ({ "you" }), 0,
                                                   1, 0, 0) + ": ", message);
    }
  }
  if (sizeof(netdead))
    write("Warning: " + query_multiple_short(netdead, 0, 1, 0, 0) +
          (sizeof(netdead) > 1 ? " is" : " are") + " net dead.\n");
  if (disappeared)
    write("It seems " + disappeared + " person" +
          (disappeared > 1 ? "s have" : " has")
          + " disappeared.\n");
  if (!sizeof(recicipients)) {
    write("No one wanted to stay around long enough "
          "to hear what you had to say.\n");
    return;
  }
  my_mess("You tell " +
          TP->convert_message(query_multiple_short(recicipients, 0, 1, 0, 0))
          + ": ", message);
  TP->add_tell_history("You cut through earmuffs and tell " +
                       TP->convert_message(capitalize(
                       query_multiple_short(recicipients, 0, 1, 0, 0))) +
                       ": ", message);
  return;
}

==================================================
FILE: player/temp_erature.c
==================================================

#include <weather.h>
#include <clothing.h>
#include <playtesters.h>
#define COMFORTABLE 20
#define ABS(x) (x > 0? x : -x)
string disp_warmth(int, int);
string disp_total(int i);
int cmd(string str) {
  object where, *clothes, item;
  string zone, type, *zones, tmp;
  mixed types;
  int adjustment, correction, temperature, room_temp, *enums, cwarm, ccool;
  where = environment(this_player());
  if(!where)
    return notify_fail("You have no environment.\n");
  if(!where->query_property("location") &&
     environment(where) &&
     environment(where)->query_property("location")) {
    where = environment(where);
  }
  switch(where->query_property("location")) {
  case "outside":
    room_temp = (WEATHER->query_temperature(where) - COMFORTABLE);
    break;
  default:
    room_temp = 0;
  }
  temperature = this_player()->query_personal_temp();
  room_temp += where->query_property("warmth");
  room_temp -= where->query_property("cooling");
  write(sprintf("It's %s here.\n",
         WEATHER->temp_string(room_temp + COMFORTABLE)));
  clothes = filter_array(this_player()->query_wearing(),
                         (: !$1->id("scabbard") &&
                          !$1->id("belt") &&
                          !$1->id("backpack") &&
                          !$1->id("glasses") &&
                          !$1->id("jewellery") :));
  zones = ({ });
  foreach(item in clothes) {
    types = item->query_type();
    if(!arrayp(types)) {
      types = ({ item->query_type() });
    }
    ccool = 0;
    cwarm = 0;
    foreach(type in types) {
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth")) {
          adjustment += item->query_property("warmth");
          cwarm += item->query_property("warmth");
        } else {
          adjustment++;
          cwarm++;
        }
        if(room_temp > 0 && item->query_property("cooling")) {
          adjustment -= item->query_property("cooling");
          ccool += item->query_property("cooling");
        }
      }
    }
    tmp = item->query_name();
    if(cwarm && ccool) {
      write(sprintf("Your %s provide%s %s and %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1),
             disp_warmth(ccool, 0)));
    } else if(cwarm) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1)));
    } else if(ccool) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(ccool, 0)));
    }
  }
  if(room_temp < 0) {
    adjustment += sizeof(zones);
    if(room_temp + sizeof(zones) > 5)
      adjustment -= (room_temp + sizeof(zones) - 5);
  } else {
    adjustment -= sizeof(zones);
    if(room_temp - sizeof(zones) < -5)
      adjustment -= (room_temp - sizeof(zones) + 5);
  }
  ccool = 0;
  enums = (int *)this_player()->effects_matching("body.wetness");
  if ( sizeof( enums ) ) {
    adjustment -= sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
    ccool = sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
  }
  adjustment += this_player()->query_property("warmth");
  adjustment -= this_player()->query_property("cooling");
  if(temperature > room_temp && room_temp >= 0 || temperature > 5)
    correction -= (temperature / 5) + 5;
  if(temperature < room_temp && room_temp <= 0 || temperature < -5)
    correction -= (temperature / 5) - 5;
  write(sprintf("On balance, you are %s and %s.\n",
         this_player()->query_temp_str(),
         disp_total(to_int((room_temp+adjustment + correction)))));
  return 1;
}
string disp_warmth(int i, int warm) {
  string pos, neg;
  if(warm) {
    pos = " warmth";
    neg = " cooling";
  } else {
    pos = " cooling";
    neg = " warmth";
  }
  switch(i) {
  case -1000..-19: return "an enormous amount of"+neg;
  case -9..-18: return "a lot of"+neg;
  case -8..-4: return "quite a lot of"+neg;
  case -3..-2: return "some"+neg;
  case -1: return "a bit of"+neg;
  case 0: return "no"+pos;
  case 1: return "a bit of"+pos;
  case 2..3: return "some"+pos;
  case 4..8: return "quite a lot of"+pos;
  case 9..18: return "a lot of"+pos;
  default: return "an enormous amount of"+pos;
  }
}
string disp_total(int i) {
  switch(i) {
  case -1000..-51: return "are freezing fast";
  case -50..-21: return "are cooling down quickly";
  case -20..-11: return "are cooling down";
  case -10..-6: return "are cooling down slowly";
  case -5..5: return "will stay pretty much as you are";
  case 6..10: return "are warming up slowly";
  case 11..20: return "are warming up";
  case 21..50: return "are warming up quickly";
  case 51..1000: return "are cooking rapidly";
  default:
    return "broken: " + i + "\n";
  }
}
mixed *query_patterns()  {
   return ({ "", (: cmd("") :) });
}

==================================================
FILE: player/time.c
==================================================

#include <localtime.h>
#include <dst.h>
#include <am_time.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
#include <config.h>
inherit "/cmds/base";
mixed *_timezones;
void show_mud_time();
void create() {
   mixed *time_rubbish;
   time_rubbish = localtime(time());
   _timezones = ({
      "Seattle", - time_rubbish[LT_GMTOFF] + (US_DST * 60 * 60),
      "Toronto", - time_rubbish[LT_GMTOFF] + (3 + CA_DST) * (60 * 60),
     "London", (UK_DST * 60 * 60),
      "Sydney", (10 + AUS_DST) * (60 * 60),
                 });
}
mixed cmd( string word ) {
   mixed *time_rubbish;
   int i;
   string mess;
   time_rubbish = localtime(time());
   mess = "";
   for (i = 0; i < sizeof(_timezones); i += 2) {
      mess += sprintf( "[%s in %-9s]\n", ctime(time() + time_rubbish[LT_GMTOFF] +
                                    _timezones[i + 1]), _timezones[i]);
   }
   if ( this_player()->query_creator() )
      show_mud_time();
   write(mess);
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd :) });
}
void show_mud_time() {
#ifndef __DISTRIBUTION_LIB__
   string mess;
   string day = cap_words(SPECIAL_DAY_HANDLER->query_special_day());
   mess = sprintf( "In Ankh-Morpork, it is %s%s\n", amtime( time() ),
           ( strlen(day) ? ".  Today is "+ day +".": ".") );
   write( mess );
#endif
}

==================================================
FILE: player/title.c
==================================================

inherit "/cmds/base";
#include <player.h>
mixed cmd_list() {
   string* titles;
   if (this_player()->query_player_title()) {
      write("Your player title is currently set to: " +
            this_player()->query_player_title() + ".\n");
   } else {
      write("Your player title is currently not set.\n");
   }
   titles = this_player()->query_all_player_titles();
   write("You can set your player title to one of " +
         query_multiple_short(map(titles, (: capitalize($1) :))) + ".\n");
   return 1;
}
int cmd_set(string title) {
    mixed mess;
   title = lower_case(title);
   if (strlen(title) > 20) {
      add_failed_mess("Your title is too long.\n");
   }
   if (member_array(title,
                    this_player()->query_all_player_titles()) == -1) {
      add_failed_mess("The title '" + title + "' is not valid.\n");
      return 0;
   }
   if (this_player()->query_player_title() &&
       lower_case(this_player()->query_player_title()) == title) {
      add_failed_mess("You already have your player title set to '" + title +
                      "'.\n");
      return 0;
   }
   this_player()->set_player_title(title);
   if ( sizeof( this_player()->query_hide_invis() ) ) {
       mess = ({ "$N set$s $p player title to " + capitalize(title) +
           ".\n", "" });
   }
   else {
       mess = "$N set$s $p player title to " + capitalize(title) +  ".\n";
   }
   add_succeeded_mess(mess);
   return 1;
}
int cmd_reset() {
   if (!this_player()->query_player_title()) {
      add_failed_mess("Your player title is already unset.\n");
      return 0;
   }
   this_player()->set_player_title(0);
   add_succeeded_mess("$N reset$s $p player title.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "<string'title'>", (: cmd_set($4[0]) :),
             "none", (: cmd_reset() :) });
}

==================================================
FILE: player/tu_rn.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  int i;
  mixed * facing;
  if ( !( i = ([ "half right": 1, "right": 2, "rt": 2, "around": 4, "left": 6,
      "lt": 6, "half left": 7 ])[ str ] ) ) {
    return 0;
  }
  facing = TP->query_facing();
  facing[ 0 ] = ( i + facing[ 0 ] ) % 8;
  write( "You reorient yourself with the world.\n" );
  if(TP->query_sneak_level())
    say( TP->one_short(1)+" reorients "+ TP->query_objective() +"self.\n");
  else
    say(TP->one_short() +" reorients "+ TP->query_objective() +"self.\n" );
  TP->set_facing(facing);
  if ( environment(TP) )
    environment(TP)->init();
  return 1;
}
mixed *query_patterns()  {
    return ({ "<string'around, [half] right, [half] left, rt, lt'>",
              (: cmd($4[0]) :) });
}

==================================================
FILE: player/typo.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("TYPO");
   set_use_last_error(0);
}

==================================================
FILE: player/un_alias.c
==================================================

inherit "/cmds/base";
varargs int unalias(string str, object who ) {
    if (!who) who = this_player();
   if (!who->is_alias(str)) {
      add_failed_mess("The alias '" + str +
                      "' does not exist, cannot unalias.\n");
      return 0;
   }
   if (who->remove_player_alias(str)) {
      write("Successfully unaliased '" + str + "'.\n");
      return 1;
   } else {
      add_failed_mess("Unable to unalias '" + str + "'.\n");
      return 0;
   }
}
varargs int unalias_pattern(string filter) {
   mapping aliases;
   string* tmp;
   string* ok;
   string gfilter;
   string bing;
   aliases = this_player()->query_aliases();
   tmp = m_indices(aliases);
   if (regexp(filter,
        "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
      add_failed_mess("Bad pattern to alias.\n");
      return 0;
   }
   if (filter[0] == '*' || filter[0] == '+') {
      add_failed_mess("Cannot start a regular expression with a '*' or '+', "                         "try: '.*' or '.+'.\n");
      return 0;
   }
   gfilter = "^" + filter;
   tmp = filter_array(tmp, (: $1 && regexp($1, $(gfilter)) :));
   ok = ({ });
   foreach (bing in tmp) {
      if (this_player()->remove_player_alias(bing)) {
         ok += ({ bing });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("Successfuly removed the aliases " +
            query_multiple_short(map(ok, (: "'" + $1 + "'" :))) + ".\n");
      return 1;
   }
   add_failed_mess("Unable to remove any of the aliases " +
            query_multiple_short(map(tmp, (: "'" + $1 + "'" :))) + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({
      "pattern <word'alias'>", (: unalias_pattern($4[0]) :),
      "<word'alias'>", (: unalias($4[0]) :),
         });
}

==================================================
FILE: player/unidentify.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
mixed cmd(object *indirect_obs)
{
   object *things;
   things = filter(indirect_obs, (: $1->query_identifier() :));
   if (!sizeof(things))  {
      if (sizeof(indirect_obs) > 1)
         write("You do not have any of those things identified.\n");
      else
         write("You do not have " + indirect_obs[0]->the_short() +
               " identified.\n");
   }
   else  {
      things->set_identifier(0);
      write("You stop identifying " + query_multiple_short(things, "one") +
            ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me'object(s)'>", (: cmd($1) :) });
}

==================================================
FILE: player/unignore.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#define TP this_player()
inherit "/cmds/base";
int cmd(string str) {
  string *ignoring;
  ignoring = TP->query_property("ignoring");
  if(!ignoring)
    ignoring = ({ });
  if(!str)
    return notify_fail("unignore who?\n");
  str = lower_case(TP->expand_nickname(str));
  if(str == "all") {
    TP->remove_property("ignoring");
    write("You are no longer ignoring anyone.\n");
    return 1;
  }
  if(member_array(str, ignoring) == -1) {
    write("You are not ignoring "+str+".\n");
    return 1;
  }
  ignoring = delete(ignoring, member_array(str, ignoring), 1);
  TP->add_property("ignoring", ignoring);
  write(str+" has been removed from your list of ignored players.\n");
  return 1;
}

==================================================
FILE: player/unkeep.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
int cmd( object *obs ) {
   object thing, *success;
   success = ({ });
   foreach (thing in obs)  {
      if (thing->query_keep())  {
         thing->reset_keep();
         success += ({ thing });
      }
   }
   if (!sizeof(success))  {
      write("You are not attempting to keep anything.\n");
   }
   else  {
      write("You will no longer attempt to keep " +
            query_multiple_short(success) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

==================================================
FILE: player/upt_ime.c
==================================================

#include <player.h>
inherit "/cmds/base";
mixed cmd(int brief) {
  mapping u;
  int r;
  string str;
  string output;
  str = "/secure/finger"->time_elapsed_string(uptime());
#ifndef __DISTRIBUTION_LIB__
  output = "A'Tuin has been paddling through space for "+
      str + ".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
  output += "  He (or as it may be, she) has been "
      "performing "+ query_load_average()+".";
#else
  output += mud_name() + " has been up for "+ str +
      ".  The load average is " +
      query_load_average()+".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
#endif
  u = rusage();
#ifndef __DISTRIBUTION_LIB__
  output += sprintf("  This has taken %.2f%% of his (or her) energy and %.2fMB "
                    "of his (or her) mental capacity.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#else
  output += sprintf("  This has taken %.2f%% of the cpu and %.2fMB of "
                    "of memory.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#endif
#ifndef __DISTRIBUTION_LIB__
  r = "/obj/handlers/garbage"->query_next_reboot();
  if (r == -1) {
    output += "It is unknown when he (or she) will be "
      "taking his (or her) next rest.";
  } else if (r < 0 || find_object(OFFLER)) {
    output += "He (or she) will be taking his (or her) next rest "
      "any moment now.";
  } else {
    str = "";
    if(r / (60*60*24)) {
      str += (string) (r / (60*60*24)) + " day";
      str += ((r /(60*60*24)) > 1 ? "s" : "");
    }
    if(r / ((60*60)) % 24) {
      if(str != "") {
        str += " and ";
      }
      str += (string)((r/(60*60))%24);
      str += " hour" + (((r/(60*60))%24) > 1 ? "s" : "");
    } else if(str == "") {
      switch(r/ 60) {
      case 0..7:
        str = "less than 15 minutes";
        break;
      case 8..22:
        str = "about a quarter of an hour";
        break;
      case 23..38:
        str = "about half an hour";
        break;
      case 39..53:
        str = "about three quarters of an hour";
        break;
      default:
        str = "just under an hour";
        break;
      }
    }
    output += "He (or she) will be taking his (or her) next rest "
      "in " + str + ".";
  }
#endif
  write(sprintf("%-=*s\n",
                  (int)this_player()->query_cols(), output));
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd(0) :),
             "{brief|verbose}", (: cmd($4[0] == "brief") :) });
}

==================================================
FILE: player/users.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>
int cmd() {
  int players, logins, login_q, first, creators, total;
  string output, *str, *logins_n;
  object pl;
  str = ({ });
  foreach(pl in users()) {
    if (pl->query_login_ob())
      logins++;
    else {
      str += ({ pl->query_cap_name() });
      if (pl->query_creator())
        creators++;
      else
        players++;
    }
  }
  logins_n = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
  logins_n = filter(logins_n, (: $1 :));
  logins_n = sort_array(logins_n,
                        (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (login_q > 0) {
    first = 0;
    if (login_q > 1)
      write(sprintf(login_q+" currently queued: %-=*s\n",
                    this_player()->query_cols()-17,
                    implode(logins_n[0..<2], ", ")+" and "+
                    logins_n[<1]));
    else
      write(sprintf("Currently Queued: %-=*s\n",
                    this_player()->query_cols()-19,
                    logins_n[0]));
  }
  output = "There ";
  first = 1;
  if (creators > 0) {
    if (first)
      if (creators == 1)
        output += "is ";
      else
        output += "are ";
    if (creators == 1)
      output += "one creator";
    else
      output += creators +" creators";
    first = 0;
    if (logins - login_q > 0)
      output += ", ";
    else
      if ( !players )
        output += " logged on.\n";
      else
        output += " and ";
  }
  if (logins - login_q > 0) {
    if (first)
      if (logins - login_q == 1)
        output += "is ";
      else
        output += "are ";
    if (logins - login_q == 1)
      output += "one person logging in";
    else
      output += ( logins - login_q ) +" people logging in";
    first = 0;
    if ( !players )
      output += ".\n";
    else
      output += " and ";
  }
  if ( players ) {
    if (first)
      if (players == 1)
        output += "is ";
      else
        output += "are ";
    if (players == 1)
      output += "one player ";
    else
      output += players +" players ";
  }
  total = sizeof(users());
  output += "a total of "+ sizeof(users()) + " people logged on.\n";
  write( output );
  str = filter(str, (: $1 :));
  str = sort_array(str, (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (sizeof(str) > 1) {
    this_player()->more_string(sprintf("Currently logged on: %-=*s\n",
                  this_player()->query_cols()-24,
                  implode(str[0..<2], ", ")+" and "+
                  str[<1]), "Who", 1 );
  } else {
    write("Currently logged on: "+str[0]+".\n");
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/verbose.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(string which, string type) {
  string t, disp;
  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types()) {
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    }
    write(disp + "\n");
    return 1;
  }
  if(type == "all") {
    foreach(t in TP->query_verbose_types()) {
      TP->set_verbose(t, which == "verbose");
    }
    write("Ok\n");
    return 1;
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
    return 1;
  } else {
    write("No such option.\n");
    return 1;
  }
}
mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("verbose", $4[0]) :),
            "", (: cmd("verbose", 0) :),
         });
}

==================================================
FILE: player/weigh.c
==================================================

#define MAX_OBJECTS_AT_ONCE   5
string weight_string(int number);
int cmd(object *things, int brief);
string weight_string(int number) {
   number = (number + 4) / 9;
   switch (number) {
      case 0:
         return "uh oh";
      case 1:
         return "half a pound";
      case 2:
         return "a pound";
      case 3:
         return "a pound and a half";
      case 4 .. 14 :
         return query_num((number + 1) / 2) + " pounds";
      case 15 .. 24:
         return "ten pounds";
      case 25 .. 34:
         return "fifteen pounds";
      case 35 .. 149:
         return query_num(((number + 10) / 20) * 10) + " pounds";
      case 150 .. 249:
         return "a hundred pounds";
      case 250 .. 349:
         return "a hundred and fifty pounds";
      case 350 .. 1499:
         return query_num(((number + 100) / 200) * 100) + " pounds";
      case 1500 .. 2499:
         return "a thousand pounds";
      case 2500 .. 2499:
         return "fifteen hundred pounds";
      case 3500 .. 14999:
         return query_num(((number + 1000) / 2000) * 1000) + " pounds";
      case 15000 .. 24999:
         return "ten thousand pounds";
      case 25000 .. 34999:
         return "fifteen thousand pounds";
      default:
         return query_num(((number + 10000) / 20000) * 10000) + " pounds";
   }
}
int cmd(object *things, int brief) {
   int     accuracy;
   int     weight;
   int     total = 0;
   string  results;
   object  thing;
   object *worn;
   object *wearing;
   if (sizeof(things) > MAX_OBJECTS_AT_ONCE)
   {
      return notify_fail("You cannot weigh that many things at once.\n");
   }
   accuracy = 9 + 89 / (1 + this_player()->query_dex());
   results = "";
   wearing = this_player()->query_wearing();
   worn = filter(things, (: member_array($1, $(wearing)) > -1 :));
   things -= worn;
   if (brief)  {
      foreach (thing in things)
         total += thing->query_complete_weight();
   }
   else foreach (thing in things)  {
      results += "You heft " + thing->the_short() +
                 " and guess that " +
        (thing->group_object() ? "they weigh " :
         thing->query_pronoun() + " weighs ");
      weight = thing->query_complete_weight();
      total += weight;
      if (4 * weight > accuracy)  {
         weight = (4 * weight + accuracy) / (2 * accuracy);
         results += "about " + weight_string(weight * accuracy) + ".\n";
      }
      else  {
         results += "less than " + weight_string(accuracy)+ ".\n";
      }
   }
   if (sizeof(worn))  {
      write("You are wearing " + query_multiple_short(worn, "the") +
             ".\n");
   }
   if (sizeof(things))  {
      if (!brief)  {
         write(results);
      }
      if (sizeof(things) > 1  ||  brief)  {
         if (4 * total > accuracy)  {
             total = (4 * total + accuracy) / (2 * accuracy);
             printf("The total weight is about " +
                    weight_string(total * accuracy) + ".\n");
         }
         else  {
             printf("The total weight is less than " +
                    weight_string(accuracy) + ".\n");
         }
      }
      tell_room(environment(this_player()),
                this_player()->one_short() + " hefts " +
                query_multiple_short(things) + (sizeof(things) > 1 ?
                " one at a time to see how much they weigh" :
                " to see how much it weighs" ) + ".\n",
                ({ this_player() }));
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me'item(s)'>", (: cmd($1, 0) :),
             "<indirect:object:me'item(s)'> brief", (: cmd($1, 1) :) });
}

==================================================
FILE: player/wet.c
==================================================

inherit "/cmds/base";
#include <dirs.h>
#define THRESHOLDS ({ 10, 30, 200, 300 })
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define BODY_WET_EFFECT "/std/effects/other/wetness"
mixed cmd(object *things) {
   string results;
   string no_wet_results;
   object thing;
   object* not_wet;
   string wet_mess;
   if (!things) {
      things = all_inventory(this_player()) + ({ this_player() });
   }
   results = "";
   not_wet = ({ });
   no_wet_results = "";
   foreach (thing in things) {
      wet_mess = OBJECT_WET_EFFECT->wet_string(thing);
      if (strlen(wet_mess)) {
         if (thing == this_player()) {
            wet_mess = "are " + wet_mess;
         } else {
            wet_mess = "is " + wet_mess;
         }
      } else {
         wet_mess = BODY_WET_EFFECT->wet_string(thing, thing == this_player());
      }
      if (strlen(wet_mess)) {
         results += "$C$" + thing->the_short(1) + " " + wet_mess + ".\n";
      } else {
         not_wet += ({ thing });
      }
   }
   if (results == "") {
      write(query_multiple_short(not_wet) +
            ((sizeof(not_wet) > 1  ||  not_wet[0] == this_player()) ?
               " are ":" is ") + "not wet.\n");
   } else {
      write(results);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/when.c
==================================================

#include <login.h>
inherit "/cmds/base";
int cmd(string who)   {
   object player;
   int last;
   int caller;
   string* bits;
   string womble;
   int bing;
   bits = explode(who, ",");
   if (sizeof(bits) > 1) {
      bing = 0;
      foreach (womble in bits) {
         if (cmd(womble)) {
            bing = 1;
         }
      }
      return bing;
   }
   caller = this_player()->query_invis();
   who = this_player()->expand_nickname(lower_case(who));
   player = find_player( who );
   if (player &&
       (caller >= player->query_invis() ||
        reference_allowed(player, this_player()))) {
      if ( interactive( player ) ) {
         write( who + " has been on for " +
                   query_time_string(time() - player->query_last_log_on(), -1) +
                   ".\n");
      } else {
         write( who + " is currently net-dead.\n" );
      }
      return 1;
   } else {
      last = PLAYER_HANDLER->test_last(who);
      if ( last < 1 ) {
         return notify_fail( "Cannot find any record of $C$" + who + ".\n" );
      } else   {
         if (time() - last < 30) {
            write(who + " only just logged off.\n");
         } else {
            write(who + " last logged off " +
                  query_time_string(time() - last, -1) +
                  " ago.\n");
         }
         return 1;
      }
   }
}
mixed *query_patterns()   {
   return ({ "<string'player name'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/who.c
==================================================

#include <clubs.h>
#include <playtesters.h>
#include <config.h>
inherit "/cmds/base";
#include <player.h>
string who_string(int width, int cre, int verbose, string name);
string who_line(object ob, int cre, int width);
mapping _nationalities;
void create() {
  string file;
  object ob;
  ::create();
  _nationalities = ([ ]);
  foreach(file in get_dir("/std/nationality
object *filter_users(object *tarr, string name, int no_cres)  {
  string *guilds;
  string guild;
  string start_guild;
  string *domains;
  object *ret_arr;
  object *arr;
  int not_tag;
  name = lower_case(name);
  name = replace(name, ({"assassins", "assassin",
                           "priests", "priest",
                           "thieves",   "thief",
                           "warriors",    "warrior",
                           "witches",   "witch",
                           "wizards",     "wizard",
                           "creators",  "creator",
                           "liaisons", "liaison",
                           "adventurers", "adventurer",
                           "fighters", "warrior",
                           "fighter", "warrior",
                           "killers", "killer",
                           "helpers", "helper",
                           "playtesters", "playtester",
                           "friends", "friend",
                           "families", "family" }));
  guilds = explode(name, "&") - ({ "" });
  if (sizeof(guilds) > 1) {
    arr = filter_users(tarr, guilds[0], no_cres);
    foreach (guild in guilds[1..]) {
      arr &= filter_users(tarr, guild, no_cres);
    }
    return arr;
  }
  guilds = explode(name, ",") - ({ "", 0 });
  domains = "/secure/master"->query_domains();
  ret_arr = ({ });
  foreach (guild in guilds)  {
    start_guild = guild;
    guild = replace(guild, " ", "", "\t", "");
    if (guild[0] == '-') {
       not_tag = 1;
       guild = guild[1..];
    } else {
       not_tag = 0;
    }
    arr = ({ });
    if (guild == "adventurer")  {
      arr += filter(tarr, (: !$1->query_guild_ob()  &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "friend")  {
      arr += filter(tarr, (: !$1->query_login_ob() && this_player()->is_friend($1->query_name()) :));
    } else if (guild == "creator")  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           $1->query_visible(this_player()) :) );
    } else if (guild == "helper") {
      arr += filter( tarr, (: !$1->query_creator() &&
                            $1->query_property( "newbie helper" ) :) );
    } else if (guild == "killer") {
      arr += filter(tarr, (: $1->query_player_killer() &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "family") {
      arr += filter(tarr, (: $1->query_family_name() :));
    } else if (guild == "playtester") {
      arr += filter(tarr,
                    (: PLAYTESTER_HAND->query_playtester($1->query_name()) :));
    } else if (member_array(guild, domains) > -1)  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           ("/d/"+$(guild)+"/master")->query_member($1->query_name())  &&
                           $1->query_visible(this_player()) :));
    } else if(member_array(guild, keys(_nationalities)) > -1) {
      arr += filter(tarr, (: $1->query_nationality() == $2 :),
                    _nationalities[guild]);
    } else  {
      if (file_size("/std/guilds/" + guild + ".c") > 0)  {
        arr += filter(tarr,
                      (: (!$(no_cres) || !$1->query_creator()) &&
                       stringp($1->query_guild_ob()) &&
                       $1->query_guild_ob() == "/std/guilds/" + $(guild) :));
      } else if (CLUB_HANDLER->is_family(start_guild)) {
        arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1) :));
      } else if (CLUB_HANDLER->is_club(start_guild)) {
        if (!CLUB_HANDLER->query_club_secret(start_guild) ||
            CLUB_HANDLER->is_member_of(start_guild, this_player()->query_name())) {
          arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1->query_name()) :));
        }
      } else {
        arr += filter(tarr, (: $1->query_deity() == $2 &&
                             (!$(no_cres) || !$1->query_creator()) :),
                      guild);
      }
    }
    if (not_tag) {
       ret_arr |= (tarr - arr);
    } else {
       ret_arr |= arr;
    }
  }
  return ret_arr;
}
int cmd(string str, int verbose)  {
  this_player()->more_string( who_string(this_player()->query_cols(),
                                         this_player()->query_creator(),
                                         verbose,
                                         str),
                              "Who", 1 );
  return 1;
}
string who_string(int width, int cre, int verbose, string name) {
  object *arr;
  int number;
  string tmp;
  string tmp2;
  string prt;
  int x;
  if (name == "here") {
    arr = filter(all_inventory(environment(this_player())), (: userp($1) &&
                                                             $1->query_visible(this_player()) :) );
  } else {
    arr = filter(users(), (: strsrch(file_name($1), "secure/login") == -1 :));
    if (name && sizeof(arr))  {
      arr = filter_users(arr, name, 1);
    }
  }
  number = sizeof(arr);
  if (number == 0)  {
    if (name)  {
      return "There are no guild(s) or members of " + name + " online.\n";
    }
    return "There is no one on " + mud_name() + "?\n";
  }
  prt = sprintf("%|*'-'s\n", width-1, "==========]  " + mud_name() + "  [===========");
  arr = sort_array(arr, (: strcmp($1->query_name(), $2->query_name() ) :) );
  tmp2 = "";
  if(!name && verbose == 0) {
    int i;
#ifndef __DISTRIBUTION_LIB__
    arr = filter_array(arr, (: !$1->query_creator() ||
                             "/d/liaison/master"->query_member($1->query_name()) :) );
#endif
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = (string)arr[i]->query_cap_name();
      if(!tmp) {
        --number;
      } else {
        x = 14;
        if (arr[i]->query_creator()) {
          if ("/secure/master"->query_trustee(arr[i]->query_name())) {
            tmp += " (%^RED%^T";
          } else if("/secure/master"->query_director(arr[i]->query_name())){
            tmp += " (%^RED%^D";
          } else if("/secure/master"->query_senior(arr[i]->query_name())){
            tmp += " (%^RED%^S";
          } else  {
            tmp += " (%^RED%^C";
          }
          x += 16;
          if ( "/d/liaison/master"->query_member(arr[i]->query_name())) {
            tmp += "%^YELLOW%^l";
            x += 10;
          }
          if(this_player()->is_friend(arr[i]->query_name())) {
            tmp += "%^GREEN%^F";
            x += 9;
          }
          tmp += "%^RESET%^)";
        } else if(this_player()->is_friend(arr[i]->query_name())) {
          tmp += " (%^GREEN%^F%^RESET%^)";
          x += 18;
        }
        tmp2 += sprintf("%-" + x + "s ", tmp);
        if((i+1) % (width/15) == 0  && tmp2 != "") {
          prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
          tmp2 = "";
        }
      }
    }
    prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
  } else {
    int i;
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = who_line(arr[i], cre, width);
      if ( !tmp )  {
        --number;
      } else  {
        prt += this_player()->fix_string(tmp + "\n", width, 10);
      }
    }
  }
  if ( name == "here" )  {
    if (number == 1)
      tmp = "> You are all by yourself. <";
    else
      tmp = "> There are " + query_num(number, 500) + " people here. <";
  } else if ( name )  {
    tmp = "> There " + (number > 1 ? "are " : "is ") +
      query_num(number, 500) +
      (number > 1 ? " members of" : " member of");
    if (strsrch(name, ",") != -1) {
      tmp += " those guilds on the " + mud_name() + ". <";
    } else {
      tmp += " this guild on the " + mud_name() + ". <";
    }
  } else if (number < 2)  {
    tmp = "> You are all alone on the " + mud_name() + ". <";
  } else  {
    tmp = "> There are " + query_num(number, 500) +
      " mudders on the " + mud_name() + ". <";
  }
  prt += sprintf("%*'-'|s\n", width-1, tmp);
  return prt;
}
string who_line(object ob, int cre, int width)  {
  string s;
  string tmp;
  tmp = ob->query_player_title();
  if (tmp) {
    tmp += " ";
  } else {
    tmp = "";
  }
  s = tmp + ob->query_cap_name();
  if ( !s )  {
    return 0;
  }
  tmp = ob->query_family_name();
  if (tmp) {
    s += " " + tmp;
  }
  if ( "/d/liaison/master"->query_member( (string)ob->query_name() ) )  {
    s += " (%^YELLOW%^Liaison%^RESET%^)";
  }
  if (ob->query_creator()) {
    if ("/secure/master"->query_trustee((string)ob->query_name()))  {
      s += " (%^RED%^Trustee%^RESET%^)";
    } else if("/secure/master"->query_director((string)ob->query_name())){
      s += " (%^RED%^Director%^RESET%^)";
    } else if("/secure/master"->query_senior((string)ob->query_name())) {
      s += " (%^RED%^Senior%^RESET%^)";
    } else  {
      s += " (%^RED%^Creator%^RESET%^)";
    }
    if (ob->query_invis() == 1) {
      s += " (Invisible)";
    } if (ob->query_invis() > 1) {
      s += " (Super Invisible)";
    }
  }
  if (cre)  {
    if ((tmp = (string)ob->query_in_editor()))  {
      s += " (editing: " + tmp + ")";
    }
  }
  if (ob->query_property("guest"))  {
    s += " guest of " + mud_name() + "";
  } else if (tmp = (string)ob->query_gtitle())  {
    s += " " + tmp;
  } else  {
    s += " the Adventurer";
  }
  if (tmp = (string)ob->query_property("player_title"))  {
    s += ", " + tmp;
  }
  tmp = (string)ob->query_title();
  if ( tmp && ( tmp != "" ) )  {
    s += ", " + tmp;
  }
  if ( PLAYTESTER_HAND->query_playtester( ob->query_name() ) ) {
    if ( PLAYTESTER_HAND->query_senior_playtester( ob->query_name() ) ) {
      s += ", (%^BOLD%^%^CYAN%^Senior Playtester%^RESET%^)";
    }
    else {
      s += ", (%^CYAN%^Playtester%^RESET%^)";
    }
  }
  if (interactive(ob))  {
    if (query_idle(ob) > 120)  {
      s += " (Idle: " + (query_idle(ob) / 60) + ")";
    }
  }
  return s + "%^RESET%^";
}
mixed *query_patterns() {
  return ({ "", (: cmd(0, 0) :),
              "verbose", (: cmd(0, 1) :),
              "here", (: cmd("here", 1) :),
              "<string'guild|liaisons|creators|killers|helpers|playtesters|friends|families|nationality'>", (: cmd( $4[0], 0 ) :) });
}

==================================================
FILE: player/whoami.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd() {
  write( "You are "+ (string)( DIR_PLAYER_CMDS +"/who" )->
         who_line(this_player(), this_player()->query_creator(),
                  this_player()->query_cols(), 1) +".\n" );
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/whois.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd(object *obs) {
  write("That is " + (string)(DIR_PLAYER_CMDS +"/who")->
        who_line(this_player()->expand_nickname(obs[0]),
                 this_player()->query_creator(),
                 this_player()->query_cols()) +".\n" );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1) :),
            this_player()->query_name(), (: cmd(({this_player()})) :) });
}

==================================================
FILE: player/xyzzy.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd() {
   write("Nothing happens.\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/group_cmds/assist.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_assist( object member, string group );
int do_unassist( object member, string group );
int do_assist_list(string group);
void create() {
   ::create();
   add_group_sub_command( "assist", "<indirect:living'member'>",
      (: do_assist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "unassist", "<indirect:distant-living'member'>",
      (: do_unassist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "assist", "list",
      (: do_assist_list( $6 ) :) );
   set_membership_required( "assist", 0, 1 );
}
int do_assist_list( string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( sizeof( assisting ) )
   {
      tell_object( this_player(), "You are currently "
         "assisting " + query_multiple_short( assisting ) +
         ".\n" );
      return 1;
   }
   add_failed_mess("You are not assisting anyone.\n");
   return 0;
}
int do_assist( object member, string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( !GROUP->is_member( group, member ) ) {
      add_failed_mess( member->the_short() + " is not a "
         "member of your group.\n" );
      return 0;
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      add_failed_mess( "You are already assisting " + member->the_short() +
         ".\n" );
      return 0;
   }
   if( sizeof( assisting ) >= MAX_PEOPLE_YOU_CAN_ASSIST ) {
      add_failed_mess( "You can not assist any more people.\n" );
      return 0;
   }
   add_succeeded_mess( "$N begin$s keeping a close eye on $I.\n",
                       ({ member }) );
   member->add_assister( this_player() );
   return 1;
}
int do_unassist( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      member->remove_assister( this_player() );
      add_succeeded_mess( ({ "You stop assisting " + member->the_short() +
         ".\n", "" }) );
      return 1;
   }
   add_failed_mess("You are not assisting $I.\n", ({ member }));
   return 0;
}
string query_help_string_for( string sub ) {
   return "With this command you can guard a group member.  If the "
      "person you're guarding gets attacked, you will automatically "
      "join the fight after a delay.  The length of the delay depends "
      "on how many people you're guarding at the moment.  Use "
      "\"list\" to see who you are currently assisting.  To stop "
      "assisting someone, use \"group assist <someone>\" again "
      "on that person.\n";
}

==================================================
FILE: player/group_cmds/base_group.c
==================================================

#define GROUP_ARRAY_SIZE      3
#define GROUP_ARRAY_FUNCTION  0
#define GROUP_ARRAY_MEM_REQ   1
#define GROUP_ARRAY_LDR_REQ   2
mapping _commands;
void create() {
   _commands = ([ ]);
}
int query_group_sub_command_amount() {
   return sizeof( _commands );
}
int add_group_sub_command( string verb, string pattern,
   function cmd_function ) {
   if( !_commands[ verb ] ) {
      _commands += ([ verb : ([ pattern : ({ cmd_function, 0, 0 }) ]) ]);
      return 1;
   }
   if( _commands[ verb ][ pattern ] ) {
      return 0;
   }
   _commands[ verb ] += ([ pattern : ({ cmd_function, 0, 0 }) ]);
   return 1;
}
varargs int remove_group_sub_command( string verb, string pattern ) {
   if( undefinedp( pattern ) ) {
      if( !_commands[ verb ] ) {
         return 0;
      }
      map_delete( _commands, verb );
      return 1;
   }
   if( !_commands[ verb ] || !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   map_delete( _commands[ verb ], pattern );
   return 1;
}
string *query_group_sub_command_verbs() {
   return keys( _commands );
}
string *query_group_sub_command_patterns( string verb ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   return keys( _commands[ verb ] );
}
varargs function *query_group_sub_command_function( string verb, string
   pattern ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( undefinedp( pattern ) ) {
      return values( _commands[ verb ] );
   }
   if( !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_FUNCTION ];
}
int set_membership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_MEM_REQ ] = flag;
   }
   return 1;
}
int set_leadership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_LDR_REQ ] = flag;
   }
   return 1;
}
varargs int query_membership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_MEM_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ];
}
varargs int query_leadership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_LDR_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ];
}

==================================================
FILE: player/group_cmds/create.c
==================================================

#include <group_handler.h>
#include <player_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_create( string name );
void create() {
   ::create();
   add_group_sub_command( "create", "<string'name'>", (: do_create( $4[ 0 ] ) :) );
}
int do_create( string name ) {
   string short;
   name = strip_colours(name);
   if( this_player()->query_group() ) {
      return notify_fail( "You are already a member of " +
         this_player()->query_group() + ".\n" );
   }
   if( GROUP->is_group( name ) ) {
      return notify_fail( "Such a group already exists.\n" );
   }
   short = name;
   name = GROUP->short_to_name( short );
   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }
   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }
   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   if( !GROUP->create_group( name, this_player() ) ) {
      return notify_fail( "You failed to create the group.\n" );
   }
   GROUP->set_group_short( name, short );
   this_player()->add_succeeded_mess( this_object(), "$N begin$s "
      "an adventuring group.\n" );
   GROUP->add_member( name, this_player() );
   GROUP->set_leader( name, this_player() );
   return 1;
}
string query_help_string_for( string sub_command ) {
   if( sub_command != "create" ) {
      return 0;
   }
   return "This sub-command creates a new group and sets you as the "
      "leader of it.  You create it by typing \"group create <name>\" "
      "with <name> being the name of your group.";
}

==================================================
FILE: player/group_cmds/emote.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_emote( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "emote", "<string'message'>",
      (: do_group_emote( $4[ 0 ], $6 ) :) );
   set_membership_required( "emote", 0, 1 );
}
int do_group_emote( string message, string group ) {
   message = replace( message, ({ "%^", "", }) );
   GROUP->notify_group( group, this_player(), ({
      "You emote: " + this_player()->query_cap_name() + " " + message,
      this_player()->query_cap_name() + " " + message
      }) );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to emote on the group "
      "channel.";
}

==================================================
FILE: player/group_cmds/follow.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_follow( object *who, string group, int unfollow );
void create() {
   ::create();
   add_group_sub_command( "follow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 0 ) :) );
   add_group_sub_command( "unfollow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 1 ) :) );
   set_membership_required( "follow", 0, 1 );
   set_membership_required( "unfollow", 0, 1 );
}
int do_group_follow( object *who, string group, int unfollow ) {
   int size;
   string fault_message;
   object *what_not, *follow, *already_following;
   fault_message = "";
   who -= ({ 0 });
   if( member_array( this_player(), who ) != -1 ) {
      who -= ({ this_player() });
      fault_message += "You cannot follow yourself.  ";
   }
   follow = ( who & GROUP->members_of( group ) );
   what_not = who - follow;
   switch( unfollow ) {
      case 1:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) == -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are not following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      case 0:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) != -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are already following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      default:
         printf( "Barf.\n" );
   }
   size = sizeof( what_not );
   if( size ) {
      fault_message += "$C$" + query_multiple_short( what_not, "the" ) +
         ( size > 1 ? " are not members of your group" :
         " is not a member of your group" ) + ".  ";
   }
   fault_message += "\n";
   if( sizeof( follow ) ) {
      GROUP->handle_group_follow( group, this_player(), follow,
         unfollow, 0 );
      return 1;
   } else {
      tell_object( this_player(), fault_message );
      return 1;
   }
}
string query_help_string_for( string sub ) {
   switch( sub ) {
      case "follow":
         return "This command lets you follow your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
      case "unfollow":
         return "This command lets you stop following your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
   }
   return 0;
}

==================================================
FILE: player/group_cmds/history.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_channel_history();
void create() {
   ::create();
   add_group_sub_command( "history", "", (: do_channel_history() :) );
   set_membership_required( "history", 0, 1 );
}
int do_channel_history() {
   this_player()->display_group_history();
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you recap what has been said on your "
      "group's channel.";
}

==================================================
FILE: player/group_cmds/invite.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_invite( object person, string group );
void create() {
   ::create();
   add_group_sub_command( "invite", "<indirect:living'person'>", (:
      do_invite( $1, $6 ) :) );
   set_membership_required( "invite", 0, 1 );
   set_leadership_required( "invite", 0, 1 );
}
int do_invite( object *persons, string group ) {
   object person;
   persons -= ({ this_player() });
   if( !sizeof( persons ) ) {
      return notify_fail( "I would come up with "
         "something witty, but I'm not going to "
         "bother.\n" );
   }
   if( sizeof( persons ) > 1 ) {
      return notify_fail( "You can only invite one person "
         "at a time.\n" );
   }
   person = persons[ 0 ];
   if( sizeof( GROUP->invitations_of( group ) ) >=
      MAX_INVITATIONS_PER_PARTY_AT_ONCE ) {
      return notify_fail( "You can only have a total of " +
         MAX_INVITATIONS_PER_PARTY_AT_ONCE + " invitations pending "
         "at one time.\n" );
   }
   if( GROUP->is_invited( group, person ) ) {
      return notify_fail( person->the_short() + " has "
         "already been invited to your group.\n" );
   }
   if( GROUP->is_member( group, person ) ) {
      return notify_fail( person->the_short() + " is "
         "already a member of your group.\n" );
   }
   if( !userp( person ) ) {
      return notify_fail( "You cannot invite " + person->the_short() +
         " to your group.\n" );
   }
   GROUP->add_invite( group, person );
   GROUP->notify_group( group, this_player(), person->query_cap_name() +
      " has been invited by " + this_player()->query_cap_name() + ".  " );
   tell_object( person, "You have been invited by " +
      this_player()->a_short() + " to join " +
      this_player()->query_possessive() + " group.  "
      "You have " + INVITE_TIMEOUT + " seconds to join "
      "the group before the invitation is withdrawn.  Use "
      "\"group join " + this_player()->query_name() + "\" "
      "to join.\n" );
   if( person->query_group() ) {
      tell_object( person, "%^BOLD%^Note that accepting the invitation "
         "will force you to leave your current group.%^RESET%^\n" );
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "With this command the leader of a group can invite new "
      "members to the group.  A person who has been invited must then "
      "use the \"join\" command to actually become a member.";
}

==================================================
FILE: player/group_cmds/join.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_join( object member );
void create() {
   ::create();
   add_group_sub_command( "join", "<indirect:living'existing member'>",
      (: do_join( $1[ 0 ] ) :) );
}
int do_join( object member ) {
   string his_group, my_group;
   his_group = member->query_group();
   if( this_player() == member ) {
      return notify_fail( "I could come up with something witty, "
         "but I'm not going to bother.\n" );
   }
   if( !his_group ) {
      return notify_fail( member->the_short() + " is not a member "
         "of any group.\n" );
   }
   if( !GROUP->is_invited( his_group, this_player() ) ) {
      return notify_fail( "You have not been invited to that "
         "group.\n" );
   }
   if( sizeof( GROUP->members_of( his_group ) ) >= MAX_PEOPLE_PER_PARTY ) {
      return notify_fail( "The group you are trying to join is "
         "full.\n" );
   }
   my_group = this_player()->query_group();
   if( my_group && ( my_group == his_group ) ) {
      return notify_fail( "You are already a member of "
         "that group.\n" );
   }
   if( my_group ) {
      if( !GROUP->remove_member( my_group, this_player() ) ) {
         return notify_fail( "You fail to leave your previous "
            "group.. for some reason.\n" );
      }
      tell_object( this_player(), "%^BOLD%^You leave your current "
         "group behind to join a new one.%^RESET%^\n" );
   }
   if( !GROUP->add_member( his_group, this_player() ) ) {
      return notify_fail( "You failed to join the group "
         "for some weird reason.\n" );
   }
   return 1;
}
string query_help_string_for( string sub_command ) {
   switch( sub_command ) {
      case "join":
         return "This command lets you join an existing group.  To join, "
            "type \"group join <existing member>\" where "
            "<existing member> is someone who is already a member of the "
            "group you wish to be a part of.  You must be invited to a "
            "group by its leader before you can join.";
      default:
         return 0;
   }
}

==================================================
FILE: player/group_cmds/kick.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_kick_member( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "kick", "<indirect:any-living'member'>",
      (: do_kick_member( $1[ 0 ], $6 ) :) );
   set_membership_required( "kick", 0, 1 );
   set_leadership_required( "kick", 0, 1 );
}
int do_kick_member( object member, string group ) {
   if( this_player() == member ) {
      this_player()->new_parser(
         "skick " + this_player()->query_name() );
      return 1;
   }
   if( !GROUP->is_member( group, member ) ) {
      return notify_fail( member->the_short() + " is not a member "
         "of your group.\n" );
   }
   GROUP->notify_group( group, this_player(), ({
      "You kick " + member->query_cap_name() + " from your ranks.",
      this_player()->query_cap_name() + " has kicked " +
      member->the_short() + " from the group." }) );
   GROUP->remove_member( group, member );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you boot out offending members in "
      "your group.";
}

==================================================
FILE: player/group_cmds/leader.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_leader( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "leader", "<indirect:any-living'member'>",
      (: do_leader( $1[ 0 ], $6 ) :) );
   set_membership_required( "leader", 0, 1 );
   set_leadership_required( "leader", 0, 1 );
}
int do_leader( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Oh, good thinking, sparky.\n" );
   }
   if( member->query_group() != group ) {
      return notify_fail( member->the_short(1) + " is not in your "
         "group.\n" );
   }
   GROUP->set_leader( group, member, this_player() );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to relinquish command and "
      "appoint a new leader for the group.  It does not remove "
      "your membership of the group, but you lose all special "
      "privileges granted to leaders.";
}

==================================================
FILE: player/group_cmds/leave.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_leave( string group );
void create() {
   ::create();
   add_group_sub_command( "leave", "", (: do_leave( $6 ) :) );
   set_membership_required( "leave", 0, 1 );
}
int do_leave( string group ) {
   if( !GROUP->remove_member( this_player()->query_group(),
      this_player() ) ) {
      return notify_fail( "You failed to leave the group "
         "for some odd-ball reason.\n" );
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to leave your current "
      "group.  If you're the leader, a new one will be "
      "chosen at random from the remaining members.";
}

==================================================
FILE: player/group_cmds/list.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
string *leader_adjectives =
   ({
      "daring",
      "heroic",
      "brave",
      "bold",
      "courageous",
      "dauntless",
      "fearless",
      "intrepid",
      "valiant",
      "awesome",
      "stalwart"
   });
string *follower_messages =
   ({
      " and also includes",
      " and features such prominent figures as",
      ", whose supporters consist of",
      " and features such renowned names as",
   });
int do_list_groups(string person);
void create() {
   ::create();
   add_group_sub_command( "list", "", (: do_list_groups(0) :) );
   add_group_sub_command( "list", "[with] <string'player'>",
                           (: do_list_groups($4[0]) :) );
}
int do_list_groups(string person) {
   string group, *groups, prefix, suffix, message, adjective, colour, stats;
   object *members, leader;
   int num_groups, num_members;
   object person_ob;
   groups = sort_array( GROUP->query_groups(),
       (: strcmp( lower_case(GROUP->query_group_short( $1 )),
            lower_case(GROUP->query_group_short( $2 )) ) :) );
   num_groups = sizeof( groups );
   if (person) {
      person = this_player()->expand_nickname(person);
      person_ob = find_player(person);
      if (!person_ob) {
         add_failed_mess("Sorry, " + person + " is not logged on.\n");
         return 0;
      }
   }
   if( !num_groups )
   {
      return notify_fail( "There are currently no active groups.\n" );
   }
   prefix = "$I$+8,+0=  + ";
   suffix = "$I$-8,-0=\n";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   message = "";
   num_members = 0;
   num_groups = 0;
   foreach( group in groups )
   {
      leader = GROUP->leader_of( group );
      members = GROUP->members_of( group );
      if( !leader || !sizeof( members ) )
      {
         continue;
      }
      if (!person_ob || person_ob == leader ||
          member_array(person_ob, members) != -1) {
         num_members += sizeof( members );
         message += prefix;
         message += colour + GROUP->query_group_short( group ) +
            "%^RESET%^ is led by ";
         members -= ({ leader });
         adjective = leader_adjectives[ random( sizeof(
                                                       leader_adjectives ) ) ];
         message += "the " + adjective + " %^BOLD%^" +
            leader->query_short(1) + "%^RESET%^";
         if( sizeof( members ) )
         {
            message += follower_messages[ random( sizeof( follower_messages )
               ) ] + " %^BOLD%^" + query_multiple_short( members->short(1) ) +
               "%^RESET%^.";
         }
         else
         {
            message += " and has no other members.";
         }
         message += suffix;
         num_groups++;
      }
   }
   switch( num_groups )
   {
      case 0:
         if (!person) {
            stats = "There are currently no groups, ";
         } else {
            add_failed_mess("There are no groups with " + person +
                            " in them.\n");
            return 0;
         }
         break;
      case 1:
         stats = "There is currently %^BOLD%^one%^RESET%^ active group, ";
         break;
      default:
         stats = "There are currently %^BOLD%^" + query_num( num_groups ) +
            "%^RESET%^ active groups, ";
         break;
   }
   stats += "with a total number of %^BOLD%^" +
      query_num( num_members ) + "%^RESET%^ persons:\n";
   tell_object( this_player(), stats + message );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you list all currently active "
      "groups and their members and leaders.";
}

==================================================
FILE: player/group_cmds/rename.c
==================================================

#include <group_handler.h>
#include <player_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_rename_group( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "rename", "<string'new name'>",
      (: do_rename_group( $4[ 0 ], $6 ) :) );
   set_membership_required( "rename", 0, 1 );
   set_leadership_required( "rename", 0, 1 );
}
int do_rename_group( string new_group, string group ) {
   string short;
   string name;
   if( GROUP->is_group( new_group ) ) {
      return notify_fail( new_group + " already exists.\n");
   }
   short = new_group;
   name = GROUP->short_to_name( short );
   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }
   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }
   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   if (!GROUP->rename_group( group, name)) {
      add_failed_mess("Not allowed to rename the group.\n");
      return 0;
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you rename a group to something more "
          "exciting.";
}

==================================================
FILE: player/group_cmds/report.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
#define GROUP_CMD_STATUS  ( GROUP_SUB_CMDS_DIR+"status" )
int do_report( string group );
void create() {
   ::create();
   add_group_sub_command( "report", "", (: do_report( $6 ) :) );
   set_membership_required( "report", 0, 1 );
}
int do_report( string group ) {
   string message;
   message = this_player()->query_cap_name() + " reports that " +
      this_player()->query_pronoun() + " is ";
   message += GROUP_CMD_STATUS->generate_status_message( this_player() );
   GROUP->notify_group( group, this_player(), ({
      "You report:  " + message,
      message
      }) );
   return 1;
}
string query_help_string_for( string sub_command ) {
   return "This command lets you report your current "
      "condition on the group's channel.";
}

==================================================
FILE: player/group_cmds/say.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_say( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "say", "<string'message'>",
      (: do_group_say( $4[ 0 ], $6 ) :) );
   set_membership_required( "say", 0, 1 );
}
int do_group_say( string message, string group ) {
   message = replace( message, ({ "%^", "" }) );
   GROUP->notify_group( group, this_player(),
      this_player()->query_cap_name() + ": " + message );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to say something on "
      "the group's channel.";
}

==================================================
FILE: player/group_cmds/shields.c
==================================================

#include <command.h>
#include <group_handler.h>
#define CMD_SHIELDS ( DIR_PLAYER_CMDS "/shields" )
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_shields( object *members, string group );
void create()
{
   ::create();
   add_group_sub_command( "shields", "", (: do_shields( 0, $6 ) :) );
   add_group_sub_command( "shields", "<indirect:any-living'member'>",
      (: do_shields( $1, $6 ) :) );
   set_membership_required( "shields", 0, 1 );
}
int do_shields( object *suggested_members, string group )
{
   object cmd_shields, member, *members, *check_for;
   string shields, mess, colour;
   cmd_shields = load_object( CMD_SHIELDS );
   if( !cmd_shields )
   {
      return notify_fail( "Cannot find the \"shield\" command.  "
         "Please bug report this group command.\n" );
   }
   check_for = members = GROUP->members_of( group );
   if( sizeof( suggested_members ) )
   {
      check_for = ( suggested_members & members );
   }
   if( !sizeof( check_for ) )
   {
      return notify_fail( "$C$" + query_multiple_short( suggested_members ) +
         ( sizeof( suggested_members ) > 1 ? " are not members " : " is not "
         "a member " ) + "of your group.\n" );
   }
   mess = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   foreach( member in check_for )
   {
		 if(!member)
			 continue;
		 shields = cmd_shields->construct_shield_message( member, 1 );
		 if( sizeof( shields ) ) {
         mess += "Arcane protection for " + colour +
					 member->query_cap_name() + "%^RESET%^:-\n";
         mess += shields + "\n";
		 } else {
			 mess += colour + member->query_cap_name() +
				 "%^RESET%^ has no arcane protection.\n\n";
		 }
   }
   if( sizeof( mess ) > 2 && mess[ sizeof( mess ) - 1 ] == '\n' )
   {
      mess = mess[ 0..( sizeof( mess ) - 2 ) ];
   }
   tell_object( this_player(), mess );
   return 1;
}
string query_help_string_for( string what )
{
   return "The \"group shields\" command allows you to view "
      "the arcane protection of all or some of your group's "
      "members.  You can either specify no arguments, or "
      "you can include the names of only those members "
      "whose protection you wish to check.\n";
}

==================================================
FILE: player/group_cmds/status.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_status( string verbose, string group );
int display_verbose_group_status( string group );
int display_brief_group_status( string group );
string calc_idle_string( object player );
string generate_status_message( object player );
string convert_percentage_to_colour( int percentage );
string convert_percentage_to_hp_message( int percentage );
string convert_percentage_to_gp_message( int percentage );
void create() {
   ::create();
   add_group_sub_command( "status", "<word'brief|verbose'>",
      (: do_group_status( $4[ 0 ], $6 ) :) );
   add_group_sub_command( "status", "",
      (: do_group_status( "default", $6 ) :) );
   set_membership_required( "status", 0, 1 );
}
int do_group_status( string verbose, string group ) {
   int use_verbose;
   switch( verbose ) {
      case "default":
         use_verbose = this_player()->query_verbose( "score" );
         break;
      case "verbose":
         use_verbose = 1;
         break;
      case "brief":
         use_verbose = 0;
         break;
      default:
         return notify_fail( "[ERROR]: Unknown return value from verbose information.\n" );
   }
   switch( use_verbose ) {
      case 1:
         return display_verbose_group_status( group );
      case 0:
         return display_brief_group_status( group );
      default:
         return notify_fail( "[ERROR]: This shouldn't happen.\n" );
   }
}
int display_verbose_group_status( string group ) {
   int size, cols;
   object member, *members, *assisting;
   string pronoun, message, status, short, colour, idle;
   cols = this_player()->query_cols();
   short = GROUP->query_group_short( group );
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   message = "\n";
   message += sprintf( "   %'+'*|s\n", cols - 3, "|" + short + "|" );
   size = sizeof( message ) - 3;
   message = replace( message, ({ short, ( colour + short +
      "%^RESET%^" ) }) );
   message += "\n";
   message += sprintf( "%' '*|s\n",
      cols - 3,
      "The group was started on " +
         ctime( GROUP->query_start_time( group ) ) + "." );
   message += "\n";
   members = GROUP->members_of( group );
   message += sprintf( "   %-=*s\n\n",
      size, "The group has %^BOLD%^" + query_num( sizeof( members ) ) +
      "%^RESET%^ " + ( sizeof( members ) > 1 ? "members" : "member" ) +
      ":" );
   if (!members) {
      message += "Very unhappy group.\n";
   } else {
      foreach( member in members ) {
          if(!member)
             continue;
          status = "$I$+8,+0=   " + colour;
          status += capitalize( member->query_cap_name() ) + "%^RESET%^" +
             " is " + generate_status_message( member ) + "  ";
          pronoun = member->query_pronoun();
          idle = calc_idle_string( member );
          if( idle ) {
             status += "  %^BOLD%^" + idle + ".%^RESET%^";
          }
          if( member == GROUP->leader_of( group ) ) {
             status += "  " + capitalize( pronoun ) + " is the " +
                colour + "current leader%^RESET%^ of the group.";
          }
          assisting = member->query_assisting();
          if( sizeof( assisting ) ) {
             status += "  " + capitalize( pronoun ) + " is assisting " +
                query_multiple_short( assisting, "one", 0, 1 ) + ".";
          }
          status += "$I$-8,-0=\n";
          message += status;
      }
   }
   tell_object( this_player(), message );
   return 1;
}
int display_brief_group_status( string group ) {
   object member, *others;
   string message, colour, idle;
   int my_gp, my_hp, my_max_hp, my_max_gp;
   message = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   others = GROUP->members_of( group ) - ({ this_player() });
   my_hp = this_player()->query_hp();
   my_gp = this_player()->query_gp();
   my_max_hp = this_player()->query_max_hp();
   my_max_gp = this_player()->query_max_gp();
   message += colour;
   message += capitalize( this_player()->query_cap_name() );
   message += "%^RESET%^; Hp: " + convert_percentage_to_colour( my_hp * 100 / my_max_hp ) +
      my_hp + "/" + my_max_hp + "%^RESET%^ Gp: " +
      convert_percentage_to_colour( my_gp * 100 / my_max_gp ) +
      my_gp + "/" + my_max_gp + "%^RESET%^.\n";
   foreach( member in others ) {
     if(!member)
       continue;
      message += colour;
      message += capitalize( member->query_cap_name() );
      message += "%^RESET%^ is " + generate_status_message( member );
      idle = calc_idle_string( member );
      if( idle ) {
         message += "  (" + idle + ")";
      }
      if( member == GROUP->leader_of( group ) ) {
         message += " (" + colour + "L%^RESET%^)";
      }
      if( member->query_property( "dead" ) ) {
         message += " (%^BOLD%^%^RED%^D%^RESET%^)";
      }
      message += "\n";
   }
   tell_object( this_player(), message );
   return 1;
}
string calc_idle_string( object player ) {
   int idle;
   if( !interactive( player ) ) {
      return "Net Dead";
   }
   idle = query_idle( player );
   if( idle < 15 ) {
      return 0;
   }
   return "Idle: " + ( idle / 60 ) + ":" + sprintf("%'0'2d", ( idle % 60 ));
}
string generate_status_message( object player ) {
   int hp_percentage, gp_percentage;
   hp_percentage = player->query_hp() * 100 / player->query_max_hp();
   gp_percentage = player->query_gp() * 100 / player->query_max_gp();
   return (
      convert_percentage_to_colour( hp_percentage ) +
      convert_percentage_to_hp_message( hp_percentage ) +
      "%^RESET%^ and " +
      convert_percentage_to_colour( gp_percentage ) +
      convert_percentage_to_gp_message( gp_percentage ) +
      "%^RESET%^." );
}
string query_help_string_for( string sub_command ) {
   return "The status sub-command displays vital statistics "
      "of your group's members.  Depending on your brief "
      "settings for \"score\", the command will either "
      "show the verbose statistics or prompt a brief "
      "display.  You can also force either version by "
      "adding the argument \"verbose\" or \"brief\".";
}
string convert_percentage_to_colour( int percentage ) {
   switch( percentage ) {
      case -1000..10: return "%^BOLD%^%^RED%^";
      case 11..20:    return "%^RED%^";
      case 21..30:    return "%^ORANGE%^";
      case 31..40:    return "%^YELLOW%^";
      case 41..50:    return "%^MAGENTA%^";
      case 51..60:    return "%^CYAN%^";
      case 61..70:    return "%^BOLD%^%^CYAN%^";
      case 71..80:    return "%^GREEN%^";
      case 81..90:    return "%^BOLD%^%^GREEN%^";
      case 91..100:   return "%^BOLD%^%^WHITE%^";
      default:        return "";
   }
}
string convert_percentage_to_hp_message( int percentage ) {
   switch( percentage ) {
      case -1000..0: return "perfectly healthy, for a ghost";
      case 1..5:     return "near death";
      case 6..10:    return "critically wounded";
      case 11..20:   return "seriously wounded";
      case 21..30:   return "heavily wounded";
      case 31..40:   return "badly wounded";
      case 41..50:   return "wounded";
      case 51..60:   return "slightly wounded";
      case 61..70:   return "injured";
      case 71..80:   return "slightly injured";
      case 81..89:   return "slightly hurt";
      case 90..94:   return "scratched";
      case 95..99:   return "almost unhurt";
      case 100:      return "unhurt";
      default:       return "ERROR";
   }
}
string convert_percentage_to_gp_message( int percentage ) {
   switch( percentage ) {
      case 0..10:    return "near unconscious";
      case 11..20:   return "severely fatigued";
      case 21..30:   return "highly fatigued";
      case 31..40:   return "very fatigued";
      case 41..50:   return "fatigued";
      case 51..60:   return "slightly fatigued";
      case 61..70:   return "confused";
      case 71..80:   return "slightly confused";
      case 81..90:   return "concentrated";
      case 91..99:   return "clear of mind";
      case 100:      return "refreshed";
      default:       return "ERROR";
   }
}
string convert_percentage_to_share_message( int percentage ) {
   switch( percentage ) {
      case 100:       return "all";
      case 95..99:    return "almost all";
      case 90..94:    return "a very large portion";
      case 80..89:    return "a large portion";
      case 70..79:    return "a major portion";
      case 60..69:    return "an above average portion";
      case 52..59:    return "a slightly above average portion";
      case 49..51:    return "an average portion";
      case 41..48:    return "a slightly below average portion";
      case 31..40:    return "a below average portion";
      case 21..30:    return "a minor portion";
      case 11..20:    return "a small portion";
      case 6..10:     return "a very small portion";
      case 1..5:      return "a miniscule portion";
      case 0:         return "next to none";
      default:        return "an ERRONEOUS portion ";
   }
}

==================================================
FILE: guild-race/gp.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_nroff_file("gp");
   set_command_name("gp");
}
int cmd() {
   int i, gp, max_gp, other_gp;
   gp = (int)this_player()->query_gp();
   max_gp = (int)this_player()->query_max_gp();
   write( "You have "+ gp +" ("+ max_gp +") guild points.\n" );
   for ( i = 0; i < sizeof( STD_SKILLS ); i += SKILL_ARR_SIZE ) {
      other_gp = (int)this_player()->query_skill_bonus( STD_SKILLS[ i ]
            +".points" ) + 50;
      if ( other_gp >= max_gp ) {
         write( "* All of your guild points can be used for "+
               STD_SKILLS[ i ] +" commands.\n" );
         continue;
      }
      if ( gp + other_gp <= max_gp ) {
         write( "* You cannot use any guild points for "+
               STD_SKILLS[ i ] +" commands until\n    your points "+
               "reach "+ ( max_gp - other_gp ) +".\n" );
         continue;
      }
      write( "* You can use "+ ( gp + other_gp - max_gp ) +" ("+ other_gp +
            ") for "+ STD_SKILLS[ i ] +" commands.\n" );
   }
   return 1;
}

==================================================
FILE: guild-race/newb_ie.c
==================================================

#include <player.h>
#include <language.h>
#include <cmds/options.h>
#include <newbiehelpers.h>
#define HIST "/obj/handlers/hist_handler"
#define SPAM_PROPERTY "newbie_tell"
#define TIME_OUT     30
#define TIME  0
#define WORDS 1
inherit "/cmds/guild_base";
inherit "/cmds/speech";
int newbie_history(object who);
void create() {
   ::create();
   set_nroff_file("newbie");
   set_command_name("newbie");
}
int cmd( string words ) {
   mixed *array;
   if (words == "history") {
      return newbie_history(this_player());
   }
   if ( this_player()->query_mature() &&
        !this_player()->query_creator() &&
        !this_player()->query_property( "newbie helper" ) &&
        !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      write( "You are no longer a newbie, being older than " + MATURITY +
             " hours.\n" );
      this_player()->remove_known_command( "newbie" );
      return 1;
   }
   if ( array = this_player()->query_property( SPAM_PROPERTY ) ) {
     if ( array[ WORDS ] == words ) {
       write( "You only said that a few seconds ago, why not wait for a "
         "response?\n" );
       return 1;
     }
     if ( time() < array[ TIME ] ) {
       write( "You only used the newbie channel a few seconds ago, why not "
         "wait for a response?\n" );
       return 1;
     }
   }
   if (this_player()->query_property("gagged")) {
      write("You are gagged!  You will not be able to use the "
            "newbie channel until a creator removes your gag.\n");
      return 1;
   }
   if(this_player()->query_property(SHORTHAND_PROP))
     words = LANGUAGES->fix_shorthand(words);
   words = strip_colours (words);
   write( "You newbie-tell: "+ words +"\n" );
   user_event("newbie", this_player()->query_cap_name() + ": "+words);
   HIST->add_chat_history("newbie", this_player()->query_name() +
                          " newbie-told: ", words);
   if (!this_player()->query_creator() &&
       !this_player()->query_property( "newbie helper") &&
       !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
     this_player()->add_property( SPAM_PROPERTY, ({ time() + 5, words }),
                                  TIME_OUT );
     write( "Please remember: this command is for obtaining assistance; "
            "it is not a chat channel.  If you over use it players "
            "stop listening and you don't get assistance when you "
            "really need it!\n");
   }
   return 1;
}
int newbie_history(object who) {
    mixed *history;
    string result;
    history = HIST->query_chat_history("newbie");
    if ( !arrayp( history ) || !sizeof( history ) ) {
        tell_object(who, "Nothing has been said on the newbie channel.\n");
    }
    else {
        result = "$P$Newbie Channel$P$";
        result += implode(map(history, (: "$I$5=$C$" + $1[0] + $1[1] +
                    "%^RESET%^" :)), "\n");
        tell_object(who, result);
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<string'message'>", (: cmd($4[0]) :),
              "history", (: cmd("history") :) });
}

==================================================
FILE: guild-race/rearrange.c
==================================================

#include <playerinfo.h>
#define ME_CON points[ this_player() ][ "me_con" ]
#define ME_DEX points[ this_player() ][ "me_dex" ]
#define ME_INT points[ this_player() ][ "me_int" ]
#define ME_STR points[ this_player() ][ "me_str" ]
#define ME_WIS points[ this_player() ][ "me_wis" ]
#define POOL points[ this_player() ][ "pool" ]
inherit "/cmds/guild_base";
mapping points = ([ ]);
int cmd();
void create() {
   ::create();
   set_command_name("rearrange");
}
void do_save() {
   int player, here;
   player = this_player()->query_real_con() +
      this_player()->query_real_dex() +
      this_player()->query_real_str() +
      this_player()->query_real_int() +
      this_player()->query_real_wis();
   here = ME_CON + ME_DEX + ME_STR + ME_INT + ME_WIS;
   if (player != here) {
      log_file("BAD_REARRANGE",
         sprintf("%s: %s had %d now has %d\n",
            ctime(time()),
            this_player()->query_name(),
            player, here));
      PLAYERINFO_HANDLER->add_entry(
         this_object(),
         this_player()->query_name(),
         "misc",
         sprintf("rearranged from %d points to %d points", player, here),
         0);
   }
   this_player()->set_con( ME_CON );
   this_player()->set_dex( ME_DEX );
   this_player()->set_int( ME_INT );
   this_player()->set_wis( ME_WIS );
   this_player()->set_str( ME_STR );
   this_player()->remove_known_command( "rearrange" );
   map_delete(points, this_player());
}
void display_stats() {
   printf( "Con: %d Dex: %d Int: %d Str: %d Wis: %d Pool: %d\n",
         ME_CON, ME_DEX, ME_INT, ME_STR, ME_WIS, POOL );
}
int get_stat_bit( string word ) {
   int num;
   string stat;
   word = lower_case( word );
   if ( word == "save" ) {
      if ( POOL ) {
         write( "WARNING: You still have points left in your pool that "
		   "could be used to make your character more powerful. If you "
		   "leave these unspent now, you will not be able to get them again later. "
           "Are you sure you want to save? [y/n] " );
         input_to( "get_check" );
         return 1;
      }
      write( "Saving.\n" );
      do_save();
      return 1;
   }
   if ( word == "quit") {
      write( "Quitting.\n" );
      map_delete(points, this_player());
      return 1;
   }
   if ( word == "reset" ) {
      write( "Resetting to previous arrangement.\n" );
      return cmd();
   }
   if ( sscanf( word, "%s %d", stat, num ) != 2 )
      stat = word;
   if ( !stat || ( stat == "" ) )
      stat = "X";
   if ( num > POOL )
      if ( !POOL ) {
         write( "Cannot add to stat.  Need to add to the pool first.\n" );
         stat = "X";
      } else {
         write( "Pool has only "+ POOL +" points in it.  "+
               "Adding these to stat.\n" );
         num = POOL;
      }
   switch( stat[ 0 ] ) {
      case 'c' :
         if ( ( ME_CON + num ) < 8 ) {
            write( "Cannot set constitution to less than 8.\n" );
         } else
            if ( ( ME_CON + num ) > 23 ) {
               write( "Cannot set constitution to more than 23.\n" );
            } else {
               ME_CON += num;
               POOL -= num;
            }
         break;
      case 'd' :
         if ( ( ME_DEX + num ) < 8 ) {
            write( "Cannot set dexterity to less than 8.\n" );
         } else
            if ( ( ME_DEX + num ) > 23 ) {
               write( "Cannot set dexterity to more than 23.\n" );
            } else {
               ME_DEX += num;
               POOL -= num;
            }
         break;
      case 'i' :
         if ( ( ME_INT + num ) < 8 ) {
            write( "Cannot set intelligence to less than 8.\n" );
         } else
            if ( ( ME_INT + num ) > 23 ) {
               write( "Cannot set intelligence to more than 23.\n" );
            } else {
               ME_INT += num;
               POOL -= num;
            }
         break;
      case 's' :
         if ( ( ME_STR + num ) < 8 ) {
            write( "Cannot set strength to less than 8.\n" );
         } else
            if ( ( ME_STR + num ) > 23 ) {
               write( "Cannot set strength to more than 23.\n" );
            } else {
               ME_STR += num;
               POOL -= num;
            }
         break;
      case 'w' :
         if ( ( ME_WIS + num ) < 8 ) {
            write( "Cannot set wisdom to less than 8.\n" );
         } else
            if ( ( ME_WIS + num ) > 23 ) {
               write( "Cannot set wisdom to more than 23.\n" );
            } else {
               ME_WIS += num;
               POOL -= num;
            }
         break;
      default :
         break;
   }
   display_stats();
   write( "Enter [d|c|i|w|s|save|reset|quit] <num> : " );
   input_to( "get_stat_bit" );
   return 1;
}
int get_check( string word ) {
   word = lower_case( word );
   if ( word[ 0 ] != 'y' ) {
      write( "Going back to stat entering.\n" );
      return get_stat_bit( "" );
   }
   do_save();
   write( "Saving.\n" );
   return 1;
}
int cmd() {
   write( "Rearranging stats.\n\n" );
   points[ this_player() ] = ([ ]);
   ME_CON = (int)this_player()->query_real_con();
   ME_DEX = (int)this_player()->query_real_dex();
   ME_INT = (int)this_player()->query_real_int();
   ME_STR = (int)this_player()->query_real_str();
   ME_WIS = (int)this_player()->query_real_wis();
   POOL = 0;
   if ( ME_CON > 8)  {
      POOL += ME_CON - 8;
      ME_CON = 8;
   }
   if ( ME_DEX > 8) {
      POOL += ME_DEX - 8;
      ME_DEX = 8;
   }
   if ( ME_INT > 8 ) {
      POOL += ME_INT - 8;
      ME_INT = 8;
   }
   if ( ME_STR > 8 ) {
      POOL += ME_STR - 8;
      ME_STR = 8;
   }
   if ( ME_WIS > 8 ) {
      POOL += ME_WIS - 8;
      ME_WIS = 8;
   }
   write( "Type \"c 3\" to add 3 points to your constitution from the pool, "+
         "or \"c -4\" to remove 4 points from constitution and add them to "+
         "the pool.  Use \"save\" to save the current state and quit.  Note "+
         "that \"%^YELLOW%^reset%^RESET%^\" will return you to your "+
         "starting position, while \"%^YELLOW%^quit%^RESET%^\" will quit "+
         "without saving any changes.\n\n" );
   return get_stat_bit( "" );
}
int teach( object thing ) { return 0; }
int clean_up() {
  if (sizeof(points))
    return 1;
  ::clean_up();
}
void reset() {
  if (sizeof(points))
    return;
  ::reset();
}
string query_name()
{
  return "Rearrange Command";
}

==================================================
FILE: guild-race/skills.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_command_name("skills");
}
string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }
    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}
string level_to_string( int level ) {
    switch( level ) {
        case 0..15:
            return "novice";
        case 16..30:
            return "apprentice";
        case 31..45:
            return "competent";
        case 46..60:
            return "proficient";
        case 61..75:
            return "skilled";
        case 76..85:
            return "adept";
        case 86..95:
            return "expert";
        default:
            return "master";
    }
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus, rp;
   string str, tp, tmp;
   rp = this_player()->query_role_playing();
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) ||
          (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero)))) {
        if(rp) {
          str += sprintf( "%*'| 's%*'.'-s %4s\n",
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ),
              args[ i ],
              (no_bonus ? level_to_string(sk) : bonus_to_string( this_player()->query_skill_bonus( tp ) ) ), "" );
        } else {
          str += sprintf( "%*'| 's%*'.'-s %4d " + (no_bonus?"   -\n":"%4d\n"),
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
                          (int)this_player()->query_skill_bonus( tp ) );
        }
      }
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         if ((only_leaf || o_l) && (tmp != "")) {
           if(rp) {
             str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           } else {
             str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           }
         } else
           str += tmp;
      }
   }
   return str;
}
int cmd( string word ) {
   int i, rp;
   string result, *bits;
   mixed *args;
   result = "";
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }
   rp = this_player()->query_role_playing();
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      if(rp) {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Proficiency" );
      } else {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Level/Bonus" );
      }
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   if(rp) {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Proficiency");
   } else {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Level/Bonus");
   }
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}

==================================================
FILE: guild-race/crafts/duplicate.c
==================================================

#include <artifacts.h>
#include <move_failures.h>
#define COST 50
#define LEVEL 100
#define SHAPING "crafts.pottery.forming.shaping"
#define SMITHING "crafts.smithing"
#define TURNING "crafts.carpentry.turning"
#define WHITTLING "crafts.carpentry.whittling"
inherit "/cmds/guild_base";
inherit "/std/basic/cute_look";
void create() {
   ::create();
   set_nroff_file("duplicate");
}
int cmd( object* things) {
   int i, bonus;
   object form;
   mapping map;
   for ( i = 0; i < sizeof( things ); i++ ) {
      if ( !function_exists( "query_artifact_type", things[ i ] ) ) {
         write( "You cannot duplicate "+  things[ i ]->the_short() +".\n" );
         continue;
      }
      if ( (int)this_player()->query_specific_gp( "crafts" ) < COST ) {
         write( "You don't have enough guild points to duplicate "+
               things[ i ]->the_short() +".\n" );
         continue;
      }
      switch( (string)things[ i ]->query_artifact_type() ) {
       case "wand" :
         bonus = (int)this_player()->query_skill_bonus( TURNING );
         break;
       default :
         write( "Oops, something went wrong with "+ things[ i ]->the_short() +
               ".  Please contact a creator.\n" );
        continue;
      }
      if ( bonus < LEVEL ) {
         write( "Your skill is insufficient to make a form from "+
               things[ i ]->the_short() +".\n" );
         continue;
      }
      this_player()->adjust_gp( -COST );
      switch ( (string)things[ i ]->query_artifact_type() ) {
       case "wand" :
         form = clone_object( "/obj/weapon" );
         break;
      }
      map = (mapping)things[ i ]->query_static_auto_load();
      if ( !m_sizeof( map ) ) {
         map = (mapping)things[ i ]->int_query_static_auto_load();
         form->init_static_arg( map );
      } else
      form->init_static_arg( map[ "::" ] );
      map = (mapping)things[ i ]->query_dynamic_auto_load();
      form->init_dynamic_arg( map[ "::" ] );
      form->set_enchant( 0 );
      form->set_value_info( "artifact", 0 );
      if ( bonus < LEVEL + random( LEVEL ) )
         form->remove_property( "artifact form" );
      write( "You duplicate a form from "+ things[ i ]->the_short() +".\n" );
      if ( (int)form->move( this_player() ) != MOVE_OK )
         form->move( environment( this_player() ) );
   }
   return 1;
}
mixed *query_pattern() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: guild-race/crafts/fix.c
==================================================

#include <money.h>
#include <tasks.h>
#define TEACH_LEVEL 10
#define LEARN_LEVEL 10
#define SKILL "crafts.smithing.black"
#define SKILLS ({ "crafts.smithing.black.weapons", \
                  "crafts.smithing.black.armour", \
                  "crafts.smithing.black.tools" })
#define A_MAX 5
#define C_MAX 100
#define A_COND 5
#define C_COND 25
#define SCALE 50
#define USE_WEAPON_SKILL 1
#define USE_ARMOUR_SKILL 2
#define USE_TOOL_SKILL 3
inherit "/cmds/guild_base";
int query_item_type( object ob );
int query_fix_cost( object player, object smithy, object item, int costing, int max, int cond, int low );
int test_fixed( object item );
void create() {
   ::create();
   set_nroff_file("fix");
   set_command_name("fix");
   add_teach_skill(SKILL, 10, 10);
}
object find_smithy(object player) {
   if (environment(player)->query_property("smithy")) {
      return environment(player);
   }
   foreach (object ob in all_inventory(player)) {
      if (ob->query_smithy()) {
         return ob;
      }
   }
   return 0;
}
int cmd( object *things, int costing ) {
    int type, bonus, cond, low, max, diff, cost, val, award;
    int new_cost;
    object here, item, fixer;
    string place;
    fixer = this_player();
    here = find_smithy(fixer);
    if ( !here || !here->query_property( "smithy" ) ) {
        add_failed_mess( "You are not in a smithy, so you cannot fix "
            "anything.\n" );
        return 0;
    }
    place = here->query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";
    if ( sizeof( things ) > 1 ) {
        add_failed_mess( "You can only fix one thing at a time.\n" );
        return 0;
    }
    item = things[ 0 ];
    type = query_item_type( item );
    if ( !type ) {
      add_failed_mess( "$I is neither armour nor a weapon.\n", things );
      return 0;
    }
    if ( item->query_worn_by() ) {
        add_failed_mess( "You should probably remove $I before making it "
                         "hot and hitting it with a hammer.\n", things );
        return 0;
    }
    if( member_array( "leather", item->query_materials() ) != -1 ) {
      add_failed_mess( "$I would be destroyed if you put it in the fire.\n",
                       things );
      return 0;
    }
    if( member_array( "wool", item->query_materials() ) != -1 ) {
      add_failed_mess( "Putting a woolen item in the fire isn't going "
                       "to improve its condition.\n",
                       things );
      return 0;
    }
    if( item->query_unfixable() ) {
        add_failed_mess( "Sticking $I in a hot forge probably isn't "
            "going to do much for its condition.\n", things );
        return 0;
    }
    bonus = (int)fixer->query_skill_bonus( SKILLS[ type - 1 ] );
    val = (int)fixer->query_value_in( place );
    if ( place != "default" )
        val += (int)fixer->query_value_in( "default" );
    low = (int)item->query_lowest_cond();
    if ( !low )
        low = 1;
    cond = (int)item->query_cond();
    max = (int)item->query_max_cond();
    if ( !max )
        max = 1;
    if ( test_fixed( item ) ) {
        add_failed_mess( "$I is already in top condition.\n", things );
        return 0;
    }
    diff = max - cond;
    cost = query_fix_cost( this_player(), here, item, costing, max, cond, low );
    new_cost = here->generate_cost(cost, 0);
    if (new_cost == -1) {
       return 0;
    }
    if (new_cost) {
       cost = new_cost;
    }
    if ( ( diff > bonus ) && !costing ) {
        diff = ( 150 * diff ) / max;
        switch ( (int)TASKER->perform_task( fixer,
            SKILLS[ type-1 ], diff, TM_COMMAND ) ) {
            case AWARD :
                award = 1;
            case SUCCEED :
                diff = max - cond;
            break;
            default :
                diff = bonus;
        }
    }
    if ( ( val < cost ) &&
         !fixer->query_property( "freelance smith" ) && !costing ) {
        add_failed_mess( "You cannot afford the materials to fix "
            "$I.\n", things );
        return 0;
    }
    if ( costing ) {
      add_succeeded_mess( ({ "To attempt to fix $I, it would probably cost "
        "you about " + MONEY_HAND->money_value_string( cost, place ) +
        ".\n", "" }), things );
        return 1;
    }
    if ( !cond ) {
        add_succeeded_mess( ({ "You begin to work on $I when it breaks!  "
            "It must have been too damaged to fix.\n",
            "$N begin$s to work on $I when it breaks!\n" }), things );
        item->break_me();
        return 1;
    }
    item->adjust_cond( diff );
    if ( !fixer->query_property( "freelance smith" ) ) {
        fixer->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
            place ), place );
        here->generate_cost(cost, 1);
    }
    if ( award ) {
        write( "%^YELLOW%^"+ replace( ({ "As you begin to fix $I, you realise "
            "how to make better use of the materials.", "As you work on $I, "
            "you find that you're able to fix it completely.", "You discover "
            "that you can fix $I more effectively." })[ random( 3 ) ], "$I",
            item->the_short() ) +"%^RESET%^\n" );
    }
    if ( test_fixed( item ) )
        write( "You fix "+ item->the_short() +
        ", bringing it to top condition.\n" );
    else
        write( "You manage to fix "+ item->the_short() +
            " a little, although it's still not in top condition.\n" );
    write( "The repair materials cost you " +
        MONEY_HAND->money_value_string( cost, place ) +".\n" );
    add_succeeded_mess( ({ "", "$N fixes up $I.\n" }), things );
    return 1;
}
int test_fixed( object item ) {
    return ( 100 * item->query_cond() > 98 * item->query_max_cond() );
}
int query_item_type( object ob ) {
    if ( ob->query_weapon() == 1 ) {
        return USE_WEAPON_SKILL;
    }
    if ( ob->query_armour() || ob->query_scabbard() ) {
        return USE_ARMOUR_SKILL;
    }
    if ( ob->query_material() == "metal" ) {
        return USE_TOOL_SKILL;
    }
    return 0;
}
int query_fix_cost( object player, object smithy,
                            object item, int costing, int max, int cond, int low ) {
    int cost, diff, per;
    if ( !max )
        max = item->query_max_cond();
    if ( !cond )
        cond = item->query_cond();
    if ( !low )
        low = item->query_lowest_cond();
    diff = max - cond;
    per = 100 - smithy->query_discount( player );
    if ( per < 0 )
        per = 0;
    cost = ( diff * sqrt( item->query_full_value() ) ) / max;
    cost *= A_MAX + ( C_MAX * ( max - low ) ) / max;
    cost *= A_COND + ( C_COND * ( cond - low ) ) / ( cond + !cond );
    cost /= SCALE;
    if ( costing ) {
        cost *= 2;
    }
    else {
        cost += roll_MdN( 4, cost / 4 );
    }
    cost = ( cost * per ) / 100;
    if ( cost < 100 ) {
        cost = 100;
    }
    return cost;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1, 0) :),
            "cost <indirect:object:me>", (: cmd($1, 1) :) });
}

==================================================
FILE: guild-race/crafts/leatherwork.c
==================================================

#include <money.h>
#include <tasks.h>
#define TEACH_LEVEL 10
#define LEARN_LEVEL 10
#define SKILL "crafts.materials.leatherwork"
#define SKILLS ({ "crafts.materials.leatherwork", \
                  "crafts.materials.needlework" })
#define A_MAX 5
#define C_MAX 100
#define A_COND 5
#define C_COND 25
#define SCALE 50
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_nroff_file("leatherwork");
   add_teach_skill(SKILL, 20, 10);
   set_command_name("leatherwork");
}
int cmd( object *things, int costing ) {
   int bonus, cond, low, max, diff, cost, per, val, award;
   string place;
   if ( !environment( this_player() )->query_property( "leatherwork" )&&
      member_array(1,  (all_inventory(environment(this_player()))->
      query_property("leatherwork"))) == -1 )
      return notify_fail( "You are not in a leatherworking shop, "
            "so you cannot repair anything.\n" );
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) ){
      place = "default";
   }
   if ( sizeof( things ) > 1 )
      return notify_fail( "You can only repair one thing at a time.\n" );
   if (things[0]->query_material() != "leather")
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is not made of leather!  Wrong shop!\n" );
   if ( things[ 0 ]->query_worn_by() )
      return notify_fail( "You should probably remove "+
            (string)things[ 0 ]->the_short() +
            " before you jab yourself with a needle "
            "while trying to patch it up.\n" );
   per = 100 -
    (int)environment( this_player() )->query_discount( this_player() );
   if ( per < 0 )
      per = 0;
   val = (int)this_player()->query_value_in( place );
   if ( place != "default" )
      val += (int)this_player()->query_value_in( "default" );
   low = (int)things[ 0 ]->query_lowest_cond();
   if ( !low )
      low = 1;
   cond = (int)things[ 0 ]->query_cond();
   max = (int)things[ 0 ]->query_max_cond();
   if ( !max )
      max = 1;
   if ( 100 * cond > 98 * max )
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is already in top condition.\n" );
   diff = max - cond;
   if ((100 * diff)/max > 70){
     bonus = (int)this_player()->query_skill_bonus( SKILLS[ 1 ] );
     cost = (( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) /
       (max * 50) + 13);
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[1],
                                          diff, TM_COMMAND ) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the thread to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
      write( "%^YELLOW%^"+ replace( ({ "As you begin to fix $I, you realise "
            "how to make better use of the materials.", "As you work on $I, "
            "you find that you're able to fix it completely.", "You discover "
            "that you can fix $I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "You sew up all the holes in "+ (string)things[ 0 ]->the_short() +
            ", bringing it to top condition.\n" );
   else
      write( "You manage to sew up some of the holes in "+ (string)things[ 0 ]->the_short() +
            " but a few pop back open due to poor stitching.\n" );
   write( "The thread and sinew costs you "+
         (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
         (string)things[ 0 ]->a_short() +".\n" );
   return 1;
  }else{
  bonus = (int)this_player()->query_skill_bonus( SKILLS[ 0 ] );
  cost = ( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) /
      (max * 3) +123;
   if ( !cond ) {
      write( "You begin to work on "+ (string)things[ 0 ]->the_short() +
            " when it falls apart!  It must have been too damaged to fix.\n" );
      say( (string)this_player()->one_short() +" begins to work on "+
            (string)things[ 0 ]->the_short() +" when it falls to scraps!\n" );
      things[ 0 ]->break_me();
      return 1;
   }
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[0],
                                          diff, TM_COMMAND) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the leather to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
     write("%^YELLOW%^"+ replace( ({ "As you begin to cut and sew the "
           "leather patches for $I, you realise how to make better use of "
           "the leather.", "As you work on $I, you find that you're able "
           "to repair it completely.", "You discover that you can repair "
           "$I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "Your patching of "+ (string)things[ 0 ]->the_short() +
            " goes quite well, and you bring it to top condition.\n" );
   else
      write( "You manage to create reasonably good patches for "+
             (string)things[ 0 ]->the_short() +
             ", but the size wasn't quite right, and the stitching doesn't "
             "look like it will hold very well.\n" );
   write( "The repair materials cost you "+
          (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
        (string)things[ 0 ]->a_short() +".\n" );
   return 1;
 }
}
int teach( object thing ) {
   if ( (int)this_player()->query_skill( SKILL ) < TEACH_LEVEL )
      return -1;
   if ( (int)thing->query_skill( SKILL ) < LEARN_LEVEL )
      return -2;
   thing->add_known_command( "leatherwork" );
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1, 0) :),
            "cost <indirect:object:me>", (: cmd($1, 1) :) });
}

==================================================
FILE: guild-race/other/judge.c
==================================================

#include <tasks.h>
#include <weapon.h>
#undef DEBUG
#define COST 25
#define SKILL "other.evaluating.weapons"
#define QUEST_AVE 140
#define QUEST_MAX 300
#define LEARN 5
#define TEACH 50
inherit "/cmds/guild_base";
nosave string *_attack_types = ({ "blunt", "sharp", "pierce" });
nosave string *attacks;
void create() {
    ::create();
    set_nroff_file("judge");
    set_command_name("judge");
    add_teach_skill(SKILL, 50, 5);
}
varargs int *calc_rating( object weapon, object player ) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;
    data = (mixed *)weapon->query_attack_data();
    if ( !( size = sizeof( data ) ) )
        return ({ 0, 0 });
    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
      debug_printf("[%s - ave: %d max: %d]\n", data[ i + W_TYPE],
                   ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100,
                   damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ]);
    }
    debug_printf("[%s - ave: %d max: %d]\n", weapon->short(), ave, max );
    return ({ ave, max });
}
void judge_against( object player, object first, object second ) {
  int grain, rating, rating_1, rating_2, difficulty, margin, *data_1,
    *data_2;
  data_1 = calc_rating( first, player );
  data_2 = calc_rating( second, player );
  difficulty = data_1[ 0 ] - data_2[ 0 ];
    if ( difficulty > 0 )
        difficulty = QUEST_AVE - difficulty;
    else
        difficulty = QUEST_AVE + difficulty;
    margin = ( difficulty + ( difficulty * ( data_1[ 1 ] + data_2[ 1 ] ) ) /
        ( 2 * QUEST_MAX ) ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL, difficulty - 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapons$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to better judge "
                "$weapons$.", "As you inspect $weapons$, you feel a sense "
                "of surety in your judgement." })[ random( 3 ) ], "$weapons$",
                query_multiple_short( ({ first, second }), "the" ) ) +
                "%^RESET%^\n" );
        case SUCCEED:
            break;
        default:
            tell_object( player,
                "You examine "+ query_multiple_short( ({ first, second }),
                    "the" ) + " closely, but you're not sure which is "
                    "better.\n" );
            return;
    }
    grain = sqrt( (int)this_player()->query_skill_bonus( SKILL ) );
    if ( grain > 12 )
        grain = 12;
    rating_1 = QUEST_AVE * data_1[ 1 ] + QUEST_MAX * data_1[ 0 ];
    rating_1 = ( grain * rating_1 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating_2 = QUEST_AVE * data_2[ 1 ] + QUEST_MAX * data_2[ 0 ];
    rating_2 = ( grain * rating_2 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating = rating_1 - rating_2;
    if ( rating > 0 )
        rating++;
    else
        rating--;
    rating = 6 + rating / 2;
    if ( rating > 12 )
        rating = 12;
    if ( rating < 0 )
        rating = 0;
    if ( rating == 6 ) {
        tell_object( player, "You think that " +
            query_multiple_short( ({ first, second }), "the" ) +
            " are exactly the same.\n" );
        return;
    }
    tell_object( player, "You think that " + first->the_short() +" is "+ ({
         "amazingly worse", "extremely worse", "very much worse",
         "much worse", "worse", "a bit worse", "!", "a bit better",
         "better", "much better", "very much better",
         "extremely better", "amazingly better" })[ rating ] +" than "+
         second->the_short() +".\n" );
}
int judge_weapon( object player, object weapon ) {
    int grain, rating, margin, *data;
    string res;
    data = calc_rating( weapon, player );
    margin = ( data[ 0 ] + ( data[ 0 ] * data[ 1 ] ) / QUEST_MAX ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL,  data[ 0 ] + 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapon$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to judge "
                "$weapon$.", "As you inspect $weapon$, you feel a sense of "
                "surety in your judgement." })[ random( 3 ) ], "$weapon$",
                weapon->the_short() ) +"%^RESET%^\n" );
    case SUCCEED:
      break;
    default:
      tell_object( player, "You think that " + weapon->the_short() +
                   " is a good weapon, but you're not sure.\n" );
      return 0;
    }
    grain = sqrt( player->query_skill_bonus( SKILL ) / 2 );
    if ( grain > 14 )
      grain = 14;
    rating = QUEST_AVE * data[ 1 ] + QUEST_MAX * data[ 0 ];
    rating = ( grain * rating + QUEST_AVE * QUEST_MAX ) /
      ( 2 * QUEST_AVE * QUEST_MAX );
    rating += 14 - grain;
    if ( rating > 14 ) {
#ifdef DEBUG
      log_file( "BAD_WEAPON", "%s exceeds weapon specifications, rating is "
                "%d.\n", file_name( weapon ), rating );
#endif
      rating = 14;
    }
    attacks = player->query_known_commands();
    attacks = filter(weapon->query_attack_names(),
                  (: (member_array($1, attacks) != -1) :));
    attacks -= ({ "crush" });
    attacks -= ({ "impale" });
    attacks -= ({ "behead" });
    if(member_array("smash", weapon->query_attack_names()) != -1 &&
       member_array("crush", player->query_known_commands()) != -1)
       attacks += ({ "crush" });
    if(member_array("pierce", weapon->query_attack_names()) != -1 &&
       member_array("impale", player->query_known_commands()) != -1)
       attacks += ({ "impale" });
    if(member_array("slice", weapon->query_attack_names()) != -1 &&
       member_array("behead", player->query_known_commands()) != -1)
       attacks += ({ "behead" });
    res = "You think that "+ weapon->the_short() +" is " + ({
      "an atrocius", "an extremely poor", "a very poor", "a rather poor",
        "a poor", "a pretty poor", "a quite poor", "a reasonable",
        "a quite good", "a pretty good", "a good", "a rather good",
        "a very good", "an extremely good", "an excellent" })[ rating ] +
      " weapon";
    debug_printf("attacks: %O", attacks);
    if(sizeof(attacks))
      res += " that can be used to " + query_multiple_short(attacks, "", 0, 1,
                                                            0);
    res += ".\n";
    tell_object(player, res);
    return rating;
}
int valid_weapon( object player, object ob ) {
  if ( living( ob ) ) {
    if ( ob == player ) {
      add_failed_mess( "You stare at your muscles for a moment, "
                       "and decide that you're more than capable of destroying "
                       "any enemy that decides to interfere with you.\n" );
      return 0;
    }
    add_failed_mess( "You stare at $I for a while, but decide it "
                     "would be better if you considered them instead.\n",
                     ({ ob }) );
    return 0;
  }
  if ( !ob->query_weapon() ) {
    add_failed_mess( "$C$$I is not a weapon.\n", ({ ob }) );
    return 0;
  }
  if(environment(ob) != this_player())
    return add_failed_mess("You can't find $I.\n", ({ ob }));
  return 1;
}
int cmd( object first, object second ) {
  object *indirect_obs;
  int cost;
  function judge_func;
  if ( !valid_weapon( this_player(), first ) ) {
    return 0;
  }
  cost = COST;
  if ( second ) {
    if ( !valid_weapon( this_player(), second ) ) {
      return 0;
    }
    cost *= 2;
    indirect_obs = ({ first, second });
    judge_func = (: judge_against :);
  } else {
    indirect_obs = ({ first });
    judge_func = (: judge_weapon :);
  }
  if ( this_player()->query_specific_gp( "other" ) < cost ) {
    add_failed_mess( "You can't muster the energy to scrutinise "
                     "$I at the moment.\n", indirect_obs );
    return 0;
  }
  this_player()->adjust_gp( -cost );
  call_out( judge_func, 0, this_player(), first, second );
  add_succeeded_mess( "$N look$s closely at $I.\n", indirect_obs );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object'weapon'>", (: cmd( $1[0], 0 ) :),
              "<indirect:object:me'weapon'> against <indirect:object:me'weapon'>",
              (: cmd( $1[0][0], $1[1][0] ) :) });
}

==================================================
FILE: guild-race/other/vurdere.c
==================================================

#include <clothing.h>
#include <weapon.h>
#define COST 5
#define SKILL "other.evaluating.armour"
#define LEARN_LEVEL 2
#define TEACH_LEVEL 10
inherit "/cmds/guild_base";
void create() {
  ::create();
  set_nroff_file("vurdere");
  set_command_name("vurdere");
  add_teach_skill(SKILL, 10, 2);
}
mixed *calc_ac( object ob ) {
  int j;
  string i;
  mapping ac;
  mixed *ret, bit;
  ac = (mapping)ob->query_armour_class();
  ret = ({ });
  foreach ( i in keys( ac ) ) {
    if ( member_array( ac[ i ][ A_TYPE ], ({ "blunt",
                                               "sharp", "pierce" }) ) == -1 )
      continue;
    bit = ac[ i ][ A_AC ];
    if( (j = member_array( ac[ i ][ A_TYPE ], ret )) == -1 ) {
      j = sizeof( ret );
      ret += ({ ac[ i ][ A_TYPE ], ({ 0, 0, 0 }) });
    }
    j++;
    if ( intp( bit ) ) {
      ret[ j ][ 1 ] += bit / 2;
      ret[ j ][ 2 ] += bit;
    } else
      switch ( sizeof( bit ) ) {
      case 1 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += bit[ 0 ];
        ret[ j ][ 2 ] += bit[ 0 ];
        break;
      case 2 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ]);
        break;
      case 3 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ]);
        break;
      default :
        write( "Barf!\n" );
      }
  }
  return ret;
}
int calc_sausage( int sausage, int lvl ) {
  int tmp;
  tmp = 99 - (lvl * 99) / 200;
  if( tmp < 0 )
    tmp = 0;
  return random( sausage ) * tmp / 100 - random( sausage ) * tmp / 100 +
    sausage;
}
string check_string( int val, int bon ) {
  int dist;
  string s;
  dist = (350 - bon) / 10;
  if( dist > (val < 0 ? -val : val) )
    return " is the same as ";
  if( val > 0 )
    s = "better than ";
  else {
    s = "worse than ";
    val -= val;
  }
  if( !val )
    return " is exactly the same as ";
  if( val < 10 )
    return " is slightly " + s;
  if( val < 20 )
    return " " + s;
  if( val < 40 )
    return " is much " + s;
  return " is amazingly " + s;
}
int cmd_against( object*from, object *to ) {
  int i, j, k, l, arm_lvl;
  object *ok, *fail;
  mixed *rat, *to_ac, *zip;
  arm_lvl = (int)this_player()->query_skill_bonus( SKILL );
  if(sizeof(from) + sizeof(to) > 10) {
    add_failed_mess("You cannot compare that many items at once.\n");
    return 0;
  }
  i = (COST*(sizeof(from)+sizeof(to)));
  if(this_player()->query_specific_gp("other") < i) {
    add_failed_mess("You cannot concentrate enough to compare these "
                       "items.\n");
    return 0;
  }
  this_player()->adjust_gp( -i);
  to_ac = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( to ); i++ ) {
    if( to[ i ]->query_armour() ) {
      rat = calc_ac( to[ i ] );
      to_ac += ({ to[ i ], rat });
    } else {
      fail += ({ to[ i ] });
      to = delete( to, i, 1 );
      i--;
    }
  }
  if( !sizeof( to ) ) {
    notify_fail( "None of " + query_multiple_short( fail ) +
                 " are armour.\n" );
    return 0;
  }
  fail = ({ });
  ok = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      if( !sizeof( to_ac ) ) {
        fail += ({ from[ i ] });
        continue;
      }
      rat = calc_ac( from[ i ] );
      zip = ({ });
      for( j = 0; j < sizeof( to_ac ); j += 2 ) {
        for( k = 0; k < sizeof( to_ac[ j + 1 ] ); k += 2 ) {
          if( (l = member_array( to_ac[ j + 1 ][ k ], rat )) == -1 ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          } else {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( (rat[ l + 1 ][ 0 ] + rat[ l + 1 ][ 1 ] +
                                  rat[ l + 1 ][ 2 ]) / 3 -
                                 (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          }
          zip += ({ to_ac[ j + 1 ][ k ] });
        }
        for( k = 0; k < sizeof( rat ); k += 2 ) {
          if( member_array( rat[ 0 ], zip ) ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] +
                                      rat[ j + 1 ][ 2 ]) / 3, arm_lvl ) +
                   to_ac[ j ]->short() + " at " + rat[ j ] + ".\n" );
          }
        }
      }
      if(member_array(from[i], ok) == -1) {
        ok += ({ from[ i ] });
      }
    } else {
      if(member_array(from[i], fail) == -1) {
        fail += ({ from[ i ] });
      }
    }
  }
  if( sizeof( fail ) ) {
    add_failed_mess( "Failed to compare " + query_multiple_short( fail ) +
                 " against " + query_multiple_short( to ) + ".\n" );
    return 0;
  }
  if( sizeof( ok ) ) {
    say( this_player()->query_cap_name() + " looks closely at " +
         query_multiple_short( uniq_array( ok + to ) ) + ".\n" );
  }
  return 1;
}
int cmd_normal( object* from ) {
  int i, j;
  object *ok, *fail;
  mixed *rat, bing;
  string type, *types, *zones;
  ok = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      rat = calc_ac( from[ i ] );
      for( j = 0; j < sizeof( rat ); j += 2 ) {
        bing = (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] + rat[ j + 1 ][ 2 ]) / 3;
        bing /= 5;
        if( bing >= 10 ) {
          bing = 9;
        }
        if( bing < 0 ) {
          bing = 0;
        }
        write( from[ i ]->the_short() + ({ " is terrible",
                                       " is amazingly poor",
                                       " is pretty poor",
                                       " is poor",
                                       " is ok",
                                       " is average",
                                       " is good",
                                       " is very good",
                                       " is extremely good",
                                       " is excellent", })[ bing ] +
                                       " at stopping " + rat[ j ] +
                                       " attacks.\n" );
        ok += ({ from[ i ] });
      }
      if(!arrayp(from[i]->query_type())) {
        types = ({ from[i]->query_type() });
      } else {
        types = from[i]->query_type();
      }
      zones = ({ });
      foreach(type in types) {
        if(CLOTHING_HANDLER->query_equivilant_type(type)) {
          zones += CLOTHING_HANDLER->query_zone_names(CLOTHING_HANDLER->query_equivilant_type(type));
        } else {
          zones += CLOTHING_HANDLER->query_zone_names(type);
        }
      }
      if(!sizeof(zones)) {
      	write(from[i]->the_short() +
              " does not protect any parts of your body.\n");
      } else {
        write(from[i]->the_short() + " protects your " +
              query_multiple_short(zones, "poss") + ".\n");
      }
      continue;
    }
    fail += ({ from[ i ] });
  }
   from = uniq_array( from );
  if( !sizeof( ok ) ) {
    notify_fail( "You failed to vurdere " + query_multiple_short( from ) +
                 ".\n" );
    return 0;
  }
    ok = uniq_array( ok );
  say( this_player()->query_cap_name() + " peers carefully at " +
       query_multiple_short( ok ) + ".\n" );
  return 1;
}
int teach( object ob ) {
  if( this_player()->query_skill( SKILL ) < TEACH_LEVEL )
    return -1;
  if( ob->query_skill( SKILL ) < LEARN_LEVEL )
    return -2;
  ob->add_known_command( "vurdere" );
  return 1;
}
mixed* query_patterns() {
   return ({ "<indirect:object:me'from'> against <indirect:object:me'to'>",
                (: cmd_against($1[0], $1[1]) :),
             "<indirect:object:me'normal'>",
                (: cmd_normal($1) :) });
}

==================================================
FILE: playtester/check.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
string query_applicant_text();
string pt_protected();
varargs int cmd(string check, string name) {
  object ob = environment (this_player());
  int min, max;
  mixed *chats;
  mixed *chatsd, *chatsn;
  string day, night;
  string ret = "";
  int count;
  mixed *args, *args1;
  if (ob->query_property ("restrict check")) {
    this_player()->add_failed_mess (this_object(), "The use of the check "
      "command in this room has been restricted.\n", ({ }));
    return 0;
  }
  switch (check) {
    case "chats":
      args= ob->query_room_chats();
      chatsd = ob->query_room_day_chats();
      chatsn = ob->query_room_night_chats();
      if (!args && !sizeof (chatsd) && !sizeof (chatsn)) {
        tell_object (this_player(), "There are no chats defined here.\n");
        return 1;
      }
      if (args) {
         min = args[0];
         max = args[1];
         if (!arrayp(args[2])) {
            ret += "%^BOLD%^%^RED%^Error in the room chats!%^RESET%^\n";
            chats = ({ });
         } else {
            chats = args[2];
         }
      } else {
         chats = ({ });
      }
      if (sizeof (chats)) {
        ret = "This room has the following chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          if (!stringp(chats[i])) {
             ret += "%^BOLD%^%^RED%^Broken chat setup in room.%^RESET%^\n";
             break;
          }
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
      if (sizeof (chatsd)) {
        min = chatsd[0];
        max = chatsd[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room day chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsd[2];
        }
        ret += "\n\nThis room has the following day chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
      if (sizeof (chatsn)) {
        min = chatsn[0];
        max = chatsn[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room night chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsn[2];
        }
        ret += "\n\nThis room has the following night chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
    break;
    case "long":
      day = ob->query_day_long();
      night = ob->query_night_long();
      ret = "Day long description:\n\n" + day;
      ret += "\n\nNight long description:\n\n" + night;
    break;
    case "items":
      ob = ob->query_item();
      if (!ob) {
        ret = "%^CYAN%^There are no add_items defined in this room.%^RESET%^\n";
      }
      else {
        args = ob->query_shrt();
        args1 = ob->query_lng();
        count = sizeof (args);
        ret += "%^YELLOW%^Main items:%^RESET%^\n";
        for (int i = 0; i < count; i++) {
          if (!sizeof (args[i])) {
            continue;
          }
          ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args1[i]) ?  ("*" + evaluate (args1[i]) + "*") : args1[i]);
          ret += "\n\n";
        }
        args = ob->query_day_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no day items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Day Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";
          }
        }
        args = ob->query_night_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no night items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Night Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";
          }
        }
      }
    break;
    case "day items":
      args = ob->query_day_items();
      if (!sizeof (args)) {
        ret += "There are no day items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";
        }
      }
    break;
    case "night items":
      args = ob->query_night_items();
      if (!sizeof (args)) {
        ret += "There are no night items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";
        }
      }
    break;
    case "protected":
      if (!PLAYTESTER_HAND->query_exec_access(this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "This facility is "
          "available only to PT Executives.\n", ({ }));
        return 0;
      }
      else {
        ret = pt_protected();
      }
    break;
  }
  write("$P$Items$P$" + ret);
  return 1;
}
private string time_string( int time_elapsed ) {
    string retval = "";
    int sec = time_elapsed % 60;
    int min = ( time_elapsed / 60 ) % 60;
    int hour = time_elapsed / 3600;
    if ( hour > 0 )
        retval += hour + "h";
    if ( min > 0 )
        retval += min + "m";
    if ( sec > 0 )
        retval += sec + "s";
    if ( sizeof( retval ) == 0 )
        return "0s";
    return retval;
}
int do_check_quota() {
    string* bits;
    string shortdate;
    int* spam;
    int reports;
    int age;
    int curage;
    mapping spamtoo;
    bits = explode( ctime( time() ), " " ) - ({ "" });
    shortdate = bits[ 1 ] + " " + bits[ 4 ];
    spamtoo = PLAYTESTER_HAND->
        query_bugs( this_player()->query_name() );
    if ( mapp( spamtoo ) ) {
        spam = spamtoo[ shortdate ];
        if ( arrayp( spam ) ) {
            reports = spam[ 0 ];
            age = spam[ 1 ];
            curage = PLAYTESTER_HAND->get_age_uncached(this_player()->query_name());
            age += curage - spam[2];
            tell_object( this_player(), "This month (" + shortdate + "), you "
                         "have made " + reports + " report" +
                         ( ( reports == 1 ) ? "" : "s" ) +  " in " +
                         time_string( age ) + " online.\n" );
            return 1;
        } else {
            tell_object( this_player(), "You cannot check your playtester "
                         "quota.\n" );
            return 1;
        }
    } else {
        tell_object( this_player(), "You cannot check your playtester "
                     "quota.\n" );
        return 1;
    }
}
int cmd_chats(object* obs) {
   mixed* chats;
   string ret;
   int i;
   object ob;
   ret = "";
   foreach (ob in obs) {
      ret += "$I$0=%^YELLOW%^$C$" + ob->the_short() + "%^RESET%^:\n";
      chats = ob->query_chat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_achat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Attack Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_chats();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Item Chats:%^RESET%^ (Min time " + chats[0] + ", "
                "Max time " + chats[1] + ")\n";
         foreach (string story in chats[2]) {
            ret += "$I$6=   " + story + "\n";
         }
      }
   }
   write("$P$Npc/Item chats$P$" + ret);
   return 1;
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "{chats|long|items|day items|night items|"
        "protected}", (: cmd($4[0]) :),
      "chats <indirect:object>",
        (: cmd_chats :),
      "quota", (: do_check_quota :),
    });
    return patterns;
}
string pt_protected() {
  object *obs = filter (users(), (: $1->query_playtester() :));
  string ret = "";
  obs = filter (obs, (: $1->query_pt_protection() :));
  if (!sizeof(obs)) {
    tell_object (this_player(), "No-one is currently using PT Protection.\n");
  }
  else {
    ret += "The following people have PT protection enabled:\n\n";
    foreach (object ob in obs) {
      ret += sprintf ("%s: %s (%s).\n\n", ob->query_name(),
        environment(ob)->query_short(), base_name (environment (ob)));
    }
  }
  return ret;
}

==================================================
FILE: playtester/comment.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
varargs int cmd(string name, string comment) {
  object ob = load_object (PT_APPLICATION_HANDLER);
  string ret = "";
  int i;
  if (!ob) {
    this_player()->add_failed_mess (this_object(), "Horrible, horrible "
      "error!\n", ({ }));
    return 0;
  }
  if (!sizeof (comment)) {
    this_player()->do_edit(0, "comment_editor", this_object(), "", name);
  }
  else {
    i =  ob->do_comment (name, comment);
    if (i) {
      tell_object (this_player(), "Thank you for your comments.\n");
    }
    else {
      tell_object (this_player(), "No candidate of that name registered.\n");
    }
  }
  return 1;
}
mixed* query_patterns() {
   return ({
      "<word'name'> <string'comment'>", (: cmd($4[0], $4[1]) :),
      "<word'name'>", (: cmd ($4[0]) :),
  });
}
void comment_editor (string comment, string name) {
  object ob = load_object (PT_APPLICATION_HANDLER);
  int i;
  if (!sizeof (comment)) {
    return;
  }
  else {
   i =  ob->do_comment (name, comment);
  }
  if (i) {
    tell_object (this_player(), "Thank you for your comments.\n");
  }
  else {
    tell_object (this_player(), "No candidate of that name registered.\n");
  }
}

==================================================
FILE: playtester/define.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   string ret;
   string* bing;
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object (player, "No definitions for " + word + ".\n");
      } else {
         ret = "";
         foreach (bing in results) {
            ret += bing[1] + "\n" + bing[2] + "\n\n";
         }
         tell_object(player, "Definitions for " + word + ":\n" + ret);
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->define_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   write ("You look up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: playtester/jumps.c
==================================================

#include <playtesters.h>
#define LOG_FILE PT_LOGS + "badge_log"
inherit "/cmds/base";
void log_attackers (object);
int do_list() {
   mapping jumps;
   string str;
   string start;
   string tmp;
   string* dest;
   object there;
   object to_there;
   object* theres;
   jumps = PLAYTESTER_HAND->query_jump_points();
   if (!sizeof(jumps)) {
      add_failed_mess("No current jumps.\n");
      return 0;
   }
   str = "Current jumps:\n";
   foreach (start, dest in jumps) {
      if ( !( there = find_object( start ) ) ) {
         catch(load_object(start));
         there = find_object( start );
         if ( !there ) {
           str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                           start, "Someone happy" );
           continue;
         }
      }
      theres = ({ });
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              continue;
            }
         }
         theres += ({ to_there });
      }
      str += "$I$6= * From " + there->the_short() + " [" +
             explode(start, "/")[1] + "] you can get to " +
             query_multiple_short(theres, "the") + ".\n";
   }
   write("$P$Jump points$P$" + str);
   return 1;
}
int do_list_from_here() {
   string* dest;
   string here;
   string str;
   string tmp;
   object to_there;
   int pos;
   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (sizeof(dest)) {
      str = "";
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%s will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              return 1;
            }
         }
         str += sprintf("$I$6=   %c: %s\n", pos + 'A', to_there->the_short());
         pos++;
      }
      write("$I$3=From here you can get to:\n" + str);
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}
int do_jump(string id) {
   string here;
   string* dest;
   string real_dest;
   object to_there;
   int pos;
   if (strlen(id) > 1) {
      add_failed_mess("The id to jump to must be a single letter.\n");
      return 0;
   }
   id = lower_case(id);
   pos = id[0] - 'a';
   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (!sizeof(dest)) {
      add_failed_mess("There are no jump points here.\n");
      return 0;
   }
   if (pos < 0 || pos >= sizeof(dest)) {
      add_failed_mess("The id must be in 'A'..'" +
                      sprintf("%c", sizeof(dest) + 'A') + "'.\n");
      return 0;
   }
   real_dest = dest[pos];
   if (real_dest) {
      if ( !( to_there = find_object( real_dest ) ) ) {
         catch(load_object(real_dest));
         to_there = find_object( real_dest );
         if ( !to_there ) {
           write(sprintf( "$I$3=%s will not load, please contact %s.\n",
                           real_dest, "Someone happy" ) );
           return 1;
         }
      }
      catch( log_attackers( this_player() ) );
      write( "Moving you to "+ to_there->the_short() +"...\n" );
      this_player()->move_with_look( to_there,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}
int do_armoury() {
   string env;
   string ret;
   object ob;
   env = file_name(environment(this_player()));
   if (environment(this_player())->query_armoury()) {
        ret = this_player()->query_property("pt return");
        if (ret) {
           if (strsrch(ret, "#") != -1) {
              if (!find_object(ret)) {
                 ret = 0;
              }
            } else if (!load_object (ret)) {
              ret = 0;
            }
        }
        if (!ret) {
           ret = this_player()->query_start_pos();
        }
      write( "Moving you from the pt armoury.\n");
      this_player()->move_with_look( ret,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   } else {
      catch( log_attackers( this_player() ) );
      write( "Moving you to the pt armoury.\n");
      if (explode (env,"/")[1] != "playtesters") {
        this_player()->add_property("pt return", env);
      }
      this_player()->move_with_look( PLAYTESTER_ARMOURY,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   }
   return 1;
}
protected void log_attackers( object o ) {
    string s;
    object* obs;
    object e;
    if ( sizeof( obs = o->query_attacker_list() ) > 0 ) {
        tell_object( o, "%^BOLD%^%^WHITE%^Please stop combat before using "
                     "the jumps command to go places.%^RESET%^\n" );
        e = environment( o );
        obs -= ({ 0 });
        obs = filter( obs, (: environment( $1 ) == $(e) :) );
        if ( sizeof( obs ) > 0 ) {
            s = ctime( time() ) + " - " + o->query_name() + " tried to "
                "teleport out of combat from " +
                ( environment( o ) ? file_name( environment( o ) ) :
                  "NULLSPACE" ) + "; query_attacker_list() == ({ ";
            foreach ( object ob in o->query_attacker_list() ) {
                s += "\"" + ob->query_short() + "\" [" +
                    file_name( ob ) + "]";
                if ( environment( ob ) != environment( o ) )
                    s += " (not in same room: " +
                        ( environment( ob ) ?
                          file_name( environment( ob ) ) :
                          "NULLSPACE" ) + ")";
                else
                    s += " (IN SAME ROOM)";
                s += ", ";
            }
            s += "});\n\n";
            log_file( LOG_FILE, s );
        }
    }
}
mixed* query_patterns() {
   return ({ "list", (: do_list :),
             "list here", (: do_list_from_here :),
             "goto <string'id'>", (: do_jump($4[0]) :),
             "armoury", (: do_armoury :) });
}

==================================================
FILE: playtester/playtesting.c
==================================================

#include <project_management.h>
#include <playtesters.h>
inherit "/cmds/base";
string format_array (string*);
string get_output (class project*, int);
mapping _globals = ([ ]);
varargs int cmd(string bing, string bong, string proj) {
  class project temp, *tmp = ({ });
  mapping query = ([ ]);
  string *blue, *blah;
  string ret = "";
  int verbose = 0, i;
  if (!PLAYTESTER_HAND->query_tester (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "Only playtesters may "
      "use this command.\n", ({ }));
    return 0;
  }
  if (bing == "list" && sizeof (bong)) {
    if (find_object ("/d/" + lower_case (bong) + "/master")) {
      bing = "domain";
    }
    else if (PLAYTESTER_HAND->query_tester (lower_case (bong))) {
      bing = "playtester";
    }
    else {
      bing = "nomatch";
    }
  }
  switch (bing) {
    case "assignments":
      bong = lower_case (bong);
      blue = PROJECT_HANDLER->query_pt_projects (bong);
      ret = sprintf (capitalize (bong) + " $I$5=%s.\n", (sizeof (blue) ? "is "
      "assigned to the following projects: " + query_multiple_short (blue) :
      "is not currently assigned to any projects"));
    break;
    case "allassign":
      blue = sort_array (PLAYTESTER_HAND->query_playtesters(), 1);
      foreach (string b in blue) {
        blah = PROJECT_HANDLER->query_pt_projects (b);
        ret += sprintf ("$I$5=%s is assigned to %s.\n",
          capitalize (b),
          (sizeof (blah) ? query_multiple_short (blah) : "nothing"));
      }
    case "list":
      query["status"] = "playtesting";
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "domain":
      query["status"] = "playtesting";
      query["domains"] = lower_case (bong);
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "playtester":
      query["status"] = "playtesting";
      query["playtesters"] = lower_case (bong);
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "details":
    case "report":
    case "assign":
    case "unassign":
      query["status"] = "playtesting";
      query["projid"] = bong;
      temp = PROJECT_HANDLER->get_project_file (bong);
      if (!temp) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in the handler.  Remember case sensitivity.\n", ({ }));
        return 0;
      }
      if (temp->status != member_array ("playtesting", STATUS)) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in playtesting.\n", ({ }));
        return 0;
      }
      if (temp) {
        tmp += ({ temp });
      }
      verbose = 1;
    break;
    case "passign":
    case "punassign":
       temp = PROJECT_HANDLER->get_project_file (proj);
       if (temp) {
        tmp += ({ temp });
      }
    break;
  }
  if (!sizeof (tmp) && !sizeof (ret)) {
    ret += "There are no projects in playtesting for this category.\n";
  }
  else {
    switch (bing) {
      case "passign":
        blue = PROJECT_HANDLER->add_playtester (proj, ({ bong }));
        if (!sizeof (blue)) {
          ret = "You cannot perform this operation.";
        }
        else {
          ret = "You assign " + capitalize (bong) + " to project " +
            proj + ".\n";
        }
      break;
      case "punassign":
        i = PROJECT_HANDLER->remove_playtester (proj, ({ bong }));
        if (!i) {
          ret = "This project does not exist.";
        }
        else {
          ret = "You remove " + capitalize (bong) + " from project " +
            proj + ".\n";
        }
      break;
      break;
      case "list":
      case "domain":
      case "playtester":
      case "details":
        ret = get_output (tmp, verbose);
      break;
      case "report":
      tell_object (this_player(), "Please enter your report for project " +
        bong + ".\n");
      this_player()->do_edit(0, "end_of_report");
      _globals [this_player()->query_name()]  = bong;
      break;
      case "assign":
      if (!PLAYTESTER_HAND->query_exec_access
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "execs can assign themselves to projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->add_playtester (bong,
          ({ this_player()->query_name() }), this_player()->query_name());
        ret += "You assign yourself to the project " + bong;
      }
      break;
      case "unassign":
      if (!PLAYTESTER_HAND->query_exec_access
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "Execs can unassign themselves from projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->remove_playtester (bong,
          ({ this_player()->query_name() }), this_player()->query_name());
        ret += "You unassign yourself from the project " + bong;
      }
      break;
    }
  }
  if (sizeof (ret)) {
    this_player()->more_string (ret);
  }
  return 1;
}
mixed *query_patterns() {
    mixed *patterns = ({ "list", (: cmd("list") :),
    "list <word>", (: cmd ( "list", $4[0]) :),
    "details <word>", (: cmd ( "details", $4[0]) :),
    "report <word>", (: cmd ( "report", $4[0]) :),
    "assign <word>", (: cmd ("assign", $4[0]) :),
    "unassign <word>", (: cmd ("unassign", $4[0]) :),
    "assignments [for] <word>", (: cmd ("assignments", $4[0]) :),
    "assignments", (: cmd ("allassign") :),
    });
    if (PLAYTESTER_HAND->query_exec_access (this_player()->query_name())) {
      patterns += ({
        "unassign <word> from <word>", (: cmd ("punassign", $4[0], $4[1]) :),
        "assign <word> to <word>", (: cmd ("passign", $4[0], $4[1]) :),
      });
    }
    return patterns;
}
string format_array (string *tmp) {
  if (!sizeof (tmp)) {
    return "None";
  }
  return query_multiple_short (map (tmp, (: capitalize ($1) :)));
}
string get_output (class project *tmp, int verbose) {
  int i;
  string ret = "";
  if (sizeof (tmp)) {
    if (!verbose) {
      ret += "The following projects match this query:\n";
      ret += sprintf ("%-20s %-40s %s\n\n", "Project ID",
          "Name", "Domains");
      foreach (class project p in tmp ) {
        ret += sprintf ("%-20s %-40s %s\n", p->id,
          p->name, format_array (p->domains));
      }
    }
    else {
      ret += "The details for this project are:\n\n";
      foreach (class project p in tmp ) {
        i = PROJECT_HANDLER->find_project (p->id);
        ret += sprintf ("$I$5=Project ID: %s\n$I$5=Project Name: %s\n$I$5="
        "Project Leader: %s\n$I$5=Description: %s\n$I$5=Domains: %s\n$I$5="
        "Creators: %s\n$I$5=Assigned Playtesters: "
        "%s.\n$I$5=Size: %s.\n$I$5=Complexity: %s.\n$I$5=Next Rotation: %s\n"
        "$I$5=Rotation: %d of %d.\n"
        "$I$5=Guilds: %s.\n"
        "$I$5=Playtester notes: "
        "%s\n$I$5=Flagged for playtesting: %s",
        p->id, p->name, capitalize (p->leader),
        replace (p->description, ({"\n\n", "\n"})),
        format_array (p->domains), format_array (p->creators),
        format_array (p->playtesters), (p->size != -1 ? SIZE[p->size] :
        "Unknown"),
        (p->complexity != -1 ? COMPLEXITY[p->complexity] : "Unknown"),
        (PROJECT_HANDLER->query_number_rotations() > p->current_rotation ?
        ctime (PROJECT_HANDLER->next_rotation_time (i)) : "On last rotation"),
        PROJECT_HANDLER->query_rotation (i),
        PROJECT_HANDLER->query_number_rotations (i),
        (sizeof (p->guild_specific) ? query_multiple_short (p->guild_specific) :
        "All guilds"),
        (sizeof (p->pt_notes) ? p->pt_notes :
        "None"), ctime(p->last_status_change));
      }
    }
  }
  return ret;
}
void end_of_report (string body) {
  int i = 0, j;
  if (!sizeof (body)) {
    tell_object (this_player(), "No report given.  Aborting.\n");
    return;
  }
  do {
    i++;
    j = PROJECT_HANDLER->find_note (_globals[this_player()->query_name()],
      capitalize (this_player()->query_name()) + "Report" + i);
  } while (j != -1);
  PROJECT_HANDLER->add_note_to_project (_globals[this_player()->query_name()],
    capitalize (this_player()->query_name()) + "Report" + i, body,
    this_player()->query_name());
  PLAYTESTER_HAND->adjust_quota( this_player()->query_name(), 1 );
  map_delete (_globals, this_player()->query_name());
  tell_object (this_player(), "Thank you for your report!\n");
}

==================================================
FILE: playtester/ptapp_lications.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
string query_applicant_text();
varargs int cmd(string check, string name) {
  string ret = "";
  mixed args;
  switch (check) {
    case "comments":
      if (!sizeof (name)) {
        ret = PT_APPLICATION_HANDLER->get_comment_list();
      }
      else {
        ret = PT_APPLICATION_HANDLER->get_comments_on_applicant (name);
      }
    break;
    break;
    case "summary":
    case "list":
      ret = "";
      ret =   PT_APPLICATION_HANDLER->get_applicant_list();
    break;
  }
  tell_object (this_player(), ret);
  return 1;
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "list", (: cmd("list") :),
    });
  if (this_player()->query_lord() ||
    load_object ("/d/playtesters/master")->query_deputy
    (this_player()->query_name())) {
    patterns +=
    ({
      "comments",  (: cmd ("comments") :),
      "comments for <string>", (: cmd ("comments", $4[0]) :),
    });
  }
    return patterns;
}

==================================================
FILE: playtester/pterrors.c
==================================================

inherit "/cmds/base";
#include <db.h>
#include <error_handler.h>
#include <player_handler.h>
void finish_lookup(object player, int type, mixed summary) {
   string bugs;
   class error_summary error;
   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bugs.\n" + summary + "\n");
      return ;
   }
   if (!sizeof(summary)) {
      tell_object(player, "No bugs found.\n");
      return ;
   }
   bugs = "";
   foreach (error in summary) {
      bugs += "#" + error->id + " " +
              ctime(error->entry_date)[4..15] +
              " by " + error->reporter + " (" +
              error->type + " - " + error->category + " - " +
              error->status + ")";
      if (error->assigned_to) {
         bugs += " assigned to " + error->assigned_to;
      }
      bugs += "\n";
   }
   tell_object(player, "$P$Bug List$P$" + bugs);
}
int cmd() {
   string fname;
   fname = base_name(environment(this_player()));
   if (!ERROR_HANDLER->do_query_open_bugs_for_fname(fname,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int do_query(string reporter, string status) {
   class error_query query;
   query = new(class error_query);
   if (status) {
      query->status = ({ status });
   }
   query->reporter = reporter;
   if (!this_player()->query_property("pterrors order")) {
      query->order_by = ERROR_ORDER_BY_DATE;
   } else {
      query->order_by = this_player()->query_property("pterrors order");
   }
   this_player()->add_property("pterrors query", query, 120);
   return ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :));
}
int cmd_next() {
   class error_query query;
   query = this_player()->query_property("pterrors query");
   if (!query) {
      add_failed_mess("You have not done a bugs query recently enough.\n");
      return 0;
   }
   query->bug_offset += 150;
   this_player()->add_property("pterrors query", query, 120);
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int cmd_mine(string status) {
   if (!do_query(this_player()->query_name(), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int cmd_order(string order) {
   switch (order) {
   case "date" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DATE);
      break;
   case "filename" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_FILENAME);
      break;
   case "directory" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DIRECTORY);
      break;
   }
   write("Set your pterrors bug order to " + order + "\n");
   return 1;
}
int cmd_ptbugs(string name, string status) {
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("There is no player called " + name + ".\n");
      return 0;
   }
   if (!do_query(lower_case(name), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
void finish_details(object player, int type, mixed details) {
   string bugs;
   class error_complete complete;
   class error_details error;
   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bug.\n" + details + "\n");
      return ;
   }
   if (!sizeof(details)) {
      tell_object(player, "No bugs found with that id.\n");
      return ;
   }
   bugs = "";
   foreach (complete in details) {
      error = complete->details;
      bugs += "%^BOLD%^#" + error->summary->id + " " +
              ctime(error->summary->entry_date)[4..15] +
              " by " + error->summary->reporter + " (" +
              error->summary->type + " - " + error->summary->category + " - " +
              error->summary->status + ")";
      if (error->summary->assigned_to) {
         bugs += " assigned to " + error->summary->assigned_to;
      }
      bugs += "\n%^RESET%^";
      bugs += error->report;
      if (player->query_creator()) {
         bugs += error->runtime;
      }
   }
   tell_object(player, "$P$Bug #" + error->summary->id + "$P$" + bugs);
}
int cmd_bug(int bug_id) {
   if (!ERROR_HANDLER->do_query_bug_details(bug_id,
                   (: finish_details($(this_player()), $1, $2) :))) {
      add_failed_mess("Unable to lookup the bug.\n");
      return 0;
   }
   write("Looking up bug, please wait.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd :),
             "next", (: cmd_next() :),
             "mine", (: cmd_mine(0) :),
             "mine status {open|fixed|considering|denied}", (: cmd_mine($4[0]) :),
             "order {date|directory|filename}", (: cmd_order($4[0]) :),
             "player <string'name'>", (: cmd_ptbugs($4[0], 0) :),
             "player <string'name'> status {open|fixed|considering|denied}", (: cmd_ptbugs($4[0], $4[1]) :),
             "<number>", (: cmd_bug($4[0]) :) });
}

==================================================
FILE: playtester/spell.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "Matches for " + word + ": None.\n");
      } else {
         tell_object(player, "Matches for " + word + ": " +
                             query_multiple_short(map(results, (: $1[1] :))) +
                             "\n");
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->spell_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   write ("You look up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: playtester/senior/mail.c
==================================================

#include <mail.h>
mixed cmd(string str) {
  return (int)MAIL_TRACK->mail(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: living/'_.c
==================================================

#include "/cmds/living/sa_y.c"

==================================================
FILE: living/:_.c
==================================================

inherit "/cmds/living/em_ote";

==================================================
FILE: living/accept.c
==================================================

#include <cmds/offer.h>
#include <money.h>
#include <move_failures.h>
inherit "/cmds/base";
int is_in(object ob, object source);
int do_buy(object *people) {
   object person;
   int ret;
   class offer_sale wombat;
   object *obs;
   object *moved;
   mixed *payment;
   object ob;
   int i;
   foreach (person in people) {
      wombat = this_player()->query_respond_command("sell", person);
      if (wombat) {
         obs = filter(wombat->sell_obs, (: is_in($1, $2) :),
                      wombat->seller);
         if (sizeof(obs) != sizeof(wombat->sell_obs)) {
            add_failed_mess("$I no longer has " +
                            query_multiple_short(wombat->sell_obs - obs) +
                            " to buy.\n",
                            ({ person }) );
         } else if (this_player()->query_value_in(wombat->place) <
                    wombat->value) {
            add_failed_mess("You no longer have enough money to buy " +
                            query_multiple_short(wombat->sell_obs) +
                            " from $I.\n", ({ person }));
         } else {
            payment = MONEY_HAND->query_person_payments(wombat->value,
                                                        wombat->place,
                                                        this_player(), person);
            if (!payment) {
               add_failed_mess("You no longer have the correct change "
                               "to pay for $I.\n", ({ person }) );
            } else {
               moved = ({ });
               foreach (ob in wombat->sell_obs) {
                  if (ob->move(this_player()) == MOVE_OK) {
                     moved += ({ ob });
                  }
               }
               if (sizeof(moved) != sizeof(wombat->sell_obs)) {
                  moved->move(person);
                  tell_object(person, "Unable to move " +
                                      query_multiple_short(wombat->sell_obs -
                                                           moved) +
                                      " out of your inventory, cancelling "
                                      "the sale.\n");
                  add_failed_mess("Unable to move some objects out "
                                  "of the inventory of $I, canceling sale.\n",
                                  ({ person }) );
               } else {
                  if (sizeof(payment[MONEY_PAY_CHANGE])) {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " from " + this_player()->the_short() +
                              " and give back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " to " + person->the_short() +
                              " and receive back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                  } else {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " from " + this_player()->the_short() +".\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " to " + person->the_short() + ".\n");
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_RETURN]); i += 2) {
                     this_player()->adjust_money(-payment[MONEY_PAY_RETURN][i+1],
                                                 payment[MONEY_PAY_RETURN][i]);
                     person->adjust_money(payment[MONEY_PAY_RETURN][i+1],
                                          payment[MONEY_PAY_RETURN][i]);
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_CHANGE]); i += 2) {
                     person->adjust_money(-payment[MONEY_PAY_CHANGE][i+1],
                                                 payment[MONEY_PAY_CHANGE][i]);
                     this_player()->adjust_money(payment[MONEY_PAY_CHANGE][i+1],
                                          payment[MONEY_PAY_CHANGE][i]);
                  }
                  add_succeeded_mess("$N buy$s " +
                                     query_multiple_short(wombat->sell_obs) +
                                     " from $I.\n", ({ person }) );
                  ret++;
               }
            }
         }
         this_player()->remove_respond_command("sell", person);
      } else {
         add_failed_mess("Sorry, $I has not offered to sell you anything.\n",
                         ({ person }) );
      }
   }
   return ret;
}
int is_in(object ob, object source) {
   object env;
   if (!ob) {
      return 0;
   }
   env = ob;
   do {
      env = environment(env);
      if (env == source) {
         return 1;
      }
   } while (env);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer from <indirect:living'person'>", (: do_buy($1) :) });
}
int query_theft_command() {
   return 1;
}

==================================================
FILE: living/attack.c
==================================================

inherit "/cmds/living/kill";

==================================================
FILE: living/climb.c
==================================================

#include <tasks.h>
#define TP this_player()
#define SKILL "other.movement.climbing.rock"
inherit "/cmds/base";
void fall_off( object place, int number ) {
   if ( place->query_at_bottom() ) {
      write( "You try to climb, but you can't seem to get anywhere.\n" );
      say( (string)TP->one_short() + " tries to climb, but fails.\n" );
      return;
   }
   if ( random( (int)TP->query_dex() ) < number / 20 ) {
      write( "You begin to climb, but your fatigue makes you "+
            "clumsily lose your grip.\n" );
      say( (string)TP->one_short() +
            " begins to climb but clumsily loses "+
            (string)TP->query_possessive() +" grip.\n" );
      place->fall_down( TP );
      return;
   }
   write( "You begin to climb but wobble precariously and decide to "+
         "stay put for the moment.\n" );
   say( (string)TP->one_short() +
            " begins to climb, but wobbles precariously and stops.\n" );
}
mixed cmd( string words ) {
   int difficulty;
   object place;
   mixed ghost_action;
   mixed *move;
   string *move_descs = ({ "", "", "" });
   string skill;
   place = environment( TP );
   if ( !place ) {
      add_failed_mess( "You cannot climb anything: you're in limbo!\n" );
      return 0;
   }
   move = (mixed *)place->query_move( words );
   if ( !move ) {
      if( sizeof( place->query_moves() ) )
         add_failed_mess( "You cannot climb \""+ words +"\" from here.\n" );
      else
         add_failed_mess( "There is nothing to climb here.\n" );
      return 0;
   }
   if( stringp( move[2] ) ) {
      move_descs[0] =
         "You climb "+ words +".\n";
      move_descs[1] =
         "$N slowly climb$s "+ words +" and disappears from view.";
      move_descs[2] =
         copy( move[2] );
   } else if( sizeof( move[2] ) == 3 ) {
      move_descs = copy( move[2] );
      move_descs[0] += "\n";
   } else {
      return 0;
   }
   if ( TP->query_property( "dead" ) ) {
      ghost_action = place->query_ghost_action( place );
      if ( ! ghost_action ) {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
      else if ( intp( ghost_action ) && ghost_action == 1 ) {
          add_failed_mess( "How can you climb anything?  You're dead!\n");
          return 0;
      }
      else if ( stringp( ghost_action ) ) {
          write( "As you move to climb the wall, your inherent wispiness gets "
              "the better of you, and you fall through to the other side.\n" );
          TP->move_with_look( ghost_action,
              "$N wisps through the wall with some undue haste.",
              "$N tries to climb the wall, but falls through it." );
          add_succeeded_mess( "" );
          return 1;
      }
      else if ( arrayp( ghost_action ) ) {
          write( ghost_action[ 1 ][ 0 ] + "\n" );
          TP->move_with_look( ghost_action[ 0 ],
              ghost_action[ 1 ][ 1 ], ghost_action[ 1 ][ 2 ] );
          add_succeeded_mess( "" );
          return 1;
      }
      else {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
   }
   if( intp( move[0] ) ) {
      difficulty = move[0] + (int)TP->query_loc_weight() / 10;
      skill = SKILL;
   } else if( arrayp( move[0] ) && sizeof( move[0] ) > 1 ) {
      difficulty = move[0][0] + (int)TP->query_loc_weight() / 10;
      skill = move[0][1];
      debug_printf( "Base difficulty: %d, total difficulty: %d, skill: %s\n",
                    move[0][0], difficulty, move[0][1] );
   }
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty / 2 );
   switch ( (int)TASKER->perform_task(TP, skill, difficulty,
                                      TM_COMMAND)) {
      case AWARD :
         call_out( "advance_notice", random( 60 ), TP );
      case SUCCEED :
         write( move_descs[ 0 ] );
         TP->move_with_look( move[ 1 ], move_descs[ 2 ],
               move_descs[ 1 ] );
         return 1;
      default :
         break;
   }
   difficulty = random( difficulty );
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty );
   switch ( (int)TASKER->perform_task(TP, skill,  difficulty / 2,
                                      TM_COMMAND)) {
      case AWARD :
         write( "%^YELLOW%^You manage not to fall off!%^RESET%^\n" );
      case SUCCEED :
         write( "You begin to climb but wobble precariously and decide to "+
               "stay put for the moment.\n" );
         say( (string)TP->one_short() +
               " begins to climb, but wobbles precariously and stops.\n" );
         break;
      default :
         fall_off( place, difficulty );
         break;
   }
   add_succeeded_mess("");
   return 1;
}
void advance_notice( object thing ) {
   if ( !thing )
      return;
   tell_object( thing, "%^YELLOW%^"+ ({
      "In a flash of inspiration, you realise how to balance better "+
            "when climbing.",
      "Thinking about your climb, you realise something important.",
      "You realise that you've been using better grips to climb.",
      "You realise you've discovered how to find better places to "+
            "support your feet.",
      "You find you've worked out a more sensible way to distribute "+
            "your weight as you climb.",
      "With all your climbing, you discover you've found a better way "+
            "to locate handholds."
   })[ random( 6 ) ] +"%^RESET%^\n" );
}
mixed *query_patterns() {
   return ({ "<string'direction'>", (: cmd($4[0]) :) });
}

==================================================
FILE: living/concentrate.c
==================================================

inherit "/cmds/base";
int concentrate_list( ) {
   object conc;
   conc = this_player()->query_concentrating();
   if ( !conc ) {
      write("You are not currently concentrating on "
                  "any particular opponent.\n" );
   } else {
      write("You are currently concentrating on "+
            conc->the_short() + ".\n");
   }
   return 1;
}
int concentrate(object *things ) {
   if ( sizeof( things ) > 1 ) {
      return notify_fail( "You can only concentrate on one thing at once.\n" );
   }
   if (!sizeof(this_player()->query_attacker_list())) {
      add_failed_mess("You are not fighting anyone.\n");
      return 0;
   }
   if ( things[0] == this_player() ) {
      return notify_fail( "It would be silly to concentrate on yourself.\n" );
   }
   if (member_array(things[0], this_player()->query_attacker_list()) == -1) {
     return notify_fail("You can only concentrate on people you are "
                        "fighting.\n");
   }
   if (this_player()->set_concentrating(things[0])) {
        add_succeeded_mess(({"You are now concentrating on $I.\n", "" }),
                           things);
   } else {
      add_succeeded_mess(({"Unable to concentrate on $I.\n", "" }), things);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "[on] <indirect:living>", (: concentrate($1) :),
             "", (: concentrate_list() :) });
}

==================================================
FILE: living/crawl.c
==================================================

#define EFFECTPATH "/std/effects/other/"
#define PT "/obj/handlers/playtesters"
inherit "/cmds/base";
int is_in_water( object room );
varargs int cmd( string str ) {
   if( str == "stop" ) {
      if( !this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You should be crawling first in order"
                                         " to stop doing it, don't you "
                                         "think?\n",
                                         ({ }) );
         return 0;
      };
      this_player()->stop_crawling();
      return 1;
   };
   if( !str ) {
      if( this_player()->query_property( "dead" ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You appear to be dead.  There is no "
                                         "necessity to torture your morphogenic"
                                         " arms, you know?\n",
                                         ({ }) );
         return 0;
      } else if( this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are already crawling.\n",
                                         ({ }) );
         return 0;
      } else if( is_in_water( environment( this_player() ) ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are in water at the moment, so "
                                         "crawling is impossible.\n",
                                         ({ }) );
         return 0;
      } else {
         this_player()->add_effect( EFFECTPATH + "crawling" );
         return 1;
      };
   };
}
mixed* query_patterns() {
   return ({
      "", (: cmd() :),
      "stop", (: cmd( "stop" ) :)
   });
}
int is_in_water( object room ) {
   if( inherits( "/std/water_inside.c", room ) ||
       inherits("/std/water_outside.c", room ) ||
       inherits("/std/uwater.c", room ) ) {
      return 1;
   } else
      return 0;
}

==================================================
FILE: living/crouch.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("crouch", "down", CROUCHING);
}

==================================================
FILE: living/debate.c
==================================================

#include <tasks.h>
#define EFFECT "/std/effects/religious/theological_debate"
#define HANDLER "/obj/handlers/philosophies"
#define DEBATE_MULT 4
inherit "/cmds/base";
mapping _debaters;
void create() {
   _debaters = ([ ]);
}
mixed cmd(object * indirect_obs,
          string indir_match,
          string dir_match,
          mixed *args,
          string pattern)
{
   int bonus;
   string topic;
   string type;
   string needed;
   object target;
   if (sizeof((int *)this_player()->effects_matching("debating"))) {
      return notify_fail("You are already engaged in a debate.\n");
   }
   if (_debaters[this_player()]) {
      tell_object(_debaters[this_player()][0],
                  this_player()->the_short() + " withdraws their debating "
                  "challenge from you.\n");
      map_delete(_debaters, this_player());
   }
   target = indirect_obs[0];
   if (target == this_player()) {
      return notify_fail("Debating with yourself?  Which one of your "
         "personalities are you trying to outwit?\n");
   }
   if (userp(target) && !interactive(target)) {
      return notify_fail("How can you debate anything with a net-dead "
                         "statue?\n");
   }
   topic = args[0];
   if (_debaters[target] && _debaters[target][0] == this_player()) {
      if ((_debaters[target][0] == this_player()) &&
          (_debaters[target][1] == topic)) {
         write("You accept " + (string) target->the_short() +
               "'s challenge to debate " + topic + ".\n");
         say((string) this_player()->the_short() + " accepts " +
             (string) target->the_short() + "'s challenge to debate " +
             topic + ".\n", target);
         tell_object(target, (string) this_player()->the_short() +
                     " accepts your challenge to debate " + topic + ".\n");
         map_delete(_debaters, target);
         this_player()->add_effect(EFFECT, target);
         target->add_effect(EFFECT, this_player());
         return 1;
      }
   }
   if (!HANDLER->query_philosophy(topic)) {
      return notify_fail("You cannot debate \"" + topic + "\".  You can " +
                         "debate " + query_multiple_short((string *) HANDLER->
                                                          query_philosophy_names
                                                          ()) + ".\n");
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) HANDLER->query_philosophy_bonus(topic);
   needed = (string) HANDLER->query_philosophy_needed(topic);
   if (this_player()->query_skill_bonus(type + ".points") < bonus) {
      return notify_fail(needed + " is not sufficient to debate " +
                         topic + " at the moment.\n");
   }
   if (this_player()->query_specific_gp(type) < bonus) {
      return notify_fail("You are too tired to debate " + topic +
                         " at the moment.\n");
   }
   this_player()->adjust_gp(-(bonus * DEBATE_MULT));
   write("You challenge " + (string) target->the_short() +
         " to a debate on " + topic + ".\n");
   say((string) this_player()->one_short() + " challenges " +
       (string) target->one_short() + " to a debate on " + topic + ".\n",
       target);
   tell_object(target,
               (string) this_player()->one_short() +
               " challenges you to a debate on " + topic + ".\n");
   _debaters[this_player()] = ({ target, topic });
   call_out("answer_challenge", 5, this_player(), target, topic);
   return 1;
}
void answer_challenge(object challenger,
                      object target,
                      string topic)
{
   int bonus;
   int diff;
   string type;
   if (!challenger) {
      return;
   }
   if (!target) {
      return;
   }
   if (environment(challenger) != environment(target)) {
      return;
   }
   if (!_debaters[challenger]) {
      return;
   }
   if ((_debaters[challenger][0] != target) || (_debaters[challenger][1] != topic)) {
      return;
   }
   if (pk_check(challenger, target)) {
      tell_object(target, "Use \"debate " + topic + " with " +
                  (string) challenger->query_name() +
                  "\" to accept the challenge.\n");
      return;
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) target->query_skill_bonus(type + ".points");
   diff = (int) target->query_skill_bonus(type + ".points") / 3;
   switch ((int) TASKER->perform_task(challenger, type + ".points", 2 * diff,
                                      TM_COMMAND)) {
   case AWARD:
      tell_object(challenger, "You feel " +
                  (string) HANDLER->query_philosophy_needed(topic) +
                  " surge for a moment.\n");
   case SUCCEED:
      tell_object(target, "You find yourself accepting " +
                  (string) challenger->the_short() +
                  "'s challenge to debate " + topic + ".\n");
      tell_room(environment(target),
                (string) target->the_short() + " accepts " +
                (string) challenger->the_short() + "'s challenge to debate " +
                topic + ".\n", ({ target, challenger }));
      tell_object(challenger,
                  (string) target->the_short() +
                  " accepts your challenge to debate " + topic + ".\n");
      map_delete(_debaters, target);
      this_player()->add_effect(EFFECT, target);
      target->add_effect(EFFECT, this_player());
      return;
   default:
      if (userp(target)) {
         tell_object(target, "Use \"debate " + topic + " with " +
                     (string) challenger->query_name() +
                     "\" to accept the challenge.\n");
      }
   }
}
mapping query_debaters()
{
   return _debaters;
}
mixed *query_patterns()
{
   return ({ "<word'topic'> with <indirect:living'person'>",
             (: cmd($1, $2, $3, $4, $5) :) });
}

==================================================
FILE: living/defend.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *defendees;
  things -= ({ TP });
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much defense as a ghost.\n" );
    return 0;
  }
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot defend yourself!\n");
     return 0;
  }
  if(TP->query_combat_response() != "parry") {
    add_failed_mess("Dodging out of the way will not help " +
                    query_multiple_short(things) + ".\n");
    return 0;
  }
  defendees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_defender( TP ) ) {
      defendees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( defendees ) ) {
    add_failed_mess("You cannot defend $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot defend "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will defend $I.\n",
                        "$N moves to defend $I.\n" }),
                  defendees);
  return 1;
}
int show_defenders() {
   object *defend;
   object womble;
   defend = this_player()->query_defenders();
   if (sizeof(defend)) {
      write("You are being defended by " + query_multiple_short(defend) +
            ".\n");
   } else {
      write("You are not being defended by anyone.\n");
   }
   defend = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_defenders()) != -1) {
            defend += ({ womble });
         }
      }
   }
   if (sizeof(defend)) {
      write("Of the people in this room, you are defending " +
            query_multiple_short(defend) + ".\n");
   } else {
      write("You are not defending anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_defenders() :) });
}

==================================================
FILE: living/double_quote.c
==================================================

#include "/cmds/living/lsay.c"

==================================================
FILE: living/drag.c
==================================================

#include <player.h>
#include <room.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd( object *indirect_obs, string direction) {
  string owner;
  object owner_ob;
  string *words, word;
  if( this_player()->query_property( "dead" ) )
    return add_failed_mess( "You're dead.  You can't drag anything.\n" );
  if( objectp( (object)this_player()->query_dragging() ) )
    return add_failed_mess( "You're already dragging something.\n" );
  if( sizeof( indirect_obs ) > 1 )
    return add_failed_mess( "You can only drag one thing at a time.\n" );
  if( indirect_obs[0] == this_player() )
    return add_failed_mess( "You try and drag yourself away from the keyboard, "
      "but you cannot.  Oh no!\n");
  if( living( indirect_obs[ 0 ] ) ) {
    if( !indirect_obs[ 0 ]->query_property( PASSED_OUT_PROP )
        || pk_check( indirect_obs[ 0 ], this_player() ) )
      return add_failed_mess( (string)indirect_obs[ 0 ]->the_short() +
        " doesn't want to be dragged away, thank you very much.\n" );
  } else
    if( base_name(indirect_obs[0]) == "/obj/corpse" ) {
      owner = indirect_obs[ 0 ]->query_owner();
      words = explode( lower_case( owner ),  " " );
      words = filter( words, (: PLAYER_HANDLER->test_user($1) :) );
      foreach( word in words ) {
          owner_ob = find_player( lower_case( word ) );
          if( owner_ob && userp( owner_ob ) &&
            pk_check( owner_ob, this_player() ) &&
            member_array ( this_player()->query_name(), indirect_obs[0]->
            query_permitted() ) == -1 )
            return add_failed_mess( "For some reason, you can't get hold of "+
              (string)indirect_obs[ 0 ]->the_short() +".\n" );
      }
  }
  if( ( environment( indirect_obs[ 0 ] ) != environment( this_player() ) ) ||
    indirect_obs[ 0 ]->get() )
      return add_failed_mess( "For some reason, you can't get hold of " +
        (string)indirect_obs[ 0 ]->the_short() +".\n" );
  write( "You get hold of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->one_short() + " gets hold of " +
    (string)indirect_obs[ 0 ]->a_short() + ".\n" );
  if( (int)indirect_obs[ 0 ]->query_complete_weight() +
    (int)this_player()->query_loc_weight() > 2 *
    (int)this_player()->query_max_weight() ) {
      write( "You struggle and strain, but you can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
      say( (string)this_player()->one_short() + " struggles and strains, but " +
        (string)this_player()->query_pronoun() + " can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
  } else {
    this_player()->set_dragging( indirect_obs[ 0 ] );
    if( !this_player()->exit_command( direction ) )
      write( "You can't drag " + (string)indirect_obs[ 0 ]->the_short() +
        " that way.\n" );
    else
      if( interactive( this_player() ) )
        indirect_obs[0]->add_property( "dropped",
          ({this_player()->query_name(), query_ip_number( this_player() ),
          time()}), 1800 );
    this_player()->reset_dragging();
  }
  write( "You let go of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->the_short() + " releases " +
    (string)this_player()->query_possessive() + " hold of " +
    (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  return 1;
}
mixed *query_patterns() {
  return
    ({ "<indirect:object:here> [to] <word'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :),
       "<indirect:object:here> [to] <string'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :) });
}

==================================================
FILE: living/draw.c
==================================================

#include <move_failures.h>
#include <obj_parser.h>
#define DEFAULT -1
#define LEFT 0
#define RIGHT 1
inherit "/cmds/base";
int cmd( string weapon_str, object * scabbards, string hand_str ) {
   object scabbard, * weapons, weapon;
   class obj_match match;
   string *limbs;
   string *hands;
   int *what_in;
   int targeted, result;
   int hand;
   match = new( class obj_match );
   targeted = scabbards ? 1 : 0;
   debug_printf( "targeted = %d\nscabbards = %O\n", targeted, scabbards );
   if( !scabbards ) {
      scabbards = filter( all_inventory( this_player() ),
        (: $1->query_scabbard() :) );
      if( !sizeof(scabbards) ) {
         add_failed_mess( "Can't find any scabbards in your inventory.\n" );
         return 0;
      }
      foreach( scabbard in scabbards ) {
         match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
           0, this_player() );
         result = match->result;
         if( result == OBJ_PARSER_SUCCESS ) {
            weapons = match->objects;
            break;
         } else if( result == OBJ_PARSER_AMBIGUOUS ) {
            add_failed_mess( "Ambiguous reference to \"" + weapon_str
              + "\" in at least one scabbard.\n" );
         }
      }
      if( !sizeof(weapons) ) {
         add_failed_mess( "Cannot find " + weapon_str + " in any "
           "scabbard in your inventory.\n" );
         return 0;
      }
   } else {
      if( sizeof(scabbards) > 1 ) {
         add_failed_mess( "You can only draw from one scabbard at a "
           "time.\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not a scabbard.\n" );
         return 0;
      }
      if ( environment(scabbard) != this_player() ) {
         add_failed_mess( "You can only draw from a scabbard in your "
           "inventory.\n" );
         return -1;
      }
      match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
        0, this_player() );
      if( match->result == OBJ_PARSER_SUCCESS ) {
         weapons = match->objects;
      } else {
         add_failed_mess( "Cannot find " + weapon_str + " in " +
           scabbard->the_short() + ".\n" );
         return -1;
      }
   }
   weapon = weapons[0];
   if ( scabbard->query_closed() ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + "; it is closed.\n" );
      return targeted ? -1 : 0;
   }
   if( !scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if ( weapon->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  hand = -1;
   else hand = member_array(hand_str, this_player()->query_limbs());
   if ( !sizeof( weapon->hold_item( this_player(), hand ) ) ) {
      weapon->move( scabbard );
      add_failed_mess( "You cannot hold " + weapon->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  {
      limbs = this_player()->query_limbs();
      what_in = find_member(weapon, this_player()->query_holding());
      hands = allocate(sizeof(what_in));
      for (hand = 0; hand < sizeof(what_in); hand++)
         hands[hand] = limbs[what_in[hand]];
      hand_str = query_multiple_short(hands);
   }
   this_player()->add_succeeded_mess(scabbard, "$N $V $I from $D into $p " +
                                     hand_str + ".\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   string limbs;
   limbs = "{" + implode(this_player()->query_limbs(), "|") + "}";
   return ({
      "<string'weapon'>",
        (: cmd( $4[0], 0, 0 ) :),
      "<string'weapon'> from <indirect:object:me'scabbard'>",
        (: cmd( $4[0], $1, 0 ) :),
      "<string'weapon'> into [my] " + limbs,
        (: cmd($4[0], 0, $4[1]) :),
      "<string'weapon'> from <indirect:object:me'scabbard'> into [my] " + limbs,
        (: cmd( $4[0], $1, $4[2]) :),
   });
}

==================================================
FILE: living/drop.c
==================================================

#include <move_failures.h>
#include <player.h>
#define MAX_DROP_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *obs, string str) {
   int num, max;
   object bing;
   string env_sh;
   object ob;
   object *fail;
   object *too_many;
   object *keep;
   mapping ret;
   object env;
   string drop_mess;
   ret = ([ ]);
   fail = ({ });
   too_many = ({ });
   keep = ({ });
   if (sizeof(obs) > MAX_DROP_NUMBER) {
      too_many = obs[MAX_DROP_NUMBER..];
      obs = obs[0..MAX_DROP_NUMBER-1];
   }
   foreach(ob in obs) {
      if (!ob->short()) {
         continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      env = environment(ob);
      if (function_exists("do_drop", ob) ||
            function_exists("command_control", ob)) {
         if (function_exists("do_drop", ob)) {
            max = (int)call_other(ob, "do_drop", ({ }), str, 0, ({ str }),
                                             "<direct:object:me>");
         } else {
            max = ob->command_control("drop", ({ }), str, 0, ({ str }),
                                                   "<direct:object:me>");
         }
         if (max == 0)  {
            fail += ({ ob });
            continue;
         }
      }
      if (ob->move(environment(TP)) == MOVE_OK) {
         if (ret[env]) {
            ret[env] += ({ ob });
         } else {
            ret[env] = ({ ob });
         }
#ifndef __DISTRUBUTION_LIB__
         if(interactive(TP))
           PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
      } else {
        fail += ({ ob });
      }
   }
   if (sizeof(ret)) {
      foreach (env, bing in ret) {
         if (env != this_player()) {
            env_sh = " from inside " + inside_the_short(env);
         } else {
            env_sh = "";
         }
         if ( drop_mess = this_player()->query_drop_mess() ) {
            add_succeeded_mess( drop_mess, bing );
         }
         else {
            add_succeeded_mess("$N $V $I" + env_sh + ".\n", bing);
         }
      }
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding.\n", "" }));
      }
   } else {
      if (sizeof(keep)) {
         add_failed_mess("You are keeping $I.\n", keep);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot drop $I.\n", fail);
         return 0;
      }
      if (sizeof(too_many)) {
         add_failed_mess("You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding $I.\n", too_many);
         return 0;
      }
   }
   num = sizeof(fail)+sizeof(ret);
   if (!num) {
        return 0;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1, $3) :) });
}

==================================================
FILE: living/dry.c
==================================================

inherit "/cmds/base";
mixed cmd(mixed *things)
{
   int pwet;
   int twet;
   int max;
   int *enums;
   object thing;
   object with;
   thing = things[0][0];
   with = things[1][0];
   if (!with->id("towel") && !with->query_property("dryer")) {
      return notify_fail("You can't dry anyone with " +
                         (string) with->the_short() + ".\n");
   }
   if (environment(with) != this_player())  {
      return notify_fail(with->a_short() + " isn't going to do much good "
         "inside " + environment(with)->a_short() + ".\n");
   }
   if (thing->query_property("dead")) {
      return notify_fail((string) thing->the_short() + " is dead; " +
                         (string) thing->query_pronoun() +
                         " has more immediate problems than being wet.\n");
   }
   max = 200 * (int) with->query_weight();
   enums = (int *) with->effects_matching("object.wet");
   if (sizeof(enums)) {
      twet = (int) with->arg_of(enums[0]);
   }
   if (twet > max / 2) {
      return notify_fail((string) with->the_short() +
                         " is already dripping wet.  You can't dry anybody "
                         "with it.\n");
   }
   enums = (int *) thing->effects_matching("body.wetness");
   if (sizeof(enums)) {
      pwet = (int) thing->arg_of(enums[0]);
   }
   if (pwet < 10) {
      if (thing == this_player()) {
         return notify_fail("You don't need drying.\n");
      } else {
         return notify_fail((string) thing->the_short() +
                            " doesn't need drying.\n");
      }
   }
   if (pwet + twet > max) {
      pwet = max - twet;
   }
   pwet -= random(10);
   if (pwet > 0) {
      thing->add_effect("/std/effects/other/wetness", -pwet);
      with->add_effect("/std/effects/object/wet", pwet);
   }
   if (thing == this_player()) {
      write("You dry yourself with " + with->the_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) this_player()->query_objective() + "self with " +
          (string) with->poss_short() + ".\n");
   } else {
      write("You dry " + (string) thing->the_short() + " with " +
            (string) with->the_short() + ".\n");
      tell_object(thing, (string) this_player()->one_short() +
                  " dries you with " + (string) with->poss_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) thing->the_short() + " with " +
          (string) with->poss_short() + ".\n", thing);
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:living'person'> with <indirect:object:me>",
             (: cmd($1) :),
             "myself with <indirect:object:me>",
             (: cmd(({ ({ this_player() }), $1 })) :) });
}

==================================================
FILE: living/echo.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("echo"))
    return notify_fail(NOT_ALLOWED);
  if (!str || str == "")
    return notify_fail("Syntax : echo <text>\n");
  if (!TP->query_creator() && TP->adjust_sp(-ECHO_COST) < 0)
    return notify_fail(NO_POWER);
  if (TP->query_volume(D_ALCOHOL))
    str = TP->drunk_speech(str);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos: "+
     str+"\n");
  str += "%^RESET%^";
  my_mess("You echo: ", str);
  TP->comm_event(environment(TP), "player_echo", str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/echoto.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string who, what;
  object ob;
  if(!TP->query_creator() && !TP->query_property("echoto"))
    return notify_fail(NOT_ALLOWED);
  if(!str || str == "")
    return notify_fail("Syntax : echoto <player> <text>\n");
  if(sscanf(str, "%s %s", who, what) != 2)
    return notify_fail("Syntax : echoto <player> <text>\n");
  who = lower_case(who);
  who = (string)TP->expand_nickname(who);
  if(!TP->query_creator() && TP->adjust_sp(-ECHOTO_COST) < 0)
    return notify_fail(NO_POWER);
  ob = find_player(who);
  if(!ob)
    return notify_fail("Can't find "+who+".\n");
  if (TP->query_volume(D_ALCOHOL))
    what = TP->drunk_speech(what);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos "+
     "to "+who+": "+what+"\n" );
  what += "%^RESET%^";
  my_mess("You echo to " + who + ": ", what);
  event(ob, "player_echo_to", what + "\n", TP);
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/em_ote.c
==================================================

#include <library.h>
#include <player.h>
inherit "/cmds/base";
mixed cmd( string words ) {
  string pad = " ";
  if(!environment(this_player())) {
    return notify_fail("You are in limbo, you cannot emote.\n");
  }
  if ( userp( this_player() ) && !this_player()->query_creator() ) {
    if ( this_player()->query_property( "emote" ) ) {
      LIBRARY->set_quest( (string)this_player()->query_name(), "emote" );
      this_player()->remove_property( "emote" );
    }
    if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
                                     "emote" ) ) {
      return notify_fail( NOT_ALLOWED );
    }
    if(this_player()->query_property("no emote")) {
      return notify_fail(NOT_ALLOWED);
    }
    if ( (int)this_player()->adjust_sp( -EMOTE_COST ) < 0 ) {
      return notify_fail( NO_POWER );
    }
  }
  if ( !words || ( words == "" ) ) {
    return notify_fail( "Syntax: emote <text>\n" );
  }
  words = strip_colours(words);
  words = replace(words, ({"        ", " ",
                           "       ", " ",
                           "      ", " ",
                           "     ", " ",
                           "    ", " ",
                           "   ", " ",
                            }) );
  this_player()->adjust_time_left( -5 );
  if (words[0..0] == "'") pad = "";
  environment( this_player() )->event_emote( this_player(),
                                             "$C$" + this_player()->one_short() + pad +
                                             words +"\n" );
  all_inventory( environment( this_player() ) )->
    event_emote( this_player(), "$C$" + this_player()->one_short() +
                                pad + words + "%^RESET%^\n" );
  write( "You emote: $C$"+
         (string)this_player()->pretty_short( this_player() ) + pad + words +
         "%^RESET%^\n" );
  return 1;
}

==================================================
FILE: living/emoteall.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
#define BEEP sprintf("%c",7)
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("emoteall")) {
    return notify_fail(NOT_ALLOWED);
  }
  if(!str || str == "") {
    return notify_fail("Syntax : emoteall <string>\n");
  }
  if(!TP->query_creator() &&
     TP->adjust_sp(-EMOTEALL_COST*((strlen(str)/10)+1)+100) < 0) {
    return notify_fail(NO_POWER);
  }
  str = replace(str, BEEP, "");
  if (TP->query_volume(D_ALCOHOL)) {
    str = TP->drunk_speech(str);
  }
  log_file("ECHOS", ctime(time())+" "+TP->query_name()+" emotes "+
           "to all: "+str+"\n");
  str += "%^RESET%^";
  my_mess("You emoteall : ", TP->query_cap_name()+" " + str);
  TP->comm_event(users(), "player_emote_all", "%^BOLD%^%^RED%^" + TP->query_cap_name() + " " + str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/eq_uip.c
==================================================

#define TP this_player()
inherit "/cmds/base";
int cmd() {
   int no_limbs;
   string stuff;
   object thing;
   object *equipped;
   object *things;
   equipped = ({ });
   things = all_inventory( TP ) - TP->query_wearing() -
            TP->query_holding();
   foreach ( thing in things ) {
      no_limbs = thing->query_no_limbs();
      if ( no_limbs > TP->query_free_limbs() ) {
         continue;
      }
      if ( thing->query_wearable() ) {
         if ( !TP->wear_armour( thing, 0 ) ) {
            equipped += ({ thing });
         }
         continue;
      }
      if (thing->query_weapon() && no_limbs) {
         if ( sizeof( TP->set_hold( thing,
               member_array( 0, TP->query_holding() ) ) ) ) {
            equipped += ({ thing });
         }
      }
   }
   if ( !sizeof( equipped ) ) {
      return notify_fail( "You have no equippable items.\n" );
   }
   stuff = query_multiple_short( equipped );
   say( (string)TP->one_short() +" equips "+ stuff +".\n" );
   write( "You equip "+ stuff +".\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: living/facing.c
==================================================

#include <dirs.h>
inherit "/cmds/base";
string find_direction( object who );
int check_reference_point( object where );
int cmd( object *indirect_obs ) {
    mapping details;
    object *oblist;
    string *show, dir;
    if ( !check_reference_point( environment( this_player() ) ) ) {
        add_failed_mess( "You can't make out a point of reference "
            "to use to determine which way you're facing!\n" );
        return 0;
    }
    if ( !indirect_obs || sizeof( indirect_obs ) == 1 &&
        indirect_obs[ 0 ] == this_player()) {
        tell_object( this_player(), "You are facing " +
            find_direction( this_player() ) + ".\n" );
        return 1;
    }
    indirect_obs -= ({ this_player() });
    details = unique_mapping( indirect_obs,
        (: find_direction( $1 ) :) );
    show = ({ });
    foreach(dir, oblist in details)  {
      if (sizeof(oblist) > 1)  {
        show += ({ query_multiple_short(oblist) + " are facing " + dir });
      }
      else  {
        show += ({ oblist[0]->one_short() + " is facing " + dir });
      }
    }
    write(query_multiple_short(show) + ".\n");
    return 1;
}
string find_direction( object who ) {
    int facing;
    mapping directions;
    facing = who->query_facing()[ 0 ];
    directions = filter( ABS_FACING, (: $2 == $(facing) :) );
    if ( !sizeof( directions ) )
        return "north";
    return keys( directions )[ 0 ];
}
int check_reference_point( object where ) {
    string *relatives;
    relatives = map( where->query_direc(),
        (: $(where)->query_relative( $1 ) :) );
    return member_array( 0, relatives ) > -1;
}
mixed *query_patterns() {
    return ({ "", (: cmd( 0 ) :),
        "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: living/flip.c
==================================================

#include <money.h>
#define EFFECTS "/obj/handlers/mag_eff_handler"
inherit "/cmds/base";
mixed cmd( object *things ) {
   int *effect;
   object place;
   mixed *stuff, *details;
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only flip one thing at once.\n");
      return 0;
   }
   stuff = (mixed *)things[ 0 ]->query_money_array();
   if ( !sizeof( stuff ) ) {
      add_failed_mess( "You must have a coin to flip.\n" );
      return 0;
   }
   if ( ( sizeof( stuff ) > 2 ) || ( stuff[ 1 ] != 1 ) ) {
      add_failed_mess( "You can only flip one coin at a time.\n" );
      return 0;
   }
   details = (mixed *)MONEY_HAND->query_details_for( stuff[ 0 ] );
   if ( details[ MONEY_DETAILS_COMPOSITION ] == "paper" ) {
       add_failed_mess( "You cannot flip $I as you would a coin, because "
        "it is made of paper.\n", things );
       return -1;
   }
   write( "You flip "+ (string)things[ 0 ]->the_short() +".\n" );
   say( (string)this_player()->one_short() +" flips "+
         (string)things[ 0 ]->a_short() +".\n" );
   effect = (int *)EFFECTS->choose_effect(
         (int)EFFECTS->ambient_enchantment( things[ 0 ] ) );
   place = environment( this_player() );
   if ( random( 1000 ) < effect[ 0 ] ) {
      switch( effect[ 1 ] ) {
         case 0 :
            things[ 0 ]->move( place );
            tell_room( place, (string)things[ 0 ]->the_short() +
                  " lands on its edge.\n" );
            break;
         default :
            things[ 0 ]->move( "/room/rubbish" );
      }
      EFFECTS->do_effect( effect[ 1 ], (string)things[ 0 ]->the_short(),
            place );
      return 1;
   }
   things[ 0 ]->move( place );
   tell_room( place, (string)things[ 0 ]->the_short() +" falls "+
         (string)place->query_property( "here" ) +", "+
         details[ random( 2 ) ] +" up.\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

==================================================
FILE: living/fo_llow.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   object *ok, ob;
   object *already;
   string s;
   mapping hide_invis;
   int hiding, sneaking;
   ok = ({ });
   already = ({ });
   foreach (ob in obs) {
      if (member_array(TP, ob->query_followers()) == -1) {
         if (ob->add_follower(TP)) {
            ok += ({ ob });
         }
      } else {
         already += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      if (sizeof(already)) {
         add_failed_mess("You are already following $I.\n", already);
      }
      obs -= already;
      if (sizeof(obs)) {
         if(member_array(TP, obs) == -1) {
            add_failed_mess("You cannot follow " + query_multiple_short(obs) +
                                          ".\n");
         } else {
            add_failed_mess("You can't follow " +
                          query_multiple_short(obs - ({TP}) + ({"yourself"})) +
                          ".\n");
         }
      }
      return 0;
   }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
    write("You follow " + ( s = query_multiple_short( ok ) ) + " unseen.\n" );
  else {
   write("You follow "+(s=query_multiple_short(ok))+".\n");
   say(TP->one_short(1)+" follows "+s+".\n", ok);
   foreach (ob in ok)
      tell_object(ob, TP->one_short(1)+
                      " follows "+query_multiple_short((ok + ({"you"})) -
                      ({ ob }))+".\n");
  }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/g_lance.c
==================================================

#include <obj_parser.h>
#include <dirs.h>
#include <player.h>
inherit "/cmds/base";
int check_exists(string file);
string room_glance(object person, object room, int dark);
mixed cmd_direction(string dir);
int check_pre_stuff() {
   int dark;
   object room;
   room = environment(previous_object());
   if (!room) {
      return notify_fail("You are in limbo... sorry you can't look at "+
             "anything.\n");
   }
   if (!previous_object()->query_property("dead")) {
      dark = (int)previous_object()->check_dark((int)room->query_light());
   }
   if( dark < 0 ) {
      write("It's too dark to look at anything.\n");
      return 1;
   } else if( dark > 0 ) {
      write("It's too bright to look at anything.\n");
      return 1;
   }
   return 2;
}
mixed cmd_ob(object* obs) {
   object thing;
   int retval;
   int dark;
   object room;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   foreach (thing in obs) {
      string tmp;
      if(thing == this_player()) {
        write("That's you that is.\n");
      } else {
        tmp = (string)thing->a_short( dark );
        if (tmp) {
          write(capitalize(tmp) + ".\n");
        }
      }
   }
   return 1;
}
mixed cmd_direction(string dir, int from_string) {
   object room;
   int dark;
   int retval;
   string ret;
   string dest;
   mixed *func;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   retval = 0;
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dir = EXPAND_EXIT(dir);
   if ( room->query_relative( dir ) ) {
      add_failed_mess( "You do not think that the "+ dir +" is here.\n" );
      return 0;
   }
   dir = (string)this_player()->find_abs(dir);
   if(room->query_exit(dir)) {
      room->set_destination( dir );
      if ( check_exists( (string)room->query_destination( dir ) ) ) {
         write("You glance " + dir + " and see:\n");
         ret = room->query_look(dir);
         if (ret) {
            write(ret+"\n");
            return 1;
         }
         func = room->query_look_func(dir);
         if(sizeof(func)) {
            call_other(func[0], func[1], 1);
            return 1;
         }
         dest = room->query_destination(dir);
         if(room->query_door_open(dir) != 0) {
            if (!dark && !previous_object()->query_property("dead") &&
                !previous_object()->query_creator()) {
               dark = previous_object()->check_dark(dest->query_light());
            }
            load_object(dest);
            this_player()->set_looked( find_object( dest ) );
            if (dark) {
               write("It's too dark to see that far.\n");
            } else  {
               write( (string)dest->a_short( dark ) +" "+
                     (string)dest->query_short_exit_string()+".\n"+
                     (string)dest->query_contents(""));
            }
            return 1;
         } else if(room->query_door_open(dir) == 0) {
            write("The "+dir+" door is closed.\n");
         }
      }
   }
   if (!retval) {
      add_failed_mess("You do not think that the "+dir+" is here.\n");
   }
   return retval;
}
string room_glance(object person, object room, int dark) {
   string ret;
   string sees;
   object mirror;
   ret = "";
   if (person->query_creator()) {
      ret += " %^CYAN%^" + file_name(room) + "%^RESET%^";
      sees=(string)room->query_property("creator sees");
      if (sees) {
         ret += sees +"\n"+ (string)room->query_contents();
      }
   }
   mirror = room->query_mirror_room();
   if (mirror) {
      room = mirror;
   }
   if(!dark || previous_object()->query_creator()) {
      if (mirror) {
         ret += ".\n" + (string)mirror->query_contents();
      } else {
         ret += (string)room->query_short_exit_string()+".\n"+
           (string)room->query_contents();
      }
   } else if((dark == 2) || (dark == -2)) {
      if (!mirror) {
         ret += (string)room->query_short_exit_string()+"\n";
      } else {
         ret += "\n";
      }
      if((string)room->query_contents("") != "") {
         ret += person->colour_event("inventory", "%^GREEN%^") +
           "Some objects you can't make out are here.%^RESET%^\n";
      }
   } else {
      ret += "\n";
   }
   if (dark == 1 || dark == -1) {
      ret += "You can't see your hand in front of your face.\n";
   } else  {
      ret = "$a_short:"+ file_name(room) + "$"+ ret;
   }
   if (mirror) {
      ret += "Around " + room->the_short() + " is:\n";
      ret += room_glance(person, mirror, dark);
   }
   return ret;
}
int cmd_here() {
   object room;
   int dark;
   int retval;
   string str;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dark = previous_object()->check_dark((int)room->query_light());
   str = room_glance(previous_object(), room, dark);
   write(str);
   return 1;
}
int check_exists(string file) {
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    return 1;
  }
  return 0;
}
mixed* query_patterns() {
   return ({
             "", (: cmd_here() :),
             "exit <string'exit'>", (: cmd_direction($4[0], 1) :),
             "[at] <indirect:object>", (: cmd_ob($1) :),
             "<string'exit'>", (: cmd_direction($4[0], 0) :),
            });
}
