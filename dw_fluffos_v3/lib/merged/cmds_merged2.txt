# Total Tokens: 22164
# Total Files Merged: 17
# Total Characters: 73931

.c
==================================================

inherit "/cmds/base";
#include <tasks.h>
#define STATS_DIR "/save/tasks/"
#define DIVISOR 100
int do_summary();
int cmd(string str) {
  string file, cmd, tmp;
  mapping awards, summary, obs;
  int lvl, i, total, files;
  return do_summary();
  if(!str)
    str="";
  tmp = "";
  obs = ([ ]);
  summary = ([ ]);
  foreach(file in get_dir(STATS_DIR+str+"*")) {
    file = file[0..sizeof(file)-3];
    files++;
    awards = TASKER->query_stats(file);
    foreach(lvl in keys(awards)) {
      foreach(cmd in keys(awards[lvl])) {
        total += awards[lvl][cmd];
        obs[cmd] += 1;
      }
    }
  }
  foreach(cmd in keys(obs)) {
    if(obs[cmd] > 100)
      i += 1;
  }
  printf("%s: Skills: %d, Total: %d: Ratio: %d, Objects: %d, "
         "Obs over 100: %d\n",
         str, files, total, total/files, sizeof(keys(obs)), i);
  return 1;
}
int do_summary() {
  string skill;
  mapping sum, stats;
  int i;
  int tries, awards;
  stats = TASKER->query_stats("summary");
  sum = stats;
  foreach(skill in keys(sum)) {
    if("/std/skills"->query_skill(({ skill })) != skill)
      continue;
    printf("Skill: %s \n", skill);
    printf("  Level 0..49:       Tries: %d, Awards: %d, ",
           sum[skill][0][0], sum[skill][0][1]);
    if(sum[skill][0][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][0][0]/(sum[skill][0][1]));
    printf("  Level 50..149:     Tries: %d, Awards: %d, ",
           sum[skill][1][0], sum[skill][1][1]);
    if(sum[skill][1][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][1][0]/(sum[skill][1][1]));
    printf("  Level 150..299:    Tries: %d, Awards: %d, ",
           sum[skill][2][0], sum[skill][2][1]);
    if(sum[skill][2][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][2][0]/(sum[skill][2][1]));
    printf("  Level 300..599:    Tries: %d, Awards: %d, ",
           sum[skill][3][0], sum[skill][3][1]);
    if(sum[skill][3][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][3][0]/(sum[skill][3][1]));
    printf("  Level >= 600:      Tries: %d, Awards: %d, ",
           sum[skill][4][0], sum[skill][4][1]);
    if(sum[skill][4][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][4][0]/(sum[skill][4][1]));
    tries = 0;
    awards = 0;
    for(i=0; i<3; i++) {
      tries += sum[skill][i][0];
      awards += sum[skill][i][1];
    }
    printf("  Total:              Tries: %d, Awards: %d, ", tries, awards);
    if(!awards)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", tries/awards);
  }
  return 1;
}

==================================================
FILE: lord/wstats.c
==================================================

inherit "/cmds/base";
int cmd(string str) {
  mapping stats;
  string obj, file;
  int total, num;
  stats = "/secure/master"->query_write_stats();
  if(str) {
    if(!stats[str])
      return notify_fail("No such file\n");
    foreach(file in keys(stats[str])) {
      if(stats[str][file] > 1)
        printf("%-60s %5d\n", file, stats[str][file]);
    }
    return 1;
  }
  printf("%-60s %5s %5s\n", "Object", "Total", "Files");
  foreach(obj in keys(stats)) {
    total = 0;
    num = 0;
    foreach(file in keys(stats[obj])) {
      num++;
      total += stats[obj][file];
    }
        if(total > 50)
      printf("%-60s %5d %5d\n", obj, total, num);
  }
  return 1;
}

==================================================
FILE: player/accept.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
inherit "/cmds/base";
mixed do_surrender(object player) {
  object *victims;
  victims = this_player()->query_surrenderers();
  if (!victims  ||  member_array(player, victims) == -1) {
    add_failed_mess("Sorry, but $I has not offered to surrender to you.\n",
                    ({ player }) );
    return 0;
  }
  this_player()->remove_surrenderer(player);
  player->accepted_surrender(this_player());
  write("Good show!\n");
  return 1;
}
mixed do_club(string club_name, object *players) {
   object ob;
   string club;
   int ok;
   foreach (ob in players) {
      club = this_player()->query_respond_command(CLUB_RESPOND_TYPE, ob);
      if (club) {
         if (lower_case(club) == lower_case(club_name)) {
            if (CLUB_HANDLER->is_member_of(club_name,
                                           this_player()->query_name())) {
               add_failed_mess("You are already a member of '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "'.\n");
            } else {
               CLUB_HANDLER->add_member(club_name,
                                        this_player()->query_name());
               add_succeeded_mess("$N join$s '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "' with an invite from $I.\n",
                               ({ ob }) );
	       ob->remove_respond_command(CLUB_RESPOND_TYPE, ob);
               ok++;
               all_inventory(this_player())->event_joined_club(this_player(),
                                                               club_name);
            }
         } else {
            add_failed_mess("$I is inviting you to join '" +
                            CLUB_HANDLER->query_club_name(club) +
                            "' not '" + club_name + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to join any clubs.\n",
                         ({ ob }));
      }
   }
   return ok;
}
int do_family(string family,
              string relationship,
              object *players) {
   object ob;
   int ok;
   string curr_family;
   class family_response_data frog;
   curr_family = this_player()->query_family_name();
   if (curr_family) {
      curr_family = CLUB_HANDLER->query_club_name(curr_family);
   }
   relationship = CLUB_HANDLER->query_ungendered_relationship(relationship);
   if (!relationship) {
      add_failed_mess("Could not figure out the relationship.\n");
      return 0;
   }
   foreach (ob in players) {
      frog = this_player()->query_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                                  ob);
      if (!family) {
         family = frog->family;
      }
      if (frog && frog->family) {
         if (lower_case(frog->family) == lower_case(family)) {
  	    if (lower_case(frog->relationship) != lower_case(relationship)) {
               add_failed_mess("You were asked to have the relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(frog->relationship,
                                     this_player()->query_female()) +
                               "', not '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' in the family '" +
                               CLUB_HANDLER->query_club_name(frog->family) +
                               "'.\n");
	    } else if (CLUB_HANDLER->is_relationship(frog->family,
                                                     this_player()->query_name(),
                                                     ob->query_name(),
                                                     relationship) &&
                       frog->family == curr_family) {
               add_failed_mess("You have already setup a relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' with $I.\n", ({ ob }) );
            } else {
               if (!CLUB_HANDLER->is_member_of(frog->family,
                                               this_player()->query_name())) {
                  if (frog->family != curr_family &&
                      curr_family) {
                     if (!CLUB_HANDLER->move_family_member(curr_family,
                                                           this_player()->query_name(),
                                                           frog->family)) {
                       add_failed_mess("Unable to move you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  } else {
                     if (!CLUB_HANDLER->add_member(frog->family,
                                                  this_player()->query_name())){
                       add_failed_mess("Unable to add you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  }
                  this_player()->set_family_name(frog->family);
               }
	       if (!CLUB_HANDLER->is_relationship(frog->family,
                                                  this_player()->query_name(),
                                                  ob->query_name(),
                                                  relationship)) {
                  if (!CLUB_HANDLER->add_relationship(ob->query_family_name(),
                                                     ob->query_name(),
                                                     frog->family,
                                                     this_player()->query_name(),
                                                     relationship)) {
                     add_failed_mess("Unable to add the relationship to $I for "
                                     "some reason.\n");
                  } else {
                     add_succeeded_mess("$N set$s up a relationship with $I " +
                                        "in '" +
                                        CLUB_HANDLER->query_club_name(frog->family) +
                                        "'.\n",
                                        ({ ob }) );
                     ok++;
                  }
               } else {
                  add_succeeded_mess("$N set$s up a relationship with $I " +
                                     "in '" +
                                     CLUB_HANDLER->query_club_name(frog->family) +
                                     "'.\n",
                                     ({ ob }) );
                  ok++;
               }
               ob->remove_respond_command(CLUB_FAMILY_RESPOND_TYPE, ob);
            }
         } else {
            add_failed_mess("$I is inviting you to a relationship in '" +
                            CLUB_HANDLER->query_club_name(frog->family) +
                            "' not '" + family + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to setup any relationships.\n",
                         ({ ob }));
      }
   }
   return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:living:here>", (: do_surrender($1[0]) :),
            "invite from <indirect:living:here> to <string'club name'>",
                (: do_club($4[1], $1) :),
            "relationship from <indirect:living:here> to <string'family'> as <string'relationship'>",
                (: do_family($4[1], $4[2], $1) :),
            "relationship from <indirect:living:here> as <string'relationship'>",
	       (: do_family(this_player()->query_family_name(), $4[1], $1) :) });
}

==================================================
FILE: player/access.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#define TP this_player()
inherit "/cmds/base";
int cmd_list() {
   string *ips;
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if ( !sizeof(ips) )  {
     write( "You are allowed to login from anywhere.\n" );
   } else  {
     ips = sort_array(ips, 1);
     write( "You are currently allowed to login from: " +
            query_multiple_short(ips) + ".\n" );
   }
   return 1;
}
int enable( string str) {
   string *ips;
   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if(member_array(str, ips) == -1 )  {
     ips += ({ str });
     TP->set_rhosts(ips);
   } else  {
     write( "You are already allowed to login from  " + str + ".\n" );
   }
   write("You are now allowed to login from "+str+".\n");
   return 1;
}
int disable( string str) {
   string *ips;
   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if ( member_array( str, ips ) != -1 )  {
     ips -= ({ str });
     if(!sizeof(ips))
       TP->set_rhosts(0);
     else
       TP->set_rhosts(ips);
   } else  {
     write( "You are already not allowed to login from  " + str + ".\n" );
   }
   if(!sizeof(ips))
     write("You are now allowed to login from anywhere.\n");
   else
     write("You are not now allowed to login from "+str+".\n");
   return 1;
}
int authorise_for (string name, string address) {
  string fname;
  string file,  *bits;
  string var_name = "player_info ";
  mapping info = ([ ]);
  int i, found = 0;
  if (!this_player()->query_lord()) {
    return notify_fail ("You may not do this.\n");
  }
  if (find_player (name)) {
    return notify_fail ("This player is online.\n");
  }
  if (!PLAYER_HANDLER->test_user(name)) {
    return notify_fail ("No such player.\n");
  }
  seteuid("Root");
  fname = "/save/players/" + name[0..0] + "/" + name;
  uncompress_file (fname+ ".o.gz");
  file = unguarded( (: read_file($(fname)+".o") :));
  if (!file) {
    return notify_fail ("Error reading file.\n");
  }
   bits = explode(file, "\n");
   for (i = 0; i < sizeof(bits); i++) {
     if (bits[i][0..strlen(var_name)-1] == var_name) {
       info = restore_variable(bits[i][strlen(var_name)..]);
       found = 1;
       break;
     }
   }
  if(!found) {
    return notify_fail ("Cannot find mapping.\n");
  }
  if (address == "reset") {
    info["allowed_ips"] = ({ });
  }
  else if (sizeof (info ["allowed_ips"])) {
    if (member_array (address, info["allowed_ips"]) == -1) {
      info["allowed_ips"] += ({ address });
    }
  }
  else {
    info["allowed_ips"] = ({ address });
  }
  if (i < sizeof(bits)) {
     bits[i] = var_name + save_variable(info);
   } else {
     bits += ({ var_name + save_variable(info) });
  }
  unguarded( (: rm($(fname) + ".old") :) );
  unguarded( (: rename($(fname)+".o", $(fname)+".old") :) );
  unguarded( (: write_file($(fname) + ".o",
    implode($(bits), "\n") + "\n") :));
  compress_file (fname + ".o");
  unguarded( (: rm($(fname) + ".o") :) );
  PLAYER_HANDLER->remove_cache_entry(name);
  tell_object (this_player(), "Access for " + name + " changed.\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "enable <string'address'>", (: enable($4[0]) :),
              "disable <string'address'>", (: disable($4[0]) :),
              "for <string'name'> <string'address'>",
                (: authorise_for ($4[0], $4[1]) :),
              "reset for <string'name'>", (: authorise_for ($4[0],
              "reset") :),
              "", (: cmd_list() :) });
}

==================================================
FILE: player/al_ias.c
==================================================

#include <alias.h>
inherit "/cmds/base";
private nosave string gfilter;
string alias_string(mixed *al) {
   int i;
   int num;
   int *add_thing;
   string str;
   str = "";
   add_thing = ({ });
   for (i=0;i<sizeof(al);i++) {
      if (stringp(al[i])) {
         str += replace(al[i], ({";", "\\;"}));
      } else {
         num = al[i] & ALIAS_MASK;
         switch (al[i] - num) {
         case NEW_LINE  :
            str += ";";
            break;
         case ALL_ARGS  :
            str += "$*$";
            break;
         case ONE_ARG   :
            str += "$"+num+"$";
            break;
         case TO_ARG    :
            str += "$*"+num+"$";
            break;
         case FROM_ARG  :
            str += "$"+num+"*$";
            break;
         case ALL_ARG   :
            str += "$arg:"+al[++i]+"$";
            break;
         case ARG_THING :
            str += "$arg"+num+":"+al[++i]+"$";
            break;
         case ELSE_THING :
           str += "$else$";
           break;
         case ALL_IFARG :
            str += "$ifarg:";
            break;
         case IFARG_THING :
            str += "$ifarg"+num+":";
            break;
         case CURR_LOC :
            str += "$!$";
            break;
         case END_IF      :
            str += "$endif$";
            break;
         }
      }
   }
   return str;
}
int print_aliases(string filter, int sorted) {
   int i;
   int len;
   string str;
   string str1;
   string str2;
   string *tmp;
   string bing;
   mapping aliases;
   string ret;
   aliases = this_player()->query_aliases();
   if (!m_sizeof(aliases)) {
      notify_fail("None defined.\n");
      return 0;
   }
   str1 = "";
   str2 = "";
   tmp = m_indices(aliases);
   if (filter) {
      if (regexp(filter,
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (filter[0] == '*' || filter[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      gfilter = "^" + filter;
      if (catch(tmp = filter_array(tmp, (: $1 && regexp($1, gfilter) :)))) {
         add_failed_mess("Bad pattern to alias (mismatched brackets?).\n");
         return 0;
      }
   }
   tmp = sort_array(tmp, 1);
   ret = "You currently have the following aliases:\n";
   for (i = 0; i < sizeof(tmp); i++) {
      if (!tmp[i]) {
         map_delete(aliases, 0);
         continue;
      }
      bing = alias_string(aliases[tmp[i]]);
      if (!bing) {
         bing = "Error in the alias!";
      }
      if (!tmp[i]) {
         tmp[i] = "icky";
      }
      if (strsrch(bing, "%^") != -1) {
         bing = replace_string(bing, "%^", "% ^");
         tmp[i] += " (colour replace)";
      }
      str = tmp[i] + ": " + bing;
      if (strlen(str) > 39 || sorted) {
         len = this_player()->query_cols() - strlen(tmp[i]) - 2;
         if (len < 0) {
            len = 10;
         }
         ret += sprintf("%s: %-=*s\n", tmp[i], len, bing);
      } else if (strlen(str) > 19) {
         str1 += str+"\n";
      } else {
         str2 += str+"\n";
      }
   }
   if (strlen(str1)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str1);
   }
   if (strlen(str2)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str2);
   }
   ret += sprintf("A total of %d aliases.\n", sizeof(tmp));
   this_player()->more_string(ret);
   return 1;
}
mixed *compile_alias(string str) {
   mixed *ret;
   int i;
   int space;
   string *frog;
   string s1;
   int tmp;
   int gumby;
   int nodollar;
   int ending_dollar;
   mixed *ifargs;
   str = replace(str, ({ "\\;", "$escaped$", ";", "$new_line$", " ", " " }));
   str = replace(str, "$escaped$", ";");
   if(str[sizeof(str)-1] == '$')
     ending_dollar = 1;
   frog = explode("&" + str + "&", "$");
   if (frog[0] == "&") {
      frog[0] = "";
   } else {
      frog[ 0 ] = frog[ 0 ][ 1 .. ];
   }
   s1 = frog[<1];
   if (s1 == "&") {
      frog = frog[0..<2];
   } else {
      frog[<1] = s1[0..<2];
   }
   ret = ({ frog[0] });
   ifargs = ({ });
   nodollar = 1;
   for (i = 1; i < sizeof(frog); i++) {
      switch (frog[i]) {
      case "new_line" :
         ret += ({ NEW_LINE });
         nodollar = 1;
         break;
      case "*" :
         ret += ({ ALL_ARGS });
         gumby = 1;
         nodollar = 1;
         break;
      case "!" :
         if (this_object()->query_creator()) {
            ret += ({ CURR_LOC });
            nodollar = 1;
         }
         break;
      case "else" :
         if (sizeof(ifargs)) {
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret) -
               ifargs[sizeof(ifargs)-1]+1;
            ret += ({ ELSE_THING, 0, "" });
            ifargs[sizeof(ifargs)-1] = sizeof(ret)-2;
            nodollar = 1;
         }
         break;
      case "~" :
      case "endif" :
         if (sizeof(ifargs)) {
            ret += ({ END_IF });
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
               ifargs[sizeof(ifargs)-1];
            ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
            nodollar = 1;
            space = 1;
         }
         break;
      default :
         if (frog[i][0..4] == "ifarg") {
            if (sscanf(frog[i], "ifarg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ IFARG_THING+ tmp, 0, "" });
               frog[i--] = s1;
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
            } else if (frog[i][5] == ':') {
               ret += ({ ALL_IFARG, 0, "" });
               frog[i] = frog[i][6..];
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
               i--;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
            }
         } else if (frog[i][0..2] == "arg") {
            if (sscanf(frog[i], "arg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ ARG_THING+ tmp, s1, "" });
               nodollar = 1;
               gumby = 1;
            } else if (frog[i][3] == ':') {
               ret += ({ ALL_ARG, frog[i][4..100], "" });
               nodollar = 1;
               gumby = 1;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
               gumby = 1;
               space = 0;
            }
         } else if (strlen(frog[i]) && frog[i][<1] == '*' &&
                    sscanf(frog[i], "%d%s*", tmp, s1) == 2 && s1 == "") {
            if (tmp < 0) {
               tmp = 0;
            }
            if (tmp > ALIAS_MASK) {
               tmp = ALIAS_MASK;
            }
            ret += ({ FROM_ARG + tmp });
            gumby = 1;
            nodollar = 1;
         } else if (strlen(frog[i]) && frog[i][0] == '*' &&
                    sscanf(frog[i][1..], "%d%s", tmp,s1) == 2 && s1 == "") {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ TO_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else if (sscanf(frog[i], "%d%s", tmp, s1) == 2 && s1 == "" &&
                    (i < sizeof(frog)-1 || ending_dollar)) {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ ONE_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else {
            if (!nodollar) {
               frog[i] = "$"+frog[i];
            }
            nodollar = 0;
            space = 0;
            if (strlen(frog[i]) && frog[i][<1] == '~') {
               if (sizeof(ifargs)) {
                  if (strlen(frog[i]) == 1) {
                     frog[i] = "";
                  } else {
                     frog[i] = frog[i][0..<2];
                  }
                  ret += ({ END_IF });
                  ret[ifargs[<1]] = sizeof(ret) - ifargs[<1];
                  ifargs = ifargs[0..<2];
                  nodollar = 1;
                  space = 1;
               }
            }
            if (sizeof(ret) && stringp(ret[<1]) && space != 2) {
               ret[<1] += frog[i];
            } else {
               ret += ({ frog[i] });
            }
            if (space) {
               space = 2;
            }
         }
      }
   }
   while (sizeof(ifargs)) {
      ret += ({ END_IF });
      ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
         ifargs[sizeof(ifargs)-1];
      ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
   }
   if (!gumby) {
      if (sizeof(ret) && !stringp(ret[sizeof(ret)-1]) || space) {
         ret += ({ " ", ALL_ARGS });
      } else if(sizeof(ret)) {
         ret[sizeof(ret)-1] += " ";
         ret += ({ ALL_ARGS });
      }
   }
   return ret;
}
int print_some_aliases(string str, int every) {
   if (this_player()->is_alias(str) && !every) {
      printf("%s: %-=*s\n", str,
                (int)this_player()->query_cols() - strlen(str) -2,
                alias_string(this_player()->query_player_alias(str)));
      return 1;
   }
   return print_aliases(str, 0);
}
protected int alias(string name, string value) {
#ifdef DISALLOW_COLOUR
   if (strsrch(name, "%^") >= 0 || strsrch(value, "%^") >= 0) {
      notify_fail("Cannot add an alias with a colour escape "
                  "sequence (% ^).\n");
      return 0;
   }
#endif
   if (strsrch(value, "END_ALIAS") != -1) {
      add_failed_mess("You cannot use 'END_ALIAS' in an alias.\n");
      return 0;
   }
   name = implode(explode(name, " "), "");
   if (name == "unalias" || name == "alias" || name == "ealias")  {
      add_failed_mess("You can't alias the '" + name + "' command, because "
                      "otherwise, there would be Problems.\n");
      return 0;
   }
   if (!this_player()->is_alias(name)) {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Added alias '" + name + "'.\n");
   } else {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Changed alias '" + name + "'.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({
         "", (: print_aliases("", 0) :),
         "sorted", (: print_aliases("", 1) :),
         "every <word'alias'>", (: print_some_aliases($4[0], 1) :),
         "<word'alias'>", (: print_some_aliases($4[0], 0) :),
         "<word'alias'> <string>", (: alias($4[0], $4[1]) :)
         });
}

==================================================
FILE: player/apply.c
==================================================

#include <applications.h>
#include <board.h>
#include <playerinfo.h>
#include <mail.h>
#include <player.h>
inherit "/cmds/base";
varargs void begin_application (object, string, string);
class applying_player {
   int step;
   object player;
   string domain;
   string next_method;
   string type;
   string *questions;
   string *answers;
}
class vouch_info {
  string applicant;
  string voucher;
  string position;
}
void create() {
  seteuid (geteuid());
}
int do_creator_apply(string domain, string type) {
  int temp;
  if (!domain) {
    domain = type;
  }
  if( this_player()->query_property( "guest" ) ) {
    write( "Only people with permanent characters are allowed to "
      "become Creators.\n" );
    return 1;
  }
  temp = APPLICATIONS_HANDLER->query_applications_accepted( domain );
  if( temp == -1 ) {
    this_player()->add_failed_mess( this_object(), "The domain " +
       domain + " is not a valid domain.\n" );
    return 0;
  }
  if( temp == 0 ) {
    this_player()->add_failed_mess (this_object(), "The domain " +
    domain + " is not currently open for applications.\n");
    return 0;
  }
  if( !APPLICATIONS_HANDLER->valid_application (this_player()->query_name(),
    type ) && !this_player()->query_lord() ) {
      write( "Sorry, you have not fulfilled the requirements yet.\n" );
      return 1;
  }
  if (domain == "liaison") {
    type = "liaison";
  }
  if (strsrch (domain, "playtester") != -1) {
    type = "playtester";
  }
  begin_application (this_player(), type, domain);
  return 1;
}
void confirm (string message,  class applying_player tmp) {
  if (!message || !sizeof (message) || strsrch (message, "no") != -1
    || strsrch (message, "n") != -1) {
    return;
  }
  else {
    call_other (this_object(), tmp->next_method, tmp->player, tmp);
  }
}
string query_application_info (string domain) {
  string ret;
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
    ret = read_file( "/d/" + domain + "/application.txt" );
  }
  return ret;
}
varargs void begin_application (object player, string type, string domain) {
  class applying_player tmp;
  string ret = APPLICATIONS_HANDLER->query_intro_text (type);
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
      ret += "\nPlease read the following information about applying to "
             "$C$" + domain + ": \n\n" ;
      ret += query_application_info (domain);
   }
  tell_object (this_player(), ret + "\n");
  tmp = new (class applying_player);
  tmp->type = type;
  tmp->domain = domain;
  tmp->answers = ({ });
  tmp->step = 1;
  tmp->next_method = "do_questions";
  tmp->player = player;
  tell_object (player, "Do you wish to continue your application?\n");
  this_player()->do_edit( "", "confirm", this_object(), 0,
    tmp);
}
varargs void do_questions (object player, class applying_player tmp) {
  if (tmp->step == 1) {
    tmp->questions = APPLICATIONS_HANDLER->query_questions (tmp->type);
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[0]
    + "%^RESET%^\n");
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void start_asking(string message, class applying_player tmp) {
  object player = tmp->player;
  if (!message || sizeof (message) == 0) {
    tell_object (player, "Your application has been aborted.\n");
    return;
  }
  tmp->answers += ({ message });
  if (tmp->step == sizeof (tmp->questions)) {
    tell_object (player, "Do you wish to submit your application?\n");
    tmp->next_method = "submit_application";
    this_player()->do_edit( "", "confirm", this_object(), 0,
      tmp);
    return;
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[tmp->step]
    + "%^RESET%^\n");
  tmp->step += 1;
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void submit_application (object player, class applying_player tmp) {
  int i;
  string *text = ({ });
  for (int j = 0; j < sizeof (tmp->questions); j++) {
    text += ({ "%^CYAN%^" +sprintf( "%2d) %-=*s", ( j + 1), 70,
      tmp->questions[j] ) + "%^RESET%^\n" });
    text += ({ sprintf( "      %-=*s\n\n", 72, tmp->answers[j] )});
  }
  i = APPLICATIONS_HANDLER->add_application (tmp->type, player->query_name(),
    implode (text, "\n"), tmp->domain);
  if (!i) {
    tell_object (player, "Something has gone wrong!\n");
    return;
  }
  else {
    tell_object (player, "Thank you for your application... it has been "
      "placed in the handler ready for people to vouch.\n");
  }
}
int do_list_types() {
  string ret = "";
  string *types;
  types = APPLICATIONS_HANDLER->query_types();
  ret += "You can apply for the following positions with this command:\n\n";
  foreach (string t in types) {
    ret += t + "\n";
  }
  this_player()->more_string (ret);
  return 1;
}
int do_list_requirements(string type) {
  string ret = APPLICATIONS_HANDLER->application_requirements (type);
  this_player()->more_string (ret);
  return 1;
}
int domain_status() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  foreach (string s, int o in map) {
    ret += (o ? "%^BOLD%^%^CYAN%^" : "") + capitalize (s) + " is " +
           (o ? "open" : "closed") + "%^RESET%^ to "
      "applications and is managed by " +
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n";
  }
  write("$P$Domain Status$P$" + ret);
  return 1;
}
int do_list_questions (string type) {
  string *quest = APPLICATIONS_HANDLER->query_questions (type);
  tell_object (this_player(), "\n\nPlease take time to write your application.  "
     "Preferably, prepare an answer to each of these questions off-line "
     "and copy your response into the editor on the MUD if possible.  "
     "You will be asked these questions one-by-one during the application "
     "process, so you should answer each question thoroughly.  Remember, "
     "this is a formal application to a position of responsibility, so "
     "treat each question seriously.\n\n");
  this_player()->more_string (implode (quest, "\n\n"));
  return 1;
}
int do_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->find_application (name, position);
  class vouch_info tmp;
  tmp = new (class vouch_info);
  if (i == -1) {
    write (capitalize (name) + " has not applied for a "
      + position + " position.\n");
    return 1;
  }
  tell_object (this_player(), "%^BOLD%^Why do you think " + capitalize (name)
    + " would be a suitable " + position + "? %^RESET%^");
  tmp->applicant = name;
  tmp->voucher = this_player()->query_name();
  tmp->position = position;
  this_player()->do_edit( "", "vouch_edit", this_object(), 0,
    tmp);
  return 1;
}
void vouch_edit(string message, class vouch_info tmp) {
  object ob;
  int i;
  string name = tmp->applicant;
  string position = tmp->position;
  ob = find_player (tmp->voucher);
  if (!sizeof (message) || message == "") {
    if (ob) {
      tell_object (ob, "Your vouch has been aborted.\n");
    }
  }
  else {
    i = APPLICATIONS_HANDLER->make_vouch (position, name, tmp->voucher, message);
    switch (i) {
      case 2:
        tell_object (ob, "You submit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 1:
        tell_object (ob, "You resubmit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 0:
        tell_object (ob, "You cannot submit a vouch for yourself.\n");
      break;
      case -1:
        tell_object (ob, "There is no application for " + capitalize (name) +
          " as a " + position + ".\n");
      break;
    }
  }
}
int do_delete_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->delete_vouch (this_player()->query_name(),
    name, position);
  if (i) {
    tell_object (this_player(), "You delete your vouch for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), "You have not vouched for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  return 1;
}
int query_my_vouch (string name, string position) {
  string v = APPLICATIONS_HANDLER->query_vouch (position, name,
    this_player()->query_name());
  if (!v) {
    tell_object (this_player(), "There is no application for "
      + capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), v + "\n");
  }
  return 1;
}
int delete_application (string pos) {
  int i = APPLICATIONS_HANDLER->delete_application (pos,
    this_player()->query_name());
  if (!i) {
    tell_object (this_player(), "You have no pending applications for "
      "that position.\n");
  }
  else {
    tell_object (this_player(), "Your application has been deleted.\n");
  }
  return 1;
}
int do_register() {
   if ( this_player()->query_property( "guest" )==1 ) {
      write ( "You are a guest. Registering as a player killer is not an "
        "option for you.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+
        " (" +query_ip_number(this_player()) + ") (a guest) tried to "
        "register as a player killer.\n");
      return 1;
   }
   if (this_player()->query_player_killer()) {
      add_failed_mess( "You already are a player killer, silly!\n" );
      return 0;
   }
   if (-this_player()->query_time_on() < PKER_MINIMUM_AGE) {
      add_failed_mess( "You are not old enough to be a player killer.  You "
        "must be " + (PKER_MINIMUM_AGE / (60 * 60 * 24)) + " days old to "
        "register as a player killer.\n");
      return 0;
   }
   if (this_player()->query_property(PKER_NOT_ALLOWED)) {
      write( "Due to previous abuses of the playerkiller system, you are "
         "not allowed to become a playerkiller.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+ " (" +query_ip_number(this_player()) +
        ") (not allowed to be a pk) tried to register as a player "
        "killer.\n");
      return 1;
   }
   write( "%^BOLD%^%^YELLOW%^You are hereby registering yourself as "
          "a player killer.\n\n"
          "This means that you can attack and be attacked by other "
          "player killers.  Once you are a registered player killer, "
          "there is NO going back.  Please note, this is NOT a quest "
          "and you will NOT get any experience points from doing "
          "it.%^RESET%^\n");
   write( "Are you sure about this, (Y/N)?\n");
   input_to("register2");
   return 1;
}
void register2(string str)
{
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
      write("You need to type 'y' or 'n'.\n");
      write("Are you sure about this, (Y/N)? ");
      input_to("register2");
      return ;
   }
   if (str[0] == 'n' ||
       str[0] == 'q') {
      write("You have chosen not to register as a playerkiller at this "
         "time.  You may choose to register later if you wish.\n");
   } else {
      write("%^BOLD%^%^YELLOW%^You are now a playerkiller, ready to kill and be killed.%^RESET%^\n");
      this_player()->set_player_killer(1);
      PLAYERINFO_HANDLER->add_entry( this_player(),
        this_player()->query_name(), "misc",
        "Registered as a Player Killer." );
   }
}
int do_query_all_vouches() {
  mapping tmp = APPLICATIONS_HANDLER->query_vouches_for_all
    (this_player()->query_name());
  string *ret = ({ });
  string tmp2;
  if (!sizeof (tmp)) {
    this_player()->add_failed_mess (this_object(), "You have made no "
      "vouches for anyone.\n", ({ }));
    return 0;
  }
  foreach (string n, string v in tmp) {
    tmp2 = "$I$5=%^CYAN%^" + capitalize (n) + "%^RESET%^: " + v;
    ret += ({ tmp2 });
  }
  this_player()->more_string (implode (ret, "\n\n"));
  return 1;
}
private int do_list_applicants() {
  string ret;
  if (!this_player()->query_lord()) {
    return 0;
  }
  ret = APPLICATIONS_HANDLER->list_applications();
  this_player()->more_string (ret);
  return 1;
}
private int do_browse_app (string type, string name) {
  int i = APPLICATIONS_HANDLER->find_application (name, type);
  string ret;
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "There is no "
      +type + " application for " + name + ".\n", ({ }));
    return 0;
  }
  ret = APPLICATIONS_HANDLER->format_application (i);
  this_player()->more_string (ret);
  return 1;
}
int query_my_vouches (string position) {
  mapping i = APPLICATIONS_HANDLER->query_application_vouches
    (this_player()->query_name(), position);
  if (!i) {
    this_player()->add_failed_mess (this_object(), "You currently have no vouches "
      "for a " + position + " application.\n", ({ }));
    return 0;
  }
  else {
    tell_object (this_player(), "The following people have vouched for your " +
      position + " application:  " + query_multiple_short (map (keys (i),
        (: capitalize ($1) :))) + ".\n");
    return 1;
  }
}
mixed* query_patterns() {
   string t = "{" + implode (APPLICATIONS_HANDLER->query_types(), "|")
    + "}";
   mixed *tmp;
   tmp = ({
             "as creator in <word> domain", (: do_creator_apply($4[0], "creator") :),
             "as player killer", (: do_register() :),
             "as playtester", (: do_creator_apply("playtesters", "playtester") :),
             "as liaison", (: do_creator_apply(0, "liaison") :),
             "delete my application as <word'position'>",
              (: delete_application ($4[0]) :),
             "list available positions", (: do_list_types() :),
             "list requirements for " + t + " applications",
              (: do_list_requirements($4[0]) :),
             "list position status", (: domain_status() :),
             "list questions for " + t + " applications",
              (: do_list_questions ($4[0]) :),
             "vouch for <word'name'> as <word'position'>",
              (: do_vouch ($4[0], $4[1]) :),
             "delete vouch for <word'name'> as <word'position'>",
              (: do_delete_vouch ($4[0], $4[1]) :),
             "query vouch for <word'name'> as <word'position'>",
              (: query_my_vouch ($4[0], $4[1]) :),
             "query all my vouches", (: do_query_all_vouches() :),
             "query vouches for my <word> application", (: query_my_vouches($4[0]) :),
  });
  if (this_player()->query_lord()) {
    tmp += ({"browse <word'type'> application for <word'name'>", (: do_browse_app($4[0], $4[1]) :) });
    tmp += ({"list applicants", (: do_list_applicants() :) });
  }
  return tmp;
}
void clean_up() {
  return 0;
}
int application_board_access_check( int type, string board,
                                    object previous, string name ) {
   switch(type) {
      case B_ACCESS_READ :
         return 1;
      case B_ACCESS_WRITE :
         if( file_name(previous) == file_name( this_object() ) )
            return 1;
          if (base_name (previous) == APPLICATIONS_HANDLER) {
            return 1;
          }
         return master()->query_lord(name);
      case B_ACCESS_DELETE :
         return 0;
   }
}
void reset() {
}

==================================================
FILE: player/appraise.c
==================================================

#include <volumes.h>
int cmd(object *things);
string query_length_mess(int number) {
    int half_feet;
    switch(number) {
        case 0:
            return "not very";
        case 1:
            return "an inch";
        case 2:
            return "a couple of inches";
        case 3:
            return "three inches";
        case 4:
            return "four inches";
        case 5..7:
            return "about six inches";
        case 8..10:
            return "about nine inches";
        case 11..14:
            return "about a foot";
        case 15..21:
            return "about a foot and a half";
        case 22..27:
            return "about two feet";
        case 28..33:
            return "about two and a half feet";
        default:
            half_feet = (number + 3)/6;
            if( half_feet%2 ) {
                return "about " + query_num(half_feet/2) + " and a half feet";
            }
            else {
                return "about " + query_num(half_feet/2) + " feet";
            }
    }
}
string query_dimensions_mess(object thing) {
    return "is " + query_length_mess(thing->query_length()) + " long and " +
        query_length_mess(thing->query_width()) + " wide.";
}
string query_appearance_mess(object thing) {
    string material_mess;
    if( !sizeof(thing->query_materials()) ) {
        material_mess = "some unidentifiable material";
    }
    else {
        material_mess = query_multiple_short(thing->query_materials());
    }
    if(thing->query_colour()) {
        return "is " + thing->query_colour() + " and is made of " +
            material_mess;
    }
    else {
        return "is made of " + material_mess;
    }
}
string query_type_mess(object thing) {
    if( thing->query_plant() ) {
        return "appears to be some sort of plant";
    }
    if( thing->query_food_object() ) {
        if( thing->query_liquid() ) {
            return "looks drinkable";
        }
        else {
            return "looks edible";
        }
    }
    if( thing->query_furniture() ) {
        return "could be placed as furniture";
    }
    if( thing->query_property("shop type") == "jewellers" ) {
        return "appears to be a piece of jewellery";
    }
    if( thing->query_weapon() ) {
        return "could be used as a weapon";
    }
    if( thing->query_armour() && thing->query_wearable()) {
        return "could be worn as armour";
    }
    if( thing->query_wearable() ) {
        return "looks like you could wear it";
    }
    if (thing->query_no_limbs() > 0) {
        return "looks like you could hold it";
    }
    return 0;
}
string query_container_mess(object thing) {
   int volume;
   int size;
   string str;
   volume = thing->query_max_volume();
   if (thing->query_container()) {
      size = thing->query_max_size();
   }
   if (size || volume) {
      str = "";
      if (size) {
         str += "can hold about " + (size / 9) + " pounds";
      }
      if (volume) {
         if (size) {
            str += " and ";
         }
         str += "can hold about ";
         if (volume > VOLUME_GALLON) {
            str += ((volume + VOLUME_GALLON / 2) / VOLUME_GALLON) + " gallons";
         } else if (volume >= VOLUME_QUART) {
            str += ((volume + VOLUME_QUART / 2) / VOLUME_QUART) + " quarts";
         } else if (volume >= VOLUME_PINT) {
            str += ((volume + VOLUME_PINT / 2) / VOLUME_PINT) + " pints";
         } else if (volume >= VOLUME_GILL) {
            str += ((volume + VOLUME_GILL / 2) / VOLUME_GILL) + " gills";
         } else if (volume >= VOLUME_SHOT) {
            str += ((volume + VOLUME_SHOT / 2) / VOLUME_SHOT) + " shots";
         } else {
            str += "nothing";
         }
      }
      return str;
   }
   return 0;
}
int cmd(object *things) {
    object thing;
    string mess;
    string tmp;
    if(!sizeof(things)) {
        add_failed_mess("For some reason, you "
            "have nothing to appraise.  Please bugrep this.\n", ({ }) );
        return 0;
    }
    if(sizeof(things) > 1) {
        add_failed_mess("You cannot appraise "
            "more than one object at once.\n", ({ }) );
        return 0;
    }
    if (thing == this_player()) {
        if (this_player()->query_name() == "penguin") {
           write("Is that a tuxuedo you are wearing?  No, probably not.\n");
        } else {
           write("You appraise yourself.  " + (random(10) + 1) + " out of 10.\n");
        }
        return 0;
    }
    thing = things[0];
    if(environment(thing) != this_player()) {
        add_failed_mess("You cannot appraise "
            "objects you are not carrying.\n", ({ }) );
        return 0;
    }
    if(living(thing)) {
        write("You appraise " + thing->the_short() + " and mmmm, very "
            "sexy.\n");
        return 1;
    }
    if(thing->query_worn_by()) {
        add_failed_mess("You cannot appraise "
            "$I while you are wearing it.\n", ({ thing }) );
        return 0;
    }
    if( !thing->query_clothing() ) {
        mess = thing->the_short() + " " + query_dimensions_mess(thing);
        mess += "  ";
    }
    else {
        mess = "";
    }
    tmp = query_type_mess(thing);
    if(tmp) {
        mess += "It " + query_appearance_mess(thing);
        mess += " and " + tmp + ".";
    }
    else {
        mess += "It " + query_appearance_mess(thing) + ".";
    }
    tmp = query_container_mess(thing);
    if (tmp) {
       mess += "  It " + tmp + ".";
    }
    if(thing->cond_string() && thing->cond_string() != "") {
        mess += "  " + thing->cond_string();
    }
    else {
        mess += "\n";
    }
    write("$P$Appraise$P$" + mess );
    add_succeeded_mess("");
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me-here'item'>", (: cmd($1) :) });
}

==================================================
FILE: player/arguments.c
==================================================

#include <philosophies.h>
inherit "/cmds/base";
int cmd() {
   string *args;
   args = PHILOSOPHY_HANDLER->query_all_known(this_player()->query_name());
   if (!sizeof(args)) {
      write("You do not know any theological arguments.\n");
   } else {
      write("You know the following theological arguments:\n" +
            query_multiple_short(args) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/birthdays.c
==================================================

inherit "/cmds/base";
int cmd()  {
   object *peeps;
   peeps = filter(users(), (: $1->query_visible(this_player())  &&
                              $1->query_is_birthday_today() :));
   if (sizeof(peeps) == 0)
      return notify_fail("No one has a birthday today.\n");
   if (sizeof(peeps) == 1)
      printf("%s has a birthday today.\n", peeps[0]->short());
   else
      write(query_multiple_short(peeps) + " have a birthday today.\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/brief.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(string which, string type) {
  string t, disp;
  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types())
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    write(disp + "\n");
  }
  else if(type == "all") {
    foreach(t in TP->query_verbose_types())
      TP->set_verbose(t, which == "verbose");
    write("Ok\n");
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
  } else {
    write("No such option.\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("brief", $4[0]) :),
            "", (: cmd("brief", 0) :),
         });
}

==================================================
FILE: player/bright.c
==================================================

inherit "/cmds/base";
#include <dirs.h>
#define THRESHOLDS ({ 10, 30, 200, 300 })
string illumination( int number ) {
   if ( number < 0 ) {
      return "in the darkness that lies beyond darkness";
   }
   if ( number < THRESHOLDS[ 0 ] ) {
      return "in pitch darkness";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "in near darkness";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return "too brightly lit to see";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return "too brightly lit to see clearly";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 5 :
      return "very poorly lit";
   case 6 .. 10 :
      return "poorly lit";
   case 11 .. 20 :
      return "dimly lit";
   case 21 .. 30 :
      return "quite well lit";
   case 31 .. 40 :
      return "well lit";
   case 41 .. 50 :
      return "brightly lit";
   default :
      return "very brightly lit";
   }
}
string intensity(int number, object thing) {
   int flag = (thing == this_player());
   if (number < 0) {
      return (flag?"are":"is") + " dark beyond darkness";
   }
   if (number < THRESHOLDS[0]) {
      return "produce" + (flag?"":"s") + " a faint light";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "produce" + (flag?"":"s") + " a bit of light";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return (flag?"are":"is") + " so bright you can't bear to look";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return (flag?"are":"is") + " so bright it hurts to look";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 24 :
      return "produce" + (flag?"":"s") + " quite a bit of light";
   case 25 .. 49 :
      return (flag?"are":"is") + " very bright";
   default :
      return (flag?"are":"is") + " extremely bright";
   }
}
int check_exists(string file) {
  int retval;
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    retval = 1;
  } else {
    retval = 0;
  }
  return retval;
}
mixed cmd(object *things) {
   int its_light;
   string results;
   string no_light_results;
   object thing;
   object* no_light;
   int result_light;
   results = "";
   if (environment(this_player())->query_light() < THRESHOLDS[0]) {
      results += "Wherever you are, it's ";
   } else {
      results += "$C$"+ environment(this_player())->the_short(1) + " is ";
   }
   results += illumination(environment(this_player())->query_light()) + ".\n";
   if (!things) {
      write(results);
      return 1;
   }
   no_light_results = "";
   no_light = ({ });
   foreach(thing in things) {
      its_light = (int)thing->query_light();
      if (its_light) {
        results += "$C$" + thing->the_short(1) + " " +
          intensity(its_light, thing) + ".\n";
        result_light = 1;
      } else {
         no_light += ({ thing });
      }
   }
   if (sizeof(no_light) && !result_light) {
      write("$C$" + query_multiple_short(no_light, "one", 0, 1) +
            ((sizeof(no_light) == 1  &&  no_light[0] != this_player()) ?
               " produces" : " produce") + " no light at all.\n");
   }
   write(results);
   return 1;
}
int cmd_exit(string arg) {
   object room;
   string other;
   room = environment(this_player());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if(!room->query_exit(arg)) {
     arg = (string)this_player()->find_abs(arg);
   }
   if ( room->query_exit( arg ) ) {
      other = room->query_destination(arg);
      if ( check_exists( other )) {
         object door;
         door = room->query_door_control(arg);
         if(room->query_door_open(arg) ||
            door->query_transparent()) {
            write(other->the_short(1) + " is " +
                       illumination(other->query_light()) + ".\n");
            return 1;
         } else {
            add_failed_mess("The exit " + arg + " is not open.\n");
            return 0;
         }
      } else {
         add_failed_mess("The exit " + arg + " does not exist.\n");
         return 0;
      }
   }
   add_failed_mess("Unable to find the exit " + arg + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "exit <string'exit name'>", (: cmd_exit($4[0]) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/bug.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("BUG");
   set_use_last_error(1);
}

==================================================
FILE: player/bugcheck.c
==================================================

#define WEIRD_OBJECT_LOG "/log/secure/playtesters/bugcheck-weird-objects"
inherit "/cmds/base";
varargs int cmd(object *obs) {
    string* s;
    string txt;
    foreach ( object ob in obs ) {
        if ( stringp( ob->query_property( "virtual name" ) ) )
            s = explode( ob->query_property( "virtual name" ), "/" );
        else
            s = explode( base_name( ob ), "/" );
        switch ( s[ 0 ] ) {
        case "d":
            write(capitalize( ob->the_short() ) +
                         " is a domain thing.  It's probably safe to "
                         "bugrep it directly.\n" );
            break;
        case "w":
            write(capitalize( ob->the_short() ) +
                         "... why do you have a creator item?\n" );
            log_file ("ILLEGAL_OBJECT", "%s: %s tried to bugcheck %s.\n\n",
              ctime(time()), this_player()->query_name(), base_name (ob));
            break;
        case "std":
            write(capitalize( ob->the_short() ) +
                         " is a weird MUD library thing.  If you bugrep "
                         "it, the response might be slow.  It may be a "
                         "better idea to bugrep the room that the object "
                         "was found in.\n" );
            break;
        case "obj":
          switch (s[1]) {
            case "weapons":
            case "armours":
            case "clothes":
            case "food":
            case "jewellery":
              write(capitalize( ob->the_short() ) +
                         " is a Disc-wide item, but belongs to a directory "
                         "that is checked regularly.  Best to make the "
                         "bugrep directly on the item.\n" );
            break;
            default:
              write(capitalize( ob->the_short() ) +
                         " is a fairly general Disc-wide object.  If you "
                         "bugrep it, the response might be slow.  It would "
                         "most likely be a better idea to bugrep the room "
                         "in which the object was found.\n" );
            break;
          }
        break;
        case "global":
          switch (s[1]) {
            case "player":
            case "lord":
            case "playtester":
              if ( ob == this_player() ) {
                  txt = "are";
              }
              else {
                  txt = "is";
              }
              write(capitalize( ob->the_short() ) +
                         " " + txt + " the general " + s[1] + " object... if your "
                         "bugrep is on this, then bugrep this object.  If "
                         "your bugrep is along the frivolous lines of '"
                         + ob->the_short() +" " + txt + " overpowered!', "
                         "then don't "
                         "bugreport it... be sure and raise the issue on the "
                         "nearest bulletin board.\n" );
            break;
          }
        break;
        default:
            write("I've got no idea about " +
                         ob->the_short() + ".  Sorry it didn't work out.\n" );
            log_file( WEIRD_OBJECT_LOG, implode( s, "/" ) + "\n" );
            break;
        }
    }
    return 1;
}
int cmd_room() {
   write("Bug report the room for anything that seems to be odd in the room, "
         "descriptions being wrong, items you look at being wrong.  Anything "
         "odd you see that does not seem to fit anywhere else should also be "
         "reported to the room.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:'thing'>", (: cmd($1) :),
             "here", (: cmd_room :)
    });
}

==================================================
FILE: player/bury.c
==================================================

#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
inherit "/cmds/base";
#define TP this_player()
#define GP_INCREMENT 10
#define MAX_BURY_NUMBER 20
mixed cmd(object *obs) {
   string person;
   mixed effs, *xp;
   string* messages;
   object ob, tmp;
   object *sobs;
   object *fobs;
   object *too_many;
   int gp;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   sobs = ({ });
   fobs = ({ });
   too_many = ({ });
   if (TP->query_property("dead")) {
      add_failed_mess("You are a disembodied spirit, how do you expect to bury "
                      "anything at all?\n");
      return 0;
   }
   if(sizeof(filter_array(TP->query_attacker_list(),
                          (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot bury items while in combat.\n");
      return 0;
   }
   if(environment(TP)->query_property("no burial")) {
      add_failed_mess("You cannot bury things here.\n");
      return 0;
   }
   fobs = filter(obs, (: !is_in_me_or_environment($1, this_player()) :));
   obs -= fobs;
   foreach (ob in obs) {
      if (sizeof(sobs) >= MAX_BURY_NUMBER) {
         too_many += ({ ob });
      } else if ((ob->query_owner() == this_player()->query_cap_name()) ||
                 ((ob->get() == MOVE_OK) ||
                  (ob->get() == MOVE_TOO_HEAVY)) &&
                 (ob->query_property("no burial") != 1) &&
                 !ob->ok_to_bury(this_player())) {
        if (ob->query_property("player") != 1 ||
            ob->query_owner() == this_player()->query_name()) {
            effs = ob->effects_matching("mudlib.owned.weapon");
            if(sizeof(effs)) {
               person = ob->arg_of(effs[0]);
               log_file("BURIAL", "%s: %s's %s buried by %s\n", ctime(time()),
                        person, ob->query_short(), TP->query_name());
            }
            environment(this_player())->add_effect(BURY_EFFECT, ob);
            sobs += ({ ob });
            if (ob->query_property("corpse bit") ||
                ob->query_property("money")) {
               gp--;
            } else if(base_name(ob) == "/obj/corpse" &&
                      !ob->query_property("already buried")) {
               gp += GP_INCREMENT;
               ob->add_property("already buried", 1);
               xp = ob->query_property("XP");
               if(xp && sizeof(xp) == 2) {
                 foreach(tmp in xp[0]) {
                   if(tmp)
                     tmp->adjust_xp(xp[1], 1);
                 }
               }
               ob->remove_property("XP");
            }
         } else {
            fobs += ({ ob });
         }
      } else {
         fobs += ({ ob });
      }
   }
   if (!sizeof(sobs)) {
      if (sizeof(fobs)) {
         if (member_array(TP, fobs) == -1) {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs)+".\n");
            return 0;
         } else {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs - ({TP}) +
                                                 ({"yourself"}))+
                            ".\n");
            return 0;
         }
      } else {
         add_failed_mess("You cannot find anything here to bury!\n");
         return 0;
      }
   }
   if (sizeof(too_many)) {
      write("You can only bury up to " + MAX_BURY_NUMBER +
            " items at a time, not burying " +
            query_multiple_short(too_many) + ".\n");
   }
   messages = environment(TP)->query_burial_message();
   if (messages) {
      write(replace_string(messages[0], "$objs$", query_multiple_short(sobs)));
      say(replace(messages[1], ({ "$N", TP->the_short(), "$objs$", query_multiple_short(sobs) })));
   } else if (environment(TP)->query_property("location") != "outside") {
      write("You tidy up the place, clearing away "+
            query_multiple_short(sobs)+".\n");
      say( (string)this_player()->one_short() +
           " tidies up the place, clearing away "+
           query_multiple_short( sobs ) +".\n" );
   } else {
      write("You bury "+query_multiple_short(sobs)+" deep within the earth.\n");
      say( (string)this_player()->one_short() +
           " buries "+ query_multiple_short( sobs ) +
           " deep within the ground.\n" );
   }
   TP->adjust_gp(gp);
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:here>", (: cmd($1) :),
            "",
            (: cmd(match_objects_for_existence("corpse", environment(TP))) :) });
}

==================================================
FILE: player/chfn.c
==================================================

inherit "/cmds/base";
#define TP this_player()
#define MAX_EMAIL_LEN 50
int cmd(string str) {
  write("Change finger information.\n");
  write("Pressing return at the prompts will take the default.  The default "
        "is the option in []'s.\n");
  write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
  input_to("real_name");
  return 1;
}
int real_name(string str) {
  string real_name;
  str = strip_colours(str);
  real_name = TP->query_real_name();
  if (str && str != "") {
    if (str == "none") {
      real_name = 0;
    } else {
      real_name = str;
    }
  }
  if (real_name && strlen(real_name) > MAX_EMAIL_LEN) {
    write("Real name is too long, a maximum of " + MAX_EMAIL_LEN + " characters is allowed.\n");
    write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
    input_to("real_name");
    return 1;
  }
  if (real_name && real_name != "") {
    write("Ok real name set to "+real_name+".\n");
  } else {
    write("Real name cleared.\n");
  }
  TP->set_real_name(real_name);
  write("Enter your location (ie Perth, oz, whatever) ["+
        TP->query_where()+"]\n(none for none) : ");
  input_to("get_where");
  return 1;
}
int get_where(string str) {
  string where;
  str = strip_colours(str);
  where = TP->query_where();
  if (str && str != "") {
    if (str == "none") {
      where = 0;
    } else {
      where = str;
    }
  }
  if (where && where != "") {
    write("Ok location set to "+where+".\n");
  } else {
    write("Location cleared.\n");
  }
  if (where && strlen(where) > MAX_EMAIL_LEN) {
     write("Your location is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
     write("Enter your location (ie Perth, oz, whatever) ["+
           TP->query_where()+"]\n(none for none) : ");
     input_to("get_where");
     return 1;
  }
  TP->set_where(where);
  if(TP->query_birthday() == "Unknown") {
    write("Enter your birthday (ddmm) ["+TP->query_birthday()+
          "] (none for none) : ");
    input_to("birthday");
  } else {
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
  }
  return 1;
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}
int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
void birthday(string str) {
  string birth_day;
  birth_day = TP->query_birthday();
  if (str == "") {
    if (birth_day)
      write("Birthday unchanged from "+birth_day+".\n");
    else
      write("Birthday left as blank.\n");
  } else {
    if(birth_day != "Unknown") {
      write("You can't change when you were born! Please ask a Creator or "
        "a Lord to change it if you made an error.\n");
    } else if(!valid_birthday(str)) {
        write("Invalid Birthday.  Birthday cleared.\n");
        birth_day = 0;
    } else {
      birth_day = convert_birthday(str);
      write("Birthday set to " + birth_day + ".\n");
      TP->birthday_gifts();
    }
  }
  TP->set_birthday(birth_day);
  write("What email address do you wish to use.  Set to none to clear.\n");
  write("Putting a : in front of it means that only the creators and lords "
        "can read it.\n");
  write("["+TP->query_email()+"] : ");
  input_to("get_email");
}
void get_email(string str) {
  string email;
  email = TP->query_email();
  str = strip_colours(str);
  if (str == "") {
    if (!email || email == "") {
      write("Email address left blank.\n");
    } else {
      write("Email address left as "+email+".\n");
    }
  } else if (str == "none") {
    email = 0;
    write("Email address cleared.\n");
  } else {
    email = str;
    write("Email address set to "+email+".\n");
  }
  if (email && strlen(email) > MAX_EMAIL_LEN) {
    write("Your email address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators and lords "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
    return ;
  }
  TP->set_email(email);
  write("Please enter your home page (World Wide Web page address), "
        "type 'none' to clear it.\n");
  if (!TP->query_homepage()) {
    write("[none] : ");
  } else {
    write("["+TP->query_homepage()+"] : ");
  }
  input_to("get_home_page");
}
void get_home_page(string str) {
  str = strip_colours(str);
  if (str == "") {
    if (!TP->query_homepage()) {
      write("Home page left as blank.\n");
    } else {
      write("Home page left as "+TP->query_homepage()+"\n");
    }
  } else if (str == "none") {
    TP->set_homepage("");
    write("Home page cleared.\n");
  } else if (strlen(str) <= MAX_EMAIL_LEN) {
    TP->set_homepage(str);
    write("Home page set to "+str+"\n");
  } else {
    write("Your home page address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("Please enter your home page (World Wide Web page address), "
          "type 'none' to clear it.\n");
    if (!TP->query_homepage()) {
      write("[none] : ");
    } else {
      write("["+TP->query_homepage()+"] : ");
    }
    input_to("get_home_page");
    return ;
  }
  TP->save_me();
}

==================================================
FILE: player/co_mmands.c
==================================================

inherit "/cmds/base";
int cmd( ) {
  string *cmds;
  write( "Your current commands are:\n"+ sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)this_player()->query_known_commands(), 1 ),
         "\n" ) ) );
  if (this_player()->query_playtester()) {
    cmds = get_dir ("/cmds/playtester/");
    cmds = filter (cmds, (: strsrch ($1, ".c") == (sizeof ($1) - 2) :));
    write( "\n\nYour playtester commands are:\n"+ replace (sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)cmds, 1 ),
         "\n" ) ), ({".c", ""})) );
  }
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/colo_urs.c
==================================================

#include <colour.h>
#include <clubs.h>
#include <creator.h>
#include <newbiehelpers.h>
inherit "cmds/base";
private string* _colours;
void create() {
  ::create();
  _colours = ({
   "BOLD",
   "FLASH",
   "BLACK",
   "RED",
   "BLUE",
   "CYAN",
   "MAGENTA",
   "ORANGE",
   "YELLOW",
   "GREEN",
   "WHITE",
   "B_RED",
   "B_ORANGE",
   "B_YELLOW",
   "B_BLACK",
   "B_CYAN",
   "B_WHITE",
   "B_GREEN",
   "B_MAGENTA" });
}
int is_valid_colour(string name) {
   if (member_array(name, _colours) != -1) {
      return 1;
   }
   return 0;
}
int show_allowed_colours() {
   write("The allowed colour codes are " +
         query_multiple_short(map(_colours, (: lower_case($1) :)), 0, 0, 1) +
         ".\n");
   return 1;
}
string* query_colour_list(int inform) {
  string* colour_list;
  string* clubs;
  string bing;
  switch (inform) {
  case 0:
    colour_list = USER_COLOUR_LIST;
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      colour_list += ({"newbiehelpers"});
    }
    if(this_player()->query_creator()) {
      colour_list += this_player()->channel_list();
    }
    break;
  case 1 :
    colour_list = this_player()->query_inform_types();
    break;
  case 2 :
    clubs = this_player()->query_player_clubs();
    clubs = filter(clubs, (: !CLUB_HANDLER->is_club($1) :));
    foreach (bing in clubs) {
       this_player()->remove_player_club(bing);
    }
    colour_list = map(this_player()->query_player_clubs(), (: "club_" + $1 :));
    break;
  }
  return colour_list;
}
mixed set_colours(int inform, string event_type, string colour, int force) {
  mapping my_colours;
  string *colour_list;
  string *bad;
  string tmp;
  string name;
  colour_list = query_colour_list(inform);
  if (inform == 2) {
    name = CLUB_HANDLER->query_club_name(event_type);
    event_type = "club_" + event_type;
  } else {
    name = lower_case(event_type);
  }
  if(member_array(event_type, colour_list) == -1) {
    return notify_fail("No such type.\n");
  }
  my_colours = this_player()->query_my_colours();
  if(colour == "default") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to default.\n");
  } else if(colour == "none") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to none.\n");
  } else {
    colour_list = map(explode(colour, " "),
                      (: upper_case($1) :));
    bad = filter(colour_list, (: !is_valid_colour($1) :));
    if (sizeof(bad) && !force) {
       if (sizeof(bad) > 1) {
          add_failed_mess("The colours " + query_multiple_short(bad) +
                          " are not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       } else {
          add_failed_mess("The colour " + query_multiple_short(bad) +
                          " is not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       }
       return 0;
    }
    tmp = "%^" + implode(colour_list, (: $1 + "%^ %^" + $2 :)) + "%^";
    this_player()->set_my_colours(event_type, tmp);
    write(name + " colour set to " + tmp + "[" + colour +
          "]%^RESET%^.\n");
  }
  return 1;
}
private int show_colours(int inform) {
  string *colour_list, event;
  mapping my_colours;
  string name;
  colour_list = query_colour_list(inform);
  my_colours = this_player()->query_my_colours();
  if (!inform) {
    write(sprintf("%-20s %s\n", "Clubs", "<list>"));
    write(sprintf("%-20s %s\n", "Inform", "<list>"));
  }
  foreach(event in colour_list) {
    if (inform == 2) {
       name = CLUB_HANDLER->query_club_name(event[5..]);
    } else {
       name = event;
    }
    if(my_colours[event]) {
      if(my_colours[event] != "") {
        write(sprintf("%-20s %s\n", name, my_colours[event] +
                      "[" + replace(my_colours[event], "%^", "") +
                      "]%^RESET%^"));
      } else {
        write(sprintf("%-20s %s\n", name, "[none]"));
      }
    } else {
      write(sprintf("%-20s %s\n", name, "[default]"));
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 0) :),
            "force <word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 1) :),
            "", (: show_colours(0) :),
            "inform <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 0) :),
            "inform force <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 1) :),
            "club <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 0) :),
            "club force <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 1) :),
            "inform", (: show_colours(1) :),
            "allowed", (: show_allowed_colours() :),
            "clubs", (: show_colours(2) :) });
}
