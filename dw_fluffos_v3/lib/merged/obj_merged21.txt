




==================================================
FILE: /lib/obj/handlers/inherit/club_elected.c
==================================================

inherit "/obj/handlers/inherit/club_family";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
#include <mail.h>
#include <board.h>
#include <player_handler.h>
private mapping _elections;
private string *_boards;
private nosave mapping _discussion_items;
#define CLUB_PRESIDENT_INDEX          "president"
#define CLUB_VICE_PRESIDENT_INDEX     "vice-president"
#define CLUB_TREASURER_INDEX          "treasurer"
#define CLUB_SECRETARY_INDEX          "secretary"
#define CLUB_ORDINARY_COMMITTEE_INDEX "committee"
#define CLUB_BOARD_PREFIX "club "
#define CLUB_DISCUSS_MESSAGE_VERIFY            1
#define CLUB_DISCUSS_MESSAGE_COMPLETE          2
#define CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION 3
#define CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION  4
#define CLUB_DISCUSS_MESSAGE_NOMINATION        5
#define CLUB_MAX_ARCHIVE_SIZE 50
int is_nomination_accepted(string club_name,
                           string position,
                           string person);
int complete_election(string club_name);
int start_election(string club_name);
int holds_position_of(string name, string position, string person);
string query_position_name(string club_name,
                           string position);
int set_position_holder(string club_name,
                                  string position,
                                  string person);
protected int add_archive(string club_name,
                          string subject,
                          string thingy);
string query_club_board_name(string club_name);
class election_info {
   string treasurer;
   string president;
   string vice_president;
   string secretary;
   mapping account_info;
   mapping positions;
   int last_election;
   int election_period;
   mapping options;
   class discussion_idea *discussion;
   class club_archive *archives;
   string announcement;
   int announce_time;
}
#define CLUB_NOMINATION        1
#define CLUB_NOMINATION_SECOND 3
#define CLUB_ELECTION          2
class election_data {
   int time_of_event;
   int state;
   mapping people;
   mapping nominated;
   mapping voted_for;
   string election_status;
}
class account_info {
   class club_transaction* transactions;
   string* allowed_people;
   string* allowed_positions;
}
private class election_info query_elected_info(string name);
void create() {
   _elections = ([ ]);
   _boards = ({ });
   ::create();
   if (!_boards) {
      _boards = ({ });
   }
}
protected void create_extra_data(string name) {
   class election_info e_info;
   class club_info data;
   class club_transaction bing;
   class account_info frog;
   if (query_club_type(name)== CLUB_ELECTED) {
      data = (class club_info)query_club_info(name);
      e_info = new(class election_info);
      e_info->treasurer = CLUB_TREASURER_INDEX;
      e_info->president = CLUB_PRESIDENT_INDEX;
      e_info->vice_president = CLUB_VICE_PRESIDENT_INDEX;
      e_info->secretary = CLUB_SECRETARY_INDEX;
      e_info->discussion = ({ });
      e_info->positions = ([
                             CLUB_TREASURER_INDEX : CLUB_UNKNOWN_MEMBER,
                             CLUB_PRESIDENT_INDEX : data->founder,
                             CLUB_VICE_PRESIDENT_INDEX : CLUB_UNKNOWN_MEMBER,
                             CLUB_SECRETARY_INDEX : CLUB_UNKNOWN_MEMBER,
                           ]);
      e_info->account_info = ([ ]);
      e_info->last_election = time();
      e_info->options = ([ ]);
      e_info->election_period = CLUB_INVALID_TIME;
      e_info->announcement = "";
      e_info->archives = ({ });
      e_info->announce_time = 0;
      data->extra_data = e_info;
      set_club_changed(name);
      bing = new(class club_transaction);
      bing->date = time();
      bing->amount = query_balance(name, CLUB_DEFAULT_ACCOUNT_NAME);
      bing->transaction_type = CLUB_TRANSACTION_START_BALANCE;
      bing->who = CLUB_CONTROLLER_MEMBER;
      frog = new(class account_info);
      frog->transactions = ({ bing });
      frog->allowed_people = ({ });
      frog->allowed_positions = ({ CLUB_TREASURER_INDEX,
                                   CLUB_PRESIDENT_INDEX });
      e_info->account_info[CLUB_DEFAULT_ACCOUNT_NAME] = frog;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
}
int change_club_type(string name,
                     int type) {
   if (::change_club_type(name, type)) {
      start_election(name);
      return 1;
   }
   return 0;
}
int disband_club(string name) {
   if (::disband_club(name)) {
      map_delete(_elections, name);
      _boards -= ({ query_club_board_name(name) });
      save_main();
      return 1;
   }
   return 0;
}
protected class election_info query_elected_info(string name) {
   class club_info data;
   class account_info fluff;
   if (is_elected_club(name)) {
      data = (class club_info)query_club_info(name);
      if (pointerp(data->extra_data->account_info)) {
         fluff = new(class account_info);
         fluff->transactions = data->extra_data->account_info;
         fluff->allowed_people = ({ });
         fluff->allowed_positions = ({ data->extra_data->president,
                                       data->extra_data->treasurer });
         data->extra_data->account_info = ([ CLUB_DEFAULT_ACCOUNT_NAME : fluff ]);
      }
      return data->extra_data;
   }
   return 0;
}
protected class account_info query_account_info(string name, string account) {
   class election_info bing;
   bing = query_elected_info(name);
   if (bing) {
      if (!account) {
         account = CLUB_DEFAULT_ACCOUNT_NAME;
      }
      return bing->account_info[account];
   }
   return 0;
}
int remove_member(string club, string member) {
   class election_info bing;
   class account_info fluff;
   string account;
   string person;
   string position;
   string name;
   mapping nominations;
   string *people;
   if (::remove_member(club, member)) {
      bing = query_elected_info(club);
      if (bing) {
         foreach (account, fluff in bing->account_info) {
            fluff->allowed_people -= ({ member });
         }
         foreach (position, person in bing->positions) {
            if (person == member) {
               set_position_holder(club, position, CLUB_UNKNOWN_MEMBER);
            }
         }
      }
      name = normalise_name(club);
      if (_elections[name]) {
         foreach (position, nominations in _elections[name]->nominated) {
            map_delete(nominations, member);
            foreach (person, people in nominations) {
               nominations[person] = people - ({ member });
            }
         }
         foreach (position, nominations in _elections[name]->people) {
            map_delete(nominations, member);
         }
      }
      return 1;
   }
   return 0;
}
int query_last_election(string name) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return info->last_election;
   }
   return 0;
}
int query_next_election(string name) {
   int bing;
   bing = query_last_election(name);
   if (bing) {
      return bing + CLUB_ELECTION_PERIOD;
   }
   return 0;
}
int query_minimum_next_election(string name) {
   int bing;
   bing = query_last_election(name);
   if (bing) {
      return bing + CLUB_MINIMUM_ELECTION_PERIOD;
   }
   return 0;
}
int is_president_of(string name, string president) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->president, president);
   }
   return 0;
}
int is_vice_president_of(string name, string vice_president) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->vice_president, vice_president);
   }
   return 0;
}
int is_secretary_of(string name, string secretary) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->secretary, secretary);
   }
   return 0;
}
int is_treasurer_of(string name, string treasurer) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->treasurer, treasurer);
   }
   return 0;
}
int holds_any_position_of(string name, string person) {
   class election_info info;
   string pos_name;
   string per_name;
   info = query_elected_info(name);
   if (info) {
      foreach (pos_name, per_name in info->positions) {
         if (per_name == person) {
            return 1;
         }
      }
   }
   return 0;
}
int holds_position_of(string name, string position, string person) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      position = query_position_name(name, position);
      return info->positions[position] == person;
   }
}
int create_account(string name, string account) {
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (::create_account(name, account)) {
      class election_info info;
      class account_info frog;
      info = query_elected_info(name);
      if (info) {
         frog = new(class account_info);
         frog->transactions = ({ });
         frog->allowed_people = ({ });
         frog->allowed_positions = ({ info->president, info->treasurer });
         info->account_info[account] = frog;
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
}
int add_money(string name,
              int amount,
              int type,
              string person,
              string account,
              string information) {
   class account_info frog;
   class club_transaction bing;
   if (::add_money(name, amount, type, person, account)) {
      frog = query_account_info(name, account);
      if (frog) {
         bing = new(class club_transaction);
         bing->date = time();
         bing->amount = amount;
         bing->transaction_type = type;
         bing->who = person;
         bing->information = information;
         frog->transactions += ({ bing });
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
}
int remove_money(string name,
                 int amount,
                 int type,
                 string person,
                 string account,
                 string information) {
   class account_info frog;
   class club_transaction bing;
   if (::remove_money(name, amount, type, person, account)) {
      frog = query_account_info(name, account);
      if (frog) {
         bing = new(class club_transaction);
         bing->date = time();
         bing->amount = -amount;
         bing->transaction_type = type;
         bing->who = person;
         bing->information = information;
         frog->transactions += ({ bing });
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
}
class club_transaction* query_transactions(string name, string account) {
   class account_info frog;
   class club_transaction bing;
   class club_transaction old;
   int i;
   if (is_elected_club(name)) {
      frog = query_account_info(name, account);
      if (sizeof(frog->transactions) &&
          sizeof(frog->transactions[0]) == 4) {
         for (i = 0; i < sizeof(frog->transactions); i++) {
            old = frog->transactions[i];
            bing = new(class club_transaction);
            bing->who = old->who;
            bing->transaction_type = old->transaction_type;
            bing->amount = old->amount;
            bing->date = old->date;
            bing->information = 0;
            frog->transactions[i] = bing;
            set_club_changed(name);
         }
      }
      return frog->transactions;
   }
   return ({ });
}
string query_transaction_type_name(int type) {
   switch (type) {
      case CLUB_TRANSACTION_UPKEEP :
         return "upkeep";
      case CLUB_TRANSACTION_DEPOSIT :
         return "player deposit";
      case CLUB_TRANSACTION_INSIGNIA :
         return "insignia";
      case CLUB_TRANSACTION_START_BALANCE :
         return "start balance";
      case CLUB_TRANSACTION_WITHDRAWL :
         return "player withdrawl";
      case CLUB_TRANSACTION_TRANSFER :
         return "player transfer";
      default :
         return "unknown";
   }
}
string* query_account_allowed_people(string club_name, string account) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog) {
      return frog->allowed_people;
   }
   return ({ });
}
int is_allowed_to_modify_account(string club_name,
                               string account,
                               string person) {
   class account_info frog;
   string pos;
   frog = query_account_info(club_name, account);
   if (frog) {
      if (member_array(person, frog->allowed_people) != -1) {
         return 1;
      }
      foreach (pos in frog->allowed_positions) {
         if (holds_position_of(club_name, pos, person)) {
            return 1;
         }
      }
   }
   return 0;
}
int add_account_allowed_person(string club_name, string account, string person) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(person, frog->allowed_people) == -1) {
      frog->allowed_people += ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int remove_account_allowed_person(string club_name, string account, string person) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(person, frog->allowed_people) != -1) {
      frog->allowed_people -= ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
string* query_account_allowed_positions(string club_name, string account) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog) {
      return frog->allowed_positions;
   }
   return ({ });
}
int add_account_allowed_position(string club_name, string account, string position) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(position, frog->allowed_positions) == -1) {
      frog->allowed_positions += ({ position });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int remove_account_allowed_position(string club_name, string account, string position) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(position, frog->allowed_positions) != -1) {
      frog->allowed_positions -= ({ position });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int set_elected_option(string club_name,
                       string option,
                       mixed value) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      data->options[option] = value;
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int remove_elected_option(string club_name,
                          string option) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      map_delete(data->options, option);
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
mixed query_elected_option(string club_name,
                           string option) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      return data->options[option];
   }
   return 0;
}
int is_elected_option(string club_name,
                      string option) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      return !undefinedp(data->options[option]);
   }
   return 0;
}
int start_election(string club_name) {
   string name;
   string pos;
   class election_info bing;
   string *stuff;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      if (!_elections[name]) {
         bing = query_elected_info(name);
         _elections[name] = new(class election_data);
         _elections[name]->people = ([ ]);
         _elections[name]->nominated = ([ ]);
         _elections[name]->voted_for = ([ ]);
         _elections[name]->time_of_event = time() + CLUB_NOMINATION_TIME;
         _elections[name]->state = CLUB_NOMINATION;
         foreach (pos, stuff in bing->positions) {
            _elections[name]->people[pos] = ([ ]);
            _elections[name]->nominated[pos] = ([ ]);
            _elections[name]->voted_for[pos] = ({ });
         }
         save_main();
         send_broadcast_message(name,
                         "An election has just started!  Nominate your "
                         "favourite person now at the club control centre.");
         return 1;
      }
   }
   return 0;
}
int nominate_person(string club_name, string position, string person,
                    string nominating) {
   string name;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      if (_elections[name] &&
          (_elections[name]->state == CLUB_NOMINATION ||
           _elections[name]->state == CLUB_NOMINATION_SECOND)) {
         position = query_position_name(club_name, position);
         if (_elections[name]->nominated[position]) {
            if (!_elections[name]->nominated[position][person]) {
                _elections[name]->nominated[position][person] = ({ });
            }
            if (member_array(nominating,
                        _elections[name]->nominated[position][person]) == -1) {
               _elections[name]->nominated[position][person] += ({ nominating });
               save_main();
               return 1;
            }
         }
      }
   }
   return 0;
}
mixed finish_nomination(string club_name) {
   string name;
   string position_name;
   mapping position_data;
   string *data;
   string person;
   string *bad_positions;
   class election_info frog;
   name = normalise_name(club_name);
   bad_positions = ({ });
   if (is_elected_club(name)) {
      frog = query_elected_info(name);
      if (_elections[name] &&
          (_elections[name]->state == CLUB_NOMINATION ||
           _elections[name]->state == CLUB_NOMINATION_SECOND)) {
         foreach (position_name,
                  position_data in _elections[name]->nominated) {
            _elections[name]->people[position_name] = ([ ]);
            foreach (person, data in position_data) {
               if (is_nomination_accepted(club_name, position_name, person)) {
                  _elections[name]->people[position_name][person] = 0;
               }
            }
            if (sizeof(_elections[name]->people[position_name]) == 0) {
               bad_positions += ({ position_name });
            }
         }
         if (!sizeof(bad_positions) ||
             _elections[name]->state == CLUB_NOMINATION_SECOND) {
            foreach (position_name, position_data in _elections[name]->people) {
               if (sizeof(position_data) == 1) {
                  set_position_holder(club_name,
                                      position_name,
                                      keys(position_data)[0]);
                  map_delete(_elections[name]->people, position_name);
               }
            }
            foreach (position_name in bad_positions) {
               set_position_holder(club_name,
                                   position_name,
                                   CLUB_UNKNOWN_MEMBER);
               map_delete(_elections[name]->people, position_name);
            }
            bad_positions = ({ });
            _elections[name]->state = CLUB_ELECTION;
            if (!sizeof(_elections[name]->people)) {
               save_main();
               complete_election(name);
            } else {
               _elections[name]->election_status = 0;
               _elections[name]->time_of_event = time() +
                                                CLUB_ELECTION_TIME;
               set_club_changed(name);
               save_main();
               send_broadcast_message(name,
                            "The nomination period has finished.  Vote "
                            "for your favourite person for each position now "
                            "at the club control centre.");
            }
         } else {
            _elections[name]->election_status = "No one has accepted "
                           "nominations for " +
                           query_multiple_short(bad_positions);
            save_main();
         }
         return bad_positions;
      }
   }
   return 0;
}
int vote_for_person(string club_name,
                    string position,
                    string person,
                    string voter) {
   string name;
   name = normalise_name(club_name);
   if (is_club(name)) {
      if (_elections[name] &&
          _elections[name]->state == CLUB_ELECTION) {
         position = query_position_name(club_name, position);
         if (_elections[name]->voted_for[position] &&
             member_array(voter,
                          _elections[name]->voted_for[position]) == -1) {
            if (!undefinedp(_elections[name]->people[position][person])) {
               _elections[name]->people[position][person]++;
               _elections[name]->voted_for[position] += ({ voter });
               save_main();
               return 1;
            }
         }
      }
   }
}
int complete_election(string club_name) {
   string name;
   string position;
   mapping people;
   string person_name;
   int count;
   int max_count;
   string *max_people;
   mapping elected_positions;
   int pos;
   class election_info frog;
   name = normalise_name(club_name);
   if (is_elected_club(name) &&
       _elections[name] &&
       _elections[name]->state = CLUB_ELECTION) {
      elected_positions = ([ ]);
      foreach (position, people in _elections[name]->people) {
         max_count = 0;
         max_people = ({ });
         if (sizeof(people) > 1) {
            foreach (person_name, count in people) {
               if (count > max_count) {
                  max_count = count;
                  max_people = ({ person_name });
               } else if (count == max_count) {
                  max_people += ({ person_name });
               }
            }
         } else {
            max_people = keys(people);
         }
         if (sizeof(max_people) == 0) {
           _elections[name]->election_status = "No one has voted for "
             "the position of " + position;
           return 0;
         }
         pos = random(sizeof(max_people));
         person_name = max_people[pos];
         elected_positions[position] = person_name;
      }
      frog = query_elected_info(name);
      foreach (position, person_name in elected_positions) {
         set_position_holder(club_name, position, person_name);
      }
      frog->last_election = time();
      set_club_changed(name);
      touch_club(name);
      map_delete(_elections, name);
      save_main();
      send_broadcast_message(name, "The election has finished!");
      return 1;
   }
   return 0;
}
int is_election_in_progress(string club) {
   string name;
   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name]) {
      return 1;
   }
}
int is_nomination_in_progress(string club) {
   string name;
   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name] &&
       (_elections[name]->state == CLUB_NOMINATION ||
        _elections[name]->state == CLUB_NOMINATION_SECOND)) {
      return 1;
   }
}
int is_voting_in_progress(string club) {
   string name;
   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name] &&
       _elections[name]->state == CLUB_ELECTION) {
      return 1;
   }
}
string *query_valid_positions(string club_name) {
   string name;
   class election_info frog;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      frog = query_elected_info(club_name);
      return keys(frog->positions);
   }
   return ({ });
}
string *query_committee(string club_name) {
   string name;
   class election_info frog;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      frog = query_elected_info(club_name);
      return values(frog->positions);
   }
   return ({ });
}
int is_valid_position(string club_name,
                      string position) {
   string *pos;
   pos = map(query_valid_positions(club_name), (: lower_case :));
   return (member_array(lower_case(position), pos) != -1);
}
int is_basic_position(string club_name,
                      string position) {
   class election_info frog;
   if (is_club(club_name) &&
       is_valid_position(club_name, position)) {
      frog = query_elected_info(club_name);
      position = query_position_name(club_name, position);
      return (position == frog->president) ||
             (position == frog->vice_president) ||
             (position == frog->secretary) ||
             (position == frog->treasurer);
   }
   return 0;
}
string query_position_name(string club_name,
                           string position) {
   string *pos;
   string *real_pos;
   int i;
   real_pos = query_valid_positions(club_name);
   pos = map(real_pos, (: lower_case :));
   i = member_array(lower_case(position), pos);
   if (i == -1) {
      return 0;
   }
   return real_pos[i];
}
string query_position_members(string club_name, string position) {
   class election_info frog;
   if (is_elected_club(club_name) &&
       is_valid_position(club_name, position)) {
      position = query_position_name(club_name, position);
      frog = query_elected_info(club_name);
      if (frog->positions[position]) {
         return frog->positions[position];
      }
   }
   return "not found";
}
int create_position_in_club(string name,
                            string position) {
   class election_info frog;
   if (is_elected_club(name) &&
       !is_voting_in_progress(name) &&
       !is_valid_position(name, position)) {
      frog = query_elected_info(name);
      frog->positions[position] = CLUB_UNKNOWN_MEMBER;
      set_club_changed(name);
      if (is_nomination_in_progress(name)) {
         name = normalise_name(name);
         _elections[name]->nominated[position] = ([ ]);
         _elections[name]->voted_for[position] = ({ });
         _elections[name]->people[position] = ([ ]);
         save_main();
      }
      return 1;
   }
   return 0;
}
int remove_position_in_club(string name,
                            string position) {
   class election_info frog;
   class account_info green;
   string account;
   if (is_elected_club(name) &&
       is_valid_position(name, position) &&
       !is_voting_in_progress(name) &&
       !is_basic_position(name, position)) {
      position = query_position_name(name, position);
      frog = query_elected_info(name);
      map_delete(frog->positions, position);
      set_club_changed(name);
      if (is_nomination_in_progress(name)) {
         name = normalise_name(name);
         map_delete(_elections[name]->nominated, position);
         map_delete(_elections[name]->voted_for, position);
         map_delete(_elections[name]->people, position);
         save_main();
      }
      foreach (account, green in frog->account_info) {
         green->allowed_positions -= ({ position });
      }
      send_observer_event("club_event_remove_position",
                          name,
                          position);
      return 1;
   }
   return 0;
}
int change_position_name_in_club(string name,
                                 string position,
                                 string new_position) {
   class election_info frog;
   class account_info green;
   string account;
   int pos;
   if (is_elected_club(name) &&
       !is_valid_position(name, new_position) &&
       !is_voting_in_progress(name) &&
       is_valid_position(name, position)) {
      position = query_position_name(name, position);
      frog = query_elected_info(name);
      frog->positions[new_position] = frog->positions[position];
      map_delete(frog->positions, position);
      if (frog->president == position) {
         frog->president = new_position;
      } else if (frog->vice_president == position) {
         frog->vice_president = new_position;
      } else if (frog->secretary == position) {
         frog->secretary = new_position;
      } else if (frog->treasurer == position) {
         frog->treasurer = new_position;
      }
      set_club_changed(name);
      name = normalise_name(name);
      if (is_nomination_in_progress(name)) {
         _elections[name]->nominated[new_position] =
                                         _elections[name]->nominated[position];
         map_delete(_elections[name]->nominated, position);
         _elections[name]->voted_for[new_position] =
                                         _elections[name]->voted_for[position];
         map_delete(_elections[name]->voted_for, position);
         _elections[name]->people[new_position] =
                                         _elections[name]->people[position];
         map_delete(_elections[name]->people, position);
         save_main();
      }
      foreach (account, green in frog->account_info) {
         pos = member_array(position, green->allowed_positions);
         if (pos != -1) {
            green->allowed_positions[pos] = new_position;
         }
      }
      send_observer_event("club_event_change_position_name",
                          name,
                          position,
                          new_position);
      return 1;
   }
   return 0;
}
int set_position_holder(string club_name,
                                  string position,
                                  string person) {
   class election_info info;
   info = query_elected_info(club_name);
   if (info) {
      if (is_valid_position(club_name, position)) {
         if (is_member_of(club_name, person) ||
             person == CLUB_UNKNOWN_MEMBER) {
            position = query_position_name(club_name, position);
            info->positions[position] = person;
            set_club_changed(club_name);
            send_observer_event("club_event_position_holder",
                                club_name,
                                position,
                                person);
            return 1;
         }
      }
   }
   return 0;
}
int has_person_voted(string club_name,
                    string position,
                    string person) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (_elections[name]->voted_for[position]) {
            return (member_array(person,
                              _elections[name]->voted_for[position]) != -1);
         } else {
            return 1;
         }
      }
   }
   return 0;
}
int has_nominated_person(string club_name,
                         string position,
                         string nominated,
                         string by) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      position = query_position_name(club_name, position);
      if (_elections[name] &&
          _elections[name]->nominated[position][nominated]) {
         return (member_array(by,
                      _elections[name]->nominated[position][nominated]) != -1);
      }
   }
}
string *query_nominated_for(string club_name,
                            string position) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (is_voting_in_progress(club_name)) {
            if (_elections[name]->people[position]) {
               return keys(_elections[name]->people[position]);
            }
            return ({ });
         } else if (is_nomination_in_progress(club_name)) {
            return keys(_elections[name]->nominated[position]);
         }
      }
   }
   return ({ });
}
string *query_nominators_for(string club_name,
                             string position,
                             string nominated) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (is_nomination_in_progress(club_name) &&
            _elections[name]->nominated[position][nominated]) {
            return _elections[name]->nominated[position][nominated];
         }
      }
   }
   return ({ });
}
int is_nominated_for(string club_name,
                     string position,
                     string person) {
   if (is_valid_position(club_name, position)) {
      return member_array(person,
                          query_nominated_for(club_name, position)) != -1;
   }
}
int is_nomination_accepted(string club_name,
                           string position,
                           string person) {
   string *nom;
   if (is_nominated_for(club_name, position, person)) {
      nom = query_nominators_for(club_name, position, person);
      if (sizeof(nom) > 1 &&
          member_array(person, nom) != -1) {
         return 1;
      }
   }
   return 0;
}
int query_next_event_time(string club_name) {
   if (is_club(club_name)) {
      club_name = normalise_name(club_name);
      if (_elections[club_name]) {
         return _elections[club_name]->time_of_event;
      }
   }
}
string query_election_status(string club_name) {
   if (is_elected_club(club_name)) {
      if (is_election_in_progress(club_name)) {
         club_name = normalise_name(club_name);
         return _elections[club_name]->election_status;
      }
   }
}
string query_announcement(string club_name) {
   class election_info bing;
   bing = query_elected_info(club_name);
   if (bing) {
      return bing->announcement;
   }
   return "";
}
int query_announcement_time(string club_name) {
   class election_info bing;
   bing = query_elected_info(club_name);
   if (bing) {
      return bing->announce_time;
   }
   return 0;
}
int set_announcement(string club_name,
                     string announce) {
   class election_info bing;
   bing = query_elected_info(club_name);
   if (bing) {
      if (bing->announce_time &&
          strlen(bing->announcement)) {
         add_archive(club_name,
                     "Announcement",
                     "Announcement on " + ctime(time()) + ":\n\n" +
                     bing->announcement);
      }
      bing->announce_time = time();
      bing->announcement = announce;
      set_club_changed(club_name);
      send_broadcast_message(club_name, "A new announcement has been added.");
      return 1;
   }
   return 0;
}
private class club_archive* convert_archives(mixed *archives) {
   string archive;
   class club_archive bing;
   int i;
   for (i = 0; i < sizeof(archives); i++) {
      archive = archives[i];
      if (stringp(archive)) {
         bing = new(class club_archive);
         bing->archive_date = time();
         bing->subject = "unknown";
         bing->matter = archive;
         archives[i] = bing;
      }
   }
   return archives;
}
protected int add_archive(string club_name,
                          string subject,
                          string thingy) {
   class election_info data;
   class club_archive fluff;
   data = query_elected_info(club_name);
   if (data) {
      fluff = new(class club_archive);
      fluff->subject = subject;
      fluff->matter = thingy;
      fluff->archive_date = time();
      data->archives += ({ fluff });
      if (sizeof(data->archives) > CLUB_MAX_ARCHIVE_SIZE) {
         data->archives = data->archives[<CLUB_MAX_ARCHIVE_SIZE..];
      }
      if (stringp(data->archives[0])) {
         data->archives = convert_archives(data->archives);
      }
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
class club_archive *query_archives(string club_name) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      if (sizeof(data->archives) &&
          stringp(data->archives[0])) {
         data->archives = convert_archives(data->archives);
         set_club_changed(club_name);
      }
      return data->archives;
   }
   return ({ });
}
string *query_boards() {
   return _boards;
}
int query_club_board(string club_name) {
   string name;
   name = query_club_board_name(club_name);
   return member_array(name, _boards) != -1;
}
string query_club_board_name(string club_name) {
   return CLUB_BOARD_PREFIX + normalise_name(club_name);
}
int create_club_board(string club_name) {
   string name;
   name = query_club_board_name(club_name);
   if(is_elected_club(club_name) || this_player()->query_director()) {
      if (BOARD_HAND->is_board(name)) {
         return 0;
      }
      BOARD_HAND->create_board(name,
                               B_PRIV_ACCESS_RESTRICTED_METHOD |
                               B_PRIV_NO_INFORM,
                               "frog");
      BOARD_HAND->set_method_access_call(name,
                                         "check_board_post",
                                         CLUB_HANDLER);
      BOARD_HAND->set_timeout(10);
      BOARD_HAND->set_maximum(60);
      BOARD_HAND->set_minimum(10);
      _boards += ({ name });
      save_main();
      return 1;
   }
   return 0;
}
int remove_club_board(string club_name) {
   string name;
   if (query_club_board(club_name)) {
      name = query_club_board_name(club_name);
      BOARD_HAND->delete_board(name);
      _boards -= ({ name });
      save_main();
      return 1;
   }
}
int check_board_post(int type,
                     string board,
                     string previous,
                     string name,
                     int num) {
   string club;
   club = board[strlen(CLUB_BOARD_PREFIX)..];
   switch (type) {
   case B_ACCESS_READ :
      return is_member_of(club, name);
   case B_ACCESS_WRITE :
      return is_member_of(club, name);
   case B_ACCESS_DELETE :
      return holds_any_position_of(club, name);
   case B_ACCESS_INFORM :
      if (!num) {
         send_broadcast_message(club,
                                name + " posts a message to the board.");
      } else {
         send_broadcast_message(club,
                                name + " posts a message to the board and " +
                                num + " message" +
                                (num > 1?"s":"") + " explode in sympathy.");
      }
      return 1;
   }
}
protected void do_mail_committee(string club_name,
                            string subject,
                            string body) {
   string *committee;
   body += "\n\nYours,\nFindlewoodlwinks\n(Club Handler)\n";
   committee = query_committee(club_name) - ({ CLUB_UNKNOWN_MEMBER });
   if (!sizeof(committee)) {
      if (PLAYER_HANDLER->test_user(query_founder(club_name))) {
         committee = ({ query_founder(club_name) });
      } else {
         return ;
      }
   }
   MAILER->do_mail_message(implode(committee, ","),
                           "Patricians office",
                           subject,
                           "",
                           body);
}
protected void check_elected_information(string name,
                                         string member,
                                         int startup) {
   class election_info data;
   string position_name;
   string person;
   mapping gruff;
   string *nom;
   int cre_club;
   int votes;
   name = normalise_name(name);
   data = query_elected_info(name);
   if (data) {
      if (!mapp(data->options)) {
         data->options = ([ ]);
         set_club_changed(name);
      }
      foreach (position_name, person in data->positions) {
         if (person != CLUB_UNKNOWN_MEMBER &&
             (!is_member_of(name, person) ||
              !PLAYER_HANDLER->test_active(person) ||
              member == person)) {
            set_position_holder(name, position_name, CLUB_UNKNOWN_MEMBER);
         }
      }
      if (query_next_election(name) < time() ||
          _elections[name]) {
         if (!_elections[name]) {
            start_election(name);
         } else {
            switch (_elections[name]->state) {
               case CLUB_NOMINATION_SECOND :
               case CLUB_NOMINATION :
                  if (_elections[name]->time_of_event < time()) {
                     if (sizeof(finish_nomination(name))) {
                        _elections[name]->time_of_event = time() +
                                                          CLUB_ELECTION_TIME;
                        _elections[name]->state = CLUB_NOMINATION_SECOND;
                        save_main();
                     }
                  }
                  break;
               case CLUB_ELECTION :
                  if (_elections[name]->time_of_event < time()) {
                     complete_election(name);
                  }
                  break;
            }
         }
      }
      if (_elections[name] &&
          startup) {
         cre_club = is_creator_club(name);
         foreach (position_name, gruff in _elections[name]->people) {
            foreach (person, votes in gruff) {
               if ((!cre_club &&
                    PLAYER_HANDLER->test_creator(person)) ||
                   !is_member_of(name, person) ||
                   !PLAYER_HANDLER->test_user(person)) {
                  map_delete(gruff, person);
               }
            }
         }
         foreach (position_name,
                  gruff in _elections[name]->nominated) {
            foreach (person, nom in gruff) {
               if ((!cre_club &&
                    PLAYER_HANDLER->test_creator(person)) ||
                   !is_member_of(name, person) ||
                   !PLAYER_HANDLER->test_user(person)) {
                  map_delete(gruff, person);
               }
            }
         }
      }
   }
}

==================================================
FILE: /lib/obj/handlers/inherit/club_family.c
==================================================

inherit "/obj/handlers/inherit/club_personal";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
#include <player_handler.h>
private nosave mapping _valid_relationships;
private nosave mapping _gender_relationship;
private void add_valid_relationship(string relation,
                                    string relation2,
                                    int flags);
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female);
string* query_gender_relationships(string relationship);
class family_info {
   mapping relationships;
   string *never_join;
   string tmp;
   int tmp2;
}
#define CLUB_INTERFAMILY_FLAG 1
#define CLUB_JOIN_FAMILY_FLAG 2
class relationship_type_data {
   string opposite;
   int flags;
}
void create() {
   _valid_relationships = ([ ]);
   _gender_relationship = ([ ]);
   ::create();
   add_valid_relationship("spouse",
                          "spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "spouse",
                           "husband",
                           "wife");
   add_valid_relationship("lover",
                          "lover",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "lover",
                           "lover",
                           "lover");
   add_valid_relationship("sibling",
                          "sibling",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling",
                           "brother",
                           "sister");
   add_valid_relationship("sibling-in-law",
                          "sibling-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling-in-law",
                           "brother-in-law",
                           "sister-in-law");
   add_valid_relationship("parent-in-law",
                          "child-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "parent-in-law",
                           "father-in-law",
                           "mother-in-law");
   add_gender_relationship("Ankh-Morpork",
                           "child-in-law",
                           "son-in-law",
                           "daughter-in-law");
   add_valid_relationship("child",
                          "parent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "child",
                          "son",
                          "daughter");
   add_gender_relationship("Ankh-Morpork",
                           "parent",
                           "father",
                           "mother");
   add_valid_relationship("grandparent",
                          "grandchild",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "grandparent",
                           "grandfather",
                           "grandmother");
   add_gender_relationship("Ankh-Morpork",
                           "grandchild",
                           "grandson",
                           "granddaughter");
   add_valid_relationship("godchild",
                          "godparent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "godchild",
                           "godson",
                           "goddaughter");
   add_gender_relationship("Ankh-Morpork",
                           "godparent",
                           "godfather",
                           "godmother");
   add_valid_relationship("uncle",
                          "niece",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "uncle",
                           "uncle",
                           "aunt");
   add_gender_relationship("Ankh-Morpork",
                           "niece",
                           "nephew",
                           "niece");
   add_valid_relationship("cousin",
                          "cousin",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "cousin",
                           "cousin",
                           "cousin");
   add_valid_relationship("master",
                          "maid",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "maid",
                           "butler",
                           "maid");
   add_gender_relationship("Ankh-Morpork",
                           "master",
                           "master",
                           "mistress");
   add_valid_relationship("apprentice",
                          "tutor",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "apprentice",
                           "apprentice",
                           "apprentice");
   add_gender_relationship("Ankh-Morpork",
                           "tutor",
                           "tutor",
                           "tutor");
   add_valid_relationship("guardian",
                          "ward",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "guardian",
                           "guardian",
                           "guardian");
   add_gender_relationship("Ankh-Morpork",
                           "ward",
                           "ward",
                           "ward");
   add_valid_relationship("ex-spouse",
                          "ex-spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "ex-spouse",
                           "ex-husband",
                           "ex-wife");
}
protected void create_extra_data(string name) {
   class family_info f_info;
   class club_info data;
   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_FAMILY) {
      f_info = new(class family_info);
      f_info->relationships = ([ ]);
      f_info->never_join = ({ });
      data->extra_data = f_info;
   } else {
      ::create_extra_data(name);
   }
   set_club_changed(name);
}
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      if (is_family(club_name)) {
         return FAMILY_COST_PER_YEAR +
              sizeof(query_members(club_name)) * FAMILY_COST_PER_MEMBER_PER_YEAR;
      } else {
         return ::query_club_cost_per_period(club_name);
      }
   }
   return 0;
}
private class family_info query_family_info(string name) {
   class club_info data;
   if (is_family(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
}
void add_valid_relationship(string relation1,
                            string relation2,
                            int flags) {
   class relationship_type_data frog;
   frog = new(class relationship_type_data);
   frog->opposite = relation2;
   frog->flags = flags;
   _valid_relationships[relation1] = frog;
   frog = new(class relationship_type_data);
   frog->opposite = relation1;
   frog->flags = flags;
   _valid_relationships[relation2] = frog;
}
string query_opposite_relationship(string relation) {
   if (_valid_relationships[relation]) {
      return _valid_relationships[relation]->opposite;
   }
   return 0;
}
int is_valid_relationship(string str) {
   return _valid_relationships[str] != 0;
}
int is_valid_interfamily_relationship(string str) {
   class relationship_type_data frog;
   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_INTERFAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
}
int is_valid_join_family_relationship(string str) {
   class relationship_type_data frog;
   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_JOIN_FAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
}
string *query_all_valid_relationships() {
   return keys(_valid_relationships);
}
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female) {
   _gender_relationship[male] = relationship;
   _gender_relationship[female] = relationship;
   if (!mapp(_gender_relationship[relationship])) {
      _gender_relationship[relationship] = ([ ]);
   }
   _gender_relationship[relationship][region] = ({ male,
                                                   female });
}
string query_ungendered_relationship(string relationship) {
   if (stringp(_gender_relationship[relationship])) {
      return _gender_relationship[relationship];
   }
   if (mapp(_gender_relationship[relationship])) {
      return relationship;
   }
   return 0;
}
string *query_all_relationships() {
   return keys(_gender_relationship);
}
string query_relationship_gender(string relationship,
                                 int female,
                                 string region) {
   string rel;
   rel = query_ungendered_relationship(relationship);
   if (!rel ||
       female < 0 ||
       female > 1) {
      return 0;
   }
   if (!region || !_gender_relationship[rel][region]) {
      region = "Ankh-Morpork";
   }
   return _gender_relationship[rel][region][female];
}
private void real_add_relationship(string name,
                                   string person,
                                   string dest,
                                   string relationship) {
   class family_info womble;
   class relationship_data plum;
   womble = query_family_info(name);
   if (!womble->relationships[person]) {
      womble->relationships[person] = ({ });
   }
   plum = new(class relationship_data);
   plum->related_to = dest;
   plum->relationship = relationship;
   womble->relationships[person] += ({ plum });
   set_club_changed(name);
}
private void real_remove_relationship(string name,
                                      string person,
                                      string dest,
                                      string relationship) {
   class family_info womble;
   int i;
   womble = query_family_info(name);
   for (i = 0; i < sizeof(womble->relationships[person]); i++) {
      if (womble->relationships[person][i]->related_to == dest &&
          womble->relationships[person][i]->relationship == relationship) {
         womble->relationships[person] = womble->relationships[person][0..i-1] +
                                         womble->relationships[person][i+1..];
         set_club_changed(name);
      }
   }
}
int add_relationship(string name,
                     string person,
                     string dest_name,
                     string dest,
                     string relationship) {
   if (is_family(name) &&
       is_family(dest_name) &&
       is_member_of(name, person) &&
       is_member_of(dest_name, dest) &&
       is_valid_relationship(relationship)) {
      real_add_relationship(name,
                            person,
                            dest,
                            relationship);
      real_add_relationship(dest_name,
                            dest,
                            person,
                            query_opposite_relationship(relationship));
      save_club(name);
      return 1;
   }
   return 0;
}
class relationship_data *query_relationships(string name,
                                             string person) {
   class family_info womble;
   if (is_family(name)) {
      womble = query_family_info(name);
      if (womble->relationships[person]) {
         return womble->relationships[person];
      }
   }
   return ({ });
}
int move_family_member(string curr_family,
                       string person,
                       string dest_family) {
  class relationship_data *stuff;
  class family_info womble;
  if (is_family(curr_family) &&
      is_family(dest_family) &&
      is_member_of(curr_family, person)) {
    stuff = query_relationships(curr_family,
                                person);
    womble = query_family_info(curr_family);
    map_delete(womble->relationships, person);
    set_club_changed(curr_family);
    remove_member(curr_family, person);
    add_member(dest_family, person);
    womble = query_family_info(dest_family);
    womble->relationships[person] = stuff;
    set_club_changed(dest_family);
    return 1;
  }
  return 0;
}
string *query_relationships_to(string name,
                               string person,
                               string related) {
   class relationship_data frog;
   string *relationships;
   relationships = ({ });
   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related) {
         relationships += ({ frog->relationship });
      }
   }
   return relationships;
}
int is_relationship(string name,
                    string person,
                    string related,
                    string relationship) {
   class relationship_data frog;
   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related &&
          frog->relationship == relationship) {
         return 1;
      }
   }
   return 0;
}
int remove_relationship(string name,
            string person,
                        string dest_name,
      string dest,
      string relationship) {
   if (is_relationship(name, person, dest, relationship)) {
      real_remove_relationship(name,
                   person,
             dest,
             relationship);
      if (dest_name) {
         real_remove_relationship(dest_name,
                      dest,
                person,
                      query_opposite_relationship(relationship));
      }
      return 1;
   }
   return 0;
}
protected void check_family_information(string name,
                                        string member,
                                        int startup) {
   class family_info fam_data;
   string family;
   fam_data = query_family_info(name);
   if (fam_data) {
      if (member &&
         fam_data->relationships[member]) {
         family = PLAYER_HANDLER->test_family(member);
         if (!family ||
              normalise_name(family) != name) {
            if (find_player(member)) {
               find_player(member)->set_family_name(family);
            } else {
               log_file("CLUB", ctime(time()) +
                                ": removed " +
                                member + " from " + family +
                                " family deficent.\n");
               remove_member(name, member);
            }
         }
         if (!undefinedp(fam_data->relationships)) {
            map_delete(fam_data->relationships, member);
            set_club_changed(name);
         }
      }
   }
}

==================================================
FILE: /lib/obj/handlers/inherit/club_inherit.c
==================================================

inherit "/obj/handlers/inherit/club_discuss";
#define __CLUBS_H_NO_CLASSES
#define __MAIL_H_NO_CLASSES
#include <mail.h>
#include <clubs.h>
#include <player_handler.h>
#include <broadcaster.h>
#include <player.h>
#include <top_ten_tables.h>
#include <library.h>
#include <player_handler.h>
private nosave int _callout_id;
private nosave int _test_callout_id;
private string _current_test_club;
private int _last_test_time;
protected void check_extra_information(string name, string person, int startup);
void check_clubs(int startup);
class top_ten_tables {
   int num;
   int qp;
   int age;
   int start_time;
   int gender;
   int single_gender;
   int rels;
   int no_pks;
   mapping guild;
}
protected void setup_call_check_clubs(int time, int startup) {
   remove_call_out(_callout_id);
   _callout_id = call_out("check_clubs", time, startup);
}
private void send_low_balance_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         to -= ({ "unknown" });
         if (!sizeof(to)) {
            to = query_members(club);
         }
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   to = filter(to, (: PLAYER_HANDLER->test_user($1) :));
   if (sizeof(to)) {
      MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has fees due.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a reminder from the Patrician's Office "
                           "the " + bit + " '" + query_club_name(club) +
                           "' is currently in remission and "
                           "its balance will need to be updated before "
                           "the next "
                           "pay period or your " + bit + " will be "
                           "disbanded.\n\nYours happily,\nThe Patrician."));
   }
}
private void send_disband_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has been disbanded.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a message from the patricians "
                           "office to you that your " + bit +
                           " '" + query_club_name(club) +
                           "' has been disbanded for having its fees "
                           "in remission."
                           "\n\nYours happily,\nThe Patrician."));
}
protected void check_extra_information(string name,
                                       string member,
                                       int startup) {
   if (is_elected_club(name)) {
      check_elected_information(name, member, startup);
   } else if (is_family(name)) {
      check_family_information(name, member, startup);
   }
}
protected void check_club_members(string club_name,
                                string* members,
                                class top_ten_tables top_info) {
   int i;
   int tmp;
   string member;
   string str;
   string flip;
   class relationship_data *rels;
   class relationship_data frog;
   for (i = 0; i < 1 && i < sizeof(members); i++) {
      member = members[i];
      if (!PLAYER_HANDLER->test_user(member)) {
         log_file("CLUB", ctime(time()) + ": removed " + member +
                          " from " + club_name + " for not existing.\n");
         remove_member(club_name, member);
      } else if (!PLAYER_HANDLER->test_creator(member) &&
                 !PLAYER_HANDLER->test_property(member, "no score")) {
         top_info->num++;
         top_info->qp += LIBRARY->query_quest_points(member);
         tmp = -PLAYER_HANDLER->test_age(member) / (60 * 60);
         top_info->rels += sizeof(CLUB_HANDLER->query_relationships(club_name, member));
         top_info->age += tmp;
         top_info->start_time += PLAYER_HANDLER->test_start_time(member) / (60 * 60);
         str = PLAYER_HANDLER->test_guild(member);
         if (str &&
             str != "") {
            if (top_info->guild[str]) {
               top_info->guild[str]++;
            } else {
               if (file_size(str + ".c") > 0) {
                  flip = str->query_real_guild_object();
                  if (flip) {
                     str = flip;
                  }
                  top_info->guild[str]++;
               }
            }
         }
         if (PLAYER_HANDLER->test_player_killer(member)) {
            top_info->no_pks++;
         }
         if (!top_info->gender) {
            top_info->gender = PLAYER_HANDLER->test_gender(member);
         }
         if (top_info->single_gender != -1 &&
             PLAYER_HANDLER->test_gender(member) != top_info->gender) {
            top_info->single_gender = -1;
         }
      }
      if (is_family(club_name)) {
         check_family_information(club_name, member, 0);
         rels = CLUB_HANDLER->query_relationships(club_name, member);
         foreach (frog in rels) {
            if (!PLAYER_HANDLER->test_family(frog->related_to)) {
               log_file("CLUB", ctime(time()) + ": removed relationship " +
                          member +
                          " <-> " + frog->related_to + " (" +
                          frog->relationship + ") for loosing their "
                          "family.\n");
            }
         }
      }
   }
   members = members[1..];
   if (!sizeof(members)) {
      if (!sizeof(query_members(club_name))) {
         disband_club(club_name);
      } else if (top_info->num > 3) {
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_LARGEST_FAMILY,
                                         top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_FAMILY,
                                         top_info->age / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_QUEST_POINTS,
                                         top_info->qp / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_GUILD,
                                         top_info->guild);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_PKS,
                                         top_info->no_pks);
         if (top_info->single_gender != -1) {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            top_info->num);
         } else {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            0);
         }
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_LOGONS,
                                         top_info->start_time / top_info->num);
      }
      top_info = new(class top_ten_tables);
      top_info->guild = ([ ]);
      i = member_array(_current_test_club, query_clubs());
      if (i < sizeof(query_clubs())) {
         _current_test_club = query_clubs()[i+1];
         _test_callout_id = call_out("check_club_members", 60, _current_test_club, query_members(_current_test_club), top_info);
      } else {
         _current_test_club = 0;
         _test_callout_id = 0;
      }
      save_main();
   } else {
      _test_callout_id = call_out("check_club_members", 60, club_name, members, top_info);
   }
}
private nosave int _specific_callout_id = 0;
private nosave string *_clubs_to_check = ({ });
protected void check_specific_club(string club_name, int startup) {
    class club_info bing;
    bing = (class club_info)query_club_info(club_name);
    if (bing->last_touched < time() - CLUB_TIMEOUT) {
        disband_club(club_name);
        return;
    }
    if (!pointerp(query_members(club_name))) {
        disband_club(club_name);
        return;
    }
    if (query_time_fees_due(club_name) < time()) {
        if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
            send_disband_mail(club_name);
            disband_club(club_name);
            return;
        }
        if (remove_money(club_name, query_club_cost_per_period(club_name),
            CLUB_TRANSACTION_UPKEEP, "Club Dues",
            CLUB_DEFAULT_ACCOUNT_NAME, 0)) {
            int tmp;
            bing = (class club_info)query_club_info(club_name);
            tmp = bing->last_paid;
            bing->last_paid = query_time_fees_due(club_name);
            set_club_changed(club_name);
            if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
               reset_eval_cost();
               send_low_balance_mail(club_name);
            }
        }
    }
    call_out( (: check_extra_information :),  1,  club_name, 0,  startup);
}
protected void check_specific_clubs( int startup, int pos ) {
    string club_name;
    if ( pos >= sizeof( _clubs_to_check ) ) {
        _clubs_to_check = ({ });
        _specific_callout_id = 0;
        pos = 0;
        return;
    }
    club_name = _clubs_to_check[ pos ];
    tell_creator( "taffyd", "Checking club %s (%d)\n", club_name, pos );
    check_specific_club(club_name, startup);
    _specific_callout_id = call_out( (: check_specific_clubs :), 10, startup, ++pos );
}
void check_clubs(int startup) {
   class top_ten_tables blue;
   setup_call_check_clubs(24 * 60 * 60, 0);
   if ( !_specific_callout_id ) {
       _clubs_to_check = query_clubs();
        _specific_callout_id = call_out( (: check_specific_clubs :), 0,
            startup, 0 );
   }
   remove_call_out(_test_callout_id);
   if (!_current_test_club &&
       _last_test_time + 7 * 24 * 60 * 60 < time()) {
      if (sizeof(query_clubs()) > 0) {
         _current_test_club = query_clubs()[0];
      }
      _last_test_time = 0;
      save_main();
   }
   if (_current_test_club) {
      blue = new(class top_ten_tables);
      blue->guild = ([ ]);
      _test_callout_id = call_out("check_club_members",
                                 60,
                                 _current_test_club,
                                 query_members(_current_test_club),
                                 blue);
   }
}
#ifdef OLD_CHECK_CODE
protected void check_specific_club(string club_name, int extra_space,
                                   int startup) {
}
#endif

==================================================
FILE: /lib/obj/handlers/inherit/club_personal.c
==================================================

inherit "/obj/handlers/inherit/club_basic";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
class personal_info {
}
protected void create_extra_data(string name) {
   class personal_info p_info;
   class club_info data;
   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_PERSONAL) {
         p_info = new(class personal_info);
      data->extra_data = p_info;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
}
private class personal_info query_personal_info(string name) {
   class club_info data;
   if (is_personal_club(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
   return 0;
}

==================================================
FILE: /lib/obj/handlers/inherit/craft_skills.c
==================================================

#include <skills.h>
private string *_craft_skill_tree;
void add_craft_skill(string name);
void create() {
   _craft_skill_tree = ({ });
   add_craft_skill("crafts.smithing.gold");
   add_craft_skill("crafts.smithing.silver");
   add_craft_skill("crafts.smithing.black.tool");
   add_craft_skill("crafts.smithing.black.weapon");
   add_craft_skill("crafts.smithing.black.armour");
   add_craft_skill("crafts.smithing.gem.cutting");
   add_craft_skill("crafts.smithing.gem.polishing");
   add_craft_skill("crafts.smithing.gem.setting");
   add_craft_skill("crafts.mining.gem");
   add_craft_skill("crafts.mining.ore.panning");
   add_craft_skill("crafts.mining.mineral");
   add_craft_skill("crafts.hunting.tracking");
   add_craft_skill("crafts.hunting.fishing");
   add_craft_skill("crafts.hunting.trapping");
   add_craft_skill("crafts.carpentry.furniture");
   add_craft_skill("crafts.carpentry.coopering");
   add_craft_skill("crafts.carpentry.turning");
   add_craft_skill("crafts.carpentry.whittling");
   add_craft_skill("crafts.pottery.forming.throwing");
   add_craft_skill("crafts.pottery.forming.shaping");
   add_craft_skill("crafts.pottery.glazing");
   add_craft_skill("crafts.pottery.staining");
   add_craft_skill("crafts.pottery.firing");
   add_craft_skill("crafts.materials.leatherwork");
   add_craft_skill("crafts.materials.weaving");
   add_craft_skill("crafts.materials.spinning");
   add_craft_skill("crafts.materials.needlework");
   add_craft_skill("crafts.materials.dyeing");
   add_craft_skill("crafts.husbandry.plant.edible");
   add_craft_skill("crafts.husbandry.plant.herbal");
   add_craft_skill("crafts.husbandry.plant.milling");
   add_craft_skill("crafts.husbandry.plant.tree");
   add_craft_skill("crafts.husbandry.animal.grooming");
   add_craft_skill("crafts.husbandry.animal.breeding");
   add_craft_skill("crafts.culinary.cooking");
   add_craft_skill("crafts.culinary.baking");
   add_craft_skill("crafts.culinary.butchering");
   add_craft_skill("crafts.culinary.preserving");
   add_craft_skill("crafts.culinary.brewing");
   add_craft_skill("crafts.culinary.distilling");
   add_craft_skill("crafts.arts.design");
   add_craft_skill("crafts.arts.calligraphy");
   add_craft_skill("crafts.arts.drawing");
   add_craft_skill("crafts.arts.painting");
   add_craft_skill("crafts.arts.printing");
   add_craft_skill("crafts.arts.sculpture");
   add_craft_skill("crafts.points");
}
private mixed *add_craft_skill_int(string *bits,
                                   mixed *arr) {
   int pos;
   pos = member_array(bits[0], arr);
   if (pos == -1) {
      pos = sizeof(arr);
      arr += ({ bits[0], 0, 0, ({ }) });
   }
   if (sizeof(bits) > 1) {
      arr[pos + SKILL_BIT] = add_craft_skill_int(bits[1..],
                                                 arr[pos + SKILL_BIT]);
   }
   return arr;
}
private void add_craft_skill(string name) {
   string *bits;
   bits = explode(name, ".");
   _craft_skill_tree = add_craft_skill_int(bits, _craft_skill_tree);
}
mixed *query_crafts_skill_tree() {
   return _craft_skill_tree;
}

==================================================
FILE: /lib/obj/handlers/inherit/distance_handler.c
==================================================

#define BAD_ROOM -1
#define TRAVEL_NOT_ALLOWED -2
#define BAD_DOMAIN -3
int* query_co_ord(string room);
private int difference(int bing, int womble){
   if (womble > bing) {
      return womble - bing;
   }
   return bing - womble;
}
private int filename_check(string one, string two){
   string dom_one;
   string dom_two;
   string alpha;
   log_file("/log/PORTAL", "Unable to get co-ords for %O %O, doing filename based check.\n", one, two);
   dom_one = explode(one, "/")[1];
   dom_two = explode(two, "/")[1];
   alpha = dom_one<dom_two?dom_one+":"+dom_two:dom_two+":"+dom_one;
   switch(alpha){
      case "am:am":
         return 3000;
      case "am:cwc":
         return TRAVEL_NOT_ALLOWED;
      case "am:ram":
         return 3000000;
      case "am:klatch":
         return 1000000;
      case "am:sur":
         return 500000;
      case "am:forn":
         return TRAVEL_NOT_ALLOWED;
      case "am:guilds":
         return 1000;
      case "cwc:ram":
      case "cwc:klatch":
      case "cwc:forn":
      case "cwc:guilds":
      case "cwc:sur":
         return TRAVEL_NOT_ALLOWED;
      case "cwc:cwc":
         return 500000;
      case "forn:forn":
         return TRAVEL_NOT_ALLOWED;
      case "forn:ram":
         return TRAVEL_NOT_ALLOWED;
      case "forn:guilds":
         return TRAVEL_NOT_ALLOWED;
      case "forn:klatch":
         return TRAVEL_NOT_ALLOWED;
      case "forn:sur":
         return TRAVEL_NOT_ALLOWED;
      case "guilds:guilds":
         return 1000;
      case "guilds:klatch":
         return 500000;
      case "guilds:sur":
         return 500000;
      case "guilds:ram":
         return 1500000;
      case "klatch:klatch":
         return 1000;
      case "klatch:sur":
         return 3300000;
      case "klatch:ram":
         return 4000000;
      case "ram:ram":
         return 500000;
      case "ram:sur":
         return 900000;
      case "sur:sur":
         return 500000;
   }
   return BAD_DOMAIN;
}
int query_distance_from_coords(int* co_ord_one, int* co_ord_two){
   float x;
   float y;
   float z;
   float distanceplane;
   float distance;
   x = difference(co_ord_one[0], co_ord_two[0]);
   y = difference(co_ord_one[1], co_ord_two[1]);
   z = difference(co_ord_one[2], co_ord_two[2]);
   distanceplane = sqrt(pow(x, 2) + pow(y, 2));
   distance = sqrt(pow(distanceplane, 2) + pow(z, 2));
   return to_int(distance);
}
int query_distance_from_rooms(mixed one, mixed two){
   mixed co_ord_one;
   mixed co_ord_two;
   if (objectp(one)) {
      one = file_name(one);
   }
   if (objectp(two)) {
      two = file_name(two);
   }
   if (one->query_co_ord()) {
      co_ord_one = one->query_co_ord();
   } else {
      co_ord_one = query_co_ord(one);
   }
   if (two->query_co_ord()) {
      co_ord_two = two->query_co_ord();
   } else {
      co_ord_two = query_co_ord(two);
   }
   if(co_ord_one == 0 || co_ord_two == 0) {
      return filename_check(one, two);
   }
   return query_distance_from_coords(co_ord_one, co_ord_two);
}
# Total Tokens: 22495
# Total Files Merged: 6
# Total Characters: 74997

