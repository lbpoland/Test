# Total Tokens: 15135
# Total Files Merged: 9
# Total Characters: 50483

c.c
==================================================

#include "weapon_old.h"
nosave mapping ac;
nosave mixed armour_types;
void create() {
  ac = ([ ]);
  armour_types = ({ });
}
int add_ac(string name, string type, mixed a_c) {
  int i;
  if (!stringp(type))
    return 0;
  if (!ac) ac = ([ ]);
  if (ac[name])
    return 0;
  ac[name] = ({ a_c, type });
  if ((i=member_array(type, armour_types)) == -1)
    armour_types += ({ type, ({ name }) });
  else
    armour_types[i+1] += ({ name });
  return 1;
}
int remove_ac(string name) {
  int j, k;
  if (!ac[name])
    return 0;
  j = member_array(ac[name][1], armour_types);
  k = member_array(name, armour_types[j+1]);
  armour_types[j+1] = delete(armour_types[j+1], k, 1);
  if (!sizeof(armour_types[j+1]))
    armour_types = delete(armour_types, j, 2);
  map_delete(ac, name);
  return 1;
}
int calc_value(mixed arr) {
  int i, val;
  if (intp(arr)) {
    if(!random(10))
      return random(arr);
    else
      return arr;
  }
  if (!pointerp(arr))
    return 0;
  if (sizeof(arr) == 1)
    return arr[F_FIXED];
  if (sizeof(arr) == 2)
    return arr[F_FIXED]+random(arr[F_RAND]);
  for (i=0;i<arr[F_NUM];i++)
    val += random(arr[F_DIE]);
  return val + arr[F_FIXED];
}
varargs int query_ac( string type, int dam, string zone ) {
  int val, i, j;
  if ( !armour_types )
    return 0;
  if ((i=member_array(type, armour_types)) != -1) {
    for ( j = 0; j < sizeof( armour_types[ i + 1 ] ); j++ )
      if ( ac[ armour_types[ i + 1 ][ j ]])
        if ( sizeof( ac[ armour_types[ i + 1 ][ j ] ] ) == A_ARRAY_SIZE )
          val += calc_value( ac[ armour_types[ i + 1 ][ j ] ][ A_AC ] );
  }
  val -= (val / 4);
  return val;
}
mapping query_armour_class() { return ac; }
string calc_string(mixed b) {
  if (intp(b))
    return "rand("+b+")";
  if (!pointerp(b))
    return "Dead";
  switch (sizeof(b)) {
    case 1 :
      return ""+b[0];
    case 2 :
      return ""+b[0]+"+rand("+b[1]+")";
    case 3 :
      return ""+b[0]+"+"+b[1]+"d"+b[2];
    default :
      return "Oh hell";
  }
}
mixed *stats() {
  int i;
  mixed *ret;
  mixed *stuff;
  ret = ({ });
  stuff = keys(ac);
  for (i=0;i<sizeof(stuff);i++)
    ret += ({ ({ "ARM"+ i +" name", stuff[ i ], }),
              ({ "     type", ac[stuff[i]][A_TYPE], }),
              ({ "    class", calc_string(ac[stuff[i]][A_AC]) }),
          });
  return ret;
}
void set_ac(mixed *bing) {
  int i;
  for (i=0;i<sizeof(ac);i+=A_ARRAY_SIZE)
    add_ac(ac[i], ac[i+1][A_TYPE], ac[i+1][A_AC]);
}

==================================================
FILE: bit.c
==================================================

#include <bit.h>
#include <corpse.h>
inherit "std/object";
#define DECAY_TIME 60
mixed *bit_data, *bits;
mixed race_ob;
int corpse_weight;
string race_name, *bits_gone = ({ });
int decay, cured;
void set_bits();
object make_bit(string which_bit);
object *make_bits(string *what_bits);
string *query_bits_left();
string *query_possible_bits(string);
void create() {
  ::create();
  set_short("anonymous bit");
  set_long("This is an unknown bit of some creature.\n");
  corpse_weight = STD_CORPSE_WEIGHT;
  set_weight(5);
  set_name("bit");
  add_property( "corpse bit", 1 );
  add_property("cureable", 1);
}
void init() {
  add_command("eat", "<direct:object>");
}
int query_edible() {
  string bit;
  if(!race_ob->query_eat(bit_data[BIT_NAME])) {
    return 0;
  }
  foreach(bit in query_possible_bits(0) - bits_gone) {
    if(!race_ob->query_eat(bit)) {
      return 0;
    }
  }
  return 1;
}
int do_eat() {
  if(!query_edible())
    return 0;
  move( "/room/rubbish" );
  return 1;
}
int no_decay() {
  if( race_ob && bit_data ) {
    return race_ob->query_unrottable(bit_data[BIT_NAME]);
  }
}
void set_race_ob(object s) {
  race_ob = s;
}
void set_race_name(string s) {
  race_name = s;
}
void setup_long() {
  if ( !bit_data ) {
    return;
  }
  if (no_decay()) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the " + (bit_data[BIT_NAME]) + " of " +
      add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the " + (bit_data[BIT_NAME]) +
               " of an unknown creature.\n");
    }
  } else if (decay > 80) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is a fresh " + (bit_data[BIT_NAME]) +
               " severed from the corpse of " + add_a(race_name) + ".\n");
    } else {      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is a fresh " + (bit_data[BIT_NAME]) +
               " severed from the corpse of an unknown creature.\n");
    }
  } else if (decay > 50) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is " + add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is " + add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of an unknown creature.\n");
    }
  } else if (decay > 30) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the partially decayed remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the partially decayed remains of " +
      add_a(bit_data[BIT_NAME]) + " severed from the "
      "corpse of an unknown creature.\n");
    }
  } else {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the almost unrecognizable remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the almost unrecognizable remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  }
  add_extra_look(this_object());
  if ( cured ) {
    set_long( query_long() +"It seems to have been pickled.\n" );
  }
}
string extra_look() {
  if(sizeof(bits_gone))
    return "It appears to be missing the " + query_multiple_short(bits_gone) + ".\n";
  return "";
}
void set_corpse_weight(int i) { corpse_weight = i; }
void set_bit(string s, int dec) {
  int temp;
  bit_data = (mixed *)race_ob->query_bit(s);
  if (!bit_data || !sizeof(bit_data)) {
    return;
  }
  if (race_name) {
    add_adjective(race_name);
  } else {
    add_adjective("unknown");
  }
  add_adjective( explode( s, " " ) );
  if ( pointerp( bit_data[ BIT_EXTRA ][ EXTRA_VALUE ] ) &&
       ( sizeof( bit_data[ BIT_EXTRA ][ EXTRA_VALUE ] ) > 3 ) ) {
    set_value(bit_data[BIT_EXTRA][EXTRA_VALUE][3]);
  }
  add_alias( bit_data[ BIT_NAME ] );
  add_plural( pluralize( bit_data[ BIT_NAME ] ) );
  if ( bit_data[ BIT_ALIAS ] && strlen( bit_data[ BIT_ALIAS ] ) ) {
    add_alias(bit_data[BIT_ALIAS]);
    add_plural( pluralize( bit_data[ BIT_ALIAS ] ) );
  }
  if ((temp=bit_data[BIT_EXTRA][EXTRA_WEIGHT] * corpse_weight
             / STD_CORPSE_WEIGHT) > 0) {
    set_weight(temp);
  } else {
    set_weight(1);
  }
  if(dec) {
    decay = dec;
  } else {
    decay = 100;
  }
  if (!no_decay()) {
      BIT_CONTROLLER->add_bit(this_object());
  }
  setup_long();
  set_bits();
  return;
}
int do_decay() {
  int rate;
  if (!environment()) {
    move( "/room/rubbish" );
    return 0;
  }
  rate = 5 + (int)environment()->query_property( "decay rate" );
  if ( rate > 0 ) {
    decay -= rate;
  }
  if (decay < 0) {
    tell_object(environment(),
                capitalize(the_short()) + " decays to dust.\n");
    move( "/room/rubbish" );
    return 0;
  }
  if (decay == 80 || decay == 50 || decay == 30) {
    setup_long();
  }
  return 1;
}
object query_race_ob() { return race_ob; }
string query_race_name() { return race_name; }
mixed query_bit_data() { return bit_data; }
int query_decay() { return decay; }
void dest_me() {
  BIT_CONTROLLER->remove_bit(this_object());
  ::dest_me();
}
mixed query_static_auto_load() {
  return int_query_static_auto_load();
}
mixed query_dynamic_auto_load() {
  return ({ bit_data, race_ob, corpse_weight, race_name,
              decay, cured, bits_gone, ::query_dynamic_auto_load() });
}
void init_dynamic_arg(mixed arg, object) {
  if (mapp(arg)) {
    ::init_dynamic_arg(arg);
    return ;
  }
  bit_data = arg[0];
  race_ob = arg[1];
  corpse_weight = arg[2];
  race_name = arg[3];
  decay = arg[4];
  cured = arg[5];
  bits_gone = arg[6];
  ::init_dynamic_arg(arg[7]);
  if ((!cured) && (!no_decay())) {
    BIT_CONTROLLER->add_bit(this_object());
  }
  setup_long();
  if(sizeof(bit_data))
    set_bits();
}
void do_cure() {
  if ( cured ) {
    return;
  }
  cured = 1;
  BIT_CONTROLLER->remove_bit( this_object() );
  set_long( query_long() +"It seems to have been pickled.\n" );
  set_short( "cured " + query_short());
  set_main_plural( "cured " + query_main_plural() );
  add_adjective("cured");
}
int query_cured() { return cured; }
int *query_vect() { return bit_data[BIT_EXTRA][EXTRA_VALUE]; }
string *query_possible_bits( string word ) {
  int i, j;
  string *possibles;
  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if ( ( bits[ i ] == word ) ||
         ( bits[ i + 1 ] == word ) ||
         !word) {
      if (arrayp( bits[i+2][2] )) {
        for ( j = 0; j < bits[ i + 2][2][1]; j++ ) {
          possibles += ({ bits[ i ] });
        }
      } else {
        possibles += ({ bits[ i ] });
      }
    }
  }
  return possibles;
}
string *query_possible_plural_bits( string word ) {
  int i, j;
  string *possibles;
  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if (((bits[i] && pluralize(bits[ i ]) == word )) ||
        ((bits[i+1] && pluralize(bits[ i + 1 ]) == word )) ||
        !word) {
      if (arrayp( bits[i+2][2] )) {
        for ( j = 0; j < bits[ i + 2][2][1]; j++ ) {
          possibles += ({ bits[ i ] });
        }
      } else {
        possibles += ({ bits[ i ] });
      }
    }
  }
  return possibles;
}
string query_bit_left(string s) {
  string *poss_bits;
  poss_bits = query_possible_bits(s);
  if (!poss_bits || !sizeof(poss_bits)) {
     return 0;
  }
  poss_bits = poss_bits - bits_gone;
  if (!sizeof(poss_bits)) {
    return 0;
  }
  return poss_bits[0];
}
string *query_bit_left_pl(string s) {
  string *poss_bits;
  poss_bits = query_possible_plural_bits(s);
  if (!poss_bits || !sizeof(poss_bits)) {
    return 0;
  }
  poss_bits = poss_bits - bits_gone;
  if (!sizeof(poss_bits)) {
    return 0;
  }
  return poss_bits;
}
object *find_inv_match( string s, object looker ) {
  string bit, *bit_pl;
  object *weap, wep, tmp;
  int cut;
  bit = query_bit_left(s);
  bit_pl = query_bit_left_pl(s);
  if (!bit && !sizeof(bit_pl))
    return all_inventory();
  cut = 0;
  if(looker)
    weap = (object *)looker->query_weapons();
  if (sizeof(weap)) {
    foreach( wep in weap ) {
      if (wep->id("dagger") || wep->id("knife"))
        cut = 1;
    }
  }
  if (bit) {
    if (cut || (string)race_ob->query_pluckable(bit)) {
      tmp = make_bit(bit);
      return ({ tmp  });
    }
    if (sizeof(weap)) {
      tell_object( looker, "You can only cut things from "+a_short()+
                           " with a knife or dagger.\n" );
    } else {
      tell_object( looker, "You can't cut bits from "+a_short()+" with your "
                           "bare hands.\n" );
    }
    return ({ });
  }
  if (sizeof(bit_pl)) {
    if (cut) {
      if (sizeof(bit_pl) > 5) {
        return make_bits(bit_pl[0..4]);
      } else {
        return make_bits(bit_pl);
      }
    }
    foreach( bit in bit_pl ) {
      if (!((string)race_ob->query_pluckable(bit)))
        bit_pl -= ({ bit });
    }
    if (sizeof(bit_pl)) {
      if (sizeof(bit_pl) > 5) {
        return make_bits(bit_pl[0..4]);
      } else {
        return make_bits(bit_pl);
      }
    }
    if (sizeof(weap)) {
      tell_object( looker, "You can only cut things from "+a_short()+
                           " with a knife or dagger.\n" );
    } else {
      tell_object( looker, "You can't cut bits from "+a_short()+" with your "
                           "bare hands.\n" );
    }
    return ({ });
  }
}
object make_bit(string which_bit) {
  mixed *bit;
  object bitobj;
  int i,j;
  bit = race_ob->query_bit(which_bit);
  if ((sizeof(bit[2][2]) > 1) && stringp(bit[2][2][1])) {
    bitobj = clone_object( bit[2][2] );
  } else if (bit[2][2] == 0) {
    bitobj = clone_object("/std/bit");
  } else {
    bitobj = clone_object("/std/bit");
  }
  bitobj->set_race_ob(race_ob);
  if (race_name) bitobj->set_race_name(race_name);
  else bitobj->set_race_name(race_ob->query_name());
  bitobj->set_corpse_weight(query_weight());
  if(!race_ob->query_eat(bit[BIT_NAME])) {
    bitobj->set_bit(bit[0], 0);
  } else {
    bitobj->set_bit(bit[0], (decay * 2) / 3);
  }
  for (i = 0; i < sizeof(bits_gone); i++) {
    j = member_array(bits_gone[i], bit[BIT_EXTRA]);
    if (j >= 0) {
      bitobj->add_bit_gone(bits_gone[i]);
    }
  }
  bits_gone += ({ bit[BIT_NAME] }) + bit[BIT_EXTRA][3..50];
  if (environment()) {
    bitobj->move(environment());
  }
  return bitobj;
}
object *make_bits(string *what_bits) {
  string bit;
  object *bit_pl = ({ });
  foreach(bit in what_bits) {
    bit_pl += ({ make_bit(bit) });
  }
  return bit_pl;
}
string *query_bits_gone() { return bits_gone; }
mixed *add_bit_gone( string bit ) {
  string *poss_bits, tempbit;
  mixed *bit_details;
  int i;
  poss_bits = query_possible_bits( bit ) - bits_gone;
  if ( !sizeof( poss_bits ) ) return 0;
  bit_details = (mixed *)race_ob->query_bit( poss_bits[ 0 ] );
  bits_gone += ({ bit_details[ BIT_NAME ] });
  foreach (tempbit in bit_details[ BIT_EXTRA ][ 3 .. sizeof(bit_details[BIT_EXTRA]) ]) {
    if (arrayp(race_ob->query_bit( tempbit )[2][2]) && intp(race_ob->query_bit( tempbit )[2][2][1])) {
      for (i = 0; i < race_ob->query_bit( tempbit )[2][2][1]; i++) {
        bits_gone += ({ tempbit });
      }
    }
  }
  return bit_details;
}
void set_bits_gone( string *bits ) {
  int i;
  bits_gone = ({ });
  for ( i = 0; i < sizeof( bits ); i++ ) {
    add_bit_gone( bits[ i ] );
  }
}
string *query_bits_left() {
  int i, j;
  string *all_bits;
  mixed *bit_pl;
  bit_pl = (mixed *)race_ob->query_bits();
  all_bits = ({ });
  for ( i = 0; i < sizeof( bit_pl ); i += 3 ) {
    if (arrayp( bit_pl[i+2][2] )) {
      for ( j = 0; j < bit_pl[ i + 2][2][1]; j++ ) {
        all_bits += ({ bit_pl[ i ] });
      }
    } else {
      all_bits += ({ bit_pl[ i ] });
    }
  }
  return all_bits - bits_gone;
}
void set_bits() {
  int i, j;
  mixed *these_bits, *all_bits;
  bits = ({ });
  these_bits = bit_data;
  all_bits = race_ob->query_bits();
  for (i=3; i<sizeof(these_bits[2]); i++) {
    for (j=0; j<sizeof(all_bits); j = j+3) {
      if ((these_bits[0] == all_bits[j+2][0]) && (these_bits[2][i] == all_bits[j])) {
        bits += all_bits[j..j+2];
        delete(all_bits, j, 2);
        break;
      }
    }
  }
}
string query_determinate(object caller)  {
   return race_ob->query_determinate(caller);
}
string query_medium_alias() {
  string temp;
  string *temp2 = ({ });
    if ( !sizeof( bit_data ) )
        return "";
    temp = bit_data[0];
    temp2 = explode( temp, " " );
    temp2 = map( temp2, (: capitalize( $1 ) :) );
    temp = implode( temp2, "" );
    return temp + "Of" + capitalize( race_ob->query_name() ) ;
}
int query_collective() {
  if(query_verb() == "get" || query_verb() == "take")
    return 1;
}

==================================================
FILE: bit_set.c
==================================================

#include "corpse.h"
inherit "std/bit";
#include <bit.h>
void create() {
  ::create();
  set_short("anonymous set of bits");
  set_long("This is an unknown set of bits of some creature.\n");
  corpse_weight = STD_CORPSE_WEIGHT;
  set_weight(5);
  set_name("bit");
  add_property( "corpse bit", 1 );
  add_property("cureable", 1);
}
void setup_long() {
  if ( !bit_data )
    return;
  if (no_decay()) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + (bit_data[BIT_NAME]) +
               " from " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + (bit_data[BIT_NAME]) +
               " from an unknown creature.\n");
    }
  } else if (decay > 80) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a fresh set of " + (bit_data[BIT_NAME]) +
               " severed from the corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a fresh set of " + (bit_data[BIT_NAME]) +
               " severed from the corpse of an unknown creature.\n");
    }
  } else if (decay > 50) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + bit_data[BIT_NAME] + " severed from the " +
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + bit_data[BIT_NAME] + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  } else if (decay > 30) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is the partially decayed remains of a set of " +
               bit_data[BIT_NAME] +" severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is the partially decayed remains of a set of " +
               bit_data[BIT_NAME] + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  } else {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is the almost unrecognizable remains of a set of " +
         bit_data[BIT_NAME] +" severed from the "
         "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is the almost unrecognizable remains of a set of " +
         bit_data[BIT_NAME] + " severed from the " +
         "corpse of an unknown creature.\n");
    }
  }
  if ( cured )
    set_long( query_long() +"It seems to have been pickled.\n" );
}

==================================================
FILE: book.c
==================================================

inherit "/std/object";
#include <move_failures.h>
#include <player.h>
private mixed *_pages;
private string _default_page_object;
private object _def_p_obj;
private int _open_page;
private int _book_num;
private int _ignore_open_page;
private int _ignore_saved_pages;
private nosave object _player;
private nosave int _num_torn_out = -1;
protected int do_open(int page);
protected int do_tear(int number);
protected int do_turn(int number);
protected int do_close();
object create_default_page_object();
void create() {
  _pages = ({ });
  _default_page_object = "/obj/misc/paper";
  load_object(_default_page_object);
  _def_p_obj = find_object(_default_page_object);
  ::create();
  add_help_file("book");
}
int query_book() { return 1; }
int query_weight() {
   if (!_def_p_obj) {
      load_object(_default_page_object);
      _def_p_obj = find_object(_default_page_object);
   }
   return ::query_weight() +
          sizeof(filter(_pages, (: objectp($1) :))) * _def_p_obj->query_weight();
}
void init() {
  add_command("open", "<direct:object>", (: do_open(1) :));
  add_command("open", "<direct:object> to [page] <number>",
              (: do_open($4[1]) :));
  add_command("tear", "page from <direct:object>", (: do_tear(1) :));
  add_command("tear", "[all] pages from <direct:object>", (: do_tear(0) :));
  add_command("tear", "<number> [of] pages from <direct:object>",
              (: do_tear($4[0]) :));
  add_command("rip", "page from <direct:object>", (: do_tear(1) :));
  add_command("rip", "<number> [of] pages from <direct:object>",
              (: do_tear($4[0]) :));
  add_command("rip", "[all] pages from <direct:object>", (: do_tear(0) :));
  add_command("turn", "[a|1] page of <direct:object>", (: do_turn(1) :));
  add_command("turn", "<number> pages of <direct:object>",
              (: do_turn($4[0]) :));
  add_command("turn", "<direct:object> to [page] <number>",
              (: do_open($4[1]) :) );
  add_command("turn", "to page <number> of <direct:object>",
              (: do_open($4[0]) :) );
  add_command("close", "<direct:object>", (: do_close() :));
}
int add_weight( int number ) {
   adjust_weight( number );
   return 1;
}
int test_add(object ob, int flag) {
  return (object)ob->query_property("my book") == this_object();
}
int test_remove( object ob, int flag, mixed dest ) {
  return ob->query_property("my book") != this_object();
}
void set_no_pages(int no) {
  int i;
  int siz;
  siz = sizeof(_pages);
  if (no < siz) {
    _pages = _pages[0..no-1];
    if (_open_page >= no) {
      _open_page = no;
    }
  } else {
    _pages = _pages + allocate(no-siz);
    for (i=siz;i<no;i++) {
      _pages[i] = ({ });
    }
  }
}
mixed *query_pages() { return _pages; }
void set_open_page(int i) {
  if (i < 0 || i == _open_page) {
     return ;
  }
  if (!_open_page && i) {
    add_alias("page");
    add_plural("pages");
  }
  if (i > sizeof(_pages)) {
    _open_page = sizeof(_pages);
  } else {
    _open_page = i;
  }
  if (!_open_page) {
    remove_alias("page");
    remove_plural("pages");
  }
}
int query_open_page() {
   return _open_page;
}
int is_current_page_torn_out() {
   if (!_open_page) {
      return 0;
   }
   if ( !_pages ) {
      return 0;
   }
   if (!_pages[_open_page-1]) {
      return 1;
   }
   return 0;
}
int is_page_torn_out(int page) {
   if (page < 1 || page > sizeof(_pages)) {
      return 0;
   }
   if (!_pages[page - 1]) {
      return 1;
   }
   return 0;
}
object query_current_page() {
   int i;
   if (!_open_page) {
      return this_object();
   }
   for (i = _open_page - 1; i < sizeof(_pages); i++) {
     if (_pages[i]) {
       if (!_def_p_obj) {
         load_object(_default_page_object);
         _def_p_obj = find_object(_default_page_object);
       }
       return _def_p_obj;
     }
   }
   return 0;
}
object query_current_page_clone() {
  return this_object();
}
int is_default_page(int num) {
   if (num > 0 && num <= sizeof(_pages)) {
      if (_pages[num - 1] &&
          !objectp(_pages[num - 1])) {
         return 1;
      }
   }
   return 0;
}
object query_selected_page(int num) {
   if (!intp(num) || num <= 0 || num > sizeof(_pages)) {
      return 0;
   }
   if (_pages[num - 1]) {
      if (objectp(_pages[num - 1])) {
         return _pages[num - 1];
      } else {
         if (!_def_p_obj) {
            load_object(_default_page_object);
            _def_p_obj = find_object(_default_page_object);
         }
         return _def_p_obj;
      }
   }
   return 0;
}
object query_selected_page_clone(int num) {
  return this_object();
}
object tear_current_page_out(object dest) {
  object page;
  if (is_current_page_torn_out()) {
    return 0;
  }
  if (_pages[_open_page-1]) {
    page = clone_object(_default_page_object);
    page->add_alias("page");
    page->add_plural("pages");
    if(_pages[_open_page-1] != 1)
      page->set_read_mess(_pages[_open_page-1]);
   }
  if (page && page->move(dest) == MOVE_OK) {
    _pages[_open_page-1] = 0;
    return page;
  }
  return 0;
}
int add_page_after(object page, int after) {
   if (after < 0 || after > sizeof(_pages) + 1 ||
       !objectp(page) || !intp(after)) {
      return 0;
   }
   _pages = _pages[0..after - 1] + page->query_read_mess() + _pages[after..];
   page->move("/room/rubbish");
   return 1;
}
int replace_page_with(object page, int num) {
   if (num < 1 || num > sizeof(_pages) ||
       !objectp(page) || !intp(num)) {
      return 0;
   }
   _pages[num-1] = page->query_read_mess();
   page->move("/room/rubbish");
}
int make_page_blank(int num) {
   if (num < 1 || num > sizeof(_pages) || !intp(num)) {
      return 0;
   }
   _pages[num-1] = 1;
}
string short(int flags) {
  if (!flags || _ignore_open_page) {
    return ::short(flags);
  }
  if (_open_page) {
    return "open " + ::short(flags);
  }
  return "closed " + ::short(flags);
}
string *parse_command_adjectiv_id_list() {
   if (_open_page) {
      return ::parse_command_adjectiv_id_list() + ({ "open" });
   }
   return ::parse_command_adjectiv_id_list() + ({ "closed" });
}
string long(string str, int dark) {
  string ret;
  int i;
  if (!_open_page) {
    return ::long(str, dark)+"It is closed.\n";
  }
  ret = ::long(str, dark)+"It is open at page " + _open_page + ".\n";
  for (i=_open_page-1;i<sizeof(_pages) && !_pages[i];i++) {
    if (!_pages[i]) {
      ret += "Page "+(i+1)+" has been torn out.\n";
    }
  }
  if (i >= sizeof(_pages)) {
    ret += "All the rest of the pages have been torn out!\n";
  } else {
    if (i != _open_page -1) {
      ret += "You can see page "+(i+1)+" however.\n";
    }
    if(str && strsrch(str, "page") != -1) {
      ret += _default_page_object->long(str, dark);
    }
  }
  return ret;
}
protected int do_open(int page) {
  if (page <= 0)  {
     write("Oddly enough, the first page is page 1.\n");
     page = 1;
  }
  else if (page > sizeof(_pages))  {
     write("There " + (sizeof(_pages) == 1 ? "is only " : "are only ") +
           query_num(sizeof(_pages)) +
           (sizeof(_pages) == 1 ? " page in " : " pages in ") +
           the_short() + ".\n");
     page = sizeof(_pages);
  }
  if (query_open_page() == page) {
    add_failed_mess("The $D is already open at page " + page + ".\n");
  }
  if (_open_page > 0  &&  is_page_torn_out (page)) {
     add_failed_mess("The page " +  page + " in $D is torn out.\n");
     return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  set_open_page(page);
  add_succeeded_mess("$N $V $D to page " + page + ".\n", ({ }));
  return 1;
}
protected int do_turn(int number) {
  int tmp;
  tmp = query_open_page();
  if (tmp+number > sizeof(_pages)) {
    set_open_page(0);
    add_succeeded_mess("$N close$s $D.\n");
  } else {
    if (tmp == 0) {
       add_succeeded_mess("$N turn$s $D to page " + number + ".\n");
    }
    else add_succeeded_mess("$N turn$s " + number +
           (number > 1 ? " pages " : " page ") + "of $D.\n");
    set_open_page(tmp + number);
  }
  if (tmp == query_open_page()) {
     add_failed_mess("Unable to turn page of $D.\n", ({ }));
     return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  return 1;
}
protected int do_close() {
  if (!query_open_page()) {
    this_player()->add_failed_mess(this_object(), "$D is already closed.\n",
                                   ({}));
    return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  set_open_page(0);
  return 1;
}
int do_tear(int number) {
  int i;
  if (_ignore_saved_pages) {
    add_failed_mess("For some reason you cannot seem to tear any pages "
                    "from $D.\n");
    return 0;
  }
  if (!_open_page) {
    this_player()->add_failed_mess(this_object(), "$D is closed!\n",
                                   ({}));
    return 0;
  }
  if(number == 0) {
    _open_page = 1;
    number = sizeof(_pages);
  }
  for(i=0; i<number; i++) {
    if(!tear_current_page_out(this_player()))
      break;
    if ( _open_page != sizeof( _pages ) ) {
        _open_page++;
    }
  }
  if(i) {
    if(i > 1)
      add_succeeded_mess("$N $V " + i + " pages from $D.\n");
    else
      add_succeeded_mess("$N $V a page from $D.\n");
    return 1;
  }
  return 0;
}
varargs void set_read_mess(string str, string lang, int size) {
  if (_open_page) {
    if(pointerp(str)) {
      _pages[_open_page-1] = str;
      return;
    }
    if(str)
      _pages[_open_page-1] = ({ ({ str, 0, lang, size }) });
    else
      _pages[_open_page-1] = 1;
    return;
  }
  return ::set_read_mess(str, lang, size);
}
void add_read_mess(mixed str, string type, string lang, int size) {
  if(_open_page) {
    if(!arrayp(_pages[_open_page-1]))
      _pages[_open_page-1] = ({ });
    _pages[_open_page-1] += ({ ({ str, type, lang, size }) });
    return;
  }
  ::add_read_mess(str, type, lang, size);
}
mixed query_read_mess() {
  if (_open_page) {
    if(!_pages[_open_page-1])
      return ({ });
    return _pages[_open_page-1];
  }
  return ::query_read_mess();
}
mixed *stats() {
  return ({
    ({ "num pages" , sizeof(_pages) }),
    ({ "ignore saved pages" , _ignore_saved_pages }),
    ({ "default page ob" , _default_page_object }),
    ({ "open page", _open_page }),
    ({ "book number" , _book_num }),
  }) + ::stats();
}
void dest_me() {
  int i;
  for (i=0;i<sizeof(_pages);i++) {
    if (objectp(_pages[i])) {
      _pages[i]->dest_me();
    }
  }
  ::dest_me();
}
mixed query_static_auto_load() {
  if (file_name(this_object())[0..8] == "/std/book") {
    return int_query_static_auto_load();
  }
}
mapping query_dynamic_auto_load() {
  mapping bing;
  bing = ([
      "::" : ::query_dynamic_auto_load(),
      "default page object" : _default_page_object,
      "open page" : _open_page,
      "book num" : _book_num,
    ]);
  if (!_ignore_saved_pages) {
    bing["pages"] = _pages;
  }
  return bing;
}
void init_dynamic_arg(mapping map, object player) {
  int i;
  object *tmp;
  if (!player) {
    player = _player;
    if (!player) {
       player = this_player();
    }
  }
  if (map["::"]) {
    ::init_dynamic_arg(map["::"]);
  }
  if (map["default page object"]) {
    _default_page_object = map["default page object"];
    load_object(_default_page_object);
    _def_p_obj = find_object(_default_page_object);
  }
  if (map["pages"] && !_ignore_saved_pages) {
    if(sizeof(map["pages"]) && sizeof(map["pages"][0]) == 3) {
      for(i=0; i<sizeof(_pages); i++) {
        tmp = (object *)player->load_auto_load_to_array(map["pages"][i],
                                                        this_object(), player);
        if(sizeof(tmp->query_read_mess()))
          _pages[i] = tmp->query_read_mess()[0];
        tmp->move("/room/rubbish");
      }
    } else
      _pages = map["pages"];
  }
  _book_num = map["book num"];
  set_open_page(map["open page"]);
}
void set_default_page_object(string obj) {
  load_object(obj);
  if (find_object(obj)) {
    _default_page_object = obj;
    _def_p_obj = find_object(obj);
  }
}
string query_default_page_object() {
   return _default_page_object;
}
object create_default_page_object() {
   return clone_object(_default_page_object);
}
int query_num_pages() {
  return sizeof(_pages);
}
int query_book_num() {
   return _book_num;
}
void set_book_num(int num) {
   _book_num = num;
}
int query_ignore_saved_pages() {
   return _ignore_saved_pages;
}
protected void set_ignore_saved_pages(int saved) {
   _ignore_saved_pages = saved;
}
void set_player(object player) {
   _player = player;
}
object query_player() {
   return _player;
}
string query_read_short(object player, int ignore_labels) {
  if(!::query_read_short(player, 0))
    return 0;
  if (!_open_page) {
    return "the cover of " + ::query_read_short(player, 0);
  }
  return "page " + query_num(_open_page) + " of " +
    ::query_read_short(player, 1);
}
string query_readable_message(object player, int ignore_labels) {
   return ::query_readable_message(player, _open_page != 0);
}

==================================================
FILE: book_dir.c
==================================================

inherit "/std/book";
#include "nroff.h"
string language = 0;
void set_book_language(string lang) {
   language = lang;
}
string query_language() { return language; }
void set_book_dir(string dir) {
  int i, max;
  set_no_pages(10);
  set_ignore_saved_pages(1);
  max = 10;
  i = 1;
  set_default_page_object("/obj/misc/nroff_paper");
  set_open_page (0);
  while (file_size(dir+i) > 0) {
    set_open_page(i);
    set_read_mess("$$" + dir + i + "$$" , language, 0);
    i++;
    if (i >= max) {
      max += 10;
      set_no_pages(max);
    }
  }
  set_no_pages(i-1);
  set_open_page(0);
}

==================================================
FILE: container.c
==================================================

#include <move_failures.h>
#include <player.h>
#include <player_handler.h>
inherit "/std/object";
inherit "/std/basic/cute_look";
inherit "/std/basic/export_inventory";
inherit "/global/auto_load";
private nosave int _max_weight;
private nosave int _loc_weight;
private nosave int _max_items;
private nosave int _prevent_insert;
private nosave string _ownership;
private nosave object _player;
private nosave int _n_tracked_items;
private nosave int _tracking;
void create() {
  registered_containers = ({ });
  _n_tracked_items = 0;
  _tracking = 1;
  export_inventory::create();
  object::create();
}
int query_max_items() {
  if(_max_items)
    return _max_items;
  if(_max_weight)
    return 4 * sqrt(_max_weight);
  return -1;
}
void set_max_items( int number ) { _max_items = number; }
int query_max_weight() { return _max_weight; }
void set_max_weight( int number ) { _max_weight = number; }
int query_loc_weight() { return _loc_weight; }
void update_loc_weight() {
   object thing;
   _loc_weight = 0;
   foreach ( thing in all_inventory( this_object() ) )
      _loc_weight += (int)thing->query_complete_weight();
}
int query_complete_weight() {
   return ::query_complete_weight() + _loc_weight;
}
int add_weight( int n ) {
#ifdef 0
  if ( _prevent_insert )
    return 0;
#endif
  if ( !_max_weight ) {
    _loc_weight += n;
    return 1;
  }
  if ( n + _loc_weight > _max_weight )
    return 0;
  if ( !environment() ) {
    _loc_weight += n;
    return 1;
  }
  if ( !environment()->add_weight( n ) )
    return 0;
  _loc_weight += n;
  return 1;
}
string query_ownership() { return _ownership; }
void set_ownership( string word ) {
  if( word )
    _ownership = lower_case( word );
  else
    _ownership = word;
}
int test_remove( object thing, int flag, mixed dest ) {
  int player;
  string str;
  if( !_ownership || !this_player() ) {
    return 1;
  }
  if( objectp( dest ) ) {
    dest = file_name( dest );
  }
  if( dest == "/room/rubbish" || dest == "/room/vault" ) {
    return 1;
  }
  str = "Item " + file_name( this_object() ) + " accessed by " +
    this_player()->query_short() + " which belongs to $C$" + _ownership;
  if( (string)this_player()->query_name() == _ownership ) {
    str += ".  Taking items, no theft event.";
    log_file( "/w/trilogy/CONTAINER", str + "\n" );
    return 1;
  }
  player = PLAYER_HANDLER->test_user( _ownership );
  if( player ) {
    str += ", who is a player.  ";
    if( !pk_check( this_player(), _ownership, 1 ) &&
      environment( this_player() ) ) {
      str += "PK check succeded: Taking items, theft event triggered.";
      this_player()->zap_harry_shadow();
      event( environment( this_player() ), "theft", this_player(),
        this_object(), ({ thing }) );
      log_file( "/w/trilogy/CONTAINER", str + "\n" );
      return 1;
    } else {
      str += "PK check failed: Cannot take items.";
      write( "An unseen force stays your hand.\n" );
      log_file( "/w/trilogy/CONTAINER", str + "\n" );
      return 0;
    }
  } else {
    str += ", which is not a player.  Taking items, theft event triggered.";
    this_player()->zap_harry_shadow();
    event( environment( this_player() ), "theft", this_player(),
      this_object(), ({ thing }) );
    log_file( "/w/trilogy/CONTAINER", str + "\n" );
    return 1;
  }
}
int test_add(object ob, int flag) {
  if(!_max_weight && !_max_items)
    return 1;
  if(ob->query_max_weight() > _max_weight - _loc_weight) {
    return 0;
  }
  if(this_object()->query_length() > 1 &&
     this_object()->query_length() < ob->query_length()) {
    return 0;
  }
  if(this_object()->query_width() > 1 &&
     this_object()->query_width() < ob->query_width()) {
    return 0;
  }
  if(ob->query_max_weight())
    return ((sizeof(deep_inventory(this_object())) +
             sizeof(deep_inventory(ob))) < query_max_items());
  else
    return sizeof(deep_inventory(this_object())) < query_max_items();
}
int set_prevent_insert() { _prevent_insert = 1; }
int reset_prevent_insert() { _prevent_insert = 0; }
int query_prevent_insert() { return _prevent_insert; }
varargs int move(mixed dest, mixed messin, mixed messout) {
  if (_prevent_insert && _loc_weight && !living(dest) && environment(dest))
    return MOVE_INVALID_DEST;
  return object::move( dest, messin, messout );
}
object *find_inv_match( string words, object looker ) {
   object *things;
   things = all_inventory( this_object() );
   things = filter(things, (: $1->short(0) &&
                              (!$2 || $1->query_visible($2)) :), looker);
   return things;
}
int do_restore_inventory_error(object ob, int move_flag) {
   object receipt;
   int ret;
   receipt = clone_object(PLAYER_RECEIPT);
   receipt->setup_receipt(ob);
   receipt->set_weight(0);
   ret = receipt->move(this_object());
   if (ret != MOVE_OK) {
      receipt->dest_me();
   } else {
      move_flag = MOVE_OK;
      ob->move("/room/rubbish");
   }
   return move_flag;
}
protected int handle_restore_inventory(object ob) {
  int move_flag;
  ob->disable_item_tracking();
  move_flag = ob->move(this_object());
  ob->enable_item_tracking();
  if (move_flag != MOVE_OK) {
     move_flag = do_restore_inventory_error(ob, move_flag);
  }
  return move_flag;
}
mixed stats() {
  return ::stats() + ({
    ({ "loc_weight", query_loc_weight(), }),
    ({ "max_weight", query_max_weight(), }),
    ({ "max_items", query_max_items(), }),
    ({ "export invent", query_can_export_inventory() }),
  });
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([
     "::" : tmp,
     "max weight" : _max_weight,
     "prevent insert" : _prevent_insert,
     "can export inventory" : query_can_export_inventory(),
  ]);
}
mapping query_dynamic_auto_load() {
  mixed inventory;
  catch(inventory = create_auto_load( all_inventory( this_object() ), 0 ) );
  return ([
    "::" : object::query_dynamic_auto_load(),
    "inv" : inventory
  ]);
}
void set_player( object thing ) {
   ::set_player(thing);
    _player = thing;
}
object query_player() { return _player; }
nomask void enable_item_tracking() { _tracking = 1; }
nomask void disable_item_tracking() { _tracking = 0; }
nomask void event_container_move( object mover, mixed from, mixed to ) {
  if (_n_tracked_items)
    all_inventory()->event_container_move( mover, from, to );
}
void event_move_object( mixed from, mixed to ) {
  if (_n_tracked_items && _tracking && !interactive()) {
    all_inventory()->event_container_move( this_object(), from, to );
    if (objectp(from)) from->remove_tracked_items( _n_tracked_items );
    if (objectp( to )) to->add_tracked_items( _n_tracked_items );
  }
}
nomask void set_tracked_item_status_reason(string reason) {
  if (_n_tracked_items)
    all_inventory()->set_tracked_item_status( reason );
}
nomask void add_tracked_items( int n_items ) {
   _n_tracked_items += n_items;
   if (environment()) environment()->add_tracked_items( n_items );
}
nomask void remove_tracked_items( int n_items ) {
  _n_tracked_items -= n_items;
  if (environment()) environment()->remove_tracked_items( n_items );
}
nomask int query_tracked_items() {
  return _n_tracked_items;
}
int can_find_match_recurse_into(object looker) {
   object env;
   env = environment();
   while (env &&
          !living(env) &&
          env != looker &&
          env != environment(looker)) {
      env = environment(looker);
   }
   return env == looker || env == environment(looker);
}
int can_find_match_reference_inside_object(object thing, object looker) {
   return 1;
}
void init_dynamic_arg( mapping bing, object ) {
  function f;
  if ( bing[ "::" ] ) {
    ::init_dynamic_arg( bing[ "::" ] );
  }
  if ( bing[ "inv" ] ) {
    f = (: handle_restore_inventory($1) :);
    if (!_player) {
      _player = this_player();
    }
    if (_player) {
      load_auto_load_to_inventory( bing["inv"], this_object(), _player, f );
    } else {
      load_auto_load_to_inventory( bing["inv"], this_object(), this_player(), f);
    }
  }
}
void init_static_arg( mapping bing ) {
  if ( bing[ "::" ] ) {
    ::init_static_arg( bing[ "::" ] );
  }
  if ( !undefinedp( bing[ "max weight" ] ) ) {
    _max_weight = bing[ "max weight" ];
  }
  if ( !undefinedp( bing[ "prevent insert" ] ) ) {
    _prevent_insert = bing[ "prevent insert" ];
  }
  if (bing["can export inventory"]) {
    set_can_export_inventory();
  } else {
    reset_can_export_inventory();
  }
}
mixed query_static_auto_load() {
  if (file_name(this_object())[0..13] == "/std/container") {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
void dest_me() {
   foreach( object ob in all_inventory( this_object() ) ) {
       reset_eval_cost();
       ob->dest_me();
   }
   ::dest_me();
}

==================================================
FILE: delivery.c
==================================================

#include <player_handler.h>
#include <login.h>
#include <move_failures.h>
inherit "/global/auto_load";
class delivery_item {
    object delivery_ob;
    string sent_by;
    int submit_time;
    int delay_time;
}
protected void set_delivery_delay(int new_time);
protected int valid_delivery(class delivery_item delivery, string person);
protected void deliver_item(string who, object ob, string sent_by);
protected void set_burdened_mess(string s);
protected void set_delivery(mapping x);
protected void set_delivery_mess(string s);
protected void set_save_file(string str);
public int query_delivery_delay();
public string query_burdened_mess();
public string query_delivery_mess();
public string query_save_file();
public varargs mixed query_delivery(string person);
public void add_delivery(mixed who, mixed sender, object item, int delay);
public void check_delivery(mixed person, string type);
public void clear_delivery();
public void setup_delivery();
public void load_file();
public void save_file();
private mapping _delivery;
private mixed _item_save;
private nosave string _save_file;
private nosave object _cont;
private nosave string _delivery_mess;
private nosave string _burdened_mess;
private nosave int _delivery_delay;
void create() {
    _delivery = ([ ]);
    _save_file = "";
    _delivery_delay = 5;
    _delivery_mess = "\nA small womble wearing a bright green hat "
        "strides up to you confidently and hands you $N.  She "
        "mutters something about \"delivery\" and \"$S\", before "
        "scurrying away.\n";
    _burdened_mess = "\nA small womble wearing a bright purple "
        "hat strides up to you, and places \"$N\" on the ground.  She "
        "mutters something about a gift from \"$S\", and the runs off.\n";
    _cont = clone_object("/std/container");
    call_out("tidy_up", 30 + random(30));
}
public void setup_delivery() {
    LOGIN_HANDLER->add_static_login_call("all", "check_delivery",
        base_name(this_object()));
}
public string query_save_file() {
    return _save_file;
}
protected void set_save_file(string str) {
    _save_file = str;
}
public void clear_delivery() {
    _delivery = ([ ]);
    save_file();
}
protected void set_delivery(mapping x) {
    _delivery = x;
    save_file();
}
void add_delivery(mixed who, mixed sender, object item, int delay) {
    string name, from;
    class delivery_item parcel;
    if (objectp(who))
        name = who->query_name();
    else
        name = who;
    if (objectp(sender))
        from = sender->query_cap_name();
    else
        from = sender;
    parcel = new(class delivery_item,
        delivery_ob : item, submit_time : time(), sent_by : from,
        delay_time : delay);
    if (undefinedp(_delivery[name]))
        _delivery[name] = ({ parcel });
    else
        _delivery[name] += ({ parcel });
    log_file("DELIVERY", "%s added a new delivery item for %s, %s sent "
        "by %s.\n", previous_object()->short(), name, item->short(),
        from);
    item->move(_cont);
    save_file();
}
protected int valid_delivery(class delivery_item delivery, string person) {
  if (delivery->submit_time + delivery->delay_time > time())
    return 1;
  if (!objectp(delivery->delivery_ob))
    return 0;
  call_out( (: deliver_item :), _delivery_delay, person, delivery->delivery_ob,
            delivery->sent_by);
  return 0;
}
public void check_delivery(mixed person, string type) {
    if (type != LOGIN && type != RECONNECT)
        return;
    if (!_delivery[person])
        return;
    _delivery[person] = filter(_delivery[person],
        (: valid_delivery($1, $(person)) :));
    if (!sizeof(_delivery[person]))
        map_delete(_delivery, person);
    save_file();
}
protected void deliver_item(string who, object ob, string sent_by) {
    string new_mess;
    object player;
    player = find_player(who);
    if (!player)
        ob->move("/room/rubbish");
    if (ob->move(player) != MOVE_OK) {
        if (environment(player)) {
            new_mess = replace(_burdened_mess, ({ "$S", sent_by, "$N",
                "$0$" }));
            player->add_message(new_mess,  ({ ({ "my_a_short:" +
            file_name(ob) }) }));
            ob->move(environment(player), );
        }
        else {
            ob->move("/room/rubbish", "$N appear$s in a puff of smoke.");
            log_file("DELIVERY", "%s: %s sent to the rubbish room, %s has "
                "no environment.\n", ctime(time()), ob->short(),
                player->short());
        }
    }
    else {
        new_mess = replace(_delivery_mess, ({ "$S", sent_by, "$N", "$0$" }));
        player->add_message(new_mess,  ({ ({ "my_a_short:" +
            file_name(ob) }) }));
        log_file("DELIVERY", "%s: %s delivered to %s.\n", ctime(time()),
            ob->short(), who);
    }
}
int query_theft_command() {
    return -1;
}
void clean_delivery_mapping() {
    string *people, person;
    people = keys(_delivery);
    foreach (person in people) {
        _delivery[person] = filter(_delivery[person],
            (: objectp($1->delivery_ob) :));
    }
    _delivery = filter(_delivery, (: sizeof($2) :));
}
public void save_file() {
  mixed *tmp;
  string player;
  class delivery_item *values;
  if(_save_file == "")
    return;
  _item_save = ({ });
  clean_delivery_mapping();
  foreach (player, values in _delivery) {
    tmp = map(values, (: $1->delivery_ob :));
    if (!arrayp(tmp))
      continue;
    _item_save += ({ player, create_auto_load(tmp, 0) });
  }
  tell_creator("ceres", "Saving: %s\n", _save_file);
  unguarded((: save_object, _save_file :));
  _item_save = 0;
}
void load_file() {
  int i, j, size;
  mixed *tmp;
  string who;
  mixed *items;
  if(_save_file == "")
    return;
  log_file("DELIVERY", "Attempting to load save file at %s.\n",
           ctime(time()));
  tell_creator("ceres", "Loading: %s\n", _save_file);
  if (file_size(_save_file + ".o") > -1) {
    unguarded((: restore_object, _save_file :));
    if (!_cont)
      _cont = clone_object("/std/container");
    all_inventory(_cont)->move("/room/rubbish");
    for (i = 0; i < sizeof(_item_save); i = i + 2) {
      who = _item_save[i];
      items = _item_save[i + 1];
      if (!_delivery[who])
        return;
      tmp = load_auto_load_to_array(items, this_player());
      size = sizeof(tmp);
      for (j = 0; j < size; j++) {
        _delivery[who][j]->delivery_ob = tmp[size - j - 1];
        tmp[j]->move(_cont);
      }
    }
    _item_save = 0;
  }
}
public string query_delivery_mess() {
    return _delivery_mess;
}
public int query_delivery_delay() {
    return _delivery_delay;
}
protected void set_delivery_delay(int new_time) {
    _delivery_delay = new_time;
}
protected void set_delivery_mess(string s) {
    _delivery_mess = s;
}
protected void set_burdened_mess(string s) {
    _burdened_mess = s;
}
public string query_burdened_mess() {
    return _burdened_mess;
}
public varargs mixed query_delivery(string person) {
    if (undefinedp(_delivery[person])) {
        return copy(_delivery);
    }
    else {
        return copy(_delivery[person]);
    }
}
void dest_me() {
    if (_cont)
        _cont->dest_me();
}
object query_cont() {
  return _cont;
}
void tidy_up() {
  string person;
  foreach(person in keys(_delivery)) {
    if(!PLAYER_HANDLER->test_user(person) || !PLAYER_HANDLER->test_active(person)) {
      log_file("DELIVERY", "%s Removing delivery for %s (inactive).\n",
               this_object()->query_short(), person);
      map_delete(_delivery, person);
    }
  }
  save_file();
}
mixed *stats() {
    return ({
        ({ "delivery mess", replace(_delivery_mess, ({ "\n",  "" }) ) }),
        ({ "burdened mess", replace(_burdened_mess, ({ "\n",  "" }) ) }),
        ({ "delivery delay", _delivery_delay, }),
        ({ "delivery save file", _save_file, }),
        ({ "undelivered items", _cont ? sizeof(all_inventory(_cont)) : 0 }),
    });
}

==================================================
FILE: effect_shadow.c
==================================================

object player;
int id;
object attach_to_player(object p, int i) {
  player = p;
  id = i;
  return shadow( player, 1 );
}
void remove_effect_shadow(int i) {
  if (i == id) { if( this_object() ) destruct( this_object() ); return; }
  player->remove_effect_shadow(i);
}
protected mixed arg() {
   int enum;
   enum = (int)player->sid_to_enum( id );
   if ( enum == -1 ) {
#ifdef DEBUG
     log_file( "EFFECTS", time() +": no effect for "+
               file_name( this_object() ) +"\n           on "+
               file_name( player ) +"\n" );
#endif
      destruct( this_object() );
      return 0;
   }
   return (mixed)player->arg_of( enum );
}
protected void set_arg(mixed newarg) {
   player->set_arg_of(player->sid_to_enum(id), newarg);
}
protected void remove_this_effect() {
  player->delete_effect( (int)player->sid_to_enum( id ) );
}

==================================================
FILE: held.c
==================================================

inherit "/std/object";
nosave object holder;
int query_holdable() { return 1; }
int set_holder(object ob) {
  holder = ob;
  return 1;
}
object query_holder() { return holder; }
int drop(mixed dest) {
  holder = 0;
  return ::drop(dest);
}
varargs int move( mixed dest, string arrive, string leave ) {
  if (holder && dest != holder) {
      holder->unhold_ob(this_object());
      holder = 0;
  }
  return ::move(dest, arrive, leave);
}
