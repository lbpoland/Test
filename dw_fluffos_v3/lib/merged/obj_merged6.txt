# Total Tokens: 99492
# Total Files Merged: 82
# Total Characters: 330708

ain_things/dungeon_maker.c
==================================================

#include <dirs.h>
#include <terrain.h>
#define END 0
#define TWO 1
#define FOUR 2
#define ROOM 3
#define HALF 0
#define FULL 1
#define DIRS ({ "north", "northeast", "east", "southeast", \
      "south", "southwest", "west", "northwest" })
inherit "/std/object";
int max, size, *clear, *c_probs, *p_probs, *r_probs, *start;
string terrain_name, *passage_files, *room_files;
object easel;
mixed *passages, *room_entries;
void setup() {
   set_name( "box" );
   set_short( "green box" );
   add_adjective( "green" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
   reset_get();
   start = allocate( 3 );
   passages = ({ });
   room_entries = ({ });
}
void dest_me() {
   if ( easel )
      easel->dest_me();
   ::dest_me();
}
int query_max_locations() { return max; }
void set_max_locations( mixed arg ) { max = to_int( arg ); }
int *query_junction_clearance() { return clear; }
void set_junction_clearance( mixed *args ) {
   int i;
   clear = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      clear[ i ] = to_int( args[ i ] );
}
int *query_continue_probabilities() { return c_probs; }
void set_continue_probabilities( mixed *args ) {
   int i;
   c_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      c_probs[ i ] = to_int( args[ i ] );
}
int *query_passage_probabilities() { return p_probs; }
void set_passage_probabilities( mixed *args ) {
   int i;
   p_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      p_probs[ i ] = to_int( args[ i ] );
}
int *query_room_probabilities() { return r_probs; }
void set_room_probabilities( mixed *args ) {
   int i;
   r_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      r_probs[ i ] = to_int( args[ i ] );
}
int *query_start_co_ord() { return start; }
void set_start_co_ord( mixed *args ) {
   int i;
   if ( sizeof( args ) != 3 )
      return;
   for ( i = 0; i < sizeof( args ); i++ )
      start[ i ] = to_int( args[ i ] );
}
string query_terrain_name() { return terrain_name; }
void set_terrain_name( string word ) { terrain_name = word; }
string *query_passage_files() { return passage_files; }
void set_passage_files( string *words ) { passage_files = words; }
string *query_room_files() { return room_files; }
void set_room_files( string *words ) { room_files = words; }
object query_easel() { return easel; }
mixed *query_passages() { return passages; }
mixed *query_room_entries() { return room_entries; }
int do_generate(string);
void init() {
   add_command( "generate", "<word'terrainname'>", (:do_generate($4[0]):));
}
void mark_passage( int *co_ord ) {
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] ) / size,
         ( start[ 0 ] - co_ord[ 0 ] ) / size }), ({ "#" }) );
}
void mark_room( int *co_ord, string room ) {
   int width;
   width = (int)room->query_room_size();
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] - width - size / 2 ) / size,
         ( start[ 0 ] - co_ord[ 0 ] - width - size / 2 ) / size }),
         (string *)easel->make_block( ( 2 * width ) / size + 2 ) );
}
int do_generate( string word ) {
   int i;
   string data, direc, *lines;
   mixed *parameters;
   if ( easel )
      return notify_fail( "The generator is working on "+
            terrain_name +".\n" );
   if ( file_size( word ) < 0 )
      return notify_fail( "File "+ word +" does not exist.\n" );
   lines = explode( read_file( word ), "\n" );
   for ( i = 0; i < sizeof( lines ); i++ ) {
      if ( lines[ i ] == "" )
         continue;
       if ( lines[ i ][ 0 .. 0 ] == "#" )
         continue;
      parameters = explode( lines[ i ], " " );
      if ( !stringp( parameters[ 0 ] ) ) {
         printf( "%s line %d: %O is not a string.\n", word, i,
               parameters[ 0 ] );
         continue;
      }
      if ( sizeof( parameters ) == 2 )
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 ] );
      else
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 .. sizeof( parameters ) - 1 ] );
      printf( "Set %s to %O.\n", parameters[ 0 ], call_other( this_object(),
            "query_"+ parameters[ 0 ] ) );
   }
   if ( file_size( RESTORE_PATH + terrain_name +".o" ) > 0 )
      return notify_fail( "Terrain "+ terrain_name +" already exists.\n" );
   easel = clone_object( "/obj/misc/easel" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\nIt seems "+
         "to be humming quietly but in a very powerful way.\n" );
   write( "Working on "+ terrain_name +".\n" );
   direc = DIRS[ random( 8 ) ];
   for ( i = 0; i < 4; i++ )
      passages += ({ ({ DIRS[ ( member_array( direc, DIRS ) + 2 * i ) % 8 ],
            passage_files[ random( sizeof( passage_files ) ) ],
            start, 0, 0, 1 + clear[ 0 ] + random( clear[ 1 ] ) }) });
   size = 2 * (int)passage_files[ 0 ]->query_room_size();
   TERRAIN_MAP->add_floating_location( terrain_name, passage_files[ 0 ],
         start, 0 );
   call_out( "process_passages", 2 );
   return 1;
}
void stop_working() {
   tell_room( environment(), "The box stops humming as it extrudes an "+
         "easel from a slot in one side.\n" );
   easel->add_shape( ({ 0, 0 }), ({ "@" }) );
   write_file( "/open/"+ terrain_name +".map",
         implode( (string *)easel->query_lines(), "\n" ) );
   easel->move( environment() );
   easel = 0;
   passages = ({ });
   room_entries = ({ });
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
}
int *shift_in( int *co_ord, string direc, string from, string to ) {
   int i, delta, *new_co_ord, *vector;
   delta = (int)from->query_room_size() + (int)to->query_room_size();
   new_co_ord = allocate( 3 );
   vector = STD_ORDERS[ member_array( direc, STD_ORDERS ) + 1 ];
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = co_ord[ i ] - delta * vector[ i ];
   return new_co_ord;
}
void process_passages() {
   int i, j, k, prob, straight, *co_ord, *new_co_ord;
   string direc, new_direc, type, new_type;
   mixed *last;
   if ( !sizeof( passages ) ) {
      tell_room( environment(), "No passages to process.\n" );
      return stop_working();
   }
   if ( max < 1 ) {
      tell_room( environment(), "Reached maximum.\n" );
      return stop_working();
   }
   max--;
   direc = passages[ 0 ][ 0 ];
   type = passages[ 0 ][ 1 ];
   co_ord = passages[ 0 ][ 2 ];
   last = passages[ 0 ][ 3 .. 4 ];
   straight = passages[ 0 ][ 5 ];
   passages = delete( passages, 0, 1 );
   call_out( "process_passages", 2 );
   for ( i = 0; i < 3; i++ ) {
      new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 + i ) % 8 ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      if ( sizeof( (mixed *)TERRAIN_MAP->
            member_floating_locations( new_co_ord ) ) ) {
         tell_room( environment(), "Passage already at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
      for ( j = 0; j < sizeof( room_entries ); j++ ) {
         for ( k = 0; k < 3; k++ )
            if ( new_co_ord[ k ] != room_entries[ j ][ k ] )
               break;
         if ( k < 3 )
            continue;
         tell_room( environment(), "Room entry at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; "+
               "joining passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         mark_passage( new_co_ord );
         room_entries = delete( room_entries, j, 1 );
         return;
      }
      if ( (int)easel->query_at( ({ ( new_co_ord[ 1 ] - start[ 1 ] ) / size,
            ( start[ 0 ] - new_co_ord[ 0 ] ) / size }) ) != 32 ) {
         tell_room( environment(), "Something at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
   }
   prob = random( 100 );
   if ( prob < p_probs[ END ] ) {
      tell_room( environment(), "Passage going "+ direc +" ends at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ END ];
   if ( ( prob < p_probs[ TWO ] ) && !straight ) {
      if ( random( 100 ) >= c_probs[ HALF ] + c_probs[ FULL ] ) {
         tell_room( environment(), "Passage branching "+ direc +" and " );
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type,
               new_co_ord, 0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
            direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
                  6 * random( 2 ) ) % 8 ];
         else
            direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
                  4 * random( 2 ) ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         tell_room( environment(), direc +" from "+
               co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
         return;
      }
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 1 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 2 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), "Passage branching "+ new_direc +" and " );
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), new_direc +" from "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ TWO ];
   if ( ( prob < p_probs[ FOUR ] ) && !straight ) {
      tell_room( environment(), "Crossroads from "+ direc +" at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      for ( i = 0; i < 3; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 + 2 * i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, new_direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
      }
      return;
   }
   prob -= p_probs[ FOUR ];
   if ( ( prob < p_probs[ ROOM ] ) && !straight ) {
      prob = random( 100 );
      new_type = room_files[ 0 ];
      for ( i = 1; i < sizeof( room_files ); i++ )
         if ( prob < r_probs[ FULL + i ] ) {
            new_type = room_files[ i ];
            break;
         } else
            prob -= r_probs[ FULL + i ];
      new_co_ord = shift_in( co_ord, direc, type, new_type );
      tell_room( environment(), "Room at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
      TERRAIN_MAP->add_floating_location( terrain_name, new_type,
            new_co_ord, 0 );
      mark_room( new_co_ord, new_type );
      mark_passage( co_ord );
      for ( i = 1; i < 8; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 4 + i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         co_ord = shift_in( new_co_ord, new_direc, new_type, type );
         if ( i % 2 ) {
            if ( random( 100 ) < r_probs[ HALF ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         } else {
            if ( random( 100 ) < r_probs[ FULL ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         }
      }
      return;
   }
   prob = random( 100 );
   if ( ( prob < c_probs[ HALF ] ) && !straight ) {
      direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
             6 * random( 2 ) ) % 8 ];
      straight = clear[ 0 ] + random( clear[ 1 ] );
   } else {
      prob -=  c_probs[ HALF ];
      if ( ( prob < c_probs[ FULL ] ) && !straight ) {
         direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
               4 * random( 2 ) ) % 8 ];
         straight = clear[ 0 ] + random( clear[ 1 ] );
      }
   }
   if ( straight > 0 )
      straight--;
   new_co_ord = shift_in( co_ord, direc, type, type );
   tell_room( environment(), "Passage goes "+ direc +" from "+
         co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
   TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
   passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
         straight }) });
   mark_passage( new_co_ord );
}

==================================================
FILE: handlers/terrain_things/logroom.c
==================================================

#include <terrain.h>
#define SAVE_FILE RESTORE_PATH +"logroom"
inherit "/std/room";
mapping locations;
void setup() {
   set_short( "limbo" );
   set_light( 50 );
   set_long( "You are between worlds, surrounded by raw potentiality and "+
         "not a lot else.\n" );
   add_item( "potentiality", "Well, it's sort of potentially something and "+
         "potentially nothing, and it can't quite decide at the moment.  "+
         "With any luck, though, you won't be here long enough to find "+
         "out...\n" );
   add_exit( "drum", "/d/am/am/mendeddrum", "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded((: restore_object, SAVE_FILE :));
}
void save_this() {
  unguarded((: save_object, SAVE_FILE :));
}
void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         ({ (string)place->query_property( "terrain name" ),
         (int *)place->query_co_ord() });
   save_this();
   call_out( "check_quitted", 5, (string)player->query_name() );
}
void check_quitted( string word ) {
   if ( !find_player( word ) )
      return;
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
}
void event_enter( object player, string words, object thing ) {
   object location;
   mixed *data;
   data = locations[ (string)player->query_name() ];
   if ( !data ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   location = (object)TERRAIN_MAP->find_location( data[ 0 ],
         data[ 1 ] );
   player->move( location );
   locations = m_delete( locations, (string)player->query_name() );
   save_this();
}

==================================================
FILE: handlers/terrain_things/sample_passage.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_passage_1.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_passage_2.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "rock-walled tunnel" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are tunnel with rough-hewn rock walls.  It looks as though "+
         "it has been deserted for a long time.\n" );
   add_item( ({ "rough-hewn rock wall", "rock" }), "The walls are rough, "+
         "where the tunnel was hewn out of the rock." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_1.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "small room" );
   set_light( 20 );
   set_room_size( 15 );
   set_long( "You are in a small room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_2.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "largish room" );
   set_light( 20 );
   set_room_size( 25 );
   set_long( "You are in a largish room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_3.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "large room" );
   set_light( 20 );
   set_room_size( 35 );
   set_long( "You are in a large room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/autodoc/autodoc_file.c
==================================================

#define MASTER_OB "/secure/master.c"
#define EOF -1
#define SAVE_DIR "/save/autodoc/"
nosave mapping private_functions;
mapping public_functions;
mapping protected_functions;
mapping inherits;
mapping main_docs;
mapping define_docs;
mapping includes;
mapping class_docs;
string file_name;
int last_changed;
int num_failed_tries;
nosave string current_comment;
nosave string current_file;
nosave int current_position;
nosave int changed;
nosave mapping defines;
nosave mixed *exclude_methods;
private void setup();
private mapping parse_comment(string stuff);
private void do_parse_file(function func);
private int query_file_position();
private void handle_inherit(mixed *bits);
void create() {
   seteuid(getuid());
   setup();
}
private void setup() {
   changed = 0;
   main_docs = 0;
   file_name = "";
   private_functions = ([ ]);
   public_functions = ([ ]);
   protected_functions = ([ ]);
   inherits = ([ ]);
   defines = ([ ]);
   define_docs = ([ ]);
   includes = ([ ]);
   class_docs = ([ ]);
   current_comment = 0;
   current_file = "";
   current_position = 0;
   last_changed = 0;
   exclude_methods = ({ "setup", "create", "init", "dest_me", "reset" });
}
private int query_file_position() {
   return current_position;
}
private int lookahead_character(int num) {
   if (current_position + num - 1 < strlen(current_file)) {
      return current_file[current_position + num - 1];
   }
   return EOF;
}
private int next_character() {
   if (current_position < strlen(current_file)) {
      return current_file[current_position++];
   }
   return EOF;
}
private int pop_character(int num) {
   current_position += num;
}
private void skip_to_end_of_line() {
   int ch;
   do {
      ch = next_character();
   } while (ch != '\r' && ch != '\n' && ch != EOF);
}
private string skip_to_end_of_comment() {
   string data;
   int ch;
   int ok;
   data = "";
   do {
      ok = 1;
      ch = next_character();
      if (ch == '*' && lookahead_character(1) == '/') {
         ok = 0;
         pop_character(1);
      } else if (ch == '\r' || ch == '\n') {
         data += "\n";
         if (lookahead_character(1) == ' ') {
            pop_character(1);
         }
         if (lookahead_character(1) == '*' && lookahead_character(2) != '/') {
            pop_character(1);
            if (lookahead_character(1) == ' ') {
               pop_character(1);
            }
         }
      } else if (ch == EOF) {
         ok = 0;
      } else if (ch == '\\' && (lookahead_character(1) == '/' ||
                               lookahead_character(1) == '*' ||
                               lookahead_character(1) == '\\')) {
      } else {
         data += sprintf("%c", ch);
      }
   } while (ok);
   return data;
}
private void skip_spaces_and_comments() {
   int ok;
   do {
     switch (lookahead_character(1)) {
        case ' ' :
        case '\t' :
        case '\n' :
        case '\r' :
           ok = 1;
           pop_character(1);
           break;
        case '/' :
           if (lookahead_character(2) == '/') {
              ok = 1;
              skip_to_end_of_line();
           } else if (lookahead_character(2) == '*') {
              ok = 1;
              if (lookahead_character(3) != '*' ||
                  lookahead_character(4) == '*') {
                 pop_character(2);
                 skip_to_end_of_comment();
                 current_comment = 0;
              } else {
                 pop_character(3);
                 if (lookahead_character(1) == ' ') {
                    pop_character(1);
                 }
                 if (!main_docs) {
                    main_docs = parse_comment(skip_to_end_of_comment());
                 } else {
                    current_comment = skip_to_end_of_comment();
                 }
              }
           } else {
              ok = 0;
           }
           break;
        default :
           ok = 0;
           break;
     }
   } while (ok);
}
private string expand_token(string token) {
   if (defines[token]) {
      return defines[token];
   }
   return 0;
}
private string get_word() {
   string data;
   int ok;
   int ch;
   skip_spaces_and_comments();
   ok = 1;
   data = "";
   ch = lookahead_character(1);
   if ((ch >= 'a' && ch <= 'z') ||
       (ch >= 'A' && ch <= 'Z') ||
       (ch == '_')) {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
      if (expand_token(data)) {
         current_file = expand_token(data) + current_file[current_position..];
         current_position = 0;
         return get_word();
      }
   } else if ((ch >= '0' && ch <= '9') ||
              (ch == '-')) {
      if (ch == '-') {
         data += sprintf("%c", next_character());
      }
      do {
         ch = lookahead_character(1);
         if ((ch >= '0' && ch <= '9') ||
             (ch >= '.')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
   } else if (ch == '\"' || ch == '\'') {
      int end_ch;
      end_ch = ch;
      ch = next_character();
      data += sprintf("%c", ch);
      do {
         ch = next_character();
         if (ch == end_ch) {
            ok = 0;
            data += sprintf("%c", ch);
         } else if (ch == '\\') {
            ch = next_character();
            data += sprintf("\\%c", ch);
         } else if (ch == EOF) {
            ok = 0;
         } else {
            data += sprintf("%c", ch);
         }
      } while (ok);
   } else if (ch == '(') {
      if (lookahead_character(2) == '{' ||
          lookahead_character(2) == '[') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == '}' || ch == ']') {
      if (lookahead_character(2) == ')') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == ';' ||
              ch == ')' ||
              ch == '=' ||
              ch == '{' ||
              ch == '}') {
      return sprintf("%c", next_character());
   } else if (ch == EOF) {
      return "";
   } else {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_') ||
             (ch == ' ') ||
             (ch == '\t') ||
             (ch == '\n') ||
             (ch == '(') ||
             (ch == ')') ||
             (ch == EOF) ||
             (ch == ';') ||
             (ch == '=') ||
             (ch == '{') ||
             (ch == '}') ||
             (ch == '\'') ||
             (ch == '\"') ||
             (ch == '\r')) {
            ok = 0;
         } else {
            ch = next_character();
            data += sprintf("%c", ch);
         }
      } while (ok);
   }
   return data;
}
private mixed *get_statement(string start) {
   mixed *bits;
   string curr;
   int depth;
   string temp_comment;
   int last_pos;
   int in_class;
   bits = ({ start });
   do {
      last_pos = query_file_position();
      curr = get_word();
      bits += ({ curr });
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
   } while (curr != ";" && curr != "{" && curr != "");
   if (curr == "{") {
      if (member_array("class", bits) != -1 &&
          member_array("(", bits) == -1) {
         in_class = 1;
      }
      temp_comment = current_comment;
      depth = 1;
      do {
        last_pos = query_file_position();
        curr = get_word();
        if (curr == "{") {
           depth++;
        } else if (curr == "}") {
           depth--;
        } else if (curr == "") {
           depth = 0;
        }
        if (last_pos != query_file_position()) {
           reset_eval_cost();
        }
        if (in_class) {
           bits += ({ curr });
        }
      } while (depth > 0);
      current_comment = temp_comment;
   }
   return bits;
}
private mapping parse_comment(string stuff) {
   string *bits;
   int i;
   mapping frog;
   string name;
   int j;
   int rabbit;
   if (!stuff) {
      return ([ ]);
   }
   if (stuff[0] == '@') {
      stuff = "\n" + stuff;
   } else {
      stuff = "\n@main " + stuff;
   }
   bits = explode(stuff, "\n@");
   frog = ([ ]);
   for (i = 0; i< sizeof(bits); i++) {
      j = strsrch(bits[i], " ");
      rabbit = strsrch(bits[i], "\n");
      if (j == -1 || (rabbit != -1 && rabbit < j)) {
         j = rabbit;
      }
      if (j > 0) {
         name = bits[i][0..j - 1];
         stuff = bits[i][j+1..];
         if (!frog[name]) {
            frog[name] = ({ stuff });
         } else {
            frog[name] += ({ stuff });
         }
      }
   }
   return frog;
}
private void handle_class(mixed *bits) {
   string name;
   int i;
   string *types;
   mapping comm;
   name = bits[1];
   types = ({ });
   i = member_array("{", bits);
   if (i != -1) {
      bits = bits[i + 1..];
      while (sizeof(bits)) {
         i = member_array(";", bits);
         if (i != -1) {
            types += ({ ({ bits[i - 1], bits[0..i - 2] }) });
            bits = bits[i + 1..];
         } else {
            bits = ({ });
         }
      }
      comm = parse_comment(current_comment);
      if (!comm["ignore"]) {
         class_docs[name] = ({ 0, types,
                               parse_comment(current_comment) });
      }
   }
}
private void handle_inherit(mixed *bits) {
   int pos;
   string name;
   pos = member_array("inherit", bits);
   if (pos >= 0) {
      name = implode(map(bits[pos+1.. sizeof(bits)-2],
                         function(string str) {
                            if (str[0] == '\"') {
                               sscanf(str, "\"%s\"", str);
                               return str;
                            }
                            return "";
                         } ), "");
      inherits[name] = bits[0..pos-1];
   }
}
private void handle_function_definition(mixed *bits) {
   int pos;
   int end_pos;
   int new_pos;
   string name;
   string *type;
   mixed *args;
   mapping comm;
   pos = member_array("(", bits);
   if (pos > 0) {
      name = bits[pos-1];
      if (member_array(name, exclude_methods) == -1) {
         type = bits[0..pos-2];
         if (sizeof(type) == 0) {
            type = ({ "int" });
         }
         end_pos = member_array(")", bits, pos);
         args = ({ });
         if (end_pos > pos + 1) {
            pos++;
            while (member_array(",", bits, pos) != -1) {
               new_pos = member_array(",", bits, pos);
               args += ({ bits[pos..new_pos-2], bits[new_pos-1] });
               pos = new_pos + 1;
            }
            args += ({ bits[pos..end_pos -2], bits[end_pos-1] });
         }
         comm = parse_comment(current_comment);
         if (!comm["ignore"]) {
            if (member_array("private", type) != -1) {
               type -= ({ "private" });
               private_functions[name] = ({ type, args,
                                          comm });
            } else if (member_array("protected", type) != -1) {
               type -= ({ "protected" });
               protected_functions[name] = ({ type, args,
                                           comm });
            } else {
               type -= ({ "public" });
               public_functions[name] = ({ type, args,
                                           comm });
            }
         }
      }
      current_comment = 0;
   }
}
private string get_rest_of_line() {
   string value;
   int ch;
   int last_pos;
   value = "";
   ch = lookahead_character(1);
   while (ch == ' ' || ch == '\t') {
      pop_character(1);
      ch = lookahead_character(1);
   }
   do {
      last_pos = query_file_position();
      ch = next_character();
      if (ch == '\\') {
         ch = next_character();
         if (ch == '\r' && lookahead_character(1) == '\n') {
            ch = next_character();
         }
         ch = ' ';
      }
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
      value += sprintf("%c", ch);
   } while (ch != '\n' && ch != '\r' && ch != EOF);
   return value;
}
private void handle_hash() {
   int i;
   string token;
   string name;
   string value;
   string *bits;
   string stuff;
   string inc_name;
   string curr_comm;
   mapping comm;
   token = get_word();
   switch (token) {
      case "define" :
      case "defin" :
         curr_comm = current_comment;
         value = get_rest_of_line();
         if (sscanf(value, "%s %s", name, value) == 2) {
            defines[name] = value;
            if (token == "define") {
               comm = parse_comment(curr_comm);
               if (!comm["ignore"]) {
                  define_docs[name] = comm;
               }
               current_comment = 0;
            }
         }
         break;
      case "include" :
         value = get_rest_of_line();
         if (value[0] == '\"') {
            bits = explode(file_name, "/");
            sscanf(value, "\"%s\"", name);
            stuff = read_file(implode(bits[0..<2], "/") +
                              "/" + name);
            if (stuff) {
               inc_name = "/" + implode(bits[0..<2], "/") +
                              "/" + name;
            }
         } else if (value[0] == '<') {
            sscanf(value, "<%s>", name);
         }
         if (name[0] == '/') {
            stuff = read_file(name);
            if (stuff) {
               inc_name = name;
            }
         }
         bits = MASTER_OB->define_include_dirs();
         while (!stuff && i < sizeof(bits)) {
            stuff = read_file(sprintf(bits[i], name));
            if (stuff) {
               stuff = replace_string(stuff, "
               stuff = replace_string(stuff, "class ", "clas ");
               stuff = replace_string(stuff, "#define ", "#defin ");
               inc_name = sprintf(bits[i], name);
            }
            i++;
         }
         if (inc_name) {
            inc_name = replace(inc_name, "
            if (inc_name[0] != '/') {
               inc_name = "/" + inc_name;
            }
         }
         if (stuff && !includes[inc_name]) {
            current_file = stuff + current_file[current_position..];
            current_position = 0;
            includes[inc_name] = unguarded( (: stat($(inc_name)) :) )[1];
         }
         break;
      default :
         skip_to_end_of_line();
         break;
   }
}
private void next_statement() {
   string token;
   string *bits;
   token = get_word();
   if (token[0] == '#') {
      return handle_hash();
   } else if (token == ";") {
      return ;
   } else if (token != "") {
      bits = get_statement(token);
      if (member_array("inherit", bits) != -1) {
         return handle_inherit(bits);
      } else if (bits[0] == "class" &&
                 member_array("(", bits) == -1) {
         return handle_class(bits);
      } else if (bits[sizeof(bits) - 1] == "{" &&
                 member_array("=", bits) == -1) {
         return handle_function_definition(bits);
      } else {
         return ;
      }
   }
}
void load_file() {
   unguarded((: restore_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
   if (!includes) {
      includes = ([ ]);
   }
   if (!class_docs) {
      class_docs = ([ ]);
   }
}
void save_file() {
   unguarded((: save_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
}
void parse_file(string name, function func, int only_load) {
   int curr_change;
   int my_change;
   string my_name;
   int reload;
   setup();
   file_name = name;
   load_file();
   if (!only_load) {
      if (sizeof(unguarded( (: stat($(name)) :) )) > 1) {
         curr_change = unguarded( (: stat($(name)) :) )[1];
         my_name = file_name(this_object());
         sscanf(my_name, "%s#%*s", my_name);
         my_name += ".c";
         my_change = unguarded( (: stat($(my_name)) :) )[1];
         reload = curr_change > last_changed;
         if (my_change > last_changed &&
             my_change > curr_change) {
            curr_change = my_change;
            reload = 1;
         }
         if (!reload) {
            foreach (my_name, my_change in includes) {
               if ( unguarded( (: stat($(my_name)) :) )[1] != my_change) {
                  reload = 1;
                  break;
               }
            }
         }
         if (reload) {
            setup();
            num_failed_tries = 0;
            file_name = name;
            changed = 1;
            last_changed = curr_change;
            current_file = read_file(name);
            current_position = 0;
            if (catch(do_parse_file(func))) {
               evaluate(func);
            }
         } else {
            if (num_failed_tries) {
               num_failed_tries = 0;
               save_file();
            }
            call_out( (: evaluate($1) :), 2, func);
         }
      } else {
         num_failed_tries++;
         save_file();
         call_out( (: evaluate($1) :), 2, func);
      }
   } else {
      call_out( (: evaluate($1) :), 2, func);
   }
}
private void do_parse_file(function func) {
   int num;
   if (unguarded( (: stat(file_name) :))[1] > last_changed) {
      return parse_file(file_name, func, 0);
   }
   num = 0;
   while (lookahead_character(1) != EOF && num < 2) {
      next_statement();
      num++;
   }
   if (lookahead_character(1) == EOF) {
      save_file();
      call_out((: evaluate($1) :), 2, func);
   } else {
      call_out((: do_parse_file($1) :), 2, func);
   }
}
mapping query_inherits() { return inherits; }
mapping query_private_functions() { return private_functions; }
mapping query_public_functions() { return public_functions; }
mapping query_protected_functions() { return protected_functions; }
mapping query_main_docs() {
   if (main_docs) {
      return main_docs;
   }
   return ([ ]);
}
string query_file_name() { return file_name; }
mapping query_defines() { return defines; }
int query_changed() { return changed; }
int query_num_failed_tries() { return num_failed_tries; }
string *query_includes() { return keys(includes); }
mapping query_define_docs() { return define_docs; }
mapping query_class_docs() { return class_docs; }
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/autodoc/autodoc_handler.c
==================================================

#include <autodoc.h>
#define MAIN_FILE 0
#define INDEX_FILE 1
#define SAVE_FILE (SAVE_DIR "main_rubbish")
string *files;
int file_pos;
int something_changed;
int last_created_index;
nosave function *filters;
nosave int call_id;
nosave mapping summary_map;
nosave mixed *extra_indexes;
mapping help_map;
private void create_nroff_file(object ob, int type);
private void create_html_file(object ob, int type);
private void after_thingy(int no_index);
private void start_processing();
private void do_parse_next_file();
private void create_index();
private void add_to_index(object ob);
private void load();
private void save();
string *query_files();
int remove_file(string fname);
void create() {
   seteuid(getuid());
   filters = ({ (: create_nroff_file($1, $2) :),
                (: create_html_file($1, $2) :) });
   file_pos = 0;
   something_changed = 0;
   files = ({ });
   load();
   do_parse_next_file();
}
private void create_nroff_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;
   if (type == MAIN_FILE) {
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      rm(NROFF_DOC_DIR + fname);
      AUTODOC_NROFF->create_nroff_file(ob, NROFF_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;
           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      for (i = 0; i < sizeof(stuff); i++) {
         fname = NROFF_DOC_DIR + "index_" + lower_case(stuff[i][0][0][0..0]);
         AUTODOC_NROFF->create_nroff_index_file(stuff[i], fname);
      }
   }
}
private void create_html_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;
   mapping chars;
   if (type == MAIN_FILE) {
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      fname += ".html";
      rm(HTML_DOC_DIR + fname);
      AUTODOC_HTML->create_html_file(ob, HTML_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;
           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name, "", summary_map[name] });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      chars = ([ ]);
      for (i = 0; i < sizeof(stuff); i++) {
         fname = "index_" + lower_case(stuff[i][0][0][0..0]) + ".html";
         rm(HTML_DOC_DIR + fname);
         AUTODOC_HTML->create_html_index_file(stuff[i], stuff[i][0][0][0..0],
                                       HTML_DOC_DIR + fname);
         reset_eval_cost();
         chars[capitalize(stuff[i][0][0][0..0])] =  fname;
      }
      fname = HTML_DOC_DIR;
      AUTODOC_HTML->create_main_index(chars, fname);
   }
}
private void after_thingy(int no_index) {
   int i;
   if (no_index) {
      printf("Finished recreating the documentation for %O\n",
              previous_object()->query_file_name(),
             previous_object());
   }
   if (previous_object()->query_changed()) {
      something_changed = 1;
   }
   if (previous_object()->query_num_failed_tries() > 1) {
      remove_file(files[file_pos - 1]);
   } else if (previous_object()->query_changed() || no_index) {
      for (i = 0; i < sizeof(filters); i++) {
         call_out((: evaluate($1, $2, $3) :), 0, filters[i],
                  previous_object(), MAIN_FILE);
      }
   }
   call_out((: $1->dest_me() :), 20, previous_object());
   save();
}
private void do_parse_next_file() {
   call_id = call_out((: start_processing() :), 60);
   if (file_pos >= sizeof(files)) {
      file_pos = 0;
   }
   new(AUTODOC_FILE)->parse_file(files[file_pos++], (: after_thingy(0) :));
}
private void start_processing() {
   if (sizeof(files) == 0) {
      return ;
   }
   if (last_created_index + SAVE_INDEX_DELAY < time()) {
      if (something_changed) {
         call_out( (: create_index() :), 2);
      }
      something_changed = 0;
      save();
   }
   call_id = call_out((: do_parse_next_file() :), 360);
}
private string query_short_args_def(mixed *args) {
   string ret;
   int i;
   ret = "";
   for (i = 0; i < sizeof(args); i += 2) {
      if (i != 0) {
         ret += ", ";
      }
      ret += implode(args[AUTO_ARGS_TYPE], " ");
   }
   return "(" + ret + ")";
}
private string *process_stuff(string name,
                              string fname,
                              string fn,
                              mapping docs) {
   string blue;
   int i;
   int end;
   mixed *ret;
   mapping fluff;
   if (name != "create" && name != "setup" && name != "init") {
      if (help_map[name]) {
         help_map[name] += ({ fn });
      } else {
         help_map[name] = ({ fn });
      }
   }
   if (docs[name]) {
      if (arrayp(docs[name])) {
         fluff = docs[name][AUTO_DOCS];
         ret =  ({ name, fname, query_short_args_def(docs[name][AUTO_ARGS]) });
      } else {
         ret = ({ name, fname, "" });
         fluff = docs[name];
      }
   } else {
      ret = ({ name, fname, "" });
      if (mapp(docs)) {
         fluff = docs;
      } else {
         fluff = ([ ]);
      }
   }
   if (fluff["main"]) {
      blue = implode(fluff["main"], "\n");
      end = strlen(blue);
      i = strsrch(blue, ".");
      if (i > 0) {
         end = i;
      }
      i = strsrch(blue, "!");
      if (i > 0 && i < end) {
         end = i;
      }
      i = strsrch(blue, "?");
      if (i > 0 && i < end) {
         end = i;
      }
      blue = blue[0..end];
   }
   ret += ({ blue });
   if (fluff["index"]) {
      foreach (blue in fluff["index"]) {
         blue = replace(blue, ({ " ", "", "\n", "" }));
         if (help_map[blue]) {
            help_map[blue] += ({ fn });
         } else {
            help_map[blue] = ({ fn });
         }
         extra_indexes += ({ ({ blue, fname, "", ret[AUTO_INDEX_SUMMARY] }) });
      }
   }
   return ret;
}
private void create_index() {
   int i;
   mixed *index_stuff;
   mixed *rabbit;
   string fname;
   string fn;
   string *bits;
   object parse;
   index_stuff = ({ });
   help_map = ([ ]);
   extra_indexes = ({ });
   summary_map = ([ ]);
   parse = clone_object(AUTODOC_FILE);
   for (i = 0; i < sizeof(files); i++) {
      parse->parse_file(files[i], 0, 1);
      fname = parse->query_file_name();
      if (fname) {
         fn = replace(fname, "/", ".");
         if (fn[0] == '.') {
            fn = fn[1..];
         }
         fn = NROFF_DOC_DIR + fn;
         bits = explode(fname[0..strlen(fname)-3], "/");
         rabbit = process_stuff(bits[sizeof(bits) - 1], "", fn,
                                parse->query_main_docs());
         if (rabbit[AUTO_INDEX_SUMMARY]) {
            summary_map[fname] = rabbit[AUTO_INDEX_SUMMARY];
         } else {
            map_delete(summary_map, fname);
         }
         index_stuff += map(keys(parse->query_public_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_public_functions()) :) );
         index_stuff += map(keys(parse->query_protected_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_protected_functions()) :) );
         index_stuff += map(keys(parse->query_class_docs()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_class_docs()) :) );
         if (sscanf(fname, "%*s.h") == 1) {
            index_stuff += map(keys(parse->query_define_docs()),
                               (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_define_docs()) :) );
         }
      }
      reset_eval_cost();
   }
   index_stuff += extra_indexes;
   extra_indexes = ({ });
   for (i = 0; i < sizeof(filters); i++) {
      reset_eval_cost();
      catch(evaluate(filters[i], index_stuff, INDEX_FILE));
   }
   summary_map = ([ ]);
   last_created_index = time();
   save();
}
int recreate_documentation(string fname) {
   object ob;
   if (member_array(fname, files) != -1) {
      ob = clone_object(AUTODOC_FILE);
      ob->parse_file(fname, (: after_thingy(1) :));
      return 1;
   }
   return 0;
}
void recreate_indexes() {
   unguarded( (: create_index() :));
}
int add_file(string fname) {
   fname = "/" + implode(explode(fname, "/") - ({ "" }), "/");
   if (member_array(fname, files) == -1) {
      if (sizeof(unguarded( (: stat($(fname)) :) ))) {
         files += ({ fname });
         save();
         if (sizeof(files) == 1) {
            start_processing();
         } else {
            call_out((: recreate_documentation($1) :), random(60), fname);
         }
         return 1;
      }
   }
   return 0;
}
int remove_file(string fname) {
   string fn;
   string dfn;
   string *our_files;
   if (member_array(fname, files) != -1) {
      files -= ({ fname });
      file_pos = 0;
      fn = HTML_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      fn = NROFF_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      fn = NROFF_DOC_SINGLE + fname[0..<3] + "/";
      our_files = get_dir(fn);
      if (sizeof(our_files)) {
         foreach (dfn in our_files) {
            dfn =  fn + dfn;
            unguarded( (: rm($(dfn)) :) );
         }
      }
      if (file_size(fn[0..<2]) != -1) {
         unguarded((: rm($(fn[0..<2])) :));
      }
      save();
      if (!sizeof(files)) {
         remove_call_out(call_id);
      }
      return 1;
   }
   return 0;
}
private void load() {
   unguarded( (: restore_object( SAVE_FILE ) :) );
}
private void save() {
   unguarded( (: save_object( SAVE_FILE ) :) );
}
string *query_files() { return files; }
mapping query_help_map() { return help_map; }
string query_help_on(string file, string func) {
   if (file[0] == '/') {
      file = file[1..];
   }
   if (sscanf(file, "%*s.c") == 1) {
      file = file[0..<3];
   }
   file = NROFF_DOC_SINGLE + file + "/" + func;
   if (file_size(file) > 0) {
      return file;
   }
   return 0;
}
mapping query_summary_map() { return summary_map; }
int is_autodoc_file(string name) {
   return member_array(name, files) != -1;
}

==================================================
FILE: handlers/autodoc/autodoc_html.c
==================================================

#include <autodoc.h>
#include <config.h>
private string query_func_def(mixed *stuff, string func);
private string query_methods(string *funcs, function data,
                           int prot);
private string query_method_description(mapping docs);
private string create_href(string str);
private string query_method_summary(string *funcs, object file);
private string query_defines(string *defs, mapping docs);
private string query_class_summary(mapping classes);
private string query_classes(mapping classes);
private string query_class_def(mixed *stuff, string name);
private string query_class_description(mapping docs);
void create() {
   seteuid(getuid());
}
void create_html_file(object file, string output) {
   int i;
   mapping stuff;
   string *pub_funcs;
   string *pro_funcs;
   string *defs;
   string *bits;
   string name;
   string bing;
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   bing = "<html><head><title>";
   bing += "File " + name +
           "\n</title></head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" VLINK=\"#b57339\">";
   bing += "[ <a href=\"index.html\">Package Index</a></code> | ";
   bing += "<a href=\"index_std.html\">Mudlib Index</a></code> | ";
   bing += "<a href=\"index_eff.html\">Effect Index</a></code> ]<br>";
   stuff = file->query_main_docs();
   if (stuff["main"]) {
      bing += "<h2>File " + file->query_file_name() +
                         "</h2>";
      bing += implode(stuff["main"], " ");
      if (stuff["see"]) {
         bing += "<p><b>See also:</b><br>" +
                            query_multiple_short(
                            map(stuff["see"], (: create_href($1) :)));
      }
      if (stuff["author"]) {
         bing += "<p>Written by " +
                    query_multiple_short(stuff["author"]);
      }
      if (stuff["started"]) {
         bing += "<p>Started " +
                    query_multiple_short(stuff["started"]);
      }
      if (stuff["example"]) {
         if (sizeof(stuff["example"]) > 1) {
            for (i = 0; i < sizeof(stuff["example"]); i++) {
               bing += "<h3>Example " + (i + 1) + "</h3>\n";
               bing += "<pre>"+stuff["example"][i]+"</pre>\n";
            }
         } else {
            bing +=  "<h3>Example</h3>\n<pre>" + stuff["example"][0] +
                             "</pre>\n";
         }
      }
      if (stuff["changed"]) {
         bing += "<h3>Change history</h3>\n<dl>" +
                            implode(map(stuff["changed"], function (string str) {
                   string start;
                   string rest;
                   if (sscanf(str, "%s\n%s", start, rest) == 2) {
                      return "<dt>" + start + "<dd>" + rest;
                   }
                   return "<dd>" + str;
             } ), "\n") + "</dl>\n";
      }
   }
   if (sizeof(file->query_inherits())) {
      bing += "<hr><h2>Inherits</h2>\n";
      bing += "This class inherits the following classes " +
                         query_multiple_short(
               map(keys(file->query_inherits()), (: create_href :)));
   }
   if (sizeof(file->query_includes())) {
      bing += "<hr><h2>Includes</h2>\n";
      bing += "This class includes the following files " +
                         query_multiple_short(
               map(file->query_includes(), (: create_href :)));
   }
   if (sizeof(file->query_class_docs())) {
       bing += query_class_summary(file->query_class_docs());
   }
   pub_funcs = keys(file->query_public_functions());
   pro_funcs = keys(file->query_protected_functions());
   bing += query_method_summary(pub_funcs + pro_funcs, file);
   if (sizeof(pub_funcs)) {
      bing += "<hr><h2>Public Functions</h2>\n";
      bing += "These are functions that everyone can "
                         "access.<p><dl>\n.";
      bing += query_methods(pub_funcs, (: $(file)->query_public_functions()[$1] :),
                    0);
      bing += "</dl>\n";
   }
   if (sizeof(pro_funcs)) {
      bing += "<hr><h2>Protected Functions</h2>\n";
      bing += "These are functions that only "
                         "objects inheriting the class can access.<p>\n";
      bing += query_methods(pro_funcs, (: $(file)->query_protected_functions()[$1] :),
                    1);
      bing +=  "\n";
   }
   if (sscanf(name, "%*s.h") == 1 &&
       sizeof(file->query_define_docs())) {
      defs = sort_array(keys(file->query_define_docs()),
                        (: strcasecmp($1, $2) :));
      bing +=  "<hr><h2>Defines</h2>\n";
      query_defines(defs, file->query_define_docs());
      bing = "";
   }
   if (sizeof(file->query_class_docs())) {
      bing += "<hr><h2>Classes</h2>\n";
      bing += "These are nice data types for dealing with...  Data!"
                         "<p>\n";
      bing += query_classes(file->query_class_docs());
   }
   write_file(output, bing, 1);
   bing = "/www/footer"->www_function(output);
   write_file(output, bing + "</body></html>");
}
void create_html_index_file(string *index, string letter, string output) {
   int i;
   string name;
   string bing;
   bing = "<html><head><title>\nIndex of " + letter +
                      "\n</title></head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" VLINK=\"#b57339\">\n";
   bing += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                       "pics/dw4.gif\">\n"
                      "<p align=right><code><a href=\"index.html\">"
                      "Main Index</a></code></p>\n"
                      "<h2>Index of " + letter + "</h2>\n"
                      "<h3><i>Letters can change the world, remove the l "
                      "from world and you have word</i></h3>\n"
                      "<br clear=both>\n"
                      "<hr><dl>\n";
   index = sort_array(index, (: strcasecmp($1[0], $2[0]) ? strcasecmp($1[0], $2[0]) :
                                        strcasecmp($1[1], $2[1]) :) );
   for (i = 0; i < sizeof(index); i++) {
      name = replace(index[i][AUTO_INDEX_FILE_NAME], "/", ".");
      if (name[0] == '.') {
         name = name[1..];
      }
      if (sscanf(index[i][AUTO_INDEX_NAME], "%*s.%*s") == 2) {
         bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                            "height=6 width=6 alt=\" . \"><b><a href=\"" +
                            name + ".html\">" + index[i][AUTO_INDEX_NAME] +
                            "</a></b>.\n";
      } else {
         bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                            "height=6 width=6 alt=\" . \"><b><a href=\"" +
                            name + ".html#" + index[i][AUTO_INDEX_NAME] +
                            "\">" + index[i][AUTO_INDEX_NAME] + "</a></b>" +
                            index[i][AUTO_INDEX_ARGS] +
                            "; <a href=\"" + name + ".html\">" +
                            index[i][AUTO_INDEX_FILE_NAME] + "</a>\n";
      }
      if (index[i][AUTO_INDEX_SUMMARY]) {
         bing += "<dd>"+index[i][AUTO_INDEX_SUMMARY]+"\n";
      }
      reset_eval_cost();
   }
   write_file(output, bing + "</dl>", 1);
   write_file(output, "/www/footer"->www_function(output) + "</body></html>");
}
private string bing_cre;
private string bing_eff;
private string bing_index;
void create_main_index(mapping chars, string output_dir) {
   int i;
   string output_index;
   string output_eff;
   string output_cre;
   string *files;
   mixed *stuff;
   string str;
   string fname;
   string *index;
   mapping summaries;
   function write_all;
   string bing_file;
   string fluff;
   summaries = AUTODOC_HANDLER->query_summary_map();
   output_index = output_dir + "index_std.html";
   output_eff = output_dir + "index_eff.html";
   output_cre = output_dir + "index_cre.html";
   bing_cre = "";
   bing_eff = "";
   bing_file = "";
   bing_index = "";
   rm (output_eff);
   rm (output_index);
   rm (output_cre);
   write_all = (: bing_eff += $1,
                  bing_cre += $1,
                  bing_index += $1 :);
   evaluate(write_all, "<html><head><title>\n");
   evaluate(write_all, "" + mud_name() + " autodoc index\n</title></head>\n"
                            "<body bgcolor=\"#ffffff\" TEXT=\"#000030\" "
                             "LINK=\"#4a529c\" VLINK=\"#b57339\">\n");
   bing_index += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "/pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Documentation</h2>\n"
                      "<h3><i>Where cabbages evaporate in the sun</i></h3>\n"
                      "<br clear=both>\n";
   bing_eff += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "/pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Effect Documentation</h2>\n"
                      "<h3><i>Where your consequences are vanquished</i></h3>\n"
                      "<br clear=both>\n";
   bing_cre += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Creator Documentation</h2>\n"
                      "<h3><i>Blue fluff?  No red and scruffy!</i></h3>\n"
                      "<br clear=both>\n";
   evaluate(write_all, "<h2>Function index</h2>\n");
   files = AUTODOC_HANDLER->query_files();
   files = sort_array(files, (: strcasecmp :) );
   index = sort_array(keys(chars), (: strcasecmp :) );
   for (i = 0; i < sizeof(index); i++) {
      if (i > 0) {
         evaluate(write_all, ", ");
      }
      evaluate(write_all, "<a href=\"" + chars[index[i]] + "\">" + index[i] +
                         "</a>\n");
   }
   bing_index += ", <a href=\"index_eff.html\">Effects</a>";
   bing_index += ", <a href=\"index_cre.html\">Creator</a>";
   bing_eff += ", <a href=\"index.html\">Main</a>";
   bing_eff += ", <a href=\"index_cre.html\">Creator</a>";
   bing_cre += ", <a href=\"index.html\">Main</a>";
   bing_cre += ", <a href=\"index_eff.html\">Effects</a>";
   evaluate(write_all, "<hr><h2>Class index</h2>\n");
   evaluate(write_all, "<dl>\n");
   stuff = unique_array(files, (: $1[0..strsrch($1, "/", -1)] :));
   for (i = 0; i < sizeof(stuff); i++) {
      str = stuff[i][0][0..strsrch(stuff[i][0], "/", -1)];
      if (str[0..12] == "/std/effects/") {
         bing_eff += "<dt><img src=\"images/cyan-ball.gif\" height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      } else if (str[0..2] == "/w/") {
         bing_cre += "<dt><img src=\"images/cyan-ball.gif\" "
                            "height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      } else {
         bing_index += "<dt><img src=\"images/cyan-ball.gif\" height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      }
   }
   evaluate(write_all, "</dl>\n");
   for (i = 0; i < sizeof(stuff); i++) {
      fluff = "";
      str = stuff[i][0][0..strsrch(stuff[i][0], "/", -1)];
      fluff += "<h2><a name=\"" + str + "\">" + str + "</a></h2>\n<dl>\n";
      reset_eval_cost();
      foreach (str in stuff[i]) {
         fname = replace(str, "/", ".")[1..];
         fluff += "<dt><img src=\"images/cyan-ball-small.gif\" "
                            "height=6 width=6><a href=\"" + fname + ".html\">" +
                            str[strsrch(str, "/", -1) + 1..] + "</a>\n";
         if (summaries[str]) {
            fluff += "<dd>" + summaries[str] + "\n";
         }
      }
      fluff += "</dl>\n";
      if (stuff[i][0][0..12] == "/std/effects/") {
         bing_eff += fluff;
      } else if (stuff[i][0][0..2] == "/w/") {
         bing_cre += fluff;
      } else {
         bing_index += fluff;
      }
   }
   write_file(output_eff, bing_eff, 1);
   write_file(output_eff,
              "/www/footer"->www_function(output_eff) + "</body></html");
   write_file(output_index, bing_index, 1);
   write_file(output_index,
              "/www/footer"->www_function(output_index) + "</body></html");
   write_file(output_cre, bing_cre, 1);
   write_file(output_cre,
              "/www/footer"->www_function(output_cre) + "</body></html");
}
private string query_classes(mapping classes) {
   string name;
   string *names;
   string bing;
   names = sort_array(keys(classes), (: strcasecmp :) );
   bing = "<dl>\n";
   foreach (name in names) {
      reset_eval_cost();
      bing += "<dt><a name=\"class_" + name + "\">\n";
      bing += "<img src=\"images/cyan-ball.gif\" width=12 "
                         "height=12 alt=\" * \">";
      bing += "<b>" + name +
              "</b></a><pre>\n" +
              query_class_def(classes[name], name) + "\n</pre>";
      if (classes[name][AUTO_CLASS_DOCS]["main"]) {
         bing += query_class_description(classes[name][AUTO_CLASS_DOCS]);
      }
      bing += "\n";
   }
   return bing + "</dl>\n";
}
private string query_methods(string *funcs, function data,
                           int prot) {
   int i;
   mixed *stuff;
   string bing;
   funcs = sort_array(funcs, (: strcasecmp($1, $2) :));
   bing = "";
   for (i = 0; i < sizeof(funcs); i++) {
      reset_eval_cost();
      stuff = evaluate(data, funcs[i]);
      bing += "<dt><a name=\"" + funcs[i] + "\">\n";
      if (prot) {
        bing += "<img src=\"images/magenta-ball.gif\" width=12 "
                           "height=12 alt=\" * \">";
      } else {
        bing += "<img src=\"images/cyan-ball.gif\" width=12 "
                           "height=12 alt=\" * \">";
      }
      bing += "<b>" + funcs[i] +
                         "</b></a><pre>\n" +
                         query_func_def(stuff, funcs[i]) +
                         "\n</pre>";
      if (stuff[AUTO_DOCS]["main"]) {
         bing += query_method_description(stuff[AUTO_DOCS]);
      }
      bing += "\n";
   }
   return bing;
}
private string query_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   int pad;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += sprintf(",\n%-"+pad+"s", "");
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_class_def(mixed *stuff, string name) {
   string ret;
   int pad;
   int i;
   ret = "class " + name + " {\n";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_CLASS_MEMBERS]); i++) {
      ret += sprintf("%-" + pad + "s", "");
      ret += implode(stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_TYPE], " ") +
             " " + stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_NAME] + ";\n";
   }
   ret += "}\n";
   return ret;
}
private string query_method_description(mapping docs) {
   int i;
   string name;
   string desc;
   string bing;
   bing = "";
   if (docs["main"]) {
      bing += "<dd>" + implode(docs["main"], " ")
                         +"<p>\n";
   }
   if (docs["param"] || docs["return"] || docs["see"] || docs["example"]) {
      bing += "<dd><dl>\n";
   }
   if (docs["param"]) {
      bing += "<dt><b>Parameters:</b>\n";
      for (i = 0; i < sizeof(docs["param"]); i++) {
         if (sscanf(docs["param"][i], "%s %s", name, desc) == 2) {
            bing += "<dd>" + name + " - " + (desc) + "\n";
         }
      }
   }
   if (docs["return"]) {
      bing += "<dt><b>Returns:</b>\n<dd>" + implode(docs["return"], " ") +
                         "\n";
   }
   if (docs["see"]) {
      bing += "<dt><b>See also:</b>\n<dd>" +
                         query_multiple_short(
                         map(docs["see"], (: create_href($1) :)));
   }
   if (docs["example"]) {
      bing += "<dt><b>Example:</b>\n<dd><pre>" +
                 implode(docs["example"], "</pre><dd><pre>\n") +
                        "</pre>";
   }
   if (docs["param"] || docs["return"] || docs["see"] || docs["example"]) {
      bing += "</dl>\n";
   }
   return bing;
}
private string query_class_description(mapping docs) {
   int i;
   string name;
   string desc;
   string bing;
   bing = "";
   if (docs["main"]) {
      bing += "<dd>" + implode(docs["main"], " ")
                         +"<p>\n";
   }
   if (docs["member"] || docs["see"]) {
      bing += "<dl>\n";
   }
   if (docs["member"]) {
      bing += "<dt><b>Members:</b>\n";
      for (i = 0; i < sizeof(docs["member"]); i++) {
         if (sscanf(docs["member"][i], "%s %s", name, desc) == 2) {
            bing += "<dd>" + name + " - " +
                               (desc) + "\n";
         }
      }
   }
   if (docs["see"]) {
      bing += "<dt><b>See also:</b>\n<dd>" +
                         query_multiple_short(
                         map(docs["see"], (: create_href($1) :)));
   }
   if (docs["member"] || docs["see"]) {
      bing += "</dl>\n";
   }
   return bing;
}
private string create_href(string str) {
   string name;
   string ref_name;
   string func;
   if (sscanf(str, "%s#%s", name, func) == 2) {
      ref_name = replace(name, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      return "<a href=\"" + ref_name + ".c.html#" + func + "\">" +
             name + "->" + func + "()</a>";
   } else if (sscanf(str, "%s->%s", name, func) == 2) {
      sscanf(func, "%s(%*s)", func);
      ref_name = replace(name, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      return "<a href=\"" + ref_name + ".c.html#" + func + "\">" + str + "</a>";
   } else if (sscanf(str, "%s()", func) == 1) {
      return "<a href=\"#" + func + "\">" + str + "</a>";
   } else if (str[0..4] == "http:") {
      return "<a href=\"" + str + "\">" + str + "</a>";
   } else {
      ref_name = replace(str, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      if (sscanf(str, "%*s.%*s") != 2) {
         ref_name += ".c";
         str += ".c";
      }
      if (member_array(str, AUTODOC_HANDLER->query_files()) != -1) {
         return "<a href=\"" + ref_name + ".html\">" + str + "</a>";
      }
      return str;
   }
}
private string query_short_args_def(mixed *args) {
   string ret;
   int i;
   ret = "";
   for (i = 0; i < sizeof(args); i += 2) {
      if (i != 0) {
         ret += ", ";
      }
      ret += implode(args[i + AUTO_ARGS_TYPE], " ");
   }
   return "(" + ret + ")";
}
private string query_short_desc(mapping docs) {
   mixed main;
   int pos;
   int tmp_pos;
   main = docs["main"];
   if (!main) {
      return 0;
   }
   main = implode(main, " ");
   pos = strlen(main);
   tmp_pos = strsrch(main, ".");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   tmp_pos = strsrch(main, "?");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   tmp_pos = strsrch(main, "!");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   return main[0..pos];
}
private string query_class_summary(mapping classes) {
   string *names;
   string name;
   string short_desc;
   string bing;
   names = sort_array(keys(classes), (: strcasecmp :));
   bing = "<hr><h2>Class Index</h2>\n";
   bing += "<dl>";
   foreach (name in names) {
      bing += "<dt><img src=\"images/cyan-ball-small.gif\" "
                         "height=6 width=6 alt=\" o \">\n";
      bing += "<a href=\"#class_" + name + "\"><b>" + name +
                         "</b></a>\n";
      short_desc = query_short_desc(classes[name][AUTO_CLASS_DOCS]);
      if (short_desc) {
         bing += "<dd>" + short_desc + "\n";
      }
   }
   bing += "</dl>";
   return bing;
}
private string query_method_summary(string *funcs,
                                  object file) {
   int i;
   mixed *stuff;
   string short_desc;
   int prot;
   string bing;
   bing = "";
   if (sizeof(funcs)) {
      bing += "<hr><h2>Method index</h2>\n<dl>";
      funcs = sort_array(funcs, (: strcasecmp :) );
      for (i = 0; i < sizeof(funcs); i++) {
         if (file->query_public_functions()[funcs[i]]) {
            stuff = file->query_public_functions()[funcs[i]];
            prot = 0;
         } else if (file->query_protected_functions()[funcs[i]]) {
            stuff = file->query_protected_functions()[funcs[i]];
            prot = 1;
         }
         if (prot) {
           bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                              "height=6 width=6 alt=\" o \">\n";
         } else {
           bing += "<dt><img src=\"images/cyan-ball-small.gif\" "
                              "height=6 width=6 alt=\" o \">\n";
         }
         bing += "<a href=\"#" + funcs[i] + "\"><b>" + funcs[i] +
                            "</b></a>" + query_short_args_def(stuff[AUTO_ARGS])
;
         short_desc = query_short_desc(stuff[AUTO_DOCS]);
         if (short_desc) {
            bing += "<dd>" + short_desc + "\n";
         }
      }
      bing += "</dl>";
   }
   return bing;
}
private string query_defines(string *defs, mapping docs) {
   int i;
   string bing;
   bing = "";
   for (i = 0; i < sizeof(defs); i++) {
      bing +=  "<dt><a name=\"" + defs[i] + "\">\n";
      bing += "<img src=\"images/red-ball.gif\" width=12 "
                         "height=12 alt=\" * \"><b>" + defs[i] + "</b></a>\n";
      if (docs[defs[i]]["main"]) {
         bing += query_method_description(docs[defs[i]]);
      }
   }
   return bing;
}

==================================================
FILE: handlers/autodoc/autodoc_nroff.c
==================================================

#include <autodoc.h>
private void write_single_description(string func, mixed *stuff,
                                      string output, string fn);
private string query_methods(string *funcs, function data,
                           string base_single, string fn);
private string query_func_def(mixed *stuff, string func);
private string query_method_description(mapping docs);
private string parse_string(string inp);
string convert_html(string text, int depth, int preformat, int edge_width);
private string query_defines(mapping defines);
private string query_class_def(mixed *stuff, string name);
private string query_class_description(mapping docs);
private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn);
private string query_classes(string base_single,
                           mapping classes,
                           string fn);
void create() {
   seteuid(getuid());
}
void create_nroff_file(object file, string output) {
   mapping stuff;
   string *funcs;
   string *bits;
   string name;
   string base_single;
   string *files;
   string ret;
   int pos;
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   ret = "";
   ret += ".DT\n";
   ret += name + "\n" + mud_name() + " autodoc help\n" + name + "\n\n";
   stuff = file->query_main_docs();
   if (stuff["main"]) {
      ret += ".SH Description\n";
      ret += convert_html(implode(stuff["main"], " "), 5, 0, 5);
      ret += ".SP 10 5\n";
      if (stuff["author"]) {
         ret += "\n\nWritten by " +
                    parse_string(query_multiple_short(stuff["author"]));
      }
      if (stuff["started"]) {
         ret += "\n\nStarted " +
                    parse_string(query_multiple_short(stuff["started"]));
      }
      ret += "\n.EP\n\n";
      if (stuff["see"]) {
         ret += "\n\n.SH See also\n.SP 5 5\n" +
                            query_multiple_short(stuff["see"]) + "\n.EP\n";
      }
      if (stuff["changed"]) {
         ret += ".SH Change history\n.SP 5 5\n" +
                            parse_string(implode(stuff["changed"], "\n\n")) +
                            "\n.EP\n\n";
      }
      if (stuff["example"]) {
        ret += ".SH Example\n.SI 5\n" +
               parse_string(implode(stuff["example"], "\n")) + "\n.EI\n";
      }
   }
   if (sizeof(file->query_inherits())) {
      ret += ".SH Inherits\n.SP 5 5\n";
      ret += "This class inherits the following classes " +
                         query_multiple_short(keys(file->query_inherits())) +
                         ".\n.EP\n\n";
   }
   if (sizeof(file->query_includes())) {
      ret += ".SH Includes\n.SP 5 5\n";
      ret += "This class includes the following files " +
                         query_multiple_short(file->query_includes()) +
                         ".\n.EP\n\n";
   }
   funcs = filter(keys(file->query_public_functions()),
                  (: $1 != "create" && $1 != "setup" &&
                   !$(file)->query_public_functions()[$1][AUTO_DOCS]["ignore"] :));
   base_single = file->query_file_name();
   pos = strsrch(base_single, ".", -1);
   if (pos > 0) {
      base_single = base_single[0..pos-1];
   }
   base_single = NROFF_DOC_SINGLE + base_single + "/";
   files = get_dir(base_single + "*");
   if (pointerp(files)) {
      foreach (name in files) {
         if (file_size(base_single + name) >= 0) {
            rm(base_single + name);
         }
      }
   }
   if (sizeof(file->query_class_docs())) {
      ret += ".SH Classes\n\n";
      ret += query_classes(base_single,
                    file->query_class_docs(),
                    file->query_file_name());
      ret += "\n";
   }
   if (sizeof(funcs)) {
      ret += ".SH Public Functions\n" +
                         ".SP 5 5\nThese are functions that everyone can "
                         "access.\n.EP\n\n";
      ret += query_methods(funcs,
                    (: $(file)->query_public_functions()[$1] :),
                    base_single,
                    file->query_file_name());
      ret += "\n";
   }
   funcs = filter(keys(file->query_protected_functions()),
                  (: !$(file)->query_protected_functions()[$1][AUTO_DOCS]["ignore"] :));
   if (sizeof(funcs)) {
      ret += ".SH Protected Functions\n"
                         ".SP 5 5\nThese are functions that only "
                         "objects inheriting the class can access.\n.EP\n\n";
      ret += query_methods(funcs, (: $(file)->query_protected_functions()[$1] :),
                    base_single, file->query_file_name());
      ret += "\n";
   }
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   if (sscanf(name, "%*s.h") == 1 &&
       sizeof(file->query_define_docs())) {
      ret += ".SH Defines\n";
      ret += query_defines(file->query_define_docs());
      ret += "";
   }
   write_file(output, ret);
}
private string query_defines(mapping docs) {
   string name;
   string *names;
   string ret;
   names = sort_array(keys(docs), (: strcasecmp :));
   ret = "";
   foreach (name in names) {
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n" +
                         ".EI\n";
      if (docs[name]["main"]) {
         ret += query_method_description(docs[name]);
      }
      ret += "\n";
   }
   return ret;
}
private string query_classes(string base_single,
                           mapping classes,
                           string fn) {
   string name;
   string *names;
   string ret;
   names = sort_array(keys(classes), (: strcasecmp :) );
   ret = "";
   foreach (name in names) {
      reset_eval_cost();
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n";
      ret += query_class_def(classes[name], name) + "\n.EI\n";
      if (classes[name][AUTO_CLASS_DOCS]["main"]) {
         ret += query_class_description(classes[name][AUTO_CLASS_DOCS]);
         write_single_class_description(name,
                                        classes[name],
                                        base_single + name,
                                        fn);
      }
      ret += "\n";
   }
   return ret;
}
private string query_methods(string *funcs,
                           function data,
                           string base_single,
                           string fn) {
   int i;
   mixed *stuff;
   string ret;
   funcs = sort_array(funcs, (: strcmp($1, $2) :));
   ret = "";
   for (i = 0; i < sizeof(funcs); i++) {
      stuff = evaluate(data, funcs[i]);
      ret += ".SI 3\n* %^BOLD%^" + funcs[i] + "%^RESET%^\n" +
                         ".EI\n.SI 5\n" + query_func_def(stuff, funcs[i]) +
                         "\n.EI\n";
      if (stuff[AUTO_DOCS]["main"]) {
         ret += query_method_description(stuff[AUTO_DOCS]);
         write_single_description(funcs[i], stuff, base_single + funcs[i], fn);
      }
      ret += "\n";
   }
   return ret;
}
private string query_class_def(mixed *stuff, string name) {
   string ret;
   int pad;
   int i;
   ret = "class " + name + " {\n";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_CLASS_MEMBERS]); i++) {
      ret += sprintf("%-" + pad + "s", "");
      ret += implode(stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_TYPE], " ") +
             " " + stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_NAME] + ";\n";
   }
   ret += "}\n";
   return ret;
}
private string query_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += ", ";
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_long_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   int pad;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += sprintf(",\n%-"+pad+"s", "");
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_class_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;
   ret = "";
   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }
   if (docs["member"]) {
      ret += ".SI 7\n%^BOLD%^Members:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["member"]); i++) {
         if (sscanf(docs["member"][i], "%s %s", name, desc) == 2) {
            ret +=  ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }
   return ret;
}
private string query_method_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;
   ret = "";
   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }
   if (docs["param"]) {
      ret += ".SI 7\n%^BOLD%^Parameters:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["param"]); i++) {
         if (sscanf(docs["param"][i], "%s %s", name, desc) == 2) {
            ret += ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }
   if (docs["return"]) {
      ret +=".SI 7\n%^BOLD%^Returns:%^RESET%^\n.EI\n.SP 9 5\n" +
                         parse_string(implode(docs["return"], " ")) +
                         "\n.EP\n";
   }
   return ret;
}
private void write_single_description(string func, mixed *stuff,
                                      string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;
   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }
   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret += ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Syntax\n.SI 5\n" + query_long_func_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["param"]) {
      ret += ".SH Parameters\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["param"]); i++) {
         if (sscanf(fluff["param"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }
   if (fluff["return"]) {
      ret += ".SH Returns\n.SI 5\n";
      ret += implode(fluff["return"], " ");
      ret += ".EI\n\n";
   }
   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }
   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
}
private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;
   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }
   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret +=  ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Definition\n.SI 5\n" +
              query_class_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["member"]) {
      ret += ".SH Members\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["member"]); i++) {
         if (sscanf(fluff["member"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }
   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }
   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
}
private string parse_string(string str) {
   return replace(str, ({ "<p>", "\n\n", "<br>", "\n\n",
                          "<b>", "%^BOLD%^", "</b>", "%^RESET%^",
                          "<i>", "%^CYAN%^", "</i>", "%^RESET%^",
                          "<pre>", "\n\n", "</pre>", "\n\n" }));
}
#define LIST_NONE 0
#define LIST_DYNAMIC 1
#define LIST_ORDERED 2
#define LIST_UNORDERED 3
#define LIST_TYPE 0
#define LIST_DEPTH 1
#define LIST_START 2
#define LIST_ADDITIONAL 3
#define LIST_NUM 4
string convert_html(string text, int depth, int preformat, int edge_width) {
   string ret;
   string *bits;
   mixed *lists;
   string* before_centers;
   string start;
   string new_start;
   string additional;
   string add;
   int i;
   string tag;
   string rest;
   ret = "";
   if (text[0] == '.') {
      text = " " + text;
   }
   bits = explode("#" + text, "<");
   bits[0] = bits[0][1..];
   start = ".SP " + depth + " " + edge_width;
   ret = start + "\n" + bits[0];
   additional = "";
   lists = ({ ({ LIST_NONE, depth, start, additional }) });
   before_centers = ({ });
   for (i = 1; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%s>%s", tag, rest) == 2) {
            new_start = start;
            add = 0;
            switch (lower_case(tag)) {
               case "p" :
                  ret += "\n\n" + additional;
                  break;
               case "br" :
                  ret += "\n.E" + start[2..2] + "\n" + start + "\n" + additional;
                  break;
               case "dl" :
                  lists += ({ ({ LIST_DYNAMIC, depth, start, additional }) });
                  break;
               case "/dl" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "u" :
                  ret += "_";
                  break;
               case "/u" :
                  ret += "_";
                  break;
               case "center" :
                  before_centers += ({ start });
                  new_start = ".SC";
                  break;
               case "/center" :
                  new_start = before_centers[<1];
                  before_centers = before_centers[0..<2];
                  break;
               case "ol" :
                  lists += ({ ({ LIST_ORDERED, depth, start, additional, 1 }) });
                  break;
               case "/ol" :
                  if (lists[<1][LIST_TYPE] == LIST_ORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "ul" :
                  lists += ({ ({ LIST_UNORDERED, depth, start, additional }) });
                  break;
               case "/ul" :
                  if (lists[<1][LIST_TYPE] == LIST_UNORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "dd" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 3) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 3;
                     start = start[0..3];
                     additional = "";
                  }
                  break;
               case "dt" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 0) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 0;
                     start = start[0..3];
                     additional = "";
                  }
                  break;
               case "li" :
                  if (lists[<1][LIST_TYPE] != LIST_DYNAMIC) {
                     switch (lists[<1][LIST_TYPE]) {
                        case LIST_ORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 3 -" + (6 + lists[<1][LIST_DEPTH]);
                           add = "\n\t" + (lists[<1][LIST_NUM]++) + ". \t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                        case LIST_UNORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 2 -" + (5 + lists[<1][LIST_DEPTH]);
                           add = "\n\t*\t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                     }
                  }
                  break;
               case "pre" :
                  preformat++;
                  break;
               case "b" :
                  ret += "%^BOLD%^";
                  break;
               case "i" :
                  ret += "%^CYAN%^";
                  break;
               case "/b" :
               case "/i" :
                  ret += "%^RESET%^";
                  break;
               case "/pre" :
                  preformat--;
                  break;
               case "code" :
               case "/code" :
                  break;
               default :
                  rest = "<" + tag + ">" + rest;
                  break;
            }
            if (new_start != start) {
               ret += "\n.E" + start[2..2] + "\n" + new_start + "\n";
               start = new_start;
            }
            if (add) {
               ret += add;
            }
            if (preformat) {
               ret += replace(rest, "\n", "\n.E" + start[2..2] + "\n" +
                                    start + "\n" + additional);
            } else {
               rest = replace(rest, "\n", " ");
               while (strlen(rest) && rest[0] == ' ') {
                  rest = rest[1..];
               }
               while (strsrch(rest, "  ") != -1) {
                  rest = replace_string(rest, "  ", " ");
               }
               ret += rest;
            }
         } else {
            ret += ">" + bits[i];
         }
   }
   ret += "\n.E" + start[2..2] + "\n";
   return ret;
}

==================================================
FILE: rings/high_gp_ring.c
==================================================

#define GP_AWARD 250
inherit "/obj/ring";
void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 750 );
    set_value_info( "artifact", 15000 );
    set_weight( 1 );
    set_enchant( 5 );
    add_property( "artifact form", ([
        "ring of power" : 6
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 75 );
    set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of power"; }
void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
}
int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
}

==================================================
FILE: rings/invisibility.c
==================================================

inherit "/obj/ring";
void setup() {
   set_name( "ring" );
   set_short( "clear crystal ring" );
   add_adjective( ({ "clear", "crystal" }) );
   set_main_plural( "clear crystal rings" );
   set_long( "The ring is made from a colourless stone that seems to refract "+
         "light in a strange way.  The outer edge has eight sides.\n" );
   set_material( "calcite" );
   set_value( 200 );
   set_value_info( "artifact", 5000 );
   set_weight( 1 );
   set_enchant( 2 );
   add_property( "no recycling", 1 );
   add_property( "fluff'n'stuff", 1 );
   add_property( "artifact form", ([
      "ring of invisibility" : 2
   ]) );
   adjust_charges( 1 + random( 7 ) );
   set_level( 60 );
   set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of invisibility"; }
void zap( object dummy, object person, object ring ) {
   person->add_effect( "/std/effects/magic/invisibility",
         roll_MdN( 7, (int)ring->query_level() ) );
}

==================================================
FILE: rings/low_gp_ring.c
==================================================

#define GP_AWARD 50
inherit "/obj/ring";
void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 250 );
    set_value_info( "artifact", 5000 );
    set_weight( 1 );
    set_enchant( 3 );
    add_property( "artifact form", ([
        "ring of energy" : 4
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 25 );
    set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of energy"; }
void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
}
int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
}

==================================================
FILE: rings/med_gp_ring.c
==================================================

#define GP_AWARD 150
inherit "/obj/ring";
void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 500 );
    set_value_info( "artifact", 10000 );
    set_weight( 1 );
    set_enchant( 4 );
    add_property( "artifact form", ([
        "ring of vigour" : 5
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 50 );
    set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of vigour"; }
void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
}
int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
}

==================================================
FILE: rings/recall.c
==================================================

#include <drinks.h>
#include <cwc.h>
#include <config.h>
inherit "/obj/ring";
void setup() {
  set_name( "ring" );
  set_short( "blue crystal ring" );
  add_adjective( ({ "blue", "crystal" }) );
  set_main_plural( "blue crystal rings" );
  set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
  set_material( "sapphire" );
  set_value( 500 );
  set_value_info( "artifact", 10000 );
  set_weight( 1 );
  set_enchant( 3 );
  add_property( "artifact form", ([
    "ring of recall" : 3
  ]) );
  adjust_charges( 1 + random( 11 ) );
  set_level( 30 );
  set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of recall"; }
string find_start_location( object person ) {
    string pos;
    if ( file_name( environment( person ) )[0..19] == "/d/cwc/Bes_Pelargic/" ) {
        return CWC_START_LOCATION;
    }
    pos = person->query_start_pos();
    if ( pos[ 0..19 ] == "/d/cwc/Bes_Pelargic/" && file_name( environment( person ) )[ 0..19 ] != "/d/cwc/Bes_Pelargic/" ) {
        return CONFIG_START_LOCATION;
    }
    return pos;
}
void zap( object dummy, object person, object ring ) {
   string place;
   place = query_property( "destination" );
   if ( !place ) {
      call_out( "move_person", 0, person, find_start_location( person ) );
   }
   else {
      call_out( "move_person", 0, person, place );
   }
}
int failed_zap( object dummy, object person, object ring ) {
  person->add_succeeded_mess( ring, "$N $V $D, but nothing happens.\n", ({ }) );
  return 1;
}
void move_person( object person, string place ) {
  tell_creator( "taffyd", "%O, %s\n", person, place );
  if ( !find_object( place ) )
    place->force_load();
  if ( !find_object( place ) ) {
    tell_object( person, "Please contact a creator and ask that \""+ place +
        "\" be checked.  You are also owed a charge on this ring.\n" );
    return;
  }
  if ( environment( person ) == find_object( place ) ) {
    tell_object( person, "You momentarily feel dislocated from reality; "+
        "the feeling passes, but something has changed...\n" );
    person->adjust_volume( D_ALCOHOL, ( 500 + random( 500 ) ) * ( 1 -
        2 * random( 2 ) ) );
    return;
  }
  tell_object( person, "You suddenly feel as if something yanks you "+
      "across the dimensions.\n" );
  person->move_with_look( place, "A spot of blue appears, enlarges and "+
      "turns into $N.", "$N shrinks and becomes red, then disappears "+
      "altogether." );
}

==================================================
FILE: plants/inherit/grain.c
==================================================

#include <move_failures.h>
#include <state_change.h>
#define TO this_object()
#define TP this_player()
#define THRESHOLD 5
inherit "/obj/food";
int _max_strip;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_name( "grain" );
  set_short( "broken grain" );
  set_long( "This is some funky, but broken, grain.\n" );
  _max_strip = THRESHOLD;
  remove_help_file( "food" );
  add_help_file( "grain" );
  add_alias( "plant" );
  add_plural( "plants" );
  set_collective();
  set_amount( 1 );
  set_weight_unit( ({ 1, 10 }) );
  set_eat_mess( ({
    "$N choke down $D. It absorbs all the moisture from your mouth and sticks "
      "in your throat.  Looks like you just aren't designed to eat unmilled "
      "grain.\n",
    "$N chokes down $D, coughing and rubbing $p throat unhappily.\n"
  }) );
  if ( ! do_setup ) {
    TO->setup();
    TO->reset();
  }
}
void init() {
  ::init();
  TP->add_command( "chew", TO );
  TP->add_command( "strip", TO );
}
void set_max_strippable( int num ) {
  _max_strip = num;
}
int query_max_strippable() {
  return _max_strip;
}
int do_chew() {
  int size;
  size = query_amount();
  if ( ! size ) {
    add_failed_mess( "You can't chew thin air.\n" );
    return 0;
  }
  if ( size > 1 ) {
    add_failed_mess( "You can't chew more than one " + short(0)
      + " at a time.\n" );
    return 0;
  }
  TP->set_position( "idly chewing " + TO->a_short() );
  add_succeeded_mess(
    "$N place$s $D between $p teeth, and chew$s it idly.\n" );
  return 1;
}
int do_strip() {
  int i;
  object stripped;
  if ( query_amount() > query_max_strippable() ) {
    add_failed_mess( "That's far too much $D for you to strip by hand.  "
      "Perhaps you should look for a tool of some kind.\n" );
    return 0;
  }
  stripped = STATE_CHANGE->transform( TO, "thresh" );
  if ( ! objectp( stripped ) ) {
    add_failed_mess( "For some reason, you can't strip $D.\n" );
    return 0;
  }
  i = stripped->move( TP );
  if ( i != MOVE_OK ) {
    stripped->move( environment( TP ) );
    add_succeeded_mess( "$N strip$s the grain from $D with $p fingers, "
      "spilling some onto the "
      + ( environment( TP )->query_property( "location" ) == "inside" ? "floor"
      : "ground" ) + ".\n" );
  } else {
    add_succeeded_mess( "$N strip$s the grain from $D with $p fingers.\n" );
  }
  move( "/room/rubbish" );
  return 1;
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}

==================================================
FILE: gatherables/handler.dat_dc.c
==================================================

class item_data {
    string skill;
    int    difficulty;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
class item_data item;
mapping data = ([ ]);
mixed data_return_0() {
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/sage.ob";
  data["sage"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/parsley.ob";
  data["parsley"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/basil.ob";
  data["basil"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/rosemary.ob";
  data["rosemary"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/eyebright.ob";
  data["eyebright"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: 15 + random( 15 ) :);
  item->ob = "/obj/plants/fennel_seed.ob";
  data["fennel seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: 15 + random( 15 ) :);
  item->ob = "/obj/plants/oregano.ob";
  data["oregano"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(4) + 2 :);
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/thyme.ob";
  data["thyme"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/foxglove.ob";
  data["foxglove"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/violet.ob";
  data["violets"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/convolvus.ob";
  data["convolvus"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/obj/food/fruits/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/obj/food/fruits/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/fruits/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/obj/food/fruits/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/obj/food/fruits/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/obj/food/fruits/ogg_apple.food";
  data["Gytha Ogg apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/cabbage.food";
  data["cabbage"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/dirty_potato.food";
  data["potato"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/tomato.food";
  data["tomato"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/small_radish.food";
  data["small radish"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/celery.food";
  data["celery"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/carrot.food";
  data["carrot"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/small_onion.food";
  data["small onion"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/lettuce.food";
  data["lettuce"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/rhubarb.food";
  data["rhubarb"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/vegetables/parsnip.food";
  data["parsnip"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/foxglove.ob";
  data["foxglove"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/bryony.ob";
  data["bryony"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/wormwood.ob";
  data["wormwood"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/monkshood.ob";
  data["monkshood"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/hemlock.ob";
  data["hemlock"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/belladonna.ob";
  data["belladonna"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/hellebore.ob";
  data["hellebore"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/cereus.ob";
  data["cereus"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/clematis.ob";
  data["clematis"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/skullcap.ob";
  data["skullcap"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/angels_trumpet.ob";
  data["angel's trumpet"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 120;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/achorion.ob";
  data["achorion mould"] = item;
  item = new( class item_data );
  item->skill = "crafts.hunting.foraging";
  item->difficulty = 100;
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/tyler_weed.ob";
  data["tyler weed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wheat.ob";
  data["wheat"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/spices/m_garlic.food";
  data["garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random( 3 ) + 3 :);
  item->ob = "/obj/plants/delphinium.ob";
  data["delphinium"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/fruits/jelly_orange.food";
  data["jelly orange"] = item;
}
mixed data_return() {
  data_return_0();
  return data;
}

==================================================
FILE: gatherables/handler.dat_old.c
==================================================

class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}
class item_data {
    string skill;
    int    difficulty;
    int    upper;
    mixed  extra;
    string *season;
    mixed  quant;
    string ob;
}
void dest_me() { destruct( this_object() ); }
mixed data_return() {
  class item_data item;
  mapping data = ([ ]);
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/floppy_madman.ob";
  data["floppy madman"] = item;
  item = new( class item_data );
  item->skill = "";
  item->difficulty = 0;
  item->upper = 0;
  item->extra = 0;
  item->season = ({ "spring", "summer" });
  item->quant = (: random(4) + 5 :);
  item->ob = "/obj/plants/pink_clover.ob";
  data["pink clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring" });
  item->quant = (: random(2) + 3 :);
  item->ob = "/std/plant";
  data["white clover"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn" });
  item->quant = (: random(6) + 20 :);
  item->ob = "/obj/plants/grass.ob";
  data["green grass"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/yarrow.ob";
  data["yarrow"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/comfrey.ob";
  data["comfrey"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/plants/ivy_seed.ob";
  data["ivy seeds"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/stinking_mayweed.ob";
  data["stinking mayweed"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/klatchian_fleabane.ob";
  data["Klatchian fleabane"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(3) + 3 :);
  item->ob = "/obj/plants/wild_garlic.ob";
  data["wild garlic"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+3 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/golden_disagreeable.food";
  data["Golden Disagreeable apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+2 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/blackheart_apple.food";
  data["Lancre Blackheart apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/green_billet.food";
  data["Green Billet apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/peachface_apple.food";
  data["Blackglass Peachface apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = (: random(1)+1 :);
  item->ob = "/d/ram/Lancre_Kingdom/Blackglass/apples/gammer_smith.food";
  data["Gammer Smith apple"] = item;
  item = new( class item_data );
  item->season = ({ "spring", "summer", "autumn", "winter" });
  item->quant = 1;
  item->ob = "/obj/food/cabbage.food";
  data["cabbage"] = item;
  return data;
}

==================================================
FILE: gatherables/plant.c
==================================================

inherit "/obj/gatherable";
void setup() {
    set_name("plant");
    set_short("hidden plant");
    set_long("There are all sorts of herbs and flowers here.  Use "
             "\"gather\" to collect specific types.\n");
    set_get_failure_mess("There are all sorts of flowers and herbs "
                         "around here.  Use \"gather\" to get "
                         "specific varieties.\n");
}

==================================================
FILE: gatherables/rock.c
==================================================

inherit "/obj/gatherable";
void setup() {
    set_name("rock");
    set_short("hidden rock");
    set_long("There are rocks of all shapes and sizes here.  Use "
             "\"gather\" to collect specific types.\n");
    set_get_failure_mess("There are all sorts of rocks and minerals "
                         "around here.  Use \"gather\" to get "
                         "specific varieties.\n");
}

==================================================
FILE: misc/abscond_trigger.c
==================================================

#define CLASS "fighting.combat.special.abscond"
#include <effect.h>
inherit "/std/object";
void init() {
   if( !environment()
    || file_name( environment( this_object() ) ) == "/room/rubbish" ) {
      return;
   }
   if( this_player()
    && this_player() == query_property( "abscond player" ) ) {
      this_player()->submit_ee2( this_player()->effects_matching(CLASS)[0],
                                 "after_command", 0, EE_REMOVE );
   }
}

==================================================
FILE: misc/active_toy.c
==================================================

inherit "/std/object";
inherit "/std/basic/item_chat";
string hug, pet, cuddle, fondle, snuggle, squeeze, spank;
void set_hug( string words ) { hug = words; }
void set_pet( string words ) { pet = words; }
void set_cuddle( string words ) { cuddle = words; }
void set_fondle( string words ) { fondle = words; }
void set_snuggle( string words ) { snuggle = words; }
void set_squeeze( string words ) { squeeze = words; }
void set_spank( string words ) { spank = words; }
void init() {
   item_chat::init();
   this_player()->add_command( "hug", this_object() );
   this_player()->add_command( "pet", this_object() );
   this_player()->add_command( "cuddle", this_object() );
   this_player()->add_command( "fondle", this_object() );
   this_player()->add_command( "snuggle", this_object() );
   this_player()->add_command( "squeeze", this_object() );
   this_player()->add_command( "spank", this_object() );
}
int do_hug() {
  if (!sizeof (hug)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( hug,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_pet() {
  if (!sizeof (pet)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( pet,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_cuddle() {
  if (!sizeof (cuddle)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( cuddle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_fondle() {
  if (!sizeof (fondle)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( fondle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_snuggle() {
  if (!sizeof (snuggle)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( snuggle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_squeeze() {
  if (!sizeof (squeeze)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( squeeze,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_spank() {
  if (!sizeof (spank)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( spank,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
mapping query_static_auto_load() {
   return ([
      "::" : int_query_static_auto_load(),
      "hug" : hug,
      "pet" : pet,
      "cuddle" : cuddle,
      "fondle" : fondle,
      "snuggle" : snuggle,
      "squeeze" : squeeze,
      "spank" : spank
   ]);
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "::" : object::query_dynamic_auto_load(),
            "chat" : item_chat::query_dynamic_auto_load(),
          ]);
   return tmp;
}
void init_dynamic_arg(mapping map) {
   if ( !map )
      return;
   if (map["::"])
      object::init_dynamic_arg(map["::"]);
   if (map["chat"])
      item_chat::init_dynamic_arg(map["chat"]);
}
void init_static_arg( mapping map ) {
   if ( !map )
      return;
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   hug = map[ "hug" ];
   pet = map[ "pet" ];
   cuddle = map[ "cuddle" ];
   fondle = map[ "fondle" ];
   snuggle = map[ "snuggle" ];
   squeeze = map[ "squeeze" ];
   spank = map[ "spank" ];
}

==================================================
FILE: misc/al_receipt.c
==================================================

#include <virtual.h>
#include <player.h>
#include <move_failures.h>
#include <armoury.h>
inherit "/std/object";
private int _timestamp;
private string _obname;
private string _obpath;
private string _virt_name;
private mixed _static_save;
void setup()
{
   set_name("receipt");
   set_short( "missing item receipt" );
   _obname = "unknown object";
   _obpath = "***";
   set_value(5);
   set_weight(1);
   add_adjective(({"missing", "item"}));
   add_property("writeable", 1);
   add_property("sale_value", 1);
   add_property("paper", 1);
   add_property("nosteal", 1);
   set_max_size(1000);
   _timestamp = time();
}
void init() {
    this_player()->add_command("kiss", this_object());
}
void set_obname(string s) { _obname = s; }
void set_object(string s) { _obpath = s; }
void set_obpath(string s) { set_object(s); }
void set_virtobname(string s) { _virt_name = s; }
void set_virtname(string s) { set_virtobname(s); }
void set_static_save(mixed m) {
  mixed p;
  _static_save = m;
  if (_obname != "unknown object") {
    return;
  }
  p = m[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}
void setup_receipt(object ob) {
   mixed* bits;
   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_object(bits[1]);
   set_static_save(bits[2]);
   set_value(ob->query_value());
   if(_obpath == "/obj/misc/al_receipt") {
     log_file("BAD_RECEIPTS", "%s: set by %s\n",
              ctime(time())[4..18], base_name(previous_object()));
     call_out("dest_me", 2);
   }
}
void being_sold()
{
    call_out("dest_me", 4);
}
string long(string str, int light)
{
   return "This is a receipt for your missing " + _obname + ".  You can either "
      "sell it for something which may be close to replacement value (and may
not), "
      "or give it to a creator and ask very nicely to have it replaced.\n"
      "You can also try kissing it - who knows, you may get lucky.\n";
}
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "obname" : _obname,
             "obpath" : _obpath,
             "obvalue" : value,
             "virt" : _virt_name,
             "timestamp" : _timestamp,
             "static" : _static_save ]);
}
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
      add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   ::init_dynamic_arg(arg["::"]);
   if(_obpath == "/obj/misc/al_receipt") {
     call_out("dest_me", 2);
   }
}
string query_obname() { return _obname; }
string query_obpath() { return _obpath; }
int query_timestamp() { return _timestamp; }
string query_virt_obname() { return _virt_name; }
mixed query_static_save() { return _static_save; }
int query_missing_item_receipt() {
   return 1;
}
mixed *stats()
{
  mixed *stuff;
  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
  return stuff;
}
int do_kiss() {
    object thing;
    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 1;
    }
    if ((query_cloned_by() != this_player()->query_name())
        && !this_player()->query_creator()) {
        write("The receipt whispers: I don't belong to you!\n");
        return 1;
    }
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 1;
       }
    }
    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            if (!thing->move( environment(this_object()) )
                || !thing->move( environment(environment(this_object())) )) {
                thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
                write(the_short() + " suddenly transforms itself into " +
                      thing->a_short() + ".\n");
                tell_room(environment(this_player()),
                          this_player()->the_short() +
                          " kisses a piece of paper, which suddenly "
                          "transforms into " + thing->a_short() + ".\n",
                          ({ this_player() }));
                this_player()->add_succeeded_mess(this_object(), "", ({ }));
                move("/room/rubbish");
            } else {
                write("The receipt whispers: I'm going to need some "
                      "creator help.\n");
                thing->dest_me();
            }
        } else {
            write("The receipt whispers: Sorry, I'm still broken.  "
                  "Try again some other time, or contact a creator.\n");
        }
    } else {
        write("The receipt whispers: Sorry, I'm still broken.  "
              "Try again some other time, or contact a creator.\n");
    }
    return 1;
}
varargs int move(mixed dest, string messin, string messout)  {
   if (!objectp(dest))  {
      if (!stringp(dest)  ||  (dest = find_object(dest)) == 0)  {
         return MOVE_EMPTY_DEST;
      }
   }
   if (::move(dest, messin, messout) != MOVE_OK)  {
      if (environment(dest))  {
         return move(environment(dest), messin, messout);
      }
      else  {
         return MOVE_INVALID_DEST;
      }
   }
   return MOVE_OK;
}

==================================================
FILE: misc/animusser.c
==================================================

#include <skills.h>
inherit "/std/object";
string *skill_names;
mapping new_skills, old_skills;
void setup() {
   set_name( "lever" );
   set_short( "blue lever" );
   add_adjective( "blue" );
   set_long( "This blue lever is apparently an animus recalculation "+
         "device.  You're not totally sure how you know this, but "+
         "there you are.  You could pull it to have your animus "+
         "recalculated, I suppose.\n" );
   reset_get();
   skill_names = ({ });
   new_skills = ([ ]);
   old_skills = ([ ]);
}
void init() {
   this_player()->add_command( "pull", this_object() );
}
int find_level( string skill ) {
   int i, sublevel, total;
   string *others;
   others = (string *)SKILL_OB->query_immediate_children( skill );
   if ( !sizeof( others ) )
      if ( undefinedp( old_skills[ skill ] ) )
         return (int)this_player()->query_skill( skill );
      else
         return old_skills[ skill ];
   for ( i = 0; i < sizeof( others ); i++ ) {
      sublevel = find_level( others[ i ] );
      total += sublevel;
      new_skills[ others[ i ] ] = sublevel;
      skill_names -= ({ others[ i ] });
   }
   return total / sizeof( others );
}
int do_pull() {
   int i, adjust;
   new_skills = ([ ]);
   old_skills = (mapping)this_player()->query_skills();
   skill_names = m_indices( old_skills );
   while ( sizeof( skill_names ) ) {
      new_skills[ skill_names[ 0 ] ] = find_level( skill_names[ 0 ] );
      skill_names = delete( skill_names, 0, 1 );
   }
   reset_eval_cost();
   skill_names = m_indices( old_skills );
   for ( i = 0; i < sizeof( skill_names ); i++ ) {
      adjust = new_skills[ skill_names[ i ] ] - old_skills[ skill_names[ i ] ];
      if ( adjust )
         write( "Adjusting "+ skill_names[ i ] +" by "+ adjust +".\n" );
   }
   this_player()->set_skills( new_skills + ([ ]) );
   return 1;
}

==================================================
FILE: misc/balance.c
==================================================

#include <library.h>
#define DEFAULT_PANS ([ \
  "left" : ([ ]), \
  "middle" : ([ \
  "very small" : ({ "1/9", 1 }), \
  "small" : ({ "1/3", 3 }), \
  "medium" : ({ "1", 9 }), \
  "large" : ({ "3", 27 }), \
  "very large" : ({ "9", 81 }) ]), \
  "right" : ([ ]) ])
inherit "/std/object";
private nosave int balance;
private nosave string *doing;
private nosave mapping pans;
void setup();
void init();
string *query_doing();
mapping query_pans();
string long( string words, int dark );
string pans_look();
void recalculate_balance();
int reset_weights();
string weight_string( int weight );
int weigh_something( object* obs );
int figure_it_out();
int move_a_specific_weight( string weight_size, string pan_to );
int move_a_weight( string weight_size, string pan_from, string pan_to );
void it_is_balanced( object person );
void setup() {
  set_name( "balance" );
  set_short( "weighing balance" );
  add_adjective( "weighing" );
  add_alias( ({ "pan", "pans", "weight", "weights" }) );
  set_weight( 200 );
  reset_get();
  doing = ({ });
  pans = DEFAULT_PANS;
}
void init() {
  add_command("weigh", "<indirect:object:me'thing(s)'> on <direct:object>",
    (:this_object()->weigh_something($1):));
  add_command("reset", "weights on balance", (: reset_weights() :));
  add_command("figure", "", (:this_object()->figure_it_out():));
  add_command("move",
          "<string'size'> weight to <string'position'> pan",
          (:this_object()->move_a_specific_weight($4[0], $4[1]):));
}
string *query_doing() { return doing; }
mapping query_pans() { return pans; }
string long( string words, int dark ) {
  int i, j;
  string long;
  string *bits;
  string *places;
  string *weights;
  if (!words) {
    words = "balance";
  }
  bits = explode( words, " " );
  switch ( bits[ sizeof( bits ) - 1 ] ) {
    case "balance" :
      return "This is a largish bronze balance, securely bolted in "
        "place.  The main part of the balance is a long arm which "
        "pivots at its centre.  There is a pan hanging from each "
        "end of the arm such that it will be level when the weights "
        "in the pans are equal.  A third pan is fixed to a stationary "
        "part of the balance where the weights can be held when not "
        "in use.\n" + pans_look() + "You could probably use the balance "
        "to weigh something.\nThere appears to be something "
        "written on it.\n";
    case "pan" :
    case "pans" :
      return "There are three pans.  One pan hangs from the left end of "
        "the arm, one from the right end and there is a third pan "
        "in the middle.\n"+ pans_look();
    case "weight" :
    case "weights" :
      long = "There are weights of many different sizes in the pans.  "
        "They are:\n";
      bits = ({ });
      places = m_indices( pans );
      for ( i = 0; i < sizeof( places ); i++ ) {
        if ( !m_sizeof( pans[ places[ i ] ] ) ) {
          continue;
        }
        weights = m_indices( pans[ places[ i ] ] );
        for ( j = 0; j < sizeof( weights ); j++ ) {
          if ( sizeof( doing ) ) {
            if ( doing[ 1 ] == weights[ j ] ) {
              continue;
            }
          }
          bits += ({ add_a( weights[ j ] ) + " weight marked with \""
            + pans[ places[ i ] ][ weights[ j ] ][ 0 ] +" lb\"" });
        }
      }
      long += "    " + implode( bits[ 0 .. sizeof( bits ) - 2 ],
        ",\n    " ) +",\n  and "+ bits[ sizeof( bits ) - 1 ] + ".\n";
      long += "The weights can be moved from one pan to another and "
        "reset back to their starting positions.\n";
      return long;
  }
  return "You're not quite sure what you're looking at.\n";
}
string pans_look() {
  int i;
  int j;
  string pans_status;
  string *places;
  string *weights;
  pans_status = "";
  places = m_indices( pans );
  for ( i = 0; i < sizeof( places ); i++ ) {
    pans_status += "The "+ places[ i ] +" pan ";
    if ( !m_sizeof( pans[ places[ i ] ] ) )
      pans_status += "is empty.\n";
    else {
      weights = m_indices( pans[ places[ i ] ] );
      for ( j = 0; j < sizeof( weights ); j++ )
        weights[ j ] = add_a( weights[ j ] ) +" weight";
      pans_status += "holds "+ query_multiple_short( weights ) +".\n";
    }
  }
  switch ( balance ) {
    case -1 :
      pans_status += "The left pan hangs lower than the right pan.\n";
      break;
    case 0 :
      pans_status += "The left pan hangs level with the right pan.\n";
      break;
    case 1 :
      pans_status += "The left pan hangs higher than the right pan.\n";
      break;
  }
  return pans_status;
}
void recalculate_balance() {
  int i;
  int j;
  int old_balance;
  string *places;
  string *weights;
  mapping pan_weights;
  pan_weights = ([ ]);
  places = m_indices( pans );
  for ( i = 0; i < sizeof( places ); i++ ) {
    pan_weights[ places[ i ] ] = 0;
    if ( !m_sizeof( pans[ places[ i ] ] ) ) {
      continue;
    }
    weights = m_indices( pans[ places[ i ] ] );
    for ( j = 0; j < sizeof( weights ); j++ ) {
      pan_weights[ places[ i ] ] +=
        pans[ places[ i ] ][ weights[ j ] ][ 1 ];
    }
  }
  old_balance = balance;
  if ( pan_weights[ "left" ] > pan_weights[ "right" ] ) {
    balance = -1;
  } else {
    if ( pan_weights[ "left" ] == pan_weights[ "right" ] ) {
      balance = 0;
    } else {
      balance = 1;
    }
  }
  if ( old_balance == balance ) {
    switch ( balance ) {
      case -1 :
        tell_room( environment(), "The arm rocks a bit but steadies, "
          "with the left pan still hanging lowest.\n" );
        break;
      case 1 :
        tell_room( environment(), "The arm rocks a bit but steadies, "
          "with the right pan still hanging lowest.\n" );
        break;
    }
    return;
  }
  switch ( balance ) {
    case -1 :
      tell_room( environment(), "The arm of the balance tips and the "
        "left pan ends up hanging lowest.\n" );
      break;
    case 0 :
      tell_room( environment(), "The arm of the balance levels out, "
        "with the left and right pans hanging level.\n" );
      break;
    case 1 :
      tell_room( environment(), "The arm of the balance tips and the "
        "right pan ends up hanging lowest.\n" );
      break;
  }
}
int reset_weights() {
  pans = DEFAULT_PANS;
  if (sizeof(doing)) {
    pans[ "left" ][ doing[ 1 ] ] = ({ "?", 1 + random( 121 ) });
  }
  add_succeeded_mess("$N $V the weights on $D.\n");
  recalculate_balance();
  return 1;
}
string weight_string( int weight ) {
  int wholes;
  int ninths;
  wholes = weight / 9;
  ninths = weight % 9;
  if ( wholes && ninths ) {
    return wholes + " " + ninths + "/9 lb";
  }
  if ( wholes ) {
    return wholes + " lb";
  }
  return ninths + "/9 lb";
}
int weigh_something( object* obs ) {
  int i;
  int info;
  int weight;
  object person;
  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( person == this_player() ) {
      add_failed_mess( "Hold your horses, you're trying to get the hang "
        "of it still.\n" );
      return 0;
    }
    if ( person && ( environment( person ) == environment() ) ) {
      add_failed_mess( (string)person->one_short() + " is using "
        "the balance at the moment.  Come back when "
        + (string)person->query_pronoun() + " has finished.\n" );
      return 0;
    }
    doing = ({ });
    pans = DEFAULT_PANS;
  }
  info = (int)LIBRARY->query_player_quest_info(
    (string)this_player()->query_name(), "balance" );
  switch ( info ) {
    case 0 :
      add_failed_mess( "You don't know how the balance works to weigh "
        "anything.\nTry looking at the balance, the pans and "
        "the weights, and then maybe you can figure it out.\n" );
      return 0;
    case 1 :
      add_failed_mess( "You're still not too sure how the balance works "
        "to weigh anything.\nTry looking at the balance, the pans and "
        "the weights, and then maybe you can figure it out.\n" );
      return 0;
    case 2 :
      add_failed_mess( "You're very nearly sure how the balance works, "
        "but maybe you should try to figure it out once more before "
        "you weigh anything.\n" );
      return 0;
  }
  for ( i = 0; i < sizeof( obs ); i++ ) {
    weight = obs[ i ]->query_complete_weight();
    if ( !weight ) {
      write( obs[ i ]->the_short() + " doesn't weigh anything.\n" );
      continue;
    }
    if ( weight > 121 ) {
      write( obs[ i ]->the_short() +
        " is heavier than all the weights available put together.\n" );
      continue;
    }
    write( obs[ i ]->the_short() +
      " weighs "+ weight_string( weight ) +".\n" );
  }
  add_succeeded_mess(({ "", "$N $V $I on $D.\n" }), obs);
  return 1;
}
int figure_it_out() {
  int info;
  object person;
  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( person == this_player() ) {
      notify_fail( "You're already engaged in figuring out how the "
        "balance can be used to weigh something.\n" );
      return 0;
    }
    if ( person && ( environment( person ) == environment() ) ) {
      notify_fail( (string)person->one_short() + " is using "
        "the balance at the moment.  Come back when "
        + (string)person->query_pronoun() + " has finished.\n" );
      return 0;
    }
    doing = ({ });
    pans = DEFAULT_PANS;
  }
  info = (int)LIBRARY->query_player_quest_info(
    (string)this_player()->query_name(), "balance" );
  if ( info > 2 ) {
    write( "You already know how the balance works.\n" );
    return 1;
  }
  doing = ({ (string)this_player()->query_name(), ({ "red", "green",
    "blue" })[ info ] });
  write( "You see " + add_a( doing[ 1 ] ) + " weight in the middle pan "
    "that you hadn't noticed before.  Maybe you could use this to "
    "experiment, so you place it in the left pan.\n" );
  say( (string)this_player()->one_short() + " moves "
    + add_a( doing[ 1 ] ) + " weight from the middle pan to the "
    "left pan.\n" );
  pans[ "left" ][ doing[ 1 ] ] = ({ "?", 1 + random( 121 ) });
  recalculate_balance();
  return 1;
}
int move_a_specific_weight( string weight_size, string pan_to ) {
  object person;
  string pan_from;
  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( !person ) {
      doing = ({ });
    } else {
      if ( person != this_player() ) {
        if ( environment( person ) == environment() ) {
          add_failed_mess( (string)person->one_short() + " is "
            "using the balance at the moment.  Come back when "
            + (string)person->query_pronoun() + " has finished.\n" );
          return 0;
        } else {
          doing = ({ });
          pans = DEFAULT_PANS;
        }
      }
    }
  }
  if ( !pans[ pan_to ] ) {
    add_failed_mess( "There is a left pan, a middle pan and a right pan, "
      "but no " + pan_to + " pan.\n" );
    return 0;
  }
  foreach (pan_from in keys(pans)) {
    if ( pans[ pan_from ][ weight_size ] ) {
      return move_a_weight(weight_size, pan_from, pan_to);
    }
  }
  add_failed_mess("Unable to find the " + weight_size + " weight.\n");
  return 0;
}
int move_a_weight( string weight_size, string pan_from, string pan_to ) {
  if ( pan_from == pan_to ) {
    add_failed_mess( "The " + weight_size + " weight is already in the "
      + pan_to + " pan.\n" );
    return 0;
  }
  if ( sizeof( doing ) ) {
    if ( weight_size == doing[ 1 ] ) {
      notify_fail( "You don't feel like moving the " + doing[ 1 ]
        + " weight since that's what you're trying to weigh.\n" );
      return 0;
    }
  }
  pans[ pan_to ][ weight_size ] = pans[ pan_from ][ weight_size ];
  pans[ pan_from ] = m_delete( pans[ pan_from ], weight_size );
  write( "You move the "+ weight_size +" weight from the "+ pan_from
    + " pan to the "+ pan_to + " pan.\n" );
  say( (string)this_player()->one_short() + " moves "
    + add_a( weight_size ) +" weight from the "+ pan_from + " pan "
    "of the balance to the " + pan_to + " pan.\n" );
  recalculate_balance();
  if ( sizeof( doing ) && !balance ) {
    call_out( "it_is_balanced", 0, this_player() );
  }
  return 1;
}
void it_is_balanced( object person ) {
  int info;
  tell_object( person, "You feel a small surge of self-esteem to have found "
    "that the "+ doing[ 1 ] +" weight weighs "
    + weight_string( pans[ "left" ][ doing[ 1 ] ][ 1 ] ) +".\n" );
  info = (int)LIBRARY->query_player_quest_info( (string)person->query_name(),
    "balance" );
  info++;
  switch ( info ) {
    case 1 :
      tell_object( person, "You've made a good start at working out "
        "how the balance operates.  You think you should practice "
        "with it a couple of times more to get the hang of it, "
        "though.\n" );
      person->adjust_xp( 5000 );
      break;
    case 2 :
      tell_object( person, "You're definitely getting to understand how "
        "the balance operates.  You think you should practice with "
        "it once more to get used to it completely, though.\n" );
      person->adjust_xp( 10000 );
      break;
    case 3 :
      tell_object( person, "You're now adept at using the balance and "
        "can use it to weigh anything.\n" );
      if ( interactive( person ) ) {
        if ( !LIBRARY->query_quest_done( (string)person->query_name(),
          "balance quest" ) ) {
          LIBRARY->set_quest( (string)person->query_name(),
            "balance quest" );
        }
      }
      break;
    case 4:
      info--;
      break;
    default :
      tell_object( person, "Something has gone wrong with the balance.  "
        "Please contact Wodan about it.\n" );
  }
  LIBRARY->set_player_quest_info( (string)person->query_name(), "balance",
    info );
  tell_object( person, "You put all the weights back into the middle "
    "pan.\n" );
  tell_room( environment(), (string)person->the_short() +
     " seems satisfied with "+ (string)person->query_objective() +"self, "
    "and returns all of the weights to the middle pan.\n", person );
  doing = ({ });
  pans = DEFAULT_PANS;
}

==================================================
FILE: misc/bank_credit_note.c
==================================================

inherit "/std/object";
#include <money.h>
#define OBJECT_TAG "credit note"
private int _id;
private int _amount;
private string _franchise;
private string _bank;
void setup() {
   set_name("note");
   set_short("bank credit note");
   add_adjective( ({ "bank", "credit" }) );
   set_long("A small piece of paper which looks like some sort of "
            "bank transaction slip.\n");
   set_value(0);
   set_weight(1);
}
void setup_read_messages() {
   string extra;
   string place;
   place = query_property("place");
   if (_amount < 0) {
     extra = "Agrees to pay " +
             MONEY_HAND->money_value_string(-_amount, place) +
             " to the master bank.\n";
   } else {
     extra = "Slip for a withdrawl of " +
             MONEY_HAND->money_value_string(-_amount, place) +
             " from the master bank.\n";
   }
   add_read_mess("Credit note #" + _id + " for the bank " +
                    _bank + " from the franchise " +
                    _franchise->query_address() + ".\n\n" + extra,
                    0, "common", 0);
}
void set_credit_num(int num) {
   _id = num;
}
int query_credit_num() {
   return _id;
}
void set_bank_name(string bank) {
   _bank = bank;
}
string query_bank_name() {
   return _bank;
}
void set_franchise(string franchise) {
   _franchise = franchise;
}
string query_franchise() {
   return _franchise;
}
void set_amount(int amount) {
   _amount = amount;
}
int query_amount() {
   return _amount;
}
int is_valid_note() {
   object bank;
   object* obs;
   object ob;
   int ret;
   bank = load_object(query_franchise());
   obs = bank->find_commercial_items("bank");
   if (sizeof(obs)) {
      foreach (ob in obs) {
         ret = ob->is_valid_note(query_credit_num());
         if (ret) {
            return 1;
         }
      }
   }
   return 0;
}
int do_process() {
   object bank;
   object* obs;
   object ob;
   int ret;
   bank = load_object(query_franchise());
   obs = bank->find_commercial_items("bank");
   if (sizeof(obs)) {
      foreach (ob in obs) {
         ret = ob->process_note(query_credit_num());
         if (ret) {
            return 1;
         }
      }
   }
   return 0;
}
mixed* stats() {
   return ::stats() +
          ({ ({ "credit amount", query_amount() }),
             ({ "franchise", query_franchise() }),
             ({ "credit id", query_credit_num() }), });
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "amount", query_amount());
   add_auto_load_value(map, OBJECT_TAG, "franchise", query_franchise());
   add_auto_load_value(map, OBJECT_TAG, "id", query_credit_num());
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   return map;
}
void init_dynamic_arg(mapping map) {
   ::init_dynamic_arg(map);
   set_amount(query_auto_load_value(map, OBJECT_TAG, "amount"));
   set_franchise(query_auto_load_value(map, OBJECT_TAG, "franchise"));
   set_credit_num(query_auto_load_value(map, OBJECT_TAG, "id"));
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
}

==================================================
FILE: misc/beeswax_candle.c
==================================================

inherit "/std/lightable";
void setup() {
   set_name( "candle" );
   set_short( "beeswax candle" );
   add_adjective( "beeswax" );
   set_long( "This is a small candle, like you'd "
         "see on a birthday cake.  It is quite soft and "
         "squidgy.\n" );
   set_fuel_messages( ({
         "It is almost burnt to a stub.", 10,
         "It is more than halfway burnt.", 50,
         "It is not yet halfway burnt.", 85,
	 "It is almost new.", 99,
         "It is new.", 100
         }) );
   set_empty_mess( "is burnt to a stub." );
   set_max_fuel( 900 );
   set_fuel( 900 );
   set_brightness( 60 );
   set_value( 400 );
   set_hold_required( 1 );
   add_property( "no recycling", 1 );
   new_weapon( 10 );
   set_weight( 1 );
   set_hide_cond( 1 );
}

==================================================
FILE: misc/board.c
==================================================

#include <mail.h>
#include <board.h>;
inherit "/std/object";
string board_name;
mapping being_written;
int action_pri;
class info_written {
   string subject;
   int note_num;
}
int do_read_next();
int do_read_new();
int do_read(int num);
int do_followup(int num);
int do_reply(int num);
int do_eat(int num);
int do_post(string str);
void setup() {
   set_name("board");
   set_short("bulletin board");
   add_adjective("bulletin");
   set_main_plural("boards");
   reset_get();
   add_property("there", "mounted on one wall");
   add_property("survive fire", 1);
   add_help_file("board");
   board_name = "frog";
   being_written = ([ ]);
   action_pri = 0;
}
string query_plural() {
   mixed *stuff;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   switch (sizeof(stuff)) {
   case 0:
      return pluralize(::short(0))+" [ Empty ]";
   case 1:
      return pluralize(::short(0))+" [ 1 note ]";
   }
   return pluralize(::short(0))+" [ "+sizeof(stuff)+" notes ]";
}
string short(int dark) {
   mixed *stuff;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   switch (sizeof(stuff)) {
   case 0:
      return ::short(dark)+" [ Empty ]";
   case 1:
      return ::short(dark)+" [ 1 note ]";
   default:
      return ::short(dark)+" [ "+sizeof(stuff)+" notes ]";
   }
}
string the_date(int i) {
   return ctime(i)[4..9];
}
int do_subjects(string search) {
   int i, size;
   mixed *stuff;
   string ret;
   mapping news_rc;
   search = lower_case(search);
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (!sizeof(stuff)) {
      add_failed_mess("The board is completely empty.\n");
      return 0;
   }
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   ret = "";
   size = sizeof(stuff);
   for (i=0; i < size; i++) {
     if(search != "" && strsrch(lower_case(stuff[i][B_SUBJECT]), search) == -1)
       continue;
     if (news_rc[board_name] < stuff[i][B_TIME]) {
       ret += sprintf("N %2d: %-=*s\n", i+1,
                      (int)this_player()->query_cols()-6,
                      stuff[i][B_SUBJECT]+" ("+
                      stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
     } else {
       ret += sprintf("  %2d: %-=*s\n", i+1,
                      (int)this_player()->query_cols()-6,
                      stuff[i][B_SUBJECT]+" ("+
                      stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
     }
   }
   this_player()->set_finish_func(0);
   this_player()->more_string(ret);
   return 1;
}
string long(string str, int dark) {
   int i,newones, size;
   mixed *stuff;
   string ret;
   mapping news_rc;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   ret = "A bulletin board ("+board_name+").\n";
   if (!sizeof(stuff)) {
      return ret+"The board is completely empty.\n";
   }
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   newones = 0;
   size = sizeof(stuff);
   for (i = 0; i < size; i++) {
      if (news_rc[board_name] < stuff[i][B_TIME]) {
         ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+
                     stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
         newones +=1;
      } else if (news_rc[board_name] < stuff[i][B_TIME]+(2*24*60*60)) {
         ret += sprintf("  %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+
                     stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
      }
   }
   if (!newones) {
      ret += "\nNo new messages\n";
   }
   return ret;
}
void add_commands() {
   add_command("read", "[new]", (: do_read_new :));
   add_command("r", "[new]", (: do_read_new :));
   add_command("read", "<number>", (: do_read($4[0]) :));
   add_command("r", "<number>", (: do_read($4[0]) :));
   add_command("read", "next", (: do_read_next :));
   if (!this_player()->query_property("guest")) {
      add_command("post", "<string'subject'>", (: do_post($4[0]) :));
      add_command("note", "<string'subject'>", (: do_post($4[0]) :));
      add_command("eat", "<number'message number'>", (: do_eat($4[0]) :));
      add_command("followup", "<number'message number'>",
                  (: do_followup($4[0]) :));
      add_command("reply", "<number'message number'>", (: do_reply($4[0]) :));
   }
   add_command("subjects", "", (: do_subjects("") :));
   add_command("subjects", "<string'search'>", (: do_subjects($4[0]) :));
}
void init() {
  if (!present("board master", this_player())) {
    add_commands();
  }
}
void mark_mine(mixed *stuff, mapping news_rc) {
   int i;
   string their_name;
   i = sizeof(stuff)-1;
   their_name = this_player()->query_name();
   while (i > 0 && stuff[i][B_TIME] > news_rc[board_name])
      i--;
   while ((i+1) < sizeof(stuff) && lower_case(stuff[i+1][B_NAME]) == their_name)
      i++;
   if (i >= sizeof(stuff)) {
      news_rc[board_name] = stuff[sizeof(stuff)-1][B_TIME];
      return;
   }
   if (news_rc[board_name] > stuff[i][B_TIME])
      return;
   news_rc[board_name] = stuff[i][B_TIME];
}
int do_read_next()  {
   mapping  news_rc;
   mixed   *stuff;
   string   their_name, sub, next_sub;
   int      num, last_time;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (undefinedp(news_rc["last board"])  ||
       news_rc["last board"] != board_name)
   {
      add_failed_mess("You have not read a note on this board yet!\n");
      return 0;
   }
   stuff = BOARD_HAND->get_subjects(board_name);
   num = sizeof(stuff);
   their_name = this_player()->query_name();
write("last time: " + ctime(news_rc["last time"]) + "\n");
   last_time = news_rc["last time"];
   while (num  &&  stuff[num - 1][B_TIME] > last_time)  {
      num--;
   }
   sub = news_rc["last sub"];
   sscanf(sub, "Re:#%*d %s", sub);
   for (++num; num <= sizeof(stuff); num++)  {
      next_sub = stuff[num - 1][B_SUBJECT];
      sscanf(next_sub, "Re:#%*d %s", next_sub);
      if (next_sub == sub)  {
         return do_read(num);
      }
   }
   add_failed_mess("No further notes in the thread \"" + sub + "\".\n");
   return 0;
}
int do_read_new() {
   int num;
   string their_name;
   mapping news_rc;
   mixed *stuff;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   num = sizeof(stuff);
   their_name = (string)this_player()->query_name();
   while(num && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
   }
   while ((num < sizeof(stuff)) &&
          (lower_case(stuff[num][B_NAME]) == their_name)) {
      num++;
   }
   if (num == sizeof(stuff)) {
      add_failed_mess("No unread messages.\n");
      return 0;
   }
   num++;
   return do_read(num);
}
int do_read(int num) {
   mapping news_rc;
   mixed *stuff;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 0) {
      num = sizeof(stuff) + num + 1;
   }
   if (num < 1 || (num > sizeof(stuff))) {
      add_failed_mess("No note of that number.\n");
      return 0;
   }
   num--;
   news_rc["last board"] = board_name;
   news_rc["last time"] = stuff[num][B_TIME];
   news_rc["last sub"] = stuff[num][B_SUBJECT];
   if (news_rc[board_name] < stuff[num][B_TIME]) {
      news_rc[board_name] = stuff[num][B_TIME];
   }
   BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
   this_player()->more_string(sprintf("%s\nNote #%d by %s posted at %s%s\nTitle: "
                                     "\"%s\"\n\n%s",
                                     "%^BOLD%^",
                                     (num + 1),
                                     stuff[num][B_NAME],
                                     ctime(stuff[num][B_TIME]),
                                     "%^RESET%^",
                                     stuff[num]
                                     [B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10],
                                     (string)BOARD_HAND->
                                       get_message(board_name, num)),
                             "[Note "+ (num + 1) +"]");
   add_succeeded_mess("", ({ }));
   return 1;
}
int do_post(string str) {
   class info_written bing;
   if (board_name=="announcements" && !this_player()->query_creator()) {
      add_failed_mess("Sorry. You can't post messages here.  "
            "It's for announcements "
            "from the creators only.  If you have a comment or flame, try "
            "the 'flame' board or the 'frog' board.  Bing\n");
      return 0;
   }
   if (!str) {
      return 0;
   }
   if (this_player()->query_sp() < BOARD_SOCIAL_POINT_COST) {
      add_failed_mess("You need " + BOARD_SOCIAL_POINT_COST +
                      " social points to post a note.\n");
      return 0;
   }
   if (!BOARD_HAND->test_can_write(board_name,
                                   this_object(),
                                   this_player()->query_name())) {
      add_failed_mess("You cannot write to this board.\n");
      return 0;
   }
   bing = new(class info_written);
   bing->subject = str;
   bing->note_num = 0;
   being_written[this_player()->query_name()] = bing;
   this_player()->do_edit(0, "end_of_thing");
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
}
void end_of_thing(string body) {
  class info_written bing;
  if (body && body != "" &&
      being_written[this_player()->query_name()]) {
    if(board_name != "announcements")
      body = sprintf( "%-=78s", body ) + this_player()->append_signature();
    bing = (class info_written)being_written[ this_player()->query_name() ];
    if ( !BOARD_HAND->add_message( board_name,
         capitalize( (string)this_player()->query_name() ),
         bing->subject,
         body,
         bing->note_num ) ) {
      printf( "Error writing message.\n" );
    } else {
      printf("Message posted.\n");
      this_player()->adjust_sp(-50);
    }
  } else {
    printf( "No message posted.\n" );
  }
  map_delete(being_written, this_player()->query_name());
  return ;
}
int do_eat(int num) {
   if (!BOARD_HAND->delete_message(board_name, num-1)) {
      add_failed_mess("Failed to eat note.\n");
      return 0;
   }
   printf("You viciously tear off and eat note %d.\n", num);
   say( (string)this_player()->one_short() +
         " viciously tears off and eats note "+ num +".\n" );
   event( users(), "inform", (string)this_player()->query_name() +
         " eats a note off "+ board_name, "message", this_player() );
   return 1;
}
int do_followup(int num) {
   int i;
   mixed stuff;
   string s;
   class info_written bing;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 0) {
      num = sizeof(stuff) + num + 1;
   }
   if (num < 1 || num > sizeof(stuff)) {
      add_failed_mess("No note of that number.\n", ({ }));
      return 0;
   }
   if (this_player()->query_sp() < BOARD_SOCIAL_POINT_COST) {
      add_failed_mess("You need " + BOARD_SOCIAL_POINT_COST +
                      " social points to post a note.\n");
      return 0;
   }
   if (!stuff[num - 1][B_REPLY_TYPE] &&
       !BOARD_HAND->test_can_write(board_name,
                                   this_object(),
                                   this_player()->query_name())) {
      add_failed_mess("You cannot followup to this board.\n", ({ }));
      return 0;
   }
   bing = new(class info_written);
   if (sscanf(stuff[num - 1][B_SUBJECT], "Re:#%d %s", i, s) != 2) {
      bing->subject = "Re:#1 "+ stuff[num - 1][B_SUBJECT];
   } else {
      bing->subject = "Re:#"+ ( i + 1 ) +" "+ s;
   }
   bing->note_num = stuff[num - 1][B_NUM];
   being_written[(string)this_player()->query_name()] = bing;
   printf("Include original post? (y/[n]) ");
   input_to("include_post", 0, num - 1, stuff[num - 1]);
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
}
void include_post(string str, int num, mixed *stuff) {
  if (!str || str == ""  || lower_case(str)[0] != 'y') {
    printf("No.\n");
    this_player()->do_edit(0, "end_of_thing");
    return;
  }
  if (this_player()->query_name() == "macchirton") {
    printf("No including notes for pointless and repeated abuse.\n");
    this_player()->do_edit(0, "end_of_thing");
    return;
  }
  this_player()->
    do_edit("On " + ctime(stuff[B_TIME]) + ", " + stuff[B_NAME] +
            " wrote:\n> " +
            replace_string(BOARD_HAND->get_message(board_name, num),
                                  "\n", "\n> ") + "\n", "end_of_thing");
}
int do_reply(int num) {
   mixed stuff;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 1 || num > sizeof(stuff)) {
      add_failed_mess("No note of that number.\n", ({ }));
      return 0;
   }
   MAIL_TRACK->mail(stuff[num-1][B_NAME], stuff[num-1][B_SUBJECT]);
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
}
void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }
int query_new_messages() {
   mixed *notes;
   mapping news_rc;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc)
      news_rc = ([ ]);
   notes = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (!sizeof(notes))
      return 0;
   return (notes[sizeof(notes)-1][B_TIME] > news_rc[board_name]);
}

==================================================
FILE: misc/board_mas.c
==================================================

#include <mail.h>
#include <board.h>
inherit "/obj/misc/board";
int do_store(int num, string str);
int do_storeall(string str);
int do_minimum(int num);
int do_maximum(int num);
int do_timeout(int num);
int do_add(string str);
int do_remove(string str);
int do_board(string str);
int do_archive(string str);
int do_killfile(string str);
int do_unkillfile(string str);
int do_transfer(int num, string str);
int do_summary();
int do_skip(string str, int move_on);
int calc_new(object player, string board);
void setup() {
  ::setup();
  add_alias("board master");
  action_pri = 3;
  reset_drop();
  set_get();
}
string long(string str, int dark) {
  int i, irp;
  mixed *stuff;
  string ret;
  mapping news_rc;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  ret = "A bulletin board ("+board_name+").\n";
  irp = (int)BOARD_HAND->query_minimum(board_name);
  if (irp)
    ret += "Minimum number of messages left by automagic deletion is "+ irp +
           ".\n";
  irp = (int)BOARD_HAND->query_maximum(board_name);
  if (irp)
    ret += "Maximum number of messages on this board is "+irp+".\n";
  irp = (int)BOARD_HAND->query_timeout(board_name);
  if (irp)
    ret += "Messages will automagically time out in "+ irp +" days.\n";
  irp = (int)BOARD_HAND->query_archive(board_name);
  if (irp)
    ret += "Deleted messages are archived in "+irp+".\n";
  ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                 "read <note number>\npost <subject>\n"+
                 "boards\n"
                 "store <note number> <file>\n"
                 "storeall <file> (optional)\n"
                 "eat <note number>\n"
                 "reply <note number>\n"
                 "followup <note number>\n"
                 "summary [all]\n"
                 "next\n"
                 "prev\n"
                 "skip [<board name>]\n"
                 "board <board name>\n"
                 "timeout <time>\n"
                 "minimum <num>\n"
                 "maximum <num>\n"
                 "archive <name|none>\n"
                 "security\n"
                 "sadd <name>\n"
                 "sremove <name>\n"
                 "killfile <board name>\n"
                 "unkillfile <board name>\n"
                 "listkillfile\ntransfer <note> <board>");
  if (!sizeof(stuff))
    return ret+"The board is completely empty.\n";
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc)
    news_rc = ([ ]);
  for (i=0;i<sizeof(stuff);i++)
    if (news_rc[board_name] < stuff[i][B_TIME])
      ret += sprintf("N %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
    else
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
  return ret;
}
int calc_new(object who, string board) {
  mapping news_rc;
  mixed *stuff;
  int amt;
  news_rc = BOARD_HAND->query_newsrc(who->query_name());
  if ( !news_rc )
    news_rc = ([ ]);
  stuff = (mixed *)BOARD_HAND->get_subjects(board);
  if ( !sizeof( stuff ) )
    return 0;
  amt = sizeof( filter_array( stuff, (: ( $1[ B_TIME ] > $2 ) &&
              ( lower_case( $1[ B_NAME ] ) != $3 ) :), news_rc[ board ],
                              (string)who->query_name() ) );
  return amt;
}
void init() {
   if (this_player()->query_creator()) {
      add_commands();
      add_command("store", "<number> <word>", (: do_store($4[0], $4[1]) :));
      add_command("storeall", "<word>", (: do_storeall($4[0]) :));
      add_command("next", "");
      add_command("prev", "");
      add_command("new", "");
      add_command("board", "<string>", (: do_board($4[0]) :));
      add_command("boards", "");
      add_command("killfile", "<string>", (: do_killfile($4[0]) :));
      add_command("unkillfile", "<string>",(: do_unkillfile($4[0]) :));
      add_command("listkillfile", "");
      add_command("security", "");
      add_command("sadd", "<word>", (: do_add($4[0]) :));
      add_command("sremove", "<word>", (: do_remove($4[0]) :));
      add_command("timeout", "<number>", (: do_timeout($4[0]) :));
      add_command("minimum", "<number>", (: do_minimum($4[0]) :));
      add_command("maximum", "<number>", (: do_maximum($4[0]) :));
      add_command("archive", "<word>", (: do_archive($4[0]) :));
      add_command("summary", "");
      add_command("skip", "", (: do_skip(0, 1) :));
      add_command("catchup", "", (: do_skip(0, 0) :));
      add_command("skip", "<string>", (: do_skip($4[0], 1) :));
      add_command("catchup", "<string>", (: do_skip($4[0], 0) :));
      add_command("arts", "");
      add_command("transfer", "<number> <string>",
                     (: do_transfer($4[0], $4[1]) :));
   }
}
int do_storeall(string file) {
  mixed *stuff;
  int i, j, amt, cnt=0;
  string *boards, their_name;
  mapping news_rc;
  seteuid( geteuid( this_player() ) );
  their_name = this_player()->query_name();
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if ( !news_rc )
      news_rc = ([ ]);
  if (!write_file(file, "File created on "+ctime(time())+
                        " - Seattle time\n", 1)) {
    add_failed_mess("Unable to save the file "+file+"\n");
    return 0;
  }
  for (i=0;i<sizeof(boards);i++) {
    reset_eval_cost();
    if (!BOARD_HAND->query_killfile(this_player()->query_name(), lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        write_file(file,"\n----> Bulletin Board Name: "+boards[i]+"\n\n\n");
        news_rc[boards[i]] = stuff[sizeof(stuff)-1][B_TIME];
        for(j = amt+1;j<sizeof(stuff);j++) {
          write_file(file,"***** Note #" +(j+1)+ " by " +stuff[j][B_NAME]+
       " posted at " +ctime(stuff[j][B_TIME])+ "\nTitle: "+
       stuff[j][B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10]+"\n\n"+
                         BOARD_HAND->get_message(boards[i], j)+"\n\n\n");
          if (cnt == 0)
             printf("Storing ");
          cnt++;
          printf(".");
        }
      }
    }
  }
  write("\n"+cnt+" new messages are now saved in "+file+"\n");
  if (cnt == 0) {
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  return 1;
}
int do_store(int which, string file) {
  mixed *stuff;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (which < 1 || which > sizeof(stuff)) {
    add_failed_mess("Invalid note number.\n");
    return 0;
  }
  which--;
  file += ".note";
     seteuid( geteuid( this_player() ) );
  if (!write_file(file,stuff[which][B_SUBJECT]+"\n\n"+
                  BOARD_HAND->get_message(board_name, which))) {
    add_failed_mess("The master object appears and prevents you.\n");
    return 0;
  }
  write("Ok.\n");
  return 1;
}
void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }
int do_next() {
  int start, i, j, k, found;
  string *boards;
  if(calc_new(this_player(), board_name))
    return do_read_new();
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((start = member_array(board_name, boards)) == -1)
    start = 0;
  for(i=0; i<sizeof(boards); i++) {
    j = (i + start) % sizeof(boards);
    if(!BOARD_HAND->query_killfile(this_player()->query_name(),
                                     lower_case(boards[j])) &&
       k = calc_new(this_player(), boards[j])) {
      found = 1;
      break;
    }
  }
  if(found) {
    board_name = boards[j];
    write("Okay, changed to board "+board_name+" with " + k +
          " new notes.\n");
    return do_read_new();
  } else
    write("No boards with new messages.\n");
  return 1;
}
int do_prev() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i-1+sizeof(boards))%sizeof(boards);
  board_name = boards[i];
  write("Okay, changed to board "+board_name+".\n");
  return 1;
}
int do_killfile(string arg) {
    string *bits, board;
    bits = explode( arg, "," );
    foreach ( board in bits ) {
        if ( sizeof( BOARD_HAND->get_subjects( board ) ) ) {
          BOARD_HAND->set_killfile(this_player()->query_name(),
                lower_case( board ));
            tell_object( this_player(), "Board " + board  + " killed.\n" );
        }
        else {
            tell_object( this_player(), "There is no such board " +
                board + ".\n" );
        }
    }
    return 1;
}
int do_unkillfile(string arg) {
  if (!BOARD_HAND->query_killfile(this_player()->query_name(),
                                  lower_case( arg ) )) {
     add_failed_mess("Board "+arg+" is not kill file anyway.\n");
     return 0;
  } else {
    BOARD_HAND->remove_killfile(this_player()->query_name(),
                                lower_case(arg));
     write("Board "+arg+" unkilled.\n");
  }
  return 1;
}
int do_listkillfile() {
   string *boards;
   boards = BOARD_HAND->list_killfile(this_player()->query_name());
   if ( sizeof( boards ) )
     write("You have the following boards killfiled: "+
           query_multiple_short( boards ) +".\n" );
   return 1;
}
int do_board(string str) {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  i = member_array(str, boards);
  if (i == -1) {
    add_failed_mess("The board "+str+" does not exist sorry.\n");
    return 0;
  }
  write("Okay, changed to board "+ str);
  i = calc_new(this_player(), boards[i]);
  if(i)
    write(" with " + i + " new notes.\n");
  else
    write(" with no new notes.\n");
  board_name = str;
  return 1;
}
int do_boards() {
   write( "The current boards are:\n\""+
         implode( (string *)BOARD_HAND->list_of_boards(), "\", \"" ) +
         "\".\n" );
  return 1;
}
int do_security() {
   write( "The current people in this boards security array are:\n"+
        implode((string *)BOARD_HAND->query_security(board_name), ", ")+"\n");
  return 1;
}
int do_add(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->add_allowed(board_name, name);
}
int do_remove(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->remove_allowed(board_name, name);
}
int do_timeout(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_timeout(board_name, i);
}
int do_minimum(string i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_minimum(board_name, i);
}
int do_maximum(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_maximum(board_name, i);
}
int do_archive(string name) {
  if (!name)
    return 0;
  if (name != "none")
    return (int)BOARD_HAND->set_archive(board_name, name);
  return (int)BOARD_HAND->set_archive(board_name);
}
varargs int move(object dest, string s1, string s2) {
  int ret;
  if (!objectp(dest))
    return ::move(dest, s1, s2);
  if (interactive(dest)) {
    ret = ::move(dest, s1, s2);
    if (ret)
      return ret;
    seteuid(geteuid(dest));
    return 0;
  }
  return ::move(dest, s1, s2);
}
mixed query_static_auto_load() {
  return board_name;
}
void init_static_arg(mixed board) {
  if (stringp(board))
    board_name = board;
}
int do_summary() {
   int i, no, amt;
   string *boards;
   boards = (string *)BOARD_HAND->list_of_boards();
   for ( i = sizeof( boards ) - 1; i > -1; i-- )
      if ( !BOARD_HAND->query_killfile(this_player()->query_name(),
                                      lower_case( boards[ i ] ) ) ) {
        amt = calc_new(this_player(), boards[i]);
         if ( amt ) {
            printf( "The %s board has %d new message%s.\n", boards[ i ],
                  amt, amt > 1 ? "s" : "" );
            no++;
         }
      }
   if ( !no )
      add_failed_mess( "No boards with new messages.\n" );
   return no;
}
int do_new() {
   int i, amt;
   string *boards;
   boards = (string *)BOARD_HAND->list_of_boards();
   for ( i = sizeof( boards ) - 1; i > -1; i-- )
     if ( !BOARD_HAND->query_killfile(this_player()->query_name(),
                                      lower_case( boards[ i ] ) ) ) {
        amt = calc_new(this_player(), boards[i]);
         if ( amt ) {
            board_name = boards[ i ];
            printf( "The %s board has %d new message%s.\n", boards[ i ],
                  amt, amt > 1 ? "s" : "" );
            return 1;
         }
      }
   add_failed_mess( "No boards with new messages.\n" );
   return 0;
}
int do_skip(string str, int move_on) {
  mapping news_rc;
  mixed *otherstuff;
  int i, j, k, start, found;
  string *boards;
  if(!str) {
    str = board_name;
  }
  boards = (string *)BOARD_HAND->list_of_boards();
  if(member_array(str, boards) == -1)
    return notify_fail("No such board " + str + ".\n");
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if ( !news_rc )
      news_rc = ([ ]);
  otherstuff = (mixed *)BOARD_HAND->get_subjects(str);
  if (sizeof(otherstuff)) {
    news_rc[str] = otherstuff[sizeof(otherstuff)-1][B_TIME];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  printf("Marked all of "+str+" as read.\n");
  if(move_on) {
    reset_eval_cost();
    if ((start = member_array(board_name, boards)) == -1)
      start = 0;
    for(i=0; i<sizeof(boards); i++) {
      j = (i + start) % sizeof(boards);
      if(!BOARD_HAND->query_killfile(this_player()->query_name(),
                                     lower_case(boards[j])) &&
         k = calc_new(this_player(), boards[j])) {
        found = 1;
        break;
      }
    }
    if(found) {
      board_name = boards[j];
      write("Okay, changed to board "+board_name+" with " + k +
            " new notes.\n");
    } else
      write("No boards with new messages.\n");
  }
  return 1;
}
int do_arts() {
  int i;
  mixed *otherstuff;
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  for (i=0;i<sizeof(otherstuff);i++)
    printf("%2d# %-20s %d\n", i, otherstuff[i][B_NAME], otherstuff[i][B_NUM]);
  return 1;
}
int do_transfer(int num, string str) {
  string mess;
  string *boards;
  mixed *otherstuff;
  boards = (string *)BOARD_HAND->query_boards();
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (member_array(str, boards) == -1) {
    add_failed_mess("Cannot find the board '"+str+"'.\n");
    return 0;
  }
  if (num < 1 || num > sizeof(otherstuff)) {
    add_failed_mess("There is no note '"+num+"' on the board '"+
                        board_name+".\n");
    return 0;
  }
  mess = BOARD_HAND->get_message(board_name, num-1);
  if (mess && BOARD_HAND->add_message(str, otherstuff[num-1][B_NAME],
                              otherstuff[num-1][B_SUBJECT],
                              mess)) {
    write("Transfered note "+num+" to board '"+str+
                   "', local copy retained.\n");
    return 1;
  }
  add_failed_mess("Unable to transfer note "+num+" to the board '"+
                      board_name+", no security privilages?\n");
  return 0;
}

==================================================
FILE: misc/board_rab.c
==================================================

#include <mail.h>
#include <board.h>
inherit "/obj/misc/board";
int do_transfer(int num, string str);
int do_store(int num, string str);
int do_storeall(string str);
int do_minimum(int num);
int do_maximum(int num);
int do_timeout(int num);
int do_add(string str);
int do_remove(string str);
int do_board(string str);
int do_archive(string str);
int do_killfile(string str);
int do_unkillfile(string str);
void setup() {
  ::setup();
  add_alias("board master");
  action_pri = 3;
  reset_drop();
  set_get();
}
string long(string str, int dark) {
  int i, irp;
  mixed *stuff;
  string ret;
  mapping news_rc;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  ret = "A bulletin board ("+board_name+").\n";
  irp = (int)BOARD_HAND->query_minimum(board_name);
  if (irp)
    ret += "Minimum number of messages left by automagic deletion is "+ irp +
           ".\n";
  irp = (int)BOARD_HAND->query_maximum(board_name);
  if (irp)
    ret += "Maximum number of messages on this board is "+irp+".\n";
  irp = (int)BOARD_HAND->query_timeout(board_name);
  if (irp)
    ret += "Messages will automagically time out in "+ irp +" days.\n";
  irp = (int)BOARD_HAND->query_archive(board_name);
  if (irp)
    ret += "Deleted messages are archived in "+irp+".\n";
  ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                            "read <note number>\npost <subject>\n"+
                            "boards\n"+
                            "store <note number> <file>\n"+
          "storeall <file> (optional)\n"+
          "eat <note number>\n"+
                            "reply <note number>\nfollowup <note number>\n"+
                            "summary [all]\nnext\nprev\nnew\n"+
                            "board <board name>\n"+
                            "timeout <time>\nminimum <num>\nmaximum <num>\n"+
                            "archive <name|none>\n"+
                            "security\nsadd <name>\nsremove <name>\n"+
                            "killfile <board name>\nunkillfile <board name>\nlistkillfile\ntransfer <note> <board>");
  if (!sizeof(stuff))
    return ret+"The board is completely empty.\n";
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!news_rc)
    news_rc = ([ ]);
  for (i=0;i<sizeof(stuff);i++)
    if (news_rc[board_name] < stuff[i][B_TIME])
      ret += sprintf("N %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
    else
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
  return ret;
}
void init() {
   if (environment() == this_player() &&
       this_player()->query_creator()) {
      add_commands();
      add_command("store", "<number> <word>", (: do_store($4[0], $4[1]) :));
      add_command("storeall", "<word>", (: do_storeall($4[0]) :));
      add_command("next", "");
      add_command("prev", "");
      add_command("new", "");
      add_command("board", "<string>", (: do_board($4[0]) :));
      add_command("boards", "");
      add_command("killfile", "<string>", (: do_killfile($4[0]) :));
      add_command("unkillfile", "<string>",(: do_unkillfile($4[0]) :));
      add_command("listkillfile", "");
      add_command("security", "");
      add_command("sadd", "<word>", (: do_add($4[0]) :));
      add_command("sremove", "<word>", (: do_remove($4[0]) :));
      add_command("timeout", "<number>", (: do_timeout($4[0]) :));
      add_command("minimum", "<number>", (: do_minimum($4[0]) :));
      add_command("maximum", "<number>", (: do_maximum($4[0]) :));
      add_command("archive", "<word>", (: do_archive($4[0]) :));
      add_command("summary", "");
      add_command("skip", "");
      add_command("arts", "");
      add_command("transfer", "<number> <string>",
                     (: do_transfer($4[0], $4[1]) :));
   }
}
int do_storeall(string file) {
  int which;
  mixed *stuff;
  int i, j, no, amt, cnt=0;
  string *boards, their_name;
  mapping news_rc;
  seteuid( geteuid( this_player() ) );
  their_name = this_player()->query_name();
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!write_file(file, "File created on "+ctime(time())+
                        " - Seattle time\n", 1)) {
    add_failed_mess("Unable to save the file "+file+"\n");
    return 0;
  }
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        write_file(file,"\n----> Bulletin Board Name: "+boards[i]+"\n\n\n");
        news_rc[boards[i]] = stuff[sizeof(stuff)-1][B_TIME];
        for(j = amt+1;j<sizeof(stuff);j++) {
          write_file(file,"***** Note #" +(j+1)+ " by " +stuff[j][B_NAME]+
       " posted at " +ctime(stuff[j][B_TIME])+ "\nTitle: "+
       stuff[j][B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10]+"\n\n"+
                         BOARD_HAND->get_message(boards[i], j)+"\n\n\n");
          if (cnt == 0)
             printf("Storing ");
          cnt++;
          printf(".");
        }
      }
    }
  }
  add_succeeded_mess(this_object(), ({
                   "\n"+cnt+" new messages are now saved in "+file+"\n",
                   "$N appears to scribble something a lot.\n" }), ({ }));
  if (cnt == 0) {
    this_player()->add_property(NEWS_RC, news_rc);
  }
  return 1;
}
int do_store(int which, string file) {
  mixed *stuff;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (which < 1 || which > sizeof(stuff)) {
    add_failed_mess("Invalid note number.\n");
    return 0;
  }
  which--;
  file += ".note";
  if (!write_file(file,stuff[which][B_SUBJECT]+"\n\n"+
                  BOARD_HAND->get_message(board_name, which))) {
    add_failed_mess("The master object appears and prevents you.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Ok.\n", "$N copies some stuff off "
                                       "the board.\n" }), ({ }) );
  return 1;
}
void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }
int do_next() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i+1)%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
}
int prev() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i-1+sizeof(boards))%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
}
int do_killfile(string arg) {
  this_player()->add_property( "news_kill_" +lower_case( arg ), 1 );
  add_succeeded_mess(this_object(), ({ "Board "+arg+" killed.\n", "" }), ({}));
  return 1;
}
int do_unkillfile(string arg) {
  if (!this_player()->query_property( "news_kill_" +lower_case( arg ) )) {
     add_failed_mess("Board "+arg+" is not kill file anyway.\n");
     return 0;
  } else {
     this_player()->remove_property( "news_kill_" +lower_case( arg ) );
     add_succeeded_mess(this_object(), ({ "Board "+arg+" unkilled.\n", "" }),
                       ({ }));
  }
  return 1;
}
int do_listkillfile(string arg) {
   string property, s1, *boards=({ });
   mixed value;
   foreach ( property, value in this_player()->query_properties() )
      if ( sscanf(property,"news_kill_%s",s1) == 1 &&
           value )
         boards += ({ s1 });
   if ( sizeof( s1 ) )
      tell_object( this_player(), "You have the following boards killfiled: "+
                  query_multiple_short( boards ) +".\n" );
   add_succeeded_mess(this_object(), "", ({ }));
   return 1;
}
int do_new() {
  int i, amt;
  string *boards, their_name;
  mixed *stuff;
  mixed otherstuff;
  mapping news_rc;
  boards = (string *)BOARD_HAND->list_of_boards();
  their_name = this_player()->query_name();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                                lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        board_name = boards[i];
        add_succeeded_mess(this_object(), ({
          "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n", "$N turns over their board.\n" }), ({ }));
        return 1;
      }
    }
  }
  add_failed_mess("No boards with new messages.\n");
  return 0;
}
int do_board(string str) {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  i = member_array(str, boards);
  if (i == -1) {
    add_failed_mess("The board "+str+" does not exist sorry.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Okay, changed to board "+ str +".\n",
                                   "$N turns over their board.\n" }), ({ }));
  board_name = str;
  return 1;
}
int do_boards() {
   write( "The current boards are:\n\""+
         implode( (string *)BOARD_HAND->list_of_boards(), "\", \"" ) +
         "\".\n" );
  return 1;
}
int do_security() {
   write( "The current people in this boards security array are:\n"+
        implode((string *)BOARD_HAND->query_security(board_name), ", ")+"\n");
  return 1;
}
int do_add(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->add_allowed(board_name, name);
}
int do_remove(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->remove_allowed(board_name, name);
}
int do_timeout(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_timeout(board_name, i);
}
int do_minimum(string i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_minimum(board_name, i);
}
int do_maximum(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_maximum(board_name, i);
}
int do_archive(string name) {
  if (!name)
    return 0;
  if (name != "none")
    return (int)BOARD_HAND->set_archive(board_name, name);
  return (int)BOARD_HAND->set_archive(board_name);
}
varargs int move(object dest, string s1, string s2) {
  int ret;
  if (!objectp(dest))
    return ::move(dest, s1, s2);
  if (interactive(dest)) {
    ret = ::move(dest, s1, s2);
    if (ret)
      return ret;
    seteuid(geteuid(dest));
    return 0;
  }
  return ::move(dest, s1, s2);
}
mixed query_static_auto_load() {
  return board_name;
}
void init_static_arg(mixed board) {
  if (stringp(board))
    board_name = board;
}
int do_summary(string str) {
  int i, no, amt;
  string *boards, their_name;
  mapping news_rc;
  mixed *stuff;
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  their_name = this_player()->query_name();
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        printf( "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n" );
        no++;
      } else if (str == "all") {
        printf("The "+boards[i]+" board has no new messages.\n");
        no++;
      }
    }
  }
  if (no) {
    add_succeeded_mess(this_object(), ({ "", "$N runs their finger over "
                                             "thier board.\n" }), ({ }));
  } else {
    add_failed_mess("No boards with new messages.\n");
  }
  return no;
}
int do_skip() {
  mapping news_rc;
  mixed *otherstuff;
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (sizeof(otherstuff)) {
    news_rc[board_name] = otherstuff[sizeof(otherstuff)-1][B_TIME];
    this_player()->add_property(NEWS_RC, news_rc);
  }
  printf("Marked all of "+board_name+" as read.\n");
  if (!do_new()) {
    printf("No new messages.\n");
  }
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int do_arts() {
  int i;
  mixed *otherstuff;
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  for (i=0;i<sizeof(otherstuff);i++)
    printf("%2d# %-20s %d\n", i, otherstuff[i][B_NAME], otherstuff[i][B_NUM]);
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int do_transfer(int num, string str) {
  string mess;
  string *boards;
  mixed *otherstuff;
  int i;
  boards = (string *)BOARD_HAND->query_boards();
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (member_array(str, boards) == -1) {
    add_failed_mess("Cannot find the board '"+str+"'.\n");
    return 0;
  }
  if (num < 1 || num > sizeof(otherstuff)) {
    add_failed_mess("There is no note '"+num+"' on the board '"+
                        board_name+".\n");
    return 0;
  }
  mess = BOARD_HAND->get_message(board_name, num-1);
  if (mess && BOARD_HAND->add_message(str, otherstuff[num-1][B_NAME],
                              otherstuff[num-1][B_SUBJECT],
                              mess)) {
    write("Transfered note "+num+" to board '"+str+
                   "', local copy retained.\n");
    return 1;
  }
  add_failed_mess("Unable to transfer note "+num+" to the board '"+
                      board_name+", no security privilages?\n");
  return 0;
}

==================================================
FILE: misc/boring_stick.c
==================================================

inherit "/std/held";
#include <move_failures.h>
int state;
void set_state(int state);
void setup() {
  set_name("stick");
  set_state(0);
  set_weight(2);
  set_value(10);
}
void init() {
  this_player()->add_command("turn", this_object(),
                                "<direct:object> {on|off}");
  this_player()->add_command("flick", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("press", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("push", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("flick", this_object(),
                                "<direct:object>");
  this_player()->add_command("turn", this_object(),
                                "switch {on|off} on <direct:object>");
  this_player()->add_command("switch", this_object(),
                                "<direct:object> {on|off}");
}
void set_state(int new_state) {
  state = new_state;
  if (state) {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.  Flashing lights "
"rush up and down the side of the stick in a mad progression.\n");
  } else {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.\n");
  }
  if (environment())
    if (state) {
      if (living(environment()))
        environment()->add_extra_look(this_object());
    } else
      environment()->remove_extra_look(this_object());
}
string extra_look() {
  return capitalize(previous_object()->query_pronoun())+
         " is surrounded by an aura of bees.\n";
}
int do_turn(mixed *indirect_obs, string indir_match,
            string dir_match, mixed *args, string pattern) {
  int new_state;
  new_state = 0;
  if ("<direct:object> {on|off}" == pattern) {
    if (args[1] == "on")
      new_state = 1;
  } else {
    if (args[0] == "on")
      new_state = 1;
  }
  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
}
int do_flick() {
  set_state(!state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V the switch on $D to the "+(state?"on":"off")+" position.\n", ({ }));
  return 1;
}
int do_press() {
  return do_flick();
}
int do_push() {
  return do_flick();
}
int do_switch(mixed *indirect_obs, string indir_match,
              string dir_match, mixed *args, string pattern) {
  int new_state;
  if (args[1] == "on")
    new_state = 1;
  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
}
mapping query_dynamic_auto_load() {
   return ([ "state" : state,
             "::" : held::query_dynamic_auto_load()
          ]);
}
void init_dynamic_arg(mapping map) {
   set_state(map["state"]);
   if ( map[ "::" ] )
      held::init_dynamic_arg( map[ "::" ] );
}
varargs int move(mixed dest, string str1, string str2) {
  int ret;
  object old;
  old = environment();
  ret = ::move(dest, str1, str2);
  if (ret == MOVE_OK) {
    if (state) {
      if (old)
        old->remove_extra_look(this_object());
      if (living(environment())) {
        environment()->add_extra_look(this_object());
      }
    }
  }
  return ret;
}

==================================================
FILE: misc/bug.c
==================================================

inherit "/std/object";
int no_shots;
void setup() {
   no_shots = 10;
   set_name( "bug");
   set_long( "It sits there, happier than a clam, its long black silvery "
             "legs sticking out the side.  The legs look fixed in place and "
             "there are some silvery words carved onto the top.  When you "
             "shake it, it sounds like it has something rattling around "
             "inside.  There appears to be a spray nozzle at one end.\n");
   add_read_mess("68000\n", "silver writing", "general", 0);
}
void init() {
  add_command("shake", "<direct:object>");
  add_command("spray", "<indirect:object> with <direct:object>");
}
int do_shake() {
   this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and you can hear something rattling around inside.\n", ({ }));
   return 1;
}
int do_spray(object *obs) {
   int i;
   int done;
   if (no_shots <= 0) {
      return 0;
   }
   done = 0;
   for (i = 0; i < sizeof(obs); i++) {
      if (no_shots > 0 && obs[i] != this_object()) {
         obs[i]->add_effect("/std/effects/object/bug_effect", 0);
         no_shots--;
         this_player()->add_succeeded(obs[i]);
         done = 1;
      }
   }
   return done;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([ "::" : ::query_dynamic_auto_load(),
            "shots" : no_shots ]);
   return map;
}
void init_dynamic_arg(mapping map, object foo) {
   ::init_dynamic_arg(map["::"]);
   no_shots = map["shots"];
}

==================================================
FILE: misc/button.c
==================================================

inherit "std/object";
void setup() {
   set_name( "button" );
   set_short( "red button" );
   add_adjective( "red" );
   set_long( "This red button destructs all non-user objects in "
         "the room.  USE WITH EXTREME CAUTION.\n");
   reset_get();
   add_property( "there", "embedded into the wall" );
}
void init() {
   this_player()->add_command( "press" , this_object() );
}
int do_press() {
   object thing, *things;
   things = (object *)environment()->query_non_destable();
   if ( !things )
      things = ({ this_object() });
   else
      things += ({ this_object() });
   foreach ( thing in all_inventory( environment() ) - things )
      if ( !userp( thing ) )
         thing->dest_me();
   write( "You clean up.\n" );
   say( (string)this_player()->one_short() +" cleans up.\n" );
   return 1;
}

==================================================
FILE: misc/camera.c
==================================================

#include <weather.h>
inherit "/std/object";
int  colour;
int  black_white;
int  scene;
void setup() {
  colour = 2;
  black_white = 4;
  scene = 1;
  set_name( "box" );
  add_adjective( ({ "heavy" , "black" }) );
  set_short( "heavy black cube" );
  set_main_plural( "heavy black cubes" );
  set_long( "You see a heavy black box with a window on one side.  "
            "Looking through the window, you notice a tiny demon sitting "
            "patiently next to a miniscule painter's easel.\n" );
  set_weight( 10 );
  add_alias( ({ "cube" , "camera" }) );
  add_plurals(({ "cubes", "cameras"}));
  adjust_money( 1 , "gold" );
  add_help_file("camera");
}
void init() {
    add_command("use", "<direct:object> on <indirect:object>");
    add_command("use", "<direct:object>");
}
int query_colour()      { return colour;  }
int query_black_white() { return black_white;  }
int do_use(object *obs) {
  int i;
  string view;
  string photo_of;
  string chars_sorted;
  string things_sorted;
  object *players;
  object *chars;
  object *things;
  object  photo;
  object  env;
  object *yes;
  players = ({ });
  chars = ({ });
  things = ({ });
  yes = ({ });
  view = "";
  photo_of = "";
  chars_sorted = "";
  things_sorted = "";
  env = environment(this_player()) ;
  photo_of = "This is a beautiful ";
  if (env->query_light() < 60) {
    this_player()->add_failed_mess(this_object(),
                                   "The little imp whispers: Hey! "
                                   "Not everyone like you can see "
                                   "in the dark you know.\n",({ }));
    return 0;
  }
  if (env->query_light() >180) {
    this_player()->add_failed_mess(this_object(),
                                   "The little demon said quietly: "
                                   "Could I have a pair of sunspecs "
                                   "please! Not too much to ask, is it?\n",
                                   ({ }));
    return 0;
  }
  if (black_white <= 0) {
    call_out("out_of_paint", 0, env);
    this_player()->add_failed_mess(this_object(),
                                   "The little imp gives up painting "
                                   "for you.\n",({ }));
    return 0;
  }
  if (colour > 1) {
    photo_of += "colour ";
    colour --;
  } else if (colour == 1) {
    photo_of += "colour ";
    call_out("out_of_colour", 2, env);
    colour --;
  } else {
    photo_of += "black and white ";
    black_white --;
  }
  if (sizeof(obs)) {
    for (i=0;i<sizeof(obs);i++) {
      if (obs[i]->query_property("player")) {
        players += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else if (obs[i]->query_property("npc")) {
        chars   += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else {
        if (environment(obs[i]) != this_player()) {
          things  += ({ obs[i] });
          this_player()->add_succeeded(obs[i]);
          yes  += ({ obs[i] });
        }
      }
    }
    chars_sorted = query_multiple_short(chars);
    things_sorted = query_multiple_short(things);
    if (chars_sorted || things_sorted || sizeof(players)) {
      scene = 0;
    }
  }
  view = env->query_long();
  if(view[sizeof(view)-1] != 10)
    view += "\n";
  if(env->query_property("location") == "outside" &&
     !env->query_weather_obscured(WEATHER->query_day())) {
    view = WEATHER->weather_string(env) + ".  " + view;
  }
  photo_of += "picture of " + env->a_short() + ".";
  if (scene == 0) {
    if ((sizeof(chars)+sizeof(players)) == 1) {
      if (sizeof(chars) == 1) {
        view += capitalize( (string)chars[0]->query_short() ) +
          " is here smiling.\n";
      } else if (sizeof(players) == 1) {
        view += players[0]->one_short() +" is here smiling.\n";
      }
    } else if ((sizeof(players)+sizeof(chars)) > 1) {
      for(i=0;i<sizeof(players);i++) {
        view += players[i]->one_short() ;
        if (i < (sizeof(players)-1)) {
          view += ", ";
        }
      }
      if (chars_sorted != "" && sizeof(players) > 0) {
        view += ", " + chars_sorted ;
      } else if (chars_sorted != "") {
        view += capitalize(chars_sorted) ;
      }
      view += " are smiling here.\n";
    }
    if (sizeof(things) == 1) {
      view += "There is a "+ things_sorted +" in the photo.\n";
    } else if ( sizeof( things ) ) {
      view += "There are " + things_sorted+" lying here in the photo.\n" ;
    }
  }
  photo = clone_object("/std/object");
  photo->set_name("glass");
  photo->add_adjective( ({"tiny", "square"}) );
  photo->set_short("tiny square of glass");
  photo->set_main_plural("tiny squares of glass");
  photo->set_long("/global/events"->convert_message(view));
  photo->set_read_mess(photo_of);
  photo->add_property("photographer", (string)this_player()->query_name()) ;
  photo->move(this_player());
  if (scene == 0) {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on $I. After some frantic "
                                      "sounds of pens scratching and "
                                      "brushes brushing, a tiny "
                                      "demon inside hands a piece of painted "
                                      "glass to $N.\n", yes);
  } else {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on the scenery. After some "
                                      "frantic sounds of pens scratching "
                                      "and brushes brushing, a "
                                      "tiny demon inside hands a piece "
                                      "of painted glass to $N.\n");
  }
  return 1;
}
mapping query_static_auto_load() {
  return ([ "colour" : colour,
          "black_white" : black_white ]);
}
void init_static_arg(mapping map) {
  colour = map["colour"];
  black_white = map["black_white"];
}
void out_of_paint(object room) {
  tell_object(this_player(), "The tiny demon whispers sarcastically: "
              "Without any more paints, I can still paint "
              "you invisible picture if you like!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "paints to "+ this_player()->one_short() +".\n",
            this_player());
}
void out_of_colour(object room) {
  tell_object(this_player(), "The tiny demon whispers: There are no more "
              "colour paints. This picture is the "
              "last colour one. I can only do you "
              "black and white pictures from now!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "colour to "+ this_player()->one_short() +".\n",
            this_player());
}

==================================================
FILE: misc/case.c
==================================================

#define READ "/cmds/living/r_ead"
inherit "/obj/baggage";
void setup() {
  set_name("case");
  set_long("This is a nice glass display case that looks out of place "
           "here, you could \"peruse\" things in it perhaps.\n");
  add_alias("container");
  add_adjective("display");
  set_transparent();
  set_weight(1000);
  set_main_plural("cases");
  set_max_weight(500000);
  reset_get();
  reset_drop();
}
void init() {
  this_player()->add_command( "peruse", this_object(),
                              "<indirect:object:direct-obs> in <direct:object>");
}
int do_peruse( object *obs ) {
  obs = filter( obs, (: environment( $1 ) == this_object() :) );
  if ( !sizeof( obs ) ) {
    add_failed_mess( "You have to browse something in the display case.\n" );
    return 0;
  }
  if ( sizeof( obs ) > 1 ) {
    add_failed_mess( "You can only browse 1 thing at a time.\n" );
    return 0;
  }
  write( "You peruse the "+ obs[0]->query_short() +".\n" );
  write( obs[0]->long() );
  READ->cmd( ({ obs[0] }) );
  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;
}
int test_add( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
int test_remove( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
void setup_case( string name, string long ) {
  add_alias( name );
  set_long( long + "You feel you could \"peruse\" things in it.\n" );
}

==================================================
FILE: misc/cash_register.c
==================================================

#include <money.h>
inherit "/std/container";
object shop;
object query_shop() { return shop; }
void set_shop( object thing ) { shop = thing; }
string long( string word, int dark ) {
   int i;
   string ret, *coins;
   object cash;
   ret = query_long();
   cash = present( MONEY_ALIAS, this_object() );
   if ( !cash )
      return ret +"There is no money in the register.\n";
   coins = (string *)cash->half_short( 1 );
   if ( !sizeof( coins ) )
      return ret +"There is no money in the register.\n";
   ret += "The register contains:\n";
   for ( i = 0; i < sizeof( coins ); i++ )
      ret += "      "+ coins[ i ] +"\n";
   return ret;
}
int test_add( object thing, int flag ) {
   if ( !thing->id( MONEY_ALIAS ) )
      return 0;
   if ( shop )
      shop->save_register();
   return 1;
}
int test_remove( object thing, int flag ) {
   if ( shop )
      shop->save_register();
   return 1;
}

==================================================
FILE: misc/chicken_feather.c
==================================================

inherit "/std/object";
void setup() {
 set_name("feather");
 set_short("chicken feather");
 set_main_plural("chicken feathers");
 add_adjective("chicken");
 add_plural("feathers");
 add_adjective("chicken");
 set_weight(1);
 set_long("This is a feather that was plucked from a chicken.\n");
}

==================================================
FILE: misc/club_badge.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
inherit "/obj/clothing";
inherit "/std/basic/club_insignia";
protected int club_members(int online);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int club_members(int online);
protected int club_info();
protected int do_history();
private string *extra_adjs;
void setup() {
   extra_adjs = ({ });
   set_name("badge");
   add_adjective("club");
   set_type("badge");
   set_short("club badge");
   setup_clothing(1000);
   set_damage_chance(5);
   set_long("The badge is a nice blue colour with a fringe "
            "like a bunny rabbit.\n");
   add_extra_look(this_object());
}
string extra_look() {
   string tmp_name;
   if (query_club() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      tmp_name = replace(lower_case(query_club()), " ", "_");
      return "  You feel like the command '" + tmp_name + "' does something.\n";
   }
   return "\n";
}
void init() {
   club_insignia::init();
}
mapping query_dynamic_auto_load(mapping map) {
   map = clothing::query_dynamic_auto_load();
   map = club_insignia::query_dynamic_auto_load(map);
   map["verSion"] = 1;
   return map;
}
void init_dynamic_arg(mapping map) {
   if (map["verSion"] != 1) {
      clothing::init_dynamic_arg(map["::"]);
   } else {
      clothing::init_dynamic_arg(map);
   }
   club_insignia::init_dynamic_arg(map);
}
void set_club(string name) {
   if (!name) {
      extra_adjs = ({ });
      set_short("club badge");
   } else {
      if (CLUB_HANDLER->is_club(name)) {
         name = CLUB_HANDLER->query_club_name(name);
         extra_adjs = explode(lower_case(name), " ");
            set_short("club badge");
      }
   }
   ::set_club(name);
}
string *parse_command_adjectiv_id_list() {
   return ::parse_command_adjectiv_id_list() +
           extra_adjs;
}
mixed *stats()
{
  return clothing::stats() +
    club_insignia::stats();
}

==================================================
FILE: misc/crystal_phial.c
==================================================

inherit "/obj/vessel";
void setup() {
   set_name( "phial" );
   set_short( "crystal phial" );
   add_adjective( "crystal" );
   set_main_plural( "crystal phials" );
   set_long( "This is a small tube-like bottle made of some sort of "+
         "crystal.  A stopper is attached at one end on a bit of wire.\n" );
   set_weight( 1 );
   set_value( 1000 );
   set_max_weight( 1 );
   set_max_volume( 10 );
   set_transparent();
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() + ({ "of" }) +
      (string *)thing->query_adjectives();
}

==================================================
FILE: misc/dart_board.c
==================================================

#include <player_handler.h>
inherit "/std/object";
string  *creators, name1, name2, target;
object  player1, player2;
int     score1, score2, in_use, thrown, bet;
void setup();
void init();
int abandon( string str );
string find_target();
int play( string str );
int throw_dart();
int score_it( int i );
void heart_beat();
void end_game();
void setup() {
  set_name("dartboard");
    add_property( "there", "mounted on the wall" );
  add_adjective("party");
  set_main_plural("dartboards");
  set_short("party dartboard");
  set_long("This is a party dartboard.  It's round, with concentric "
    "circles in black and yellow painted on it.\n");
  set_weight(10000);
  set_value(0);
  reset_get();
  set_read_mess(
    "This is a game of darts for two players. Before beginning "
    "their throws, the players must both type 'play'. Each player "
    "in turn can then throw three darts at the board (by typing "
    "'throw' three times). Note that your accuracy is affected "
    "by your DEX stat. The winner of the game is the player with the "
    "highest score after all darts have been thrown.\n" );
}
void init() {
  add_command("abandon", "", (:this_object()->abandon(""):));
  add_command("play", "", (:this_object()->play(0):));
  add_command("throw", "", (:this_object()->throw_dart():));
}
int abandon( string str ) {
  if (this_player() == player1 || this_player() == player2) {
    write("You call off the game of darts.\n");
    say("The game of darts is called off by "
      + this_player()->query_short()+".\n");
    end_game();
    return 1;
  }
}
string find_target() {
  string *creators, victim;
  creators = get_dir("/w/");
  victim = (creators[(random(sizeof(creators)))]);
  while (!PLAYER_HANDLER->test_user(victim) ) {
    victim = (creators[(random(sizeof(creators)))]);
}
  return capitalize(victim);
}
int play( string str ) {
  int val;
  if (in_use) {
    write("The dartboard is in use right now.\n");
    return 1;
  }
  if (!str) str = "0";
  if (!sscanf(str, "%d", val) || val < 0) {
    write("Bets must be for zero or greater coins.\n");
    return 1;
  }
  if (this_player()->query_money() < val) {
    write("Betting is not yet supported... I'm working on it! "
   "Just type \"play\".\n");
    return 1;
  }
  if (player1) {
    if (this_player() == player1) {
      write("You can't play against yourself!\n");
      return 1;
    }
    if (val != bet) {
      write("Bet amounts must match. " + name1 + " bet " + bet + ".\n");
      return 1;
    }
    player2 = this_player();
    name2 = player2->query_short();
    target = find_target();
    tell_room( environment(), name1 + " and " + name2 +
      " have started a game of darts, throwing at " + target
      + ".\n", ({ player1, player2 }) );
    tell_object( player2, "You accept " + name1 + "'s challenge, "
      "and you both prepare to throw darts at " + target + ".\n" );
    tell_object( player1, name2 + " accepts your challenge, and you "
      "both prepare to throw darts at " + target + ".\nThrow your darts.\n");
    in_use = 1;
    return 1;
  }
  bet = val;
  player1 = this_player();
  name1 = player1->query_short();
  write("You can 'abandon' the game if no one takes up your challenge.\n");
  say( name1 + " is looking for someone else to play darts with.\n");
  set_heart_beat(1);
  return 1;
}
int throw_dart() {
  int hit;
  string start;
  if (!in_use)  {
     return notify_fail( "You are not currently playing.\n ");
  }
  if (this_player() != player1 && this_player() != player2)  {
     return notify_fail( "You are not currently playing.\n" );
  }
  if (in_use == 1 && this_player() == player1) {
    thrown += 1;
    write("You throw a dart.\n");
    say( name1 + " throws a dart.\n" );
    hit = score_it(random(21) + ((player1->query_dex() -13 ) / 2 ));
    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player1->ajdust_xp(10);
    }
    score1 += hit;
    if (thrown == 3) {
      write("That was your third dart. Your score is " + score1 + ".\n");
      say(name1 + " has a score of " + score1 + " after three darts.\n");
      if (player2) tell_object(player2, "Your turn to throw.\n");
      in_use = 2;
    }
    return 1;
  }
  if (in_use == 2 && this_player() == player2) {
    thrown += 1;
    write("You throw a dart.\n");
    say(name2+ " throws a dart.\n" );
    hit = score_it(random(21) + ((player2->query_dex() - 13 ) / 2 ));
    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player2->adjust_xp(10);
    }
    score2 += hit;
    if (thrown == 6) {
      write("That was your third dart.\n");
      if (score1 > score2) {
        start = " with a score of " + score1 + " to " +
          score2 + ".\n";
        write(name1 + " beats you" + start);
        tell_room( environment(), name1 + " beats " + name2 + start,
                ({ player1, player2 }));
        tell_object(player1, "You beat " + name2 + start);
      } else if (score2 > score1) {
        start = " with a score of " + score2 + " to " +
          score1 + ".\n";
        write("You beat " + name1 + start);
        tell_room( environment(), name2 + " beats " + name1 + start,
                    ({ player1, player2 }));
        tell_object(player1, name2 + " beats you" + start);
      } else {
        tell_room(environment(this_object()),
          "It's a tie with a score of " + score1 + "!\n");
      }
      end_game();
    }
    return 1;
  }
  write("It's not your turn to throw a dart!\n");
  return 1;
}
int score_it( int i ) {
  string rest_mess;
  int ret;
  if (i < 2) {
    rest_mess = "the wall. No score.\n";
    ret = 0;
  } else if (i < 19) {
    rest_mess = "number "+i+", scoring "+(i*5)+".\n" ;
    ret = i * 5;
  } else if (i == 19) {
    rest_mess =  target+"'s face! Score of 250!\n";
    ret = 250;
  } else {
    rest_mess = target+"'s nose! Score of 500!\n";
    ret = 500;
  }
  write("You hit " + rest_mess);
  say( this_player()->query_short() + " hit " + rest_mess);
  return ret;
}
void heart_beat() {
  if (!player1) player1 = find_player(lower_case(name1));
  if (name2 && !player2) player2 = find_player(lower_case(name2));
  if (!player1 || environment() != environment(player1))
    say(name1 + " is no longer here. The game of darts is called off.\n");
  else if (name2 && (!player2 || environment() != environment(player2)))
    say(name2 + " is no longer here. The game of darts is called off.\n");
  else
    return;
  end_game();
}
void end_game() {
  set_heart_beat(0);
  in_use  = 0; bet    = 0; thrown  = 0;
  player1 = 0; player2 = 0;
  name1  = 0; name2  = 0;
  score1  = 0; score2  = 0;
}

==================================================
FILE: misc/dead_book.c
==================================================

inherit "/std/book_dir";
#define DEAD_PAGES "/save/books/dead/dead_page"
void setup() {
  int i, max;
  seteuid(getuid());
  add_property("dead usable", 1);
  set_short("dark brown book");
  set_name("book");
  add_adjective( ({ "dark", "brown", "dead", "death", "dieing" }) );
  set_long("The book has some writing "
           "burnt into the dark brown leather cover.\n");
  add_read_mess("Introduction to death, or what to "
                "do when your blood runs out", 0, "general", 0 );
  set_book_language("general");
  set_book_dir(DEAD_PAGES);
  set_open_page(0);
}
void recovery_from_death() {
  call_out((: tell_object($1, the_short()+" crumbles and vanishes "
                              "mysteriously.\n") :), 1, previous_object());
  call_out("dest_me", 2);
}
mixed query_static_auto_load() { return 0; }
mixed query_dynamic_auto_load() { return 0; }
mixed query_auto_load() { return 0; }
void check_location() {
  if (environment() &&
      !environment()->query_property("dead") &&
      !environment()->query_creator()) {
    say(the_short()+" vanishes suddenly and randomly.\n");
    call_out("dest_me", 1);
  }
}
varargs int move(object dest, string mess1, string mess2) {
  ::move(dest, mess1, mess2);
  call_out("check_location", 1);
}

==================================================
FILE: misc/dead_chicken.c
==================================================

#include <move_failures.h>
#define CHICKEN_FEATHER "/obj/misc/chicken_feather"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "chicken" );
  set_short( "dead chicken" );
  add_alias( ({ "corpse", "chicken corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead chickens" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled chicken.  "
                  "Judging from the total lack of feathers it is "
                  "ready to be cooked.\n";
              return
                  "This is the dead body of a bedraggled chicken.  "
                  "Most people would pluck the few feathers on it "
                  "and then cook it.\n";
            } );
  set_weight( 8 );
  set_value( 300 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The chicken is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( CHICKEN_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead chicken with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead chicken cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

==================================================
FILE: misc/dead_duck.c
==================================================

#include <move_failures.h>
#define DUCK_FEATHER "/obj/misc/duck_feather.ob"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "duck" );
  set_short( "dead duck" );
  add_alias( ({ "corpse", "duck corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead ducks" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled duck.  Judging "
                  "from the lack of feathers it is ready to be "
                  "cooked.\n";
              return
                  "This is the dead body of a bedraggled duck.  "
                  "Most people would pluck it and then cook it.\n";
            } );
  set_weight( 10 );
  set_value( 400 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The duck is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( DUCK_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead duck with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead duck cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

==================================================
FILE: misc/dead_eel.c
==================================================

#include <move_failures.h>
#define EEL_SKIN "/obj/misc/eel_skin"
inherit "/obj/food";
void    setup();
void    init();
int     do_skin( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
int     test_sharp( object weapon );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int skinned;
void setup()
{
  set_name( "eel" );
  set_short( "dead eel" );
  add_alias( ({ "corpse", "eel corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead eels" );
  set_long( function()
	    {
	      if( skinned )
		return
		  "This is the dead body of an unfortunate eel.  "
		  "As if being dead wasn't bad enough, it has also "
		  "been skinned.\n";
	      return
		  "This is the dead body of an unfortunate eel.  "
		  "Most people skin such a fish before eating it.\n";
	    } );
  set_weight( 60 );
  set_value( 200 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "skin", this_object(),
        "<direct:object:me-here> with <indirect:object:me>" );
}
int do_skin( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object skin;
  if ( skinned ) return notify_fail( "The eel is already skinned.\n" );
  if( !test_sharp( indirect_obs[0] ) )
    {
      tell_room( environment( this_player() ),
	     this_player()->one_short() + " unsuccessfully tries to "
             "skin an eel with " + indirect_obs[0]->one_short() + ".\n",
             this_player() );
      return notify_fail( indirect_obs[0]->the_short() +
            " only makes a shallow mark in the eel skin.  "
            "It would probably be easier to skin the eel "
            "with some kind of sharp implement.\n" );
    }
  skinned = 1;
  skin = clone_object( EEL_SKIN );
  if( MOVE_OK != skin->move( this_player() ) )
        skin->move( environment() );
  tell_room( environment( this_player() ),
        this_player()->one_short() + " skins an eel with "
        + indirect_obs[0]->one_short() + ".\n",
        this_player() );
  return notify_fail( "You skin the dead eel with " +
        indirect_obs[0]->the_short() + ".\n" );
}
int test_sharp( object weapon )
{
  int i;
  mixed *pongo;
  pongo = weapon->weapon_attacks();
  for( i = 1; i < sizeof( pongo ); i++ )
    {
      if( pongo[i] == "sharp" ) return 1;
    }
  return 0;
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "skinned" : skinned ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  skinned = arg["skinned"];
}

==================================================
FILE: misc/delete_thyself.c
==================================================

inherit "/std/object";
void create() {
   ::create();
   if (clonep(this_object())) {
      call_out((: move("/room/rubbish") :), 3);
   }
}
void init_dynamic_arg(mapping map) {
}
void init_static_arg() {
}

==================================================
FILE: misc/deplusser.c
==================================================

inherit "/std/object.c";
void setup()  {
   set_short("deplusser");
   set_name("deplusser");
   set_long("It's shaped like a plus sign set in a circle, with a diagonal "
             "slash across it.  Type 'deplus <path>' to use.");
   set_weight(9);
}
void init()  {
   add_command("deplus", "<string'file'>", (:this_object()->deplus($4[0]):));
}
int deplus( string fname )  {
   string *files, *lines, last_line, this_line, next_line, old;
   int i, j, sz;
   seteuid(geteuid(this_player()));
   files = get_dir( this_player()->get_path( fname ) );
   if ( !sizeof(files) )
      return notify_fail( "No files found\n" );
   for (i = 0; i < sizeof(files); i++ )  {
      if ( file_size( this_player()->get_path( files[i] ) ) == -2 )  continue;
      old = read_file( this_player()->get_path( files[i] ) );
      lines = explode( replace_string( old, "\t", "   " ), "\n" );
      if ( ( sz = sizeof( lines ) ) < 2 )  continue;
      last_line = implode( explode( lines[0], " " ), "" );
      this_line = implode( explode( lines[1], " " ), "" );
      if ( sz > 2 )
         next_line = implode( explode( lines[2], " " ), "" );
      else next_line = "";
      for (j = 1, sz = sizeof(lines); j < sz - 1; j++ )  {
         if ( last_line[<2 .. <1] == "\"+"  &&
             strlen( this_line )  &&  this_line[0] == '\"' )
            lines[j-1] = lines[j-1][0 .. strsrch(lines[j-1], "+", -1) - 1];
         else if ( this_line[0 .. 1] == "+\""  &&
                   strlen(last_line)  && last_line[<1] == '\"' )
            lines[j] = " " + delete( lines[j], strsrch(lines[j], "+"), 1 );
         last_line = this_line;
         this_line = next_line;
         if ( j < sz - 2 )
            next_line = implode( explode( lines[j+2], " " ), "" );
      }
      if ( !rm( this_player()->get_path(files[i]) ) )
         write("Couldn't remove old file: " + files[i] + "\n" );
      else if ( !write_file(this_player()->get_path(files[i]),
                            implode(lines, "\n" ) + "\n" ) )  {
         write("Could not write new file: " + files[i] + "\n" );
         if ( !write_file(this_player()->get_path(files[i]), old ) )
            return notify_fail("Uh-oh, could not replace old file either.\n");
      }
      else write("File deplussed: " + files[i] + "\n");
   }
   return 1;
}

==================================================
FILE: misc/detabber.c
==================================================

inherit "/std/object";
void setup()
{   set_name("detabber");
    set_long("A long stick with absoulutely no tabs in it.\n"
             "Usage:  detab <filename>.\n");
}
void init()
{   this_player()->add_command("detab",this_object(),"<string>");
}
int do_detab(object *indirect_obs, string *dir_match, string indir_match, mixed *args, string pattern)
{
    string file;
    string tb;
    tb = sprintf("\t");
    file = read_file(args[0]);
    if(file)
        {file = replace_string(file,"\t","    ");
         write_file(args[0],file,1);
         return 1;
         }
    return 0;
}

==================================================
FILE: misc/easel.c
==================================================

#define DIRS ([ \
      "north" : ({ ({ 0, -1 }), ({ "|" }) }), \
      "northeast" : ({ ({ 1, -1 }), ({ "/" }) }), \
      "east" : ({ ({ 1, 0 }), ({ "-" }) }), \
      "southeast" : ({ ({ 1, 1 }), ({ "\\" }) }), \
      "south" : ({ ({ 0, 1 }), ({ "|" }) }), \
      "southwest" : ({ ({ -1, 1 }), ({ "/" }) }), \
      "west" : ({ ({ -1, 0 }), ({ "-" }) }), \
      "northwest" : ({ ({ -1, -1 }), ({ "\\" }) }), \
   ])
#define PRIMES ({ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 })
inherit "/std/object";
int *origin;
string *lines;
void setup() {
   set_name( "easel" );
   set_short( "small easel" );
   add_adjective( "small" );
   set_main_plural( "small easels" );
   set_value( 800 );
   origin = ({ 0, 0 });
   lines = ({ });
}
int *query_origin() { return origin; }
string *query_lines() { return lines; }
string long( string word, int dark ) {
   int i, max, min, width;
   string part;
   if ( !sizeof( lines ) )
      return "The easel is blank.\n";
   width = ( (int)this_player()->query_cols() - 2 ) / 2;
   min = origin[ 0 ] - width;
   max = origin[ 0 ] + width;
   if ( min < 0 ) {
      max -= min;
      min = 0;
   }
   if ( max >= strlen( lines[ 0 ] ) )
      max = strlen( lines[ 0 ] ) - 1;
   part = "";
   for ( i = 0; i < sizeof( lines ); i++ )
      part += " "+ lines[ i ][ min .. max ] +"\n";
   return part;
}
int query_at( int *place ) {
   if ( !sizeof( lines ) )
      return 32;
   if ( ( origin[ 0 ] + place[ 0 ] ) < 0 )
      return 32;
   if ( ( origin[ 0 ] + place[ 0 ] ) >= strlen( lines[ 0 ] ) )
      return 32;
   if ( ( origin[ 1 ] + place[ 1 ] ) < 0 )
      return 32;
   if ( ( origin[ 1 ] + place[ 1 ] ) >= sizeof( lines ) )
      return 32;
   return lines[ origin[ 1 ] + place[ 1 ] ][ origin[ 0 ] + place[ 0 ] ];
}
void add_shape( int *start, string *pieces ) {
   int i, number, max, width;
   string gap, front, back;
   for ( i = 0; i < sizeof( pieces ); i++ )
      if ( strlen( pieces[ i ] ) > max )
         max = strlen( pieces[ i ] );
   if ( sizeof( lines ) )
       width = strlen( lines[ 0 ] );
   else
      lines = ({ "" });
   if ( ( origin[ 0 ] + start[ 0 ] ) < 0 ) {
      gap = "";
      for ( i = origin[ 0 ] + start[ 0 ]; i < 0; i++ )
         gap += " ";
      for ( i = 0; i < sizeof( lines ); i++ )
         lines[ i ] = gap + lines[ i ];
      origin[ 0 ] = -start[ 0 ];
   }
   if ( ( origin[ 0 ] + start[ 0 ] + max ) > width ) {
      gap = "";
      for ( i = width; i < ( origin[ 0 ] + start[ 0 ] + max ); i++ )
         gap += " ";
      for ( i = 0; i < sizeof( lines ); i++ )
         lines[ i ] += gap;
   }
   max = sizeof( pieces );
   width = sizeof( lines );
   if ( ( origin[ 1 ] + start[ 1 ] ) < 0 ) {
      gap = "";
      for ( i = 0; i < strlen( lines[ 0 ] ); i++ )
         gap += " ";
      for ( i = origin[ 1 ] + start[ 1 ]; i < 0; i++ )
         lines = ({ gap }) + lines;
      origin[ 1 ] = -start[ 1 ];
   }
   if ( ( origin[ 1 ] + start[ 1 ] + max ) > width ) {
      gap = "";
      for ( i = 0; i < strlen( lines[ 0 ] ); i++ )
         gap += " ";
      for ( i = width; i < ( origin[ 1 ] + start[ 1 ] + max ); i++ )
         lines += ({ gap });
   }
   for ( i = origin[ 1 ] + start[ 1 ]; i < ( origin[ 1 ] + start[ 1 ] + max );
         i++ ) {
      number = origin[ 0 ] + start[ 0 ];
      if ( number > 0 )
         front = lines[ i ][ 0 .. number - 1 ];
      else
         front = "";
      number = origin[ 0 ] + start[ 0 ] +
            strlen( pieces[ i - origin[ 1 ] - start[ 1 ] ] );
      if ( number < strlen( lines[ i ] ) )
         back = lines[ i ][ number .. strlen( lines[ i ] ) - 1 ];
      else
         back = "";
      lines[ i ] = front + pieces[ i - origin[ 1 ] - start[ 1 ] ] + back;
   }
}
string *make_block( int size, int home ) {
   int i, j;
   string start, end, *blocks;
   if ( size == 1 )
      if ( home )
         return ({ "@" });
      else
         return ({ "#" });
   blocks = allocate( size );
   if ( home )
      blocks[ 0 ] = "@";
   else
      blocks[ 0 ] = "+";
   for ( i = 2; i < size; i++ )
      blocks[ 0 ] += "-";
   if ( home )
      blocks[ 0 ] += "@";
   else
      blocks[ 0 ] += "+";
   for ( i = 2; i < size; i++ ) {
      blocks[ i - 1 ] = "|";
      for ( j = 2; j < size; j++ )
         blocks[ i - 1 ] += ".";
      blocks[ i - 1 ] += "|";
   }
   if ( home )
      blocks[ size - 1 ] = "@";
   else
      blocks[ size - 1 ] = "+";
      for ( i = 2; i < size; i++ )
      blocks[ size - 1 ] += "-";
   if ( home )
      blocks[ size - 1 ] += "@";
   else
      blocks[ size - 1 ] += "+";
   return blocks;
}
void make_map( mixed *locations, mapping connections ) {
   int i, j, k, x, y, *sizes;
   string *places;
   mapping centres;
   sizes = ({ });
   places = ({ });
   centres = ([ ]);
   for ( i = 0; i < sizeof( locations ); i+= 2 ) {
      sizes += ({ locations[ i + 1 ] });
      places += ({ locations[ i ] });
      reset_eval_cost();
   }
   for ( i = 0; i < sizeof( PRIMES ); i++ ) {
      x = 0;
      y = 0;
      for ( j = 0; j < sizeof( sizes ); j++ ) {
         if ( PRIMES[ i ] > sizes[ j ] ) {
            x = 1;
            break;
         }
         if ( sizes[ j ] % PRIMES[ i ] )
            y = 1;
      }
      if ( x )
         break;
      if ( !y ) {
         for ( j = 0; j < sizeof( sizes ); j++ )
            sizes[ j ] /= PRIMES[ i ];
         i--;
      }
   }
   reset_eval_cost();
   centres[ places[ 0 ] ] = ({ 0, 0 });
   for ( i = 0; i < sizeof( places ); i++ ) {
      tell_object( find_player( "deutha" ), "On "+ i +", "+ places[ i ] +
            ", at "+ centres[ places[ i ] ][ 0 ] +", "+
            centres[ places[ i ] ][ 1 ] +" for "+ sizes[ i ] +"\n" );
      add_shape( ({ centres[ places[ i ] ][ 0 ] - sizes[ i ],
            centres[ places[ i ] ][ 1 ] - sizes[ i ] }),
            make_block( 2 * sizes[ i ] - 1, !i ) );
      if ( undefinedp( connections[ places[ i ] ] ) )
            continue;
      for ( j = 0; j < sizeof( connections[ places[ i ] ] ); j += 2 ) {
         reset_eval_cost();
         add_shape( ({ centres[ places[ i ] ][ 0 ] -1 + sizes[ i ] *
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 0 ],
               centres[ places[ i ] ][ 1 ] -1 + sizes[ i ] *
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 1 ] }),
               DIRS[ connections[ places[ i ] ][ j ] ][ 1 ] );
         k = member_array( connections[ places[ i ] ][ j + 1 ], places );
         if ( k < 0 )
            continue;
         x = centres[ places[ i ] ][ 0 ] +
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 0 ] *
               ( sizes[ i ] + sizes[ k ] );
         y = centres[ places[ i ] ][ 1 ] +
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 1 ] *
               ( sizes[ i ] + sizes[ k ] );
         centres[ places[ k ] ] = ({ x, y });
         tell_object( find_player( "deutha" ), "Put "+
               connections[ places[ i ] ][ j + 1 ] +" at "+
               x +", "+ y +"\n" );
         reset_eval_cost();
      }
   }
}

==================================================
FILE: misc/eel_skin.c
==================================================

inherit "/std/object";
void setup()
{
  set_name( "skin" );
  set_short( "eel skin" );
  add_adjective( "eel" );
  set_main_plural( "eel skins" );
  set_long( "This is the skin of an eel.  It is very greasy and "
        "glistens prettily when you tilt it towards the light.\n" );
  set_weight( 3 );
  set_value( 100 );
}

==================================================
FILE: misc/envelope.c
==================================================

#define SMALL   3
#define MEDIUM  5
#define LARGE   8
#define UNSEALED  1
#define SEALED    2
#define OPENED    3
inherit "/obj/baggage";
nosave int status;
void make_envelope( string description, int size ) {
   string adjective, noun;
   if( size < 2 )
      size = 2;
   switch( size ) {
      case 0..SMALL:
         adjective = "small";
         noun = "envelope";
         break;
      case SMALL + 1..MEDIUM:
         adjective = "medium sized";
         noun = "envelope";
         break;
      case MEDIUM + 1..LARGE:
         adjective = "large";
         noun = "envelope";
         break;
      default:
         adjective = "large";
         noun = "packet";
         add_alias("packet");
   }
   set_name( "envelope" );
   set_short( adjective + " " + description + " " + noun );
   add_adjective( adjective );
   add_adjective( explode( description, " " ) );
   set_long( "This is a " + adjective + " " + description + " envelope.  " );
   set_weight( 1 );
   set_value( 300 + size * 20 );
   set_max_weight( size );
   set_material( "paper" );
   add_property( "writeable", 1 );
   add_extra_look( this_object() );
   status = UNSEALED;
}
void init() {
   ::init();
   this_player()->add_command( "seal", this_object(),
      "<direct:object:me>" );
   this_player()->add_command( "unseal", this_object(),
      "<direct:object:me>" );
}
string long( string str, int dark ) {
   string desc;
   switch( status ) {
   case UNSEALED :
      desc = "It has a sticky flap at one end with which you could "
         "probably seal it if you wanted to, though it might be wise to put "
         "something into it first or you're going to feel rather silly.\n";
      break;
   case SEALED :
      desc = "The sticky flap seems to have been sealed down.\n";
      break;
   case OPENED :
      desc = "It looks like it has been sealed and then opened up.\n";
      break;
   default :
      desc = "It is completely broken - you'd better tell a liaison.\n";
   }
   return ::long( str, dark ) + desc;
}
int do_seal() {
   if( status != UNSEALED ) {
      return notify_fail( this_object()->the_short() + " has already been "
         "sealed.\n" );
   }
   do_close();
   set_stuck( 1 );
   status = SEALED;
   this_player()->add_succeeded_mess( this_object(), "$N lick$s the flap on "
      "$D and seal$s it down.\n", ({ }) );
   return 1;
}
int do_unseal() {
   if( status != SEALED ) {
      return notify_fail( this_object()->the_short() + " has not been "
         "sealed.\n" );
   }
   set_stuck( 0 );
   do_open();
   status = OPENED;
   this_player()->add_succeeded_mess( this_object(), "$N tear$s back the "
      "flap on $D and open$s it.\n", ({ }) );
   return 1;
}
int query_envelope_status() {
   return status;
}
mixed *stats() {
   return ::stats() + ({
      ({ "status", status, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "status" : status,
   ]);
}
void init_static_arg( mapping map ) {
   if( map["::"] )
      ::init_static_arg( map["::"] );
   if( !undefinedp( map["status"] ) )
      status = map["status"];
}
mixed query_static_auto_load() {
   if( base_name( this_object() ) + ".c" == __FILE__ )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: misc/fire_cracker.c
==================================================

inherit "/std/object";
#define EFFECT "/w/dogbolter/cracker_eff"
#define DURATION 180
void setup() {
    set_name( "firecracker" );
    add_alias( "cracker" );
    add_adjective( "fire" );
    add_plural( "crackers" );
    set_short( "fire cracker" );
    set_long( "This is a large red fire cracker of Auriental manufacture"
      ".  It's the sort of thing that is thrown at weddings.  You may "
      "'light' it, and 'throw' it.\n" );
    set_weight( 2 );
    set_value( 500 );
    set_read_mess("ACME Firecracker", "agatean");
}
void explosion() {
    object victim;
    if( !environment() )
        return;
    if( living( environment() ) ) {
        victim = environment();
        tell_object( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes in your face!\nMeep meep!%^RESET%^\n" );
        environment()->add_effect (EFFECT, DURATION);
        if( environment( environment() ) ) {
            tell_room( environment( environment() ), "%^BOLD%^%^RED%^$C$"+
              the_short() +" explodes in "+
              environment()->the_short() +"'s face!\nMeep meep!%^RESET%^\n",
              environment() );
        }
    } else {
        tell_room( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes!%^RESET%^\n" );
    }
    move( "/room/rubbish" );
}
int do_light() {
    call_out( (: explosion :), 10 );
    add_succeeded_mess( "$N $V $D and smoke begins to pour out.\n",
      ({ }) );
    return 1;
}
int do_throw() {
    if( environment() && environment( environment() ) ) {
        add_succeeded_mess( "$N $V $D on the ground.\n", ({ }) );
        move( environment( environment() ) );
        return 1;
    } else {
        add_failed_mess( "There is no ground to $V $D on.  How very odd\n",
          ({ }) );
        return 0;
    }
}
void init() {
    add_command( "light", "<direct:object:me>", (: do_light :) );
    add_command( "throw", "<direct:object:me>", (: do_throw :) );
}
string query_death_reason() {
    return "being blown up by a fire cracker, in true Road Runner Style.\n"
    "%^BOLD%^Meep meep!%^RED%^";
}

==================================================
FILE: misc/football.c
==================================================

inherit "/std/object";
string me, him;
void setup() {
     set_name("football");
     set_short("leather football");
     add_adjective("leather");
     add_alias("ball");
     set_long("This is a leather football, pumped up hard.  Looks like you could"
             " kick it to people.\n");
     set_weight(10);
     set_value(1);
     add_plural("footballs");
     add_plural("balls");
}
void init() {
  this_player()->add_command("kick", this_object(),
        "<direct:object:me> to <indirect:player>");
  add_command( "kickup", "<direct:object>" );
}
int do_kickup()  {
   write( "You kick the football into the air a few times, stopping it from "
   "hitting the floor by bouncing it off your knee, your chest and your feet."
   "  A rare display of skill!\n" );
tell_room( environment( this_player() ),
     this_player()->query_cap_name() + " expertly kicks the ball into the "
     "air, heads it back up, bounces it a few times on their chest and displays "
     "an uncanny level of skill.\n", this_player());
   return 1;
}
int do_kick(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks "+
        this_object()->query_short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A leather football flies "
        "through the air, "+ in_dir[0]->query_name()+" tries to trap it "
        "but fails and it lands next to them.", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks a "
           "leather football at you.  It curls towards you at speed but you "
           "manage to " +
           ({ "trap it with your foot.",
           "bounce it off your chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stand"
           " on it",
           "catch it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  You should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+"\n");
    tell_room(environment(in_dir[0]), "A leather football curls "
           "gracefully towards "+ in_dir[0]->query_cap_name()+", who "+
                "manages to "+
                ({ "trap it with their foot.",
           "bounce it off their chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stands"
           " on it",
           "catches it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  They should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+
                "\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

==================================================
FILE: misc/football.s
==================================================



==================================================
FILE: misc/fountain.c
==================================================

#include <volumes.h>
#define FOUNTAIN_SIZE 150000
#define DEFAULT_CYCLE_TIME 60 * ( 2 + random( 2 ) )
inherit "/obj/vessel";
string _liquid_path;
int _liquid_volume;
int _time;
void setup() {
  set_name( "fountain" );
  set_short( "fountain" );
  set_long( "This is a fountain.\n" );
  set_max_volume( FOUNTAIN_SIZE );
  set_weight( 100000 );
  set_stuck( 1 );
}
varargs void initialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  call_out( "make_water", 5 );
  return;
}
varargs void reinitialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  return;
}
void make_water() {
object water;
  if ( !( query_max_volume() - query_volume() ) ) {
    tell_room( environment(), sprintf( "Some of the %s in %s sloshes over the sides.\n",
      query_multiple_short( all_inventory() ), this_object()->the_short() ) );
    remove_volume( -VOLUME_QUART * random( 4 ) * 2 );
  }
  water = clone_object( _liquid_path );
  water->set_amount( _liquid_volume );
  call_out( (: $(water)->move( this_object() ) :), 1 );
  switch( water->query_amount() ) {
	case 0 .. VOLUME_SHOT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
  	  water->a_short(), ({ "trickles", "seeps", "dribbles" })[random(3)],
	  this_object()->the_short() ) );
      break;
    case VOLUME_SHOT + 1 .. VOLUME_PINT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(),  ({ "flows", "splashes", "pours" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_PINT + 1 .. VOLUME_LITRE:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(), ({ "streams", "cascades", "sloshes" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_LITRE + 1 .. VOLUME_QUART:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
	    water->a_short(), ({ "gushes", "courses", "swirls" })[random(3)],
        this_object()->the_short() ) );
      break;
    default:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
        water->a_short(), ({ "floods", "surges", "washes" })[random(3)],
  	    this_object()->the_short() ) );
      break;
  }
  call_out( "make_water", _time );
}

==================================================
FILE: misc/frisbee.c
==================================================

inherit "/std/object";
string me, him;
void setup() {
  set_name("frisbee");
  set_short("black frisbee");
  add_adjective("black");
  set_long("This is a small black frisbee.  It looks like you could "
           "throw it to "
           "people.\n");
  add_property("feeding_frenzy", "frisbee");
  set_weight(10);
  set_value(200);
  set_main_plural("black frisbees");
  add_plural("frisbees");
}
void init() {
  this_player()->add_command("throw", this_object(),
                             "<direct:object:me> to <indirect:player>");
}
int do_throw(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->one_short()+" throws "+
                this_object()->short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A frisbee arcs through the air, "+
              in_dir[0]->query_name()+" tries to catch it but fails and it "+
              "falls on the floor.\n", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->one_short()+" throws a frisbee "+
                "at you, you catch it... just.\n");
    tell_room(environment(in_dir[0]), in_dir[0]->one_short()+
          " fumbles the catch of the "+
          short(0)+" but manages to keep hold of it.\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

==================================================
FILE: misc/glass.c
==================================================

inherit "/obj/vessel";
nosave string description, actual_drink, actual_glass_size;
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_name("glass");
    set_weight(1);
    set_value(400);
    set_stuck(1);
    set_leak_rate(0);
    set_material("glass");
    add_property("fragile", 200);
    if (!do_setup) {
        this_object()->setup();
    }
}
void make_glass(string drink, string glass_description, string glass_size,
   int amount, int has_contents)
{
    string *glass_adjectives;
    object contents;
    description = glass_description;
    actual_drink = drink;
    actual_glass_size = glass_size;
    glass_adjectives = explode( glass_size, " " )[0..<2];
    set_short( glass_size );
    set_long( (: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        " " + actual_drink + ".\n" :) );
    glass_adjectives = explode( glass_size, " " );
    if (sizeof(glass_adjectives) > 1)
        add_alias(glass_adjectives[<1..]);
    else
        add_alias(glass_size);
    add_adjective(glass_adjectives);
    set_max_volume(amount);
    if (has_contents) {
        contents = clone_object("/obj/reagents/generic_liquid.ob");
        contents->set_name("drink");
        contents->set_short(drink);
        contents->set_long("This is some delicious looking " + drink + ".\n" );
        contents->add_adjectives(explode(drink, " ")[0..<2]);
        contents->add_alias( explode( drink, " " )[ sizeof(
           explode( drink, " " ) ) - 1 ] );
        contents->set_amount(amount);
        contents->move(this_object());
    }
}
mapping int_query_static_auto_load() {
    return ([
        "::": ::int_query_static_auto_load(),
        "description": description,
        "actual_drink" : actual_drink,
        "actual_glass_size" : actual_glass_size,
    ]);
}
void init_static_arg(mapping map) {
    if (map["::"])
        ::init_static_arg(map["::"]);
    if (!undefinedp(map["description"]))
        description = map["description"];
    if (!undefinedp(map["actual_drink"]))
        actual_drink = map["actual_drink"];
    if (!undefinedp(map["actual_glass_size"]))
        actual_glass_size = map["actual_glass_size"];
    set_long((: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        "sort of " + actual_drink + ".\n" :));
}
mixed query_static_auto_load() {
    if (base_name(this_object()) == "/obj/misc/glass" )
        return int_query_static_auto_load();
    return ([ ]);
}

==================================================
FILE: misc/golem_corpse.c
==================================================

#include <armoury.h>
inherit "/obj/container";
void make_fragments();
void setup() {
    set_name( "rubble" );
    set_short( "heap of clay rubble" );
    add_alias( ({"heap", "clay"}) );
    add_adjective( ({"heap of", "clay"}) );
    set_main_plural( "heaps of clay rubble" );
    add_plural( "heaps" );
    set_weight( 40000 );
    set_max_weight( 50000 );
    set_value( 0 );
    set_stuck( 1 );
    make_fragments();
    add_property( "no recycling", 1 );
}
void make_fragments() {
    int amount = random( 8 );
    int i;
    for( i = 1; i <= amount; i++ )
        switch( random( 11 ) ) {
           case 0..5:
               ARMOURY->request_item( "golem shard", 100 )->
                   move( this_object() );
               break;
           case 6..7:
               ARMOURY->request_item( "golem finger", 100 )->
                   move( this_object() );
               break;
           case 8..9:
               ARMOURY->request_item( "golem toe", 100 )->
                   move( this_object() );
               break;
           case 10:
               ARMOURY->request_item( "golem eye", 100 )->
                   move( this_object() );
               break;
        }
}
string long( string word, int dark ) {
    string inv = query_multiple_short( all_inventory( this_object() ) );
    string tmp = "";
    switch( sizeof( all_inventory( this_object() ) ) ) {
        case 0:
           break;
        case 1:
            tmp = "Something that looks like " + inv + " protrudes from it.  ";
            break;
        default:
            tmp = "It looks like " + inv + " are buried in it.  ";
    }
    return "This is a large heap of shattered clay.  " + tmp + "Whatever this "
        "was before, it is destroyed thouroughly and beyond any means of "
        "repair.\n";
}

==================================================
FILE: misc/golem_eye.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "triangle" );
    set_short( "clay triangle" );
    add_adjective( ({"clay"}) );
    set_long( "This is a cracked piece of clay.  A hole in the shape of a "
       "triangle is in its middle.\n" );
    set_main_plural( "clay triangles" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_finger.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "fingertip" );
    set_short( "broken clay fingertip" );
    add_adjective( ({"broken", "clay"}) );
    set_long( "This looks like a crude fingertip made of clay.  It is broken "
       "in the middle.\n" );
    set_main_plural( "broken clay fingertips" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_shard.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "shard" );
    set_short( "cracked clay shard" );
    add_adjective( ({"clay"}) );
    set_long( "This is a heavily cracked clay shard." );
    set_main_plural( "cracked clay shards" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_toe.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "toe" );
    set_short( "remains of a clay toe" );
    add_adjective( ({"remains", "of", "a", "clay"}) );
    set_long( "This looks part of a toe made of clay.\n" );
    set_main_plural( "remains of clay toes" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
    add_property( "determinate", "the " );
}

==================================================
FILE: misc/grinder.c
==================================================

#include <move_failures.h>
#define STATE_CHANGE "/obj/handlers/state_change"
inherit "/obj/container";
int test_add(object ob, int flag);
int do_grind( string what );
int do_empty(object *dest, string me, string him, string prep);
void set_max_grindable( int i );
int query_max_grindable();
string long_status();
private int _max_grind = 0;
void setup() {
  set_name( "grinder" );
  set_short( "food grinder" );
  add_adjective( "food" );
  set_main_plural( "food grinders" );
  set_long( "This is a mechanical contraption to grind food into small "
      "pieces.  There is a funnel-type piece at the top, a crank on one "
      "side and on the other a pipe where the ground food comes out and "
      "is caught in a small tray.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_weight( 100 );
}
void init() {
  this_player()->add_command( "grind", this_object(),
      "<string'object'> in <direct:object'" + query_short() + "'>",
      (: do_grind( $4[0] ) :) );
  add_command( "empty", "<direct:object>" );
}
int test_add(object ob, int flag) {
  object stuff = first_inventory();
  if (stuff) {
    add_failed_mess( "There is already some " + stuff->query_short()
      + " in the grinder.  You'll have to empty it first.\n");
    return 0;
  } else return 1;
}
int do_grind( string what ) {
  object *things, thing;
  object ground;
  object contents;
  things = match_objects_for_existence( what, ({ this_object(),
                                                 this_player() }) );
  if( !sizeof( things ) ) {
    add_failed_mess( "You must be holding something or put it in $D in "
                     "order to $V it.\n" );
    return -1;
  }
  thing = things[0];
  if( ( contents = first_inventory() ) && contents != thing ) {
    add_failed_mess( "$D isn't empty.\n" );
    return -1;
  }
  if( query_max_grindable() &&
      ( thing->query_amount() > query_max_grindable() ||
        thing->query_weight() > query_max_grindable() ) ) {
    add_failed_mess( "You cannot grind that much with $D at once.\n" );
    return -1;
  }
  ground = STATE_CHANGE->transform( thing, "grind" );
  if ( !objectp( ground ) ) {
    add_failed_mess( "You cannot $V $I in $D.\n", ({ thing }) );
    return -1;
  }
  thing->move( "/room/rubbish" );
  if( ground->move( this_object() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N grind$s $I with $D, spilling it onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  this_player()->add_succeeded_mess( this_object(), "$N grind$s $I "
    "in $D.\n", ({ thing }) );
  return 1;
}
int do_empty(object *dest, string me, string him, string prep) {
  object ground = first_inventory( this_object() );
  if( !ground ) {
    add_failed_mess( "There is nothing in $D.\n" );
    return 0;
  }
  if( ground->move( this_player() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N $V $D onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  return 1;
}
void set_max_grindable( int i ) { _max_grind = i; }
int query_max_grindable() { return _max_grind; }
string long_status() { return ""; }

==================================================
FILE: misc/housing_creator.c
==================================================

inherit "/std/object";
#include <housing.h>
#define ORIENTATION ({ "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "up" })
#define OPP_ORIENTATION ({ "south", "southwest", "west", "northwest", "north", "northeast", "east", "southeast", "down" })
#define PATH "/std/houses/"
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test);
string list_plans();
void setup() {
  set_name("ball");
  set_short("small jade ball");
  add_adjective(({"small", "jade"}));
  set_long("This non-descript jade ball can be used to make player houses.\n");
  set_read_mess((: list_plans() :));
  set_weight(1);
  set_value(0);
  seteuid("Room");
}
void init() {
  this_player()->add_command("make", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 1) :) );
  this_player()->add_command("makereal", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 0) :) );
  this_player()->add_command("maketest", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 1, 1) :) );
}
string list_plans() {
  string ret, str;
  string plan;
  ret = "To create a house use:\n"
    "  'make <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makereal <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makeforce <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  floor plan is one of the standard floor plans\n"
    "  orientation is its orientation (ie. the direction you enter it to)\n"
    "  location is the directory to write the houses files into\n"
    "  address is a the unique address for the house\n"
    "  region is the region of the house\n"
    "The 'makereal' command will add the house into the housing handler, "
    "the 'make' command will do a normal test make and the 'makeforce' "
    "will overwrite any existing housing files.\n\n"
    "Example:\n"
    "$I$5=   makereal twobedhouse south /d/am/fluff/housing OUT+room1 am \"12 Fluff Street\"\n\n$I$0="
    "The following floorplans are available:\n";
  str = "";
  foreach(plan in get_dir(PATH + "*")) {
    if(plan != "." && plan != ".." && file_size(PATH + plan) == -2 )
      str += plan + "\n";
  }
  ret += sprintf("%-#*s", this_player()->query_cols(), str);
  return ret;
}
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test) {
  string room;
  string tmp;
  string fname;
  mapping files;
  mapping main_file;
  string number;
  int orient;
  int i;
  if(file_size(PATH+type) != -2) {
    return notify_fail("No such floor plan\n");
  }
  orient = member_array(orientation, ORIENTATION);
  if(orient == -1) {
    return notify_fail("No such orientation.\n");
  }
  if(file_size(location) != -2) {
    return notify_fail("No such location.\n");
  }
  if (address[0] < '0' || address[0] > '9') {
     add_failed_mess("Address must start with a number.\n");
     return 0;
  }
  i = 0;
  do {
     i++;
  } while (address[i] != ' ');
  number = address[0..i-1];
  address = address[i..];
  if (out[0] == '/') {
     if (out[<2..] == ".c") {
        out = out[0..<3];
     }
     out = "\"" + out + "\"";
  } else {
     if (member_array('+', out) == -1) {
        out = "PATH+\"" + out + "\"";
     }
  }
  files = ([ ]);
  main_file = ([ ]);
  if (type[<1] != 'M') {
     main_file[""] = 0;
  }
  foreach(room in get_dir(PATH+type+"

==================================================
FILE: misc/ink_well.c
==================================================

inherit "/obj/container";
void create() {
  ::create();
  set_name("well");
  add_adjective("ink");
  set_short("ink well");
  set_long("A nice, small ink well.\n");
  set_value( 500 );
  set_leak_rate(0);
  set_max_volume(250);
  set_volume(200);
  set_water_volume(200);
  set_ps_coord_quantity((int *)"/std/effects/other/ink"->query_coordinate(), 200);
}

==================================================
FILE: misc/juicer.c
==================================================

#include  <bit.h>
inherit "/obj/vessel";
int juice_bit( object ob, string fn );
mapping juice_funs = ([
  "/std/bit" : (: juice_bit :),
]);
void setup() {
  set_name( "juicer" );
  set_short( "juicer" );
  set_main_plural( "juicers" );
  set_long( "This is a device for extracting the juice or liquid from " +
            "objects.  It has a hole at the top for inserting things, " +
            "and a small bowl at the bottom to catch the juice.  You " +
            "could probably \"juice\" something and then \"pour\" " +
            "the juicer into another container.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_volume( 19200 );
}
void init() {
  ::init();
  this_player()->add_command( "juice", this_object(), "%I 'in' %D" );
}
int do_juice( object *things ) {
  int i, amount, *weight_unit, percent;
  string medium_short, *types, fn;
  mapping amount_types;
  if ( living( environment() ) ) {
    this_player()->add_failed_mess( this_object(), "You have to put down "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  for ( i = 0; i < sizeof( things ); i++ )
    if ( environment( things[ i ] ) != this_player() ) {
      things = delete( things, i, 1 );
      i--;
    }
  if ( !sizeof( things ) ) {
    this_player()->add_failed_mess( this_object(), "You should be carrying "+
        "whatever you want to $V in $D", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You should only $V "+
        "one thing at a time in $D in case they get mixed up.\n", ({ }) );
    return 0;
  }
  if ( !function_exists( "query_continuous", things[ 0 ] ) ) {
    if ( fn = things[ 0 ]->query_property("juice")
        && functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    fn = explode(file_name(things[ 0 ]), "#")[ 0 ];
    if (functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    this_player()->add_failed_mess( this_object(), "You cannot $V $I "+
        "in $D.  Trust me on this.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !(percent = things[ 0 ]->query_property("%liquid")) ) {
    this_player()->add_failed_mess( this_object(), "$I apparently doesn't " +
        "contain much juice.\n", ({ things[ 0 ] }) );
    things[ 0 ]->move("/room/rubbish");
    return 0;
  }
  things[ 0 ]->add_plural( (string)things[ 0 ]->query_name() );
  if ((amount = (int)things[ 0 ]->query_amount()) == 0) {
    weight_unit = (int *)things[ 0 ]->query_weight_unit();
    amount = ( weight_unit[ 1 ] * (int)things[ 0 ]->query_weight() ) /
      weight_unit[ 0 ];
    amount = ( ( 50 + random( 21 ) ) * amount ) / 80;
  }
  things[ 0 ]->set_amount( amount*percent/100 );
  things[ 0 ]->set_weight_per_bite( 0 );
  things[ 0 ]->set_bites_gone( 0 );
  medium_short = (string)things[ 0 ]->query_medium_short();
  if ( !medium_short )
    medium_short = (string)things[ 0 ]->query_short();
  if ( !things[ 0 ]->query_medium_alias() )
    things[ 0 ]->set_medium_alias( "Ground"+ capitalize( medium_short ) );
  amount_types = ([ "drop" : ({ 1, "drops" }), "ounce" :
        ({ 120, "ounces" }), "pint" : ({ 2400, "pints" }) ]);
  things[ 0 ]->set_amount_types( amount_types );
  types = m_indices( amount_types );
  for ( i = 0; i < sizeof( types ); i++ )
    things[ 0 ]->add_adjective( ({ types[ i ],
        amount_types[ types[ i ] ][ 1 ] }) );
  things[ 0 ]->add_adjective( "of" );
  if ( !sizeof( (mixed *)things[ 0 ]->query_pile_types() ) )
    things[ 0 ]->set_pile_types( ({ 50, "small", 2400, "medium", 19200,
        "large", "huge" }) );
  things[ 0 ]->add_property( "determinate", "some " );
  things[ 0 ]->grind();
  things[ 0 ]->move( this_object() );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
      ({ things[ 0 ] }) );
  return 1;
}
int juice_bit( object ob, string fn ) {
    object juice_ob;
    mixed *bit_data;
    string *m, s;
    int i;
    juice_ob = clone_object("/obj/reagents/generic_liquid.ob");
    juice_ob->set_name("juice");
    if (s = ob->query_race_name())
      s = capitalize(s);
    bit_data = ob->query_bit_data();
    m = explode(bit_data[ BIT_NAME ], " ");
    for ( i = 0; i < sizeof(m); i++ )
      s += capitalize(m[i]?m[i]:"");
    juice_ob->set_medium_alias(s+"Juice");
    switch ( bit_data[ BIT_ALIAS ] ) {
      case "eye":
        juice_ob->add_adjective("eye");
        juice_ob->add_alias("ichor");
        juice_ob->set_short("clear liquid");
        juice_ob->set_long("This is a clear liquid, slightly tinged" +
                           "with blood.\n");
        juice_ob->set_amount(10*(int)ob->query_weight() + 10);
        break;
      default:
        juice_ob->set_short("liquid");
        juice_ob->set_long("This is a non-descript liquid.  It's probably " +
                           "useless.\n");
        break;
    }
    juice_ob->move(this_object());
    ob->move("/room/rubbish");
    this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
                                      ({ juice_ob }) );
    return 1;
}

==================================================
FILE: misc/keyring.c
==================================================

inherit "/std/container";
void create() {
   do_setup++;
   container::create();
   set_name( "keyring" );
   set_short( "keyring" );
   add_property( "determinate", "a " );
   set_main_plural( "keyrings" );
   add_property("shop type", "jewellers");
   set_long( "This is a ring of metal that overlaps itself at one point, "
         "allowing keys to be strung onto it and be kept together.  It's "
         "amazing how useful a ring of metal can be.\n" );
   set_weight( 2 );
   set_value( 20 );
   set_max_weight( 1 );
   do_setup--;
   if (!do_setup)
      this_object()->setup();
}
string long( string word, int dark ) {
   return ::long( word, dark ) +
         query_contents( "$C$"+ the_short() +" holds: " );
}
mapping query_properties() {
   object thing;
   mixed arg, *args;
   mapping props, map;
   props = ::query_properties();
   args = copy( keys( props ) );
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      map = (mapping)thing->query_properties();
      foreach ( arg in keys( map ) ) {
         if ( !stringp( arg ) ) {
            continue;
         }
         if ( member_array( arg, args ) != -1 ) {
            continue;
         }
         props[ arg ] = map[ arg ];
         args += ({ arg });
      }
   }
   return props;
}
mixed query_property( string word ) {
   object thing;
   mixed arg;
   arg = ::query_property( word );
   if ( arg ) {
      return arg;
   }
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      arg = (mixed)thing->query_property( word );
      if ( arg ) {
         return arg;
      }
   }
   return 0;
}
int test_add( object thing, int flag ) {
   if ( !thing->id( "key" ) && environment( thing ) ) {
      return 0;
   }
   return 1;
}
int add_weight(int n) {
  int tmp, ret;
  if(sizeof(all_inventory(this_object())) >= 15)
    return 0;
  return ::add_weight(n);
}
mapping query_static_auto_load() {
   if ( explode( file_name(), "#" )[ 0 ] == "/obj/misc/keyring" ) {
      return int_query_static_auto_load();
   }
   return ([ ]);
}

==================================================
FILE: misc/label.c
==================================================

inherit "/std/object";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "label" );
   set_short( "small label" );
   add_adjective( "small" );
   set_main_plural( "small labels" );
   set_long( "This is a small label made from paper with some sort of "+
         "dried glue smeared on one side.  You could probably \"stick\" "+
         "it onto something.\n" );
   set_value( 100 );
   add_property( "writeable", 1 );
   add_property( "label", 1 );
   set_max_size( 200 );
   if ( !do_setup )
      this_object()->setup();
}
void init() {
   this_player()->add_command( "stick", this_object(),
         "<direct:object:me> to <indirect:object>" );
}
int do_stick( mixed *things ) {
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can't stick $D to more than one thing at a time.\n");
      return 0;
   }
   if ( things[ 0 ] == this_object() ) {
      add_failed_mess("You cannott stick $D to itself!\n");
      return 0;
   }
   things[ 0 ]->add_effect( "/std/effects/object/label", this_object() );
   add_succeeded_mess("$N lick$s $D and stick$s it to $I.\n", things[0..0]);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/label" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}

==================================================
FILE: misc/lantern.c
==================================================

inherit "/obj/lantern";
void setup() {
   fuel_left = 3600;
   is_lit    = 0;
   set_name( "lantern" );
   set_main_plural( "lanterns");
   set_short( "lantern" );
   add_help_file("torch");
   set_long(function() {
     string str;
     str = "This is a camping lantern, which smells of lamp oil.\n";
     if ( is_lit ) {
       return str + "The wick flickers inside spreading a dull "
         "glow.\n";
     }
     str += "The lantern is not lit, and ";
     if ( !fuel_left )
       return str + "is out of oil.\n";
     return str + "has some oil left in it.\n";
   } );
   set_weight( 60 );
   set_value( 150 );
}

==================================================
FILE: misc/lock.c
==================================================

inherit "/std/object";
#include <move_failures.h>
void create() {
  add_help_file("door_lock");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  this_player()->add_command("change", this_object(),
      "[lock in] <indirect:object:here'door or furniture'> for "
                             "<indirect:object:me'lock'>");
}
int do_change(mixed *in_dir, string direct, string indirect, mixed *args,
              string) {
  object lock;
  object ob;
  object item;
  object other;
  string other_id;
  item = in_dir[0][0];
  lock = in_dir[1][0];
  if(function_exists("query_my_room", item) &&
     (query_property("locktype") != "door"))
    return notify_fail("This lock is not suitable for a door.\n");
  if(item->query_furniture()) {
    switch(item->query_pick_skill()) {
    case "covert.lockpick.door":
      if(query_property("locktype") != "furniture")
        return notify_fail("This lock is not suitable for furniture.\n");
    case "covert.lockpick.safes":
      if(query_property("locktype") != "safe")
        return notify_fail("This lock is not suitable for safes.\n");
    }
  }
  if(function_exists("query_my_room", item) &&
     !function_exists("test_occupier", environment(this_player())))
    return notify_fail("You cannot change the locks here.\n");
  if(function_exists("test_occupier", environment(this_player())) &&
     !environment(this_player())->test_occupier(this_player()->query_name())
     && !this_player()->query_creator())
    return notify_fail("Sorry, only the owner of the house can change the "
                       "locks on items in the house.\n");
  if(!function_exists("pick_lock", item))
    return notify_fail("Sorry, that object can't take a lock.\n");
  if(!item->query_unlocked())
    return notify_fail("Sorry, the item must be unlocked in order to change "
                       "its lock.\n");
  if(!lock->query_property("key prop")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a key.\n", ({ lock }));
    return 0;
  }
  if(!lock->query_property("difficulty")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a difficulty.\n", ({ lock }));
    return 0;
  }
  item->set_key(lock->query_property("key prop"));
  item->set_difficulty(lock->query_property("difficulty"));
  item->set_lock_owner(environment(this_player())->query_owner());
  item->set_trap_armed(0);
  if(function_exists("query_my_room", item)) {
    other = load_object(item->query_dest());
    other_id = item->query_other_id();
    other->modify_exit(other_id, ({ "key", lock->query_property("key prop")}));
    other->modify_exit(other_id, ({ "difficulty",
                                      lock->query_property("difficulty")}));
    other->modify_exit(other_id, ({ "lock owner",
                                      environment(this_player())->query_owner()
                                      }));
    environment(this_player())->update_doors();
    other->update_doors();
    environment(this_player())->do_save();
    other->do_save();
  }
  ob = clone_object("/std/object");
  ob->set_name("lock");
  ob->set_short("busted lock");
  ob->add_adjective("busted");
  ob->set_main_plural("busted locks");
  ob->set_long("A broken door lock.\n");
  ob->set_value(0);
  ob->set_weight(lock->query_weight());
  ob->move(environment());
  if(lock->move("/room/rubbish") != MOVE_OK)
    lock->dest_me();
  this_player()->add_succeeded_mess(this_object(),
                                    "$N remove$s the existing, and now "
                                    "broken, lock from $I and replace$s it "
                                    "with the new one.\n", ({ item }));
  return 1;
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

==================================================
FILE: misc/mailer_ob.c
==================================================

inherit "/std/object";
int do_mail(string str);
void setup() {
  set_name("mailer");
  set_short( "mailer object" );
  set_long("It is a small black box with pictures of small red demons "
           "painted on "+
           "the front.  Though, some of them look suspicously like frogs.\n");
  set_weight(1);
  reset_drop();
}
void init() {
  add_command("mail", "", (: do_mail(0) :) );
  add_command("mail", "<string>", (: do_mail($4[0]) :) );
}
int do_mail(string str) {
  return (int)"/obj/handlers/mail_track"->mail(str);
}

==================================================
FILE: misc/menu.c
==================================================

inherit "/std/object";
#include <language.h>
object our_pub;
void create() {
  ::create();
  set_name("menu");
  set_long("This is a menu.\n");
  reset_get();
}
void set_pub(object pub) {
  our_pub = pub;
  add_read_mess(our_pub->read(), "printed letters", our_pub->query_language());
}
object query_pub() { return our_pub; }
void init() {
  this_player()->add_command( "list", this_object(), "" );
}
string query_readable_message(object player) {
   string lang;
   string mess;
   mess = our_pub->read();
   lang = our_pub->query_language();
   mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
   return mess;
}
int do_list() {
  write(query_readable_message(this_player()));
  add_succeeded_mess(({ "", "$N read$s $D.\n" }));
  return 1;
}

==================================================
FILE: misc/mortar_pestle.c
==================================================

inherit "/obj/misc/grinder";
void setup() {
  set_name( "pestle" );
  set_short( "mortar and pestle" );
  set_long( "Roughly hewn from stone, the mortar's bowl has been "
      "smoothed from long use.  The stone pestle used for grinding "
      "herbs within the bowl is smooth as well and hangs from a "
      "leather thong tied through a ring in the side of the bowl.\n" );
  set_main_plural( "mortars and pestles" );
  add_adjective( ({ "mortar and", "rough", "stone", "smooth" }) );
  add_alias( ({ "mortar", "pestle", "bowl" }) );
  set_value( 800 );
  set_weight( 44 );
  set_max_grindable( 8 );
  set_max_weight( 8 );
}

==================================================
FILE: misc/newspaper.c
==================================================

inherit "/std/book";
#include <room/newspaper.h>
#define AUTO_LOAD_TAG "newspaper"
private string _paper;
private int _edition;
void setup() {
  set_name("newspaper");
  set_short("newspaper");
  add_alias("paper");
  add_plural("papers");
  set_long("A bunch of nice newspapers.\n");
  set_main_plural("newspapers");
  set_weight(10);
  set_value(10);
  set_ignore_saved_pages(1);
}
int query_binding_force() {
  return 100;
}
void setup_paper() {
   class article* articles;
   class advert* adverts;
   class advert data;
   string* bits;
   int i;
   int j;
   string header;
   string index;
   string fluff;
   int page;
   mixed* stuff;
   object ob;
   if (_paper && _edition) {
      bits = explode(_paper, " ");
      if (bits[0] != "The") {
         set_short("copy of the " + _paper);
         add_adjective( ({ "the" }) );
         set_main_plural("copies of the " + _paper);
      } else {
         set_short("copy of " + _paper);
         set_main_plural("copies of " + _paper);
         add_plural_adjective("copies");
      }
      bits = map(bits, (: lower_case($1) :));
      add_adjective( ({ "copy", "of" }) );
      add_adjective(bits[0..<2]);
      add_alias(lower_case(bits[<1]));
      add_property("determinate", "a ");
      page = query_open_page();
      articles = NEWSPAPER_HANDLER->query_edition_articles(_paper, _edition);
      set_no_pages(sizeof(articles) + 1);
      index = "Edition #" + _edition + " of " + _paper + ".\n%^BOLD%^" +
              NEWSPAPER_HANDLER->query_paper_headline(_paper, _edition) +
              "%^RESET%^\n\n";
      index += sprintf("%2d .... %70-=s\n", 1, "Contents");
      for (i = 0; i < sizeof(articles); i++) {
         set_open_page(i + 2);
         ob = query_current_page();
         ob->set_value(0);
         if (articles[i]->colour) {
            index += "%^" + articles[i]->colour + "%^";
         }
         switch (articles[i]->type) {
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            header = "%^BOLD%^%^CYAN%^'Adverts'%^RESET%^\n\n";
            adverts = NEWSPAPER_HANDLER->query_edition_adverts(_paper, _edition);
            stuff = unique_array(adverts, (: $1->category :) );
            foreach (adverts in stuff) {
               header += "\n$I$0=" + adverts[0]->category + "\n$I$3=   ";
               foreach (data in adverts)  {
                  header += data->text + "\n-- " + data->author + "\n\n";
               }
            }
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            header = "%^BOLD%^" + articles[i]->title + "'%^RESET%^\n\n";
            for (j = i + 1; j < sizeof(articles); j++) {
               if (articles[j]->type == NEWSPAPER_ARTICLE_TYPE_SECTION) {
                  break;
               }
               header += sprintf("%2d .... %70-=s\n", i + 2, articles[j]->title);
            }
            index += sprintf("%2d -=== %65|=s ===-\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            header = "%^BOLD%^%^CYAN%^'" + articles[i]->title + "'%^RESET%^ at " +
                     ctime(articles[i]->date_written)[0..10] + "\n" +
                     "by " + articles[i]->shown_name;
            header += NEWSPAPER_HANDLER->query_article_text_plain(articles[i]);
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         }
         if (articles[i]->colour) {
            index += "%^RESET%^";
         }
         set_read_mess( header, NEWSPAPER_HANDLER->query_language_for( _paper ),
             0 );
      }
      set_open_page(1);
      set_read_mess( index, NEWSPAPER_HANDLER->query_language_for( _paper ), 0);
      ob = query_current_page();
      ob->set_value(0);
      fluff = NEWSPAPER_HANDLER->query_paper_long(_paper);
      if (fluff[<1] != '\n') {
         fluff += "\n";
      }
      set_long(fluff + "Edition " + _edition + " of " + _paper + ".\n");
      set_open_page(page);
   }
}
void set_paper(string paper) {
   _paper = paper;
   set_long(NEWSPAPER_HANDLER->query_paper_long(_paper));
   setup_paper();
}
void set_edition(int edition) {
   _edition = edition;
   setup_paper();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, AUTO_LOAD_TAG, "paper", _paper);
   add_auto_load_value(map, AUTO_LOAD_TAG, "edition", _edition);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   ::init_dynamic_arg(map);
   set_paper(query_auto_load_value(map, AUTO_LOAD_TAG, "paper"));
   set_edition(query_auto_load_value(map, AUTO_LOAD_TAG, "edition"));
}

==================================================
FILE: misc/newspaper_box.c
==================================================

inherit "/std/object";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
private string _paper;
void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   reset_get();
}
void set_paper(string paper) {
   int cost;
   string place;
   string* bits;
   _paper = paper;
   place = query_property("place");
   if (!place) {
      if (environment()) {
         place = environment()->query_property("place");
      } else if (previous_object()) {
         place = previous_object()->query_property("place");
      }
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(paper);
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy() {
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_property("place");
   if (!place) {
      place = environment()->query_property("place");
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return -1;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return -1;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N $V a paper from $D.\n");
   return 1;
}
void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));
}

==================================================
FILE: misc/nroff_paper.c
==================================================

inherit "/obj/misc/paper";
#include "nroff.h"
private nosave mixed *stuff = ({ });
string file_name = 0;
string language = 0;
void create() {
  seteuid(getuid());
  ::create();
}
void set_file_name(string fname) {
  file_name = fname;
}
string query_file_name() { return file_name; }
void set_language(string lang) { language = lang; }
string query_language() { return language; }
mixed *query_read_mess() {
  string str;
  if(sizeof(stuff) == 0) {
    if (file_name) {
      str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      if (!str) {
        unguarded((: NROFF_HAND->create_nroff(file_name, file_name+"_nroff") :));
        str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      }
      if(!str)
        return ::query_read_mess() +
          ({ ({ "Unable to nroff file.\n", 0, "common", 0 }) });
      if( language ) {
         return stuff = ({ ({ str, 0, language, 0 }) });
      }
      return stuff = ({ ({ str, 0, "common", 0 }) });
    }
  }
  return stuff + ::query_read_mess();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   map["read mess"] = ::query_read_mess();
   return map;
}

==================================================
FILE: misc/paper.c
==================================================

#include <playtesters.h>
#define AUTO_LOAD_TAG "paper"
inherit "/std/object";
int do_uncrumple();
int do_crumple();
int do_eat();
private int _crumpled;
private string _old_short;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "paper" );
   set_short( "piece of writing paper" );
   add_adjective( ({ "piece of", "writing" }) );
   set_main_plural( "pieces of writing paper" );
   add_plural( "pieces of writing paper" );
   add_adjective(({ "piece", "pieces", "of", "writing" }));
   set_long( "This is a nice sheet of writing paper.\n" );
   set_value( 25 );
   set_weight( 0 );
   add_property( "writeable", 1 );
   add_property( "paper", 1 );
   set_max_size( 1000 );
   if ( !do_setup ) {
      this_object()->setup();
   }
}
void init() {
   if ( !this_player() ) {
       return;
   }
   add_command( "eat", "<direct:object>", (: do_eat :) );
   add_command( "crumple", "<direct:object>", (: do_crumple :) );
   add_command( "untangle", "<direct:object>", (: do_uncrumple :) );
   add_command( "uncrumple", "<direct:object>", (: do_uncrumple :) );
}
public int query_edible() {
    return 1;
}
public int query_paper() {
   return 1;
}
int do_crumple() {
   if (_crumpled) {
      add_failed_mess("$D is already crumpled.\n");
      return 0;
   }
   _old_short = query_short();
   call_out( (: set_short :), 1, "crumpled up " + query_short() );
   _crumpled = 1;
   return 1;
}
int do_uncrumple() {
    if (!_crumpled) {
        add_failed_mess("$D is already uncrumpled.\n");
        return 0;
    }
    call_out( (: set_short :), 1, _old_short );
   _crumpled = 0;
   return 1;
}
int do_eat() {
   string *flavours = ({ "red ink", "green ink", "black ink",
       "blue ink", "orange", "apple", "cinnamon", "banana",
       "monkey", "cabbage", "hat" });
   add_succeeded_mess( ({ "You open your mouth up widely and pop $D into "
      "your mouth.  After a moment's deliberation, you chew and consume "
      "$D.\n", "$N $V $D.\n" }) );
   call_out( (: tell_object( $1, $2 ) :), 1,
       this_player(), "Mmm! " +
       capitalize( flavours[random( sizeof( flavours ) ) ] ) +
       " flavoured!\n" );
   move( "/room/rubbish" );
   return 1;
}
string query_readable_message(object player, int ignore_labels) {
   if (!_crumpled) {
      return ::query_readable_message(player, ignore_labels);
   }
   return "Only bits of ink can be seen on the crumpled paper.\n";
}
string *parse_command_adjectiv_id_list() {
   if (_crumpled) {
      return ::parse_command_adjectiv_id_list() + ({ "crumpled", "up" });
   }
   return ::parse_command_adjectiv_id_list();
}
mapping query_dynamic_auto_load() {
    mapping map;
    map = ::query_dynamic_auto_load();
    add_auto_load_value( map, AUTO_LOAD_TAG, "crumpled", _crumpled );
    add_auto_load_value( map, AUTO_LOAD_TAG, "old short", _old_short );
    return map;
}
void init_dynamic_arg( mapping map, object ) {
    ::init_dynamic_arg(map);
    if (map) {
        _crumpled = query_auto_load_value( map, AUTO_LOAD_TAG, "crumpled" );
        _old_short = query_auto_load_value( map, AUTO_LOAD_TAG, "old short" );
        if ( map[ "paper - crumpled" ] ) {
            _crumpled = map[ "paper - crumpled" ];
        }
        if ( map[ "paper - short" ] ) {
            _old_short = map[ "paper - short" ];
        }
    }
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/paper" )
      return ([ ]);
   return int_query_static_auto_load();
}

==================================================
FILE: misc/paper_packet.c
==================================================

inherit "/obj/baggage";
void setup() {
   set_name( "packet" );
   set_short( "waxed paper packet" );
   add_adjective( ({ "waxed", "paper" }) );
   set_main_plural( "waxed paper packets" );
   set_long( "This is a small packet, rather like an envelope, of thick "+
         "paper that has been waxed to make it more resilient.\n" );
   set_weight( 1 );
   set_value( 10 );
   set_max_weight( 3 );
   set_transparent();
   add_property("writeable", 1);
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_id_list();
   return ::parse_command_id_list() +
         ({ ::short( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_plural_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_plural_id_list();
   return ::parse_command_plural_id_list() +
         ({ ::query_plural( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_id_list();
}

==================================================
FILE: misc/pawn_receipt.c
==================================================

#include <am_time.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <virtual.h>
#define TO this_object()
#define TP this_player()
inherit "/obj/misc/paper" ;
private int    _expired ;
private int    _expired_sold ;
private int    _expiry_time ;
private int    _item_value, _obplural ;
private int    _timestamp;
private mixed  _static_save;
private string _obname, _obpath, _obshort ;
private string _shop_path, _virt_name ;
object do_kiss();
void setup() {
    set_name( "receipt" );
    set_short( "pawned item receipt" ) ;
    add_adjective( ({ "pawned", "item" }) );
    set_long( "This is a small slip of paper, with a black border.\n" );
    set_main_plural( "pawned item receipts" ) ;
    add_plural( "receipts" );
    add_adjective( "pawned" ) ;
    set_value( 0 ) ;
    set_weight( 1 );
    _obname = "unknown object";
    _obpath = "***";
    _timestamp = time();
}
void init() {
    add_command( "reclaim", "<direct:object:me'receipt'>" ) ;
}
void reset() {
    object item ;
    if ( ( ! _expired ) && time() > _expiry_time ) {
        _expired = 1 ;
        set_short( "expired pawned item receipt" ) ;
        add_adjective( "expired" ) ;
        if ( ! _expired_sold ) {
            _expired_sold = 1 ;
            item = do_kiss() ;
            if ( item ) {
                item->move( _shop_path->query_store_room() ) ;
            }
        }
    }
}
void set_obshort( string s ) {
  _obshort = s;
}
string query_obshort() {
  return _obshort;
}
void set_expiry_time( int time ) {
    _expiry_time = time ;
}
int query_expiry_time() {
    return _expiry_time ;
}
void set_item_value( int value ) {
    _item_value = value ;
}
int query_item_value() {
    return _item_value ;
}
void set_shop_path( mixed shop ) {
    if ( objectp( shop ) ) {
        _shop_path = base_name( shop ) ;
        return ;
    }
    _shop_path = shop ;
    return ;
}
string query_shop_path() {
    return _shop_path ;
}
void set_obname( string name ) {
    _obname = name;
}
void set_object( string path ) {
    _obpath = path;
}
void set_virtobname( string name ) {
    _virt_name = name;
}
string query_obname() {
    return _obname;
}
string query_obpath() {
    return _obpath;
}
int query_timestamp() {
    return _timestamp;
}
string query_virt_obname() {
    return _virt_name;
}
mixed query_static_save() {
  return _static_save;
}
int query_pawned_item_receipt() {
    return 1 ;
}
void set_static_save( mixed args ) {
  mixed p;
  _static_save = args;
  if (_obname != "unknown object") {
    return;
  }
  p = args[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}
void set_object_plural( object ob ) {
  if ( ob->query_collective() && ob->query_amount() > 1 ) {
    _obplural = 1;
  } else {
    _obplural = 0;
  }
}
int query_object_plural() {
  return _obplural;
}
string query_correct_short( object ob ) {
    if ( ! ob ) {
      return 0;
    }
    set_object_plural( ob );
    if ( _obplural ) {
      return pluralize( ob->query_short() );
    }
    return ob->query_short();
}
void setup_receipt( object ob ) {
   mixed* bits;
   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_obshort( query_correct_short( ob ) );
   set_object(bits[1]);
   set_static_save(bits[2]);
}
string pluralize_sentence( string text, int plural ) {
  if ( plural ) {
    return replace( text, ({
      "$o", "them",
      "$r", "they",
      "$ve", "ve"
    }) );
  }
  return replace( text, ({
    "$o", "it",
    "$r", "it",
    "$ve", "s"
  }) );
}
string query_details() {
    if ( _expired ) {
        return pluralize_sentence(
          "This is a receipt for your pawned " + query_obshort() + ".\n"
          "Sadly, you have left it too long to collect $o and $r ha$ve "
          "expired, so the shop will put $o up for sale.  Better hurry to "
          + _shop_path->the_short() + " sharpish and try to buy $o back!",
          _obplural );
    }
    return pluralize_sentence(
      "This is a receipt for your pawned " + query_obshort() + ".\n"
      "You must reclaim $o from " + _shop_path->the_short() + " before "
      + AM_TIME_HANDLER->query_am_time( _expiry_time ) + " or $r will "
      "be sold.", _obplural );
}
mixed *query_read_mess() {
  string lang;
  if ( _shop_path ) {
    lang = _shop_path->query_language();
  } else {
    lang = "general";
  }
  return ::query_read_mess()
    + ({ ({ (: query_details() :), "neat printing", lang, 0 }) });
}
mapping query_dynamic_auto_load()
{
   return ([
     "::"         : ::query_dynamic_auto_load(),
     "obname"     : _obname,
     "obpath"     : _obpath,
     "obvalue"    : value,
     "virt"       : _virt_name,
     "timestamp"  : _timestamp,
     "static"     : _static_save,
     "been sold"  : _expired_sold,
     "expired"    : _expired,
     "expires on" : _expiry_time,
     "item value" : _item_value,
     "item short" : _obshort,
     "item plural": _obplural,
     "shop path"  : _shop_path
  ]);
}
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
       add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   _expired = arg["expired"] ;
   _expired_sold = arg["been sold"] ;
   _expiry_time = arg["expires on"] ;
   _item_value = arg["item value"] ;
   _obshort = arg["item short"];
   _obplural = arg["item plural"];
   _shop_path = arg["shop path"] ;
   ::init_dynamic_arg(arg["::"]);
   if ( _expired ) {
       set_short( "expired pawned item receipt" ) ;
       add_adjective( "expired" ) ;
       set_main_plural( "expired pawned item receipts" ) ;
       add_plural( "pawned item receipts" ) ;
   }
}
mixed *stats() {
  mixed *stuff;
  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
      ({ "been sold", _expired_sold }),
      ({ "expired", _expired }),
      ({ "expires on", _expiry_time }),
      ({ "item short", _obshort }),
      ({ "item value", _item_value }),
      ({ "item plural", _obplural }),
      ({ "shop path", _shop_path })
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
  return stuff;
}
object do_kiss() {
    object thing;
    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 0;
    }
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 0;
       }
    }
    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
            move("/room/rubbish");
            return thing;
        } else {
            write("The receipt whispers: I'm going to need some "
                  "creator help.\n");
            thing->dest_me();
        }
    } else {
         write("The receipt whispers: Sorry, I'm still broken.  "
               "Try again some other time, or contact a creator.\n");
    }
    return 0;
}
int do_reclaim() {
    int cost, i ;
    object change, item ;
    string change_str, place ;
    if ( ! query_pawned_item_receipt() ) {
        add_failed_mess( "$D is not a pawned item receipt.\n" ) ;
        return 0 ;
    }
    if ( base_name( environment( TP ) ) != _shop_path ) {
        add_failed_mess(
            "This is not the right place for you to reclaim $D.  "
            "Try a pawn shop.\n" ) ;
        return 0 ;
    }
    if ( ! environment( TP )->is_open( TP, 0 ) ) {
        return 0;
    }
    if ( _expired ) {
        add_failed_mess( "Oh dear, your receipt has expired.  With luck, your "
            + query_obshort() + " will be available for sale in the shop.\n" ) ;
        return 0 ;
    }
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }
    cost = ( ( 100 + _shop_path->query_pawn_markup() ) * _item_value ) / 100 ;
    debug_printf( "cost = %d, _item_value = %d, markup = %d",
        cost, _item_value, _shop_path->query_pawn_markup() ) ;
    if ( TP->query_value_in( place ) < cost ) {
        add_failed_mess( "You don't have enough money to reclaim $D.  "
            "It would cost you "
            + MONEY_HAND->money_value_string( cost, place ) + "\n" ) ;
        return 0 ;
    }
    change = MONEY_HAND->pay_amount_from( cost, TP, place ) ;
    if ( change ) {
        change->move( TP ) ;
        change_str = change->short() ;
    }
    item = do_kiss();
    if ( ! item ) {
        add_failed_mess(
          "Oh dear, your item doesn't seem to be here any more.  "
          "Please contact a liaison.\n" );
        return 0;
    }
    i = item->move( TP );
    if ( i != MOVE_OK ) {
        tell_object( TP, "You're too heavily burdened to accept "
          + item->the_short() + ", so it is placed on the floor for you.\n" );
        item->move( environment(TP) );
    }
    add_succeeded_mess( ({
        "$N $V " + item->the_short() + " for "
          + MONEY_HAND->money_value_string( cost, place )
          + ( change_str ? " and receive " + change_str + " in change" : "" )
          + ".\n",
        "$N $V $D and receives " + item->the_short() + " in exchange.\n"
    }) ) ;
    return 1 ;
}

==================================================
FILE: misc/perfume_bottle.c
==================================================

#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
int squirts;
string glass, scent, scent_plural;
void create() {
   object::create();
   holdable::create();
}
void setup() {
   set_name( "bottle" );
   set_short( "perfume bottle" );
   add_adjective( "perfume" );
   set_value( 4000 );
   set_weight( 2 );
   squirts = 12;
}
void set_glass( string word ) {
   set_short( word +" perfume bottle" );
   add_adjective( word );
   set_main_plural( word +" perfume bottles" );
   glass = word;
}
void set_scent( string words ) { scent = words; }
void set_scent_plural( string words ) { scent_plural = words; }
string long( string word, int dark ) {
   string words;
   words = "This is a perfume bottle made out of "+ glass +" crystal.  "+
         "It is ";
   switch( squirts ) {
      case 0 :
         return words +"empty.\n";
      case 1 .. 3 :
         words += "about a quarter full";
         break;
      case 4 .. 6 :
         words += "about half full";
         break;
      case 7 .. 9 :
         words += "about three-quarters full";
         break;
      default :
         words += "almost full";
   }
   words += " of "+ scent +" perfume which can be sprayed onto "+
         "someone.\n";
   return words;
}
void init() {
   this_player()->add_command( "spray", this_object(), "<direct:object> at <indirect:object>" );
}
int do_spray( object *things ) {
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You can only spray $D "+
        "at one person at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot spray $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  if ( !living( things[ 0 ] ) ) {
    this_player()->add_failed_mess( this_object(), "SI would probably not "+
        "benefit from being sprayed.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !squirts ) {
    this_player()->add_failed_mess( this_object(), "There is no perfume in "+
        "$D to spray at $I.\n", ({ things[ 0 ] }) );
    return 0;
  }
  squirts--;
  things[ 0 ]->add_effect( "/std/effects/other/perfume", ({ 300, scent,
      scent_plural }) );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "squirts" : squirts
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] !=
      "/obj/misc/perfume_bottle" )
    return 0;
  return ([
    "::" : int_query_static_auto_load(),
    "glass" : glass,
    "scent" : scent,
    "scent_plural" : scent_plural
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  squirts = map[ "squirts" ];
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( map[ "glass" ] )
    set_glass( map[ "glass" ] );
  if ( map[ "scent" ] )
    scent = map[ "scent" ];
  if ( map[ "scent_plural" ] )
    scent_plural = map[ "scent_plural" ];
}
void dest_me() {
   holdable::dest_me();
   object::dest_me();
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}

==================================================
FILE: misc/plate.c
==================================================

inherit "/std/surface";
void init() {
  this_player()->add_command( "eat", this_object(),
    "<indirect:object:direct-obs> {from|on} <direct:object:me>" );
  this_player()->add_command( "eat", this_object(),
    "from <direct:object:me>" );
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_long( "This is a nice plate for keeping food on.\n" );
  if ( ! do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int do_eat( object *obs, string dir, string indir, mixed *args ) {
  object ob;
  object *food;
  if( sizeof( obs ) )
    food = copy( obs );
  else
    food = all_inventory();
  if( sizeof( food ) ) {
    food = filter( food, (: $1->query_edible() :) );
  } else {
    this_player()->add_failed_mess( this_object(),
      "There's nothing on $D\n", ({ }) );
    return 0;
  }
  if( !sizeof( food ) ) {
    if( sizeof( obs ) )
      this_player()->add_failed_mess( this_object(),
        "You can't eat $I on $D!\n", obs );
    else
      this_player()->add_failed_mess( this_object(),
        "There's nothing edible on $D\n", ({ }) );
    return 0;
  }
  foreach( ob in food ) {
    ob->do_eat();
  }
  return 1;
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
