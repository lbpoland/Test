# Total Tokens: 91292
# Total Files Merged: 72
# Total Characters: 304494

================================================

#include <parse_command.h>
inherit "/std/basic/id_match";
class Id {
  string name;
  string *alias;
  string *faux_alias;
  string *unique_faux_alias;
  string *adjectives;
  string *faux_adjectives;
  string *unique_faux_adjectives;
  string *plural_adjectives;
  string *plurals;
}
private nosave class Id _id;
int id_adjective(string);
int id_plural(string str);
int faux_id_allowed();
private void setup_id_class() {
   if (_id) {
      return ;
   }
   _id = new( class Id );
   _id->alias = ({ });
   _id->faux_alias = ({ });
   _id->unique_faux_alias = ({ });
   _id->plurals = ({ });
   _id->adjectives = ({ });
   _id->faux_adjectives = ({ });
   _id->unique_faux_adjectives = ({ });
   _id->plural_adjectives = ({ });
   _id->name = "object";
}
void set_name(string str) {
   _id->name = str;
}
string query_name() {
   if (!_id) {
      return 0;
   }
   return _id->name;
}
string query_cap_name() {
   if (!_id->name) {
      return "Someone";
   }
   return capitalize(_id->name);
}
void create() {
   setup_id_class();
}
void set_aliases(string *str) {
   _id->alias = str;
}
void add_alias(mixed str) {
   if (pointerp(str)) {
      _id->alias += str;
      return;
   }
   if (member_array(str, _id->alias) == -1) {
      _id->alias += ({ str });
   }
}
int remove_alias(string str) {
   int i;
   i = member_array(str, _id->alias);
   if (i == -1) {
      return 0;
   }
   _id->alias = _id->alias[0..i - 1] + _id->alias[i + 1..];
   return 1;
}
varargs string *query_alias( int no_faux ) {
  if( no_faux ||
      !sizeof( _id->unique_faux_alias ) ||
      !faux_id_allowed() )
    return _id->alias;
  else
    return _id->alias + _id->unique_faux_alias;
}
void add_faux_alias(mixed str) {
   if (pointerp(str)) {
      foreach( string aka in str )
        add_faux_alias( aka );
      return;
   }
   if( member_array( str, _id->alias ) != -1 )
     return;
   _id->faux_alias += ({ str });
   _id->unique_faux_alias = _id->unique_faux_alias | ({ str });
}
int remove_faux_alias(string str) {
   int i;
   i = member_array(str, _id->faux_alias);
   if (i == -1) {
      return 0;
   }
   _id->faux_alias = _id->faux_alias[0..i - 1] +
                      _id->faux_alias[i + 1..];
   if( member_array(str, _id->faux_alias) == -1 ) {
      _id->unique_faux_alias -= ({ str });
   }
   return 1;
}
string *query_faux_alias() {
  return _id->faux_alias;
}
string *query_unique_faux_alias() {
  return _id->unique_faux_alias;
}
int faux_id_allowed() {
  foreach( object ob in previous_object(-1) ) {
    if( objectp(ob) && ob->ignore_identifier() )
      return 0;
  }
  return 1;
}
int id(string str) {
   return (str == _id->name ||
          (member_array(str, query_alias()) != -1) );
}
int full_id(string str) {
   string *words;
   string name;
   string adjective;
   words = explode(str, " ") - ({ "" });
   name = words[<1];
   words = words[0.. < 2];
   if (!id(name)) {
      if (!id_plural(name)) {
         return 0;
      }
   }
   foreach(adjective in words) {
      if (!id_adjective(adjective)) {
         return 0;
      }
   }
   return 1;
}
void set_plurals(string *str) {
   _id->plurals = str;
}
void add_plural(mixed str) {
   if (pointerp(str)) {
      _id->plurals += str;
   } else if (_id->plurals) {
      if (member_array(str, _id->plurals) == -1) {
         _id->plurals += ({ str });
      }
   } else {
      _id->plurals = ({ str });
   }
}
void remove_plural(string str) {
   int i;
   i = member_array(str, _id->plurals);
   if (i != -1) {
      _id->plurals = _id->plurals[0..i - 1] + _id->plurals[i + 1..];
   }
}
void add_plurals(string *str) {
   _id->plurals += str;
}
string *query_plurals() {
   return _id->plurals;
}
int id_plural(string str) {
   return (member_array(str, _id->plurals) != -1);
}
void set_adjectives(string *str) {
   _id->adjectives = str;
}
void add_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         add_adjective(str[i]);
      }
      return;
   }
   if (stringp(str)) {
      str = explode(str, " ");
   }
   for (i = 0; i < sizeof(str); i++) {
      if (member_array(str[i], _id->adjectives) == -1) {
         _id->adjectives += ({ str[i] });
      }
   }
}
void remove_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         remove_adjective(str[i]);
      }
   } else {
      if ((i = member_array(str, _id->adjectives)) != -1) {
         _id->adjectives = delete(_id->adjectives, i, 1);
      }
   }
}
void add_faux_adjective(mixed str) {
   if (pointerp(str)) {
      foreach( string adj in str )
         add_faux_adjective( adj );
      return;
   }
   if( stringp( str ) ) {
      str = explode(str, " ");
   }
   str -= _id->adjectives;
   foreach( string adj in str ) {
      _id->faux_adjectives += ({ adj });
      _id->unique_faux_adjectives = _id->unique_faux_adjectives |
                                    ({ adj });
   }
}
void remove_faux_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      foreach( string adj in str )
         remove_faux_adjective( adj );
      return;
   }
   i = member_array(str, _id->faux_adjectives);
   if( i == -1 )
     return;
   _id->faux_adjectives = _id->faux_adjectives[0..i-1] +
                          _id->faux_adjectives[i+1..];
   if( ( i = member_array( str, _id->faux_adjectives ) ) == -1 )
     _id->unique_faux_adjectives -= ({ str });
}
string *query_faux_adjectives() {
  return _id->faux_adjectives;
}
string *query_unique_faux_adjectives() {
  return _id->unique_faux_adjectives;
}
varargs string *query_adjectives( int no_faux ) {
  if( no_faux ||
      !sizeof( _id->unique_faux_adjectives ) ||
      !faux_id_allowed() )
    return _id->adjectives;
  else
    return _id->adjectives + _id->unique_faux_adjectives;
}
int id_adjective(string word) {
   return (member_array(word, query_adjectives()) != -1);
}
void set_plural_adjectives(string *str) {
   _id->plural_adjectives = str;
}
void add_plural_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         add_plural_adjective(str[i]);
      }
      return;
   }
   if (stringp(str)) {
      str = explode(str, " ");
   }
   for (i = 0; i < sizeof(str); i++) {
      if (member_array(str[i], _id->plural_adjectives) == -1) {
         _id->plural_adjectives += ({ str[i] });
      }
   }
}
void remove_plural_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         remove_plural_adjective(str[i]);
      }
   } else {
      if ((i = member_array(str, _id->plural_adjectives)) != -1) {
         _id->plural_adjectives = delete(_id->plural_adjectives, i, 1);
      }
   }
}
string *query_plural_adjectives() {
   return _id->plural_adjectives;
}
int id_plural_adjective(string word) {
   return (member_array(word, _id->plural_adjectives) != -1);
}
string *parse_command_id_list() {
   return ({ _id->name, file_name(this_object()) }) + query_alias();
}
string *parse_command_plural_id_list() {
   return query_plurals();
}
string *parse_command_adjectiv_id_list() {
   return query_adjectives();
}
string *parse_command_plural_adjectiv_id_list() {
   return query_plural_adjectives();
}
object query_parse_id(mixed *arr) {
   if (arr[P_THING] == 0) {
      return this_object();
   }
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return this_object();
   }
   arr[P_THING]--;
   if (arr[P_THING] != 0) {
      return this_object();
   }
   arr[P_THING] = -10101;
   return this_object();
}
object query_frac_parse_id(mixed *arr) {
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10235;
      return 0;
   }
   if (arr[P_THING] == 0) {
      if ((arr[P_MAX_NUM] * arr[P_TOP]) / arr[P_BOT] > arr[P_CUR_NUM]++) {
         return this_object();
      } else {
         return 0;
      }
   }
   if ((arr[P_THING] * arr[P_TOP]) / arr[P_BOT] > arr[P_CUR_NUM]++) {
      return this_object();
   }
   return 0;
}

==================================================
FILE: basic/id_match.c
==================================================

#include <obj_parser.h>
private int _no_all;
protected void set_no_all(int no_all) {
   _no_all = no_all;
}
int query_no_all() {
   return _no_all;
}
protected int is_matching_object(string* input,
                          object viewer,
                          class obj_match_context context )
{
   string *adj;
   string *padj;
   string *names;
   string *pnames;
   int n;
   int ret;
   if( this_object() == context->him &&
       input[<1] == "him" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->her &&
              input[<1] == "her" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->it &&
              input[<1] == "it" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( context->plural &&
              input[<1] == "them" &&
              member_array( this_object(), context->plural ) != -1 ) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if( this_object() == viewer &&
              input[<1] == "me" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if (!_no_all && input[<1] == "all") {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "things" || input[<1] == "ones")) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "thing" || input[<1] == "one")) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   }
   if (!ret) {
      if (input[<1] == "here" &&
          viewer != environment() &&
          sizeof(input) > 1) {
         input = input[0..<2];
      }
      names = this_object()->parse_command_id_list();
      pnames = this_object()->parse_command_plural_id_list();
      if( member_array( input[<1], pnames ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_PLURAL;
      }
      if( member_array( input[<1], names ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_SINGULAR;
      }
      if (!ret) {
         return 0;
      }
   }
   adj = this_object()->parse_command_adjectiv_id_list();
   padj = this_object()->parse_command_plural_adjectiv_id_list();
   if( environment() == context->him ) {
      adj += ({ "his" });
   } else if( environment() == context->her ) {
      adj += ({ "her" });
   } else if( environment() == context->it ) {
      adj += ({ "its" });
   } else if( environment() == viewer ) {
      adj += ({ "my" });
   } else if( context->plural &&
                   member_array( environment(), context->plural ) != -1 ) {
      adj += ({ "their" });
   }
   for( n = 0; n < sizeof( input ) - 1; n++ )
   {
      if( member_array( input[n], adj ) == -1 ) {
         if (!padj || member_array(input[n], padj) == -1) {
            return 0;
         } else {
            ret &= ~OBJ_PARSER_MATCH_SINGULAR;
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }
   return ret;
}
protected int update_parse_match_context(class obj_match_context context,
                                         int num,
                                         int singular) {
   if (context->ordinal) {
      if (context->ordinal == -1) {
         return 1;
      }
      if (context->ordinal > num) {
         context->ordinal -= num;
         return 0;
      }
      context->ignore_rest = 1;
      return 1;
   } else if (context->number_included) {
      if (context->number_included <= num) {
         context->ignore_rest = 1;
         num = context->number_included;
         context->number_included = 0;
         return num;
      }
      context->number_included -= num;
      return num;
   } else {
      if (num > 0 && (singular & OBJ_PARSER_MATCH_SINGULAR)) {
         return 1;
      }
      return num;
   }
}
mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   int ret;
   ret = is_matching_object(input, viewer, context);
   if (!ret) {
      return 0;
   }
   if (!update_parse_match_context(context, 1, ret)) {
      return 0;
   }
   return ({ ret, ({ this_object() }) });
}

==================================================
FILE: basic/item_chat.c
==================================================

#include <room.h>
private nosave int _off, _already_added;
private nosave mixed *_chats;
void check_chat();
mixed *query_chats() { return _chats; }
void init() {
  check_chat();
}
void item_chat( mixed *args ) {
  if ( !args || sizeof(args) < 3 || !sizeof(args[2]) ){
    write( "Incorrect args to item_chat.\n" );
    return;
  }
  args = args - ({ 0 });
  args[2] = map( args[2],
        (: replace( $1, ({ "$a_short$", this_object()->a_short(),
                           "$the_short$", this_object()->the_short(),
                           "$poss_short$", this_object()->poss_short() }) ) :) );
  _off = 0;
  _chats = args + ({ 0 });
  check_chat();
}
void chat_on(){
   _off = 0;
   check_chat();
}
void chat_off(){
   _off = 1;
}
void make_chat(){
  int saying;
  string stuff;
  object env, *targets;
  _already_added = 0;
  if( !(env = environment()) || _off )
    return;
  saying = random( sizeof(_chats[ 2 ]) );
  if( saying == _chats[ 3 ] )
    saying = ( saying + 1 ) % sizeof( _chats[ 2 ] );
  _chats[ 3 ] = saying;
  stuff = _chats[ 2 ][ saying ];
  if( env->query_is_room() ||
      ( interactive(env) && (env = environment(env)) && env->query_is_room() ) ){
    targets = filter( all_inventory(env), (: interactive($1) :) );
    if( !sizeof(targets) )
      return;
    if( stuff[0..0] == "#" )
      call_other( this_object(), stuff[ 1 .. ] );
    else
      tell_room( env, stuff + "\n" );
    _already_added = 1;
    ROOM_HANDLER->add_chatter( this_object(), _chats[ 0 ] +
                               random( _chats[ 1 ] - _chats[ 0 ] + 1 ) );
  }
}
void check_chat(){
  if( !_off && !_already_added && arrayp(_chats) && environment() ){
    if( interactive(environment()) ||
          ( environment(environment()) &&
            interactive(environment(environment()))
          )
       ){
           _already_added = 1;
           ROOM_HANDLER->add_chatter( this_object(),
           ( _chats[ 0 ] + random( _chats[ 1 ] - _chats[ 0 ] + 1 ) ) / 2 );
        }
  }
}
mapping query_dynamic_auto_load() {
   return ([ "_off"  : _off,
            "_chats" : _chats
          ]);
}
string fix_saved_chat( string chat ){
  string old_ob;
  if( !chat )
    return 0;
  sscanf( chat, "%*s$%*s_short:%s$%*s", old_ob );
  if( old_ob )
    chat = replace( chat, old_ob, file_name(this_object()) );
  return chat;
}
void init_dynamic_arg( mapping map ) {
  mixed info;
  if( !map )
    return;
  if( (info = map["_chats"]) && arrayp(info) && sizeof(info) > 2 ){
    info[2] = map( info[2], "fix_saved_chat", this_object() );
    item_chat( info );
  }
  if( !(_off = map["_off"]) )
    chat_on();
  else
    chat_off();
}

==================================================
FILE: basic/light.c
==================================================

private nosave int _light;
private nosave int _my_light;
private nosave int _need_recalculate;
private nosave object *_inform_of_change;
void new_recalc_light();
mixed query_property(string name);
void add_property(string name, mixed value);
void remove_property(string name);
void create() {
    _inform_of_change = ({ });
}
int query_light() {
    if (_need_recalculate) {
        _need_recalculate = 0;
        new_recalc_light();
    }
    return _light;
}
int query_light_needs_inform() {
    return _light || _need_recalculate;
}
int query_my_light() { return _my_light; }
varargs void new_recalc_light() {
    object *obs;
    object ob;
    int tmp_light;
    _need_recalculate = 0;
    _light = _my_light * _my_light;
    if (_my_light < 0)  _light = -_light;
    if ( !this_object()->query_opaque() ) {
        obs = all_inventory(this_object());
        foreach (ob in obs) {
            if (ob->query_opaque()) {
                tmp_light = ob->query_my_light();
            } else {
                tmp_light = ob->query_light();
            }
            if (tmp_light >= 0)  _light += tmp_light * tmp_light;
            else  _light -= tmp_light * tmp_light;
        }
    }
    if (_light >= 0)  _light = sqrt(_light);
    else  _light = -sqrt(-_light);
    _inform_of_change->event_light_change(this_object(), 0, _light);
}
void light_level_changed() {
    _need_recalculate = 1;
}
void inform_of_light_level_change(object ob) {
    if (ob) {
        ob->light_level_changed();
    }
    while (ob && !ob->query_opaque()) {
        ob->light_level_changed();
        ob = environment(ob);
    }
}
void add_inform_light_change(object ob) {
    _inform_of_change += ({ ob });
}
void remove_inform_light_change(object ob) {
    _inform_of_change -= ({ ob });
}
void set_opaque() {
    add_property( "opaque", 1 );
}
void reset_opaque() {
    remove_property( "opaque" );
}
int query_opaque() {
    return query_property("opaque");
}
int adjust_light( int number ) {
    if (number) {
        _my_light += number;
        inform_of_light_level_change(this_object());
    }
    return _light;
}
int set_light(int number) {
    return adjust_light(number - _my_light);
}
mixed *stats() {
    return ({
      ({ "light", _light, }),
      ({ "my light", _my_light, }),
    });
}

==================================================
FILE: basic/misc.c
==================================================

#include <money.h>
#include <move_failures.h>
#define WATCH_DEFINE "fluff'n'stuff"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
inherit "/std/basic/light";
inherit "/std/basic/consecrate";
inherit "/std/basic/move";
nosave int weight;
nosave int length = 1;
nosave int width = 1;
nosave int value;
nosave mapping value_info;
void check_log_status( object *parray );
void create() {
  weight = 1;
  light::create();
  if(this_object()->query_property(WATCH_DEFINE))
    call_out( "check_log_status", 1, previous_object(-1) );
  value_info = ([ ]);
}
void set_width(int w) { width = w; }
int query_width() { return width; }
void set_length(int l) { length = l; }
int query_length() { return length; }
void adjust_weight(int w) {
    if (environment()) {
        environment()->add_weight(w);
    }
    weight += w;
}
void set_weight(int w) {
    if (environment())
        environment()->add_weight(w-weight);
    weight = w;
}
int query_weight() { return weight; }
int query_complete_weight() { return (int)this_object()->query_weight(); }
varargs int adjust_money(mixed amt, string coin) {
    if (pointerp(amt)) {
        value += (int)MONEY_HAND->query_total_value(amt);
        if (value < 0) {
            value = 0;
        }
        return value;
    }
    amt = (int)MONEY_HAND->query_total_value( ({ coin, amt }) );
    value += amt;
    if (value < 0) {
        value = 0;
    }
    return value;
}
int adjust_value(int i) {
    value += i;
    return value;
}
mixed *query_money_array() {
    return (mixed *)MONEY_HAND->create_money_array(value);
}
int query_money(string type) {
    int i;
    mixed *m_a;
    m_a = (mixed *)MONEY_HAND->create_money_array(value);
    i = member_array(type, m_a);
    if (i == -1) {
        return 0;
    }
    return m_a[i+1];
}
void set_value( int number ) { value = number; }
void set_value_info( string word, int number ) {
    value_info[ word ] = number;
}
void remove_value_info( string word ) {
    if ( undefinedp( value_info[ word ] ) )
        return;
    value_info = m_delete( value_info, word );
}
int query_value() { return value; }
int query_base_value() {
   return value;
}
mapping query_value_info() { return value_info; }
int query_value_at( object place ) {
    int i, total;
    string *info;
    mixed how;
    if ( !value_info ) {
        value_info = ([ ]);
    }
    total = (int)this_object()->query_value();
    info = m_indices( value_info );
    for ( i = 0; i < sizeof( info ); i++ ) {
        how = (mixed)place->query_property( info[ i ] +" valued" );
        if ( how ) {
            switch ( info[ i ] ) {
            case "artifact" :
                total += ( value_info[ "artifact" ] * ( how[ 0 ] +
                    how[ 1 ] * (int)this_object()->query_charges() ) ) / how[ 2 ];
                break;
            case "enchantment" :
                if ( this_object()->query_max_enchant() )
                    total += ( value_info[ "enchantment" ] * how *
                      (int)this_object()->query_enchant() ) /
                    (int)this_object()->query_max_enchant();
                break;
            case "material" :
                total += (int)this_object()->query_weight() *
                (int)PRICE_INDEX->query_price( (string)this_object()->
                  query_material(), how );
                break;
            default :
                total += value_info[ info[ i ] ];
            }
        }
    }
    return total;
}
int query_value_real(string place) {
   int i;
   int total;
   string *info;
   if ( !value_info ) {
      value_info = ([ ]);
   }
   total = (int)this_object()->query_value();
   info = m_indices( value_info );
   for ( i = 0; i < sizeof( info ); i++ ) {
      switch ( info[ i ] ) {
      case "artifact" :
         total += ( value_info[ "artifact" ] * ( 3 +
             1 * (int)this_object()->query_charges() ) ) / 1;
         break;
      case "enchantment" :
         if ( this_object()->query_max_enchant() )
             total += ( value_info[ "enchantment" ] * 10 *
               (int)this_object()->query_enchant() ) /
             (int)this_object()->query_max_enchant();
         break;
      case "material" :
         total += (int)this_object()->query_weight() *
         (int)PRICE_INDEX->query_price( (string)this_object()->
           query_material(), place );
         break;
      default :
         total += value_info[ info[ i ] ];
         break;
      }
   }
   return total;
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if( stringp(dest) ) {
   if ( strsrch( dest , "#") != -1 )
     dest = find_object(dest);
   else
     dest = load_object(dest);
  }
  if(!dest)
    return MOVE_INVALID_DEST;
  w = (int)this_object()->query_complete_weight();
  if(!(dest->add_weight(w)))
    return MOVE_TOO_HEAVY;
  from = environment();
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-w);
    return i;
  }
  if(from)
    from->add_weight(-w);
  if(query_light_needs_inform()) {
    if(from)
      inform_of_light_level_change(from);
    inform_of_light_level_change(dest);
  }
  return i;
}
void dest_me() {
    if ( environment() ) {
        environment()->add_weight( -(int)this_object()->query_complete_weight() );
        if ( query_my_light() )
            adjust_light( -query_my_light() );
    }
    ::dest_me();
}
mixed *stats() {
    int i;
    string *info;
    mixed *guff;
    guff = ({ ({ "value", value }) });
    if ( !value_info )
        value_info = ([ ]);
    info = m_indices( value_info );
    for ( i = 0; i < sizeof( info ); i++ )
        guff += ({ ({ "(info) "+ info[ i ], value_info[ info[ i ] ] }) });
    return light::stats() + consecrate::stats() + guff;
}
void check_log_status( object *parray ) {
  if ( this_object()->query_property( WATCH_DEFINE ) &&
       clonep( this_object() ) &&
       arrayp( parray ) &&
       member_array(load_object("/secure/cmds/creator/cl_one"), parray) != -1){
    log_file( "WATCH", "%s TO: %s. TP: %s.\n", ctime(time()),
              base_name( this_object() ), parray[2]->query_name() );
    this_object()->add_property( "CT", time() );
    user_event( "inform", sprintf( "[Restricted] %s cloned %s.",
                                   parray[2]->query_cap_name(),
                                   base_name( this_object() ) ), "cheat" );
  }
}

==================================================
FILE: basic/move.c
==================================================

#include <move_failures.h>
#define DROP 1
#define GET 2
private int move_flag;
varargs int move( mixed dest, string messin, string messout ) {
   object prev;
   if ( !objectp( dest ) ) {
      if ( !stringp( dest ) || !( dest = find_object( dest ) ) ) {
         return MOVE_EMPTY_DEST;
      }
   }
   if ( !dest->test_add( this_object(), this_object()->get(dest) ) ) {
      return MOVE_NO_GET;
   }
   if(dest == this_object()) {
      return MOVE_INVALID_DEST;
   }
   prev = environment();
   if ( prev ) {
      if ( !prev->test_remove( this_object(),
                               this_object()->drop(dest),
                               dest ) ) {
         return MOVE_NO_DROP;
      } else if (prev != find_object("/room/virtual")) {
         event( prev, "exit", messout, dest );
      }
   }
   if (dest != environment()) {
      if( environment() )
        this_object()->remove_property( "there" );
      move_object (dest);
      this_object()->event_move_object( prev, dest );
   }
   if (!(dest == find_object("/room/rubbish") || dest == find_object("/room/virtual"))) {
      event( dest, "enter", messin, prev );
   }
   this_object()->remove_hide_invis( "concealed" );
   this_object()->remove_hide_invis( "secreted" );
   return MOVE_OK;
}
void reset_get() { move_flag |= GET; }
void set_get() { move_flag &= ~GET; }
void reset_drop() { move_flag |= DROP; }
void set_drop() { move_flag &= ~DROP; }
void dest_me() {
   if ( environment() ) {
      event( environment(), "dest_me" );
   }
   this_object()->event_destruct();
   efun::destruct( this_object() );
}
nomask mixed dwep() {
   efun::destruct( this_object() );
   return "Destructed With Extreme Prejudice";
}
int drop( mixed dest ) { return move_flag & DROP; }
int get( mixed dest ) { return move_flag & GET; }
void set_move_flag( int i ) { move_flag = i; }

==================================================
FILE: basic/print_object.c
==================================================

varargs string print_object(mixed ob, int off) {
  int i;
  write("                   "[0..off]);
  if (intp(ob)) {
    write(ob+"\n");
    return "int";
  }
  if (stringp(ob)) {
    write("\""+ob+"\"\n");
    return "string";
  }
  if (objectp(ob)) {
    write(file_name(ob)+"  ");
    if (ob->short())
      write("(short) "+ob->short()+"\n");
    else if (ob->query_name())
      write("(name)  "+ob->query_name()+"\n");
    else
      write("(Argghhhh)\n");
    return "object";
  }
  if (pointerp(ob)) {
    if (!sizeof(ob))
      write("({ })\n");
    else {
      write("({  -- size "+sizeof(ob)+"\n");
      for (i=0;i<sizeof(ob);i++)
        print_object(ob[i], off+3);
      write("                       "[0..off]+"})\n");
    }
    return "pointer";
  }
  return "oh dear";
}

==================================================
FILE: basic/property.c
==================================================

mapping map_prop;
mapping timed_properties;
mapping property_stats;
void create() {
}
varargs int add_property(string var, mixed val, int tim) {
  if (!stringp(var))
    return 0;
  if (!map_prop)
    map_prop = ([ ]);
  map_prop[var] = val;
  if (tim > 0) {
    if (!timed_properties)
      timed_properties = ([ ]);
    timed_properties[var] = tim + time();
  }
#ifdef TRACK_PROPERTY_STATS
  if (!property_stats)
    property_stats = ([ ]);
  if (previous_object())
    property_stats[var] = ({ file_name( previous_object() ), time(), tim });
  else
    property_stats[var] = ({ "No previous object.", time(), tim });
#endif
  return 1;
}
int remove_property(string var) {
  if (map_prop)
    map_delete(map_prop, var);
  if (timed_properties)
    map_delete(timed_properties, var);
#ifdef TRACK_PROPERTY_STATS
  if (property_stats)
    map_delete(property_stats, var);
#endif
  return 1;
}
mixed query_property(string str) {
  if (!map_prop)
    return ([ ])["bing"];
  if (timed_properties && timed_properties[str] &&
      timed_properties[str] < time()) {
    map_delete(timed_properties, str);
    map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
    if(property_stats)
      map_delete(property_stats, str);
#endif
    return map_prop[str];
  }
  return map_prop[str];
}
int query_is_timed_property(string str) {
  if (timed_properties && timed_properties[str]) {
    if (timed_properties[str] < time()) {
      map_delete(timed_properties, str);
      map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
      map_delete(property_stats, str);
#endif
      return 0;
    }
    return 1;
  }
  return 0;
}
int query_property_time_left(string str) {
  if (timed_properties &&
      timed_properties[str]) {
    if (timed_properties[str] < time()) {
      map_delete(timed_properties, str);
      map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
      map_delete(property_stats, str);
#endif
      return 0;
    }
    return timed_properties[str] - time();
  }
  return 0;
}
int query_property_exists(string str) {
  if (!map_prop)
    return 0;
  if (timed_properties &&
      timed_properties[str] &&
      timed_properties[str] < time()) {
    map_delete(timed_properties, str);
    map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
    map_delete(property_stats, str);
#endif
    return map_prop[str];
  }
  return !undefinedp(map_prop[str]);
}
mapping query_properties() {
  if (map_prop)
    return map_prop ;
  return ([ ]);
}
mapping query_timed_properties() {
  if (timed_properties)
    return timed_properties;
  return ([ ]);
}
void add_properties(mapping map) {
  if (!map_prop)
    map_prop = map;
  else
    map_prop += map;
}
void set_properties(mapping map) {
  map_prop = map;
}
protected void save_player_properties() {
  string prop;
  if(timed_properties)
    foreach(prop in keys(timed_properties))
      if(timed_properties[prop] < time())
        map_delete(timed_properties, prop);
      else
        timed_properties[prop] -= time();
}
protected void reload_player_properties() {
  string prop;
  if (timed_properties)
    foreach(prop in keys(timed_properties))
      if(!map_prop[prop])
        map_delete(timed_properties, prop);
      else
        timed_properties[prop] += time();
}
mixed stats() {
  int i, bing;
  mixed *k, *v, *res;
  mapping props;
  props = (mapping)this_object()->query_properties();
  if ( !props )
    return ({ });
  k = keys( props );
  v = values( props );
  res = ({ });
  for ( i = sizeof( k ) - 1; i > -1; i-- ) {
    bing = 0;
    if (timed_properties &&
        timed_properties[ k[ i ] ] &&
        timed_properties[ k[ i ] ] < time()) {
      map_delete(timed_properties, k[ i ]);
      map_delete(map_prop, k[ i ]);
#ifdef TRACK_PROPERTY_STATS
      if(property_stats)
        map_delete(property_stats, k[i]);
#endif
      continue;
    }
    if (timed_properties &&
        timed_properties[ k[ i ] ]) {
      bing = timed_properties[ k[ i ] ] - time();
    }
    if ( !stringp( k[ i ] ) || k[ i ][ 0 .. 3 ] == "news" ||
         k[ i ] [ 0 ] == '.' )
      continue;
    if ( pointerp( v[ i ] ) ) {
      res += ({ ({ "(" + k[ i ] + (bing ? ":"+bing : "") + ")",
                     array_to_string( v[ i ] ) }) });
      continue;
    }
    if ( mapp( v[ i ] ) ) {
      res += ({ ({ "(" + k[ i ] + (bing ? ":"+bing : "") + ")",
                     mapping_to_string( v[ i ] ) }) });
      continue;
    }
    res += ({ ({ "("+ k[ i ] + ( bing ? ":"+ bing : "" ) +")",
                   v[ i ] }) });
  }
  return res;
}
#ifdef TRACK_PROPERTY_STATS
mixed query_property_stats( string var ) {
  if (!property_stats || undefinedp( property_stats[var] ) )
    return ({ });
  return property_stats[ var ];
}
mapping query_stats() {
  mixed property1, property2;
  if (!property_stats)
    return ([ ]);
  foreach( property1, property2 in property_stats )
    if(undefinedp(map_prop[property1]) &&
       undefinedp(timed_properties[property1]))
      map_delete(property_stats, property1);
  return property_stats;
}
#endif

==================================================
FILE: basic/read_desc.c
==================================================

#include <language.h>
#include <nroff.h>
inherit "/std/basic/desc";
private nosave mixed *_read_mess = ({ });
private nosave int _max_size = 100;
private nosave int _cur_size;
varargs mixed add_read_mess(mixed str, string type, string lang, int size);
mixed query_property(string name);
void set_max_size(int siz) { _max_size = siz; }
int query_max_size() { return _max_size; }
void set_cur_size(int siz) { _cur_size = siz; }
int query_cur_size() { return _cur_size; }
varargs void set_read_mess(mixed str, string lang, int size) {
   if ( pointerp( str ) ) {
      _read_mess = str;
      return;
   }
  if (!lang)
    return;
  if (!size)
    size = 1;
  if ( str )
    _read_mess = ({ ({ str, 0, lang, size }) });
  else
    _read_mess = ({ });
}
mixed *query_read_mess() { return copy( _read_mess ); }
varargs mixed add_read_mess(mixed str, string type, string lang, int size) {
  int de_size;
  if (_cur_size >= _max_size) {
     return "";
  }
  if (!size) {
    size = 1;
  }
  de_size = size*((int)LANGUAGE_HAND->query_language_size(lang, str));
  if (_cur_size+de_size > _max_size) {
    str = (string)LANGUAGE_HAND->squidge_text(lang, str,
                                              (_max_size-_cur_size)/size);
    if (!strlen(str))
      return ;
    _cur_size += size*((int)LANGUAGE_HAND->query_language_size(lang, str));
  }
  _read_mess += ({ ({ str, type, lang, size }) });
  return str;
}
int remove_read_mess(string str, string type, string lang) {
  int i;
  for (i=0;i<sizeof(_read_mess);i++) {
    if (str && _read_mess[i][READ_STR] != str)
      continue;
    if (type && _read_mess[i][READ_TYPE] != type)
      continue;
    if (lang && _read_mess[i][READ_LANG] != lang)
      continue;
    _cur_size -= _read_mess[i][READ_SIZE]
                *((int)LANGUAGE_HAND->query_language_size(lang,
                                                    _read_mess[i][READ_STR]));
    _read_mess = _read_mess[0..i - 1] + _read_mess[i + 1..];
    return 1;
  }
  return 0;
}
string query_readable_message(object player, int ignore_labels) {
  string message;
  string file;
  string type;
  string lang;
  mixed mess;
  mixed *bit;
  mixed *read_mess;
  int pos;
  if(!player)
    player = this_player();
  read_mess = query_read_mess();
  if ( !sizeof( read_mess ) ) {
    return 0;
  }
  message = "";
  foreach ( bit in read_mess ) {
    mess = bit[ READ_MESS ];
    type = bit[ READ_TYPE ];
    lang = bit[ READ_LANG ];
    if ( functionp( mess ) ) {
      mess = evaluate( mess );
    }
    if ( stringp( mess ) ) {
      if ( sscanf( mess, "$$%s$$", file ) ) {
        mess = unguarded( (: read_file, file +".txt" :) );
        if ( !mess ) {
          mess = unguarded( (: NROFF_HAND->cat_file($(file)+"_nroff", 1) :) );
          if(!mess) {
            unguarded((: NROFF_HAND->create_nroff($(file),
                                                  $(file)+"_nroff") :));
            mess = unguarded((: NROFF_HAND->cat_file($(file)+"_nroff", 0) :));
            if(!mess)
              mess = "Warning: text file cannot be read!";
          }
        }
      }
    }
    mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
#ifdef DISABLED
    if (stringp(mess)) {
      pos = strsrch(mess, "Written in ");
      while (pos != -1) {
        if ((pos == 0 && !type) || (pos > 0 && mess[pos-1] == '\n')) {
          mess = mess[0..pos-1] + "---> " + mess[pos..pos + 4] + " " +
            mess[pos + 5..];
        } else {
          mess = mess[0..pos + 4] + " " +
            mess[pos + 5..];
        }
        pos = strsrch(mess[pos + 5..], "Written in ");
      }
    }
#endif
    if ( !LANGUAGES->query_language_magic( lang ) ) {
      if ( !type && player && (lang == player->query_default_language())) {
        mess += "\n";
      } else {
        if (stringp(lang)) {
          mess = "Written"+ ( type ? " in "+ type : "" ) +
            ( lang != "general" ? " in "+ capitalize(lang) : "" ) +
            ": "+ mess +"\n";
        } else {
          mess = "Written in some weird broken language: " + mess + "\n";
        }
      }
    }
    message += mess;
  }
  return message;
}
string query_read_short(object player, int ignore_labels) {
   string id;
   string *read_mess;
   read_mess = query_read_mess();
   if ( !arrayp(read_mess) || !sizeof( read_mess ) ) {
      return 0;
   }
   id = query_property("read id");
   if (id) {
      id += " $name$";
   } else {
      id = "$name$";
   }
   return id;
}

==================================================
FILE: basic/repeater.c
==================================================

private nosave object _repeater;
void set_repeater_owner(object owner) {
   _repeater = owner;
}
object query_repeater_owner() {
   return _repeater;
}
void repeat_event_person_say(object caller,
                             object ob,
                             string start,
                             string mess,
                             string lang) {
}
void event_person_say(object ob, string start, string mess, string lang) {
   if (_repeater) {
      _repeater->repeat_event_person_say(this_object(),
                                         ob,
                                         start,
                                         mess,
                                         lang);
   }
}
void repeat_event_emote(object caller,
                        object ob,
                        string mess) {
}
void event_emote( object ob, string mess ) {
   if (_repeater) {
   _repeater->repeat_event_emote(this_object(),
                                 ob,
                                 mess);
   }
}
void repeat_event_say(object caller,
                      object ob,
                      string mess,
                      object *avoid) {
}
void event_say(object ob, string str, mixed avoid) {
   if (_repeater) {
      _repeater->repeat_event_say(this_object(),
                                  ob,
                                  str,
                                  avoid);
   }
}
void repeat_event_soul(object caller,
                       object ob,
                       string mess,
                       object *avoid) {
}
void event_soul(object ob, string str, mixed avoid) {
   if (_repeater) {
      _repeater->repeat_event_soul(this_object(),
                                  ob,
                                  str,
                                  avoid);
   }
}
void repeat_event_enter(object caller,
                        object ob,
                        string mess,
                        object prev) {
}
void event_enter( object thing,
                  string mess,
                  object prev ) {
   if (_repeater) {
      _repeater->repeat_event_enter(this_object(),
                                    thing,
                                    mess,
                                    prev);
   }
}
void repeat_event_exit(object caller,
                       object ob,
                       string mess,
                       object dest) {
}
void event_exit( object thing,
                 string mess,
                 object dest ) {
   if (_repeater) {
      _repeater->repeat_event_enter(this_object(),
                                    thing,
                                    mess,
                                    dest);
   }
}

==================================================
FILE: basic/scroll_base.c
==================================================

#include <tasks.h>
inherit "/std/basic/scroll_book_react";
#define SKILL "magic.items.scroll"
#define CONTROL_SKILL "magic.spells.special"
private string _spell;
string long( string word, int dark ) {
   int i;
   int j;
   int chance;
   int level;
   int width;
   string spell_name;
   level = 2 * (int)_spell->query_power_level();
   width = sqrt( level );
   chance = (int)this_player()->query_skill_bonus( SKILL ) - ( level - width );
   chance = ( 100 * chance ) / ( 2 * width + 1 );
   spell_name = "$"+ (string)_spell->query_name() +"$";
   j = strlen( spell_name ) - 1;
   for ( i = 1; i < j; i++ ) {
      if ( random( 100 ) > chance ) {
         switch ( spell_name[ i ] ) {
            case 32 :
               break;
            case 65 .. 90 :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     sprintf( "%c", 65 + random( 26 ) ) +
                     spell_name[ i + 1 .. j ];
               break;
            case 97 .. 122 :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     sprintf( "%c", 97 + random( 26 ) ) +
                     spell_name[ i + 1 .. j ];
               break;
            default :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     spell_name[ i + 1 .. j ];
               j--;
         }
      }
   }
   spell_name = spell_name[ 1 .. j - 1 ];
   return spell_name;
}
int query_magic_scroll() { return 1; }
int query_binding_force() { return 5; }
string query_spell() { return _spell; }
int query_spell_power_level() {
   if (_spell) {
      return _spell->query_power_level();
   }
}
void set_spell( string word ) { _spell = word; }
string query_spell_name() { return (string)_spell->query_name(); }
int test_skill() {
   int level;
   level = 2 * (int)( _spell->query_power_level() ) + 1;
   return (int)TASKER->perform_task(this_player(), SKILL, level, TM_FREE);
}
void clear_spell( int award ) {
   if ( award ) {
     write( "%^YELLOW%^"+ ({ "A piece of lore concerning scrolls becomes "
             "clearer for you", "You manage to grasp one of the principles "
             "of magic scrolls more firmly", "A sudden flash of insight "
             "allows you to understand process of casting a spell from a "
             "scroll a little better" })[ random( 3 ) ] +".%^RESET%^\n" );
   }
}
int cast_spell( string words ) {
   int outcome;
   if ( !words ) {
      words = "";
   }
   outcome = test_skill();
   if ( outcome == FAIL ) {
      return notify_fail( "You can't figure out how to use the scroll.\n" );
   }
   if ( !( _spell->cast_spell( words, 1 ) ) ) {
      return 0;
   }
   clear_spell( outcome == AWARD );
   return 1;
}
int cast_spell_new( string words , object* targets, object* using ) {
   int outcome;
   if ( !words ) {
      words = "";
   }
   outcome = test_skill();
   if ( outcome == FAIL ) {
      return notify_fail( "You can't figure out how to use the scroll.\n" );
   }
   if ( !( _spell->cast_spell_new( words, 1, targets, using ) ) ) {
      return 0;
   }
   clear_spell( outcome == AWARD );
   return 1;
}
string query_death_reason() {
   return " a spell going wild and getting out of control.";
}

==================================================
FILE: basic/scroll_book_react.c
==================================================

#include <tasks.h>
#define SKILL "magic.items.scroll"
#define CONTROL_SKILL "magic.spells.special"
void destroy_this_scroll() {
}
void check_react(object player) {
   object ob;
   int level;
   int ac;
   string check_spell;
   object paper;
   object *items;
   object env;
   if (!environment(player)) {
      return;
   }
   env = environment(player);
   while (env && !living(env)) {
      env = environment(env);
   }
   if (env && !userp(env) && !env->query_owner()) {
      return ;
   }
   items = filter(deep_inventory(environment(player)),
                  (: $1->query_magic_scroll() ||
                     $1->query_spell_book() :));
   foreach (paper in items) {
      level += paper->query_spell_power_level();
   }
   if (random(sqrt(level)) <= 5 + random(5)) {
      return;
   }
   ob = environment(player);
   while(ob) {
      if(living(ob)) {
         break;
      } else {
         ob = environment(ob);
      }
   }
   if(!ob || !living(ob)) {
      return;
   }
   if(ob) {
      switch(TASKER->perform_task(ob, CONTROL_SKILL, level*2 + random(4),
                                  TM_FREE)) {
      case AWARD:
         tell_object(ob, "Suddenly the spell "+
                      this_object()->query_spell_name()+ " on the "+
                     player->the_short()+" gets out of control and tries to go "
                     "wild.\n");
         tell_room(environment(ob), "Suddenly " + ob->one_short() +
                   " looks very startled as the spell " +
                   this_object()->query_spell_name() +
                   " on "+player->the_short()+" gets out of control and "
                   "tries to go wild.\n", ob);
         write("%^YELLOW%^You feel you have a better grasp of controlling "
               "spells on scrolls.\n.%^RESET%^\n" );
      case SUCCEED:
         return;
      default:
         tell_object(ob, "Suddenly the spell " +
                     this_object()->query_spell_name() + " on the "+
                     player->the_short() +
                     " gets out of control and tries to go wild.\n");
         tell_room(environment(ob), "Suddenly " + ob->one_short() +
                   " looks very startled as the spell " +
                   this_object()->query_spell_name() +
                   " on " + player->the_short() + " gets out of control and "
                   "tries to go wild.\n", ob);
         tell_object(ob, "Unfortunately you cannot get control of it and "
                     "before flying away into nowhere it tears wildly at "
                     "your mind.\n");
         tell_room(environment(ob), "Unfortunately "+ob->one_short()+" cannot "
                   "get control of it and it flies away to freedom.\n", ob);
         ac = (int)ob->query_ac("magic", level * 10);
         level -= ac;
         ob->adjust_hp(-level, this_object());
         ob->adjust_tmp_int(-2 + random(2));
         destroy_this_scroll();
         break;
      }
   }
}
string query_death_reason() {
   return " a spell going wild and getting out of control.";
}

==================================================
FILE: basic/setup.c
==================================================

private int _do_setup;
protected void inc_setup() {
   _do_setup++;
}
protected void dec_setup() {
   _do_setup--;
}
protected void do_setup() {
   if (!_do_setup) {
      this_object()->setup();
   }
}
protected void do_reset() {
   if (!_do_setup) {
      this_object()->reset();
   }
}

==================================================
FILE: basic/stat_adjustments.c
==================================================

#include <effects/stat_adjustment.h>
private nosave mapping _adjs;
void create() {
   _adjs = ([ ]);
}
void set_stat_adjustment(object player, mapping adjs) {
   _adjs[player] = adjs;
   player->add_effect(STAT_ADJUSTMENT_EFFECT, ({ this_object(), adjs }));
}
void remove_stat_adjustment(object player) {
   STAT_ADJUSTMENT_EFFECT->remove_stat_adjustment_ob(player, this_object());
   map_delete(_adjs, player);
}
void remove_all_stat_adjustments() {
   mapping adj;
   object play;
   foreach (play, adj in _adjs) {
      STAT_ADJUSTMENT_EFFECT->remove_stat_adjustment_ob(play, this_object());
      map_delete(_adjs, play);
   }
   _adjs = ([ ]);
}
mapping query_stat_adjustments(object play) {
   return _adjs[play];
}

==================================================
FILE: basic/surface.c
==================================================

#include <surface.h>
nosave object *surface_shadows;
object *query_surface_shadows() {
   return surface_shadows;
}
void make_shadow( object thing ) {
  object shadow;
  shadow = clone_object( SURFACE_SHADOW );
  shadow->setup_shadow( thing, this_object() );
  if ( !surface_shadows ) surface_shadows = ({ });
  surface_shadows += ({ shadow });
}
void check_shadows() {
  int i;
  for ( i = 0; i < sizeof( surface_shadows ); i++ ) {
    if ( surface_shadows[ i ] ) {
      if ( environment() == (object)surface_shadows[ i ]->
          query_shadowed( surface_shadows[ i ] ) ) {
        surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] );
        surface_shadows = surface_shadows[0..i-1] + surface_shadows[i + 1..];
        i--;
      }
    } else {
      surface_shadows = surface_shadows[0..i-1] + surface_shadows[i + 1..];
      i--;
    }
  }
  call_out( "check_environment", 0 );
}
void check_environment() {
  if ( environment() ) {
     make_shadow( environment() );
  }
}
void dest_me() {
  int i;
  for ( i = 0; i < sizeof( surface_shadows ); i++ )
    if ( surface_shadows[ i ] )
      surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] );
}

==================================================
FILE: basic/theft_callback.c
==================================================

class theft_callback {
     string func_name;
     string path;
}
class theft_callback *calls = ({ });
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  if ( !sizeof( calls ) )
    return;
  if ( !stolen ) {
    foreach( class theft_callback temp in calls ) {
      if ( stringp( temp->path ) && stringp( temp->func_name ) )
        call_other( temp->path, temp->func_name, this_object(), thief, victim );
    }
  }
  return;
}
int add_theft_callback( string func_name, string path ) {
class theft_callback temp = new( class theft_callback, func_name: func_name,
  path: path );
  if ( !stringp( func_name ) || !stringp( path ) )
    return -1;
  debug_printf( "Added theft callback: %s %s.\n", func_name, path );
  calls += ({ temp });
  return sizeof( calls ) - 1;
}
int remove_theft_callback( int id ) {
  if ( id >= sizeof( calls ) || id < 0 )
    return -1;
  debug_printf( "Deleting callback: %s %s.\n", calls[id]->func_name,
    calls[id]->path );
  calls -= ({ calls[id] });
  return 1;
}
string query_theft_callbacks() {
string ret = "";
int count = 0;
  if ( !sizeof( calls ) )
    return "No theft callbacks found!\n";
  foreach( class theft_callback temp in calls ) {
    ret += sprintf( "%d. %s: %s.\n", count, temp->func_name, temp->path );
    count++;
  }
  return ret;
}

==================================================
FILE: basic/trap.c
==================================================

#include <tasks.h>
#define SKILL "covert.lockpick.traps"
private nosave int _trap_difficulty;
private nosave string _trap_trigger;
private nosave string _trap_description;
private nosave mixed _trap_message;
private nosave mixed _trap_effect;
private nosave mixed _trap_armed;
void setup_trap(int difficulty, string trigger, string description,
                     mixed message, mixed effect) {
  if(!trigger)
    return;
  if(trigger == "open")
    this_object()->set_open_trap(this_object(), "basic_trap");
  else
    this_object()->set_lock_trap(this_object(), "basic_trap");
  _trap_difficulty = difficulty;
  _trap_trigger = trigger;
  _trap_description = description;
  _trap_message = message;
  _trap_effect = effect;
}
mixed *query_trap_data() {
  return ({ _trap_difficulty, _trap_trigger, _trap_description,
              _trap_message, _trap_effect, _trap_armed });
}
int query_trap_difficulty() { return _trap_difficulty; }
string query_trap_trigger() { return _trap_trigger; }
string query_trap_description() { return _trap_description; }
mixed query_trap_message() { return _trap_message; }
mixed query_trap_effect() { return _trap_effect; }
void set_trap_armed(int i) { _trap_armed = i; }
int query_trap_armed() { return _trap_armed; }
int basic_trap(string action) {
  if(!_trap_armed || action != _trap_trigger)
    return 1;
  switch(TASKER->perform_task(this_player(), SKILL, _trap_difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about avoiding "
          "traps.%^RESET%^\n");
  case SUCCEED:
    return 1;
  default:
    if(arrayp(_trap_message)) {
      write(_trap_message[0]);
      say(_trap_message[1], this_player());
    } else
      write(_trap_message);
    if(intp(_trap_effect)) {
      if(_trap_effect > this_player()->query_hp())
        this_player()->do_death();
      else
        this_player()->adjust_hp(-(_trap_effect));
    } else if(arrayp(_trap_effect)) {
      if(sizeof(_trap_effect) == 2)
        this_player()->add_effect(_trap_effect[0], _trap_effect[1]);
      else
        this_player()->add_effect(_trap_effect[0], _trap_effect[1..]);
    } else
      this_player()->add_effect(_trap_effect);
    return 0;
  }
}

==================================================
FILE: basic/version.c
==================================================

nosave mapping version_control = ([ ]);
void create() {
  version_control[ base_name( this_object() ) ] = ctime( time() );
  foreach( object temp in inherit_list( this_object() ) )
    version_control[ base_name( temp ) ] = temp->query_version();
}
void query_version_control() {
  write( "File:\tTime:\n" );
  foreach( string temp in keys( version_control ) )
    printf( "%s\t%s.\n", temp, version_control[ temp ] );
  return;
}
string query_version() {
  return version_control[ base_name( this_object() ) ];
}

==================================================
FILE: basic/virtual_quit_control.c
==================================================

protected string find_start_pos(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char;
   if ( place ) {
      quit_env = place->query_quit_handler( player );
      if (arrayp(quit_env)) {
         last_pos = quit_env[0];
      } else {
         last_pos = (string)quit_env;
      }
      if ( last_pos ) {
         last_pos->player_quitting( player, place );
      } else {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }
   if (last_pos && last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {
      test_char = player->query_property( "test character" );
      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }
      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if (!player->query_creator() ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }
   return last_pos;
}
protected int * find_start_coord(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char;
   if ( place ) {
      quit_env = place->query_quit_handler();
      if (arrayp(quit_env)) {
         return quit_env[1];
      } else {
         last_pos = (string)quit_env;
      }
      if ( !last_pos ) {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }
   if (last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {
      test_char = player->query_property( "test character" );
      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }
      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if( !( player->query_creator() ||
                player->query_property( "test character" ) ) ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }
   return last_pos->query_co_ord();
}

==================================================
FILE: basic/virtual_update.c
==================================================

#include <virtual.h>
mixed query_property(string name);
void add_property(string name, mixed prop);
void init_static_arg(mapping data);
void replace_me()
{
   object receipt;
   mixed als;
   receipt = clone_object("/obj/misc/al_receipt");
   receipt->set_name("receipt");
   receipt->set_object(file_name(this_object()));
   receipt->set_virtobname(query_property(VIRTUAL_NAME_PROP));
   receipt->set_value(this_object()->query_value());
   als = "/global/auto_load"->fragile_auto_str_ob(this_object());
   als[0] = 1;
   receipt->set_static_save(als);
   receipt->set_short("destructed item receipt");
   receipt->add_adjective(({ "destructed", "item" }));
   receipt->set_long("This seems to be a small piece of paper.\n");
   receipt->set_read_mess("According to our sources, your " +
                          this_object()->query_short() +
                          " was not " "allowed to exist.  Have a nice day.");
   receipt->move(environment());
   receipt->set_weight(1);
   destruct(this_object());
}
void init_virtual_object()
{
   mapping stat_temp;
   string virt_name;
   string new_name;
   virt_name = query_property(VIRTUAL_NAME_PROP);
   if (virt_name) {
      if (file_size(virt_name) == -1) {
         new_name = (CLONER)->other_file(virt_name);
         if (stringp(new_name) && (new_name != virt_name)) {
            add_property(VIRTUAL_NAME_PROP, new_name);
            virt_name = new_name;
         } else {
            if (VIRTUAL_HANDLER->query_forbidden(virt_name)) {
               call_out("replace_me", 1);
            } else {
               VIRTUAL_HANDLER->add_missing(virt_name);
            }
         }
      }
      if (file_size(virt_name) != -1 &&
          query_property("virtual time") < stat(virt_name)[1]) {
         stat_temp = (VIRTUAL_HANDLER)->new_data(virt_name);
         if (mapp(stat_temp)) {
            init_static_arg(stat_temp);
            add_property("virtual time", time());
         }
      }
   }
}

==================================================
FILE: basic/wearable.c
==================================================

inherit "/std/basic/condition";
#include <clothing.h>
#include <move_failures.h>
private string *immune_to;
private string *wear_effects;
private mixed type;
private mixed *wear_remove_func;
nosave object worn_by;
void create() {
   condition::create();
   set_damage_chance( 25 );
   immune_to = ({ "cold", "sound", "gas", "mental" });
   wear_effects = ({ });
   wear_remove_func = ({ });
}
int query_wearable() { return 1; }
string long( string word, int dark ) {
   switch ( dark ) {
      case 0 :
         return cond_string();
      default :
         return "";
   }
}
mixed *query_wear_remove_func() {
   return wear_remove_func;
}
void set_wear_remove_func( mixed file, string func ) {
   wear_remove_func = ({ file, func });
}
string *query_wear_effects() {
  if(!wear_effects)
    wear_effects = ({ });
  return copy(wear_effects);
}
void set_wear_effects( string *effects ) {
   wear_effects = effects;
}
void add_wear_effect( string effect ) {
   if ( member_array( effect, wear_effects ) == -1 ) {
      wear_effects += ({ effect });
   }
}
void do_damage( string type, int amount ) {
   if ( member_array( type, immune_to ) == -1 ) {
      condition::do_damage( type, amount );
   }
}
object query_worn_by() {
   return worn_by;
}
int set_worn_by( object thing ) {
   int i;
   if ( thing == worn_by ) {
      return 1;
   }
   if (thing && environment() != thing) {
      return 0;
   }
   this_object()->remove_hide_invis( "concealed" );
   if ( sizeof( wear_remove_func ) ) {
    if ( !objectp( wear_remove_func[ 0 ] ) && !objectp( load_object( wear_remove_func[ 0 ] ) ) ) {
        debug_printf( "Wear/Remove func is %O. Not called.\n", wear_remove_func );
      return 0;
    }
    if ( worn_by ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], 0, worn_by );
      }
      if ( thing ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], thing, thing );
      }
   }
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         if ( worn_by ) {
            worn_by->taken_off( this_object(), wear_effects[ i ] );
         }
         if ( thing ) {
            thing->add_effect( wear_effects[ i ], this_object() );
         } else {
            wear_effects[i]->person_removing_item(this_object(), worn_by);
         }
      }
   }
   if ( worn_by ) {
      worn_by->now_removed( this_object() );
      this_object()->add_adjective("worn");
      this_object()->remove_adjective("unworn");
   } else {
      this_object()->remove_adjective("worn");
      this_object()->add_adjective("unworn");
   }
   if ( thing ) {
      thing->now_worn( this_object() );
   }
   worn_by = thing;
   return 1;
}
string *query_immune_to() {
   return immune_to;
}
void add_immune_to( mixed args ) {
   int i;
   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         add_immune_to( args[ i ] );
      }
   } else {
      if ( member_array( args, immune_to ) == -1 ) {
         immune_to += ({ args });
      }
   }
}
void remove_immune_to( mixed args ) {
   int i;
   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         remove_immune_to( args[ i ] );
      }
   } else {
      i = member_array( args, immune_to );
      if ( i != -1 ) {
         immune_to = delete( immune_to, i, 1 );
      }
   }
}
string query_type() {
   return type;
}
private void log_bad_type( mixed type ) {
  string word, str;
  if ( !clonep( this_object() ) ) {
      return;
  }
  word = (string)this_object()->query_property( "virtual name" );
  if ( word ) {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", word,
           (string)this_object()->query_short(), type );
  } else {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", file_name(),
           (string)this_object()->query_short(), type );
  }
  if ( this_player()) {
    write(str);
  }
  call_out("move", 2, "/room/broken");
}
void set_type( mixed word ) {
  int i;
   if(!stringp(word) && !pointerp(word))
      return log_bad_type(word);
   type = word;
   if(stringp(word)) {
     if(CLOTHING_HANDLER->query_equivilant_type(word))
       type = CLOTHING_HANDLER->query_equivilant_type(word);
     if(!CLOTHING_HANDLER->query_valid_type(word))
       log_bad_type( word );
     return;
   }
   for(i=0; i<sizeof(word); i++) {
     if(CLOTHING_HANDLER->query_equivilant_type(word[i]))
       type[i] = CLOTHING_HANDLER->query_equivilant_type(word[i]);
     if (!CLOTHING_HANDLER->query_valid_type(word[i]))
       log_bad_type( word );
     return;
   }
}
int modify_value( int amount ) {
   return ( amount * ( 10 + ( 90 * query_cond() ) / query_max_cond() ) ) / 100;
}
void player_wear() {
   if ( !environment() ) {
      return;
   }
   environment()->wear_armour( this_object() );
}
void break_me() {
   if ( !worn_by ) {
      return condition::break_me();
   }
   tell_object( worn_by, "%^RED%^$C$"+ (string)this_object()->the_short() +
         " breaks!%^RESET%^\n" );
   tell_room( environment( worn_by ), (string)worn_by->the_short() +"'s "+
         this_object()->short( 0 ) +" breaks!\n", worn_by );
   worn_by->remove_armour( this_object() );
   if((int)this_object()->move("/room/rubbish") != MOVE_OK)
     move_object("/room/rubbish");
}
mixed *stats() {
   int i;
   string *stuff;
   stuff = condition::stats() +
      ({
         ({ "type", type }),
      });
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         stuff += ({ ({ "wear effect", wear_effects[ i ] }) });
      }
   }
   for ( i = 0; i < sizeof( immune_to ); i++ ) {
      stuff += ({ ({ "immune to", immune_to[ i ] }) });
   }
   if (worn_by) {
      stuff += ({ ({ "worn by", worn_by->short() }) });
   }
   return stuff;
}
mapping query_static_auto_load() {
   return ([
      "condition" : condition::query_static_auto_load(),
      "type" : type,
      "wear remove func" : wear_remove_func
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "condition" : condition::query_dynamic_auto_load(),
      "wear effects" : wear_effects,
      "immune" : immune_to,
      "worn" : ( worn_by != 0 )
   ]);
}
void init_static_arg( mapping map ) {
   if ( map[ "type" ] )
      type = map[ "type" ];
   if ( map[ "wear remove func" ] )
      wear_remove_func = map[ "wear remove func" ];
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_static_arg( map[ "condition" ] );
   }
#ifdef AFTER_1999_I_BELIEVE
   else {
      if ( !undefinedp( map[ "max cond" ] ) )
         max_cond = map[ "max cond" ];
      if ( !undefinedp( map[ "damage chance" ] ) )
         damage_chance = map[ "damage chance" ];
   }
#endif
}
void init_dynamic_arg( mapping map, object ) {
   if ( map[ "effect" ] )
      wear_effects = ({ map[ "effect" ] });
   if ( pointerp( map[ "wear effects" ] ) )
      wear_effects = map[ "wear effects" ];
   if ( map[ "immune" ] )
      immune_to = map[ "immune" ];
   if ( map[ "worn" ] )
      call_out( "player_wear", 0 );
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_dynamic_arg( map[ "condition" ] );
   }
#ifdef AFTER_1999_I_BELIEVE
   } else {
      cond = map[ "cond" ];
      lowest_cond = map[ "lowest cond" ];
   }
#endif
}
void remove_wear_remove_func() {
    wear_remove_func = ({ });
}

==================================================
FILE: socket/telnet.c
==================================================

#include <socket.h>
#include <socket_errors.h>
#define WRITE_WAIT_CALLBACK 0
#define WRITE_GO_AHEAD      1
#define DISCONNECTED "an internet terminal"
#define CONNECTED "an internet terminal (connected)"
#define IAC  255
#define DONT 254
#define DO   253
#define WONT 252
#define WILL 251
#define TELOPT_ECHO   1
#define TELOPT_SGA    3
#define TELOPT_TTYPE 24
#define TELOPT_NAWS  31
nosave string *telopts = ({"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD",
			"NAME", "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
		    "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
		    "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
		    "DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
		    "SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
		    "TACACS UID", "OUTPUT MARKING", "TTYLOC",
		    "3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
		    "LINEMODE"});
nosave string s_iac_dont_echo;
nosave string s_iac_do_echo;
nosave string s_iac_wont_echo;
nosave string s_iac_will_echo;
nosave string s_iac_dont_sga;
nosave string s_iac_do_sga;
nosave string s_iac_wont_sga;
nosave string s_iac_will_sga;
nosave string s_iac_wont_ttype;
nosave string s_iac_wont_naws;
nosave string s_iac;
nosave string s_dont_echo;
nosave string s_do_echo;
private string callback;
private int conn_fd;
private int connected;
private int verbose;
private int write_state = WRITE_WAIT_CALLBACK;
private string write_message = "";
protected void init_tel_neg()
{
  s_iac_dont_echo  = sprintf("%c%c%c",IAC,DONT,TELOPT_ECHO);
  s_iac_do_echo    = sprintf("%c%c%c",IAC,DO  ,TELOPT_ECHO);
  s_iac_wont_echo  = sprintf("%c%c%c",IAC,WONT,TELOPT_ECHO);
  s_iac_will_echo  = sprintf("%c%c%c",IAC,WILL,TELOPT_ECHO);
  s_iac_dont_sga   = sprintf("%c%c%c",IAC,DONT,TELOPT_SGA);
  s_iac_do_sga     = sprintf("%c%c%c",IAC,DO  ,TELOPT_SGA);
  s_iac_wont_sga   = sprintf("%c%c%c",IAC,WONT,TELOPT_SGA);
  s_iac_will_sga   = sprintf("%c%c%c",IAC,WILL,TELOPT_SGA);
  s_iac_wont_ttype = sprintf("%c%c%c",IAC,WONT,TELOPT_TTYPE);
  s_iac_wont_naws  = sprintf("%c%c%c",IAC,WONT,TELOPT_NAWS);
  s_iac            = sprintf("%c",    IAC);
  s_dont_echo      = sprintf("%c%c",  DONT,TELOPT_ECHO);
  s_do_echo        = sprintf("%c%c",  DO,  TELOPT_ECHO);
}
void
set_callback(string arg)
{
	callback = arg;
}
void create()
{
  init_tel_neg();
  connected = 0;
  verbose = 0;
  set_callback("handler");
}
void
set_verbosity(int v)
{
	verbose = v;
}
int
query_connected()
{
	return connected;
}
void disconnected()
{
  call_other(this_object(), callback, "close");
  connected = 0;
}
int connected()
{
  call_other(this_object(), callback, "open");
  connected = 1;
}
void my_socket_write(int fd, string message)
{
  int ret;
  write_message = write_message + message;
  if(write_state == WRITE_GO_AHEAD){
    ret = socket_write(fd, write_message);
    write_message = "";
    if(ret == EESUCCESS) write_state = WRITE_GO_AHEAD;
    else if(ret == EECALLBACK) write_state = WRITE_WAIT_CALLBACK;
  }
}
int line(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_dont_sga+s_iac_dont_echo);
    write("SENT dont SUPPRESS GO AHEAD\nSENT dont ECHO\n");
    return(1);
  }
  return(0);
}
int char(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_do_sga+s_iac_do_echo);
    write("SENT do SUPPRESS GO AHEAD\nSENT do ECHO\n");
    return(1);
  }
  return(0);
}
int connect(string str)
{
  int ret;
  if(!str) return(0);
  conn_fd = socket_create(STREAM,"socket_shutdown");
  ret = socket_connect(conn_fd,str,"receive_data","write_data");
  if(ret != EESUCCESS){
    notify_fail("unable to connect: " + socket_error(ret) + "\n");
    return(0);
  }
  connected();
  return(1);
}
int send(string str)
{
  if(connected){
    if(!str){
      write("Sending CR.\n");
      my_socket_write(conn_fd,"\n");
      return(1);
    }
    my_socket_write(conn_fd,str + "\n");
    return(1);
  }
  return(0);
}
int disconnect(string str)
{
  int ret;
  ret = socket_close(conn_fd);
  if(ret <= 0){
    notify_fail("unable to disconnect.\n");
    return(0);
  }
  disconnected();
  return(1);
}
void receive_data(int rec_fd, string msg) {
  string *chunks;
  int i;
  object hearer;
  this_object()->recieve_message(msg);
}
void write_data(int fd) {
  write_state = WRITE_GO_AHEAD;
  my_socket_write(fd,"");
}
void socket_shutdown(int fd)
{
  object hearer;
  if(fd == conn_fd){
    hearer = environment(this_object());
    disconnected();
    return;
  }
}

==================================================
FILE: nationality/basic.c
==================================================

inherit "/std/basic/setup";
class region {
   string description;
   string start_location;
   string accent_ob;
}
private string _name;
private string _information;
private string _same_nat_description;
private string _different_nat_description;
private string _start_loc;
private string _language;
private string _accent;
private string _currency;
private mapping _regions;
void create() {
   _regions = ([ ]);
   do_setup();
}
void add_region(string name, string description, string start, string accent) {
   class region bing;
   bing = new(class region,
              description : description,
              start_location : start,
              accent_ob : accent);
   _regions[name] = bing;
}
void set_name(string name) {
   _name = name;
}
string query_name() {
   return _name;
}
void set_same_nationality_description(string description) {
   _same_nat_description = description;
}
string query_same_nationality_description() {
   return _same_nat_description;
}
void set_different_nationality_description(string description) {
   _different_nat_description = description;
}
string query_different_nationality_description() {
   return _different_nat_description;
}
string query_look_description(object person, object looker) {
   return "";
   if (person->query_nationality() == looker->query_nationality()) {
      return capitalize(person->query_pronoun()) + " " +
             _same_nat_description;
   } else {
      return capitalize(person->query_pronoun()) + " " +
             _different_nat_description;
   }
}
void set_default_start_location(string start_loc) {
   _start_loc = start_loc;
}
string query_default_start_location() {
   return _start_loc;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
void set_information(string info) {
   _information = info;
}
string query_information() {
	if (!_information) {
      _information = "The $C$" + query_name() + " nationality is yet to "
                     "be described.\n";
   }
   return _information;
}
string* query_regions() {
   return keys(_regions);
}
string query_region_description(string region) {
   return _regions[region]->description;
}
string query_region_start_location(string region) {
   return _regions[region]->start_location;
}
string query_start_location(string region) {
   if (_regions[region] && _regions[region]->start_location) {
      return _regions[region]->start_location;
   }
   return _start_loc;
}
string query_region_accent_ob(string region) {
   if (_regions[region]) {
      return _regions[region]->accent_ob;
   }
   return 0;
}
void set_currency_area(string area) {
   _currency = area;
}
string query_currency_area() {
   return _currency;
}

==================================================
FILE: nationality/pumpkin.c
==================================================

inherit "/std/nationality/basic";
void setup() {
   set_name( "pumpkin" );
   set_information( "Pumpkin is a large orange ball shaped town.\n");
   add_region( "round",
               "Pumpkins which are round.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/round");
   add_region( "square",
               "Sto Lat is the second biggest city in the Morporkian kingdom, "
               "it sits on the river Ankh on the way to the Carrack "
               "Mountains.  It is a harder starting location than "
               "Ankh-Morpork but close enough that it is not that much of an "
               "issue.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/square");
   set_language("pumpkin");
   set_currency_area("Pumpkin");
   set_default_start_location("/d/am/buildings/drum/mendeddrum");
}

==================================================
FILE: nationality/accents/accent_base.c
==================================================

#define NATIONAL_ACCENT_PATH "/std/nationality/accents/national/"
mapping accent_lang_map = ([
   "Pumpkin" : "pumpkin",
   ]);
string query_nat_accent( string lang ) {
   return NATIONAL_ACCENT_PATH + lang;
}
string national_garble( string mess, object person, object sayer, int say_type,
                        string def_lang, string accent ) {
   string accent_lang = accent_lang_map[ accent ];
   string nat_accent = query_nat_accent( accent_lang );
   if( def_lang != accent_lang ) {
      if( nat_accent )
         mess = load_object( query_nat_accent( accent_lang ) )->garble_say( mess,
                                                                            person,
                                                                            sayer,
                                                                            say_type );
   } else {
   }
   return mess;
}

==================================================
FILE: nationality/accents/regional/round.c
==================================================

inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Morporkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "au", "$AU_PROTECT",
                               "oo", "$OO_PROTECT",
                               "ou", "$OU_PROTECT",
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                                "$OO_PROTECT", "oo",
                               "$OU_PROTECT", "ou",
                               "$AU_PROTECT", "au"
                               }) );
}

==================================================
FILE: nationality/accents/regional/square.c
==================================================

inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Pumpkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "a", "aa",
                               "oo", "o",
                               "ou", "ooou"
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                               }) );
}

==================================================
FILE: nationality/accents/national/pumpkin.c
==================================================

string garble_say( string mess, object person,
                   object sayer, int say_type ) {
   return replace( mess, ({
                            "eh", "a",
                            "ah", "eh",
                            "ou", "oo"
                         }) );
}
string query_accent_name() {
   return "Pumpkinian";
}

==================================================
FILE: curses/chef_curse.c
==================================================

#include "path.h"
#define MY_NAME "chef curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"chef_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"chef_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"chef_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"chef_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"chef_mangle")->do_transmute(str));
}

==================================================
FILE: curses/chef_mangle.c
==================================================

string *replace_matrix;
void create() {
  replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
}
string do_transmute(string str) {
  return replace(" "+str, replace_matrix)[1..10000];
}

==================================================
FILE: curses/ken_curse.c
==================================================

#include "path.h"
#define MY_NAME "ken curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"ken_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"ken_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"ken_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"ken_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"ken_mangle")->do_transmute(str));
}

==================================================
FILE: curses/ken_mangle.c
==================================================

string *replace_matrix;
mapping trans;
void create() {
  replace_matrix = ({
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });
  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
}
string do_transmute(string str) {
  string tmp, *bits;
  mixed erp;
  int i;
  tmp = replace(" "+str+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
}

==================================================
FILE: curses/newbie_curse.c
==================================================

#include "path.h"
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

==================================================
FILE: curses/newbie_eff_shadow.c
==================================================

inherit "/std/effect_shadow";
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
string name, my_name;
void remove_effect_shadow(int i) {
   if (i == id) {
      destruct(this_object());
      return;
   }
      else player->remove_effect_shadow(i);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

==================================================
FILE: curses/path.h
==================================================

#define HERE "/std/curses/"

==================================================
FILE: curses/shout_curse.c
==================================================

#include "path.h"
#define MY_NAME "Shout curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  printf("%O, %O\n", pl, this_object());
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"shout_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}
int do_shout(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}

==================================================
FILE: curses/upper_case.c
==================================================

#include "path.h"
#define MY_NAME "UPPER CASE"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string upper_case(string str) {
  string ret;
  int i;
  ret = "";
  for (i=0;i<strlen(str);i++)
    ret += capitalize(str[i..i]);
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(upper_case(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(upper_case(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(upper_case(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(upper_case(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(upper_case(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(upper_case(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(upper_case(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(upper_case(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(upper_case(str));
}

==================================================
FILE: shops/auction_house.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/auction_house";
void create() {
   auction_house::create();
   basic_room::create();
   add_help_file("auction_house");
}
void init() {
   basic_room::init();
   auction_house::init();
}

==================================================
FILE: shops/bank.c
==================================================

#include <money.h>
#include <move_failures.h>
#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"
nosave inherit "/std/room/basic_room";
int total_account, total_made;
nosave int account_cost, percentage;
nosave string bank_name, place;
int do_withdraw(int num, string type);
int do_deposit(string str);
nosave string save_file;
void create() {
  account_cost = 0;
  percentage = 90;
  total_account = 0;
  total_made = 0;
  bank_name = "Bing's First";
  place = "default";
  add_help_file("bank");
  ::create();
}
void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<number> <string>",
               (: do_withdraw($4[0], $4[1]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
  ::init();
}
int query_account_cost() { return account_cost; }
void set_account_cost( int number ) { account_cost = number; }
int query_percentage() { return percentage; }
void set_percentage( int number ) { percentage = number; }
int query_total_account() { return total_account; }
int query_total_made() { return total_made; }
string query_bank_name() { return bank_name; }
void set_bank_name( string word ) { bank_name = word; }
string query_place() { return place; }
string query_money_place() { return query_place(); }
void set_place( string word ) { place = word; }
string query_save_file() { return save_file; }
void set_save_file( string word ) {
  save_file = word;
  if ( file_size( save_file +".o" ) > 0 )
    unguarded((: restore_object, save_file :));
}
void do_save() {
   if ( !save_file ) {
      return;
   }
   unguarded( (: save_object, save_file :) );
}
int get_account() {
  int amount;
  if ( amount = (int)this_player()->query_property( "bank "+ OLD_BANK ) ) {
    HANDLER->adjust_account( NAME, bank_name, amount );
    this_player()->remove_property( "bank "+ OLD_BANK );
    total_account += amount;
    do_save();
  }
  return (int)HANDLER->query_account( NAME, bank_name );
}
int set_account( int amount ) {
  HANDLER->set_account( NAME, bank_name, amount );
}
int do_balance() {
  int amount;
  amount = get_account();
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     this_player()->add_succeeded_mess(this_object(),
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }), ({ }) );
    return 1;
  }
  this_player()->add_succeeded_mess(this_object(),
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount, place ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }), ({ }) );
  return 1;
}
int do_withdraw( int number, string type ) {
  int amount;
  int best;
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( number <= 0 ) {
    notify_fail( "You must withdraw something.\n" );
    return 0;
  }
  money = clone_object( MONEY_OBJECT );
  money->set_money_array( (mixed *)MONEY_HAND->query_values_in( place ) );
  if ( ( best = (int)money->find_best_fit( type ) ) == -1 ) {
    notify_fail( "That currency is not legal tender here.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  type = ( (mixed *)money->query_money_array() )[ best ];
  amount = number * ( (mixed *)money->query_money_array() )[ best + 1 ];
  if ( ( amount > total ) ||
       ( amount < 0 ) ) {
    notify_fail( "You don't have enough money in your account.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  money->set_money_array( ({ type, number }) );
  set_account( total - amount );
  total_account -= amount;
  do_save();
  this_player()->add_succeeded_mess(this_object(),
   ({ "You withdraw "+ (string)money->short() +".\n" +
      "You have "+ (string)MONEY_HAND->money_value_string( get_account(),
                                                           place ) +
        " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
       }), ({ }) );
  if ( (int)money->move( this_player() ) != MOVE_OK ) {
    write( "You are too heavily burdened to collect the money, so the teller "+
      "puts it on the counter for you.\n" );
    money->move( this_object() );
  }
  this_player()->save();
  return 1;
}
int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;
   total = get_account();
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only deposit money.\n" );
         default :
            return notify_fail( "You can only deposit legal tender.\n" );
      }
   }
   if (!place) {
      place = "default";
   }
   tender = MONEY_HAND->filter_legal_tender( money, place);
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
     amount = legal->query_value_in(place);
     if (place != "default") {
       amount += legal->query_value_in("default");
     }
     if(amount < 200) {
       if( legal->move( this_player() ) != MOVE_OK ) {
          legal->move( environment( this_player() ) );
          tell_object( this_player(), "You lose hold of some coins and "
             "they tumble to the floor.\n" );
          tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
       }
       if(illegal)
         if( illegal->move( this_player() ) != MOVE_OK ) {
            illegal->move( environment( this_player() ) );
            tell_object( this_player(), "You lose hold of some coins and "
               "they tumble to the floor.\n" );
            tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
         }
       add_failed_mess("That is too small an amount to deposit.\n");
       return 0;
     }
     tmp = ( amount * ( 100 - percentage ) ) / 100;
     total_made += tmp;
     amount = amount - tmp;
     set_account( total + amount );
     total_account += amount;
     do_save();
   }
   if (illegal) {
      if( illegal->move( this_player() ) != MOVE_OK ) {
         illegal->move( environment( this_player() ) );
         tell_object( this_player(), "You lose hold of some coins and "
            "they tumble to the floor.\n" );
         tell_room( environment( this_player() ), this_player()->one_short() +
            "accidentally drops some coins.\n", this_player() );
       }
   }
   if (legal) {
      howmuch = legal->the_short();
      legal->move( "/room/rubbish" );
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }
   write( "You give the teller "+ howmuch +".\n" );
   write( "After expenses, this leaves "+ (string)MONEY_HAND->
          money_value_string( amount, place ) +".\n" );
   this_player()->add_succeeded_mess(this_object(),
       ({  "$N $V "+words+".\n"
           "This gives a total of " +
           MONEY_HAND->money_value_string(total + amount, place ) +
           " in your account.\n",
           "$N deposit$s some money into $p account.\n" }), ({ }) );
   return 1;
}
int do_open() {
  int amount;
  object money;
  if ( get_account() >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( account_cost ) {
    if ( !( money = present( MONEY_ALIAS, this_player() ) ) ) {
      notify_fail( "You do not have any money.\n" );
      return 0;
    }
    amount = (int)money->query_value_in( place );
    if ( place != "default" )
      amount += (int)money->query_value_in( "default" );
    if ( amount < account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      account_cost, place ) +" to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  return 1;
}
int check_open( string word ) {
  object money;
  word = lower_case( word );
  if (word [ 0 ] ==  110 ) {
    write( "Okay, not opening an account.\n" );
    return 1;
  }
  if ( word[ 0 ] !=  121 ) {
    write( "Do you want to open an account? Answer \"yes\" or \"no\".\n" );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  write( "You now have an account here.\n" );
  money = present( MONEY_ALIAS, this_player() );
  MONEY_HAND->pay_amount_from( account_cost, money, place );
  total_made += account_cost;
  do_save();
  this_player()->save();
  return 1;
}
int do_close() {
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, place ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
      total_made += total;
    }
    total_account -= total;
  } else
    write( "You close your account.\n" );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  set_account( -1 );
  do_save();
  this_player()->save();
  return 1;
}
mixed *stats() {
  return ::stats() + ({
    ({ "account cost", account_cost }),
    ({ "percentage", percentage }),
    ({ "total accounts", total_account }),
    ({ "total made", total_made }),
    ({ "bank name", bank_name }),
    ({ "place", place }),
    ({ "save file", save_file }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = (int)HANDLER->query_account( player_name, bank_name ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      HANDLER->adjust_account( player_name, bank_name, -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  total_account -= total;
  amount = total / 3;
  total_made += 2 * amount;
  do_save();
  mon_array = (mixed *)MONEY_HAND->create_money_array( amount / number, place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}

==================================================
FILE: shops/bank_franchise.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_franchise";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
string query_franchise() {
   return file_name(this_object());
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_franchise::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_franchise::init();
}

==================================================
FILE: shops/bank_master.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_master";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_master::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_master::init();
}

==================================================
FILE: shops/binding.c
==================================================

inherit "/std/room/basic_room";
#include <money.h>
#include <language.h>
private int _cost_per_book;
private int _cost_per_page;
void create() {
   _cost_per_book = 4000;
   _cost_per_page = 400;
}
void init() {
   add_command("bind", "<object:indirect:me'pages'> into book");
}
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
}
int do_bind(object *obs) {
   object *magic;
   object *paper;
   object *fail;
   object ob;
   object book;
   string place;
   int cost;
   foreach (ob in obs) {
      if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      }
   }
   if (sizeof(fail) || sizeof(magic)) {
      if (sizeof(magic)) {
         add_failed_mess("Cannot bind up $I with magic stuff into "
                         "a book.\n", magic);
      }
      if (sizeof(fail)) {
         add_failed_mess("$I are not pieces of paper and cannot be "
                         "bound into a book.\n", fail);
      }
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _cost_per_book + _cost_per_page * sizeof(paper);
   if (this_player()->query_value(place) > cost) {
      add_failed_mess("You do not have enough money, you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to bind $I into a book.\n", paper);
      return 0;
   }
   book = clone_object("/std/book");
   foreach (ob in paper) {
      book->add_page_after(ob, book->query_num_pages() + 1);
   }
   book->move(this_player());
   this_player()->pay_money( MONEY_HAND->create_money_array(cost, place),
                             place);
   return 1;
}

==================================================
FILE: shops/book_shop.c
==================================================

#include <shops/craft_shop.h>
inherit CRAFT_SHOP_INHERIT;
#define READ_PAGE_PROPERTY "browse page"
int browse_pages(object *obs);
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables);
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables);
void init() {
   string storeroom;
   ::init();
   storeroom = file_name(query_controller()->query_sell_list());
   add_command("browse", "page of <indirect:object:" + storeroom + ">",
               (: browse_pages($1) :) );
   set_extra_sell_check((: choose_which_page :));
}
int browse_pages(object *obs) {
   object *real_obs;
   object ob;
   int number;
   string mess;
   string read;
   object *no_pages;
   object *ok;
   int i;
   if (!check_open(this_player(), "browse")) {
      return 0;
   }
   real_obs = query_controller()->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse page$P$";
   no_pages = ({ });
   ok = ({ });
   for (i = 0; i < sizeof(obs); i++) {
      ob = real_obs[i];
      number = ob->query_property(READ_PAGE_PROPERTY);
      if (undefinedp(number)) {
         number = random(ob->query_num_pages() - 1) + 1;
         ob->add_property(READ_PAGE_PROPERTY, number);
         query_controller()->update_craft_object(obs[i], real_obs[i]);
      }
      if (number > ob->query_num_pages()) {
         no_pages += ({ ob });
      } else {
         ob->set_open_page(number);
         mess += ob->the_short() + ":\n" + ob->long();
         read = ob->query_readable_message();
         if (read) {
            mess += "You read " +
                    replace(ob->query_read_short(this_player()), "$name$",
                            ob->a_short()) + ":\n" +
                    ob->query_readable_message();
         }
         ok += ({ ob });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess(({ mess, "$N browses a page of $I.\n" }), ok);
      return 1;
   } else {
      add_failed_mess("There are not enough pages in $I to open to " +
                      " page " + number + ".\n", no_pages);
      return 0;
   }
}
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables) {
   write("Which page of " + query_multiple_short(sellables) +
         " would you like to let people browse (0 for the cover only)? ");
   input_to((: finish_choose :), 0, end_func, value, name, sellables);
}
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables) {
   int page;
   object *invalid;
   if (page_num == "quit" ||
       page_num == "q") {
      write("Aborting sale.\n");
      return ;
   }
   if (sscanf(page_num, "%d", page) != 1) {
      write("Need to actually enter a number.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   if (page < 0) {
      write("Need to specify a page number greator than zero.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   invalid = filter(sellables, (: $1->query_num_pages() < $(page) :) );
   if (sizeof(invalid)) {
      write("Page Number " + page + " is larger the number of pages in " +
            query_multiple_short(invalid) + ".\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   sellables->add_property(READ_PAGE_PROPERTY, page);
   sellables->set_open_page(0);
   evaluate(end_func, value, name, sellables);
}

==================================================
FILE: shops/bureau_de_change.c
==================================================

#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
int standard, buy_only;
string place;
mapping exchanges;
int do_buy(object *obs, string country);
int query_standard() { return standard; }
void set_standard( int number ) { standard = number; }
int query_buy_only() { return buy_only; }
void set_buy_only() { buy_only = 1; }
string query_place() { return place; }
void set_place( string word ) { place = word; }
mapping query_exchanges() { return exchanges; }
void set_exchanges( mapping map ) { exchanges = map; }
string exchanges_list() {
    int i, value, smallest;
    string list, *places;
    if ( !sizeof( exchanges ) )
         return "There are no exchanges to be made here.";
    list = "";
    places = keys( exchanges );
    for ( i = 0; i < sizeof( places ); i++ ) {
         list += places[ i ] +":\n      $I$+20,+10="+
                  (string)MONEY_HAND->money_value_string( standard, place ) +
                  " will buy: ";
         value = ( exchanges[ places[ i ] ][ 0 ] * standard ) / 100;
         smallest = MONEY_HAND->smallest_value_in( places[ i ] );
         if (value % smallest != 0)  value += smallest - (value % smallest);
         list += (string)MONEY_HAND->money_value_string( value, places[ i ] );
         if ( buy_only ) {
             list += ".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         } else {
             list += ";$I$-20,-10=\n$I$+20,+10=      for "+
                      (string)MONEY_HAND->money_value_string( standard,
                      place ) +", sell: ";
             value = ( 100 * standard ) / exchanges[ places[ i ] ][ 1 ];
             list += (string)MONEY_HAND->money_value_string( value,
                      places[ i ] ) +".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         }
    }
    return list;
}
void create() {
   do_setup++;
   ::create();
   do_setup--;
   standard = 100;
   place = "default";
   exchanges = ([ ]);
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   ::init();
   add_command("buy", "[from] <string'" + implode(keys(exchanges), "|") +
       "'> with <indirect:object:me>",  (: do_buy( $1, $4[0] ) :) );
   if ( !buy_only ){
      add_command("sell" ,"<indirect:object:me'stuff'>",
                        (:this_object()->sell($1):));
   }
   add_command("list", "", (:this_object()->list():));
}
int do_buy(object *things, string country) {
   int     value;
   int     smallest;
   object  thing;
   object  money;
   mixed  *change;
   mixed  *monies;
   mixed  *no_value;
   string  word;
   change = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money"))  {
         change = MONEY_HAND->merge_money_arrays(change,
                                                 thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   if (sizeof(change) == 0) {
      return notify_fail("You can only use money to buy currency here.  "
                         "Sorry.\n");
   }
   if (undefinedp(exchanges[country])) {
      foreach (word in keys(exchanges)) {
         if (lower_case(country) == lower_case(word)) {
            country = word;
            break;
         }
      }
      if (country != word) {
         add_failed_mess("You cannot exchange that currency here.  Only " +
              query_multiple_short(keys(exchanges)) + " currency can be "
              "purchased at this shop.\n");
         this_player()->adjust_money(change);
         return 0;
      }
   }
   if (country == place) {
      this_player()->adjust_money(change);
      return notify_fail("You cannot buy currency from " + country +
            " here, since you're currently in " + country + ".\n");
   }
   monies = MONEY_HAND->filter_legal_money_to_array(change, place);
   no_value = monies[1];
   if (sizeof(monies[0]) != 0  &&  place != "default")  {
      monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
      if (sizeof(monies[0]) != 0)
         no_value = MONEY_HAND->merge_money_arrays(no_value, monies[0]);
      monies[0] = monies[1];
   }
   if (sizeof(no_value) != 0)  {
      this_player()->adjust_money(no_value);
      write("Sorry, but you cannot use " +
            MONEY_HAND->money_string(no_value) + " to buy currency here.\n");
   }
   if (sizeof(monies[0]) == 0) {
      return notify_fail("Sorry, but you didn't offer any acceptable money "
                         "to buy currency.\n");
   }
   value = (MONEY_HAND->query_total_value(monies[0], place) *
           exchanges[country][0]) / 100;
   smallest = MONEY_HAND->smallest_value_in(country);
   if (value % smallest != 0)  value += smallest - (value % smallest);
   change = MONEY_HAND->create_money_array(value, country);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(monies[0]);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(monies[0]) + " is not worth anything "
            "in " + country + ".\n");
   }
   write("OK, you bought "+ MONEY_HAND->money_string(change) + " with " +
         MONEY_HAND->money_string(monies[0]) + ".\n");
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }
   say(this_player()->one_short() + " exchanges some currency.\n");
   return 1;
}
int sell(object *things) {
   int value;
   int test_val;
   int first;
   string *places;
   string  a_place;
   object thing;
   object money;
   mixed *monies;
   mixed *change;
   mixed *m_array_a;
   mixed *m_array_b;
   mixed *m_array_c;
   m_array_a = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money")) {
         m_array_a = MONEY_HAND->merge_money_arrays(m_array_a,
                         thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   if (sizeof(m_array_a) == 0) {
      return notify_fail("You can only sell currency here.  Sorry.\n");
   }
   places = m_indices(exchanges);
   m_array_b = ({ });
   m_array_c = ({ });
   first = 1;
   foreach (a_place in places)  {
      monies = MONEY_HAND->filter_legal_money_to_array(m_array_a, a_place);
      m_array_a = monies[1];
      if (sizeof(monies[0]) != 0)  {
         if (first  &&  a_place != "default")   {
            monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
            if (sizeof(monies[0]) != 0)
               m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
            monies[0] = monies[1];
            first = 0;
         }
         test_val = MONEY_HAND->query_total_value(monies[0], a_place) *
                    exchanges[a_place][1] / 100;
         if (test_val)   {
            value += test_val;
            m_array_b = MONEY_HAND->merge_money_arrays(m_array_b, monies[0]);
         }
         else
            m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
      }
      if (sizeof(m_array_a) == 0)
         break;
   }
   if (sizeof(m_array_c) != 0)
      m_array_a = MONEY_HAND->merge_money_arrays(m_array_a, m_array_c);
   if (sizeof(m_array_a) != 0) {
      write("Sorry, but you cannot sell " +
            MONEY_HAND->money_string(m_array_a) + " here.\n");
      this_player()->adjust_money(m_array_a);
   }
   if (sizeof(m_array_b) == 0) {
      return notify_fail( "Sorry, but you aren't offering to sell any "
            "acceptable coinage.\n");
   }
   change = MONEY_HAND->create_money_array(value, place);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(m_array_b);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(m_array_b) + " is not "
            "worth anything in " + place + ".\n");
   }
   write("OK, you sold " + MONEY_HAND->money_string(m_array_b) + " for " +
         MONEY_HAND->money_string(change) + ".\n");
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }
   say(this_player()->one_short() + " exchanges some currency.\n");
   return 1;
}
int list() {
   write( exchanges_list() +"\n" );
   return 1;
}

==================================================
FILE: shops/commercial.c
==================================================

inherit "/std/shops/inherit/commercial";

==================================================
FILE: shops/craft_shop.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop";
void create() {
   add_help_file("craft_shop");
   basic_room::create();
   craft_shop::create();
}
void init() {
   basic_room::init();
   craft_shop::init();
}
void dest_me() {
   craft_shop::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/craft_shop_category.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop_category";
void create() {
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   basic_room::create();
   craft_shop_category::create();
}
void init() {
   basic_room::init();
   craft_shop_category::init();
}
void dest_me() {
   craft_shop_category::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/engrave_inherit.c
==================================================

#include <money.h>
#include <shops/engrave.h>
void set_engrave_language(string str);
protected int do_engrave( object *things, string message);
mixed query_property(string name);
private string _lingo = "general";
void create() {
   this_object()->add_help_file("engrave");
}
void engrave_init() {
   add_command( "engrave", "<string> on <indirect:object>",
                (: do_engrave($1, $4[0]) :));
}
protected int engrave_living(object *obs) {
   return 0;
}
protected int engrave_wrong_items(object *obs) {
   return 0;
}
protected int engrave_no_money(object *obs, int cost) {
   return 0;
}
int engrave_objects(object *obs, int cost) {
   return 0;
}
protected int do_engrave( object *things, string message) {
   int cost;
   string coststring;
   string place;
   object *liv;
   object *engravable;
   liv = filter(things, (: living($1) :));
   if (sizeof(liv) && !engrave_living(liv)) {
      add_failed_mess("Cannot engrave messages on $I, they are living things.\n", liv);
   }
   things -= liv;
   if (!sizeof(things)) {
      return 0;
   }
   engravable = filter(things,
                       (: ($1->query_property( "shop type" ) == "jewellers" ||
                         $1->query_property( ENGRAVE_PROP ) == 1 ||
                           $1->query_property( "shop type" ) == "armoury") &&
                          $1->query_short() != "holy blade of Soyin" :) );
   if (!sizeof(engravable)) {
      if (!engrave_wrong_items(things - engravable)) {
         add_failed_mess("Cannot engrave messages on $I.\n",
                         things - engravable);
      }
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   coststring = replace_string(message, " ", "");
   cost = (strlen(coststring) * 80) * sizeof(engravable);
   if ( (int) this_player()->query_value_in( place ) < cost ) {
      if (!engrave_no_money(engravable, cost)) {
         add_failed_mess("Not enough money to engrave $I, you need " +
                         MONEY_HAND->money_value_string(cost, place) + ".\n",
                         engravable);
      }
      return 0;
   }
   if ( engrave_objects( engravable, cost ) ) {
      this_player()->pay_money( ( mixed *)MONEY_HAND->create_money_array( cost,
                                place ), place );
      add_succeeded_mess( ({ "You have the message \"" + message +
                            "\" engraved into $I for " +
                            MONEY_HAND->money_value_string(cost, place)
                            + ".\n", "$N gets $I engraved with a message.\n" }),
                            engravable);
      engravable->add_read_mess( message,
                 "neatly engraved letters", _lingo, 1);
      return 1;
   }
   else return 0;
}
void init() {
  engrave_init();
}
void set_engrave_language(string lang) {
  _lingo = lang;
}

==================================================
FILE: shops/general_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shop.h>
#include <tasks.h>
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/open_shop";
private mixed our_storeroom;
private mixed buy_mess;
private mixed sell_mess;
private mixed list_mess;
private mixed value_mess;
private mixed too_costly_mess;
private mixed not_worthy_mess;
private mixed browse_mess;
private mixed *other_shops;
private int amount_sold;
private int amount_bought;
private int strict_shop;
private int no_steal;
private int sell_stolen;
private int steal_difficulty;
private int min_amount;
private int max_inventory;
private int sell_large;
private mixed shop_type;
private mixed buy_func;
private mixed sell_func;
private mixed value_func;
private mixed too_costly_func;
private mixed cannot_sell_func;
private mixed browse_func;
private mixed list_func;
private nosave string shoplift_handler;
private string original_storeroom;
private int _strict_currency;
private nosave mapping elist = (["north" : "south", "south" : "north",
  "east" : "west", "west" : "east", "up" : "down", "down" : "up"]);
string shop_list(mixed arr, int detail);
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which);
string find_free_exit();
int do_buy(object *ob);
int do_list_these(object *obs);
void do_buy_things( object *obs, int cost, object pl );
void do_parse(mixed arr, mixed ob, object client, string money,
  string extra);
object create_mercenary(object rep);
void event_shoplift(object command_ob, object thief, object victim);
object query_store_room();
int creator_object (object);
void create() {
    buy_mess = ({
      "You buy $ob$ for $money$.\n",
      "$client$ buys $ob$.\n"});
    sell_mess = ({
      "You sell $ob$ for $money$.\n",
      "$client$ sells $ob$.\n"});
    list_mess = "$extra$";
    value_mess = "$ob$ is valued at $money$.\n";
    too_costly_mess = "$ob$ is worth too much to be sold here.\n";
    not_worthy_mess = "$ob$ is not worth enough to be sold here.\n";
    browse_mess = "$ob$ costs $money$, it looks like:\n$extra$";
    other_shops = ({ });
    max_inventory = MAX_INVENTORY;
    min_amount = 50;
    add_help_file("shop");
    _strict_currency = 1;
    ::create();
}
void reset() {
    if(!random(3)) {
        remove_property("inventory_loss");
    }
    call_out("send_out_reps", 2);
}
void set_buy_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        buy_func = func;
    }
}
void set_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        sell_func = func;
    }
}
void set_value_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        value_func = func;
    }
}
void set_too_costly_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        too_costly_func = func;
    }
}
void set_cannot_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        cannot_sell_func = func;
    }
}
void set_browse_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        browse_func = func;
    }
}
void set_list_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        list_func = func;
    }
}
void set_sell_message(mixed str) {
    sell_mess = str;
}
void set_buy_message(mixed str) {
    buy_mess = str;
}
void set_value_message(mixed str) {
    value_mess = str;
}
void set_too_costly_message(mixed str) {
    too_costly_mess = str;
}
void set_not_worthy_message(mixed str) {
    not_worthy_mess = str;
}
void set_browse_message(mixed str) {
    browse_mess = str;
}
void set_list_message(mixed str) {
    list_mess = str;
}
void set_open_condition(mixed str) {
   if (functionp(str)) {
      ::set_open_function(str);
   } else if (intp(str)) {
      ::set_open_function( (: $(str) :) );
   } else if (pointerp(str)) {
      ::set_open_function( (: call_other($(str[0]), $(str[1]), $1) :) );
   } if ( stringp(str) ) {
      ::set_open_function( (: call_other( this_object(), $(str), $1 ) :) );
   }
}
void set_no_steal(int i) {
    no_steal = i;
}
void set_steal_difficulty(int i) {
    steal_difficulty = i;
}
void set_sell_stolen(int i) {
    sell_stolen = i;
    no_steal = 1;
}
void set_sell_large(int i) { sell_large = i; }
mixed query_sell_mess() {
    return sell_mess;
}
mixed query_list_mess() {
    return list_mess;
}
mixed query_value_mess() {
    return value_mess;
}
mixed query_too_costly_mess() {
    return too_costly_mess;
}
mixed query_not_worthy_mess() {
    return not_worthy_mess;
}
mixed query_buy_mess() {
    return buy_mess;
}
mixed query_browse_mess() {
    return browse_mess;
}
int query_no_steal() {
    return no_steal;
}
int query_steal_difficulty(int i) {
    return steal_difficulty;
}
string query_shoplift_response_handler() {
    return shoplift_handler;
}
int query_shop() {
    return 1;
}
object *query_shop_lift_items(string str, object player) {
    return match_objects_for_existence(str, ({ query_store_room() }));
}
object shoplift_success(object ob) {
    return ob;
}
void set_shoplift_response_handler(string word) {
    shoplift_handler = word;
}
void set_min_amount(int i) { min_amount = i; }
void set_max_inventory(int i) { max_inventory = i; }
void init() {
    string room;
    ::init();
    if(stringp(our_storeroom)) {
        room = our_storeroom;
    } else if(our_storeroom) {
        room = file_name(our_storeroom);
    } else {
      tell_room(this_object(),
                "Oh dear, we don't seem to have a storeroom.\n");
    }
    add_command("sell", "<indirect:object:me>");
    add_command("buy", "<indirect:object:"+room+">");
    add_command("list", "[all]");
    add_command("list", "<indirect:object:"+room+">",
      (: do_list_these($1) :));
    add_command("browse", "<indirect:object:"+room+">");
    add_command("value", "<indirect:object:me>");
}
int query_max_amount() {
    return MAX_AMOUNT;
}
int query_min_amount() {
    return min_amount;
}
varargs int query_value(object thing, int sell) {
     if ( thing->query_property("cost here") && !sell ) {
         return (int)thing->query_property("cost here");
     }
     else {
        return (int)thing->query_value_at( this_object() );
     }
}
int scaled_value(int n) {
    int i, tot, *fish;
    fish = PAY_RATES;
    if(n < fish[0]) {
        return n;
    } else {
        tot = fish[0];
        n -= fish[0];
    }
    i = 0;
    while(n && ((i + 1) < sizeof(fish))) {
        if(n >= fish[i]) {
            tot += fish[i + 1] * fish[i] / 100;
            n -= fish[i];
        } else {
            tot += fish[i + 1] * n / 100;
            n = 0;
        }
        i += 2;
    }
    if(n) {
        tot += (n * fish[sizeof(fish) - 1]) / 100;
    }
    return tot;
}
int do_sell(object *in_obs) {
    int i, amt, total_amt;
    string place, filename, *text = ({ });
    object money, *obs, *selling, *cannot, *stolen, storeob, one_item, *cre;
    object thing;
    mixed *m_array;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    in_obs = uniq_array( in_obs );
    obs = filter_array(in_obs, (: !$1->query_keep() :));
    cre = filter (obs, (: creator_object ($1) :));
    if (sizeof (cre) && strsrch (file_name (this_object()),
      "_dev") == -1) {
      if (!this_player()->query_creator()) {
        tell_object (this_player(), "Oh dear, you shouldn't have " +
          query_multiple_short (cre) + "!  They disappear with a flash "
          "of octarine light.\n");
        cre->move ("/room/rubbish");
      }
      else {
        tell_object (this_player(), "Oh dear, you shouldn't be trying to sell " +
          query_multiple_short (cre) + "!\n");
      }
      foreach (thing in cre) {
        if ( thing->query_property( "virtual name" ) ) {
          filename = thing->query_property( "virtual name" );
        } else {
          filename = base_name (thing);
        }
        text += ({filename});
      }
      log_file ("ILLEGAL_OBJECT", sprintf ("%s: %s tried to sell %s at "
        "%s.\n\n", ctime (time()), this_player()->query_name(),
        query_multiple_short (text), file_name (this_object())));
      obs -= cre;
   }
    if(!sizeof(obs)) {
        this_player()->add_failed_mess(this_object(),
          "You previously decided to keep $I.\n", in_obs);
        return 0;
    }
    in_obs = this_player()->query_holding() + this_player()->query_armours();
    cannot = filter(obs, (: member_array($1, $2) != -1 :), in_obs);
    if (sizeof(cannot)) {
        obs -= cannot;
        tell_object(this_player(), "You decide not to sell " +
          query_multiple_short(cannot, "the") + ", because "
          "you are wearing or holding $V$0=it,them$V$.\n");
    }
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) > max_inventory) {
        this_player()->add_failed_mess(this_object(),
          "Sorry, the shop is full up and isn't buying items!\n", ({ }));
        call_out("tidy_inventory", random(20));
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS - 1];
    }
    selling = cannot = stolen = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(!sell_stolen && obs[i]->query_property("stolen")) {
            stolen += ({obs[i]});
            continue;
        } else {
            obs[i]->remove_property("stolen");
        }
        if((this_object()->query_value(obs[i], 1) > 0) &&
          !obs[i]->do_not_sell() &&
          !this_object()->do_not_buy(obs[i]) && (!strict_shop ||
            shop_type == obs[i]->query_property("shop type")) &&
          environment(obs[i]) == this_player()) {
            if(obs[i]->move(our_storeroom)) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                continue;
            }
            amt = (int)this_object()->query_value(obs[i], 1);
            if(!(obs[i]->query_property("sale_value"))) {
                amt = scaled_value( amt );
            }
            if((amt <= (int)this_object()->query_max_amount()) &&
              (amt >= (int)this_object()->query_min_amount())) {
                if(shop_type != obs[i]->query_property("shop type")) {
                    amt = (amt * 90) / 100;
                }
                total_amt += amt;
                selling += ({obs[i]});
                obs[i]->being_sold();
            } else {
                if(obs[i]->short())
                    cannot += ({obs[i]});
                obs[i]->move(this_player());
            }
        } else {
            if(obs[i]->short()) {
                cannot += ({obs[i]});
            }
        }
    }
    if (!sizeof(selling)) {
        if (sizeof(cannot)) {
            if (stringp(cannot_sell_func)) {
                call_other(this_object(), cannot_sell_func, this_player(), cannot);
            } else if (functionp(cannot_sell_func)) {
                evaluate(cannot_sell_func, this_player(), cannot);
            }
            this_player()->add_failed_mess(this_object(),
              "You cannot sell $I.\n", cannot);
        } else if(sizeof(stolen)) {
            if(sizeof(stolen) > 1) {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because they're stolen!\n", stolen);
            } else {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because it's stolen!\n", stolen);
            }
            foreach(one_item in obs) {
                if(one_item->query_property("stolen") == this_player()->query_name()) {
                    event_shoplift(this_object(), this_player(), this_object());
                    break;
                }
            }
        } else {
            this_player()->add_failed_mess(this_object(),
              "You have nothing to sell.\n", ({ }));
        }
        return 0;
    }
    if(this_object()->cannot_afford(total_amt)) {
        selling->move(this_player());
        this_player()->add_failed_mess(this_object(),
          "The shop cannot afford to buy $I from you.\n", selling);
        return 0;
    }
    amount_sold += total_amt;
    m_array = (mixed *)MONEY_HAND->create_money_array(total_amt, place);
    money = clone_object(MONEY_OBJECT);
    money->set_money_array(m_array);
    if(sizeof(cannot)) {
        if(stringp(cannot_sell_func)) {
            call_other(this_object(), cannot_sell_func, this_player(), cannot);
        } else if (functionp(cannot_sell_func)) {
            evaluate(cannot_sell_func, this_player(), cannot);
        }
        write("You cannot sell "+query_multiple_short(cannot)+".\n");
        cannot->move(this_player());
    }
    if(stringp(sell_func)) {
        call_other(this_object(), sell_func, this_player(), obs);
    } else if (functionp(sell_func)) {
        evaluate(sell_func, this_player(), obs);
    }
    do_parse(sell_mess, selling, this_player(),
      (string)MONEY_HAND->money_string(m_array), "");
    if((int)money->move(this_player()) != MOVE_OK) {
        tell_object(this_player(),
          "You're too heavily burdened to accept all that money, "
          "so the shopkeeper puts it on the floor.\n");
        money->move(this_object());
    }
    this_object()->made_transaction(-total_amt, selling);
    return 1;
}
int creator_object( object ob ) {
    string path;
    if ( file_name( ob )[0..2] == "/w/" ) {
        return 1;
    }
    if ( ( path = ob->query_property( "virtual name" ) ) &&
      path[0..2] == "/w/" ) {
        return 1;
    }
    return 0;
}
int do_buy(object *obs) {
    int i, amt, ob_amt, total_cost;
    string place;
    object money, *to_buy, *cannot, *too_much;
    object *creator_obs;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS-1];
    }
    creator_obs = filter( obs, (: creator_object( $1 ) :) );
    if ( sizeof( creator_obs ) && file_name()[0..2] != "/w/" ) {
        tell_object( this_player(), "You cannot buy " +
          query_multiple_short( creator_obs, "the" ) +
          " because they shouldn't be in the game!\n" );
        obs -= creator_obs;
    }
    to_buy = too_much = cannot = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, this_player());
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You have no money.\n", obs);
        return 0;
    }
    amt = money->query_value_in(place);
    if(place != "default" && !_strict_currency ) {
        amt += money->query_value_in("default");
    }
    while(i < sizeof(obs)) {
        ob_amt = this_object()->query_value(obs[i], 0);
        if(ob_amt > amt) {
            if(obs[i]->short()) {
                too_much += ({obs[i]});
            }
            obs = delete(obs, i, 1);
            continue;
        }
        if(obs[i]->move(this_player())) {
            if(!sell_large) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                i++;
                continue;
            } else {
                obs[i]->move(this_object());
            }
        }
        amt -= ob_amt;
        total_cost += ob_amt;
        to_buy += ({obs[i]});
        i++;
    }
    amount_bought += total_cost;
    if(sizeof(cannot)) {
        this_player()->add_failed_mess(this_object(),
          "You cannot pick up $I.\n", cannot);
    }
    if(sizeof(too_much)) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), cannot);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), cannot);
        }
        this_player()->add_failed_mess(this_object(),
          "$I costs too much.\n", too_much);
    }
    if(!sizeof(to_buy)) {
        return 0;
    }
    do_buy_things(to_buy, total_cost, this_player());
    return 1;
}
void do_buy_things(object *obs, int cost, object pl) {
    int i, j;
    string place;
    object money, change;
    mixed m_array, p_array;
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, pl);
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_object(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You don't have any money.\n", obs);
        return 0;
    }
    change = clone_object(MONEY_OBJECT);
    m_array = (int)MONEY_HAND->create_money_array(cost, place);
    for(i = 0; i < sizeof(m_array); i += 2) {
        p_array = (mixed *)MONEY_HAND->make_payment(m_array[i],
          m_array[i + 1], money, place);
        if(!pointerp(p_array)) {
            continue;
        }
        for(j = 0; j < sizeof(p_array[0]); j += 2) {
            money->adjust_money(-p_array[0][j + 1], p_array[0][j]);
        }
        change->adjust_money(p_array[1]);
    }
    do_parse(buy_mess, obs, pl,
      (string)MONEY_HAND->money_string(m_array), "");
    if(stringp(buy_func)) {
        call_other(this_object(), buy_func, pl, obs);
    } else if (functionp(buy_func)) {
        evaluate(buy_func, pl, obs);
    }
    if((int)change->move(pl) != MOVE_OK) {
        tell_object(pl, "You are too heavily burdened to accept "
          "your change, so the shopkeeper puts it on the floor.\n");
        change->move(this_object());
    }
    this_object()->made_transaction(cost, obs);
}
int do_list() {
    object ob;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(objectp(our_storeroom)) {
        ob = our_storeroom;
    } else {
        if ( original_storeroom ) {
            our_storeroom = load_object( original_storeroom );
            ob = our_storeroom;
        }
        else {
            add_failed_mess( "Please notify a creator: the storeroom for "
                "this shop cannot load or has gone missing.\n" );
            return 0;
        }
    }
    if(stringp(list_func)) {
        call_other(this_object(), list_func, this_player());
    } else if (functionp(list_func)) {
        evaluate(list_func, this_player());
    }
    do_parse(list_mess, ({ this_object() }), this_player(), "",
      shop_list(all_inventory(ob), 0));
    return 1;
}
int do_list_these(object *obs) {
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    do_parse(list_mess, ({this_object()}),
      this_player(), "", shop_list(obs, 1));
    return 1;
}
int do_browse(object *obs) {
    int i, value;
    string place;
    if (!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    if(stringp(browse_func)) {
        call_other(this_object(), browse_func, this_player(), obs);
    } else if (functionp(browse_func)) {
        evaluate(browse_func, this_player(), obs);
    }
    for(i = 0; i < sizeof(obs); i++) {
        value = (int)this_object()->query_value(obs[i], 0);
        do_parse(browse_mess, obs[i..i], this_player(),
          (string)MONEY_HAND->money_value_string(value, place),
          (string)obs[i]->long());
    }
    return 1;
}
int do_value(object *obs) {
    int i;
    int val;
    int total;
    string place;
    int obnum;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->do_not_sell() || this_object()->do_not_buy(obs[i]) ||
          (environment(obs[i] ) != this_player()) ||
          (strict_shop &&
            (shop_type != (string)obs[i]->query_property("shop type")))) {
            val = 0;
        } else {
            val = (int)this_object()->query_value(obs[i], 1);
            if (shop_type != (string)obs[i]->query_property("shop type")) {
                val = (val * 90) / 100;
            }
        }
        val = scaled_value(val);
        total += val;
        if(val > (int)this_object()->query_max_amount()) {
            do_parse(too_costly_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else if(val < (int)this_object()->query_min_amount()) {
            do_parse(not_worthy_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else {
            do_parse(value_mess, obs[i..i], this_player(),
              (string)MONEY_HAND->money_value_string(val, place),
              (string)obs[i]->do_not_sell());
            if(stringp(value_func)) {
                call_other(this_object(), value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            } else if (functionp(value_func)) {
                evaluate(value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            }
        obnum++;
        }
    }
    if (obnum > 1) {
        write("This gives you a total value of " +
          MONEY_HAND->money_value_string(total, place) +
          ".\n");
        return 1;
    }
    this_player()->add_failed_mess( this_object(), "None of your items are "
        "suitable for sale here!\n", obs );
    return obnum;
}
string shop_list(mixed arr, int detail) {
    int i, j, value, num;
    string s, mon, place, *shorts, *vals;
    object *list;
    mapping inv, costs;
    mixed ind;
    if(pointerp(arr)) {
        list = arr;
    } else {
        list = all_inventory(this_object());
    }
    inv = ([ ]);
    for(i = 0; i < sizeof(list); i++) {
        s = (string)list[i]->short();
        if(!s || !this_object()->query_value(list[i], 1)) {
            continue;
        }
        if(!stringp(s)) {
            s = "get a creator for this one!";
        }
        if(inv[s]) {
            inv[s] += ({list[i]});
        } else {
            inv[s] = ({list[i]});
        }
    }
    s = "";
    shorts = m_indices(inv);
    if(!sizeof(shorts)) {
        if(detail) {
            return "The shop is all out of what you wanted.\n";
        } else {
            return "The shop is totally out of stock.\n";
        }
    }
    s = "You find on offer:\n";
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(shorts); i++) {
        ind = inv[shorts[i]];
	num = sizeof(ind);
	if(num == 1 && ind[0]->query_collective())
	  num = ind[0]->query_amount();
        switch(num) {
        case 1:
            s += "Our very last " + shorts[i];
            break;
        case 2..5 :
            s += capitalize(query_num(num, 0)+" "+
			    (string)ind[0]->query_plural());
            break;
        default:
            if(detail) {
                s += capitalize(query_num(num, 0) + " " +
                  (string)ind[0]->query_plural());
            } else {
                s += "A large selection of "+
                (string)ind[0]->query_plural();
            }
        }
        if(detail) {
            costs = ([ ]);
            for(j = 0; j < sizeof(ind); j++) {
                value = (int)this_object()->query_value(ind[j], 0);
                mon = (string)MONEY_HAND->money_value_string(value, place);
                if(!costs[mon]) {
                    costs[mon] = ({""+(j + 1)});
                } else {
                    costs[mon] += ({""+(j + 1)});
                }
            }
            if(m_sizeof(costs) == 1) {
                s += " for "+m_indices(costs)[0];
                if(sizeof(m_values(costs)[0]) > 1) {
                    s += " each.\n";
                } else {
                    s += ".\n";
                }
            } else {
                s += ":-\n";
                vals = m_indices(costs);
                for(j = 0; j < sizeof(vals); j++) {
                    s += "  [#"+implode(costs[vals[j]], ",")+"] for "
                    +vals[j]+".\n";
                }
            }
        } else {
            s += ".\n";
        }
    }
    return s;
}
void set_store_room(mixed ob) {
    if(stringp(ob)) {
        original_storeroom = ob;
        our_storeroom = find_object(ob);
        if(!our_storeroom) {
            our_storeroom = load_object(ob);
        }
    }
    else our_storeroom = ob;
}
void guards(object tp) {
    object ob;
    if(environment(tp) != this_object() && environment(tp) != our_storeroom) {
        return;
    }
    while(!random(6)) {
        ob = create_mercenary(0);
        ob->move(environment(tp));
        ob->attack_ob(tp);
    }
}
object query_store_room() {
    return our_storeroom;
}
void do_parse(mixed arr, object *ob, object client,
  string money, string extra) {
    if(stringp(arr)) {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr,
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(), "", ob);
    } else if (functionp(arr)) {
        evaluate(arr, ob, client, money, extra);
    } else {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr[0],
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(),
          ({"", replace(arr[1], ({"$ob$", "$I", "$client$",
                "$N", "$money$", money, "$extra$", extra}))}), ob);
    }
}
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which) {
    if(sizeof(ob)) {
        str = replace(str, "$ob$", query_multiple_short(ob, which));
    } else {
        str = replace(str, "$ob$", call_other(ob, which +"_short"));
    }
    if(client) {
        str = replace(str, "$client$", client->the_short());
    }
    str = replace(str, ({"$money$", money, "$extra$", extra}));
    return str;
}
void add_other_shop(mixed shop) {
    other_shops += ({shop});
}
string query_shop_type() {
    return shop_type;
}
void set_shop_type(string ty) {
    shop_type = ty;
}
void set_strict_shop(int i) {
    strict_shop = i;
}
int query_strict_shop() {
    return strict_shop;
}
object create_rep() {
    object ob;
    ob = clone_object("/obj/monster");
    ob->set_name("rep");
    ob->set_short("sales rep");
    ob->add_adjective("sales");
    ob->set_long("This is tall strong looking sales rep.  He "
      "stares at you with bright piercing eyes.\n");
    ob->add_alias("Sales rep alias");
    ob->set_guild("fighter");
    ob->set_race("human");
    ob->adjust_bon_str(15);
    ob->set_level(60);
    ARMOURY->request_weapon("dagger", 100)->move(ob);
    ARMOURY->request_armour("cloth robe", 100)->move(ob);
    ob->init_equip();
    ob->add_property("rep type", shop_type);
    all_inventory(ob)->add_property("mine", 1);
    return ob;
}
void send_out_reps() {
    int i;
    object ob;
    for(i = 0; i < sizeof(other_shops); i++) {
        ob = (object)this_object()->create_rep();
        ob->add_property("goto destination", other_shops[i]);
        ob->add_property("goto property", "shop");
        ob->move(this_object(),
          "$N stride$s determinedly into the room.");
        ob->add_triggered_action("froggy", "goto_destination",
          file_name(this_object()), "rep_made_it");
    }
}
void rep_made_it(int bing) {
    object *obs, rep;
    int i, cost;
    if(!bing) {
        previous_object()->init_command("'Oh no!  I am utterly lost!");
        previous_object()->init_command("sigh");
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = (previous_object()->query_current_room())->query_stock(shop_type);
    if(!obs) {
        obs = ({ });
    }
    if(!sizeof(obs)) {
        this_object()->none_to_sell();
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]) {
            cost += (int)this_object()->query_value( obs[ i ], 1 ) * 2 / 3;
        }
    }
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    cost += (int)this_object()->query_value(obs[i], 1) * 2 / 3;
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    previous_object()->adjust_value(cost);
}
object create_mercenary(object rep) {
    object ob;
    string nam;
    if(rep) {
        nam = implode(rep->query_adjectives(), " ")+" "+rep->query_name();
    }
    ob = clone_object("/obj/monster");
    ob->set_name("mercenary");
    ob->add_alias("troll");
    ob->add_adjective("troll");
    ob->set_short("troll mercenary");
    ob->set_main_plural("troll mercenaries");
    ob->set_race("troll");
    ob->set_class("fighter");
    ob->set_level(200 + random(200));
    ob->set_long("This is a large, hulking troll.  He looks "
      "quite competent and capable of mashing you with or "
      "without a weapon.\n");
    if(rep) {
        ob->move(environment(rep));
        ob->do_command("follow "+nam);
        ob->do_command("protect "+nam);
        ob->add_property("merchant", rep);
    } else {
        ARMOURY->request_weapon("spiked club", 100)->move(ob);
    }
    ob->set_natural(1);
    ob->init_equip();
    ob->set_join_fights("Troll yells something incomprehensible.\n");
    ob->set_join_fight_type(0);
    return ob;
}
object *query_stock(string type) {
    mapping blue;
    blue = (mapping)our_storeroom->query_shop_type_mapping();
    if(!blue[type]) {
        return ({ });
    }
    return blue[type];
}
void do_rep_buy(mixed *bing) {
    object rep, *obs;
    int cost;
    rep = bing[0];
    obs = bing[1];
    cost = bing[2];
    rep->adjust_money(cost, "brass");
    rep->query_current_room()->do_buy(obs, cost, rep);
    obs->move(present("Sales rep alias", rep->query_current_room()));
    call_out("set_up_return", 5, rep);
}
void set_up_return(object rep) {
    rep->add_property("goto destination", file_name(this_object()));
    rep->add_triggered_action("froggy", "goto_destination",
      this_object(), "rep_came_back");
}
void rep_came_back() {
    int i;
    object *obs, *obs2, rep;
    obs = previous_object()->find_inv_match("all", previous_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->query_property("mine")) {
            continue;
        }
        if(obs[i]->query_property("money")) {
            continue;
        }
        obs[i]->move(our_storeroom);
        obs2 += ({obs[i]});
    }
    if(sizeof(obs2)) {
        tell_room(this_object(), previous_object()->short()+" puts "+
          query_multiple_short(obs2)+" into the stock.\n");
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = all_inventory(this_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if((object)obs[i]->query_property("merchant") == rep) {
            obs2 += ({ obs[i] });
        }
    }
    if(sizeof(obs2)) {
        tell_room(this_object(),
          query_multiple_short(obs2+({previous_object()}), "one")+" go away.\n");
    } else {
        tell_room(this_object(), previous_object()->short()+" goes away.\n");
    }
    obs2->dest_me();
    previous_object()->dest_me();
}
void summon_guards(object tp) {
    object ob;
    int i;
    if(environment(tp) != this_object()) {
        return;
    }
    ob = environment(tp)->create_mercenary(0);
    if(!ob) {
        return;
    }
    ob->move(this_object(),
      "$N charge$s in to protect the shop!");
    ob->attack_ob(tp);
    for(i = 0; i < random(5); i++) {
        ob = create_mercenary(0);
        ob->move(this_object(),
          "$N charge$s in to protect the shop!");
        ob->attack_ob(tp);
    }
}
void set_strict_currency( int new_strict ) {
    _strict_currency = new_strict;
}
int query_strict_currency() {
    return _strict_currency;
}
void event_shoplift(object command_ob, object thief, object victim) {
    if(stringp(shoplift_handler)) {
        if(shoplift_handler != "none") {
            shoplift_handler->handle_shoplift(thief, victim);
        }
    } else if (functionp(shoplift_handler)) {
        evaluate(shoplift_handler, thief, victim);
    } else {
        "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
    }
}
void tidy_inventory() {
    object storeob;
    object *inventory;
    int i, inv_to_leave;
    int count;
    inv_to_leave = max_inventory - (max_inventory / 4);
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) < inv_to_leave)
        return;
    inventory = all_inventory(storeob);
    while(sizeof(inventory) > inv_to_leave) {
        i = random(sizeof(inventory));
        if(inventory[i])
            inventory[i]->dest_me();
        if(count++ > 500)
            break;
        inventory = all_inventory(storeob);
    }
}
void dest_me() {
    if(our_storeroom)
        our_storeroom->dest_me();
    ::dest_me();
}
mixed *stats() {
    return ::stats()+({
      ({"total sold", amount_sold}),
      ({"total bought", amount_bought}),
      ({"shop type", shop_type}),
      ({"shoplift handler", shoplift_handler }),
      ({"strict shop", strict_shop})});
}

==================================================
FILE: shops/general_shop_close.c
==================================================

inherit "/std/shops/general_shop";
inherit "/std/shops/inherit/store_close";
void womble() {
}

==================================================
FILE: shops/item_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/item_shop";
void create() {
  do_setup++;
  basic_room::create();
  item_shop::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
   basic_room::init();
   item_shop::init();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
    basic_room::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen );
}
void dest_me() {
   item_shop::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/item_shop_close.c
==================================================

inherit "/std/shops/item_shop";
inherit "/std/shops/inherit/store_close";
void womble() {
}

==================================================
FILE: shops/item_shop_outside.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/std/room/outside";
inherit "/std/shops/inherit/item_shop";
void create() {
   item_shop::create();
   outside::create();
}
void init() {
   outside::init();
   item_shop::init();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
    outside::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen );
}
void dest_me() {
   item_shop::dest_me();
   outside::dest_me();
}

==================================================
FILE: shops/laundry_entry_inherit.c
==================================================

#include <money.h>
#include <vault.h>
inherit "/std/room";
#define TIME_LIMIT 500
#define LO laundryowner->the_short()
string location, laundry_room;
int visit_cost;
object laundryowner;
void set_location(string str) { location = str; }
void set_visit_cost(int i) { visit_cost = i; }
void set_laundryowner(object ob) { laundryowner = ob; }
void set_laundry_exit(string direc, mixed dest, string type) {
  laundry_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  if(!laundryowner || environment(laundryowner) != this_object())
    return notify_fail("Since the owner of this laundry is missing "
      "you think twice before entering the laundry.\n");
  if( !interactive(thing) )
    return 0;
  owner = (string)thing->query_name();
  if ( !( vroom = find_object( laundry_room ) ) )  {
      laundry_room->load_me();
      vroom = find_object( laundry_room );
  }
  if(sizeof(filter_array(all_inventory(vroom),
                         (: userp( $1 ) :)))) {
    tell_object(thing, LO + " intercepts you.\n");
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing);
    laundryowner->do_command("say No more than one person at a time in "
      "laundry room.  It can be very dangerous!");
    laundryowner->do_command("emote taps his head implying madness.");
    return notify_fail( "" );
  }
  if(query_property(owner)) {
    remove_property(owner);
    tell_object(thing, LO + " opens the round door of the laundry and "
      "signalls you to enter.\n" );
    tell_room(this_object(), LO + " signalls "+
              (string)thing->the_short() +" to enter the laundry through "
                "the small round door of the laundry.\n", thing );
    call_out("check_idler", TIME_LIMIT, thing);
    return 1;
  }
  if ( (int)thing->query_value_in( location ) +
       (int)thing->query_value_in( "default" ) < visit_cost ) {
    tell_object( thing, LO + " intercepts you.\n" );
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    laundryowner->do_command("say Well... I am but a poor man.  I cannot "
      "just let you use my fine, imp-powered laundry for nothing!\n" );
    laundryowner->do_command("emote sniffs.\n" );
    return notify_fail( "" );
  }
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay " + LO + " who signals you to go through "
    "the small, round door of the laundry.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays " + LO + " who signals to "
             + (string)thing->query_objective() + " to move through "
             "a small, round door and enters the laundry.\n", thing );
   return 1;
}
void player_quitting(object who, object env) {
}

==================================================
FILE: shops/money_changer.c
==================================================

#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
int change(string str1, string str2);
void create() {
   add_help_file("money_changer");
   ::create();
}
void init() {
  ::init();
  add_command("change", "<string> {into|to} <string>",
                (: change($4[0], $4[2]) :) );
}
int change( string words, string type ) {
   int val_index;
   int value;
   int value_type;
   int value_unit;
   int value_change;
   int i;
   string place;
   mixed money;
   object changed;
   object *monies;
   mixed *change;
   mixed *values;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   values = (mixed *)MONEY_HAND->query_values_in( place );
   MONEY_OBJECT->set_money_array( values );
   val_index = (int)MONEY_OBJECT->find_best_fit( type );
   if ( val_index == -1 ) {
      return notify_fail( "The coin type \""+ type +
            "\" is not legal tender here.\n" );
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only change money here.\n" );
         default :
            return notify_fail( "You can only change legal tender.\n" );
      }
   }
   if (place != "default")  {
      monies = MONEY_HAND->filter_legal_tender(money, "default");
      if (monies[0])  monies[0]->move(this_player());
      if (!monies[1])  {
         return notify_fail( "You can only change legal tender.\n" );
      }
      money = monies[1];
   }
   value = (int)money->query_value_in( place );
   i = member_array(values[val_index], money->query_money_array());
   if (i != -1) {
      value_type = money->query_money_array()[i + 1] * values[val_index + 1];
   }
   value_unit = values[val_index + 1] * 100 / query_property("rate");
   value_change = (value - value_type) % value_unit;
   value = ( (value - value_type) / value_unit ) * values[val_index + 1] +
           value_type;
   if ( value < values[ val_index + 1 ] ) {
      money->move( this_player() );
      return notify_fail(
        "That is not even worth one "+ values[ val_index ] +" after I "
        "subtract my commission.\n" );
   }
   changed = clone_object( MONEY_OBJECT );
   changed->set_money_array( ({ values[ val_index ],
                                value / values[ val_index + 1 ] }));
   change = (mixed *)MONEY_HAND->create_money_array( value_change, place );
   this_player()->add_succeeded_mess(this_object(),
    ({ "You changed "+query_multiple_short( money->half_short( 1 ) ) +
         " into "+
         query_multiple_short( changed->half_short( 1 ) ) +".\n",
       "$N $V some money into "+type+".\n" }), ({ }) );
   money->move( "/room/rubbish" );
   if ( sizeof( change ) ) {
      changed->adjust_money( change );
      write( "You were returned "+ (string)MONEY_HAND->money_string( change )
            +" in change.\n" );
   }
   if ( (int)changed->move( this_player() ) != MOVE_OK ) {
      write( "Unfortunately, you're too heavily burdened to accept all that "+
            "money, so it's put on the table for you.\n" );
      changed->move( this_object() );
   }
   return 1;
}

==================================================
FILE: shops/player_craft_shop.c
==================================================

#include <config.h>
#ifdef __DISTRIBUTION_LIB__
inherit "/std/room";
#else
inherit "/std/room/player_housing";
#endif
inherit "/std/shops/inherit/player_craft_shop";
void create() {
#ifdef __DISTRIBUTION_LIB__
   room::create();
#else
   player_housing::create();
#endif
   player_craft_shop::create();
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   add_help_file("player_craft_shop");
}
void init() {
#ifdef __DISTRIBUTION_LIB__
   room::init();
#else
   player_housing::init();
#endif
   player_craft_shop::init();
}
void dest_me() {
#ifdef __DISTRIBUTION_LIB__
   room::dest_me();
#else
   player_craft_shop::dest_me();
#endif
   player_housing::dest_me();
}
void set_save_dir(string dir) {
   set_save_file(dir + "_main");
#ifndef __DISTRIBUTION_LIB__
   ::set_save_dir(dir);
#endif
}
int is_allowed(string name) {
   if (name == "pinkfish") {
      return 1;
   }
   if (lower_case(name) == lower_case(query_owner())) {
      return 1;
   }
   if (member_array(lower_case(name), query_allowed()) != -1) {
      return 1;
   }
   return 0;
}
void event_exit(object ob, string mess, object to) {
#ifdef __DISTRIBUTION_LIB__
   room::event_exit(ob, mess, to);
#else
   player_housing::event_exit(ob, mess, to);
#endif
   player_craft_shop::event_exit(ob, mess, to);
}
#ifndef __DISTRIBUTION_LIB__
int ownership_change(string old_owner, string new_owner) {
   player_craft_shop::ownership_change(old_owner, new_owner);
   return player_housing::ownership_change(old_owner, new_owner);
}
#endif

==================================================
FILE: shops/player_pub.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/pub";
private mapping _cold_drinks;
private mapping _food;
private mapping _hot_drinks;
void create() {
   do_setup++;
   basic_room::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   basic_room::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/potion_shop.c
==================================================

#define CONVERT "/global/events"->convert_message
#define MIN_VOLUME 1000
inherit "/std/shops/craft_shop_category";
void shopkeeper_say( string message );
int is_potion_or_salve( object ob );
void set_message_function( function wossname );
private nosave function _message_function;
private nosave string _shopkeeper;
void create() {
   set_message_function( (: shopkeeper_say :) );
   ::create();
   set_allowed_to_sell( (: is_potion_or_salve :) );
}
void set_message_function( function wossname ) {
   _message_function = wossname;
}
function query_message_function() {
   return _message_function;
}
void set_shopkeeper( string name ) {
   _shopkeeper = name;
}
string query_shopkeeper() {
   return _shopkeeper;
}
void shopkeeper_say( string message ) {
   object *frog;
   if( !message || message == "" )
      message = "Tuppence a bucket, well stamped down!";
   if( _shopkeeper ) {
      frog = match_objects_for_existence( _shopkeeper, this_object() );
      if( sizeof( frog ) == 1 ) {
         frog[0]->init_command( "' "+ message );
         return;
      }
   }
   write( message );
   return;
}
int is_potion_or_salve( object ob ) {
   object thing, *contents;
   int found_something;
   string contents_string;
   if( !ob->query_volume() ) {
      tell_creator( this_player(), "ob has 0 volume.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "There's nothing in "+ ob->the_short() +" that "
               "can be described as either potion or salve, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   } else if( ob->query_volume() < MIN_VOLUME ||
              ob->query_volume() < ( 7 * ob->query_max_volume() / 10 ) ) {
      tell_creator( this_player(), "ob does not contain enough stuff.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "We don't deal in quantities smaller than a cup, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   }
   contents = all_inventory( ob );
   if( !sizeof( contents ) ) {
      tell_creator( this_player(), "No contents.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( ob->the_short() +" is empty, "+
               this_player()->the_short() +"!\n" ) );
      return 0;
   }
   foreach( thing in contents )
      if( !( sizeof( thing->query_apply_effects() ) +
             sizeof( thing->query_eat_effects() ) ) ) {
         found_something = 1;
      } else {
         tell_creator( this_player(), "thing %s, effect %O.\n",
                       thing->query_short(), thing->query_eat_effects()  );
      }
   contents_string = ( sizeof( contents ) > 1 ) ?
         query_multiple_short( contents, "the" ) +" are neither potions nor "
            "salves, or they are " :
         contents[0]->the_short() +" is neither potion nor salve, or it is ";
   if( found_something ) {
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "Either "+ contents_string +"impure, or so weak as "
               "to make no difference, "+ this_player()->the_short() +"." ) );
      return 0;
   }
   return 1;
}

==================================================
FILE: shops/print_shop.c
==================================================

#include <language.h>
#include <money.h>
#include <book_handler.h>
inherit "/std/room/basic_room";
#define COPYRIGHT_NUMBER 3
nosave mixed *discount_schedule;
mapping collectables;
int current_save_number;
nosave int letter_cost;
nosave int time_to_collect;
nosave int time_per_copy;
nosave string save_dir;
nosave string office_room;
nosave int no_collection;
nosave function open_func;
nosave string default_language;
nosave mapping translation_costs;
nosave string print_shop_name;
#define SCHEDULE_NUM 1
#define SCHEDULE_PERCENTAGE 0
#define COLLECT_TIME 0
#define COLLECT_NUM  1
#define COLLECT_OB_NAME 2
#define COLLECT_LANGUAGE 3
#define COLLECT_AUTO_LOAD_NUM 4
#define COLLECT_ARR_SIZE 5
#define BINDING_COST 600
#define DEFAULT_LETTER_COST 1
#define DEFAULT_TIME_TO_COLLECT (8*60*60)
#define DEFAULT_TIME_PER_COPY (20*60)
#define MAX_NUMBER 30
int price_object(object ob, int num, string language);
protected int do_print_copies(object *obs, int num, string language);
protected int do_print(object *obs, string language);
protected int do_claim(object *obs);
protected int do_collect();
void do_print_run(object ob, int number, int cost, string language);
void print_pricing(object ob, string language);
void remove_print_run(string name, mixed *info);
mixed *query_print_run(string name);
void add_print_run(string name, object ob, int number, string language);
void load_it();
void save_it();
string query_print_shop_name();
string query_static_auto_load_info(int num);
mapping query_dynamic_auto_load_info(int num);
protected int add_auto_load_info(string static, string dynamic);
private object create_fly_leaf(object book, string language);
private void remove_auto_load_info(int num);
void create() {
   letter_cost = DEFAULT_LETTER_COST;
   time_to_collect = DEFAULT_TIME_TO_COLLECT;
   time_per_copy = DEFAULT_TIME_PER_COPY;
   collectables = ([ ]);
   discount_schedule = ({ ({ 100, 5 }),
                          ({ 95, 10 }),
                          ({ 90, 20 }),
                          ({ 80, 101 }) });
   default_language = "common";
   translation_costs = ([ ]);
   print_shop_name = "Rabbits happy little printing press";
   ::create();
   load_it();
   add_help_file("print_shop");
}
void init() {
   string languages;
   if (!office_room) {
      add_command("print", "<indirect:object>",
                   (: do_print($1, default_language) :));
      add_command("print", "<number> [copies] of <indirect:object>",
                      (: do_print_copies($1, $4[0], default_language) :) );
      add_command("claim", "copyright on <indirect:object>", (: do_claim :));
      if (sizeof(translation_costs)) {
         languages = implode(keys(translation_costs) + ({ default_language }), "|");
         add_command("print", "<indirect:object> in {" + languages + "}",
                   (: do_print($1, $4[1]) :));
         add_command("print", "<number> [copies] of <indirect:object> in "
                              "{" + languages + "}",
                         (: do_print_copies($1, $4[0], $4[2]) :) );
      }
   }
   if (!no_collection) {
      add_command("collect", "", (: do_collect :));
   }
}
protected int is_copyright(object book) {
  if (BOOK_HANDLER->check_book_same(book, book->query_book_num())) {
     return 1;
  }
  return 0;
}
protected string copyright_holder(object book) {
   return BOOK_HANDLER->query_book_owner(book->query_book_num());
}
protected int do_claim(object *obs) {
   object ob;
   object *already_copyright;
   object *new_copyright;
   object *cannot_copyright;
   string name;
   string place;
   int value;
   int player_money;
   already_copyright = ({ });
   new_copyright = ({ });
   cannot_copyright = ({ });
   name = this_player()->query_name();
   foreach (ob in obs) {
      if (!ob->query_book()) {
         cannot_copyright += ({ ob });
      } else if (is_copyright(ob)) {
         already_copyright += ({ ob });
      } else {
         new_copyright += ({ ob });
      }
   }
   if (!sizeof(new_copyright)) {
      if (sizeof(cannot_copyright)) {
         add_failed_mess("You cannot copyright $I.\n", cannot_copyright);
      }
      if (sizeof(already_copyright) == 1) {
         add_failed_mess("$I is copyrighted.\n",
                         already_copyright);
      } else {
         add_failed_mess("$I are copyrighted.\n",
                         already_copyright);
      }
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   value = 0;
   foreach (ob in new_copyright) {
      value += price_object(ob, COPYRIGHT_NUMBER, default_language);
   }
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   write("It will cost you " + MONEY_HAND->money_value_string( value, place ) +
         " to make " + query_multiple_short(new_copyright) +
         " copyright.\n");
   if (player_money > value) {
      write("Do you wish to continue? ");
      input_to("check_copyright", 0, new_copyright, value);
   } else {
      write("Although you do not currently have enough money.\n");
   }
   add_succeeded_mess( ({ "", "$N enquires about copyrighting $I.\n" }),
                       new_copyright);
   return 1;
}
protected void check_copyright(string str, object *new_copyright, int value) {
   int new_num;
   object ob;
   string place;
   if (!strlen(str) || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, never mind.  See you again soon.\n");
      return ;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               value, place ), place );
   foreach (ob in new_copyright) {
      new_num = BOOK_HANDLER->add_book(ob, 0, this_player()->query_name());
      ob->set_book_num(new_num);
      ob->add_property(BH_COPYRIGHT, this_player()->query_name());
   }
   write("Ok, added " + query_multiple_short(new_copyright) +
         " as a copyright book.\n");
}
protected int do_collect() {
   object new_ob;
   object page;
   object fly_leaf;
   int i;
   int j;
   int number;
   int no_printed;
   string ob_name;
   mixed static_arg;
   mixed dynamic_arg;
   string language;
   mixed *info;
   mixed *stuff;
   mixed *collectables;
   mixed room;
   int auto_load_num;
   if (open_func) {
      if (!evaluate(open_func)) {
         return 0;
      }
   }
   if (office_room) {
      room = office_room;
   } else {
      room = this_object();
   }
   collectables = room->query_print_run(this_player()->query_name());
   if (!collectables) {
      add_failed_mess("No books available for collection.\n");
      return 0;
   }
   no_printed = 0;
   foreach (info in collectables) {
      if (time() < info[COLLECT_TIME]) {
         add_failed_mess("You need to wait until " +
                         amtime(info[COLLECT_TIME]) +
                         " to collect your book.\n");
         continue;
      }
      auto_load_num = info[COLLECT_AUTO_LOAD_NUM];
      static_arg = room->query_static_auto_load_info(auto_load_num);
      dynamic_arg = room->query_dynamic_auto_load_info(auto_load_num);
      ob_name = info[COLLECT_OB_NAME];
      number = info[COLLECT_NUM];
      language = info[COLLECT_LANGUAGE];
      if (office_room) {
         office_room->remove_print_run(this_player()->query_name(), info);
      } else {
         remove_print_run(this_player()->query_name(), info);
      }
      new_ob = clone_object(ob_name);
      if (static_arg) {
         new_ob->init_static_arg(static_arg);
      }
      if (dynamic_arg) {
         new_ob->init_dynamic_arg(dynamic_arg);
      }
      new_ob->set_open_page(0);
      for (j = 0; j < new_ob->query_num_pages(); j++) {
         if (j > 0) {
            page = new_ob->query_selected_page(j);
         } else {
            new_ob->set_open_page(0);
            page = new_ob;
         }
         if (j == 1) {
             fly_leaf = create_fly_leaf(new_ob, language);
             if (page->query_property(BH_IGNORE_PAGE)) {
                new_ob->replace_page_with(fly_leaf, j);
             } else {
                new_ob->add_page_after(fly_leaf, j - 1);
             }
             page = new_ob->query_selected_page(j + 1);
         }
         stuff = page->query_read_mess();
         foreach (info in stuff) {
            if (info[READ_LANG] != language) {
               info[READ_LANG] = language;
            }
         }
         page->set_read_mess(stuff);
      }
      static_arg = new_ob->query_static_auto_load();
      dynamic_arg = new_ob->query_dynamic_auto_load();
      new_ob->dest_me();
      for (i = 0; i < number; i++) {
         new_ob = clone_object(ob_name);
         new_ob->set_player(this_player());
         if (static_arg) {
            new_ob->init_static_arg(static_arg, this_player());
         }
         if (dynamic_arg) {
            new_ob->init_dynamic_arg(dynamic_arg, this_player());
         }
         new_ob->move(this_object());
      }
      if (number > 1) {
         write("Ok, your " + query_num(number, 1000) + " copies of " +
               new_ob->the_short() +
               " have been placed on the floor here.\n");
      } else {
         write("Ok, your copy of " + new_ob->the_short() +
               " has been placed on the floor here.\n");
      }
      no_printed++;
   }
   return no_printed;
}
private object create_fly_leaf(object book, string language) {
    object page;
    page = book->create_default_page_object();
    if (is_copyright(book)) {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n\nCopyright " +
                             this_player()->query_name(), 0,
                             language);
    } else {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n", 0,
                             language);
    }
    page->add_property(BH_IGNORE_PAGE, 1);
    return page;
}
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
}
int check_for_untranslatable_language(object ob) {
   mixed *stuff;
   int i;
   string lang;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      lang = stuff[i][READ_LANG];
      if (lang != default_language &&
          !translation_costs[lang]) {
         return 1;
      }
   }
   return 0;
}
object find_book_or_paper(object *obs) {
   object *paper;
   object *books;
   object *magic;
   object *torn_out;
   object *nothing;
   object ob;
   int page;
   int old_page;
   string owner;
   paper = ({ });
   books = ({ });
   magic = ({ });
   torn_out = ({ });
   nothing = ({ });
   foreach (ob in obs) {
      owner = copyright_holder(ob);
      if (is_copyright(ob) && owner != this_player()->query_name()) {
         add_failed_mess("$I has been copyrighted by " + owner +
                         " and cannot be copied.\n", ({ ob }));
      } else if (ob->query_book()) {
         if (ob->query_spell_book()) {
            magic += ({ ob });
         } else {
            old_page = ob->query_open_page();
            for (page = 0; page <= ob->query_num_pages(); page++) {
               ob->set_open_page(page);
               if (ob->is_current_page_torn_out()) {
                  torn_out += ({ ob });
                  break;
               }
               if (check_for_magic_writing(ob)) {
                  magic += ({ ob });
                  break;
               }
            }
            ob->set_open_page(old_page);
            if (page == ob->query_num_pages() + 1) {
               books += ({ ob });
            }
         }
      } else if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      } else {
         nothing += ({ ob });
      }
   }
   if (sizeof(magic)) {
      add_failed_mess("$I have magic writing in them and cannot be copied.\n",
                      magic);
   }
   if (sizeof(torn_out)) {
      add_failed_mess("$I have pages torn out and cannot be copied.\n",
                      torn_out);
   }
   if (!sizeof(books) && !sizeof(paper)) {
      if (sizeof(nothing)) {
         add_failed_mess("Unable to print $I as they are not a book or paper.\n", nothing);
      }
      return 0;
   }
   if (sizeof(books + paper) > 1) {
      add_failed_mess("Can only do print one book or piece of paper at a time.  "
                  "Please be more specific and choose from " +
                  query_multiple_short(books + paper) + ".\n");
      return 0;
   }
   if (sizeof(books) > 0) {
      return books[0];
   }
   return paper[0];
}
int do_print(object *obs, string language) {
   object ob;
   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }
   print_pricing(ob, language);
   write("Use: print <number> of <book>\n");
   add_succeeded_mess(({ "",
                       "$N enquires about the cost of printing a book.\n" }));
   return 1;
}
int do_print_copies(object *obs, int number, string language) {
   object ob;
   int cost;
   int player_money;
   string place;
   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }
   if (number < 1) {
      add_failed_mess("Must print at least one copy.\n", obs);
      return 0;
   }
   if (number > MAX_NUMBER) {
      add_failed_mess("Cannot print more than " + MAX_NUMBER +
                      " copies.\n", obs);
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }
   cost = price_object(ob, number, language);
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   if (player_money < cost) {
      add_failed_mess("This will cost you " +
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) + " and you do not have enough "
                  "money to afford it.\n", ({ ob }));
      return 0;
   }
   if (is_copyright(ob)) {
      write("NOTE:  You are printing a copyright document.\n");
   } else {
      write("NOTE:  Please use 'claim copyright' to claim copyright "
            "on a document.\n");
   }
   add_succeeded_mess(({ "This will cost you " +
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) +
                       " to do, do you wish to continue? ",
                       "$N starts to do some printing.\n" }));
   input_to("check_cost", 0, ob, number, cost, language);
   return 1;
}
void check_cost(string str, object ob, int number, int cost, string language) {
   if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, don't worry.  See you again.\n");
      return ;
   }
   do_print_run(ob, number, cost, language);
}
void do_print_run(object ob, int number, int cost, string language) {
   string place;
   int player_money;
   mixed *stuff;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   if (player_money < cost) {
      write("You do not seem to have enough money any more.\n");
      return ;
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
   add_print_run(this_player()->query_name(),
                 ob,
                 number,
                 language);
   stuff = query_print_run(this_player()->query_name());
   if (no_collection) {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion at the "
            "collection office.\n");
   } else {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion.\n");
   }
}
int price_object(object ob, int num, string to_language) {
   int i;
   int num_letters;
   int multiplier;
   int cost;
   mixed *stuff;
   if (num <= 0 || !ob) {
     return 0;
   }
   ob->set_open_page(0);
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      num_letters += strlen(stuff[i][READ_MESS]);
      if (stuff[i][READ_LANG] != default_language) {
         cost = translation_costs[stuff[i][READ_LANG]];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
      if (to_language != default_language) {
         cost = translation_costs[to_language];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
   }
   cost = ob->query_value() + (num_letters / 10) * letter_cost;
   if (ob->query_book()) {
      for (i = 1; i < ob->query_num_pages(); i++) {
         ob->set_open_page(i + 1);
         if (ob != ob->query_current_page()) {
            cost += price_object(ob->query_current_page(), 1, to_language);
         }
      }
      cost += BINDING_COST;
   }
   multiplier = 200;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      if (num < discount_schedule[i][SCHEDULE_NUM]) {
         multiplier = discount_schedule[i][SCHEDULE_PERCENTAGE];
      }
   }
   return (cost * num * multiplier) / 100;
}
void print_pricing(object ob, string language) {
   int i;
   int num;
   string place;
   int cost;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   write("The cost for the different numbers of " + ob->the_short() + " is:\n");
   write("  1 for " + (string)MONEY_HAND->money_value_string(
                    price_object(ob, 1, language), place ) +
                    " and will be ready at " +
                    amtime(time_to_collect + time_per_copy + time()) + ".\n");;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      num = discount_schedule[i][SCHEDULE_NUM];
      if (num < MAX_NUMBER) {
         write(sprintf("%3d for %s and will be ready at %s.\n", num,
                       (string)MONEY_HAND->money_value_string(
                       price_object(ob, num, language), place ),
                       amtime(time_to_collect + time_per_copy * num + time()) ));
      }
   }
   if (sizeof(translation_costs)) {
      write("You can translate a book to or from " +
            query_multiple_short(keys(translation_costs) + ({ default_language })) +
            ", the cost of doing the translation is defined in the "
            "following table.");
      if (sizeof(translation_costs) > 2) {
         write("  Translating between two of these languages "
               "is also possible, but it will cost the amount to translate "
               "from the language to " + default_language + " and back again.");
      }
      write("\n");
      foreach (language, cost in translation_costs) {
         write(sprintf("   %3d%% %s", cost, language));
      }
      write("\n");
   }
}
mixed *query_discount_schedule() {
   return discount_schedule;
}
void set_discount_schedule(mixed *value) {
   discount_schedule = value;
}
int query_letter_cost() {
   return letter_cost;
}
void set_letter_cost(int value) {
   letter_cost = value;
}
void add_print_run(string name, object ob, int number, string language) {
   mixed *arr;
   int num;
   if (!collectables[name]) {
      collectables[name] = ({ });
   }
   arr = allocate(COLLECT_ARR_SIZE);
   arr[COLLECT_TIME] = time() + time_to_collect + time_per_copy * number;
   arr[COLLECT_NUM] = number;
   arr[COLLECT_LANGUAGE] = language;
   arr[COLLECT_OB_NAME] = base_name(ob);
   num = add_auto_load_info(ob->query_static_auto_load(),
                             ob->query_dynamic_auto_load());
   arr[COLLECT_AUTO_LOAD_NUM] = num;
   collectables[name] += ({ arr });
   save_it();
}
mixed *query_print_run(string name) {
   return collectables[name];
}
void remove_print_run(string name, mixed *info) {
   int index;
   if (collectables[name]) {
      index = member_array(info, collectables[name]);
      if (index != -1) {
         remove_auto_load_info(info[COLLECT_AUTO_LOAD_NUM]);
         collectables[name] = collectables[name][0.. index - 1] +
                              collectables[name][index + 1..];
         if (!sizeof(collectables[name])) {
            map_delete(collectables, name);
         }
         save_it();
      }
   }
}
protected int add_auto_load_info(string static, string dynamic) {
   int num;
   num = current_save_number;
   while (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      num++;
   }
   current_save_number = num + 1;
   unguarded( (: write_file(save_dir + "/" + $(num),
                            save_variable( ({ $(static), $(dynamic) }) ) +
                            "\n") :) );
   return num;
}
private void remove_auto_load_info(int num) {
   unguarded( (: rm(save_dir + "/" + $(num) ) :) );
}
string query_static_auto_load_info(int num) {
   string *arr;
   string tmp;
   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[0];
      }
   }
   return 0;
}
mapping query_dynamic_auto_load_info(int num) {
   mixed arr;
   string tmp;
   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[1];
      }
   }
   return 0;
}
void set_save_dir(string name) {
   save_dir = name;
}
string query_save_dir() {
   return save_dir;
}
void load_it() {
   if (save_dir) {
      unguarded((: restore_object(save_dir + "/main") :));
      if (!collectables) {
         collectables = ([ ]);
      }
   }
}
void save_it() {
   if (save_dir) {
      unguarded((: save_object(save_dir + "/main") :));
   }
}
void set_office_room(string room) {
   office_room = room;
}
string query_office_room() {
   return office_room;
}
void set_no_collection(int collect) {
   no_collection = collect;
}
int query_no_collection() {
   return no_collection;
}
void set_open_func(function func) {
   open_func = func;
}
function query_open_func() {
   return open_func;
}
void set_default_language(string lang) {
   default_language = lang;
}
string query_default_language() {
   return default_language;
}
void add_translation_cost(string lang, int cost) {
   translation_costs[lang] = cost;
}
void remove_translation_cost(string lang) {
   map_delete(translation_costs, lang);
}
mapping query_all_translantion_costs() {
   return translation_costs;
}
void set_print_shop_name(string name) {
   print_shop_name = name;
}
string query_print_shop_name() {
   return print_shop_name;
}

==================================================
FILE: shops/pub_shop.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/pub";
void create() {
   add_help_file("pub_shop");
   do_setup++;
   basic_room::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   basic_room::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/pub_shop_outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/shops/inherit/pub";
void create() {
   add_help_file("pub_shop");
   do_setup++;
   outside::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   outside::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   outside::dest_me();
}

==================================================
FILE: shops/real_estate_auction.c
==================================================

inherit "/std/shops/auction_house";
#include <housing.h>
#include <money.h>
#include <move_failures.h>
#include <room/auction.h>
#include <nomic_system.h>
#include <morpork.h>
#define AUCTION_LENGTH (3600*24*5)
#define NEW_AGREEMENT_COST 4000
#define REAL_ESTATE_NEW_LOT_BIDDING "new_low_bidding"
private nosave string* _areas;
private nosave string _city;
private nosave string _language;
int add_house(string house);
int check_can_bid(object person,
                  class auction which,
                  int bid_amount);
void create() {
   _areas = ({ });
   _city = "Ankh-Morpork";
   _language = "morporkian";
   ::create();
   add_help_file("real_estate");
}
void reset()
{
   call_out("after_reset", 10);
}
void add_housing_area(string area) {
   _areas += ({ area });
}
string* query_housing_areas() {
   return _areas;
}
void after_reset()
{
   string house;
   string *available;
   int i;
   string area;
   foreach (area in _areas) {
      available = HOUSING->query_vacant(area);
      if (sizeof(available)) {
        i = 1;
        foreach(house in available) {
          call_out("add_house", i++, house);
        }
      }
   }
}
int add_house(string house)
{
   object agreement;
   string text;
   int tim;
   if (member_array(house, keys(HOUSING->query_houses())) == -1) {
      return 0;
   }
   if(lower_case(HOUSING->query_owner(house)) != "for sale") {
     log_file("REAS", ctime(time()) + ": attempt to add house %s that's "
              "not for sale.\n", house);
     return 0;
   }
   HOUSING->set_rent(house, 0);
   agreement = clone_object(AGREEMENT);
   agreement->set_city(_city);
   agreement->set_language(_language);
   agreement->set_house(house);
   text = HOUSING->query_address(house);
   tim = query_last_auction_finish_time();
   if (tim + 60 * 60 < time() + query_auction_times()["very long"]) {
      tim = 0;
   } else {
      tim = tim + 60 * 60 - time();
   }
   if (add_item_to_auction(({ agreement }), text,
                           400, "Patrician", tim,
                           "housing_auction", house)) {
      HOUSING->set_under_offer(house);
      broadcast_shop_event(REAL_ESTATE_NEW_LOT_BIDDING, this_player(),
                           house);
      log_file("REAS", ctime(time()) + ": Added house %s\n", house);
      return 1;
   }
}
void housing_auction(int event_type,
                     class auction auct,
                     string house,
                     string buyer,
                     int cost,
                     object *obs)
{
   object book;
   switch (event_type) {
   case AUCTION_WITHDRAW_PHASE:
     if(lower_case(HOUSING->query_owner(house)) != "under offer") {
       write("House is not currently under offer!\n");
       log_file("REAS", ctime(time()) + ": attempted to withdraw %s when it "
                "was not 'Under Offer'.\n", house);
     } else {
       HOUSING->set_for_sale(house);
       log_file("REAS", ctime(time()) + ": %s back to For Sale.\n", house);
     }
     break;
   case AUCTION_CLAIM_PHASE:
      HOUSING->set_owner(house, buyer);
      HOUSING->set_value(house, cost);
      obs[0]->set_city(_city);
      obs[0]->set_language(_language);
      obs[0]->set_house(house);
      log_file("REAS", ctime(time()) + ": %O sold to %O for %O.\n",
               house, buyer,
               MONEY_HAND->money_value_string(cost, query_property("place")));
      book = clone_object(BOOK);
      if (book) {
         if (book->move(this_player()) != MOVE_OK) {
            book->move(this_object());
         }
      }
      write("A nice new house owner's guide pops up for you.\n");
      break;
   }
}
int do_agreement()
{
   string *houses;
   int i;
   string place;
   place = query_property("place");
   if (this_player()->query_value_in(place) < NEW_AGREEMENT_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) +
                      " to get a new agreement.\n");
      return 0;
   }
   houses = filter(keys(HOUSING->query_houses()),
                   (: HOUSING->query_owner($1) == $2 :),
                   this_player()->query_name());
   if (!sizeof(houses)) {
      add_failed_mess("You are not renting any houses.\n");
      return 0;
   }
   for (i = 0; i < sizeof(houses); i++) {
      printf("%c) %s %s\n", i + 'A',
             HOUSING->query_address(houses[i]),
             HOUSING->query_region(houses[i]));
   }
   write("It will cost you " + MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) + " for a new "
         "agreement.\n");
   write("Which house to choose? ");
   input_to("new_agreement_choice", 0, houses);
   add_succeeded_mess(({ "",
                         "$N enquires about a new rental agreement.\n" }));
   return 1;
}
protected void new_agreement_choice(string choice,
                          string *houses)
{
   int index;
   object agreement;
   string place;
   place = query_property("place");
   choice = lower_case(choice);
   if (!strlen(choice)) {
      write("Ok, canceling agreement check.\n");
      return;
   }
   index = choice[0] - 'a';
   if (index < 0 || index >= sizeof(houses)) {
      write("Choice out of bounds.\n");
      return;
   }
   if (this_player()->query_value_in(place) < NEW_AGREEMENT_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) +
                      " to get a new agreement.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->
                            create_money_array(NEW_AGREEMENT_COST, place));
   agreement = clone_object(AGREEMENT);
   agreement->set_city(_city);
   agreement->set_language(_language);
   agreement->set_house(houses[index]);
   if (agreement->move(this_player()) != MOVE_OK) {
      write("Unable to move the agreement into your inventory.\n");
      return 0;
   }
   write("Created a new agreement for " +
         HOUSING->query_address(houses[index]) + ".\n");
}
int check_can_bid(object person,
                  class auction which,
                  int bid_amount)
{
   int total_money,
     total_bids;
   string *accounts;
   string account;
   class auction auction;
   accounts = "/obj/handlers/bank_handler"->query_accounts(person->
                                                           query_name());
   foreach(account in accounts) {
      total_money += "/obj/handlers/bank_handler"->query_account(person->
                                                                 query_name(),
                                                                 account);
   }
   foreach(auction in query_auctions()) {
      if (auction->current_bidder &&
          lower_case(auction->current_bidder) == person->query_name()) {
         total_bids += auction->bid;
      }
   }
   if (total_bids + bid_amount > total_money * 3) {
      add_failed_mess
         ("You do not have sufficient funds in your bank accounts "
          "to cover such a bid.\n");
      return 0;
   }
   return 1;
}
void init()
{
   ::init();
   add_command("request", "[agreement]", (: do_agreement() :));
}
void reset_auctions_to_under_offer() {
    class auction auc;
    foreach( auc in query_auctions() ) {
        HOUSING->set_under_offer(auc->extra);
    }
}
void set_city( string where ) {
    _city = where;
}
void set_language( string lang ) {
    _language = lang;
}
string query_city() {
    return _city;
}
string query_language() {
    return _language;
}
mixed *stats() {
  return ::stats() +
    ({
        ({ "areas", _areas }),
        ({ "city", _city }),
        ({ "language", _language }),
    });
}

==================================================
FILE: shops/sign_writer.c
==================================================

inherit "/std/room/basic_room";
#include <money.h>
#include <move_failures.h>
#define SIGN_MAKING_PICK_UP_TIME (24 * 60 * 60)
class sign_type {
   string short;
   string long;
   int cost;
   int weight;
   int max_letters;
   int max_lines;
}
class sign_making {
   int type;
   string mess;
   string colour;
   int pick_up;
}
private nosave class sign_type* _signtypes;
private nosave mapping _paintcolours;
private nosave string _save_file;
private nosave string _language;
private nosave function _open_func;
private mapping _signs;
void do_load();
void create() {
   _signtypes = ({ });
   _paintcolours = ([ ]);
   _signs = ([ ]);
   ::create();
   do_load();
   add_help_file("sign_writer");
}
int is_open() {
   if (_open_func) {
      return evaluate(_open_func);
   }
   return 1;
}
void set_open_func(function func) {
   _open_func = func;
}
function query_open_func() {
   return _open_func;
}
void set_language(string lang) {
   _language = lang;
}
string query_language() {
   return _language;
}
void set_save_file_name(string save) {
   _save_file = save;
}
string query_save_file_name() {
   return _save_file;
}
void do_save() {
   if (_save_file) {
      save_object(_save_file);
   }
}
void do_load() {
   if (_save_file) {
      restore_object(_save_file);
   }
}
void add_paint_colour(string colour, int cost) {
   _paintcolours[colour] = cost;
}
void add_sign_type(string short, string long, int cost,
                   int weight, int max_letters, int max_lines) {
   class sign_type bing;
   bing = new(class sign_type);
   bing->short = short;
   bing->long = long;
   bing->cost = cost;
   bing->weight = weight;
   bing->max_letters = max_letters;
   bing->max_lines = max_lines;
   _signtypes += ({ bing });
}
void add_sign_making(string owner, int type, string mess,
                     string colour, int pick_up) {
   class sign_making bing;
   bing = new(class sign_making);
   bing->type = type;
   bing->mess = mess;
   bing->colour = colour;
   bing->pick_up = pick_up;
   if (!_signs[owner]) {
      _signs[owner] = ({ });
   }
   _signs[owner] += ({ bing });
   do_save();
}
int do_order(string type) {
   int pos;
   int cost;
   string place;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   if (strlen(type) == 1) {
      pos = lower_case(type)[0] - 'a';
      if (pos < 0 || pos > sizeof(_signtypes)) {
         add_failed_mess("The id must be between 'a' and '" +
               sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
         return 0;
      }
   } else {
      add_failed_mess("The id must be between 'a' and '" +
            sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _signtypes[pos]->cost;
   if (cost > this_player()->query_value_in(place)) {
      add_failed_mess("You do not have enough money to pay for this "
            "sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return 0;
   }
   write("Using a sign of type " + _signtypes[pos]->short +
         ".  What message would "
         "you like on your sign?\n");
   this_player()->do_edit("", "finish_editing_message", this_object(),
                          0, pos);
   add_succeeded_mess(({ "",
                         "$N looks into getting a sign made up.\n" }));
   return 1;
}
void finish_editing_message(string mess, int type) {
   string colour;
   int cost;
   string place;
   class sign_type bing;
   if (!mess) {
      write("Aborting sign writing process.\n");
      return ;
   }
   bing = _signtypes[type];
   if (strlen(replace(mess, ({ "\n", "", }))) > bing->max_letters) {
      write("The message " + mess + " has too many letters for the "
            "sign " + bing->short + ", the most allowed is " +
            bing->max_letters + ", you have " +
            strlen(replace(mess, ({ "\n", "", }))) +
            ".\n");
      return ;
   }
   if (sizeof(explode(mess, "\n")) > bing->max_lines) {
      write("The message " + mess + " has too many lines for the "
            "sign " + bing->short + ", the most allowed is " +
            bing->max_lines + ", you have " +
            sizeof(explode(mess, "\n")) +
            ".\n");
      return ;
   }
   write("You have selected a sign of type " + bing->short + " and have "
         "decided to put the message:\n" + mess + "\nonto the sign.\n"
         "Paint colours are:\n");
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   foreach (colour, cost in _paintcolours) {
      write(sprintf("%-20s %s per letter\n", colour,
            MONEY_HAND->money_value_string(cost, place)));
   }
   write("What colour paint would you like? ");
   input_to("finish_sign", 0, type, mess);
}
void finish_sign(string colour, int type, string mess) {
   int cost;
   string place;
   class sign_type bing;
   colour = lower_case(colour);
   bing = _signtypes[type];
   if (!strlen(colour)) {
      write("Aborting the sign process.\n");
      return ;
   }
   if (!_paintcolours[colour]) {
      write("I am sorry, we do not stock " + colour + ".\n");
      write("Try one of " +
            query_multiple_short(keys(_paintcolours)) + ".\n");
      write("What colour paint would you like? ");
      input_to("finish_sign", 0, type, mess);
      return ;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _paintcolours[colour] *
          strlen(replace(mess, ({ "\n", "", " ", "" })));
   cost += bing->cost;
   if (cost > this_player()->query_value_in(place)) {
      write("You do not have enough money to pay for this sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return ;
   }
   write("Making a sign of type " + bing->short + " with a message of:\n" +
         mess + "\nWill cost " +
         MONEY_HAND->money_value_string(cost, place) +
         ".\nDo you wish to make this sign? ");
   input_to("validate_sign", 0, type, mess, colour, cost);
}
void validate_sign(string choice, int type, string mess,
                   string colour, int cost) {
   int pick_up;
   string place;
   class sign_type bing;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (cost > this_player()->query_value_in(place)) {
      write("You do not have enough money to pay for this sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return ;
   }
   bing = _signtypes[type];
   choice = lower_case(choice);
   if (!strlen(choice) || (choice[0] != 'n' && choice[0] != 'y')) {
      write("You did not enter 'yes' or 'no'.  Please try again.\n");
      write("Making a sign of type " + bing->short + " with a message of:\n" +
            mess + "\nWill cost " +
            MONEY_HAND->money_value_string(cost, place) +
            ".\nDo you wish to make this sign? ");
      input_to("validate_sign", 0, type, mess, colour);
      return 0;
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
   pick_up = time() + SIGN_MAKING_PICK_UP_TIME;
   add_sign_making(this_player()->query_name(), type, mess, colour,
                   pick_up);
   write("Ok, we will start making your sign.  Please come "
         "back tomorrow (after " + ctime(pick_up) +
         ") to pick up your sign.\n");
}
int do_collect() {
   class sign_making sign;
   class sign_type type;
   object* ok;
   string* not_yet;
   string* bits;
   object ob;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   if (!_signs[this_player()->query_name()]) {
      add_failed_mess("You have no signs to pick up.\n");
      return 0;
   }
   ok = ({ });
   not_yet = ({ });
   foreach (sign in _signs[this_player()->query_name()]) {
      if (time() > sign->pick_up) {
         type = _signtypes[sign->type];
         ob = clone_object("/std/room/furniture/basic");
         bits = explode(type->short, " ");
         ob->set_name(bits[<1]);
         ob->add_adjective(bits[0..<2]);
         ob->set_short(type->short);
         ob->set_long(type->long);
         ob->set_weight(type->weight);
         ob->add_read_mess(sign->mess, sign->colour + " paint",
                           query_language(), 1);
         ob->add_property("sign");
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         ok += ({ ob });
      } else {
         not_yet += ({ _signtypes[sign->type]->short + " with " +
                       sign->colour + " letters" });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("$N pick$s up $I.\n", ok);
      return 1;
   }
   if (sizeof(not_yet) == 1) {
      add_failed_mess("The sign " + query_multiple_short(not_yet) +
                      " is not ready to be picked up yet.\n");
   } else {
      add_failed_mess("The signs " + query_multiple_short(not_yet) +
                      " are not ready to be picked up yet.\n");
   }
   return 0;
}
int do_browse(string type) {
   class sign_type bing;
   string place;
   int pos;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (strlen(type) == 1) {
      pos = lower_case(type)[0] - 'a';
      if (pos < 0 || pos > sizeof(_signtypes)) {
         add_failed_mess("The id must be between 'a' and '" +
               sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
         return 0;
      }
   } else {
      add_failed_mess("The id must be between 'a' and '" +
            sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
      return 0;
   }
   bing = _signtypes[pos];
   write("The sign of type " + type + " has a short description of '" +
         bing->short + "' and a long description:\n" + bing->long +
         "\nIt will cost " +
         MONEY_HAND->money_value_string(bing->cost, place) +
         " and will take a maximum of " + bing->max_letters +
         " letters and a maximum number of lines of " +
         bing->max_lines + ".\n");
   add_succeeded_mess(({ "", "$N browses a sign in " + the_short() +
                             ".\n" }));
   return 1;
}
int do_list() {
   class sign_type bing;
   int i;
   string ret;
   string place;
   string colour;
   int cost;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "Signs availabe:\n";
   for (i = 0; i < sizeof(_signtypes); i++) {
      bing = _signtypes[i];
      ret += "$I$7=   " + sprintf("%c", 'a' + i) +
             ") " + bing->short + " costs " +
         MONEY_HAND->money_value_string(bing->cost, place) +
         " with " + bing->max_letters + " characters and " +
         bing->max_lines + " lines.\n";
   }
   ret += "\n$I$0=Colours available:\n";
   foreach (colour, cost in _paintcolours) {
      ret += sprintf("$I$7=   %-20s %s per letter\n", colour,
            MONEY_HAND->money_value_string(cost, place));
   }
   write("$P$Sign browse$P$" + ret);
   add_succeeded_mess(({ "", "$N lists the signs in " +
                             the_short() + ".\n" }) );
   return 1;
}
void init() {
   add_command("list", "", (: do_list() :));
   add_command("browse", "<string'sign'>", (: do_browse($4[0]) :));
   add_command("collect", "sign", (: do_collect() :));
   add_command("buy", "<string'sign'>", (: do_order($4[0]) :));
   add_command("order", "<string'sign'>", (: do_order($4[0]) :));
}

==================================================
FILE: shops/storeroom.c
==================================================

#include <config.h>
#ifndef __DISTRIBUTION_LIB__
#include <thief.h>
#endif
inherit "/std/room/basic_room";
mapping room_cont;
int max_num;
int loot;
mapping shop_type;
void create() {
  room_cont = ([ ]);
  shop_type = ([ ]);
  max_num = 8;
  ::create();
  loot = random(10);
  set_keep_room_loaded(1);
  call_out("test_cont", 1);
}
mapping query_room_cont() {
  return room_cont;
}
int query_max_num() { return max_num; }
void set_max_num(int i) { max_num = i; }
void add_thing(object ob) {
  string shr;
  if (!ob || environment(ob) != this_object())
    return ;
  shr = (string)ob->query_property("shop type");
  if (!shop_type[shr])
    shop_type[shr] = ({ ob });
  else
    shop_type[shr] += ({ ob });
  shr = (string)ob->short();
  if (!room_cont[shr]) {
    room_cont[shr] = ({ ob });
    return ;
  }
  if (sizeof(room_cont[shr]) > max_num)
    call_out("do_dest", 1, ob);
  else
    room_cont[shr] += ({ ob });
  return ;
}
void test_cont() {
  int i;
  object *obs;
  obs = all_inventory();
  for (i=0;i<sizeof(obs);i++)
    add_thing(obs[i]);
}
void remove_thing(object ob) {
  mixed *arr;
  int i;
  string sh;
  if (!ob || environment(ob) == this_object())
    return ;
  sh = (string)ob->query_property("shop type");
  if (shop_type[sh])
    shop_type[sh] = (object *)shop_type[sh] - ({ ob });
  sh = (string)ob->short();
  if (!room_cont[sh])
    return ;
  arr = room_cont[sh];
  if ((i = member_array(ob, arr)) == -1)
    return ;
  if (sizeof(arr) <= 1) {
    room_cont = m_delete(room_cont, sh);
  } else
    room_cont[sh] = delete(arr, i, 1);
}
void event_enter(object ob, string, object) {
  call_out("add_thing", 1, ob);
}
void event_exit(object ob, string mesage, object to) {
  call_out("remove_thing", 1, ob);
}
void do_dest( object thing ) {
   if ( !thing )
      return;
   thing->move( "/room/rubbish" );
}
mapping query_shop_type_mapping() { return shop_type; }
int clean_up(int) { return 0; }

==================================================
FILE: shops/vault.c
==================================================

#include <vault.h>
inherit "/std/room/basic_room";
private object _container;
private string _vault_name;
private string _entry;
private string _there;
void set_vault_exit(string direc, mixed dest, string type) {
  _entry = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_done" }) );
  modify_exit( direc, ({ "closed", 1 }) );
}
void set_vault_name(string str) { _vault_name = str; }
object init_container(object person) {
  object container;
  string owner;
  owner = person->query_name();
  container = clone_object( "/obj/cont_save" );
  container->set_max_weight( 1000 );
  container->set_open();
  container->set_stuck( 1 );
  container->set_can_recurse(1);
  container->reset_get();
  container->set_save_file( VAULT_SAVE +_vault_name+ "/"+ owner,
                           person );
  if ( !master()->file_exists( VAULT_SAVE +_vault_name+"/"+ owner +".o" ) ) {
    container->add_property( "owner", owner );
    container->do_save();
  }
  container->move(this_object());
  container->add_property("there", "here");
  this_object()->setup_container(container);
  container->add_property( "owner", owner );
  _there = container->query_property("there");
  return container;
}
void event_enter(object thing, string mess, object from) {
  string owner;
  if( !userp( thing ) )
    return;
  owner = thing->query_name();
  if ( _container ) {
    if((string)_container->query_property( "owner" ) == owner)
      return;
    else if(thing->query_creator() &&
            find_player(_container->query_property( "owner" )) &&
            environment(find_player(_container->query_property( "owner" ))) ==
            this_object())
         return;
      else {
        _container->dest_me();
        _container = 0;
      }
  }
  _container = init_container(thing);
  call_out("fix_owner", 2, owner);
}
void fix_owner(string owner) {
  if (_container) {
     _container->add_property( "owner", owner );
     if(_there) {
       _container->add_property("there", _there);
     }
  }
}
int check_done( string verb, object thing, string special ) {
  if ( thing->query_auto_loading() ) {
    tell_room( this_object(), "The door swings shut.\n" );
    tell_object( thing, "Your vaults's inventory is still being generated.\n"
                "Please wait until it is completed.\n" );
      return notify_fail( "" );
   }
   return 1;
}
void event_exit( object thing, string message, object to ) {
  if(_container && _container->query_property("owner") == thing->query_name()) {
    _container->move("/room/void");
    call_out((: _container->dest_me() :), 1);
  }
  if(interactive(thing))
    thing->save_me();
}
string query_quit_handler() {
  return _entry;
}
void setup_container(object container) {
  container->set_name( "drawer" );
  container->set_short( "drawer" );
  container->add_alias( "drawer" );
  container->set_long("The single open drawer is sticking straight "
                      "out of the wall like...  well, like a drawer sticking "
                      "straight out of the wall.  " );
}
int trap_action( string str ) {
   string st1;
   if( sscanf( str,"%s %s", str, st1 ) );
      switch(str) {
      case "circle":
         tell_object( this_player(),
               "Something tells you that drawing a circle in this location "
               "would be a bad idea.\n");
         return 1;
      case "erect":
         tell_object( this_player(),
               "You can't seem to get the tent to unfold properly.  "
               "Perhaps you should try it somewhere else.\n");
         return 1;
      default:
         return 0;
    }
}
void event_net_dead(object ob) {
   ob->move_with_look(_entry);
}
void init() {
   ::init();
   this_player()->command_override( (: trap_action :) );
}
int query_vault_room() {
   return 1;
}

==================================================
FILE: shops/vault_entry.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/vault_entry";
void create() {
   add_help_file("vault_entry");
   basic_room::create();
}
void init() {
  basic_room::init();
  vault_entry::init();
}

==================================================
FILE: shops/controllers/craft_shop_controller.c
==================================================

#include <obj_parser.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <shops/craft_shop.h>
class craft_object {
   int cost;
   string cap_owner;
   int ob_num;
   string category;
   string short;
}
class craft_sellable {
   mapping objects;
}
class craft_category {
   int state;
   string description;
   string information;
   string* voted;
   int yes;
   int no;
   int abstain;
   int timeout;
}
#define SELL_OBJECT_NAME_PROP "sell name"
#define SELL_OBJECT_OWNER_PROP "sell owner"
#define SELL_OBJECT_CLASS_PROP "sell class"
#define SELL_OBJECT_ID_PROP "sell id"
private nosave mapping _sellables;
private nosave object _sell_list;
private nosave mapping _royalties;
private nosave int _current_save_num;
private nosave mapping _categories;
private nosave int _category_callout;
private nosave int _category_dont_use_name;
private nosave function _save_function;
private nosave function _load_function;
private nosave function _category_function;
private nosave int *_current_ids;
private nosave int _has_loaded;
void load_it();
void save_it();
private void update_sellable(string name);
class craft_object create_craft_object(object ob,
                                       string owner,
                                       int cost,
                                       string category);
void adjust_royalty(string player, int amt);
class craft_sellable create_craft_sellable();
void adjust_royalty(string player, int amt);
class craft_object query_class_of_shop_object(object ob);
object find_shop_object(class craft_object frog);
object *query_sell_list_obs();
string query_id_of_shop_object(object ob);
void remove_shop_id(string id);
private void setup_timeout_call();
object* query_items_with_shop_id(string id);
void create() {
   _sell_list = clone_object("/std/container");
   _current_save_num = 1;
   _current_ids = ({ });
   _categories = ([ ]);
}
void set_dont_use_name(int flag) {
   _category_dont_use_name = flag;
}
int query_dont_use_name() {
   return _category_dont_use_name;
}
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   mixed tmp;
   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = evaluate(_load_function,
                        CRAFT_SHOP_DATA_SAVE_FILE,
                        "" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   evaluate(_save_function,
            CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "" + fixed_num);
   return fixed_num;
}
protected object create_real_auto_load_object(int num, object player) {
   mixed *auto_load;
   object *obs;
   auto_load = evaluate(_load_function,
                        CRAFT_SHOP_DATA_SAVE_FILE,
                        "" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
protected void remove_auto_load_file(int num) {
   evaluate(_save_function,
            CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
            0,
            "" + num);
}
protected void add_to_sellables(string name,
                                string owner,
                                class craft_object *ob) {
   class craft_sellable craft_sell;
   if (_sellables[name]) {
      craft_sell = (class craft_sellable)_sellables[name];
   } else {
      craft_sell = create_craft_sellable();
      _sellables[name] = craft_sell;
   }
   if (!craft_sell->objects[owner]) {
      craft_sell->objects[owner] = ({ });
   }
   craft_sell->objects[owner] += ob;
   update_sellable(name);
}
int add_list_object(object ob,
                    string name,
                    int cost,
                    string owner,
                    string category,
                    int dont_update_cost) {
   class craft_object craft_ob;
   string cap_owner;
   if (!objectp(ob) || !stringp(name) || !intp(cost)) {
      return 0;
   }
   cap_owner = owner;
   owner = lower_case(owner);
   add_to_sellables(name,
                    owner,
                    ({ create_craft_object(ob, cap_owner, cost, category) }));
   if (!dont_update_cost) {
      foreach (craft_ob in ((class craft_sellable)_sellables[name])->objects[owner]) {
         craft_ob->cost = cost;
         craft_ob->category = category;
      }
   }
   save_it();
   return 1;
}
void remove_list_object(string name, string owner, class craft_object ob) {
   int i;
   object us;
   class craft_object *data;
   if (_sellables[name] &&
       ((class craft_sellable)_sellables[name])->objects[owner]) {
      data = ((class craft_sellable)_sellables[name])->objects[owner];
      for (i = 0; i < sizeof(data); i++) {
         if (data[i] == ob) {
            break;
         }
      }
      if (i < sizeof(data)) {
         ((class craft_sellable)_sellables[name])->objects[owner] -= ({ ob });
         if (!sizeof(((class craft_sellable)_sellables[name])->objects[owner])) {
            map_delete(((class craft_sellable)_sellables[name])->objects, owner);
            if (!sizeof(((class craft_sellable)_sellables[name])->objects)) {
               map_delete(_sellables, name);
               us = find_shop_object(ob);
               remove_shop_id(query_id_of_shop_object(us));
            }
         }
         save_it();
         remove_auto_load_file(ob->ob_num);
         us = find_shop_object(ob);
         us->dest_me();
      } else {
         printf("Unable to find the object to remove? %O, %O\n", name, owner);
      }
   }
}
object create_real_object(object player, class craft_object craft) {
   return create_real_auto_load_object(craft->ob_num, player);
}
object *create_all_real_objects(object player, object *obs) {
   object *ret;
   object ob;
   class craft_object craft;
   object new_ob;
   ret = ({ });
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      new_ob = create_real_object(player, craft);
      if (!new_ob) {
         ret->move("/room/rubbish");
         return ({ });
      }
      ret += ({ new_ob });
   }
   return ret;
}
class craft_object create_craft_object(object ob,
                                       string owner,
                                       int cost,
                                       string category) {
   class craft_object craft;
   int num;
   craft = new (class craft_object);
   num = create_auto_load_file(ob, 0);
   craft->ob_num = num;
   craft->cost = cost;
   craft->cap_owner = owner;
   craft->category = category;
   craft->short = ob->query_short();
   return craft;
}
class craft_sellable create_craft_sellable() {
   class craft_sellable craft;
   craft = new(class craft_sellable);
   craft->objects = ([ ]);
   return craft;
}
string query_owner_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_OWNER_PROP);
}
string query_name_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_NAME_PROP);
}
string query_id_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_ID_PROP);
}
void set_id_of_shop_objects(object *obs, string id) {
   obs->add_property(SELL_OBJECT_ID_PROP, id);
   obs->add_alias(id);
}
string query_category_of_shop_object(object ob) {
   class craft_object craft;
   craft = query_class_of_shop_object(ob);
   if (craft) {
      return craft->category;
   }
   return 0;
}
string query_short_of_shop_object(object ob) {
   class craft_object craft;
   craft = query_class_of_shop_object(ob);
   if (craft) {
      if (sizeof(craft) == 5) {
         return craft->short;
      }
      return "womble";
   }
   return 0;
}
void update_craft_object(object craft_ob, object replacement_ob) {
   class craft_object craft;
   craft = query_class_of_shop_object(craft_ob);
   if (craft) {
      create_auto_load_file(replacement_ob, craft->ob_num);
   }
}
string query_next_shop_id() {
   int num;
   num = 0;
   while (member_array(num, _current_ids) != -1) {
      num++;
   }
   _current_ids += ({ num });
   return sprintf("%c%c", (num / 26) + 'a',
                          (num % 26) + 'a');
}
void remove_shop_id(string id) {
   int real_id;
   real_id = (id[0] * 26) - 'a' + id[1] - 'a';
   _current_ids -= ({ real_id });
}
class craft_object query_class_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_CLASS_PROP);
}
object find_shop_object(class craft_object frog) {
   object ob;
   foreach (ob in query_sell_list_obs()) {
      if (query_class_of_shop_object(ob) == frog) {
         return ob;
      }
   }
   return 0;
}
void change_value_of_shop_object(object ob, int value) {
   string owner;
   string name;
   class craft_object wombat;
   object* obs;
   obs = query_items_with_shop_id(query_id_of_shop_object(ob));
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      wombat = query_class_of_shop_object(ob);
      wombat->cost = value;
      ob->set_value(value);
   }
   save_it();
}
int change_name_of_shop_object(object ob, string new_name,
                               int dont_update_cost) {
   string owner;
   string name;
   object* obs;
   string* names;
   class craft_object wombat;
   int new_cost;
   class craft_object* fluff;
   int i;
   obs = query_items_with_shop_id(query_id_of_shop_object(ob));
   names = ({ });
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      wombat = query_class_of_shop_object(ob);
      if (!_sellables[name]) {
tell_creator("pinkfish", "The name %O does not exist.\n", name);
         return 0;
      }
      if (!wombat) {
tell_creator("pinkfish", "Unable to find the class.\n");
         return 0;
      }
      if (!dont_update_cost &&
          _sellables[new_name] &&
          (((class craft_sellable)_sellables[new_name])->objects[owner])) {
         new_cost = (((class craft_sellable)_sellables[new_name])->objects[owner])[0]->cost;
         wombat->cost = new_cost;
      }
      if (!_sellables[new_name]) {
         _sellables[new_name] = create_craft_sellable();
      }
      if (!(((class craft_sellable)_sellables[new_name])->objects[owner])) {
         (((class craft_sellable)_sellables[new_name])->objects[owner]) = ({ });
      }
      (((class craft_sellable)_sellables[new_name])->objects[owner]) += ({ wombat });
      fluff = ((class craft_sellable)_sellables[name])->objects[owner];
      for (i = 0; i < sizeof(fluff); i++) {
         if (fluff[i] == wombat) {
            fluff = fluff[0..i-1] + fluff[i+1..];
         }
      }
      if (sizeof(fluff)) {
         ((class craft_sellable)_sellables[name])->objects[owner] = fluff;
      } else {
         map_delete(((class craft_sellable)_sellables[name])->objects, owner);
      }
      if (!sizeof(((class craft_sellable)_sellables[name])->objects)) {
         map_delete(_sellables, name);
      }
      names |= ({ name });
   }
   if (sizeof(names)) {
      update_sellable(name);
      update_sellable(new_name);
      save_it();
      return 1;
   }
   return 0;
}
int change_category_of_shop_object(object ob, string new_category) {
   string owner;
   string name;
   class craft_object bing;
   object* obs;
   int do_save;
   obs = query_items_with_shop_id(query_id_of_shop_object(ob));
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      if (!_sellables[name] ||
          !((class craft_sellable)_sellables[name])->objects[owner]) {
         return 0;
      }
      foreach (bing in ((class craft_sellable)_sellables[name])->objects[owner]) {
         bing->category = new_category;
         do_save = 1;
      }
   }
   if (do_save) {
      save_it();
   }
   return 1;
}
void remove_shop_object(object ob) {
   string name;
   string owner;
   owner = query_owner_of_shop_object(ob);
   name = query_name_of_shop_object(ob);
   remove_list_object(name, owner, query_class_of_shop_object(ob));
}
class obj_match find_matching_objects(string str) {
   class obj_match obs;
   obs = (class obj_match)match_objects_in_environments(str, ({ _sell_list }));
   return obs;
}
int value_of_objects(object *obs) {
   object ob;
   class craft_object craft;
   int value;
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      if (craft) {
         value += craft->cost;
      }
   }
   return value;
}
object *sell_objects(object *obs, string place, object player, int cut) {
   object ob;
   object this_ob;
   object *sold;
   class craft_object craft;
   sold = ({ });
   if (cut < 0) {
      cut = 0;
   }
   if (cut > 100) {
      cut = 100;
   }
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      if (craft) {
         if (player->query_value_in(place) >= craft->cost) {
            this_ob = create_real_object(player, craft);
            if (this_ob && this_ob->move(player) == MOVE_OK) {
               sold += ({ this_ob });
               player->pay_money(
                       MONEY_HAND->create_money_array(craft->cost, place),
                       place);
               adjust_royalty(query_owner_of_shop_object(ob),
                              craft->cost - (craft->cost * cut) / 100);
               remove_shop_object(ob);
            }
         }
      }
   }
   return sold;
}
void delete_objects( string id ) {
   object ob, *obs;
   obs = all_inventory( _sell_list );
   obs = filter( obs,
         (: $1->query_property( SELL_OBJECT_ID_PROP ) == $(id) :) );
   foreach( ob in obs ) {
      remove_shop_object( ob );
   }
}
object *buy_objects(object *obs,
                    string name,
                    int cost,
                    string owner,
                    string category,
                    int dont_update_costs) {
   object ob;
   object *bought;
   bought = ({ });
   foreach (ob in obs) {
      if (add_list_object(ob, name, cost, owner, category, dont_update_costs)) {
         ob->move("/room/rubbish");
         bought += ({ ob });
      }
   }
   return bought;
}
protected object create_dummy_object(string owner, string name, int cost,
                                     class craft_object craft) {
   object new_name;
   string *bits;
   new_name = clone_object("/std/object");
   new_name->reset_get();
   bits = explode(lower_case(name), " ");
   if (!sizeof (bits)) {
    new_name->set_name("error");
   }
   else {
    new_name->set_name(bits[<1]);
    new_name->add_adjective(bits[0..<2]);
   }
   if (member_array(lower_case(owner), bits) == -1) {
      new_name->add_adjective(owner);
   }
   if (!_category_dont_use_name &&
       member_array(lower_case(owner) + "'s", bits) == -1) {
      new_name->add_adjective(lower_case(owner) + "'s");
      new_name->set_short(craft->cap_owner + "'s " + name);
   } else {
      new_name->set_short(capitalize(name));
   }
   new_name->add_property(SELL_OBJECT_NAME_PROP, name);
   new_name->add_property(SELL_OBJECT_OWNER_PROP, owner);
   new_name->add_property(SELL_OBJECT_CLASS_PROP, craft);
   new_name->add_property("determinate", "");
   new_name->set_value(cost);
   return new_name;
}
private void add_sell_object(object ob) {
   if (ob->move(_sell_list) != MOVE_OK) {
      printf("Unable to move %O into the sell list (%O).\n", ob, _sell_list);
   }
}
object *query_sell_list_obs() {
   return all_inventory(_sell_list);
}
object query_sell_list() {
   return _sell_list;
}
object* query_items_with_shop_id(string id) {
   return filter(query_sell_list_obs(), (: query_id_of_shop_object($1) == $2 :),
                 id);
}
private void update_sellable(string name) {
   string owner;
   class craft_sellable bing;
   mixed *data;
   class craft_object womble;
   class craft_object craft;
   object shop_ob;
   string id;
   mixed *need_ids;
   int cost;
   mapping costs;
   int pos;
   if (_sellables[name]) {
      bing = _sellables[name];
      costs = ([ ]);
      foreach (owner, data in bing->objects) {
         id = 0;
         data = filter(data, (: $1 :));
         bing->objects[owner] = data;
         pos = 0;
         foreach (womble in data) {
            if (sizeof(womble) == 4) {
               craft = new(class craft_object);
               craft->ob_num = womble->ob_num;
               craft->cost = womble->cost;
               craft->cap_owner = womble->cap_owner;
               craft->category = womble->category;
               craft->short = "womble";
               data[pos] = craft;
            }
            pos++;
            shop_ob = find_shop_object(womble);
            if (!shop_ob ||
                query_name_of_shop_object(shop_ob) != name) {
               if (shop_ob) {
                  shop_ob->move("/room/rubbish");
               }
               add_sell_object(create_dummy_object(owner, name,
                                                   womble->cost, womble));
            }
            shop_ob = find_shop_object(womble);
            if (!costs[womble->cost]) {
               costs[womble->cost] = ({ 0, ({ }) });
            }
            if (!costs[womble->cost][0]) {
               id = query_id_of_shop_object(shop_ob);
               if (id) {
                  costs[womble->cost][0] = id;
               }
            }
            if (!costs[womble->cost][0] ||
                query_id_of_shop_object(shop_ob) != costs[womble->cost][0]) {
               costs[womble->cost][1] += ({ shop_ob });
            }
         }
         if (!_category_dont_use_name) {
            foreach (cost, need_ids in costs) {
               if (!need_ids[0]) {
                  need_ids[0] = query_next_shop_id();
               }
               set_id_of_shop_objects(need_ids[1], need_ids[0]);
            }
         }
      }
      if (_category_dont_use_name) {
         foreach (cost, need_ids in costs) {
            if (!need_ids[0]) {
               need_ids[0] = query_next_shop_id();
            }
            set_id_of_shop_objects(need_ids[1], need_ids[0]);
         }
      }
   }
}
string *query_owner_sellables(string owner) {
   class craft_sellable sell;
   mixed *womble;
   string *ret;
   string name;
   ret = ({ });
   foreach (name, sell in _sellables) {
      if (sell->objects[owner]) {
         womble = sell->objects[owner];
         ret += allocate(sizeof(womble), (: $(name) :) );
      }
   }
   return ret;
}
int query_list_object_cost(string name, string owner) {
   class craft_sellable sell;
   class craft_object wombat;
   owner = lower_case(owner);
   if (_sellables[name]) {
      sell = _sellables[name];
      if (sell->objects[owner]) {
         wombat = sell->objects[owner][0];
         return wombat->cost;
      }
   }
   return 0;
}
void set_save_function(function func) {
   _save_function = func;
}
void set_load_function(function func) {
   _load_function = func;
}
void set_category_function(function func) {
   _category_function = func;
}
void save_it() {
   if (_has_loaded) {
      evaluate(_save_function, CRAFT_SHOP_MAIN_SAVE_FILE,
            ({ _sellables, _royalties, _current_save_num, _categories }) );
   }
}
void load_it() {
   mixed *map;
   string name;
   _has_loaded = 1;
   map = evaluate(_load_function, CRAFT_SHOP_MAIN_SAVE_FILE);
   if (pointerp(map) && sizeof(map) == 3) {
      _sellables = map[0];
      _royalties = map[1];
      _current_save_num = map[2];
      foreach (name in keys(_sellables)) {
         reset_eval_cost();
         update_sellable(name);
      }
   } else if (pointerp(map) && sizeof(map) == 4) {
      _sellables = map[0];
      _royalties = map[1];
      _current_save_num = map[2];
      _categories = map[3];
      foreach (name in keys(_sellables)) {
         reset_eval_cost();
         update_sellable(name);
      }
   } else {
      _sellables = ([ ]);
      _royalties = ([ ]);
   }
   setup_timeout_call();
}
void adjust_royalty(string player, int amt) {
   _royalties[player] += amt;
   save_it();
}
int query_royalty(string player) {
  return _royalties[player];
}
mapping query_all_royalties() {
   return copy(_royalties);
}
void pay_out_royalty(string player, string place, int amount) {
   object pl;
   pl = find_player(player);
   if (pl && _royalties[player]) {
      if (!amount) {
         amount = _royalties[player];
      }
      pl->adjust_money(MONEY_HAND->create_money_array(amount, place));
      _royalties[player] -= amount;
      if (!_royalties[player]) {
         map_delete(_royalties, player);
      }
      save_it();
   }
}
int is_valid_category(string category) {
   if (_categories[category] &&
       (_categories[category]->state == CRAFT_CATEGORY_STATE_ACCEPTED ||
        _categories[category]->state == CRAFT_CATEGORY_STATE_DELETEING)) {
      return 1;
   }
   return 0;
}
int add_category_request(string name,
                         object player,
                         int timeout) {
   if (!_categories[name]) {
      _categories[name] = new(class craft_category);
      _categories[name]->state = CRAFT_CATEGORY_STATE_NOMINATING;
      _categories[name]->voted = ({ player->query_name() });
      _categories[name]->description = 0;
      _categories[name]->yes = 0;
      _categories[name]->no = 0;
      _categories[name]->timeout = time() + timeout;
      save_it();
      return 1;
   }
   return 0;
}
int remove_category_accepted(string category) {
   if (_categories[category]) {
      map_delete(_categories, category);
      save_it();
      return 1;
   }
   return 0;
}
int add_category_accepted(string name) {
   if (!_categories[name]) {
      _categories[name] = new(class craft_category);
      _categories[name]->state = CRAFT_CATEGORY_STATE_ACCEPTED;
      _categories[name]->voted = ({ });
      _categories[name]->description = 0;
      _categories[name]->yes = 0;
      _categories[name]->no = 0;
      _categories[name]->timeout = 0;
      save_it();
      return 1;
   }
   return 0;
}
void set_category_description(string cat, string desc) {
   if (_categories[cat]) {
      _categories[cat]->description = desc;
      save_it();
   }
}
string query_category_description(string cat) {
   if (_categories[cat]) {
      if (stringp(_categories[cat]->description)) {
         return _categories[cat]->description;
      }
   }
   return 0;
}
void set_category_information(string cat, string info) {
   if (_categories[cat]) {
      _categories[cat]->information = info;
      save_it();
   }
}
string query_category_information(string cat) {
   if (_categories[cat]) {
      if (stringp(_categories[cat]->information)) {
         return _categories[cat]->information;
      }
   }
}
string query_category_of(string name, string owner) {
   if (_sellables[name] &&
       sizeof( ((class craft_sellable)_sellables[name])->objects[owner])) {
      return ((class craft_sellable)_sellables[name])->objects[owner][0]->category;
   }
   return 0;
}
int has_voted_for_category(string name,
                           object player) {
   return _categories[name] &&
       member_array(player->query_name(), _categories[name]->voted) != -1;
}
int query_category_timeout(string name) {
   if (_categories[name]) {
      return _categories[name]->timeout;
   }
   return CRAFT_CATEGORY_ERROR;
}
int vote_for_category(string name,
                      object player,
                      int choice) {
   if (_categories[name]) {
      if (!has_voted_for_category(name, player)) {
         if (choice == CRAFT_CATEGORY_CHOICE_YES ||
             choice == CRAFT_CATEGORY_CHOICE_NO ||
             choice == CRAFT_CATEGORY_CHOICE_ABSTAIN) {
            switch (choice) {
            case CRAFT_CATEGORY_CHOICE_YES :
               _categories[name]->yes++;
               break;
            case CRAFT_CATEGORY_CHOICE_NO :
               _categories[name]->no++;
               break;
            case CRAFT_CATEGORY_CHOICE_ABSTAIN :
               _categories[name]->abstain++;
               break;
            }
            _categories[name]->voted += ({ player->query_name() });
            save_it();
         }
      }
   }
   return 0;
}
string* query_categories() {
   return filter(keys(_categories), (: is_valid_category($1) :));
}
private void do_timeout_categories() {
   string name;
   class craft_category cat;
   int timeout;
   foreach (name, cat in _categories) {
      if (cat->state != CRAFT_CATEGORY_STATE_ACCEPTED &&
          cat->timeout &&
          cat->timeout < time()) {
         timeout = evaluate(_category_function,
                            cat->state,
                            cat->voted,
                            cat->yes,
                            cat->no,
                            cat->abstain);
         if (timeout) {
            cat->voted = ({ });
            cat->yes = 0;
            cat->no = 0;
            switch (cat->state) {
            case CRAFT_CATEGORY_STATE_NOMINATING :
               cat->state = CRAFT_CATEGORY_STATE_VOTING;
               cat->timeout = time() + timeout;
               break;
            case CRAFT_CATEGORY_STATE_VOTING :
               cat->state = CRAFT_CATEGORY_STATE_ACCEPTED;
               cat->timeout = 0;
               break;
            case CRAFT_CATEGORY_STATE_DELETEING :
               map_delete(_categories, name);
               break;
            }
         } else {
            switch (cat->state) {
            case CRAFT_CATEGORY_STATE_VOTING :
            case CRAFT_CATEGORY_STATE_NOMINATING :
               map_delete(_categories, name);
               break;
            case CRAFT_CATEGORY_STATE_DELETEING :
               cat->state = CRAFT_CATEGORY_STATE_ACCEPTED;
               cat->timeout = 0;
               cat->voted = ({ });
               cat->yes = 0;
               cat->no = 0;
               break;
            }
         }
      }
   }
   save_it();
   setup_timeout_call();
}
private void setup_timeout_call() {
   string name;
   class craft_category cat;
   int bing;
   foreach (name, cat in _categories) {
      if (cat->state != CRAFT_CATEGORY_STATE_ACCEPTED &&
          cat->timeout != 0 &&
          cat->timeout < bing) {
         bing = cat->timeout;
      }
   }
   if (_category_callout) {
      remove_call_out(_category_callout);
   }
   if (bing) {
      _category_callout = call_out((: do_timeout_categories() :), bing);
   }
}
void dest_me() {
  if(_sell_list) {
    all_inventory(_sell_list)->move("/room/rubbish");
    _sell_list->dest_me();
  }
  destruct(this_object());
}

==================================================
FILE: shops/inherit/auction_house.c
==================================================

#include <room/auction.h>
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <mail.h>
#include <player_handler.h>
#include <am_time.h>
inherit "/std/shops/inherit/shop_event";
inherit "/std/shops/inherit/open_shop";
#define DEFAULT_QUICK_AUCTION_LENGTH (15 * 60)
#define DEFAULT_SHORT_AUCTION_LENGTH (60 * 60)
#define DEFAULT_MEDIUM_AUCTION_LENGTH (AM_SECONDS_PER_DAY)
#define DEFAULT_LONG_AUCTION_LENGTH (AM_SECONDS_PER_DAY * 3)
#define DEFAULT_VERY_LONG_AUCTION_LENGTH (AM_SECONDS_PER_DAY * 14)
#define DEFAULT_RETRIEVAL_TIME (AM_SECONDS_PER_DAY * 7)
#define DEFAULT_EXTENSION_TIME (20 * 60)
class auction {
   mixed save_stuff;
   int time_started;
   int auction_length;
   string name;
   string seller;
   string current_bidder;
   int bid;
   int reserve;
   int retries;
   string end_function;
   mixed extra;
}
private nosave mixed* _auction_obs;
private nosave int _callout_id;
private nosave string _save_file;
private nosave int _max_auctions;
private nosave mapping _auction_times;
private nosave int _retrieval_time;
private nosave int _max_retries;
private nosave int _cut;
private nosave int _minimum_bid_increase;
private nosave function _can_bid;
private nosave int _allow_add;
private nosave string _bid_type_names;
private class auction* _auctions;
private class auction* _finished_auctions;
private mapping _royalties;
void next_auction_finish();
mixed query_property(string name);
class auction query_auction_item(string id);
void retry_auction(class auction auction);
void create() {
   _auctions = ({ });
   _finished_auctions = ({ });
   _cut = 10;
   _max_auctions = 20;
   _auction_obs = ({ });
   _royalties = ([ ]);
   _auction_times = ([
                      "quick" : DEFAULT_QUICK_AUCTION_LENGTH,
                      "short" : DEFAULT_SHORT_AUCTION_LENGTH,
                      "medium" : DEFAULT_MEDIUM_AUCTION_LENGTH,
                      "long" : DEFAULT_LONG_AUCTION_LENGTH,
                      "very long" : DEFAULT_VERY_LONG_AUCTION_LENGTH
                    ]);
   _retrieval_time = DEFAULT_RETRIEVAL_TIME;
   _max_retries = 5;
   _minimum_bid_increase = 10;
   _allow_add = 1;
   shop_event::create();
}
class auction *query_auctions() { return copy(_auctions); }
class auction *query_finished_auctions() { return copy(_finished_auctions); }
void load_me() {
   unguarded( (: restore_object(_save_file, 1) :));
   _auction_obs = allocate(sizeof(_auctions));
   if (!_royalties) {
      _royalties = ([ ]);
   }
   next_auction_finish();
}
void save_me() {
   unguarded( (: save_object(_save_file) :));
}
void set_save_file(string fname) {
   _save_file = fname;
   load_me();
}
string query_save_file() {
   return _save_file;
}
void set_check_can_bid(function f) {
   _can_bid = f;
}
void set_allowed_add(int flag) {
   _allow_add = flag;
}
void set_max_auctions(int i) { _max_auctions = i; }
void set_auction_time(string index, int i) {
   if (!i) {
      map_delete(_auction_times, index);
   } else {
      if (!_auction_times[index]) {
         _bid_type_names = 0;
      }
      _auction_times[index] = i;
   }
}
mapping query_auction_times() { return _auction_times; }
void set_retrieval_time(int i) { _retrieval_time = i; }
void set_max_retries(int i) { _max_retries = i; }
void set_min_bid_increase(int i) { _minimum_bid_increase = i; }
int add_item_to_auction(object* obs, string name, int reserve,
                        string seller, int length,
                         string end_function, mixed extra) {
   class auction new_auct;
   if (sizeof(_auctions) + sizeof(_finished_auctions) >= _max_auctions) {
      return 0;
   }
   if (!reserve) {
      reserve = 40;
   }
   new_auct = new(class auction);
   new_auct->save_stuff = AUTO_LOAD_OB->create_auto_load(obs);
   new_auct->name = name;
   new_auct->reserve = reserve;
   new_auct->end_function = end_function;
   new_auct->time_started = time();
   if (!length) {
      new_auct->auction_length = _auction_times["very long"];
   } else {
      new_auct->auction_length = length;
   }
   new_auct->seller = seller;
   new_auct->extra = extra;
   _auctions += ({ new_auct });
   _auction_obs += ({ obs });
   save_me();
   next_auction_finish();
   _auction_obs -= ({ obs });
   _auction_obs += ({ 0 });
   return 1;
}
object* query_auction_objects(class auction auct) {
   int i;
   for (i = 0; i < sizeof(_auctions); i++) {
      if (_auctions[i] == auct) {
         if (!_auction_obs[i]) {
            _auction_obs[i] = AUTO_LOAD_OB->load_auto_load_to_array(auct->save_stuff);
         }
         return _auction_obs[i];
      }
   }
   return ({ });
}
void bid_on_item(class auction auct,
                 int bid, string person) {
    if (bid > auct->bid && bid >= auct->reserve) {
        auct->bid = bid;
        auct->current_bidder = person;
        if (auct->auction_length + auct->time_started - time() <
            DEFAULT_EXTENSION_TIME) {
            auct->auction_length = time() - auct->time_started +
                DEFAULT_EXTENSION_TIME;
        }
    }
}
int reset_bid(string id, int bid, string person) {
  class auction auct;
  if(!(this_player()->query_lord()))
    return 0;
  auct = query_auction_item(id);
  if(!auct)
    return 0;
  auct->bid = bid;
  auct->current_bidder = person;
  return 1;
}
void remove_finished_auction_item(class auction auction) {
   int i;
   for (i = 0; i < sizeof(_finished_auctions); i++) {
      if (_finished_auctions[i] == auction) {
         _finished_auctions = _finished_auctions[0..i-1] + _finished_auctions[i+1..];
      }
   }
}
void remove_auction_item(class auction auction) {
   int i;
   for (i = 0; i < sizeof(_auctions); i++) {
      if (_auctions[i] == auction) {
         if (i < sizeof(_auction_obs) && _auction_obs[i]) {
            ((_auction_obs[i]) - ({ 0 }))->move("/room/rubbish");
         }
         _auctions = _auctions[0..i-1] + _auctions[i+1..];
         _auction_obs = _auction_obs[0..i-1] + _auction_obs[i+1..];
      }
   }
}
void finish_auction(class auction auction) {
   string place;
   if (auction->end_function) {
      call_other(this_object(), auction->end_function,
                 AUCTION_FINISH_PHASE, auction, auction->extra,
                 auction->current_bidder, auction->bid);
   }
   place = query_property("place");
   remove_auction_item(auction);
   if (!auction->current_bidder) {
      auction->current_bidder = auction->seller;
      auction->bid = 4000;
   }
   _finished_auctions += ({ auction });
   save_me();
   if (auction->current_bidder &&
       PLAYER_HANDLER->test_user(lower_case(auction->current_bidder))) {
      AUTO_MAILER->auto_mail(lower_case(auction->current_bidder),
                              this_object()->query_short(),
                              "Results of auction for " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed.\nPlease pay the " +
                              MONEY_HAND->money_value_string(auction->bid, place) +
                              " as soon as you can.\n", 0, auction->current_bidder);
   } else {
      retry_auction(auction);
   }
   return ;
}
void force_finish_auction(string id) {
   string place;
   class auction auction;
   auction = query_auction_item(id);
   if (auction->end_function) {
      call_other(this_object(), auction->end_function,
                 AUCTION_FINISH_PHASE, auction, auction->extra,
                 auction->current_bidder, auction->bid);
   }
   place = query_property("place");
   remove_auction_item(auction);
   if (!auction->current_bidder) {
      auction->current_bidder = auction->seller;
      auction->bid = 4000;
   }
   _finished_auctions += ({ auction });
   save_me();
   if (auction->current_bidder &&
       PLAYER_HANDLER->test_user(lower_case(auction->current_bidder))) {
      AUTO_MAILER->auto_mail(lower_case(auction->current_bidder),
                              this_object()->query_short(),
                              "Results of auction for " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed.\nPlease pay the " +
                              MONEY_HAND->money_value_string(auction->bid, place) +
                              " as soon as you can.\n");
   }
   return ;
}
void retry_auction(class auction auction) {
   string place;
   if (auction->end_function) {
      call_other(this_object(), auction->end_function,
                 AUCTION_RETRY_PHASE, auction, auction->extra);
   }
   place = query_property("place");
   remove_finished_auction_item(auction);
   auction->bid = 0;
   auction->current_bidder = 0;
   auction->retries++;
   auction->time_started = time();
   if (auction->retries > _max_retries) {
   } else {
      _auctions += ({ auction });
      _auction_obs += ({ 0 });
   }
   save_me();
   if (auction->seller &&
       PLAYER_HANDLER->test_user(lower_case(auction->seller))) {
      AUTO_MAILER->auto_mail(lower_case(auction->seller),
                              this_object()->query_short(),
                              "Default on auction of " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed and the payee defaulted.\n"
                              "The item has been put up for reauctioning.\n");
   }
   return ;
}
class auction query_auction_item(string id) {
   id = lower_case(id);
   if (strlen(id) == 1 &&
       id[0] >= 'a' && id[0] < 'a' + sizeof(_auctions)) {
      return _auctions[id[0] - 'a'];
   }
   return 0;
}
string query_time_end_string(int left) {
   string str;
   string extra;
   if (left >= AM_SECONDS_PER_DAY) {
      str = (left / AM_SECONDS_PER_DAY) + " day";
      if ((left / AM_SECONDS_PER_DAY) > 1) {
         str += "s";
      }
      left = left % (AM_SECONDS_PER_DAY);
      if (left >= (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) {
         if ((left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) > 1) {
             extra = "s";
          } else {
             extra = "";
         }
         return str + " and " +
           (left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) + " hour" +
           extra;
      }
      return str;
   } else if (left >= AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR) {
      if ((left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) > 1) {
          extra = "s";
       } else {
          extra = "";
      }
      str = (left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) + " hour" +
            extra;
      left %= AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR;
      if ((left / (AM_SECONDS_PER_MINUTE)) > 1) {
          extra = "s";
       } else {
          extra = "";
      }
      if (left > AM_SECONDS_PER_MINUTE) {
         return str + " and " + (left / AM_SECONDS_PER_MINUTE) + " minute" +
                extra;
      }
      return str;
   } else if (left <= 0) {
      return "already finished";
   }
    if( !(left/60) ) {
        return "less than a minute";
    }
    else {
        str = "";
        str += ( left / 60) + " minute";
        if (left / 60 > 1) {
            str += "s";
        }
        return str;
    }
}
string query_auction_end_string(class auction auction) {
   return query_time_end_string(auction->time_started +
                                auction->auction_length - time());
}
int query_last_auction_finish_time() {
   int tim;
   class auction auction;
   foreach (auction in _auctions) {
      if (tim < auction->time_started + auction->auction_length) {
         tim = auction->time_started + auction->auction_length;
      }
   }
   return tim;
}
void next_auction_finish() {
   class auction auct;
   int next;
   int tmp;
   next = 0;
   foreach (auct in _auctions) {
      tmp = auct->time_started + auct->auction_length - time();
      if (tmp <= 0) {
         finish_auction(auct);
      } else if (tmp < next || !next) {
         next = tmp;
      }
   }
   foreach (auct in _finished_auctions) {
      tmp = auct->time_started + auct->auction_length + _retrieval_time -
        time();
      if (tmp <= 0) {
         retry_auction(auct);
         tmp = auct->time_started + auct->auction_length - time();
         if (tmp < next || !next) {
            next = tmp;
         }
      } else if (tmp < next || !next) {
         next = tmp;
      }
   }
   if (_callout_id) {
      remove_call_out(_callout_id);
      _callout_id = 0;
   }
   if (next) {
      _callout_id = call_out("next_auction_finish", next);
   }
}
int do_list() {
   string str;
   class auction bing;
   int pos;
   string place;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   if (!sizeof(_auctions)) {
      add_failed_mess("Nothing currently on auction.\n");
      return 0;
   }
   place = query_property("place");
   str = "Items currently up for auction:\n";
   foreach (bing in _auctions) {
      str += sprintf("%c) %s", pos + 'A', bing->name);
      if (bing->current_bidder) {
         str += "; " +
                MONEY_HAND->money_value_string(bing->bid, place) +
                " by " + bing->current_bidder + "; finishes in " +
                query_auction_end_string(bing) + ".\n";
      } else {
         str += "; no current bid; finishes in " +
                query_auction_end_string(bing) + ".\n";
      }
      pos++;
   }
   if (!broadcast_shop_event(AUCTION_EVENT_LIST,
                             this_player(), str)) {
      write("$P$Auctions$P$" + str);
   }
   return 1;
}
int do_browse(string id) {
   class auction bing;
   string place;
   string str;
   object* obs;
   object ob;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   bing = query_auction_item(id);
   if (!bing) {
      add_failed_mess("There is no auction item " + id + ".\n");
      return 0;
   }
   place = query_property("place");
   str = "Auction called " + bing->name + " started at " +
        amtime(bing->time_started) + " finishes at " +
        amtime(bing->time_started + bing->auction_length) + " (in " +
        query_auction_end_string(bing) + ".\n";
   str += "Reserve price " +
          MONEY_HAND->money_value_string(bing->reserve, place);
   if (bing->bid) {
      str += "; current bid " +
             MONEY_HAND->money_value_string(bing->bid, place) +
             " by " + bing->current_bidder + ".\n";
   } else {
      str += "; no current bid.\n";
   }
   obs = query_auction_objects(bing);
   foreach (ob in obs) {
      str += "\n$I$0=$C$" + ob->the_short() + ":\n$I$3=   " +
             ob->long();
      if (ob->query_readable_message(this_player())) {
         str += "$I$0=Read message:\n$I$3=   " + ob->query_readable_message(this_player()) + "\n";
      }
   }
   if (!broadcast_shop_event(AUCTION_EVENT_BROWSE,
                             this_player(), bing, obs, str)) {
      write("$P$Browse Auction$P$" + str);
   }
   return 1;
}
int do_bid(string id, string bid) {
   class auction auct;
   string place;
   int value;
   int inc;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   auct = query_auction_item(id);
   if (!auct) {
      if (!broadcast_shop_event(AUCTION_EVENT_BAD_ITEM,
                                 this_player(), id)) {
         add_failed_mess("There is no auction item " + id + ".\n");
      }
      return 0;
   }
   place = query_property("place");
   value = MONEY_HAND->value_from_string(bid, place);
   if (_can_bid) {
      if (!evaluate(_can_bid, this_player(), auct, value)) {
         return 0;
      }
   }
   inc = auct->bid + ((auct->bid * _minimum_bid_increase) / 100);
   if (value < inc) {
      if (!broadcast_shop_event(AUCTION_EVENT_BID_TOO_SMALL,
                                 this_player(), auct, value, inc)) {
         add_failed_mess("You must bid " + _minimum_bid_increase + "% more than "
                         "the current bid, current bid is " +
                         MONEY_HAND->money_value_string(auct->bid, place) +
                         " so " + _minimum_bid_increase + "% more is " +
                         MONEY_HAND->money_value_string(inc, place) +
                         ".\n");
      }
      return 0;
   }
   if (value < auct->reserve) {
      if (!broadcast_shop_event(AUCTION_EVENT_BID_BELOW_RESERVE,
                                 this_player(), auct, value, auct->reserve)) {
         add_failed_mess("You must bid more than the reserve bid, it is " +
                      MONEY_HAND->money_value_string(auct->reserve, place) + ".\n");
      }
      return 0;
   }
   bid_on_item(auct, value, this_player()->query_cap_name());
   save_me();
   if (!broadcast_shop_event(AUCTION_EVENT_BID,
                             this_player(), auct, value)) {
      add_succeeded_mess("$N $V " +
                         MONEY_HAND->money_value_string(value, place) +
                         " on " + auct->name + ".\n");
   }
   return 1;
}
int do_withdraw(string id) {
   class auction auct;
   string place;
   int value;
   object* obs;
   object ob;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   auct = query_auction_item(id);
   if (!auct) {
      if (!broadcast_shop_event(AUCTION_EVENT_BAD_ITEM,
                                 this_player(), id)) {
         add_failed_mess("There is no auction item " + id + ".\n");
      }
      return 0;
   }
   place = query_property("place");
   if (lower_case(auct->seller) == this_player()->query_name() ||
       this_player()->query_creator()) {
      if (auct->reserve > auct->bid) {
         value = auct->reserve;
      } else {
         value = auct->bid;
      }
      if (this_player()->query_value_in(place) < value) {
         if (!broadcast_shop_event(AUCTION_EVENT_TOO_POOR,
                              this_player(), auct,
                              this_player()->query_value_in(place),
                              auct->bid)) {
            add_failed_mess("You need at least " +
                            MONEY_HAND->money_value_string(value, place) +
                            " to withdraw this item from auction.\n");
         }
         return 0;
      }
      obs = query_auction_objects(auct);
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place),
        place);
      remove_auction_item(auct);
      save_me();
      if (auct->end_function) {
         call_other(this_object(), auct->end_function,
                    AUCTION_WITHDRAW_PHASE, auct, auct->extra);
      }
      foreach (ob in obs) {
         if (ob->move(this_player()) != MOVE_OK) {
             ob->move(this_object());
             write("Unable to move " + ob->the_short() +
                   " into your inventory, put on the floor.\n");
         }
      }
      if (!broadcast_shop_event(AUCTION_EVENT_WITHDRAW,
                                 this_player(), auct)) {
         add_succeeded_mess("$N remove$s " + auct->name + " from auction.\n");
      }
      return 1;
   }
   if (!broadcast_shop_event(AUCTION_EVENT_CANNOT_WITHDRAW,
                              this_player(), auct)) {
      add_failed_mess("You cannot withdraw that item from auction.\n");
   }
   return 0;
}
int do_claim() {
   class auction auction;
   int num;
   string place;
   object* obs;
   object ob;
   int i;
   int value;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   place = query_property("place");
   value = this_player()->query_value_in(place);
   foreach (auction in _finished_auctions) {
      if (!auction->current_bidder) {
         remove_finished_auction_item(auction);
      } else if (lower_case(auction->current_bidder) == this_player()->query_name()) {
         if (value < auction->bid) {
            if (!broadcast_shop_event(AUCTION_EVENT_TOO_POOR,
                              this_player(), auction, value, auction->bid)) {
               write("You do not have enough money to pay for " +
                     MONEY_HAND->money_value_string(auction->bid, place) +
                     ".\n");
            }
         } else {
            this_player()->pay_money(
                MONEY_HAND->create_money_array(auction->bid, place), place);
            value -= auction->bid;
            _royalties[lower_case(auction->seller)] += auction->bid -
                                           auction->bid * _cut / 100;
            obs = AUTO_LOAD_OB->load_auto_load_to_array(auction->save_stuff);
            foreach (ob in obs) {
               if (ob->move(this_player()) != MOVE_OK) {
                  ob->move(this_object());
                  write("Unable to move " + ob->the_short() +
                        " into your inventory, put on the floor.\n");
               }
            }
            if (!broadcast_shop_event(AUCTION_EVENT_CLAIM,
                              this_player(), auction, auction->bid, obs)) {
               write("You paid " +
                     MONEY_HAND->money_value_string(auction->bid, place) +
                     " for " +
                     query_multiple_short(obs) + ".\n");
            }
            remove_finished_auction_item(auction);
            save_me();
            if (auction->end_function) {
               call_other(this_object(), auction->end_function,
                          AUCTION_CLAIM_PHASE, auction, auction->extra,
                          auction->current_bidder, auction->bid, obs);
            }
         }
         num++;
      }
      i++;
   }
   if (!num) {
      if (!broadcast_shop_event(AUCTION_EVENT_NOTHING_TO_CLAIM,
                              this_player())) {
         add_failed_mess("You cannot find anything to claim.\n");
      }
   }
   return num;
}
int do_add(string name, object* obs, string res_str, string length) {
   int reserve;
   string ret;
   string place;
   int len;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   place = query_property("place");
   len = _auction_times[length];
   if (sizeof(_auctions) >= _max_auctions) {
      if (!broadcast_shop_event(AUCTION_EVENT_FULL,
                             this_player(), name, obs, reserve, len)) {
         add_failed_mess("The auction house is full.\n");
      }
      return 0;
   }
   if (res_str) {
      reserve = MONEY_HAND->value_from_string(res_str, place);
      if (!reserve) {
         if (!broadcast_shop_event(AUCTION_EVENT_BAD_MONEY,
                             this_player(), name, obs, reserve, len)) {
            add_failed_mess("Unable to figure out how much " + res_str +
                            " is.\n");
         }
         return 0;
      }
   }
   ret = "You are putting " + query_multiple_short(obs) + " up for "
         "auction as " + name + " for " +
          query_time_end_string(len);
   if (reserve) {
     ret += " with a reserve price of " +
            MONEY_HAND->money_value_string(reserve, place);
   }
   if (!broadcast_shop_event(AUCTION_EVENT_ADD_AUCTION,
                             this_player(), name, obs, reserve, len, ret + ".")) {
      write(ret + ".\n");
      write("Are you sure you wish to do this? ");
   }
   input_to("confirm_auction", 0, name, obs, reserve, len);
   add_succeeded_mess(({ "", "$N put$s $I up for auction.\n" }), obs);
   return 1;
}
void confirm_auction(string check, string name, object* obs, int reserve, int len) {
   string place;
   string ret;
   place = query_property("place");
   check = lower_case(check);
   if (!strlen(check) || check[0] != 'y') {
      if (!broadcast_shop_event(AUCTION_EVENT_ADD_ABORT,
                             this_player(), name, obs, reserve, len)) {
         write("Ok, Aborting.\n");
      }
      return ;
   }
   add_item_to_auction(obs, name, reserve,
                       this_player()->query_cap_name(), len, 0, 0);
   ret = "You put " + query_multiple_short(obs) + " up for "
         "auction as " + name + " for " +
          query_time_end_string(len);
   if (reserve) {
     ret += " with a reserve price of " +
            MONEY_HAND->money_value_string(reserve, place) + "";
   }
   if (!broadcast_shop_event(AUCTION_EVENT_CONFIRM_AUCTION,
                             this_player(), name, obs, reserve, len, ret + ".")) {
      write(ret + ".\n");
   }
   obs->move("/room/rubbish");
}
int do_info() {
   string ret;
   string name;
   int len;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   ret = "$I$3=The times for the auction are:\n";
   foreach (name, len in _auction_times) {
      ret += name + ": " + query_time_end_string(len) + "\n";
   }
   if (!broadcast_shop_event(AUCTION_EVENT_INFO, this_player(), ret)) {
      write("$P$Auction lengths$P$" + ret);
   }
   return 1;
}
void init() {
   add_command("list", "", (: do_list() :));
   add_command("browse", "<string'auction id'>", (: do_browse($4[0]) :));
   add_command("bid", "<string'auction id'> for <string'money'>",
               (: do_bid($4[0], $4[1]) :));
   add_command("bid", "<string'money'> on <string'auction id'>",
               (: do_bid($4[1], $4[0]) :));
   add_command("claim", "", (: do_claim() :));
   add_command("withdraw", "<string'auction id'> [from auction]",
                (: do_withdraw($4[0]) :));
   if (_allow_add) {
      if (!_bid_type_names) {
         _bid_type_names = implode(keys(_auction_times), "|");
      }
      add_command("info", "", (: do_info() :));
      add_command("add", "{" + _bid_type_names +
                   "} auction of <indirect:object:me> as <string'name'>",
                  (: do_add($4[2], $1, 0, $4[0]) :));
      add_command("add", "{" + _bid_type_names +
                  "}  auction of <indirect:object:me> as <string'name'> reserve <string'price'>",
                  (: do_add($4[2], $1, $4[3], $4[0]) :));
   }
}

==================================================
FILE: shops/inherit/bank_base.c
==================================================

#include <money.h>
#include <move_failures.h>
#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"
private string _franchise;
private int _total_difference;
private nosave int _account_cost;
private nosave int _percentage;
private nosave string _bank_name;
string query_money_place();
void adjust_float(int amount);
int is_open_for(string type, string person);
void event_save(object ob);
void create() {
  _account_cost = 400;
  _total_difference = 0;
  _percentage = 10;
}
int query_bank() {
   return 1;
}
int query_account_cost() { return _account_cost; }
void set_account_cost( int number ) { _account_cost = number; }
int query_percentage() { return _percentage; }
void set_percentage( int number ) { _percentage = number; }
int query_total_difference() { return _total_difference; }
void adjust_total_difference(int amount) {
   _total_difference += amount;
}
void set_total_difference(int amount) {
   _total_difference = amount;
}
string query_bank_name() { return _bank_name; }
void set_bank_name( string word ) { _bank_name = word; }
int get_account(string player) {
  return HANDLER->query_account( player, _bank_name );
}
void set_account( string player, int amount ) {
  HANDLER->set_account( player, _bank_name, amount );
}
void adjust_account(string person, int amount) {
}
string query_franchise() {
   return _franchise;
}
void set_franchise(string franchise) {
   _franchise = franchise;
}
int can_adjust_account(string person, int amount) {
   if ( ( get_account( person ) + amount ) >= 0 ) {
      return 1;
   }
   add_failed_mess("You do not have enough money to complete the "
                   "transaction.\n");
   return 0;
}
object find_main_bank() {
   object office;
   string room;
   room = BANK_HANDLER->query_bank_master_office(_bank_name);
   if (!room) {
      return 0;
   }
   office = load_object(room);
   if (!office) {
      return 0;
   }
   if (office->query_bank()) {
      return office;
   }
   return 0;
}
string query_main_branch_owner() {
   object branch;
   branch = find_main_bank();
   if (!branch) {
      return "no owner";
   }
   if (branch->query_owner()) {
      return lower_case(branch->query_owner());
   }
   return "no owner";
}
int do_balance() {
  int amount;
   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }
   if (!is_open_for("bank", this_player()->query_name())) {
      add_failed_mess("The bank is not open for withdrawals.\n");
      return 0;
   }
   amount = get_account(this_player()->query_name());
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     add_succeeded_mess(
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }));
    return 1;
  }
  add_succeeded_mess(
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount,
         query_money_place() ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }));
  return 1;
}
int do_withdraw( string type ) {
  int amount;
  int total;
  object money;
   if (this_player()->query_property("dead"))  {
      add_failed_mess("You are dead.  You know what they say; you can't take "
         "it with you.\n");
      return 0;
   }
   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }
   if (!is_open_for("withdraw", this_player()->query_name())) {
      add_failed_mess("The bank is not open for withdrawals.\n");
      return 0;
   }
   total = get_account(this_player()->query_name());
   if ( total < 0 ) {
      notify_fail( "You do not have an account here.\n" );
      return 0;
   }
   amount = MONEY_HAND->value_from_string(type, query_money_place());
   if ( amount <= 0 ) {
      notify_fail( "You must withdraw something.\n" );
      return 0;
   }
   if ( amount > total ) {
      add_failed_mess( "You don't have that much money in your account!\n" );
      return 0;
   }
   if (!can_adjust_account(this_player()->query_name(), -amount)) {
      add_failed_mess("The bank cannot handle this transaction.\n");
      return 0;
   }
   money = MONEY_VAULT->get_money_ob();
   money->set_money_array(MONEY_HAND->create_money_array(amount,
       query_money_place()));
   if (money->move(this_player()) != MOVE_OK)  {
      if (money->move(this_object()) != MOVE_OK) {
         add_failed_mess("Unable to put the money on the floor, cancelling "
               "the transaction.\n");
         money->move("/room/rubbish");
         return 0;
      } else {
         write("You are carrying too much weight to accept your money, "
               "So it is placed on the floor for you.\n");
      }
   }
   set_account(this_player()->query_name(), total - amount );
   adjust_account(this_player()->query_name(), -amount);
   _total_difference -= amount;
   event_save(this_object());
   add_succeeded_mess( ({
      "You withdraw "
      + MONEY_HAND->money_value_string( amount, query_money_place() )
      +".\nYou have "
      + MONEY_HAND->money_value_string( get_account( this_player()->query_name() ),
                                        query_money_place() )
      + " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
   }) );
   this_player()->save();
   return 1;
}
int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   int howmuch;
   mixed money;
   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }
   if (!is_open_for("deposit", this_player()->query_name())) {
      add_failed_mess("The bank is not open for deposits.\n");
      return 0;
   }
   total = get_account(this_player()->query_name());
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }
   money = MONEY_HAND->parse_money(words, this_player(), query_money_place());
   if( money == NO_MATCH ) {
      add_failed_mess( "Deposit what?\n" );
      return 0;
   }
   else if( money == NO_MONEY ) {
      add_failed_mess( "You can't deposit that.\n" );
      return 0;
   }
   else if( money == NO_LEGAL ) {
      add_failed_mess( "You can only deposit legal tender.\n");
      return 0;
   }
   amount = money->query_value_in(query_money_place());
   if(amount < 200) {
      money->move(this_player());
      add_failed_mess("That is too small an amount, you must deposit "
                      "at least " +
                      MONEY_HAND->money_value_string(200, query_money_place()) +
                      ".\n");
      return 0;
   }
   if (!can_adjust_account(this_player()->query_name(), amount)) {
      money->move(this_player());
      add_failed_mess("The bank cannot handle this transaction.\n");
      return 0;
   }
   tmp = ( amount * _percentage ) / 100;
   adjust_float(tmp);
   howmuch = amount;
   amount = amount - tmp;
   set_account(this_player()->query_name(), total + amount );
   _total_difference += amount;
   adjust_account(this_player()->query_name(), amount);
   event_save(this_object());
   money->move("/room/rubbish");
   this_player()->save();
   add_succeeded_mess(
       ({  "You give the teller "+ MONEY_HAND->
           money_string(money->query_money_array(), query_money_place()) +
           ", which after expenses leaves "+ MONEY_HAND->
           money_value_string( amount, query_money_place() ) +".\n"
           "This gives a total of " + MONEY_HAND->
           money_value_string(total + amount, query_money_place() ) +
           " in your account.\n",
           "$N deposits some money into $p account.\n" }) );
   return 1;
}
int do_open() {
  int amount;
  if (!is_open_for("open account", this_player()->query_name())) {
     add_failed_mess("The bank is not open for new accounts.\n");
     return 0;
  }
  if ( get_account(this_player()->query_name()) >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( _account_cost ) {
    amount = this_player()->query_value_in( query_money_place() );
    if ( amount < _account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      _account_cost, query_money_place() ) +
      " to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account(this_player()->query_name(), 0 );
  add_succeeded_mess( "$N $V an account.\n" );
  return 1;
}
void check_open( string word ) {
  object money;
  int amount;
  object main;
  word = lower_case( word );
  if (!strlen(word) || word [ 0 ] !=  'y') {
    write( "Okay, not opening an account.\n" );
    return ;
  }
  amount = this_player()->query_value_in( query_money_place() );
  if (amount < _account_cost) {
    write("You lost all your money!\n");
    return ;
  }
  set_account(this_player()->query_name(), 0 );
  write( "You now have an account here.\n" );
  money = this_player()->query_money_object(0);
  money = MONEY_HAND->pay_amount_from( _account_cost, money, query_money_place() );
  if (money  &&  money->move(this_player()) != MOVE_OK)  {
    write("Your change is too heavy and you drop it on the floor.\n");
    money->move(this_object());
  }
  amount = BANK_HANDLER->query_cost_for_new_account(_bank_name,
                                                    query_franchise());
  main = find_main_bank();
  if (main) {
     main->adjust_float(amount);
  }
  adjust_float(_account_cost - amount);
  return ;
}
int do_close() {
  int total;
  object money;
  total = get_account(this_player()->query_name());
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, query_money_place() ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
      adjust_float(-total);
      _total_difference -= total;
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
    }
  } else {
    write( "You close your account.\n" );
  }
  add_succeeded_mess("$N $V an account.\n");
  set_account(this_player()->query_name(), -1 );
  event_save(this_object());
  this_player()->save();
  return 1;
}
mixed *stats() {
  return ({
    ({ "account cost", _account_cost }),
    ({ "percentage", _percentage }),
    ({ "total difference", _total_difference }),
    ({ "bank name", _bank_name }),
    ({ "place", query_money_place() }) });
}
void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<string>",
               (: do_withdraw($4[0]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
}

==================================================
FILE: shops/inherit/bank_franchise.c
==================================================

inherit "/std/shops/inherit/bank_base";
#include <money.h>
#include <shops/bank.h>
class credit_note {
   int num;
   int amt;
   int made;
   string maker;
}
private int _credit_num;
private class credit_note* _notes;
void create() {
   _notes = ({ });
   ::create();
}
int is_allowed(string name) {
   return 0;
}
int is_allowed_credit(string name) {
   return is_allowed(name) ||
          name == query_main_branch_owner();
}
protected void set_credit_num(int num) {
   _credit_num = num;
}
int query_credit_num() {
   return _credit_num;
}
protected void set_credit_notes(class credit_note* notes) {
   _notes = notes;
}
class credit_note* query_credit_notes() {
   return copy(_notes);
}
int query_outstanding_credit_value() {
   int diff;
   class credit_note note;
   foreach (note in _notes) {
      diff += note->amt;
   }
   return diff;
}
int do_create() {
   object ob;
   int diff;
   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for creating credit notes.\n");
      return 0;
   }
   diff = query_total_difference() - query_outstanding_credit_value();
   if (diff == 0) {
      add_failed_mess("The bank is currently at a zero balance with the "
                      "outstanding credit notes.\n");
      return 0;
   }
   ob = clone_object(BANK_CREDIT_NOTE);
   ob->set_credit_num(++_credit_num);
   ob->set_franchise(query_franchise());
   ob->set_bank_name(query_bank_name());
   ob->set_amount(query_total_difference());
   ob->add_property("place", query_money_place());
   ob->setup_read_messages();
   ob->move(this_player());
   if (!_notes) {
      _notes = ({ });
   }
   _notes += ({ new(class credit_note, num : ob->query_credit_num(),
                                   amt : ob->query_amount(),
                                   maker : this_player()->query_cap_name(),
                                   made : time()) });
   event_save(this_object());
   add_succeeded_mess("$N $V " + ob->a_short() + ".\n");
   return 1;
}
int do_list() {
   class credit_note note;
   string ret;
   string place;
   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for listing credit notes.\n");
      return 0;
   }
   place = query_money_place();
   if (!sizeof(_notes)) {
      add_failed_mess("No credit notes to list.\n");
      return 0;
   }
   ret = "Credit notes\n\n";
   foreach (note in _notes) {
      ret += "$I$6=" + sprintf("%3d) ", note->num) +
             ctime(note->made) + ": by " +
             note->maker + " for " +
             MONEY_HAND->money_value_string(note->amt, place) + "\n";
   }
   write("$P$Credit Notes$P$" + ret);
   return 1;
}
int do_recind(int id) {
   class credit_note note;
   int i;
   string place;
   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for listing credit notes.\n");
      return 0;
   }
   for (i = 0; i < sizeof(_notes); i++) {
      note = _notes[i];
      if (note->num == id) {
          place = query_money_place();
          _notes = _notes[0..i-1] + _notes[i+1..];
          add_succeeded_mess(({
             "You recind #" + note->num + " made at " +
             ctime(note->made) + " by " +
             note->maker + " for " +
             MONEY_HAND->money_value_string(note->amt, place) + "\n", "" }));
          return 1;
      }
   }
   add_failed_mess("Unable to find credit note #" + id + ".\n");
   return 0;
}
int is_valid_note(int id) {
   int i;
   for (i = 0; i < sizeof(_notes); i++) {
      if (_notes[i]->num == id) {
         return 1;
      }
   }
   return 0;
}
int process_note(int id) {
   int i;
   if (!is_valid_note(id)) {
      return 0;
   }
   for (i = 0; i < sizeof(_notes); i++) {
      if (_notes[i]->num == id) {
         adjust_total_difference(-_notes[i]->amt);
         _notes = _notes[0..i-1] + _notes[i+1..];
         i--;
      }
   }
   event_save(this_object());
   return 1;
}
void init() {
   ::init();
   add_command("create", "credit note");
   add_command("list", "credit notes");
   add_command("recind", "credit note <number'id'>", (: do_recind($4[0]) :));
}

==================================================
FILE: shops/inherit/bank_master.c
==================================================

inherit "/std/shops/inherit/bank_base";
#include <money.h>
int query_float();
int do_process(object *obs) {
   object ob;
   int amount;
   int found;
   object* not_credit;
   object* not_valid;
   string place;
   place = query_money_place();
   not_valid = ({ });
   not_credit = ({ });
   foreach (ob in obs) {
      if (ob->query_credit_note() ||
          ob->query_bank_name() != query_bank_name()) {
         not_credit += ({ ob });
         obs -= ({ ob });
      } else if (ob->is_valid_note()) {
         amount += ob->query_credit_balance();
      } else {
         not_valid += ({ ob });
         obs -= ({ ob });
      }
   }
   if (!sizeof(obs)) {
      if (sizeof(not_credit)) {
         add_failed_mess("None of $I are credit notes.\n", not_credit);
      }
      if (sizeof(not_valid)) {
         add_failed_mess("None of $I are valid credit notes.\n", not_valid);
      }
      return 0;
   }
   foreach (ob in obs) {
      amount = ob->query_amount();
      if (amount > 0) {
         if (this_player()->query_value_in(query_money_place()) < amount) {
            add_failed_mess("You do not have the needed " +
                            MONEY_HAND->money_value_string(amount, place) +
                            " to deposit.\n");
            continue;
         }
         else if (ob->do_process()) {
            this_player()->pay_money(MONEY_HAND->create_money_array(amount,
                   place), place);
            add_succeeded_mess("$N $V depositing " +
                               MONEY_HAND->money_value_string(amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      } else if (amount < 0) {
         if (ob->do_process()) {
            this_player()->adjust_money(MONEY_HAND->create_money_array(-amount, place));
            add_succeeded_mess("$N $V withdrawing " +
                               MONEY_HAND->money_value_string(-amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      }
      ob->move("/room/rubbish");
   }
   return found;
}
void init() {
   ::init();
   add_command("process", "<indirect:object>");
}

==================================================
FILE: shops/inherit/clone_on_demand.c
==================================================

#include <armoury.h>
#define INFINITE_LEFT 10000
#define MAX_PROP "max per reset"
#define NUM_REMOVED "number removed this reset"
#define REFERENCE "name we are reference by"
#define DISPLAY "display in shop"
nosave object _cont;
nosave string _domain;
void create(){
}
object query_cont(){  return _cont;  }
void check_cont() {
  if (!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
}
void reset() {
  object ob;
  check_cont();
  foreach( ob in all_inventory(_cont) ){
    ob->remove_property(NUM_REMOVED);
  }
}
void set_object_domain(string domain) {
   _domain = domain;
}
string query_object_domain() {
   return _domain;
}
varargs int add_object( string name, int max_per_reset, string display_as ) {
  object ob;
  if(!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
  if (!(ob = this_object()->create_object(name))) {
    if(!ob = clone_object(name)) {
      ob = ARMOURY->request_item(name, 100, _domain);
    }
  }
  if(ob) {
    if (ob->query_decays()) {
      ob->set_decay_speed(0);
    }
    ob->move(_cont);
    if (display_as) {
         ob->add_property( DISPLAY, display_as);
    }
    ob->add_property( REFERENCE, name);
    ob->add_property( MAX_PROP, max_per_reset );
    return 1;
  }
  return 0;
}
int query_num_items_left(object ob) {
   int max;
   int num;
   max = ob->query_property( MAX_PROP );
   num = ob->query_property( NUM_REMOVED );
   if( max ){
     return max - num;
   }
   return INFINITE_LEFT;
}
int query_number_left(string name) {
   object * things;
   things = filter( all_inventory(_cont),
     (: $1->query_short() == $(name) :) );
   if( !sizeof(things) ) {
      return -1;
   }
   return query_num_items_left( things[0] );
}
int * query_items_left( string *names ) {
   if( !names )
      return ({ });
   return map( names, (: query_number_left($1) :) );
}
private void switch_properties(object newone, object original) {
  mixed *extra, *props, prop;
  props = ({ MAX_PROP, NUM_REMOVED, REFERENCE });
  extra = this_object()->switch_extra_properties();
  if( sizeof(extra) )
    props += extra;
  foreach( prop in props ){
    newone->add_property( prop, original->query_property( prop ) );
    original->remove_property( prop );
  }
  if (newone->query_decay_speed()) {
     original->set_decay_speed( newone->query_decay_speed() );
     newone->set_decay_speed(0);
  }
}
protected object create_real_object(object thing) {
   string name;
   object new_thing, *continv, temp_cont;
   int j, max, num;
   name = thing->query_property( REFERENCE );
   if(!name)
     return 0;
   new_thing = this_object()->create_object( name );
   if ( !new_thing )  {
      new_thing = clone_object(name);
   }
   if ( !new_thing )  {
      new_thing = ARMOURY->request_item( name, 80 + random( 20 ), _domain );
   }
  if( new_thing ){
    switch_properties( new_thing, thing );
    continv = all_inventory(_cont);
    j = member_array( thing, continv );
    temp_cont = clone_object("/std/container");
    thing->move("/room/void");
    continv[j] = new_thing;
    new_thing->move(_cont);
      for (j=sizeof(continv)-1;j>=0;j--) {
      continv[j]->move(temp_cont);
      continv[j]->move(_cont);
    }
    temp_cont->dest_me();
    max = new_thing->query_property( MAX_PROP );
    num = new_thing->query_property( NUM_REMOVED );
    if ( max ) {
      new_thing->add_property( NUM_REMOVED, num + 1 );
    }
  }
  return thing;
}
void dest_me(){
  if( _cont )
    _cont->dest_me();
}
varargs int add_armour( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
}
varargs int add_weapon( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
}
