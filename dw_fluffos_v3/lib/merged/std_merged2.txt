# Total Tokens: 16515
# Total Files Merged: 7
# Total Characters: 55067

==================================================

#include <armoury.h>
#include <data.h>
#include <weather.h>
#include <hospital.h>
#define CREATE_NPCS 1
inherit "/std/room";
inherit HOSPITAL_ALIGNMENT_INHERIT;
public object *load_random_npc(string zone, int wealth, int busy);
protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);
public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );
private nosave string _save_file;
private nosave string _hospital_type;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;
private nosave string _data_directory;
private nosave string _npc_path;
private nosave string _domain;
private nosave int _max_cache;
private nosave int _disable_npc_generation;
private mapping _unique_npcs;
private mapping _hospital_npcs;
private mapping _cache_inventory;
private int _last_npc_check;
private int _zone_npcs;
private mapping _group_info;
private mapping _npc_info;
private mapping _zone_info;
private mapping _path_to_npc;
private mapping _file_modified_time;
void create() {
    seteuid(master()->creator_file(file_name(this_object())));
    do_setup++;
    ::create();
    do_setup--;
    if (!_group_info) {
        _group_info = ([ ]);
    }
    if (!_npc_info) {
        _npc_info = ([ ]);
    }
    if (!_zone_info) {
        _zone_info = ([ ]);
    }
    if (!_path_to_npc) {
        _path_to_npc = ([ ]);
    }
    if (!_file_modified_time) {
        _file_modified_time = ([ ]);
    }
    if (!_unique_npcs) {
        _unique_npcs = ([ ]);
    }
    if (!_cache_inventory) {
      _cache_inventory = ([ ]);
    }
    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);
    if(!_max_cache)
      _max_cache = DEFAULT_MAX_CACHE;
    if (!do_setup) {
        set_short( "Un-configured Hospital" );
        set_long("This is an unconfigured hospital.  Find the right one.\n");
        add_property("determinate", "the ");
        set_light(60);
        this_object()->setup();
    }
}
int ok_to_clone() {
   return 1;
}
public string *query_deities() {
   return ({ "fish", "pishe", "sek", "hat", "gapp",
      "gufnork", "sandelfon" });
}
public int get_item(object destination, string *items) {
    int i;
    object item;
    if (!objectp(destination)) {
        return 0;
    }
    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21), _domain);
        if (!item) {
            item = ARMOURY->request_item(items[i], 80 + random(21) );
            if ( !item ) {
                items = items[0..i-1] + items[i+1..];
                continue;
            }
        }
        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the Ankh-Morpork hospital.\n",
                previous_object()->short());
            break;
        }
    }
    if (objectp(item)) {
        item->move(destination);
        return 1;
    }
    return 0;
}
protected void load_file() {
    class npc_info npc;
    class group_info group;
    string name;
    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
        if (!_group_info) {
            _group_info = ([ ]);
        } else {
            foreach (name, group in _group_info) {
                group->storage = 0;
            }
        }
        if (!_npc_info) {
            _npc_info = ([ ]);
        } else {
            foreach (name, npc in _npc_info) {
                npc->population = ({ });
            }
        }
        if (!_zone_info) {
            _zone_info = ([ ]);
        }
        if (!_path_to_npc) {
            _path_to_npc = ([ ]);
        }
        if (!_file_modified_time) {
            _file_modified_time = ([ ]);
        }
        if (!_unique_npcs) {
            _unique_npcs = ([ ]);
        }
    }
}
protected void save_file() {
    unguarded((: save_object, _save_file :));
}
protected void set_save_file(string new_save) {
    _save_file = new_save;
    load_file();
}
public string query_save_file() {
    return _save_file;
}
void set_data_directory(string dir) {
   _data_directory = dir;
   call_out("scan_for_new_data", 2);
}
string query_data_directory() {
   return _data_directory;
}
void set_npc_path(string path) {
  _npc_path = path;
}
void set_domain(string domain) {
  _domain = domain;
}
void set_max_cache(int num) {
  _max_cache = num;
}
void set_disable_npc_generation(int value) {
   _disable_npc_generation = value;
}
int query_disable_npc_generation() {
   return _disable_npc_generation;
}
public int make_unique(mixed who) {
    int delay;
    if (!_unique_npcs) {
        return 0;
    }
    if (objectp(who)) {
        who = who->query_name();
    }
    if (!_unique_npcs[who]) {
        _unique_npcs[who] = new(class unique_npc);
    }
    if ( _unique_npcs[who]->next_regen_time > time() ) {
        return 0;
    }
    if (_npc_info[who] && _npc_info[who]->delay) {
        delay = _npc_info[who]->delay;
    } else {
        delay = REGEN_TIME;
    }
    _unique_npcs[who]->next_regen_time = time() + delay;
    save_file();
    return 1;
}
public void reset_unique(string who) {
    if (!_unique_npcs[who]) {
        return ;
    }
    _unique_npcs[who]->next_regen_time = 0;
}
#ifdef REGENERATE_AFTER_DEATH
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;
    if ( !dead_npc )
        return;
    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"),
        load_position : previous_object()->query_property("start location") ) });
    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;
    new_npc = _regenerated_npcs[0];
    if ( !classp( new_npc ) )
        return;
    _regenerated_npcs = _regenerated_npcs[1..];
    if (!new_npc->load_position || !new_npc->type );
        return;
    max = random(5);
    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );
        if ( !objectp( destination ) )
            return;
        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);
        call_out((: $1->announce_entry($2) :), 8 + random(6), destination,
            monsters);
    }
}
#endif
string npc_path(string str) {
   return _npc_path + "/" + str;
}
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;
    filename = _hospital_log_directory;
    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }
    log_file( _hospital_log_directory + "/" + file, ctime(time()) + ": " + format, args ...);
}
protected void set_log_directory(string new_dir) {
    if (file_size(new_dir) != -2) {
        debug_printf( "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );
        new_dir = DEFAULT_LOG_DIRECTORY;
    }
    _hospital_log_directory = new_dir;
}
private void parse_zone(string fname, mapping data) {
   string name;
   class zone_info info;
   mapping bing;
   int chance;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for zone %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for zone %O\n", data);
      return 0;
   }
   name = data["name"];
   if (data["group"] && !arrayp(data["group"])) {
      data["group"] = ({ data["group"] });
   } else if (!arrayp(data["groups"])) {
      data["group"] = ({ });
   }
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   if (data["zone"] && !arrayp(data["zone"])) {
      data["zone"] = ({ data["zone"] });
   } else if (!arrayp(data["zone"])) {
      data["zone"] = ({ });
   }
   info = new(class zone_info, npcs : ([ ]), groups : ([ ]), zones : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->npc_chance = chance;
   chance = 0;
   foreach (bing in data["group"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->groups[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->group_chance = chance;
   chance = 0;
   foreach (bing in data["zone"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->zones[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->zone_chance = chance;
   info->busy = data["busy"];
   bits = keys(data) - ({ "zone", "group", "npc", "name", "busy" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in zone %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in %s\n",
                         query_multiple_short(bits), name);
   }
   _zone_info[name] = info;
   save_file();
}
private void parse_npc(string fname, mapping data) {
   string name;
   class npc_info info;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for npc %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      hospital_log_file("COMPILE_ERROR", "Required path field not present for npc %s\n", name);
      return 0;
   }
   if (file_size(npc_path(data["path"]) + ".c") < 0) {
      hospital_log_file("BAD_NPC_PATH", "Bad path for npc %s (%s)\n", name, data["path"]);
   }
   if (data["command"] && !arrayp(data["command"])) {
      data["command"] = ({ data["command"] });
   }
   if (data["move_zone"] && !arrayp(data["move_zone"])) {
      data["move_zone"] = ({ data["move_zone"] });
   }
   info = new(class npc_info, move_zones : ({ }), commands : ({ }));
   info->unique = data["unique"];
   info->path = data["path"];
   info->delay = data["delay"];
   info->max_population = data["population"];
   if(data["transient"])
     info->transient = 1;
   if(data["nocturnal"])
     info->nocturnal = 1;
   if(data["diurnal"])
     info->diurnal = 1;
   if(data["seasonal"]) {
     if(!arrayp(data["group"]))
       info->seasonal = ({ data["seasonal"] });
     else
       info->seasonal = data["seasonal"];
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   if (data["command"]) {
      info->commands = data["commands"];
   }
   bits = keys(data) - ({ "unique", "path", "move_zone", "population", "name", "delay", "transient", "nocturnal" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in npc %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in npc %s\n",
                         query_multiple_short(bits), name);
   }
   if (_path_to_npc[info->path] && _path_to_npc[info->path] != name) {
      hospital_log_file("NPC_NAME_CLASH", "NPC path %s is used by %s and %s.\n",
                         info->path, name, _path_to_npc[info->path]);
   }
   _path_to_npc[info->path] = name;
   if (_npc_info[name]) {
      info->population = _npc_info[name]->population;
      info->no_created = _npc_info[name]->no_created;
      info->no_reused = _npc_info[name]->no_reused;
      info->no_deaths = _npc_info[name]->no_deaths;
   }
   _npc_info[name] = info;
   save_file();
}
private void parse_group(string fname, mapping data) {
   string name;
   class group_info info;
   mapping bing;
   int chance;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for group %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for group %O\n", data);
      return 0;
   }
   name = data["name"];
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   info = new(class group_info, npcs : ([ ]), move_zones : ({ }),
                                npc_commands : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) ||
          (!intp(bing["quantity"]) && !classp(bing["quantity"]))) {
         debug_printf("Invalid data for group (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for group (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["quantity"];
         if (bing["command"]) {
            if (arrayp(bing["command"])) {
               info->npc_commands[bing["name"]] = bing["command"];
            } else {
               info->npc_commands[bing["name"]] = ({ bing["command"] });
            }
         }
      }
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   info->max_population = data["population"];
   info->protect = data["protect"];
   info->defend = data["defend"];
   info->transient = data["transient"];
   bits = keys(data) - ({ "npc", "name", "population", "move_zone", "protect", "defend", "transient", });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in group %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in group %s\n",
                         query_multiple_short(bits), name);
   }
   if (_group_info[name]) {
     info->storage = _group_info[name]->storage;
   }
   _group_info[name] = info;
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "zone" :
         foreach (thing in bits) {
            parse_zone(fname, thing);
         }
         break;
      case "npc" :
         foreach (thing in bits) {
            parse_npc(fname, thing);
         }
         break;
      case "group" :
         foreach (thing in bits) {
            parse_group(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         hospital_log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
}
int scan_for_new_data(int force) {
  string *files;
  string fname;
  string *bits;
  debug_printf("Scan for new data.");
  if (unguarded( (: stat(__FILE__)[1] :)) !=
      _file_modified_time[__FILE__]) {
    _file_modified_time = ([ ]);
  }
  if(force) {
    _npc_info = ([ ]);
    _zone_info = ([ ]);
    _group_info = ([ ]);
  }
  files = ({ _data_directory });
  while (sizeof(files)) {
    fname = files[0];
    files = files[1..];
    if (unguarded( (: file_size($(fname)) :)) == -2) {
      bits = get_dir(fname + "/");
      if (bits) {
        bits -= ({ "RCS", ".", ".." });
        bits = filter(bits, (: $1[0] != '.' :));
        files += map(bits, (: $2 + "/" + $1 :), fname);
      }
    } else {
      if(unguarded((: stat($(fname)) :))[1] != _file_modified_time[fname] ||
         force) {
        debug_printf("Compiling %s", fname);
        DATA_HANDLER->compile_file(fname, (: finish_compiling :));
      }
    }
  }
  _file_modified_time[__FILE__] = unguarded( (: stat(__FILE__)[1] :));
  return 1;
}
int roll_dice(mixed die) {
   int result;
   int i;
   if (intp(die)) {
      return die;
   }
   if (classp(die)) {
      for (i = 0; i < die->number; i++) {
         result += random(die->die) + 1;
      }
      result += die->modifier;
      return result;
   }
   return 0;
}
int query_npc_max_population( string npc) {
   if (!_npc_info[npc]) {
      return -1;
   }
   return ((class npc_info)_npc_info[npc])->max_population;
}
int query_npc_current_population( string npc, int clean) {
   class npc_info data;
   if (!_npc_info[npc]) {
      return -1;
   }
   data = _npc_info[npc];
   if (!data->population) {
      data->population = children(npc_path(data->path));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }
   if (clean || data->next_update < time()) {
      data->population = filter(data->population, (: objectp($1) :));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }
   return sizeof(data->population);
}
int is_npc_under_max_population(string name) {
    class npc_info info;
    info = _npc_info[name];
    if (!info) {
       return 0;
    }
    if(info->transient)
      return 1;
    if (info->max_population) {
       return query_npc_current_population(name, 1) < info->max_population;
    }
    return 1;
}
int is_group_under_max_population(string name) {
    class group_info group;
    group = _group_info[name];
    if (!group) {
       return 0;
    }
    if (!group->max_population || group->transient) {
       return 1;
    }
    if (!group->storage) {
        group->storage = ({ });
    } else if (group->next_update < time()) {
        group->storage = map(group->storage, (: filter($1, (: objectp($1) :)) :));
        group->storage = filter(group->storage, (: sizeof($1) :));
        group->next_update = time() + POPULATION_UPDATE_TIME;
    }
    if (sizeof(group->storage) >= group->max_population) {
        return 0;
    }
    return 1;
}
public object load_npc_object(string npc_name) {
    class npc_info info;
    object npc;
    string zone;
    string cmd;
    if ( undefinedp(_npc_info[npc_name])) {
        debug_printf("Unable to find npc %O", npc_name);
        return 0;
    }
    info = _npc_info[npc_name];
    if(info->diurnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->nocturnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->seasonal &&
       member_array(WEATHER->query_season(), info->seasonal) == -1)
      return 0;
    if (stringp(info->path)) {
        if ( info->unique ) {
            npc = find_object( npc_path(info->path) );
            if ((!npc || !environment(npc)) && make_unique(npc_name)) {
               debug_printf("Unique npc %O", info);
               if (catch(npc = load_object( npc_path(info->path) ))) {
                   hospital_log_file("BAD_NPC_PATH", "Error loading %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if (!objectp(npc) || npc == 0) {
                   hospital_log_file("BAD_NPC_PATH", "Failed to load %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if ( environment( npc ) ) {
                   debug_printf("NPC unique and already exists %O", npc_name);
                   return 0;
               }
            }
        } else if(info->transient) {
          if(!_cache_inventory)
            _cache_inventory = ([ ]);
          else if(_cache_inventory[npc_name])
            _cache_inventory[npc_name] -= ({ 0 });
          if(sizeof(_cache_inventory[npc_name])) {
            npc = _cache_inventory[npc_name][0];
            _cache_inventory[npc_name] -= ({ npc });
            info->no_reused++;
          } else {
            npc = clone_object( npc_path(info->path) );
            if(npc) {
              npc->add_property("transient", 1);
              npc->add_property("npc_id", npc_name);
              npc->add_property("hospital", base_name(this_object()));
              info->no_created++;
            } else
              debug_printf("Failed to clone %s", npc_path(info->path));
          }
        } else {
            if (is_npc_under_max_population(npc_name)) {
               npc = clone_object( npc_path(info->path) );
               info->no_created++;
               if (!npc) {
                  debug_printf("Npc path does not exist %O (%O)", npc, npc_path(info->path));
               }
            } else {
               debug_printf("NPC over max population %O", npc_name);
            }
        }
    } else {
        debug_printf("Broken npc data %O", info->path);
        return 0;
    }
    if (npc && !info->transient) {
        if( info->population == 0 )
            info->population = ({ });
        info->population += ({ npc });
        npc->add_property("npc_id", npc_name);
        foreach (zone in info->move_zones) {
            npc->add_move_zone(zone);
        }
        foreach (cmd in info->commands) {
            npc->init_command(cmd, 2);
        }
    }
    return npc;
}
public object *load_group_npcs(string group_name) {
    class group_info group;
    int quantity;
    int i;
    object *npcs;
    string npc_name;
    object ob;
    object ob_bing;
    string cmd;
    if ( undefinedp(_group_info[group_name]) ||
         !is_group_under_max_population(group_name)) {
        return 0;
    }
    group = _group_info[group_name];
    npcs = ({ });
    foreach (npc_name, quantity in group->npcs) {
        quantity = roll_dice(quantity);
        for (i = 0; i < quantity; i++) {
            ob = load_npc_object(npc_name);
            if (!ob) {
               npcs->move("/room/rubbish");
               return ({ });
            }
            npcs += ({ ob });
            if (group->npc_commands[npc_name]) {
               foreach (cmd in group->npc_commands[npc_name]) {
                  ob->init_command(cmd, 2);
               }
            }
        }
    }
    if (!group->storage) {
        group->storage = ({ });
    }
    group->storage += ({ npcs });
    npcs->add_property("group_id", group_name);
    foreach (ob in npcs) {
       foreach (ob_bing in npcs) {
          if (ob != ob_bing) {
             ob->add_follower(ob_bing);
             if (group->defend) {
               ob->add_defender(ob_bing);
             }
             if (group->protect) {
                ob->add_protector(ob_bing);
             }
          }
       }
    }
    return npcs;
}
public class npc_info query_npc_info( string npc ) {
    if ( !_npc_info ) {
        return 0;
    }
    return _npc_info[ npc ];
}
mapping query_debug_npc_info() {
   return _npc_info;
}
public class group_info query_group_info( string group ) {
    if ( !_group_info ) {
        return 0;
    }
    return _group_info[ group ];
}
void npc_died(object ob) {
   string npc_id;
   class npc_info info;
   int i;
   mixed* stuff;
   npc_id = ob->query_property("npc_id");
   info = _npc_info[npc_id];
   if (!info || !npc_id) {
      return ;
   }
   info->population -= ({ ob });
   info->no_deaths++;
   npc_id = ob->query_property("group_id");
   stuff = _group_info[npc_id]->storage;
   if (sizeof(stuff)) {
      for (i = 0; i < sizeof(stuff); i++) {
         stuff[i] -= ({ ob, 0 });
      }
      _group_info[npc_id]->storage = filter(_group_info[npc_id]->storage,
                                             (: sizeof($1) :));
   }
}
mapping query_all_npc_info() {
   return _npc_info;
}
mapping query_all_group_info() {
   return _group_info;
}
mapping query_all_zone_info() {
   return _zone_info;
}
private int count_chances_in_zone(string zone) {
    class zone_info info;
    int chance;
    info = _zone_info[zone];
    if (!zone) {
       return 0;
    }
    chance = info->npc_chance + info->group_chance + info->zone_chance;
    return chance;
}
private object* create_npcs_in_zone(string zone, int pos) {
    class zone_info info;
    string extra;
    string npc;
    object ob;
    object* obs;
    int chance;
    info = _zone_info[zone];
    if (!zone) {
       return ({ });
    }
    if (pos < info->npc_chance) {
       foreach (npc, chance in info->npcs) {
          if (pos < chance) {
             ob = load_npc_object(npc);
             if (ob) {
               if(environment(ob) == this_object())
                 debug_printf("Reused %s in %s", npc, zone);
               else
                 debug_printf("Created %s in %s", npc, zone);
                return ({ ob });
             }
          }
          pos -= chance;
       }
    }
    pos -= info->npc_chance;
    if (pos < info->group_chance) {
       foreach (npc, chance in info->groups) {
          if (pos < chance) {
             obs = load_group_npcs(npc);
             if (sizeof(obs)) {
                return obs;
             }
          }
          pos -= chance;
       }
    }
    pos -= info->group_chance;
    foreach (extra, chance in info->zones) {
        if (pos < chance) {
           return load_random_npc(extra, -1, -1);
        }
    }
    return ({ });
}
public object *load_random_npc(string zone, int wealth, int busy) {
    int chance;
    int pos;
    if (_disable_npc_generation) {
        return ({ });
    }
    if (_zone_info[zone + "-w" + wealth + "-b" + busy]) {
       zone = zone + "-w" + wealth + "-b" + busy;
    } else if (_zone_info[zone + "-w" + wealth]) {
       zone = zone + "-w" + wealth;
    } else if (_zone_info[zone + "-b" + busy]) {
       zone = zone + "-b" + busy;
    }
    if (!_zone_info[zone]) {
        return ({ });
    }
    if(_zone_info[zone]->busy &&
       _zone_info[zone]->busy < random(random(100)))
      return ({ });
    chance = count_chances_in_zone(zone);
    if (!chance) {
       return ({ });
    }
    pos = random(chance);
    return create_npcs_in_zone(zone, pos);
}
int do_report() {
    string name;
    class group_info group;
    class npc_info npc;
    string txt;
    int total;
    int max;
    int pop;
    txt = "";
    total = 0;
    txt += "%^WHITE%^NPCs%^RESET%^\n";
    foreach( name, npc in _npc_info ) {
      reset_eval_cost();
      if(stringp(npc->path) && file_size(npc_path(npc->path) + ".c") > 0) {
        pop = query_npc_current_population(name, 0);
      } else {
        pop = 0;
      }
      if(npc->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient) Reused %d Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
                        npc->no_reused, npc->no_created, npc->no_deaths);
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d) Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
            pop, npc->max_population, npc->no_created, npc->no_deaths );
        total += pop;
        max += npc->max_population;
    }
    txt += "$I$0=%^WHITE%^Groups%^RESET%^\n";
    foreach( name, group in _group_info ) {
      if(group->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient)\n", name,
            query_multiple_short(keys(group->npcs)));
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d)\n", name,
            query_multiple_short(keys(group->npcs)),
            sizeof( group->storage ), group->max_population );
    }
    txt += "$I$0=%^WHITE%^Cache%^RESET%^\n";
    foreach(name in keys(_cache_inventory))
      _cache_inventory[name] -= ({ 0 });
    foreach(name, group in _cache_inventory)
      txt += sprintf("$I$5=Name: %s %d\n", name, sizeof(group));
    txt += "\nTotal NPCs in hospital: " + total + "/" +
            max + ".\n";
    write("$P$Report$P$" + txt );
    return 1;
}
void init() {
  object ob;
  ob = this_player();
  add_command("report", "", (: do_report :));
  add_command("scan", "", (: scan_for_new_data :));
  if(ob->query_property("npc_id") && ob->query_property("hospital") &&
     ob->query_property("hospital") == base_name(this_object())) {
    if(!_cache_inventory[ob->query_property("npc_id")])
      _cache_inventory[ob->query_property("npc_id")] = ({ ob });
    else if(sizeof(_cache_inventory[ob->query_property("npc_id")]) >
            _max_cache)
      ob->move("/room/rubbish");
    else
      _cache_inventory[ob->query_property("npc_id")] += ({ ob });
  } else if(base_name(ob) == "/obj/corpse")
    ob->move("/room/rubbish");
}
int no_attack() { return 1; }
mapping query_dynamic_auto_load() {
    string group_name;
    string npc;
    class group_info data;
    class npc_info npc_data;
    mapping tmp;
    mapping tmp2;
    tmp = allocate_mapping( sizeof( _group_info ) );
    foreach( group_name, data in _group_info ) {
        tmp[ group_name ] = data->storage;
    }
    tmp2 = allocate_mapping( sizeof( _npc_info) );
    foreach( npc, npc_data in _npc_info ) {
        tmp2[ npc ] = npc_data->population;
    }
    return ([ file_name( this_object() ) : tmp, "npcs" : tmp2 ]);
}
void init_dynamic_arg( mapping tmp ) {
    string group_name;
    object *npcs;
    if ( tmp[ file_name( this_object() ) ] ) {
        foreach( group_name, npcs in tmp[ file_name( this_object() ) ] ) {
            if (_group_info[group_name]) {
               _group_info[ group_name ]->storage = npcs;
            }
        }
        foreach( group_name, npcs in tmp[ "npcs" ]) {
            if (_npc_info[group_name]) {
               _npc_info[ group_name ]->population = npcs;
            }
        }
    }
}
mixed query_all_npcs() {
    return values( map( _group_info, (: $2->storage :) ) );
}
mapping query_inventory_cache() {
  return copy(_cache_inventory);
}
string* query_registered_npcs() {
    return keys( _npc_info );
}

==================================================
FILE: key.c
==================================================

inherit "/std/object";
#include <shops/engrave.h>
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_name("key");
  set_long("A key.  Wonder where it fits?.\n");
  add_plural("keys");
  set_short("key");
  add_property(ENGRAVE_PROP, 1);
  if(!do_setup) {
    this_object()->setup();
  }
}
void set_key( string str, string prop ) {
  string *bits;
  int i;
  set_short( str + " key" );
  set_main_plural( str + " keys" );
  set_name( "key" );
  add_plural( "keys" );
  bits = explode( str, " " );
  for( i = 0; i < sizeof( bits ); i ++ ) {
    add_adjective( bits[i] );
  }
  add_property( prop, 1 );
  set_value( 0 );
  set_weight( 1 );
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

==================================================
FILE: leaflet.c
==================================================

inherit "/std/object";
private int page;
private mixed *pages;
int do_open(int page_no);
void create() {
   do_setup++;
   ::create();
   do_setup--;
   pages = ({ ({ }) });
   if ( !do_setup )
      this_object()->setup();
  add_help_file("leaflet");
}
int query_leaflet() { return 1; }
int query_page() { return page; }
mixed *query_pages() { return copy( pages ); }
void init() {
   add_command( "turn", "[a] page of <direct:object>" );
   add_command( "open", "<direct:object> to [page] <number>",
                (: do_open($4[1]) :));
}
void set_no_pages( int number ) {
   int i;
   if ( number < 1 ) {
      number = 1;
   }
   pages = ({ });
   for ( i = 0; i < number; i++ ) {
      pages += ({ ({ }) });
   }
}
varargs void set_read_mess( mixed mess, string lang, int size ) {
   ::set_read_mess( mess, lang, size );
   pages[ page ] = query_read_mess();
}
mixed add_read_mess( mixed mess, string type, string lang, int size ) {
   mixed ret;
   ret = ::add_read_mess( mess, type, lang, size );
   pages[ page ] = query_read_mess();
   return ret;
}
int query_open_page() { return page + 1; }
void set_open_page( int number ) {
   if ( ( number < 1 ) || ( number > sizeof( pages ) ) ) {
      number = 1;
   }
   page = number - 1;
   ::set_read_mess( pages[ page ] );
}
int do_turn() {
   set_open_page( page + 2 );
   return 1;
}
int do_open(int page_no) {
   if ( ( page_no < 1 ) || ( page_no > sizeof( pages ) ) ) {
      add_failed_mess("The page no " + page_no + " does not exist.\n");
      return 0;
   }
   set_open_page(page_no);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/std/leaflet" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "page" : page,
      "pages" : copy( pages ),
   ]);
}
void init_dynamic_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   }
   page = map[ "page" ];
   if ( pointerp( map[ "pages" ] ) ) {
      pages = map[ "pages" ];
      set_open_page( page + 1 );
   }
}
string query_read_short(object player, int ignore_labels) {
   string ret;
   if (page == 0) {
      ret = ::query_read_short(player, 1);
   } else {
      ret = ::query_read_short(player, 0);
   }
   return "page " + query_num(page) + " of " + ret;
}

==================================================
FILE: learning.c
==================================================

#include <money.h>
#include <tasks.h>
class step {
  string *blurbs;
  string skill;
  int difficulty;
  string *responses;
  string *params;
  string award_mess;
  string succeed_mess;
  string fail_mess;
}
class lesson {
  mapping minimum_skills;
  mapping maximum_skills;
  string *materials;
  int cost;
  string currency;
  string *lesson_ending;
  object teacher;
  class step *plan;
}
private nosave mapping _lessons;
private nosave int current_step;
private nosave int attempt;
int lesson_response(string, object, int, string);
int register_lesson(string name, mapping minimum_skills,
                    mapping maximum_skills, string *materials, int cost,
                    string currency, string *lesson_ending, object teacher ) {
  if(!_lessons)
    _lessons = ([ ]);
  if(_lessons[name])
    return 0;
  _lessons[name] = new(class lesson,
                       minimum_skills : minimum_skills,
                       maximum_skills : maximum_skills,
                       materials : materials,
                       cost : cost,
                       currency : currency,
                       lesson_ending : lesson_ending,
                       teacher : teacher
                       );
  return 1;
}
int add_step( string lesson_name, string *blurbs, string skill, int diff,
        string *responses, string *params, string award_mess, string succeed_mess,
        string fail_mess) {
  if(!_lessons)
    _lessons = ([ ]);
  if( !_lessons[lesson_name] ){
    return 0;
  }
  if( !_lessons[lesson_name]->plan ){
    _lessons[lesson_name]->plan = ({ });
  }
  _lessons[lesson_name]->plan += ({ new(class step,
          blurbs : blurbs,
          skill : skill,
          difficulty : diff,
          responses : responses,
          params : params,
          award_mess : award_mess,
          succeed_mess : succeed_mess,
          fail_mess : fail_mess
          ) });
  return 1;
}
int has_required_skills( string name, object player ) {
  string skill;
  int p_level;
  foreach( skill in (keys(_lessons[name]->minimum_skills)) ){
    p_level = player->query_skill(skill);
    if( p_level < _lessons[name]->minimum_skills[skill] ){
      return 0;
    }
  }
  foreach( skill in (keys(_lessons[name]->maximum_skills)) ){
    p_level = player->query_skill(skill);
    if( p_level > _lessons[name]->maximum_skills[skill] ){
      return 0;
    }
  }
  return 1;
}
int has_required_materials( string name, object player ) {
  string mat;
  foreach( mat in _lessons[name]->materials ) {
    if( sizeof( filter_array(deep_inventory(player),
           (: ($1)->query_short() :) ) ) ){
      return 1;
    }
  }
  return 0;
}
int has_required_cash( string name, object player ) {
  if(player->query_value_in(_lessons[name]->currency) < _lessons[name]->cost) {
    return 0;
  } else {
    return 1;
  }
}
int start_lesson(string name, object player) {
  string *needed;
  if(!_lessons[name])
    return notify_fail(player, "Sorry, it's not clear what you want to learn "
                "here.\n");
  needed = ({ });
  if(!has_required_skills(name, player))
    needed += ({ "skills" });
  if(!has_required_materials( name, player ))
    needed += ({ "materials" });
  if(!has_required_cash( name, player ))
    needed += ({ "cash" });
  if(sizeof(needed)) {
    debug_printf( "Player doesn't have the correct %s\n",
                  query_multiple_short(needed) );
    return add_failed_mess("Sorry, You don't have the correct " +
                  query_multiple_short(needed) + " to learn today.\n");
  }
  call_out("lesson_step", 1, name, player, 0);
  return 1;
}
string *query_lessons() { return keys(_lessons); }
protected void lesson_step(string name, object student, int lessonstep) {
  string str;
  class step current;
  object teacher = _lessons[name]->teacher;
  int i;
  current = _lessons[name]->plan[lessonstep];
  str = "";
  for(i=0; i<sizeof(current->responses); i++) {
    if(current->params && sizeof(current->params) > i) {
      str = " <string:'" + current->params[i] + "'>";
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), $4) :));
    } else {
      str = "";
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), "") :));
    }
  }
  foreach( str in (current->blurbs) ) {
   if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }
}
int lesson_response(string name, object student, int lessonstep, string args) {
  class step current;
  if(this_player() != student)
    return 0;
  current = _lessons[name]->plan[lessonstep];
  if(sizeof(current->params) &&
     member_array(args[0], current->params) == -1)
    return student->add_failed_mess(this_object(), "Invalid response.\n",
            ({ }));
  switch(TASKER->perform_task(student, current->skill, current->difficulty,
                              TM_FIXED)) {
  case AWARD:
    tell_object(student, "%^YELLOW%^"+current->award_mess+"%^RESET%^\n");
  case SUCCEED:
    tell_object( student, current->succeed_mess + "\n");
    student->remove_object(this_object(), 1);
    if( (sizeof(_lessons[name]->plan)-1) == lessonstep ) {
      tell_creator("belle", "Lesson is on its last step: %d\n", lessonstep );
      call_out( "lesson_end", 1, name, student );
      return 1;
    } else {
      call_out("lesson_step", 1, name, student, ++lessonstep);
    }
    break;
  default:
    tell_object(student, current->fail_mess + "\n" );
    break;
  }
  return 1;
}
int lesson_end ( string name, object student ) {
  string str;
  object teacher = _lessons[name]->teacher;
  foreach( str in (_lessons[name]->lesson_ending) ) {
    if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }
  return 1;
}

==================================================
FILE: lightable.c
==================================================

#include <fuel_handler.h>
#define HOLD_COMMAND "/cmds/living/ho_ld"
#define DEPARTURES "/room/departures"
inherit "/obj/weapon";
int max_fuel, fuel, lit, brightness, time, hold;
string empty_mess;
mixed fuel_messages;
int set_lit(int);
void create() {
   ::create();
   add_extra_look( this_object() );
}
void init() {
   this_player()->add_command( "light", this_object() );
   this_player()->add_command( "dowse", this_object() );
   this_player()->add_command( "extinguish", this_object() );
}
varargs string short( int dark ) {
   if( lit )
      return "lit "+ ::short( dark );
   else
      return ::short( dark );
}
void out_of_fuel() {
   object env;
   fuel = 0;
   lit = 0;
   set_lit( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   if( !environment() ) return;
   env = environment();
   if( living( env ) ) {
      tell_object( env, the_short() +" goes out.\n" );
      tell_room( environment( env ),
            env->the_short() +"'s "+ short() +" goes out.\n", env );
   } else {
      tell_room( env, the_short() +" goes out.\n" );
   }
}
void delayed_light() {
   lit = 1;
}
int hold_thing() {
   if( !query_wielded() )
      return HOLD_COMMAND->cmd( ({ this_object() }) );
   else
      return 1;
}
int set_lit( int i ) {
   if( !i ) {
      if( !query_property( "unextinguishable" ) ) {
         lit = 0;
         FUEL_HANDLER->remove_burner( this_object() );
         remove_adjective( "lit" );
         set_light( 0 );
         return 0;
      }
   } else {
      if( !query_property( "unlightable" ) && fuel > 0 ) {
         if( lit )
            return 1;
         if( hold && !hold_thing() )
            return 0;
         call_out( (: delayed_light :), 2 );
         FUEL_HANDLER->add_burner( this_object() );
         add_adjective( "lit" );
         set_light( brightness );
         return 1;
      }
   }
}
mixed set_holder( object ob, int pos ) {
   if( lit && hold && !ob && environment( this_player() )
       && file_name( environment( this_player() ) ) != DEPARTURES )
      if( !set_lit( 0 ) ) {
         tell_object( this_player(), "You extinguish "+ the_short() +".\n" );
         tell_room( environment( this_player() ), this_player()->the_short() +
               " extinguishes "+ the_short() +".\n", this_player() );
     }
   return ::set_holder( ob, pos );
}
int query_lit() {
   return lit;
}
int do_light() {
   if( lit )
      return notify_fail( the_short() +" is already lit.\n" );
   if( !fuel )
      return notify_fail( the_short() +" "+ empty_mess +"\n" );
   if( !set_lit( 1 ) )
      return notify_fail( "You cannot light "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}
int do_dowse() {
   if( !lit )
      return notify_fail( the_short() +" is not lit.\n" );
   if( set_lit( 0 ) )
      return notify_fail( "You cannot extinguish "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}
int do_extinguish() {
   return do_dowse();
}
void set_fuel_messages( mixed msgs ) {
   fuel_messages = msgs;
}
mixed query_fuel_messages() {
   return fuel_messages;
}
void set_max_fuel( int i ) {
   max_fuel = i;
}
int query_max_fuel() {
   return max_fuel;
}
void set_fuel( int i ) {
   fuel = i;
   if( fuel > max_fuel )
      fuel = max_fuel;
}
int query_fuel() {
   return fuel;
}
string current_fuel_message() {
   mixed messages;
   int fuel_percent, size, i;
   string fuel_string = "";
   if( fuel < 1 )
      return "It "+ empty_mess;
   messages = query_fuel_messages();
   size = sizeof( messages );
   if( !size )
      return "This item needs a creator.  It is broken and lonely.";
   if( size < 2 )
      return messages[0];
   fuel_percent = fuel * 99 / max_fuel;
   if( intp( messages[1] ) ) {
      for( i = 1; i < size; i += 2 ) {
         if( messages[i] > fuel_percent ) {
            fuel_string = messages[i-1];
            break;
         }
      }
      if( fuel_string == "" )
         fuel_string = messages[ size - 2 ];
   } else {
      fuel_string = messages[ fuel_percent * size / 100 ];
   }
   return fuel_string;
}
void set_empty_mess( string msg ) {
   empty_mess = msg;
}
string query_empty_mess() {
   return empty_mess;
}
void set_brightness( int i ) {
   brightness = i;
}
int query_brightness() {
   return brightness;
}
void set_hold_required( int hands ) {
   hold = hands;
}
int query_hold_required() {
   return hold;
}
string extra_look() {
   string lit_str;
   if( lit )
      lit_str = "It is lit.  ";
   else
      lit_str = "It is not currently lit.  ";
   return lit_str + current_fuel_message() +"\n";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel" : fuel,
             "lit" : lit,
           ]);
}
void init_dynamic_arg(mapping arg, object bing ) {
   fuel = arg["fuel"];
   ::init_dynamic_arg(arg["::"], bing);
   set_lit(arg["lit"]);
}
void consume_fuel() {
   fuel -= FUEL_TIME;
   if( fuel < 1 )
      out_of_fuel();
}
int query_value() {
   return (int)( ::query_value() * fuel / max_fuel );
}
varargs int move( mixed dest, string messin, string messout ) {
   object destination;
   if( objectp( dest ) ) {
      destination = dest;
   } else {
      destination = load_object( dest );
   }
   if( ( inherits( "/std/container", destination ) &&
         !living( destination ) ) ||
       inherits( "/std/uwater", destination ) ||
       inherits( "/std/water_inside", destination ) ||
       inherits( "/std/water_outside", destination ) ) {
      set_lit( 0 );
   }
   return ::move( dest, messin, messout );
}

==================================================
FILE: map.c
==================================================

#include <terrain_map.h>
inherit "/std/object";
#define WORLD_MAP TERRAIN_MAP_WORLD_MAP
private nosave int *_area;
private nosave int _detail;
private nosave string *_features;
private nosave mapping _locations;
private nosave object _env, _pl;
private nosave int *_co_ords;
private nosave int _fudge;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_alias("map");
  add_plural("maps");
  _locations = ([ ]);
  add_extra_look(this_object());
  if(!do_setup) {
    this_object()->setup();
  }
}
string extra_look() {
  return "Marked on the map are " +
    query_multiple_short(_features->query_base_description() +
                         keys(_locations)) + ".";
}
int filter_features(string feature) {
#ifdef DEBUG
  debug_printf("%s %d %d", feature,
               feature->query_max_range() / TERRAIN_MAP_ONE_MILE,
               _detail / TERRAIN_MAP_ONE_MILE);
#endif
  return (!feature->query_max_range() ||
          feature->query_max_range() >= _detail);
}
void setup_map(int x1, int y1, int x2, int y2, int detail) {
  _area = ({ x1, y1, x2, y2 });
  _detail = detail;
  _features = WORLD_MAP->query_features_in_region(x1, y1, x2, y2);
  _features = filter(_features, "filter_features", this_object());
}
void set_map(string area) {
  int width, height, detail, x1, y1, x2, y2;
  switch(area) {
  case "sur":
    width = (TERRAIN_MAP_ONE_MILE * 300);
    height = (TERRAIN_MAP_ONE_MILE * 200);
    x1 = -150575040 - width;
    y1 = -2173248 - height;
    x2 = -150575040 + width;
    y2 = -2173248 + height;
    detail = (TERRAIN_MAP_ONE_MILE * 50);
    break;
  case "world":
    x1 = TERRAIN_MAP_WORLD_LOW_X / 10;
    y1 = TERRAIN_MAP_WORLD_LOW_Y / 10;
    x2 = TERRAIN_MAP_WORLD_HIGH_X / 10;
    y2 = TERRAIN_MAP_WORLD_HIGH_Y / 10;
    detail = (TERRAIN_MAP_ONE_MILE * 200);
    break;
  }
  setup_map(x1, y1, x2, y2, detail);
}
void recalc_coords() {
  int accuracy;
  if(!_co_ords || this_player() != _pl || environment(this_player()) != _env) {
    _pl = this_player();
    _env = environment(_pl);
    _co_ords = _env->query_co_ord();
    accuracy = 500 - _pl->query_skill_bonus("other.direction");
    if(accuracy < 1)
      accuracy = 1;
    _fudge = TERRAIN_MAP_ONE_MILE * accuracy;
    _co_ords[0] += -(_fudge/2) + random(_fudge);
    _co_ords[1] += -(_fudge/2) + random(_fudge);
    _co_ords[2] += -(_fudge/2) + random(_fudge);
  }
}
int do_consult(string find) {
  string feature, *res;
  object ob;
  mapping direcs;
  if(this_player()->check_dark(environment(this_player())->query_light()))
    return notify_fail("Sorry the light levels are not conducive to "
                       "reading a map.\n");
  recalc_coords();
  if(_co_ords[0] < _area[0] || _co_ords[1] < _area[1] ||
     _co_ords[0] > _area[2] || _co_ords[1] > _area[3])
    return notify_fail("Sorry, you do not appear to be anywhere on this "
                       "map.\n");
  res = ({ });
  foreach(feature in _features) {
    ob = feature->query_region_ob();
    if(ob) {
#ifdef DEBUG
      debug_printf("%O max range %d", feature,
                   feature->query_max_range()/TERRAIN_MAP_ONE_MILE);
#endif
      direcs = ob->query_feature_desc_from(_co_ords[0], _co_ords[1],
                                           _co_ords[2], 1);
      if(direcs) {
        if(find == "" || strsrch(lower_case(feature->query_base_description()),
                   lower_case(find)) != -1)
          res += ({ feature->calc_map_feature_desc(direcs, _fudge) });
      }
    }
  }
  if(res == ({ })) {
    if(find != "")
      return notify_fail("You cannot find " + find + " on your map.\n");
    else
      return notify_fail("You cannot find anything on your map.\n");
  }
  write("You consult your map and estimate that " +
        query_multiple_short(res) + "\n");
  this_player()->add_succeeded_mess(this_object(), "");
  return 1;
}
int do_add(string location) {
  if(member_array(lower_case(location), keys(_locations)) != -1)
    return notify_fail("A location with the name " + location +
                       " already exists on this map.\n");
  _locations[lower_case(location)] = _co_ords;
  this_player()->add_succeeded_mess(this_object(), "$N $V a new location "
                                    "to $D.\n");
  return 1;
}
void init() {
  this_player()->add_command("consult", this_object(), "<direct:object>",
                             (: do_consult("") :));
  this_player()->add_command("find", this_object(),
                             "<string'place'> on <direct:object>",
                             (: do_consult($4[0]) :));
  this_player()->add_command("add", this_object(),
                             "<string'description'> to <direct:object>",
                             (: do_add($4[0]) :));
}
mapping int_query_static_auto_load() {
  return ([
    "::": ::int_query_static_auto_load(),
    "features": _features,
    "detail": _detail,
    "area": _area,
  ]);
}
mixed query_static_auto_load() {
  if((file_name(this_object()))[0..7] != "/std/map" )
    return 0;
  return int_query_static_auto_load();
}
void init_static_arg(mapping args) {
  if(args["::"])
    ::init_static_arg(args["::"]);
  if(args["features"])
    _features = args["features"];
  if(args["detail"])
    _detail = args["detail"];
  if(args["area"])
    _area = args["area"];
}

==================================================
FILE: mineral.c
==================================================

#include <mineral.h>
#define HANDLER "/obj/handlers/cmr_handler"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
#define DEFAULT_MARKET "Ankh-Morpork"
inherit "/std/object";
int check_tool( object *tools );
nosave string mineral;
void create() {
   write( "If you've not just logged in and are waiting for your "
         "inventory to be regenerated, please bug report this location, "
         "as it's using the obsolete mineral object.\n" );
   ::create();
}
void init() {
   this_player()->add_command( "chip", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "chip", this_object(), "<direct:object> 'using' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'using' <indirect:object>" );
}
varargs void make_mineral( string word, int number, string *inputs ) {
   string adjective, material_adjective, colour_code, noun, *args;
   mineral = word;
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   colour_code = (string)HANDLER->query_material_ansi_colour( mineral );
   set_weight( number );
   switch( number ) {
      case 0..PEBBLE:
         adjective = "small";
         noun = "pebble";
         break;
      case PEBBLE+1..STONE:
         adjective = "medium sized";
         noun = "stone";
         break;
      case STONE+1..ROCK:
         adjective = "large";
         noun = "rock";
         break;
      default:
         adjective = "huge";
         noun = "boulder";
   }
   if ( !pointerp( inputs ) )
      args = allocate( 10 );
   else
      args = inputs + ({ 0, 0, 0, 0, 0 });
   if ( !args[0] ) {
      set_name( noun );
      add_plural( noun +"s" );
   } else {
      set_name( args[0] );
      if ( !args[3] )
         add_plural( args[0] +"s" );
      else
         add_plural( args[3] );
   }
   if ( !args[1] ) {
      set_short( colour_code + material_adjective +" "+ noun +"%^RESET%^" );
      set_main_plural( colour_code + material_adjective +" "+ noun +
            "s%^RESET%^" );
   } else {
      set_short( args[1] );
      if ( !args[4] )
         set_main_plural( args[1] +"s" );
      else
         set_main_plural( args[4] );
   }
   if ( !args[2] )
      set_long( "This is a "+ adjective +" lump of $mineral$.\n" );
   else
      set_long( args[2] );
   add_adjective( ({ adjective }) + explode( material_adjective, " " ) );
}
string long( string str, int dark ) {
   string bit1, bit2, ret;
   sscanf( ::long( str, dark ), "%s$mineral$%s", bit1, bit2 );
   ret = bit1 + (string)HANDLER->identify_material( mineral, this_player(), 1 )
      + bit2;
   return ret;
}
string *query_adjectives() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::query_adjectives() + ({ ret });
}
string *parse_command_adjectiv_id_list() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::parse_command_adjectiv_id_list() + ({ ret });
}
string query_mineral() { return mineral; }
string query_material() { return mineral; }
int query_value() {
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral,
            DEFAULT_MARKET ) );
}
int query_value_in( string word ) {
  if ( ( !word || ( word == "" ) ) || ( word == "default" ) )
    word = DEFAULT_MARKET;
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral, word ) );
}
int do_chip( object *tools ) {
   object chip;
   if ( !check_tool( tools ) )
      return 0;
   if ( query_weight() == 1 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
                this_player(), 0 ) +" is already a chip.\n" );
      return 0;
   }
   set_weight( query_weight() - 1 );
   chip = clone_object( MINERAL );
   chip->make_mineral( mineral, 1 );
   chip->move( environment() );
   this_player()->add_succeeded( tools[0] );
   return 1;
}
int do_smash( object *tools ) {
   int i, j, largest, number, size;
   object debris, remains;
   if ( !check_tool( tools ) )
      return 0;
   largest = this_player()->query_max_weight();
   if ( largest >= query_weight() )
      largest = query_weight();
   else {
      remains = clone_object( MINERAL );
      remains->make_mineral( mineral, query_weight() - largest );
      remains->move( environment() );
   }
   tools[ 0 ]->hit_weapon( largest, "blunt" );
   number = 2 + random( 4 );
   for ( i = 0; i < 8; i++ ) {
      largest /= number;
      for ( j = 1; j < number; j++ ) {
         size = ( 3 * largest + random( largest ) ) / 4;
         if ( size ) {
            debris = clone_object( MINERAL );
            debris->make_mineral( mineral, size );
            debris->move( environment() );
          }
       }
   }
   this_player()->add_succeeded( tools[0] );
   move( "/room/rubbish" );
   return 1;
}
int check_tool( object *tools ) {
   string tool;
   object *held;
   if ( sizeof( tools ) > 1 ) {
      write( "You only need to use one tool at a time.\n" );
      return 0;
   }
   if ( !sizeof( tools ) ) {
      write( "You need to use a tool of some sort.\n" );
      return 0;
   }
   held = this_player()->query_holding();
   if ( member_array( tools[0], held ) == -1 ) {
      write( "You need to use a tool that you are holding.\n" );
      return 0;
   }
   tool = tools[0]->query_name();
   if ( member_array( tool, ({ "pickaxe", "pick" }) ) == -1 ) {
      write( "You need to use a tool appropriate to the job.\n" );
      return 0;
   }
   return 1;
}
mixed *stats() {
   return ::stats() + ({
      ({ "mineral", mineral, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "mineral" : mineral,
   ]);
}
void init_static_arg( mapping map ) {
   if ( map["::"] )
      ::init_static_arg( map["::"] );
   if ( !undefinedp( map["mineral"] ) )
      mineral = map["mineral"];
}
mixed query_static_auto_load() {
   if ( file_name( this_object() )[ 0 .. 11 ] == "/std/mineral" )
      return int_query_static_auto_load();
   return ([ ]);
}
