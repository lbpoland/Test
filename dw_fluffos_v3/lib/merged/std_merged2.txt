# Total Tokens: 21196
# Total Files Merged: 16
# Total Characters: 70698

============================================

inherit "/std/object";
#include <shops/engrave.h>
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_name("key");
  set_long("A key.  Wonder where it fits?.\n");
  add_plural("keys");
  set_short("key");
  add_property(ENGRAVE_PROP, 1);
  if(!do_setup) {
    this_object()->setup();
  }
}
void set_key( string str, string prop ) {
  string *bits;
  int i;
  set_short( str + " key" );
  set_main_plural( str + " keys" );
  set_name( "key" );
  add_plural( "keys" );
  bits = explode( str, " " );
  for( i = 0; i < sizeof( bits ); i ++ ) {
    add_adjective( bits[i] );
  }
  add_property( prop, 1 );
  set_value( 0 );
  set_weight( 1 );
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

==================================================
FILE: leaflet.c
==================================================

inherit "/std/object";
private int page;
private mixed *pages;
int do_open(int page_no);
void create() {
   do_setup++;
   ::create();
   do_setup--;
   pages = ({ ({ }) });
   if ( !do_setup )
      this_object()->setup();
  add_help_file("leaflet");
}
int query_leaflet() { return 1; }
int query_page() { return page; }
mixed *query_pages() { return copy( pages ); }
void init() {
   add_command( "turn", "[a] page of <direct:object>" );
   add_command( "open", "<direct:object> to [page] <number>",
                (: do_open($4[1]) :));
}
void set_no_pages( int number ) {
   int i;
   if ( number < 1 ) {
      number = 1;
   }
   pages = ({ });
   for ( i = 0; i < number; i++ ) {
      pages += ({ ({ }) });
   }
}
varargs void set_read_mess( mixed mess, string lang, int size ) {
   ::set_read_mess( mess, lang, size );
   pages[ page ] = query_read_mess();
}
mixed add_read_mess( mixed mess, string type, string lang, int size ) {
   mixed ret;
   ret = ::add_read_mess( mess, type, lang, size );
   pages[ page ] = query_read_mess();
   return ret;
}
int query_open_page() { return page + 1; }
void set_open_page( int number ) {
   if ( ( number < 1 ) || ( number > sizeof( pages ) ) ) {
      number = 1;
   }
   page = number - 1;
   ::set_read_mess( pages[ page ] );
}
int do_turn() {
   set_open_page( page + 2 );
   return 1;
}
int do_open(int page_no) {
   if ( ( page_no < 1 ) || ( page_no > sizeof( pages ) ) ) {
      add_failed_mess("The page no " + page_no + " does not exist.\n");
      return 0;
   }
   set_open_page(page_no);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/std/leaflet" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "page" : page,
      "pages" : copy( pages ),
   ]);
}
void init_dynamic_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   }
   page = map[ "page" ];
   if ( pointerp( map[ "pages" ] ) ) {
      pages = map[ "pages" ];
      set_open_page( page + 1 );
   }
}
string query_read_short(object player, int ignore_labels) {
   string ret;
   if (page == 0) {
      ret = ::query_read_short(player, 1);
   } else {
      ret = ::query_read_short(player, 0);
   }
   return "page " + query_num(page) + " of " + ret;
}

==================================================
FILE: learning.c
==================================================

#include <money.h>
#include <tasks.h>
class step {
  string *blurbs;
  string skill;
  int difficulty;
  string *responses;
  string *params;
  string award_mess;
  string succeed_mess;
  string fail_mess;
}
class lesson {
  mapping minimum_skills;
  mapping maximum_skills;
  string *materials;
  int cost;
  string currency;
  string *lesson_ending;
  object teacher;
  class step *plan;
}
private nosave mapping _lessons;
private nosave int current_step;
private nosave int attempt;
int lesson_response(string, object, int, string);
int register_lesson(string name, mapping minimum_skills,
                    mapping maximum_skills, string *materials, int cost,
                    string currency, string *lesson_ending, object teacher ) {
  if(!_lessons)
    _lessons = ([ ]);
  if(_lessons[name])
    return 0;
  _lessons[name] = new(class lesson,
                       minimum_skills : minimum_skills,
                       maximum_skills : maximum_skills,
                       materials : materials,
                       cost : cost,
                       currency : currency,
                       lesson_ending : lesson_ending,
                       teacher : teacher
                       );
  return 1;
}
int add_step( string lesson_name, string *blurbs, string skill, int diff,
        string *responses, string *params, string award_mess, string succeed_mess,
        string fail_mess) {
  if(!_lessons)
    _lessons = ([ ]);
  if( !_lessons[lesson_name] ){
    return 0;
  }
  if( !_lessons[lesson_name]->plan ){
    _lessons[lesson_name]->plan = ({ });
  }
  _lessons[lesson_name]->plan += ({ new(class step,
          blurbs : blurbs,
          skill : skill,
          difficulty : diff,
          responses : responses,
          params : params,
          award_mess : award_mess,
          succeed_mess : succeed_mess,
          fail_mess : fail_mess
          ) });
  return 1;
}
int has_required_skills( string name, object player ) {
  string skill;
  int p_level;
  foreach( skill in (keys(_lessons[name]->minimum_skills)) ){
    p_level = player->query_skill(skill);
    if( p_level < _lessons[name]->minimum_skills[skill] ){
      return 0;
    }
  }
  foreach( skill in (keys(_lessons[name]->maximum_skills)) ){
    p_level = player->query_skill(skill);
    if( p_level > _lessons[name]->maximum_skills[skill] ){
      return 0;
    }
  }
  return 1;
}
int has_required_materials( string name, object player ) {
  string mat;
  foreach( mat in _lessons[name]->materials ) {
    if( sizeof( filter_array(deep_inventory(player),
           (: ($1)->query_short() :) ) ) ){
      return 1;
    }
  }
  return 0;
}
int has_required_cash( string name, object player ) {
  if(player->query_value_in(_lessons[name]->currency) < _lessons[name]->cost) {
    return 0;
  } else {
    return 1;
  }
}
int start_lesson(string name, object player) {
  string *needed;
  if(!_lessons[name])
    return notify_fail(player, "Sorry, it's not clear what you want to learn "
                "here.\n");
  needed = ({ });
  if(!has_required_skills(name, player))
    needed += ({ "skills" });
  if(!has_required_materials( name, player ))
    needed += ({ "materials" });
  if(!has_required_cash( name, player ))
    needed += ({ "cash" });
  if(sizeof(needed)) {
    debug_printf( "Player doesn't have the correct %s\n",
                  query_multiple_short(needed) );
    return add_failed_mess("Sorry, You don't have the correct " +
                  query_multiple_short(needed) + " to learn today.\n");
  }
  call_out("lesson_step", 1, name, player, 0);
  return 1;
}
string *query_lessons() { return keys(_lessons); }
protected void lesson_step(string name, object student, int lessonstep) {
  string str;
  class step current;
  object teacher = _lessons[name]->teacher;
  int i;
  current = _lessons[name]->plan[lessonstep];
  str = "";
  for(i=0; i<sizeof(current->responses); i++) {
    if(current->params && sizeof(current->params) > i) {
      str = " <string:'" + current->params[i] + "'>";
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), $4) :));
    } else {
      str = "";
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), "") :));
    }
  }
  foreach( str in (current->blurbs) ) {
   if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }
}
int lesson_response(string name, object student, int lessonstep, string args) {
  class step current;
  if(this_player() != student)
    return 0;
  current = _lessons[name]->plan[lessonstep];
  if(sizeof(current->params) &&
     member_array(args[0], current->params) == -1)
    return student->add_failed_mess(this_object(), "Invalid response.\n",
            ({ }));
  switch(TASKER->perform_task(student, current->skill, current->difficulty,
                              TM_FIXED)) {
  case AWARD:
    tell_object(student, "%^YELLOW%^"+current->award_mess+"%^RESET%^\n");
  case SUCCEED:
    tell_object( student, current->succeed_mess + "\n");
    student->remove_object(this_object(), 1);
    if( (sizeof(_lessons[name]->plan)-1) == lessonstep ) {
      tell_creator("belle", "Lesson is on its last step: %d\n", lessonstep );
      call_out( "lesson_end", 1, name, student );
      return 1;
    } else {
      call_out("lesson_step", 1, name, student, ++lessonstep);
    }
    break;
  default:
    tell_object(student, current->fail_mess + "\n" );
    break;
  }
  return 1;
}
int lesson_end ( string name, object student ) {
  string str;
  object teacher = _lessons[name]->teacher;
  foreach( str in (_lessons[name]->lesson_ending) ) {
    if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }
  return 1;
}

==================================================
FILE: lightable.c
==================================================

#include <fuel_handler.h>
#define HOLD_COMMAND "/cmds/living/ho_ld"
#define DEPARTURES "/room/departures"
inherit "/obj/weapon";
int max_fuel, fuel, lit, brightness, time, hold;
string empty_mess;
mixed fuel_messages;
int set_lit(int);
void create() {
   ::create();
   add_extra_look( this_object() );
}
void init() {
   this_player()->add_command( "light", this_object() );
   this_player()->add_command( "dowse", this_object() );
   this_player()->add_command( "extinguish", this_object() );
}
varargs string short( int dark ) {
   if( lit )
      return "lit "+ ::short( dark );
   else
      return ::short( dark );
}
void out_of_fuel() {
   object env;
   fuel = 0;
   lit = 0;
   set_lit( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   if( !environment() ) return;
   env = environment();
   if( living( env ) ) {
      tell_object( env, the_short() +" goes out.\n" );
      tell_room( environment( env ),
            env->the_short() +"'s "+ short() +" goes out.\n", env );
   } else {
      tell_room( env, the_short() +" goes out.\n" );
   }
}
void delayed_light() {
   lit = 1;
}
int hold_thing() {
   if( !query_wielded() )
      return HOLD_COMMAND->cmd( ({ this_object() }) );
   else
      return 1;
}
int set_lit( int i ) {
   if( !i ) {
      if( !query_property( "unextinguishable" ) ) {
         lit = 0;
         FUEL_HANDLER->remove_burner( this_object() );
         remove_adjective( "lit" );
         set_light( 0 );
         return 0;
      }
   } else {
      if( !query_property( "unlightable" ) && fuel > 0 ) {
         if( lit )
            return 1;
         if( hold && !hold_thing() )
            return 0;
         call_out( (: delayed_light :), 2 );
         FUEL_HANDLER->add_burner( this_object() );
         add_adjective( "lit" );
         set_light( brightness );
         return 1;
      }
   }
}
mixed set_holder( object ob, int pos ) {
   if( lit && hold && !ob && environment( this_player() )
       && file_name( environment( this_player() ) ) != DEPARTURES )
      if( !set_lit( 0 ) ) {
         tell_object( this_player(), "You extinguish "+ the_short() +".\n" );
         tell_room( environment( this_player() ), this_player()->the_short() +
               " extinguishes "+ the_short() +".\n", this_player() );
     }
   return ::set_holder( ob, pos );
}
int query_lit() {
   return lit;
}
int do_light() {
   if( lit )
      return notify_fail( the_short() +" is already lit.\n" );
   if( !fuel )
      return notify_fail( the_short() +" "+ empty_mess +"\n" );
   if( !set_lit( 1 ) )
      return notify_fail( "You cannot light "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}
int do_dowse() {
   if( !lit )
      return notify_fail( the_short() +" is not lit.\n" );
   if( set_lit( 0 ) )
      return notify_fail( "You cannot extinguish "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}
int do_extinguish() {
   return do_dowse();
}
void set_fuel_messages( mixed msgs ) {
   fuel_messages = msgs;
}
mixed query_fuel_messages() {
   return fuel_messages;
}
void set_max_fuel( int i ) {
   max_fuel = i;
}
int query_max_fuel() {
   return max_fuel;
}
void set_fuel( int i ) {
   fuel = i;
   if( fuel > max_fuel )
      fuel = max_fuel;
}
int query_fuel() {
   return fuel;
}
string current_fuel_message() {
   mixed messages;
   int fuel_percent, size, i;
   string fuel_string = "";
   if( fuel < 1 )
      return "It "+ empty_mess;
   messages = query_fuel_messages();
   size = sizeof( messages );
   if( !size )
      return "This item needs a creator.  It is broken and lonely.";
   if( size < 2 )
      return messages[0];
   fuel_percent = fuel * 99 / max_fuel;
   if( intp( messages[1] ) ) {
      for( i = 1; i < size; i += 2 ) {
         if( messages[i] > fuel_percent ) {
            fuel_string = messages[i-1];
            break;
         }
      }
      if( fuel_string == "" )
         fuel_string = messages[ size - 2 ];
   } else {
      fuel_string = messages[ fuel_percent * size / 100 ];
   }
   return fuel_string;
}
void set_empty_mess( string msg ) {
   empty_mess = msg;
}
string query_empty_mess() {
   return empty_mess;
}
void set_brightness( int i ) {
   brightness = i;
}
int query_brightness() {
   return brightness;
}
void set_hold_required( int hands ) {
   hold = hands;
}
int query_hold_required() {
   return hold;
}
string extra_look() {
   string lit_str;
   if( lit )
      lit_str = "It is lit.  ";
   else
      lit_str = "It is not currently lit.  ";
   return lit_str + current_fuel_message() +"\n";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel" : fuel,
             "lit" : lit,
           ]);
}
void init_dynamic_arg(mapping arg, object bing ) {
   fuel = arg["fuel"];
   ::init_dynamic_arg(arg["::"], bing);
   set_lit(arg["lit"]);
}
void consume_fuel() {
   fuel -= FUEL_TIME;
   if( fuel < 1 )
      out_of_fuel();
}
int query_value() {
   return (int)( ::query_value() * fuel / max_fuel );
}
varargs int move( mixed dest, string messin, string messout ) {
   object destination;
   if( objectp( dest ) ) {
      destination = dest;
   } else {
      destination = load_object( dest );
   }
   if( ( inherits( "/std/container", destination ) &&
         !living( destination ) ) ||
       inherits( "/std/uwater", destination ) ||
       inherits( "/std/water_inside", destination ) ||
       inherits( "/std/water_outside", destination ) ) {
      set_lit( 0 );
   }
   return ::move( dest, messin, messout );
}

==================================================
FILE: map.c
==================================================

#include <terrain_map.h>
inherit "/std/object";
#define WORLD_MAP TERRAIN_MAP_WORLD_MAP
private nosave int *_area;
private nosave int _detail;
private nosave string *_features;
private nosave mapping _locations;
private nosave object _env, _pl;
private nosave int *_co_ords;
private nosave int _fudge;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_alias("map");
  add_plural("maps");
  _locations = ([ ]);
  add_extra_look(this_object());
  if(!do_setup) {
    this_object()->setup();
  }
}
string extra_look() {
  return "Marked on the map are " +
    query_multiple_short(_features->query_base_description() +
                         keys(_locations)) + ".";
}
int filter_features(string feature) {
#ifdef DEBUG
  debug_printf("%s %d %d", feature,
               feature->query_max_range() / TERRAIN_MAP_ONE_MILE,
               _detail / TERRAIN_MAP_ONE_MILE);
#endif
  return (!feature->query_max_range() ||
          feature->query_max_range() >= _detail);
}
void setup_map(int x1, int y1, int x2, int y2, int detail) {
  _area = ({ x1, y1, x2, y2 });
  _detail = detail;
  _features = WORLD_MAP->query_features_in_region(x1, y1, x2, y2);
  _features = filter(_features, "filter_features", this_object());
}
void set_map(string area) {
  int width, height, detail, x1, y1, x2, y2;
  switch(area) {
  case "sur":
    width = (TERRAIN_MAP_ONE_MILE * 300);
    height = (TERRAIN_MAP_ONE_MILE * 200);
    x1 = -150575040 - width;
    y1 = -2173248 - height;
    x2 = -150575040 + width;
    y2 = -2173248 + height;
    detail = (TERRAIN_MAP_ONE_MILE * 50);
    break;
  case "world":
    x1 = TERRAIN_MAP_WORLD_LOW_X / 10;
    y1 = TERRAIN_MAP_WORLD_LOW_Y / 10;
    x2 = TERRAIN_MAP_WORLD_HIGH_X / 10;
    y2 = TERRAIN_MAP_WORLD_HIGH_Y / 10;
    detail = (TERRAIN_MAP_ONE_MILE * 200);
    break;
  }
  setup_map(x1, y1, x2, y2, detail);
}
void recalc_coords() {
  int accuracy;
  if(!_co_ords || this_player() != _pl || environment(this_player()) != _env) {
    _pl = this_player();
    _env = environment(_pl);
    _co_ords = _env->query_co_ord();
    accuracy = 500 - _pl->query_skill_bonus("other.direction");
    if(accuracy < 1)
      accuracy = 1;
    _fudge = TERRAIN_MAP_ONE_MILE * accuracy;
    _co_ords[0] += -(_fudge/2) + random(_fudge);
    _co_ords[1] += -(_fudge/2) + random(_fudge);
    _co_ords[2] += -(_fudge/2) + random(_fudge);
  }
}
int do_consult(string find) {
  string feature, *res;
  object ob;
  mapping direcs;
  if(this_player()->check_dark(environment(this_player())->query_light()))
    return notify_fail("Sorry the light levels are not conducive to "
                       "reading a map.\n");
  recalc_coords();
  if(_co_ords[0] < _area[0] || _co_ords[1] < _area[1] ||
     _co_ords[0] > _area[2] || _co_ords[1] > _area[3])
    return notify_fail("Sorry, you do not appear to be anywhere on this "
                       "map.\n");
  res = ({ });
  foreach(feature in _features) {
    ob = feature->query_region_ob();
    if(ob) {
#ifdef DEBUG
      debug_printf("%O max range %d", feature,
                   feature->query_max_range()/TERRAIN_MAP_ONE_MILE);
#endif
      direcs = ob->query_feature_desc_from(_co_ords[0], _co_ords[1],
                                           _co_ords[2], 1);
      if(direcs) {
        if(find == "" || strsrch(lower_case(feature->query_base_description()),
                   lower_case(find)) != -1)
          res += ({ feature->calc_map_feature_desc(direcs, _fudge) });
      }
    }
  }
  if(res == ({ })) {
    if(find != "")
      return notify_fail("You cannot find " + find + " on your map.\n");
    else
      return notify_fail("You cannot find anything on your map.\n");
  }
  write("You consult your map and estimate that " +
        query_multiple_short(res) + "\n");
  this_player()->add_succeeded_mess(this_object(), "");
  return 1;
}
int do_add(string location) {
  if(member_array(lower_case(location), keys(_locations)) != -1)
    return notify_fail("A location with the name " + location +
                       " already exists on this map.\n");
  _locations[lower_case(location)] = _co_ords;
  this_player()->add_succeeded_mess(this_object(), "$N $V a new location "
                                    "to $D.\n");
  return 1;
}
void init() {
  this_player()->add_command("consult", this_object(), "<direct:object>",
                             (: do_consult("") :));
  this_player()->add_command("find", this_object(),
                             "<string'place'> on <direct:object>",
                             (: do_consult($4[0]) :));
  this_player()->add_command("add", this_object(),
                             "<string'description'> to <direct:object>",
                             (: do_add($4[0]) :));
}
mapping int_query_static_auto_load() {
  return ([
    "::": ::int_query_static_auto_load(),
    "features": _features,
    "detail": _detail,
    "area": _area,
  ]);
}
mixed query_static_auto_load() {
  if((file_name(this_object()))[0..7] != "/std/map" )
    return 0;
  return int_query_static_auto_load();
}
void init_static_arg(mapping args) {
  if(args["::"])
    ::init_static_arg(args["::"]);
  if(args["features"])
    _features = args["features"];
  if(args["detail"])
    _detail = args["detail"];
  if(args["area"])
    _area = args["area"];
}

==================================================
FILE: mineral.c
==================================================

#include <mineral.h>
#define HANDLER "/obj/handlers/cmr_handler"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
#define DEFAULT_MARKET "Ankh-Morpork"
inherit "/std/object";
int check_tool( object *tools );
nosave string mineral;
void create() {
   write( "If you've not just logged in and are waiting for your "
         "inventory to be regenerated, please bug report this location, "
         "as it's using the obsolete mineral object.\n" );
   ::create();
}
void init() {
   this_player()->add_command( "chip", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "chip", this_object(), "<direct:object> 'using' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'using' <indirect:object>" );
}
varargs void make_mineral( string word, int number, string *inputs ) {
   string adjective, material_adjective, colour_code, noun, *args;
   mineral = word;
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   colour_code = (string)HANDLER->query_material_ansi_colour( mineral );
   set_weight( number );
   switch( number ) {
      case 0..PEBBLE:
         adjective = "small";
         noun = "pebble";
         break;
      case PEBBLE+1..STONE:
         adjective = "medium sized";
         noun = "stone";
         break;
      case STONE+1..ROCK:
         adjective = "large";
         noun = "rock";
         break;
      default:
         adjective = "huge";
         noun = "boulder";
   }
   if ( !pointerp( inputs ) )
      args = allocate( 10 );
   else
      args = inputs + ({ 0, 0, 0, 0, 0 });
   if ( !args[0] ) {
      set_name( noun );
      add_plural( noun +"s" );
   } else {
      set_name( args[0] );
      if ( !args[3] )
         add_plural( args[0] +"s" );
      else
         add_plural( args[3] );
   }
   if ( !args[1] ) {
      set_short( colour_code + material_adjective +" "+ noun +"%^RESET%^" );
      set_main_plural( colour_code + material_adjective +" "+ noun +
            "s%^RESET%^" );
   } else {
      set_short( args[1] );
      if ( !args[4] )
         set_main_plural( args[1] +"s" );
      else
         set_main_plural( args[4] );
   }
   if ( !args[2] )
      set_long( "This is a "+ adjective +" lump of $mineral$.\n" );
   else
      set_long( args[2] );
   add_adjective( ({ adjective }) + explode( material_adjective, " " ) );
}
string long( string str, int dark ) {
   string bit1, bit2, ret;
   sscanf( ::long( str, dark ), "%s$mineral$%s", bit1, bit2 );
   ret = bit1 + (string)HANDLER->identify_material( mineral, this_player(), 1 )
      + bit2;
   return ret;
}
string *query_adjectives() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::query_adjectives() + ({ ret });
}
string *parse_command_adjectiv_id_list() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::parse_command_adjectiv_id_list() + ({ ret });
}
string query_mineral() { return mineral; }
string query_material() { return mineral; }
int query_value() {
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral,
            DEFAULT_MARKET ) );
}
int query_value_in( string word ) {
  if ( ( !word || ( word == "" ) ) || ( word == "default" ) )
    word = DEFAULT_MARKET;
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral, word ) );
}
int do_chip( object *tools ) {
   object chip;
   if ( !check_tool( tools ) )
      return 0;
   if ( query_weight() == 1 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
                this_player(), 0 ) +" is already a chip.\n" );
      return 0;
   }
   set_weight( query_weight() - 1 );
   chip = clone_object( MINERAL );
   chip->make_mineral( mineral, 1 );
   chip->move( environment() );
   this_player()->add_succeeded( tools[0] );
   return 1;
}
int do_smash( object *tools ) {
   int i, j, largest, number, size;
   object debris, remains;
   if ( !check_tool( tools ) )
      return 0;
   largest = this_player()->query_max_weight();
   if ( largest >= query_weight() )
      largest = query_weight();
   else {
      remains = clone_object( MINERAL );
      remains->make_mineral( mineral, query_weight() - largest );
      remains->move( environment() );
   }
   tools[ 0 ]->hit_weapon( largest, "blunt" );
   number = 2 + random( 4 );
   for ( i = 0; i < 8; i++ ) {
      largest /= number;
      for ( j = 1; j < number; j++ ) {
         size = ( 3 * largest + random( largest ) ) / 4;
         if ( size ) {
            debris = clone_object( MINERAL );
            debris->make_mineral( mineral, size );
            debris->move( environment() );
          }
       }
   }
   this_player()->add_succeeded( tools[0] );
   move( "/room/rubbish" );
   return 1;
}
int check_tool( object *tools ) {
   string tool;
   object *held;
   if ( sizeof( tools ) > 1 ) {
      write( "You only need to use one tool at a time.\n" );
      return 0;
   }
   if ( !sizeof( tools ) ) {
      write( "You need to use a tool of some sort.\n" );
      return 0;
   }
   held = this_player()->query_holding();
   if ( member_array( tools[0], held ) == -1 ) {
      write( "You need to use a tool that you are holding.\n" );
      return 0;
   }
   tool = tools[0]->query_name();
   if ( member_array( tool, ({ "pickaxe", "pick" }) ) == -1 ) {
      write( "You need to use a tool appropriate to the job.\n" );
      return 0;
   }
   return 1;
}
mixed *stats() {
   return ::stats() + ({
      ({ "mineral", mineral, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "mineral" : mineral,
   ]);
}
void init_static_arg( mapping map ) {
   if ( map["::"] )
      ::init_static_arg( map["::"] );
   if ( !undefinedp( map["mineral"] ) )
      mineral = map["mineral"];
}
mixed query_static_auto_load() {
   if ( file_name( this_object() )[ 0 .. 11 ] == "/std/mineral" )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: object.c
==================================================

#include <cmr.h>
inherit "/std/basic/extra_look";
inherit "/std/basic/enchant";
inherit "/std/basic/id";
inherit "/std/basic/misc";
inherit "/std/basic/property";
inherit "/std/basic/read_desc";
inherit "/std/basic/auto_load";
inherit "/std/basic/help_files";
inherit "/std/basic/theft_callback";
inherit "/std/basic/effects";
#define AUTO_LOAD_TAG "basic.object";
nosave int do_setup;
nosave string create_me;
nosave string colour;
private string* _materials;
nosave object player;
void create() {
  _materials = ({ });
  extra_look::create();
  id::create();
  misc::create();
  property::create();
  read_desc::create();
  effects::create();
  seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
  if ( this_player() ) {
    create_me = (string)this_player()->query_name();
  } else {
    create_me = "who knows";
  }
  if ( !do_setup ) {
    this_object()->setup();
  }
}
void set_name( string word ) {
  if ( query_name() && ( query_name() != "object" ) ) {
    ::set_name(word);
    return;
  }
  ::set_name(word);
  if ( !short_d ) {
    short_d = word;
  }
  add_plural( pluralize( word ) );
}
string query_long_details(string arg, int dark, object looker) {
   string stuff;
   stuff = "";
   if ( this_player()->query_see_octarine() ) {
      stuff += enchant_string();
   }
   if ( sizeof( query_read_mess() ) ) {
      stuff += "It appears to have something written on it.\n";
   }
   return stuff;
}
string replace_long_dollars(object player, string text) {
   if ( colour ) {
      text = replace( text, "$colour$",
          (string)CMR_HANDLER->identify_colour( colour, player ) );
   }
   if ( sizeof(_materials) ) {
      text = replace( text, "$material$",
          (string)CMR_HANDLER->identify_material( _materials[0], player, 1 ) );
   }
   return text;
}
string long( string word, int dark ) {
   string stuff;
   stuff = ::long( word, dark );
   stuff += calc_extra_look();
   stuff += query_long_details(word, dark, this_player());
   stuff = replace_long_dollars( this_player(), stuff );
   return stuff;
}
string query_colour() { return colour; }
void set_colour( string word ) { colour = word; }
string query_material() {
   if (sizeof(_materials)) {
      return _materials[0];
   }
   return 0;
}
string* query_materials() {
    string *new_materials;
    new_materials = ({ });
     if(!_materials) _materials=({ });
    foreach( mixed bit in _materials ) {
        if ( stringp( bit ) ) {
            new_materials += ({ bit });
        }
        else {
            if ( arrayp( bit ) ) {
                foreach( mixed inner_bit in bit ) {
                    if( stringp( inner_bit ) ) {
                        new_materials += ({ inner_bit });
                    }
                }
            }
        }
    }
   return new_materials;
}
void set_material( mixed word ) {
   if (!arrayp(word)) {
      word = ({ word });
   }
   if (sizeof (word)) {
      _materials = word + _materials;
      add_adjective(word);
   }
}
void add_material(mixed material) {
   if (pointerp(material)) {
      _materials |= material;
   } else if (stringp(material)) {
      _materials += ({ material });
   }
   add_adjective(material);
}
string query_pronoun() { return "it"; }
string query_possessive() { return "its"; }
string query_objective() { return "it"; }
string query_cloned_by() { return create_me; }
void set_quality(int quality) {
   add_property("quality", quality);
}
int query_quality() {
   return query_property("quality");
}
mixed *stats() {
  if(!_materials) _materials=({ });
  return ({
    ({ "name" , query_name(), }),
    ({ "short", short( 0 ), }),
    ({ "plural", query_plural(0), }),
    ({ "weight", (int)this_object()->query_weight(), }),
    ({ "enchantment", query_enchant(), }),
    ({ "colour", colour, }),
    ({ "material", query_multiple_short(_materials), }),
    ({ "cloned by", create_me, }),
    ({ "length", (int)this_object()->query_length(), }),
    ({ "width", (int)this_object()->query_width(), }),
   }) + property::stats() + misc::stats() + effects::stats();
}
mapping int_query_static_auto_load() {
  return ([
    "name" : query_name(),
    "short" : short_d,
    "main plural" : plural_d,
    "long" : long_d,
    "alias" : query_alias(1),
    "adjective" : query_adjectives(1),
    "plural adjective" : query_plural_adjectives(),
    "plural" : query_plurals(),
    "value" : value,
    "value info" : value_info + ([ ]),
    "weight" : weight,
    "colour" : colour,
    "length" : length,
    "width" : width,
  ]);
}
mapping query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/std/object" ) {
    return ([ ]);
  }
  return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   mapping map;
   if ( !query_name() || ( query_name() == "object" ) ) {
      return 0;
   }
   if ( query_enchant() > this_object()->query_max_enchant() ) {
      set_enchant(this_object()->query_max_enchant());
   }
   map = ([
      "read mess" : ::query_read_mess(),
      "degrade enchantment" : query_degrade_enchant(),
      "enchantment" : query_real_enchant(),
      "enchantment time" : query_enchant_set_time(),
      "light" : query_my_light(),
      "materials" : query_materials(),
      "cloned by" : create_me,
   ]);
   if ( map_prop ) {
      map[ "properties" ] = copy( map_prop );
   }
   if ( timed_properties ) {
      save_player_properties();
      map[ "timed properties" ] = copy(timed_properties);
   }
   if ( sizeof(query_effs() ) ) {
     effect_freeze();
     effects_saving();
     map += ([
              "effects" : ({
                (mixed *)query_effs(),
                  (int *)query_eeq()
                  })
              ]);
     effect_unfreeze();
   }
   if ( this_object()->query_special() ) {
      map[ "special" ] =  (mapping)this_object()->query_special_info();
   }
   if ( query_deity() ) {
     map[ "consecrated" ] = query_deity();
   }
   return map;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( !undefinedp( map[ "name" ] ) ) {
      set_name(map[ "name" ]);
   }
   if ( !undefinedp( map[ "short" ] ) ) {
      set_short( map[ "short" ] );
   }
   if ( !undefinedp( map[ "main plural" ] ) ) {
      set_main_plural( map[ "main plural" ] );
   }
   if ( !undefinedp( map[ "long" ] ) ) {
      set_long( map[ "long" ] );
   }
   if ( map[ "alias" ] ) {
      set_aliases( map[ "alias" ] );
   }
   if ( map[ "adjective" ] ) {
      set_adjectives( map[ "adjective" ] );
   }
   if ( map[ "plural adjective" ] ) {
      set_plural_adjectives( map[ "plural adjective" ] );
   }
   if ( map[ "plural" ] ) {
      set_plurals( map[ "plural" ] );
   }
   if ( !undefinedp( map[ "value" ] ) ) {
      set_value( map[ "value" ] );
   }
   if ( !undefinedp( map[ "value info" ] ) ) {
      value_info = map[ "value info" ];
   }
   if ( !undefinedp( map[ "weight" ] ) ) {
      set_weight( map[ "weight" ] );
   }
   if ( !undefinedp( map[ "colour" ] ) ) {
      set_colour( map[ "colour" ] );
   }
   if ( !undefinedp( map[ "material" ] ) ) {
      set_material( map[ "material" ] );
   }
   if ( !undefinedp( map[ "length" ] ) ) {
      set_length( map[ "length" ] );
   }
   if ( !undefinedp( map[ "width" ] ) ) {
      set_width( map[ "width" ] );
   }
}
void set_player( object thing ) { player = thing; }
void init_dynamic_arg( mapping map, object ) {
   int recycle;
   if ( !mapp( map ) )
      return;
   recycle = query_property("no recycling");
   if ( map[ "properties" ] )
      map_prop = map[ "properties" ];
   if (recycle)
      add_property("no recycling", recycle);
   if ( map[ "timed properties" ] ) {
      timed_properties = map[ "timed properties" ];
      reload_player_properties();
   }
   if ( sizeof( map[ "read mess" ] ) )
      set_read_mess( map[ "read mess" ] );
   if ( !undefinedp( map[ "materials" ] ) ) {
      _materials = map["materials"];
   }
   set_enchant(map["enchantment"]);
   set_degrade_enchant(map["degrade enchantment"]);
   if (map["enchantment time"]) {
      set_enchant_set_time(map["enchantment time"]);
   }
   set_light( map[ "light" ] );
   create_me = map[ "cloned by" ];
   if( map[ "effects" ] ) {
     set_effs( map[ "effects" ][ 0 ] );
     set_eeq( map[ "effects" ][ 1 ] );
     if ( environment() && shadow( this_object(), 0 ) )
       move_object( environment() );
   }
   init_after_save();
   if ( map[ "special" ] ) {
      clone_object( "/std/shadows/object/special_item" )->
            setup_shadow( this_object(), player );
      this_object()->set_special_info( map[ "special" ] );
   }
   if ( map[ "consecrated" ] ) {
     set_deity( map[ "consecrated" ] );
   }
}
string query_readable_message(object player, int ignore_labels) {
   string ret;
   string bing;
   object *labels;
   object ob;
   int *enums;
   object store;
   ret = ::query_readable_message(player);
   if (!ignore_labels) {
      enums = (int *)this_object()->effects_matching( "object.label" );
      if ( !sizeof( enums ) ) {
         labels = ({ });
      } else {
         store = (object)this_object()->arg_of( enums[ 0 ] )[ 0 ];
         if ( !objectp( store ) ) {
            labels = ({ });
         } else {
            labels = (object *)store->find_inv_match( "" );
         }
      }
      if (sizeof(labels) && !ret) {
         ret = "";
      }
      foreach (ob in labels) {
         ret += "On " + ob->the_short() + " is written:\n";
         bing = ob->query_readable_message(player, 0);
         if (bing) {
            ret += bing;
         } else {
            ret += "Nothing.\n";
         }
      }
   }
   return ret;
}
string query_read_short(object player, int ignore_labels) {
   string ret;
   object *labels;
   int *enums;
   object store;
   ret = ::query_read_short(player);
   if (!ignore_labels) {
      enums = (int *)this_object()->effects_matching( "object.label" );
      if ( !sizeof( enums ) ) {
         labels = ({ });
      } else {
         store = (object)this_object()->arg_of( enums[ 0 ] );
         if ( !objectp( store ) ) {
            labels = ({ });
         } else {
            labels = (object *)store->find_inv_match( "" );
         }
      }
      if (sizeof(labels)) {
         if (ret) {
            ret += " and " + query_multiple_short(labels, "the") +
                   " stuck on $name$";
         } else {
            ret = query_multiple_short(labels, "the") +
                   " stuck on $name$";
         }
      }
   }
   return ret;
}
string query_help_file_directory() {
   return "/doc/object/";
}
int clean_up(int inherited) {
  if(inherited) {
    log_file("CLEANUP", "%s %s cleaned up.\n", ctime(time()),
             file_name(this_object()));
    move("/room/rubbish");
  }
  return 1;
}
void dest_me() {
  effects_desting();
  ::dest_me();
}

==================================================
FILE: plant.c
==================================================

inherit "/std/object";
string plant_name, plant_type, plant_desc;
void set_plant(string name) { plant_name = name; add_alias(name);  }
void set_plant_type(string type) { plant_type = type; }
void set_plant_desc(string desc) { plant_desc = desc; }
string query_plant() { return plant_name; }
string query_plant_type() { return plant_type; }
string get_plant_short() {
  if (plant_name && plant_type)
    return plant_type;
  return "plant";
}
string get_plant_long() {
  if (plant_desc)
    return plant_desc;
  return "A lovely plant thingy.\n";
}
void setup() {
  set_name("plant");
  set_short((: get_plant_short() :));
  set_long((: get_plant_long() :));
  add_property("plant",1);
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "plant_name" : plant_name,
      "plant_type" : plant_type,
      "plant_desc" : plant_desc,
   ]);
}
void init_dynamic_arg( mapping map, object bing ) {
   if ( map["::"] )
      ::init_dynamic_arg( map["::"], bing );
   if ( !undefinedp( map["plant_name"] ) ) {
      plant_name = map["plant_name"];
   }
   if( !undefinedp( map["plant_type"] ) ) {
      plant_type = map["plant_type"];
   }
   if( !undefinedp( map["plant_desc"] ) ) {
      plant_desc = map["plant_desc"];
   }
}

==================================================
FILE: race.c
==================================================

#include "race.h"
inherit "/std/basic/print_object";
private mapping _races;
private mapping _guilds;
private mapping _race_obs;
private mapping _guild_obs;
void create() {
  string tmp;
  _races = ([
      0                  : "/std/races/human",
      "ape"              : "/std/races/ape",
      "arachnid"         : "/std/races/arachnid",
      "baboon"           : "/std/races/baboon",
      "basilisk"         : "/std/races/basilisk",
      "badger"           : "/std/races/badger",
      "bat"              : "/std/races/bat",
      "bear"             : "/std/races/bear",
      "beetle"           : "/std/races/beetle",
      "bird"             : "/std/races/bird",
      "blowfish"         : "/std/races/blowfish",
      "bufonid"          : "/std/races/bufonid",
      "cabbage"          : "/std/races/cabbage",
      "camel"            : "/std/races/camel",
      "cat"              : "/std/races/cat",
      "caterpillar"      : "/std/races/caterpillar",
      "chicken"          : "/std/races/chicken",
      "chimera"          : "/std/races/chimera",
      "cockroach"        : "/std/races/cockroach",
      "cow"              : "/std/races/cow",
      "crab"             : "/std/races/crab",
      "crocodile"        : "/std/races/crocodile",
      "deer"             : "/std/races/deer",
      "demon"            : "/std/races/demon",
      "dog"              : "/std/races/dog",
      "dryad"            : "/std/races/dryad",
      "duck"             : "/std/races/duck",
      "dwarf"            : "/std/races/dwarf",
      "duckling"         : "/std/races/duckling",
      "eagle"            : "/std/races/chicken",
      "elemental"        : "/std/races/elemental",
      "elephant"         : "/std/races/elephant",
      "elf"              : "/std/races/elf",
      "ferret"           : "/std/races/ferret",
      "fish"             : "/std/races/fish",
      "fox"              : "/std/races/fox",
      "frog"             : "/std/races/frog",
      "gargoyle"         : "/std/races/gargoyle",
      "giant"            : "/std/races/giant",
      "giant bat"        : "/std/races/giant_bat",
      "giant spider"     : "/std/races/giant_spider",
      "gnoll"            : "/std/races/gnoll",
      "gnome"            : "/std/races/gnome",
      "goat"             : "/std/races/goat",
      "golem"            : "/std/races/golem",
      "grflx"            : "/std/races/grflx",
      "guppy"            : "/std/races/guppy",
      "half elf"         : "/std/races/half_elf",
      "hare"             : "/std/races/hare",
      "hedgehog"         : "/std/races/hedgehog",
      "hengeyokai"       : "/std/races/hengeyokai",
      "horse"            : "/std/races/horse",
      "human"            : "/std/races/human",
      "igor"             : "/std/races/igor",
      "imp"              : "/std/races/imp",
      "insect"           : "/std/races/insect",
      "light"            : "/std/races/light",
      "lion"             : "/std/races/lion",
      "lobster"          : "/std/races/lobster",
      "luggage"          : "/std/races/luggage",
      "jellyfish"        : "/std/races/jellyfish",
      "mole"             : "/std/races/mole",
      "moose"            : "/std/races/moose",
      "mouse"            : "/std/races/mouse",
      "mustelidae"       : "/std/races/mustelidae",
      "newt"             : "/std/races/newt",
      "noble dragon"     : "/std/races/noble_dragon",
      "nymph"            : "/std/races/nymph",
      "peacock"          : "/std/races/peacock",
      "penguin"          : "/std/races/penguin",
      "panda"            : "/std/races/panda",
      "parrot"           : "/std/races/parrot",
      "pig"              : "/std/races/pig",
      "rabbit"           : "/std/races/rabbit",
      "raptor"           : "/std/races/raptor",
      "rat"              : "/std/races/rat",
      "rodent"           : "/std/races/rodent",
      "sargassum"        : "/std/races/sargassum",
      "satyr"            : "/std/races/satyr",
      "scorpion"         : "/std/races/scorpion",
      "sektarian demon"  : "/std/races/sektarian_demon",
      "shark"            : "/std/races/shark",
      "sprite"           : "/std/races/sprite",
      "sheep"            : "/std/races/sheep",
      "skunk"            : "/std/races/skunk",
      "slice human"      : "/std/races/slice_human",
      "snake"            : "/std/races/snake",
      "sphinx"           : "/std/races/sphinx",
      "spider"           : "/std/races/spider",
      "squirrel"         : "/std/races/squirrel",
      "stoat"            : "/std/races/stoat",
      "stone giant"      : "/std/races/stone_giant",
      "stone palm"       : "/std/races/stone_palm",
      "strange"          : "/std/races/strange",
      "swamp dragon"     : "/std/races/swamp_dragon",
      "toad"             : "/std/races/toad",
      "tortoise"         : "/std/races/tortoise",
      "tree"             : "/std/races/tree",
      "troll"            : "/std/races/troll",
      "vulture"          : "/std/races/vulture",
      "unicorn"          : "/std/races/unicorn",
      "vampire"          : "/std/races/vampire",
      "vorpal bunny"     : "/std/races/vorpal_bunny",
      "weasel"           : "/std/races/weasel",
      "werewolf"         : "/std/races/werewolf",
      "wolf"             : "/std/races/wolf",
      "wombat"           : "/std/races/wombat",
      "wererat"          : "/std/races/wererat",
      "giant rat"        : "/std/races/giant_rat",
    ]);
    _guilds = ([
      0                  : "/std/guilds/standard",
      "fighter"          : "/std/guilds/warrior",
      "warrior"          : "/std/guilds/warrior",
      "cleric"           : "/std/guilds/priest",
      "priest"           : "/std/guilds/priest",
      "witch"            : "/std/guilds/witch",
      "wizard"           : "/std/guilds/wizard",
      "cat burglar"      : "/std/guilds/thief",
      "cut throat"       : "/std/guilds/thief",
      "thief"            : "/std/guilds/thief",
      "pickpocket"       : "/std/guilds/thief",
      "swashbuckler"     : "/std/guilds/thief",
      "monk"             : "/std/guilds/monk",
      "assassin"         : "/std/guilds/assassin",
    ]);
    _race_obs = ([ ]);
    foreach(tmp in values(_races))
      _race_obs[tmp] = load_object(tmp);
    _guild_obs = ([ ]);
    foreach(tmp in values(_guilds))
      catch(_guild_obs[tmp] = load_object(tmp));
}
int query_valid_race( string race ) {
    return !undefinedp(_races[race]);
}
void set_level( int lvl, string race, string guild ) {
    object ob;
    string race_ob, guild_ob;
    if (_races[race]) {
        race_ob = _races[race];
    } else {
        race_ob = _races[0];
    }
    if (_guilds[guild]) {
        guild_ob = _guilds[guild];
    } else {
        guild_ob = _guilds[0];
    }
    ob = previous_object();
    ob->set_no_check(1);
    ob->set_race_ob(race_ob);
    race_ob->set_level(ob, lvl);
    ob->set_guild_ob(guild_ob);
    guild_ob->set_level(ob, lvl, guild);
    ob->race_guild_commands();
}
private int add_race( string name, mixed ob ) {
    if (_races[name]) {
        return 0;
    }
    _races[name] = ob;
    return 1;
}
private int remove_race( string name ) {
    if (!_races[name]) {
        return 0;
    }
    _races[name] = 0;
    return 1;
}
mapping query_races() {
    return copy(_races);
}
string query_race_path( string race_name ) {
    return _races[race_name];
}
private int add_guild( string name, mixed ob ) {
    if (_guilds[name]) {
        return 0;
    }
    _guilds[name] = ob;
    return 1;
}
private int remove_guild( string name ) {
    if (!_guilds[name]) {
        return 0;
    }
    _guilds[name] = 0;
    return 1;
}
mapping query_guilds() {
    return copy(_guilds);
}
string query_guild_path(string guild_name) {
    return _guilds[guild_name];
}
void monster_heart_beat(string race,  string guild, mixed race_ob,
                        mixed guild_ob) {
  object tmp;
  if(stringp(race_ob)) {
    if(!_race_obs[race_ob])
      _race_obs[race_ob] = find_object(race_ob);
    tmp = _race_obs[race_ob];
  } else if(objectp(race_ob))
    tmp = race_ob;
  if(tmp)
    tmp->player_heart_beat( race, previous_object() );
  if(stringp(guild_ob)) {
    if(!_guild_obs)
      _guild_obs = ([ ]);
    if(!_guild_obs[guild_ob]) {
      _guild_obs[guild_ob] = find_object(guild_ob);
    }
    tmp = _guild_obs[guild_ob];
  } else if(objectp(guild_ob))
    tmp = guild_ob;
  if(tmp)
    tmp->player_heart_beat(guild, previous_object());
}

==================================================
FILE: scroll.c
==================================================

inherit "/std/object";
int num_pages, open_page;
mixed *pages;
void create() {
  num_pages = 1;
  open_page = 1;
  pages = ({ ({ 0, 0, 0 }) });
  ::create();
}
void init() {
  add_command("scroll", "<word'forward|backward'>", (:this_object()->do_scroll($4[0]):));
}
void set_read_mess( string mess, string lang, int size ) {
  pages[ open_page ] = ({ mess, lang, size });
  ::set_read_mess( mess, lang, size );
}
void add_read_mess( string mess, string type, string lang, string size ) {
  pages[ open_page ] = ({ mess, lang, size });
  ::set_read_mess( mess, lang, size );
}
int query_num_pages() { return num_pages; }
void set_num_pages( int number ) { num_pages = number; }
int query_open_page() { return open_page; }
void set_open_page( int number ) {
  int size;
  string mess, lang;
  mixed *text;
  if ( ( number < 0 ) || ( number > num_pages ) )
    open_page = 1;
  else
    open_page = number;
  text = pages[ open_page ];
  if ( !text || ( sizeof( text ) < 3 ) )
    text = ({ 0, 0, 0 });
  mess = text[ 0 ];
  lang = text[ 1 ];
  size = text[ 2 ];
  ::set_read_mess( mess, lang, size );
}
int do_scroll( string word ) {
  if ( ( word != "forward" ) && ( word != "backward" ) ) {
    notify_fail( "Syntax: scroll forward|backward\n" );
    return 0;
  }
  if ( word == "forward" ) {
    if ( open_page == num_pages ) {
      notify_fail( "The scroll is already rolled forward to the last "+
          "section.\n" );
      return 0;
    }
    set_open_page( ++open_page );
    write( "You roll the scroll forward to the next section.\n" );
    say( (string)this_player()->one_short() +" rolls the "+ short( 0 ) +
        " forward.\n" );
    return 1;
  }
  if ( open_page == 1 ) {
    notify_fail( "The scroll is already open at the first section.\n" );
    return 0;
  }
  set_open_page( --open_page );
  write( "You roll the scroll backward to the previous section.\n" );
  say( (string)this_player()->one_short() +" rolls the "+ short( 0 ) +
      " backward.\n" );
  return 1;
}
mixed *stats() {
  return ::stats() + ({
    ({ "pages", num_pages }),
    ({ "open at", open_page })
  });
}
mapping query_auto_dynamic_load() {
  return ([
    "::": ::query_dynamic_auto_load(),
    "open_page": open_page
  ]);
}
mapping int_query_static_auto_load() {
  return ([
    "::": ::int_query_static_auto_load(),
    "num_pages": num_pages,
    "pages": pages
  ]);
}
mixed query_static_auto_load() {
  if ( ( file_name( this_object() ) )[ 0 .. 10 ] != "/std/scroll" )
    return 0;
  return int_query_static_auto_load();
}
void init_dynamic_arg( mapping args ) {
  ::init_dynamic_arg( args[ "::" ] );
  open_page = args[ "open_page" ];
}
void init_static_arg( mapping args ) {
  if ( args[ "::" ] ) ::init_static_arg( args[ "::" ] );
  if ( args[ "num_pages" ] ) num_pages = args[ "num_pages" ];
  if ( args[ "pages" ] ) pages = args[ "pages" ];
}

==================================================
FILE: skills.c
==================================================

#include <skills.h>
#include <language.h>
#define SKILL_BONUS 0
private mapping _stat_bonus;
private mixed *_skills;
private mapping _reg_skills;
private mapping _skill_tree;
private mapping _immediate_children;
private mapping _only_leaf;
private mapping _not_allowed_to_teach;
private mapping _only_show_if_non_zero;
private mapping _no_bonus;
private mapping _ignore_bits;
private mapping flatten(mixed *arr, string bit);
mixed *add_skill_rec(mixed *skill, string *path);
mixed *del_skill_rec(mixed *skill, string *path);
int query_skill_cost_int(string str);
void create() {
  string *languages, *lang_tree;
  int i;
  mixed *rabbit;
  string skill_written;
  string skill_spoken;
  string *skill_bits;
  _skills = STD_SKILLS;
  _skill_tree = ([ ]);
  _immediate_children = ([ ]);
  _not_allowed_to_teach = ([ ]);
  _only_show_if_non_zero = ([ ]);
  _no_bonus = ([ ]);
  lang_tree = ({ });
  languages = LANGUAGE_HAND->query_languages();
  for (i=0;i<sizeof(languages);i++) {
     rabbit = ({ });
     if (LANGUAGE_HAND->query_language_spoken(languages[i])) {
        rabbit += ({ SPOKEN_SKILL, 0, 0, ({ }), });
     }
     if (LANGUAGE_HAND->query_language_written(languages[i]) ||
         LANGUAGE_HAND->query_language_magic(languages[i])) {
        rabbit += ({ WRITTEN_SKILL, 0, 0, ({ }) });
     }
     skill_written = LANGUAGE_HAND->query_language_written_skill(languages[i]);
     skill_spoken = LANGUAGE_HAND->query_language_spoken_skill(languages[i]);
     languages[i] = replace(languages[i], " ", "_");
     lang_tree += ({ languages[i], 0, 0, rabbit });
     _not_allowed_to_teach[LANGUAGE_SKILL_START + languages[i]] = 1;
     _not_allowed_to_teach[skill_spoken] = 1;
     _not_allowed_to_teach[skill_written] = 1;
     _only_show_if_non_zero[skill_spoken] = 1;
     _only_show_if_non_zero[skill_written] = 1;
     _no_bonus[skill_spoken] = 1;
     _no_bonus[skill_written] = 1;
  }
  skill_bits = explode(LANGUAGE_SKILL_START, ".");
  _not_allowed_to_teach["other.language"] = 1;
  i = member_array(skill_bits[0], _skills);
  if (i != -1) {
     _skills[i+SKILL_BIT] += ({ skill_bits[1], 0, 0, lang_tree });
  }
  _only_leaf = ([ "other" : 1 ]);
  _ignore_bits = ([ "crafts" : 1 ]);
  _reg_skills = flatten( _skills, "" );
  _stat_bonus = ([
"covert"                            : ({ "DDDII" }),
  "covert.stealth"                  : ({ "DDDIS" }),
  "covert.hiding"                   : ({ "DDIIS" }),
  "covert.lockpick"                 : ({ "DDDDI" }),
  "covert.manipulation"             : ({ "DDISS" }),
  "covert.casing"                   : ({ "DIIWW" }),
  "covert.items"                    : ({ "DIIII" }),
  "covert.points"                   : ({ "DDIIC" }),
"crafts"                            : ({ "DDIIW" }),
  "crafts.smithing"                 : ({ "DDIIS" }),
  "crafts.mining"                   : ({ "DIISS" }),
  "crafts.hunting"                  : ({ "DDIII" }),
  "crafts.carpentry"                : ({ "DDIIS" }),
  "crafts.pottery"                  : ({ "DDDII" }),
  "crafts.materials"                : ({ "DDIIS" }),
  "crafts.husbandry"                : ({ "IIIWW" }),
  "crafts.culinary"                 : ({ "DDIII" }),
  "crafts.arts"                     : ({ "DIIII" }),
  "crafts.music"                    : ({ "DIIII" }),
  "crafts.points"                   : ({ "DDIIW" }),
"faith"                             : ({ "ISWWW" }),
  "faith.rituals.offensive"         : ({ "ISSWW" }),
  "faith.rituals.defensive"         : ({ "IDDWW" }),
  "faith.rituals.curing"            : ({ "ICCWW" }),
  "faith.rituals.misc"              : ({ "IIWWW" }),
  "faith.items"                     : ({ "IIDWW" }),
  "faith.points"                    : ({ "IICWW" }),
"fighting"                          : ({ "DDSSI" }),
  "fighting.combat.melee"           : ({ "DSSSW" }),
  "fighting.combat.melee.sharp"     : ({ "DDSSS" }),
  "fighting.combat.melee.pierce"    : ({ "DDDSS" }),
  "fighting.combat.melee.blunt"     : ({ "DSSSS" }),
  "fighting.combat.melee.unarmed"   : ({ "DDDSW" }),
  "fighting.combat.range"           : ({ "DDDSS" }),
  "fighting.combat.parry"           : ({ "DDSSW" }),
  "fighting.combat.dodging"         : ({ "DDDSW" }),
  "fighting.combat.special.weapon"  : ({ "SDIII" }),
  "fighting.combat.special.unarmed" : ({ "DDIII" }),
  "fighting.combat.special.tactics" : ({ "WWIII" }),
  "fighting.points"                 : ({ "DSSCC" }),
"magic"                             : ({ "IIIDW" }),
  "magic.spells"                    : ({ "IIDWW" }),
  "magic.spells.offensive"          : ({ "WSSII" }),
  "magic.spells.defensive"          : ({ "WCCII" }),
  "magic.spells.misc"               : ({ "WDDII" }),
  "magic.spells.special"            : ({ "WWWII" }),
  "magic.methods.elemental"         : ({ "IICCC" }),
  "magic.methods.mental"            : ({ "IIIII" }),
  "magic.methods.spiritual"         : ({ "IIWWW" }),
  "magic.methods.physical"          : ({ "IIDDD" }),
  "magic.items"                     : ({ "IIDWW" }),
  "magic.items.held"                : ({ "IIDWW" }),
  "magic.points"                    : ({ "IISWW" }),
"other"                             : ({ "DDISS" }),
   "other.trading"                  : ({ "IIIIW" }),
   "other.movement"                 : ({ "CCDDS" }),
   "other.acrobatics"               : ({ "CDDSS" }),
   "other.evaluating"               : ({ "IIIIW" }),
   "other.perception"               : ({ "IIWWW" }),
   "other.direction"                : ({ "DDIIW" }),
   "other.health"                   : ({ "CCCCS" }),
   "other.points"                   : ({ "CDISW" }),
   "other.language"                 : ({ "IIIWW" }),
   "other.culture"                  : ({ "IIIWW" }),
  ]);
}
mapping query_reg_skills() { return _reg_skills; }
mixed *query_skills() { return _skills; }
string *query_skill_path(string skill) {
   if (skill[0] == '.') {
      skill = skill[1..1090];
   }
   if (!_reg_skills[skill]) {
      return 0;
   }
   return explode(skill, ".");
}
string *query_skill_tree(string skill) {
   return _skill_tree[skill];
}
string query_skill_stat(string skill) {
   int i;
   string *bit, s;
   bit = explode(skill, ".");
   i = sizeof(bit);
   while (i >= 0) {
      s = implode(bit[0..i], ".");
      if (_stat_bonus[s])
         return _stat_bonus[s][SKILL_BONUS];
      else
         i--;
   }
   return "";
}
private int add_stat_bonus(string skill, string bonus) {
   if (_stat_bonus[skill]) {
      return 0;
   }
   _stat_bonus[skill] = ({ bonus });
   return 1;
}
private int remove_stat_bonus(string skill) {
   if (!_stat_bonus[skill]) {
      return 0;
   }
   _stat_bonus = m_delete(_stat_bonus, skill);
   return 1;
}
string *query_children(mixed *arr, string path) {
   string *ret;
   int i;
   ret = ({ });
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      ret += ({ path+arr[i] }) +
           query_children(arr[i+SKILL_BIT], path+arr[i]+".");
   }
   return ret;
}
string *query_immediate_children(string skill) {
   return _immediate_children[skill];
}
string *query_all_children(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][0];
   }
   return 0;
}
private string *query_imm_children(mixed *arr, string path) {
   string *ret;
   int i;
   ret = ({ });
   for (i = 0; i < sizeof(arr); i+= SKILL_ARR_SIZE) {
      ret += ({ path+arr[i] });
   }
   return ret;
}
private string *create_skill_tree(string skill) {
   string *ret, *bits;
   int i;
   ret = ({ });
   bits = explode(skill, ".");
   if (_only_leaf[bits[0]]) {
      return ({ skill });
   }
   for (i = sizeof(bits) - 1; i >= 0; i--) {
      ret += ({ implode(bits[0..i], ".") });
   }
   return ret;
}
private mapping flatten(mixed *arr, string bit) {
   int i;
   mapping ret;
   if (!bit) {
      bit = "";
   }
   ret = ([ ]);
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      reset_eval_cost();
      if (sizeof(arr[i+SKILL_BIT]) == 0) {
         ret[(bit+arr[i])] = ({ ({ bit+arr[i] }), 1 });
      } else {
         ret[bit + arr[i]] = ({ query_children(arr[i+SKILL_BIT], bit+arr[i]+".") +
                              ({ bit + arr[i] }),
                              query_skill_cost_int(bit+arr[i]) });
         ret += flatten(arr[i+SKILL_BIT], bit+arr[i]+".");
      }
      _skill_tree[(bit+arr[i])] = create_skill_tree(bit+arr[i]);
      _immediate_children[(bit+arr[i])] = query_imm_children(arr[i+SKILL_BIT],bit+arr[i]+".");
   }
   return ret;
}
private int query_skill_cost_rec(mixed *arr) {
   int i, tmp;
   if (!sizeof(arr)) {
      return 1;
   }
   for (i=0;i<sizeof(arr);i+=SKILL_ARR_SIZE) {
      tmp += query_skill_cost_rec(arr[i+SKILL_BIT]);
   }
   return tmp;
}
private int query_skill_cost_int(string str) {
   int i;
   mixed *arr;
   string *path;
   path = explode(str, ".");
   arr = _skills;
   while (sizeof(path)) {
      i = member_array(path[0], arr);
      if (i == -1) {
         return -1;
      } else {
         path = path[1..sizeof(path)];
         arr = arr[i+SKILL_BIT];
      }
   }
   return query_skill_cost_rec(arr);
}
string *query_related_skills(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][0];
   }
   return 0;
}
int query_skill_cost(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][1];
   }
   return -1;
}
string query_skill(string *bits) {
   mixed *arr;
   int i;
   string path, s1;
   if( !bits || !sizeof(bits) ) {
      return 0;
   }
   path = "";
   arr = _skills;
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      if (sscanf(arr[i], bits[0]+"%s", s1) == 1) {
         path += "."+arr[i];
         arr = arr[i+SKILL_BIT];
         i = -SKILL_ARR_SIZE;
         bits = bits[1..sizeof(bits)];
         if (!sizeof(bits))
            return path[1..strlen(path)];
      }
   }
   if (i<sizeof(arr)) {
      return path[1..strlen(path)];
   }
   return 0;
}
int query_only_leaf(string str) {
   string *bits;
   bits = explode(str, ".");
   return _only_leaf[bits[0]];
}
int query_allowed_to_teach(string str) {
   return !_not_allowed_to_teach[str];
}
int query_only_show_if_non_zero(string str) {
   return _only_show_if_non_zero[str];
}
int query_no_bonus(string str) {
   return _no_bonus[str] || _ignore_bits[str];
}
int is_skill_ignored(string skill) {
   return _ignore_bits[skill];
}
int query_skill_depth(string* skill) {
   int depth;
   int i;
   depth = 0;
   for (i = 0; i < sizeof(skill) - 1; i++) {
      if (!is_skill_ignored(implode(skill[0..i], "."))) {
         depth++;
      }
   }
   return depth;
}

==================================================
FILE: smart_log.c
==================================================

#include <log.h>
#include <db.h>
#include <config.h>
#include <playtesters.h>
#undef OLD_SYSTEM
#define NEW_SYSTEM
void create() {
}
void smart_log(string full_type, string reporter, string text,
                      string trace, string file) {
   int i;
   string type, temp1, *j, *person, dir;
#ifdef OLD_SYSTEM
   string temp2, report;
#endif
#ifdef NEW_SYSTEM
   string query, name, category;
   int rtime;
#endif
   seteuid("Root");
   person = ({ });
   person = master()->query_assigned_to_directory(file);
   j = explode(file, "/") - ({ "" });
   dir = "/" + implode(j[0..<2], "/");
   file = implode(j, "/");
   sscanf(full_type, "%s %s", category, full_type);
   if (!sscanf(full_type, "%s %s", type, name)) {
      type = full_type;
      name = "";
   }
   rtime = time();
   if (sizeof(person) > 0) {
      query = sprintf("INSERT INTO errors (EntryDate, DirEntryDate, "
                           "Directory, Filename, Category, Type, Name, Reporter, "
                           "Report, Runtime, AssignedTo) VALUES(%d, %d, '%s', '/%s', '%s', '%s', "
                           "'%s', '%s', '%s', '%s', '%s');", rtime, rtime, dir,
                           db_escape(file), category, type, db_escape(name), reporter,
                           db_escape(text), (trace ? db_escape(trace) : ""),
                           db_escape(person[0]));
   } else {
      query = sprintf("INSERT INTO errors (EntryDate, DirEntryDate, "
                           "Directory, Filename, Category, Type, Name, Reporter, "
                           "Report, Runtime) VALUES(%d, %d, '%s', '/%s', '%s', '%s', "
                           "'%s', '%s', '%s', '%s');", rtime, rtime, dir,
                           db_escape(file), category, type, db_escape(name), reporter,
                           db_escape(text), (trace ? db_escape(trace) : ""));
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "",
                                query, (: tell_creator("pinkfish", "%O %O\n", $1, $2) :));
   PLAYTESTER_HAND->report_made(reporter, type, file,
                               (sizeof(person) > 0 ?
                                 "Assigned to " + capitalize(person[0]) + "\n\n" : "Not assigned to anyone.\n\n" ) +
                               text + ( trace
                                       ? "\nError:\n" + trace : ""));
   j = explode( file, "/" );
   file = "/"+ implode( j[ 0 .. <2 ], "/" );
   for(i=0;i<sizeof(person);i++) {
      temp1 = read_file("/w/"+person[i]+"/"+PLAYER_ERROR_LOG);
      if (!temp1) {
         temp1 = "";
      }
      j = explode(temp1, "\n");
      if (!j) {
         j = ({ });
      }
      if (member_array(file, j) == -1) {
         j += ({ file });
      }
      temp1 = implode(j, "\n")+ "\n";
      master()->do_log(person[i], temp1);
   }
}
void dest_me() {
   destruct(this_object());
}
void clean_up() { dest_me(); }
void reset() { dest_me(); }

==================================================
FILE: storeroom.c
==================================================

inherit "/std/shops/storeroom";
void create() {
   ::create();
}

==================================================
FILE: weapon_logic.c
==================================================

#include <weapon.h>
nosave string *attack_names;
nosave string *attack_types;
nosave mixed *attack_data;
nosave mapping special_messages;
void create() {
   attack_names = ({ });
   attack_types = ({ });
   attack_data = ({ });
   special_messages = ([ ]);
}
string *query_attack_names() { return copy( attack_names ); }
string *query_attack_types() { return uniq_array( attack_types ); }
mixed *query_attack_data() { return copy( attack_data ); }
mapping query_special_messages() { return copy( special_messages ); }
void add_attack_message(string name, string type, string *data) {
   string nam;
   nam = type;
   if (name) {
      nam += "-" + name;
   }
   special_messages[nam] = data;
}
mixed *query_attack_message(string name, string type) {
   if (special_messages[type + "-" + name]) {
      return special_messages[type + "-" + name];
   }
   if (special_messages[type]) {
     return special_messages[type];
   }
   return 0;
}
varargs int add_attack( string a_name, int chance, int *damage, string type,
      string skill, mixed func, mixed bogus_1, mixed bogus_2 ) {
   if ( stringp( bogus_1 ) ) {
      write( file_name( this_object() ) +" is using the obselete syntax "+
            "of add_attack.\n" );
      return 0;
   }
   if ( member_array( a_name, attack_names ) != -1 )
      return 0;
   attack_names += ({ a_name });
   attack_types += ({ type });
   attack_data += ({ chance, damage, type, skill, func });
   return 1;
}
void remove_attack( string a_name ) {
   int i;
   i = member_array( a_name, attack_names );
   if ( i == -1 )
      return;
   attack_names = delete(attack_names, i, 1);
   attack_types = delete(attack_types, i, 1);
   attack_data = delete( attack_data, i * W_ARRAY_SIZE, W_ARRAY_SIZE );
}
int modify_damage( int damage, string attack_name ) { return damage; }
int calc_attack( int number, int percent ) {
   int damage, *data;
   data = attack_data[ number * W_ARRAY_SIZE + W_DAMAGE ];
   damage = data[ F_FIXED ] + roll_MdN( data[ F_NUM ], data[ F_DIE ] );
   damage = (int)this_object()->modify_damage( damage,
         attack_names[ number ] );
   damage = ( damage * percent ) / 100;
   return damage;
}
mixed *weapon_attacks(int percent, object target ) {
   int i, *order;
   mixed *attacks;
   if ( !percent )
      percent = 100;
   order = ({ });
   for ( i = 0; i < sizeof( attack_names ); i++ )
      order += ({ i });
   order = shuffle( order );
   attacks = ({ });
   for ( i = 0; i < sizeof( order ); i++ ) {
      if ( random( percent ) <
            attack_data[ order[ i ] * W_ARRAY_SIZE + W_CHANCE ] ) {
         attacks += ({ calc_attack( order[ i ], percent ),
               attack_data[ order[ i ] * W_ARRAY_SIZE + W_SKILL ],
               attack_data[ order[ i ] * W_ARRAY_SIZE + W_TYPE ],
               attack_names[ order[ i ] ] });
      }
   }
   return attacks;
}
void attack_function( string a_name, int damage, object attack_ob,
      object attack_by ) {
   int i;
   i = member_array( a_name, attack_names );
   if ( i == -1 ) {
      return;
   }
   i *= W_ARRAY_SIZE;
   if ( !attack_data[ i + W_FUNCTION ] ) {
      return;
   }
   if ( stringp( attack_data[ i + W_FUNCTION ] ) ) {
      call_other( this_object(), attack_data[ i + W_FUNCTION ],
            damage, attack_ob, attack_by, attack_data[ i + W_TYPE ], a_name );
   } else {
      call_other( attack_data[ i + W_FUNCTION ][ 1 ],
            attack_data[ i + W_FUNCTION ][ 0 ], damage, attack_ob, attack_by,
            attack_data[ i + W_TYPE ], a_name );
   }
}
string query_weapon_type() {
   int i;
   string type;
   for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE ) {
      if ( !type ) {
         type = attack_data[ i + W_SKILL ];
         continue;
      }
      if ( type != attack_data[ i + W_SKILL ] )
         return "mixed";
   }
   return type;
}
mixed weapon_stats() {
   int i, j;
   string bit;
   mixed *ret;
   ret = ({ });
   for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE, j++ ) {
      ret += ({
         ({ "attack #"+ j, attack_names[ j ] }),
         ({ "   chance", attack_data[ i + W_CHANCE ] })
      });
      if ( attack_data[ i + W_DAMAGE ][ F_FIXED ] )
         bit = attack_data[ i + W_DAMAGE ][ F_FIXED ] +"+";
      else
         bit = "";
      if ( attack_data[ i + W_DAMAGE ][ F_NUM ] )
         bit += attack_data[ i + W_DAMAGE ][ F_NUM ] +"d"+
               attack_data[ i + W_DAMAGE ][ F_DIE ];
      else
         if ( attack_data[ i + W_DAMAGE ][ F_DIE ] )
            bit += "1d"+ attack_data[ i + W_DAMAGE ][ F_DIE ];
      ret += ({
         ({ "   damage", bit }),
         ({ "     type", attack_data[ i + W_TYPE ] }),
         ({ "    skill", attack_data[ i + W_SKILL ] })
      });
      if ( stringp( attack_data[ i + W_FUNCTION ] ) )
         ret += ({ ({ " function", attack_data[ i + W_FUNCTION ] }) });
      else
         if ( pointerp( attack_data[ i + W_FUNCTION ] ) )
            ret += ({
               ({ " function", attack_data[ i + W_FUNCTION ][ 0 ] }),
               ({ "called on", attack_data[ i + W_FUNCTION ][ 1 ] })
            });
   }
   return ret;
}
mixed stats() { return weapon_stats(); }

==================================================
FILE: basic/artifact.c
==================================================

#include <artifacts.h>
int charges, level, total_charges;
string type, zapper;
string query_artifact_type() { return type; }
void set_artifact_type( string word ) { type = word; }
int query_charges() { return charges; }
void set_charges( int number ) { charges = number; }
int adjust_charges( int number ) {
  charges += number;
  if ( number > 0 )
    total_charges += number;
  if ( charges < 0 )
    charges = 0;
  return charges;
}
int query_total_charges() { return total_charges; }
void set_total_charges( int number ) { total_charges = number; }
int query_level() { return level; }
void set_level( int number ) { level = number; }
string query_zapper() { return zapper; }
void set_zapper( string word ) {
   zapper = word;
   call_out( "zapper_init", 1, this_object() );
}
void zapper_init( object thing ) {
   if ( !thing )
      return;
   zapper->init_artifact( thing );
}
int break_on_charging() {
  int top, chance;
  top = 1000 / ( 32 + level );
  if ( total_charges > top )
    chance = 6 * ( total_charges - top ) * ( total_charges - top );
  top = 14 - level / 7;
  if ( top < 0 )
    top = 0;
  if ( charges > top )
    chance += 3 * ( charges - top ) * ( charges - top );
  chance += 1;
  if ( random( 100 ) < chance )
    return 1;
  return 0;
}
string long( int word, int dark ) {
  string a_name, start;
  a_name = (string)call_other( zapper, "query_"+ type +"_name" );
  if ( !ARTIFACT_HAND->query_known( (string)this_player()->query_name(),
      a_name ) )
    return "";
   start = "You recognise "+ this_object()->the_short() +" to be ";
  if ( a_name[ 0 .. 0 ] == lower_case( a_name[ 0 .. 0 ] ) )
    return start + add_a( a_name ) +".  ";
  return start + a_name +".  ";
}
mixed *stats() {
  return ({
    ({ "charges", charges +" ("+ total_charges +")", }),
    ({ "level", level, }),
    ({ "zapper", zapper, }),
  });
}
mapping query_dynamic_auto_load() {
  return ([
    "charges" : charges,
    "total charges" : total_charges,
  ]);
}
mapping query_static_auto_load() {
  return ([
    "level" : level,
    "zapper" : zapper,
  ]);
}
void init_dynamic_arg( mapping map ) {
  charges = map[ "charges" ];
  total_charges = map[ "total charges" ];
}
void init_static_arg( mapping map ) {
  if ( map[ "level" ] )
    level = map[ "level" ];
  if ( map[ "zapper" ] )
    zapper = map[ "zapper" ];
}

==================================================
FILE: basic/auto_load.c
==================================================

mapping add_auto_load_value(mapping map,
                            string file_name,
                            string tag,
                            mixed value) {
   map[file_name + "  :  " + tag] = value;
   return map;
}
mixed query_auto_load_value(mapping map,
                            string file_name,
                            string tag) {
   mixed tmp;
   if (tag == "::") {
      return map;
   }
   tmp = map[file_name + "  :  " + tag];
   if (tmp) {
      return tmp;
   }
   return map[tag];
}
