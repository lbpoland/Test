# Total Tokens: 17121
# Total Files Merged: 21
# Total Characters: 57132

l_quit_control.c
==================================================

protected string find_start_pos(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char;
   if ( place ) {
      quit_env = place->query_quit_handler( player );
      if (arrayp(quit_env)) {
         last_pos = quit_env[0];
      } else {
         last_pos = (string)quit_env;
      }
      if ( last_pos ) {
         last_pos->player_quitting( player, place );
      } else {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }
   if (last_pos && last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {
      test_char = player->query_property( "test character" );
      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }
      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if (!player->query_creator() ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }
   return last_pos;
}
protected int * find_start_coord(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char;
   if ( place ) {
      quit_env = place->query_quit_handler();
      if (arrayp(quit_env)) {
         return quit_env[1];
      } else {
         last_pos = (string)quit_env;
      }
      if ( !last_pos ) {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }
   if (last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {
      test_char = player->query_property( "test character" );
      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }
      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if( !( player->query_creator() ||
                player->query_property( "test character" ) ) ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }
   return last_pos->query_co_ord();
}

==================================================
FILE: basic/virtual_update.c
==================================================

#include <virtual.h>
mixed query_property(string name);
void add_property(string name, mixed prop);
void init_static_arg(mapping data);
void replace_me()
{
   object receipt;
   mixed als;
   receipt = clone_object("/obj/misc/al_receipt");
   receipt->set_name("receipt");
   receipt->set_object(file_name(this_object()));
   receipt->set_virtobname(query_property(VIRTUAL_NAME_PROP));
   receipt->set_value(this_object()->query_value());
   als = "/global/auto_load"->fragile_auto_str_ob(this_object());
   als[0] = 1;
   receipt->set_static_save(als);
   receipt->set_short("destructed item receipt");
   receipt->add_adjective(({ "destructed", "item" }));
   receipt->set_long("This seems to be a small piece of paper.\n");
   receipt->set_read_mess("According to our sources, your " +
                          this_object()->query_short() +
                          " was not " "allowed to exist.  Have a nice day.");
   receipt->move(environment());
   receipt->set_weight(1);
   destruct(this_object());
}
void init_virtual_object()
{
   mapping stat_temp;
   string virt_name;
   string new_name;
   virt_name = query_property(VIRTUAL_NAME_PROP);
   if (virt_name) {
      if (file_size(virt_name) == -1) {
         new_name = (CLONER)->other_file(virt_name);
         if (stringp(new_name) && (new_name != virt_name)) {
            add_property(VIRTUAL_NAME_PROP, new_name);
            virt_name = new_name;
         } else {
            if (VIRTUAL_HANDLER->query_forbidden(virt_name)) {
               call_out("replace_me", 1);
            } else {
               VIRTUAL_HANDLER->add_missing(virt_name);
            }
         }
      }
      if (file_size(virt_name) != -1 &&
          query_property("virtual time") < stat(virt_name)[1]) {
         stat_temp = (VIRTUAL_HANDLER)->new_data(virt_name);
         if (mapp(stat_temp)) {
            init_static_arg(stat_temp);
            add_property("virtual time", time());
         }
      }
   }
}

==================================================
FILE: basic/wearable.c
==================================================

inherit "/std/basic/condition";
#include <clothing.h>
#include <move_failures.h>
private string *immune_to;
private string *wear_effects;
private mixed type;
private mixed *wear_remove_func;
nosave object worn_by;
void create() {
   condition::create();
   set_damage_chance( 25 );
   immune_to = ({ "cold", "sound", "gas", "mental" });
   wear_effects = ({ });
   wear_remove_func = ({ });
}
int query_wearable() { return 1; }
string long( string word, int dark ) {
   switch ( dark ) {
      case 0 :
         return cond_string();
      default :
         return "";
   }
}
mixed *query_wear_remove_func() {
   return wear_remove_func;
}
void set_wear_remove_func( mixed file, string func ) {
   wear_remove_func = ({ file, func });
}
string *query_wear_effects() {
  if(!wear_effects)
    wear_effects = ({ });
  return copy(wear_effects);
}
void set_wear_effects( string *effects ) {
   wear_effects = effects;
}
void add_wear_effect( string effect ) {
   if ( member_array( effect, wear_effects ) == -1 ) {
      wear_effects += ({ effect });
   }
}
void do_damage( string type, int amount ) {
   if ( member_array( type, immune_to ) == -1 ) {
      condition::do_damage( type, amount );
   }
}
object query_worn_by() {
   return worn_by;
}
int set_worn_by( object thing ) {
   int i;
   if ( thing == worn_by ) {
      return 1;
   }
   if (thing && environment() != thing) {
      return 0;
   }
   this_object()->remove_hide_invis( "concealed" );
   if ( sizeof( wear_remove_func ) ) {
    if ( !objectp( wear_remove_func[ 0 ] ) && !objectp( load_object( wear_remove_func[ 0 ] ) ) ) {
        debug_printf( "Wear/Remove func is %O. Not called.\n", wear_remove_func );
      return 0;
    }
    if ( worn_by ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], 0, worn_by );
      }
      if ( thing ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], thing, thing );
      }
   }
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         if ( worn_by ) {
            worn_by->taken_off( this_object(), wear_effects[ i ] );
         }
         if ( thing ) {
            thing->add_effect( wear_effects[ i ], this_object() );
         } else {
            wear_effects[i]->person_removing_item(this_object(), worn_by);
         }
      }
   }
   if ( worn_by ) {
      worn_by->now_removed( this_object() );
      this_object()->add_adjective("worn");
      this_object()->remove_adjective("unworn");
   } else {
      this_object()->remove_adjective("worn");
      this_object()->add_adjective("unworn");
   }
   if ( thing ) {
      thing->now_worn( this_object() );
   }
   worn_by = thing;
   return 1;
}
string *query_immune_to() {
   return immune_to;
}
void add_immune_to( mixed args ) {
   int i;
   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         add_immune_to( args[ i ] );
      }
   } else {
      if ( member_array( args, immune_to ) == -1 ) {
         immune_to += ({ args });
      }
   }
}
void remove_immune_to( mixed args ) {
   int i;
   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         remove_immune_to( args[ i ] );
      }
   } else {
      i = member_array( args, immune_to );
      if ( i != -1 ) {
         immune_to = delete( immune_to, i, 1 );
      }
   }
}
string query_type() {
   return type;
}
private void log_bad_type( mixed type ) {
  string word, str;
  if ( !clonep( this_object() ) ) {
      return;
  }
  word = (string)this_object()->query_property( "virtual name" );
  if ( word ) {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", word,
           (string)this_object()->query_short(), type );
  } else {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", file_name(),
           (string)this_object()->query_short(), type );
  }
  if ( this_player()) {
    write(str);
  }
  call_out("move", 2, "/room/broken");
}
void set_type( mixed word ) {
  int i;
   if(!stringp(word) && !pointerp(word))
      return log_bad_type(word);
   type = word;
   if(stringp(word)) {
     if(CLOTHING_HANDLER->query_equivilant_type(word))
       type = CLOTHING_HANDLER->query_equivilant_type(word);
     if(!CLOTHING_HANDLER->query_valid_type(word))
       log_bad_type( word );
     return;
   }
   for(i=0; i<sizeof(word); i++) {
     if(CLOTHING_HANDLER->query_equivilant_type(word[i]))
       type[i] = CLOTHING_HANDLER->query_equivilant_type(word[i]);
     if (!CLOTHING_HANDLER->query_valid_type(word[i]))
       log_bad_type( word );
     return;
   }
}
int modify_value( int amount ) {
   return ( amount * ( 10 + ( 90 * query_cond() ) / query_max_cond() ) ) / 100;
}
void player_wear() {
   if ( !environment() ) {
      return;
   }
   environment()->wear_armour( this_object() );
}
void break_me() {
   if ( !worn_by ) {
      return condition::break_me();
   }
   tell_object( worn_by, "%^RED%^$C$"+ (string)this_object()->the_short() +
         " breaks!%^RESET%^\n" );
   tell_room( environment( worn_by ), (string)worn_by->the_short() +"'s "+
         this_object()->short( 0 ) +" breaks!\n", worn_by );
   worn_by->remove_armour( this_object() );
   if((int)this_object()->move("/room/rubbish") != MOVE_OK)
     move_object("/room/rubbish");
}
mixed *stats() {
   int i;
   string *stuff;
   stuff = condition::stats() +
      ({
         ({ "type", type }),
      });
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         stuff += ({ ({ "wear effect", wear_effects[ i ] }) });
      }
   }
   for ( i = 0; i < sizeof( immune_to ); i++ ) {
      stuff += ({ ({ "immune to", immune_to[ i ] }) });
   }
   if (worn_by) {
      stuff += ({ ({ "worn by", worn_by->short() }) });
   }
   return stuff;
}
mapping query_static_auto_load() {
   return ([
      "condition" : condition::query_static_auto_load(),
      "type" : type,
      "wear remove func" : wear_remove_func
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "condition" : condition::query_dynamic_auto_load(),
      "wear effects" : wear_effects,
      "immune" : immune_to,
      "worn" : ( worn_by != 0 )
   ]);
}
void init_static_arg( mapping map ) {
   if ( map[ "type" ] )
      type = map[ "type" ];
   if ( map[ "wear remove func" ] )
      wear_remove_func = map[ "wear remove func" ];
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_static_arg( map[ "condition" ] );
   }
#ifdef AFTER_1999_I_BELIEVE
   else {
      if ( !undefinedp( map[ "max cond" ] ) )
         max_cond = map[ "max cond" ];
      if ( !undefinedp( map[ "damage chance" ] ) )
         damage_chance = map[ "damage chance" ];
   }
#endif
}
void init_dynamic_arg( mapping map, object ) {
   if ( map[ "effect" ] )
      wear_effects = ({ map[ "effect" ] });
   if ( pointerp( map[ "wear effects" ] ) )
      wear_effects = map[ "wear effects" ];
   if ( map[ "immune" ] )
      immune_to = map[ "immune" ];
   if ( map[ "worn" ] )
      call_out( "player_wear", 0 );
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_dynamic_arg( map[ "condition" ] );
   }
#ifdef AFTER_1999_I_BELIEVE
   } else {
      cond = map[ "cond" ];
      lowest_cond = map[ "lowest cond" ];
   }
#endif
}
void remove_wear_remove_func() {
    wear_remove_func = ({ });
}

==================================================
FILE: socket/telnet.c
==================================================

#include <socket.h>
#include <socket_errors.h>
#define WRITE_WAIT_CALLBACK 0
#define WRITE_GO_AHEAD      1
#define DISCONNECTED "an internet terminal"
#define CONNECTED "an internet terminal (connected)"
#define IAC  255
#define DONT 254
#define DO   253
#define WONT 252
#define WILL 251
#define TELOPT_ECHO   1
#define TELOPT_SGA    3
#define TELOPT_TTYPE 24
#define TELOPT_NAWS  31
nosave string *telopts = ({"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD",
			"NAME", "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
		    "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
		    "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
		    "DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
		    "SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
		    "TACACS UID", "OUTPUT MARKING", "TTYLOC",
		    "3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
		    "LINEMODE"});
nosave string s_iac_dont_echo;
nosave string s_iac_do_echo;
nosave string s_iac_wont_echo;
nosave string s_iac_will_echo;
nosave string s_iac_dont_sga;
nosave string s_iac_do_sga;
nosave string s_iac_wont_sga;
nosave string s_iac_will_sga;
nosave string s_iac_wont_ttype;
nosave string s_iac_wont_naws;
nosave string s_iac;
nosave string s_dont_echo;
nosave string s_do_echo;
private string callback;
private int conn_fd;
private int connected;
private int verbose;
private int write_state = WRITE_WAIT_CALLBACK;
private string write_message = "";
protected void init_tel_neg()
{
  s_iac_dont_echo  = sprintf("%c%c%c",IAC,DONT,TELOPT_ECHO);
  s_iac_do_echo    = sprintf("%c%c%c",IAC,DO  ,TELOPT_ECHO);
  s_iac_wont_echo  = sprintf("%c%c%c",IAC,WONT,TELOPT_ECHO);
  s_iac_will_echo  = sprintf("%c%c%c",IAC,WILL,TELOPT_ECHO);
  s_iac_dont_sga   = sprintf("%c%c%c",IAC,DONT,TELOPT_SGA);
  s_iac_do_sga     = sprintf("%c%c%c",IAC,DO  ,TELOPT_SGA);
  s_iac_wont_sga   = sprintf("%c%c%c",IAC,WONT,TELOPT_SGA);
  s_iac_will_sga   = sprintf("%c%c%c",IAC,WILL,TELOPT_SGA);
  s_iac_wont_ttype = sprintf("%c%c%c",IAC,WONT,TELOPT_TTYPE);
  s_iac_wont_naws  = sprintf("%c%c%c",IAC,WONT,TELOPT_NAWS);
  s_iac            = sprintf("%c",    IAC);
  s_dont_echo      = sprintf("%c%c",  DONT,TELOPT_ECHO);
  s_do_echo        = sprintf("%c%c",  DO,  TELOPT_ECHO);
}
void
set_callback(string arg)
{
	callback = arg;
}
void create()
{
  init_tel_neg();
  connected = 0;
  verbose = 0;
  set_callback("handler");
}
void
set_verbosity(int v)
{
	verbose = v;
}
int
query_connected()
{
	return connected;
}
void disconnected()
{
  call_other(this_object(), callback, "close");
  connected = 0;
}
int connected()
{
  call_other(this_object(), callback, "open");
  connected = 1;
}
void my_socket_write(int fd, string message)
{
  int ret;
  write_message = write_message + message;
  if(write_state == WRITE_GO_AHEAD){
    ret = socket_write(fd, write_message);
    write_message = "";
    if(ret == EESUCCESS) write_state = WRITE_GO_AHEAD;
    else if(ret == EECALLBACK) write_state = WRITE_WAIT_CALLBACK;
  }
}
int line(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_dont_sga+s_iac_dont_echo);
    write("SENT dont SUPPRESS GO AHEAD\nSENT dont ECHO\n");
    return(1);
  }
  return(0);
}
int char(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_do_sga+s_iac_do_echo);
    write("SENT do SUPPRESS GO AHEAD\nSENT do ECHO\n");
    return(1);
  }
  return(0);
}
int connect(string str)
{
  int ret;
  if(!str) return(0);
  conn_fd = socket_create(STREAM,"socket_shutdown");
  ret = socket_connect(conn_fd,str,"receive_data","write_data");
  if(ret != EESUCCESS){
    notify_fail("unable to connect: " + socket_error(ret) + "\n");
    return(0);
  }
  connected();
  return(1);
}
int send(string str)
{
  if(connected){
    if(!str){
      write("Sending CR.\n");
      my_socket_write(conn_fd,"\n");
      return(1);
    }
    my_socket_write(conn_fd,str + "\n");
    return(1);
  }
  return(0);
}
int disconnect(string str)
{
  int ret;
  ret = socket_close(conn_fd);
  if(ret <= 0){
    notify_fail("unable to disconnect.\n");
    return(0);
  }
  disconnected();
  return(1);
}
void receive_data(int rec_fd, string msg) {
  string *chunks;
  int i;
  object hearer;
  this_object()->recieve_message(msg);
}
void write_data(int fd) {
  write_state = WRITE_GO_AHEAD;
  my_socket_write(fd,"");
}
void socket_shutdown(int fd)
{
  object hearer;
  if(fd == conn_fd){
    hearer = environment(this_object());
    disconnected();
    return;
  }
}

==================================================
FILE: nationality/basic.c
==================================================

inherit "/std/basic/setup";
class region {
   string description;
   string start_location;
   string accent_ob;
}
private string _name;
private string _information;
private string _same_nat_description;
private string _different_nat_description;
private string _start_loc;
private string _language;
private string _accent;
private string _currency;
private mapping _regions;
void create() {
   _regions = ([ ]);
   do_setup();
}
void add_region(string name, string description, string start, string accent) {
   class region bing;
   bing = new(class region,
              description : description,
              start_location : start,
              accent_ob : accent);
   _regions[name] = bing;
}
void set_name(string name) {
   _name = name;
}
string query_name() {
   return _name;
}
void set_same_nationality_description(string description) {
   _same_nat_description = description;
}
string query_same_nationality_description() {
   return _same_nat_description;
}
void set_different_nationality_description(string description) {
   _different_nat_description = description;
}
string query_different_nationality_description() {
   return _different_nat_description;
}
string query_look_description(object person, object looker) {
   return "";
   if (person->query_nationality() == looker->query_nationality()) {
      return capitalize(person->query_pronoun()) + " " +
             _same_nat_description;
   } else {
      return capitalize(person->query_pronoun()) + " " +
             _different_nat_description;
   }
}
void set_default_start_location(string start_loc) {
   _start_loc = start_loc;
}
string query_default_start_location() {
   return _start_loc;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
void set_information(string info) {
   _information = info;
}
string query_information() {
	if (!_information) {
      _information = "The $C$" + query_name() + " nationality is yet to "
                     "be described.\n";
   }
   return _information;
}
string* query_regions() {
   return keys(_regions);
}
string query_region_description(string region) {
   return _regions[region]->description;
}
string query_region_start_location(string region) {
   return _regions[region]->start_location;
}
string query_start_location(string region) {
   if (_regions[region] && _regions[region]->start_location) {
      return _regions[region]->start_location;
   }
   return _start_loc;
}
string query_region_accent_ob(string region) {
   if (_regions[region]) {
      return _regions[region]->accent_ob;
   }
   return 0;
}
void set_currency_area(string area) {
   _currency = area;
}
string query_currency_area() {
   return _currency;
}

==================================================
FILE: nationality/pumpkin.c
==================================================

inherit "/std/nationality/basic";
void setup() {
   set_name( "pumpkin" );
   set_information( "Pumpkin is a large orange ball shaped town.\n");
   add_region( "round",
               "Pumpkins which are round.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/round");
   add_region( "square",
               "Sto Lat is the second biggest city in the Morporkian kingdom, "
               "it sits on the river Ankh on the way to the Carrack "
               "Mountains.  It is a harder starting location than "
               "Ankh-Morpork but close enough that it is not that much of an "
               "issue.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/square");
   set_language("pumpkin");
   set_currency_area("Pumpkin");
   set_default_start_location("/d/am/buildings/drum/mendeddrum");
}

==================================================
FILE: nationality/accents/accent_base.c
==================================================

#define NATIONAL_ACCENT_PATH "/std/nationality/accents/national/"
mapping accent_lang_map = ([
   "Pumpkin" : "pumpkin",
   ]);
string query_nat_accent( string lang ) {
   return NATIONAL_ACCENT_PATH + lang;
}
string national_garble( string mess, object person, object sayer, int say_type,
                        string def_lang, string accent ) {
   string accent_lang = accent_lang_map[ accent ];
   string nat_accent = query_nat_accent( accent_lang );
   if( def_lang != accent_lang ) {
      if( nat_accent )
         mess = load_object( query_nat_accent( accent_lang ) )->garble_say( mess,
                                                                            person,
                                                                            sayer,
                                                                            say_type );
   } else {
   }
   return mess;
}

==================================================
FILE: nationality/accents/regional/round.c
==================================================

inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Morporkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "au", "$AU_PROTECT",
                               "oo", "$OO_PROTECT",
                               "ou", "$OU_PROTECT",
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                                "$OO_PROTECT", "oo",
                               "$OU_PROTECT", "ou",
                               "$AU_PROTECT", "au"
                               }) );
}

==================================================
FILE: nationality/accents/regional/square.c
==================================================

inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Pumpkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "a", "aa",
                               "oo", "o",
                               "ou", "ooou"
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                               }) );
}

==================================================
FILE: nationality/accents/national/pumpkin.c
==================================================

string garble_say( string mess, object person,
                   object sayer, int say_type ) {
   return replace( mess, ({
                            "eh", "a",
                            "ah", "eh",
                            "ou", "oo"
                         }) );
}
string query_accent_name() {
   return "Pumpkinian";
}

==================================================
FILE: curses/chef_curse.c
==================================================

#include "path.h"
#define MY_NAME "chef curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"chef_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"chef_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"chef_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"chef_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"chef_mangle")->do_transmute(str));
}

==================================================
FILE: curses/chef_mangle.c
==================================================

string *replace_matrix;
void create() {
  replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
}
string do_transmute(string str) {
  return replace(" "+str, replace_matrix)[1..10000];
}

==================================================
FILE: curses/ken_curse.c
==================================================

#include "path.h"
#define MY_NAME "ken curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"ken_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"ken_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"ken_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"ken_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"ken_mangle")->do_transmute(str));
}

==================================================
FILE: curses/ken_mangle.c
==================================================

string *replace_matrix;
mapping trans;
void create() {
  replace_matrix = ({
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });
  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
}
string do_transmute(string str) {
  string tmp, *bits;
  mixed erp;
  int i;
  tmp = replace(" "+str+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
}

==================================================
FILE: curses/newbie_curse.c
==================================================

#include "path.h"
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

==================================================
FILE: curses/newbie_eff_shadow.c
==================================================

inherit "/std/effect_shadow";
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
string name, my_name;
void remove_effect_shadow(int i) {
   if (i == id) {
      destruct(this_object());
      return;
   }
      else player->remove_effect_shadow(i);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

==================================================
FILE: curses/path.h
==================================================

#define HERE "/std/curses/"

==================================================
FILE: curses/shout_curse.c
==================================================

#include "path.h"
#define MY_NAME "Shout curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  printf("%O, %O\n", pl, this_object());
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"shout_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}
int do_shout(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}

==================================================
FILE: curses/upper_case.c
==================================================

#include "path.h"
#define MY_NAME "UPPER CASE"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string upper_case(string str) {
  string ret;
  int i;
  ret = "";
  for (i=0;i<strlen(str);i++)
    ret += capitalize(str[i..i]);
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(upper_case(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(upper_case(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(upper_case(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(upper_case(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(upper_case(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(upper_case(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(upper_case(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(upper_case(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(upper_case(str));
}

==================================================
FILE: shops/auction_house.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/auction_house";
void create() {
   auction_house::create();
   basic_room::create();
   add_help_file("auction_house");
}
void init() {
   basic_room::init();
   auction_house::init();
}

==================================================
FILE: shops/bank.c
==================================================

#include <money.h>
#include <move_failures.h>
#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"
nosave inherit "/std/room/basic_room";
int total_account, total_made;
nosave int account_cost, percentage;
nosave string bank_name, place;
int do_withdraw(int num, string type);
int do_deposit(string str);
nosave string save_file;
void create() {
  account_cost = 0;
  percentage = 90;
  total_account = 0;
  total_made = 0;
  bank_name = "Bing's First";
  place = "default";
  add_help_file("bank");
  ::create();
}
void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<number> <string>",
               (: do_withdraw($4[0], $4[1]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
  ::init();
}
int query_account_cost() { return account_cost; }
void set_account_cost( int number ) { account_cost = number; }
int query_percentage() { return percentage; }
void set_percentage( int number ) { percentage = number; }
int query_total_account() { return total_account; }
int query_total_made() { return total_made; }
string query_bank_name() { return bank_name; }
void set_bank_name( string word ) { bank_name = word; }
string query_place() { return place; }
string query_money_place() { return query_place(); }
void set_place( string word ) { place = word; }
string query_save_file() { return save_file; }
void set_save_file( string word ) {
  save_file = word;
  if ( file_size( save_file +".o" ) > 0 )
    unguarded((: restore_object, save_file :));
}
void do_save() {
   if ( !save_file ) {
      return;
   }
   unguarded( (: save_object, save_file :) );
}
int get_account() {
  int amount;
  if ( amount = (int)this_player()->query_property( "bank "+ OLD_BANK ) ) {
    HANDLER->adjust_account( NAME, bank_name, amount );
    this_player()->remove_property( "bank "+ OLD_BANK );
    total_account += amount;
    do_save();
  }
  return (int)HANDLER->query_account( NAME, bank_name );
}
int set_account( int amount ) {
  HANDLER->set_account( NAME, bank_name, amount );
}
int do_balance() {
  int amount;
  amount = get_account();
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     this_player()->add_succeeded_mess(this_object(),
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }), ({ }) );
    return 1;
  }
  this_player()->add_succeeded_mess(this_object(),
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount, place ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }), ({ }) );
  return 1;
}
int do_withdraw( int number, string type ) {
  int amount;
  int best;
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( number <= 0 ) {
    notify_fail( "You must withdraw something.\n" );
    return 0;
  }
  money = clone_object( MONEY_OBJECT );
  money->set_money_array( (mixed *)MONEY_HAND->query_values_in( place ) );
  if ( ( best = (int)money->find_best_fit( type ) ) == -1 ) {
    notify_fail( "That currency is not legal tender here.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  type = ( (mixed *)money->query_money_array() )[ best ];
  amount = number * ( (mixed *)money->query_money_array() )[ best + 1 ];
  if ( ( amount > total ) ||
       ( amount < 0 ) ) {
    notify_fail( "You don't have enough money in your account.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  money->set_money_array( ({ type, number }) );
  set_account( total - amount );
  total_account -= amount;
  do_save();
  this_player()->add_succeeded_mess(this_object(),
   ({ "You withdraw "+ (string)money->short() +".\n" +
      "You have "+ (string)MONEY_HAND->money_value_string( get_account(),
                                                           place ) +
        " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
       }), ({ }) );
  if ( (int)money->move( this_player() ) != MOVE_OK ) {
    write( "You are too heavily burdened to collect the money, so the teller "+
      "puts it on the counter for you.\n" );
    money->move( this_object() );
  }
  this_player()->save();
  return 1;
}
int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;
   total = get_account();
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only deposit money.\n" );
         default :
            return notify_fail( "You can only deposit legal tender.\n" );
      }
   }
   if (!place) {
      place = "default";
   }
   tender = MONEY_HAND->filter_legal_tender( money, place);
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
     amount = legal->query_value_in(place);
     if (place != "default") {
       amount += legal->query_value_in("default");
     }
     if(amount < 200) {
       if( legal->move( this_player() ) != MOVE_OK ) {
          legal->move( environment( this_player() ) );
          tell_object( this_player(), "You lose hold of some coins and "
             "they tumble to the floor.\n" );
          tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
       }
       if(illegal)
         if( illegal->move( this_player() ) != MOVE_OK ) {
            illegal->move( environment( this_player() ) );
            tell_object( this_player(), "You lose hold of some coins and "
               "they tumble to the floor.\n" );
            tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
         }
       add_failed_mess("That is too small an amount to deposit.\n");
       return 0;
     }
     tmp = ( amount * ( 100 - percentage ) ) / 100;
     total_made += tmp;
     amount = amount - tmp;
     set_account( total + amount );
     total_account += amount;
     do_save();
   }
   if (illegal) {
      if( illegal->move( this_player() ) != MOVE_OK ) {
         illegal->move( environment( this_player() ) );
         tell_object( this_player(), "You lose hold of some coins and "
            "they tumble to the floor.\n" );
         tell_room( environment( this_player() ), this_player()->one_short() +
            "accidentally drops some coins.\n", this_player() );
       }
   }
   if (legal) {
      howmuch = legal->the_short();
      legal->move( "/room/rubbish" );
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }
   write( "You give the teller "+ howmuch +".\n" );
   write( "After expenses, this leaves "+ (string)MONEY_HAND->
          money_value_string( amount, place ) +".\n" );
   this_player()->add_succeeded_mess(this_object(),
       ({  "$N $V "+words+".\n"
           "This gives a total of " +
           MONEY_HAND->money_value_string(total + amount, place ) +
           " in your account.\n",
           "$N deposit$s some money into $p account.\n" }), ({ }) );
   return 1;
}
int do_open() {
  int amount;
  object money;
  if ( get_account() >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( account_cost ) {
    if ( !( money = present( MONEY_ALIAS, this_player() ) ) ) {
      notify_fail( "You do not have any money.\n" );
      return 0;
    }
    amount = (int)money->query_value_in( place );
    if ( place != "default" )
      amount += (int)money->query_value_in( "default" );
    if ( amount < account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      account_cost, place ) +" to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  return 1;
}
int check_open( string word ) {
  object money;
  word = lower_case( word );
  if (word [ 0 ] ==  110 ) {
    write( "Okay, not opening an account.\n" );
    return 1;
  }
  if ( word[ 0 ] !=  121 ) {
    write( "Do you want to open an account? Answer \"yes\" or \"no\".\n" );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  write( "You now have an account here.\n" );
  money = present( MONEY_ALIAS, this_player() );
  MONEY_HAND->pay_amount_from( account_cost, money, place );
  total_made += account_cost;
  do_save();
  this_player()->save();
  return 1;
}
int do_close() {
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, place ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
      total_made += total;
    }
    total_account -= total;
  } else
    write( "You close your account.\n" );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  set_account( -1 );
  do_save();
  this_player()->save();
  return 1;
}
mixed *stats() {
  return ::stats() + ({
    ({ "account cost", account_cost }),
    ({ "percentage", percentage }),
    ({ "total accounts", total_account }),
    ({ "total made", total_made }),
    ({ "bank name", bank_name }),
    ({ "place", place }),
    ({ "save file", save_file }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = (int)HANDLER->query_account( player_name, bank_name ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      HANDLER->adjust_account( player_name, bank_name, -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  total_account -= total;
  amount = total / 3;
  total_made += 2 * amount;
  do_save();
  mon_array = (mixed *)MONEY_HAND->create_money_array( amount / number, place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
