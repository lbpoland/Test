# Total Tokens: 99417
# Total Files Merged: 86
# Total Characters: 331641

er/topography/area.c
==================================================

#include <dirs.h>
#include <image.h>
inherit "/std/room";
mapping direction_bits = ([
    "north": 1,
    "northeast": 2,
    "east": 4,
    "southeast": 8,
    "south": 16,
    "southwest": 32,
    "west": 64,
    "northwest": 128,
    "up": 256,
    "down": 512,
]);
class AREA_INFO {
  string base;
  int *origin;
  int *size;
  mixed *bbox;
  mixed *vertices;
  class IMAGE_INFO height;
  class IMAGE_INFO exits;
}
private int dbg_lvl = 0;
private string debugger = "jeremy";
private string _handler;
private class AREA_INFO *areas = ({ });
private mapping room_cache = ([ ]);
private mapping area_cache = ([ ]);
void set_handler(string handler) {
   _handler = handler;
}
string query_handler() {
   return _handler;
}
void set_debugger(string s) { debugger = s; }
string query_debugger() { return debugger; }
void set_debug_level(int l) { dbg_lvl = l; }
int query_debug_level() { return dbg_lvl; }
mixed query(string s) { return fetch_variable(s); }
void set_base(int i, string s) { areas[i]->base = s; }
string query_base(int i) { return areas[i]->base; }
void set_origin(int i, int *o) { areas[i]->origin = copy(o); }
int *query_origin(int i) { return copy(areas[i]->origin); }
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_keep_room_loaded(1);
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int *quantize_to_origin(int *coord_r, int a) {
  int size2, i, *coord_q;
  coord_q = allocate(3);
  for (i = 0; i < 3; i++) {
    size2 = areas[a]->size[i] * 2;
    if (coord_r[i] < areas[a]->origin[i]) {
      coord_q[i] = coord_r[i] - areas[a]->size[i];
    } else {
      coord_q[i] = coord_r[i] + areas[a]->size[i];
    }
    coord_q[i] = ((coord_q[i] - areas[a]->origin[i]) / size2) * size2
      + areas[a]->origin[i];
  }
  return coord_q;
}
void set_size(int i, mixed s) {
  if (intp(s)) {
    areas[i]->size = ({ s, s, s });
  } else if (arrayp(s) && (sizeof(s) == 3)) {
    areas[i]->size = copy(s);
  } else {
    error("Illegal size; must be int or 3-element array.\n");
  }
}
varargs void set_height_map(int i, string map_file, int rle) {
  int *nw;
  areas[i]->height = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->height->nw_coord = quantize_to_origin(nw, i);
  }
}
varargs void set_exits_map(int i, string map_file, int rle) {
  int *nw;
  areas[i]->exits = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->exits->nw_coord = quantize_to_origin(nw, i);
  }
}
int new_area() {
  areas += ({ new(class AREA_INFO) });
}
void set_vertices(int a, mixed *vs) {
  int v, i;
  if (!arrayp(areas[a]->origin)) {
    error("Origin unset - setting to (0,0,0).\n");
    areas[a]->origin = ({ 0, 0, 0 });
  }
  areas[a]->vertices = copy(vs);
  areas[a]->bbox = ({ copy(vs[0]), copy(vs[0]) });
  for (i = 0; i < 3; i++) {
    areas[a]->bbox[0][i] += areas[a]->origin[i];
    areas[a]->bbox[1][i] += areas[a]->origin[i];
  }
  for (v = 0; v < sizeof(areas[a]->vertices); v++) {
    for (i = 0; i < 3; i++) {
      areas[a]->vertices[v][i] += areas[a]->origin[i];
      if (areas[a]->vertices[v][i] < areas[a]->bbox[0][i]) {
        areas[a]->bbox[0][i] = areas[a]->vertices[v][i];
      } else if (areas[a]->vertices[v][i] > areas[a]->bbox[1][i]) {
        areas[a]->bbox[1][i] = areas[a]->vertices[v][i];
      }
    }
  }
}
int in_bbox(int *coord, mixed *bbox) {
  if ((coord[0] < bbox[0][0]) || (coord[0] > bbox[1][0])) {
    return 0;
  }
  if ((coord[1] < bbox[0][1]) || (coord[1] > bbox[1][1])) {
    return 0;
  }
  if ((coord[2] < bbox[0][2]) || (coord[2] > bbox[1][2])) {
    return 0;
  }
  return 1;
}
int in_area(int a, int *v) {
  int crossings, i, i0, i1, de, int_n, below_vertex;
  mixed *vs;
  if (!in_bbox(v, areas[a]->bbox)) {
    return 0;
  }
  vs = allocate(2);
  for (i = 0; i < sizeof(areas[a]->vertices); i++) {
    below_vertex = 0;
    vs[0] = areas[a]->vertices[i];
    if (i < sizeof(areas[a]->vertices)-1) {
      vs[1] = areas[a]->vertices[i+1];
    } else {
      vs[1] = areas[a]->vertices[0];
    }
    if ((v[1] < vs[0][1]) && (v[1] < vs[1][1])) {
      continue;
    }
    if ((v[1] > vs[0][1]) && (v[1] > vs[1][1])) {
      continue;
    }
    if ((v[0] > vs[0][0]) && (v[0] > vs[1][0])) {
      continue;
    }
    if ((v[0] < vs[0][0]) && (v[0] < vs[1][0])) {
      if (v[1] != vs[0][1]) {
        if (v[1] != vs[1][1]) {
          crossings++;
        }
        continue;
      } else {
        below_vertex = 1;
      }
    }
    if (vs[0][1] == vs[1][1]) {
      if (!below_vertex) {
        return 1;
      }
      continue;
    }
    if ((v[0] == vs[0][0]) && (v[1] == vs[0][1])) {
      return 1;
    }
    if ((vs[0][0] == vs[1][0]) && !below_vertex) {
      return 1;
    }
    if (v[1] == vs[1][1]) {
      continue;
    }
    if (v[1] == vs[0][1]) {
      if (v[0] > vs[0][0]) {
        continue;
      }
      i0 = i;
      while (areas[a]->vertices[i0][1] == v[1]) {
        i0--;
        if (i0 < 0) i0 = sizeof(areas[a]->vertices) - 1;
      }
      i1 = i;
      while (areas[a]->vertices[i1][1] == v[1]) {
        i1++;
        if (i1 >= sizeof(areas[a]->vertices)) i1 = 0;
      }
      crossings++;
      if (((areas[a]->vertices[i0][1] > v[1]) &&
           (areas[a]->vertices[i1][1] > v[1])) ||
          ((areas[a]->vertices[i0][1] < v[1]) &&
           (areas[a]->vertices[i1][1] < v[1]))) {
        crossings++;
      }
      continue;
    }
    de = vs[1][1] - vs[0][1];
    int_n = ceil(to_float(vs[1][0] - vs[0][0])*(v[1] - vs[0][1])/de
                 + vs[0][0] + 0.5);
    if (int_n > v[0]) {
      crossings++;
    }
  }
  return (crossings & 1);
}
object clone_room(int a, int *coord_q, string coord_s) {
  int i, j, e, bit;
  string dir;
  object room;
  room = clone_object(areas[a]->base);
  room_cache[coord_s] = room;
  area_cache[coord_s] = a;
  room->set_room_size(areas[a]->size);
  room->set_co_ord(coord_q);
  if (areas[a]->exits) {
    i = (areas[a]->origin[0] - coord_q[0])/(2*areas[a]->size[0]);
    j = (coord_q[1] - areas[a]->origin[1])/(2*areas[a]->size[1]);
    if ((i < areas[a]->exits->size[0]) && (j < areas[a]->exits->size[1])
        && (i >= 0) && (j >= 0)) {
      e = areas[a]->exits->image[i][j];
      foreach (dir, bit in direction_bits) {
        if (e & bit) {
          room->add_exit(dir, "", "path");
        }
      }
      room->add_property("image_cell", ({ i, j }));
    }
  }
  return room;
}
object find_room_at_coord(int *coord) {
  int a, ac, *coord_q;
  string coord_s;
  object room;
  coord_s = sprintf("%d:%d:%d", coord[0], coord[1], coord[2]);
  if (objectp(room = room_cache[coord_s])) {
    return room;
  }
  if (!undefinedp(ac = area_cache[coord_s])) {
    return clone_room(ac, coord, coord_s);
  }
  for (a = 0; a < sizeof(areas); a++) {
    coord_q = quantize_to_origin(coord, a);
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
  }
  return 0;
}
object find_room_at_exit(object r, int *d, string direc) {
  int a, ac, i, *coord, *coord_r, *coord_q;
  string coord_s;
  object room;
  mixed size_r;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (a = 0; a < sizeof(areas); a++) {
    for (i = 0; i < 3; i++) {
      coord_r[i] = coord[i] + (size_r[i] + areas[a]->size[i]) * d[i];
    }
    coord_s = sprintf("%d:%d:%d", coord_r[0], coord_r[1], coord_r[2]);
    return load_object(_handler + ":" + coord_s);
#if 0
    if (objectp(room = room_cache[coord_s])) {
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found room %O cached at %s...\n",
                 file_name(this_object()), room, coord_s);
      }
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found area %O cached at %s...\n",
                 file_name(this_object()), ac, coord_s);
      }
      return clone_room(ac, coord_r, coord_s);
    }
    coord_q = quantize_to_origin(coord_r, a);
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
#endif
  }
  return 0;
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
int goto_room_at_exit(int *d, string direc) {
  return this_player()->move_with_look(find_room_at_exit(
                        environment(this_player()), d, direc));
}
void print_images(int a) {
  if (areas[a]->height) {
    printf("-------- Height:\n");
    IMAGE_HANDLER->print_image(areas[a]->height);
  }
  if (areas[a]->exits) {
    printf("-------- Exits:\n");
    IMAGE_HANDLER->print_image(areas[a]->exits);
  }
}
void print_map(int a) {
  int s, e;
  string l = "";
  class IMAGE_INFO exits;
  if (areas[a]->exits) {
    exits = areas[a]->exits;
    for (s = 0; s < exits->size[1]; s++) {
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 128)?"\\":" ";
        l += (exits->image[s][e] & 1)  ?"|":" ";
        l += (exits->image[s][e] & 2)  ?"/":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 64) ?"-":" ";
        l += "*";
        l += (exits->image[s][e] & 4)  ?"-":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 32) ?"/":" ";
        l += (exits->image[s][e] & 16) ?"|":" ";
        l += (exits->image[s][e] & 8)  ?"\\":" ";
      }
      l += "\n";
    }
    write(l);
  }
}

==================================================
FILE: room/controller/topography/interroom.c
==================================================

#include <map.h>
inherit "/std/room";
class IROOM_INFO {
  string base;
  int *size;
  mixed *bbox;
  int sgn_n;
  int sgn_e;
  string *exits;
}
int closed;
nosave int dbg_lvl = 0;
mixed *irooms;
string *milestones;
mixed *milestone_coords;
mapping milestone_idx = ([ ]);
class IROOM_INFO *iroom_info;
mixed *overall_bbox;
string save_file;
nosave string debugger = "jeremy";
mixed *bbox(int *coord_a, int *coord_b);
int in_bbox(int *coord_a, mixed bbox);
void set_debugger(string s) { debugger = s; }
string query_debugger() { return debugger; }
void set_debug_level(int l) { dbg_lvl = l; }
int query_debug_level() { return dbg_lvl; }
mixed query(string s) { return fetch_variable(s); }
int abs(int i) {
  return (i<0)?-i:i;
}
float fabs(float i) {
  return (i<0)?-i:i;
}
void set_save_file(string s) { save_file = s; }
string query_save_file() { return save_file; }
void set_milestones(string *s) {
  int i;
  milestones = copy(s);
  if (milestones[0] == milestones[<1]) {
    closed = 1;
  }
  for (i = 0; i < sizeof(milestones) - closed; i++) {
    milestone_idx[s[i]] = i;
  }
  milestone_coords = allocate(sizeof(milestones));
  irooms = allocate(sizeof(milestones)-1);
  iroom_info = allocate(sizeof(milestones)-1);
  for (i = 0; i < sizeof(iroom_info); i++) {
    iroom_info[i] = new(class IROOM_INFO);
    iroom_info[i]->exits = allocate(2);
  }
  overall_bbox = 0;
}
string *query_milestones() { return milestones; }
string query_milestone(int i) { return milestones[i]; }
void set_milestone_coords(int i, int *c) {
  if (!arrayp(c) || (sizeof(c) != 3)) {
    return;
  }
  if (!arrayp(milestone_coords[i]) || (milestone_coords[i][0] != c[0])
  || (milestone_coords[i][1] != c[1]) || (milestone_coords[i][2] != c[2])) {
    milestone_coords[i] = copy(c);
    if ((i > 0) && arrayp(milestone_coords[i-1])) {
      iroom_info[i-1]->bbox = bbox(milestone_coords[i-1], milestone_coords[i]);
      if (milestone_coords[i-1][0] < milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = 1;
      } else if (milestone_coords[i-1][0] > milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = -1;
      } else {
        iroom_info[i-1]->sgn_n = 0;
      }
      if (milestone_coords[i-1][1] < milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = 1;
      } else if (milestone_coords[i-1][1] > milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = -1;
      } else {
        iroom_info[i-1]->sgn_e = 0;
      }
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i-1]->bbox);
      } else {
        if (iroom_info[i-1]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i-1]->bbox[0][0];
        }
        if (iroom_info[i-1]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i-1]->bbox[0][1];
        }
        if (iroom_info[i-1]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i-1]->bbox[1][0];
        }
        if (iroom_info[i-1]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i-1]->bbox[1][1];
        }
      }
    }
    if ((i < sizeof(iroom_info)) && arrayp(milestone_coords[i+1])) {
      iroom_info[i]->bbox = bbox(milestone_coords[i], milestone_coords[i+1]);
      if (milestone_coords[i][0] < milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = 1;
      } else if (milestone_coords[i][0] > milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = -1;
      } else {
        iroom_info[i]->sgn_n = 0;
      }
      if (milestone_coords[i][1] < milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = 1;
      } else if (milestone_coords[i][1] > milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = -1;
      } else {
        iroom_info[i]->sgn_e = 0;
      }
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i]->bbox);
      } else {
        if (iroom_info[i]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i]->bbox[0][0];
        }
        if (iroom_info[i]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i]->bbox[0][1];
        }
        if (iroom_info[i]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i]->bbox[1][0];
        }
        if (iroom_info[i]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i]->bbox[1][1];
        }
      }
    }
  }
}
mixed query_milestone_coords() { return milestone_coords; }
void set_bases(string *s) {
  int i;
  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of bases (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->base = s[i];
  }
}
void set_sizes(mixed *s) {
  int i;
  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of sizes (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->size = allocate(3);
    if (intp(s[i])) {
      iroom_info[i]->size[0] = s[i];
      iroom_info[i]->size[1] = s[i];
      iroom_info[i]->size[2] = s[i];
    } else if (arrayp(s[i])) {
      iroom_info[i]->size[0] = s[i][0];
      iroom_info[i]->size[1] = s[i][1];
      iroom_info[i]->size[2] = s[i][2];
    } else {
      error("Illegal room size given (" + i + ").\n");
      continue;
    }
  }
}
class IROOM_INFO *query_iroom_info() { return iroom_info; }
int query_endpoint(int i, int j, int dir) {
  if ((dir && (j == sizeof(irooms[i])-1)) || (!dir && (j == 0))) {
    return 1;
  }
  return 0;
}
object *query_irooms_inv(int i, int j, int dir) {
  int k;
  object *invs;
  invs = ({ });
  if (dir) {
    if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j+1; k < sizeof(irooms[i]); k++) {
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  } else {
    if (j == -1) {
      if (closed) {
        i = sizeof(milestones) - 2;
      } else {
        i--;
      }
      if (!arrayp(irooms[i])) {
        return invs;
      } else {
        j = sizeof(irooms[i]);
      }
    } else if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j-1; k >= 0; k--) {
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  }
  return invs;
}
mixed *bbox(int *coord_a, int *coord_b) {
  int c;
  mixed *bbox;
  bbox = allocate(2);
  bbox[0] = allocate(3);
  bbox[1] = allocate(3);
  for (c = 0; c < 3; c++) {
    if (coord_a[c] < coord_b[c]) {
      bbox[0][c] = coord_a[c];
      bbox[1][c] = coord_b[c];
    } else {
      bbox[0][c] = coord_b[c];
      bbox[1][c] = coord_a[c];
    }
  }
  return bbox;
}
int in_bbox(int *coord_a, mixed bbox) {
  if ((coord_a[0] < bbox[0][0]) || (coord_a[0] > bbox[1][0])
  || (coord_a[1] < bbox[0][1]) || (coord_a[1] > bbox[1][1]))
    return 0;
  return 1;
}
int number_of_irooms(int i) {
  int n;
  mixed bbox;
  class IROOM_INFO ir;
  ir = iroom_info[i];
  bbox = ir->bbox;
  if (ir->sgn_n == 0) {
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
  } else if (ir->sgn_e == 0) {
    n = (bbox[1][0] - bbox[0][0])/(ir->size[0]*2);
  } else {
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
    if (n != (bbox[1][0] - bbox[0][0])/(ir->size[0]*2)) {
      error("Interroom sizes don't match diagonal.\n");
      return 0;
    }
  }
  return n-1;
}
object clone_iroom(int i, int idx, int *icoord) {
  object iroom;
  iroom = clone_object(iroom_info[i]->base);
  iroom->set_room_size(iroom_info[i]->size);
  iroom->set_co_ord(icoord);
  iroom->set_milestone_index( ({ i, idx }) );
  iroom->add_exit(iroom_info[i]->exits[0], milestones[i], "road");
  iroom->add_exit(iroom_info[i]->exits[1], milestones[i+1], "road");
  iroom->add_milestone_dir(iroom_info[i]->exits[0]);
  iroom->add_milestone_dir(iroom_info[i]->exits[1]);
  iroom->add_topo_exits_int();
  return iroom;
}
void setup_milestone(object ms) {
  int *coord, i, j, idir;
  string *dir;
  if (undefinedp(i = milestone_idx[file_name(ms)])) {
    error("This room (" + file_name(ms) + ") is not a milestone.\n");
    return;
  }
  ms->set_milestone_index(file_name(this_object()), i);
  coord = ms->query_co_ord();
  if (arrayp(coord)) {
    set_milestone_coords(i, coord);
  } else {
    if (arrayp(milestone_coords[i])) {
      coord = milestone_coords[i];
    } else {
      coord = MAP->static_query_co_ord(file_name(ms));
      set_milestone_coords(i, coord);
    }
    ms->set_co_ord(coord);
  }
  if (closed && (i == 0)) {
    milestone_coords[<1] = milestone_coords[0];
  }
  dir = ms->query_dest_dir();
  if ((i > 0) || closed) {
    if (closed && i == 0) {
      j = sizeof(milestones) - 2;
    } else {
      j = i - 1;
    }
    if ((idir = member_array(milestones[j], dir)) < 0) {
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[j]->exits[0] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  } else {
    ms->add_milestone_dir(file_name(this_object()), 0);
  }
  if (i < sizeof(irooms)) {
    j = i + 1;
    if ((idir = member_array(milestones[j], dir)) < 0) {
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[i]->exits[1] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  }
}
varargs object find_room_at_coord(int *coord_a, int hint_idx) {
  int i, idx, in_bbox;
  int start_i, stop_i;
  int *icoord = ({ 0, 0, 0 });
  mixed bbox;
  float slope;
  class IROOM_INFO ir;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  coord_a: %O\n"
                 "  hint_idx: %s\n",
                 file_name(this_object()), coord_a,
                 undefinedp(hint_idx)?"NULL":hint_idx+"");
  }
  if (!in_bbox(coord_a, overall_bbox)) {
    return 0;
  }
  in_bbox = 0;
  if (undefinedp(hint_idx)) {
    start_i = 0;
    stop_i = sizeof(iroom_info);
  } else {
    start_i = hint_idx;
    stop_i = hint_idx + 1;
  }
  for (i = start_i; i < stop_i; i++) {
    ir = iroom_info[i];
    bbox = ir->bbox;
    if (dbg_lvl > 1) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Checking bbox(%d,%d): %O\n",
                   file_name(this_object()), i, i+1, bbox);
    }
    if (in_bbox(coord_a, bbox)) {
      if (dbg_lvl > 1) {
        tell_creator(debugger, "%s::find_room_at_coord()\n"
                     "  In bbox(%d,%d)...\n",
                     file_name(this_object()), i, i+1);
      }
      if (ir->sgn_e == 0) {
        if (abs(coord_a[1]-milestone_coords[i][1]) < ir->size[1]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On vline between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      } else {
        slope = to_float(milestone_coords[i][0] - milestone_coords[i+1][0])
          / to_float(milestone_coords[i][1] - milestone_coords[i+1][1]);
        if (abs(slope * (coord_a[1] - milestone_coords[i+1][1]) +
            milestone_coords[i+1][0] - coord_a[0]) < ir->size[0]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On line between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      }
    }
  }
  if (i == stop_i) {
    if (dbg_lvl > 2) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Couldn't find a room...\n",
                   file_name(this_object()));
    }
    return 0;
  }
  if (ir->sgn_n == 0) {
    idx = abs(coord_a[1] - milestone_coords[i][1]
              + ir->size[1]*ir->sgn_e)/(ir->size[1]*2);
    icoord[0] = milestone_coords[i][0];
    icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
  } else {
    idx = abs(coord_a[0] - milestone_coords[i][0]
              + ir->size[0]*ir->sgn_n)/(ir->size[0]*2);
    icoord[0] = milestone_coords[i][0] + idx*ir->sgn_n*ir->size[0]*2;
    if (ir->sgn_e == 0) {
      icoord[1] = milestone_coords[i][1];
    } else {
      icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
    }
  }
  if (dbg_lvl > 2) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  idx: %O\n",
                 file_name(this_object()), idx);
  }
  if (idx == 0) {
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])+1) {
    return load_object(milestones[i+1]);
  }
  idx--;
  if (!objectp(irooms[i][idx])) {
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
}
object find_room_at_index(int i, int idx) {
  int *icoord = ({ 0, 0, 0 });
  class IROOM_INFO ir;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_index()\n"
                 "  i: %O, idx: %O\n",
                 file_name(this_object()), i, idx);
  }
  if (closed && (i == -1)) {
    i = sizeof(milestones) - 2;
  }
  if ((i < 0) || (i >= sizeof(irooms))) {
    return 0;
  }
  if (idx == -1) {
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])) {
    return load_object(milestones[i+1]);
  }
  if (idx == -2) {
    idx = sizeof(irooms[i]) - 1;
  }
  if ((idx < 0) || (idx >= sizeof(irooms[i]))) {
    return 0;
  }
  if (!objectp(irooms[i][idx])) {
    ir = iroom_info[i];
    if (ir->sgn_n == 0) {
      icoord[0] = milestone_coords[i][0];
      icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
    } else {
      icoord[0] = milestone_coords[i][0] + (idx+1)*ir->sgn_n*ir->size[0]*2;
      if (ir->sgn_e == 0) {
        icoord[1] = milestone_coords[i][1];
      } else {
        icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
      }
    }
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
}
int query_region(int *coord, mixed bbox) {
  int ret;
  if (coord[0] < bbox[0][0]) {
    ret += 1;
  } else if (coord[0] > bbox[1][0]) {
    ret += 2;
  }
  if (coord[1] < bbox[0][1]) {
    ret += 4;
  } else if (coord[1] > bbox[1][1]) {
    ret += 8;
  }
  return ret;
}
object find_room_at_crossing(int *coord_a, int *coord_b) {
  int i, a, b, c, d, dist2, ret_dist2;
  float e, f, det;
  int *isect;
  object ret;
  mixed bbox, road_a, road_b;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_crossing()\n"
                 "  coord_a: %O\n"
                 "  coord_b: %O\n",
                 file_name(this_object()), coord_a, coord_b);
  }
  if (query_region(coord_a, overall_bbox)
      & query_region(coord_b, overall_bbox)) {
    return 0;
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    bbox = iroom_info[i]->bbox;
    if (query_region(coord_a, iroom_info[i]->bbox)
        & query_region(coord_b, iroom_info[i]->bbox)) {
      continue;
    }
    road_a = allocate(3);
    road_b = allocate(3);
    if (iroom_info[i]->sgn_n > 0) {
      road_a[0] = bbox[0][0];
      road_b[0] = bbox[1][0];
    } else {
      road_a[0] = bbox[1][0];
      road_b[0] = bbox[0][0];
    }
    if (iroom_info[i]->sgn_e > 0) {
      road_a[1] = bbox[0][1];
      road_b[1] = bbox[1][1];
    } else {
      road_a[1] = bbox[1][1];
      road_b[1] = bbox[0][1];
    }
    a = coord_b[0] - coord_a[0];
    b = coord_a[1] - coord_b[1];
    c = road_b[0] - road_a[0];
    d = road_a[1] - road_b[1];
    e = to_float(a)*coord_a[1] + to_float(b)*coord_a[0];
    f = to_float(c)*road_a[1] + to_float(d)*road_a[0];
    det = a*d - b*c;
    if (fabs(det) < 0.0000000000001) {
      continue;
    }
    isect = allocate(3);
    isect[0] = to_int(floor((a*f - e*c)/det + 0.5));
    isect[1] = to_int(floor((e*d - b*f)/det + 0.5));
    if (!in_bbox(isect, bbox) || !in_bbox(isect, bbox(coord_a, coord_b))) {
      continue;
    }
    dist2 = (isect[0]-coord_a[0])*(isect[0]-coord_a[0]) +
      (isect[1]-coord_a[1])*(isect[1]-coord_a[1]);
    if (objectp(ret) && (dist2 >= ret_dist2)) {
      continue;
    }
    ret = find_room_at_coord(isect, i);
    if (dbg_lvl > 0) {
      tell_creator(debugger, "%s::find_room_at_crossing()\n"
                   "  find_room_at_coord() returned %O\n",
                   file_name(this_object()), ret);
    }
    ret_dist2 = dist2;
    if (!objectp(ret)) {
      error("Couldn't find a room where there should be one!\n");
    }
  }
  return ret;
}
void create() {
  string std_euid;
  std_euid = "/secure/master"->creator_file(file_name(this_object()));
  seteuid(std_euid);
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  set_keep_room_loaded(1);
}
void dest_me() {
  if (stringp(save_file)) {
    unguarded( (: save_object, save_file :) );
  }
  ::dest_me();
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
int goto_room_at_index(int i, int j) {
  return this_player()->move_with_look(find_room_at_index(i, j));
}
int goto_room_at_crossing(int *a, int *b) {
  return this_player()->move_with_look(find_room_at_crossing(a, b));
}
void recalc_milestones(int idx, int callouts, object tp) {
  int *c;
  string ms;
  if (callouts > 10) {
    error(sprintf("Too many callouts in %s:recalc_iroom_info(%d, %d)\n",
          file_name(this_object()), idx, callouts));
    return;
  }
  if (!idx && !callouts && !tp) {
    rm(save_file);
    this_object()->setup();
    idx = 0;
    tp = this_player();
  }
  ms = milestones[idx];
  if (!arrayp(c = ms->query_co_ord())) {
    call_out("recalc_milestones", 0, idx, callouts+1, tp);
    tell_object(tp, sprintf("Waiting on %s (%d, %d)...\n",
                          ms, idx, callouts));
    return;
  }
  ms->setup_milestone(ms);
  tell_object(tp, sprintf("Loaded room %s at (%d, %d, %d)...\n",
                          ms, c[0], c[1], c[2]));
  idx++;
  if (idx < sizeof(milestones)) {
    call_out("recalc_milestones", 0, idx, 0, tp);
    return;
  }
  tell_object(tp, "IRoom info successfully recalculated.\n");
}
void clear_map_handler() {
  int i;
  string ms, directory, troom;
  for (i = 0; i < sizeof(milestones); i++) {
    ms = milestones[i];
    directory = implode( explode( ms, "/" )[ 0..<2 ], "/" );
    troom = explode( ms, "/" )[ <1 ];
    if ( troom[ <2.. ] == ".c" ) {
      troom = troom[ 0..<3];
    }
    MAP->del(directory, troom);
    printf("Deleting %s in %s from map handler.\n", directory, troom);
  }
}
int sanity_checks() {
  int i, success = 1;
  for (i = 0; i < sizeof(milestone_coords); i++) {
    if (sizeof(milestone_coords[i]) != 3) {
      printf("Milestone %d (%s) doesn't have proper coordinates: %O\n",
             i, milestones[i], milestone_coords[i]);
      success = 0;
    }
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    if (sizeof(iroom_info[i]->size) != 3) {
      printf("Interroom segment %d has improper size: %O\n",
             i, iroom_info[i]->size);
      success = 0;
    }
    if ((sizeof(iroom_info[i]->bbox) != 2) ||
        (sizeof(iroom_info[i]->bbox[0]) != 3) ||
        (sizeof(iroom_info[i]->bbox[1]) != 3)) {
      printf("Interroom segment %d has improper bounding box: %O\n",
             i, iroom_info[i]->bbox);
      success = 0;
    }
  }
  return success;
}

==================================================
FILE: room/controller/topography/path.h
==================================================

#define FIXED_SHADOW "/std/room/basic/topography/fixed_shadow"

==================================================
FILE: room/controller/topography/topography.c
==================================================

#include <dirs.h>
#include "path.h"
inherit "/std/basic/setup";
class bounding_box {
   int* topleft;
   int* bottomright;
}
class FIXED_INFO {
  string path;
  object ob;
  int *coord;
  mixed bbox;
}
private mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);
private int _dbg_lvl = 0;
private string _debugger;
private object *_area_handlers = ({ });
private object *_iroom_handlers = ({ });
private class FIXED_INFO *_fixed_rooms = ({ });
private mapping _fixed_room_index = ([ ]);
private class bounding_box _topo_box;
void set_debugger(string s) { _debugger = s; }
string query_debugger() { return _debugger; }
void set_debug_level(int l) { _dbg_lvl = l; }
int query_debug_level() { return _dbg_lvl; }
void create() {
  do_setup();
}
class bounding_box query_bounding_box() {
   return _topo_box;
}
int in_bbox(int *coord, class bounding_box bbox) {
  if ((coord[0] < bbox->topleft[0]) || (coord[0] > bbox->bottomright[0])) {
    return 0;
  }
  if ((coord[1] < bbox->topleft[1]) || (coord[1] > bbox->bottomright[1])) {
    return 0;
  }
  return 1;
}
class bounding_box bounding_box(int *coord, mixed s) {
  int *size;
  class bounding_box bbox;
  if (sizeof(coord) != 3) {
    return 0;
  }
  if (arrayp(s)) {
    if (sizeof(s) == 3) {
      size = s;
    } else {
      return 0;
    }
  } else if (intp(s)) {
    size = ({ s, s, s });
  } else {
    return 0;
  }
  bbox = new(class bounding_box);
  bbox->topleft = ({ coord[0]-size[0], coord[1]-size[1], coord[2]-size[2] });
  bbox->bottomright = ({ coord[0]+size[0], coord[1]+size[1], coord[2]+size[2] });
  return bbox;
}
void add_area_handler(mixed h) {
  object oh;
  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _area_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find area handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _area_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find area handler %O.\n", h));
  }
}
void add_iroom_handler(mixed h) {
  object oh;
  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _iroom_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find interroom handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _iroom_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find interroom handler %O.\n", h));
  }
}
private void add_internal_fixed_room(string path,
                                     object ob,
                                     int* coord,
                                     class bounding_box bbox) {
  class FIXED_INFO cf;
  cf = new(class FIXED_INFO);
  cf->path = path;
  cf->ob = ob;
  cf->coord = coord;
  cf->bbox = bbox;
  _fixed_room_index[cf->path] = sizeof(_fixed_rooms);
  _fixed_rooms += ({ cf });
}
void add_fixed_room(string f) {
  object of;
  of = load_object(f);
  if (!objectp(of)) {
    error(sprintf("Couldn't load fixed room %s.\n", f));
    return;
  }
  add_internal_fixed_room(f, of, of->query_co_ord(),
                      bounding_box(of->query_co_ord(), of->query_room_size()));
}
void add_fixed_room_object(object of) {
  add_internal_fixed_room(file_name(of), of, of->query_co_ord(),
                    bounding_box(of->query_co_ord(), of->query_room_size()));
}
void add_fixed_room_coordinate(string f, int* coord, int* size) {
    add_internal_fixed_room(f, 0, coord, bounding_box(coord, size));
}
void setup_fixed_room() {
  object shad, r;
  int i;
  r = previous_object();
  shad = clone_object(FIXED_SHADOW);
  if (!objectp(shad)) {
    error(sprintf("Couldn't create shadow for fixed room %O.\n", r));
    return;
  }
  shad->attach(r);
  shad->set_area_handler(file_name(this_object()));
  if (undefinedp(i = _fixed_room_index[file_name(r)])) {
    error(sprintf("Couldn't find entry for fixed room %O.\n", r));
  }
  r->set_co_ord(_fixed_rooms[i]->coord);
}
object find_room_at_coord(int *coord) {
  int i;
  object ob;
  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_coord()\n"
                 "  coord: %O\n",
                 file_name(this_object()), coord);
  }
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      return _fixed_rooms[i]->ob;
    }
  }
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    if (objectp(ob = _iroom_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  return 0;
}
object create_virtual_object(int x, int y, int z) {
   if (undefinedp(x) || undefinedp(y) || undefinedp(z)) {
      return 0;
   }
   return find_room_at_coord(({ x, y, z }));
}
object find_room_at_exit(object r, int *d, string direc) {
  int i, s, dist, max_dist, max_iroom, *coord, *coord_r, *coord_ob;
  string msg;
  object ob, *irooms = ({ });
  mixed size_r;
  class bounding_box bbox_r;
  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (i = 0; i < 3; i++) {
    coord_r[i] = coord[i] + 2 * size_r[i] * d[i];
  }
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord_r, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      msg = evaluate(_fixed_rooms[i]->ob->query_topo_barrier(direc));
      if (!undefinedp(msg)) {
        if (!stringp(msg)) {
          msg = "You can't go that way.\n";
        }
        notify_fail(msg);
        return 0;
      }
      return _fixed_rooms[i]->ob;
    }
  }
  bbox_r = bounding_box(coord, size_r);
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    ob = _iroom_handlers[i]->find_room_at_crossing(coord, coord_r);
    tell_creator("rhinehold", "ob = %O\n", ob);
    if (objectp(ob )
        && (ob != r)) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_crossing() returned %O\n",
                     file_name(this_object()), _iroom_handlers[i], ob);
      }
      if (!arrayp(ob->query_co_ord())) {
        return ob;
      }
      if (r->query_fixed_room() && in_bbox(ob->query_co_ord(), bbox_r)) {
        continue;
      }
      irooms += ({ ob });
    }
  }
  if ((s = sizeof(irooms)) > 0) {
    if (s == 1) {
      return irooms[0];
    } else {
      max_dist = 0;
      max_iroom = -1;
      for (i = 0; i < s; i++) {
        coord_ob = irooms[i]->query_co_ord();
        dist = (coord[0] - coord_ob[0])*(coord[0] - coord_ob[0]) +
          (coord[1] - coord_ob[1])*(coord[1] - coord_ob[1]);
        if (dist > max_dist) {
          max_dist = dist;
          max_iroom = i;
        }
      }
      if (max_iroom >= 0) {
        return irooms[max_iroom];
      }
    }
  }
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_exit(r, d))) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_exit() returned %O\n",
                     file_name(this_object()), _area_handlers[i], ob);
      }
      return ob;
    }
  }
  return 0;
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
string query_text_map(int width) {
   int x;
   int y;
   int maxy;
   string map;
   object room;
   map = "";
   for (y = 0; y < maxy; y++) {
      for (x = 0; x < width; x++) {
         room = find_room_at_coord( ({ x, y, 0 }) );
         if (!room) {
            map += " ";
         } else if (!room->query_room_letter()) {
            map += "?";
         } else {
            map += room->query_room_letter();
         }
      }
      map += "\n";
   }
   return map;
}

==================================================
FILE: room/punishments/banishment.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
private nosave string _banish_handler;
void create() {
   set_short("banishment");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "banishment");
   ::create();
}
void set_banish_handler(string hand) {
   _banish_handler = hand;
}
string query_banish_handler() {
   return _banish_handler;
}
string query_short(string area, class nomic_case the_case, string type, mixed data) {
   return ::query_short() + " for " + data + " days";
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   if (sizeof(filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area))) {
      write("You cannot banish a magistrate.\n");
      return ;
   }
   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
}
void days_of_banishment(string input,
                        string area,
                        class nomic_case the_case,
                        string type,
                        function finish) {
   int num;
   input = lower_case(input);
   if (input == "" || input[0] == 'q') {
      write("Aborting banishment.\n");
      return ;
   }
   if (input[0] >= '0' && input[0] <= '9') {
      if (sscanf(input, "%d", num) == 1) {
         evaluate(finish, the_case, type, num);
         return ;
      }
   }
   write("Invalid input.\n");
   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      _banish_handler->banish_person(person, data);
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      _banish_handler->banish_person_suspend(person);
   }
   return ;
}

==================================================
FILE: room/punishments/dismissed.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("dismissed");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "dismissed");
}

==================================================
FILE: room/punishments/fine.c
==================================================

#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
inherit "/std/room/inherit/punishment_inherit";
#define TIMEOUT (4 * 7 * 24 * 60 * 60)
private mapping _fines;
private nosave string _money_area;
private nosave string _save_file;
class fine_type {
   int paid;
   int fines;
   int last_touched;
}
void load_me();
void setup() {
   _fines = ([ ]);
   set_short("fine");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "fine");
   seteuid(getuid());
   load_me();
}
void load_me() {
   if (_save_file) {
      unguarded((: restore_object( _save_file ) :));
      call_out("remove_old_fines", 2);
   }
}
void save_me() {
   unguarded((: save_object( _save_file ) :));
}
void remove_old_fines() {
   class fine_type fine;
   string player;
   int changed;
   foreach (player, fine in _fines) {
      if (!PLAYER_HANDLER->test_user(player)) {
         map_delete(_fines, player);
         changed = 1;
      }
      if (sizeof(fine) == 2) {
         fine = new(class fine_type, paid : fine->paid, fines : fine->fines,
                                last_touched : time());
         _fines[player] = fine;
         changed = 1;
      }
      if (fine->fines <= 0 && fine->last_touched + TIMEOUT < time()) {
         map_delete(_fines, player);
         changed = 1;
      }
   }
   if (changed) {
      save_me();
   }
}
void set_money_area(string area) {
   _money_area = area;
}
string query_money_area() {
   return _money_area;
}
void set_save_file(string fname) {
   _save_file = fname;
}
string query_save_file() {
   return _save_file;
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   write("How much do you wish to fine " +
         query_multiple_short(the_case->people) + "? ");
   input_to("fine_amount", 0, area, the_case, type, finish);
}
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "fined " +
          MONEY_HAND->money_value_string(data, _money_area);
}
void fine_amount(string amt, string area, class nomic_case the_case,
                 string type, function finish) {
   int value;
   amt = lower_case(amt);
   if (!strlen(amt) || amt[0] == 'q') {
      write("Aborting the fine.\n");
      return ;
   }
   value = MONEY_HAND->value_from_string(amt, _money_area);
   if (value <= 0) {
      write("You did not specify a positive money value.\n");
      write("How much do you wish to fine " +
            query_multiple_short(the_case->people) + "? ");
      input_to("fine_amount", 0, area, the_case, type, finish);
      return ;
   }
   evaluate(finish, the_case, type, value);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines += data;
      _fines[person]->last_touched = time();
   }
   save_me();
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines -= data;
      _fines[person]->last_touched = time();
   }
   save_me();
   return ;
}
int pay_fine(string person, int amount) {
   if (_fines[person]) {
      _fines[person]->paid += amount;
      _fines[person]->last_touched = time();
      save_me();
      return 1;
   }
   return 0;
}
int query_current_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines - _fines[person]->paid;
   }
   return 0;
}
int query_total_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines;
   }
   return 0;
}
int query_total_payments(string person) {
   if (_fines[person]) {
      return _fines[person]->paid;
   }
   return 0;
}
string* query_people_with_fines() {
   return keys(_fines);
}

==================================================
FILE: room/punishments/lose_citizenship.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("lose citizenship");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "lose_citizenship");
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   string* not_citizens;
   string* magistrates;
   not_citizens = filter(the_case->people,
                     (: !NOMIC_HANDLER->is_citizen_of($2, $1) :), area);
   if (sizeof(not_citizens)) {
      write(query_multiple_short(not_citizens) + " cannot lose "
            "their citizenship since they are not citizens.\n");
      return ;
   }
   magistrates = filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area);
   if (sizeof(magistrates)) {
      write(query_multiple_short(magistrates) + " cannot lose "
            "their citizenship since they are magistrates.\n");
      return ;
   }
   evaluate(finish, the_case, type, 0);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;
   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->remove_citizen(area, citizen);
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;
   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->add_citizen(area, citizen);
   }
   return ;
}

==================================================
FILE: room/punishments/not_guilty.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("not guilty");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "not_guilty");
}

==================================================
FILE: room/punishments/title.c
==================================================

#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
#include <player.h>
inherit "/std/room/inherit/punishment_inherit";
private nosave string* _titles;
void create() {
   _titles = ({ });
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "title");
   set_short("title");
   ::create();
}
void set_titles(string* titles) {
   _titles = titles;
}
string* query_titles() {
   return _titles;
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   int i;
   for (i = 0; i < sizeof(_titles); i++) {
      write(sprintf("%c) %s\n", i + 'A', _titles[i]));
   }
   write("Which title do you wish " +
         query_multiple_short(the_case->people) + " to have? ");
   input_to("choose_title", 0, area, the_case, type, finish);
}
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "set to a title of " + data[0] + " for " + data[1] + " hours";
}
void choose_title(string title, string area, class nomic_case the_case,
                 string type, function finish) {
   int i;
   int pos;
   if (!strlen(title) || title[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }
   title = lower_case(title);
   if (strlen(title) == 1) {
      pos = title[0] = 'a';
      if (pos >= 0 && pos < sizeof(_titles)) {
         title = _titles[pos];
      }
   }
   if (member_array(title, _titles) == -1) {
      write("You did not specify a valid title.\n");
      for (i = 0; i < sizeof(_titles); i++) {
         write(sprintf("%c) %s\n", i + 'A', _titles[i]));
      }
      write("What title do you want to give " +
            query_multiple_short(the_case->people) + "? ");
      input_to("choose_title", 0, area, the_case, type, finish);
      return ;
   }
   write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
         title +
         "(this is in hours and is online time, not real time)? ");
   input_to("choose_timeout", 0, area, the_case, type, finish, title);
}
void choose_timeout(string str, string area, class nomic_case the_case,
                 string type, function finish, string title) {
   int timeout;
   if (!strlen(str) || str[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }
   timeout = to_int(str);
   if (timeout <= 0) {
      write("The timeout must be greator than 0 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }
   if (timeout > 30) {
      write("The timeout must be less than 30 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }
   evaluate(finish, the_case, type, ({ title, timeout }));
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->set_forced_title_on_player(person, data[0], data[1] * (60 * 60));
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->remove_forced_title(person, data[0]);
   }
   return ;
}

==================================================
FILE: room/furniture/bank_franchise.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/bank_franchise";
#include <money.h>
#include <am_time.h>
#define SAVE_TIME 300
#define OBJECT_TAG "bank franchise"
#define MONTH_LENGTH (AM_SECONDS_PER_WEEK * 4)
private nosave int _maximum_total_difference;
private int _last_paid;
void create() {
   _maximum_total_difference = 4000;
   _last_paid = time();
   bank_franchise::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("bank");
   set_commercial_information("A franchise is connected up to a main "
          "bank.  You will pay a monthly fee to the main bank that is "
          "settable by the owner of the main bank.  The maximum balance "
          "of the bank counter is variable, but it is controlled at purchase "
          "time.  The bank balance and the float of the shop are tied "
          "together.");
   add_help_file("bank_franchise");
}
int query_player_bank() {
   return 1;
}
void set_maximum_total_difference(int max) {
   _maximum_total_difference = max;
}
int query_maximum_total_difference() {
   return _maximum_total_difference;
}
void set_last_paid(int paid) {
   _last_paid = paid;
}
int query_last_paid() {
   return _last_paid;
}
void adjust_account(string person, int amount) {
   adjust_float(amount);
}
object find_main_bank() {
   object office;
   object* obs;
   office = load_object(BANK_HANDLER->query_bank_master_office(query_bank_name()));
   if (!office) {
      return 0;
   }
   if (office->query_bank()) {
      return office;
   }
   obs = filter(office->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (!sizeof(obs)) {
      return 0;
   }
   return obs[0];
}
int can_adjust_account(string person, int amount) {
   int amt;
   amt = query_total_difference() + amount;
   if (amt < -query_maximum_total_difference()  ||
       amt > query_maximum_total_difference()) {
      if (amt < 0) {
         add_failed_mess("This bank does not have the funds to handle "
                            "your request.\n");
      } else {
         add_failed_mess("This bank does not have the vault space to handle "
                            "your request.\n");
      }
      return 0;
   }
   return ::can_adjust_account(person, amount);
}
string query_commercial_information() {
   string* bits;
   string bank;
   string place;
   place = previous_object()->query_money_place();
   bits = ({ });
   foreach (bank in BANK_HANDLER->query_banks()) {
      bits += ({ bank + " costs " +
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(bank), place) +
                 " per month and " +
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(bank), place) +
                 " to open" });
   }
   return ::query_commercial_information() +
          "This counter has a fixed maximum bank balance of " +
          MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
          ".  The costs of the franchises are " + query_multiple_short(bits) +
          ".";
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   set_percentage(percent);
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_open_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   return 1;
}
int is_allowed(string name) {
   return commercial::is_allowed(name);
}
void init() {
   bank_franchise::init();
   commercial::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
   }
}
string query_franchise() {
   return file_name(environment());
}
void event_save(object ob) {
   environment()->event_save(ob);
}
mapping query_commercial_options() {
   string bank;
   mapping ret;
   ret = ([ ]);
   foreach (bank in BANK_HANDLER->query_banks()) {
      ret[bank] = BANK_HANDLER->query_bank_default_cost_to_open(bank);
   }
   return ([ "branch" : ret ]);
}
void set_commercial_option(string type, string name, object room) {
   switch (type) {
   case "branch" :
      set_bank_name(name);
      BANK_HANDLER->add_new_franchise(name,
                                      file_name(room->query_main_room()));
      break;
   }
}
int query_monthly_fee() {
   return BANK_HANDLER->query_bank_franchise_cost_per_month(
             query_bank_name(), query_franchise());
}
int is_open_for(string type, string name) {
   if (query_monthly_fee() == -1) {
      return 0;
   }
   return ::is_open_for(type, name);
}
void setup_call_out() {
   int tim;
   if (!_last_paid) {
      _last_paid = time();
   }
   tim = _last_paid + MONTH_LENGTH - time();
   call_out("make_payment", tim);
}
void make_payment() {
   _last_paid += MONTH_LENGTH;
   adjust_float(-query_monthly_fee());
   setup_call_out();
}
string query_main_status(int hints) {
   string ret;
   string place;
   add_help_file("bank_franchise");
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n"
         "$I$6=   Bank Branch                  : " + query_bank_name() + "\n"
         "$I$6=   Revenue                      : " +
             MONEY_HAND->money_value_string(query_revenue(), place) + "\n"
           "$I$6=   Master Address               : " +
             BANK_HANDLER->query_bank_master_office(query_bank_name())->query_address() +
         "\n$I$6=   Maximum allowed bank balance : " +
             MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
         " (fixed)\n$I$6=   Bank Balance                 : " +
             MONEY_HAND->money_value_string(query_total_difference(), place) +
         "\n$I$6=   Credit Notes Outstanding     : " +
             MONEY_HAND->money_value_string(query_outstanding_credit_value(), place) + "\n";
   if (hints) {
      ret += "$I$6=     Hint: list credit notes\n";
      ret += "$I$6=     Hint: create credit note\n";
      ret += "$I$6=     Hint: recind credit note <id>\n";
   }
   ret += "$I$6=   Monthly Fee                  : " +
             MONEY_HAND->money_value_string(query_monthly_fee(), place) +
         " (set by bank owner)\n"
         "$I$6=   Next Pay Day                 : " +
             AM_TIME_HANDLER->query_am_time(_last_paid + MONTH_LENGTH) +
             " (" + ctime(_last_paid + MONTH_LENGTH) + ")\n"
         "$I$6=   Percentage                   : " +
             query_percentage() + "%"
         "\n$I$6=   Open account cost            : " +
             MONEY_HAND->money_value_string(query_account_cost(), place) +
       "\n";
   if (hints) {
      ret += "$I$6=     Hint: set open cost <amount> on <bank>\n";
   }
   return ret;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   add_auto_load_value(map, OBJECT_TAG, "notes", query_credit_notes());
   add_auto_load_value(map, OBJECT_TAG, "credit num", query_credit_num());
   add_auto_load_value(map, OBJECT_TAG, "last paid", query_last_paid());
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
   set_credit_notes(query_auto_load_value(map, OBJECT_TAG, "notes"));
   set_credit_num(query_auto_load_value(map, OBJECT_TAG, "credit num"));
   set_last_paid(query_auto_load_value(map, OBJECT_TAG, "last paid"));
   setup_call_out();
}
mixed* stats() {
   return bank_franchise::stats() + commercial::stats() + ({
          ({ "last paid", ctime(_last_paid) }) });
}

==================================================
FILE: room/furniture/bank_master.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/furniture/commercial";
nosave inherit "/std/shops/inherit/bank_master";
#define OBJECT_TAG "bank master"
private nosave string _place;
void create() {
  add_help_file("bank_master");
  commercial::create();
  bank_master::create();
  set_commercial_name("bank");
}
void event_save(object ob) {
   environment()->event_save(ob);
}
mixed *stats() {
  return commercial::stats() +
         bank_master::stats();
}
object find_bank_object(string franchise) {
   object* obs;
   object room;
   room = load_object(franchise);
   if (room->query_bank()) {
      return room;
   }
   obs = filter(room->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
int do_list_franchises() {
   string franchise;
   int pos;
   object bank_ob;
   string ret;
   string place;
   if (!sizeof(BANK_HANDLER->query_franchises(query_bank_name()))) {
      add_failed_mess("This bank has no franchises.\n");
      return 0;
   }
   place = query_money_place();
   ret = "Franchises:\n";
   foreach (franchise in BANK_HANDLER->query_franchises(query_bank_name())) {
      bank_ob = find_bank_object(franchise);
      ret += sprintf("$I$6=   %c %s Balance %s (cost per month %s)\n",
                      pos + 'A', franchise->the_short(),
                      MONEY_HAND->money_value_string(bank_ob->query_total_difference(), place),
                      MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_franchise_cost_per_month(query_bank_name(), franchise), place));
      pos++;
   }
   write("$P$Franchises$P$" + ret);
   return 1;
}
int do_set_franchise_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_to_open(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_default_monthly_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_per_month(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_main_bank_name(string new_name) {
   string* names;
   string name;
   if (query_bank_name()) {
      add_failed_mess("This bank already has a name.\n");
      return 0;
   }
   names = BANK_HANDLER->query_banks();
   foreach (name in names) {
      if (lower_case(name) == lower_case(new_name)) {
         add_failed_mess("There is already a bank called " +
                         name + ".\n");
         return 0;
      }
   }
   write("Do you really want to set the bank name to " + new_name +
         " (Make sure you have correct capitalisation)? ");
   input_to("check_bank_name", 0, new_name);
   add_succeeded_mess("");
   return 1;
}
void check_bank_name(string response, string new_name) {
   if (!strlen(response) || lower_case(response)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   write("You set the bank name to " + new_name + ".\n");
   BANK_HANDLER->create_new_bank(new_name, file_name(environment()));
   ::set_bank_name(new_name);
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   set_percentage(percent);
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_open_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   return 1;
}
int do_set_franchise_cost_per_month(string id, string amount) {
   string *franchises;
   int id_num;
   int amt;
   id = lower_case(id);
   if (strlen(id) != 1) {
      add_failed_mess("Must be one letter.\n");
      return 0;
   }
   franchises = BANK_HANDLER->query_franchises(query_bank_name());
   id_num = id[0] - 'a';
   if (id_num < 0 || id_num >= sizeof(franchises)) {
      add_failed_mess("The id of the franchises must be between 'A' and '" +
                      sprintf("%c", 'A' + sizeof(franchises) - 1) + ".\n");
      return 0;
   }
   amt = MONEY_HAND->value_from_string(amount, query_money_place());
   if (amt <= 0) {
      add_failed_mess("The amount " + amount + " is invalid.\n");
      return 0;
   }
   BANK_HANDLER->set_bank_franchise_cost_per_month(query_bank_name(),
               franchises[id_num], amt);
   add_succeeded_mess(({ "You set the cost per month for the franchise " +
                         franchises[id_num]->query_address() + " to " +
                         MONEY_HAND->money_value_string(amt, query_money_place()) + ".\n",
                         "" }));
   return 1;
}
string query_main_status(int hints) {
   string ret;
   string place;
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n";
   ret += "$I$6=   Bank Name             : " +
          query_bank_name() + "\n";
   ret += "$I$6=   Revenue               : " +
          MONEY_HAND->money_value_string(query_revenue(), place) + "\n";
   ret += "$I$6=   Cost to buy franchise : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set buy franchise cost <amount> on <object>\n";
   }
   ret += "$I$6=   Franchise cost per month : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set default franchise monthly cost <amount> on <object>\n";
   }
   ret += "$I$6=   Percentage            : " +
             query_percentage() + "%\n";
   if (hints) {
      ret += "$I$9=      Hint: set percentage <number> on <counter>\n";
   }
   ret += "$I$6=   Cost to open account  : " +
          MONEY_HAND->money_value_string(query_account_cost(), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set account cost <amount> on <object>\n";
   }
   ret += "$I$6=   Number of Franchises  : " +
          sizeof(BANK_HANDLER->query_franchises(query_bank_name())) + "\n";
   return ret;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
}
void init() {
   commercial::init();
   bank_master::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "bank name <string'name'> on <direct:object>",
                  (: do_set_main_bank_name($4[0]) :));
      add_command("set", "buy franchise cost <string'cost'> on <direct:object>",
                  (: do_set_franchise_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> on <direct:object>",
                  (: do_set_default_monthly_cost($4[0]) :));
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> for <string'franchise id'> on <direct:object>",
                  (: do_set_franchise_cost_per_month($4[1], $4[0]) :));
      add_command("list", "franchises on <direct:object>",
                  (: do_list_franchises :));
   }
}

==================================================
FILE: room/furniture/basic.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <room/placement.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
void create() {
  do_setup++;
  object::create();
  furniture_base::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  set_no_all(1);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
}

==================================================
FILE: room/furniture/bath.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/surface";
#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
int water = 0;
int dirt = 0;
string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});
void zap_bad_effects( object who );
int do_wash(object *indirect_obs );
void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
    add_help_file("bath");
}
string extra_look() {
    object *stuff;
    string answer = "";
    stuff = all_inventory( this_object() );
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " +
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n";
    }
   return answer;
}
string long_status() {
    return "";
}
void init(){
    ::init();
    add_command( "lie", "in <direct:object>");
    add_command( "sit", "in <direct:object>");
    add_command( "kneel", "in <direct:object>");
    add_command( "stand", "in <direct:object>");
    add_command( "leave", "<direct:object>");
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
}
int can_player_get_in_it() {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to get in it.\n");
      return 0;
    }
    if( environment( this_object() ) == this_player() ){
        this_object()->move(environment(this_player() ));
        tell_object(this_player(), "You drop the "+
            this_object()->short()+".\n");
        tell_room(environment(this_player()), this_player()->short()+" drops "
        "a "+this_object()->short()+".\n", this_player() );
    }
    return 1;
}
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {
            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}
void reset() {
    wet_everyone_in();
}
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}
int do_lie() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "lying") {
            tell_object(player, "You are already lying in the pool.\n" );
            return 1;
        }
        tell_object(player, "You lie in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" lies "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and lie down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and lies down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_sit() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "sitting") {
            tell_object(player, "You are already sitting in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You sit in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" sits "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and sit down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and sits down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "sitting" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_kneel() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player=this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "kneeling") {
            tell_object(player, "You are already kneeling in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You kneel in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" kneels "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and kneel down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and kneel down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "kneeling" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_stand() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player = this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "standing") {
            tell_object(player, "You are already standing in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You stand in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" stands "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + ".\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
void event_exit(object ob, string message, object to) {
  if (ob==this_player() && this_player()->query_position_on() == this_object()) {
    this_player()->return_to_default_position(1);
  }
}
int do_leave(){
    if (this_player()->query_position_on() == "the "+this_object()->short()) {
        this_player()->return_to_default_position(1);
        tell_object(this_player(), "You clamber out of the " + this_object()->short() + ".\n" );
        tell_room(environment(this_object()), this_player()->short()+" clambers "
            "out of the " + this_object()->short() + ".\n", this_player() );
    }
    else {
        tell_object(this_player(), "Umm... You're not in the " + this_object()->short() + " in the "
            "first place.\n" );
    }
    add_succeeded_mess( "", ({ }) );
    return 1;
}
int do_splash( object *indirect_obs ) {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to splash with it.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}
int do_wash( object *indirect_obs ) {
    if (!can_player_get_in_it()) {
        return 0;
    }
    if (this_player() -> query_position_type() != "in" &&
        this_player()->query_position_on() != "the "+this_object()->short()) {
      this_player()->add_failed_mess(this_object(), "You need to get "
                                     "into the " + this_object()->short() +
                                     " first.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
}
int query_baths() {
    return 1;
}
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    dirt++;
    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.writing.soap");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The rest of the words wash off without a single "
            "bubble in sight.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    if (!random(dirt)) {
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
}

==================================================
FILE: room/furniture/chime_inherit.c
==================================================

inherit "/std/object";
inherit "/std/room/furniture/inherit/furniture_base";
#include <weather.h>
#define TIME 120
string chimes_short();
string chimes_long();
void set_chime_type( string type );
string chime_type();
void jingle();
string chime_verb();
void add_chime_verb( string verb );
void remove_chime_verb( string verb );
string *query_chime_verbs();
void set_hung_up( int up );
int hung_up();
void set_hook( object hook );
object hook();
int do_hang( object hook );
int do_unhang();
private string _chime_type = "metal";
private string *_chime_verbs = ({ "jingles", "tinkles" });
private int _hung_up = 0;
private object _hook;
void create() {
   furniture_base::create();
   object::create();
}
void setup() {
  set_name( "chime" );
  set_short( (: chimes_short() :) );
  set_long( (: chimes_long() :) );
  add_adjective( ({ "wind", chime_type() }) );
  set_value( 420 );
}
void init() {
  add_command( "hang", "<direct:object'chime'> {on|from} "
      "<indirect:object'hook'>", (: do_hang( $1[0] ) :) );
  add_command( "unhang", "<direct:object'chime'>" );
}
string chimes_short() {
  return chime_type() + " wind chime";
}
string chimes_long() {
  return "This little wind chime is nothing more than bits of "
             + chime_type() + " dangling from strings tied to a "
             "ring.\n";
}
void set_chime_type( string type ) {
  remove_adjective( _chime_type );
  add_adjective( type );
  _chime_type = type;
}
string chime_type() { return _chime_type; }
void jingle() {
  object env = environment();
  int wind;
  if( !env )
    return;
  if( !hung_up() )
    return;
  if( !inherits( "/std/room", env ) )
    return;
  wind = env->query_wind_speed();
  if( undefinedp( wind ) ) {
    if( env->query_property( "location" ) == "outside" ||
        env->query_property( "windy" ) )
      wind = WEATHER->query_windsp( this_object() );
    else
      return;
  }
  if( random( wind ) )
    tell_room( env, the_short() + chime_verb() + " in the "
        "wind.\n" );
  call_out( "jingle", TIME );
}
string chime_verb() {
  return " " + _chime_verbs[ random( sizeof( _chime_verbs ) ) ];
}
void add_chime_verb( string verb ) {
  _chime_verbs += ({ verb });
}
void remove_chime_verb( string verb ) {
  _chime_verbs -= ({ verb });
}
void set_chime_verbs( string *verbs ) { _chime_verbs = verbs; }
string *query_chime_verbs() { return _chime_verbs; }
void set_hung_up( int up ) {
  remove_call_out( "jingle" );
  if( up )
    call_out( "jingle", 30 );
  _hung_up = up;
}
int hung_up() { return _hung_up; }
void set_hook( object hook ) { _hook = hook; }
object hook() { return _hook; }
int jingling() { return find_call_out( "jingle" ); }
void init_dynamic_arg( mapping arg ) {
  set_chime_type( arg[ "type" ] );
  set_chime_verbs( arg[ "chime verbs" ] );
  set_hook( arg[ "hook" ] );
  set_hung_up( arg[ "hung up" ] );
  if( undefinedp( hook() ) || !hung_up() ||
      !sizeof( match_objects_for_existence( hook(), ({ environment() }) ) ) ) {
    remove_property( "there" );
    set_hung_up( 0 );
  }
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "type" : chime_type(),
            "chime verbs" : query_chime_verbs(),
            "hung up" : hung_up(),
            "hook" : hook() ]);
}
int do_hang( object hook ) {
  string where = hook->a_short();
  if( hung_up() ) {
    add_failed_mess( "The chime is already hanging up.\n" );
    return 0;
  }
  if( !hook->query_hook() && !hook->query_property( "hook" ) )
    return 0;
  if( move( environment( this_player() ) ) )
    return 0;
  if( where )
    where = "on " + where;
  else
    where = "up";
  add_property( "there", "hanging "+ where );
  reset_get();
  set_hung_up( 1 );
  set_hook( hook );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D on "
      "$I.\n", ({ hook }) );
  return 1;
}
int do_unhang() {
  if( !hung_up() ) {
    add_failed_mess( "The chime isn't hanging from anything.\n" );
    return 0;
  }
  remove_property( "there" );
  set_get();
  set_hung_up( 0 );
  move( this_player() );
  return 1;
}

==================================================
FILE: room/furniture/clock.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/obj/clock";
inherit "/std/room/furniture/inherit/furniture_base";
void chime(string mess) {
  int *co_ords;
  if(environment(this_object())) {
    co_ords = (int *)environment(this_object())->query_co_ord();
    "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
                                                 mess, 20, 1, 0 );
    tell_room(environment(this_object()), mess);
  }
}
void create() {
   do_setup++;
   clock::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   furniture_base::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
}
private int do_real_move(mixed dest, string messin, string messout) {
   return clock::move(dest, messin, messout);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}

==================================================
FILE: room/furniture/commercial.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <money.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
string query_main_status(int hints);
private nosave int _commercial_size;
private nosave string _commercial_type;
private nosave string _commercial_name;
private nosave string* _use_types;
private nosave string _info;
private int _revenue;
private int _weekly_revenue;
private int _commercial_id;
private int _weekly_upkeep_cost;
#define OBJECT_TAG "commercial inh"
void create() {
   _commercial_size = 100;
   if (!_use_types) {
      _use_types = ({ });
   }
   do_setup++;
   object::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
   reset_get();
}
void set_weekly_upkeep_cost(int cost) {
   _weekly_upkeep_cost = cost;
}
int query_weekly_upkeep_cost() {
   return _weekly_upkeep_cost;
}
int query_revenue() {
   return _revenue;
}
void set_revenue(int revenue) {
   _revenue = revenue;
}
string query_save_dir() {
   return environment()->query_save_dir();
}
string query_owner() {
  return environment()->query_owner();
}
string query_language() {
  return environment()->query_language();
}
string query_money_place() {
   if (!environment()) {
      return "default";
   }
   return environment()->query_property("place");
}
int is_allowed(string person) {
   return environment()->is_allowed(person);
}
string query_allowed() {
   return environment()->query_allowed();
}
int query_float() {
   return environment()->query_royalty(query_owner());
}
int query_royalty(string person) {
   return environment()->query_royalty(person);
}
int adjust_royalty(string person, int amount) {
   if (person == query_owner()) {
      _revenue += amount;
      _weekly_revenue += amount;
   }
   environment()->adjust_royalty(person, amount);
}
int adjust_float(int amt) {
   adjust_royalty(query_owner(), amt);
}
int is_open_for(string type, string person) {
   if (!environment()->query_commercial_property()) {
      return 0;
   }
   return environment()->is_open_for(type, person);
}
void set_commercial_size(int size) {
   _commercial_size = size;
}
string query_commercial_type() {
   return _commercial_type;
}
void set_commercial_type(string type) {
   _commercial_type = type;
}
void set_commercial_information(string info) {
   _info = info;
}
string query_commercial_information() {
   return _info;
}
void set_commercial_name(string name) {
   _commercial_name = name;
}
string query_commercial_name() {
   return _commercial_name;
}
int query_commercial_size() {
   return _commercial_size;
}
int query_commercial_id() {
   return _commercial_id;
}
void setup_new_commercial_id() {
   _commercial_id = environment()->find_next_commercial_id();
}
void set_commercial_id(int id) {
   _commercial_id = id;
}
string query_parcel_post() {
   return environment()->query_parcel_post();
}
void set_shop_use_types(string* types) {
   _use_types = types;
}
string* query_shop_use_types() {
   return _use_types;
}
void reset_weekly_status() {
   _weekly_revenue = 0;
}
string query_weekly_status_string() {
   string ret;
   string place;
   place = query_money_place();
   if (query_weekly_upkeep_cost()) {
      ret = "Weekly Upkeep : " +
            MONEY_HAND->money_value_string(_weekly_upkeep_cost, place) + "\n" +
            "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n" +
            "Profit        : " +
            MONEY_HAND->money_value_string(_weekly_revenue - _weekly_upkeep_cost, place) + "\n";
   } else {
      ret = "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n";
   }
   return ret;
}
int can_trash_furniture() {
   return 1;
}
int query_commercial_furniture() {
   return 1;
}
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   int t;
   int f;
   object from;
   if(stringp(dest)) {
      dest = find_object(dest);
   }
   if (!move_check(dest)) {
      write(the_short() + " resists being picked up and shocks you slightly.\n");
      return MOVE_INVALID_DEST;
   }
   if(!dest) {
      return MOVE_INVALID_DEST;
   }
   if(living(dest)) {
      t = (int)this_object()->query_complete_weight() * 5;
      if(!(dest->add_weight(t))) {
         return MOVE_TOO_HEAVY;
      }
      debug_printf("Added %d", t);
   }
   from = environment();
   i = ::move(dest, messin, messout);
   if(i != MOVE_OK) {
      dest->add_weight(-t);
      return i;
   }
   if(from && living(from)) {
      f = (int)this_object()->query_complete_weight() * 5;
      from->add_weight(-f);
   }
   if (from) {
      from->remove_commercial_thing(this_object());
   }
   dest->add_commercial_thing(this_object());
   dest->register_use_types(_use_types);
   return i;
}
int get(mixed dest) {
   if(!move_check(dest)) {
      write("You feel it would be wrong to take " + the_short() + ".\n");
      return 2;
   }
   return ::get(dest);
}
int do_status(int hint) {
   string ret;
   ret = query_main_status(hint);
   write("$P$Status$P$" + ret);
   add_succeeded_mess("$N get$s the status of $D.\n");
   return 1;
}
int do_reset() {
   string place;
   int old_revenue;
   place = query_money_place();
   old_revenue = _revenue;
   _revenue = 0;
   add_succeeded_mess("$N clear$s the revenue of " +
                      MONEY_HAND->money_value_string(old_revenue, place) +
                      " on $D.\n");
   return 1;
}
void init() {
   ::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>", (: do_status, 0 :));
      add_command("status", "hints <direct:object>", (: do_status, 1 :));
      add_command("status", "hint <direct:object>", (: do_status, 1 :));
      add_command("reset", "revenue on <direct:object>", (: do_reset :));
   }
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   add_auto_load_value(junk, OBJECT_TAG, "revenue", query_revenue());
   add_auto_load_value(junk, OBJECT_TAG, "commercial id", query_commercial_id());
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   if (map) {
      set_bonded(map["bonded"]);
      set_revenue(query_auto_load_value(map, OBJECT_TAG, "revenue"));
      if (query_auto_load_value(map, OBJECT_TAG, "commercial id")) {
         set_commercial_id(query_auto_load_value(map, OBJECT_TAG, "commercial id"));
      }
   }
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "revenue", query_revenue() }),
             ({ "bonded", query_bonded() }),
             ({ "commercial id", query_commercial_id() }) });
}

==================================================
FILE: room/furniture/curtains.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/std/room/furniture/basic";
private nosave object _window;
private string _window_id;
private string _window_old_long;
void create() {
  do_setup++;
  ::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if ( !query_property( "shop type" ) ) {
    add_property( "shop type", "furniture" );
  }
  set_allowed_room_verbs((["hanging" : "hangs" ]));
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
}
void init() {
  if(!_window_id) {
    this_player()->add_command("hang", this_object(),
        "<direct:object> [on|at] <indirect:object:here>");
  }
  this_player()->add_command("open", this_object(), "<direct:object>");
  this_player()->add_command("close", this_object(), "<direct:object>");
}
int do_open() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already open.\n");
    return 0;
  }
  _window->set_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_close() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(!_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already closed.\n");
    return 0;
  }
  _window->reset_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_hang(mixed *in_dir, string direct, string indirect, mixed *args) {
  if(member_array("window", in_dir[0]->parse_command_id_list()) == -1) {
    this_player()->add_failed_mess(this_object(),
        "You can only $V $D at windows.\n",
        ({ }));
    return 0;
  }
  if(this_object()->move(environment(this_player())) != MOVE_OK) {
    this_player()->add_failed_mess(this_object(),
        "You seem to be unable to $V $D "
        "at $I.\n", ({ in_dir[0] }));
    return 0;
  }
  this_object()->add_property("current room hidden", 1);
  _window_id = in_dir[0]->query_my_id();
  _window_old_long = in_dir[0]->query_long();
  in_dir[0]->set_long(in_dir[0]->query_long()+"It has " +
                      this_object()->query_short() +
                      " hanging round it.\n");
  event(environment(), "save", this_object());
  this_player()->add_succeeded_mess(this_object(),
                                   "$N $V $D at $I.\n", ({ in_dir[0] }));
  return 1;
}
void removed() {
  this_object()->remove_property("current room hidden");
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  _window->set_long(_window_old_long);
  _window->set_transparent();
  _window_id = 0;
}
int query_furniture() { return 1; }
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load() +
      ([ "window" : _window_id,
       "window_old_long" : _window_old_long ]);
  return ([ "window" : _window_id,
          "window_old_long" : _window_old_long ]);
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) {
    return;
  }
  ::init_static_arg(map);
  if ( !undefinedp( map[ "window" ] ) )
    _window_id = map["window"];
  if(!undefinedp(map["window_old_long"]))
    _window_old_long = map["window_old_long"];
}

==================================================
FILE: room/furniture/dividor.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room.h>
#define SIZE_OF_FURNITURE 5
#define TAG "dividor"
#define TEMPLATE_DIVIDOR_ROOM "/mudlib/data/dividor_template.c"
private int _size;
private string _exit_direction;
private string _our_room;
int query_furniture_size() {
   return _size + SIZE_OF_FURNITURE;
}
int query_commercial_id() {
   if (!::query_commercial_id()) {
      setup_new_commercial_id();
   }
   return ::query_commercial_id();
}
string query_exit_direction() {
   return _exit_direction;
}
string query_exit_destination() {
   return _our_room;
}
int create_room() {
   string path;
   string *bits;
   string room_path;
   string stuff;
   path = environment()->query_save_dir();
   path += "/division" + query_commercial_id();
   if (file_size(path) == -2) {
      mkdir(path);
   }
   bits = explode(base_name(environment()), "/");
   room_path = implode(bits[0..<2], "/");
   room_path += "/" + bits[<1] + "_dividor";
   if (file_size(room_path) == -2) {
      mkdir(room_path);
   }
   room_path += "/" + query_commercial_id();
   if (file_size(room_path + ".c") > 0) {
      return 0;
   }
   _our_room = room_path;
   stuff = "inherit \"/std/room/furniture/dividor_room\";\n\n"
           "void setup() {\n"
           "   set_base_desc(\"" + environment()->query_base_desc() + "\");\n"
           "   set_main_room(\"" + base_name(environment()) + "\");\n"
           "   set_save_dir(\"" + path + "\");\n"
           "   set_theft_handler(\"" + environment()->query_theft_handler() + "\");\n"
           "   add_exit(\"" + ROOM_HANDLER->query_opposite_direction(query_exit_direction()) + "\", \"" + base_name(environment() + "\", \"door\");\n"
           "   set_property_size(" + _size + ");\n"
           "   add_property(\"place\", \"" + environment()->query_property("place") + "\");\n"
           "}";
   write_file(room_path + ".c", stuff, 1);
   return 1;
}
void add_exit_to_room() {
   environment()->add_exit(query_exit_direction(), query_exit_destination(), "door");
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, TAG, "exit", _exit_direction);
   add_auto_load_value(map, TAG, "room", _our_room);
   add_auto_load_value(map, TAG, "size", _size);
   return map;
}
void init_dynamic_arg(mapping map) {
   _exit_direction = query_auto_load_value(map, TAG, "exit");
   _our_room = query_auto_load_value(map, TAG, "room");
   _size = query_auto_load_value(map, TAG, "size");
   ::init_dynamic_arg(map);
}

==================================================
FILE: room/furniture/dividor_room.c
==================================================

inherit "/std/shops/commercial";
private string _main_room;
void set_main_room(string room) {
   _main_room = room;
}
string query_main_room() {
   return _main_room;
}
string query_parcel_post() {
   return _main_room->query_parcel_post();
}

==================================================
FILE: room/furniture/document_handler.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/room/furniture/inherit/document_handler";
#include <room/document_handler.h>
void create() {
   document_handler::create();
   commercial::create();
   add_help_file("document_handler");
   set_shop_use_types( ({ "document_view",
                          "document_add",
                          "document_delete" }) );
}
string query_save_dir() {
   return commercial::query_save_dir() + "/" + query_commercial_id();
}
void load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }
   if (unguarded( (: file_size(query_save_dir()) :) ) != -2) {
      unguarded( (: mkdir(query_save_dir()) :));
   }
}
void save_me() {
   environment()->event_save(this_object());
}
void init() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   document_handler::query_dynamic_auto_load(map);
   return map;
}
void init_dynamic_arg(mapping map) {
   document_handler::init_dynamic_arg(map);
   commercial::init_dynamic_arg(map);
}

==================================================
FILE: room/furniture/fireplace.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
#define WIZARD "/std/guilds/wizard"
#define CMD "/cmds/"
#define BURN_PER_TICK   1
#define BRIGHT 30
#define K      1
inherit "/std/room/furniture/surface";
private nosave int _light_produced;
private nosave int _is_lit;
private nosave int _frequency;
private nosave string _lit_mess;
private nosave string _unlit_mess;
private nosave string *_lit_chats;
private nosave string *_dying_chats;
private nosave string _turn_on_mess;
private nosave string _turn_off_mess;
private nosave string _out_of_fuel_mess;
void set_light_produced(int b);
void set_lit_mess(string str);
void set_unlit_mess(string str);
void set_frequency(int i);
void set_lit_chats(string *str);
void add_lit_chat(string str);
string request_lit_chat();
void set_dying_chats(string *str);
void add_dying_chat(string str);
string request_dying_chat();
void set_turn_on_mess(string mess);
void set_turn_off_mess(string mess);
void set_out_of_fuel_mess(string mess);
int do_light(object *obs);
int do_zap();
int turn_on();
int do_dowse(object *obs);
int turn_off();
int calc_fuel();
void create() {
  do_setup++;
  surface::create();
  do_setup--;
  set_name("fireplace");
  add_alias( ({ "fireplace", "furniture", "hearth", "fire" }) );
  add_plural( "fireplaces" );
  add_property( "shop type", "furniture" );
  add_property( "degrees", 0 );
  set_light_produced( BRIGHT );
  set_lit_mess("A fire blazes happily in the hearth, providing "
      "a soft red glow and pleasant warmth. It crackles and spits "
      "occasionally, giving the room that homely feel.\n");
  set_unlit_mess("The hearth is blackened with ashes and old embers.\n");
  set_frequency(5);
  set_lit_chats( ({
      "The fire crackles and spits cheerfully.",
      "The warm fire soothes your weariness.",
      "An enchanting orange glow radiates from the hearth.",
      "Small glowing embers dance over the fire.",
      "The fire blazes in the grate." }) );
  set_dying_chats( ({
      "The fire splutters.",
      "The warm red glow flickers.",
      "A whisp of smoke from the fire trails around the room." }) );
  set_turn_on_mess("Soon a roaring fire is blazing in the grate.\n");
  set_turn_off_mess("The embers smoke slightly and their glow dims.\n");
  set_out_of_fuel_mess("The fire flickers and dies away.\n");
  if ( !do_setup ) {
      this_object()->setup();
  }
  this_object()->add_extra_look( this_object() );
  add_help_file("fireplace");
}
void init() {
  this_player()->add_command("light", this_object(), "<direct:object> with <indirect:object>");
  this_player()->add_command("extinguish", this_object(), "<direct:object>", (: do_dowse :) );
  this_player()->add_command("dowse", this_object(), "<direct:object>");
  if( this_player()->query_guild_ob() == WIZARD ){
    this_player()->add_command("zap", this_object(), "<direct:object>");
    this_player()->add_command("point", this_object(), "[finger] at <direct:object>", (: do_zap :) );
  }
}
int query_fuel_left(){  return calc_fuel();  }
void set_light_produced(int b){  _light_produced = b;  }
int query_light_produced(){  return _light_produced;  }
void set_frequency(int i){  _frequency = i + 1;  }
int query_frequency(){  return _frequency;  }
int do_light(object *obs){
  string q_n;
  q_n = obs[0]->query_name();
  if( _is_lit ){
    this_player()->add_failed_mess( this_object(),
         "$D is already ablaze.\n", ({ }) );
    return 0;
  }
  if( q_n != "flint" && q_n != "match" && q_n != "lighter" ){
    this_player()->add_failed_mess(this_object(),
         "You can't light $D with $I.\n", ({ obs[0] }) );
    return 0;
  }
  if( this_player()->query_dex() < random(18) ){
    this_player()->add_failed_mess(this_object(),
      "You strike $I, but can't quite get the spark to catch.\n", ({ obs[0] }) );
    return 0;
  }
  if ( calc_fuel() <= 0 ) {
    this_player()->add_failed_mess( this_object(),
        "There is nothing in the fireplace to burn.\n", ({ }) );
    return 0;
  }
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D with $I.\n", ({ obs[0] }) );
  return turn_on();
}
int do_zap(){
  object tp;
  tp = this_player();
  if(tp->query_gp() < 10){
    tell_object(tp, "You don't even have the energy for such a small task!\n");
    return 1;
  }
  if(_is_lit){
    tell_object(tp, "There is already a merry fire burning in the fireplace.\n");
    return 1;
  } else {
    tp->add_succeeded_mess(this_object(),
      "$N extend$s an arm towards $D.\nA small fireball leaps from $p "
      "index finger and throws itself onto the hearth.\n", ({ }) );
    tp->adjust_gp( -10 );
    return turn_on();
  }
}
void set_turn_on_mess(string mess){  _turn_on_mess = mess;  }
string query_turn_on_mess(){  return _turn_on_mess;  }
void set_turn_off_mess(string mess){  _turn_off_mess = mess;  }
string query_turn_off_mess(){  return _turn_off_mess;  }
void msg_on(){
  if(_is_lit){
    tell_room(environment( this_object() ), query_turn_on_mess() );
  }
}
int turn_on(){
  int x;
  FUEL_HANDLER->add_burner( this_object() );
  _is_lit = 1;
  adjust_light( query_light_produced() );
    x = query_light_produced() / 4;
    add_property("degrees", query_light_produced() * 4);
    environment( this_object() )->add_property("warmth", x );
  call_out( "msg_on", 7 );
  return 1;
}
int do_dowse(object *obs){
  if( !_is_lit ){
    this_player()->add_failed_mess( this_object(),
         "There is no fire to put out.\n", ({ }) );
    return 0;
  } else {
    this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and the room loses its warm glow.\n", ({ }) );
    return turn_off();
  }
}
void msg_off() {
  if(!_is_lit){
    tell_room(environment( this_object() ), query_turn_off_mess() );
  }
}
int turn_off(){
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
  adjust_light( -query_light_produced() );
  add_property( "degrees", 0 );
  environment( this_object() )->remove_property("warmth");
  call_out( "msg_off", 10 );
  return 1;
}
void set_out_of_fuel_mess(string mess){  _out_of_fuel_mess = mess;  }
string query_out_of_fuel_mess(){  return _out_of_fuel_mess;  }
void out_of_fuel() {
  turn_off();
  tell_room(environment( this_object() ), query_out_of_fuel_mess() );
}
void set_lit_chats(string *str){  _lit_chats = str;  }
void add_lit_chat(string str){
  if( !_lit_chats ){
    _lit_chats = ({ });
  }
  _lit_chats += ({ str });
}
string request_lit_chat(){
  return _lit_chats[random( sizeof(_lit_chats) - 1 )];
}
void set_dying_chats(string *str){  _dying_chats = str;  }
void add_dying_chat(string str){
  if( !_dying_chats ){
    _dying_chats = ({ });
  }
  _dying_chats += ({ str });
}
string request_dying_chat(){
  return _dying_chats[random( sizeof(_dying_chats) - 1 )];
}
void set_lit_mess(string str){  _lit_mess = str;  }
string query_lit_mess(){  return _lit_mess;  }
void set_unlit_mess(string str){  _unlit_mess = str;  }
string query_unlit_mess(){  return _unlit_mess;  }
void consume_fuel() {
  int x;
  int q;
  int z;
  int w;
  int amount;
  string r;
  object *inv;
  object ashes;
  object thing;
  object env;
  inv = filter(all_inventory( this_object() ),
              (:$1->query_property("fuel") :));
  if( !inv || inv == ({ }) || calc_fuel() < 1){
    out_of_fuel();
    return;
  }
  x = sizeof(inv);
  foreach(thing in inv){
      q = thing->query_amount_left();
      w = thing->query_weight();
      z = q - ( ( BURN_PER_TICK * 100 / x ) / w );
      if ( z < 1 ){
          thing->move("/room/rubbish");
          amount = roll_MdN(4, 20);
          ashes = clone_object("/obj/cont_medium");
          ashes->set_name("ash");
          ashes->set_short("fine grey ash");
          ashes->add_property("determinate", "some ");
          ashes->add_adjective(({"some", "fine", "grey", "pinch", "pinches",
           "handful", "handfuls", "bucketful", "bucketfuls", "of"}));
          ashes->add_plural("ash");
          ashes->set_long("This is $pile_size$ of fine grey ash, "
            "$amount_size$. It looks like it was the leftovers "
            "from someone's camp fire.\n");
          ashes->set_weight_unit(({ 1, 50 }));
          ashes->set_medium_alias("FiNeGrEyAsH");
          ashes->set_amount_types((["pinch" : ({1, "pinches"}),
           "handful" : ({50, "handfuls"}),
           "bucketful" : ({1000, "bucketfuls"})]));
          ashes->set_pile_types(({50, "small", 100, "medium",
            200, "large", "huge"}));
          ashes->set_continuous();
          ashes->set_amount(amount);
          ashes->move(this_object());
      } else {
        thing->set_amount_left( z );
      }
  }
  calc_fuel();
  env = environment( this_object() );
  if( random( query_frequency() ) == 1 ){
    if( calc_fuel() > 10 ){
      r = request_lit_chat();
      tell_room( env, r + "\n");
    } else {
      r = request_dying_chat();
      tell_room( env, r + "\n");
    }
  }
}
int calc_fuel(){
  object *inv;
  object thing;
  int tot_fuel = 0;
  int w;
  int amt;
  inv = all_inventory( this_object() );
  if( !inv || inv == ({ }) ) { return 0; }
  foreach(thing in inv){
    if( thing->query_property("fuel") ){
      w =  thing->query_weight();
      amt = thing->query_amount_left();
      tot_fuel += w * amt * K / 100 ;
    }
  }
  return tot_fuel;
}
int test_remove( object thing, int flat, mixed dest){
  object tp;
  object *prev;
  tp = this_player();
  prev = previous_object(-1);
  if(_is_lit && tp && strsrch( file_name(prev[1]), CMD ) != -1 ){
    tell_object(tp, "You reach out towards the fire but "
       "you can't brave the flames and quickly pull away.\n");
    tell_room( environment(tp), tp->query_short() + " tries to take something "
      "from the fire but pulls back sucking " + tp->query_possessive() +
      " fingers.\n", tp);
    tp->adjust_hp( -random(120) );
    return 0;
  }
  return ::test_remove(thing, flat, dest);
}
int test_add( object thing, int flag ) {
  if( !thing->query_property("fuel") && environment(thing) ){
    tell_object(this_player(), "You don't think " + thing->the_short() +
      " would be a suitable fuel.\n");
    return 0;
  }
  if( _is_lit ){
    tell_room(environment( this_object() ),
      ({ "The fire crackles.\n",
         "A shower of glowing embers tumble around the hearth.\n" })[random(2)] );
  }
  call_out("calc_fuel",1);
  return 1;
}
string extra_look( object ob ){
  if( _is_lit ) {
      return query_lit_mess();
  }
  else {
      return query_unlit_mess();
  }
}
void pre_dest_me() {
  int tmp;
  if(_is_lit && environment()) {
    FUEL_HANDLER->remove_burner( this_object() );
    _is_lit = 0;
    adjust_light( -query_light_produced() );
    tmp = environment()->query_property("warmth");
    if(tmp > query_light_produced() / 4)
      environment()->add_property("warmth", tmp -
                            (query_light_produced() / 4));
    else
      environment()->remove_property("warmth");
  }
  return;
}
void dest_me() {
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
   ::dest_me();
}

==================================================
FILE: room/furniture/fireplace_inherit.c
==================================================

inherit "/std/room/furniture/fireplace";

==================================================
FILE: room/furniture/fuel_inherit.c
==================================================

inherit "/std/object";
private nosave int _amount;
private nosave string *_shorts;
private nosave string *_longs;
string fuel_short();
string fuel_long();
void create(){
   ::create();
   if(!_amount){
     _amount = 100;
   }
   set_short( (: fuel_short :) );
   set_long( (: fuel_long :) );
   add_property("no recycling", 1);
   add_property("fuel", 1);
}
void set_amount_left(int i){  _amount = i;  }
void adjust_amount_left(int i){  _amount += i;  }
int query_amount_left(){  return _amount;  }
void set_shorts(string *desc){  _shorts = desc;  }
void set_longs(string *desc){  _longs = desc;  }
string fuel_short(){
   int i;
   int x;
   x = sizeof(_shorts);
   for(i = 1; i <= x; i++){
      if( (_amount + 1) > 100 - ( i * 100 / x ) ){
         return _shorts[(i-1)];
      }
   }
   return "fuel";
}
string fuel_long(){
   int i;
   int x;
   x = sizeof(_longs);
   for(i = 1; i <= x; i++){
      if( ( _amount + 1 ) > ( 100 - ( i * 100 / x )) ){
         return _longs[(i-1)];
      }
   }
   return "fuel";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "amount" : _amount
          ]);
}
void init_dynamic_arg(mapping arg) {
   _amount = arg[ "amount" ];
   ::init_dynamic_arg(arg["::"]);
}

==================================================
FILE: room/furniture/furniture.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
private nosave object *_on_top;
private nosave int _has_surface;
#define DEBUG
void create() {
  do_setup++;
  ::create();
  _drawer_mess = "a drawer in $ob_short$";
  _drawers = ({ });
  _on_top = ({ });
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if (!query_property("shop type"))
    add_property( "shop type", "furniture" );
   do_setup--;
   if(!do_setup)
     this_object()->setup();
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
int query_has_surface() { return _has_surface; }
void set_has_surface(int i) { _has_surface = i; }
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   if(sizeof(_on_top))
     ret += query_contents( "On " + the_short() + " " +
                            (sizeof(_on_top) == 1 ? "is " : "are " ), _on_top);
   return ret;
}
varargs string query_contents( string start, object *things,
  int ignore_living) {
  if(!arrayp(things)) {
    things = this_object()->find_inv_match( "", this_player() );
    things -= ({ this_player() });
    things = filter_array( things, (: environment( $1 ) == this_object() :) );
    things -= _on_top;
  }
  return ::query_contents(start, things, ignore_living);
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  result = ::test_remove(thing, flag, dest);
  if(result) {
    stuff = thing->query_property("dropped");
    if(environment() &&
       dest == this_player() &&
       function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(this_player()->query_name()) &&
       (!sizeof(stuff) || stuff[0] != this_player()->query_name())) {
      event(environment(this_player()), "theft", this_player(), this_object(),
            ({ thing }));
    }
    if(dest) {
      _on_top -= ({ thing });
      thing->remove_property("_on_top");
    }
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  int result;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  result = ::test_add(thing, flag);
  if(!result)
    return 0;
  if("/cmds/living/put"->query_con() == "on" && _has_surface) {
    _on_top += ({ thing });
    thing->add_property("_on_top", 1);
  } else if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  return result;
}
int pick_unlock(object player) {
  mixed owner;
  if(!environment())
    return ::pick_unlock(player);
  if(!environment() || !function_exists("query_owner", environment()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions( map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
void init_dynamic_arg(mapping bing) {
  object item;
  ::init_dynamic_arg(bing);
  foreach(item in all_inventory(this_object())) {
    if(item->query_property("_on_top"))
      _on_top += ({ item });
  }
}
string query_help_file_directory() {
  return "/doc/furniture/";
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  ret += ({ ({ "surface", _has_surface }) });
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}

==================================================
FILE: room/furniture/mirror.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/basic";
int _in_extra;
void create(){
	::create();
	add_extra_look(this_object());
}
string extra_look(object ob) {
	int dark;
	object env;
	env = environment(ob);
	if(living(env))
		return "You can see yourself in the mirror.";
	dark = (int) this_player()->check_dark((int)env->query_light());
	if(dark)
		return "It is too dark to see much in the room.";
	return "Reflected in the mirror is " +
		query_multiple_short(all_inventory(env) - ({ ob }), "a", 0, 1, dark) +
		".";
}

==================================================
FILE: room/furniture/poker.c
==================================================

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";
#include <money.h>
#include <room/card_base.h>
#define HAND_TYPE_HIGH_CARD  1
#define HAND_TYPE_PAIR       2
#define HAND_TYPE_TWO_PAIR   3
#define HAND_TYPE_THREE      4
#define HAND_TYPE_STRAIGHT   5
#define HAND_TYPE_FLUSH      6
#define HAND_TYPE_FULL_HOUSE 7
#define HAND_TYPE_FOUR       8
#define HAND_TYPE_STRAIGHT_FLUSH 9
#define POKER_STATE_ANTE      0
#define POKER_STATE_PAID_ANTE 1
#define POKER_STATE_DEALT     2
#define POKER_STATE_BET       3
#define POKER_STATE_DISCARD   4
#define POKER_STATE_AFTER_DISCARD   5
#define POKER_STATE_FINAL_BET 6
#define POKER_STATE_FOLDED    7
#define POKER_STATE_END       8
#define TIE -1
class hand_type {
   int hand_type;
   class playing_card* kickers;
   class playing_card duplicate_1;
   class playing_card duplicate_2;
   class playing_card high_card;
}
class player_data {
   class playing_card* hand;
   class hand_type hand_type;
   int bet;
   int state;
}
#define BOARD_TAG "poker"
private int _return;
private int _ante_amount;
private int _ante_house;
private int _house_cut;
private int _min_bet;
private int _max_bet;
private int _current_bet;
private int _pot;
private int _finished;
private int _poker_phase;
private int _turn_timeout;
private int _draw_round;
private int _max_draw_rounds;
private class playing_card* _deck;
private class playing_card* _discard;
private mapping _player_stats;
int query_hand_value(class playing_card* cards);
class hand_type query_hand_type(class playing_card* hand);
void create() {
   multiplayer_base::create();
   set_minimum_needed(2);
   add_help_file("poker");
   _ante_house = 400;
   _ante_amount = 400;
   _min_bet = 400;
   _max_bet = 1200;
   _max_draw_rounds = 1;
   _player_stats = ([ ]);
   set_shop_use_types(({ "poker" }));
   commercial::create();
   set_commercial_type("gambling");
   set_commercial_name("poker");
}
string query_hand_type_string(class hand_type bing) {
   string ret;
   switch (bing->hand_type) {
   case HAND_TYPE_FULL_HOUSE :
      ret = "Full house";
      break;
   case HAND_TYPE_THREE :
      ret = "Three of a kind";
      break;
   case HAND_TYPE_FLUSH :
      ret = "Flush";
      break;
   case HAND_TYPE_STRAIGHT :
      ret = "Straight";
      break;
   case HAND_TYPE_STRAIGHT_FLUSH :
      ret = "Straight flush";
      break;
   case HAND_TYPE_PAIR :
      ret = "Pair";
      break;
   case HAND_TYPE_FOUR :
      ret = "Four of a kind";
      break;
   case HAND_TYPE_TWO_PAIR :
      ret = "Two pairs";
      break;
   case HAND_TYPE_HIGH_CARD :
      ret = "High card " + query_card_string(bing->high_card);
      break;
   default :
      ret = "Nothing";
      break;
   }
   return ret;
}
string query_card_status(string id) {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   string* womble;
   string place;
   int left;
   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = query_money_place();
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing)) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->state == POKER_STATE_FOLDED) {
               ret += " Folded!\n";
            } else {
               if (data->state == POKER_STATE_PAID_ANTE) {
                  ret += " (paid ante) ";
               }
               if (data->state == POKER_STATE_AFTER_DISCARD) {
                  ret += " (discarded) ";
               }
               if (data->state == POKER_STATE_BET ||
                   data->state == POKER_STATE_FINAL_BET) {
                  if (id_bing == query_current_player()) {
                     ret += " <-- Their bet ";
                  }
               }
               if (data->bet) {
                  ret += "  Current bet " +
                         MONEY_HAND->money_value_string(data->bet, place);
                  ret += "\n";
               } else {
                  ret += "  No bet yet.\n";
               }
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }
   if (sizeof(not_playing) > 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " are not playing.\n";
   } else if (sizeof(not_playing) == 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " is not playing.\n";
   }
   ret += "The pot is " +
          MONEY_HAND->money_value_string(_pot, place) + ".\n";
   if (is_game_started()) {
      if (_draw_round < _max_draw_rounds) {
         left = _max_draw_rounds - _draw_round;
         ret += left + " draw round" + (left>1?"s":"") + " left.\n";
      }
   }
   ret += "\n";
   if (id) {
      if (!_finished) {
         data = query_player_data(id);
         if (data && sizeof(data->hand)) {
            ret += "Your hand (" +
                   query_hand_type_string(data->hand_type) +
                   (data->state == POKER_STATE_FOLDED?" -- Folded":"") +
                   "):\n";
            if (data->state != POKER_STATE_FOLDED) {
               ret += query_hand_string(data->hand,
                                     CARD_HAND_THREE|CARD_HAND_LETTERS,
                                     this_player()->query_cols());
            }
         }
         if (_finished) {
            tell_all_players(query_player_cap_name(id) + " peeks at their hand on " +
                         the_short() + ".\n", ({ id }));
         }
      } else {
         foreach (id in query_started_player_ids()) {
            data = query_player_data(id);
            if (data && sizeof(data->hand)) {
               ret += query_player_cap_name(id);
               if (data->state == POKER_STATE_FOLDED) {
                  ret += " folded, so the cards are hidden.\n";
               } else {
                  ret += " hand (" +
                         query_hand_type_string(data->hand_type) + ":\n";
                  ret += query_hand_string(data->hand, CARD_HAND_SINGLE,
                                        this_player()->query_cols());
               }
            }
         }
      }
   }
   return ret;
}
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status(find_player_id_of_person(this_player()));
}
int check_end_round() {
   int bet;
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         if (!data->bet) {
            return 0;
         } else if (!bet && data->bet) {
            bet = data->bet;
         } else if (bet != data->bet) {
            return 0;
         }
      }
   }
   if (bet) {
      call_out("complete_round", 2);
      _poker_phase = POKER_STATE_END;
      return 1;
   }
}
void next_person_turn() {
   class player_data data;
   string start_id;
   start_id = query_current_player();
   do {
      increment_current_player();
      data = query_player_data(query_current_player());
   } while (data->state == POKER_STATE_FOLDED &&
            query_current_player() != start_id);
   if (query_current_player() == start_id) {
      printf("Force end of game.\n");
      call_out("complete_round", 2, 1);
      _poker_phase = POKER_STATE_END;
   } else {
      call_out("tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n");
   }
}
void deal_cards() {
   string id;
   class player_data data;
   _deck = make_deck(1, 0);
   _deck = shuffle_deck(_deck);
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      data->hand = sort_cards(_deck[0..4], 3);
      data->bet = 0;
      if (data->state != POKER_STATE_FOLDED) {
         if (!_max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
      data->hand_type = query_hand_type(data->hand);
      _deck = _deck[5..];
      if (query_player_object(id)) {
         tell_player(id, "Your hand:\n" +
                query_hand_string(data->hand, CARD_HAND_THREE|CARD_HAND_LETTERS,
                                  query_player_object(id)->query_cols()) +
            query_hand_type_string(data->hand_type) + ".\n");
      }
   }
   if (!_max_draw_rounds) {
      _poker_phase = POKER_STATE_FINAL_BET;
   } else {
      _poker_phase = POKER_STATE_BET;
   }
   next_person_turn();
   tell_all_players(query_player_cap_name(query_current_player()) +
                    " goes first.\n");
   _current_bet = 0;
}
int start_game() {
   class player_data data;
   string id;
   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->bet = 0;
      data->hand = ({ });
      data->state = POKER_STATE_ANTE;
      set_player_data(id, data);
   }
   _poker_phase = POKER_STATE_ANTE;
   _pot = 0;
   _finished = 0;
   _draw_round = 0;
   _discard = ({ });
   tell_all_players("%^BOLD%^Place your ante to start playing.%^RESET%^\n");
   return 1;
}
void check_for_finish_ante() {
   string id;
   class player_data data;
   object ob;
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      ob = query_player_object(id);
      if (ob && !interactive(ob)) {
         data->state = POKER_STATE_FOLDED;
      }
      if (ob && interactive(ob) && data->state == POKER_STATE_ANTE) {
         return ;
      }
   }
   _poker_phase = POKER_STATE_BET;
   call_out("deal_cards", 2);
}
int is_card_higher(class playing_card card_new, class playing_card card_old) {
   if (card_new->number == card_old->number) {
      return 0;
   }
   if (card_new->number == CARD_NUMBER_ACE) {
      return 1;
   }
   if (card_old->number == CARD_NUMBER_ACE) {
      return 0;
   }
   if (card_new->number > card_old->number) {
      return 1;
   }
   return 0;
}
class hand_type query_hand_type(class playing_card* hand) {
   int high_num;
   int num;
   int id;
   int i;
   int j;
   class playing_card* tmp_hand;
   class hand_type ret_type;
   class playing_card tmp_card;
   ret_type = new(class hand_type);
   high_num = 0;
   for (i = 1; i < sizeof(hand); i++) {
      if (is_card_higher(hand[i], hand[high_num])) {
         high_num = i;
      }
   }
   ret_type->hand_type = HAND_TYPE_HIGH_CARD;
   ret_type->high_card = hand[high_num];
   high_num = 1;
   for (i = 0; i < sizeof(hand) - 1; i++) {
      num = 1;
      for (j = 0; j < sizeof(hand) - i - 1; j++) {
         if (hand[i]->number == hand[i + j + 1]->number) {
            num++;
         }
      }
      if (num > high_num) {
         high_num = num;
         id = hand[i]->number;
      }
   }
   tmp_hand = hand;
   if (high_num > 1) {
      for (i = 0; i < sizeof(tmp_hand); i++) {
         if (tmp_hand[i]->number == id) {
            ret_type->duplicate_1 = tmp_hand[i];
            tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            i--;
         }
      }
   }
   if (high_num == 2) {
      high_num = 1;
      for (i = 0; i < sizeof(tmp_hand) - 1; i++) {
         num = 1;
         for (j = 0; j < sizeof(tmp_hand) - i - 1; j++) {
            if (tmp_hand[i]->number == tmp_hand[i + j + 1]->number) {
               num++;
            }
         }
         if (num > high_num) {
            high_num = num;
            id = tmp_hand[i]->number;
         }
      }
      if (high_num == 2) {
         ret_type->hand_type = HAND_TYPE_TWO_PAIR;
         for (i = 0; i < sizeof(tmp_hand); i++) {
            if (tmp_hand[i]->number == id) {
               ret_type->duplicate_2 = tmp_hand[i];
               tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            }
         }
         if (is_card_higher(ret_type->duplicate_2, ret_type->duplicate_1)) {
            tmp_card = ret_type->duplicate_1;
            ret_type->duplicate_1 = ret_type->duplicate_2;
            ret_type->duplicate_2 = tmp_card;
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      } else {
         ret_type->hand_type = HAND_TYPE_PAIR;
         high_num = 0;
         for (i = 1; i < sizeof(tmp_hand); i++) {
            if (is_card_higher(tmp_hand[i], tmp_hand[high_num])) {
               high_num = i;
            }
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 3) {
      if (tmp_hand[0]->number == tmp_hand[1]->number) {
         ret_type->hand_type = HAND_TYPE_FULL_HOUSE;
         ret_type->duplicate_2 = tmp_hand[0];
         ret_type->kickers = ({ });
      } else {
         ret_type->hand_type = HAND_TYPE_THREE;
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 4) {
      ret_type->hand_type = HAND_TYPE_FOUR;
      ret_type->high_card = tmp_hand[0];
      return ret_type;
   }
   for (i = 0; i < sizeof(hand) - 1; i++) {
      if (hand[i + 1]->suit != hand[0]->suit) {
         break;
      }
   }
   if (i == sizeof(hand) - 1) {
      ret_type->hand_type = HAND_TYPE_FLUSH;
      ret_type->kickers = sort_cards(hand, 3);
      high_num = 0;
      for (i = 1; i < sizeof(hand); i++) {
         if (is_card_higher(hand[i], hand[high_num])) {
            high_num = i;
         }
      }
      ret_type->high_card = hand[high_num];
   }
   tmp_hand = sort_array(hand, (: ((class playing_card)$1)->number -
                                  ((class playing_card)$2)->number :));
   if (tmp_hand[0]->number == CARD_NUMBER_ACE) {
      if (tmp_hand[1]->number == 2) {
         j = 1;
      } else {
         j = 0;
         tmp_hand = tmp_hand[1..] + ({ tmp_hand[0] });
      }
   } else {
      j = 0;
   }
   for (i = j; i < sizeof(tmp_hand) - 1; i++) {
      if (tmp_hand[i]->number + 1 != tmp_hand[i + 1]->number) {
         if (tmp_hand[i + 1]->number != CARD_NUMBER_ACE ||
             tmp_hand[i]->number != CARD_NUMBER_KING) {
            break;
         }
      }
   }
   if (i == sizeof(tmp_hand) - 1) {
      if (ret_type->hand_type == HAND_TYPE_FLUSH) {
         ret_type->hand_type = HAND_TYPE_STRAIGHT_FLUSH;
         ret_type->high_card = tmp_hand[<1];
      } else {
         ret_type->hand_type = HAND_TYPE_STRAIGHT;
         ret_type->high_card = tmp_hand[<1];
      }
   }
   if (ret_type->hand_type == HAND_TYPE_HIGH_CARD) {
      ret_type->kickers = sort_cards(hand, 3);
   }
   return ret_type;
}
int is_greator_hand(class hand_type new_hand,
                    class hand_type old_hand) {
   int i;
   if (new_hand->hand_type > old_hand->hand_type) {
      return 1;
   }
   if (new_hand->hand_type < old_hand->hand_type) {
      return 0;
   }
   if (new_hand->hand_type == old_hand->hand_type) {
      switch (new_hand->hand_type) {
      case HAND_TYPE_HIGH_CARD :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(old_hand->high_card,
                            new_hand->high_card)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FLUSH :
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_TWO_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_THREE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FOUR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_FULL_HOUSE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         break;
      case HAND_TYPE_STRAIGHT :
      case HAND_TYPE_STRAIGHT_FLUSH :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 0;
         }
         break;
      }
   }
   return TIE;
}
void test_hand_type() {
   class playing_card* other_tmp_hand;
   class playing_card* tmp_hand;
   other_tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 12),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13) });
   tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 2),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 3),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 4),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 1),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 5) });
write(query_hand_type_string(query_hand_type(tmp_hand)) + " --\n" +
      query_hand_type_string(query_hand_type(other_tmp_hand)));
printf("%O\n", sizeof(query_hand_type(tmp_hand)->kickers));
printf("%O\n", sizeof(query_hand_type(other_tmp_hand)->kickers));
write("Result: " + is_greator_hand(query_hand_type(tmp_hand),
      query_hand_type(other_tmp_hand)) + "\n");
}
void complete_round(int force_end) {
   string stuff;
   object ob;
   class player_data data;
   string id;
   string place;
   string* winner;
   class hand_type winning_hand_type;
   class playing_card* winning_hand;
   int paid;
   int discard;
   int result;
   int num;
   if (_finished) {
      return 0;
   }
   place = query_money_place();
   stuff = "";
   winner = ({ });
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if ((data->state == POKER_STATE_BET || discard) && !force_end) {
         if (data->state != POKER_STATE_FOLDED) {
            data->state = POKER_STATE_DISCARD;
            data->bet = 0;
         }
         discard = 1;
      } else if (data->state != POKER_STATE_FOLDED) {
         num++;
         if (!winning_hand) {
            winning_hand = data->hand;
            winning_hand_type = data->hand_type;
            winner = ({ id });
         } else {
            data->hand_type = query_hand_type(data->hand);
            result = is_greator_hand(data->hand_type, winning_hand_type);
            if (result == TIE) {
               winner += ({ id });
            } else if (result) {
               winning_hand = data->hand;
               winning_hand_type = data->hand_type;
               winner = ({ id });
            }
         }
         stuff += query_player_cap_name(id) + "'s hand (" +
                  query_hand_type_string(data->hand_type) + "):\n" +
                  query_hand_string(data->hand, CARD_HAND_SINGLE,
                                     this_player()->query_cols()) + "\n";
      }
   }
   if (num == 1) {
      stuff = "All but one person folded so the cards are not revealed.\n";
   }
   if (discard) {
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state == POKER_STATE_FOLDED) {
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "You have folded.\n");
         } else {
            data->bet = 0;
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "Your hand:\n" +
               query_hand_string(data->hand, CARD_HAND_THREE | CARD_HAND_LETTERS,
                                    80));
         }
      }
   } else {
      if (_house_cut) {
         stuff += "House takes " +
            MONEY_HAND->money_value_string((_pot * _house_cut) / 100, place) +
                  ".\n";
        adjust_float((_pot * _house_cut) / 100);
        _pot -= (_pot * _house_cut) / 100;
      }
      if (sizeof(winner) > 1) {
         stuff += "Tie for winning between " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", they each win " +
                  MONEY_HAND->money_value_string(_pot / sizeof(winner), place) +
                  ".\n";
         paid = _pot / sizeof(winner);
         foreach (id in winner) {
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(paid, place), place);
               _player_stats[ob->query_name()] += paid;
            } else {
               stuff += "Unable to find " + id + " to pay them, money "
                               "going to the house.\n";
               adjust_float(paid);
            }
         }
      } else {
         stuff += "Winner is " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", and they win " +
                  MONEY_HAND->money_value_string(_pot, place) +
                  ".\n";
         ob = query_player_object(winner[0]);
         ob->adjust_money(MONEY_HAND->create_money_array(_pot, place), place);
         _player_stats[ob->query_name()] += _pot;
      }
      tell_all_players("The players reveal their cards as:\n" +
                       stuff);
      tell_room(environment(), "The game ends with " + query_multiple_short(winner) +
                               " as the winner.\n");
      finish_game(query_multiple_short(winner));
      _finished = 1;
   }
}
void finish_discard() {
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_AFTER_DISCARD &&
          data->state != POKER_STATE_FOLDED) {
         return 0;
      }
   }
   _draw_round++;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state == POKER_STATE_AFTER_DISCARD) {
         if (_draw_round >= _max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
   }
   _current_bet = 0;
   _poker_phase = POKER_STATE_FINAL_BET;
   call_out("tell_all_players", 0,
            "Discard round completed.  Now onto the " +
            (_draw_round >= _max_draw_rounds?"final ":"") + "betting round.\n");
   next_person_turn();
}
int do_ante() {
   string place;
   string id;
   int amount;
   class player_data data;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != POKER_STATE_ANTE) {
      add_failed_mess("You have already put in your ante.\n");
      return 0;
   }
   place = query_money_place();
   amount = _ante_house + _ante_amount;
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " to meet the ante.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amount;
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);
   adjust_float(_ante_house);
   _pot += _ante_amount;
   data->state = POKER_STATE_PAID_ANTE;
   environment()->event_save(this_object());
   check_for_finish_ante();
   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
}
int do_discard(string throw_away) {
   int i;
   string id;
   class player_data data;
   string* bits;
   int* new_bits;
   throw_away = lower_case(throw_away);
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot discard before you have been dealt "
                      "cards.\n");
      return 0;
   }
   if (data->state != POKER_STATE_DISCARD) {
      add_failed_mess("You are not in the discard phase.\n");
      return 0;
   }
   if (throw_away && throw_away != "none") {
      throw_away = lower_case(replace_string(throw_away, " ", ""));
      bits = explode(throw_away, ",");
      if (sizeof(filter(bits, (: strlen($1) > 1 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      new_bits = map(bits, (: $1[0] - 'a' :));
      if (sizeof(filter(new_bits, (: $1 < 0 || $1 >= 5 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      for (i = 0; i < sizeof(new_bits); i++) {
         if (member_array(new_bits[i],
                          new_bits[0..i-1] + new_bits[i+1..]) != -1) {
            add_failed_mess("You have referenced the card " +
                            sprintf("%c", 'A' + new_bits[i]) + " twice.\n");
            return 0;
         }
      }
      new_bits = sort_array(new_bits, (: $2 - $1 :));
      for (i = 0; i < sizeof(new_bits); i++) {
         _discard += ({ data->hand[new_bits[i]] });
         data->hand = data->hand[0..new_bits[i]-1] +
                      data->hand[new_bits[i]+1..];
      }
      i = 5 - sizeof(data->hand) - 1;
      if (sizeof(_deck) < i) {
         _deck += _discard;
         _deck = shuffle_array(_deck);
         _discard = ({ });
      }
      data->hand += _deck[0..i];
      _deck = _deck[i + 1..];
      data->hand = sort_cards(data->hand, 3);
      data->hand_type = query_hand_type(data->hand);
      add_succeeded_mess(({ "", "$N draw$s " + query_num(sizeof(new_bits)) +
                                " new card" +
                               (sizeof(new_bits) > 1?"s":"") + " on $D.\n" }));
      write("Your new hand (" +
            query_hand_type_string(data->hand_type) +
            "):\n" +
            query_hand_string(data->hand, CARD_HAND_THREE,
                                  this_player()->query_cols()));
      data->state = POKER_STATE_AFTER_DISCARD;
   } else {
      new_bits = ({ });
      data->state = POKER_STATE_AFTER_DISCARD;
      add_succeeded_mess("$N do$es not discard any cards on $D.\n");
   }
   finish_discard();
   return 1;
}
int do_check() {
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (_current_bet) {
      add_failed_mess("You cannot check since betting has started.\n");
      return 0;
   }
   add_succeeded_mess("$N check$s on $D.\n");
   next_person_turn();
   return 1;
}
int do_call() {
   class player_data data;
   int amt;
   string place;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (!_current_bet) {
      add_failed_mess("No one has bet anything for you to call.\n");
      return 0;
   }
   place = query_money_place();
   data = query_player_data(query_current_player());
   if (_current_bet && data->bet == _current_bet) {
      call_out("complete_round", 2);
      if (_poker_phase == POKER_STATE_ANTE) {
         _poker_phase = POKER_STATE_DISCARD;
      } else {
         _poker_phase = POKER_STATE_ANTE;
      }
   } else {
      amt = _current_bet - data->bet;
      if (this_player()->query_value_in(place) < amt) {
         add_failed_mess("You do not have the necessary " +
                         MONEY_HAND->money_value_string(amt, place) +
                         " to call the bet.\n");
         return 0;
      }
      _player_stats[this_player()->query_name()] -= amt;
      this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
      _pot += amt;
      data->bet = _current_bet;
      if (!check_end_round()) {
         next_person_turn();
      }
   }
   add_succeeded_mess("$N call$s the bet by adding " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to the pot for a total bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   return 1;
}
int do_raise(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   raise_amt = amt;
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_bet(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt == _current_bet) {
      return do_call();
   }
   if (amt < _current_bet) {
      add_failed_mess("You have to bet higher than the current bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " money amount.\n");
      return 0;
   }
   amt = amt - _current_bet;
   raise_amt = amt;
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_fold() {
   class player_data data;
   string id;
   int not_folded;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   data->state = POKER_STATE_FOLDED;
   add_succeeded_mess("$N fold$s on $D.\n");
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         not_folded++;
      }
   }
   if (not_folded == 1) {
      call_out("complete_round", 0, 1);
      _poker_phase = POKER_STATE_END;
   } else if (!check_end_round()) {
      next_person_turn();
   }
   return 1;
}
int do_start() {
   int old_pot;
   if (!is_open_for("poker", this_player()->query_name())) {
      add_failed_mess("The poker table is not open.\n");
      return 0;
   }
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }
   old_pot = _pot;
   if (!start_game()) {
      add_failed_mess("You need at least two people to play poker.\n");
      return 0;
   }
   adjust_float(old_pot);
   add_succeeded_mess("$N $V a game on $D.\n");
   return 1;
}
int do_finish() {
   string person;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }
   finish_game(0);
   reset_game();
   return 1;
}
string query_main_status(int hint) {
   string place;
   string ret;
   string name;
   int amt;
   place = query_money_place();
   ret = "$I$0=Poker table:\n"
          "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Ante       : " +
              MONEY_HAND->money_value_string(_ante_amount, place) +
          "\n$I$6=   House Ante : " +
              MONEY_HAND->money_value_string(_ante_house, place) +
          "\n$I$6=   Draw Rounds: " + _max_draw_rounds +
          "\n$I$6=   Cut        : " + _house_cut + "%"
          "\n$I$6=   Revenue    : " +
              MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$0=";
   foreach (name, amt in _player_stats) {
      ret += sprintf(" %-13s: %s\n" , name,
                     MONEY_HAND->money_value_string(amt, place));
   }
   return ret + "\n";
}
int do_set_ante(string str, int ante_game) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (lower_case(str) == "none" && !ante_game) {
      value = 0;
   } else {
      place = query_money_place();
      value = MONEY_HAND->value_from_string(str, place);
      if (!value) {
         add_failed_mess("Unable to parse the string " + str + ".\n");
         return 0;
      }
   }
   if (ante_game) {
      _ante_amount = value;
      add_succeeded_mess("$N set$s the ante amount to play to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _ante_house = value;
      add_succeeded_mess("$N set$s the ante amount for the house to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_bet(string str, int max_bet) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   _house_cut = percent;
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_draw(int draw) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (draw < 0) {
      add_failed_mess("You cannot set the number of draws less than 0.\n");
      return 0;
   }
   if (draw > 5) {
      add_failed_mess("You cannot set the draw to greator than 5.\n");
      return 0;
   }
   _max_draw_rounds = draw;
   add_succeeded_mess("$N set$s the number of draw rounds to " + draw + " on $D.\n");
   return 1;
}
int do_rules() {
   string ret;
   string place;
   place = query_money_place();
   ret = "The rules for this table are:\n";
   ret += "$I$6=   Maximum amount that can be raised " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum amount that can be raised " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Total ante " +
              MONEY_HAND->money_value_string(_ante_amount + _ante_house, place) +
          "\n$I$6=   Cut of the pool : " + _house_cut +
          "\n$I$6=   Draw Rounds     : " + _max_draw_rounds +
          "\n$I$6=   House Ante      : " +
              MONEY_HAND->money_value_string(_ante_house, place);
   write("$P$Rules$P$" + ret);
}
int do_reset() {
   if (::do_reset()) {
      _player_stats = ([ ]);
      add_succeeded_mess("$N clear$s the player stats.\n");
      return 1;
   }
}
void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("discard", "<string'card'> on <direct:object>",
               (: do_discard($4[0]) :));
   add_command("ante", "on <direct:object>",
               (: do_ante() :));
   add_command("check", "on <direct:object>",
               (: do_check() :));
   add_command("call", "on <direct:object>",
               (: do_call() :));
   add_command("bet", "<string'total bet'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("raise", "<string'raise'> on <direct:object>",
               (: do_raise($4[0]) :));
   add_command("fold", "on <direct:object>",
               (: do_fold() :));
   add_command("finish", "game on <direct:object>",
               (: do_finish() :));
   add_command("start", "game on <direct:object>",
               (: do_start() :));
   add_command("rules", "<direct:object>",
               (: do_rules() :));
   add_command("rules", "{for|on|of} <direct:object>",
               (: do_rules() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "draw <number'rounds'> on <direct:object>",
                  (: do_set_draw($4[0]) :));
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "ante house <string'amount|none'> on <direct:object>",
                  (: do_set_ante($4[0], 0) :));
      add_command("set", "ante game <string'amount'> on <direct:object>",
                  (: do_set_ante($4[0], 1) :));
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
   }
}
void resign_person(string id) {
   class player_data data;
   int not_folded;
   data = query_player_data(id);
   if (data && data->state != POKER_STATE_FOLDED) {
      tell_all_players(query_player_cap_name(id) +
                       " resigns and folds.\n");
      data->state = POKER_STATE_FOLDED;
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state != POKER_STATE_FOLDED) {
            not_folded++;
         }
      }
      if (not_folded == 1) {
         call_out("complete_round", 0, 1);
         _poker_phase = POKER_STATE_END;
      }
   } else {
      switch (_poker_phase) {
      case POKER_STATE_ANTE :
         check_for_finish_ante();
         break;
      case POKER_STATE_BET :
         check_end_round();
         break;
      case POKER_STATE_DISCARD :
         finish_discard();
         break;
      }
   }
}
void event_exit(object ob, string mess, object to) {
   string id;
   if (userp(ob) && to != environment()) {
      id = find_player_id_of_person(ob);
      if (id) {
         resign_person(id);
      }
   }
}
void multiplayer_someone_resigns(string id, string name) {
   resign_person(id);
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, BOARD_TAG, "return", _return);
   add_auto_load_value(map, BOARD_TAG, "ante amount", _ante_amount);
   add_auto_load_value(map, BOARD_TAG, "house cut", _house_cut);
   add_auto_load_value(map, BOARD_TAG, "ante house", _ante_house);
   add_auto_load_value(map, BOARD_TAG, "min bet", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "current bet", _current_bet);
   add_auto_load_value(map, BOARD_TAG, "pot", _pot);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "poker phase", _poker_phase);
   add_auto_load_value(map, BOARD_TAG, "draw round", _draw_round);
   add_auto_load_value(map, BOARD_TAG, "max draw rounds", _max_draw_rounds);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "player stats", _player_stats);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);
   _return = query_auto_load_value(map, BOARD_TAG, "return");
   _ante_amount = query_auto_load_value(map, BOARD_TAG, "ante amount");
   _ante_house = query_auto_load_value(map, BOARD_TAG, "ante house");
   _house_cut = query_auto_load_value(map, BOARD_TAG, "house cut");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _current_bet = query_auto_load_value(map, BOARD_TAG, "current bet");
   _pot = query_auto_load_value(map, BOARD_TAG, "pot");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _poker_phase = query_auto_load_value(map, BOARD_TAG, "poker phase");
   _draw_round = query_auto_load_value(map, BOARD_TAG, "draw round");
   _max_draw_rounds = query_auto_load_value(map, BOARD_TAG, "max draw rounds");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _player_stats = query_auto_load_value(map, BOARD_TAG, "player stats");
   if (!_player_stats) {
      _player_stats = ([ ]);
   }
}

==================================================
FILE: room/furniture/shop_base.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/player_craft_shop_base";
#define SAVE_TIME 1
private int _save_call;
private int _last_saved;
private string _counter_short;
#define OBJECT_TAG "shop base"
void create() {
   player_craft_shop_base::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("craft shop");
}
int query_player_craft_shop() {
   return 1;
}
int disallow_sale_here(object room) {
   object* obs;
   obs = room->find_commercial_items(query_commercial_name());
   return sizeof(obs);
}
int query_royalty(string person) {
   return commercial::query_royalty(person);
}
string query_craft_shop_save_dir() {
   return environment()->query_save_dir() + "craft_shop";
}
void adjust_royalty(string person, int amount) {
   commercial::adjust_royalty(person, amount);
}
string query_parcel_post() {
   return commercial::query_parcel_post();
}
void reset_weekly_status() {
   player_craft_shop_base::reset_weekly_status();
}
string query_weekly_status_string() {
   return player_craft_shop_base::query_weekly_status_string();
}
void load_me() {
  string fname, tmp;
#ifdef USE_RAMDISK
  tmp = replace_string(query_save_dir() + "craft_shop_file", "/save/",
                       "/save/ramdisk/");
  if(unguarded((: file_size($(tmp) = ".o.gz") :)) > 0 ||
     unguarded((: file_size($(tmp) = ".o") :)) > 0) {
    fname = tmp;
  }
#endif
  if(!fname) {
    fname = query_save_dir() + "craft_shop_file";
  }
   unguarded( (: restore_object($(fname)) :));
#ifdef USE_RAMDISK
   tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                        "/save/ramdisk/");
   unguarded( (: mkdir($(tmp)) :));
#endif
   unguarded( (: mkdir(query_craft_shop_save_dir()) :));
   reload_shop();
   add_property("place", environment()->query_property("place"));
}
void init() {
   player_craft_shop_base::init();
   commercial::init();
}
void do_save() {
  string fname;
  string dir;
   _save_call = 0;
   if (environment() && query_save_dir()) {
#ifdef USE_RAMDISK
     dir = replace_string(query_save_dir(), "/save/",
                            "/save/ramdisk/");
     if (file_size(dir) == -2) {
        fname = dir + "craft_shop_file";
     }
#endif
     if(!fname) {
       fname = query_save_dir() + "craft_shop_file";
     }
     debug_printf("Saving to %O\n", fname);
     unguarded( (: save_object($(fname), 2) :));
   }
}
void dest_me() {
   do_save();
   player_craft_shop_base::dest_me();
   commercial::dest_me();
}
string query_commercial_information() {
   return "This shop can have a maximum of " + query_maximum_inventory_size() +
          " items for sale.  "
          "You can only have "
          "one shop counter in any room, more than one will not be "
          "able to be bought.";
}
void event_save(object ob) {
   if (!_save_call) {
      if(_last_saved > time() - SAVE_TIME) {
         _save_call = call_out("do_save", SAVE_TIME - (time() - _last_saved));
      } else {
         _save_call = call_out("do_save", SAVE_TIME);
      }
#ifdef DEBUG
      debug_printf("Adding call_out");
#endif
   }
}
mapping query_commercial_options() {
   return ([
    "counter type" : ([
       "polished hardwood counter" : 500000,
       "shiny polished counter" : 150000,
       "unfinished pine counter" : 0,
      ]),
   "stockroom size" : ([
       "50" : 0,
       "100" : 1000000,
       "150" : 2500000,
      ]),
   ]);
}
void set_commercial_option(string type, string name) {
   string* bits;
   int size;
   switch (type) {
   case "counter type" :
      _counter_short = name;
      set_short(_counter_short);
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
      break;
   case "stockroom size" :
      sscanf(name, "%d", size);
      set_maximum_waiting_queue_size(size);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "stocksize", query_maximum_waiting_queue_size());
   add_auto_load_value(map, OBJECT_TAG, "counter short", _counter_short);
}
void init_dynamic_arg(mapping map, object player) {
   string* bits;
   int size;
   commercial::init_dynamic_arg(map, player);
   size = query_auto_load_value(map, OBJECT_TAG, "stocksize");
   _counter_short = query_auto_load_value(map, OBJECT_TAG, "counter short");
   if (size) {
      set_maximum_waiting_queue_size(size);
   }
   if (_counter_short) {
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
   }
}

==================================================
FILE: room/furniture/sink_inherit.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/surface";
#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
int water = 0;
int dirt = 0;
string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});
void zap_bad_effects( object who );
int do_wash(object *indirect_obs );
void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
}
string extra_look() {
    object *stuff;
    string answer = "";
    stuff = all_inventory( this_object() );
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " +
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n";
    }
   return answer;
}
string long_status() {
    return "";
}
void init(){
    ::init();
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
}
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {
            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}
void reset() {
    wet_everyone_in();
}
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}
int do_splash( object *indirect_obs ) {
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() +
            "before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}
int do_wash( object *indirect_obs ) {
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() +
            "before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
}
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    dirt++;
    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    if (!random(dirt)) {
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
}

==================================================
FILE: room/furniture/storage.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
#undef DEBUG
void create() {
   do_setup++;
   furniture_base::create();
   cont_save::create();
   _drawer_mess = "a drawer in $ob_short$";
   _drawers = ({ });
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   return ret;
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  object thief;
  result = ::test_remove(thing, flag, dest);
  if(result && environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    stuff = thing->query_property("dropped");
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  i = ::test_add(thing, flag);
#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put in %s by %s [%d].\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown",
             i);
#endif
  return i;
}
private int pick_ok(object player) {
  mixed owner;
  if(!environment() ||
     !function_exists("query_owner", environment()) ||
     environment()->test_occupier(player->query_name()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
int pick_unlock(object player) {
  if(!pick_ok(player))
    return 0;
  return ::pick_unlock(player);
}
int pick_lock(object player) {
  if(!pick_ok(player))
    return 0;
  return ::pick_lock(player);
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions(map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = cont_save::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map, object) {
   cont_save::init_dynamic_arg(map, 0);
   set_bonded(map["bonded"]);
}

==================================================
FILE: room/furniture/surface.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "/std/object";
inherit "/std/basic/cute_look";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave int _loc_weight, _max_weight;
private nosave string *_shadows;
private nosave object _player;
private nosave string *_aliases;
private nosave int _use_internals;
void create() {
  do_setup++;
  furniture_base::create();
  object::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  set_no_all(1);
}
void init() {
  string alias;
  if(_aliases)
    foreach(alias in _aliases) {
      add_command(alias, "<indirect:object:me> {in|on|into} <indirect:object>",
                  (: "/cmds/living/put"->cmd($1, $3, $4) :) );
    }
  ::init();
}
void set_put_aliases(string *aliases) {
  _aliases = aliases;
}
void set_allow_use_internals(int allow) {
   _use_internals = allow;
}
int query_allow_use_internals() {
   return _use_internals;
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else {
    if (_use_internals) {
      if (from) {
        from->remove_use_internal_object(this_object());
      }
      dest->add_use_internal_object(this_object());
    }
    if (query_light_needs_inform()) {
      if ( from ) {
        inform_of_light_level_change(from);
      }
      inform_of_light_level_change(dest);
    }
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
int test_remove(object thing, int flag, mixed dest) {
  mixed *stuff;
  object thief;
  if(environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    stuff = thing->query_property("dropped");
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  return 1;
}
int test_add( object thing, int flag ) {
  if(environment())
    event(environment(), "save");
#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put on %s by %s.\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown");
#endif
  return 1;
}
void set_max_weight(int arg) { _max_weight = arg; }
int query_max_weight() { return _max_weight; }
int query_loc_weight() { return _loc_weight; }
int query_has_surface() { return 1; }
void update_loc_weight() {
  int i;
  object *contents;
  _loc_weight = 0;
  contents = all_inventory( this_object() );
  for ( i = 0; i < sizeof( contents ); i++ )
    _loc_weight += (int)contents[ i ]->query_complete_weight();
}
int query_complete_weight() {
  return ::query_complete_weight() + query_loc_weight();
}
int add_weight( int n ) {
  if ( !_max_weight ) return 1;
  if ( n + _loc_weight > _max_weight ) return 0;
  if ( !environment() ) {
    _loc_weight += n;
    return 1;
  }
  if ( !( environment()->add_weight( n ) ) ) return 0;
  _loc_weight += n;
  return 1;
}
int transfer_all_to(object dest) {
  object *ob;
  int i;
  ob = all_inventory(this_object());
  for (i=0;i<sizeof(ob);i++)
    ob[i]->move(dest);
  if (first_inventory(this_object())) return 0;
  return 1;
}
string long( string word, int dark ) {
   object *things;
   things = (object *)this_object()->find_inv_match( "all", this_player() );
   if ( !sizeof( things ) )
      return object::long( word, dark ) +"There is nothing on "+
            the_short() +".\n";
   return object::long( word, dark ) + query_contents( "On " +
            the_short() +" "+ ( sizeof( things ) == 1 ? "is " :
            "are " ), things );
}
object *find_inv_match( string words, object looker ) {
   int i;
   object *things;
   things = all_inventory( this_object() );
   for ( i = sizeof( things ) - 1; i > -1; i-- ) {
      if ( !things[ i ]->short( 0 ) ) {
         things = delete( things, i, 1 );
         continue;
      }
      if ( !looker )
         continue;
      if ( !things[ i ]->query_visible( looker ) )
         things = delete( things, i, 1 );
   }
   return things;
}
void set_player( object thing ) { _player = thing; }
object query_player() { return _player; }
mixed stats() {
  return ::stats() + ({
    ({ "loc_weight", query_loc_weight(), }),
    ({ "max_weight", query_max_weight(), }),
  });
}
mapping int_query_static_auto_load() {
  return ([
    "::" : ::int_query_static_auto_load(),
    "max weight" : _max_weight,
    "allowed positions" : query_allowed_positions(),
  ]);
}
mapping query_dynamic_auto_load() {
  mixed inventory;
  if (!inventory) {
    catch(inventory = PLAYER_OB->
        create_auto_load( all_inventory( this_object() ) ) );
  }
  return ([ "::" : ::query_dynamic_auto_load(),
            "inv" : inventory,
            "bonded" : query_bonded()
         ]);
}
int handle_restore_inventory(object ob) {
  return (int)ob->move(this_object());
}
void init_dynamic_arg( mapping bing ) {
  function f;
  if ( bing[ "::" ] ) {
    ::init_dynamic_arg( bing[ "::" ] );
  }
  if ( bing[ "inv" ] ) {
    f = (: handle_restore_inventory($1) :);
    if (_player) {
      _player->load_auto_load_to_inventory( bing["inv"], this_object(),
                                            _player, f);
    } else {
      PLAYER_OB->load_auto_load_to_inventory( bing["inv"], this_object(),
                                              this_player(), f);
    }
  }
  set_bonded(bing["bonded"]);
}
void init_static_arg(mapping bing) {
  if (bing["::"]) {
     ::init_static_arg(bing["::"]);
  }
  if (!undefinedp(bing["max weight"])) {
    _max_weight = bing["max weight"];
  if(!undefinedp(bing["allowed_positions"]))
    set_allowed_positions(bing["allowed_positions"]);
  }
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void dest_me() {
  int i;
  object shadow;
  for ( i = 0; i < sizeof( _shadows ); i++ ) {
    if ( shadow = find_object( _shadows[ i ] ) ) {
      shadow->destruct_shadow( shadow );
    }
  }
  all_inventory()->dest_me();
  object::dest_me();
}
string query_help_file_directory() {
   return "/doc/furniture/";
}

==================================================
FILE: room/furniture/vessel.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/obj/vessel";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
void create() {
   do_setup++;
   vessel::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
}
void init() {
   item_chat::init();
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = vessel::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map) {
   vessel::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
}

==================================================
FILE: room/furniture/inherit/document_handler.c
==================================================

#include <move_failures.h>
#include <nroff.h>
#include <room/newspaper.h>
#include <room/document_handler.h>
#define TAG "document__h"
class document {
   string title;
   string fname;
   string added_by;
   int time_added;
   int type;
}
private mapping _documents;
private int _next_doc_id;
string query_save_dir();
void save_me();
int is_open_for(string type, string name);
void add_auto_load_value(mapping map, string tag, string name, mixed value);
mixed query_auto_load_value(mapping map, string tag, string name);
void create() {
   _documents = ([ ]);
}
string query_document_file_name(string id) {
   if (_documents[id]) {
      return query_save_dir() + "/" + _documents[id]->fname;
   }
   return 0;
}
string query_document_data(string id) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      return unguarded( (: read_file($(fname)) :) );
   }
   return 0;
}
int is_document(string id) {
   return _documents[id] != 0;
}
string query_document_readable(string id) {
   string fname;
   string text;
   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: NROFF_HAND->cat_file($(fname) + ".nroff", 1) :) );
         if (!text) {
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
}
string query_document_html(string id) {
   string fname;
   string text;
   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         text = replace(fname, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;",
                                  " ", "&nbsp;", "\n", "<br>" }) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: read_file($(fname)) :) );
         if (!text) {
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
}
void update_document_text(string id, string text) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: write_file($(fname), $(text), 1) :));
   }
}
void delete_document(string id) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: rm($(fname) + ".proc") :));
      unguarded( (: rm($(fname) + ".nroff.o") :));
      unguarded( (: rm($(fname)) :));
      map_delete(_documents, id);
      save_me();
   }
}
string add_document(string title, string text, string person, int type) {
   class document bing;
   string id;
   id = _next_doc_id + "";
   bing = new(class document);
   bing->title = title;
   bing->added_by = person;
   bing->type = type;
   bing->time_added = time();
   bing->fname = id + ".txt";
   _next_doc_id++;
   _documents[id] = bing;
   update_document_text(id, text);
   save_me();
   return id;
}
int do_list() {
   string ret;
   class document info;
   string id;
   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot list documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   if (!sizeof(_documents)) {
      add_failed_mess("Cannot find any documents to list on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   ret = "";
   foreach (id, info in _documents) {
      ret += "$I$3=" + id + ") " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " +
             ctime(info->time_added)[<4..] + "\n";
   }
   write("$P$Documents$P$" + ret);
   add_succeeded_mess(({ "", "$N lists the documents in $I.\n" }),
                      ({ this_object() }));
   return 1;
}
int do_display(string id) {
   string ret;
   class document info;
   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot view documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   ret = query_document_readable(id);
   if (!ret) {
      add_failed_mess("Cannot find the document " + id + " on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   info = _documents[id];
   ret = "Document #" + id + " " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " +
             ctime(info->time_added)[<4..] + "\n" + ret;
   write("$P$Document " + id + "$P$" + ret);
   add_succeeded_mess(({ "", "$N reads a document from $I.\n" }),
                      ({ this_object() }));
   return 1;
}
int do_add_document(string title, int type) {
   if (!is_open_for("document_add", this_player()->query_name())) {
      add_failed_mess("You cannot add documents to $I.\n",
                      ({ this_object() }));
      return 0;
   }
   this_player()->do_edit("", "finish_edit", this_object(), 0,
                          ({ title, type }));
   return 1;
}
void finish_edit(string str, mixed* args) {
   string title;
   int type;
   title = args[0];
   type = args[1];
   if (!str || str == "") {
      write("Abandoning adding the document.\n");
      return ;
   }
   add_document(title, str, this_player()->query_cap_name(), type);
   write("Added the document into the collection.\n");
}
int do_delete_document(string id) {
   if (!is_open_for("document_delete", this_player()->query_name())) {
      add_failed_mess("You cannot delete documents from $I.\n",
                      ({ this_object() }));
      return 0;
   }
   if (!is_document(id)) {
      add_failed_mess("The document " + id + " does not exist in $I.\n",
                      ({ this_object() }));
      return 0;
   }
   delete_document(id);
   add_succeeded_mess("$N delete$s a document from $I.\n", ({ this_object() }));
   return 1;
}
mapping query_dynamic_auto_load(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      add_auto_load_value(map, TAG, "documents", _documents);
      add_auto_load_value(map, TAG, "doc id", _next_doc_id);
      return map;
   }
}
void init_dynamic_arg(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      _documents = query_auto_load_value(map, TAG, "documents");
      if (!_documents) {
         _documents = ([ ]);
      }
      _next_doc_id = query_auto_load_value(map, TAG, "doc id");
   }
}
void init_object() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
}
void init_room() {
   add_command("list", "[documents]", (: do_list() :));
   add_command("view", "[document] <string'id'>",
                (: do_display($4[0]) :));
   add_command("add", "[document] {html|plain} called <string:quoted'title'>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "[document] <string'id'>",
                (: do_delete_document($4[0]) :));
}

==================================================
FILE: room/furniture/inherit/furniture_base.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <housing.h>
#include <room/placement.h>
void add_property(string name, mixed type);
mixed query_property(string name);
string one_short();
int query_light_needs_inform();
void inform_of_light_level_change(object ob);
private nosave mapping _allowed_room_verbs;
private nosave string *_allowed_positions;
private nosave string _bonded;
void create() {
  _allowed_positions = ({ });
  if (base_name(this_object()) + ".c" != __FILE__) {
    if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
    }
    this_object()->set_max_cond(100000);
    this_object()->set_cond(100000);
  }
  if(clonep(this_object()) &&
     base_name(this_object())[0..14] != "/obj/furnitures" &&
     base_name(this_object())[0..2] != "/w/" &&
     strsrch (base_name(this_object()), "_dev") == -1 &&
     strsrch (base_name(this_object()), "_pt") == -1) {
    call_out("move", 2, "/room/void");
  }
}
int query_furniture() {
   return 1;
}
void set_allowed_positions(string *positions) {
   _allowed_positions = positions;
}
void remove_allowed_positions( string *positions ){
  _allowed_positions -= positions;
}
string* query_allowed_positions() {
   return _allowed_positions;
}
void set_allowed_room_verbs( mapping allowed ) {
  _allowed_room_verbs = allowed;
}
mapping query_allowed_room_verbs() {
   return _allowed_room_verbs;
}
string query_position_string(string position_type) {
  if(member_array(position_type, _allowed_positions) != -1) {
    return one_short();
  }
  return 0;
}
void set_bonded(string person) {
   _bonded = person;
}
string query_bonded() {
   return _bonded;
}
string query_owner() {
   return _bonded;
}
int is_allowed_to_mess(object player) {
  mixed *stuff;
  string occupier;
  if(environment() && !function_exists("query_owner", environment()))
    return 1;
  if(player->query_creator())
    return 1;
  if(player->query_caster())
    player = find_player(player->query_caster());
  if(player->query_owner())
    player = player->query_owner();
  if (player && player->query_name() == _bonded)
    return 1;
  stuff = this_object()->query_property("dropped");
  if(player && sizeof(stuff) && stuff[0] == player->query_name())
    return 1;
  if(player && environment()) {
    if(environment()->test_occupier(player->query_name()))
      return 1;
    if(environment()->query_owner() == "For Sale" ||
       environment()->query_owner() == "Under Offer")
      return 1;
    occupier = HOUSING->query_owner(base_name(environment()));
    if(pk_check(player, occupier, 1))
      return 0;
  }
  return (!_bonded);
}
int move_check(object dest) {
  if (living(dest)) {
    if (!is_allowed_to_mess(dest)) {
       return 0;
    }
  } else if (this_player() && environment()) {
    if (!(living(environment()) && dest == environment(environment()))) {
       if (!is_allowed_to_mess(this_player())) {
          return 0;
       }
    }
  }
  return 1;
}
string query_placement_verb() {
   return query_property(PLACEMENT_CURRENT_ROOM_VERB);
}
string query_placement_other() {
   return query_property(PLACEMENT_CURRENT_ROOM_OTHER);
}
string query_placement_position() {
   return query_property(PLACEMENT_CURRENT_ROOM_POSITION);
}
int query_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}
int is_placed() {
   return query_placement_position() &&
     stringp(query_placement_verb()) &&
     stringp(query_placement_other());
}
void set_placement_verb(string verb) {
   add_property(PLACEMENT_CURRENT_ROOM_VERB, verb);
}
void set_placement_other(string other) {
   add_property(PLACEMENT_CURRENT_ROOM_OTHER, other);
}
void set_placement_position(string position) {
   add_property(PLACEMENT_CURRENT_ROOM_POSITION, position);
}
int set_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}

==================================================
FILE: room/furniture/inherit/one_armed_bandit_inherit.c
==================================================

#include <money.h>
int do_slot();
int do_pull_lever();
int do_read_dial();
int set_coin_type( string coin );
int set_chances( int c1, int c2, int c3, int c4, int c5 );
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot );
int* query_prizes();
int* query_chances();
string query_coin_type();
void rollem( object player );
string my_short();
private string *animal = ({"albatross", "frog", "hippo", "turtle", "cabbage"});
private string *adject = ({"A crazy", "A dancing", "A sad", "A floopy", "A bemused",
    "A sarcastic", "A quizzical", "A startled", "A friendly", "A mindless"});
private string _coin = "Ankh-Morpork pence", _coin_short = "pence",
    _coin_pl = "Ankh-Morpork pence";
private int _busy = 0;
private int* _chances = ({1,1,1,1,1});
private int* _prizes = ({2,2,2,2,2,3});
void init(){
    this_player()->add_command( "slot", this_object(),
        _coin_short + " into <direct:object>", (: do_slot() :) );
    this_player()->add_command( "pull", this_object(),
        "lever on <direct:object>", (: do_pull_lever() :) );
    this_player()->add_command( "read", this_object(),
        "dial on <direct:object>", (: do_read_dial() :) );
}
int set_coin_type( string coin ) {
    if( member_array( coin, MONEY_HAND->query_valid_types() ) == -1 )
        return 0;
    _coin = coin;
    _coin_short = MONEY_HAND->query_aliases_for( coin )[0];
    _coin_pl = MONEY_HAND->query_main_plural_for( coin );
    return 1;
}
int set_chances( int c1, int c2, int c3, int c4, int c5 ) {
    if( !( c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c5 > 0 ) )
        return 0;
    _chances = ({ c1, ( c1 + c2 ), ( c1 + c2 + c3 ), ( c1 + c2 + c3 + c4 ),
        ( c1 + c2 + c3 + c4 + c5 ) });
    return 1;
}
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot ) {
    if( !( p1 > 1 && p2 > 1 && p3 > 1 && p4 > 1 && p5 > 1 && jackpot > 1 ) ||
        ( jackpot <= p1 || jackpot <= p2 || jackpot <= p3 ||
        jackpot <= p4 || jackpot <= p5 ) )
        return 0;
    _prizes = ({p1, p2, p3, p4, p5, jackpot});
    return 1;
}
int do_slot() {
    if( member_array( _coin, this_player()->query_money_array() ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
            "You need " + add_a( _coin ) + " to play.\n", ({ }) );
        return 0;
    }
    if( _busy == 1 ) {
        this_player()->add_failed_mess( this_object(),
            "There is already a coin inserted.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are still spinning.\n", ({ }) );
        return 0;
    }
    this_player()->adjust_money( -1, _coin );
    this_object()->adjust_money( 1 );
    _busy = 1;
    this_player()->add_succeeded_mess( this_object(),
        "$N insert$s " + add_a( _coin_short ) + " into $D.\n", ({ }) );
    return 1;
}
int do_pull_lever() {
    if( _busy == 0 ) {
        this_player()->add_failed_mess( this_object(),
            "You must put a coin in the slot before you can play.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are already spinning.\n", ({ }) );
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(),
        ({"You pull the lever.  The pictures behind the windows blur... one by "
             "one they are replaced by a new picture that appears with a sharp "
             "click.\n",
        "$N pull$s the lever on $D and the machine whirs softly.  The sound is "
        "cut short by three sharp clicks.\n"
        }), ({ }) );
    call_out( "rollem", 0, this_player() );
    _busy = 2;
    return 1;
}
void rollem( object player ) {
    int a1, a2, a3, c;
    int adj1 = random( 10 ),
        adj2 = random( 10 ),
        adj3 = random( 10 );
    c = random( _chances[4] );
    if( c < _chances[0] )
        a1 = 0;
    else if( c < _chances[1] )
        a1 = 1;
    else if( c < _chances[2] )
        a1 = 2;
    else if( c < _chances[3] )
        a1 = 3;
    else
        a1 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a2 = 0;
    else if( c < _chances[1] )
        a2 = 1;
    else if( c < _chances[2] )
        a2 = 2;
    else if( c < _chances[3] )
        a2 = 3;
    else
        a2 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a3 = 0;
    else if( c < _chances[1] )
        a3 = 1;
    else if( c < _chances[2] )
        a3 = 2;
    else if( c < _chances[3] )
        a3 = 3;
    else
        a3 = 4;
    tell_object( player,
        "The windows now show these pictures :\n\n"
         "        " + adject[ adj1 ] + " " + animal[ a1 ] +
         "    " + adject[ adj2 ] + " " + animal[ a2 ] +
         "    " + adject[ adj3 ] + " "+animal[ a3 ] + "\n\n" );
    if( a1 == a2 && a1 == a3 ) {
        if( adj1 == adj2 && adj1 == adj3 ) {
            tell_object( player,
                "WOW!!  A triple " + adject[ adj1 ] + " " + animal[ a1 ] +
                "!!  You really hit the jackpot this time!\n\n"
                "Whistles and bells start sounding like crazy, the whole " +
                this_object()->short() +  " glows with flashing lights.  There "
                "is a loud tingling as " + _prizes[5] + " " +
                MONEY_HAND->query_plural_for( _coin ) + " drop into the tray "
                "of " + my_short() + ".  Slightly stunned you quickly scoop "
                "it up and cackle with delight.\n" );
            tell_room( environment( this_object() ),
                "Whistles and bells start sounding and " + my_short() +
                " starts to flash with coloured lights.  Someone must have "
                "won the jackpot...lucky buggers.  As you watch some coins "
                "drop into the tray at the bottom of " + my_short() + ", " +
                player->one_short() + " snatches it up and cackles with "
                "delight.\n", ({player}) );
            player->adjust_money( _prizes[5] ,_coin );
            this_object()->adjust_money( -(_prizes[ 5 ]) );
            _busy = 0;
            return;
        }
        tell_object( player,
            "Congratulations!  You scored a triple " + animal[ a1 ] + "!\n" );
        player->adjust_money( _prizes[ a1 ], _coin );
        tell_object( player,
            _prizes[ a1 ]+ " " + MONEY_HAND->query_plural_for( _coin ) +
            " fall into the tray at the bottom of " + my_short() + ".  You "
            "quickly scoop them up before anyone else can snaffle them.\n" );
        tell_room( environment( this_object() ),
            player->one_short() + " deftly scoops some coins from the tray at "
            "the bottom of " + my_short() + ".\n", ({player}) );
        this_object()->adjust_money( -(_prizes[ a1 ]) );
        _busy = 0;
        return;
    }
    tell_object( player,
        "You didn't win.  Why not have another go and attempt to recoup your "
        "losses?\n" );
    _busy = 0;
}
int* query_chances() {
    int* tmp = ({ });
    tmp += ({ _chances[0] });
    tmp += ({ _chances[1] - _chances[0] });
    tmp += ({ _chances[2] - _chances[1] });
    tmp += ({ _chances[3] - _chances[2] });
    tmp += ({ _chances[4] - _chances[3] });
    return tmp;
}
int* query_prizes() {
    return _prizes;
}
string query_coin_type() {
    return _coin;
}
string my_short() {
    return this_object()->the_short();
}
int do_read_dial() {
    string tmp =
        "Stake        : 1 " + _coin_pl + "\n"
        "3x Albatross : " + _prizes[0] + " " + _coin_pl + "\n"
        "3x Frog      : " + _prizes[1] + " " + _coin_pl + "\n"
        "3x Hippo     : " + _prizes[2] + " " + _coin_pl + "\n"
        "3x Turtle    : " + _prizes[3] + " " + _coin_pl + "\n"
        "3x Cabbage   : " + _prizes[4] + " " + _coin_pl + "\n"
        "JACKPOT      : " + _prizes[5] + " " + _coin_pl + "\n";
    this_player()->add_succeeded_mess( this_object(),
        ({tmp, "$N read$s the dial on $D.\n"}), ({ }) );
    return 1;
}

==================================================
FILE: room/furniture/games/card_base.c
==================================================

#include <room/card_base.h>
#define CARD_NUM_MAX CARD_NUMBER_KING
int is_card_red(class playing_card card);
class playing_card* make_deck(int number_of_decks,
                              int number_of_jokers) {
   class playing_card* deck;
   class playing_card card;
   int i;
   int suit;
   int num;
   deck = ({ });
   for (i = 0; i < number_of_decks; i++) {
      for (suit = CARD_SUIT_HEARTS; suit <= CARD_SUIT_SPADES; suit++) {
         for (num = 1; num <= CARD_NUM_MAX; num++) {
            card = new(class playing_card);
            card->suit = suit;
            card->number = num;
            deck += ({ card });
         }
      }
   }
   for (i = 0; i < number_of_jokers; i++) {
      card = new(class playing_card);
      card->suit = CARD_SUIT_JOKER;
      deck += ({ card });
   }
   return deck;
}
class playing_card* shuffle_deck(class playing_card* deck) {
   class playing_card* new_deck;
   int pos;
   int i;
   for (i = 0; i < 2; i++) {
      new_deck = ({ });
      while (sizeof(deck)) {
         pos = random(sizeof(deck));
         new_deck += deck[pos..pos];
         deck = deck[0..pos - 1] + deck[pos+1..];
      }
      deck = new_deck;
   }
   return deck;
}
string query_suit_letter(int suit) {
   switch (suit) {
   case CARD_SUIT_SPADES :
      return "S";
      break;
   case CARD_SUIT_HEARTS :
      return "H";
      break;
   case CARD_SUIT_DIAMONDS :
      return "D";
      break;
   case CARD_SUIT_CLUBS :
      return "C";
      break;
   case CARD_SUIT_JOKER :
      return "J";
   }
}
string query_card_string(class playing_card card) {
   string ret;
   string colour;
   if (card->suit == CARD_SUIT_JOKER) {
      return "*J*";
   }
   ret = query_suit_letter(card->suit) + "%^RESET%^";
   if (is_card_red(card)) {
      colour = "%^BOLD%^%^RED%^";
   } else {
      colour = "%^BOLD%^";
   }
   if (card->number > 10 || card->number == CARD_NUMBER_ACE) {
      switch (card->number) {
      case CARD_NUMBER_JACK :
         ret = colour + "J " + ret;
         break;
      case CARD_NUMBER_QUEEN :
         ret = colour + "Q " + ret;
         break;
      case CARD_NUMBER_KING :
         ret = colour + "K " + ret;
         break;
      case CARD_NUMBER_ACE :
         ret = colour + "A " + ret;
         break;
      }
   } else {
      ret = sprintf("%s%-2d%s", colour, card->number, ret);
   }
   return ret + "%^RESET%^";
}
int is_card_red(class playing_card card) {
   return card->suit == CARD_SUIT_HEARTS || card->suit == CARD_SUIT_DIAMONDS;
}
int is_card_black(class playing_card card) {
   return card->suit == CARD_SUIT_SPADES || card->suit == CARD_SUIT_CLUBS;
}
int is_card_joker(class playing_card card) {
   return card->suit == CARD_SUIT_JOKER;
}
string* query_card_three(class playing_card card) {
   string* lines;
   if (is_card_red(card)) {
      lines = allocate(3, "%^BOLD%^%^RED%^");
   } else {
      lines = allocate(3, "%^BOLD%^");
   }
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] += "H  %^RESET%^";
      lines[2] += "  H%^RESET%^";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] += "D  %^RESET%^";
      lines[2] += "  D%^RESET%^";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] += "C  %^RESET%^";
      lines[2] += "  C%^RESET%^";
      break;
   case CARD_SUIT_SPADES :
      lines[0] += "S  %^RESET%^";
      lines[2] += "  S%^RESET%^";
      break;
   case CARD_SUIT_JOKER :
      lines[0] += "J *%^RESET%^";
      lines[1] += " O %^RESET%^";
      lines[2] += "* K%^RESET%^";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      if (card->number == 10) {
         lines[1] += " 10%^RESET%^";
      } else {
         lines[1] += " " + card->number + " %^RESET%^";
      }
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] += " K %^RESET%^";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] += " Q %^RESET%^";
         break;
      case CARD_NUMBER_JACK :
         lines[1] += " J %^RESET%^";
         break;
      case CARD_NUMBER_ACE :
         lines[1] += " A %^RESET%^";
         break;
      }
   }
   return lines;
}
string* query_card_two(class playing_card card) {
   string* lines;
   lines = allocate(2);
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] = "H ";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] = "D ";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] = "C ";
      break;
   case CARD_SUIT_SPADES :
      lines[0] = "S ";
      break;
   case CARD_SUIT_JOKER :
      lines[0] = "J*";
      lines[1] = "*O";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      lines[1] = sprintf("%2d", card->number);
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] = " K";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] = " Q";
         break;
      case CARD_NUMBER_JACK :
         lines[1] = " J";
         break;
      case CARD_NUMBER_ACE :
         lines[1] = " A";
         break;
      }
   }
   return lines;
}
string query_hand_string(class playing_card* hand, int flags, int cols) {
   string hand_str;
   int i;
   int j;
   int width;
   int start_pos;
   string top;
   string line;
   string start;
   string end;
   string start_space;
   string end_space;
   mixed card_str;
   if (!sizeof(hand)) {
      return "No cards\n";
   }
   hand_str = "";
   if (!(flags & CARD_HAND_NO_ADORNMENTS)) {
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         top = "+---+";
         width = 5;
      } else {
         top = "+--+";
         width = 4;
      }
      start = "|";
      end = "|";
      start_space = " ";
      end_space = " ";
   } else {
      top = 0;
      line = "";
      start = " ";
      end = " ";
      start_space = " ";
      end_space = " ";
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         width = 3;
      } else {
         width = 2;
      }
   }
   start_pos = 0;
   if (flags & CARD_HAND_THREE) {
      card_str = map(hand, (: query_card_three :));
   } else if (flags & CARD_HAND_SINGLE) {
      card_str = map(hand, (: ({ query_card_string($1) }) :));
   } else {
      card_str = map(hand, (: query_card_two :));
   }
   while (start_pos < sizeof(hand)) {
      if (top) {
         line = "";
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            line += top;
         }
         line += "\n";
      }
      if (flags & CARD_HAND_LETTERS) {
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            if (flags & CARD_HAND_THREE) {
               hand_str += start_space + sprintf(" %c ", 'A' + i + start_pos) + end_space;
            } else {
               hand_str += start_space + sprintf("%c ", 'A' + i + start_pos) + end_space;
            }
         }
      }
      hand_str += "\n" + line;
      for (j = 0; j < sizeof(card_str[0]); j++) {
         for (i = 0; i + start_pos < sizeof(card_str) && (i + 1) * width < cols; i++) {
            hand_str += start + (card_str[i + start_pos][j]) + end;
         }
         hand_str += "\n";
      }
      hand_str += line;
      start_pos += cols / width;
   }
   return hand_str;
}
private int compare_cards(class playing_card card1, class playing_card card2,
                          int flags) {
   if (card1->suit == card2->suit ||
       (flags & 2)) {
      if (!(flags & 1)) {
         return card1->number - card2->number;
      }
      if (card1->number == CARD_NUMBER_ACE) {
         return 1;
      }
      if (card2->number == CARD_NUMBER_ACE) {
         return -1;
      }
      return card1->number - card2->number;
   }
   return card1->suit - card2->suit;
}
class playing_card* sort_cards(class playing_card* deck, int flags) {
   return sort_array(deck,
                (: compare_cards($1, $2, $(flags)) :));
}

==================================================
FILE: room/furniture/games/multiplayer_base.c
==================================================

private inherit "/std/basic/auto_load";
#define LOAD_TAG "multiplayer base"
class player_info {
   int number;
   string cap_name;
   string name;
   mixed data;
}
private mapping _players;
private string _winner;
private string* _ids_when_started;
private string _current_player;
private int _minimum_needed;
private int _maximum_allowed;
private int _can_join_as_new;
private int _game_started;
string* query_currently_playing_ids();
void delete_gone_players();
string find_player_id_of_person(object person);
void create() {
   _players = ([ ]);
   _ids_when_started = ({ });
}
void reset_game() {
}
int start_game() {
   delete_gone_players();
   if (sizeof(query_currently_playing_ids()) < _minimum_needed) {
      return 0;
   }
   _winner = 0;
   _game_started = 1;
   _ids_when_started = query_currently_playing_ids();
   _current_player = _ids_when_started[random(sizeof(_ids_when_started))];
   return 1;
}
void finish_game(string winner) {
   _winner = winner;
   _game_started = 0;
}
string query_winner() {
   return _winner;
}
int is_game_started() {
   return _game_started;
}
int can_join_as_new_player() {
   return _can_join_as_new;
}
void set_can_join_as_new_player(int join) {
   _can_join_as_new = join;
}
int is_person_playing(string id) {
   if (_players[id]->name) {
      if (find_player(_players[id]->name) &&
          is_in_me_or_environment(this_object(),
                                  find_player(_players[id]->name)) &&
          interactive(find_player(_players[id]->name))) {
         return 1;
      }
   }
   return 0;
}
int is_playing(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id != 0;
}
int is_current_player(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id == _current_player;
}
int add_person_to_game(string id, object person) {
   class player_info info;
   if (is_person_playing(id)) {
      return 0;
   }
   info = _players[id];
   info->name = person->query_name();
   info->cap_name = person->query_cap_name();
   return 1;
}
int remove_person_object_from_game(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         info->name = 0;
         info->cap_name = 0;
         return 1;
      }
   }
   return 0;
}
int remove_person_id_from_game(string id) {
   if (_players[id]->name) {
      _players[id]->name = 0;
      return 1;
   }
   return 0;
}
void randomise_player_numbers() {
   string* ids;
   int num;
   int pos;
   ids = keys(_players);
   num = 0;
   while (sizeof(ids)) {
      pos = random(sizeof(ids));
      _players[ids[pos]]->number = num;
      ids = ids[0..pos-1] + ids[pos+1..];
      num++;
   }
}
void add_player_id_type(string id, int number) {
   _players[id] = new(class player_info);
   _players[id]->number = number;
}
void remove_player_id_type(string id) {
   map_delete(_players, id);
}
class player_info find_player_info_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return info;
      }
   }
   return 0;
}
string find_player_id_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return id;
      }
   }
   return 0;
}
string* query_player_ids() {
   return keys(_players);
}
string* query_currently_playing_ids() {
   return filter(keys(_players), (: is_person_playing($1) :));
}
string* query_started_player_ids() {
   return _ids_when_started;
}
string query_player_cap_name(string id) {
   if (_players[id] && _players[id]->name) {
      return _players[id]->cap_name;
   }
   return "No one";
}
object query_player_object(string id) {
   return find_player(_players[id]->name);
}
string query_player_the_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->the_short();
      }
   }
   return "No one";
}
string query_player_poss_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->poss_short();
      }
   }
   return "No one";
}
void delete_gone_players() {
   string id;
   class player_info info;
   foreach (id, info in _players) {
      if (info->name) {
         if (!find_player(info->name) ||
             !is_in_me_or_environment(this_object(), find_player(info->name))) {
            info->name = 0;
         }
      }
   }
}
void set_minimum_needed(int minimun) {
   _minimum_needed = minimun;
}
int can_start_game() {
   if (sizeof(query_currently_playing_ids()) > _minimum_needed) {
      return 1;
   }
   return 0;
}
string find_next_player(string id) {
   class player_info info;
   int start;
   int cur;
   string new_id;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur + 1) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
                member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
string find_previous_player(string id) {
   class player_info info;
   int start;
   string new_id;
   int cur;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur - 1 + sizeof(_players)) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
               member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
void increment_current_player() {
   _current_player = find_next_player(_current_player);
}
string find_player_id_of_person(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         return id;
      }
   }
   return 0;
}
string query_current_player() {
   if (!_current_player) {
      _current_player = find_player_id_from_number(0);
   }
   return _current_player;
}
string set_current_player(string id) {
   _current_player = id;
}
void tell_player(string id, string message) {
   object player;
   player = find_player(_players[id]->name);
   if (player && (environment(player) == environment() ||
                  player == environment())) {
      tell_object(player, message);
   }
}
void tell_current_player(string message) {
   tell_player(_current_player, message);
}
varargs void tell_all_players(string message, string* exclude) {
   class player_info info;
   string id;
   if (!exclude) {
      exclude = ({ });
   }
   foreach (id, info in _players) {
      if (member_array(id, exclude) == -1) {
         tell_player(id, message);
      }
   }
}
mixed query_player_data(string id) {
   return _players[id]->data;
}
void set_player_data(string id, mixed data) {
   _players[id]->data = data;
}
void multiplayer_someone_joins(string id) {
}
void multiplayer_someone_resigns(string id, string name) {
}
mixed* shuffle_array(mixed *arr) {
   int i;
   int pos;
   mixed* new_arr;
   for (i = 0; i < 2; i++) {
      new_arr = ({ });
      while (sizeof(arr)) {
         pos = random(sizeof(arr));
         new_arr += arr[pos..pos];
         arr = arr[0..pos - 1] + arr[pos + 1..];
      }
      arr = new_arr;
   }
   return arr;
}
int do_join(string id) {
   if (is_person_playing(id)) {
      add_failed_mess("Someone is already playing " + id + " on $D.\n");
      return 0;
   }
   if (is_playing(this_player())) {
      add_failed_mess("You are already playing on $D.\n");
      return 0;
   }
   if (is_game_started() &&
       !can_join_as_new_player() &&
       member_array(id, query_started_player_ids()) == -1) {
      add_failed_mess("You can only take over one of the spots vacated by "
                      "someone else.\n");
      return 0;
   }
   if (add_person_to_game(id, this_player())) {
      add_succeeded_mess("$N $V as " + id + " on $D.\n");
      multiplayer_someone_joins(id);
      return 1;
   }
   add_failed_mess("Some weird error joining game on $D.\n");
   return 0;
}
int do_resign() {
   string id;
   id = find_player_id_of_person(this_player());
   if (remove_person_object_from_game(this_player())) {
      add_succeeded_mess("$N $V from the game on $D.\n");
      multiplayer_someone_resigns(id, this_player()->query_cap_name());
      if (id == query_current_player()) {
         increment_current_player();
      }
      return 1;
   }
   add_failed_mess("You are not playing on $D to resign.\n");
   return 0;
}
void init() {
   string ids;
   ids = implode(keys(_players), "|");
   add_command("join", "[game] [as] {" + ids + "} on <direct:object>",
                (: do_join($4[0]) :));
   add_command("resign", "[from] [game] on <direct:object>",
               (: do_resign() :));
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      return 0;
   }
   add_auto_load_value(map, LOAD_TAG, "players", _players);
   add_auto_load_value(map, LOAD_TAG, "current player", _current_player);
   add_auto_load_value(map, LOAD_TAG, "started ids", _ids_when_started);
   add_auto_load_value(map, LOAD_TAG, "winner", _winner);
   add_auto_load_value(map, LOAD_TAG, "game started", _game_started);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   if (!map) {
      return ;
   }
   _players = query_auto_load_value(map, LOAD_TAG, "players");
   _current_player = query_auto_load_value(map, LOAD_TAG, "current player");
   _ids_when_started = query_auto_load_value(map, LOAD_TAG, "started ids");
   _winner = query_auto_load_value(map, LOAD_TAG, "winner");
   _game_started = query_auto_load_value(map, LOAD_TAG, "game started");
}

==================================================
FILE: liquids/ink.c
==================================================

int splash_func(object ob) {
  ob->add_extra_look(this_object());
  ob->add_property("splashed with", previous_object()->query_liquid_name());
  return 1;
}
int query_ink() { return 1; }
string extra_look() {
  return capitalize((string)previous_object()->query_name())+
         " has been splashed with "+
         previous_object()->query_property("splashed with");
}

==================================================
FILE: shadows/peace_shadow.c
==================================================

inherit "/std/effect_shadow";
#define GCR peacenpc->get_combat_reason()
#define GER peacenpc->get_escape_reason()
#define GFR peacenpc->get_fighting_reason()
#define GMR peacenpc->get_magic_reason()
#define GOR peacenpc->get_other_reason()
#define GRR peacenpc->get_ritual_reason()
#define GSR peacenpc->get_stealth_reason()
#define TO this_object()
#define TP this_player()
object peacenpc;
void setup_shadow(object person, object thing) {
    shadow( person, 1 );
    peacenpc=thing;
}
void dest_peace_shadow() { destruct(TO); }
void event_exit(object ob, string message, object to) {
    if (ob==peacenpc)
        dest_peace_shadow();
}
void event_move_object(mixed from, mixed to) {
    dest_peace_shadow();
}
int command_shadowed( string verb, string args ) {
    switch(verb) {
        case "attack":
        case "behead":
        case "berserk":
        case "bob":
        case "crush":
        case "disarm":
        case "fire":
        case "guard":
        case "hack":
        case "hurl":
        case "iai":
        case "impale":
        case "kill":
        case "punch":
        case "riposte":
        case "slash":
        case "throw":
        case "warcry":
            tell_object(TP, GFR);
            return 1;
        case "cast":
        case "circle":
        case "educe":
        case "forget":
        case "invoke":
        case "remember":
        case "scribe":
        case "scry":
        case "spellcheck":
        case "twist":
        case "use":
        case "zap":
            tell_object(TP, GMR);
            return 1;
        case "bodyguard":
        case "bury":
        case "drag":
        case "eye":
        case "fuel":
        case "hedgehog":
        case "judge":
        case "leatherwork":
        case "mock":
        case "tempt":
        case "scathe":
        case "vurdere":
            tell_object(TP, GOR);
            return 1;
        case "conflagrate":
        case "consecrate":
        case "decompose":
        case "ensumpf":
        case "envalise":
        case "imbue":
        case "perform":
        case "pray":
        case "pyroscipate":
        case "shroud":
        case "suffuse":
        case "ventisepelate":
            tell_object(TP, GRR);
            return 1;
        case "abscond":
        case "ambush":
        case "case":
        case "conceal":
        case "crack":
        case "disable":
        case "filch":
        case "hide":
        case "inhume":
        case "lpick":
        case "palm":
        case "peek":
        case "plant":
        case "probe":
        case "scope":
        case "shoplift":
        case "slip":
        case "snatch":
        case "sneak":
        case "steal":
        case "unhide":
            tell_object(TP, GSR);
            return 1;
        default:
            return 0;
    }
}
int run_away() {
    tell_object(TO, GER);
}

==================================================
FILE: shadows/object/basic_trap.c
==================================================

inherit "/std/effect_shadow";
int trap_lock(string type) {
  if(type != "pick")
    return 0;
  tell_object(this_player(), "Trap triggered.\n");
  return 0;
}

==================================================
FILE: shadows/object/death_ward.c
==================================================

inherit "/std/effect_shadow";
void event_death( object thing, object *killers, object killer,
      string room_mess, string killer_mess ) {
   int damage;
   object twit;
   player->event_death( thing, killers, killer, room_mess, killer_mess );
   if ( thing != (object)player->query_worn_by() )
      return;
   tell_room( environment( thing ), (string)player->the_short() +
         " explodes in a ball of flame!\n" );
   thing->remove_armour( player );
   player->move( "/room/rubbish" );
   foreach ( twit in killers ) {
      if ( environment( twit ) != environment( thing ) )
         continue;
      damage = arg();
      if ( twit == killer )
         damage *= 2;
      damage -= (int)twit->query_ac( "fire", damage );
      if ( damage > 0 )
         twit->adjust_hp( -damage );
      if ( (int)twit->query_hp() < 0 )
         twit->attack_by( player );
   }
   remove_this_effect();
}

==================================================
FILE: shadows/object/identity_hold.c
==================================================

inherit "/std/effect_shadow";
#include <move_failures.h>
private int _keep;
private string _identifier;
private string* _adjs;
private object _owner;
int query_keep() { return _keep; }
void set_keep_value(int keep) { _keep = keep; }
void set_keep() { _keep = 1; }
void reset_keep() {
   _keep = 0;
   if (!_identifier)
      remove_this_effect();
}
string query_identifier() { return _identifier; }
string query_full_identifier() {
    string tmp;
    tmp = "";
    if ( sizeof( _adjs ) ) {
        tmp += implode( _adjs, " " ) + " ";
    }
    if ( _identifier ) {
       tmp += _identifier;
    }
    if ( strlen( tmp ) > 0 ) {
       return tmp;
    }
    return 0;
}
void set_identifier( string word ) {
   string* bits;
   if (word) {
      bits = explode(word, " ");
      _identifier = bits[<1];
      _adjs = bits[0..<2];
   } else {
      _identifier = 0;
      _adjs = ({ });
      if (!_keep)
         remove_this_effect();
   }
}
void set_identity_hold_owner(object ob) {
   _owner = ob;
}
object query_identity_hold_owner() {
   return _owner;
}
string *parse_command_id_list() {
   string *words;
   words = (string *)player->parse_command_id_list();
   if ( ( this_player() == _owner ) && stringp( _identifier ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1 && $1->ignore_identifier() :) ) ) ) {
      words += ({ _identifier });
   }
   return words;
}
string *parse_command_adjectiv_id_list() {
   string *words;
   words = (string *)player->parse_command_adjectiv_id_list();
   if ( ( this_player() == _owner ) && pointerp( _adjs ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1->ignore_identifier() :) ) ) ) {
      words += _adjs;
   }
   return words;
}
private void check_move_stuff() {
   object ob;
   ob = environment(player);
   while (ob &&
          ob != _owner) {
      ob = environment(ob);
   }
   if (ob != _owner) {
      remove_this_effect();
   }
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = player->move( dest, messin, messout );
   if ( flag == MOVE_OK &&
        objectp( dest ) ) {
      call_out((: check_move_stuff :), 2);
   }
   return flag;
}

==================================================
FILE: shadows/object/newbie_shoes.c
==================================================

#include <move_failures.h>
#include "path.h"
inherit "/std/effect_shadow";
int query_orthopaedic_shoes() { return 1; }
string query_msgin()
{
return "$N stagger$s clumsily from $F.";
}
string query_msgout()
{
return "$N stagger$s $T clumsily.";
}
int move(mixed dest, string inmsg, string outmsg)
{
  int ret;
  ret = player->move(dest, inmsg, outmsg);
  if (ret == MOVE_OK) {
    tell_object( player, "You wince as spikes seem to drive themselves "
      "into the balls of your feet, but you get there eventually.\n" );
  }
  return ret;
}
int test_for_effect( object thing ) {
   return member_array( EFFECTS +"newbie_shoes",
      (string *)thing->query_wear_effects() ) != -1;
}
void taken_off(object what, string eff)
{
  if (eff != EFFECTS + "newbie_shoes")
    player->taken_off(what, eff);
  else {
    remove_this_effect();
  }
}

==================================================
FILE: shadows/object/no_save.c
==================================================

inherit "/std/effect_shadow";
mixed query_auto_load() {
   return 0;
}
mixed query_dynamic_auto_load() {
   return 0;
}
mixed query_static_auto_load() {
   return 0;
}

==================================================
FILE: shadows/object/owned_weapon.c
==================================================

inherit "/std/effect_shadow";
mixed set_holder( object thing, int pos ) {
   this_object()->remove_hide_invis( "concealed" );
   if ( objectp( thing ) )
      if ( !thing->query_corpse() &&
            ( (string)thing->query_name() != arg() ) )
         return 0;
   return (mixed)player->set_holder( thing, pos );
}
string query_owner(){
   return (string) arg();
}

==================================================
FILE: shadows/object/path.h
==================================================

#define PATH "/std/shadows/object/"
#undef EFFECTS
#define EFFECTS "/std/effects/object/"

==================================================
FILE: shadows/object/swim_fins.c
==================================================

inherit "/std/effect_shadow";
int query_skill_bonus(string skill, int true) {
  if ((skill != "other.movement.swimming") || true)
    return player->query_skill_bonus(skill);
  return player->query_skill_bonus(skill)+50;
}

==================================================
FILE: shadows/object/talker.c
==================================================

#include "path.h"
#include <talker.h>
#include <network.h>
#include <term.h>
#include <playtesters.h>
#include <language.h>
#include <cmds/options.h>
#define EMOTE_ENABLED 1
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)
inherit "/std/effect_shadow";
int do_talker_control(mixed *args, string pattern);
int do_chat(string message, string pattern, string verb);
int handle_status_command(string mode, class talker_args args);
int handle_verbose_command(string mode, class talker_args args);
int handle_history_command(string channel, class talker_args args);
int handle_colour_list(mixed *colour_args, class talker_args args);
int handle_colour_command(string channel, string new_colour, class talker_args args);
int handle_colour_on_off_command( string str_status, class talker_args args);
int handle_colour_toggle_command( class talker_args args);
int handle_echo_command( string mode, class talker_args args);
void init() {
  mixed args;
  object where;
  string channel;
  where = environment(player);
#ifdef DEBUG
  tell_creator("taffyd", "%O, %O, %O.\n", player, this_player(), where);
#endif
  if( !where )
    return;
  if (!living(where)) {
    player->init();
    return;
  }
  args = arg();
  if (!classp(args)) {
    args = new(class talker_args, status : 0, channels : ({ "one" }),
               verbose : 1, local_echo : 0, colour : 0 );
    set_arg(args);
  }
  where->add_command("talker", player,
                     ({ON_PATTERN,
                         VERBOSE_PATTERN,
                         CHANNEL_PATTERN,
                         DELETE_CHANNEL_PATTERN,
                         HISTORY_PATTERN,
                         HISTORY_CHANNEL_PATTERN,
                         LIST_PATTERN,
                         LIST_CHANNEL_PATTERN,
                         LIST_CHANNEL_PATTERN_BRIEF,
                         SET_COLOUR_PATTERN,
                         COLOUR_ON_OFF_PATTERN,
                         COLOUR_LIST,
                         TOGGLE_COLOUR_PATTERN,
                         NEW_CHANNEL_PATTERN,
                         ECHO_PATTERN,
                         "delete <string'channel'> from <direct:object'talker'>",
                         "help" }),
                     (: do_talker_control($4, $5) :) );
  where->add_command("chat", player,
                     ({ "<string'message'>" }),
                     (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
  where->add_command("chat:", player,
                     ({ "<string'message'>" }),
                     (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  if ( !( EFFECTS + "talker" )->valid( args->channels, where ) ) {
    args->channels = ({ "one" });
    set_arg(args);
  }
  foreach (channel in args->channels) {
#ifdef DEBUG
    tell_creator("taffyd", "Adding channel. %O.\n", channel);
#endif
    where->add_command(lower_case(channel), player,
                       "<string'message'>", (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
    where->add_command( lower_case(channel) + ":", player,
                        "<string'message'>",
                        (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  }
  player->init();
}
object query_player() {
  if(player && environment(player) && living(environment(player)))
    return environment(player);
  return 0;
}
int do_talker_control(mixed *args, string pattern) {
  class talker_args t_args;
  int position;
  string full_name;
#ifdef DEBUG
  tell_creator("taffyd", "Args to talker control is %O. Pattern is %O.\n",
               args, pattern);
#endif
  t_args = arg();
  switch (pattern) {
  case ON_PATTERN:
    return handle_status_command(args[0], t_args);
  case VERBOSE_PATTERN:
    return handle_verbose_command(args[0], t_args);
  case CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(), "The eyes are asleep.\n");
      return 1;
    }
    tell_object(this_player(), "You may use the following channels:\n" +
                (string)( EFFECTS +"talker" )->channels() +
                "You are on channel(s) " +
                query_multiple_short( t_args->channels ) + ".\n" );
    return 1;
    break;
  case ECHO_PATTERN:
    return handle_echo_command( args[0], t_args );
  case "delete <string'channel'> from <direct:object'talker'>":
    add_succeeded_mess( ({ "", "" }) );
  case DELETE_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
    if ( !(EFFECTS +"talker")->valid( full_name ) ) {
      tell_object(this_player(), "The eyes are not aware of that "
                  "channel.\n");
      return 1;
    }
    position = member_array(full_name, t_args->channels);
    if (position == -1) {
      tell_object(this_player(), "The eyes are not listening to "
                  "that channel.\n");
      return 1;
    }
    if (sizeof(t_args->channels) > 1) {
      t_args->channels = t_args->channels[0..position-1] +
        t_args->channels[position+1..];
      tell_object(this_player(), "The eyes sigh with relief as they "
                  "can now ignore what happens on "
                  "channel \"" + full_name + "\".\n");
    }
    else {
      tell_object(this_player(), "The eyes are bored with not listening "
                  "to any channel at all, and add channel \"one\" to their "
                  "list again.\n");
      t_args->channels = ({ "one" });
    }
    set_arg(t_args);
    break;
  case NEW_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
    (EFFECTS+"talker")->clear_cache(this_player()->query_name());
    if ( ( EFFECTS +"talker" )->valid( full_name ) ) {
      if ( member_array( full_name, t_args->channels ) != -1 ) {
        tell_object(this_player(), "The eyes frown at you; they are "
                    "already listening to that channel.\n");
        return 1;
      }
      tell_object(this_player(),  "You whisper to " +
                  player->the_short() + " and the eyes add "
                  "channel \""+ full_name +"\" to the list.\n");
      t_args->channels += ({ full_name });
      set_arg(t_args);
      this_object()->init();
    } else {
      tell_object(this_player(), "You whisper to " +
                  player->the_short() + ", but the eyes "
                  "refuse to give you that channel.\n");
      return 1;
    }
    break;
  case SET_COLOUR_PATTERN:
  case SET_COLOUR_FULL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_colour_command( args[0], args[1], t_args );
  case COLOUR_ON_OFF_PATTERN:
    return handle_colour_on_off_command( args[0], t_args );
  case TOGGLE_COLOUR_PATTERN:
    return handle_colour_toggle_command(t_args);
  case COLOUR_LIST:
    return handle_colour_list( args, t_args );
    break;
  case HISTORY_CHANNEL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_history_command(args[0], t_args);
  case HISTORY_PATTERN:
    return handle_history_command("one", t_args);
  case LIST_PATTERN:
  case LIST_CHANNEL_PATTERN:
  case LIST_CHANNEL_PATTERN_BRIEF:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    if (sizeof(args) == 1) {
      args[ 0 ] = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
      tell_object(this_player(), "The following people are using "
                  "channel \""+ args[0] + "\":\n" +
                  ( EFFECTS +"talker" )->list( args[0],
                                 pattern == LIST_CHANNEL_PATTERN_BRIEF) );
    } else
      tell_object(this_player(), "The following people are using "
                  "talkers:\n" + (string)( EFFECTS +"talker" )->list() );
    return 1;
    break;
  case "help":
  default:
    write( "Talker commands:\n\n"
           "help               : give this help file\n"
           "on|off             : switch talker on or off\n"
           "brief              : make talker use shorter messages\n"
           "verbose            : make talker use longer messages\n"
           "channels           : list valid channels\n"
           "<channel>          : switch to <channel> if valid\n"
           "delete <channel>   : switch <channel> off if valid\n"
           "list [channel]     : list users of the talker\n"
           "history [channel]  : show chat history of <channel>\n"
           "Prefix commands with \"talker\" to use, e.g. "
           "\"talker help\".  For a more detailed description type "
           "\"help talker\".\n" );
    break;
  }
  return 1;
}
int handle_history_command(string channel, class talker_args args) {
  mixed *history;
  string result;
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  if (!channel)
    channel = "one";
  if ( !( EFFECTS +"talker" )->valid( channel ) ) {
    tell_object(this_player(), "The eyes are not aware of that "
                "channel.\n");
    return 1;
  }
  tell_object(this_player(), "You whisper to " + player->the_short() +
              ", asking for the last few chats on channel " + channel + ".\n");
  history = HIST->query_chat_history(lower_case( channel ) );
  if ( !arrayp( history ) || !sizeof( history ) ) {
    tell_object(this_player(), "The eyes mutter that nothing has "
                "been said on this channel, or it is not being remembered.\n");
    return 1;
  }
  result = "$P$Channel " + channel + "$P$The eyes mutter about your bad "
    "memory.\n";
  result += implode(map(history, (: "$I$5=$C$" + $1[0] + ($1[1] ? $1[1] : "") +
                                  "%^RESET%^" :)), "\n");
  tell_object(this_player(), result);
  return 1;
}
string query_colour_status( class talker_args args ) {
  if ( !mapp( args->colour ) ) {
    return "off";
  }
  return args->colour[ "status" ];
}
int set_colour_status( class talker_args args, string status ) {
  if ( !args->colour ) {
    args->colour = DEFAULT_COLOUR_SETTINGS;
  } else {
    if ( stringp( args->colour ) ) {
      args->colour = DEFAULT_COLOUR_WITH( args->colour );
    }
  }
  args->colour[ "status" ] = status;
  set_arg( args );
  return 1;
}
int set_channel_colour(class talker_args args, string channel, string colour) {
  if ( !channel || !colour )
    return 0;
  if ( !mapp( args->colour ) ) {
    args->colour = DEFAULT_COLOUR_WITH(colour);
  }
  args->colour[ channel ] = colour;
  set_arg( args );
  return 1;
}
varargs string query_channel_colour( class talker_args args, string channel ) {
  string colour;
  if ( !mapp( args ) ) {
    return DEFAULT_COLOUR;
  }
  if ( colour = args->colour[ channel ] ) {
    return colour;
  } else {
    if ( colour = args->colour[ "default" ] ) {
      return colour;
    }
  }
  return DEFAULT_COLOUR;
}
int handle_colour_toggle_command( class talker_args args ) {
  if ( query_colour_status( args ) == "on" ) {
    return handle_colour_on_off_command( "off", args );
  }
  return handle_colour_on_off_command( "on", args );
}
int handle_colour_on_off_command( string str_status, class talker_args args ) {
  string status;
  status = query_colour_status( args );
  switch( str_status ) {
  case "on":
    if ( status == "on" ) {
      add_failed_mess( "Talker colours for $D are already on!\n" );
      return -1;
    }
    set_colour_status( args, "on" );
    add_succeeded_mess( ({ "The eyes on $D flash with " +
                             query_channel_colour( args, "default" ) +
                             "colour%^RESET%^.\n", "" }) );
    break;
  case "off":
    if ( status == "off" ) {
      add_failed_mess("Talker colours for $D have already been turned off!\n");
      return -1;
    }
    set_colour_status( args, "off" );
    add_succeeded_mess( ({ "The eyes on $D blink sadly.\n", "" }) );
    break;
  default:
    args->colour = DEFAULT_COLOUR_SETTINGS;
    set_arg( args );
    add_succeeded_mess( ({ "Talker colour settings for $D have been reset.\n",
                             "" }) );
  }
  return 1;
}
mapping create_valid_colours( string my_colours ) {
  string *colours;
  string *valid_colours = TERM_HANDLER->query_colour_codes();
  colours = map( explode( my_colours, " " ),
                 (: upper_case( $1 ) :) );
  return unique_mapping( colours,
                         (: member_array( $1, $(valid_colours) ) > -1 :) );
}
int handle_colour_command(string channel, string new_colour,
                          class talker_args args) {
  mapping colours;
  string valid_colour;
  if ( !(EFFECTS + "talker")->valid( channel ) && channel != "default" ) {
    tell_object( this_player(), "You cannot set that "
                 "channel! Use the channel name \"default\" to set "
                 "the default channel colour.\n" );
    return 1;
  }
  colours = create_valid_colours( new_colour );
  switch( sizeof( colours[ 0 ] ) ) {
  case 0:
    valid_colour = implode( map( colours[ 1 ], (: "%^" + $1 + "%^" :) ), "" );
    set_channel_colour( args, channel, valid_colour );
    add_succeeded_mess( ({ "The eyes flash with" + valid_colour +
                             " colour.%^RESET%^\n", "" }) );
    return 1;
  case 1:
    add_failed_mess( "The colour $I is invalid.\n", colours[ 0 ] );
    return -1;
  default:
    add_failed_mess( "The colours $I are invalid.\n", colours[ 0 ] );
    return -1;
  }
}
int handle_status_command(string mode, class talker_args args) {
  switch (mode) {
  case "on" :
    if ( args->status ) {
      tell_object(this_player(),  "The eyes are already alert "
                  "and listening to your every word.\n");
    } else {
      tell_object(this_player(), "The eyes open and light up "
                  "eagerly, then dim to a dull glow.\n");
      args->status = 1;
    }
    break;
  case "off" :
    if ( !args->status ) {
      tell_object(this_player(), "You notice that the eyes are "
                  "already closed, so you wake them up again "
                  "in order to tell them to go to sleep.\n");
    } else {
      tell_object(this_player(), "The eyes slowly lose their "
                  "glow as they close.\n");
      args->status = 0;
    }
    break;
  }
  set_arg(args);
  return 1;
}
int handle_verbose_command(string mode, class talker_args args) {
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  switch (mode) {
  case "brief":
    if ( !args->verbose ) {
      tell_object(this_player(), "The eyes ignore you completely.\n");
    } else {
      tell_object(this_player(), "The eyes seem sad as they dim "
                  "slightly.\n");
      args->verbose = 0;
    }
    break;
  case "verbose":
    if ( args->verbose ) {
      tell_object(this_player(),  "The eyes glitter at you "
                  "angrily.  They already know that they are to "
                  "be verbose.\n");
    } else {
      tell_object(this_player(), "The eyes light up happily for "
                  "a moment.\n");
      args->verbose = 1;
    }
    break;
  }
  set_arg(args);
  return 1;
}
void receive(string channel, string sender, string text, object *receivers) {
  class talker_args args;
  string *ignoring;
  object where;
  string colour;
  string txt;
  if(!player || !environment(player) )
    return;
  where = environment(player);
  args = arg();
  if (args && !classp(args))
    return;
  if (!args || !args->status || !living(where) || !interactive(where))
    return;
  if(member_array(channel, map(args->channels, (: lower_case($1) :)) ) == -1) {
    return;
   }
  if ( channel == "intermud" && where->query_creator() ) {
    return;
  }
  if ( file_name( previous_object( 1 ) ) == "/secure/cmds/creator/exe_c" ||
       file_name( previous_object( 1 ) ) == "/secure/cmds/creator/ca_ll" ) {
    if ( this_player(1) && this_player(1)->query_creator() &&
         !this_player(1)->query_property( "talker cheat" ) ) {
      txt = this_player(1)->query_name() +
        " made " + sender + " chat \"" + text + "\" on "
        "channel " + channel;
      user_event( "inform", txt, "cheat" );
      log_file( "/d/admin/log/TALKER", txt + "\n" );
      this_player(1)->add_property( "talker cheat", 1, 3 );
    }
  }
  ignoring = where->query_property("ignoring");
  if (ignoring && member_array(lower_case(sender), ignoring) != -1 ) {
    return;
  }
  if(player->query_property(SHORTHAND_OUTPUT_PROP))
    text = LANGUAGES->fix_shorthand(text);
  if ( args->verbose ) {
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying: " + text;
#ifdef EMOTE_ENABLED
    }
#endif
  } else {
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps: " +text;
#ifdef EMOTE_ENABLED
    }
#endif
  }
  if ( stringp( args->colour ) ) {
    colour = args->colour;
  }
  if(mapp(args->colour) && query_colour_status( args ) == "on") {
    if (!( colour = args->colour[ channel ] ) ) {
      if(!(colour = args->colour[(EFFECTS + "talker")->
                                normalise_name(channel)])) {
        colour = args->colour[ "default" ];
        if ( !colour ) {
          colour = DEFAULT_COLOUR;
        }
      }
    }
  } else {
    colour = "";
  }
  tell_object(where, colour +  "$I$5=$C$"+ text + "%^RESET%^\n" );
#ifdef NOISY
  if(receivers && sizeof(receivers) && !where->query_invis() &&
     environment(where) && base_name(environment(where)) != "/room/rubbish") {
    receivers = map(receivers, (: $1->query_player() :));
    receivers += ({ this_player() });
    tell_room(environment(where),
              "A wispy voice comes from " + player->poss_short(1) + ".\n",
              receivers);
  }
#endif
}
int do_chat(string message, string pattern, string verb) {
  class talker_args args;
  object *things, *receivers;
  string sender;
#ifdef DEBUG
  tell_creator("taffyd", "Message is %s, pattern is %s, verb is "
               "%s.\n", message, pattern, verb);
#endif
#ifdef EMOTE_ENABLED
  if ( verb[ <1 ] == ':' ) {
    verb = verb[0..<2];
  }
#endif
  if (pattern == "into <direct:object>") {
    add_succeeded_mess("$N whisper$s lovingly to $D.\n");
    return 1;
  }
  args = arg();
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  while (strsrch(message, "%^") != -1) {
    message = replace(message, ({ "%^", "" }) );
  }
  if(member_array( verb, map(args->channels, (: lower_case($1) :)) ) == -1 &&
     verb != "chat") {
    return 0;
  }
  if(this_player()->query_property("no talker")) {
    add_failed_mess("Sorry, you are not allowed to use a talker.\n");
    return 0;
  }
  if(environment(this_player()) &&
     environment(this_player())->query_property("no talker")) {
    if(stringp(environment(this_player())->query_property("no talker")))
      add_failed_mess(environment(this_player())->query_property("no talker"));
    else
      add_failed_mess("Your talker doesn't seem to work here.\n");
    return 0;
  }
  if (this_player()->query_property("gagged")) {
    add_failed_mess("You have been gagged!  You cannot chat until "
                    "your gag is removed.  Perhaps you should talk to a "
                    "creator about this.\n");
    return 0;
  }
  if (environment(player) != this_player()) {
    add_failed_mess("You're too far away from $D to whisper into it.\n");
    return 0;
  }
  if (verb == "chat") {
    if (member_array("one", args->channels) == -1) {
      verb = args->channels[0];
    }
    else {
      verb = "one";
    }
  }
  sender = this_player()->query_cap_name();
  message = replace(message,
                    ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                         "[D", "", "%^", " " }));
  if(this_player()->query_property(SHORTHAND_PROP))
    message = LANGUAGES->fix_shorthand(message);
  things = children( PATH + "talker" );
  if ( args->local_echo ) {
    things -= ({ find_object( PATH + "talker" ) });
  } else {
    things -= ({ this_object(), find_object( PATH + "talker" ) });
  }
  tell_object(this_player(), "You whisper into " + player->the_short() +
              ".\n");
  if(!this_player()->query_invis() &&
     base_name(environment(this_player())) != "/room/rubbish" ) {
    receivers = map(things, (: $1->query_player() :));
    receivers += ({ this_player() });
    tell_room(environment(this_player()), this_player()->one_short(1) +
              " whispers into " + this_player()->query_possessive() +
              " " + player->short() + ".\n", receivers);
  }
  things->receive(verb, sender, message, things);
  if( verb == "intermud" ) {
    if (message[0] == '@' || message[0] == ':') {
      user_event( "intermud_tell", sender + " ", message[1..], "dwchat" );
      message = "$N " + message[1..];
      SERVICES_D->eventSendChannel(sender, "discworld-chat", message, 1);
    } else {
      SERVICES_D->eventSendChannel( sender, "discworld-chat", message, 0 );
      user_event( "intermud_tell", sender +": ", message, "dwchat" );
    }
  }
  if ( verb == "playtesters" ) {
    if ( !this_player()->query_creator() &&
         !PLAYTESTER_HAND->query_playtester(this_player()->query_name()) ) {
      args->channels -= ({ "playtesters" });
      set_arg(args);
      add_failed_mess("You're no longer a playtester!\n");
      return 0;
    }
  }
#ifdef EMOTE_ENABLED
  if ( message[0] == '@' || message[0] == ':' ) {
    HIST->add_chat_history( verb , sender +" wisped that " +
                            this_player()->query_pronoun() + " ",
                            message[1..] );
  } else {
#endif
    HIST->add_chat_history( verb , sender +" wisped: ", message );
#ifdef EMOTE_ENABLED
  }
#endif
  return 1;
}
void remove_effect_shadow( int i ) {
  if ( i == id ) {
    if ( player && environment( player ) ) {
      environment( player )->remove_object( player, 1 );
      init();
    }
  }
  ::remove_effect_shadow( i );
}
protected string format_channel_colour( string colour ) {
  return colour +
    lower_case( replace_string( implode( explode( colour, "%^%^" ), " " ),
                                "%^", "" ) ) + "%^RESET%^";
}
int handle_colour_list(mixed *colour_args, class talker_args args) {
  string channel;
  if (!mapp(args->colour) || query_colour_status( args ) == "off" ) {
    add_failed_mess( "You currently have talker colours disabled.  Use "
                     "\"talker colour on\" to turn them on.\n" );
    return 0;
  }
  foreach( channel in args->channels ) {
    if ( args->colour[ channel ] ) {
      tell_object( this_player(),
                   "Channel " + channel + " is " +
                   format_channel_colour( args->colour[ channel ] ) + ".\n");
    }
  }
  if ( args->colour[ "default" ] ) {
    tell_object( this_player(),
                 "The default talker colour is " +
                 format_channel_colour( args->colour[ "default" ] ) + ".\n");
  }
  return 1;
}
int handle_echo_command( string mode, class talker_args args) {
  int current;
  current = args->local_echo;
  if ( current ) {
    if ( mode == "on" ) {
      add_failed_mess( "Talker echo is already on for $D!\n" );
      return -1;
    }
    args->local_echo = 0;
    add_succeeded_mess( ({ "The eyes on $D flash slowly.\n", "" }) );
  } else {
    if ( mode == "off" ) {
      add_failed_mess( "Talker echo is already off for $D!\n" );
      return -1;
    }
    args->local_echo = 1;
    add_succeeded_mess( ({ "The eyes on $D flash twice rapidly.\n",
                             "" }) );
  }
  set_arg( args );
  return 1;
}

==================================================
FILE: shadows/disease/flu_shadow.c
==================================================

inherit "/std/effect_shadow";
string *soulverb;
string *souladverb;
int query_flu(){ return 1; }
string flusoul(){
   string flu;
   soulverb = ({"sneeze",
                "cough"
   });
   souladverb = ({"violently",
                "loudly",
                "suddenly"
   });
this_player()->force_soul_command(soulverb[random(sizeof(soulverb))]+" "+souladverb[random(sizeof(souladverb))]);
   return flu;
}
int look_me(string arg){
   if(!arg){
      if (random(100) > 30){
         tell_object(player, "You feel dizzy and bleary eyed.\n");
      }
      else{
         player->look_me();
      }
      return 1;
   }
   return 1;
}
int attack_ob(object obj){
   object *contents;
   object target;
   if(random(100) > 30){
      tell_object(player, "You feel too ill, and can't be bothered to attack.\n");
      return 1;
   }
   player->attack_ob(target);
   return 1;
}
int cast(string str){
   if(random(100) > 50){
      tell_object(player, "You lose your concentration as you feel a "+
                          "sneeze coming on.\n");
      this_player()->force_soul_command("sneeze");
      return 1;
   }
   player->cast(str);
   return 1;
}

==================================================
FILE: shadows/disease/headache_shadow.c
==================================================

inherit "/std/effect_shadow";
int query_special_manoeuvre() {
   tell_object(player, "Your head hurts too much to try anything.\n");
   return 0;
}
int command_shadowed(string verb, string arg){
   if(verb=="cast"){
     write("Your head hurts too much to muster your might.\n");
     return 1;
   }
   return player->command_shadowed(verb, arg);
}

==================================================
FILE: shadows/curses/alone.c
==================================================

inherit "/std/effect_shadow";
int query_blinded() {
   return 1;
}

==================================================
FILE: shadows/curses/antisqeal.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix =  ({
"kewl", "cool",
"l33t", "elite",
" ur ", "your",
" r ", " are ",
" u ", " you ",
" y ", " why ",
"2", "two",
"4", "for",
"sum", "some",
"wut", "what",
"z", "s",
"Z", "s",
"k", "c",
"K", "c",
"wif", "with",
"werk", "work" });
#ifdef 0
string mangle_speech( string s ) {
    string s1;
    s1 = player->mangle_speech( s ); return replace( " " + (stringp(s1)?s1:s),
    replace_matrix)[1..10000]; }
#endif
string mangle_chat( string s ) {
  return replace(s, replace_matrix);
}

==================================================
FILE: shadows/curses/chef_curse.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
string mangle_speech( string s ) {
    string s1;
    s1 = player->mangle_speech( s );
    return replace( " " + (stringp(s1)?s1:s), replace_matrix)[1..10000];
}

==================================================
FILE: shadows/curses/deaf_shadow.c
==================================================

inherit "/std/effect_shadow";
#include "effect.h"
void event_whisper(object ob, string start, string mess, object *d, string lang) {
   int i;
   i = (int)arg() / 2;
   if (random(100) < i) {
      player->event_whisper(ob, start, mess, d, lang);
   } else {
      player->add_message(ob, "$N %hiss% something at you, but you just "+
"can't make it out.\n", 1);
   }
}
void event_person_say(object ob, string start, string mess, string lang) {
   string dum1, dum2;
   if (sscanf(start, "%sloud%s", dum1, dum2)) {
      if (random(100) > (100 - (int)arg()) / 2) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something loudly, but "+
"you fail to hear it properly.\n", 1);
      }
   } else {
      if (random(100) < arg()) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something, but you just can't "+
   "hear it properly.\n", 1);
      }
   }
}
void event_person_say_new(object ob, string start, string mess, string lang,
  mixed avoid) {
   tell_object(player, sprintf("New Say: %O %O %O %O %O\n", ob, start, mess, lang, avoid));
}

==================================================
FILE: shadows/curses/ensmurfed.c
==================================================

inherit "/std/effect_shadow";
varargs string short(int dark) {
   if (player)
     return player->short(dark)+"smurf";
   return "Smurf curse shadow";
}
mixed query_short() { return player->query_short()+"smurf"; }
mixed query_long() { return "This is a small blue humanoid.\n"; }
int query_female() { return 0; }
int query_gender() { return 0; }
int query_male() { return 0; }
int query_neuter() { return 1; }
string query_gender_string() { return "smurf"; }
string query_gender_title() { return "smurf"; }
string query_objective() { return "it"; }
string query_possessive() { return "its"; }
string query_pronoun() { return "it"; }
string long(string str, int dark) {
   string s, guild_ob;
   s = "You see "+ query_short();
   guild_ob = player->query_guild_ob();
   if (guild_ob)
      s += " "+ (string)guild_ob->query_title( this_object() ) +".\n";
   else
      s += ".\n";
   s += "It is a small blue humanoid wearing white trousers.\n";
   s += capitalize(query_pronoun())+" "+player->health_string()+".\n";
   s += player->calc_extra_look();
   s += player->weather_extra_look();
   s += player->query_living_contents(0);
   return s;
}
string smurf( string str ) {
   string str1;
   if ( sscanf( str, "%s,", str ) ) str1 = ",";
   else if ( sscanf( str, "%s.", str ) ) str1 = ".";
   else if ( sscanf( str, "%s!", str ) ) str1 = "!";
   else if ( sscanf( str, "%s;", str ) ) str1 = ";";
   else str1 = "";
   if ( sscanf( str, "%sing", str ) ) str = "smurfing";
   else if ( sscanf( str, "%sd", str ) ) str = "smurfed";
   else if ( sscanf( str, "%ss", str ) ) str = "smurfs";
   else str = "smurf";
   return str + str1;
}
string mangle_speech( string str ) {
   string tmp, *bits;
   int i;
   tmp = player->mangle_speech( str );
   if( !tmp ) tmp = str;
   bits = explode(tmp, " ");
   for (i=1;i<sizeof(bits);i+=3) {
      bits[i] = smurf( bits[i] );
   }
   tmp = implode(bits, " ");
   return tmp;
}

==================================================
FILE: shadows/curses/ken_curse.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix;
mapping trans;
void create() {
  replace_matrix = ({
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });
  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
}
string mangle_speech(string str) {
  string tmp, *bits;
  mixed erp;
  int i;
  tmp = player->mangle_speech( str );
  tmp = replace(" "+(stringp(tmp)?tmp:str)+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
}

==================================================
FILE: shadows/curses/no_player_title.c
==================================================

#include <effect.h>
inherit "/std/effect_shadow";
varargs int add_property(string var, mixed val, int tim) {
    if ( var == "player_title" ) {
        tell_object( player, "You are not allowed to have a player title.\n" );
        return 0;
    }
    return player->add_property( var, val, tim );
}
mixed query_property( string prop ) {
    if ( prop == "player_title" ) {
        return 0;
    }
    return player->query_property( prop );
}
void bing() {
player->submit_ee2( player->sid_to_enum( id ), "spam", 5, EE_CONTINUOUS );
}

==================================================
FILE: shadows/room/hat_tent.c
==================================================

inherit "/std/effect_shadow";
int query_keep_room_loaded() {
   return 1;
}
int dont_free() {
   return 1;
}
int clean_up() {
   return 1;
}
void tent_collapsed() {
   remove_this_effect();
}

==================================================
FILE: shadows/room/terrain_dont_unload.c
==================================================

inherit "/std/effect_shadow";
#define BP tell_object( find_player("gerbil"), "BP.\n");
int i;
int dont_free() {return 1;}
void setup_shad() {
    i++;
}
string test_my_effect() {return "Yup!";}
void ditch_room() {
    if( !--i ) {
        remove_this_effect();
    }
}

==================================================
FILE: shadows/npc/basilisk_stare.c
==================================================

#include <move_failures.h>
inherit "/std/effect_shadow";
int query_basil_stare_shad(){ return 1; }
string query_passed_out_message()
{
  string *msgs = ({
    "The eyes!  They're burning!  Can't think!\n",
    "Your concentration is too fragmented.\n",
    "Why do that when you can just sit here and fall into those eyes?\n",
    "Arrrrgghhhh!  Too much pain!\n"
    }) ;
  return msgs[random(sizeof(msgs))];
}
int move_with_look(object dest, string messin, string messout)
{
   tell_object(player, "Your mind is not here to help you control "+
                       "your movement.\n");
   return MOVE_NO_DROP;
}
int attack_by(object obj)
{
   if( !obj || ( !obj->one_short() ) ) {
      tell_room( environment( player ), player->one_short() + " is totally "
         "helpless.\n", player );
   }
   else {
      tell_room(environment(player), player->one_short()+
        " is totally helpless against "+obj->one_short()+"'s attack.\n",
        player);
   }
   tell_object(player, "Oh dear! How do I defend myself? I forgot!\n") ;
   return 1;
}
int query_special_manoeuvre() { return 0; }

==================================================
FILE: shadows/npc/controlled_monster.c
==================================================

inherit "/std/effect_shadow";
int turn_chance;
object my_owner;
object my_enemy;
string leave_msg;
string enter_msg;
int summoned;
int set_enemy( object enemy );
object query_owner() { return my_owner; }
object query_enemy() { return my_enemy; }
void set_leave_msg( string mess ) { leave_msg = mess; }
void set_enter_msg( string mess ) { enter_msg = mess; }
void set_summoned( int summ ) { summoned = summ; }
void init() {
   player->init();
   if( this_player() != my_owner )
      return;
   this_player()->add_command( "help", this_object(), "<direct:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to {kill|attack} <indirect:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to protect <indirect:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to leave" );
}
int do_order( object *indir, string indir_match, string dir_match,
             mixed *args, string pattern ) {
   if( this_player() != my_owner )
      return 0;
   if( pattern == "<direct:living:here> to leave" ) {
      my_owner->add_succeeded_mess( this_object(),
                                   "$D smiles happily.\n", ({ }) );
      tell_object( my_owner,
                  (string)this_object()->the_short() +
		   " tells you: Thank you.\n");
      if ( summoned ) {
         call_out( "go_away", 1 );
      } else {
         my_owner = 0;
         call_out( "run_away", 1 );
      }
   } else if ( pattern == "<direct:living:here> to protect <indirect:living:here>" ) {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D asks you: Who do you want me to protect?\n", ({ }) );
         return 0;
      }
      tell_object( indir[ 0 ], (string)this_object()->the_short() +" tells you:  "+
                  (string)my_owner->the_short()
                  +" has asked me to protect you.\n" );
      tell_object( my_owner, (string)this_object()->the_short()
                  +" tells you: Fine.\n" );
      this_player()->add_succeeded_mess( this_object(),
                                        "$N $V $D to protect $I.\n ", ({ indir[ 0 ] }) );
      this_object()->do_command( "protect "+
				 (string)indir[ 0 ]->query_name() );
   } else {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D asks you: Who do you want me to kill?\n", ({ }) );
         return 0;
      }
      if ( !set_enemy( indir[ 0 ] ) ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D tells you: There is no way you can force me to attack $I.\n",
                                   ({ indir[ 0 ] }));
         return 0;
      };
      tell_object( my_enemy, (string)this_object()->the_short() +
		   " tells you:  "+
                  (string)my_owner->the_short()
                  +" has asked me to kill you.\nPrepare to die!\n" );
      tell_object( my_owner, this_object()->the_short() +
		   " tells you: Fine.\n" );
   }
   return 1;
}
int do_help( object *indir, string indir_match, string dir_match,
            mixed *args, string pattern ) {
   if ( this_player() != my_owner )
     return 0;
   this_player()->add_succeeded_mess( this_object(),
                                     "You can \"order\" "+
				      this_object()->the_short()
                                     +" to kill someone or to leave.\n ", ({ }) );
   return 1;
}
int set_enemy( object enemy ) {
   object *list;
   int i;
   my_enemy = enemy;
   if( my_enemy == my_owner ) {
      my_owner = 0;
      list = this_object()->query_attacker_list();
      for( i = 0; i < sizeof(list); i++ ) {
         this_object()->stop_fight( list[i] );
         (list[ i ])->stop_fight( this_object() );
         if ( !pk_check( list[ i ], my_enemy ) ) {
            (list[ i ])->attack_ob( my_enemy );
            my_enemy->attack_ob( list[ i ] );
            tell_object( list[ i ], (string)this_object()->the_short()
                        +" tells you: I will help you fight "+
                        (string)my_enemy->the_short() +".\n");
         }
      }
   } else {
      if ( pk_check( my_owner, my_enemy ) ) {
         if ( turn_chance )
           call_out( "set_enemy", 1, my_owner );
         else
           call_out( "go_away", 1);
         return 0;
      }
   }
   this_object()->attack_ob( my_enemy );
   call_out( "move_me", 1 );
   return 1;
}
int set_owner( object owner, int time, int turn) {
   if ( !owner ) return 0;
   my_owner = owner;
   turn_chance = turn;
   if ( summoned )
     call_out( "do_leave", time ) ;
   call_out( "move_me", 1 );
   return 1;
}
void event_dest_me( object ob ) {
   if ( ob == my_owner )
     call_out( "go_away", 0 );
   if ( ob == my_enemy ) {
      if ( !my_owner )
        call_out( "go_away", 0 );
      if ( my_enemy )
        tell_object( my_owner, (string)my_enemy->the_short() +" has left DiscWorld\n" );
      my_enemy = 0;
      call_out( "move_me",0);
   }
}
void event_death( object ob ) {
   if ( ob == my_enemy ) {
      if ( !my_owner ) call_out( "go_away", 0 );
      call_out( "do_tell", 0, my_owner, this_object()->query_short() +" tells you: "+
               my_enemy->the_short() +" has been killed!\n");
      my_enemy = 0;
      call_out( "move_me", 0 );
   }
}
void do_tell( object ob, string str ) {
   tell_object( ob, str );
}
void move_me() {
   if ( my_enemy ) {
      if ( environment() == environment( my_enemy ) ) return;
      player->move( environment( my_enemy ), enter_msg, leave_msg );
      tell_object( my_enemy, this_object()->the_short() +" says: You cannot escape me!\n" );
      return;
   }
   if ( my_owner ) {
      if ( environment() == environment( my_owner ) ) return;
      player->move( environment( my_owner ), enter_msg, leave_msg );
      this_object()->do_command( "protect "+ (string)my_owner->query_name() );
      this_object()->do_command( "follow "+ (string)my_owner->query_name() );
      return;
   }
   if ( summoned )
     call_out( "go_away", 0 );
   else
     call_out( "run_away", 1 );
}
int do_leave() {
   if ( my_owner ) {
      tell_object( my_owner, this_object()->the_short()
                  +" tells you:  It is time for me to leave.\n" );
      say( this_object()->the_short() +" smiles happily.\n" );
   }
   call_out( "go_away", 2 );
   return 1;
}
int attack_by( object ob ) {
   if ( summoned && !my_owner ) {
      say( this_object()->the_short()
	   +" says: I will not fight without an owner!\n");
      call_out("go_away",0);
      return 1;
   }
   if ( interactive( my_owner ) ) {
      if ( (string) ob->query_guild_ob() == "/std/guilds/priest" ) {
         tell_object( my_owner, this_object()->the_short() +" tells you: "
                     "I do not wish to kill "+ ob->the_short()+".\n");
         if ( !turn_chance ) {
            call_out( "go_away", 1 );
            return 1;
         }
         if ( random( 100 ) < turn_chance ) {
            set_enemy( my_owner );
            return 1;
         }
      }
      if ( random( 100 ) < ( turn_chance / 5 ) ) {
         set_enemy( my_owner );
         return 1;
      }
   }
   return player->attack_by( ob );
}
void event_exit( object ob ) {
   if( ob != my_owner && ob != my_enemy ) return;
   call_out( "move_me", 1 );
}
void go_away() {
  write( leave_msg );
  player->move( "/room/rubbish" );
}

==================================================
FILE: shadows/npc/death.c
==================================================

inherit "/std/effect_shadow";
int second_life() {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player);
   }
   if (!pointerp(bit) || sizeof(bit) < 3 || !bit[2]) {
      ret = player->second_life();
   }
   remove_this_effect();
   return ret;
}

==================================================
FILE: shadows/npc/dont_move.c
==================================================

inherit "/std/effect_shadow";
int cannot_walk() {
   return 1;
}

==================================================
FILE: shadows/npc/eat_corpse.c
==================================================

inherit "/std/effect_shadow";
mixed move( mixed dest, string messin, string messout ) {
   int ret;
   ret = player->move( dest, messin, messout );
   if( ret == 0 ) {
      call_out( "find_corpse", 0 );
   }
   return ret;
}
string *query_valid_bits( object corpse ) {
   object race_obj;
   string *edible_bits;
   if( !corpse )
      return ({ });
   if( !corpse->query_corpse() )
      return ({ });
   edible_bits = corpse->query_edible_bits_left();
   if( !sizeof( edible_bits ) )
      return ({ });
   race_obj = corpse->query_race_ob();
   if( !race_obj )
      return ({ });
   return filter( edible_bits,
                  (: sizeof( $(race_obj)->query_bit($1)[2] ) == 3 :) );
}
protected void find_corpse() {
   object ob, *obs;
   obs = all_inventory( environment(player) );
   foreach( ob in obs ) {
      if( sizeof( query_valid_bits(ob) ) ) {
         remove_call_out( "eat_corpse" );
         call_out( "eat_corpse", 1 + random(120), ob );
         break;
      }
   }
}
protected void eat_corpse( object corpse ) {
   string which_bit;
   string *valid_bits;
   if( !corpse ) {
      call_out( "find_corpse", 1 + random(2*60) );
      return ;
   }
   valid_bits = query_valid_bits( corpse );
   if( sizeof( valid_bits ) && environment(corpse) == environment(player) ) {
      which_bit = valid_bits[ random( sizeof( valid_bits ) ) ];
      corpse->add_bit_gone( which_bit );
      tell_room( environment( player ), "$C$" + player->the_short() +
         " tears the " + which_bit + " from " + corpse->the_short() + " and "
         "begins eating.\n" );
   }
   if( sizeof( valid_bits ) > 1 ) {
      remove_call_out( "eat_corpse" );
      call_out( "eat_corpse", 1 + random(2*60), corpse );
   } else {
      call_out( "find_corpse", 1 + random(2*60) );
   }
}
void event_enter( object ob, string mess, object from ) {
   player->event_enter( ob, mess, from );
   if( sizeof( query_valid_bits(ob) ) ) {
      remove_call_out( "eat_corpse" );
      call_out( "eat_corpse", 10, ob );
   }
}

==================================================
FILE: shadows/npc/eat_edible.c
==================================================

inherit "/std/effect_shadow";
protected void real_eat(object ob);
protected void do_eat_edible();
mixed move(mixed dest, string messin, string messout) {
  int ret;
  ret = player->move(dest, messin, messout);
  if (ret == 0) {
    call_out((: do_eat_edible :), 0);
  }
  return ret;
}
protected void do_eat_edible() {
  int i;
  object *obs;
  obs = all_inventory(player);
  for (i=0;i<sizeof(obs);i++) {
    if (obs[i]->query_edible()) {
      call_out((: real_eat :), 1, obs[i]);
    }
  }
}
protected void real_eat(object ob) {
  if (ob && player) {
    player->do_command("eat "+ob->query_name());
  }
}
void event_enter(object ob, string mess, object from) {
  player->event_enter(ob, mess, from);
  if (ob->query_edible()) {
    call_out("real_eat", 2, ob);
  }
}

==================================================
FILE: shadows/npc/enter.c
==================================================

inherit "/std/effect_shadow";
void event_enter(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_enter(ob, mess);
}

==================================================
FILE: shadows/npc/exit.c
==================================================

inherit "/std/effect_shadow";
void event_exit(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_exit(ob, mess);
}

==================================================
FILE: shadows/npc/given.c
==================================================

inherit "/std/effect_shadow";
void event_enter(object ob, string mess, object from) {
   mixed *bit = ({ });
   int ret;
   if (environment(ob) == player) {
      if(sizeof(arg()) > 1)
        bit = arg();
          else
        bit = ({ arg() });
           if (sizeof(bit) < 2)
              ret = evaluate(bit[0], player, ob, mess, from);
           else
              ret = call_other(bit[0], bit[1], player, ob, mess, from);
   }
   player->event_enter(ob, mess, from);
}

==================================================
FILE: shadows/npc/good_fighter.c
==================================================

#include <good_fighter.h>
#define LOGFILE "good_fighter"
#define CMDS "/cmds/guild-race/fighting/"
#define DEBUG
inherit "/std/effect_shadow";
#define W_ATTACKS ([ "crush"   : "crush $N with $W", \
                     "behead"  : "behead $N with $W", \
                     "impale"  : "impale $N with $W", \
                     "stab"    : "stab $N with $W", \
                     "pierce"  : "pierce $N with $W", \
                     "bash"    : "bash $N with $W", \
                     "smash"   : "smash $N with $W", \
                     "slash"   : "slash $N with $W", \
                     "slice"   : "slice $N with $W", \
                     "hack"    : "hack $N with $W", \
                     "chop"    : "chop $N with $W", \
                     "feint"   : "feint at $N with $W" ])
#define U_ATTACKS ([ "trip"    : "trip $N", \
                     "shove"   : "shove $N" ])
string *specials;
mapping weapons;
int bluntorsharp;
int dodgeorparry;
object victim;
void create()
{
  specials = ({ });
  weapons = ([ ]);
}
protected void check_skill(string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur < level)
    player->add_skill_level(skill, level - cur);
}
protected void check_add_command(string command, string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur >= level) {
    player->add_known_command(command);
    specials += ({ command });
  }
}
void good_fighter_setup()
{
  int adjust;
  int lvl;
  int *args = arg();
  if (!args || !arrayp(args) || sizeof(args) != 2)
    return;
  specials = ({ });
  bluntorsharp = args[0];
  dodgeorparry = args[1];
  lvl = player->query_level();
  check_skill("other.perception", lvl / 2);
  check_skill("other.health", lvl);
  adjust += (lvl / 3);
  if (bluntorsharp == USE_PIERCE) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl + adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_BLUNT) {
    check_skill("fighting.combat.melee.blunt", lvl + adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_SHARP) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl + adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_UNARMED) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl + adjust);
  } else {
    check_skill("fighting.combat.melee.blunt", lvl);
    check_skill("fighting.combat.melee.sharp", lvl);
    check_skill("fighting.combat.melee.pierce", lvl);
    check_skill("fighting.combat.melee.unarmed", lvl);
  }
  adjust = lvl * 2 / 3;
  if (dodgeorparry == DEFEND_DODGE) {
    check_skill("fighting.combat.dodging", lvl + adjust);
    check_skill("fighting.combat.parry", lvl - adjust);
    player->init_command("tactics response dodge", 1);
  } else if (dodgeorparry == DEFEND_PARRY) {
    check_skill("fighting.combat.dodging", lvl - adjust);
    check_skill("fighting.combat.parry", lvl + adjust);
    player->init_command("tactics response parry", 1);
  } else {
    check_skill("fighting.combat.dodging", lvl);
    check_skill("fighting.combat.parry", lvl);
    player->init_command("tactics response neutral", 1);
  }
  check_skill("fighting.combat.special", lvl / 2);
  check_skill("fighting.points", lvl * 2);
  player->init_command("tactics attitude offensive", 1);
  if (bluntorsharp != USE_BLUNT) {
    if (dodgeorparry == DEFEND_PARRY)
      check_add_command("riposte", "fighting.combat.special", 15);
    if (bluntorsharp == USE_SHARP || bluntorsharp == USE_BALANCED)  {
      check_add_command("hack", "fighting.combat.special", 15);
      check_add_command("slash", "fighting.combat.special", 15);
      check_add_command("slice", "fighting.combat.special", 75);
      check_add_command("chop", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("behead", "fighting.combat.special", 150);
    }
    if (bluntorsharp == USE_PIERCE) {
      check_add_command("stab", "fighting.combat.special", 15);
      check_add_command("pierce", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("impale", "fighting.combat.special", 150);
    }
  } else {
    check_add_command("bash", "fighting.combat.special", 15);
    check_add_command("smash", "fighting.combat.special", 75);
    if (player->query_guild_ob() == "/std/guilds/warrior")
      check_add_command("crush", "fighting.combat.special", 150);
  }
  check_add_command("feint", "fighting.combat.special", 15);
  check_add_command("trip", "fighting.combat.special", 15);
  check_add_command("shove", "fighting.combat.special", 15);
  player->add_known_command("concentrate");
}
protected int check_weapon(object weapon, string command) {
  if(!weapon->query_attack_names())
    return 0;
  switch(command) {
  case "crush":
    command = "smash";
    break;
  case "behead":
    command = "slice";
    break;
  case "impale":
    command = "impale";
    break;
  case "riposte":
    command = "slash";
    break;
  case "feint":
    return 1;
  }
  return (member_array(command, weapon->query_attack_names()) != -1);
}
void event_fight_in_progress(object attacker, object opponent)
{
  object ts, weapon;
  int chance;
  string cmd;
  ts = player;
  ts->event_fight_in_progress(attacker, opponent);
  if(ts->query_specific_gp("fighting") < 50)
    return;
  if (victim && !objectp(victim))
    victim = 0;
  if (victim && !interactive(victim))
    victim = 0;
  if (victim && environment(victim) != environment(player))
    victim = 0;
  if (victim && victim != attacker)
    return;
  if (!victim) {
    if(member_array(attacker, ts->query_attacker_list()) != -1)
       victim = attacker;
    if (!victim)
      return;
  }
  if(!sizeof(player->query_weapons()) &&
     player->query_combat_attitude() != "wimp" &&
     arg()[0] != USE_UNARMED) {
    object *shields;
    player->queue_command("tactics attitude wimp", 1);
    shields = filter(player->query_holding(), (: $1 && $1->id("shield") :));
    if(!sizeof(shields)) {
      if(player->query_race_ob() == "/std/races/troll") {
        if(!player->query_unarmed_parry())
          player->queue_command("tactics parry unarmed");
      } else {
        player->queue_command("tactics response dodge", 2);
      }
    }
  }
  chance = (player->query_level() / 12) + 5;
  if(chance > 25)
    chance = 25;
  if(sizeof(player->query_specials()))
    chance /= (sizeof(player->query_specials()) * 10);
  if(random(100) + 1 < chance) {
    string *candidates;
    int i;
    candidates = ({ });
    foreach(weapon in player->query_weapons()) {
      if(!weapons[weapon]) {
        weapons[weapon] = ({ });
        for (i = 0; i < sizeof(specials); i++)
          if(W_ATTACKS[specials[i]] && check_weapon(weapon, specials[i])) {
            weapons[weapon] += ({ replace(W_ATTACKS[specials[i]], "$W",
                                          weapon->query_short()) });
          }
      }
      candidates += weapons[weapon];
    }
    if(!weapons["unarmed"]) {
      weapons["unarmed"] = ({ });
      for(i=0; i<sizeof(specials); i++)
        if(U_ATTACKS[specials[i]])
          weapons["unarmed"] += ({ U_ATTACKS[specials[i]] });
    }
    candidates += weapons["unarmed"];
#ifdef DEBUG
#endif
    if(sizeof(candidates)) {
      cmd = replace(candidates[random(sizeof(candidates))], "$N",
                    victim->query_name());
#ifdef DEBUG
      debug_printf("Trying to perform: %O", cmd);
#endif
      player->do_command(cmd, 1);
    } else {
#ifdef DEBUG
      debug_printf("No command to perform");
#endif
    }
  }
}
mixed *stats()
{
  if (!player || !objectp(player))
    return ({ ({ "good fighter", "unattached" }) });
  return player->stats() + ({
    ({ "good fighter",
      ((bluntorsharp == USE_BLUNT) ? "blunt" :
        ((bluntorsharp == USE_PIERCE) ? "pierce" :
          ((bluntorsharp == USE_SHARP) ? "sharp" : "balanced"))) +
      ((dodgeorparry == DEFEND_DODGE) ? " dodger" :
        ((dodgeorparry == DEFEND_PARRY) ? " parrier" : " fighter")) }),
    ({ "managed commands", implode(specials, ", ") })
  });
}

==================================================
FILE: shadows/npc/gossip.c
==================================================

inherit "/std/effect_shadow";
#include <gossip.h>
mixed *_says;
private void fixup_says() {
   int i;
   int num;
   if (!_says) {
      _says = ({
    ({ "Pinkfish", "Chickens look good under ultra violet light.", }),
    ({ "Deutha", "In the woods there is a singing lemon.  It has the "
                 "answers to all the quests." }),
    ({ "Turrican", "I am not a number, I am a free womble." }),
    ({ "Ceres", "I want to be a cabbage, I want to see the sea, I want "
                "to live in rabbit land, I want to be with thee.", }),
      });
      num = random(sizeof(_says));
      while (num > 0) {
         i = random(sizeof(_says));
         _says = _says[0..i-1] + _says[i+1..];
         num--;
      }
   }
}
void event_person_say(object ob, string start, string mess, string lang) {
   int i;
   string *bits;
   string *filter;
   player->event_person_say(ob, start, mess, lang);
   if (!userp(ob)) {
      return ;
   }
   fixup_says();
   filter = GOSSIP_HANDLER->query_filter();
   bits = explode(mess, " ");
   for (i = 0; i < sizeof(bits); i++) {
      if (member_array(bits[i], filter) != -1) {
         player->event_person_say(ob, start, mess, lang);
         return ;
      }
   }
   if (_says[<1][0] != ob->query_cap_name() ||
       _says[<1][1] != mess) {
      _says += ({ ({ ob->query_cap_name(), mess }) });
   }
   if (!random(50)) {
      GOSSIP_HANDLER->add_gossip(ob->query_cap_name(), mess);
   }
}
void do_gossip_say(string str) {
   int i;
   string *stuff;
   int chance;
   if (!str) {
      str = "$name$ said: $mess$";
   }
   chance = arg();
   if (!intp(chance)) {
      chance = 5;
   }
   fixup_says();
   if (sizeof(_says) > 0 && random(chance)) {
      i = random(sizeof(_says));
      stuff = _says[i];
   } else {
      stuff = GOSSIP_HANDLER->query_random_gossip();
   }
   if (!stuff) {
      i = random(sizeof(_says));
      stuff = _says[i];
   }
   if (!stuff) {
      str = replace(str, ({ "$name$", "fluff",
                            "$mess$", "big fluff" }));
   } else {
      str = replace(str, ({ "$name$", stuff[0],
                            "$mess$", stuff[1] }));
   }
   player->do_command("say "+str);
}
mixed *query_gossip_says() {
   return _says;
}

==================================================
FILE: shadows/npc/goto_destination.c
==================================================

inherit "/std/effect_shadow";
object womble;
int done, moved;
void stopped_route() {
   if (!done) {
      mixed *rabbit;
      rabbit = arg();
      if (objectp(rabbit[0])) {
         womble = rabbit[0];
      }
      done = 1;
   }
   if (womble && environment(womble) != environment(player)) {
      if (!moved) {
         player->move(environment(womble),
                      (string)player->query_mmsgin(),
                      (string)player->query_mmsgout() );
         call_out("remove_this_effect", 0);
      } else {
         player->move_me_to(file_name(environment(womble)));
      }
   } else {
      call_out("remove_this_effect", 0);
   }
}
int move(object ob, string in_thing, string out_thing) {
   int ret;
   if (!done) {
      mixed *rabbit;
      rabbit = arg();
      done = 1;
      if (arrayp(rabbit) && objectp(rabbit[0])) {
         womble = rabbit[0];
         done = 2;
      }
   }
   ret = player->move(ob, in_thing, out_thing);
   if (!ret && womble && environment(womble) == environment(player)) {
      player->stop_following_route();
      remove_this_effect();
   }
   if (done == 2 && !womble) {
      call_out("remove_this_effect", 4);
   }
   if (!ret)
      moved = 1;
   return ret;
}

==================================================
FILE: shadows/npc/guard_duty.c
==================================================

inherit "/std/effect_shadow";
int id;
#define GOTO_DEST "/std/effects/npc/goto_destination"
int move(object ob, string in_thing, string out_thing) {
   int ret;
   ret = player->move(ob, in_thing, out_thing);
   if (ret) {
      if (id) {
         remove_call_out(id);
      }
      if  (!sizeof(player->query_following_route()) &&
           file_name(environment(player)) != arg()) {
         id = call_out(function() {
                       object *arr;
                       arr = filter(player->query_attacker_list(),
                              (: environment($1) == environment(player) :));
                       if (!sizeof(arr)) {
                          player->add_effect(GOTO_DEST, arg());
                       }
                    }, 10);
      }
   }
   return ret;
}

==================================================
FILE: shadows/npc/i_died.c
==================================================

#include <effect.h>
inherit "/std/effect_shadow";
#define CLASS "npc.death.me"
int second_life() {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player);
   }
   if (!pointerp(bit) || sizeof(bit) < 3 || !bit[2]) {
      ret = player->second_life();
   }
   player->submit_ee2( player->effects_matching(CLASS)[0], 0, 0, EE_REMOVE );
   return ret;
}

==================================================
FILE: shadows/npc/light_change.c
==================================================

inherit "/std/effect_shadow";
void event_light_change(object ob, int delta) {
   call_out("delayed_event_light_change",0, ob, delta );
}
void delayed_event_light_change(object ob, int delta) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, delta);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, delta);
   }
   player->event_light_change(ob, delta);
}

==================================================
FILE: shadows/npc/mock_block.c
==================================================

inherit "/std/effect_shadow";
string *unblock_skills( string *skills ) {
  set_arg( arg() - skills );
  if( !sizeof( arg() ) ) {
    remove_this_effect();
    return ({});
  }
  return arg();
}
int query_mock_block( string mocked ) {
  if( member_array( "all", arg() ) != -1 ) {
    return 1;
  }
  foreach( string skill in arg() ) {
    if( !strsrch( mocked, skill ) ) {
      return 1;
    }
  }
}

==================================================
FILE: shadows/npc/ngood_fighter.c
==================================================

#include <good_fighter.h>
#define LOGFILE "good_fighter"
#define CMDS "/cmds/guild-race/fighting/"
#define DEBUG
inherit "/std/effect_shadow";
#define W_ATTACKS ([ "crush"   : "crush $N with $W", \
                     "behead"  : "behead $N with $W", \
                     "impale"  : "impale $N with $W", \
                     "riposte" : "riposte $N with $W", \
                     "stab"    : "stab $N with $W", \
                     "pierce"  : "pierce $N with $W", \
                     "bash"    : "bash $N with $W", \
                     "smash"   : "smash $N with $W", \
                     "slash"   : "slash $N with $W", \
                     "slice"   : "slice $N with $W", \
                     "hack"    : "hack $N with $W", \
                     "chop"    : "chop $N with $W", \
                     "feint"   : "feint at $N with $W" ])
#define U_ATTACKS ([ "trip"    : "trip $N", \
                     "shove"   : "shove $N" ])
string *specials;
mapping weapons;
int bluntorsharp;
int dodgeorparry;
object victim;
void create()
{
  specials = ({ });
  weapons = ([ ]);
}
protected void check_skill(string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur < level)
    player->add_skill_level(skill, level - cur);
}
protected void check_add_command(string command, string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur >= level) {
    player->add_known_command(command);
    specials += ({ command });
  }
}
void good_fighter_setup()
{
  int adjust;
  int lvl;
  int *args = arg();
  if (!args || !arrayp(args) || sizeof(args) != 2)
    return;
  specials = ({ });
  bluntorsharp = args[0];
  dodgeorparry = args[1];
  lvl = player->query_level();
  check_skill("other.perception", lvl / 2);
  check_skill("other.health", lvl);
  adjust = lvl * 3 / 4;
  if (bluntorsharp == USE_PIERCE) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl + adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_BLUNT) {
    check_skill("fighting.combat.melee.blunt", lvl + adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_SHARP) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl + adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_UNARMED) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl + adjust);
  } else {
    check_skill("fighting.combat.melee.blunt", lvl);
    check_skill("fighting.combat.melee.sharp", lvl);
    check_skill("fighting.combat.melee.pierce", lvl);
    check_skill("fighting.combat.melee.unarmed", lvl);
  }
  adjust = lvl * 2 / 3;
  if (dodgeorparry == DEFEND_DODGE) {
    check_skill("fighting.combat.dodging", lvl + adjust);
    check_skill("fighting.combat.parry", lvl - adjust);
    player->init_command("tactics response dodge", 1);
  } else if (dodgeorparry == DEFEND_PARRY) {
    check_skill("fighting.combat.dodging", lvl - adjust);
    check_skill("fighting.combat.parry", lvl + adjust);
    player->init_command("tactics response parry", 1);
  } else {
    check_skill("fighting.combat.dodging", lvl);
    check_skill("fighting.combat.parry", lvl);
    player->init_command("tactics response neutral", 1);
  }
  check_skill("fighting.combat.special", lvl / 2);
  check_skill("fighting.points", lvl * 2);
  player->init_command("tactics attitude offensive", 1);
  if (bluntorsharp != USE_BLUNT) {
    if (dodgeorparry == DEFEND_PARRY)
      check_add_command("riposte", "fighting.combat.special", 15);
    if (bluntorsharp == USE_SHARP) {
      check_add_command("hack", "fighting.combat.special", 15);
      check_add_command("slash", "fighting.combat.special", 15);
      check_add_command("slice", "fighting.combat.special", 75);
      check_add_command("chop", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("behead", "fighting.combat.special", 150);
    }
    if (bluntorsharp == USE_PIERCE) {
      check_add_command("stab", "fighting.combat.special", 15);
      check_add_command("pierce", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("impale", "fighting.combat.special", 150);
    }
  }
  if (bluntorsharp == USE_BLUNT || bluntorsharp == USE_BALANCED) {
    check_add_command("bash", "fighting.combat.special", 15);
    check_add_command("smash", "fighting.combat.special", 75);
    if (player->query_guild_ob() == "/std/guilds/warrior")
      check_add_command("crush", "fighting.combat.special", 150);
  }
  check_add_command("feint", "fighting.combat.special", 15);
  check_add_command("trip", "fighting.combat.special", 15);
  check_add_command("shove", "fighting.combat.special", 15);
  player->add_known_command("concentrate");
}
protected int check_weapon(object weapon, string command) {
  if (member_array(weapon->query_command_names(), ({ command })) != -1)
    return 1;
  return 0;
}
protected int check_crush(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "smash" })) != -1)
    return 1;
  return 0;
}
protected int check_behead(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "slice" })) != -1)
    return 1;
  return 0;
}
protected int check_impale(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "pierce" })) != -1)
    return 1;
  return 0;
}
protected int check_riposte(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "slash" })) != -1)
    return 1;
  return 0;
}
void event_fight_in_progress(object attacker, object opponent)
{
  object ts, temp, weapon;
  int chance;
  string cmd, str;
  ts = player;
  ts->event_fight_in_progress(attacker, opponent);
  if (victim && !objectp(victim))
    victim = 0;
  if (victim && !interactive(victim))
    victim = 0;
  if (victim && environment(victim) != environment(player))
    victim = 0;
  if (victim && victim != attacker)
    return;
  if (!victim) {
    victim = attacker;
    if (!victim)
      return;
  }
  chance = (player->query_level() / 12) + 5;
  if(chance > 25)
    chance = 25;
  if (random(100) + 1 < chance) {
    object *holding;
    string *candidates;
    int i, j;
    candidates = ({ });
    holding = player->query_holding() - ({ 0 });
    foreach(weapon in holding) {
      if(!weapons[weapon]) {
        weapons[weapon] = ({ });
        for (i = 0; i < sizeof(specials); i++)
          if(W_ATTACKS[specials[i]]) {
            weapons[weapon] += ({ replace(W_ATTACKS[specials[i]], "$W",
                                          weapon->query_short()) });
          }
      }
      candidates += weapons[weapon];
    }
    if(weapons["unarmed"]) {
      for(i=0; i<sizeof(specials); i++)
        weapons["unarmed"] = ({ });
        if(U_ATTACKS[specials[i]])
          weapons["unarmed"] += ({ U_ATTACKS[specials[i]] });
    }
    candidates += weapons["unarmed"];
#ifdef DEBUG
#endif
    if(sizeof(candidates)) {
      cmd = replace(candidates[random(sizeof(candidates))], "$N",
                    opponent->query_name());
#ifdef DEBUG
      debug_printf("Trying to perform: %O", cmd);
#endif
      player->do_command(cmd, 1);
    } else {
#ifdef DEBUG
      debug_printf("No command to perform");
#endif
    }
  } else {
#ifdef DEBUG
    debug_printf("Not doing a special this time");
#endif
  }
}
mixed *stats()
{
  if (!player || !objectp(player))
    return ({ ({ "good fighter", "unattached" }) });
  return player->stats() + ({
    ({ "good fighter",
      ((bluntorsharp == USE_BLUNT) ? "blunt" :
        ((bluntorsharp == USE_PIERCE) ? "pierce" :
          ((bluntorsharp == USE_SHARP) ? "sharp" : "balanced"))) +
      ((dodgeorparry == DEFEND_DODGE) ? " dodger" :
        ((dodgeorparry == DEFEND_PARRY) ? " parrier" : " fighter")) }),
    ({ "managed commands", implode(specials, ", ") })
  });
}

==================================================
FILE: shadows/npc/no_follow.c
==================================================

inherit "/std/effect_shadow";
int add_follower(object ob) {
   call_out("do_command", 0, "lose everyone");
   return player->add_follower(ob);
}

==================================================
FILE: shadows/npc/pub_brawl.c
==================================================

inherit "/std/effect_shadow";
void event_pub_brawl(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_pub_brawl(ob, mess);
}

==================================================
FILE: shadows/npc/savage_corpse.c
==================================================

inherit "/std/effect_shadow";
mixed move(mixed dest, string messin, string messout) {
   int ret;
   ret = player->move(dest, messin, messout);
   if (ret == 0) {
      call_out("do_savage_corpse", 0);
   }
   return ret;
}
protected void do_savage_corpse() {
   int i;
   object *obs;
   obs = all_inventory(environment(player));
   for (i = 0; i < sizeof(obs); i++) {
      if (obs[i]->query_corpse() &&
          sizeof(obs[i]->query_edible_bits_left()) > 0) {
         remove_call_out("real_savage");
         call_out("real_savage", 1 + random(120), obs[i]);
         break;
      }
   }
}
protected void real_savage(object ob) {
   string *bits;
   object bit;
   int i;
   if (!ob) {
      call_out("do_savage_corpse", 1 + random(2*60));
      return ;
   }
   bits = ob->query_edible_bits_left();
   if (sizeof(bits) > 0 && environment(ob) == environment(player)) {
      i = random(sizeof(bits));
      bit = ob->make_bit(bits[i]);
      tell_room(environment(player), capitalize(player->the_short()) +
                " rips apart " + ob->the_short() +
                " pulling off " + bit->a_short() + ".\n");
      bit->move(environment(player));
   }
   if (sizeof(bits) > 1) {
      remove_call_out("real_savage");
      call_out("real_savage", 1 + random(2*60), ob);
   } else {
      call_out("do_savage_corpse", 1 + random(2*60));
   }
}
void event_enter(object ob, string mess, object from) {
   player->event_enter(ob, mess, from);
   if (ob->query_corpse()) {
      remove_call_out("real_savage");
      call_out("real_savage", 10, ob);
   }
}

==================================================
FILE: shadows/npc/sell_stuff.c
==================================================

inherit "/std/effect_shadow";
void stopped_route() {
  object *obs;
  int i;
  mixed room;
  room = arg();
  if (pointerp(room)) {
    room = room[0];
  }
  if (file_name(environment(player)) == room) {
    obs = all_inventory(player);
    for (i=0;i<sizeof(obs);i++) {
      if (!obs[i]->query_property("start equipment"))
        call_out("sell_the_stuff", 1, obs[i]);
        call_out( "drop_the_stuff", 2, obs[ i ] );
    }
    call_out( "bury_the_stuff", 3, query_multiple_short( obs ) );
  }
  call_out("remove_this_effect", 4);
}
protected void sell_the_stuff(object ob) {
  player->do_command("sell "+ob->query_name());
}
protected void drop_the_stuff( object thing ) {
   player->do_command( "drop "+ (string)thing->query_name() );
}
protected void bury_the_stuff( string words ) {
   player->do_command( "bury "+ words );
}

==================================================
FILE: shadows/npc/spell_effects.c
==================================================

inherit "/std/effect_shadow";
void do_spell_effects(object ob) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob);
   }
   player->do_spell_effects(ob);
}

==================================================
FILE: shadows/npc/they_died.c
==================================================

inherit "/std/effect_shadow";
void event_death(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_exit(ob, mess);
}

==================================================
FILE: shadows/npc/uu_staff_protection.c
==================================================

inherit "/std/effect_shadow";
#define HANDLER "/obj/handlers/guild_things/punishment_handler"
mixed info = ({":thinks you should contact a creator. Something is wrong.",
     ":thinks you should contact a creator. Something is wrong.",
     ":thinks you should contact a creator. Something is wrong.", 0});
int attack_by(object thing){
      info = arg();
      if(!thing->query_property("player")){
         return 1;
      }
      if(thing->query_property("Wizard attack") != player->query_name()){
         if(info[0] != 0)
            player->do_command(info[0]);
         if(info[3] <= 0)
            info[3] = 1;
         HANDLER->add_offender(thing->query_name(), "attacking "+
            player->the_short(), info[3]);
         thing->add_property("Wizard attack", player->query_name(), 600);
   }
   return 1;
}
void event_enter(object ob, string mess, object from){
      string name = ob->query_name();
      int bing;
      if(!ob->query_property("player")){
         return;
      }
      bing = (HANDLER->query_no_offences(name));
      info = arg();
      if(bing){
         if(info[1] != 0)
            player->init_command(info[1], 1);
         if(HANDLER->query_unpunished(name)){
            if(info[2] != 0)
               player->init_command(info[2], 1);
            HANDLER->punishment(name);
         }
      }
     player->event_enter(ob, mess, from);
}

==================================================
FILE: shadows/npc/vampirebite_shadow.c
==================================================

inherit "/std/effect_shadow";
object vamp_corpse( object corpse ) {
   string player_name;
   if( corpse && objectp( corpse )
       && !corpse->query_property( "vampire corpse" )
       && corpse->query_race_name() == "human" ) {
      corpse->add_property( "no burial", 1 );
      corpse->add_property( "vampire corpse", 1 );
      if( stringp( player->query_property( "determinate" ) ) )
         player_name = player->query_property( "determinate" ) +
            player->query_short();
      else
         player_name =
            "/global/events"->convert_message( player->a_short() );
      corpse->add_effect( "/std/effects/npc/vampirecorpse_effect",
         ({ player_name, copy( player->query_gender() ),
            copy( player->query_level() ), 0 }) );
   }
   return corpse;
}
varargs object do_death( object thing, object weapon, string attack ) {
   int *effs;
   object corpse;
   effs = player->effects_matching( "body.bite.vampire" );
   call_out( "remove_this_effect", 2 );
   corpse = player->do_death( thing, weapon, attack );
   vamp_corpse( corpse );
   return corpse;
}
object make_corpse() {
   object corpse;
   corpse = player->make_corpse();
   vamp_corpse( corpse );
   return corpse;
}

==================================================
FILE: shadows/misc/concealment.c
==================================================

object shadowed, *concealed;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   shadowed = thing;
   concealed = ({ });
}
void destruct_shadow( object thing ) {
   if ( thing == this_object() )
      destruct( this_object() );
   else
      thing->destruct_shadow( thing );
}
void add_concealed( object thing ) {
   concealed -= ({ 0 });
   if ( member_array( thing, concealed ) == -1 )
      concealed += ({ thing });
}
int set_worn_by( object thing ) {
   int weight;
   if ( thing == (object)shadowed->query_worn_by() )
      return 1;
   if ( !shadowed->set_worn_by( thing ) )
      return 0;
   weight = (int)shadowed->query_weight();
   concealed -= ({ 0 });
   foreach ( thing in concealed ) {
      if ( (int)thing->query_complete_weight() > random( weight ) )
         thing->remove_hide_invis( "concealed" );
   }
   call_out( "destruct_shadow", 0, this_object() );
   return 1;
}
mixed *stats() {
   concealed -= ({ 0 });
   return ({
      ({ "concealing", array_to_string( concealed ) })
   }) + (mixed *)shadowed->stats();
}
int query_concealing() { return 1; }

==================================================
FILE: shadows/misc/davidshad.c
==================================================

object player;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
}
void dest_shadow() { destruct( this_object() ); }
void run_away() {
  tell_object(player, "You feel too peaceful to run away.\n");
}
int pk_check( mixed thing1, mixed thing2, int off_line ) {
  return 1;
}
void start_attack(){}
void adjust_hp( int number, object attacker ) {
  if(player->query_attacker_list()) {
    foreach(attacker in player->query_attacker_list()) {
      attacker->stop_fight(player);
      player->stop_fight(attacker);
    }
  }
    return;
}
void adjust_gp( int number ) {
  if ( number < 0 )
    return player->adjust_gp( number );
  return;
}
int attack_by(object ob) {
  ob->stop_fight(player);
  player->stop_fight(ob);
  return 1;
}
