# Total Tokens: 12423
# Total Files Merged: 6
# Total Characters: 41426

herit/club_inherit.c
==================================================

inherit "/obj/handlers/inherit/club_discuss";
#define __CLUBS_H_NO_CLASSES
#define __MAIL_H_NO_CLASSES
#include <mail.h>
#include <clubs.h>
#include <player_handler.h>
#include <broadcaster.h>
#include <player.h>
#include <top_ten_tables.h>
#include <library.h>
#include <player_handler.h>
private nosave int _callout_id;
private nosave int _test_callout_id;
private string _current_test_club;
private int _last_test_time;
protected void check_extra_information(string name, string person, int startup);
void check_clubs(int startup);
class top_ten_tables {
   int num;
   int qp;
   int age;
   int start_time;
   int gender;
   int single_gender;
   int rels;
   int no_pks;
   mapping guild;
}
protected void setup_call_check_clubs(int time, int startup) {
   remove_call_out(_callout_id);
   _callout_id = call_out("check_clubs", time, startup);
}
private void send_low_balance_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         to -= ({ "unknown" });
         if (!sizeof(to)) {
            to = query_members(club);
         }
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   to = filter(to, (: PLAYER_HANDLER->test_user($1) :));
   if (sizeof(to)) {
      MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has fees due.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a reminder from the Patrician's Office "
                           "the " + bit + " '" + query_club_name(club) +
                           "' is currently in remission and "
                           "its balance will need to be updated before "
                           "the next "
                           "pay period or your " + bit + " will be "
                           "disbanded.\n\nYours happily,\nThe Patrician."));
   }
}
private void send_disband_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has been disbanded.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a message from the patricians "
                           "office to you that your " + bit +
                           " '" + query_club_name(club) +
                           "' has been disbanded for having its fees "
                           "in remission."
                           "\n\nYours happily,\nThe Patrician."));
}
protected void check_extra_information(string name,
                                       string member,
                                       int startup) {
   if (is_elected_club(name)) {
      check_elected_information(name, member, startup);
   } else if (is_family(name)) {
      check_family_information(name, member, startup);
   }
}
protected void check_club_members(string club_name,
                                string* members,
                                class top_ten_tables top_info) {
   int i;
   int tmp;
   string member;
   string str;
   string flip;
   class relationship_data *rels;
   class relationship_data frog;
   for (i = 0; i < 1 && i < sizeof(members); i++) {
      member = members[i];
      if (!PLAYER_HANDLER->test_user(member)) {
         log_file("CLUB", ctime(time()) + ": removed " + member +
                          " from " + club_name + " for not existing.\n");
         remove_member(club_name, member);
      } else if (!PLAYER_HANDLER->test_creator(member) &&
                 !PLAYER_HANDLER->test_property(member, "no score")) {
         top_info->num++;
         top_info->qp += LIBRARY->query_quest_points(member);
         tmp = -PLAYER_HANDLER->test_age(member) / (60 * 60);
         top_info->rels += sizeof(CLUB_HANDLER->query_relationships(club_name, member));
         top_info->age += tmp;
         top_info->start_time += PLAYER_HANDLER->test_start_time(member) / (60 * 60);
         str = PLAYER_HANDLER->test_guild(member);
         if (str &&
             str != "") {
            if (top_info->guild[str]) {
               top_info->guild[str]++;
            } else {
               if (file_size(str + ".c") > 0) {
                  flip = str->query_real_guild_object();
                  if (flip) {
                     str = flip;
                  }
                  top_info->guild[str]++;
               }
            }
         }
         if (PLAYER_HANDLER->test_player_killer(member)) {
            top_info->no_pks++;
         }
         if (!top_info->gender) {
            top_info->gender = PLAYER_HANDLER->test_gender(member);
         }
         if (top_info->single_gender != -1 &&
             PLAYER_HANDLER->test_gender(member) != top_info->gender) {
            top_info->single_gender = -1;
         }
      }
      if (is_family(club_name)) {
         check_family_information(club_name, member, 0);
         rels = CLUB_HANDLER->query_relationships(club_name, member);
         foreach (frog in rels) {
            if (!PLAYER_HANDLER->test_family(frog->related_to)) {
               log_file("CLUB", ctime(time()) + ": removed relationship " +
                          member +
                          " <-> " + frog->related_to + " (" +
                          frog->relationship + ") for loosing their "
                          "family.\n");
            }
         }
      }
   }
   members = members[1..];
   if (!sizeof(members)) {
      if (!sizeof(query_members(club_name))) {
         disband_club(club_name);
      } else if (top_info->num > 3) {
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_LARGEST_FAMILY,
                                         top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_FAMILY,
                                         top_info->age / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_QUEST_POINTS,
                                         top_info->qp / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_GUILD,
                                         top_info->guild);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_PKS,
                                         top_info->no_pks);
         if (top_info->single_gender != -1) {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            top_info->num);
         } else {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            0);
         }
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_LOGONS,
                                         top_info->start_time / top_info->num);
      }
      top_info = new(class top_ten_tables);
      top_info->guild = ([ ]);
      i = member_array(_current_test_club, query_clubs());
      if (i < sizeof(query_clubs())) {
         _current_test_club = query_clubs()[i+1];
         _test_callout_id = call_out("check_club_members", 60, _current_test_club, query_members(_current_test_club), top_info);
      } else {
         _current_test_club = 0;
         _test_callout_id = 0;
      }
      save_main();
   } else {
      _test_callout_id = call_out("check_club_members", 60, club_name, members, top_info);
   }
}
private nosave int _specific_callout_id = 0;
private nosave string *_clubs_to_check = ({ });
protected void check_specific_club(string club_name, int startup) {
    class club_info bing;
    bing = (class club_info)query_club_info(club_name);
    if (bing->last_touched < time() - CLUB_TIMEOUT) {
        disband_club(club_name);
        return;
    }
    if (!pointerp(query_members(club_name))) {
        disband_club(club_name);
        return;
    }
    if (query_time_fees_due(club_name) < time()) {
        if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
            send_disband_mail(club_name);
            disband_club(club_name);
            return;
        }
        if (remove_money(club_name, query_club_cost_per_period(club_name),
            CLUB_TRANSACTION_UPKEEP, "Club Dues",
            CLUB_DEFAULT_ACCOUNT_NAME, 0)) {
            int tmp;
            bing = (class club_info)query_club_info(club_name);
            tmp = bing->last_paid;
            bing->last_paid = query_time_fees_due(club_name);
            set_club_changed(club_name);
            if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
               reset_eval_cost();
               send_low_balance_mail(club_name);
            }
        }
    }
    call_out( (: check_extra_information :),  1,  club_name, 0,  startup);
}
protected void check_specific_clubs( int startup, int pos ) {
    string club_name;
    if ( pos >= sizeof( _clubs_to_check ) ) {
        _clubs_to_check = ({ });
        _specific_callout_id = 0;
        pos = 0;
        return;
    }
    club_name = _clubs_to_check[ pos ];
    tell_creator( "taffyd", "Checking club %s (%d)\n", club_name, pos );
    check_specific_club(club_name, startup);
    _specific_callout_id = call_out( (: check_specific_clubs :), 10, startup, ++pos );
}
void check_clubs(int startup) {
   class top_ten_tables blue;
   setup_call_check_clubs(24 * 60 * 60, 0);
   if ( !_specific_callout_id ) {
       _clubs_to_check = query_clubs();
        _specific_callout_id = call_out( (: check_specific_clubs :), 0,
            startup, 0 );
   }
   remove_call_out(_test_callout_id);
   if (!_current_test_club &&
       _last_test_time + 7 * 24 * 60 * 60 < time()) {
      if (sizeof(query_clubs()) > 0) {
         _current_test_club = query_clubs()[0];
      }
      _last_test_time = 0;
      save_main();
   }
   if (_current_test_club) {
      blue = new(class top_ten_tables);
      blue->guild = ([ ]);
      _test_callout_id = call_out("check_club_members",
                                 60,
                                 _current_test_club,
                                 query_members(_current_test_club),
                                 blue);
   }
}
#ifdef OLD_CHECK_CODE
protected void check_specific_club(string club_name, int extra_space,
                                   int startup) {
}
#endif

==================================================
FILE: handlers/inherit/club_personal.c
==================================================

inherit "/obj/handlers/inherit/club_basic";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
class personal_info {
}
protected void create_extra_data(string name) {
   class personal_info p_info;
   class club_info data;
   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_PERSONAL) {
         p_info = new(class personal_info);
      data->extra_data = p_info;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
}
private class personal_info query_personal_info(string name) {
   class club_info data;
   if (is_personal_club(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
   return 0;
}

==================================================
FILE: handlers/inherit/craft_skills.c
==================================================

#include <skills.h>
private string *_craft_skill_tree;
void add_craft_skill(string name);
void create() {
   _craft_skill_tree = ({ });
   add_craft_skill("crafts.smithing.gold");
   add_craft_skill("crafts.smithing.silver");
   add_craft_skill("crafts.smithing.black.tool");
   add_craft_skill("crafts.smithing.black.weapon");
   add_craft_skill("crafts.smithing.black.armour");
   add_craft_skill("crafts.smithing.gem.cutting");
   add_craft_skill("crafts.smithing.gem.polishing");
   add_craft_skill("crafts.smithing.gem.setting");
   add_craft_skill("crafts.mining.gem");
   add_craft_skill("crafts.mining.ore.panning");
   add_craft_skill("crafts.mining.mineral");
   add_craft_skill("crafts.hunting.tracking");
   add_craft_skill("crafts.hunting.fishing");
   add_craft_skill("crafts.hunting.trapping");
   add_craft_skill("crafts.carpentry.furniture");
   add_craft_skill("crafts.carpentry.coopering");
   add_craft_skill("crafts.carpentry.turning");
   add_craft_skill("crafts.carpentry.whittling");
   add_craft_skill("crafts.pottery.forming.throwing");
   add_craft_skill("crafts.pottery.forming.shaping");
   add_craft_skill("crafts.pottery.glazing");
   add_craft_skill("crafts.pottery.staining");
   add_craft_skill("crafts.pottery.firing");
   add_craft_skill("crafts.materials.leatherwork");
   add_craft_skill("crafts.materials.weaving");
   add_craft_skill("crafts.materials.spinning");
   add_craft_skill("crafts.materials.needlework");
   add_craft_skill("crafts.materials.dyeing");
   add_craft_skill("crafts.husbandry.plant.edible");
   add_craft_skill("crafts.husbandry.plant.herbal");
   add_craft_skill("crafts.husbandry.plant.milling");
   add_craft_skill("crafts.husbandry.plant.tree");
   add_craft_skill("crafts.husbandry.animal.grooming");
   add_craft_skill("crafts.husbandry.animal.breeding");
   add_craft_skill("crafts.culinary.cooking");
   add_craft_skill("crafts.culinary.baking");
   add_craft_skill("crafts.culinary.butchering");
   add_craft_skill("crafts.culinary.preserving");
   add_craft_skill("crafts.culinary.brewing");
   add_craft_skill("crafts.culinary.distilling");
   add_craft_skill("crafts.arts.design");
   add_craft_skill("crafts.arts.calligraphy");
   add_craft_skill("crafts.arts.drawing");
   add_craft_skill("crafts.arts.painting");
   add_craft_skill("crafts.arts.printing");
   add_craft_skill("crafts.arts.sculpture");
   add_craft_skill("crafts.points");
}
private mixed *add_craft_skill_int(string *bits,
                                   mixed *arr) {
   int pos;
   pos = member_array(bits[0], arr);
   if (pos == -1) {
      pos = sizeof(arr);
      arr += ({ bits[0], 0, 0, ({ }) });
   }
   if (sizeof(bits) > 1) {
      arr[pos + SKILL_BIT] = add_craft_skill_int(bits[1..],
                                                 arr[pos + SKILL_BIT]);
   }
   return arr;
}
private void add_craft_skill(string name) {
   string *bits;
   bits = explode(name, ".");
   _craft_skill_tree = add_craft_skill_int(bits, _craft_skill_tree);
}
mixed *query_crafts_skill_tree() {
   return _craft_skill_tree;
}

==================================================
FILE: handlers/inherit/distance_handler.c
==================================================

#define BAD_ROOM -1
#define TRAVEL_NOT_ALLOWED -2
#define BAD_DOMAIN -3
int* query_co_ord(string room);
private int difference(int bing, int womble){
   if (womble > bing) {
      return womble - bing;
   }
   return bing - womble;
}
private int filename_check(string one, string two){
   string dom_one;
   string dom_two;
   string alpha;
   log_file("/log/PORTAL", "Unable to get co-ords for %O %O, doing filename based check.\n", one, two);
   dom_one = explode(one, "/")[1];
   dom_two = explode(two, "/")[1];
   alpha = dom_one<dom_two?dom_one+":"+dom_two:dom_two+":"+dom_one;
   switch(alpha){
      case "am:am":
         return 3000;
      case "am:cwc":
         return TRAVEL_NOT_ALLOWED;
      case "am:ram":
         return 3000000;
      case "am:klatch":
         return 1000000;
      case "am:sur":
         return 500000;
      case "am:forn":
         return TRAVEL_NOT_ALLOWED;
      case "am:guilds":
         return 1000;
      case "cwc:ram":
      case "cwc:klatch":
      case "cwc:forn":
      case "cwc:guilds":
      case "cwc:sur":
         return TRAVEL_NOT_ALLOWED;
      case "cwc:cwc":
         return 500000;
      case "forn:forn":
         return TRAVEL_NOT_ALLOWED;
      case "forn:ram":
         return TRAVEL_NOT_ALLOWED;
      case "forn:guilds":
         return TRAVEL_NOT_ALLOWED;
      case "forn:klatch":
         return TRAVEL_NOT_ALLOWED;
      case "forn:sur":
         return TRAVEL_NOT_ALLOWED;
      case "guilds:guilds":
         return 1000;
      case "guilds:klatch":
         return 500000;
      case "guilds:sur":
         return 500000;
      case "guilds:ram":
         return 1500000;
      case "klatch:klatch":
         return 1000;
      case "klatch:sur":
         return 3300000;
      case "klatch:ram":
         return 4000000;
      case "ram:ram":
         return 500000;
      case "ram:sur":
         return 900000;
      case "sur:sur":
         return 500000;
   }
   return BAD_DOMAIN;
}
int query_distance_from_coords(int* co_ord_one, int* co_ord_two){
   float x;
   float y;
   float z;
   float distanceplane;
   float distance;
   x = difference(co_ord_one[0], co_ord_two[0]);
   y = difference(co_ord_one[1], co_ord_two[1]);
   z = difference(co_ord_one[2], co_ord_two[2]);
   distanceplane = sqrt(pow(x, 2) + pow(y, 2));
   distance = sqrt(pow(distanceplane, 2) + pow(z, 2));
   return to_int(distance);
}
int query_distance_from_rooms(mixed one, mixed two){
   mixed co_ord_one;
   mixed co_ord_two;
   if (objectp(one)) {
      one = file_name(one);
   }
   if (objectp(two)) {
      two = file_name(two);
   }
   if (one->query_co_ord()) {
      co_ord_one = one->query_co_ord();
   } else {
      co_ord_one = query_co_ord(one);
   }
   if (two->query_co_ord()) {
      co_ord_two = two->query_co_ord();
   } else {
      co_ord_two = query_co_ord(two);
   }
   if(co_ord_one == 0 || co_ord_two == 0) {
      return filename_check(one, two);
   }
   return query_distance_from_coords(co_ord_one, co_ord_two);
}

==================================================
FILE: handlers/inherit/error_handler.c
==================================================

#include <db.h>
#include <error_handler.h>
#define SAVE_FILE "/save/handlers/error_handler"
#define ERROR_SUMMARY_FIELDS "id, entrydate, filename, type, category, name, reporter, status, directory"
#define ERROR_DETAILS_FIELDS ERROR_SUMMARY_FIELDS \
                      ", report, runtime"
#define ERROR_REPLY_TIMEOUT (60 * 60 * 24 * 7 * 4)
void finish_update(int type, mixed data, function finished, string query);
private string _db;
private string _user;
private string _password;
void create() {
   unguarded( (: restore_object(SAVE_FILE) :) );
   DB_HANDLER->make_sql_request(_db, _user, _password,
                 "delete from error_replies where senddate < " +
                 (time() - ERROR_REPLY_TIMEOUT), (: 1 :));
}
protected void setup_error_handler(string user, string db, string password) {
   _user = user;
   _db = db;
   _password = password;
   save_object(SAVE_FILE);
}
protected string build_sql_query(string select_rows, class error_query query) {
   string* restrict;
   string name;
   string tmp;
   restrict = ({ });
   if (query->id != 0) {
      restrict += ({ "id = " + query->id });
   }
   if (query->dir) {
      if (query->dir[<1] == '/') {
         query->dir = query->dir[0..<2];
      }
      if (query->recursive) {
         restrict += ({ "directory like '" + query->dir + "%'" });
      } else {
         restrict += ({ "directory = '" + query->dir + "'" });
      }
   }
   if (query->assigned_to) {
      restrict += ({ "AssignedTo = '" + query->assigned_to + "'" });
   }
   if (query->reporter) {
      restrict += ({ "Reporter = '" + query->reporter + "'" });
   }
   if (query->file_name) {
      restrict += ({ "FileName = '" + query->file_name + "'" });
   }
   if (sizeof(query->type)) {
      tmp = "Type in (";
      foreach (name in query->type) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->status)) {
      tmp = "Status in (";
      foreach (name in query->status) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->category)) {
      tmp = "Category in (";
      foreach (name in query->category) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(restrict)) {
      tmp = "select " + lower_case(select_rows) + " from errors where " +
             implode(restrict, " and ");
      switch (query->order_by) {
      case ERROR_ORDER_BY_FILENAME :
         tmp += " order by filename, entrydate";
         break;
      case ERROR_ORDER_BY_DATE :
         tmp += " order by entrydate";
         break;
      case ERROR_ORDER_BY_REPORTER :
         tmp += " order by reporter, entrydate";
         break;
      case ERROR_ORDER_BY_DIRECTORY :
      default :
         tmp += " order by directory, filename, entrydate";
         break;
      }
      return tmp + " limit 150";
   }
   return 0;
}
string build_sql_update(int id, string field, mixed value) {
   string ret;
   ret = "update errors set " + field + " = ";
   if (stringp(value)) {
      ret += "'" + value + "'";
   } else {
      ret += "" + value;
   }
   ret += " where id = " + id;
   return ret;
}
class error_forward create_error_forward(mapping map) {
   class error_forward newy;
   newy = new(class error_forward);
   newy->date = map["forwarddate"];
   newy->forwarder = map["forwarder"];
   newy->old_directory = map["olddirectory"];
   return newy;
}
class error_comment create_error_comment(mapping map) {
   class error_comment newy;
   newy = new(class error_comment);
   newy->date = map["commentdate"];
   newy->commenter = map["commenter"];
   newy->comment = map["comment"];
   return newy;
}
class error_summary create_error_summary(mapping map) {
   class error_summary newy;
   newy = new(class error_summary);
   newy->id = map["id"];
   newy->entry_date = map["entrydate"];
   newy->filename = map["filename"];
   newy->category = map["category"];
   newy->assigned_to = map["assignedto"];
   newy->reporter = map["reporter"];
   newy->status = map["status"];
   newy->type = map["type"];
   newy->directory = map["directory"];
   return newy;
}
class error_details create_error_details(mapping map) {
   class error_details newy;
   newy = new(class error_details);
   newy->summary = create_error_summary(map);
   newy->fix_date = map["fixdate"];
   newy->fixer = map["fixer"];
   newy->report = map["report"];
   newy->runtime = map["runtime"];
   return newy;
}
class error_complete create_error_complete(class error_details details) {
   class error_complete newy;
   newy = new(class error_complete);
   newy->details = details;
   newy->comments = ({ });
   newy->forwards = ({ });
   newy->replies = ({ });
   return newy;
}
class error_replies create_error_replies(mapping map) {
   class error_replies reply;
   reply = new(class error_replies);
   reply->id = map["id"];
   reply->bug_id = map["bug_id"];
   reply->sender = map["sender"];
   reply->status = map["status"];
   reply->recipient = map["recipient"];
   reply->senddate = map["senddate"];
   reply->subject = map["subject"];
   reply->message = map["message"];
   return reply;
}
void finish_summary(int type, mixed data, function finished, string query) {
   class error_summary* errors;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      foreach (map in data) {
         errors += ({ create_error_summary(map) });
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_forwards(int type, mixed data, function finished,
                     class error_complete* errors, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->forwards += ({ create_error_forward(map) });
            }
         }
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_details_error_replies(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["bug_id"]) {
               detail->replies += ({ create_error_replies(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select id,forwarddate,forwarder,olddirectory from "
                     "forwards where id in " + ids +
                     " order by forwarddate",
                     (: finish_forwards($1, $2, $(finished), $(errors), $(query)) :));
   }
}
void finish_comments(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->comments += ({ create_error_comment(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select * from "
                     "error_replies where bug_id in " + ids +
                     " order by senddate",
                     (: finish_details_error_replies($1, $2, $(finished), $(errors), $(ids), $(query)) :));
   }
}
void finish_details(int type, mixed data, function finished, string query) {
   class error_complete* errors;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      str = "(";
      foreach (map in data) {
         errors += ({ create_error_complete(create_error_details(map)) });
         str += map["id"] + ",";
      }
      str = str[0..<2] + ")";
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select commentdate,commenter,comment,id "
                     "from comments where id in " + str +
                     " order by commentdate desc",
                     (: finish_comments($1, $2, $(finished), $(errors), $(str), $(query)) :));
   }
}
void finish_forward_query(int type, mixed data, function finished,
                          string user, string newdir) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (error->details->summary->directory != newdir) {
         str = "insert into forwards (id,forwarddate,forwarder,olddirectory) " +
               "values (" + error->details->summary->id + ", " + time() + ", '" +
               db_escape(user) + "', '" +
               db_escape(error->details->summary->directory) +
               "')";
         DB_HANDLER->make_sql_request(_db, _user, _password,
                     str, (: 1 :));
         str = build_sql_update(error->details->summary->id, "directory", newdir);
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                 (: finish_update($1, $2, $(finished), $(str)) :));
      } else {
         evaluate(finished, type, data);
      }
   }
}
void finish_status_query(int type, mixed data, function finished,
                         string status,
                         int nomail, string user, string subject,
                         string message) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (!nomail) {
         str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
               "values (" +
               error->details->summary->id + ", 'NEW', '" + user + "', '" +
               error->details->summary->reporter + "', " +
               time() + ", '" +
               "Change status from " + error->details->summary->status +
               " to " + status +
               "\n" + db_escape(message) + "', '" + db_escape(subject) + "')";
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                 (: 1 :) );
      }
      str = build_sql_update(error->details->summary->id, "status", status);
      if (!str) {
         return 0;
      }
      DB_HANDLER->make_sql_request(_db, _user, _password, str,
                            (: finish_update($1, $2, $(finished), $(str)) :));
   }
}
void finish_update(int type, mixed data, function finished, string query) {
   evaluate(finished, type, data, query);
}
void finish_error_replies(int type, mixed data, function finished, string query) {
   class error_replies* replies;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      replies = ({ });
      foreach (map in data) {
         replies += ({ create_error_replies(map) });
      }
      evaluate(finished, type, replies);
   }
}
int do_query_bug_summary(class error_query query, function finished) {
   string str;
   str = build_sql_query(ERROR_SUMMARY_FIELDS,
                         query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                   (: finish_summary($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_bug_details(int bug_id, function finished) {
   string str;
   class error_query query;
   query = new(class error_query);
   query->id = bug_id;
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_details($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_open_bugs_in_dir(string dir, function finished) {
   class error_query query;
   query = new(class error_query);
   query->dir = dir;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_for_fname(string fname, function finished) {
   class error_query query;
   query = new(class error_query);
   query->file_name = fname;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_by_reporter(string reporter, function finished) {
   class error_query query;
   query = new(class error_query);
   query->reporter = reporter;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_change_type(int id, string type, function finished) {
   string str;
   str = build_sql_update(id, "type", type);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_category(int id, string category, function finished) {
   string str;
   str = build_sql_update(id, "category", category);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_assign_bug_to(int id, string assigned_to, function finished) {
   string str;
   str = build_sql_update(id, "assignedto", assigned_to);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_status(int id, string status, int nomail, string subject,
                     string user, string message, function finished) {
   string str;
   class error_query query;
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_status_query($1, $2, $(finished), $(status),
                                    $(nomail), $(user), $(subject),
                                     $(message)) :));
   return 1;
}
int do_forward(int id, string user, string dir, function finished) {
   string str;
   class error_query query;
   if (!strlen(dir)) {
      return 0;
   }
   if (dir[0] != '/') {
      dir = "/" + dir;
   }
   if (dir[<1] == '/') {
      dir = dir[0..<2];
   }
   if (file_size(dir) != -2 || dir == "/") {
      return 0;
   }
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_forward_query($1, $2, $(finished), $(user), $(dir)) :));
   return 1;
}
int do_comment(int id, string user, string comment, function finished) {
   string str;
   str = "insert into comments (id,commentdate,commenter,comment) values (" +
         id + ", " + time() + ", '" + user + "', '" + db_escape(comment) +
         "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                             (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_error_replies(string recipient, int only_new, function finished) {
   string str;
   str = "select * from error_replies where recipient = '" + recipient +
         "'";
   if (only_new) {
      str += " and status = 'NEW'";
   } else {
      str += " and status != 'DELETED'";
   }
   str += " order by senddate";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_error_replies($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_status_error_reply(int id, string status, function finished) {
   string str;
   str = "update error_replies set status = '" + status + "' where id = " +
         id;
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_add_error_reply(int bug_id, string from, string to, string subject, string message) {
   string str;
   str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
         "values (" + bug_id + ", 'NEW', '" + from + "', '" + to + "', " +
         time() + ", '" +
         db_escape(message) + "', '" + db_escape(subject) + "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
           (: 1 :) );
   return 1;
}

==================================================
FILE: handlers/inherit/nomic_rules.c
==================================================

#include <nomic_system.h>
private mapping _rules;
void save_me();
int query_can_change_rule(string area, class nomic_rule rule);
class nomic_rule find_nomic_rule(string area, string creator, string text);
void create() {
   _rules = ([ ]);
}
int add_nomic_rule(string area, int type, string creator, string text) {
   int bing;
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, creator, text)) {
      return NOMIC_ERROR;
   }
   nomic_rule = new(class nomic_rule);
   bing = _rules[area]->new_type_num[type];
   nomic_rule->id = bing;
   nomic_rule->creator = creator;
   nomic_rule->type = type;
   nomic_rule->text = text;
   nomic_rule->date_created = time();
   nomic_rule->amendments = ({ });
   _rules[area]->rules += ({ nomic_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int add_nomic_rule_class(string area,
                                   class nomic_rule new_rule,
                                   int type) {
   int bing;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, new_rule->creator, new_rule->text)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   new_rule->id = bing;
   new_rule->type = type;
   _rules[area]->rules += ({ new_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int move_nomic_rule(string area, class nomic_rule rule,
                              int type) {
   int bing;
   int i;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules[i]->id = bing;
         ((class nomic_rule)_rules[area]->rules[i])->type = type;
         _rules[area]->new_type_num[type] = bing + 1;
         save_me();
         return bing;
      }
   }
   return NOMIC_ERROR;
}
int change_nomic_rule(string area, class nomic_rule rule) {
   int i;
   if (!_rules[area]) {
      return 0;
   }
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         rule->type = ((class nomic_rule)_rules[area]->rules[i])->type;
         rule->id = ((class nomic_rule)_rules[area]->rules[i])->id;
         _rules[area]->rules[i] = rule;
         save_me();
         return 1;
      }
   }
   return 0;
}
int remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         if (!query_can_change_rule(area, nomic_rule)) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
int int_remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
class nomic_rule query_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         return copy(nomic_rule);
      }
   }
   return 0;
}
class nomic_rule* query_all_nomic_rules(string area) {
   if (!_rules[area]) {
      return ({ });
   }
   return copy(_rules[area]->rules);
}
class nomic_rule find_nomic_rule(string area, string creator, string text) {
   class nomic_rule rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (rule in _rules[area]->rules) {
      if (rule->creator == creator && rule->text == text) {
         return rule;
      }
   }
   return 0;
}
int create_area(string area) {
   class nomic_area new_area;
   if (_rules[area]) {
       return 0;
   }
   new_area = new(class nomic_area);
   new_area->new_type_num = NOMIC_DEFAULT_TYPE_NUMS;
   new_area->rules = ({ });
   _rules[area] = new_area;
   return 1;
}
int query_type_number(string name) {
   switch (lower_case(name)) {
   case "immutable" :
      return NOMIC_TYPE_IMMUTABLE;
   case "general" :
      return NOMIC_TYPE_GENERAL;
   case "citizen" :
      return NOMIC_TYPE_CITIZEN;
   default :
      return NOMIC_ERROR;
   }
}
string query_type_name(int type_no) {
   switch (type_no) {
   case NOMIC_TYPE_IMMUTABLE :
      return "immutable";
   case NOMIC_TYPE_GENERAL :
      return "general";
   case NOMIC_TYPE_CITIZEN :
      return "citizen";
   default :
      return "error";
   }
}
int query_can_change_rule(string area, class nomic_rule rule) {
   return rule->type != NOMIC_TYPE_IMMUTABLE;
}
string rule_as_string(int indent, class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;
   ret = "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
          (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + " by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):\n" + rule->text +
          "\n";
   foreach (amend in rule->amendments) {
      ret += "$I$" + (indent + 10) + "=" + sprintf("%*s", indent + 3, "") +
             capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):\n" +
             amend->text + "\n";
   }
   return ret;
}
