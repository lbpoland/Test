# Total Tokens: 15920
# Total Files Merged: 31
# Total Characters: 53136

ir.c
==================================================

mixed cmd(string str) {
   string *filenames;
   int fsize, loop;
   seteuid(geteuid(this_player()));
   if (!str || str == "") {
      notify_fail("Remove what dir?\n");
      return 0;
   }
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail("No such directory : " + str + "\n");
      return 0;
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      str = filenames[loop];
      fsize = file_size(str);
      if (fsize == -1) {
         notify_fail(str + " doesn't exist.\n");
         return 0;
      }
      if (fsize != -2) {
         notify_fail(str + " is not a directory.\n");
         return 0;
      }
      if (!rmdir(str)) {
         notify_fail("Couldn't remove dir : " + str + "\n");
         return 0;
      }
   }
   write("Ok.\n");
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/sar.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int i;
  string *files;
  string s1, s2, s3, s4;
  mixed *things;
  seteuid(geteuid(this_player()));
  if ( !str ) {
    notify_fail( "Usage: sar <search_string> <replace_string> <files>\n" );
    return 0;
  }
  s4 = str[ 0 .. 0 ];
  if ( sscanf( str, s4 +"%s"+ s4 +" "+ s4 +"%s"+ s4 +" %s", s1, s2, s3 ) != 3 )
    if ( sscanf( str, "%s %s %s", s1, s2, s3 ) != 3 ) {
      notify_fail( "Usage: sar <search_string> <replace_string> <files>\n" );
      return 0;
    }
  if(strsrch(s3, "*") == -1) {
    if(sizeof(things = WIZ_PRESENT->wiz_present(s3, this_player()))) {
      s3 = file_name(things[0]);
      sscanf(s3, "%s#%*d", s3);
      if (file_size(s3) <= 0)
        s3 += ".c";
    }
  }
  files = (string *)this_player()->get_files(s3);
  if(!sizeof(files))
  {
    notify_fail("File(s) " + s3 + " not found.\n");
    return 0;
  }
  s1 = replace( s1, "^M", "\n" );
  s2 = replace( s2, "^M", "\n" );
  for (i=0;i<sizeof(files);i++)
  {
    if (file_size(files[i]) <= 0) continue;
    printf("Looking at %s.\n", files[i]);
    s4 = read_file(files[i]);
    if (s4)
    {
      s4 = replace(s4, s1, s2);
      rm(files[i]);
      write_file(files[i], s4);
    }
    else
      printf("...failed...no file\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/scorepl_ayer.c
==================================================

inherit "/cmds/base";
#define SCORE_CMD "/cmds/player/score"
int score_quests(object *obs) {
   object play;
   foreach(play in obs) {
      write("Quests score for " + play->the_short() + ":\n");
      SCORE_CMD->score_quests(play);
   }
   return 1;
}
int score_stats(object *obs) {
   object play;
   foreach(play in obs) {
      write("Stats score for " + play->the_short() + ":\n");
      SCORE_CMD->score_stats(play, "verbose");
   }
   return 1;
}
int score_normal(object *obs) {
   object play;
   foreach(play in obs) {
      write("Score for " + play->the_short() + ":\n");
      SCORE_CMD->score_normal(play, "verbose");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "quests <indirect:player>", (: score_quests($1) :),
             "stats <indirect:player>", (: score_stats($1) :),
             "<indirect:any-living>", (: score_normal($1) :) });
}

==================================================
FILE: creator/screen.c
==================================================

inherit "/cmds/base";
object target;
int cmd(object player)
{
   target = player;
   if (target == this_player())
      return notify_fail("You start to send text to yourself, "
                         "but think better of it.\n");
   if (target->check_earmuffs("remote-spam")) {
      tell_object(target, sprintf("%s tried to screen some text to you.\n",
                                  this_player()->query_short()));
      return notify_fail(target->query_short() +
                         " currently has " + target->query_possessive() +
                         " screen earmuffs on, ask " +
                         target->query_possessive() + " to turn "
                         "them off.\n");
   }
   tell_object(target, sprintf("Receiving text from %s.\n",
                               this_player()->query_short()));
   tell_object(this_player(),
               sprintf("Sending text to %s. Use ** to stop.\n]",
                       target->query_short()));
   input_to("do_screen");
   return 1;
}
void do_screen(string spam)
{
   if (spam == "**") {
      tell_object(target,
                  sprintf("Stopped receiving text from %s.\n",
                          this_player()->query_short()));
      tell_object(this_player(),
                  sprintf("Stopped sending text to %s.\n",
                          target->query_short()));
      return;
   }
   if (spam) {
      tell_object(target, "] " + spam + "\n");
      write("] ");
   }
   input_to("do_screen");
}
int screen_toggle(string toggle)
{
   if (toggle == "on") {
      if (member_array("remote-spam",
                       this_player()->query_property("earmuffs")) == -1)
         return notify_fail("You aren't earmuffing remote-spam events!\n");
      this_player()->add_property("earmuffs",
                                  (this_player()->query_property("earmuffs") -
                                   ({ "remote-spam" })));
      write("Remote-spam earmuffs off.\n");
      return 1;
   }
   if (toggle == "off") {
      if (member_array("remote-spam",
                       this_player()->query_property("earmuffs")) != -1)
         return
            notify_fail("You are already earmuffing remote-spam events!\n");
      this_player()->add_property("earmuffs",
                                  (this_player()->query_property("earmuffs") +
                                   ({ "remote-spam" })));
      write("Remote-spam earmuffed.\n");
      if (!this_player()->query_earmuffs())
         write("Remeber to \"earmuff on\" to enable them.\n");
      return 1;
   }
}
mixed *query_patterns()
{
   return ({ "<indirect:player>", (: cmd($1[0]) :),
             "{on|off}", (: screen_toggle($4[0]) :) });
}

==================================================
FILE: creator/set.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  return (int)PEOPLER->set_var(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/setmin.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if(sizeof(explode("^"+str, "$N")) < 2 ||
       sizeof(explode("^"+str, "$F")) < 2)
      return notify_fail("Must have a $N and a $F in your entry message.\n");
    TP->set_msgin(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/setmmin.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if (sizeof(explode("^"+str, "$N")) < 2)
      return notify_fail("Must have a $N in your teleport entry message.\n");
    TP->set_mmsgin(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/setmmout.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if (sizeof(explode("^"+str, "$N")) < 2)
      return notify_fail("Must have a $N in your teleport exit message.\n");
    TP->set_mmsgout(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/setmout.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if(sizeof(explode("^"+str, "$N")) < 2 ||
       sizeof(explode("^"+str, "$T")) < 2)
      return notify_fail("Must have a $N and a $T in your exit message.\n");
    TP->set_msgout(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/sh_adows.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd(object *indirect_obs) {
  object *objs, *shadows, ob, shad, nobj;
   objs = indirect_obs;
  foreach (ob in objs) {
    shadows = ({ });
     nobj = ob;
     while(nobj = shadow(nobj, 0))
       shadows += ({ nobj });
     if(!sizeof(shadows)) {
       write(WIZ_PRESENT->desc_f_object(ob) + " is not being shadowed.\n");
     } else {
       write(WIZ_PRESENT->desc_f_object(ob) + " is being shadowed by:\n");
       foreach (shad in shadows)
         write("    " + file_name(shad) + "\n");
    }
  }
  return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd( $1 ) :) });
}

==================================================
FILE: creator/show_help.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
#define WHO(n) globals[n]
private nosave mapping globals = ([]);
mixed show_help(object *player, string helpname) {
   player[0]->set_finish_func("who_did_it", this_object());
   WHO(player[0]) = capitalize(this_player()->query_name());
   if (!player[0]->eventForce("help "+ helpname)) {
      map_delete(globals, player[0]);
      return notify_fail("The help command failed ... Did you specify the "
              "correct help subject ?\n");
   }
   event(users(), "inform", capitalize(this_player()->query_name())+
         " showed help on \"" + helpname + "\" to " + player[0]->the_short(),
         "help");
   write("Okay, showed help on \"" + helpname + "\" to " +
         player[0]->query_cap_name() + ".\n");
   PLAYERINFO_HANDLER->add_entry(this_player(),
                                 player[0]->query_name(),
                                 "showhelp",
                                 "Showed help on " + helpname,
                                 0);
   return 1;
}
int who_did_it() {
   tell_object(previous_object(), WHO(previous_object()) +
         " wanted you to read this help file.\n");
   map_delete(globals, previous_object());
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player> <string'help file'>",
             (: show_help($1, $4[1]) :) });
}

==================================================
FILE: creator/shutdown.c
==================================================

inherit "/cmds/base";
mixed cmd(int tim, string reason, int force) {
  string str;
  seteuid(geteuid(this_player()));
  str = (string)this_player()->query_name()+" at "+ctime(time());
#ifdef GAME_LOG
  log_file("GAME_LOG", "Game shutdown by ");
  log_file("GAME_LOG", str);
  log_file("GAME_LOG", " for\n");
  log_file("GAME_LOG", num + " " + reason);
  log_file("GAME_LOG", "\n\n");
#endif
  write("Ok... shutting down game... \n");
  if (tim < 10 && (!master()->query_lord(geteuid(this_object())) && !force)) {
    tim = 10;
  }
  if (!tim) {
    "/obj/shut"->end_it_all(reason);
  } else {
    "/obj/shut"->shut(tim, reason);
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<number'number of minutes'> <string'reason'>",
              (: cmd($4[0], $4[1], 0) :),
              "now <string'reason'>", (: cmd(0, $4[0], 1) :),
              });
}

==================================================
FILE: creator/sne_tstat.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#include <peopler.h>
mixed cmd(string str) {
   mixed *bing;
   bing = (mixed *)this_player()->query_property("netstat list");
   if (!bing) {
     bing = SN_DEFAULT;
   }
   (int)PEOPLER->do_command( bing, str,
                         (: strcmp(query_ip_number($1), query_ip_number($2)) :) );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/snoop.c
==================================================

inherit "/cmds/base";
int do_snoop_cancel() {
  seteuid(geteuid(this_player()));
  if (!query_snooping(this_player()))
    write("You aren't snooping anyone.\n");
  else  {
    snoop(this_player(), 0);
    write("Ok, snoop cancelled.\n");
  }
  return 1;
}
int do_snoop(object *obs) {
  object targ;
  targ = obs[0];
  if(!snoop(this_player(), targ)) {
    notify_fail("You fail to snoop " + targ->the_short() + ".\n");
    return 0;
  }
  write("Ok, snooping "+targ->the_short()+".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: do_snoop($1) :),
            "", (: do_snoop_cancel() :) });
}

==================================================
FILE: creator/snoope_rs.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *obs;
  int i;
  obs = (object *)PEOPLER->get_people(str);
  obs = filter_array(obs, "check_snoop", this_object());
  if (!sizeof(obs)) {
    notify_fail("No one is being snooped by anyone.\n");
    return 0;
  }
  for (i=0;i<sizeof(obs);i++)
    write(obs[i]->query_cap_name()+" is snooping "+
          obs[i]->query_snoopee()->query_cap_name()+".\n");
  return 1;
}
int check_snoop(object ob) {
  if((object)ob->query_snoopee())
    return 1;
  else
    return 0;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/sockets.c
==================================================

inherit "/cmds/base";
mixed cmd(string ) {
  this_player()->more_string(dump_socket_status());
  return 1;
}

==================================================
FILE: creator/spell.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "Matches for " + word + ": None.\n");
      } else {
         tell_object(player, "Matches for " + word + ": " +
                             query_multiple_short(map(results, (: $1[1] :))) +
                             "\n");
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->spell_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   add_succeeded_mess("$N look$s up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/sql.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
private mapping fd = ([]), com = ([]);
#define FD fd[this_player()]
#define COM com[this_player()]
void prompt(string db, string user, string pass, object player){
   if(!strlen(COM)) {
      tell_object(player, "sql> ");
   } else {
      tell_object(player, "  -> ");
   }
   input_to("main", 0, db, user, pass);
}
int cmd(string arg, string user, string passwd){
   string err;
   if(!passwd){
      passwd = "";
   }
   if(!user){
      user = CONFIG_DB_USER;
   }
   if (stringp(err)){
      return notify_fail(err);
   }
   write("Welcome to the " + mud_name() + " SQL monitor.  Commands end with ; .\n\nType 'help' for help."
        "\n\n");
   COM = "";
   prompt(arg, user, passwd, this_player());
   return 1;
}
void finish_query(int result, mixed params, string db, string user,
                  string passwd, object player) {
   mapping row;
   string *keys;
   string key;
   if (result != DB_SUCCESS) {
      tell_object(player, "Failed: " + params + ".\n");
      return ;
   }
   foreach (row in params) {
      if (!keys) {
         keys = keys(row);
         foreach (key in keys) {
            tell_object(player, key + "   ");
         }
      }
      foreach (key in keys) {
         tell_object(player, row[key] + "   ");
      }
      tell_object(player, "\n");
   }
   prompt(db, user, passwd, player);
}
void main(string input, string db, string user, string passwd){
   if(strlen(input)) {
      while(input[<1] == ' ') {
         input = input[0..<2];
      }
      while(input[0] == ' ') {
         input = input[1..];
      }
   }
  switch(input){
  case "clear":
    COM = "";
    return prompt(db, user, passwd, this_player());
  case "edit":
    this_player()->do_edit(COM, "edfin", this_object(), 0, ({ db, user, passwd }));
    return;
  case "quit":
    printf("Use 'exit' to quit.\n");
    return prompt(db, user, passwd, this_player());
  case "exit":
    map_delete(fd, this_player());
    map_delete(com, this_player());
    return;
  case "help":
    printf(@END
'help' prints this help.
'clear' clears the command you are working on.
'edit' enters the editor so you can edit your query.
'exit' quits sql.
END);
    return prompt(db, user, passwd, this_player());
  default:
    if(strlen(input) && input[<1] == ';'){
      COM += input[0..<2] + "\n";
      DB_HANDLER->make_sql_request(db, user, passwd, input,
                                  (: finish_query($1, $2, $(db), $(user), $(passwd), $(this_player())) :));
      input_to("main", db, user, passwd);
      COM="";
     tell_creator ("drakkos", "Bing %s.\n", input);
      return ;
    } else {
      COM += input + "\n";
    }
    prompt(db, user, passwd, this_player());
  }
}
void edfin(string input, string* args){
  COM=input;
  prompt(args[0], args[1], args[2], this_player());
}
mixed *query_patterns() {
   return ({ "<word'database'>", (:cmd($4[0], CONFIG_DB_USER, 0) :),
            "<word'database'> -u <word'user'>", (:cmd($4[0], $4[1], 0):),
            "<word'database'> -u <word'user'> -p <word'password'>",
                                    (:cmd($4[0], $4[1], $4[2]):)});
}

==================================================
FILE: creator/sqlcmd.c
==================================================

#include <db.h>
#include <config.h>
mapping *results;
void set_results( int flag, mapping *res, object who);
int cmd( string db, string query ) {
  DB_HANDLER->make_sql_request( db, CONFIG_DB_USER, "", query,
  (: set_results( $1, $2, $(this_player()) ) :) );
  return 1;
}
void set_results( int flag, mapping *res, object who ) {
  tell_creator( who, "flag: %O\n%O\n", flag, res );
  results = res;
}
mapping *query_results() { return results; }
mixed query_patterns() {
  return ({
    "<word'db'> <string:quoted'query'>",
    (: cmd( $4[0], $4[1] ) :) });
}

==================================================
FILE: creator/st_at.c
==================================================

#include <creator.h>
inherit "/cmds/base";
mixed cmd(string str) {
  object *ob, thing;
  mixed *ob1, *thing1;
  string s, bing;
  string long_fields, temp;
  int long_length;
  bing = "";
  str = (string)this_player()->expand_nickname(str);
  ob = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ob)) {
    write("No such object.\n");
    return 1;
  }
  foreach (thing in ob) {
    ob1 = (mixed *)thing->stats();
    if (!pointerp(ob1))
      continue;
    s = "";
    long_fields = "";
    long_length = ( (int)this_player()->query_cols() / 3 ) - 1;
    foreach (thing1 in (pointerp(ob1[0][0])?ob1[0]:ob1)) {
      if (thing1[1]) {
        temp = thing1[0] +": "+ sprintf("%O", thing1[1]) +"\n";
        if (strlen(temp) > long_length) {
          long_fields += temp;
        } else {
          s += temp;
        }
      }
    }
    bing += sprintf("%-*#s\n", this_player()->query_cols(), long_fields) +
      sprintf( "%-*#s\n", this_player()->query_cols(), s );
  }
  this_player()->more_string(bing, "Stat");
  return 1;
}

==================================================
FILE: creator/stats.c
==================================================

inherit "/cmds/base";
#define TP this_player()
#define STATS ({"con", "dex", "int", "str", "wis"})
#define GUILDS ({"assassin", "priest", "thief", "warrior", "witch", "wizard"})
#define TREES ({"covert", "crafts", "faith", "fighting", "magic", "other" })
string get_stat(string s) {
  switch(s) {
  case "S": return "str";
  case "I": return "int";
  case "W": return "wis";
  case "D": return "dex";
  case "C": return "con";
  }
}
int cmd() {
  object user;
  string guild_ob, stat, str;
  mapping stats;
  int val, m, i;
  mapping tmp;
  mapping mode;
  stats = ([ ]);
  foreach(user in users()) {
    if(user->query_creator() || user->query_known_command("rearrange"))
      continue;
    tmp = ([]);
    guild_ob = user->query_guild_ob();
    if(guild_ob)
      guild_ob = guild_ob->query_name();
    if(stats[guild_ob])
      tmp = stats[guild_ob];
    else {
      foreach(stat in STATS) {
        tmp[stat] = ({ 0, 0, 0, 0 });
      }
    }
    if(!mode)
      mode = ([ ]);
    if(!mode[guild_ob])
      mode[guild_ob] = ([ ]);
    foreach(stat in STATS) {
      val = call_other(user, "query_real_" + stat);
      tmp[stat][0] += 1;
      tmp[stat][1] += val;
      if(tmp[stat][2] > val || !tmp[stat][2]) {
        tmp[stat][2] = val;
      }
      if(tmp[stat][3] < val) {
        tmp[stat][3] = val;
      }
      if(!mode[guild_ob][stat])
        mode[guild_ob][stat] = ([ val : 1 ]);
      else if(!mode[guild_ob][stat][val])
        mode[guild_ob][stat][val] = 1;
      else
        mode[guild_ob][stat][val] += 1;
    }
    stats[guild_ob] = tmp;
  }
  write("stat: min max mode ave\n");
  foreach(guild_ob in keys(stats)) {
    if(!guild_ob)
      continue;
    printf("\n%s:\n", guild_ob);
    str = "";
    foreach(stat in STATS) {
      m = 0;
      foreach(i in keys(mode[guild_ob][stat]))
        if(mode[guild_ob][stat][i] > m) {
          val = i;
          m = mode[guild_ob][stat][i];
        }
      str += sprintf("  %s: %2d %2d %2d %2d\n",
                     stat,
                     stats[guild_ob][stat][2], stats[guild_ob][stat][3],
                     val, stats[guild_ob][stat][1] / stats[guild_ob][stat][0]);
    }
    printf("%-#*s", this_player()->query_cols(), str);
  }
  printf("\n");
  return 1;
}
int guild(string gstr) {
  string user, stat, gob, tstr, guild;
  mapping count, total;
  int val, i;
  foreach(guild in GUILDS) {
    if(gstr && gstr != guild && gstr != guild+"s" &&
       gstr != guild+"es")
      continue;
    gob = "/std/guilds/" + guild;
    count = ([ ]);
    total = ([ ]);
    foreach(user in users()) {
      if(user->query_guild_ob() != gob || user->query_creator() ||
         user->query_known_command("rearrange"))
        continue;
      foreach(stat in STATS) {
        total[stat] += 1;
        val = call_other(user, "query_real_" + stat);
        if(!count[stat])
          count[stat] = ([ val : 1 ]);
        if(!count[stat][val])
          count[stat][val] = 1;
        else
          count[stat][val] += 1;
      }
    }
    if(!sizeof(count))
      return notify_fail("No players in that guild.\n");
    write("\nStats for " + guild + "\n");
    foreach(stat in STATS)
      printf("%-13s", "   " + capitalize(stat));
    write("\n");
    for(val = 8; val <= 23; val++) {
      foreach(stat in STATS) {
        tstr = "";
        for(i=0; i<((count[stat][val] * 10) / total[stat]); i++)
          tstr += "#";
        printf("%2d %-10s", val, tstr);
      }
      write("\n");
    }
  }
  return 1;
}
int stats(string sstr) {
  string user, guild, tstr, st;
  mapping count, total;
  int val, i;
  foreach(st in STATS) {
    if(sstr && st[0] != sstr[0])
      continue;
    count = ([ ]);
    total = ([ ]);
    foreach(user in users()) {
      if(user->query_creator() || user->query_known_command("rearrange"))
        continue;
      guild = replace(user->query_guild_ob(), "/std/guilds/", "");
      if(!guild)
        continue;
      val = call_other(user, "query_real_" + st);
      if(!count[guild])
        count[guild] = ([ val : 1 ]);
      else
        count[guild][val] += 1;
      total[guild] += 1;
    }
    if(!sizeof(count))
      return notify_fail("No players in that guild.\n");
    write("\nValues for " + capitalize(st) + "\n");
    foreach(guild in GUILDS)
      printf("%-13s", "   " + capitalize(guild));
    write("\n");
    for(val = 8; val <= 23; val++) {
      foreach(guild in GUILDS) {
        tstr = "";
        for(i=0; i<((count[guild][val] * 10) / total[guild]); i++) {
          tstr += "#";
        }
        printf("%2d %-10s", val, tstr);
      }
      write("\n");
    }
  }
  return 1;
}
int primaries() {
  string guild, skill, st, stats;
  mapping count;
  int i, total;
  string str;
  write("Guild Primaries\n");
  foreach(guild in GUILDS) {
    write(guild + "\n");
    count = ([ ]);
    total = 0;
    str = "";
    foreach(skill in ("/std/guilds/" + guild)->query_skills()) {
      stats = "/std/skills"->query_skill_stat(skill);
      total += sizeof(stats);
      for(i=0; i<sizeof(stats); i++) {
        st = get_stat(stats[i..i]);
        count[st] += 1;
      }
    }
    foreach(st in STATS) {
      str += sprintf("  %s: %2d%%\n",
                     capitalize(st), (count[st] * 100) / total);
    }
    printf("%-#*s", this_player()->query_cols(), str);
    write("\n");
  }
  return 1;
}
int skills() {
  string tree, skill, st, stats;
  mapping count;
  int i, total;
  string str;
  write("Guild Primaries\n");
  foreach(tree in TREES) {
    write(tree + "\n");
    count = ([ ]);
    total = 0;
    str = "";
    foreach(skill in ("/std/skills")->query_all_children(tree)) {
      stats = "/std/skills"->query_skill_stat(skill);
      total += sizeof(stats);
      for(i=0; i<sizeof(stats); i++) {
        st = get_stat(stats[i..i]);
        count[st] = 1;
      }
    }
    foreach(st in STATS) {
      str += sprintf("  %s: %2d%%\n",
                     capitalize(st), (count[st] * 100) / total);
    }
    printf("%-#*s", this_player()->query_cols(), str);
    write("\n");
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "guild", (: guild(0) :),
             "guild <word'guild'>", (: guild($4[0]) :),
             "stat", (: stats(0) :),
             "stat <word'guild'>", (: stats($4[0]) :),
             "primaries", (: primaries() :),
             "skills", (: skills() :) });
}

==================================================
FILE: creator/statthief.c
==================================================

#include <player_handler.h>
inherit "/cmds/base";
#define QUOTA "/obj/handlers/guild_things/quota"
#define MONEY "/obj/handlers/money_handler"
string cost_str(int amt);
string time_str(int time);
int cmd(string str) {
  if(!str || !PLAYER_HANDLER->test_user(str))
    return notify_fail("Get thief stats for who?\n");
  if( !QUOTA->query_quota_data( str ) )
    return notify_fail("Sorry, "+str+" does not have a quota.\n");
  printf("Thief statistics for: %s\n", str);
  printf("  Quota: \n");
  printf("    Min %s\n", cost_str((int)QUOTA->query_thief_minquota(str)));
  printf("    Max %s\n", cost_str((int)QUOTA->query_thief_maxquota(str)));
  printf("  Debts:\n");
  printf("    Debts %s\n", cost_str(QUOTA->query_thief_debts(str)));
  printf("    Fines %s\n", cost_str(QUOTA->query_thief_fines(str)));
  printf("  This period:\n");
  printf("    Stolen %s\n", cost_str(QUOTA->query_total_stolen(str)));
  printf("    Time left %s\n", time_str(QUOTA->query_time_to_reset(str)));
  return 1;
}
string cost_str(int amt) {
  return MONEY->money_string(MONEY->create_money_array(amt, "Ankh-Morpork"));
}
string time_str(int time) {
  string str;
  str = "";
  if (time > 86400)
    str += sprintf("%d days, ", time/86400);
  if (time > 3600)
    str += sprintf("%d hours, ", (time/3600)%24);
  str += sprintf("%d minutes and %d seconds",
                     (time/60)%60, time%60);
  return str;
}

==================================================
FILE: creator/status.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  if (str)
    this_player()->more_string(mud_status(1), "Status info");
  else
    printf("%s", mud_status());
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd(0) :),
             "detailed", (: cmd("detailed") :) });
}

==================================================
FILE: creator/suspend.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
#define MULTI_SUSPEND 28*24
#define LIAISON "/d/liaison/master"
private int do_suspend(string, int, string);
private int cmd(string name, int tim, string type, string reason) {
  if (this_player() != this_player(1)) {
    return 0;
  }
  if (!master()->query_lord(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail("You must be a lord or liaison deputy to suspend "
                       "someone.");
  }
  if ( type[<1] != 's' ) {
      type += "s";
  }
  switch (type) {
    case "days":
        tim *= 24;
    break;
    case "weeks":
        tim *= 24 * 7;
    break;
    case "months":
        tim  *= 24 * 7 * 4;
    break;
    case "years":
        tim *= 24 * 365;
    break;
    case "hours":
    break;
    default:
  }
  if (!master()->query_lord (geteuid(previous_object()))
      && LIAISON->query_deputy(geteuid(previous_object()))
      && tim > MULTI_SUSPEND) {
    return notify_fail ("You can only suspend for a maximum of " +
      query_num (MULTI_SUSPEND) + " hours.");
  }
  return do_suspend(name, tim, reason);
}
private int suspend(string who, string reason) {
  if(this_player() != this_player(1))
    return 0;
  if (!master()->query_lord(geteuid(previous_object())) &&
      !master()->query_senior(geteuid(previous_object())) &&
      !LIAISON->query_member(geteuid(previous_object()))) {
    return notify_fail("Only liaisons or seniors can do that.\n");
  }
  return do_suspend(who, 2, reason);
}
#ifdef SUSPEND_MULTI
private int suspend_multi(string who) {
  if(this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail("You must be a lord or liaison deputy to suspend "
                       "someone for multiplaying.");
  }
  return do_suspend(who, MULTI_SUSPEND, "Multiplaying");
}
#endif
private int do_suspend(string name, int tim, string reason) {
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->suspend_person(name, tim*60*60, reason)) {
    return 0;
  }
  write(name+" suspended until "+ctime(time()+tim*60*60)+"\n");
  return 1;
}
int help() {
  if(!"/secure/master"->query_lord(geteuid(previous_object())) &&
     !LIAISON->query_member(this_player()->query_name()))
    return notify_fail("You cannot use suspend.\n");
  if(this_player()->query_lord() ||
     master()->query_senior(geteuid(previous_object())) ||
     LIAISON->query_member(geteuid(previous_object())))
    write("suspend <name> <reason> -- will suspend a player for 2 hours.\n");
#ifdef SUSPEND_MULTI
  if(this_player()->query_lord() ||
     LIAISON->query_deputy(geteuid(this_player())))
    write("suspend <name> multiplaying -- will suspend a multiplayer for "
          "2 weeks.\n");
#endif
  if (LIAISON->query_deputy(geteuid(this_player()))) {
    write("suspend <name> <time> <reason> where time is in hours.\n");
    write ("You may suspend people for a maximum of "
      + query_num (MULTI_SUSPEND) + " hours as a liaison deputy.\n");
  }
  if ("/secure/master"->query_lord(geteuid(this_player()))) {
    write("suspend <name> <time> <reason> where time is in hours.\n");
    write("suspend <name> <time> <hours|days|weeks|months|years> <reason> "
        "where time is in the units specified in the command.\n");
  }
  return 1;
}
public mixed *query_patterns() {
  mixed retval;
  retval = ({ "help", (: help() :) });
  if( master()->query_lord(geteuid(this_player())) ||
     master()->query_senior(geteuid(previous_object())) ||
     LIAISON->query_member(geteuid(previous_object())))
    retval += ({ "<word'player'> <string'reason'>",
                   (: suspend($4[0], implode($4[1..], " ")) :) });
#ifdef SUSPEND_MULTI
  if(this_player()->query_lord() ||
     LIAISON->query_deputy(geteuid(this_player())))
    retval += ({ "<word'player'> multiplaying",
                   (: suspend_multi($4[0]) :) });
#endif
  if( master()->query_lord(geteuid(this_player())) ||
        LIAISON->query_deputy(geteuid(this_player()))) {
        retval += ({ "<word'player'> <number'time'> <string'reason'>",
                   (: cmd($4[0], $4[1], "hours", implode($4[2..], " ") ) :) });
        retval += ({ "<word'player'> <number'time'> "
            "<word'hours|days|weeks|months|years'> <string'reason'>",
                   (: cmd($4[0], $4[1], $4[2], implode($4[3..], " ") ) :) });
  }
  return retval;
}

==================================================
FILE: creator/tasks.c
==================================================

#include <skills.h>
#define SAVE_FILES "/save/tasks/"
inherit "/cmds/base";
mapping awards;
void create() { seteuid( "Root" ); }
void main_menu( string word ) {
   int i, j, *numbers;
   string text, *words;
   if ( !word || ( word == "" ) )
      word = " ";
   switch ( word[ 0 ] ) {
      case 'Q' :
      case 'q' :
         return;
      case 'L' :
      case 'l' :
         words = get_dir( SAVE_FILES +"*.o" );
         if ( !sizeof( words ) ) {
            printf( "No tasks have been logged.\n" );
            return;
         }
         for ( i = sizeof( words ) - 1; i > -1; i-- ) {
            words[ i ] = words[ i ][ 0 .. strlen( words[ i ] ) - 3 ];
            if ( sizeof( (string *)SKILL_OB->
                  query_immediate_children( words[ i ] ) ) )
               words[ i ] += sprintf( "%*s", 60 - strlen( words[ i ] ),
                     "[non-primary]" );
         }
         this_player()->set_finish_func( "main_menu", this_object() );
         this_player()->more_string( "Skills with logged tasks are:\n   "+
               implode( words, "\n   " ) +"\n", "Tasks", 1 );
         return;
      case 'C' :
      case 'c' :
         if ( strlen( word ) < 4 ) {
            printf( "Syntax: C <skill>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( file_size( SAVE_FILES + word +".o" ) < 1 ) {
            printf( "There are no tasks logged for "+ word +".\n" );
            break;
         }
         unguarded( (: restore_object, SAVE_FILES + word :) );
         numbers = allocate( 5 );
         text = "Skill awards made for "+ word +":\n";
         foreach ( i in sort_array( keys( awards ), 1 ) ) {
            j = 0;
            foreach ( word in keys( awards[ i ] ) )
               j += awards[ i ][ word ];
            text += sprintf( "   level%5d awarded by%5d tasks\n", i, j );
            if ( i < 301 )
               switch ( j ) {
                  case 1 .. 4 :
                     numbers[ 0 ]++;
                     break;
                  case 5 .. 9 :
                     numbers[ 1 ]++;
                     break;
                  case 10 .. 19 :
                     numbers[ 2 ]++;
                     break;
                  case 20 .. 49 :
                     numbers[ 3 ]++;
                     break;
                  default :
                     numbers[ 4 ]++;
               }
         }
         text += sprintf( "Coverage at the  1 task level is%4d%%.\n",
               ( numbers[ 0 ] + numbers[ 1 ] + numbers[ 2 ] +
               numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the  5 task level is%4d%%.\n",
               ( numbers[ 1 ] + numbers[ 2 ] + numbers[ 3 ] +
               numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 10 task level is%4d%%.\n",
               ( numbers[ 2 ] + numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 20 task level is%4d%%.\n",
               ( numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 50 task level is%4d%%.\n",
               numbers[ 4 ] / 3 );
         this_player()->set_finish_func( "main_menu", this_object() );
         this_player()->more_string( text, "Tasks", 1 );
         return;
      case 'H' :
      case 'h' :
         printf( "\nTasks editor commands:\n\n"+
               "Q         : quit the quest editor\n"+
               "L         : list tasked skills\n"+
               "C <skill> : examine coverage for <skill>\n"+
               "H         : get this list of commands\n\n" );
         break;
      default :
   }
   printf( "Choose one of Q, L, C or H (for help) : " );
   input_to( "main_menu" );
}
int cmd() {
   main_menu( "L" );
   return 1;
}

==================================================
FILE: creator/tcheck.c
==================================================

int cmd( string str ) {
   mixed  err, ret;
   object ob;
   string file, wiz_dir;
   if (!this_player()) return 0;
   seteuid(geteuid(this_player()));
   if (!str) {
      notify_fail("Usage: tcheck <file name>\n");
      return 0;
   }
   wiz_dir = "/w/" + (string)this_player()->query_name();
   if (file_size(wiz_dir)!=-2) {
      notify_fail("Directory: " + wiz_dir + " does not exist.\n");
      return 0;
   }
   if ( str[0..0] != "/" )
     str = (string)this_player()->query_path() + "/" + str;
   if (str[<1..<1]=="0") {
      str=str[0..<2];
   }
   if (file_size(str)<0) {
      notify_fail("File: " + str + " does not exist or is a directory.\n");
      return 0;
   }
   file = wiz_dir + "/exec_tmp";
   if (find_object(file)) file->dest_me();
   if (file_size(file+".c")>0) rm(file+".c");
   write_file(file+".c",
              "#pragma strict_types\n" +
              "#pragma save_types\n" +
              "#include \""+ str +"\"\n" +
              "void dest_me_in_exec_temp() { destruct(this_object()); }\n" +
              "\n");
   err = catch(ret = (mixed) file->force_load());
   if (err==0) printf("%s loaded ok.\n", str);
   if (find_object(file)) file->dest_me_in_exec_temp();
   rm(file+".c");
   return 1;
}
void dest_me() {
   destruct(this_object());
}
void clean_up() {
   dest_me();
}
void reset() {
   dest_me();
}

==================================================
FILE: creator/tell!.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#define TP this_player()
inherit "/cmds/base";
inherit "/cmds/speech";
#ifdef USE_SMILEYS
string *two_smileys = ({":)", ":(", ":P", ":p", ":b", ";)",
  ";(", ";P", ";p", ";b", "=)", "=("});
string *three_smileys = ({":-)", ":-(", ":-P", ":-p", ":-b",
  ";-)", ";-(", ";-P", ";-p", ";-b", ":o)", ":o(", ":oP",
  ":op", ":ob", ";o)", ";o(", ";oP", ";op", ";ob", "=-)",
  "=-(", "=o)", "=o("});
#endif
int cmd( string arg, mixed thing, int silent ) {
   string word, lang, words, emotion;
#ifdef USE_SMILEYS
   string smiley, smiley_words;
#endif
   string them_mess, temp;
   string me_mess;
   object *obs;
   object *net_dead;
   object *fail;
   mixed busy;
   emotion = "";
   if (pointerp(thing)) {
      words = arg;
   } else if ( !objectp( thing ) ) {
      if ( !arg || sscanf( arg, "%s %s", word, words ) != 2 )
         return 0;
      word = lower_case( word );
      word = (string)TP->expand_nickname( word );
      thing = find_player( word );
      if ( !thing ) {
         if ( sscanf( word, "%*s@%*s" ) == 2 ) {
            "/net/daemon/out_tell"->do_tell( word+" "+words );
            return 1;
         }
         add_failed_mess( capitalize( word ) +" is not logged in.\n" );
         return 0;
      }
   } else {
      words = arg;
   }
   if (!pointerp(thing)) {
      obs = ({ thing });
   } else {
      obs = thing;
   }
   obs -= ({ this_player() });
   if ( !sizeof(obs) ) {
      add_failed_mess( "Talking to yourself again.  I don't know.\n" );
      return 0;
   }
   if (sizeof(obs) > 20) {
      add_failed_mess("You can only tell up to 20 people a message.\n");
      return 0;
   }
   fail = this_player()->query_ignoring(obs);
   if ( sizeof( fail ) )  {
      write( "You are currently ignoring " +
             query_multiple_short( fail ) + ", so " +
             (sizeof(fail) > 1 ? " they" : fail[0]->query_pronoun()) +
             " couldn't reply anyway.\n" );
      obs -= fail;
      if ( !sizeof( obs ) )  {
         return 1;
      }
   }
   lang = (string)TP->query_current_language();
   if ( !LANGUAGE_HAND->query_language_spoken( lang ) ) {
      return notify_fail( capitalize( lang ) +
            " is not a spoken language.\n" );
   }
   if ( !LANGUAGE_HAND->query_language_distance( lang ) ) {
      return notify_fail( capitalize( lang ) +
            " is not able to be spoken at a distance.\n" );
   }
#ifdef USE_SMILEYS
  if(sizeof(words) >= 3) {
    if(member_array(words[<3..], three_smileys) != -1) {
      smiley = words[<3..];
    } else if(member_array(words[<2..], two_smileys) != -1) {
      smiley = words[<2..];
    }
  } else if(member_array(words, three_smileys) != -1) {
    smiley = words;
  } else if(member_array(words, two_smileys) != -1) {
    smiley = words;
  }
#endif
  word = query_word_type(words, "");
  if(word != "") {
    word = " "+word+"ing";
  }
#ifdef USE_SMILEYS
  if(smiley) {
    if(sizeof(words) > 3) {
      smiley_words = words[0..<sizeof(smiley) + 1];
    } else {
      smiley_words = words;
    }
    word = query_word_type(smiley_words, "");
    if(word != "") {
      word = " "+word+"ing";
    }
  }
  switch(smiley) {
    case ":)" :
    case ":-)" :
    case ":o)" :
      emotion = " happily";
      break;
    case ":(" :
    case ":-(" :
    case ":o(" :
      emotion = " sadly";
      break;
    case "=)" :
    case "=-)" :
    case "=o)" :
      emotion = " innocently";
      break;
    case "=(" :
    case "=-(" :
    case "=o(" :
      emotion = " tearfully";
      break;
    case ";(" :
    case ";-(" :
    case ";o(" :
      emotion = " angrilly";
      break;
    case ";)" :
    case ";-)" :
    case ";o)" :
      emotion = " mischieviously";
      break;
    case ":P" :
    case ":-P" :
    case ":oP" :
    case ":p" :
    case ":-p" :
    case ":op" :
    case ":b" :
    case ":-b" :
    case ":ob" :
      emotion = " insanely";
      break;
    case "=P" :
    case "=-P" :
    case "=oP" :
    case "=p" :
    case "=-p" :
    case "=op" :
    case "=b" :
    case "=-b" :
    case "=ob" :
      emotion = " cheekily";
      break;
    case ";P" :
    case ";-P" :
    case ";oP" :
    case ";b" :
    case ";-b" :
    case ";ob" :
    case ";p" :
    case ";-p" :
    case ";op" :
      emotion = " evilly";
      break;
    default :
      emotion = "";
  }
#endif
   if ( word != " asking" ) {
      me_mess = "tell";
   } else {
      me_mess = "ask";
      word = "";
   }
   net_dead = ({ });
   foreach (thing in obs) {
      temp = emotion;
      if(thing->query_earmuffs("emoticon")) {
         emotion = "";
      }
      thing->event_person_tell( TP,
            capitalize( (string)TP->query_name() ) +
            " (creator) "+ me_mess + "s "+
            query_multiple_short(obs - ({ thing }) + ({ "you" })) + emotion +
            word + ": ", words, lang );
      if (!interactive(thing) && userp(thing)) {
         net_dead += ({ thing });
      }
   }
   if ( !silent ) {
      if ( lang != "common" ) {
         word += " in "+ lang;
      }
      if (sizeof(obs)) {
         them_mess =
               TP->convert_message(capitalize( query_multiple_short(obs)));
         emotion = temp;
         if(this_player()->query_earmuffs("emoticon")) {
           emotion = "";
         }
         TP->add_tell_history( "(creator) You " + me_mess + " "+ them_mess +
               word + emotion+ ": ", words );
      }
      if ( sizeof(net_dead)) {
          write("Warning: "+query_multiple_short(
                               map(net_dead, (: $1->query_cap_name() :)))+
                " "+ (sizeof(net_dead)>1?"are":"is")+" net dead.\n" );
      }
      emotion = temp;
      if(this_player()->query_earmuffs("emoticon")) {
        emotion = "";
      }
      busy = this_player()->query_busy();
      if (busy == 1) {
         write("Warning! You have your busy flag on.\n");
      } else if (pointerp(busy) && sizeof(obs - busy)) {
         write("Warning! You are currently set as busy with " +
                  query_multiple_short(busy) + ".\n");
      }
      my_mess("(creator) You "+me_mess+" "+them_mess+
            emotion + word+": ", words);
   }
   TP->adjust_time_left( -5 );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player> <string'message'>", (: cmd($4[1], $1, 0) :),
             "<string>", (: cmd($4[0], 0, 0) :) });
}

==================================================
FILE: creator/template.c
==================================================

#include <terrain_map.h>
inherit "/cmds/base";
int cmd(int size) {
   mixed* data;
   int x;
   int y;
   string line;
   data = TERRAIN_MAP_WORLD_MAP->query_map_template(size);
   line = "";
   for (y = 0; y < sizeof(data); y++) {
      for (x = 0; x < sizeof(data[y]); x++) {
         if (data[x][y]) {
            line += "*";
         } else {
            line += " ";
         }
      }
      line += "\n";
   }
   write(line);
   return 1;
}
mixed* query_patterns() {
   return ({ "<number>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/terms.c
==================================================

inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("term list");
   if (!stuff) {
      stuff = T_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/terrain_s.c
==================================================

inherit "/cmds/base";
#include <terrain_map.h>
int do_map() {
   string map;
   object hand;
   int* coords;
   int x;
   int y;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   coords = environment(this_player())->query_terrain_coords();
   x = coords[0];
   y = coords[1];
   map = hand->query_debug_map(x, y, 13, x, y);
   write(map);
   add_succeeded_mess("");
   return 1;
}
int do_map_terrain() {
   string map;
   object hand;
   string* map_data;
   int i;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   map_data = hand->query_area_map();
   map = "";
   for (i = sizeof(map_data) - 1; i >= 0; i--) {
      map += map_data[i] + "\n";
   }
   write("$P$Map$P$" + map);
   add_succeeded_mess("");
   return 1;
}
int do_features_distant() {
   object hand;
   string title;
   mixed tmp;
   string fluff;
   string ret;
   int* coords;
   int x;
   int y;
   int z;
   string* features;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   if (!sizeof(features)) {
      add_failed_mess("No distant features to list.\n");
      return 0;
   }
   ret = "List of distant features:\n";
   foreach (title in features) {
      tmp = title->query_feature_desc_from(x, y, z);
      if (tmp && tmp != "") {
         if (stringp(tmp)) {
            ret += "$I$3=%^BOLD%^" + title + "%^RESET%^: " + tmp + "\n";
         } else if (pointerp(tmp)) {
            foreach (fluff in tmp) {
               ret += "$I$3=%^BOLD%^" + title + "%^RESET%^: " + fluff + "\n";
            }
         }
      }
   }
   write("$P$Distant Features$P$" + ret);
   return 1;
}
int do_features_local() {
   mapping features;
   string ret;
   object hand;
   mapping hand_features;
   string name;
   mixed stuff;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   hand_features = hand->query_features();
   features = environment(this_player())->query_features();
   if (!features) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   if (!sizeof(features)) {
      add_failed_mess("No local features.\n");
      return 0;
   }
   ret = "List of features:\n";
   foreach (name, stuff in hand_features) {
      ret += "$I$3=%^BOLD%^" + name + "%^RESET%^ (" +
             file_name(hand->query_feature_region(name)) + ")";
      if (features[name]) {
         ret += " " + features[hand] + "\n";
      } else {
         ret += " Not visible here.\n";
      }
   }
   write("$P$Features$P$" + ret);
   return 1;
}
int do_feature_local_map(string feature) {
   object hand;
   mapping hand_features;
   string ret;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   hand_features = hand->query_features();
   if (!hand_features[feature]) {
      add_failed_mess("There is no feature called " + feature + ".\n");
      return 0;
   }
   ret = hand->query_debug_map_feature(feature);
   write("$P$" + feature + "$P$" + ret);
   return 1;
}
int do_feature_distant_map(string feature) {
   object hand;
   string* dist_features;
   string ret;
   int* coords;
   int x;
   int y;
   int z;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   dist_features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   if (member_array(feature, dist_features) == -1) {
      add_failed_mess("There is no distant feature " + feature + ".\n");
      return 0;
   }
   ret = hand->query_debug_map_feature_distant(feature);
   write("$P$" + feature + "$P$" + ret);
   return 1;
}
int do_terrain_status() {
   string ret;
   object hand;
   mixed* coords;
   mapping features;
   string name;
   int x;
   int y;
   int z;
   string* dist_features;
   mapping terrs;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   ret = "%^BOLD%^" + file_name(hand) + ":%^RESET%^\n";
   ret += "Size: " + hand->query_dimensions()[0] + ", " + hand->query_dimensions()[1] + "\n";
   coords = hand->query_real_coords();
   if (coords) {
      ret += "Real: " + coords[0][0] + ", " + coords[0][1] + " -- " +
             coords[1][0] + ", " + coords[1][1] + "\n";
   }
   features = hand->query_features();
   foreach (name in keys(features)) {
      ret += name + ": " + file_name(hand->query_feature_ob(name)) + "\n";
   }
   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   dist_features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   foreach (name in dist_features) {
      ret += name + " (distant feature)\n";
   }
   hand->find_all_adjacent_terrains();
   terrs = hand->query_adjacent_terrains();
   if (terrs["-1:-1"]) {
      ret += "Southwest: " + terrs["-1:-1"] + "\n";
   }
   if (terrs["0:-1"]) {
      ret += "South: " + terrs["0:-1"] + "\n";
   }
   if (terrs["40:-1"]) {
      ret += "Southeast: " + terrs["40:-1"] + "\n";
   }
   if (terrs["40:0"]) {
      ret += "East: " + terrs["40:0"] + "\n";
   }
   if (terrs["40:40"]) {
      ret += "NorthEast: " + terrs["40:40"] + "\n";
   }
   if (terrs["0:40"]) {
      ret += "North: " + terrs["0:40"] + "\n";
   }
   if (terrs["-1:40"]) {
      ret += "Northwest: " + terrs["-1:40"] + "\n";
   }
   if (terrs["-1:0"]) {
      ret += "West: " + terrs["-1:0"] + "\n";
   }
   write("$P$Status$P$" + ret);
   return 1;
}
mixed* query_patterns() {
   return ({ "map", (: do_map() :),
             "map terrain", (: do_map_terrain :),
             "features local", (: do_features_local :),
             "features distant", (: do_features_distant :),
             "status", (: do_terrain_status :),
             "features local <string'feature to map'>",
                  (: do_feature_local_map($4[0]) :),
             "features distant <string'feature to map'>",
                  (: do_feature_distant_map($4[0]) :) });
}

==================================================
FILE: creator/testchar.c
==================================================

inherit "/cmds/base";
private mapping properties = ([ "no score" : 1,
    "no delete" : 1,
    "test character" : (: $1->query_name() :),
    "authorised player" : 1 ]);
int cmd( object player, string status ) {
    foreach( string property, mixed value in properties ) {
        if ( status == "on" ) {
            if ( functionp( value ) ) {
                player->add_property( property, evaluate( value,
                    this_player() ) );
            }
            else {
                player->add_property( property, value );
            }
        }
        else {
            player->remove_property( property );
        }
    }
    if ( status == "on" ) {
        player->save_me();
        add_succeeded_mess( ({ "$I is now a test character.\n", "" }),
            ({ player }) );
    }
    else {
        add_succeeded_mess( ({ "$I is no longer a test character.\n", "" }),
            ({ player }) );
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:player> {on|off}", (: cmd($1[0], $4[1]) :) });
}
