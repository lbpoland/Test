# Total Tokens: 99271
# Total Files Merged: 29
# Total Characters: 330991

p_handler.c
==================================================

#include <group_handler.h>
#include <broadcaster.h>
#include <login_handler.h>
int _loaded;
int _groups_formed;
mapping _groups;
class group
{
   int start_time;
   string short;
   string leader_name;
   object leader;
   object *members;
   object *invited;
}
int is_group( string group );
int is_member( string name, object person );
int is_invited( string name, object person );
object *invitations_to( string name );
string query_group_short( string name );
object *members_of( string name );
object leader_of( string name );
string short_to_name( string short );
int create_group( string name );
int remove_group( string name );
int add_invite( string name, object person, int flag );
int remove_invite( string name, object person );
int add_member( string name, object person );
int remove_member( string name, object person );
varargs int set_leader( string name, object person, object appointer );
void notify_group( string name, object broadcaster, mixed message );
varargs void disband_group( string name, mixed message );
varargs object shuffle_new_leader( string group, int way, object *exclude );
void leader_goes_linkdead( string player, string event_type );
void handle_group_follow( string group, object who, object *what,
   int unfollow, int silent );
void broadcast_to_groups( string *name, string message );
string *query_groups();
int set_group_short( string, string);
void create()
{
   _groups = ([ ]);
   _loaded = time();
   _groups_formed = 0;
}
void dest_me() {
   string name;
   broadcast_to_groups( 0, "%^BOLD%^WARNING%^RESET%^: The group handler is being destructed."
      "  All active groups will be disbanded.  It should be possible to "
      "recreate the group almost immediately afterwards.  If not, please "
      "file a bug report for the \"group\" command." );
   foreach( name in query_groups() ) {
      disband_group( name, 0 );
   }
}
void stats_please() {
   printf( "The handler was loaded on %s.  Since then, "
      "%i groups have been formed.\n", ctime( _loaded ),
      _groups_formed );
}
string *query_groups() {
   return keys( _groups );
}
int is_group( string group ) {
   return !undefinedp( _groups[ group ] );
}
int is_member( string name, object person ) {
   if( !is_group( name ) ) {
      return 0;
   }
   if( member_array( person, _groups[ name ]->members ) == -1 ) {
      return 0;
   }
   return 1;
}
int is_invited( string name, object person )
{
   if( member_array( person, _groups[ name ]->invited ) != -1 )
   {
      return 1;
   }
   return 0;
}
object *invitations_to( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->invited;
}
string query_group_short( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->short;
}
object *members_of( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->members;
}
object leader_of( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->leader;
}
int query_start_time( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->start_time;
}
string short_to_name( string short )
{
   string *words;
   short = lower_case( short );
   words = explode( short, " " );
   words -= INVALID_WORDS;
   if( !sizeof( words ) ) {
      return "";
   }
   short = implode( words, " " );
   if( BROADCASTER->query_channel_members( "group_" + short ) ) {
      return "";
   }
   return short;
}
int create_group( string name )
{
   if( is_group( name ) ) {
      return 0;
   }
   _groups += ([ name : new( class group ) ]);
   _groups[ name ]->members = ({ });
   _groups[ name ]->invited = ({ });
   _groups[ name ]->start_time = time();
   _groups_formed++;
   return 1;
}
int rename_group(string group, string new_group) {
   object member;
   if (is_group(new_group) || new_group == group) {
      return 0;
   }
   _groups[new_group] = _groups[group];
   map_delete(_groups, group);
   set_group_short(new_group, new_group);
   foreach (member in _groups[new_group]->members) {
      if (!member) {
         continue;
      }
      BROADCASTER->remove_object_from_channel( "group_" + group, member );
      member->group_membership_removed();
      member->add_effect( EFFECT, new_group);
      BROADCASTER->add_object_to_channel( "group_" + new_group, member );
      member->set_title( GROUP_TITLE, "a member of " +
      query_group_short( new_group ) );
   }
   notify_group( new_group, this_object(), ({ "", "The group has been renamed to " +
      new_group + "." }) );
   return 1;
}
int set_group_short( string name, string short_desc )
{
   if( !is_group( name ) ) {
      return 0;
   }
   _groups[ name ]->short = short_desc;
   return 1;
}
int remove_group( string name )
{
   if( !is_group( name ) ) {
      return 0;
   }
   if( _groups[ name ]->leader_name ) {
      LOGIN_HANDLER->remove_login_call(
         _groups[ name ]->leader_name, "leader_goes_linkdead",
         this_object() );
   }
   map_delete( _groups, name );
   return 1;
}
int add_invite( string name, object person, int flag )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   if( is_member( name, person ) )
   {
      return 0;
   }
   if( member_array( person, _groups[ name ]->invited ) != -1 )
   {
      return 0;
   }
   _groups[ name ]->invited += ({ person });
   if( !flag )
   {
      call_out( (: remove_invite, name, person :), INVITE_TIMEOUT );
   }
   return 1;
}
int remove_invite( string name, object person )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   if( !is_invited( name, person ) )
   {
      return 0;
   }
   _groups[ name ]->invited -= ({ person, 0 });
   return 1;
}
int add_member( string name, object person )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   if( is_member( name, person ) )
   {
      return 0;
   }
   _groups[ name ]->members += ({ person });
   _groups[ name ]->invited -= ({ person });
   person->add_effect( EFFECT, name );
   BROADCASTER->add_object_to_channel( "group_" + name, person );
   notify_group( name, person, ({ "You have joined the group.",
      person->query_cap_name() + " has joined the group." }) );
   if( sizeof( _groups[ name ]->members ) > 1 )
   {
      handle_group_follow( name, person, ({ _groups[ name ]->leader }), 0, 0 );
   }
   person->set_title( GROUP_TITLE, "a member of " +
      query_group_short( name ) );
   return 1;
}
int remove_member( string name, object person )
{
   object member;
   if( !is_group( name ) )
   {
      return 0;
   }
   if( !is_member( name, person ) )
   {
      return 0;
   }
   if( person )
   {
      notify_group( name, person, ({
         "You have left the group.",
      person->query_cap_name() + " has left the group." }) );
      foreach( member in person->query_assisting() )
      {
         if( !member )
         {
            continue;
         }
         member->remove_assister( person );
      }
      foreach( member in person->query_assisters() )
      {
         if( !member )
         {
            continue;
         }
         member->remove_assisting( person );
      }
   }
   _groups[ name ]->members -= ({ person });
   BROADCASTER->remove_object_from_channel( "group_" + name, person );
   if( person )
   {
      person->group_membership_removed();
   }
   if( person == leader_of( name ) && sizeof( members_of( name ) ) )
   {
      if (sizeof(members_of(name)) == 1) {
         notify_group( name, this_object(), "The current leader has left "
            "the group, you are now all alone.  Better start recruiting.");
      } else {
         notify_group( name, this_object(), "The current leader has left "
            "the group.  A new leader will be chosen randomly." );
      }
      if( !shuffle_new_leader( name, 0 ) )
      {
         notify_group( name, this_object(), "The choosing of a new "
            "leader has failed (oh dear).  The group is hereby "
            "disbanded.\n" );
         call_out( "disband_group", 0, name );
         return 1;
      }
   }
   handle_group_follow( name, person, _groups[ name ]->members, 1, 1 );
   foreach( member in _groups[ name ]->members ) {
      handle_group_follow( name, member, ({ person }), 1, 1 );
   }
   if (person && objectp(person)) {
      person->remove_title( GROUP_TITLE );
   }
   if( !sizeof( members_of( name ) ) ) {
      remove_group( name );
   }
   return 1;
}
varargs int set_leader( string name, object person, object appointer )
{
   object *followers, old_leader, member;
   if( !is_group( name ) )
   {
      return 0;
   }
   if( !is_member( name, person ) )
   {
      return 0;
   }
   if( !person )
   {
      return 0;
   }
   if( _groups[ name ]->leader_name )
   {
      LOGIN_HANDLER->remove_dynamic_login_call(
         _groups[ name ]->leader_name, "leader_goes_linkdead",
         base_name( this_object() ) );
   }
   old_leader = _groups[ name ]->leader;
   if( old_leader )
   {
      followers = ( old_leader->query_followers() & _groups[ name ]->members );
      followers -= ({ 0 });
      followers += ({ old_leader });
      foreach( member in followers )
      {
         handle_group_follow( name, member, ({ old_leader }), 1, 1 );
         handle_group_follow( name, member, ({ person }), 0, 1 );
      }
      old_leader->set_title( GROUP_TITLE, "a member of " +
         query_group_short( name ) );
   }
   _groups[ name ]->leader = person;
   if( userp( person ) ) {
      _groups[ name ]->leader_name = person->query_name();
      LOGIN_HANDLER->add_dynamic_login_call( person->query_name(),
         "leader_goes_linkdead", base_name( this_object() ) );
   }
   else
   {
      _groups[ name ]->leader_name = 0;
   }
   if( !appointer )
   {
      notify_group( name, person, ({ "You are now the leader of "
         "the group.", person->query_cap_name() + " is now the leader "
         "of the group." }) );
   }
   else
   {
      notify_group( name, appointer, "By the power vested in " +
         appointer->query_cap_name() + ", " + person->query_cap_name() +
         " has been appointed as the new leader of the group." );
   }
   person->set_title( GROUP_TITLE, "the leader of " +
      GROUP->query_group_short( name ) );
   return 1;
}
void notify_group( string name, object broadcaster, mixed message ) {
   BROADCASTER->broadcast_to_channel( broadcaster, "group_" + name,
      ({ message, time() }) );
}
varargs void disband_group( string name, mixed message ) {
   object bugger, leader, *members;
   if( !is_group( name ) ) {
      return;
   }
   if( message ) {
      notify_group( name, this_object(), message );
   }
   members = members_of( name );
   leader = leader_of( name );
   if( leader ) {
      members -= ({ leader });
   }
   foreach( bugger in members ) {
      remove_member( name, bugger );
   }
   remove_member( name, leader );
   remove_group( name );
}
varargs object shuffle_new_leader( string group, int way, object *exclude ) {
   object leader;
   object *members;
   if( !is_group( group ) ) {
      return 0;
   }
   members = members_of( group );
   if( !sizeof( members ) ) {
      return 0;
   }
   if( exclude ) {
      members -= exclude;
   }
   members = filter( members, (: $1 && interactive( $1 ) :) );
   if( !sizeof( members ) ) {
      return 0;
   }
   switch( way ) {
      case 0:
         leader = members[ random( sizeof( members ) ) ];
         if( set_leader( group, leader ) ) {
            return leader;
         }
         return 0;
      default:
         return 0;
   }
}
void leader_goes_linkdead( string player, string event_type ) {
   string group;
   object player_ob, *members;
   if( event_type != NETDEATH && event_type != RECONNECT ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   if( !player_ob = find_player( player ) ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   group = player_ob->query_group();
   if( !group ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   if( _groups[ group ]->leader_name != player ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   members = members_of( group );
   members -= ({ player_ob });
   if( !sizeof( members ) ) {
      return;
   }
   LOGIN_HANDLER->remove_dynamic_login_call( player,
      "leader_goes_linkdead", base_name( this_object() ) );
   notify_group( group, this_object(), "The current leader "
      "has gone netdead.  A new leader will be selected at random." );
   if( !shuffle_new_leader( group, 0, 0 ) ) {
      notify_group( group, this_object(), "No eligible leaders "
         "found.  The group is disbanded." );
      disband_group( group );
   }
}
void handle_group_follow( string group, object who, object *what,
   int unfollow, int silent ) {
   string short, mess_to_me, mess_to_others;
   switch( unfollow ) {
      case 0:
         what = filter( what, (: $1->add_follower( $( who ) ) :) );
         if( !sizeof( what ) ) {
            mess_to_me = "You begin following noone.";
            break;
         }
         short = query_multiple_short( what );
         mess_to_me = "You begin following " + short + ".";
         mess_to_others = who->query_cap_name() + " begins following " +
            short + ".";
         break;
      case 1:
         what = filter( what, (: $1->remove_follower( $( who ) ) :) );
         if( !sizeof( what ) ) {
            mess_to_me = "You stop following noone.";
            mess_to_others = 0;
            break;
         }
         short = query_multiple_short( what );
         mess_to_me = "You stop following " + short + ".";
         mess_to_others = who->query_cap_name() + " stops following " +
            short + ".";
         break;
      default:
         printf( "Barf.\n" );
         return;
   }
   if( !silent ) {
      notify_group( group, who, ({ mess_to_me, mess_to_others }) );
   }
}
void broadcast_to_groups( string *name, string message ) {
   string group;
   string *groups;
   if( name && sizeof( name ) ) {
      groups = name;
   }
   else {
      groups = keys( _groups );
   }
   foreach( group in groups ) {
      notify_group( group, this_player(), message );
   }
}
mapping query_dynamic_auto_load() {
   return ([ "groups" : _groups,
             "groups formed" : _groups_formed ]);
}
void init_dynamic_arg(mapping map) {
   _groups = map["groups"];
   _groups_formed = map["groups formed"];
}

==================================================
FILE: handlers/haggle_handler.c
==================================================

#include <money.h>
mixed *accept_sayings, *bodged_sayings, *finalb_sayings,
    *finals_sayings, *insult_sayings, *offerb_sayings,
    *offers_sayings, *sodoff_sayings;
void create() {
  accept_sayings = ({
      ({ "grin", "Done!" }),
      "Accepted!",
      "Fine...",
      ({ "smile", "Agreed!" }),
      ({ "mutter", "Okay..." }),
      "Taken!",
      "You drive a hard bargain, but taken...",
      "You'll make me bankrupt, but it's a deal...",
      ({ "sigh", "I'll take it..." }),
      "My poor sick children will starve, but done!",
      "Finally!  I accept...",
      ({ "grimace", "Robbed again..." }),
      "A pleasure to do business with you!",
      ({ "scowl", "My spouse will have my hide, but accepted." }) });
  bodged_sayings = ({
      "I must have heard you wrong...",
      "What was that?",
      "I'm sorry, say that again...",
      "What did you say?",
      "Sorry, what was that again?" });
  finalb_sayings = ({
      "I'll pay no more than $offer$; take it or leave it.",
      "You'll get no more than $offer$ from me.",
      "$offer$ and that's final." });
  finals_sayings = ({
      "$asking$ is my lowest price; take it or leave it...",
      "It'll cost you no less than $asking$.",
      "My patience grows thin... $asking$ is final." });
  insult_sayings = ({
      "You will have to do better than that!",
      "That's an insult!",
      "Do you wish to do business or not?",
      "Hah!  Try again...",
      "Ridiculous!",
      "You've got to be kidding!",
      "You'd better be kidding!",
      "You're trying my patience...",
      "I didn't hear that.  Say it again?",
      "Hmmm... Nice weather we're having..." });
  offerb_sayings = ({
      "$asking$ for that piece of junk?  No more than $offer$.",
      "For $asking$ I could own ten of those.  Try $offer$.",
      "$asking$?!?  Never!  $offer$ is more like it...",
      "Let's be reasonable...  How about $offer$?",
      ({ "cough", "$offer$ for that junk, no more..." }),
      "$offer$ and be thankful for it!",
      "$offer$ and not an iotum more...",
      "$asking$?  Ha!  $offer$ is more like it...",
      "Try $offer$...",
      "I wouldn't pay $asking$ for your children!  Try $offer$.",
      ({ "choke", "For that?!?  Let's say $offer$." }),
      "How about $offer$?",
      "That looks like army surplus!  Say $offer$.",
      "I'll buy it as scrap for $offer$.",
      "$asking is too much; let us say $offer$." });
  offers_sayings = ({
      "$offer$ for such a fine item?  Hah!  No less than $asking$.",
      "$offer$ is an insult!  Try $asking$...",
      "$offer$?!?  You would rob my poor starving children?  "+
          "Even they would give $asking$ for this.",
      "Why, I'll take no less than $asking$.",
      ({ "cackle", "No less than $asking$." }),
      "You swine!  No less than $asking$.",
      "$offer$ is far too little;  how about $asking$?",
      "I paid more than $offer$ for it myself!  Try $asking$.",
      ({ "boggle", "$offer$?  Are you mad?!?  How about $asking$?" }),
      "As scrap this would bring $offer$.  Try $asking$.",
      "May the fleas of a thousand camels molest you.  "+
          "I want $asking$.",
      "My mother you can get for $offer$, "+
          "this will cost you $asking$.",
      "May your chickens grow lips!  I want $asking$!",
      "Sell this for such a pittance?  Give me $asking$.",
      "May the Grflx find you tasty!  $asking$?",
      "Your mother was a troll!  $asking$ or I'll tell..." });
  sodoff_sayings = ({
      ({ "Enough!",
          "You have abused my generosity once too often!",
          "Out of my establishment!" }),
      ({ "That does it!",
          "You will waste my time no more!",
          "Out...  Out...  OUT!!!" }),
      ({ "This is getting nowhere!",
          "Leave me alone!",
          "Come back tomorrow..." }),
      ({ "Bah!",
          "No more will you insult me!",
          "Leave my place!  Begone!" }),
      ({ "Begone!",
          "I have had enough abuse for one day.",
          "Come back when you're richer..." }) });
}
int insult_factor( object keeper, object customer ) {
  return 150;
}
int bargain_factor( object keeper, object customer ) {
  return 50;
}
int *sell_haggle( int value, int offer, int asking, int insults,
    string place, object keeper, object customer ) {
  int adjustment, number;
  string text;
  if ( offer > asking ) {
    keeper->do_command( "boggle" );
    number = random( sizeof( bodged_sayings ) );
    keeper->do_command( "'"+ bodged_sayings[ number ] );
    return ({ 0, asking, insults });
  }
  if ( offer == asking ) {
    number = random( sizeof( accept_sayings ) );
    if ( sizeof( accept_sayings[ number ] ) == 2 ) {
      keeper->do_command( accept_sayings[ number ][ 0 ] );
      keeper->do_command( "'"+ accept_sayings[ number ][ 1 ] );
    } else
      keeper->do_command( "'"+ accept_sayings[ number ] );
    return ({ 1, asking, insults });
  }
  if ( ( offer * insult_factor( keeper, customer ) ) >
      ( asking * 100 ) ) {
    adjustment = ( ( asking - offer ) *
        bargain_factor( keeper, customer ) ) / 100;
    if ( adjustment < 0 ) adjustment = 0;
    asking -= adjustment;
    number = random( sizeof( offers_sayings ) );
    if ( sizeof( offers_sayings[ number ] ) == 2 ) {
      keeper->do_command( offers_sayings[ number ][ 0 ] );
      text = offers_sayings[ number ][ 1 ];
    } else
      text = offers_sayings[ number ];
    text = replace( text, "$offer$",
        (string)MONEY_HAND->money_value_string( offer, place ) );
    text = replace( text, "$asking$",
        (string)MONEY_HAND->money_value_string( asking, place ) );
    keeper->do_command( "'"+ text );
    return ({ 0, asking, insults });
  }
  insults++;
  if ( insults < (int)keeper->query_property( "max insults" ) ) {
    number = random( sizeof( insult_sayings ) );
    keeper->do_command( "'"+ insult_sayings[ number ] );
    return ({ 0, asking, insults });
  }
  number = random( sizeof( sodoff_sayings ) );
  keeper->do_command( "lsay "+ sodoff_sayings[ 0 ] );
  keeper->do_command( "'"+ sodoff_sayings[ 1 ] );
  keeper->do_command( "'"+ sodoff_sayings[ 2 ] );
  return ({ 0, 0, -1 });
}

==================================================
FILE: handlers/hist_handler.c
==================================================

#define SAVE "/save/hist_handler.o"
#define MAX_HIS 20
#define HISTORY_TIME (3600*24*2)
mapping history;
mixed *query_lord_history();
void add_lord_history( string start, string mess );
void create() {
  seteuid(master()->get_root_uid());
  history = ([]);
  if(!unguarded((: restore_object, SAVE+".gz" :)))
    unguarded((: restore_object, SAVE :));
  call_out("tidy_history", 2);
}
void save_me() {
  unguarded((: save_object, SAVE, 2 :));
}
void add_cre_history(string start, string mess) {
  mixed *cre_history = history["cre"];
  if (undefinedp(history["cre"]))
    cre_history = ({ ({ start, mess, time() }) });
  else
    cre_history += ({ ({ start, mess, time() }) });
  if (sizeof(cre_history) > MAX_HIS)
    cre_history = cre_history[1..];
  history["cre"] = cre_history;
}
mixed *query_cre_history() {
  return history["cre"];
}
void add_chat_history(string channel, string start, string mess) {
  mixed *chat_history = history[channel];
  if ( !chat_history ) {
    chat_history = ({ });
  }
  if (channel == "lord")   {
    add_lord_history( start, mess );
    return;
  } else {
    chat_history += ({ ({ start, mess, time() }) });
  }
  if (sizeof(chat_history) > MAX_HIS) {
    chat_history = chat_history[1..];
  }
  history[channel] = chat_history;
}
mixed *query_chat_history(string channel) {
  if (channel == "lord")
    return query_lord_history();
  return history[channel];
}
void add_lord_history(string start, string mess) {
  mixed *lord_history = history["lord"];
  if (!master()->query_lord(previous_object(-1)))
    return;
  if (undefinedp(history["lord"]))
    lord_history = ({ ({ start, mess, time() }) });
  else
    lord_history += ({ ({ start, mess, time() }) });
  if (sizeof(lord_history) > MAX_HIS)
    lord_history = lord_history[1..];
  history["lord"] = lord_history;
}
mixed *query_lord_history() {
  if (!master()->query_lord(previous_object(-1)))
    return ({ });
  return history["lord"];
}
void dest_me() {
  save_me();
  destruct(this_object());
}
void reset() {
  save_me();
}
void tidy_history() {
  string channel;
  int i;
  foreach(channel in keys(history)) {
    for(i = 0; i<sizeof(history[channel]); i++)
      if(history[channel][i][2] < time() - HISTORY_TIME) {
  history[channel] = history[channel][1..];
      } else
  break;
    if(!sizeof(history[channel]))
      map_delete(history, channel);
  }
  save_object(SAVE, 2);
}
void reset_history() {
  if (!master()->high_programmer(previous_object(-1)))
    return;
  history = ([]);
  save_object(SAVE, 2);
}

==================================================
FILE: handlers/hospital.c
==================================================

#include <armoury.h>
#include <data.h>
#include <weather.h>
#define CREATE_NPCS 1
#define REGEN_TIME 1 * 60 * 60
#define DEFAULT_MAX_CACHE 10
#define DEFAULT_LOG_DIRECTORY "/log"
#define DEFAULT_POPULATION 3
#define MINIMUM_DEATH_REGEN 3
#define POPULATION_UPDATE_TIME 15 * 60
#define TOTAL_CHANCE 150
#define CENTRE 0
#define LIMIT_ONE     35
#define LIMIT_TWO     68
#define LIMIT_THREE   95
#define LIMIT_FOUR   115
#define LIMIT_FIVE   130
#define LIMIT_SIX    139
#define LIMIT_SEVEN  145
#define LIMIT_EIGHT  147
#define LIMIT_NINE   149
inherit "/std/room";
class regenerated_npc {
    string type;
    string load_position;
}
class zone_info {
   int wealth;
   int busy;
   int npc_chance;
   mapping npcs;
   int group_chance;
   mapping groups;
   int zone_chance;
   mapping zones;
}
class unique_npc {
   int next_regen_time;
}
class npc_info {
   string path;
   int unique;
   int delay;
   int transient;
   int nocturnal;
   int diurnal;
   string* seasonal;
   int max_population;
   string* move_zones;
   string* commands;
   object* population;
   int no_deaths;
   int no_created;
   int no_reused;
   int next_update;
}
class group_info {
   string* move_zones;
   mapping npcs;
   mapping npc_commands;
   int protect;
   int defend;
   int transient;
   int max_population;
   mixed* storage;
   int no_creates;
   int next_update;
}
object* load_random_npc(string zone, int wealth, int busy);
protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);
public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );
private nosave string _save_file;
private nosave string _hospital_type;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;
private nosave string _data_directory;
private nosave string _npc_path;
private nosave string _domain;
private nosave int _max_cache;
private nosave int _disable_npc_generation;
private mapping _unique_npcs;
private mapping _hospital_npcs;
private mapping _cache_inventory;
private int _last_npc_check;
private int _zone_npcs;
private mapping _group_info;
private mapping _npc_info;
private mapping _zone_info;
private mapping _path_to_npc;
private mapping _file_modified_time;
void create() {
    seteuid(master()->creator_file(file_name(this_object())));
    do_setup++;
    ::create();
    do_setup--;
    if (!_group_info) {
        _group_info = ([ ]);
    }
    if (!_npc_info) {
        _npc_info = ([ ]);
    }
    if (!_zone_info) {
        _zone_info = ([ ]);
    }
    if (!_path_to_npc) {
        _path_to_npc = ([ ]);
    }
    if (!_file_modified_time) {
        _file_modified_time = ([ ]);
    }
    if (!_unique_npcs) {
        _unique_npcs = ([ ]);
    }
    if (!_cache_inventory) {
      _cache_inventory = ([ ]);
    }
    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);
    if(!_max_cache)
      _max_cache = DEFAULT_MAX_CACHE;
    if (!do_setup) {
        set_short( "Un-configured Hospital" );
        set_long("This is an unconfigured hospital.  Find the right one.\n");
        add_property("determinate", "the ");
        set_light(60);
        this_object()->setup();
    }
}
int ok_to_clone() {
   return 1;
}
int pick_al( int average, int range ) {
   int choice, section, section_width, result;
   if( range < 0 ) {
      range = -range;
   }
   if( range < 10 ) {
      range = 10;
   }
   section_width = floor( range / 10 );
   choice = random( TOTAL_CHANCE );
   switch( choice ) {
      case CENTRE..LIMIT_ONE:
         section = 0;
         break;
      case ( LIMIT_ONE + 1 )..LIMIT_TWO:
         section = 1;
         break;
      case ( LIMIT_TWO + 1 )..LIMIT_THREE:
         section = 2;
         break;
      case ( LIMIT_THREE + 1 )..LIMIT_FOUR:
         section = 3;
         break;
      case ( LIMIT_FOUR + 1 )..LIMIT_FIVE:
         section = 4;
         break;
      case ( LIMIT_FIVE + 1 )..LIMIT_SIX:
         section = 5;
         break;
      case ( LIMIT_SIX + 1 )..LIMIT_SEVEN:
         section = 6;
         break;
      case ( LIMIT_SEVEN + 1 )..LIMIT_EIGHT:
         section = 7;
         break;
      case ( LIMIT_EIGHT + 1 )..LIMIT_NINE:
         section = 8;
         break;
      default:
         section = 9;
         break;
   }
   result = section * section_width;
   result = result + random( section_width );
   switch( random( 2 ) ) {
      case( 0 ):
         result = average + result;
         break;
      default:
         result = average - result;
         break;
   }
   result = result + average;
   return result;
}
public string *query_deities() {
   return ({ "fish", "pishe", "sek", "hat", "gapp",
      "gufnork", "sandelfon" });
}
public int get_item(object destination, string *items) {
    int i;
    object item;
    if (!objectp(destination)) {
        return 0;
    }
    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21), _domain);
        if (!item) {
            item = ARMOURY->request_item(items[i], 80 + random(21) );
            if ( !item ) {
                items = items[0..i-1] + items[i+1..];
                continue;
            }
        }
        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the Ankh-Morpork hospital.\n",
                previous_object()->short());
            break;
        }
    }
    if (objectp(item)) {
        item->move(destination);
        return 1;
    }
    return 0;
}
protected void load_file() {
    class npc_info npc;
    class group_info group;
    string name;
    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
        if (!_group_info) {
            _group_info = ([ ]);
        } else {
            foreach (name, group in _group_info) {
                group->storage = 0;
            }
        }
        if (!_npc_info) {
            _npc_info = ([ ]);
        } else {
            foreach (name, npc in _npc_info) {
                npc->population = ({ });
            }
        }
        if (!_zone_info) {
            _zone_info = ([ ]);
        }
        if (!_path_to_npc) {
            _path_to_npc = ([ ]);
        }
        if (!_file_modified_time) {
            _file_modified_time = ([ ]);
        }
        if (!_unique_npcs) {
            _unique_npcs = ([ ]);
        }
    }
}
protected void save_file() {
    unguarded((: save_object, _save_file :));
}
protected void set_save_file(string new_save) {
    _save_file = new_save;
    load_file();
}
public string query_save_file() {
    return _save_file;
}
void set_data_directory(string dir) {
   _data_directory = dir;
   call_out("scan_for_new_data", 2);
}
string query_data_directory() {
   return _data_directory;
}
void set_npc_path(string path) {
  _npc_path = path;
}
void set_domain(string domain) {
  _domain = domain;
}
void set_max_cache(int num) {
  _max_cache = num;
}
void set_disable_npc_generation(int value) {
   _disable_npc_generation = value;
}
int query_disable_npc_generation() {
   return _disable_npc_generation;
}
public int make_unique(mixed who) {
    int delay;
    if (!_unique_npcs) {
        return 0;
    }
    if (objectp(who)) {
        who = who->query_name();
    }
    if (!_unique_npcs[who]) {
        _unique_npcs[who] = new(class unique_npc);
    }
    if ( _unique_npcs[who]->next_regen_time > time() ) {
        return 0;
    }
    if (_npc_info[who] && _npc_info[who]->delay) {
        delay = _npc_info[who]->delay;
    } else {
        delay = REGEN_TIME;
    }
    _unique_npcs[who]->next_regen_time = time() + delay;
    save_file();
    return 1;
}
public void reset_unique(string who) {
    if (!_unique_npcs[who]) {
        return ;
    }
    _unique_npcs[who]->next_regen_time = 0;
}
#ifdef REGENERATE_AFTER_DEATH
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;
    if ( !dead_npc )
        return;
    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"),
        load_position : previous_object()->query_property("start location") ) });
    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;
    new_npc = _regenerated_npcs[0];
    if ( !classp( new_npc ) )
        return;
    _regenerated_npcs = _regenerated_npcs[1..];
    if (!new_npc->load_position || !new_npc->type );
        return;
    max = random(5);
    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );
        if ( !objectp( destination ) )
            return;
        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);
        call_out((: $1->announce_entry($2) :), 8 + random(6), destination,
            monsters);
    }
}
#endif
string npc_path(string str) {
   return _npc_path + "/" + str;
}
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;
    filename = _hospital_log_directory;
    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }
    log_file( _hospital_log_directory + "/" + file, ctime(time()) + ": " + format, args ...);
}
protected void set_log_directory(string new_dir) {
    if (file_size(new_dir) != -2) {
        tell_creator( previous_object( 1 ), "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );
        new_dir = DEFAULT_LOG_DIRECTORY;
    }
    _hospital_log_directory = new_dir;
}
private void parse_zone(string fname, mapping data) {
   string name;
   class zone_info info;
   mapping bing;
   int chance;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for zone %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for zone %O\n", data);
      return 0;
   }
   name = data["name"];
   if (data["group"] && !arrayp(data["group"])) {
      data["group"] = ({ data["group"] });
   } else if (!arrayp(data["groups"])) {
      data["group"] = ({ });
   }
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   if (data["zone"] && !arrayp(data["zone"])) {
      data["zone"] = ({ data["zone"] });
   } else if (!arrayp(data["zone"])) {
      data["zone"] = ({ });
   }
   info = new(class zone_info, npcs : ([ ]), groups : ([ ]), zones : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->npc_chance = chance;
   chance = 0;
   foreach (bing in data["group"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->groups[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->group_chance = chance;
   chance = 0;
   foreach (bing in data["zone"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->zones[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->zone_chance = chance;
   info->busy = data["busy"];
   bits = keys(data) - ({ "zone", "group", "npc", "name", "busy" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in zone %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in %s\n",
                         query_multiple_short(bits), name);
   }
   _zone_info[name] = info;
   save_file();
}
private void parse_npc(string fname, mapping data) {
   string name;
   class npc_info info;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for npc %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      hospital_log_file("COMPILE_ERROR", "Required path field not present for npc %s\n", name);
      return 0;
   }
   if (file_size(npc_path(data["path"]) + ".c") < 0) {
      hospital_log_file("BAD_NPC_PATH", "Bad path for npc %s (%s)\n", name, data["path"]);
   }
   if (data["command"] && !arrayp(data["command"])) {
      data["command"] = ({ data["command"] });
   }
   if (data["move_zone"] && !arrayp(data["move_zone"])) {
      data["move_zone"] = ({ data["move_zone"] });
   }
   info = new(class npc_info, move_zones : ({ }), commands : ({ }));
   info->unique = data["unique"];
   info->path = data["path"];
   info->delay = data["delay"];
   info->max_population = data["population"];
   if(data["transient"])
     info->transient = 1;
   if(data["nocturnal"])
     info->nocturnal = 1;
   if(data["diurnal"])
     info->diurnal = 1;
   if(data["seasonal"]) {
     if(!arrayp(data["group"]))
       info->seasonal = ({ data["seasonal"] });
     else
       info->seasonal = data["seasonal"];
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   if (data["command"]) {
      info->commands = data["commands"];
   }
   bits = keys(data) - ({ "unique", "path", "move_zone", "population", "name", "delay", "transient", "nocturnal" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in npc %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in npc %s\n",
                         query_multiple_short(bits), name);
   }
   if (_path_to_npc[info->path] && _path_to_npc[info->path] != name) {
      hospital_log_file("NPC_NAME_CLASH", "NPC path %s is used by %s and %s.\n",
                         info->path, name, _path_to_npc[info->path]);
   }
   _path_to_npc[info->path] = name;
   if (_npc_info[name]) {
      info->population = _npc_info[name]->population;
      info->no_created = _npc_info[name]->no_created;
      info->no_reused = _npc_info[name]->no_reused;
      info->no_deaths = _npc_info[name]->no_deaths;
   }
   _npc_info[name] = info;
   save_file();
}
private void parse_group(string fname, mapping data) {
   string name;
   class group_info info;
   mapping bing;
   int chance;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for group %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for group %O\n", data);
      return 0;
   }
   name = data["name"];
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   info = new(class group_info, npcs : ([ ]), move_zones : ({ }),
                                npc_commands : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) ||
          (!intp(bing["quantity"]) && !classp(bing["quantity"]))) {
         debug_printf("Invalid data for group (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for group (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["quantity"];
         if (bing["command"]) {
            if (arrayp(bing["command"])) {
               info->npc_commands[bing["name"]] = bing["command"];
            } else {
               info->npc_commands[bing["name"]] = ({ bing["command"] });
            }
         }
      }
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   info->max_population = data["population"];
   info->protect = data["protect"];
   info->defend = data["defend"];
   info->transient = data["transient"];
   bits = keys(data) - ({ "npc", "name", "population", "move_zone", "protect", "defend", "transient", });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in group %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in group %s\n",
                         query_multiple_short(bits), name);
   }
   if (_group_info[name]) {
     info->storage = _group_info[name]->storage;
   }
   _group_info[name] = info;
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "zone" :
         foreach (thing in bits) {
            parse_zone(fname, thing);
         }
         break;
      case "npc" :
         foreach (thing in bits) {
            parse_npc(fname, thing);
         }
         break;
      case "group" :
         foreach (thing in bits) {
            parse_group(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         hospital_log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
}
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;
   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_directory });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
           debug_printf("Compiling %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
}
int roll_dice(mixed die) {
   int result;
   int i;
   if (intp(die)) {
      return die;
   }
   if (classp(die)) {
      for (i = 0; i < die->number; i++) {
         result += random(die->die) + 1;
      }
      result += die->modifier;
      return result;
   }
   return 0;
}
int query_npc_max_population( string npc) {
   if (!_npc_info[npc]) {
      return -1;
   }
   return ((class npc_info)_npc_info[npc])->max_population;
}
int query_npc_current_population( string npc, int clean) {
   class npc_info data;
   if (!_npc_info[npc]) {
      return -1;
   }
   data = _npc_info[npc];
   if (!data->population) {
      data->population = children(npc_path(data->path));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }
   if (clean || data->next_update < time()) {
      data->population = filter(data->population, (: objectp($1) :));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }
   return sizeof(data->population);
}
int is_npc_under_max_population(string name) {
    class npc_info info;
    info = _npc_info[name];
    if (!info) {
       return 0;
    }
    if(info->transient)
      return 1;
    if (info->max_population) {
       return query_npc_current_population(name, 1) < info->max_population;
    }
    return 1;
}
int is_group_under_max_population(string name) {
    class group_info group;
    group = _group_info[name];
    if (!group) {
       return 0;
    }
    if (!group->max_population || group->transient) {
       return 1;
    }
    if (!group->storage) {
        group->storage = ({ });
    } else if (group->next_update < time()) {
        group->storage = map(group->storage, (: filter($1, (: objectp($1) :)) :));
        group->storage = filter(group->storage, (: sizeof($1) :));
        group->next_update = time() + POPULATION_UPDATE_TIME;
    }
    if (sizeof(group->storage) >= group->max_population) {
        return 0;
    }
    return 1;
}
public object load_npc_object(string npc_name) {
    class npc_info info;
    object npc;
    string zone;
    string cmd;
    if ( undefinedp(_npc_info[npc_name])) {
        debug_printf("Unable to find npc %O", npc_name);
        return 0;
    }
    info = _npc_info[npc_name];
    if(info->diurnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->nocturnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->seasonal &&
       member_array(WEATHER->query_season(), info->seasonal) == -1)
      return 0;
    if (stringp(info->path)) {
        if ( info->unique ) {
            npc = find_object( npc_path(info->path) );
            if ((!npc || !environment(npc)) && make_unique(npc_name)) {
               debug_printf("Unique npc %O", info);
               if (catch(npc = load_object( npc_path(info->path) ))) {
                   hospital_log_file("BAD_NPC_PATH", "Error loading %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if (!objectp(npc) || npc == 0) {
                   hospital_log_file("BAD_NPC_PATH", "Failed to load %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if ( environment( npc ) ) {
                   debug_printf("NPC unique and already exists %O", npc_name);
                   return 0;
               }
            }
        } else if(info->transient) {
          if(!_cache_inventory)
            _cache_inventory = ([ ]);
          else if(_cache_inventory[npc_name])
            _cache_inventory[npc_name] -= ({ 0 });
          if(sizeof(_cache_inventory[npc_name])) {
            npc = _cache_inventory[npc_name][0];
            _cache_inventory[npc_name] -= ({ npc });
            info->no_reused++;
          } else {
            npc = clone_object( npc_path(info->path) );
            if(npc) {
              npc->add_property("transient", 1);
              npc->add_property("npc_id", npc_name);
              npc->add_property("hospital", base_name(this_object()));
              info->no_created++;
            } else
              debug_printf("Failed to clone %s", npc_path(info->path));
          }
        } else {
            if (is_npc_under_max_population(npc_name)) {
               npc = clone_object( npc_path(info->path) );
               info->no_created++;
               if (!npc) {
                  debug_printf("Npc path does not exist %O (%O)", npc, npc_path(info->path));
               }
            } else {
               debug_printf("NPC over max population %O", npc_name);
            }
        }
    } else {
        debug_printf("Broken npc data %O", info->path);
        return 0;
    }
    if (npc && !info->transient) {
        if( info->population == 0 )
            info->population = ({ });
        info->population += ({ npc });
        npc->add_property("npc_id", npc_name);
        foreach (zone in info->move_zones) {
            npc->add_move_zone(zone);
        }
        foreach (cmd in info->commands) {
            npc->init_command(cmd, 2);
        }
    }
    return npc;
}
object *load_group_npcs(string group_name) {
    class group_info group;
    int quantity;
    int i;
    object *npcs;
    string npc_name;
    object ob;
    object ob_bing;
    string cmd;
    if ( undefinedp(_group_info[group_name]) ||
         !is_group_under_max_population(group_name)) {
        return 0;
    }
    group = _group_info[group_name];
    npcs = ({ });
    foreach (npc_name, quantity in group->npcs) {
        quantity = roll_dice(quantity);
        for (i = 0; i < quantity; i++) {
            ob = load_npc_object(npc_name);
            if (!ob) {
               npcs->move("/room/rubbish");
               return ({ });
            }
            npcs += ({ ob });
            if (group->npc_commands[npc_name]) {
               foreach (cmd in group->npc_commands[npc_name]) {
                  ob->init_command(cmd, 2);
               }
            }
        }
    }
    if (!group->storage) {
        group->storage = ({ });
    }
    group->storage += ({ npcs });
    npcs->add_property("group_id", group_name);
    foreach (ob in npcs) {
       foreach (ob_bing in npcs) {
          if (ob != ob_bing) {
             ob->add_follower(ob_bing);
             if (group->defend) {
               ob->add_defender(ob_bing);
             }
             if (group->protect) {
                ob->add_protector(ob_bing);
             }
          }
       }
    }
    return npcs;
}
public class npc_info query_npc_info( string npc ) {
    if ( !_npc_info ) {
        return 0;
    }
    return _npc_info[ npc ];
}
mapping query_debug_npc_info() {
   return _npc_info;
}
public class group_info query_group_info( string group ) {
    if ( !_group_info ) {
        return 0;
    }
    return _group_info[ group ];
}
void npc_died(object ob) {
   string npc_id;
   class npc_info info;
   int i;
   mixed* stuff;
   npc_id = ob->query_property("npc_id");
   info = _npc_info[npc_id];
   if (!info || !npc_id) {
      return ;
   }
   info->population -= ({ ob });
   info->no_deaths++;
   npc_id = ob->query_property("group_id");
   stuff = _group_info[npc_id]->storage;
   if (sizeof(stuff)) {
      for (i = 0; i < sizeof(stuff); i++) {
         stuff[i] -= ({ ob, 0 });
      }
      _group_info[npc_id]->storage = filter(_group_info[npc_id]->storage,
                                             (: sizeof($1) :));
   }
}
mapping query_all_npc_info() {
   return _npc_info;
}
mapping query_all_group_info() {
   return _group_info;
}
mapping query_all_zone_info() {
   return _zone_info;
}
private int count_chances_in_zone(string zone) {
    class zone_info info;
    int chance;
    info = _zone_info[zone];
    if (!zone) {
       return 0;
    }
    chance = info->npc_chance + info->group_chance + info->zone_chance;
    return chance;
}
private object* create_npcs_in_zone(string zone, int pos) {
    class zone_info info;
    string extra;
    string npc;
    object ob;
    object* obs;
    int chance;
    info = _zone_info[zone];
    if (!zone) {
       return ({ });
    }
    if(_zone_info[zone]->busy &&
       _zone_info[zone]->busy < random(random(100)))
      return ({ });
    if (pos < info->npc_chance) {
       foreach (npc, chance in info->npcs) {
          if (pos < chance) {
             ob = load_npc_object(npc);
             if (ob) {
                return ({ ob });
             }
          }
          pos -= chance;
       }
    }
    pos -= info->npc_chance;
    if (pos < info->group_chance) {
       foreach (npc, chance in info->groups) {
          if (pos < chance) {
             obs = load_group_npcs(npc);
             if (sizeof(obs)) {
                return obs;
             }
          }
          pos -= chance;
       }
    }
    pos -= info->group_chance;
    foreach (extra, chance in info->zones) {
        if (pos < chance) {
           return load_random_npc(extra, -1, -1);
        }
    }
    return ({ });
}
object* load_random_npc(string zone, int wealth, int busy) {
    int chance;
    int pos;
    if (_disable_npc_generation) {
        return ({ });
    }
    if (_zone_info[zone + "-w" + wealth + "-b" + busy]) {
       zone = zone + "-w" + wealth + "-b" + busy;
    } else if (_zone_info[zone + "-w" + wealth]) {
       zone = zone + "-w" + wealth;
    } else if (_zone_info[zone + "-b" + busy]) {
       zone = zone + "-b" + busy;
    }
    if (!_zone_info[zone]) {
        return ({ });
    }
    chance = count_chances_in_zone(zone);
    if (!chance) {
       return ({ });
    }
    pos = random(chance);
    return create_npcs_in_zone(zone, pos);
}
int do_report() {
    string name;
    class group_info group;
    class npc_info npc;
    string txt;
    int total;
    int max;
    int pop;
    txt = "";
    total = 0;
    txt += "%^WHITE%^NPCs%^RESET%^\n";
    foreach( name, npc in _npc_info ) {
      if(stringp(npc->path) && file_size(npc_path(npc->path) + ".c") > 0) {
        pop = query_npc_current_population(name, 0);
      } else {
        pop = 0;
      }
      if(npc->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient) Reused %d Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
                        npc->no_reused, npc->no_created, npc->no_deaths);
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d) Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
            pop, npc->max_population, npc->no_created, npc->no_deaths );
        total += pop;
        max += npc->max_population;
    }
    txt += "$I$0=%^WHITE%^Groups%^RESET%^\n";
    foreach( name, group in _group_info ) {
      if(group->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient)\n", name,
            query_multiple_short(keys(group->npcs)));
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d)\n", name,
            query_multiple_short(keys(group->npcs)),
            sizeof( group->storage ), group->max_population );
    }
    txt += "$I$0=%^WHITE%^Cache%^RESET%^\n";
    foreach(name in keys(_cache_inventory))
      _cache_inventory[name] -= ({ 0 });
    foreach(name, group in _cache_inventory)
      txt += sprintf("$I$5=Name: %s %d\n", name, sizeof(group));
    txt += "\nTotal NPCs in hospital: " + total + "/" +
            max + ".\n";
    write("$P$Report$P$" + txt );
    return 1;
}
void init() {
  object ob;
  ob = this_player();
  add_command("report", "", (: do_report :));
  if(ob->query_property("npc_id") && ob->query_property("hospital") &&
     ob->query_property("hospital") == base_name(this_object())) {
    if(!_cache_inventory[ob->query_property("npc_id")])
      _cache_inventory[ob->query_property("npc_id")] = ({ ob });
    else if(sizeof(_cache_inventory[ob->query_property("npc_id")]) >
            _max_cache)
      ob->move("/room/rubbish");
    else
      _cache_inventory[ob->query_property("npc_id")] += ({ ob });
  } else if(base_name(ob) == "/obj/corpse")
    ob->move("/room/rubbish");
}
int no_attack() { return 1; }
mapping query_dynamic_auto_load() {
    string group_name;
    string npc;
    class group_info data;
    class npc_info npc_data;
    mapping tmp;
    mapping tmp2;
    tmp = allocate_mapping( sizeof( _group_info ) );
    foreach( group_name, data in _group_info ) {
        tmp[ group_name ] = data->storage;
    }
    tmp2 = allocate_mapping( sizeof( _npc_info) );
    foreach( npc, npc_data in _npc_info ) {
        tmp2[ npc ] = npc_data->population;
    }
    return ([ file_name( this_object() ) : tmp, "npcs" : tmp2 ]);
}
void init_dynamic_arg( mapping tmp ) {
    string group_name;
    object *npcs;
    if ( tmp[ file_name( this_object() ) ] ) {
        foreach( group_name, npcs in tmp[ file_name( this_object() ) ] ) {
            if (_group_info[group_name]) {
               _group_info[ group_name ]->storage = npcs;
            }
        }
        foreach( group_name, npcs in tmp[ "npcs" ]) {
            if (_npc_info[group_name]) {
               _npc_info[ group_name ]->population = npcs;
            }
        }
    }
}
mixed query_all_npcs() {
    return values( map( _group_info, (: $2->storage :) ) );
}
mapping query_inventory_cache() {
  return copy(_cache_inventory);
}
string* query_registered_npcs() {
    return keys( _npc_info );
}

==================================================
FILE: handlers/housing.c
==================================================

#include <housing.h>
#include <login_handler.h>
#include <am_time.h>
#include <nomic_system.h>
#define BANK "/obj/handlers/bank_handler"
#define DEFAULT_BANK "Bing's First"
#define DEFAULT_PLACE "Ankh-Morpork"
#define MAIL_HANDLER "/obj/handlers/mailer"
#define SAVE_FILE "/save/player_housing/housing"
class housing {
  string *other_rooms;
  string owner;
  string address;
  string region;
  int type;
  int value;
  string bank;
}
void load_file();
string query_housing_area_bank(string area);
private nosave string *_tmp_houses;
private nosave string *_tmp_rentals;
private mapping houses;
private int last_paid;
private mapping _housing_area;
private mapping _area_money;
void create() {
  houses = ([ ]);
  _housing_area = ([ ]);
  _area_money = ([ ]);
  seteuid("Root");
  load_file();
  if (!_housing_area) {
    _housing_area = ([ ]);
  }
  if (!_area_money) {
    _area_money = ([ ]);
  }
  call_out("check_owners", 900 + random(1800), 0);
  call_out("check_rent", 900 + random(1800));
}
void save_file() {
  unguarded((: cp, SAVE_FILE + ".o", SAVE_FILE + ".o.bak" :));
  unguarded((: save_object, SAVE_FILE :));
}
void load_file() {
  if (file_size(SAVE_FILE+".o") > 0)
    unguarded((: restore_object, SAVE_FILE :));
}
#ifdef 0
int change() {
  class housing nhouse;
  string house;
  foreach(house in keys(houses)) {
    write(sizeof(houses[house]) + "\n");
    if(sizeof(houses[house]) == 6) {
      nhouse = new(class housing,
                   other_rooms: houses[house]->other_rooms,
                   owner: houses[house]->owner,
                   address: houses[house]->address,
                   region: houses[house]->region,
                   type: houses[house]->type,
                   bank: houses[house]->region
               );
      houses[house] = nhouse;
    }
  }
  save_file();
  return 1;
}
#endif
int add_house(string house, string *other_rooms, string address,
              string region, int type) {
  if(!houses)
    houses = ([ ]);
  if(houses[house])
    return 0;
  houses[house] = new(class housing,
                      other_rooms: uniq_array(other_rooms),
                      address: address,
                      region: region,
                      type: type,
                      bank: query_housing_area_bank(region)
                  );
  save_file();
  return 1;
}
int modify_house(string house, string *other_rooms, string address,
              string region, int type) {
  if(!houses)
    houses = ([ ]);
  if(!houses[house])
    return 0;
  houses[house] = new(class housing,
                      other_rooms: uniq_array(other_rooms),
                      address: address,
                      region: region,
                      type: type,
                      bank: query_housing_area_bank(region));
  save_file();
  return 1;
}
int rename_house(string house, string newhouse) {
  if(!houses[house])
    return 0;
  if(houses[newhouse])
    return 0;
  houses[newhouse] = houses[house];
  if(member_array(newhouse, houses[newhouse]->other_rooms) != -1)
    houses[newhouse]->other_rooms -= ({ newhouse });
  map_delete(houses, house);
  save_file();
  return 1;
}
int remove_house( string house ) {
  if(!houses[house])
    return 0;
  map_delete( houses, house );
  return 1;
}
int add_rooms(string house, string *rooms) {
  if(!houses[house])
    return 0;
  houses[house]->other_rooms = uniq_array(houses[house]->other_rooms + rooms);
  save_file();
  return 1;
}
int remove_rooms(string house, string *rooms) {
  if(!houses[house])
    return 0;
  houses[house]->other_rooms -= rooms;
  save_file();
  return 1;
}
int set_owner(string house, string owner) {
  string room;
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  if(!owner)
    return 0;
  owner = lower_case(owner);
  house->ownership_change(houses[house]->owner, owner);
  foreach(room in houses[house]->other_rooms)
    room->ownership_change(houses[house]->owner, owner);
  log_file("HOUSING", "%s Owner for %s set to %s from %s.\n",
           ctime(time())[4..15], house, owner, houses[house]->owner);
  houses[house]->owner = owner;
  save_file();
  return 1;
}
int set_region(string house, string region) {
  if(!houses) {
    return 0;
  }
  if(!houses[house]) {
    return 0;
  }
  if(!stringp(region)) {
    return 0;
  }
  houses[house]->region = region;
  save_file();
  log_file("HOUSING", "%s Region for %s set to %s\n",
           ctime(time())[4..15], house, region);
  return 1;
}
int set_address(string house, string address) {
  if(!houses) {
    return 0;
  }
  if(!houses[house]) {
    return 0;
  }
  if(!stringp(address)) {
    return 0;
  }
  houses[house]->address = address;
  save_file();
  log_file("HOUSING", "%s Address for %s set to %s\n",
           ctime(time())[4..15], house, address);
  return 1;
}
string query_owner(string house) {
  string tmp;
  if(!houses)
    return 0;
  if(houses[house])
    return replace(houses[house]->owner, " (In Arrears)", "");
  foreach(tmp in keys(houses))
    if(member_array(house, houses[tmp]->other_rooms) != -1)
      return replace(houses[tmp]->owner, " (In Arrears)", "");
}
int query_house(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  return 1;
}
int set_bank(string house, string bank) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  if(!bank)
    return 0;
  if(((class housing)houses[house])->type != RENT)
    return 0;
  houses[house]->bank = bank;
  save_file();
  return 1;
}
string query_bank(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  return houses[house]->bank;
}
string *query_rooms(string house) {
  string *tmp;
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  if(sizeof(houses[house]->other_rooms)) {
    tmp = houses[house]->other_rooms;
    tmp += ({ house });
  } else
    tmp = ({ house });
  return tmp;
}
string query_address(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  return houses[house]->address;
}
string query_region(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  return houses[house]->region;
}
int set_type(string house, int type) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  if(type < 0 || type > 1)
    return 0;
  ((class housing)houses[house])->type = type;
  save_file();
  return 1;
}
int query_type(string house) {
  if(!houses)
    return -1;
  if(!houses[house])
    return -1;
  return ((class housing)houses[house])->type;
}
int query_value(string house) {
  if(!houses)
    return 0;
  if(!houses[house])
    return 0;
  return houses[house]->value;
}
string *query_vacant(string region) {
  string house, *sale_list;
  sale_list = ({ });
  foreach(house in keys(houses)) {
    if(stringp(houses[house]->owner)) {
      if (lower_case(houses[house]->owner) == "for sale" &&
          houses[house]->region == region) {
        sale_list += ({ house });
      }
    } else {
      debug_printf("Bad owner for house %O\n", house);
    }
  }
  return sale_list;
}
int set_for_sale(string house) {
  if(!houses || !houses[house])
    return 0;
  log_file("HOUSING", "%s %s set to For Sale from %s\n",
           ctime(time())[4..15], house, houses[house]->owner);
  houses[house]->owner = "For Sale";
  houses[house]->bank = DEFAULT_BANK;
  save_file();
  return 1;
}
int set_under_offer(string house) {
  if(!houses || !houses[house])
    return 0;
  log_file("HOUSING", "%s %s set to Under Offer from %s\n",
           ctime(time())[4..15], house, houses[house]->owner);
  houses[house]->owner = "Under Offer";
  houses[house]->value = 0;
  save_file();
  return 1;
}
int set_in_arrears(string house) {
  if(!houses || !houses[house])
    return 0;
  log_file("HOUSING", "%s %s set to In Arrears from %s\n",
           ctime(time())[4..15], house, houses[house]->owner);
  houses[house]->owner = houses[house]->owner + " (In Arrears)";
  save_file();
  return 1;
}
int set_value(string house, int value) {
  if(!houses || !houses[house])
    return 0;
  houses[house]->value = value;
  save_file();
  return 1;
}
int player_refreshed(mixed name, int refresh_type) {
  class housing house;
  string hname;
  if(objectp(name))
    name = name->query_name();
  foreach(hname, house in houses)
    if(house->owner == name) {
      log_file("HOUSING", "%s %s refreshed or deleted.\n", ctime(time())[4..15],
               house->owner);
      set_for_sale(hname);
    }
  return 1;
}
void set_housing_area_citizenship(string area, string citizenship) {
   _housing_area[area] = citizenship;
   save_file();
}
void remove_housing_area_citizenship(string area) {
   map_delete(_housing_area, area);
   save_file();
}
string query_housing_area_citizenship(string area) {
   return _housing_area[area];
}
mapping query_all_housing_area_citizenships() {
   return copy(_housing_area);
}
void set_housing_area_money( string area, string bank, string place ) {
    if( !_area_money[area] ) {
        _area_money[area] = ([ ]);
    }
    if( bank ) {
        _area_money[area]["bank"] = bank;
    }
    if( place ) {
        _area_money[area]["place"] = place;
    }
    save_file();
}
string query_housing_area_bank(string area) {
    if( _area_money[area] && _area_money[area]["bank"] ) {
        return _area_money[area]["bank"];
    }
    else {
        return DEFAULT_BANK;
    }
}
string query_housing_area_place(string area) {
    if( _area_money[area] && _area_money[area]["place"] ) {
        return _area_money[area]["place"];
    }
    else {
        return DEFAULT_PLACE;
    }
}
void check_owners(int i) {
  class housing tmp;
  if(!_tmp_houses)
    _tmp_houses = keys(houses);
  if(i == sizeof(_tmp_houses))
    return;
  tmp = houses[_tmp_houses[i]];
  if(!tmp->owner ||
     lower_case(tmp->owner) == "for sale" ||
     lower_case(tmp->owner) == "under offer" ||
     strsrch(lower_case(tmp->owner), "(in arrears)") != -1) {
    call_out("check_owners", 1, ++i);
    return;
  }
  if(!PLAYER_HANDLER->test_user(lower_case(tmp->owner))) {
    log_file("HOUSING", "%s %s doesn't exist.\n", ctime(time())[4..15],
             tmp->owner);
    set_for_sale(_tmp_houses[i]);
  } else if(!PLAYER_HANDLER->test_creator(tmp->owner)) {
    switch(tmp->type) {
    case SALE:
      if(PLAYER_HANDLER->test_last(tmp->owner) < time() - OWNER_TIMEOUT) {
        log_file("HOUSING", "%s %s is idle last login %s ago [%s].\n",
                 ctime(time())[4..15], tmp->owner,
                 ctime_elapsed(time() - PLAYER_HANDLER->test_last(tmp->owner)),
                 _tmp_houses[i]);
        set_for_sale(_tmp_houses[i]);
      }
      break;
    case RENT:
      if(PLAYER_HANDLER->test_last(tmp->owner) < time() - RENTER_TIMEOUT) {
        log_file("HOUSING", "%s %s is idle last login %s [%s].\n",
                 ctime(time())[4..15], tmp->owner,
                 ctime_elapsed(time() - PLAYER_HANDLER->test_last(tmp->owner)),
                 _tmp_houses[i]);
        set_for_sale(_tmp_houses[i]);
      }
      if (_housing_area[tmp->region] &&
          !NOMIC_HANDLER->is_citizen_of(_housing_area[tmp->region],
                                        tmp->owner)) {
        log_file("HOUSING", "Property %s has an owner %s, who is not "
                 "a citizen of %s [rent %d].\n", _tmp_rentals[i],
                 tmp->owner, _housing_area[tmp->region], tmp->value);
        MAIL_HANDLER->do_mail_message(tmp->owner,
                                      "Housing Rental Office",
                                      "Reposession", "",
                                      "Due to not being a citizen of " +
                                      _housing_area[tmp->region] +
                                      " when your rent was due, your property "
                                      "at " +tmp->address + " has been "
                                      "reposessed and put up for sale.\n\n"
                                      "The rental office.\n");
        set_for_sale(_tmp_rentals[i]);
      }
      break;
    }
  }
  call_out("check_owners", 1, ++i);
}
void check_rent() {
  int *now, daysleft;
  now = AM_TIME_HANDLER->query_am_time_array(time());
  if(now[AM_TIME_MONTH] != last_paid) {
    log_file("HOUSING", "Processing rent for " +
             AM_TIME_HANDLER->query_month(now[AM_TIME_MONTH]) + "\n");
    call_out("charge_rent", 0);
    last_paid = now[AM_TIME_MONTH];
    save_file();
  }
  daysleft = AM_TIME_HANDLER->query_days_per_month()[now[AM_TIME_MONTH]-1] -
    now[AM_TIME_DAY_OF_MONTH];
  call_out("check_rent", (daysleft * AM_SECONDS_PER_DAY) + 1);
}
void charge_rent(int i) {
  class housing tmp;
  string owner;
  if(!_tmp_rentals)
    _tmp_rentals = keys(houses);
  if(i >= sizeof(_tmp_rentals))
    return;
  tmp = houses[_tmp_rentals[i]];
  while(i < sizeof(_tmp_rentals) &&
        (tmp->type != RENT || !tmp->owner ||
         lower_case(tmp->owner) == "for sale" ||
         lower_case(tmp->owner) == "under offer")) {
    if(++i < sizeof(_tmp_rentals))
      tmp = houses[_tmp_rentals[i]];
  }
  if(i >= sizeof(_tmp_rentals)) {
    return;
  }
  call_out("charge_rent", 1, (i+1));
  if(!tmp->bank) {
    set_bank( _tmp_rentals[i], query_housing_area_bank( tmp->region ) );
    log_file("HOUSING", "Property %s had no bank, setting it to %s.\n",
             _tmp_rentals[i], tmp->bank);
  }
  if(!tmp->value) {
    log_file("HOUSING", "Property %s has a rent of zero.\n",
             _tmp_rentals[i]);
  } else if(strsrch(tmp->owner, "(In Arrears)") != -1) {
    owner = replace(tmp->owner, " (In Arrears)", "");
    if(BANK->query_account(owner, tmp->bank) < tmp->value * 3) {
      log_file("HOUSING", "%s %s failed to pay %d (%d) for %s [%s] "
               "property repossessed.\n",
               ctime(time())[4..15], owner, tmp->value * 3,
               BANK->query_account(owner, tmp->bank), _tmp_rentals[i],
               tmp->bank);
      MAIL_HANDLER->do_mail_message(owner,
                                    "Housing Rental Office",
                                    "Reposession", "",
                                    "Due to insufficient funds in your "
                                    "account at " + tmp->bank + " bank your "
                                    "property\n"
                                    "at " +tmp->address + " has been "
                                    "reposessed.\n\n"
                                    "The rental office.\n");
      BANK->adjust_account(owner, tmp->bank,
                           -(BANK->query_account(owner, tmp->bank)));
      set_for_sale(_tmp_rentals[i]);
    } else {
      BANK->adjust_account(owner, tmp->bank, - (tmp->value * 3));
      log_file("HOUSING", "%s %s paid arrears of %d for %s [%s]\n",
               ctime(time())[4..15], tmp->owner, tmp->value * 3,
               BANK->query_account(owner, tmp->bank), _tmp_rentals[i],
               tmp->bank);
      set_owner(_tmp_rentals[i], owner);
    }
  } else if(BANK->query_account(tmp->owner, tmp->bank) < tmp->value) {
    log_file("HOUSING", "%s %s failed to pay %d (%d) for %s [%s] "
             "property set in arrears.\n", ctime(time())[4..15], tmp->owner,
             tmp->value, BANK->query_account(tmp->owner, tmp->bank),
             _tmp_rentals[i], tmp->bank);
    MAIL_HANDLER->do_mail_message(tmp->owner,
                                  "Housing Rental Office",
                                  "In Arrears", "",
                                  "Due to insufficient funds in your account "
                                  "at " + tmp->bank + " bank your property\n"
                                  "at " +tmp->address + " is now in arrears."
                                  "\n\n"
                                  "Next month you will be charged three times "
                                  "the normal rent (this months rent, a one "
                                  "month late fee and next months rent).\n\n"
                                  "Failure to pay will result in repossession "
                                  "of your property.\n\n"
                                  "The rental office.\n");
    set_in_arrears(_tmp_rentals[i]);
  } else {
    BANK->adjust_account(tmp->owner, tmp->bank, -tmp->value);
    log_file("HOUSING", "%s %d rental paid by %s for %s\n",
             ctime(time())[4..15], tmp->value, tmp->owner, _tmp_rentals[i]);
  }
  if(tmp->owner != "For Sale" &&
     BANK->query_account(tmp->owner, tmp->bank) < (tmp->value * 3)) {
    MAIL_HANDLER->do_mail_message(tmp->owner,
                                  "Housing Rental Office",
                                  "Shortage of funds", "",
                                  "Your bank account currently has funds for "
                                  "less than three months rent.\n\n"
                                  "The rental office.\n");
  }
  debug_printf("Doing callout %d.", (i+1));
}
mapping query_houses() {
  return copy(houses);
}
mixed stats() {
  return ({
    ({ "total houses", sizeof(keys(houses)) }),
      ({ "paid for" , AM_TIME_HANDLER->query_month(last_paid) }),
      });
}

==================================================
FILE: handlers/image.c
==================================================

#include <image.h>
varargs class IMAGE_INFO load_image(string image_file, int rle) {
  int i, j, n, size_x, size_y;
  string image_type, l;
  mixed vals;
  class IMAGE_INFO ret;
  image_type = read_file(image_file, 1, 1);
  image_type = replace_string(image_type, " ", "");
  image_type = replace_string(image_type, "\n", "");
  if (image_type != "RAW") {
    error("Only image type RAW is currently supported.\n");
  }
  l = read_file(image_file, 2, 1);
  if (sscanf(l, "%d%d", size_x, size_y) != 2) {
    error("Image size(s) not found.\n");
  }
  ret = new(class IMAGE_INFO);
  ret->size = ({ size_x, size_y });
  vals = read_file(image_file, 3);
  vals = reg_assoc(vals, ({ "[0-9]+" }), ({ 1 }));
  n = 0;
  while (vals[1][n] != 1) n++;
  ret->image = allocate(size_x);
  for (i = 0; i < size_x; i++) {
    ret->image[i] = allocate(size_y);
    for (j = 0; j < size_y; j++) {
      if (n >= sizeof(vals[0])) {
        error("Ran out of values for image at " + i + ", " + j + ".\n");
      }
      ret->image[i][j] = to_int(vals[0][n++]);
      while ((n < sizeof(vals[0])) && (vals[1][n] != 1))
        n++;
    }
  }
  return ret;
}
void print_image(class IMAGE_INFO im) {
  int i, j;
  printf("size: %d x %d, %s, ", im->size[0], im->size[1],
         (im->rle?"rle":"no rle"));
  if (arrayp(im->nw_coord))
    printf("@ ({ %d, %d, %d })\n", im->nw_coord[0], im->nw_coord[1],
           im->nw_coord[2]);
  else
    printf("(not placed)\n");
  printf("Image:\n    ");
  for (i = 0; i < sizeof(im->image); i++) {
    for (j = 0; j < sizeof(im->image[i]); j++) {
      printf("% 4d", im->image[i][j]);
    }
    printf("\n    ");
  }
  printf("\n");
}

==================================================
FILE: handlers/inhume.c
==================================================

#include <inhume.h>
void create() {
   string * prev;
   string msg;
   prev = map( previous_object(-1), (: file_name($1) :) );
   msg = sprintf( "%s: /obj/handlers/inhume loaded: previous_object(-1) = %O",
     ctime( time() ), prev );
   tell_creator( "shrike", msg );
   log_file( LOG, msg );
}

==================================================
FILE: handlers/item_tracker.c
==================================================

#include <library.h>
#include <quest_handler.h>
inherit "/std/object";
#define QUEST_INFO_IDENT  "items"
#define MAX_COPIES    10
mapping item_cache;
mapping player_items;
void create()
{
   ::create();
   item_cache = ([ ]);
}
mixed query_item_state( mixed pl_name, mixed item )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  return player_items[ item ];
}
int delete_item( mixed pl_name, mixed item )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  map_delete( player_items, item );
  return 1;
}
int query_item_copies( mixed pl_name, mixed item )
{
  int copy_number,n_copies;
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    item = item->query_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  n_copies = 0;
  for (copy_number = 1; copy_number < MAX_COPIES; copy_number++) {
    if (player_items[ item+"/"+copy_number ]) n_copies++;
  }
  return n_copies;
}
int set_item_state( mixed pl_name, mixed item, mixed state )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  player_items[ item ] = state;
  return 1;
}
mixed query_all_item_states( mixed pl_name )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  return player_items;
}
int save_all_item_states( mixed pl_name )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    return 0;
  }
  LIBRARY->set_player_quest_info( pl_name, QUEST_INFO_IDENT, player_items );
  return 1;
}
int save_all_item_states_delete_cache( mixed pl_name )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    return 0;
  }
  LIBRARY->set_player_quest_info( pl_name, QUEST_INFO_IDENT, player_items );
  map_delete( item_cache, pl_name );
  return 1;
}

==================================================
FILE: handlers/key_handler.c
==================================================

#define RESTORE_PATH "/save/keys/"
inherit "/std/object";
mapping keys;
mapping key_names;
nosave string _current_group;
private void init_data( string group ) {
   keys = ([ ]);
   key_names = ([ ]);
}
private int get_data_file( string group ) {
   if (_current_group == group) {
      return 1;
   }
   _current_group = group;
   if ( file_size( RESTORE_PATH + group +".o" ) > 0 ) {
      unguarded((: restore_object, RESTORE_PATH + group :));
   } else {
      init_data( group );
      return 0;
   }
   return 1;
}
private void save_data_file( ) {
   unguarded((: save_object, RESTORE_PATH + _current_group :));
}
mapping query_all_keys( string group ) {
   get_data_file( group );
   return keys;
}
private void set_keys( string group, mapping list ) {
   get_data_file( group );
   keys = list;
   save_data_file( );
}
string *query_all_key_permissions( string group, string key ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
      return ({ });
   }
   return keys[ key ];
}
void set_key_permissions( string group, string key, string *types ) {
   get_data_file( group );
   if (sizeof(types)) {
      keys[ key ] = types;
   } else {
      map_delete(keys, key);
   }
   save_data_file( );
}
int query_key_permission( string group, string key, string type ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
      return 0;
   }
   if ( member_array( type, keys[ key ] ) == -1 ) {
      return 0;
   }
   return 1;
}
int add_key_permission( string group, string key, string type ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
       keys[ key ] = ({ });
   }
   if ( member_array( type, keys[ key ] ) != -1 ) {
      return 0;
   }
   keys[ key ] += ({ type });
   save_data_file( );
   return 1;
}
int remove_key_permission( string group, string key, string type ) {
   int i;
   get_data_file( group );
   if ( !keys[ key ] ) {
      return 0;
   }
   if ( ( i = member_array( type, keys[ key ] ) ) == -1 ) {
      return 0;
   }
   keys[ key ] = delete( keys[ key ], i, 1 );
   if (!sizeof(keys[key])) {
      map_delete(keys, key);
   }
   save_data_file( );
   return 1;
}
mapping query_all_key_names( string group ) {
   get_data_file( group );
   return key_names;
}
private void set_key_names( string group, mapping list ) {
   get_data_file( group );
   key_names = list;
   save_data_file( );
}
string query_key_name( string group, string key ) {
   get_data_file( group );
   return key_names[ key ];
}
void set_key_name( string group, string key, string name ) {
   get_data_file( group );
   key_names[ key ] = name;
   save_data_file( );
}
void delete_key_name( string group, string key ) {
   get_data_file( group );
   if ( !key_names[ key ] ) {
      return;
   }
   map_delete( key_names, key );
   save_data_file( );
}

==================================================
FILE: handlers/languages.c
==================================================

#include <language.h>
#define L_NEW 512
#define REPLACEMENTS (["no1":"noone",\
                       "ne1":"anyone",\
                       "any1":"anyone",\
                       "u":"you",\
                       "r":"are", \
                       "NE1":"anyone",\
                       "U":"you",\
                       "R":"are", \
                       "ur":"you are",\
                       "teh":"the", \
                       "some1":"someone", \
                       "c":"see", \
                       "cing":"seeing",\
                       "sum1":"someone",\
                       "urs":"yours",\
                       "thier":"their", \
                       "pls":"please",\
                       "PLZ":"please",\
                       "plz":"please",\
                       "b4":"before", \
                       "tnx":"thanks"])
mapping languages;
string search;
void create() {
  languages = ([
  "rabbit" : ({ L_SPOKEN|L_WRITTEN|L_DISTANCE|L_ALWAYS_SPEAK|L_NEW,
                "/std/languages/rabbit", 10 }),
  "general" : ({ L_SPOKEN|L_WRITTEN|L_DISTANCE|L_ALWAYS_SPEAK,
                "/std/languages/general", 10 }),
  "grunt" : ({ L_SPOKEN | L_ALWAYS_SPEAK, "/std/languages/grunt", 100 }),
  "wommon" : ({ L_WRITTEN|L_SPOKEN|L_DISTANCE|L_MAGIC,
                "/std/languages/wommon", 10 }),
              ]);
  search = "(" + implode(keys(REPLACEMENTS), "|") + ")";
}
int query_language_spoken(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_SPOKEN;
}
int query_language_written(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_WRITTEN;
}
int query_language_distance(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_DISTANCE;
}
int query_language_new(string str) {
  if (!languages[str])
     return 0;
  return languages[str][0]&L_NEW;
}
int query_language_magic(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_MAGIC;
}
int query_language_size(string str) {
  if (!languages[str])
    return 0;
  return languages[str][2];
}
int query_language_always_spoken(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_ALWAYS_SPEAK;
}
mixed squidge_text(string lang, mixed str, int size) {
  if (!languages[lang])
    return 0;
  if (!(languages[lang][0]&L_MAGIC))
    return str[0..(size/languages[lang][2])];
  return (mixed)languages[lang][1]->squidge_text(str, size);
}
int query_flags(string name) {
  if (!languages[name])
    return 0;
  return languages[name][0];
}
string query_garble_object(string name) {
  if (!languages[name])
    return 0;
  return languages[name][1];
}
string *query_languages() {
  return m_indices(languages);
}
int test_language(string str) {
  return pointerp(languages[str]);
}
string query_language_spoken_skill(string lang) {
  return LANGUAGE_SKILL_START + replace(lang, " ", "_") + "." + SPOKEN_SKILL;
}
string query_language_written_skill(string lang) {
  return LANGUAGE_SKILL_START + replace(lang, " ", "_") + "." + WRITTEN_SKILL;
}
mixed garble_say(string lang, string start, string mess,
                 object player, object from, string type) {
   string garble_ob;
   if (query_language_new(lang)) {
      garble_ob = query_garble_object(lang);
      if (living (from) && garble_ob) {
         return garble_ob->garble_say(start, mess, player, from, type,
                                      query_language_spoken_skill(lang),
                                      type == SHOUT_TYPE);
      }
   } else {
      if (player->query_skill(query_language_spoken_skill(lang)) < 99) {
         garble_ob = query_garble_object(lang);
         if(garble_ob)
           return garble_ob->garble_say(start, mess, player, type);
         else
           debug_printf("Error, %s has no garble object.", lang);
      }
   }
   return ({ start, mess });
}
string garble_text(string lang, mixed text, object thing, object player ) {
   string garble_ob;
   if (functionp(text)) {
      text = evaluate(text);
   }
   if (query_language_new(lang)) {
      garble_ob = query_garble_object(lang);
      if (garble_ob) {
         return garble_ob->garble_text(text, thing, player,
                                       query_language_written_skill(lang));
      }
   } else {
      if (player->query_skill(query_language_written_skill(lang)) < 99) {
         garble_ob = query_garble_object(lang);
         if( !garble_ob )
            return "You do not recognise the language.\n";
         else
            return garble_ob->garble_text(text, thing, player);
      }
      if (query_language_magic(lang)) {
         garble_ob = query_garble_object(lang);
         return garble_ob->magical_text(text, thing, player);
      }
      return text;
   }
   if (query_language_magic(lang))
      return 0;
   return "Text written in " + lang + " could not have been written.  "
          "There are "
          "broken bits of letters scattered over the page, looks like "
          "someone had a bad game of scrabble.\n";
}
string do_replacements(string mess) {
  string *bits, name, value;
  mixed *tmp;
  int index, i, add_space;
  mess = replace(mess, ({"ne1 no ", "anyone know "}));
  if(!regexp(mess, search))
    return mess;
  if(mess[<1] == ' ')
    add_space = 1;
  bits = explode(mess, " ");
  foreach(name, value in REPLACEMENTS) {
    tmp = regexp(bits, "(^|[^A-Za-z0-9\\\\./_&-]+)"+name+"($|[^A-Za-z0-9\\./&_-]+)", 1);
    if(sizeof(tmp)) {
      for(i=0; i<sizeof(tmp); i+=2) {
        index = tmp[i+1]-1;
        bits[index] = replace(bits[index], name, value);
      }
    }
  }
  return implode(bits, " ") + (add_space ? " " : "");
}
string fix_shorthand(string mess) {
  string pre, mid, post, res;
  if (!stringp(mess)) {
     return "";
  }
  res = "";
  while(sscanf(mess, "%s'%s'%s", pre, mid, post) == 3) {
    res += do_replacements(pre) + "'" + mid;
    mess = "'" + post;
  }
  res += do_replacements(mess);
  return res;
}

==================================================
FILE: handlers/library.c
==================================================

#include <quest_handler.h>
#include <player_handler.h>
#define XP 10000
#define XP_QUESTS ({"womble's brooch", "balance quest", "easy post quest", \
                    "hard post quest", "apprentice baker" })
#define RESTORE_PATH  "save/library/"
#define MAX_CACHE_SIZE 100
#define CACHE_TIMEOUT 900
inherit "/std/object";
int *times;
string player_name, *quests, text_file;
mapping player_quest_info;
nosave mapping qps;
nosave int requests, cache_hits;
class qinfo {
  int cached;
  string player_name;
  string *quests;
  int *times;
  string text_file;
  mapping player_quest_info;
}
nosave mapping player_cache = ([ ]);
int new_top_quest();
int query_quest_time(string, string);
private void init_data(string pl_name) {
  player_name = pl_name;
  quests = ({ });
  times = ({ });
  text_file = "";
  player_quest_info = ([ ]);
}
void clean_cache() {
  string name;
  foreach(name in keys(player_cache))
    if(player_cache[name]->cached < time() - CACHE_TIMEOUT)
      map_delete(player_cache, name);
}
private int get_data_file(string name) {
  int success;
  class qinfo tmp;
  requests++;
  if(player_cache[name]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }
  success = unguarded((: restore_object, RESTORE_PATH+name[0..0]+"/"+name :));
  if(!success)
    init_data(name);
  tmp = new(class qinfo,
            cached : time(),
            player_name : player_name,
            quests : quests,
            times : times,
            text_file : text_file,
            player_quest_info : player_quest_info);
  player_cache[name] = tmp;
  if((sizeof(player_cache) > MAX_CACHE_SIZE) &&
     (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);
  return success;
}
private void save_data_file(string name) {
  if(!player_cache[name])
    return;
  player_name = player_cache[name]->player_name;
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  text_file = player_cache[name]->text_file;
  player_quest_info = player_cache[name]->player_quest_info;
  unguarded((: save_object, RESTORE_PATH+name[0..0]+"/"+name :));
  return ;
}
string query_title( string name ) {
  string quest;
  get_data_file( name );
  if(!player_cache[name]->quests || !sizeof(player_cache[name]->quests)) {
    return 0;
  }
  quest = player_cache[name]->
    quests[random(sizeof(player_cache[name]->quests))];
  return (string)QUEST_HANDLER->query_quest_title(quest);
}
string *query_quests(string name) {
  get_data_file(name);
  if(!player_cache[name]->quests ) {
    return ({ });
  }
  return player_cache[name]->quests + ({ });
}
string get_most_recent_quest(string name) {
  int loop, highest;
  string quest_name;
  string *quests;
  int *times;
  if(!get_data_file(name))
    return "Sorry";
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  if(sizeof(quests) == 0)
    return "None";
  for(highest = loop = 0; loop < sizeof(quests); loop++) {
    if(times[loop] > highest) {
      highest = times[loop];
      quest_name = quests[loop];
    }
  }
  return quest_name;
}
int get_most_recent_time(string name) {
  int loop, hightime;
  string *quests;
  int *times;
  if(!get_data_file(name)) {
    return -1;
  }
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  if(sizeof(quests) == 0) {
    return 0;
  }
  for(hightime = loop = 0; loop < sizeof(quests); loop++) {
    if(times[loop] > hightime) {
      hightime = times[loop];
    }
  }
  return hightime;
}
int set_quest(string pl_name, string qu_name, int no_xp) {
  int qu_level;
  object ob;
  object card;
  int i;
  if(!find_player(pl_name) || find_player(pl_name)->query_property("guest"))
    return 0;
  i = QUEST_HANDLER->query_quest_status(qu_name);
  ob = find_player (pl_name);
  if (i == 0 && ob->query_playtester()) {
    tell_object (ob, "%^BOLD%^If this quest weren't inactive, you'd be "
      "showered in riches right about now!\n%^RESET%^");
  }
  if(i < 1) {
   user_event( "inform", pl_name +" completes "+ qu_name + " (inactive)", "quest");
    return 0;
  }
  if (ob && ob->advancement_restriction()) {
    log_file ("/log/secure/playtesters/protection_log", "%s: %s "
      "completed quest %s while advancement restricted active.\n", ctime(time()),
      pl_name, qu_name);
    return 0;
  }
  if(qps && qps[pl_name])
    map_delete(qps, pl_name);
  get_data_file(pl_name);
  if ( member_array( qu_name, player_cache[pl_name]->quests ) != -1 )
    return 0;
  player_cache[pl_name]->quests += ({ qu_name });
  player_cache[pl_name]->times += ({ time() });
  qu_level = (int)QUEST_HANDLER->query_quest_level(qu_name);
  if ( qu_level < 1 )
    return 0;
  QUEST_HANDLER->quest_completed( pl_name, qu_name, previous_object() );
  save_data_file( pl_name );
  if ( !ob ) {
    return 0;
  }
  if(member_array(qu_name, XP_QUESTS) != -1) {
    ob->adjust_xp(XP*qu_level, 0);
    call_out("save_them", 1, ob);
  }
  ob->set_title( "quest",
                 (string)QUEST_HANDLER->query_quest_title( qu_name ) );
  card = clone_object ("/d/underworld/creator_cards/creator_card");
  card->move (ob, "$N appear$s in your inventory with a flash.");
  return 1;
}
int unset_quest(string pl_name, string qu_name) {
  int qu_level;
  get_data_file(pl_name);
  if ( member_array( qu_name, player_cache[pl_name]->quests ) == -1 )
    return 0;
  qu_level = (int)QUEST_HANDLER->query_quest_level(qu_name);
  if ( qu_level < 1 )
    return 0;
  player_cache[pl_name]->quests -= ({ qu_name });
  player_cache[pl_name]->times -= ({ time() });
  save_data_file( pl_name );
  return 1;
}
void save_them( object thing ) {
  if ( thing )
    thing->save_me();
}
void set_player_quest_info( string pl_name, string qu_info, mixed *details ) {
  get_data_file( pl_name );
  if(!player_cache[pl_name]->player_quest_info )
    player_cache[pl_name]->player_quest_info = ([ ]);
  player_cache[pl_name]->player_quest_info[qu_info] = details;
  save_data_file(pl_name);
}
mapping query_all_player_quest_info( string pl_name ) {
  if(!get_data_file( pl_name ))
    return 0;
  if ( !player_cache[pl_name]->player_quest_info )
    return 0;
  return copy(player_cache[pl_name]->player_quest_info);
}
mixed *query_player_quest_info( string pl_name, string qu_info ) {
  if(!get_data_file( pl_name))
    return 0;
  if(!player_cache[pl_name]->player_quest_info)
    return 0;
  player_cache[pl_name]->player_quest_info =
    player_cache[pl_name]->player_quest_info + ([ ]);
  return player_cache[pl_name]->player_quest_info[qu_info];
}
int query_quest_time(string name, string qu_name) {
  int time;
  if(!get_data_file(name)) {
    return 0;
  }
  time = member_array(qu_name, player_cache[name]->quests);
  if(time < 0) {
    return 0;
  }
  return player_cache[name]->times[time];
}
string query_story(string name) {
  string story, *quests;
  int loop;
  if(!get_data_file(name)) {
    return "You can find nothing in the library on " + name + "\n";
  }
  story = "";
  if(player_cache[name]->text_file != "") {
    return unguarded((: read_file, text_file :));
  }
  quests = player_cache[name]->quests;
  if(!sizeof(quests)) {
    return "That person has lead a most unadventureous life";
  }
  for(loop = 0; loop < sizeof(quests); loop++) {
    story += capitalize(QUEST_HANDLER->query_quest_story(quests[loop])) +".\n";
  }
  return story;
}
int query_quest_done(string player, string quest) {
  if(!get_data_file(player))
    return 0;
  return (member_array(quest, player_cache[player]->quests) != -1);
}
int flush_cache (string name) {
  qps[name] = 0;
}
int query_quest_points( string name ) {
   int points;
   string word;
   string *quests;
   if(!qps)
     qps = ([ ]);
   if(qps[name])
     return qps[name]-1;
   get_data_file( name );
   quests = player_cache[name]->quests;
   if ( !quests || !sizeof( quests ) )
      points = 0;
   else {
     foreach( word in quests ) {
       points += (int)QUEST_HANDLER->query_quest_level( word );
     }
   }
   qps[name] = points+1;
   return points;
}
int restart(mixed name) {
  class qinfo tmp;
  if(objectp(name))
    name = name->query_name();
  if(!PLAYER_HANDLER->test_user(name))
    return 0;
  init_data(name);
  tmp = new(class qinfo,
            cached : time(),
            player_name : player_name,
            quests : quests,
            times : times,
            text_file : text_file,
            player_quest_info : player_quest_info);
  player_cache[name] = tmp;
  save_data_file(name);
  return 1;
}
mixed *stats() {
  int percentage;
  if(requests)
    percentage = (cache_hits * 100) / requests;
  return ({
    ({ "cache size", sizeof(player_cache) }),
      ({ "requests", requests }),
      ({ "cache hits", cache_hits }),
      ({ "cache misses", requests - cache_hits }),
      ({ "percentage hits", percentage }),
      });
}

==================================================
FILE: handlers/livings.c
==================================================

private nosave mapping _lnames = ([]);
private nosave mapping _players = ([]);
#ifdef 0
void create() {
  object player, *players;
  players = filter(efun::users(), (: $1 && inherits("/std/container", $1) :));
  foreach(player in players) {
    _players[player->query_name()] = player;
  }
}
#endif
private void check_lnames(string* names) {
   string key;
   foreach (key in names) {
      mixed bing = _lnames[key];
      if (arrayp(bing)) {
         bing -= ({ 0 });
         if (sizeof(bing)) {
            _lnames[key] = bing;
         }
         else {
            map_delete(_lnames, key);
         }
      }
      else {
         map_delete(_lnames, key);
      }
   }
}
private void check_players(string* names) {
   string key;
   foreach (key in names) {
      mixed bing = _players[key];
      if (arrayp(bing)) {
         bing -= ({ 0 });
         if (sizeof(bing)) {
            _players[key] = bing;
         }
         else {
            map_delete(_players, key);
         }
      }
      else {
         map_delete(_players, key);
      }
   }
}
void remove_garbage(){
  string* names;
  int i;
  names = keys(_lnames);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_lnames :), i / 25, names[i..i+50]);
  }
  names = keys(_players);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_players :), i / 25, names[i..i+50]);
  }
}
void enable_commands(object ob){
}
void set_living_name(string name, object ob){
  if (!stringp(name) || !objectp(ob)) {
    return ;
  }
  if(!_lnames[name]) {
    _lnames[name] = ({ob});
  } else {
    _lnames[name] += ({ob});
  }
  if ( ob == master() ) {
     log_file( "LIVINGS", "%O (%s) became a living. %O\n", ob,
         name, call_stack(0) );
  }
}
object *named_livings(){
  object *ret;
  ret = keys(_lnames);
  ret = map(ret, (:$1?(_lnames)[$1]:0:));
  reset_eval_cost();
  ret = filter(ret, (:$1:));
  reset_eval_cost();
  ret = implode(ret, (:$1 + $2:));
  reset_eval_cost();
  ret = filter(ret, (:$1:));
  return ret;
}
object find_living(string it) {
  if(_lnames[it]) {
    _lnames[it] = filter(_lnames[it], (: $1 :));
    if(sizeof(_lnames[it]))
      return _lnames[it][<1];
  }
  return 0;
}
object find_player(string it) {
  object *people;
  int t = real_time();
  object *tmp;
  if(_players[it]) {
      return _players[it];
    return 0;
  }
  people = filter(efun::users(), (: $1 && $1->query_name() == $(it) &&
                                  inherits("/std/container", $1):));
  if(sizeof(people)) {
    _players[it] = people[0];
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (1)\n",
               real_time() - t, it);
      return _players[it];
  }
  if(!_lnames[it]) {
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (2)\n",
               real_time() - t, it);
    return 0;
  }
  tmp = filter(_lnames[it], (: $1 && userp($1) :));
  if(real_time() - t > 1)
    log_file("GARBAGE", "find_player took %d seconds to find %s (3)\n",
             real_time() - t, it);
  if(sizeof(tmp))
    return tmp[0];
  return 0;
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "lnames" : _lnames,
            "players" : _players,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   object ob;
   string name;
   if (maps["lnames"])
      _lnames = maps["lnames"];
   if (maps["players"])
      _players = maps["players"];
   foreach(ob in efun::users()){
      if ( !ob ) {
        continue;
      }
      name = ob->query_name();
      _players[name] = ob;
      if(!_lnames[name]){
        _lnames[name] = ({ob});
      } else {
        _lnames[name] |= ({ob});
      }
   }
}
mixed *stats() {
  return ({ ({ "lnames", sizeof(keys(_lnames)) }),
              ({ "players", sizeof(keys(_players)) })});
}

==================================================
FILE: handlers/login_handler.c
==================================================

#include <login.h>
#ifdef LOGIN_DEBUG
#undef MAX_COMPRESSED_PLAYERS
#undef MAX_UNCOMPRESSED_PLAYERS
#undef MAX_PLAYERS
#define LOGIN_MAX_COMPRESSED_PLAYERS 2
#define MAX_UNCOMPRESSED_PLAYERS 1
#define MAX_PLAYERS (MAX_COMPRESSED_PLAYERS + MAX_UNCOMPRESSED_PLAYERS)
#endif
#ifdef LOGIN_DEBUG
#define is_compressed_login(x) (strsrch((x)->query_name(), "test") > -1)
#else
#define is_compressed_login(x) (compressedp(x))
#endif
#define COMPRESSED_INTAKE_COUNT 5
#ifdef USE_RAMDISK
#define SAVE_TIME 300
#else
#define SAVE_TIME 900
#endif
#define NEW_SAVE_TIME 15
#define SAVE_NAME "/save/login_handler"
#define BUFFER_TIME 30
#define LOCKDOWN_TIME 900
#define MAX_FAILURES 3
class login_information {
    mixed ob;
    string funct;
}
mapping _static_login_calls;
nosave mapping _dynamic_login_calls;
nosave string _best;
nosave string _worst;
nosave string *_players_on;
nosave mapping _compressed_players_on;
nosave mapping _telnet_players_on;
nosave object *_compressed_login_queue;
nosave object *_telnet_login_queue;
nosave int _compressed_login_count;
nosave string enter_log;
nosave int last_entry;
nosave mapping messages;
nosave mapping lockdowns;
nosave int _creators;
nosave int _players;
nosave int _login_q;
nosave int _next_user_log;
nosave int _title_call;
nosave int _save_call;
nosave int _out_q;
nosave int _q_time;
nosave int _last_queue_time;
nosave int _last_queue_result;
int is_discworld_full(int test_login_queue);
void write_log(string event, string name, int guest, string other);
void save_users();
private void store_user_count();
private void log_user_count();
protected void check_all_titles( string player );
private void do_all_calls(string player, string event);
private void do_call(class login_information login_inf,
  string player, int event);
int is_uncompressed_full( int );
void create() {
    object pl;
    string name;
    _static_login_calls = ([ ]);
    _dynamic_login_calls = ([ ]);
    seteuid( "Root" );
    unguarded((: restore_object, SAVE_NAME :));
    foreach(name in keys(_static_login_calls)) {
      if(!sizeof(_static_login_calls[name])) {
        map_delete(_static_login_calls, name);
      }
      catch(unguarded((: save_object, SAVE_NAME :)));
    }
    _compressed_players_on = ([ ]);
    _telnet_players_on = ([ ]);
    _players_on = ({ });
    foreach(pl in users()) {
        if (is_compressed_login(pl)) {
            _compressed_players_on[ pl->query_name() ] = 1;
        }
        else {
            _telnet_players_on[ pl->query_name() ] = 1;
        }
        _players_on += ({ pl->query_name() });
    }
    _compressed_login_queue = ({ });
    _telnet_login_queue = ({ });
    _compressed_login_count = 1;
    _save_call = call_out( "save_users", NEW_SAVE_TIME );
    _next_user_log = time() + 3601 - (time() % 3600);
    enter_log = "";
    last_entry = time();
    call_out("clean_lockdowns", 3600);
    write_log("Periodic", "", 0, "");
}
mapping query_static_login_calls() {
    return copy(_static_login_calls);
}
mapping query_dynamic_login_calls() {
    return copy(_dynamic_login_calls);
}
string query_best() { return _best; }
string query_worst() { return _worst; }
string *query_players_on() {
    return keys( _compressed_players_on ) + keys( _telnet_players_on );
}
object *query_login_queue() {
    return _compressed_login_queue + _telnet_login_queue;
}
void add_to_login_queue(object login_ob) {
    if ( is_compressed_login( login_ob ) ) {
        _compressed_login_queue += ({ login_ob });
    }
    else {
        _telnet_login_queue += ({ login_ob });
    }
}
void remove_from_login_queue(object ob) {
    _compressed_login_queue -= ({ ob });
    _telnet_login_queue -= ({ ob });
}
int can_jump_queue( object ob ) {
    return ob->query_creator() || ob->query_net_dead() ||
        ob->query_property( "test character" );
}
object pop_from_login_queue() {
    object ob;
    object *login_queue;
    login_queue = query_login_queue();
    if ( !sizeof( login_queue ) ) {
        return 0;
    }
    if(time() != _q_time){
      _q_time = time();
      _out_q = 0;
    }
    _out_q++;
    foreach( ob in _compressed_login_queue ) {
        if ( can_jump_queue( ob ) ) {
            remove_from_login_queue( ob );
            return ob;
        }
    }
    reset_eval_cost();
    if(sizeof(_telnet_login_queue) &&
       !is_uncompressed_full(WITHOUT_LOGIN_QUEUE)) {
      foreach( ob in _telnet_login_queue ) {
        if ( can_jump_queue( ob ) ) {
          remove_from_login_queue( ob );
          return ob;
        }
      }
    }
    if ( sizeof( _compressed_login_queue) &&
         _compressed_login_count < COMPRESSED_INTAKE_COUNT ) {
        _compressed_login_count++;
        ob = _compressed_login_queue[ 0 ];
        _compressed_login_queue = _compressed_login_queue[ 1.. ];
    } else {
        _compressed_login_count = 0;
        ob = _telnet_login_queue[ 0 ];
        _telnet_login_queue = _telnet_login_queue[ 1.. ];
    }
    return ob;
}
int add_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;
  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }
  if(obj[0..3] == "/w/")
    return 0;
  if(_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
    login_inf->funct == funct) {
  return 1;
      }
    }
  }
  if (!_static_login_calls[player]) {
    _static_login_calls[player] = ({ });
  }
  login_inf = new (class login_information, funct : funct, ob : obj);
  _static_login_calls[player] += ({ login_inf });
  catch(unguarded((: save_object, SAVE_NAME :)));
  return 1;
}
int remove_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;
  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
          login_inf->funct == funct) {
        _static_login_calls[player] -= ({ login_inf });
        if(!sizeof(_static_login_calls[player]))
          map_delete(_static_login_calls, player);
        catch(unguarded((: save_object, SAVE_NAME :)));
        return 1;
      }
    }
  }
  return 0;
}
int add_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;
    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }
    if (!_dynamic_login_calls[player]) {
        _dynamic_login_calls[player] = ({ });
    }
    login_inf = new (class login_information, funct : funct, ob : obj);
    _dynamic_login_calls[player] += ({ login_inf });
    return 1;
}
int remove_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;
    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }
    if (_dynamic_login_calls[player]) {
        foreach (login_inf in _dynamic_login_calls[player]) {
            if (login_inf->ob == obj &&
              login_inf->funct == funct) {
                _dynamic_login_calls[player] -= ({ login_inf });
                return 1;
            }
        }
    }
    return 0;
}
void update_players_on( string player ) {
    object ob = find_player( player );
    if ( !ob ) {
        return;
    }
    if ( is_compressed_login( ob ) ) {
        if ( undefinedp( _compressed_players_on[ player ] ) ) {
            _compressed_players_on[ player ] = 1;
        }
    }
    else {
        if ( undefinedp( _telnet_players_on[ player ] ) ) {
            _telnet_players_on[ player ] = 1;
        }
    }
    if ( member_array( player, _players_on ) == -1 ) {
        _players_on += ({ player });
    }
}
int tidy_players_on( string player ) {
    int pos;
    int ret;
    ret = 0;
    if ( _compressed_players_on[ player ] ) {
        map_delete( _compressed_players_on, player );
        ret = 1;
    }
    if ( _telnet_players_on[ player ] ) {
        map_delete( _telnet_players_on, player );
        ret = 1;
    }
    pos = member_array( player, _players_on );
    if ( pos != -1 ) {
        _players_on = _players_on[0..pos-1] + _players_on[pos+1..];
        ret = 1;
    }
    return ret;
}
int player_logon(string player, int guest, string ip) {
    if(lower_case(player) != (string)previous_object()->query_name()) {
        return 0;
    }
    update_players_on( player );
    do_all_calls(player, LOGIN);
    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player );
    }
    write_log("Enter", player, guest, ip);
}
private void do_all_calls(string player, string event_t) {
  class login_information login_inf;
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_static_login_calls["all"]) {
    foreach (login_inf in _static_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls[player]) {
    foreach (login_inf in _dynamic_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls["all"]) {
    foreach (login_inf in _dynamic_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
}
private void do_call(class login_information login_inf,
                     string player, int event_t) {
  object ob;
  if (!find_player(player) || find_player(player)->query_invis() < 2) {
    if (!functionp(login_inf->funct)) {
      if(login_inf->ob && login_inf->funct)
        catch(ob = load_object(login_inf->ob));
      if ( ob ) {
        catch(call_other(ob, login_inf->funct, player,
                         event_t));
      } else {
        tell_creator("ceres", "failed to load %s", login_inf->ob);
      }
    } else {
      catch(evaluate(login_inf->funct, player, event_t));
    }
  }
}
int player_logout(string player) {
    object ob;
    do_all_calls(player, LOGOUT);
    if ( tidy_players_on( player ) ) {
        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }
    if(find_call_out(_save_call) == -1) {
        _save_call = call_out("save_users", NEW_SAVE_TIME );
    }
    while (sizeof(query_login_queue()) &&
        !is_discworld_full(WITHOUT_LOGIN_QUEUE) ) {
        ob = pop_from_login_queue();
        if (ob) {
            ob->remove_from_login_queue();
        }
    }
    write_log("Exit", player, 0, "");
    return 1;
}
int player_net_dead(string player) {
    object ob;
    if ( tidy_players_on( player ) ) {
        do_all_calls(player, NETDEATH);
        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }
    while ( sizeof(query_login_queue()) && !is_discworld_full(WITHOUT_ANY_LOGINS) ) {
        ob = pop_from_login_queue();
        if (ob) {
            ob->remove_from_login_queue();
        }
    }
    write_log("NDead", player, 0, "");
    return 1;
}
int player_reconnected(string player) {
    update_players_on(player);
    do_all_calls(player, RECONNECT);
    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player);
    }
    write_log("Recon", player, 0, query_ip_name(find_player(player)));
}
protected void check_all_titles( string player ) {
    int al, good, bad;
    object good_thing, bad_thing, thing, *things;
    good = -250;
    bad = 250;
    things = users();
    foreach( thing in things ) {
      if (!thing || thing->query_creator() ) {
        continue;
      }
      al = (int)thing->query_al();
      if ( al > bad ) {
        bad = al;
        bad_thing = thing;
      }
      if ( al < good ) {
        good = al;
        good_thing = thing;
      }
    }
    if ( bad_thing ) {
      if ( stringp( _worst ) && ( _worst != player ) ) {
        thing = find_player( _worst );
      } else {
        thing = 0;
      }
      if ( bad_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)bad_thing->query_gender() ) {
        case 1 :
          bad_thing->set_title( "align", "Lord of Darkness" );
          break;
        case 2 :
          bad_thing->set_title( "align", "Lady of Darkness" );
          break;
        default :
          bad_thing->set_title( "align", "Monster of Darkness" );
        }
        _worst = (string)bad_thing->query_name();
      }
    }
    if ( good_thing ) {
      if ( stringp( _best ) && ( _best != player ) ) {
        thing = find_player( _best );
      } else {
        thing = 0;
      }
      if ( good_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)good_thing->query_gender() ) {
        case 1 :
          good_thing->set_title( "align", "Lord of Light" );
          break;
        case 2 :
          good_thing->set_title( "align", "Lady of Light" );
          break;
        default :
          good_thing->set_title( "align", "Creature of Light" );
        }
        _best = (string)good_thing->query_name();
      }
    }
}
void save_users() {
    int number;
    int next_time;
    string word;
    object thing;
    number = sizeof( _players_on );
    if ( !number ) {
        _players_on = query_players_on();
        _save_call = call_out("save_users", NEW_SAVE_TIME );
        return;
    }
    store_user_count();
    if(_next_user_log < time()) {
        log_user_count();
    }
    word = _players_on[ 0 ];
    thing = find_player( word );
    if ( objectp( thing ) && ( number > 1 ) ) {
        if ( environment( thing ) ) {
            thing->save_me();
        }
        _players_on = _players_on[1..] + ({ word });
    } else {
        _players_on = _players_on[1..] + ({ word });
    }
    next_time = SAVE_TIME / number;
    if ( next_time > 10 ) {
        next_time = 10;
    }
    _save_call = call_out( (: save_users :), next_time );
}
int int_is_discworld_full(int logins) {
    object *players;
    int compressed;
    int uncompressed;
    int ret;
    int ext;
    players = users();
    switch (logins) {
    case WITHOUT_LOGINS_NOT_IN_QUEUE :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :)) + query_login_queue();
        break;
    case WITHOUT_LOGIN_QUEUE :
        players -= query_login_queue();
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    case WITHOUT_ANY_LOGINS :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :));
        ext = _out_q;
        break;
    default :
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    }
    if(time() != _q_time){
      ext = 0;
      _out_q = 0;
      _q_time = time();
    }
    compressed = sizeof( filter( players, (: is_compressed_login($1) :) )  ) + ext;
    uncompressed = sizeof( players ) - compressed;
    ret = DISCWORLD_IS_EMPTY;
    if ( compressed >= MAX_COMPRESSED_PLAYERS ) {
        ret |= COMPRESSED_FULL;
    }
    if ( uncompressed >= MAX_UNCOMPRESSED_PLAYERS ) {
        ret |= UNCOMPRESSED_FULL;
    }
    return ret;
}
int is_compressed_full( int logins ) {
    return int_is_discworld_full( logins ) & COMPRESSED_FULL;
}
int is_uncompressed_full( int logins ) {
    return int_is_discworld_full( logins ) & UNCOMPRESSED_FULL;
}
int is_discworld_full(int logins) {
    int ret;
    ret = int_is_discworld_full( logins );
    ret = (ret & COMPRESSED_FULL) && (ret & UNCOMPRESSED_FULL);
    return ret;
}
private void store_user_count() {
    object pl;
    int current_players, current_creators, current_login_q;
    string *logins_n;
    foreach(pl in users()) {
      if (pl && !pl->query_login_ob()) {
        if (pl->query_creator()) {
          current_creators++;
        } else {
          current_players++;
        }
      }
    }
    logins_n = map(LOGIN_HANDLER->query_login_queue(),
      (: $1->query_cap_name() :));
    logins_n = sort_array(logins_n, 1);
    current_login_q = sizeof(logins_n);
    if(current_players + current_login_q > _players + _login_q) {
        _players = current_players;
        _creators = current_creators;
        _login_q = current_login_q;
    }
}
private void log_user_count() {
    log_file("USERS", "%s %d %d %d\n" ,ctime(time()), _creators, _players,
      _login_q);
    _creators = 0;
    _players = 0;
    _login_q = 0;
    _next_user_log = time() + 3601 - (time() % 3600);
}
void write_log(string event, string name, int guest, string other) {
    switch(event) {
    case "Enter":
        enter_log += sprintf( "%s [Enter] %-15s %s%s\n",
          ctime(time())[4..18], name,
          guest?"(guest) ":"",
          other);
        break;
    case "Su":
        enter_log += sprintf( "%s [Su]    %15-s %15-s\n",
          ctime(time())[4..18], name, other);
        break;
    case "Periodic":
        call_out("write_log", BUFFER_TIME, "Periodic", "", 0, "");
        if (sizeof(enter_log) && time() - last_entry > BUFFER_TIME) {
            unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
            enter_log = "";
            last_entry = time();
        }
        return;
    case "Recon":
        enter_log += sprintf( "%s [Recon] %15-s %s\n",
          ctime(time())[4..18], name, other);
        break;
    default:
        enter_log += sprintf("%s %-7s %15-s\n", ctime(time())[4..18],
          "["+event+"]", name);
        break;
    }
    last_entry = time();
    if(sizeof(enter_log) > 1024) {
        unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
        enter_log = "";
    }
}
void dest_me() {
    unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
    enter_log = "";
    destruct(this_object());
}
string get_message(string mess_name) {
    if(!messages)
        messages = ([ ]);
    if(mess_name[0..4] != "/doc/")
        return 0;
    if(!messages[mess_name])
        messages[mess_name] = read_file(mess_name);
    return messages[mess_name];
}
void clear_messages() {
    messages = ([ ]);
}
int site_lockeddown(string ip_addr) {
    if(!lockdowns)
        lockdowns = ([ ]);
    if(lockdowns[ip_addr] &&
      (sizeof(lockdowns[ip_addr]) >= MAX_FAILURES) &&
      (lockdowns[ip_addr][0] > time() - LOCKDOWN_TIME))
        return 1;
    return 0;
}
void failed_login(string ip_addr) {
  int i;
  if(!lockdowns)
    lockdowns = ([ ]);
  if(!lockdowns[ip_addr])
    lockdowns[ip_addr] = ({ time() });
  else {
    for(i=0; i<sizeof(lockdowns[ip_addr]); i++)
      if(lockdowns[ip_addr][i] < time() - LOCKDOWN_TIME) {
        lockdowns[ip_addr] -= ({ lockdowns[ip_addr][i] });
        i--;
      }
    lockdowns[ip_addr] += ({ time() });
    if(sizeof(lockdowns[ip_addr]) > MAX_FAILURES) {
      lockdowns[ip_addr] =
        lockdowns[ip_addr][sizeof(lockdowns[ip_addr])-MAX_FAILURES..];
    }
  }
}
void clean_lockdowns() {
  string ip;
  call_out("clean_lockdowns", 1800);
  foreach(ip in keys(lockdowns)) {
    if(lockdowns[ip][sizeof(lockdowns[ip])-1] < time() - LOCKDOWN_TIME) {
      map_delete(lockdowns, ip);
    }
  }
}
void clear_lockdowns(string ip) {
  if(!ip)
    lockdowns = ([ ]);
  else if(lockdowns[ip])
    map_delete(lockdowns, ip);
}
void query_lockdowns() {
    printf("%O\n", lockdowns);
}
void reset() {
    if (find_call_out(_save_call) == -1) {
        save_users();
    }
}

==================================================
FILE: handlers/mag_eff_handler.c
==================================================

#define BLACK_MASS 1000
#define NUM_POSS 6
#define NUM_USER 20
private mixed *_octonite;
private int _call_out_no;
protected void update_octonite();
protected void schedule_next();
int block( object thing ) {
   if ( !thing->query_closed() )
      return 0;
   return (int)thing->query_property( "enchantment block" );
}
int ambient_enchantment( object thing ) {
   int i, total;
   object *tops;
   tops = ({ thing });
   while ( environment( tops[ 0 ] ) ) {
      tops = ({ environment( tops[ 0 ] ) }) + tops;
   }
   for ( i = 0; i < sizeof( tops ); i++ ) {
      total += (int)tops[ i ]->query_enchant();
      total = ( total * ( 100 - block( tops[ i ] ) ) + 50 ) / 100;
   }
   return total;
}
int *choose_effect( int number ) {
  return ({ number, random( NUM_POSS * number ) / BLACK_MASS });
}
void do_effect( int number, string name, object place ) {
  int i;
  string word;
  object thing, *things;
  switch( number ) {
    case 0:
      tell_room( place, "How curious.\n" );
      break;
    case 1:
      tell_room( place, name +" spins slowly in mid-air, then "+
        "vanishes with a small \"pop!\"\n" );
      break;
    case 2:
      i = random( 4 );
      tell_room( place, name +" sparkles and turns into a small "+
        ({ "yellow", "green", "hairy", "spotted" })[ i ] +" caterpillar.\n" );
      thing = clone_object( "/obj/monster" );
      thing->set_name( "caterpillar" );
      thing->set_short( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillar" );
      thing->add_adjective( ({ "yellow", "green", "hairy", "spotted" })[ i ] );
      thing->set_main_plural( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillars" );
      thing->add_plural( "caterpillars" );
      thing->set_long( "This is a small, common or garden caterpillar.\n" );
      thing->set_race( "caterpillar" );
      thing->set_level( 1 );
      thing->move( place );
      break;
    case 3:
      tell_room( place, name +" vanishes with a sharp \"spang!\"\n"+
        "A moment later, you hear a small thunderclap.\n" );
      break;
    case 4:
      tell_room( place, "Balefire blossoms, and "+ name +" turns into "+
        "a bunch of flowers.\n" );
      thing = clone_object( "/std/object" );
      thing->set_name( "flowers" );
      thing->set_short( "bunch of flowers" );
      thing->set_main_plural( "bunches of flowers" );
      thing->add_adjective( ({ "bunch", "bunches", "of" }) );
      thing->add_plural( "bunches" );
      thing->set_long( "A nice bunch of flowers.\n" );
      thing->set_weight( 10 );
      thing->set_value( 100 );
      thing->move( place );
      break;
    case 5:
      tell_room( place, "With a small gout of flame, "+ name +" begins "+
        "to accelerate.\n" );
      switch( (string)place->query_property( "location" ) ) {
        case "outside":
          tell_room( place, name +" vanishes into the distance.\n" );
          break;
        default:
          tell_room( place, "There is a small puff of burning dust as "+
            name +" passes through a wall.\n" );
      }
      things = users() - all_inventory( place );
      if ( sizeof( things ) > ( i = random( NUM_USER ) ) ) {
        if ( !( thing = environment( things[ i ] ) ) ) break;
        tell_object( find_player( "deutha" ),
            (string)things[ i ]->query_name() +"\n" );
        tell_room( thing, "You hear a high-pitched whine.\n" );
        tell_object( things[ i ], "Something small and very hot zooms past "+
          "you at ear level.\n" );
        if ( ( !( word = (string)things[ i ]->query_short() ) || ( word == "" )
          ) || things[ i ]->query_invis() ) break;
        tell_room( thing, word +" looks shaken.\n", things[ i ] );
      }
      break;
    default:
      tell_room( place, "Something really, really strange happens.\n" );
  }
}
object *query_octonite_crystals() { return _octonite; }
void add_octonite_crystal( object crystal ) {
   int i, when;
   when = time() + roll_MdN( 5, 60 );
   if ( !sizeof( _octonite ) ) {
      _octonite = ({ crystal, when });
      schedule_next();
   } else {
      for ( i = 0; i < sizeof( _octonite ); i += 2 ) {
         if ( when < _octonite[ i + 1 ] ) {
            break;
         }
      }
      if ( i == 0 ) {
         _octonite = ({ crystal, when }) + _octonite;
         schedule_next();
         return;
      }
      if ( i >= sizeof( _octonite ) ) {
         _octonite += ({ crystal, when });
         return;
      }
      _octonite = _octonite[ 0 .. i - 1 ] + ({ crystal, when }) +
            _octonite[ i ..  ];
   }
}
protected void schedule_next() {
   int next;
   remove_call_out(_call_out_no);
   next = _octonite[ 1 ] - time();
   if ( next > 0 ) {
      _call_out_no = call_out( (: update_octonite :), next );
   } else {
      _call_out_no = call_out( (: update_octonite :), 0 );
   }
}
protected void update_octonite() {
   int ambient, weight;
   object crystal;
   crystal = _octonite[ 0 ];
   if ( objectp( crystal ) ) {
      weight = 20 * (int)crystal->query_weight();
      tell_object( find_player( "deutha" ), "Current: "+ weight +".\n" );
      ambient = ambient_enchantment( crystal );
      if ( ambient > weight ) {
         weight += ( ambient - weight ) / 4;
      }
      weight -= ( weight * ( 100 - block( environment( crystal ) ) ) ) / 800;
      if ( random( 20 ) < weight % 20 ) {
         weight += 20;
      }
      weight /= 20;
      if ( !weight )
         crystal->dest_me();
      else {
         crystal->set_weight( weight );
         crystal->set_enchant( ( 7 * (int)crystal->query_max_enchant() ) / 8 );
         crystal->set_value_info( "magic", weight * 10000 );
      }
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
      if ( crystal ) {
         add_octonite_crystal( crystal );
      }
   } else {
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
   }
}
string extra_look( object thing ) {
   if ( explode( file_name( thing ), "#" )[ 0 ] != "/obj/magic/octonite" ) {
      return "";
   }
   switch ( (int)thing->query_weight() ) {
      case 0 :
         return "";
      case 1 .. 2 :
         return "It is about the size of a pea.\n";
      case 3 .. 6 :
         return "It is about the size of a hazelnut.\n";
      case 7 .. 12 :
         return "It is about the size of a walnut.\n";
      case 13 .. 20 :
         return "It is about the size of an orange.\n";
      case 21 .. 30 :
         return "It is about the size of a grapefruit.\n";
      default :
         return "It is about the size of a pumpkin.\n";
   }
}

==================================================
FILE: handlers/mail_track.c
==================================================

inherit "std/object";
#include <mail.h>
#include <mail_track.h>
#include <player_handler.h>
#define SECURITY if (!master()->query_leader(previous_object(-1))) return 0;
int add_member(string list, string mem);
private void load_me();
private void save_me();
int query_list(string list);
int create_list(string list, string creator);
nosave mixed *our_mailers;
mapping mailing_lists;
void setup() {
   set_name("tracker");
   set_short("mail tracker");
   add_property("determinate", "the ");
   add_property("there", "mounted on one wall");
   add_adjective("mail");
   set_long("This thing tracks mail.   Clever, innit?\n");
   reset_get();
   reset_drop();
   our_mailers = ({ });
   mailing_lists = ([ ]);
   seteuid("Root");
   load_me();
   if (!query_list("postmaster")) {
      create_list("postmaster", "pinkfish");
   }
   move(MAIL_ROOM);
}
int add_mailer(object ob, string str) {
   int i;
   if (!stringp(str) || !objectp(ob)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      our_mailers += ({ ob, str });
   } else {
      write(i);
      if (our_mailers[i-1]) {
         our_mailers[i-1]->dest_me();
      }
      our_mailers += ({ ob, str });
   }
   return 1;
}
object find_mailer(string str) {
   int i;
   if (!stringp(str)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      return 0;
   }
   return our_mailers[i-1];
}
int delete_mailer(object ob) {
   int i;
   if (!objectp(ob)) {
      return 0;
   }
   i = member_array(ob, our_mailers);
   if (i == -1) {
      return 0;
   }
   our_mailers = delete(our_mailers, i, 2);
}
void we_are_done(object me) {
   if (objectp(me)) {
      me->dest_me();
   }
}
int mail(string str, string sub) {
   object mailer;
   mailer = clone_object(MAILER);
   mailer->set_do_this_last(({ this_object(), "we_are_done", mailer }));
   mailer->read_mail(str, sub);
   return 2;
}
private void save_me() {
   unguarded((: save_object, "/save/mail_track" :));
}
private void load_me() {
   string *list_names, name;
   mixed *list;
   unguarded((: restore_object, "/save/mail_track" :));
   list_names = keys(mailing_lists);
   if (sizeof(list_names) && !classp(mailing_lists[list_names[0]])) {
      foreach (name, list in mailing_lists) {
         mailing_lists[name] = new(class mailing_list, members : list[0],
                                                controllers : list[1], creator : list[2]);
      }
      save_me();
   }
}
string *query_mailing_lists() {
   return keys(mailing_lists) +
     "/secure/master"->query_domains() +
      ({ "seniors", "lords", "hlords" });
}
int query_list(string list) {
   return member_array(list, query_mailing_lists()) != -1;
}
string *query_members(string list) {
  string *tmp;
  switch (list) {
  case "playtesters" :
    tmp = (string *)"/obj/handlers/playtesters"->query_playtesters();
    return ({ "/d/playtesters/master"->query_lord() }) + sort_array(tmp, 1);
  case "seniors" :
    tmp = (string *)master()->query_all_seniors();
    return tmp;
  case "lords" :
    tmp = (string *)master()->query_all_leaders();
    return tmp;
  case "hlords" :
    tmp = ((string *)master()->query_administrators() -
           ({ "Admin", "Root", "offler" }));
    return tmp;
  default :
  }
  if (file_size("/d/"+ list) == -2) {
    tmp = (string *)("/d/"+ list +"/master")->query_members() +
      ({ (string)("/d/"+ list +"/master")->query_lord() });
  }
  else if (mailing_lists[list]) {
    tmp = copy(mailing_lists[list]->members);
  }
  if(tmp)
    return filter_array(tmp, (: PLAYER_HANDLER->test_active($1, 1) :));
  return ({ });
}
int query_member(string list_name, string name) {
   class mailing_list list;
   list = mailing_lists[list_name];
   if (list) {
      return member_array(name, list->members) != -1;
   }
   if (file_size("/d/" + list_name) == -2) {
      return (int)("/d/" + list_name + "/master")->query_member(name);
   }
   if (list_name == "seniors") {
      return (int)master()->query_senior(name);
   }
   if (list_name == "lords") {
      return (int)master()->query_leader(name);
   }
   if (list_name == "hlords") {
      return (int)master()->query_administrator(name);
   }
}
string *query_controllers(string list) {
   if (file_size("/d/"+ list) == -2) {
      return ({ (string)("/d/"+ list +"/master")->query_lord() });
   }
   if (mailing_lists[list]) {
      return copy(mailing_lists[list]->controllers);
   }
   return ({ });
}
int query_controller(string list_name, string name) {
   class mailing_list list = mailing_lists[list_name];
   if (!list) {
      return 0;
   }
   return member_array(name, list->controllers) != -1;
}
string query_creator(string list_name) {
   class mailing_list list = mailing_lists[list_name];
   if (!classp(list)) {
      return 0;
   }
   return list->creator;
}
int create_list(string list, string creator) {
   SECURITY
   if (mailing_lists[list]) {
      return 0;
   }
   if (file_size("/d/" + list) == -2) {
      return 0;
   }
   if (PLAYER_HANDLER->test_user(list)) {
      return 0;
   }
   mailing_lists[list] = new(class mailing_list, members : ({ creator }),
                                          controllers : ({ creator }), creator : creator);
   save_me();
   return 1;
}
protected int delete_list(string list) {
   if (!mailing_lists[list]) {
      return 0;
   }
   map_delete(mailing_lists, list);
   save_me();
   return 1;
}
int add_controller(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->controllers) != -1) {
      return 0;
   }
   list->controllers += ({ mem });
   add_member(list_name, mem);
   save_me();
   return 1;
}
int remove_controller(string list_name, string name) {
   int i;
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(name, list->controllers)) == -1) {
      return 0;
   }
   list->controllers = delete(list->controllers, i, 1);
   save_me();
   return 1;
}
int add_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->members) != -1) {
      return 0;
   }
   list->members += ({ mem });
   save_me();
   return 1;
}
int remove_member(string list_name, string mem) {
   int i;
   class mailing_list list = mailing_lists[list_name];
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(mem, list->members)) == -1) {
      return 0;
   }
   list->members = delete(list->members, i, 1);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
}
int delete_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!remove_member(list_name, mem)) {
      return 0;
   }
   remove_controller(list_name, mem);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
}

==================================================
FILE: handlers/mailer.c
==================================================

#include <mime.h>
#include <mail.h>
#include <localtime.h>
#include <player_handler.h>
#define FOLDER_H "/obj/handlers/folder_handler.c"
#define MAIL_PATH "/save/mail/"
#define COLS (int)owner->query_cols()
#define ROWS (int)owner->query_rows()
#undef CONVERTER
nosave class mail_header *folder;
nosave int *deleted, *newish, no_menu, last_read, full_header;
nosave string current, to, subject, cc, mailrc;
nosave mixed *do_this_last;
nosave object owner;
nosave string *ignore = ({
  "email-version",
  "x-lines",
  "expires",
  "transport-options",
  "x-mailer",
  "errors-to",
  "lines",
  "priority",
  "newsgroups",
  "default-options",
  "auto-forward-count",
  "ua-message-id",
  "approved",
  "followup-to",
  "message-version",
  "message-id",
  "message-service",
  "message-type",
  "sender",
  "end-of-header",
  "content-type",
  "path",
  "report-version",
  "submitted-by",
  "message-protocol",
  "posting-number",
  "x-postmark",
  "apparently-to",
  "organization",
  "posted-date",
  "return-receipt-to",
  "keywords",
  "x-sun-charset",
  "summary",
  "in-reply-to",
  "reply-to",
  "distribution",
  "sent-by",
  "company",
  "references",
  "mts-message-id",
  "x-sequence",
  "via",
  "content-charset",
  "status",
  "confirmed-by",
  "ua-content-id",
  "content-length",
  "mime-version",
  "auto-forwarded-from",
  "content-transfer-encoding",
  "received",
  "end-of-protocol",
  "x-uidl",
  "precedence",
  "return-path"
});
string *folder_names;
varargs protected void rm_message(string input);
protected void unrm_message(string input);
private void print_message(int number);
varargs private void reply_message(int input, int flag);
private void save_me();
private int load_me();
void dest_me();
private void read_messages(string fname);
protected void read_loop(string input);
private void prompt();
protected void change_folder(string input);
varargs private void delete_it(string bonk, int last, string newish_folder);
varargs protected void move_message(string input, int flag);
private void save_message(string input);
protected void get_recipient(string input);
varargs protected void get_subject(string input, int number, int flag);
varargs protected void main_menu(string fname, int flag, int *range);
protected void forward_message(string input);
void finish_write_message(string input);
string format_date(int x);
private int *expand_range(string str);
private int valid_name(string str);
void read_mail(string str, string sub);
private void forward_email(int number);
private void write_message();
private void check_external_mail();
private void create() {
    mapping aliases;
    seteuid("Mailer");
    no_menu = full_header = 0;
    last_read = -1;
    newish = ({ });
    folder = ({ });
    folder_names = ({ "inbox" });
    deleted = ({ });
    current = "";
    if (clonep()) {
        owner = this_player();
        if (owner) {
            aliases = owner->query_aliases();
            if (aliases) {
                mailrc = aliases[".mailrc"];
            }
        }
    } else {
        check_external_mail();
    }
}
#define HEADER_NAME 1
#define HEADER_VAL  2
private string folder_filename(string name) {
    return MAIL_PATH+name[0..0] + "/"  + name;
}
private string strip_header(string message) {
    mixed *ra;
    int i;
    string header;
    if ((i = strsrch(message, "\n\n")) == -1) {
        return message;
    }
    header = message[0..i];
    message = message[i+1..];
    ra = reg_assoc(header,
      ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
      ({ HEADER_NAME, HEADER_VAL }));
    for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
        if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
            if (member_array(replace_string(lower_case(ra[0][i]), ":", ""),
                ignore) != -1) {
                ra[0][i] = ra[0][i+2] = "";
            }
        }
    }
    return implode(ra[0], "") + message;
}
private void check_external_mail() {
    string *dir, fname, mess, t, ccs;
    class mail_message msg = new(class mail_message);
    class mime_header hdr;
    dir = unguarded((: get_dir, EXTERNAL_MAIL_PATH :));
    if (!dir) {
        call_out((: check_external_mail :), 60);
        return;
    }
    foreach (fname in dir) {
        mess = unguarded((: read_file, EXTERNAL_MAIL_PATH + fname :));
        mess = replace(mess, ({ "\r\n", "\n", "\t", "        " }));
        hdr = MIME->parse_headers(mess);
        if (!hdr) {
            unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
            continue;
        }
        msg->from = hdr->header_m["from"];
        msg->subject = hdr->header_m["subject"];
        t = hdr->header_m["to"];
        if (!t) {
            continue;
        }
        msg->to = explode(t, ",");
        ccs = hdr->header_m["cc"];
        if (!ccs) {
            ccs = "";
        }
        msg->cc = explode(ccs, ",");
        msg->body = mess;
        FOLDER_H->add_it(msg, 1);
        unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
    }
    call_out((: check_external_mail :), 60);
}
void set_do_this_last(mixed *bing) { do_this_last = bing; }
mixed *query_do_this_last() { return do_this_last; }
varargs int do_mail_message(string t, string from, string sub, string ccs,
  string body, int, string only_to, int flag) {
    string *cc_e, *goto;
    class mail_message msg;
    if(file_name(previous_object())[0..12] != "/secure/login" &&
       file_name(previous_object())[0..13] != "/secure/nlogin" &&
       file_name(previous_object())[0..13] != "/obj/handlers/" &&
       file_name(previous_object())[0..4] != "/www/" &&
       file_name(previous_object())[0..11] != "/net/daemon/" &&
       file_name(previous_object())[0..11] != "/global/lord" &&
       file_name(previous_object())[0..14] != "/global/creator" &&
       file_name(previous_object())[0..18] != "/global/auto_mailer" &&
       file_name(previous_object())[0..12] != "/cmds/creator" &&
       file_name(previous_object())[0..9] != "/cmds/lord" &&
       file_name(previous_object()) != "/d/am/buildings/post/parcel" &&
       file_name(previous_object()) != "/d/am/buildings/apex/admin_office" &&
       file_name(previous_object()) != "/d/am/bookkeepers/weichert_office" &&
       file_name(previous_object()) != "/d/ram/ohulan/market/post_office" &&
       file_name(previous_object()) != "/d/ram/interview" &&
       file_name(previous_object()) != "/d/forn/utils/interview" &&
       file_name(previous_object()) != "/d/am/buildings/flintwick/lawyer_office" &&
       file_name(previous_object()) != "/d/am/buildings/council/court" &&
       file_name(previous_object()) != "/d/klatch/djel/city/palace/council_court" &&
       file_name(previous_object()) != "/d/guilds/error_tracker" &&
       file_name(previous_object())[0..25] != "/d/ram/ohulan/market/post2") {
        printf("MAILER: illegal access (%O).\n", file_name(previous_object()));
        return 0;
    }
    if ((file_name(previous_object())[0..11] == "/global/lord" ||
        file_name(previous_object())[0..14] == "/global/creator") &&
        (lower_case(from) != (string)this_player()->query_name())) {
        printf("MAILER: illegal acces.\n");
        return 0;
    }
    if (!ccs) {
        ccs = "";
    }
    cc_e = explode(ccs, ",")-({""});
    goto = explode(t, ",")-({""});
    if (only_to) {
        goto = explode(only_to, ",")-({""});
    }
    msg = new(class mail_message);
    msg->to = goto;
    msg->cc = cc_e;
    msg->body = "From " + from + " " + ctime(time()) +
    "\nDate: " + format_date(time()) +
    "\nFrom: " + from +
    "\nTo: " + t +
    "\nSubject: " + sub +
    "\n" + (sizeof(cc_e)?"Cc: "+ ccs+ "\n":"")+
    "\n" + body;
    msg->from = lower_case(from);
    msg->subject = sub;
    FOLDER_H->add_it(msg, flag);
    return 1;
}
string finger_mail(string pname) {
    return FOLDER_H->finger_mail(lower_case(pname));
}
string new_mail(string pname) {
    return FOLDER_H->check_mail(lower_case(pname));
}
private void prompt() {
    printf("\nCommand (h for main menu): ");
}
void read_mail(string str, string sub) {
    if (this_player()->query_property("guest")) {
        write("Sorry, mailer access is not allowed for guests.\n");
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }
    if (!load_me()) {
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }
    if (str) {
        no_menu = 1;
        if (!sub) {
            get_recipient(str);
        } else {
            to = str;
            get_subject(sub);
        }
        return;
    }
    MAIL_TRACK->add_mailer(this_object(), owner->query_name());
    main_menu("inbox");
    return;
}
varargs private void main_menu(string fname, int flag, int *range) {
    int i, size, offs, cols, fromcols, statcols;
    cols = COLS;
    printf("%|=*s", cols, "" + mud_name() + " mailer system version 2.0\n\n");
    if (!strlen(fname)) {
        fname = "inbox";
    }
    current = fname;
    if (!flag) {
        read_messages(current);
        last_read = -1;
        deleted = ({ });
    }
    if (!range) {
        range = ({ });
    }
    newish = ({ });
    size = sizeof(folder);
    for (i = 0; i < size; i++) {
        if (folder[i]->status == "N") {
            newish += ({ i });
        }
    }
    if (sizeof(newish) && newish[0] != 0 && last_read == -1) {
        last_read = newish[0]-1;
    }
    if (size && !sizeof(newish) && last_read == -1) {
        last_read = size-1;
    }
    printf(owner->fix_string(sprintf("%s%|=*s%s","%^CYAN%^",cols,
          "Folder "+current+" with "+
          (size?""+size:"no")+
          " message"+(size == 1?"":"s")+".\n\n",
          "%^RESET%^")));
    if (!sizeof(range)) {
        i = size - ROWS + 11;
        if (i < 0) {
            i = 0;
        }
        range = expand_range(sprintf("%d-%d", i, size));
    }
    size = sizeof(range);
    if (size) {
        offs = range[0]-1;
    } else {
        offs = 0;
    }
    statcols = cols / 3;
    fromcols = 2 * cols / 3 - 8;
    for (i = 0; i<size; i++) {
        printf(owner->
          fix_string(sprintf("%s%-6s %-*.*s %-*.*s%s\n",
              (last_read == i+offs?
                "%^REVERSE%^":""),
              (last_read == i+offs?">":" ")+
              folder[i+offs]->status+
              " " + (i+offs+1), statcols, statcols, "From: " +
              folder[i+offs]->from, fromcols, fromcols,
              "Subject: "+
              replace_string(terminal_colour(folder[i+offs]->subject,
                  ([ ])), "%", "%%"),
              "%^RESET%^")));
    }
    printf("%|=*s", cols, "\n  You can use any of the following commands by "
      "entering the first character;\nd)elete or u)ndelete mail,  m)ail a "
      "message,  r)eply or f)orward mail,  q)uit,\n"
      "> = move messages, c)hange folder, i)ndex of folders, ? = help\n"
      "To read next unread message, press <return>.\n");
    printf("Command: ");
    input_to("read_loop");
}
protected void read_loop(string input) {
    int i, num;
    string s1, s2, comm, *tmp;
    num = 0;
    i = 0;
    if (sscanf(input, "%d%s", num, input) != 2) {
        comm = "";
        if (sscanf(input, "%s %d %s", s1, num, s2) == 3) {
            i = 1;
            input = s1 + " " + s2;
        }
    }
    if (sscanf(input, "%s %s", comm, input) != 2) {
        comm = input;
        input = "";
    }
    if (i)
        input = ""+num+" "+input;
    switch(comm) {
    case "q" :  if (current == "inbox") {
            if (sizeof(folder) &&
              (sizeof(folder) != sizeof(newish)) &&
              (sizeof(deleted) != sizeof(folder))) {
                printf( "\nMove read message(s) to \"received\" folder? "
                  "(y/[n]): ");
                input_to("get_yesno");
                break;
            }
        }
        delete_it(current, 1);
        break;
    case "d" :
        if (input != "") {
            rm_message(input);
            break;
        }
        printf( "\nDelete which messages (number or range): " );
        input_to("rm_message");
        break;
    case "u" :
        if (input != "") {
            unrm_message(input);
            break;
        }
        printf( "\nUndelete which messages (number or range): " );
        input_to("unrm_message");
        break;
    case "c" :
        if (input != "") {
            change_folder(input);
            break;
        }
        printf( "\nChange to which folder (= for inbox): " );
        input_to("change_folder");
        break;
    case "m" :
        if (input != "") {
            get_recipient(input);
            break;
        }
        printf( "\nRecipient: " );
        input_to("get_recipient");
        break;
    case "R" :
        reply_message(num);
        break;
    case "r" :
        reply_message(num, 1);
        break;
    case "$" :
        main_menu(current);
        break;
    case "f" :
        if (input != "") {
            forward_message(input);
            break;
        }
        printf("\nForward a message.  Ranges are not supported.\n"
          "Enter the number of the message and the name(s) of the "
          "recipient(s), separated by a comma: ");
        input_to("forward_message");
        break;
    case "F" :
        forward_email(num);
        break;
    case "i" :
        printf("\nHere's the index of your folders:\n");
        printf("\n%-#*s\n", COLS, implode(folder_names, "\n"));
        prompt();
        input_to("read_loop");
        break;
    case "L" :
        if (full_header) {
            printf("\nOkay, now showing abbreviated header.\n");
            full_header = 0;
        } else {
            printf("\nOkay, now showing full header.\n");
            full_header = 1;
        }
        prompt();
        input_to("read_loop");
        break;
    case "l" :
        if (input != "") {
            if (!MAIL_TRACK->query_list(input)) {
                printf( "\nSorry, list "+input+" does not exist.\n" );
                prompt();
                input_to("read_loop");
                break;
            }
            printf( "\nMembers of list "+ input +":\n" );
            tmp = MAIL_TRACK->query_members(input);
        } else {
            printf( "\nCurrently available mailing lists:\n" );
            tmp = MAIL_TRACK->query_mailing_lists();
        }
        printf("\n%-#*s\n", COLS, implode(tmp,"\n"));
        prompt();
        input_to("read_loop");
        break;
    case ">" :
        if (!PLAYER_HANDLER->test_user(owner->query_name())) {
            printf( "You can't do that as a guest.\n" );
            break;
        }
        if (input != "") {
            move_message(input);
            break;
        }
        printf("\nMove message to folder.\nEnter the number "
          "(or range) of the message and the name of the folder, "
          "separated by a comma: ");
        input_to("move_message");
        break;
    case "h" :
        if (input != "") {
            main_menu(current, 1, expand_range(input));
            break;
        }
        main_menu(current, 1);
        break;
    case "s" :
        save_message(input);
        break;
    case "?" :
        owner->set_finish_func("finish_print");
        comm = read_file("/doc/helpdir/mailer");
        owner->more_string(comm);
        break;
    case "" :
        if (num) {
            print_message(num-1);
            last_read = num-1;
            break;
        }
        if (newish == ({ })) {
            printf("\nNo more new messages in folder.\n");
            prompt();
            input_to("read_loop");
            break;
        }
        last_read = newish[0];
        print_message(newish[0]);
        break;
    default :
        printf("\nUnknown command.  Use \"?\" for help.\n");
        prompt();
        input_to("read_loop");
        break;
    }
}
protected void get_yesno(string input) {
    int bing, i;
    if (!input || (input == "")) {
        printf("No.\n");
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "n") {
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "y") {
        bing = sizeof(folder);
        for (i = 0; i < bing; i++) {
            if ((member_array(i, newish) == -1) &&
              (member_array(folder[i]->number, deleted) == -1)) {
                move_message(""+(i+1)+" received", 1);
            }
        }
    }
    delete_it(current, 1);
    return;
}
private void forward_email(int number) {
    int i;
    string email, body;
    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    if (!(email = PLAYER_HANDLER->test_email(owner->query_name()))) {
        printf("Sorry, your E-mail address is not set.  Use chfn or email "
          "to set it.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (email[0] == ':') {
        email = email[1..];
    }
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (body) {
        SMTP->eventSendMail(email, owner->query_name(), body);
        printf("Message #%d forwarded to your E-mail address.\n", number + 1);
    }
    prompt();
    input_to("read_loop");
}
private string rewrite_local(string rcpt) {
    string tmpr;
    if ((tmpr = FOLDER_H->check_local(rcpt))) {
        return tmpr;
    }
    return rcpt;
}
varargs private void reply_message(int number, int flag) {
    int i;
    string body;
    class mime_header hdr;
    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    to = folder[number]->from;
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (!body) {
        prompt();
        input_to("read_loop");
        return;
    }
    hdr = MIME->parse_headers(body);
    if (!hdr) {
        prompt();
        input_to("read_loop");
        return;
    }
    if (hdr->header_m["reply-to"]) {
        to = hdr->header_m["reply-to"];
    }
    if (!flag) {
        string tmp;
        cc = hdr->header_m["cc"];
        tmp = hdr->header_m["to"];
        if (tmp) {
            if (cc) {
                cc += "," + tmp;
            } else {
                cc = tmp;
            }
        }
        if (cc == "") {
            cc = 0;
        }
        if (cc) {
            cc = implode(map(MIME->get_email_addrs(cc)[0],
                (: rewrite_local($1) :))-({ owner->query_name(), to }),
              ",");
        }
    }
    printf("Include original message? (y/[n]/q) ");
    input_to("finish_reply_message", 0, number);
}
protected void finish_reply_message(string input, int number) {
    int flag, i;
    string s1;
    if (!input || input == "" || lower_case(input)[0] != 'y') {
        if (lower_case(input)[0] == 'q') {
            cc = 0;
            to = "";
            printf("Aborting.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        printf( "No.\n" );
    } else flag = 1;
    subject = folder[number]->subject;
    if (sscanf(subject, "Re:#%d %s", i, s1) != 2)
        subject = "Re:#1 " + subject;
    else
        subject = sprintf("Re:#%d %s", (i+1), s1);
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (flag)
        input_to("get_subject", 0, ++number, 1);
    else
        input_to("get_subject");
}
protected void change_folder(string input) {
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (input == "=") {
        delete_it(current, 0, "inbox");
        return;
    }
    if (member_array(input, folder_names) == -1) {
        printf("No folder named %s.\n", input);
        prompt();
        input_to("read_loop");
        return;
    }
    delete_it(current, 0, input);
}
protected void get_recipient(string input) {
    string *str, *full, nn;
    int i;
    mixed *addrs;
    if (!input || input == "") {
        printf("No recipient given: aborting.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i=0;i<sizeof(str);i++){
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (sizeof(full))
        to = implode(full, ",");
    else {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    subject = "";
    printf("Subject: ");
    input_to("get_subject");
}
varargs protected void get_subject(string input, int number, int flag) {
    if ((!input || input == "") && (!subject || subject == "")) {
        printf("No subject given: aborting.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    if (input && input != "")
        subject = input;
    printf("Cc: ");
    input_to("get_cc", 0 , number, flag);
}
private int valid_name(string str) {
    string mud;
    str = lower_case(str);
    if (!sscanf(str, "%s@%s", str, mud) ||
      lower_case(mud) == lower_case(mud_name())) {
        return (int)PLAYER_HANDLER->test_user(str) ||
        (int)MAIL_TRACK->query_list(str);
    }
    return 1;
}
varargs protected void get_cc(string input, int number, int flag) {
    string *str, body, *full, nn;
    int i;
    mixed *addrs;
    if (!input || input == "**" || input == "") {
        if (number) {
            body = FOLDER_H->load_message(owner->query_name(), current,
              folder[number-1]->number);
            if (!body) {
                prompt();
                input_to("read_loop");
                return;
            }
            if (!flag) {
                finish_write_message("> " + replace_string(body, "\n", "\n> ") + "\n");
                return;
            }
            owner->do_edit("> " + replace_string(body, "\n", "\n> ") + "\n",
              "finish_write_message");
            return;
        }
        write_message();
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc", 0, number, flag);
}
private void write_message() {
    owner->do_edit(0, "finish_write_message");
}
void finish_write_message(string input) {
    if (!input || input == "") {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    printf("Cc: ");
    input_to("get_cc_after", 0, input);
}
protected void get_cc_after(string input, string body) {
    mixed *goto, cc_e, *addrs;
    class mail_message msg;
    string *str, *full, nn;
    int i;
    if (!input || input == "**" || input == "") {
        body += owner->append_signature();
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        goto = explode(to, ",") - ({ "" });
        if (cc && cc != "") {
            cc_e = explode(cc, ",") - ({ "" });
        } else {
            cc_e = ({ });
        }
        msg = new(class mail_message);
        msg->to = goto;
        msg->cc = cc_e;
        msg->body = "From " + owner->query_name() + " " + ctime(time()) +
        "\nDate: " + format_date(time()) +
        "\nFrom: " + owner->query_name() +
        "\nTo: " + to +
        "\nSubject: " + subject +
        "\n" + (sizeof(cc_e)?"Cc: " + cc + "\n":"") +
        "\n" + body;
        msg->from = owner->query_name();
        msg->subject = subject;
        FOLDER_H->add_it(msg, 0);
        to = "";
        cc = 0;
        subject = "";
        printf("Message sent.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc_after", 0, body);
}
varargs private void delete_it(string fname, int last, string newish_folder) {
    if (!fname)
        fname = current;
    if (deleted != ({ })) {
        printf("Delete message(s)? ([y]/n) ");
        input_to("finish_delete_it", 0, fname, last, newish_folder);
        return;
    }
    if (last) {
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        save_me();
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
}
protected void finish_delete_it(string input, string fname, int last,
  string newish_folder) {
    if (lower_case(input) == "n" || (input && input != "" &&
        lower_case(input) != "y")) {
        printf("Keeping message(s).\n");
        deleted = ({ });
        if (last) {
            FOLDER_H->mark_read(owner->query_name(), current, newish);
            save_me();
            if (do_this_last && objectp(do_this_last[0]))
                call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
            else
                dest_me();
            return;
        }
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        if (!newish_folder || newish_folder == "")
            main_menu(fname);
        else
            main_menu(newish_folder);
        return;
    }
    printf("Deleting message(s).\n");
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    FOLDER_H->delete_it(owner->query_name(), fname, deleted);
    deleted = ({ });
    save_me();
    if (last) {
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
    return;
}
varargs protected void rm_message(string input, int flag) {
    int i, tmp;
    int *range;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number,
            deleted) == -1) {
            newish -= ({ range[i]-1 });
            deleted += ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "D";
            printf("Marked message %d as deleted.\n", range[i]);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
}
protected void unrm_message(string input) {
    int i, tmp;
    int *range;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number,
            deleted) > -1) {
            deleted -= ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "U";
            printf("Undeleted message %d.\n", range[i]);
        }
    }
    prompt();
    input_to("read_loop");
}
protected void forward_message(string input) {
    int number, i;
    string *str, *full, nn;
    mixed *addrs;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (sscanf(input, "%d %s", number, to) != 2) {
        printf("Wrong syntax (ranges are not supported with forward).\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (number > sizeof(folder) || !number) {
        printf("Oh dear. No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(to);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (sizeof(full)) {
        to = implode(full, ",");
    } else {
        prompt();
        input_to("read_loop");
        return;
    }
    cc = 0;
    printf("Edit outgoing message? (y/[n]) ");
    input_to("edit_it", 0, number);
}
protected void edit_it(string input, int number) {
    subject = folder[number-1]->subject + " (fwd)";
    if (!input || input == "")
        printf( "No.\n" );
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (!strlen(input) || (lower_case(input) == "n"))
        input_to("get_subject", 0, number);
    else if (lower_case(input) == "y")
        input_to("get_subject", 0, number, 1);
    return;
}
varargs protected void move_message(string input, int flag) {
    int *range, i, bing;
    string to_folder, number;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (!sscanf(input, "%s %s", number, to_folder)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == current) {
        printf("Destination folder is the same as source folder: not moved.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == "=")
        to_folder = "inbox";
    range = expand_range(number);
    bing = sizeof(range);
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    for (i = 0; i < bing; i++) {
        int status;
        if (member_array(to_folder, folder_names) == -1) {
            if (FOLDER_H->can_create_folder(owner->query_name(), to_folder)) {
                folder_names += ({ to_folder });
            } else {
                printf("Cannot create a folder called %s, please choose "
                    "another another name.\n", to_folder);
                break;
            }
        }
        deleted += ({ folder[range[i]-1]->number });
        status = FOLDER_H->move_it(owner->query_name(), current, to_folder,
          folder[range[i]-1]->number);
        folder[range[i]-1]->status = "D";
        switch(status) {
        case 2:
          printf("Folder full!\n");
        case 1:
          printf("Marked message %d as deleted.\n", range[i]);
          break;
        case 0:
          if(!flag)
            printf("Saved message %d to folder %s.\n", range[i], to_folder);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
}
private void save_message(string input) {
    int *range, i, bing, ret;
    string to_file, number, body, err;
    if (!wizardp(owner)) {
        printf("Sorry, only creators can save mail to files.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (!input || input == "") {
        if (last_read != -1)
            input = sprintf("%d ~/mbox",(last_read+1));
        else {
            printf("No messages in folder or all messages still unread.\n");
            prompt();
            input_to("read_loop");
            return;
        }
    }
    if (!sscanf(input, "%s %s", number, to_file)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    seteuid(geteuid(owner));
    to_file = (string)owner->get_path(to_file);
    if (!master()->valid_write(to_file, owner, "write_file")) {
        printf("You cannot write to that file.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if ((i=file_size(to_file)) > 0)
        printf("Appending to existing file.\n");
    else if (i == -2) {
        printf("That is a directory.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(number);
    bing = sizeof(range);
    i = 0;
    for (i = 0; i < bing; i++) {
        body = FOLDER_H->load_message(owner->query_name(), current,
          folder[range[i]-1]->number);
        if (!body) {
            continue;
        }
        err = catch(ret = write_file(to_file, body + "\n\n"));
        if (err) {
            printf("Writing to file failed: %s\n", err);
        } else if (!ret) {
            printf("Writing to file failed.\n");
        } else {
            printf("Saved message %d to %s.\n", range[i], to_file);
        }
    }
    seteuid("Mailer");
    prompt();
    input_to("read_loop");
}
private void print_message(int number) {
    string body;
    if (number > sizeof(folder)-1 || number < 0) {
        printf("No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (folder[number]->status == "N") {
        newish -= ({ number });
        folder[number]->status = " ";
    }
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (!body) {
        rm_message(""+(number+1));
        return;
    }
    owner->set_finish_func("finish_print");
    printf("\n\nMessage %d\n", (number + 1));
    owner->more_string((full_header?body:strip_header(body)),
      "Message "+(number+1));
}
void finish_print() {
    printf("\n");
    prompt();
    input_to("read_loop");
}
private void save_me() {
    if (!PLAYER_HANDLER->test_user(owner->query_name())) {
        return;
    }
    if (current != "inbox") {
        if (FOLDER_H->check_empty(owner->query_name(), current)) {
            folder_names -= ({ current });
        }
    }
    unguarded((: save_object, folder_filename(owner->query_name()) :));
}
private int load_me() {
#ifdef CONVERTER
    if ("/obj/handlers/converter"->query_busy(owner->query_name())) {
        printf( "You cannot use the mailer now, your mail is being converted.\n" );
        return 0;
    }
#endif
    unguarded((: restore_object, folder_filename(owner->query_name()) :));
    if (!folder_names) {
        folder_names = ({ "inbox" });
    }
    return 1;
}
string *query_folders(string pname) {
    unguarded((: restore_object, folder_filename(pname) :));
    if (!folder_names)
        return ({});
    return folder_names;
}
private void read_messages(string fname) {
    folder = FOLDER_H->get_messages(owner->query_name(), fname);
}
void dest_me() {
    MAIL_TRACK->delete_mailer(this_object());
    destruct(this_object());
}
string format_date(int x) {
    string str;
    string mon;
    mixed *tm;
    if (x<0 || !intp(x))
        return "Bad time";
    tm = localtime(x);
    str = DAYS[tm[LT_WDAY]];
    mon = MONTHS[tm[LT_MON]];
    str = sprintf("%s, %d %s %d %02d:%02d %s", str, tm[LT_MDAY], mon,
      tm[LT_YEAR], tm[LT_HOUR], tm[LT_MIN], tm[LT_ZONE]);
    return str;
}
private int *expand_range(string str) {
    int *ms, i, start, end;
    if (!str)
        str = "";
    if (!sizeof(folder))
        return ({ });
    str = replace_string(str, " ", "");
    ms = ({ });
    if (sscanf(str, "%*sall%*s")==2) {
        int size = sizeof(folder) + 1;
        for (i = 1; i < size; i++) {
            ms += ({ i });
        }
        return ms;
    }
    while (sscanf(str, "%d%s", start, str) == 2) {
        if (start < 1)
            start = 1;
        if (start > sizeof(folder))
            start = sizeof(folder);
        if (str && str != "" && (str[0] == '-' || ((strlen(str) > 1) &&
              str[0..1] == ".."))) {
            sscanf(str, "%*(-|(..))%d%s", end, str);
            if (end >= start) {
                if (end > sizeof(folder))
                    end = sizeof(folder);
                for (i = start; i <= end; i++)
                    if (member_array(i, ms) == -1)
                        ms += ({ i });
            }
        } else
        if (member_array(start, ms) == -1)
            ms += ({ start });
        sscanf(str, ",%s", str);
    }
    return ms;
}

==================================================
FILE: handlers/map.c
==================================================

#include <map_handler.h>
#include <config.h>
inherit "/obj/handlers/inherit/distance_handler";
mapping shorts = ([ ]);
mapping movezoness = ([ ]);
mapping changetimes = ([ ]);
#if !efun_defined(db_exec)
mapping clusters = ([ ]);
mapping map = ([ ]);
#else
int db, loop = 0;
#include <db.h>
#endif
mapping forced_rooms = ([ ]);
#ifdef COORDS
mapping coords = ([ ]);
mapping sizes = ([ ]);
#endif
int load = 0, time, stopped;
string *cache = ({ }), *queue = ({ });
int check_next_call_out;
mapping stats = ([]);
private void do_room1( string room );
private void check_next();
private void check_map2( string );
void create() {
   seteuid( (string)"secure/master"->get_root_uid() );
   "/room/void"->force_load();
   check_next_call_out = call_out( (: check_next :), SKEWTIME );
#if efun_defined(db_exec)
   db = db_connect("localhost","discworld",CONFIG_DB_USER);
#endif
}
protected void update_cache( string directory, int load ) {
   if ( !shorts[ directory ] || load ) {
      cache = ( cache - ({ directory }) ) + ({ directory });
      if ( sizeof( cache ) > CACHESIZE ) {
         map_delete( shorts, cache[ 0 ] );
         map_delete( movezoness, cache[ 0 ] );
         map_delete( changetimes, cache[ 0 ] );
#if !efun_defined(db_exec)
         map_delete( clusters, cache[ 0 ] );
         map_delete( map, cache[ 0 ] );
#endif
#ifdef COORDS
         map_delete( coords, cache[ 0 ] );
         map_delete( sizes, cache[ 0 ] );
#endif
         cache -= ({ cache[ 0 ] });
         LOG( sprintf( "%%^RED%%^uncaching %s%%^RESET%%^\n", cache[ 0 ] ) );
      }
      shorts[ directory ] = MH->query_shorts( directory );
      movezoness[ directory ] = MH->query_movezones( directory );
      changetimes[ directory ] = MH->query_changetimes( directory );
#if !efun_defined(db_exec)
      clusters[ directory ] = MH->query_clusters( directory );
      map[ directory ] = MH->query_map( directory );
#endif
#ifdef COORDS
      coords[ directory ] = MH->query_co_ords( directory );
      sizes[ directory ] = MH->query_sizes( directory );
#endif
   }
}
void clear_cache() {
   shorts = ([ ]);
   movezoness = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   cache = ({ });
}
#if !efun_defined(db_exec)
mapping query_map( string dir ) {
   if ( !map[ dir ] ) {
     update_cache( dir, 1 );
   }
   stats["map"]++;
   return map[ dir ];
}
void change_map( string dir, string room, string *dd ) {
   MH->change_map( dir, room, dd );
   map[ dir ][ room ] = dd;
}
#endif
mapping query_shorts( string dir ) {
   if ( !shorts[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["shorts"]++;
   return shorts[ dir ];
}
void change_shorts( string dir, string room, string sh ) {
   MH->change_shorts( dir, room, sh );
   shorts[ dir ][ room ] = sh;
}
mapping query_movezones( string dir ) {
   if ( !movezoness[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["movezones"]++;
   return movezoness[ dir ];
}
void change_movezones( string dir, string room, string *zones ) {
   MH->change_movezones( dir, room, zones );
   movezoness[ dir ][ room ] = zones;
}
mapping query_changetimes( string dir ) {
   if ( !changetimes[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["changetimes"]++;
   return changetimes[ dir ];
}
void change_changetimes( string dir, string room, int time ) {
   MH->change_changetimes( dir, room, time );
   changetimes[ dir ][ room ] = time;
}
#if !efun_defined(db_exec)
mapping query_clusters( string dir ) {
  if ( !clusters[ dir ] ) {
    update_cache( dir, 1 );
  }
  return clusters[ dir ];
}
void change_clusters( string dir, string room, int cluster ) {
   MH->change_clusters( dir, room, cluster );
   if(clusters[ dir ])
     clusters[ dir ][ room ] = cluster;
}
#endif
#ifdef COORDS
mapping query_co_ords( string dir ) {
   if ( !coords[ dir ] )
      update_cache( dir, 1 );
   stats["co_ords"]++;
   return coords[ dir ];
}
void change_co_ords( string dir, string room, int *coord ) {
   MH->change_co_ords( dir, room, coord );
   coords[ dir ][ room ] = coord;
}
mapping query_sizes( string dir ) {
   if ( !sizes[ dir ] )
      update_cache( dir, 1 );
   stats["sizes"]++;
   return sizes[ dir ];
}
void change_sizes( string dir, string room, int *size ) {
   MH->change_sizes( dir, room, size );
   sizes[ dir ][ room ] = size;
}
#endif
void del( string dir, string room ) {
   MH->del( dir, room );
   update_cache( dir, 1 );
}
#if !efun_defined(db_exec)
int query_cluster( string room ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  if( !clusters[ directory ] ) {
    update_cache( directory, 1 );
  }
  if( !clusters[ directory ] ) {
    clusters[ directory ] = ([]);
  }
  return query_clusters( directory )[ troom ];
}
void set_cluster( string room, int cluster ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  change_clusters( directory, troom, cluster);
}
#endif
string *query_dest_dir( string room ) {
#if !efun_defined(db_exec)
  string directory, troom;
#else
  mixed rows;
  string *ret;
  int i = 0;
#endif
  stats["dest_dir"]++;
  if(!room || room == "/" || room == "" || strsrch(room, "/") == -1)
    return ({ });
#if !efun_defined(db_exec)
  directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  if( !query_map( directory )[ troom ] ) {
    check_map2( room );
  }
  return query_map( directory )[ troom ];
#else
  if ( room[ <2.. ] == ".c" ) {
    room = room[ 0..<3];
  }
  if(loop == time())
    return ({});
  loop = time();
  rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
  if(stringp(rows)||!rows){
    forced_rooms[ room ] = 1;
    check_map2( room );
    rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
    if(stringp(rows)){
      loop = 0;
      return ({ });
    }
  }
  ret = allocate(rows * 2);
  for(i=0; i<rows; i++){
    string *row;
    row = db_fetch(db, i + 1);
    ret[i*2] = row[0];
    ret[i*2+1] = row[1];
  }
  loop = 0;
  return ret;
#endif
}
string *qdd( string room ) {
   return query_dest_dir( room );
}
string query_destination( string exit, string room ) {
   int i;
   string *dest_dir;
   stats["destination"]++;
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return "/room/void";
   }
   dest_dir = query_dest_dir( room );
   i = member_array( exit, dest_dir );
   if( i < 0 ) return "/room/void";
   return dest_dir[ i + 1 ];
}
string qdes( string exit, string room ) {
   return query_destination( exit, room );
}
string *qdir( string room ) {
   int i;
   string *qddir, *dir=({});
   stats["qdir"]++;
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return ({ "/room/void" });
   }
   qddir = query_dest_dir( room );
   for( i = sizeof( qddir ) - 2;i > -1;i -= 2)
     dir += ({ qddir[ i ]} );
   return dir;
}
string *query_cache() { return cache; }
string *query_queue() { return queue; }
void set_stopped( int s ) { stopped = s; }
int compare_arrays( mixed *ar1, mixed *ar2 ) {
   int i;
   if ( !ar1 && !ar2 ) return 0;
   if ( sizeof( ar1 ) != sizeof( ar2 ) ) return 1;
   i = sizeof( ar1 );
   while ( i-- ) {
      if ( ar1[ i ] != ar2[ i ] ) {
         return 1;
      }
   }
   return 0;
}
varargs void queue_room( string room, int force, string reason ) {
   queue -= ({ room });
   queue += ({ room });
   forced_rooms[ room ] = force;
#ifdef LOGTO
   if ( !reason ) reason = "";
   LOG( sprintf( "%%^RED%%^Queueing %s(%i) %s.%%^RESET%%^\n",
                room, sizeof( queue ), reason ) );
#else
   reason = reason;
#endif
}
void do_room( string room ) {
   call_out( (: do_room1 :), 1, room );
}
private void do_room1( string room ) {
   mixed tmp;
   int changetime;
   string directory = implode( explode( room, "/" )[ 0 .. <2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" )
      troom = troom[ 0 .. <3 ];
   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return;
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return;
   }
   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 ) {
      tmp = stat( room );
      if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
         return;
   }
   tmp = find_object( room );
   if ( tmp ) {
      if( tmp->query_property( "no map" ) ) {
         LOG( sprintf( "%%^BLUE%%^Skipping %s%%^RESET%%^, it asked me to.\n",
                      tmp->a_short() ) );
         return;
      }
#ifdef COORDS
      tmp->calc_co_ord();
      if ( sizeof( tmp->query_co_ord() ) >
          sizeof( query_co_ords( directory )[ troom ] ) ) {
         queue_room( room, 1, "new co_ordinates");
         return;
      }
#endif
   }
   tmp = stat( room +".c" );
   if ( query_changetimes( directory )[ troom ] ==
       ( changetime = tmp[ TIME ] ) ) {
      return;
   }
   queue -= ({ room });
   queue += ({ room });
   LOG( sprintf( "%%^RED%%^Queueing %s(%i).%%^RESET%%^\n",
                room, sizeof( queue ) ) );
}
private void check_next() {
   string room;
   if ( sizeof( queue ) && !stopped ) {
        check_next_call_out = call_out( (: check_next :), SKEWTIME );
      room = queue[ 0 ];
      queue -= ({ room });
      check_map2( room );
   } else {
      check_next_call_out = call_out( (: check_next :), 60 );
   }
}
private void check_short( object room_obj, string room_short, string room ) {
   string tmp_short, bad_short;
   if(!room_short)
     return;
   tmp_short = lower_case(room_short);
   bad_short = 0;
   if ( tmp_short[ 0 .. 4 ] == "an a " ||
       tmp_short[ 0 .. 5 ] == "an an " ||
       tmp_short[ 0 .. 5 ] == "the the " ||
       tmp_short[ 0 .. 5 ] == "a the " ) {
      bad_short = "strange or missing determinate";
   } else {
      if(!sizeof(tmp_short))
         bad_short = "no short";
      else if ( tmp_short[ <1 ] == '.' ) {
         bad_short = "period in short";
      } else {
         if ( !(tmp_short = (string)room_obj->query_property( "determinate" ) ) ) {
            tmp_short = (string)room_obj->query_short();
            if ( tmp_short )
            if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) )
               bad_short = "suspicious capitalisation";
         } else {
            if ( tmp_short != "" ) {
               if ( tmp_short[ <1 ] != ' ' ) {
                  bad_short = "missing space in determinate";
               } else {
                  if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) ) {
                     bad_short = "suspicious capitalisation in determinate";
                  }
               }
            }
         }
      }
   }
   if ( bad_short ) {
      log_file( "STRANGE_SHORT","%s, %s (%s)\n",
               room_short, bad_short, room );
      LOG( sprintf( "%%^RED%%^%s.%%^RESET%%^\n", bad_short ) );
   }
}
void check_map( string room ) {
   do_room( room );
}
private void check_map2( string room ) {
   mixed tmp;
   int i, changetime, do_update;
   string *dest_dir, *tmpdest_dir, room_short, *movezones;
#ifdef COORDS
   int *coord;
   mixed size;
#endif
   object room_obj;
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return;
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return;
   }
   do_update = forced_rooms[ room ];
   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
      return;
#ifdef COORDS
   if ( room_obj = find_object( room ) ) {
      room_obj->calc_co_ord();
      if ( ( sizeof( room_obj->query_co_ord() ) >
            sizeof( query_co_ords( directory )[ troom ] ) ) ||
          compare_arrays( room_obj->query_co_ord(),
                         query_co_ords( directory )[ troom ] ) ) {
         do_update = 1;
      }
   }
#endif
   if ( !do_update &&
       ( query_changetimes( directory )[ troom ] ==
        ( changetime = tmp[ TIME ] ) ) ) {
      return;
   }
   if ( !find_object( room ) )
      catch( room->force_load() );
   room_obj = find_object( room );
   queue -= ({ room });
   map_delete( forced_rooms, room );
   update_cache( directory, 0 );
   if( !room_obj ) {
      if( shorts[ directory ][ troom ] ) {
         dest_dir = query_dest_dir(room);
         for(i = 1; i < sizeof( dest_dir ); i += 2 )
            check_map( dest_dir[ i ] );
#if !efun_defined(db_exec)
         map_delete( map[ directory ], troom );
#endif
         map_delete( shorts[ directory ], troom );
         map_delete( movezoness[ directory ], troom );
         map_delete( changetimes[ directory ], troom );
#ifdef COORDS
         map_delete( coords[ directory ], troom );
         map_delete( sizes[ directory ], troom );
#endif
         del( directory, room );
         LOG( sprintf( "%%^RED%%^Removing %s,%%^RESET%%^.\n", room ) );
      }
      return;
   }
   if ( room_obj->query_property( "no map" ) ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ it asked me to.\n",
                   room ) );
      return;
   }
   room_short = (string)"/global/events"->convert_message(
         (string)room_obj->a_short() );
   if ( shorts[ directory ][ troom ] != room_short )
      do_update = 1;
   LOG( sprintf( "%%^YELLOW%%^Updating %s%%^RESET%%^. (%s)\n",
                room_short, troom ) );
#ifdef LOG_SHORTS
   check_short( room_obj, room_short, room );
#endif
   movezones = room_obj->query_zones();
   if ( !pointerp( movezones ) ) movezones = ({ });
   if ( movezoness[ directory ][ troom ] != movezones )
      do_update = 1;
#ifdef COORDS
   room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coord ) room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coords[ directory ] ) coords[ directory ] = ([ ]);
   if ( compare_arrays( coords[ directory ][ troom ], coord ) )
      do_update = 1;
   size = room_obj->query_room_size_array();
   if ( !sizes[ directory ] ) sizes[ directory ] = ([ ]);
   if ( sizes[ directory ][ troom ] != size )
      do_update = 1;
#endif
   if ( changetimes[ directory ][ troom ] != changetime )
      do_update = 1;
   if ( do_update ) {
      change_changetimes( directory, troom, changetime );
      change_movezones( directory, troom, movezones );
      change_shorts( directory, troom, room_short );
#ifdef COORDS
      if ( sizeof( coord ) == 3 )
         change_co_ords( directory, troom, coord );
      change_sizes( directory, troom, size );
#endif
      update_cache( directory, 1 );
   }
   dest_dir = room_obj->query_dest_dir();
   if( !dest_dir ) {
      dest_dir = ({ });
   } else {
      string exit;
      if( room_obj->query_blockage() ) {
        exit = room_obj->query_direction();
        if( !exit )
          for( i = 1; i < sizeof( dest_dir ); i += 2 )
            if( dest_dir[ i ]->query_blockage() ) {
              exit = dest_dir[ i - 1 ];
              break;
            }
      }
      if(!exit)
         exit = "";
      tmpdest_dir = ({ });
      for ( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         mixed tmp2;
         catch(load_object(dest_dir[i]));
         if ( objectp( find_object( dest_dir[ i ] ) ) &&
                          !clonep( find_object( dest_dir[ i ] ) ) &&
              exit != dest_dir[i - 1] &&
              dest_dir[i - 1][0..5] != "enter " &&
              dest_dir[i][1] != 'w' &&
              dest_dir[i][1..3] != "std" &&
              dest_dir[i][1..4] != "room" &&
                     (catch(tmp2 = dest_dir[i]->query_property( "no map" )), !tmp2)) {
            tmpdest_dir += ({ dest_dir[ i - 1 ], dest_dir[ i ] });
         }
      }
      dest_dir = tmpdest_dir;
   }
   if ( compare_arrays( query_dest_dir(room), dest_dir ) ) {
#if !efun_defined(db_exec)
      map[ directory ][ troom ] = dest_dir;
#else
      db_exec(db, "delete from roomexit where id = '%s'", db_escape(room));
      for(i=0; i<sizeof(dest_dir)/2; i++){
        db_exec(db, "insert into roomexit values ('%s', '%s', '%s')",
                db_escape(room), db_escape(dest_dir[i*2]),
                db_escape(dest_dir[i*2+1]));
      }
#endif
      for( i = 1; i < sizeof( dest_dir );i += 2 ) {
         if ( dest_dir[ i ][ <2.. ] == ".c" ) {
#ifdef LOG_EXITS
            log_file("BAD_EXIT","from %s, %s to %s\n",
                     directory +"/"+ troom, dest_dir[ i-1 ], dest_dir[ i ] );
#endif
            dest_dir[ i ] = dest_dir[ i ][ 0..<3 ];
         }
      }
#if !efun_defined(db_exec)
      change_map( directory, troom, dest_dir );
#endif
#ifdef PARANOID
      update_cache( directory, 1 );
#endif
      for( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         do_room( dest_dir[ i ] );
      }
#ifdef PARANOID
      return;
#endif
   }
#ifdef PARANOID
   update_cache( directory, 1 );
#endif
}
string query_short( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["short"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string)"/global/events"->convert_message(
                     (string)room->a_short() );
      } else {
         return "The map_handler was called on a non-existent clone";
      }
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   if ( !catch( load_object(room) ) ) {
     return (string)"/global/events"->convert_message(
                            (string)room->a_short() );
   }
   return "Oops!";
}
string static_query_short( string room ) {
   string directory, troom;
   if(!stringp(room))
     return "";
   directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["static short"]++;
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   return 0;
}
string *query_zones( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   object roomob;
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["zones"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string *)room->query_movezones();
      } else {
         return ({ });
      }
   }
   if ( !movezoness[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !movezoness[ directory ] ) {
      movezoness[ directory ] = ([ ]);
   }
   if ( movezoness[ directory ][ troom ] ) {
     return movezoness[ directory ][ troom ];
   }
   if ( !catch( roomob = load_object(room) ) ) {
     if(roomob)
       return roomob->query_movezones();
   }
   return ({ "Oops!" });
}
#ifdef COORDS
void set_co_ord( string room, int *coord ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   MH->change_co_ords( directory, troom, coord );
   coords[ directory ][ troom ] = coord;
}
int *query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["co_ord"]++;
   LOG( sprintf( "%%^BLUE%%^query_co_ord(%s)%%^RESET%%^\n", room ) );
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   if ( !catch( load_object(room ) ) ) {
     return room->query_co_ord();
   }
   return 0;
}
int *static_query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["static co_ord"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   return 0;
}
int *query_room_size( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["room_size"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_room_size_array();
      } else {
         return 0;
      }
   }
   if ( !sizes[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !sizes[ directory ] ) {
      sizes[ directory ] = ([ ]);
   }
   if ( sizes[ directory ][ troom ] ) {
     return sizes[ directory ][ troom ];
   }
   if (!catch(room->force_load())) {
      return room->query_room_size_array();
   }
   return 0;
}
#endif
int test_room( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( strsrch( room, "#" ) != -1 )  {
      return 1;
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return 1;
   }
   if ( !catch( load_object(room) ) ) {
     return 1;
   }
   return 0;
}
int query_known( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   return !undefinedp(shorts[ directory ][troom]);
}
void check_save_files() {
   string *files, file, room, *tmp;
   files = unguarded((: get_dir, "/save/map/" :));
   files = map( files, (: replace( $1, ({ "_", "/", ".o", ""}) ) :) );
   foreach( file in files ) {
      printf( "%s\n", file );
      tmp = keys( MH->query_map( file ) );
      reset_eval_cost();
      foreach( room in tmp ) {
         if( file_size( file +"/"+ room + ".c" ) < 0 ) {
            printf( "%s no longer exists.\n", file + "/" + room );
            MH->del( file, room );
         }
      }
   }
   cache = ({ });
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "shorts" : shorts,
            "movezoness" : movezoness,
            "changetimes" : changetimes,
#if !efun_defined(db_exec)
            "clusters" : clusters,
            "map" : map,
#endif
#ifdef COORDS
            "coords" : coords,
            "sizes" : sizes,
#endif
            "cache" : cache,
            "queue" : queue,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   if (maps["shorts"])
      shorts = maps["shorts"];
   if (maps["movezoness"])
      movezoness = maps["movezoness"];
   if (maps["changetimes"])
      changetimes = maps["changetimes"];
#if !efun_defined(db_exec)
   if (maps["clusters"])
      clusters = maps["clusters"];
   if (maps["map"])
     map = maps["map"];
#endif
#ifdef COORDS
   if (maps["coords"])
      coords = maps["coords"];
   if (maps["sizes"])
      sizes = maps["sizes"];
#endif
   if (maps["cache"])
      cache = maps["cache"];
   if (maps["queue"])
      queue = maps["queue"];
}
mixed *stats() {
   return ({
      ({ "queue size", sizeof( queue ) }),
      ({ "cache size", sizeof( cache ) }),
      ({ "next check", find_call_out( check_next_call_out ) }),
        }) + map(keys(stats), (:({$1, $(stats)[$1]}):));
}

==================================================
FILE: handlers/map_helper.c
==================================================

#include <map_handler.h>
mapping shorts = ([ ]), movezones = ([ ]), changetimes = ([ ])
#if !efun_defined(db_exec)
, clusters = ([ ]), map = ([ ])
#endif
;
#ifdef COORDS
mapping coords = ([ ]), sizes = ([ ]);
#endif
string directory;
nosave string loaded;
nosave int save;
void create() {
   seteuid( (string)master()->get_bb_uid() );
}
void save_dir() {
#ifdef HELPLOGTO
   tell_object( find_living( LOGTO ), "%^RED%^saving%^RESET%^ "+ loaded +"\n");
#endif
   if (sizeof(shorts) ||
       sizeof(movezones) ||
       sizeof(changetimes) ||
#ifdef COORDS
       sizeof(coords) ||
       sizeof(sizes) ||
#endif
#if !efun_defined(db_exec)
       sizeof(clusters) ||
       sizeof(map) ||
#endif
        0) {
      unguarded((: save_object, "/save/map/" + loaded :));
   } else {
      unguarded((: rm("/save/map/" + loaded) :));
   }
   save = 0;
}
void check_dir( string dir ) {
   string tmp_file;
   if ( dir == directory ) {
      return;
   }
   if ( save )  {
      save_dir();
   }
   tmp_file = replace_string( dir, "/", "_" );
   shorts = ([ ]);
   movezones = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   if ( file_size( "/save/map/" + tmp_file + ".o" ) > 0 ) {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^GREEN%^loading%^RESET%^ "+ tmp_file
                   +"\n");
#endif
      unguarded((: restore_object, "/save/map/" + tmp_file :));
   } else {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^BLUE%^newmap%^RESET%^ "+ tmp_file +"\n");
#endif
      shorts = ([ ]);
      movezones = ([ ]);
      changetimes = ([ ]);
#if !efun_defined(db_exec)
      clusters = ([ ]);
      map = ([ ]);
#endif
#ifdef COORDS
      coords = ([ ]);
      sizes = ([ ]);
#endif
   }
   loaded = tmp_file;
   directory = dir;
}
#if !efun_defined(db_exec)
void change_map( string dir, string room, string *dd ) {
   check_dir( dir );
   map[ room ] = dd;
   save = 1;
}
mapping query_map( string dir ) {
   check_dir( dir );
   if ( !map )
     return ([ ]);
   return map;
}
#endif
void change_shorts( string dir, string room, string sh ) {
   check_dir( dir );
   shorts[ room ] = sh;
   save = 1;
}
mapping query_shorts( string dir ) {
   check_dir( dir );
   if ( !shorts ) {
     return ([ ]);
   }
   return shorts;
}
void change_movezones( string dir, string room, string *zones ) {
   check_dir( dir );
   movezones[ room ] = zones;
   save = 1;
}
mapping query_movezones( string dir ) {
   check_dir( dir );
   if ( !movezones )
     return ([ ]);
   return movezones;
}
#if !efun_defined(db_exec)
void change_clusters( string dir, string room, int cluster ){
  check_dir( dir );
  if(!clusters)
    clusters = ([]);
  clusters[ room ] = cluster;
  save = 1;
}
mapping query_clusters( string dir ){
  check_dir( dir );
  if( !clusters )
    return ([ ]);
  return clusters;
}
#endif
void change_changetimes( string dir, string room, int time ) {
   check_dir( dir );
   if ( !changetimes )
      changetimes = ([ ]);
   changetimes[ room ] = time;
   save = 1;
}
mapping query_changetimes( string dir ) {
   check_dir( dir );
   if ( !changetimes )
     return ([ ]);
   return changetimes;
}
#ifdef COORDS
void change_co_ords( string dir, string room, int *coord ) {
   check_dir( dir );
   if ( !coords )
      coords = ([ ]);
   coords[ room ] = coord;
   save = 1;
}
mapping query_co_ords( string dir ) {
   check_dir( dir );
   if ( !coords )
     return ([ ]);
   return coords;
}
void change_sizes( string dir, string room, int size ) {
   check_dir( dir );
   if ( !sizes )
      sizes = ([ ]);
   sizes[ room ] = size;
   save = 1;
}
mapping query_sizes( string dir ) {
   check_dir( dir );
   if ( !sizes )
     return ([ ]);
   return sizes;
}
#endif
void del( string dir, string room ) {
   check_dir( dir );
#if !efun_defined(db_exec)
   if (mapp(map)) {
     map_delete( map, room );
   } else {
     map = ([ ]);
   }
#endif
   if (mapp(shorts)) {
     map_delete( shorts, room );
   } else {
     shorts = ([ ]);
   }
   if (mapp(movezones)) {
     map_delete( movezones, room );
   } else {
     movezones = ([ ]);
   }
   if (mapp(changetimes)) {
     map_delete( changetimes, room );
   } else {
     changetimes = ([ ]);
   }
#if !efun_defined(db_exec)
   if (mapp(clusters)) {
     map_delete( clusters, room );
   } else {
     clusters = ([ ]);
   }
#endif
#ifdef COORDS
   if (mapp(coords)) {
     map_delete( coords, room );
   } else {
     coords = ([ ]);
   }
   if (mapp(sizes)) {
     map_delete( sizes, room );
   } else {
     sizes = ([ ]);
   }
#endif
   save = 1;
}

==================================================
FILE: handlers/mime.c
==================================================

#include <mime.h>
#define HEADER_NAME 1
#define HEADER_VAL  2
#define MUDMAIL     3
#define TOK_QP      4
#define TOK_QUOTE   5
#define TOK_OP      6
#define TOK_CP      7
#define TOK_LT      8
#define TOK_GT      9
#define TOK_SEP     10
#define TOK_AMP     11
#define SPECIAL     12
#define LWS         13
#define ATOM        14
#define COMMENT     15
#define EMAIL       16
#define QUOTE       17
private mixed *tokenize(string header_field) {
  int i, quoted, paren_count, angle_count;
  int *tokens, state;
  mixed *bits;
  bits = reg_assoc(header_field,
                   ({ "\\\\.", "\"", "\\(", "\\)", "<", ">",
                      ",", "@",
                      "[]()<>@,;:\\\\\".[]",
                      "(\n?[ \t])+",
                      "[!#-'*+/-9=?A-Z^-~-]+" }),
                   ({ TOK_QP, TOK_QUOTE, TOK_OP, TOK_CP, TOK_LT, TOK_GT,
                      TOK_SEP, TOK_AMP, SPECIAL, LWS, ATOM }));
  tokens = ({ 0 });
  for (i = 1; i < sizeof(bits[0]); i += 2) {
    switch(bits[1][i]) {
    case LWS:
      if (quoted) {
        tokens += ({ state, 0 });
      } else {
        tokens += ({ 0, 0 });
      }
      break;
    case TOK_QUOTE:
      quoted = !quoted;
      if (!state && quoted) {
        state = QUOTE;
      }
      tokens += ({ state, 0 });
      if (state == QUOTE && !quoted) {
        state = 0;
      }
      break;
    case TOK_OP:
      if (!quoted) {
        paren_count++;
        state = COMMENT;
      }
      tokens += ({ state, 0 });
      break;
    case TOK_CP:
      if (!quoted) {
        paren_count--;
        if (paren_count < 0) {
          printf("Unbalanced ')'\n");
          return ({ });
        }
      }
      tokens += ({ state, 0 });
      if (!paren_count) {
        state = 0;
      }
      break;
    case TOK_LT:
      tokens += ({ state, 0 });
      if (!(quoted || paren_count)) {
        angle_count++;
        state = EMAIL;
      }
      break;
    case TOK_GT:
      if (!(quoted || paren_count)) {
        angle_count--;
        if (angle_count != 0) {
          printf("Unbalanced '%c'\n", (angle_count < 0?'>':'<'));
          return ({ });
        }
        state = 0;
      }
      tokens += ({ state, 0 });
      break;
    default:
      if (!state) {
        tokens += ({ bits[1][i], 0 });
      } else {
        tokens += ({ state, 0 });
      }
      break;
    }
    if (paren_count < 0) {
      printf("Unbalanced ')'\n");
      return ({ });
    }
  }
  if (paren_count != 0) {
    printf("Unbalanced '%c'\n", (paren_count < 0?')':'('));
    return ({ });
  }
  bits += ({ tokens });
  return bits;
}
mixed *get_email_addrs(string arg) {
  string *addrs, *full_addrs;
  int i, idx, state;
  mixed *bits;
  if (!arg) {
    return ({ ({ }), ({ }) });
  }
  bits = tokenize(arg);
  if (!sizeof(bits)) {
    return ({ ({ }), ({ }) });
  }
  addrs = allocate(1);
  addrs[0] = "";
  full_addrs = allocate(1);
  full_addrs[0] = "";
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      idx++;
      addrs += ({ "" });
      full_addrs += ({ "" });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = bits[0][i];
        state = EMAIL;
      } else {
        addrs[idx] += bits[0][i];
      }
      full_addrs[idx] += bits[0][i];
      break;
    case COMMENT:
    case LWS:
    case 0:
      full_addrs[idx] += bits[0][i];
      break;
    default:
      addrs[idx] += bits[0][i];
      full_addrs[idx] += bits[0][i];
      break;
    }
  }
  return ({ addrs, full_addrs });
}
string rewrite_field(string header_field) {
  int i, idx, state;
  mixed *bits, *addrs, *indices;
  if (!header_field) {
    return "";
  }
  bits = tokenize(header_field);
  if (!sizeof(bits)) {
    return "";
  }
  addrs = allocate(1);
  addrs[0] = ({ });
  indices = allocate(1);
  indices[0] = ({ });
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      if (sizeof(addrs[idx]) && member_array(TOK_AMP, addrs[idx]) == -1) {
        if (bits[0][indices[idx][<1]] == "discworld") {
          bits[0][indices[idx][<1]] += "@discworld.imaginary.com";
        } else {
          bits[0][indices[idx][<1]] += ".discworld@discworld.imaginary.com";
        }
      }
      idx++;
      addrs += ({ ({ }) });
      indices += ({ ({ }) });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = ({ bits[1][i] });
        indices[idx] = ({ i });
        state = EMAIL;
      } else {
        addrs[idx] += ({ bits[1][i] });
        indices[idx] += ({ i });
      }
      break;
    case COMMENT:
    case LWS:
    case 0:
      break;
    default:
      addrs[idx] += ({ bits[1][i] });
      indices[idx] += ({ i });
      break;
    }
  }
  if (sizeof(addrs[<1]) && member_array(TOK_AMP, addrs[<1]) == -1) {
    if (bits[0][indices[<1][<1]] == "discworld") {
      bits[0][indices[<1][<1]] += "@discworld.imaginary.com";
    } else {
      bits[0][indices[<1][<1]] += ".discworld@discworld.imaginary.com";
    }
  }
  return implode(bits[0], "");
}
class mime_header parse_headers(string message) {
  string *bits, bit, cont, headers;
  int idx, len;
  class mime_header hdr;
  if ((idx = strsrch(message, "\n\n")) == -1) {
    return hdr;
  }
  headers = message[0..idx];
  hdr = new(class mime_header, header_m : ([]), header_k : ({}));
  bits = explode(headers, "\n") - ({ "", 0 });
  foreach (bit in bits[1..]) {
    if (cont && ((bit[0] == ' ') || (bit[0] == '\t'))) {
      hdr->header_m[cont] += "\n" + bit[1..];
      continue;
    }
    len = strlen(bit);
    if ((idx = strsrch(bit, ':')) == -1) {
      continue;
    }
    cont = bit[0..idx-1];
    if (undefinedp(hdr->header_m[lower_case(cont)])) {
      hdr->header_k += ({ cont });
    }
    cont = lower_case(cont);
    ++idx;
    while ((idx < len) && isspace(bit[idx])) {
      ++idx;
    }
    if (undefinedp(hdr->header_m[cont])) {
      hdr->header_m[cont] = bit[idx..];
    } else {
      hdr->header_m[cont] += sprintf(", %s", bit[idx..]);
    }
  }
  return hdr;
}
string rewrite_header(string message) {
  mixed *ra;
  int i;
  string header, field;
  if ((i = strsrch(message, "\n")) == -1) {
    return message;
  }
  message = message[i+1..];
  if ((i = strsrch(message, "\n\n")) == -1) {
    return message;
  }
  header = message[0..i];
  message = message[i+1..];
  ra = reg_assoc(header,
                 ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
                 ({ HEADER_NAME, HEADER_VAL }));
  for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
    if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
      switch(lower_case(ra[0][i])) {
      case "to:":
      case "from:":
      case "cc:":
      case "bcc:":
      case "reply-to:":
        field = rewrite_field(ra[0][i+2]);
        if (field != "") {
          ra[0][i+2] = field;
        }
        break;
      default:
        break;
      }
    }
  }
  return implode(ra[0], "") + message;
}
void dest_me() {
  destruct(this_object());
}
int cleanup(int inherited) {
  if (!inherited) {
    dest_me();
  }
  return 1;
}

==================================================
FILE: handlers/money_handler.c
==================================================

#include <money.h>
#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#define USE_VAULT DEF_VALUE
mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where);
void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_all_values() { return copy( values ); }
string *query_all_places() {
   return keys(values);
}
mixed *query_values() { return copy( values[ "default" ] ); }
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
}
mixed *query_weighted_values_in( string where, int backwards ) {
    mixed *bits;
    int i, j;
    int max_size;
    int len;
    mixed *arr, *reversed;
    if ( !where || ( where == "" ) ) {
        return 0;
    }
    bits = copy( values[ where ] );
    arr = ({ });
    max_size = 0;
    for ( i = 0; i < sizeof( bits ); i += 2 ) {
        len = sizeof( bits[ i ] );
        if ( len > max_size ) {
            arr += ({ bits[ i ], bits[ i + 1 ] });
            max_size = len;
            continue;
        }
        for ( j = 0; j < sizeof( arr ); j += 2 ) {
            if ( len <= sizeof( arr[ j ] ) ) {
                arr = arr[ 0..j-1] + ({ bits[ i ], bits[ i + 1 ] }) + arr[j..];
                break;
            }
        }
    }
    if ( backwards ) {
        reversed = ({ });
        for ( i = sizeof( arr ) - 1; i > 0; i -= 2) {
            reversed += ({ arr[ i - 1 ], arr[ i ] });
        }
        return reversed;
    }
    else {
       return arr;
    }
}
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;
   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
}
void add_type( string where, string type, int value ) {
   int i;
   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
}
void remove_type( string where, string type ) {
   int i;
   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
}
mapping query_details() { return copy( details ); }
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
}
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
}
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
}
mapping query_symbols() { return copy( symbols ); }
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
}
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
}
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
}
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
}
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
}
string *query_aliases_for( string type ) {
   string *ret;
   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
}
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
}
string *query_adjectives_for( string type ) {
   string *ret;
   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   return ret;
}
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
}
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
}
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
}
string query_main_plural_for( string type ) {
   string *type_exp;
   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
}
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
}
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
}
string money_string( mixed mon_array ) {
   int i;
   string ret;
   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 );
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
}
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
}
varargs string money_value_string( int value, string where ) {
   string symboliser;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
}
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;
   if (!where) {
      where = "default";
   }
   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = query_weighted_values_in( where, 1 );
   if (!value && stuff) {
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
}
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
}
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;
   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
}
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }
      value *= query_value( type, where );
   }
   if (!value) {
      return 0;
   }
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   if ( value > total ) {
      return 0;
   }
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];
   ret = ({ });
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }
   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }
   return ({ ret, value, mon_array });
}
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;
   if (!type) {
     return 0;
   }
   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
}
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;
   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }
      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }
   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }
   if (sizeof(change_array) == 0) {
      return 0;
   }
#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;
}
varargs object make_new_amount( int value, string where ) {
   object money;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
}
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   object *monies;
   m_array = money->query_money_array();
   monies = filter_legal_money_array(m_array, where);
#ifdef USE_VAULT
   MONEY_VAULT->add_to_list(money);
#else
   money->move("/room/rubbish");
#endif
   return monies;
}
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   object good, no_good;
   mixed *money_arrays;
   money_arrays = filter_legal_money_to_array(m_array, where);
   if (sizeof(money_arrays[0]) == 0) {
      good = 0;
   } else  {
#ifdef USE_VAULT
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(money_arrays[0]);
   }
   if (sizeof(money_arrays[1]) == 0) {
      no_good = 0;
   } else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(money_arrays[1]);
   }
   return ({ good, no_good });
}
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where) {
   int i;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });
   if (sizeof(m_array) == 0) {
      return ({ ({ }), ({ }) });
   }
   if (!where || where == "") {
     where = "default";
   }
   if (!(poss_values = values[where])) {
      return ({ ({ }), copy(m_array) });
   }
   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }
   return ({ good_array, no_good_array });
}
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;
   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;
}
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   int     adjust_flag;
   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[i]) < m_array[i + 1]) {
            return NO_MATCH;
         }
      }
      adjust_flag = 1;
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      adjust_flag = 0;
      m_array = ({ });
      foreach (thing in things) {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   monies = filter_legal_money_array(m_array, place);
   if(monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
      if (!adjust_flag)
         this_player()->adjust_money(m_array);
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#else
      monies[1]->dest_me();
#endif
   }
   if (monies[0])  {
      if (adjust_flag)  {
         m_array2 = copy(monies[0]->query_money_array());
         for (i = 0; i < sizeof(m_array2); i += 2)
            m_array2[i + 1] = -m_array2[i + 1];
         this_player()->adjust_money(m_array2);
      }
      return monies[0];
   }
   else  {
      return NO_LEGAL;
   }
}
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;
   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
}
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
  tmp = values(query_all_values());
  foreach( elem in tmp ){
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}
string query_origin_of( string type ){
  string elem, *places;
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  places = query_all_places();
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  types = query_valid_types();
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   r = 1;
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
int smallest_value_in( string place ) {
   int i, smallest;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
      }
   }
   return smallest;
}
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;
   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
}

==================================================
FILE: handlers/monster_handler.c
==================================================

int num;
void create() {
  seteuid("Room");
  unguarded((: restore_object, "/save/monster-handler" :));
}
string query_shadow_name() {
  num++;
  return "/tmp/mon-shad/frog-"+num;
}
void reset() {
  unguarded((: save_object, "/save/monster-handler" :));
}
void dest_me() {
  unguarded((: save_object, "/save/monster-handler" :));
}

==================================================
FILE: handlers/multiplayer.c
==================================================

#include <login_handler.h>
#include <playerinfo.h>
#define SAVE_FILE   "/save/multiplayer"
#define ALIST "/secure/alist"
#define ALLOWED_ITEMS ({ "/obj/misc/club_badge", "/obj/misc/al_receipt" })
string *denied_parcels;
mapping allowed;
protected void create() {
  string denied_parcel;
  int changed = 0;
  denied_parcels = ({ });
  allowed = ([ ]);
  seteuid(master()->creator_file(file_name()));
  if (file_size(SAVE_FILE + ".o") > 0) {
    unguarded((: restore_object, SAVE_FILE, 1 :));
  }
  foreach (denied_parcel in denied_parcels) {
    if (!PLAYER_HANDLER->test_user(denied_parcel)) {
      denied_parcels -= ({ denied_parcel });
      changed = 1;
    }
  }
  if (changed) {
    unguarded((: save_object, SAVE_FILE :));
  }
}
private void save_me() {
  unguarded((: save_object, SAVE_FILE :));
}
string *check_allowed(mixed user, mixed *others) {
  string *not_allowed;
  mixed tmp, alt;
  if(objectp(user))
    user = user->query_name();
  if(!allowed[user] && PLAYERINFO_HANDLER->query_alt_of(user) != "")
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  not_allowed = ({ });
  foreach(tmp in others) {
    if(objectp(tmp))
      tmp = tmp->query_name();
    alt = PLAYERINFO_HANDLER->query_alt_of(tmp);
    if(!alt)
      alt = tmp;
    if(!allowed[user] || member_array(alt, allowed[user]) == -1)
      not_allowed += ({ tmp });
  }
  return not_allowed;
}
int add_git(string git) {
  PLAYERINFO_HANDLER->add_entry(this_player(), git, "multiplay",
                                "Caught multiplaying.\n");
  return 1;
}
int add_allowed(string user, string other) {
  int oldsize, changed;
  if (!(PLAYER_HANDLER->test_user(user) && PLAYER_HANDLER->test_user(other))) {
    return 0;
  }
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if(PLAYERINFO_HANDLER->query_alt_of(other))
    other = PLAYERINFO_HANDLER->query_alt_of(other);
  if (undefinedp(allowed[user])) {
    allowed[user] = ({ other });
  } else {
    oldsize = sizeof(allowed[user]);
    allowed[user] |= ({ other });
  }
  if (!oldsize || (oldsize != sizeof(allowed[user]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + other + ".\n");
  }
  if (undefinedp(allowed[other])) {
    allowed[other] = ({ user });
  } else {
    oldsize = sizeof(allowed[other]);
    allowed[other] |= ({ user });
  }
  if (!oldsize || (oldsize != sizeof(allowed[other]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), other, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + user + ".\n");
  }
  if (changed) {
    call_out((: save_me :), 1);
  }
  return 1;
}
int delete_allowed(string user) {
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if (undefinedp(allowed[user]))
    return 0;
  map_delete(allowed, user);
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                "Deleted from multiplayer handler "
                                "(allowed).\n");
  return 1;
}
mapping query_allowed() {
  return copy(keys(allowed));
}
int add_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to add a user to this list.\n");
    return 0;
  }
  if (member_array( user, denied_parcels) != -1) {
    denied_parcels -= ({ user });
  }
  if (!PLAYER_HANDLER->test_user(user)) {
    return 0;
  }
  denied_parcels += ({ lower_case(user) });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                            "Denied the use of the parcel system.\n");
  return 1;
}
int remove_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to remove a user to this list.\n");
    return 0;
  }
  if (member_array(user, denied_parcels) == -1)
    return 0;
  denied_parcels -= ({ user });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                           "Allowed the use of the parcel system.\n");
  return 1;
}
int member_denied_parcel( string user ) {
  if (member_array(user, denied_parcels) == -1)
    return 0;
  return 1;
}
string *query_denied_parcels() {
  return copy(denied_parcels);
}
varargs void mark_log(string user, string comment) {
  if (!comment) {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + " Previous log entries handled.\n");
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Previous log entries handled.\n");
  } else {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + ": " + comment + "\n" );
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  comment + "\n");
  }
}
string query_name() {
  return "Multiplayer handler";
}
void record_object(string action, object player, object item) {
  mixed stuff;
  stuff = item->query_property("dropped");
  if(sizeof(stuff) && player->query_name() != stuff[0])
    stuff = ({ player->query_name(), query_ip_number(player), time(),
                 stuff[0] });
  else
    stuff = ({ player->query_name(), query_ip_number(player), time() });
  item->add_property("dropped", stuff, 1800);
}
int check_multiplayers(string action, object player, object item) {
  mixed stuff;
  string direction, verb, res, is;
  if(objectp(player) && !interactive(player))
    return 0;
  stuff = item->query_property("dropped");
  if(!stuff)
    return 0;
  is = "";
  switch(action) {
  case "get":
    verb = " got ";
    direction = " from ";
    break;
  case "give":
    verb = " was given ";
    direction = " by ";
    is = "is ";
    break;
  case "slip":
    verb = " was slipped ";
    direction = " by ";
    is = "is ";
    break;
  case "palm":
    verb = " palmed ";
    direction = " from ";
    break;
  case "plant":
    verb = " planted ";
    direction = " on ";
    is = "is ";
    break;
  case "recover":
    verb = " recovered ";
    direction = " from ";
    break;
  }
  if(stuff[0] != player->query_name() &&
     query_ip_number(player) == stuff[1] &&
     sizeof(check_allowed(player, ({ stuff[0]}) ))) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who " + is +"logged in from the same "
      "address.";
  } else if(direction != " by " &&
            player->query_name() == stuff[0] &&
            player->query_refresh_time() > stuff[2]) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      " after a refresh.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) == 100) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who is " + player->query_possessive() +
      " alt.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) >= 60) {
    res = capitalize(player->query_name()) + verb +  item->a_short() +
      direction + stuff[0] + " who is POSSIBLY " +
      player->query_possessive() + " alt.";
  } else if(sizeof(stuff) == 4) {
    if(player->query_name() == stuff[3]) {
      if(player->query_refresh_time() > stuff[2]) {
        res = capitalize(player->query_name()) + verb + item->a_short() +
          " after a refresh" + direction + stuff[0] + ".";
      }
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) == 100) {
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is " + player->query_possessive() +
        " alt.";
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) >= 60) {
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is _POSSIBLY_ " +
        player->query_possessive() + " alt.";
    }
  } else if((PLAYER_HANDLER->test_creator(stuff[0]) ||
             PLAYER_HANDLER->test_property(stuff[0], "test character")) &&
            !player->query_creator() &&
            !player->query_property("test character") &&
            member_array(base_name(item), ALLOWED_ITEMS) == -1 &&
            base_name(item)[0..14] != "/d/liaison/TOYS") {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0];
    user_event("inform", res, "cheat");
    log_file("/d/admin/log/CHEAT", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
    return 0;
  }
  if(res) {
    user_event("inform", res, "multiplayer");
    log_file("MULTIPLAYERS", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
  }
  return 0;
}

==================================================
FILE: handlers/new_soul.c
==================================================

#include <player.h>
#include <soul.h>
#include <user_parser.h>
#define SAVE_FILE "/save/soul"
#define SOUL_DATA_DIR "/save/soul/data/"
#define POS_SELF   0
#define POS_TARGET 1
#define POS_REST   2
#define PCACHE_MAX_SIZE 30
#define SCACHE_MAX_SIZE 100
#define CLEAN_UP_DELAY 300
mixed soul_commands;
mapping soul_command_names;
nosave mapping pattern_cache;
nosave mapping soul_cache;
nosave string *pcache_order,
 *scache_order;
nosave int scache_hits, scache_reads, pcache_hits, pcache_reads, cache_callout;
void load_it();
void save_it();
void print_messages(string verb, mixed obs, string arg, string self,
                    string rest, string target, string force,
                    mapping position);
protected void save_soul_command(string name, mixed *data);
void create() {
  soul_commands = 0;
  soul_command_names = ([ ]);
  pattern_cache = ([ "" : NO_ARGUMENT ]);
  pcache_order = ({ });
  scache_order = ({ });
  soul_cache = ([ ]);
  seteuid("Room");
  load_it();
}
void clean_cache() {
  int i;
  for (i = 0; i < (sizeof(pcache_order) - PCACHE_MAX_SIZE); i++) {
    map_delete(pattern_cache, pcache_order[i]);
  }
  pcache_order = pcache_order[i..];
  for (i = 0; i < (sizeof(scache_order) - SCACHE_MAX_SIZE); i++) {
    map_delete(soul_cache, scache_order[i]);
  }
  scache_order = scache_order[i..];
  cache_callout = 0;
}
void add_soul_command(string name, mixed data) {
  if (file_name(previous_object()) != SOUL_COMPILER)
    return;
  save_soul_command(name, data);
  map_delete(soul_cache, name);
  save_it();
}
void delete_soul_command(string name) {
  map_delete(soul_cache, name);
  map_delete(soul_command_names, name);
  unguarded((: rm, SOUL_DATA_DIR + name + ".os" :));
  save_it();
}
string *query_soul_commands() {
  return keys(soul_command_names);
}
protected mixed *query_soul_command_data(string str) {
  scache_reads++;
  if (!soul_cache[str] && soul_command_names[str]) {
    string tmp;
    tmp = unguarded((: read_file, SOUL_DATA_DIR + str + ".os" :));
    soul_cache[str] = restore_variable(tmp);
    if (!cache_callout && (sizeof(scache_order) > SCACHE_MAX_SIZE))
      cache_callout = call_out("clean_cache", CLEAN_UP_DELAY);
  } else {
    scache_order -= ({ str });
    scache_hits++;
  }
  scache_order += ({ str });
  return soul_cache[str];
}
mixed *query_soul_command_stuff(string str) {
  return query_soul_command_data(str) + ({ });
}
protected void save_soul_command(string name, mixed *data) {
  string str;
  str = save_variable(data);
  unguarded((: rm, SOUL_DATA_DIR + name + ".os" :));
  unguarded((: write_file, SOUL_DATA_DIR + name + ".os", str :));
  soul_command_names[name] = 1;
}
void save_it() {
  unguarded((: save_object, SAVE_FILE :));
}
void load_it() {
  string *names;
  int i;
  unguarded((: restore_object, SAVE_FILE :));
  if (mapp(soul_commands)) {
    soul_command_names = ([ ]);
    names = keys(soul_commands);
    for (i = 0; i < sizeof(names); i++) {
      reset_eval_cost();
      save_soul_command(names[i], soul_commands[names[i]]);
    }
    soul_commands = 0;
    save_it();
  }
}
private mixed create_pattern_cache(string pattern) {
  mixed *bing, ret;
  string s1, s2;
  bing = explode("#" + pattern, "<indirect:");
  if (sizeof(bing) == 1)
    if (sscanf(bing[0], "%s<word>%s", s1, s2) ||
        sscanf(bing[0], "%s<string>%s", s1, s2))
      ret = ONLY_ARGUMENT;
    else
      ret = NO_ARGUMENT;
  else if (sscanf(bing[0], "%s<word>%s", s1, s2) ||
           sscanf(bing[0], "%s<string>%s", s1, s2))
    ret = ARGUMENT_FIRST;
  else if (sscanf(bing[1], "%s<word>%s", s1, s2) ||
           sscanf(bing[1], "%s<string>%s", s1, s2))
    ret = ARGUMENT_SECOND;
  else
    ret = ONLY_TARGET;
  return ret;
}
mixed *query_soul_command(string name) {
  mixed *data;
  mixed *ret;
  string pat;
  int i;
  if (!soul_command_names[name]) {
    return 0;
  }
  data = query_soul_command_data(name);
  if (!data) {
    return 0;
  }
  ret = ({ ({ ({ }), "", 0, this_object(), 0 }) });
  for (i = 0; i < sizeof(data[PATTERNS]); i++) {
    pat = data[PATTERNS][i];
    pcache_reads++;
    if (!pattern_cache[pat]) {
      pattern_cache[pat] = create_pattern_cache(pat);
      if (!cache_callout && sizeof(pcache_order) > PCACHE_MAX_SIZE) {
        cache_callout = call_out("clean_cache", CLEAN_UP_DELAY);
      }
    } else {
      pcache_hits++;
      pcache_order -= ({ pat });
    }
    pcache_order += ({ pat });
    ret += ({ ({ ((mixed *) PATTERN_OB->query_pattern(pat))[1],
                   pat, 0, this_object(), 0 }) });
  }
  return ret;
}
int command_control(string verb, object * obs, string, string in_dir_match,
                    string *args, string pattern) {
  int i;
  int j;
  string arg;
  mixed *stuff;
  object *wom;
  object *rem;
  mixed *data;
  if (!soul_command_names[verb]) {
    return 0;
  }
  if (pattern != "") {
    stuff = PATTERN_OB->query_pattern(pattern);
    for (i = 1; i < sizeof(stuff); i++) {
      switch (stuff[i]) {
      case INDIRECT_OBJECT:
        i += 2;
        wom = obs;
        if (previous_object()->query_property("no soul")) {
          previous_object()->add_failed_mess(this_object(),
                                           "You cannot use directed souls.\n",
                                             ({ }));
          return 0;
        }
        if ((sizeof(obs) == 1) &&
            !previous_object()->query_creator() &&
            obs[0]->query_property("ignoring") &&
            member_array((string) previous_object()->query_name(),
                         (string *)obs[0]->query_property("ignoring")) != -1) {
          return 0;
        }
        if (sizeof(obs) > 1) {
          obs = filter(obs, (: !$1->check_earmuffs("multiple-soul") :));
          if (!sizeof(obs)) {
            previous_object()->add_failed_mess(this_object(),
               "Everyone seems to have their multiple souls earmuffed.  "
               "I'm depressed, are you depressed?\n",
                                               ({ }));
            return 0;
          }
        }
        rem = filter(obs,
                     (:
                      (!interactive($1) &&
                       environment(previous_object(1)) != environment($1)) ||
                      (interactive($1) && $1->query_role_playing() &&
                       environment($1) != environment(previous_object(1)))
                      :));
        obs -= rem;
        obs -= previous_object()->query_ignoring(obs);
         if(previous_object()->query_role_playing())
           obs -= filter(obs,
                         (:
                          environment($1) != environment(previous_object(1)) ||
                          (interactive($1) &&
                           !previous_object(1)->is_friend($1->query_name()))
                          :));
         if (!sizeof(obs)) {
           return 0;
         }
         if (previous_object()->check_earmuffs("remote-soul")) {
           if (previous_object()->query_earmuffs() ==
               PLAYER_ALLOW_FRIENDS_EARMUFF) {
             rem = filter(obs,
                          (:
                          environment(previous_object(1)) != environment($1) &&
                           !previous_object(1)->is_friend($1->query_name())
                           :));
           } else {
             rem = filter(obs,
                          (:
                           environment(previous_object(1)) != environment($1)
                           :));
           }
           if (sizeof(rem) == sizeof(obs)) {
             previous_object()->add_failed_mess(this_object(),
               "You cannot do a remote soul when you have remote souls "
                                                "earmuffed.\n", ({ }));
             return 0;
           }
           obs = obs - rem;
         } else {
           obs = filter(obs, (: !$1->check_earmuffs("remote-soul") ||
                              (environment(previous_object(1)) ==
                               environment($1)) :));
           if (!sizeof(obs)) {
             previous_object()->add_failed_mess(this_object(),
               "Remote soul earmuffs enabled for $I.\n", wom);
             return 0;
           }
         }
         j++;
         break;
       case STRING:
       case SINGLE_WORD:
       case SHORT_STRING:
         arg = args[j++];
         break;
       case NUMBER:
         j++;
         break;
       case FRACTION:
         j += 2;
         break;
       case OPTIONAL:
       case OPTIONAL_SPACES:
         i++;
         break;
       case WORD_LIST:
       case WORD_LIST_SPACES:
         i++;
         if (pointerp(stuff[i]) && sizeof(stuff[i]) > 1)
           j++;
         break;
       }
     }
   }
   if (!pattern_cache[pattern]) {
     return 0;
   }
   if (!previous_object()->query_creator()) {
     if ((int) previous_object()->adjust_sp(-SOUL_COST *
                                            (1 + sizeof(obs))) < 0) {
       previous_object()->add_failed_mess(this_object(), NO_POWER, ({ }));
       return 0;
     }
   }
   data = query_soul_command_data(verb);
   switch (pattern_cache[pattern]) {
   case NO_ARGUMENT:
     if (data[SINGLE])
       if (data[SINGLE][NO_ARGUMENTS]) {
         if (sizeof(data[SINGLE][NO_ARGUMENTS]) > POSITION_SINGLE) {
           print_messages(verb, 0, "", data[SINGLE][NO_ARGUMENTS][SELF],
                          data[SINGLE][NO_ARGUMENTS][REST],
                          0, 0,
                          data[SINGLE][NO_ARGUMENTS][POSITION_SINGLE]);
         } else {
           print_messages(verb, 0, "", data[SINGLE][NO_ARGUMENTS][SELF],
                          data[SINGLE][NO_ARGUMENTS][REST], 0, 0, 0);
         }
         return 1;
       } else {
         if (!data[SINGLE][ARGUMENTS])
           return 0;
         arg = data[SINGLE][ARGUMENTS][ARGS][0];
       } else
         return 0;
   case ONLY_ARGUMENT:
     if (arg == "?") {
       j = 0;
       for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
         j += sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
       j = random(j);
       for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
         if (j < sizeof(data[SINGLE][ARGUMENTS][i + ARGS])) {
           if (data[SINGLE][ARGUMENTS][i + ARGS][j] == "#") {
             if (j > 0)
               j--;
             else {
               j++;
               if (j >= sizeof(data[SINGLE][ARGUMENTS][i + ARGS])) {
                 j -= sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
                 continue;
               }
             }
           }
           print_messages(verb, 0, data[SINGLE][ARGUMENTS][i + ARGS][j],
                          data[SINGLE][ARGUMENTS][i + SELF],
                          data[SINGLE][ARGUMENTS][i + REST], 0, 0,
                          data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
           return 1;
         } else {
           j -= sizeof(data[SINGLE][ARGUMENTS][i + ARGS]);
         }
     }
     for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE) {
       if ((j = member_array(arg, data[SINGLE][ARGUMENTS][i + ARGS], 0, 1))
           != -1) {
         print_messages(verb, 0, data[SINGLE][ARGUMENTS][i + ARGS][j],
                        data[SINGLE][ARGUMENTS][i + SELF],
                        data[SINGLE][ARGUMENTS][i + REST],
                        0, 0,
                        data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
         return 1;
       }
     }
     for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE)
       if ((j = member_array("#", data[SINGLE][ARGUMENTS][i + ARGS], 0, 1))
           != -1) {
         print_messages(verb, 0, arg,
                        data[SINGLE][ARGUMENTS][i + SELF],
                        data[SINGLE][ARGUMENTS][i + REST], 0, 0,
                        data[SINGLE][ARGUMENTS][i + POSITION_SINGLE]);
         return 1;
       }
     previous_object()->add_failed_mess(this_object(),
                                        arg +
                                        " is not a valid argument to the soul "
                                        "command \"" + verb + "\".\n",
                                        ({ }));
     return 0;
   case ARGUMENT_FIRST:
   case ARGUMENT_SECOND:
     break;
   case ONLY_TARGET:
     if (data[TARGET][NO_ARGUMENTS]) {
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, 0);
       print_messages(verb, obs, "",
                      data[TARGET][NO_ARGUMENTS][SELF],
                      data[TARGET][NO_ARGUMENTS][REST],
                      data[TARGET][NO_ARGUMENTS][TARGET],
                      data[TARGET][NO_ARGUMENTS][FORCE],
                      data[TARGET][NO_ARGUMENTS][POSITION]);
       return 1;
     }
     if (!data[TARGET][ARGUMENTS]) {
       return 0;
     }
     arg = data[TARGET][ARGUMENTS][ARGS][0];
     break;
   }
   if (arg == "?") {
     j = 0;
     for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
       j += sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
     }
     j = random(j);
     for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
       if (j < sizeof(data[TARGET][ARGUMENTS][i + ARGS])) {
         if (data[TARGET][ARGUMENTS][i + ARGS][j] == "#") {
           if (j > 0) {
             j--;
           } else {
             j++;
             if (j >= sizeof(data[TARGET][ARGUMENTS][i + ARGS])) {
               j -= sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
               continue;
             }
           }
         }
         obs->event_soul_command(this_object(), verb, previous_object(),
                                 in_dir_match, arg);
         print_messages(verb, obs, data[TARGET][ARGUMENTS][i + ARGS][j],
                        data[TARGET][ARGUMENTS][i + SELF],
                        data[TARGET][ARGUMENTS][i + REST],
                        data[TARGET][ARGUMENTS][i + TARGET],
                        data[TARGET][ARGUMENTS][i + FORCE],
                        data[TARGET][ARGUMENTS][i + POSITION]);
         return 1;
       } else {
         j -= sizeof(data[TARGET][ARGUMENTS][i + ARGS]);
       }
     }
   }
   for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
     if ((j =
          member_array(arg, data[TARGET][ARGUMENTS][i + ARGS], 0,
                       1)) != -1) {
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, arg);
       print_messages(verb, obs, data[TARGET][ARGUMENTS][i + ARGS][j],
                      data[TARGET][ARGUMENTS][i + SELF],
                      data[TARGET][ARGUMENTS][i + REST],
                      data[TARGET][ARGUMENTS][i + TARGET],
                      data[TARGET][ARGUMENTS][i + FORCE],
                      data[TARGET][ARGUMENTS][i + POSITION]);
       return 1;
     }
   }
   for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
     if ((j =
          member_array("#", data[TARGET][ARGUMENTS][i + ARGS], 0,
                       1)) != -1) {
       obs->event_soul_command(this_object(), verb, previous_object(),
                               in_dir_match, arg);
       print_messages(verb, obs, arg,
                      data[TARGET][ARGUMENTS][i + SELF],
                      data[TARGET][ARGUMENTS][i + REST],
                      data[TARGET][ARGUMENTS][i + TARGET],
                      data[TARGET][ARGUMENTS][i + FORCE],
                      data[TARGET][ARGUMENTS][i + POSITION]);
       return 1;
     }
   }
   return 0;
}
string get_name(object ob, int use_name, int type) {
  if(ob == previous_object())
    return ob->query_objective() + "self";
  if(userp(ob) && use_name && environment(ob) != environment(previous_object()))
    return "$mirror_short:" + file_name(ob) + "$";
  return ob->one_short(use_name);
}
private string create_message(mixed targets, string args, string pattern,
                              int type, string verb, string position,
                              string actor_position, mixed me,
                              int use_name) {
  string *bits;
  string *rabbit;
  string singular;
  string plural;
  int i;
  int word_break;
  if(arrayp(targets) && sizeof(targets) == 1)
    targets = targets[0];
  if (stringp(verb) && type && (sizeof(explode(pattern, "$V$")) < 2)) {
    if (pointerp(targets) && sizeof(targets) > 0) {
      pattern = replace_string(pattern, pluralize(verb), "$V$1=" +
                               pluralize(verb) + "," + verb + "$V$");
    } else {
      pattern = replace_string(pattern, pluralize(verb), "$V$0=" +
                               pluralize(verb) + "," + verb + "$V$");
    }
  }
  if(pattern) {
    pattern = replace_string(pattern, "$V$", "VERBFROG");
    bits = explode("%" + replace(pattern, ({ "$arg$", args })), "$");
  }
  if (!me) {
    me = previous_object();
  }
  for (i = 1; i < sizeof(bits); i += 2) {
    switch (bits[i]) {
    case "article":
      if (vowel(args[0])) {
        bits[i] = "an";
      } else {
        bits[i] = "a";
      }
      break;
    case "hcname":
      if (stringp(targets)) {
        bits[i] = targets;
        break;
      }
      if (objectp(targets)) {
        if ((targets == me)) {
          if (type) {
            bits[i] = (string) targets->query_objective() + "self";
          } else {
            bits[i] = "yourself";
          }
        } else {
          bits[i] = (string) get_name(targets, use_name, type);
        }
        break;
      }
      if(arrayp(targets)) {
        bits[i] = "$M$" + implode(map(targets, (: get_name :), use_name, type), "") +
                  "$M$";
      }
      break;
    case "mhcname":
      if (stringp(targets)) {
        bits[i] = targets + "'s";
        break;
      }
      if (objectp(targets)) {
        if ((targets == me))
          if (type)
            bits[i] = (string) targets->query_possessive();
          else
            bits[i] = "your";
        else
          bits[i] = (string) targets->the_poss_short();
        break;
      }
      bits[i] = "$M$" + implode(map(targets,
        (: objectp($1) ? $1->the_poss_short($(use_name)) : $1 + "'s" :)), "") +
        "$M$";
      break;
    case "hposs":
      if (objectp(targets))
        bits[i] = (string) targets->query_possessive();
      else
        bits[i] = "their";
      break;
    case "hpronoun":
      if (objectp(targets))
        bits[i] = (string) targets->query_pronoun();
      else
        bits[i] = "they";
      break;
    case "hobj":
      if (objectp(targets))
        bits[i] = (string) targets->query_objective();
      else
        bits[i] = "them";
      break;
    case "mcname":
      if(stringp(me))
        bits[i] = me;
      else if (me != previous_object()) {
        bits[i] = (string) me->short(0, 0);
      } else if(userp(me) && use_name) {
        bits[i] = me->short(0, 0);
      } else
        bits[i] = me->the_short();
      break;
    case "mposs":
      if (type && objectp(me)) {
        bits[i] = (string) me->query_possessive();
      } else {
        bits[i] = "your";
      }
      break;
    case "mpronoun":
      bits[i] = (string) me->query_pronoun();
      break;
    case "mobj":
      if(objectp(me))
        bits[i] = (string) me->query_objective();
      else
        bits[i] = "you";
      break;
    case "position":
      if (position) {
        rabbit = explode("%" + position, "$");
        rabbit[0] = rabbit[0][1..];
        if ((sizeof(rabbit) % 2) == 1) {
          rabbit += ({ "" });
        }
        bits = bits[0..i] + rabbit + bits[i + 1..];
      }
      bits[i] = "";
      break;
    case "aposition":
      if (actor_position) {
        rabbit = explode("%" + actor_position, "$");
        rabbit[0] = rabbit[0][1..];
        if ((sizeof(rabbit) % 2) == 1) {
          rabbit += ({ "" });
        }
        bits = bits[0..i] + rabbit + bits[i + 1..];
      }
      bits[i] = "";
      break;
    case "s":
      if (i == 0)
        break;
      word_break = strsrch(bits[i - 1], ' ', -1);
      if (word_break == -1)
        break;
      if (me == previous_object())  {
        if (use_name)
          bits[i] = pluralize(bits[i - 1][word_break + 1 .. ]);
        else  {
          if (pointerp(targets)  &&  sizeof(targets) > 0)
            bits[i] = "$V$1=";
          else
            bits[i] = "$V$0=";
          bits[i] +=  pluralize(bits[i - 1][word_break + 1 .. ]) + "," +
                    bits[i - 1][word_break + 1 .. ] + "$V$";
        }
        bits[i - 1] = bits[i - 1][0 .. word_break];
      }
      break;
    case "verb":
      if (i + 1 < sizeof(bits))  {
        if (sscanf(bits[i + 1], "%s,%s", singular, plural) == 2)
        {
          if (me == previous_object())  {
            if (use_name)
              bits[i] = singular;
            else  {
              if (pointerp(targets)  &&  sizeof(targets) > 0)
                bits[i] = "$V$1=";
              else
                bits[i] = "$V$0=";
              bits[i] +=  singular + "," + plural + "$V$";
            }
          }
          else bits[i] = singular;
          bits = bits[0 .. i] + bits[i + 2 .. ];
        }
      }
      break;
    case "dollar":
      bits[i] = "$";
      break;
    }
  }
  pattern = implode(bits, "")[1..] + "\n";
  pattern = replace_string(pattern, "VERBFROG", "$V$");
  return pattern;
}
private string position_command(mixed bing) {
  if (stringp(bing)) {
    return bing;
  }
  if (mapp(bing)) {
    return bing["cmd"];
  }
  return 0;
}
private void do_position_stuff(object ob, mapping position) {
  string cur_pos;
  string new_pos;
  if (position) {
    cur_pos = ob->query_position();
    if (position[cur_pos]) {
      new_pos = position_command(position[cur_pos]);
    } else if (position["default"]) {
      new_pos = position_command(position["default"]);
    }
    if (new_pos && new_pos != "ignore" &&
        !ob->query_cannot_change_position() &&
        ("/cmds/living/" + new_pos)->query_position_command()) {
      ("/cmds/living/" + new_pos)->position(ob, position["silent"]);
    }
  }
}
private string *position_string(object ob, mapping position, int) {
  string *str;
  string cur_pos;
  mixed new_pos;
  str = ({ 0, 0, 0 });
  if (position) {
    cur_pos = ob->query_position();
    if (position[cur_pos]) {
      new_pos = position[cur_pos];
    } else if (position["default"]) {
      new_pos = position["default"];
    }
    if (mapp(new_pos)) {
      return ({ new_pos["self"], new_pos["target"], new_pos["rest"] });
    }
    if (new_pos && new_pos != "ignore" &&
        !ob->query_cannot_change_position() &&
        ("/cmds/living/" + new_pos)->query_position_command()) {
      str = ({ " making you " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down(),
                 " making $hobj$ " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down(),
                 " making $hobj$ " + new_pos + " " +
                 ("/cmds/living/" + new_pos)->query_up_down()
                 });
    }
  }
  return str;
}
private string position_of(object ob, mapping position) {
  string tmp;
  tmp = ob->query_position();
  if (position[tmp]) {
    tmp = position_command(position[tmp]);
    if (tmp) {
      return tmp;
    }
  }
  if (position["default"]) {
    tmp = position_command(position["default"]);
    if (tmp) {
      return tmp;
    }
  }
  return "";
}
private string env_position_of(object ob, mapping position) {
  return file_name(ob->query_current_room()) + position_of(ob, position);
}
private void print_messages(string verb, mixed obs, string arg, string self,
                            string rest, string target, string force,
                            mapping position) {
  object *here, *targ;
  string *pos_stuff, *actor_pos_stuff;
  if(!obs)
    obs = ({ });
  if(!position)
    position = ([ ]);
  switch(sizeof(obs)) {
  case 0:
    pos_stuff = position_string(previous_object(), position, 0);
    actor_pos_stuff = ({ "", "", ""});
    do_position_stuff(previous_object(), position);
    break;
  case 1:
    pos_stuff = position_string(obs[0], position, 0);
    actor_pos_stuff = position_string(previous_object(), position["actor"], 0);
    do_position_stuff(obs[0], position);
    if (position && position["actor"])
      do_position_stuff(previous_object(), position["actor"]);
    break;
  default:
    actor_pos_stuff = position_string(previous_object(), position["actor"], 0);
    pos_stuff = ({ "", "", "" });
    if (position && position["actor"])
      do_position_stuff(previous_object(), position["actor"]);
  }
  here = filter(obs, (: environment(previous_object(1)) == environment($1) :));
  targ = obs - here - ({ previous_object() });
  if(!sizeof(obs) || sizeof(here))
    previous_object()->remove_hide_invis("hiding");
  if(member_array(previous_object(), obs) == -1) {
    previous_object()->event_soul(previous_object(),
                                 create_message(obs, arg, self, 0, 0,
                                                 pos_stuff[POS_TARGET],
                                                 actor_pos_stuff[POS_TARGET],
                                                 0, 1), ({ }), verb, arg, 0);
  } else {
    if(sizeof(obs) > 1)
      obs -= ({ previous_object() });
    previous_object()->event_soul(previous_object(),
                                  create_message(obs, arg, self, 0, 0,
                                                 pos_stuff[POS_SELF],
                                                 actor_pos_stuff[POS_SELF],
                                                 0, 1), ({ }), verb, arg, 0);
  }
  if(arg)
    arg = replace(arg,
                  ({ "yourself", previous_object()->query_objective() + "self",
                       "your", previous_object()->query_possessive() }));
  if(sizeof(targ)) {
    target = replace(target, ({ " you.", " $hcname$.",
                                " you ", " $hcname$ ",
                                " you!", " $hcname$!",
                                " your ", " $mhcname$ " }));
    targ->event_soul(previous_object(),
                     create_message(obs, arg, target, 1, 0,
                                    pos_stuff[POS_SELF],
                                    actor_pos_stuff[POS_TARGET], 0, 1),
                     ({ }), verb, arg, 0);
  }
  obs -= ({ previous_object() });
  if(!sizeof(obs) || sizeof(here)) {
    if(sizeof(here) > 1)
      here -= ({ previous_object() });
    if(environment(previous_object()))
      event(environment(previous_object()), "soul",
            create_message(here, arg, rest, 1, 0, pos_stuff[POS_REST],
                           actor_pos_stuff[POS_REST], 0, 0),
            ({ previous_object() }) + targ, verb, arg,
            sizeof(here)>=1?here[0]:0);
  }
#ifdef DISABLED
  if(sizeof(obs) && stringp(force)) {
    force = replace(force, "$mcname$", previous_object()->query_name());
    foreach(ob in obs)
      call_out("do_force", 2, ({ ob, force }));
  }
#endif
}
string add_start(string pat, string verb) {
  return verb + " " + pat;
}
string help_list() {
  return "$P$Soul$P$The commands available in this soul currently number " +
    sizeof(soul_command_names) +
    ".\nHere is a nice list of them.\nGood luck!\n" +
    sprintf("%-#*s\n\n", (int) this_player()->query_cols(),
            implode(sort_array(keys(soul_command_names), 1), "\n"));
}
string help_string(string verb) {
  string ret, arg;
  int i;
  mixed target;
  mixed *data;
  if (!soul_command_names[verb])
    return 0;
  data = query_soul_command_data(verb);
  ret = sprintf("Allowed command patterns:\n%-#*s\n\n",
                (int) this_player()->query_cols(),
                implode(map_array(data[PATTERNS],
                                  "add_start", this_object(), verb), "\n"));
  if (data[SINGLE]) {
    if (data[SINGLE][NO_ARGUMENTS]) {
      ret += "Has a no arguments mode.\nSelf:   " +
        create_message(0, "", data[SINGLE][NO_ARGUMENTS][SELF], 0, 0,
                       0, 0, this_player(), 0) +
        "Others: " +
        create_message(0, "", data[SINGLE][NO_ARGUMENTS][REST], 1, 0,
                       0, 0, this_player(), 0) + "\n";
    }
    if (data[SINGLE][ARGUMENTS]) {
      for (i = 0; i < sizeof(data[SINGLE][ARGUMENTS]); i += SMALL_ARG_SIZE) {
        arg = data[SINGLE][ARGUMENTS][i + ARGS][0];
        ret += sprintf("For the arguments: [%-=*s",
                       (int) this_player()->query_cols() - 20,
                       implode(data[SINGLE][ARGUMENTS][i + ARGS],
                               ", ") + "]") + "\nSelf:   " +
          create_message(0, arg, data[SINGLE][ARGUMENTS][i + SELF], 0, 0,
                         0, 0, this_player(), 0)
          + "Others: " + create_message(0, arg,
                                        data[SINGLE][ARGUMENTS][i + REST], 1,
                                        0, 0, 0, this_player(), 0)
          + "\n";
      }
    }
  }
  if (data[TARGET]) {
    target = query_multiple_short(({ "Womble", "Cabbage" }));
    if (data[TARGET][NO_ARGUMENTS]) {
      ret += "Has a no arguments, targeted mode.\nSelf:   " +
        create_message(target, "", data[TARGET][NO_ARGUMENTS][SELF], 0, 0,
                       0, 0,
                       this_player(), 0) + "Target: " +
        (data[TARGET][NO_ARGUMENTS][TARGET] ?
         create_message(target, "", data[TARGET][NO_ARGUMENTS][TARGET], 2,
                        0, 0, 0, this_player(), 0) :
         create_message(target, "", data[TARGET][NO_ARGUMENTS][REST],
                        1, 0, 0, 0,this_player(), 0)) +
        "Others: " + create_message(target, "",
                                    data[TARGET][NO_ARGUMENTS][REST], 1,
                                    0, 0, 0, this_player(), 0) + "\n";
    }
    if (data[TARGET][ARGUMENTS]) {
      for (i = 0; i < sizeof(data[TARGET][ARGUMENTS]); i += ARG_SIZE) {
        arg = data[TARGET][ARGUMENTS][i + ARGS][0];
        ret += sprintf("For the arguments: [%-=*s",
                       (int) this_player()->query_cols() - 20,
                       implode(data[TARGET][ARGUMENTS][i + ARGS],
                               ", ") + "]") + "\nSelf:   " +
          create_message(target, arg, data[TARGET][ARGUMENTS][i + SELF],
                         0, 0, 0, 0,
                         this_player(), 0) + "Target: " +
          (data[TARGET][ARGUMENTS][TARGET + i] ?
           create_message(target, arg,
                          data[TARGET][ARGUMENTS][i + TARGET], 2, 0, 0,
                          0, this_player(), 0) :
           create_message(target, arg,data[TARGET][ARGUMENTS][i + REST],
                          1, 0, 0, 0,this_player(), 0)) +
          "Others: " + create_message(target, arg,
                                      data[TARGET][ARGUMENTS][i + REST],
                                      1, 0, 0, 0, this_player(), 0);
      }
    }
  }
  return this_player()->convert_message(ret);
}
void do_force(mixed *arr) {
  string cmd;
  cmd = explode(arr[1], " ")[0];
  if (soul_command_names[cmd] &&
      !arr[0]->query_property("dead") &&
      userp(arr[0]))
    arr[0]->eventForce(arr[1]);
}
int query_pcache_size() {
  return sizeof(keys(pattern_cache));
}
int query_scache_size() {
  return sizeof(keys(soul_cache));
}
mixed *stats() {
  return ({ ({ "souls read", scache_reads, }),
              ({ "soul cache hit percent",
                   (scache_hits * 100) / scache_reads, }),
              ({ "souls in cache", sizeof(keys(soul_cache)), }),
              ({ "patterns read", pcache_reads, }),
              ({ "pattern cache hit percent",
                   (pcache_hits * 100) / pcache_reads, }),
              ({ "patterns in cache", sizeof(keys(pattern_cache)) - 1, }), });
}

==================================================
FILE: handlers/newbiehelpers.c
==================================================

#include <playerinfo.h>
#include <player_handler.h>
#include <mail.h>
#define PI_TYPE "misc"
#define SAVE_FILE "/save/newbiehelpers"
#define TO this_object()
#define TP this_player()
private mapping admin;
private mapping helpers;
private mapping applicants;
private int minimum_apply_age, minimum_vouch_age;
protected void log_message( string message );
protected void load_file();
protected void save_file();
void create() {
    admin = ([ ]);
    helpers = ([ ]);
    applicants = ([ ]);
    minimum_apply_age = 0;
    minimum_vouch_age = 0;
    load_file();
}
string query_list( object lister ) {
    string list_mess, person;
    if( !sizeof( admin ) ) {
        list_mess = "There are no newbie helpers admin at present.\n";
    }
    else {
        list_mess = "Current newbie helpers admin:\n";
        foreach( person in keys(admin) ) {
            list_mess += "    $C$" + person + "\n";
        }
    }
    list_mess += "\n";
    if( !sizeof( helpers ) ) {
        list_mess += "There are no newbie helpers at present.\n";
    }
    else {
        list_mess += "Current newbie helpers:\n";
        foreach( person in keys(helpers) ) {
            list_mess += "    $C$" + person + "\n";
        }
    }
    if( admin[lister->query_name()] ) {
        list_mess += "\n";
        if( !sizeof( applicants ) ) {
            list_mess += "There are no outstanding newbie helper "
                "applications at present.\n";
        }
        else {
            list_mess += "Current applications to newbie helpers:\n";
            foreach( person in keys(applicants) ) {
                list_mess += "    $C$" + person + "\n";
            }
        }
    }
    return list_mess;
}
private string helper_info( string name, object tp ) {
    string helper_mess, *vouches;
    helper_mess = "Details for $C$" + name + ":\n";
    helper_mess += "    Hired by $C$" + helpers[name]["employer"] +
        ", " + ctime(helpers[name]["time"]) + ".\n";
    if( helpers[name] ) {
        vouches = helpers[name]["vouches"];
        if( !vouches || !sizeof(vouches) ) {
            helper_mess += "    No vouches.\n";
        }
        else {
            helper_mess += "    Vouches were: " +
                query_multiple_short( map( vouches, (: "$C$" + $1 :) ) ) +
                ".\n";
        }
        if( !helpers[name]["guild"] || helpers[name]["guild"] == "unknown" ) {
            helper_mess += "    Guild: Unknown.\n";
        }
        else {
            helper_mess += "    Guild: " + helpers[name]["guild"] +
                ".\n";
        }
        if( !helpers[name]["nationality"] ||
            helpers[name]["nationality"] == "unknown" ) {
            helper_mess += "    Nationality: Unknown.\n";
        }
        else {
            helper_mess += "    Nationality: " + helpers[name]["nationality"]
                + ".\n";
        }
    }
    if( admin[name] ) {
        helper_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
    return helper_mess;
}
private string applicant_info( string name, object tp ) {
    string app_mess, voucher;
    mapping vouches;
    app_mess = "Details for $C$" + name + ":\n";
    app_mess += "    Applied: " +
        ctime(applicants[name]["time"]) + ".\n";
    app_mess += "    Age: " + query_time_string(applicants[name]["age"],-1) +
        ".\n";
    app_mess += "    Guild: " + applicants[name]["guild"] + ".\n";
    app_mess += "    Nationality: " + applicants[name]["nationality"] + ".\n";
    vouches = applicants[name]["vouches"];
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        app_mess += "    Vouches:\n";
        foreach( voucher in keys(vouches) ) {
            app_mess += "        $C$" + voucher + " (" +
                query_time_string(
                    applicants[name]["vouches"][voucher]["age"], -1
                ) + " old)\n";
        }
    }
    app_mess += "\n";
    app_mess += "    $C$" + name + "'s application:$I$8=\n\n";
    app_mess += applicants[name]["statement"] + "$I$0=\n\n";
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        foreach( voucher in keys(vouches) ) {
            app_mess += "    Vouch by $C$" + voucher + " made " +
                ctime(applicants[name]["vouches"][voucher]["time"]) +
                ":$I$8=\n\n";
            app_mess += applicants[name]["vouches"][voucher]["statement"] +
                "$I$0=\n\n";
        }
    }
    if( admin[name] ) {
        app_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
    return app_mess;
}
string query_check_player( object checker, string player ) {
    if( !helpers[player] && !admin[player] && !applicants[player] ) {
        return "$C$" + player + " is not registered with the newbie "
            "helpers handler.\n";
    }
    if( !admin[checker->query_name()] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }
    TP->add_succeeded_mess(TO, "", ({ }) );
    if( helpers[player] ) {
        return helper_info( player, TP );
    }
    if( applicants[player] ) {
        return applicant_info( player, TP );
    }
    return "$C$" + player + " is just an admin.\n";
}
int add_helper( object adder, string player ) {
    string *player_vouches, player_guild, player_nationality, name;
    name = adder->query_name();
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;
    }
    if( !PLAYER_HANDLER->test_user(player) ) {
        tell_object( TP, "There is no player $C$" + player + "!\n" );
        return 0;
    }
    if( helpers[player] ) {
        tell_object( TP, "$C$" + player + " is already a newbie "
            "helper.\n" );
        return 0;
    }
    if( applicants[player] ) {
        player_vouches = keys( applicants[player]["vouches"] );
        player_guild = applicants[player]["guild"];
        player_nationality = applicants[player]["nationality"];
        map_delete( applicants, player );
            AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
                "application", "", "Hello,\n\nI am pleased to inform you "
                "that your newbie helpers application was successful, and "
                "that you have now been hired as a newbie helper.  This was "
                "an automatic mail.\n\n$C$" + name, 0, 0);
    }
    else {
        player_vouches = ({ });
        player_guild = "unknown";
        player_nationality = "unknown";
    }
    helpers[player] = ([ ]);
    helpers[player]["time"] = time();
    helpers[player]["employer"] = name;
    helpers[player]["vouches"] = player_vouches;
    helpers[player]["guild"] = player_guild;
    helpers[player]["nationality"] = player_nationality;
    save_file();
    log_message( player + " added as a helper by " + name );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Added as a newbiehelper.", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
    return 1;
}
string remove_helper( object remover, string player, string reason ) {
    string name;
    name = remover->query_name();
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;
    }
    if( !helpers[player] ) {
        return "$C$" + player + " is not a newbie helper.\n";
    }
    map_delete( helpers, player );
    save_file();
    log_message( player + " removed as a helper by " + name + ", reason: " +
        reason );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Removed as a newbiehelper (" + reason + ").", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
    return "You remove $C$" + player + "'s helper status.\n";
}
void submit_vouch(string statement, mixed args) {
    string name, player;
    object voucher;
    voucher = args[0];
    player = args[1];
    name = voucher->query_name();
    applicants[player]["vouches"][name] = ([ ]);
    applicants[player]["vouches"][name]["time"] = time();
    applicants[player]["vouches"][name]["age"] = -voucher->query_time_on();
    applicants[player]["vouches"][name]["statement"] = statement;
    save_file();
    log_message( name + " submits a vouch for " + player );
}
string no_vouch_reason( object voucher, string applicant ) {
    string name;
    name = voucher->query_name();
    if( !applicants[applicant] ) {
        return "$C$" + applicant + " isn't applying to be a newbie helper, "
            "so you can't vouch for them.\n";
    }
    if( applicants[applicant]["vouches"][name] ) {
        return "You already have already vouched for $C$" + applicant + " on "
            "this application, you cannot vouch again.\n";
    }
    if( applicant == name ) {
        return "You cannot vouch for yourself!\n";
    }
    if( -voucher->query_time_on() < minimum_vouch_age ) {
        return "You cannot vouch for $C$ " + applicant + " as you are too "
            "young to vouch.  You need to be " +
            query_time_string( minimum_vouch_age, -1 ) + " old before you "
            "can vouch on people's applications to be a newbie helper.\n";
    }
    return 0;
}
void submit_application(string statement, object player) {
    string name;
    name = player->query_name();
    applicants[name] = ([ ]);
    applicants[name]["time"] = time();
    applicants[name]["age"] = -player->query_time_on();
    applicants[name]["statement"] = statement;
    applicants[name]["vouches"] = ([ ]);
    applicants[name]["guild"] =
        (load_object(player->query_guild_ob()))->query_short();
    if( player->query_nationality() ) {
        applicants[name]["nationality"] = "$C$" +
            (load_object(player->query_nationality()))->query_name();
        }
    else {
        applicants[name]["nationality"] = "unknown";
    }
    save_file();
    log_message( name + " submits an application to newbiehelpers" );
}
string no_apply_reason( object player ) {
    string name;
    name = player->query_name();
    if( helpers[name] ) {
        return "You are already a newbie helper, why are you applying "
            "again?\n";
    }
    if( applicants[name] ) {
        return "You already have a newbie helper application open, you "
            "should wait to hear back about it.\n";
    }
    if( -player->query_time_on() < minimum_apply_age ) {
        return "You cannot apply to be a newbie helper as you are too "
            "young.  You need to be " +
            query_time_string( minimum_apply_age, -1 ) + " before you can "
            "apply to be a newbie helper.\n";
    }
    return 0;
}
void reject_application( object rejecter, string player, string reason,
    string mail ) {
    string name;
    name = rejecter->query_name();
    if( !admin[name] ) {
        return;
    }
    if( !applicants[player] ) {
        return;
    }
    AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
        "application", "", mail, 0, 0);
    map_delete( applicants, player );
    save_file();
    log_message( name + " rejects " + player + "'s application, reason: " +
        reason );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Rejected as a newbiehelper (" + reason + ").", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
}
string no_reject_reason( object rejecter, string player ) {
    string name;
    name = rejecter->query_name();
    if( !admin[name] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }
    if( !applicants[player] ) {
        return "$C$" + player + " isn't applying to be a newbie helper, so "
            "you can't reject them.\n";
    }
    return 0;
}
int query_helper( string name ) {
    if( helpers[name] ) {
        return 1;
    }
    else {
        return 0;
    }
}
int add_admin( string name ) {
    if( !admin[TP->query_name()] ) {
        return 0;
    }
    if( !admin[name] ) {
        admin[name] = 1;
        save_file();
        log_message( name + " added as admin by " + TP->query_name() );
        return 1;
    }
    else {
        return 0;
    }
}
int remove_admin( string name ) {
    if( !admin[TP->query_name()] ) {
        return 0;
    }
    if( !admin[name] ) {
        return 0;
    }
    else {
        map_delete(admin, name);
        save_file();
        log_message( name + " removed from admin by " + TP->query_name() );
        return 1;
    }
}
int query_admin( string name ) {
    if( admin[name] ) {
        return 1;
    }
    else {
        return 0;
    }
}
int query_can_chat( object who ) {
    if( query_helper( who->query_name() ) ||
        query_admin( who->query_name() ) ||
        who->query_creator() ) {
        return 1;
    }
    return 0;
}
string query_name() { return "Newbiehelpers Handler"; }
protected void log_message( string message ) {
    log_file("/log/NEWBIEHELPERS", ctime(time()) + ": " + message + "\n");
}
protected void save_file() {
    unguarded( (: save_object, SAVE_FILE, 1 :) );
}
protected void load_file() {
    if (file_size(SAVE_FILE + ".o") > 0)
        unguarded( (: restore_object, SAVE_FILE, 1 :) );
}

==================================================
FILE: handlers/news_handler.c
==================================================

#include <board.h>
#include <login_handler.h>
#define BOARD_NAME "announcements"
#define DELAY_TIME 30
int has_unread_announcements( string player ) {
    mapping news_rc;
    mixed subjects;
    news_rc = BOARD_HAND->query_newsrc( player );
    if ( !news_rc ) {
        news_rc = ([ ]);
    }
    subjects = BOARD_HAND->get_subjects( BOARD_NAME );
    if ( !sizeof( subjects ) ) {
        return 0;
    }
    return subjects[ <1 ][ B_TIME ] > news_rc[ BOARD_NAME ];
}
void show_message( mixed person ) {
    object player;
    if ( stringp( person ) ) {
        player = find_player( person );
    }
    else {
        player = person;
    }
    if ( !player ) {
        return;
    }
    if ( has_unread_announcements( player->query_name() ) ) {
        tell_object( player, "\nThere are %^YELLOW%^NEW%^RESET%^ "
            "announcements!  You can read them with \"news\".\n\n" );
    }
}
void login_event(mixed person, string type) {
    if ( type == LOGIN || type == RECONNECT ) {
        if ( objectp( person ) ) {
            person = person->query_name();
        }
        call_out( (: show_message :), DELAY_TIME, person );
    }
}
void broadcast_announcement() {
    foreach( object user in users() ) {
        if ( interactive( user ) ) {
            show_message( user );
        }
    }
}

==================================================
FILE: handlers/newspaper.c
==================================================

#include <room/newspaper.h>
#include <nroff.h>
#include <autodoc.h>
#include <login_handler.h>
#define SAVE_DIR "/save/newspaper/"
class edition {
   int date_published;
   class article* articles;
   class advert* adverts;
   string headline;
   int num_sold;
   int num_web_hits;
   int total_revenue;
}
class paper {
   class edition* published_editions;
   string dir_name;
   string long;
   string description;
   string office;
   int paper_cost;
   string language;
}
private mapping _papers;
private mapping _areas;
private mapping _xp;
private mapping _inform;
void load_me();
void save_me();
void create() {
   _papers = ([ ]);
   _areas = ([ ]);
   _xp = ([ ]);
   _inform = ([ ]);
   seteuid(getuid());
   load_me();
   if (!_inform) {
      _inform = ([ ]);
   }
}
int is_paper(string paper) {
   return classp(_papers[paper]);
}
void add_paper(string name, string long, string desc, string office,
    string language) {
   if (is_paper(name)) {
      return ;
   }
   _papers[name] = new(class paper);
   _papers[name]->published_editions = ({ });
   _papers[name]->dir_name = replace_string(lower_case(name), " ", "_");
   _papers[name]->long = long;
   _papers[name]->description = desc;
   _papers[name]->office = office;
   _papers[name]->paper_cost = 5 * 4;
   _papers[name]->language = language;
   save_me();
}
string* query_all_papers() {
   return keys(_papers);
}
int query_current_edition_num(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return sizeof(_papers[paper]->published_editions) + 1;
}
int query_last_edition_num(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return sizeof(_papers[paper]->published_editions);
}
int is_valid_edition(string paper, int edition) {
   if (!is_paper(paper)) {
      return 0;
   }
   if (edition > 0 && edition <= sizeof(_papers[paper]->published_editions)) {
      return 1;
   }
   return 0;
}
int query_edition_date(string paper, int edition) {
   if (!is_paper(paper)) {
      return 0;
   }
   if (!is_valid_edition(paper, edition)) {
      return 0;
   }
   return _papers[paper]->published_editions[edition - 1]->date_published;
}
class article* query_edition_articles(string paper, int edition) {
   if (!is_paper(paper)) {
      return ({ });
   }
   if (!is_valid_edition(paper, edition)) {
      return ({ });
   }
   return copy(_papers[paper]->published_editions[edition - 1]->articles);
}
class advert* query_edition_adverts(string paper, int edition) {
   if (!is_paper(paper)) {
      return ({ });
   }
   if (!is_valid_edition(paper, edition)) {
      return ({ });
   }
   return copy(_papers[paper]->published_editions[edition - 1]->adverts);
}
string query_paper_office(string paper) {
   if (!is_paper(paper)) {
      return  0;
   }
   return _papers[paper]->office;
}
void set_paper_office(string paper, string office) {
   if (!is_paper(paper)) {
      return  0;
   }
    _papers[paper]->office = office;
   save_me();
}
string query_paper_headline(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  "No news is good news.";
   }
   return _papers[paper]->published_editions[edition - 1]->headline;
}
void set_paper_headline(string paper, int edition, string headline) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }
   _papers[paper]->published_editions[edition - 1]->headline = headline;
   save_me();
}
int query_edition_revenue(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }
   return _papers[paper]->published_editions[edition - 1]->total_revenue;
}
void add_edition_revenue(string paper, int edition, int revenue) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }
   _papers[paper]->published_editions[edition - 1]->total_revenue += revenue;
   save_me();
}
void add_edition_web_hit(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  ;
   }
   _papers[paper]->published_editions[edition - 1]->num_web_hits++;
   _papers[paper]->published_editions[edition - 1]->total_revenue += NEWSPAPER_WEB_HIT_REVENUE;
   save_me();
}
void add_edition_paper_sold(string paper, int edition, int cost) {
   if (!is_valid_edition(paper, edition)) {
tell_creator("pinkfish", "Not valid edition %O %O\n", paper, previous_object());
      return  ;
   }
tell_creator("pinkfish", "Updating num sold %O %O\n", paper, edition);
   _papers[paper]->published_editions[edition - 1]->num_sold++;
   _papers[paper]->published_editions[edition - 1]->total_revenue += cost;
   save_me();
}
int query_edition_num_sold(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }
   return _papers[paper]->published_editions[edition - 1]->num_sold;
}
int query_edition_num_web_hits(string paper, int edition) {
   if (!is_valid_edition(paper, edition)) {
      return  0;
   }
   return _papers[paper]->published_editions[edition - 1]->num_web_hits;
}
int is_paper_area(string area) {
   return pointerp(_areas[area]);
}
void add_paper_area(string area) {
   if (is_paper_area(area)) {
      return ;
   }
   _areas[area] = ({ });
}
void add_paper_to_area(string paper, string area) {
   if (!is_paper(paper) || !is_paper_area(area)) {
      return ;
   }
   _areas[area] += ({ paper });
   save_me();
}
string* query_papers_in_area(string area) {
   if (_areas[area]) {
      return _areas[area];
   }
   return ({ });
}
void set_article_text(class article art, string text) {
   unguarded( (:
      write_file(SAVE_DIR + $(art->file_name), save_variable(({ $(art), $(text) })), 1) :) );
}
void add_newspaper_inform(string paper, string ob) {
   if (!_inform[paper]) {
      _inform[paper] = ({ });
   }
   if (!stringp(ob)) {
      return ;
   }
   if (member_array(ob, _inform[paper]) != -1) {
      return ;
   }
   _inform[paper] += ({ ob });
   save_me();
}
void remove_newspaper_inform(string paper, string ob) {
   if (!_inform[paper]) {
      return ;
   }
   _inform[paper] -= ({ ob });
   save_me();
}
string* query_newspaper_informs(string paper) {
   if (!_inform[paper]) {
      return ({ });
   }
   return _inform[paper];
}
string query_article_text(class article art) {
   string str;
   string* bits;
   str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      return bits[1];
   }
   return "Error reading the article text.";
}
string query_article_text_html(class article art) {
   string str;
   string* bits;
   str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      switch (art->type & NEWSPAPER_ARTICLE_TYPE_MASK) {
      case NEWSPAPER_ARTICLE_TYPE_PLAIN :
         bits[1] = replace_string(bits[1], "\n\n", "<p>");
         bits[1] = replace_string(bits[1], "\n", "<br>");
         return bits[1];
      case NEWSPAPER_ARTICLE_TYPE_HTML :
         bits[1] = replace_string(bits[1], "<pre>", "</font><pre>");
         bits[1] = replace_string(bits[1], "</pre>",
                                  "</pre>\n<font face=\"helvetica,arial\">");
         return bits[1];
      }
      return bits[1];
   }
   return "Error reading the article text.";
}
string convert_html(string input) {
   return AUTODOC_NROFF->convert_html(input);
}
string query_article_text_plain(class article art) {
   string str;
   string fluff;
   string* bits;
   switch (art->type & NEWSPAPER_ARTICLE_TYPE_MASK) {
   case NEWSPAPER_ARTICLE_TYPE_SECTION :
      return "";
   case NEWSPAPER_ARTICLE_TYPE_PLAIN :
      str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
      if (str) {
         bits = restore_variable(str);
         return bits[1];
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_HTML :
      fluff = unguarded( (: NROFF_HAND->cat_file(SAVE_DIR + $(art->file_name) + ".nroff", 1) :) );
      if (!fluff) {
         str = unguarded( (: read_file(SAVE_DIR + $(art->file_name)) :) );
         if (str) {
            bits = restore_variable(str);
            bits[1] = convert_html(bits[1]);
            unguarded( (: write_file(SAVE_DIR + $(art->file_name) + ".proc",
                                     $(bits[1]), 1) :) );
            unguarded( (: NROFF_HAND->create_nroff(SAVE_DIR + $(art->file_name) + ".proc",
                                SAVE_DIR + $(art->file_name) + ".nroff") :) );
            str = unguarded( (: NROFF_HAND->cat_file(SAVE_DIR + $(art->file_name) + ".nroff") :) );
            return str;
         }
      } else {
         return fluff;
      }
   }
   return "Error reading the article text.";
}
string query_paper_long(string paper) {
   if (!is_paper(paper)) {
      return "This is a very transperant and unhappy newspaper.\n";
   }
   return _papers[paper]->long;
}
void set_paper_description(string paper, string description) {
   if (!is_paper(paper)) {
      return ;
   }
   _papers[paper]->description = description;
   save_me();
}
string query_paper_description(string paper) {
   if (!is_paper(paper)) {
      return "This is a very transperant and unhappy newspaper.\n";
   }
   return _papers[paper]->description;
}
void set_paper_long(string paper, string long) {
   if (!is_paper(paper)) {
      return ;
   }
   _papers[paper]->long = long;
   save_me();
}
void set_paper_cost(string paper, int cost) {
   if (!is_paper(paper)) {
      return ;
   }
   _papers[paper]->paper_cost = cost;
   save_me();
}
int query_paper_cost(string paper) {
   if (!is_paper(paper)) {
      return 0;
   }
   return _papers[paper]->paper_cost;
}
int publish_paper(string paper,
                  string headline,
                  class article* articles,
                  string* text,
                  class advert* adds,
                  string* editors) {
   string paper_dir;
   string tmp;
   class paper fluff;
   class article article;
   class edition womble;
   int i;
   int edition;
   int total_xp;
   int type;
   if (!is_paper(paper)) {
      return 0;
   }
   fluff = _papers[paper];
   edition = sizeof(fluff->published_editions) + 1;
   paper_dir = SAVE_DIR + fluff->dir_name;
   unguarded( (: mkdir($(paper_dir)) :));
   paper_dir += "/" + edition;
   unguarded( (: mkdir($(paper_dir)) :));
   foreach (article in articles) {
      article->file_name = fluff->dir_name + "/" + edition + "/" +
                           article->file_name;
      type = article->type & NEWSPAPER_ARTICLE_TYPE_MASK;
      if ((type == NEWSPAPER_ARTICLE_TYPE_PLAIN ||
           type == NEWSPAPER_ARTICLE_TYPE_HTML) &&
           !(article->type & NEWSPAPER_ARTICLE_NO_XP_FLAG)) {
         _xp[lower_case(article->author)] += NEWSPAPER_XP_PER_ARTICLE;
         total_xp += NEWSPAPER_XP_PER_ARTICLE;
      }
   }
   total_xp = total_xp * 10 / 100;
   total_xp += NEWSPAPER_XP_EDITOR;
   if (sizeof(editors)) {
      foreach (tmp in editors) {
         _xp[tmp] += total_xp / sizeof(editors);
      }
   }
   for (i = 0; i < sizeof(articles); i++) {
      set_article_text(articles[i], text[i]);
   }
   womble = new(class edition);
   womble->articles = articles;
   womble->adverts = adds;
   womble->date_published = time();
   womble->headline = headline;
   fluff->published_editions += ({ womble });
   save_me();
   foreach (tmp in query_newspaper_informs(paper)) {
      call_out((: $1->event_publish_paper($2) :), 2, tmp, paper);
   }
   return 1;
}
void load_me() {
   string paper;
   class paper fluff;
   class paper rabbit;
   unguarded( (: restore_object(SAVE_DIR + "main", 1) :) );
   foreach (paper, fluff in _papers) {
      if (sizeof(fluff) == 6) {
         rabbit = new(class paper);
         rabbit->published_editions = fluff->published_editions;
         rabbit->dir_name = fluff->dir_name;
         rabbit->long = fluff->long;
         rabbit->description = fluff->description;
         rabbit->office = fluff->office;
         rabbit->paper_cost = 5 * 4;
         rabbit->language = "general";
         _papers[paper] = rabbit;
         fluff = rabbit;
      } else if( sizeof( fluff ) == 7 ) {
         rabbit = new(class paper);
         rabbit->published_editions = fluff->published_editions;
         rabbit->dir_name = fluff->dir_name;
         rabbit->long = fluff->long;
         rabbit->description = fluff->description;
         rabbit->office = fluff->office;
         rabbit->paper_cost = 5 * 4;
         rabbit->language = fluff->language;
         _papers[paper] = rabbit;
         fluff = rabbit;
      }
   }
}
void save_me() {
   unguarded( (: save_object(SAVE_DIR + "main") :) );
}
mixed* stats() {
   string paper;
   string person;
   class paper data;
   mixed* ret;
   int last;
   int xp;
   ret = ({ });
   foreach (paper, data in _papers) {
      last = query_last_edition_num(paper);
      ret += ({ ({ paper + ": office", data->office }),
                ({ paper + ": dir name", data->dir_name }),
                ({ paper + ": last issue", last }),
                ({ paper + ": current issue", query_current_edition_num(paper) }),
                ({ paper + ": num sold", query_edition_num_sold(paper, last) }),
                ({ paper + ": num web hits", query_edition_num_web_hits(paper, last) }),
                ({ paper + ": revenue", query_edition_revenue(paper, last) }),
              });
   }
   foreach (person, xp in _xp) {
      ret += ({ ({ person + ": xp", xp }) });
   }
   return ret;
}
void player_login_check(string player, string bing) {
   object play;
   int xp;
   if (bing != LOGIN) {
      return ;
   }
   xp = _xp[player];
   if (xp) {
      play = find_player(player);
      play->adjust_xp(xp);
      map_delete(_xp, player);
      save_me();
      tell_object(play, "%^YELLOW%^You feel like the experience of writing "
                        "an article has made you a better person.\n%^RESET%^");
   }
}
void set_language_for( string paper, string language ) {
    if( is_paper( paper ) )
        _papers[ paper ]->language = language;
}
string query_language_for( string paper ) {
    if( is_paper( paper ) ) {
        if( !undefinedp( _papers[ paper ]->language ) )
            return _papers[ paper ]->language;
        return "general";
    }
    return 0;
}

==================================================
FILE: handlers/nmoney_handler.c
==================================================

#include <money.h>
#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#undef USE_VAULT
mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_all_values() { return copy( values ); }
string *query_all_places() {
   return keys(values);
}
mixed *query_values() { return copy( values[ "default" ] ); }
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
}
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;
   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
}
void add_type( string where, string type, int value ) {
   int i;
   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
}
void remove_type( string where, string type ) {
   int i;
   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
}
mapping query_details() { return copy( details ); }
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
}
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
}
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
}
mapping query_symbols() { return copy( symbols ); }
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
}
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
}
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
}
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
}
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
}
string *query_aliases_for( string type ) {
   string *ret;
   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
}
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
}
string *query_adjectives_for( string type ) {
   string *ret;
   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   return ret;
}
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
}
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
}
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
}
string query_main_plural_for( string type ) {
   string *type_exp;
   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
}
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
}
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
}
string money_string( mixed mon_array ) {
   int i;
   string ret;
   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 );
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
}
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
}
varargs string money_value_string( int value, string where ) {
   string symboliser;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
}
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;
   if (!where) {
      where = "default";
   }
   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = values[ where ];
   if (!value && stuff) {
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
}
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
}
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;
   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
}
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }
      value *= query_value( type, where );
   }
   if (!value) {
      return 0;
   }
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   if ( value > total ) {
      return 0;
   }
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];
   ret = ({ });
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }
   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }
   return ({ ret, value, mon_array });
}
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;
   if (!type) {
     return 0;
   }
   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
}
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;
   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }
      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }
   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }
   if (sizeof(change_array) == 0) {
      return 0;
   }
#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;
}
varargs object make_new_amount( int value, string where ) {
   object money;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
}
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   m_array = (mixed *)money->query_money_array();
   money->dest_me();
   return filter_legal_money_array(m_array, where);
}
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   int i;
   object good, no_good;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });
   if (sizeof(m_array) == 0) {
      return ({ 0, 0 });
   }
   if (!(poss_values = values[where])) {
      poss_values = ({ });
   }
   if (!where || where == "") {
     where = "default";
   }
   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }
   if (sizeof(good_array) == 0) {
      good = 0;
   }
   else  {
#ifdef USE_VAULT
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(good_array);
   }
   if (sizeof(no_good_array) == 0) {
      no_good = 0;
   }
   else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(no_good_array);
   }
   return ({ good, no_good });
}
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;
   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;
}
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[0]) < m_array[1]) {
            return NO_MATCH;
         }
      }
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      m_array = ({ });
      foreach (thing in things)  {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#endif
      }
   }
   monies = filter_legal_money_array(m_array, place);
   if (monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#endif
   }
   else
      m_array = ({ });
   if (monies[0])  {
      m_array2 = copy(monies[0]->query_money_array());
      for (i = 0; i < sizeof(m_array2); i += 2)
         m_array2[i + 1] = -m_array2[i + 1];
      merge_money_arrays(m_array, m_array2);
      this_player()->adjust_money(m_array);
      return monies[0];
   }
   else return NO_LEGAL;
}
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;
   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
}
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
  tmp = values(query_all_values());
  foreach( elem in tmp ){
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}
string query_origin_of( string type ){
  string elem, *places;
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  places = query_all_places();
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  types = query_valid_types();
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
int smallest_value_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r];
}
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;
   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
}

==================================================
FILE: handlers/non_refuelling_lantern.c
==================================================

#include <fuel_handler.h>
inherit "/std/object";
#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
int  fuel_left;
int  is_lit;
void create(){
  ::create();
}
string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
  return ::short( 0 );
}
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
}
int do_dowse() {
   return do_extinguish();
}
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}
void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}
void out_of_fuel() {
   object env;
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else
      say( poss_short() +" burns out.\n" );
}
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
   }
}
string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
  return ::pretty_plural(thing);
}
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
}
void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
}
int query_fuel_left() {
    return fuel_left;
}
void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }
    fuel_left = i;
}
int query_max_fuel() {
    return MAX_FUEL;
}

==================================================
FILE: handlers/nquest_handler.c
==================================================

#include <player_handler.h>
#define LIBRARY "/obj/handlers/nlibrary"
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"
inherit "/std/object";
private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }
void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
}
int query_total_qp() { return total_qp; }
int add_quest( string name, int level, string title, string story ) {
   string log_name;
   if ( member_array( name, quest_name ) != -1 )
      return 0;
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 });
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
}
int change_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}
int query_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}
int query_quest_level(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
}
int set_quest_level(string name, int level) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
}
string query_quest_story(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
}
int set_quest_story(string name, string story) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
}
string query_quest_title(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
}
int set_quest_title(string name, string title) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
}
int query_quest_times( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
}
mixed query_quest_done( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
}
int delete_quest(string name) {
   int temp;
   string log_name;
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
}
string *query_quest_names() {
  return quest_name + ({ });
}
int *query_quest_levels() {
  return quest_level + ({ });
}
string *query_quest_titles() {
  return quest_title + ({ });
}
string *query_quest_stories() {
  return quest_story + ({ });
}
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;
   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
}
int query_player_fame(string name){
   int playerqp, rank;
   if (!name){
      return 0;
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   playerqp = (int)LIBRARY->query_quest_points(name);
   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
}
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
}
string *query_player_story(string name){
   string *quests;
   string *story;
   int i;
   story = ({ });
   if (!name){
      return ({ });
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
}
void print_some_stats()  {
   int i;
   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
}
