# Total Tokens: 21356
# Total Files Merged: 23
# Total Characters: 71253

.c
==================================================

#include <player.h>
#include <weather.h>
#include <dirs.h>
#include <error_handler.h>
#include <db.h>
#include <terrain_map.h>
inherit "/cmds/base";
#define TP this_player()
string weather_long(string str);
int check_exists(string file);
string look_around();
mixed cmd_string(string arg);
void finish_bug_summary(object player, int type, mixed data) {
   class error_complete summ;
   class error_complete* errors;
   string str;
   int pos;
   if (type != DB_SUCCESS) {
      return ;
   }
   errors = data;
   if (!sizeof(errors)) {
      tell_object(player, "No errors for this room.\n");
      return ;
   }
   str = "";
   str = sprintf("#<bug id>  ( <date> ) %5-s %4-s %-4s by %11-s %11-s\n",
                 "Status", "Type", "Cat", "Reporter", "Assigned");
   foreach (summ in errors) {
      pos = strsrch(summ->details->report, "\n");
      if (pos < 0 || pos > player->query_cols() - 5) {
         pos = player->query_cols() - 5;
      } else {
         pos --;
      }
      str += sprintf("$I$3=#%d (%s) %5-s %4-s %-4s by %11-s %11-s\n%s\n",
                     summ->details->summary->id,
                     ctime(summ->details->summary->entry_date)[4..15],
                     summ->details->summary->status[0..4],
                     summ->details->summary->type,
                     summ->details->summary->category[0..3],
                     summ->details->summary->reporter,
                     summ->details->summary->assigned_to,
                     summ->details->report[0..pos]);
   }
   tell_object(player, str);
}
void show_error_summary(object player, string* types) {
   class error_query query;
   if (!arrayp(types) || !sizeof(types)) {
      return ;
   }
   query = new(class error_query);
   query->file_name = file_name(environment(player));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   query->type = types;
   query->no_extra_details = 1;
   ERROR_HANDLER->do_query_multiple_bug_details(query, (: finish_bug_summary, player :));
}
int cmd_look_room()
{
   object room;
   int dark;
   string ret;
   int *coords;
   room = environment(TP);
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (TP->query_creator()) {
      coords = room->query_co_ord();
      if (sizeof(coords)) {
         ret = "  (" + coords[0] + "," + coords[1] + "," + coords[2] + ")";
      } else {
         ret = "  (unset)";
      }
      if (virtualp(room)) {
         write("%^CYAN%^" + file_name(room) + " [" +
                room->query_property("base path")  + "]" + ret + "%^RESET%^\n");
      } else {
         write("%^CYAN%^" + file_name(room) + ret + "%^RESET%^\n");
      }
   }
   if ((TP->query_creator() || TP->query_playtester()) &&
       TP->query_property(TERRAIN_MAP_IN_LOOK_PROP)) {
      ret = room->long_test(0, dark);
      if (ret) {
         write("$P$Look$P$" + ret);
      } else {
         write("$P$Look$P$" + (string) room->long(0, dark));
      }
   } else {
      write("$P$Look$P$" + (string) room->long(0, dark));
   }
   if (dark && TP->query_creator()) {
      write("%^YELLOW%^As a creator, you can see:%^RESET%^\n" +
            (string) room->long(0, 0));
   }
   if (TP->query_creator() && TP->query_property(PLAYER_SHOW_ERRORS_PROP)) {
      show_error_summary(this_player(), TP->query_property(PLAYER_SHOW_ERRORS_PROP));
   }
   return 1;
}
string query_look_thing(object thing,
                        object player,
                        int dark,
                        string verb,
                        string arg)
{
   string ret;
   object env;
   string other;
   string replaced;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   ret = "";
   if (living(thing)) {
      if (thing == player) {
         ret += "Looking at yourself again?  What a narcissist!\n";
      } else {
         tell_object(thing, "$one_short:" + file_name(player) +
                     "$ $V$0=looks,look$V$ at you.\n");
      }
   } else {
      env = environment(thing);
      while (env && !living(env)) {
         env = environment(env);
      }
   }
   if (env && env != player) {
      tell_object(env, player->the_short() + " " + verb + " "
                  "at your " + thing->pretty_short() + ".\n");
      other = thing->query_long(arg, dark);
      if (other) {
         replaced = thing->replace_long_dollars(player, other);
         if (replaced) {
            ret += replaced;
         }
         else {
            ret += other;
         }
      }
      other = thing->query_long_details(arg, dark, player);
      if (other) {
         ret += other;
      }
   } else {
      ret += thing->long(arg, dark);
   }
   return ret;
}
mixed cmd_object(object * obs,
                 string arg)
{
   object thing;
   object room;
   int dark;
   int retval;
   string ret;
   room = environment(TP);
   if (LENGTHEN[arg]) {
     arg = LENGTHEN[arg];
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   ret = "";
   foreach(thing in obs) {
      ret += query_look_thing(thing, this_player(), dark, "looks", arg);
   }
   if (ret != "") {
      write("$P$Look$P$" + ret);
      retval = 1;
   }
   if (room->query_exit(arg))
      cmd_string(arg);
   else {
      arg = (string) this_player()->find_abs(arg);
      if (room->query_exit(arg))
         cmd_string(arg);
   }
   return 1;
}
mixed cmd_string(string arg)
{
   object room;
   int dark;
   int retval;
   string ret;
   string other;
   string orig_arg;
   mixed *func;
   room = environment(TP);
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   switch (arg) {
   case "soul":
      write((string) "/obj/handlers/new_soul"->help_list());
      return 1;
   case "sun":
   case "moon":
   case "stars":
   case "weather":
   case "sky":
      write(weather_long(arg));
      return 1;
   case "around":
      write(look_around());
      return 1;
   }
   orig_arg = arg;
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (!room->query_exit(arg)) {
      arg = (string) this_player()->find_abs(arg);
   }
   if (room->query_exit(arg)) {
      int tmp_ret_val;
      room->set_destination(arg);
      other = (string) room->query_destination(arg);
      ret = room->query_look(arg);
      if (ret && ret != "") {
         write(ret + "\n");
         retval = 1;
         tmp_ret_val = 1;
      }
      func = room->query_look_func(arg);
      if (pointerp(func) && sizeof(func) >= 1 && func[0] && func[1]) {
         if (call_other(func[0], func[1], 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      } else if (functionp(func)) {
         if (evaluate(func, 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      }
      if (check_exists(other) && !tmp_ret_val) {
         object door;
         door = room->query_door_control(arg);
         if (room->query_door_open(arg) || door->query_transparent()) {
            other->force_load();
            dark = (int) TP->check_dark((int) other->query_light());
            ret = other->long(0, dark);
            this_player()->set_looked(find_object(other));
            write(ret);
            retval = 1;
         } else {
            add_failed_mess(door->the_short() +
                            " is closed and not transparent.\n");
            retval = 0;
         }
      }
   }
   return retval;
}
int check_exists(string file)
{
   int retval;
   if (objectp(find_object(file))) {
      return 1;
   }
   if (strsrch(file, ":")) {
      return 1;
   }
   if (file_size(file + ".c") > 0) {
      retval = 1;
   } else {
      retval = 0;
   }
   return retval;
}
string weather_long(string str)
{
   object env;
   string temp;
   string whandler;
   env = environment(TP);
   temp = (string) env->query_property("location");
   switch (temp) {
   case ("inside"):
      return "You are not outside.\n";
   }
   whandler = env->query_weather_handler() ;
   if ( ! whandler ) {
       whandler = WEATHER ;
   }
   if (str == "sun") {
      if (whandler->query_day(env)) {
         return "Ouch that hurts.\n";
      } else {
         return "The sun is not up, sorry.\n";
      }
   }
   if (str == "moon") {
      if (whandler->query_day(env)) {
         return "The moon is not up, try at night.\n";
      } else if ( (temp = whandler->query_moon_string(env)) ) {
         return temp;
      } else {
         return "The moon is not up at the moment, try again later.\n";
      }
   }
   if (str == "stars") {
       if (whandler->query_day(env)) {
           return "The stars are not out at the moment - try at night.\n" ;
       } else {
           if ( (temp = whandler->query_star_string(env)) ) {
               return temp ;
           } else {
               return "There aren't any visible stars right now.\n" ;
           }
       }
   }
   return "You look up at the sky.  " + whandler->weather_string(env) + ".\n";
}
string look_around()
{
   int i;
   int j;
   string prep;
   string room;
   string *parts;
   string *rooms;
   object place;
   object thing;
   object *contents;
   mixed *locations;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   place = environment(this_player());
   if (place->query_linked()) {
      rooms = (string *) place->query_rooms();
   } else {
      rooms = ({ });
   }
   locations = ({ });
   say((string) this_player()->one_short() + " $V$0=looks,look$V$ around.\n");
   foreach(room in rooms) {
      if (!find_object(room)) {
         continue;
      }
      if (this_player()->check_dark((int) room->query_light())) {
         continue;
      }
      contents = ({ });
      foreach(thing in all_inventory(find_object(room))) {
         if (living(thing) && thing->query_visible(this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         continue;
      }
      prep = (string) room->query_static_preposition();
      if (prep != "") {
         if (!stringp(prep)) {
            prep = sprintf("%O", prep);
         }
         prep += " ";
      }
      locations += ({ ({ contents, prep +
                         (string) this_player()->
                         convert_message((string) room->the_short())
                      }) });
   }
   if (!sizeof(locations)) {
      contents = ({ });
      if (this_player()->check_dark((int) place->query_light())) {
         return "You can't see well enough to look around here.\n";
      }
      foreach(thing in all_inventory(place)) {
         if (living(thing) && thing->query_visible(this_player()) &&
             (thing != this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         return "You do not see anyone else about.\n";
      }
      return "$C$" + query_multiple_short(contents) +
         " $V$0=is,are$V$ here.\n";
   }
   for (i = 0; i < sizeof(locations) - 1; i++) {
      for (j = i + 1; j < sizeof(locations); j++) {
         if (locations[i][1] == locations[j][1]) {
            locations[i][0] += locations[j][0];
            locations = delete(locations, j, 1);
            j--;
         }
      }
   }
   parts = ({ });
   for (i = 0; i < sizeof(locations); i++) {
      parts += ({ query_multiple_short(locations[i][0]) + " " +
                  locations[i][1] });
   }
   if (sizeof(parts) == 1) {
      return "You can see " + parts[0] + ".\n";
   }
   return "You can see " + query_multiple_short(parts) + ".\n";
}
mixed *query_patterns()
{
   return ({ "", (: cmd_look_room() :),
             "<string'direction'>", (: cmd_string($4[0]) :),
             "<indirect:object>", (: cmd_object($1, $4[0]) :),
             "at <indirect:object>", (: cmd_object($1, $4[0]) :),
             "in <indirect:object>", (: cmd_object($1, $4[0]) :),
             "inside <indirect:object>", (: cmd_object($1, $4[0]) :),
             "around", (: cmd_string("around") :) });
}

==================================================
FILE: living/learn.c
==================================================

#include <skills.h>
#include <tune.h>
#include <cmds/teach.h>
#include <command.h>
inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str, object *obs);
mixed cmd(string str, object *obs) {
  object *diff_lvl;
  object *no_xp;
  object *not_offer;
  object *ok;
  object *moved;
  object ob;
  int time;
  string skill;
  string cmd;
  string cmd_ob;
  string *bits;
  string levelstr;
  class teaching_skill womble;
  if (TP->query_property("dead")) {
    notify_fail("Your dead.  Your mind slips off the task and goes for "
                "a wander down memory lane.\n");
    return 0;
  }
  skill = str;
  bits = explode(implode(explode(skill, " "), "."), ".");
  skill = SKILL_OB->query_skill(bits);
  if (!skill) {
    ok = ({ });
    cmd = str;
    if (sizeof(CMD_D->GetPaths(cmd)) &&
        CMD_D->GetPaths(cmd)[0]) {
       cmd_ob = CMD_D->GetPaths(cmd)[0] + "/" + cmd;
       foreach (ob in obs) {
          bits = TP->query_respond_command(TEACH_COMMAND_TYPE, ob);
          if (pointerp(bits) && member_array(cmd, bits) != -1) {
             cmd_ob->teach_command(ob, this_player());
             ok += ({ ob });
             bits -= ({ cmd });
             if (sizeof(bits)) {
                TP->add_respond_command(TEACH_COMMAND_TYPE, ob, bits);
             } else {
                TP->remove_respond_command(TEACH_COMMAND_TYPE, ob);
             }
             event(environment(this_player()), "teach", "command", ob, this_player());
             break;
          }
       }
       if (sizeof(ok)) {
          add_succeeded_mess("$N learn$s " + cmd + " from $I.\n", ok);
          return 1;
       }
       add_failed_mess("The skill \"" + cmd + "\" is invalid, or $I "
                       "is not trying to teach you the \"" + cmd + "\" "
                       "command.\n");
    } else {
       add_failed_mess("The skill '" + cmd + "' is invalid.\n");
    }
    return 0;
  }
  moved = ok = not_offer = no_xp = diff_lvl = ({ });
  foreach (ob in obs) {
    womble = TP->query_respond_command(TEACH_SKILL_TYPE, ob);
    if (!womble) {
      not_offer += ({ ob });
      continue;
    }
    if (skill != womble->skill) {
      not_offer += ({ ob });
      continue;
    }
    if ((int)TP->query_xp() < womble->xp ||
        !womble->xp) {
      no_xp += ({ ob });
      continue;
    }
    if (TP->query_skill(womble->skill) != womble->lvl) {
      diff_lvl += ({ ob });
      TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
      continue;
    }
    if (sizeof(ok)) {
      continue;
    }
    if(womble->num == 1)
      levelstr = "level";
    else
      levelstr = "levels";
    if (environment(this_player()) != womble->room) {
       moved += ({ ob });
       TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
       continue;
    }
    if (ob != TP) {
      write(ob->short()+" starts to teach you " + womble->num + " " +
            levelstr + " of " + womble->skill + " for " + womble->xp +
            " xp.\n");
      tell_object(ob, "You start to teach " + TP->short() +
                  " " + womble->num + " " + levelstr +
                  " of " + womble->skill +
                  " for " + womble->xp + " xp.\n");
      say(ob->short()+" starts to teach "+TP->short()+" some skills.\n",
          ({ TP, ob }));
      ok += ({ ob });
    } else {
      write("You start to teach yourself " + womble->num + " " +
            levelstr + " in "+
            womble->skill + " for " + womble->xp + " xp.\n");
      say(TP->short()+" starts to teach " + TP->query_objective() +
          "self some skills.\n", ({ TP }));
    }
    time = womble->xp / TIME_DIV;
    if(time > 1000) {
      time = 1000;
    }
    TP->adjust_time_left(-time);
    womble->teacher = ob;
    womble->taught = TP;
    TP->set_interupt_command("stop_teaching_skills", file_name(this_object()),
                             womble);
    if (TP != ob) {
      ob->adjust_time_left(-time);
      ob->set_interupt_command("stop_teaching_skills", TP, womble);
    }
  }
  if (sizeof(not_offer)) {
    if(sizeof(not_offer) == 1) {
      if(not_offer[0] != this_player())
        write(capitalize(query_multiple_short(not_offer)) +
              " is not offering to teach you "+ skill+".\n");
      else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach yourself "+ skill+".\n");
    } else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach you "+ skill+".\n");
  }
  if (sizeof(moved)) {
    write("You appear to have moved away from the excellent teaching "
          "environment selected by "+
          query_multiple_short(moved)+".\n");
  }
  if (sizeof(no_xp)) {
    write("You do not have enough xp to learn "+skill+" from "+
          query_multiple_short(no_xp)+".\n");
  }
  if (sizeof(diff_lvl)) {
    write("You were a different level in "+skill+" when "+
          query_multiple_short(diff_lvl)+" offered to teach you.\n");
  }
  if (sizeof(ok)) {
    say(TP->short()+" learns some skills from "+query_multiple_short(ok)+
        ".\n", ok);
  }
  return 1;
}
void stop_teaching_skills(int time_left, class teaching_skill womble,
                          object us, object interupter, string cmd) {
   object ob;
   mixed *stuff;
   string levelstr;
   if (time_left > 0) {
      if (womble->teacher == us) {
         if (womble->teacher == womble->taught) {
            say(womble->taught->short() + " stops teaching " +
                womble->taught->query_objective() + "self some "
                "skills.\n");
         } else if (us == interupter) {
            ob = womble->teacher;
            tell_object(ob, womble->taught->short() + " interupts your "
                            "training.\n");
         } else {
            tell_object(us, interupter->short() + " interupts your "
                            "training.\n");
         }
         say(interupter->short() + " stops teaching some skills to " +
             womble->taught->short() + ".\n",
             ({ us, interupter }));
      }
      if (us == womble->teacher) {
         ob = womble->taught;
      } else {
         ob = womble->teacher;
      }
      if (ob) {
         stuff = ob->query_interupt_command();
         if (stuff) {
            if (stuff[0] == "stop_teaching_skills") {
               ob->interupt_command(us);
            }
         }
      }
      us->adjust_time_left(-((int)womble->taught->query_time_left()));
      us->set_interupt_command(0);
      return ;
   }
   if (interupter != us) {
      return ;
   }
   if (environment(womble->taught) != environment(womble->teacher) ||
       environment(womble->taught) != womble->room) {
      tell_object(us, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      tell_object(womble->teacher, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      return;
   }
   if(womble->taught->query_xp() < womble->xp) {
      write("Something has gone wrong. :(\n");
      return;
   }
   if (womble->taught != womble->teacher) {
      womble->teacher->adjust_xp(womble->xp / 10);
   }
   womble->taught->adjust_xp(-womble->xp);
   if(womble->num == 1)
     levelstr = "level";
   else
     levelstr = "levels";
   if(womble->taught->add_skill_level(womble->skill, womble->num, womble->xp))
     {
       if (us != womble->teacher) {
         tell_object(us, "You finish learning " + womble->num +
                     " " + levelstr + " of "
                     + womble->skill + " from " + womble->teacher->short() +
                     ".\n");
         tell_object(womble->teacher, womble->taught->short() + " finishes " +
                     "learning " + womble->num + " " + levelstr + " of "
                     + womble->skill + " from you.\n");
         say(us->short() + " finishes learning some skills "+
             "from "+ womble->teacher->short()+".\n",
             ({ us, womble->teacher }));
       } else {
         tell_object(us, "You finish teaching yourself " + womble->num +
                     " " + levelstr + " of " +
                     womble->skill + ".\n");
         say(us->short() + " finishes learning some skills "
             "from " + us->query_objective() + "self.\n",
             ({ us, womble->teacher }));
       }
     } else {
       tell_object(womble->taught, "Something went wrong learning " +
                   womble->skill + " from " + womble->teacher->query_short() +
                   ".\n");
     }
   womble->taught->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
}
mixed *query_patterns() {
   return ({ "<string'skill/command'> from <indirect:living>",
             (: cmd($4[0], $1) :) });
}

==================================================
FILE: living/lie.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("lie", "down", LYING);
}

==================================================
FILE: living/lo_se.c
==================================================

inherit "/cmds/base";
mixed cmd(object *obs, string str) {
  object *ok, ob;
  string s;
  if (str == "everyone")
    obs = this_player()->query_followers();
  if (!sizeof(obs)) {
    write("You are not being followed by anyone.\n");
    return 1;
  }
  ok = ({ });
  foreach (ob in obs)
    if (this_player()->remove_follower(ob))
      ok += ({ ob });
  if (!sizeof(ok)) {
    if (member_array(this_player(), obs) == -1)
      return notify_fail("You are not being followed by "+
                         query_multiple_short(obs)+".\n");
    else
      return notify_fail("You are not being followed by " +
                         query_multiple_short(obs - ({this_player()}) +
                                              ({"yourself"})) + ".\n");
  }
  write("You lose "+(s=query_multiple_short(ok))+".\n");
  say(this_player()->the_short()+" loses "+s+".\n", ok);
  foreach (ob in ok)
    tell_object(ob, this_player()->the_short() + " loses " +
                query_multiple_short((ok + ({ "you" })) - ({ ob }))+".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "everyone", (: cmd(0, "everyone") :),
            "<indirect:living>", (: cmd($1, 0) :) });
}

==================================================
FILE: living/lsay.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
#include <broadcaster.h>
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(string arg) {
  int *co_ords;
  int status;
  class message mess;
  if (!arg)  arg = "";
  mess = build_message("@loudly " + arg, 0, "say");
  status = say_it(mess);
  if(status && TP && environment(TP))  {
    co_ords = environment(TP)->query_co_ord();
    BROADCASTER->npc_shout_event(TP, mess->notify_mess, mess->text,
                                 mess->language, co_ords, 20);
  }
  return status;
}
mixed *query_pattern() {
   return ({ "<string'message'>", (: cmd($4[0]) :) });
}

==================================================
FILE: living/meditate.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("meditate", "", MEDITATING);
}

==================================================
FILE: living/offer.c
==================================================

#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int offer_sale(object *to_sell, object *sell_to, string amt, int each) {
   int value;
   int num;
   string *fluff;
   string place;
   string *gumboot;
   object *fail;
   class offer_sale wombat;
   fluff = MONEY_HAND->query_all_places();
   gumboot = ({ });
   foreach (place in fluff) {
      value = MONEY_HAND->value_from_string(amt, place);
      if (value) {
        gumboot += ({ place });
      }
   }
   if (!sizeof(gumboot)) {
      add_failed_mess("Unable to understand the value of " + amt + ".\n",
                      to_sell);
      return 0;
   }
   if (member_array("Ankh-Morpork", gumboot) != -1) {
      gumboot = ({ "Ankh-Morpork" });
   }
   if (sizeof(gumboot) > 1) {
      add_failed_mess("Too many types of currency matched, matched currency "
                      "from " + query_multiple_short(gumboot) + ", try and "
                      "be more specific.  ie:  Ankh-Morpork dollars, not just "
                      "dollars.\n",
                      to_sell);
      return 0;
   }
   fail = this_player()->query_ignoring(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since you are "
                         "ignoring them.\n", fail);
         return 0;
      }
   }
   fail = this_player()->query_ignored_by(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since they are "
                         "ignoring you.\n", fail);
         return 0;
      }
   }
   place = gumboot[0];
   value = MONEY_HAND->value_from_string(amt, place);
   if (value < 0) {
      add_failed_mess("The value of the item was set too high.\n");
      return 0;
   }
   if (sizeof(sell_to) > 1) {
      add_failed_mess("Attempted to sell to $I, cannot sell to more than "
                      "one person.\n", sell_to);
      return 0;
   }
   if (sell_to[0] == this_player()) {
      add_failed_mess("You cannot sell $I to yourself.\n", to_sell);
      return 0;
   }
   if (each) {
      num = 0;
      foreach(object item in to_sell) {
          if ( item->query_collective() || item->query_continuous() ) {
             num += item->query_amount();
          }
          else {
             num++;
          }
      }
      value = value * num;
   }
#ifdef CHECK_MONEY
   if (sell_to[0]->query_value_in(gumboot[0]) < value) {
      add_failed_mess(sell_to[0]->the_short() + " does not have enough money "
                      "to buy $I.\n", to_sell);
      return 0;
   }
   if (!MONEY_HAND->query_person_payments(value, gumboot[0], sell_to[0], this_player())) {
      add_failed_mess(sell_to[0]->the_short() + " does not have the correct "
                      "change to pay " +
                      MONEY_HAND->money_value_string(value, gumboot[0]) +
                      " (and you do not have change to give back).\n");
      return 0;
   }
#endif
   wombat = new(class offer_sale);
   wombat->sell_obs = to_sell;
   wombat->seller = this_player();
   wombat->buyer = sell_to[0];
   wombat->value = value;
   wombat->place = gumboot[0];
   sell_to->add_respond_command("sell", this_player(), wombat);
   tell_object(sell_to[0],
               "You can accept the offer by typing:\n"
               "accept offer from " + this_player()->query_name() + "\n");
   add_succeeded_mess("$N offer$s to sell $I to " + sell_to[0]->the_short() +
                      " for " + MONEY_HAND->money_value_string(value,
                                            gumboot[0]) + ".\n", to_sell);
   return 1;
}
mixed *query_patterns() {
   return ({
 "<indirect:object:me'sell object'> to <indirect:living> for <string>",
             (: offer_sale($1[0], $1[1], $4[2], 0) :),
 "<indirect:object:me'sell object'> to <indirect:living> for <string> each",
             (: offer_sale($1[0], $1[1], $4[2], 1) :) });
}

==================================================
FILE: living/protect.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *protectees;
  things -= ({ TP });
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot protect yourself!\n");
     return 0;
  }
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much protection as a ghost.\n" );
    return 0;
  }
  protectees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_protector( TP ) ) {
      protectees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( protectees ) ) {
    add_failed_mess("You cannot protect $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot protect "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will protect $I.\n",
                        "$N moves to protect $I.\n" }),
	                protectees);
  return 1;
}
int show_protectors() {
   object *protect;
   object womble;
   protect = this_player()->query_protectors();
   if (sizeof(protect)) {
      write("You are being protected by " + query_multiple_short(protect) +
            ".\n");
   } else {
      write("You are not being protected by anyone.\n");
   }
   protect = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_protectors()) != -1) {
            protect += ({ womble });
         }
      }
   }
   if (sizeof(protect)) {
      write("Of the people in this room, you are protecting " +
            query_multiple_short(protect) + ".\n");
   } else {
      write("You are not protecting anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_protectors() :) });
}

==================================================
FILE: living/put.c
==================================================

#include <move_failures.h>
#include <player.h>
#define MAX_PUT_NUMBER 20
inherit "cmds/base";
#define TP this_player()
string con;
mixed cmd(mixed *indir,
          string *indir_match,
          string *args)
{
   string person;
   string thing;
   string sh;
   int tot;
   int max;
   object *per;
   object *ret;
   object *fail;
   object pobj;
   object ob;
   object *obs;
   object *succ;
   object *too_many;
   int num;
   con = args[1];
   per = indir[1];
   thing = indir_match[0];
   person = indir_match[1];
   succ = ({ });
   too_many = ({ });
   foreach(pobj in per) {
      if (living(pobj) && !pobj->query_living_container()) {
         tell_object(TP,
                     "You cannot put things " + con + " living things.\n");
         continue;
      }
      obs = indir[0];
      obs -= per;
      if (!sizeof(obs)) {
         tell_object(TP, "Nothing to " + query_verb() + " " + con + " " +
                     inside_the_short(pobj) + ".\n");
         continue;
      }
      if (!is_in_me_or_environment(pobj, this_player())) {
         add_failed_mess("Cannot $V $I " + con + " " + pobj->the_short() +
                         ".\n", obs);
         continue;
      }
      ret = ({ });
      fail = ({ });
      foreach(ob in obs) {
         if (member_array(ob, succ) > -1) {
            continue;
         }
         if (num > MAX_PUT_NUMBER) {
            too_many += ({ ob });
            continue;
         }
         if (function_exists("do_put", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_put", ob)) {
               max = (int) call_other(ob, "do_put", pobj, thing, person,
                                      ({ thing, person }),
                                      "<direct:object> " + con +
                                      " <indirect:object>");
            } else {
               max = ob->command_control("put", pobj, thing, person,
                                         ({ thing, person }),
                                         "<indirect:object> " +
                                         con + " <indirect:object>");
            }
            if (max == 0) {
               fail += ({ ob });
               continue;
            }
         }
         if (pobj->query_closed() || ob->move(pobj) != MOVE_OK) {
            fail += ({ ob });
         } else {
            ret += ({ ob });
            tot += (int) ob->query_weight();
#ifndef __DISTRUBUTION_LIB__
            if(interactive(TP))
              PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
            num++;
         }
      }
      if (sizeof(ret)) {
         succ += ret;
         sh = query_multiple_short(ret);
         add_succeeded_mess("$N $V $I " + con + " " +
                            inside_the_short(pobj) + ".\n", ret);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot $V $I " + con + " " +
                         inside_the_short(pobj) + ".\n", fail);
      }
   }
   if (sizeof(too_many)) {
      if (sizeof(succ) > 0) {
         add_succeeded_mess(({ "You cannot handle more than " +
                               query_num(MAX_PUT_NUMBER) +
                               " objects with $V; discarding $I.\n", "" }),
                            too_many);
      } else {
         add_failed_mess("You cannot handle more than " +
                         query_num(MAX_PUT_NUMBER) +
                         " objects with $V; discarding $I.\n", too_many);
      }
   }
   return sizeof(succ) > 0;
}
string query_con() {
  return con;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me> {in|on|into} <indirect:object>",
             (: cmd($1, $3, $4) :) });
}

==================================================
FILE: living/r_ead.c
==================================================

#include <language.h>
inherit "/cmds/base";
varargs string create_text( object thing, int label );
mixed cmd( object *things ) {
   string gendstr;
   string text;
   string read;
   string reader;
   string *others;
   string r_short;
   object thing;
   mapping hide_invis;
   int dark;
   dark = this_player()->check_dark(environment(this_player())->query_light());
   if (dark < 0) {
      add_failed_mess("It is too dark to read $I.\n", things);
      return 0;
   }
   if (dark > 0) {
      add_failed_mess("It is too bright to read $I.\n", things);
      return 0;
   }
   reader = "";
   others = ({ });
   foreach( thing in things ) {
      if (!is_in_me_or_environment(thing, this_player())) {
          add_failed_mess("You cannot read $I.\n", ({ thing }));
          continue;
      }
      text = thing->query_readable_message(this_player());
      read = thing->query_read_short();
      if (!read) {
         read = "$name$";
      }
      if ( !text) {
        if (living(thing)) {
            gendstr = thing->query_objective();
        } else {
           gendstr = "it";
        }
        r_short = thing->query_read_short();
        if (!r_short) {
           r_short = "$name$";
        }
        if (!thing->command_control("read")) {
            if (thing != this_player()) {
               reader += "$C$"+ replace_string(r_short,
                                        "$name$",
                                        thing->a_short()) +
                     " does not have anything written on " +
                     gendstr + ".\n";
            } else {
               reader += "You cannot read yourself.\n";
            }
         } else {
            others += ({ replace( read, "$name$", (string)thing->a_short() ) });
            reader += "";
         }
         continue;
      }
      reader += "You read "+ replace_string( read, "$name$",
            (string)thing->the_short() ) +":\n"+ text + "\n";
      if ( read == "$name$" ) {
          others += ({ thing });
      }
      else {
          others += ({ replace( read, "$name$", (string)thing->a_short() ) });
      }
   }
   if ( !sizeof( others ) ) {
      add_failed_mess(reader);
      return 0;
   }
   write( "$P$Read$P$"+ reader );
   hide_invis = this_player()->query_hide_invis();
   if(!hide_invis["hiding"]) {
      add_succeeded_mess(({ "", "$N read$s $I.\n" }), others);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :) });
}

==================================================
FILE: living/remove.c
==================================================

#include <clothing.h>
#include <tasks.h>
#define SKILL "covert.manipulation.sleight-of-hand"
#ifdef DEBUG
#define TELL_ME "presto"
#endif
inherit "cmds/base";
int cmd(object *things)  {
   object  *removed = ({ });
   object  *blocking = ({ });
   object  *blocked;
   object  *total_blocking = ({ });
   object  *succeeded;
   object  *failed;
   object  *failed_rewear;
   object   ob;
   object   blocker;
   mapping  is_blocking = ([ ]);
   mapping  hide_invis;
   string   tmp1;
   string   tmp2;
   int      last_blocking;
   int      limit;
   int      i;
   int      hiding;
   int      sneaking;
   int      difficulty;
   int      light;
   int      my_light;
   succeeded = this_player()->query_wearing();
   failed = filter(things, (: member_array($1, $(succeeded)) == -1 :));
   things -= failed;
   if (sizeof(things) == 0)  {
      write("You are not wearing " + query_multiple_short(failed, "the") +
            ".\n");
      return 1;
   }
   succeeded = things;
   for (i = 0; i < sizeof(succeeded); i++)  {
      ob = succeeded[i];
      blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player()) -
                 ({ ob });
      if (sizeof(blocking))  {
         foreach (blocker in blocking)  {
            if (undefinedp(is_blocking[blocker]))
               is_blocking[blocker] = ({ ob });
            else
               is_blocking[blocker] |= ({ ob });
         }
         total_blocking |= blocking;
         succeeded = ({ things..., total_blocking... });
      }
   }
   total_blocking = ({ });
   foreach (ob, blocked in is_blocking)  {
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
      tell_creator(TELL_ME, "ob == %s, blocked == %O\n",
                   ob->short(), blocked->short());
#endif
      last_blocking = -1;
      for (i = sizeof(total_blocking) - 1; i >= 0; i--)  {
         if (member_array(ob, is_blocking[total_blocking[i]]) > -1)  {
            last_blocking = i;
            break;
         }
      }
      if (last_blocking == -1)  {
         total_blocking = ({ ob, total_blocking... });
#ifdef DEBUG
         if (this_player() == find_player(TELL_ME))
            tell_creator(TELL_ME, "Nothing is blocking ob, adding it to "
                         "the beginning\n%O\n", total_blocking->short());
#endif
         continue;
      }
      total_blocking = ({ total_blocking[0 .. last_blocking]...,
                          ob,
                          total_blocking[(last_blocking + 1) .. ]... });
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
         tell_creator(TELL_ME, "Adding ob after last_blocking position "
                      "(%d)\n%O\n",
                      last_blocking, total_blocking->short());
#endif
      limit = last_blocking;
      blocking = copy(blocked);
      for (i = 0; i < limit; i++)  {
         if (member_array(total_blocking[i], blocking) > -1)  {
            blocking += is_blocking[total_blocking[i]];
            if (i == 0)
               total_blocking =
                  ({ total_blocking[1 .. (last_blocking + 1)]...,
                     total_blocking[0],
                     total_blocking[(last_blocking + 2) .. ]... });
            else
               total_blocking =
                  ({ total_blocking[0 .. (i - 1)]...,
                     total_blocking[(i + 1) .. (last_blocking + 1)]...,
                     total_blocking[i],
                     total_blocking[(last_blocking + 2) .. ]... });
            --limit;
            --i;
#ifdef DEBUG
            if (this_player() == find_player(TELL_ME))
               tell_creator(TELL_ME, "Reordered list:\n%O\n",
                            total_blocking->short());
#endif
         }
      }
   }
   foreach (blocker in total_blocking)  {
      tmp1 = CLOTHING_HANDLER->can_wear_or_remove(blocker, this_player());
      if (tmp1)  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " " + tmp1 + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else if (this_player()->remove_armour(blocker))  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " because you cannot remove " + blocker->one_short() + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else removed += ({ blocker });
   }
   succeeded = things & removed;
   failed = ({ });
   foreach (ob in things - removed)  {
      if (this_player()->remove_armour(ob))
         failed += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      removed -= things;
      tmp2 = query_multiple_short(succeeded, "the") ;
      if (sizeof(removed) > 0)  {
         tmp1 = query_multiple_short(removed, "the");
         write("You remove " + tmp1 + " so you can remove " + tmp2 + ".\n");
         say(this_player()->the_short() + " removes " + tmp1 + " so " +
             this_player()->query_pronoun() + " can remove " + tmp2 + ".\n");
      }
      else  {
        hide_invis = ( mapping )this_player()->query_hide_invis();
        hiding = hide_invis[ "hiding" ] ? 1 : 0;
        sneaking = this_player()->query_sneak_level() ? 1 : 0;
        if( hiding || sneaking ) {
          my_light = this_player()->query_light();
          light = environment( this_player() )->query_light();
          difficulty = light + ( 4 * my_light ) / ( light + 1 );
          difficulty += succeeded[0]->query_complete_weight();
          debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                        difficulty, SKILL, this_player()->
                        query_skill_bonus( SKILL ) );
          switch( TASKER->perform_task( this_player(), SKILL, difficulty,
            TM_FREE ) ) {
            case AWARD :
              write( "%^YELLOW%^" + ({
                "You discover something that lets your fingers move more "
                  "nimbly.",
                "You find yourself capable of deceiving the eye with greater "
                  "ease than before.",
                "You realise how to deceive the eye more effectively."
              })[ random(3) ] + "%^RESET%^\n" );
            case SUCCEED :
              add_succeeded_mess( ({ "$N $V " + tmp2 + ", managing to stay "
                "unnoticed.\n",
                "" }) );
              break;
            default :
              this_player()->add_succeeded_mess( this_object(), "$N "
                "unsuccessfully tr$y to " + query_verb() + " " + tmp2 +
                " while staying unnoticed.\n", ({ }) );
              break;
          }
        } else {
          this_player()->add_succeeded_mess( this_object(), "$N $V " + tmp2 +
            ".\n", ({ }) );
        }
      }
   }
   succeeded = ({ });
   failed_rewear = ({ });
   foreach (ob in removed)  {
      if (this_player()->wear_armour(ob))
         failed_rewear += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      this_player()->force_burden_recalculate();
      tmp1 = query_multiple_short(succeeded, "the");
      write("You wear " + tmp1 + ".\n");
      say(this_player()->the_short() + " wears " + tmp1 + ".\n");
   }
   if (sizeof(failed_rewear) > 0)  {
      write("You cannot put " +
            query_multiple_short(failed_rewear, "the") + " back on.\n");
   }
   if (sizeof(failed) > 0)  {
      write("You cannot remove " + query_multiple_short(failed, "the") +
            ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/sa_y.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "cmds/speech";
mixed cmd(string arg) {
  class message mess;
  mess = build_message(arg, 0, "say");
  return say_it(mess);
}

==================================================
FILE: living/sayto.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(object *obs, string str) {
  class message mess;
  obs = filter(obs, (: $1 && $1 != this_player() :));
  if(!sizeof(obs)) {
    return notify_fail("Be serious.\n");
  }
  mess = build_message(str, obs, "say");
  return say_it_to(mess, obs, 0, "person_say");
}
mixed *query_patterns() {
   return ({ "<indirect:living> <string>", (: cmd($1, $4[1]) :) });
}

==================================================
FILE: living/sh_out.c
==================================================

#include <player.h>
#include <drinks.h>
#include <language.h>
#include <cmds/options.h>
#include "/d/am/path.h"
inherit "/cmds/base";
inherit "/cmds/speech";
#define TP this_player()
#define BEEP sprintf("%c",7)
#define NO_QUIT_INVENTORY 1
#define NO_QUIT_COMBAT    2
#define BROADCASTER "/obj/handlers/broadcaster"
int query_no_quit();
string query_shout_word_type(string str);
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string s1, s2, s;
  object g;
  string cur_lang;
  object lag;
  int tim, cost;
  if(!str || str == "")
    return notify_fail("Syntax : shout <text>\n");
  if (!environment(this_player()))
    return notify_fail( "You appear to be in limbo...\n" );
  if(TP->query_property("dead") == 1)
    return notify_fail("You don't have any lungs, how can you shout?\n");
  if (TP->check_earmuffs("shout"))
    return notify_fail("Why shout when you can't hear people "
                       "shout back?\n");
  cur_lang = TP->query_current_language();
  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");
  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken "
                       "at a distance.\n");
  if (TP->query_invis())
    return notify_fail("Invisible people cannot shout, they cannot "
                       "see their arm in front of their face.  Shouting is "
                       "out of the question.\n");
  if (TP->query_property("gagged"))
    return notify_fail("You have been gagged!  You will not be able "
                       "to shout again until the gag is removed.  Perhaps "
                       "you should talk to a creator about this.\n");
  if (TP->query_property("recently shouted")) {
    return notify_fail("You have shouted very recently, perhaps you "
                       "should give your lungs a small break and try again "
                       "in a couple seconds.\n");
  }
  if(TP->query_property("player") == 1 && !TP->query_creator()) {
    cost = SHOUT_COST * ((strlen(str) / 5) + 1);
    cost += sizeof(filter(explode(str, ""), (: $1 <= "Z" :))) / 2;
    if(TP->adjust_sp(-cost) < 0)
      return notify_fail(NO_POWER);
    TP->adjust_max_sp(- (cost / 5));
  }
  if (!interactive(TP)) {
    str = TP->convert_message( str );
    str = TP->fit_message( str );
  }
  s1 = query_shout_word_type(str);
  if (s1 != "yell")
    s = "shouts" + s1;
  else
    s = s1 + "s";
  if(TP->query_property(SHORTHAND_PROP))
    str = fix_shorthand(str);
  if(TP->query_volume( D_ALCOHOL))
    str = drunk_speech( str );
  TP->remove_hide_invis("hiding");
  if (s1 != "yell") {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You shout" + s1 + ": ", str);
  } else {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You " + s1 + ": ", str);
  }
  s2 =  " " + lower_case(str);
  if (sscanf(" "+s2, "%s eight%s", s1, s1)==2 ||
      sscanf(s2, "%s8%s", s1, s1)==2) {
    s1 = replace(str, ({ "8", "", " eight", "", " ", "" }));
    switch (query_no_quit()) {
    case NO_QUIT_INVENTORY:
      return notify_fail("You only just arrived.  You are far too "
                         "busy strapping on equipment to shout like that.\n");
    case NO_QUIT_COMBAT:
      return notify_fail("You are too busy fighting to shout "
                         "like that.\n");
    default:
      if (s1 == "") {
        write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
      else {
        g = (object)TP->query_guild_ob();
        if (random(100) < 40 ||
            (g && (string)g->query_name() == "wizards"))
          write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
    }
  }
  lag = load_object(SHORT + "short20")->lag_for_shout();
  if(lag && sscanf(" "+lower_case(s2), "%*s lag%*s") == 2) {
    tim = TP->query_property("lag shout time");
    TP->add_property("lag shout time", time(), 300);
    if((tim + 300 > time()) && lag != TP) {
      switch (query_no_quit()) {
      case NO_QUIT_INVENTORY:
        lag->init_command("hug "+ TP->query_name() +
                          " Welcome to " + mud_name() + "", 0);
        return notify_fail("The air is suddenly squeezed out "
                           "of you.\n");
      case NO_QUIT_COMBAT:
        lag->init_command("wedgie " + TP->query_name(), 0);
        return notify_fail("You are rudely interrupted "
                           "mid-shout.  Fortunately you are not distracted "
                           "from the fight.\n");
      default:
        call_out( "summon_bel_shamharoth", 10, TP, 1);
      }
    }
  }
  if(environment(this_player()) &&
     environment(this_player())->query_property("location") == "inside")
    tim = 10;
  else
    tim = 3;
  user_event( this_player(), "person_shout",
              (string)this_player()->a_short() +" "+ s,
              str, cur_lang,
              (int *)environment( this_player() )->query_co_ord(),
              ( 100 * ( (int)this_player()->query_con() +
                        (int)this_player()->query_str() ) ) / tim );
  environment(TP)->event_person_shout( 0, (string)TP->a_short() +" "+ s,
                                       str + "%^RESET%^", cur_lang );
  BROADCASTER->npc_shout_event(TP, (string)TP->a_short() +" "+ s,
                               str + "%^RESET%^", cur_lang,
                               (int *)environment(TP)->query_co_ord(),
                               (100 * ((int)TP->query_con() +
                                       (int)TP->query_str() ) ) / 3);
  if (TP->query_property("player") == 1 && !TP->query_creator()) {
    TP->add_property("recently shouted", 1, 2);
  }
  return 1;
}
string query_shout_word_type(string str) {
  switch (str[<1]) {
  case '!':
    return "yell";
  case '?':
    return " asking";
  default:
    return "";
  }
}
void my_mess(string fish, string erk) {
  if(!interactive(TP))
    return;
  printf("%s%-=*s\n", fish, TP->query_cols() - strlen(fish),
         TP->fix_string(erk));
}
void summon_bel_shamharoth(object who, int lag_shout) {
  object env;
  if (!who || !objectp(who))
    return;
  if (!random(3))
    who->adjust_tmp_con(-2);
  if (!random(3))
    who->adjust_tmp_int(-2);
  if (!random(3))
    who->adjust_tmp_wis(-2);
  if (!random(3))
    who->adjust_tmp_dex(-2);
  env = environment(who);
  if ("/secure/master"->query_lord(geteuid(who))) {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                 "The heavens shake with a hideous roar and just as suddenly "
                 "all is quiet.\n$C$"+ who->query_name() + " chuckles in the "
                 "distance.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object(who, "Your lordliness saves you from a grizzly "
                "encounter with the Sender of Eight.\n");
  } else {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                             "a sudden chill passes through the land as $C$" +
                           who->query_name() + " is carried off screaming "
                           "to the land of shades.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object( who, "You think you'd best be careful what you "
                 "shout in the future as shadowy tentacles drag you "
                 "into the ground...\n" );
    if(lag_shout)
      BROADCASTER->broadcast_event(users(),
                                   (int *)env->query_co_ord(),
                                   ( 100 * ( (int)who->query_con() +
                  "The heavens shake with a hideous chuckle and in the "
                  "distance a booming yet apologetic voice says: Oops.\n",
                                             (int)who->query_str() ) ) / 3,
                                   1, 0);
    if(base_name(env) != "/room/departures")
      who->quit();
  }
}
int query_no_quit() {
  if (TP->query_save_inhibit() || TP->query_auto_loading()) {
    return NO_QUIT_INVENTORY;
  }
  if (sizeof(filter_array(TP->query_attacker_list(), (: living($1) :)))) {
    return NO_QUIT_COMBAT;
  }
  return 0;
}

==================================================
FILE: living/sheathe.c
==================================================

#include <move_failures.h>
inherit "/cmds/base";
int cmd( object * weapons, object * scabbards ) {
   object weapon;
   object scabbard;
   if( sizeof(weapons) > 1 ) {
      add_failed_mess( "You can only sheathe one thing at a time.\n" );
      return 0;
   }
   weapon = weapons[0];
   if ( ( scabbard = environment( weapon ) )->query_scabbard() &&
        scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( weapon->the_short() + " is already sheathed.\n" );
      return 0;
   }
   if ( environment( weapon ) != this_player() ) {
      add_failed_mess( weapon->the_short() + " is not in your inventory.\n" );
      return 0;
   }
   if ( scabbards ) {
      if ( sizeof(scabbards) > 1 ) {
         add_failed_mess( "For shame! Trying to sheathe your weapon "
           "in more than one object at a time?\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if ( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not even a "
           "scabbard!\n" );
         return -1;
      }
      if( !scabbard->test_type_ok( weapon ) ) {
        return add_failed_mess( "$C$"+scabbard->the_short() + " is not a "
                                "suitable scabbard for " + weapon->a_short()
                                + ".\n" );
      }
   } else {
      scabbards = filter( all_inventory( this_player() ),
                          (: $1->query_scabbard() &&
                             $1->test_type_ok( $(weapon) ) :) );
      if ( !sizeof( scabbards ) ) {
         return add_failed_mess( "Can't find any suitable scabbards in "
           "your inventory.\n" );
      }
      scabbards = filter( scabbards, (: $1->test_add( $(weapon), 0, 1 ) :) );
      if ( !sizeof(scabbards) ) {
         return add_failed_mess( "Can't find any empty scabbards in your "
           "inventory.\n" );
      }
      scabbard = scabbards[0];
   }
   if ( weapon->query_wielded() &&
       !sizeof( this_player()->set_unhold(weapon) ) )
   {
      return add_failed_mess( "You cannot let go of " + weapon->the_short()
        + ".\n" );
   }
   if ( weapon->move(scabbard) != MOVE_OK ) {
      this_player()->add_failed_mess( scabbard, "You cannot $V $I in $D.\n",
        ({ weapon }) );
      return 0;
   }
   this_player()->add_succeeded_mess( scabbard, "$N $V $I in $D.\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   return ({
      "<indirect:object:me'weapon'>",
        (: cmd( $1, 0 ) :),
      "<indirect:object:me'weapon'> in <indirect:object:me'scabbard'>",
        (: cmd( $1[0], $1[1]) :)
   });
}

==================================================
FILE: living/show.c
==================================================

#include <command.h>
#define READ ( DIR_LIVING_CMDS "/r_ead" )
inherit "/cmds/base";
int do_show_object( object shower, object item, object owner, object target, int no_mess );
#ifdef DEBUG
int notify_fail(string str) {
  tell_object(find_player("tape"), "%^YELLOW%^"+
              this_player()->query_short()+" "+str+"%^RESET%^\n");
  return efun::notify_fail(str);
}
#endif
int cmd( object item, object target )
{
   return do_show_object( this_player(), item, this_player(), target, 0 );
}
int do_show_object( object shower, object item, object owner, object target, int nomess )
{
   tell_creator( shower, "%O\n%O\n", item, target );
   if( target == shower ) {
      add_failed_mess( "Why not just look at it?\n");
      return 0;
   }
   if( !shower->query_visible( target ) ) {
      add_failed_mess( "It appears that " + target->the_short() +
         " can't see you or your item.\n" );
      return 0;
   }
   if( target->query_property( "ignoring" ) ) {
      if( member_array( shower->query_name(),
         target->query_property( "ignoring" ) ) != -1 ) {
         add_failed_mess( target->the_short() + " ignores you.\n" );
         return 0;
      }
   }
   if( item->query_worn_by() ) {
      add_failed_mess( item->the_short() + " must be removed before it can be "
         "shown.\n" );
      return 0;
   }
   target->add_respond_command( "show offer", this_object(),
      ({ item, owner, shower }) );
   if( !nomess )
   {
      tell_room( environment( shower ), shower->the_short() +
         " offers to show " + item->a_short() + " to " +
         target->a_short() + ".\n",
         ({ target, shower }) );
      tell_object( shower, "You offer " + item->the_short() +
         " to " + target->the_short() + " for inspection.\n" );
      tell_object( target, shower->the_short() + " offers you " +
         item->a_short() + " for inspection.  Use \"show accept offer "
         "from " + shower->query_name() + "\" to view it.\n" );
   }
   return 1;
}
int accept_show( object target, int read ) {
   mixed *stuff;
   object from;
   object owner;
   object item;
   string message;
   if( target == this_player() ) {
      add_failed_mess( "You cannot show stuff to yourself.\n");
      return 0;
   }
   stuff = this_player()->query_respond_command(
      "show offer", this_object() );
   if( !sizeof( stuff ) ) {
      add_failed_mess( "No one has offered to show you anything.\n");
      return 0;
   }
   item     = stuff[ 0 ];
   owner    = stuff[ 1 ];
   from     = stuff[ 2 ];
   if( !from || target != from ) {
      add_failed_mess( target->the_short() + " hasn't offered "
         "to show you anything.\n" );
      return 0;
   }
   if( !item || ( owner && environment( item ) != owner ) )
   {
      add_failed_mess( "It appears that " + target->the_short() +
         " has misplaced " + target->query_possessive() + " item.\n");
      return 0;
   }
   this_player()->remove_respond_command( "show offer", this_object() );
   tell_room( environment( this_player() ), this_player()->the_short() +
      " accepts the offer from " +
      target->the_short() +
      " to see " + item->the_short() + ".\n", ({ this_player(), target }) );
   message = "You accept " + target->the_short() + "'s offer.\n";
   tell_object( target, "You show " + item->the_short() + " to " +
      this_player()->the_short() + ".\n" );
   message += "\n";
   if( this_player()->query_creator() ) {
      message += "%^CYAN%^" + file_name( item ) + ":%^RESET%^\n";
   }
   message += item->long();
   if( sizeof( item->query_read_mess() ) ) {
      message += item->the_short() + " also contains some writing.\n";
      message += item->query_readable_message(this_player());
   }
   write("$P$Show$P$" + message);
   return 1;
}
mixed *query_patterns() {
   return ({
      "<indirect:object:me'item'> to <indirect:living'living'>",
         (: cmd( $1[ 0 ][ 0 ], $1[ 1 ][ 0 ] ) :),
      "accept [offer] [from] <indirect:living'living'>",
         (: accept_show( $1[ 0 ], 0 ) :) });
}

==================================================
FILE: living/sit.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   if(this_player()->query_position() == "lying")
     setup_position("sit", "up", SITTING);
   else
     setup_position("sit", "down", SITTING);
}

==================================================
FILE: living/sp_eak.c
==================================================

inherit "/cmds/base";
#include <language.h>
#define TP this_player()
int cmd(string which)
{
   string *langs;
   string skill;
   int i;
   mapping skills;
   skills = TP->query_skills();
   if (!which) {
      langs = LANGUAGE_HAND->query_languages();
      for (i = 0; i < sizeof(langs); i++) {
         if (TP->
             query_skill(LANGUAGE_HAND->
                         query_language_spoken_skill(langs[i])) > 1
             || TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
         } else {
            langs = langs[0..i - 1] + langs[i + 1..];
            i--;
         }
      }
      write("You are currently speaking " +
            cap_words(TP->query_current_language()) + " and your default "
            "language is " + cap_words(TP->query_default_language()) + ".\n");
      write("You can speak " +
            query_multiple_short(map(langs, (: cap_words :)) +
                                 ({ "Grunt" })) + ".\n");
      write("Please note that the language you are speaking is used for "
            "writing as well, so some of the languages may be just written.\n");
      return 1;
   }
   which = lower_case(which);
   skill = LANGUAGE_HAND->query_language_spoken_skill(which);
   if (!skill) {
      return notify_fail("You cannot speak that language.\n");
   }
   if((!TP->query_skill(skill) && which != "grunt" && which != "general") ||
      (which == "general" && !TP->query_creator() && interactive(TP)))
      return notify_fail("You don't know that language.\n");
   if (which == this_player()->query_current_language()) {
      add_failed_mess("You are already speaking " + cap_words(which) + ".\n");
      return 0;
   }
   if (!TP->set_language(which)) {
      return notify_fail("Argh... something weird happened.\n");
   }
   write("Now using " + cap_words(which) + " for speaking and writing.\n");
   return 1;
}
mixed *query_patterns()
{
   string *languages;
   string tmp;
   languages = LANGUAGE_HAND->query_languages();
   if ( TP->query_womens_day() ) {
       languages += ({ "wommon" });
   }
   tmp = implode(languages + map(languages, (: cap_words :)), "|");
   return ({ "{" + tmp + "}", (: cmd(implode($4, " ")) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: living/stand.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("stand", "up", STANDING);
}

==================================================
FILE: living/surr_ender.c
==================================================

inherit "/cmds/base";
mixed cmd(int mode, int val) {
  if (!mode) {
    int surr = this_player()->query_surrender();
    if (surr)
      write(sprintf("You will surrender at %d%% of your max hps.\n", surr));
    else
      write("You will not surrender.\n");
    return 1;
  } else {
    if (val < 0 || val > 100)
      return notify_fail("Your surrender must be between 0 and 100.\n");
    this_player()->set_surrender(val);
    write(sprintf("Surrender set to %d%%\n", this_player()->query_surrender()));
    return 1;
  }
}
mixed *query_patterns()
{
  return ({ "", (: cmd(0, 0) :),
            "<number>", (: cmd(1, $4[0]) :) });
}

==================================================
FILE: living/swim.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("swim", "around", SWIMMING);
}

==================================================
FILE: living/tactics.c
==================================================

inherit "/cmds/base";
#include <combat.h>
int cmd() {
  class tactics tactics;
  tactics = (class tactics) this_player()->query_tactics();
  write("Your combat options are:\n\n" );
  write("   Attitude - "+ tactics->attitude +".\n" );
  write("   Response - "+ tactics->response +".\n" );
#ifdef USE_SURRENDER
  write("   Mercy - "+ (tactics->mercy?tactics->mercy:"none") + ".\n");
#endif
  write("   Focus - "+ (tactics->focus_zone?tactics->focus_zone:"none") + ".\n" );
#ifdef USE_DISTANCE
  write("   Target distance - "+ (tactics->ideal_distance?tactics->ideal_distance:"none") + ".\n" );
#endif
  write("You will use "+
        (tactics->attack == "both" ? "both hands" :
         "your "+ (tactics->attack?tactics->attack:"either") +" hand" ) +
        " to attack.\n" );
  write("You will use "+
        (tactics->parry == "both" ? "both hands" :
         "your "+ (tactics->parry?tactics->parry:"either") +" hand" ) +
        " to parry.\n" );
  write("\nYou will"+ ( tactics->parry_unarmed ? " " : " not " ) +
        "attempt to parry unarmed.\n" );
  return 1;
}
int attitude(string word) {
  class tactics my_tactics;
  my_tactics = new(class tactics);
  my_tactics = (class tactics) this_player()->query_tactics();
  switch(word) {
  case "insane":
  case "offensive":
  case "neutral":
  case "defensive":
  case "wimp":
    if((my_tactics->attitude) == word) {
      write("Your attitude is already " + word + ".\n");
    } else {
      my_tactics->attitude = word;
      write("Your attitude is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics attitude "
                       "insane|offensive|neutral|defensive|wimp.\n");
  }
}
int response(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "dodge":
  case "neutral":
  case "parry":
    if(my_tactics->response == word) {
      write("Your response is already " + word + ".\n");
    } else {
      my_tactics->response = word;
      write("Your response is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics response dodge|neutral|parry\n");
  }
}
int parry(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "unarmed":
    my_tactics->parry_unarmed = 1 - my_tactics->parry_unarmed;
    write("You will"+ ( my_tactics->parry_unarmed ? " " : " not " ) +
          "now attempt to parry unarmed.\n" );
    this_player()->set_tactics(my_tactics);
    return 1;
  case "left":
  case "right":
  case "both":
    if(my_tactics->parry == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
    } else {
      my_tactics->parry = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics parry "+
                        "left|right|both [hand(s)]\n        "
                        "tactics parry unarmed\n" );
  }
}
int attack(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "left":
  case "right":
  case "both":
    if(my_tactics->attack == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
    } else {
      my_tactics->attack = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics attack "+
                        "left|right|both [hand(s)]\n" );
  }
}
int focus(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "head":
  case "neck":
  case "chest":
  case "abdomen":
  case "arms":
  case "hands":
  case "legs":
  case "feet":
  case "upper body":
  case "lower body":
    if(my_tactics->focus_zone == word) {
      write("You are already focussing on your opponent's "+ word + ".\n");
    } else {
      my_tactics->focus_zone = word;
      write("You will now focus on your opponent's "+ word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  case "none":
    if(!my_tactics->focus_zone) {
      write("You are not currently focussing on any particular target "
            "area.\n");
    } else {
      my_tactics->focus_zone = 0;
      write("You will no longer focus on a specific target area.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics focus " +
                        "upper body|lower body|head|neck|chest|abdomen|arms|hands|legs|feet|none\n");
  }
}
int distance(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "long":
  case "medium":
  case "close":
  case "hand-to-hand":
    if(my_tactics->ideal_distance == word) {
      write("You are already set for " + word + " range.\n");
      return 1;
    }
    my_tactics->ideal_distance = word;
    write("You will now aim for "+ word + " range combat.\n");
    this_player()->set_tactics(my_tactics);
    return 1;
  case "none":
    if(!my_tactics->ideal_distance) {
      write("You are not currently aiming for any specific combat distance.\n");
    } else {
      my_tactics->ideal_distance = 0;
      write("You will no longer aim for a specific combat distance.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics distance " +
                        "{long|medium|close|hand-to-hand\n");
  }
}
#ifdef USE_SURRENDER
int mercy(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "always":
  case "ask":
  case "never":
    if(my_tactics->mercy == word) {
      write("Your mercy is already " + word + ".\n");
    } else {
      my_tactics->mercy = word;
      write("Your mercy is now "+ word +".\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics mercy always|ask|never\n");
  }
}
#endif
mixed *query_patterns() {
  return ({ "", (: cmd() :),
              "attitude <word'insane|offensive|neutral|defensive|wimp'>",
              (: attitude($4[0]) :),
              "response <word'dodge|neutral|parry'>", (: response($4[0]) :),
#ifdef USE_SURRENDER
              "mercy <word'always|ask|never'>", (: mercy($4[0]) :),
#endif
              "parry <word'left|right|both|unarmed'>", (: parry($4[0]) :),
              "attack <word'left|right|both'>", (: attack($4[0]) :),
              "focus <string'upper body|lower body|head|neck|chest|abdomen|"
              "arms|hands|legs|feet|none'>", (: focus($4[0]) :),
#ifdef USE_DISTANCE
              "distance <word'long|medium|close|hand-to-hand|none'>",
              (: distance($4[0]) :),
#endif
              });
}

==================================================
FILE: living/take.c
==================================================

inherit "/cmds/living/get";
