# Total Tokens: 21801
# Total Files Merged: 17
# Total Characters: 72731

ther/judge.c
==================================================

#include <tasks.h>
#include <weapon.h>
#undef DEBUG
#define COST 25
#define SKILL "other.evaluating.weapons"
#define QUEST_AVE 140
#define QUEST_MAX 300
#define LEARN 5
#define TEACH 50
inherit "/cmds/guild_base";
nosave string *_attack_types = ({ "blunt", "sharp", "pierce" });
nosave string *attacks;
void create() {
    ::create();
    set_nroff_file("judge");
    set_command_name("judge");
    add_teach_skill(SKILL, 50, 5);
}
varargs int *calc_rating( object weapon, object player ) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;
    data = (mixed *)weapon->query_attack_data();
    if ( !( size = sizeof( data ) ) )
        return ({ 0, 0 });
    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
      debug_printf("[%s - ave: %d max: %d]\n", data[ i + W_TYPE],
                   ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100,
                   damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ]);
    }
    debug_printf("[%s - ave: %d max: %d]\n", weapon->short(), ave, max );
    return ({ ave, max });
}
void judge_against( object player, object first, object second ) {
  int grain, rating, rating_1, rating_2, difficulty, margin, *data_1,
    *data_2;
  data_1 = calc_rating( first, player );
  data_2 = calc_rating( second, player );
  difficulty = data_1[ 0 ] - data_2[ 0 ];
    if ( difficulty > 0 )
        difficulty = QUEST_AVE - difficulty;
    else
        difficulty = QUEST_AVE + difficulty;
    margin = ( difficulty + ( difficulty * ( data_1[ 1 ] + data_2[ 1 ] ) ) /
        ( 2 * QUEST_MAX ) ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL, difficulty - 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapons$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to better judge "
                "$weapons$.", "As you inspect $weapons$, you feel a sense "
                "of surety in your judgement." })[ random( 3 ) ], "$weapons$",
                query_multiple_short( ({ first, second }), "the" ) ) +
                "%^RESET%^\n" );
        case SUCCEED:
            break;
        default:
            tell_object( player,
                "You examine "+ query_multiple_short( ({ first, second }),
                    "the" ) + " closely, but you're not sure which is "
                    "better.\n" );
            return;
    }
    grain = sqrt( (int)this_player()->query_skill_bonus( SKILL ) );
    if ( grain > 12 )
        grain = 12;
    rating_1 = QUEST_AVE * data_1[ 1 ] + QUEST_MAX * data_1[ 0 ];
    rating_1 = ( grain * rating_1 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating_2 = QUEST_AVE * data_2[ 1 ] + QUEST_MAX * data_2[ 0 ];
    rating_2 = ( grain * rating_2 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating = rating_1 - rating_2;
    if ( rating > 0 )
        rating++;
    else
        rating--;
    rating = 6 + rating / 2;
    if ( rating > 12 )
        rating = 12;
    if ( rating < 0 )
        rating = 0;
    if ( rating == 6 ) {
        tell_object( player, "You think that " +
            query_multiple_short( ({ first, second }), "the" ) +
            " are exactly the same.\n" );
        return;
    }
    tell_object( player, "You think that " + first->the_short() +" is "+ ({
         "amazingly worse", "extremely worse", "very much worse",
         "much worse", "worse", "a bit worse", "!", "a bit better",
         "better", "much better", "very much better",
         "extremely better", "amazingly better" })[ rating ] +" than "+
         second->the_short() +".\n" );
}
int judge_weapon( object player, object weapon ) {
    int grain, rating, margin, *data;
    string res;
    data = calc_rating( weapon, player );
    margin = ( data[ 0 ] + ( data[ 0 ] * data[ 1 ] ) / QUEST_MAX ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL,  data[ 0 ] + 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapon$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to judge "
                "$weapon$.", "As you inspect $weapon$, you feel a sense of "
                "surety in your judgement." })[ random( 3 ) ], "$weapon$",
                weapon->the_short() ) +"%^RESET%^\n" );
    case SUCCEED:
      break;
    default:
      tell_object( player, "You think that " + weapon->the_short() +
                   " is a good weapon, but you're not sure.\n" );
      return 0;
    }
    grain = sqrt( player->query_skill_bonus( SKILL ) / 2 );
    if ( grain > 14 )
      grain = 14;
    rating = QUEST_AVE * data[ 1 ] + QUEST_MAX * data[ 0 ];
    rating = ( grain * rating + QUEST_AVE * QUEST_MAX ) /
      ( 2 * QUEST_AVE * QUEST_MAX );
    rating += 14 - grain;
    if ( rating > 14 ) {
#ifdef DEBUG
      log_file( "BAD_WEAPON", "%s exceeds weapon specifications, rating is "
                "%d.\n", file_name( weapon ), rating );
#endif
      rating = 14;
    }
    attacks = player->query_known_commands();
    attacks = filter(weapon->query_attack_names(),
                  (: (member_array($1, attacks) != -1) :));
    attacks -= ({ "crush" });
    attacks -= ({ "impale" });
    attacks -= ({ "behead" });
    if(member_array("smash", weapon->query_attack_names()) != -1 &&
       member_array("crush", player->query_known_commands()) != -1)
       attacks += ({ "crush" });
    if(member_array("pierce", weapon->query_attack_names()) != -1 &&
       member_array("impale", player->query_known_commands()) != -1)
       attacks += ({ "impale" });
    if(member_array("slice", weapon->query_attack_names()) != -1 &&
       member_array("behead", player->query_known_commands()) != -1)
       attacks += ({ "behead" });
    res = "You think that "+ weapon->the_short() +" is " + ({
      "an atrocius", "an extremely poor", "a very poor", "a rather poor",
        "a poor", "a pretty poor", "a quite poor", "a reasonable",
        "a quite good", "a pretty good", "a good", "a rather good",
        "a very good", "an extremely good", "an excellent" })[ rating ] +
      " weapon";
    debug_printf("attacks: %O", attacks);
    if(sizeof(attacks))
      res += " that can be used to " + query_multiple_short(attacks, "", 0, 1,
                                                            0);
    res += ".\n";
    tell_object(player, res);
    return rating;
}
int valid_weapon( object player, object ob ) {
  if ( living( ob ) ) {
    if ( ob == player ) {
      add_failed_mess( "You stare at your muscles for a moment, "
                       "and decide that you're more than capable of destroying "
                       "any enemy that decides to interfere with you.\n" );
      return 0;
    }
    add_failed_mess( "You stare at $I for a while, but decide it "
                     "would be better if you considered them instead.\n",
                     ({ ob }) );
    return 0;
  }
  if ( !ob->query_weapon() ) {
    add_failed_mess( "$C$$I is not a weapon.\n", ({ ob }) );
    return 0;
  }
  if(environment(ob) != this_player())
    return add_failed_mess("You can't find $I.\n", ({ ob }));
  return 1;
}
int cmd( object first, object second ) {
  object *indirect_obs;
  int cost;
  function judge_func;
  if ( !valid_weapon( this_player(), first ) ) {
    return 0;
  }
  cost = COST;
  if ( second ) {
    if ( !valid_weapon( this_player(), second ) ) {
      return 0;
    }
    cost *= 2;
    indirect_obs = ({ first, second });
    judge_func = (: judge_against :);
  } else {
    indirect_obs = ({ first });
    judge_func = (: judge_weapon :);
  }
  if ( this_player()->query_specific_gp( "other" ) < cost ) {
    add_failed_mess( "You can't muster the energy to scrutinise "
                     "$I at the moment.\n", indirect_obs );
    return 0;
  }
  this_player()->adjust_gp( -cost );
  call_out( judge_func, 0, this_player(), first, second );
  add_succeeded_mess( "$N look$s closely at $I.\n", indirect_obs );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object'weapon'>", (: cmd( $1[0], 0 ) :),
              "<indirect:object:me'weapon'> against <indirect:object:me'weapon'>",
              (: cmd( $1[0][0], $1[1][0] ) :) });
}

==================================================
FILE: guild-race/other/vurdere.c
==================================================

#include <clothing.h>
#include <weapon.h>
#define COST 5
#define SKILL "other.evaluating.armour"
#define LEARN_LEVEL 2
#define TEACH_LEVEL 10
inherit "/cmds/guild_base";
void create() {
  ::create();
  set_nroff_file("vurdere");
  set_command_name("vurdere");
  add_teach_skill(SKILL, 10, 2);
}
mixed *calc_ac( object ob ) {
  int j;
  string i;
  mapping ac;
  mixed *ret, bit;
  ac = (mapping)ob->query_armour_class();
  ret = ({ });
  foreach ( i in keys( ac ) ) {
    if ( member_array( ac[ i ][ A_TYPE ], ({ "blunt",
                                               "sharp", "pierce" }) ) == -1 )
      continue;
    bit = ac[ i ][ A_AC ];
    if( (j = member_array( ac[ i ][ A_TYPE ], ret )) == -1 ) {
      j = sizeof( ret );
      ret += ({ ac[ i ][ A_TYPE ], ({ 0, 0, 0 }) });
    }
    j++;
    if ( intp( bit ) ) {
      ret[ j ][ 1 ] += bit / 2;
      ret[ j ][ 2 ] += bit;
    } else
      switch ( sizeof( bit ) ) {
      case 1 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += bit[ 0 ];
        ret[ j ][ 2 ] += bit[ 0 ];
        break;
      case 2 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ]);
        break;
      case 3 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ]);
        break;
      default :
        write( "Barf!\n" );
      }
  }
  return ret;
}
int calc_sausage( int sausage, int lvl ) {
  int tmp;
  tmp = 99 - (lvl * 99) / 200;
  if( tmp < 0 )
    tmp = 0;
  return random( sausage ) * tmp / 100 - random( sausage ) * tmp / 100 +
    sausage;
}
string check_string( int val, int bon ) {
  int dist;
  string s;
  dist = (350 - bon) / 10;
  if( dist > (val < 0 ? -val : val) )
    return " is the same as ";
  if( val > 0 )
    s = "better than ";
  else {
    s = "worse than ";
    val -= val;
  }
  if( !val )
    return " is exactly the same as ";
  if( val < 10 )
    return " is slightly " + s;
  if( val < 20 )
    return " " + s;
  if( val < 40 )
    return " is much " + s;
  return " is amazingly " + s;
}
int cmd_against( object*from, object *to ) {
  int i, j, k, l, arm_lvl;
  object *ok, *fail;
  mixed *rat, *to_ac, *zip;
  arm_lvl = (int)this_player()->query_skill_bonus( SKILL );
  if(sizeof(from) + sizeof(to) > 10) {
    add_failed_mess("You cannot compare that many items at once.\n");
    return 0;
  }
  i = (COST*(sizeof(from)+sizeof(to)));
  if(this_player()->query_specific_gp("other") < i) {
    add_failed_mess("You cannot concentrate enough to compare these "
                       "items.\n");
    return 0;
  }
  this_player()->adjust_gp( -i);
  to_ac = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( to ); i++ ) {
    if( to[ i ]->query_armour() ) {
      rat = calc_ac( to[ i ] );
      to_ac += ({ to[ i ], rat });
    } else {
      fail += ({ to[ i ] });
      to = delete( to, i, 1 );
      i--;
    }
  }
  if( !sizeof( to ) ) {
    notify_fail( "None of " + query_multiple_short( fail ) +
                 " are armour.\n" );
    return 0;
  }
  fail = ({ });
  ok = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      if( !sizeof( to_ac ) ) {
        fail += ({ from[ i ] });
        continue;
      }
      rat = calc_ac( from[ i ] );
      zip = ({ });
      for( j = 0; j < sizeof( to_ac ); j += 2 ) {
        for( k = 0; k < sizeof( to_ac[ j + 1 ] ); k += 2 ) {
          if( (l = member_array( to_ac[ j + 1 ][ k ], rat )) == -1 ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          } else {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( (rat[ l + 1 ][ 0 ] + rat[ l + 1 ][ 1 ] +
                                  rat[ l + 1 ][ 2 ]) / 3 -
                                 (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          }
          zip += ({ to_ac[ j + 1 ][ k ] });
        }
        for( k = 0; k < sizeof( rat ); k += 2 ) {
          if( member_array( rat[ 0 ], zip ) ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] +
                                      rat[ j + 1 ][ 2 ]) / 3, arm_lvl ) +
                   to_ac[ j ]->short() + " at " + rat[ j ] + ".\n" );
          }
        }
      }
      if(member_array(from[i], ok) == -1) {
        ok += ({ from[ i ] });
      }
    } else {
      if(member_array(from[i], fail) == -1) {
        fail += ({ from[ i ] });
      }
    }
  }
  if( sizeof( fail ) ) {
    add_failed_mess( "Failed to compare " + query_multiple_short( fail ) +
                 " against " + query_multiple_short( to ) + ".\n" );
    return 0;
  }
  if( sizeof( ok ) ) {
    say( this_player()->query_cap_name() + " looks closely at " +
         query_multiple_short( uniq_array( ok + to ) ) + ".\n" );
  }
  return 1;
}
int cmd_normal( object* from ) {
  int i, j;
  object *ok, *fail;
  mixed *rat, bing;
  string type, *types, *zones;
  ok = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      rat = calc_ac( from[ i ] );
      for( j = 0; j < sizeof( rat ); j += 2 ) {
        bing = (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] + rat[ j + 1 ][ 2 ]) / 3;
        bing /= 5;
        if( bing >= 10 ) {
          bing = 9;
        }
        if( bing < 0 ) {
          bing = 0;
        }
        write( from[ i ]->the_short() + ({ " is terrible",
                                       " is amazingly poor",
                                       " is pretty poor",
                                       " is poor",
                                       " is ok",
                                       " is average",
                                       " is good",
                                       " is very good",
                                       " is extremely good",
                                       " is excellent", })[ bing ] +
                                       " at stopping " + rat[ j ] +
                                       " attacks.\n" );
        ok += ({ from[ i ] });
      }
      if(!arrayp(from[i]->query_type())) {
        types = ({ from[i]->query_type() });
      } else {
        types = from[i]->query_type();
      }
      zones = ({ });
      foreach(type in types) {
        if(CLOTHING_HANDLER->query_equivilant_type(type)) {
          zones += CLOTHING_HANDLER->query_zone_names(CLOTHING_HANDLER->query_equivilant_type(type));
        } else {
          zones += CLOTHING_HANDLER->query_zone_names(type);
        }
      }
      if(!sizeof(zones)) {
      	write(from[i]->the_short() +
              " does not protect any parts of your body.\n");
      } else {
        write(from[i]->the_short() + " protects your " +
              query_multiple_short(zones, "poss") + ".\n");
      }
      continue;
    }
    fail += ({ from[ i ] });
  }
   from = uniq_array( from );
  if( !sizeof( ok ) ) {
    notify_fail( "You failed to vurdere " + query_multiple_short( from ) +
                 ".\n" );
    return 0;
  }
    ok = uniq_array( ok );
  say( this_player()->query_cap_name() + " peers carefully at " +
       query_multiple_short( ok ) + ".\n" );
  return 1;
}
int teach( object ob ) {
  if( this_player()->query_skill( SKILL ) < TEACH_LEVEL )
    return -1;
  if( ob->query_skill( SKILL ) < LEARN_LEVEL )
    return -2;
  ob->add_known_command( "vurdere" );
  return 1;
}
mixed* query_patterns() {
   return ({ "<indirect:object:me'from'> against <indirect:object:me'to'>",
                (: cmd_against($1[0], $1[1]) :),
             "<indirect:object:me'normal'>",
                (: cmd_normal($1) :) });
}

==================================================
FILE: playtester/check.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
string query_applicant_text();
string pt_protected();
varargs int cmd(string check, string name) {
  object ob = environment (this_player());
  int min, max;
  mixed *chats;
  mixed *chatsd, *chatsn;
  string day, night;
  string ret = "";
  int count;
  mixed *args, *args1;
  if (ob->query_property ("restrict check")) {
    this_player()->add_failed_mess (this_object(), "The use of the check "
      "command in this room has been restricted.\n", ({ }));
    return 0;
  }
  switch (check) {
    case "chats":
      args= ob->query_room_chats();
      chatsd = ob->query_room_day_chats();
      chatsn = ob->query_room_night_chats();
      if (!args && !sizeof (chatsd) && !sizeof (chatsn)) {
        tell_object (this_player(), "There are no chats defined here.\n");
        return 1;
      }
      if (args) {
         min = args[0];
         max = args[1];
         if (!arrayp(args[2])) {
            ret += "%^BOLD%^%^RED%^Error in the room chats!%^RESET%^\n";
            chats = ({ });
         } else {
            chats = args[2];
         }
      } else {
         chats = ({ });
      }
      if (sizeof (chats)) {
        ret = "This room has the following chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          if (!stringp(chats[i])) {
             ret += "%^BOLD%^%^RED%^Broken chat setup in room.%^RESET%^\n";
             break;
          }
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
      if (sizeof (chatsd)) {
        min = chatsd[0];
        max = chatsd[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room day chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsd[2];
        }
        ret += "\n\nThis room has the following day chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
      if (sizeof (chatsn)) {
        min = chatsn[0];
        max = chatsn[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room night chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsn[2];
        }
        ret += "\n\nThis room has the following night chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
    break;
    case "long":
      day = ob->query_day_long();
      night = ob->query_night_long();
      ret = "Day long description:\n\n" + day;
      ret += "\n\nNight long description:\n\n" + night;
    break;
    case "items":
      ob = ob->query_item();
      if (!ob) {
        ret = "%^CYAN%^There are no add_items defined in this room.%^RESET%^\n";
      }
      else {
        args = ob->query_shrt();
        args1 = ob->query_lng();
        count = sizeof (args);
        ret += "%^YELLOW%^Main items:%^RESET%^\n";
        for (int i = 0; i < count; i++) {
          if (!sizeof (args[i])) {
            continue;
          }
          ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args1[i]) ?  ("*" + evaluate (args1[i]) + "*") : args1[i]);
          ret += "\n\n";
        }
        args = ob->query_day_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no day items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Day Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";
          }
        }
        args = ob->query_night_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no night items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Night Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";
          }
        }
      }
    break;
    case "day items":
      args = ob->query_day_items();
      if (!sizeof (args)) {
        ret += "There are no day items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";
        }
      }
    break;
    case "night items":
      args = ob->query_night_items();
      if (!sizeof (args)) {
        ret += "There are no night items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";
        }
      }
    break;
    case "protected":
      if (!PLAYTESTER_HAND->query_exec_access(this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "This facility is "
          "available only to PT Executives.\n", ({ }));
        return 0;
      }
      else {
        ret = pt_protected();
      }
    break;
  }
  write("$P$Items$P$" + ret);
  return 1;
}
private string time_string( int time_elapsed ) {
    string retval = "";
    int sec = time_elapsed % 60;
    int min = ( time_elapsed / 60 ) % 60;
    int hour = time_elapsed / 3600;
    if ( hour > 0 )
        retval += hour + "h";
    if ( min > 0 )
        retval += min + "m";
    if ( sec > 0 )
        retval += sec + "s";
    if ( sizeof( retval ) == 0 )
        return "0s";
    return retval;
}
int do_check_quota() {
    string* bits;
    string shortdate;
    int* spam;
    int reports;
    int age;
    int curage;
    mapping spamtoo;
    bits = explode( ctime( time() ), " " ) - ({ "" });
    shortdate = bits[ 1 ] + " " + bits[ 4 ];
    spamtoo = PLAYTESTER_HAND->
        query_bugs( this_player()->query_name() );
    if ( mapp( spamtoo ) ) {
        spam = spamtoo[ shortdate ];
        if ( arrayp( spam ) ) {
            reports = spam[ 0 ];
            age = spam[ 1 ];
            curage = PLAYTESTER_HAND->get_age_uncached(this_player()->query_name());
            age += curage - spam[2];
            tell_object( this_player(), "This month (" + shortdate + "), you "
                         "have made " + reports + " report" +
                         ( ( reports == 1 ) ? "" : "s" ) +  " in " +
                         time_string( age ) + " online.\n" );
            return 1;
        } else {
            tell_object( this_player(), "You cannot check your playtester "
                         "quota.\n" );
            return 1;
        }
    } else {
        tell_object( this_player(), "You cannot check your playtester "
                     "quota.\n" );
        return 1;
    }
}
int cmd_chats(object* obs) {
   mixed* chats;
   string ret;
   int i;
   object ob;
   ret = "";
   foreach (ob in obs) {
      ret += "$I$0=%^YELLOW%^$C$" + ob->the_short() + "%^RESET%^:\n";
      chats = ob->query_chat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_achat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Attack Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_chats();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Item Chats:%^RESET%^ (Min time " + chats[0] + ", "
                "Max time " + chats[1] + ")\n";
         foreach (string story in chats[2]) {
            ret += "$I$6=   " + story + "\n";
         }
      }
   }
   write("$P$Npc/Item chats$P$" + ret);
   return 1;
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "{chats|long|items|day items|night items|"
        "protected}", (: cmd($4[0]) :),
      "chats <indirect:object>",
        (: cmd_chats :),
      "quota", (: do_check_quota :),
    });
    return patterns;
}
string pt_protected() {
  object *obs = filter (users(), (: $1->query_playtester() :));
  string ret = "";
  obs = filter (obs, (: $1->query_pt_protection() :));
  if (!sizeof(obs)) {
    tell_object (this_player(), "No-one is currently using PT Protection.\n");
  }
  else {
    ret += "The following people have PT protection enabled:\n\n";
    foreach (object ob in obs) {
      ret += sprintf ("%s: %s (%s).\n\n", ob->query_name(),
        environment(ob)->query_short(), base_name (environment (ob)));
    }
  }
  return ret;
}

==================================================
FILE: playtester/comment.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
varargs int cmd(string name, string comment) {
  object ob = load_object (PT_APPLICATION_HANDLER);
  string ret = "";
  int i;
  if (!ob) {
    this_player()->add_failed_mess (this_object(), "Horrible, horrible "
      "error!\n", ({ }));
    return 0;
  }
  if (!sizeof (comment)) {
    this_player()->do_edit(0, "comment_editor", this_object(), "", name);
  }
  else {
    i =  ob->do_comment (name, comment);
    if (i) {
      tell_object (this_player(), "Thank you for your comments.\n");
    }
    else {
      tell_object (this_player(), "No candidate of that name registered.\n");
    }
  }
  return 1;
}
mixed* query_patterns() {
   return ({
      "<word'name'> <string'comment'>", (: cmd($4[0], $4[1]) :),
      "<word'name'>", (: cmd ($4[0]) :),
  });
}
void comment_editor (string comment, string name) {
  object ob = load_object (PT_APPLICATION_HANDLER);
  int i;
  if (!sizeof (comment)) {
    return;
  }
  else {
   i =  ob->do_comment (name, comment);
  }
  if (i) {
    tell_object (this_player(), "Thank you for your comments.\n");
  }
  else {
    tell_object (this_player(), "No candidate of that name registered.\n");
  }
}

==================================================
FILE: playtester/jumps.c
==================================================

#include <playtesters.h>
#define LOG_FILE PT_LOGS + "badge_log"
inherit "/cmds/base";
void log_attackers (object);
int do_list() {
   mapping jumps;
   string str;
   string start;
   string tmp;
   string* dest;
   object there;
   object to_there;
   object* theres;
   jumps = PLAYTESTER_HAND->query_jump_points();
   if (!sizeof(jumps)) {
      add_failed_mess("No current jumps.\n");
      return 0;
   }
   str = "Current jumps:\n";
   foreach (start, dest in jumps) {
      if ( !( there = find_object( start ) ) ) {
         catch(load_object(start));
         there = find_object( start );
         if ( !there ) {
           str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                           start, "Someone happy" );
           continue;
         }
      }
      theres = ({ });
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              continue;
            }
         }
         theres += ({ to_there });
      }
      str += "$I$6= * From " + there->the_short() + " [" +
             explode(start, "/")[1] + "] you can get to " +
             query_multiple_short(theres, "the") + ".\n";
   }
   write("$P$Jump points$P$" + str);
   return 1;
}
int do_list_from_here() {
   string* dest;
   string here;
   string str;
   string tmp;
   object to_there;
   int pos;
   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (sizeof(dest)) {
      str = "";
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%s will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              return 1;
            }
         }
         str += sprintf("$I$6=   %c: %s\n", pos + 'A', to_there->the_short());
         pos++;
      }
      write("$I$3=From here you can get to:\n" + str);
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}
int do_jump(string id) {
   string here;
   string* dest;
   string real_dest;
   object to_there;
   int pos;
   if (strlen(id) > 1) {
      add_failed_mess("The id to jump to must be a single letter.\n");
      return 0;
   }
   id = lower_case(id);
   pos = id[0] - 'a';
   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (!sizeof(dest)) {
      add_failed_mess("There are no jump points here.\n");
      return 0;
   }
   if (pos < 0 || pos >= sizeof(dest)) {
      add_failed_mess("The id must be in 'A'..'" +
                      sprintf("%c", sizeof(dest) + 'A') + "'.\n");
      return 0;
   }
   real_dest = dest[pos];
   if (real_dest) {
      if ( !( to_there = find_object( real_dest ) ) ) {
         catch(load_object(real_dest));
         to_there = find_object( real_dest );
         if ( !to_there ) {
           write(sprintf( "$I$3=%s will not load, please contact %s.\n",
                           real_dest, "Someone happy" ) );
           return 1;
         }
      }
      catch( log_attackers( this_player() ) );
      write( "Moving you to "+ to_there->the_short() +"...\n" );
      this_player()->move_with_look( to_there,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}
int do_armoury() {
   string env;
   string ret;
   object ob;
   env = file_name(environment(this_player()));
   if (environment(this_player())->query_armoury()) {
        ret = this_player()->query_property("pt return");
        if (ret) {
           if (strsrch(ret, "#") != -1) {
              if (!find_object(ret)) {
                 ret = 0;
              }
            } else if (!load_object (ret)) {
              ret = 0;
            }
        }
        if (!ret) {
           ret = this_player()->query_start_pos();
        }
      write( "Moving you from the pt armoury.\n");
      this_player()->move_with_look( ret,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   } else {
      catch( log_attackers( this_player() ) );
      write( "Moving you to the pt armoury.\n");
      if (explode (env,"/")[1] != "playtesters") {
        this_player()->add_property("pt return", env);
      }
      this_player()->move_with_look( PLAYTESTER_ARMOURY,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   }
   return 1;
}
protected void log_attackers( object o ) {
    string s;
    object* obs;
    object e;
    if ( sizeof( obs = o->query_attacker_list() ) > 0 ) {
        tell_object( o, "%^BOLD%^%^WHITE%^Please stop combat before using "
                     "the jumps command to go places.%^RESET%^\n" );
        e = environment( o );
        obs -= ({ 0 });
        obs = filter( obs, (: environment( $1 ) == $(e) :) );
        if ( sizeof( obs ) > 0 ) {
            s = ctime( time() ) + " - " + o->query_name() + " tried to "
                "teleport out of combat from " +
                ( environment( o ) ? file_name( environment( o ) ) :
                  "NULLSPACE" ) + "; query_attacker_list() == ({ ";
            foreach ( object ob in o->query_attacker_list() ) {
                s += "\"" + ob->query_short() + "\" [" +
                    file_name( ob ) + "]";
                if ( environment( ob ) != environment( o ) )
                    s += " (not in same room: " +
                        ( environment( ob ) ?
                          file_name( environment( ob ) ) :
                          "NULLSPACE" ) + ")";
                else
                    s += " (IN SAME ROOM)";
                s += ", ";
            }
            s += "});\n\n";
            log_file( LOG_FILE, s );
        }
    }
}
mixed* query_patterns() {
   return ({ "list", (: do_list :),
             "list here", (: do_list_from_here :),
             "goto <string'id'>", (: do_jump($4[0]) :),
             "armoury", (: do_armoury :) });
}

==================================================
FILE: playtester/playtesting.c
==================================================

#include <project_management.h>
#include <playtesters.h>
inherit "/cmds/base";
string format_array (string*);
string get_output (class project*, int);
mapping _globals = ([ ]);
varargs int cmd(string bing, string bong, string proj) {
  class project temp, *tmp = ({ });
  mapping query = ([ ]);
  string *blue, *blah;
  string ret = "";
  int verbose = 0, i;
  if (!PLAYTESTER_HAND->query_tester (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "Only playtesters may "
      "use this command.\n", ({ }));
    return 0;
  }
  if (bing == "list" && sizeof (bong)) {
    if (find_object ("/d/" + lower_case (bong) + "/master")) {
      bing = "domain";
    }
    else if (PLAYTESTER_HAND->query_tester (lower_case (bong))) {
      bing = "playtester";
    }
    else {
      bing = "nomatch";
    }
  }
  switch (bing) {
    case "assignments":
      bong = lower_case (bong);
      blue = PROJECT_HANDLER->query_pt_projects (bong);
      ret = sprintf (capitalize (bong) + " $I$5=%s.\n", (sizeof (blue) ? "is "
      "assigned to the following projects: " + query_multiple_short (blue) :
      "is not currently assigned to any projects"));
    break;
    case "allassign":
      blue = sort_array (PLAYTESTER_HAND->query_playtesters(), 1);
      foreach (string b in blue) {
        blah = PROJECT_HANDLER->query_pt_projects (b);
        ret += sprintf ("$I$5=%s is assigned to %s.\n",
          capitalize (b),
          (sizeof (blah) ? query_multiple_short (blah) : "nothing"));
      }
    case "list":
      query["status"] = "playtesting";
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "domain":
      query["status"] = "playtesting";
      query["domains"] = lower_case (bong);
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "playtester":
      query["status"] = "playtesting";
      query["playtesters"] = lower_case (bong);
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "details":
    case "report":
    case "assign":
    case "unassign":
      query["status"] = "playtesting";
      query["projid"] = bong;
      temp = PROJECT_HANDLER->get_project_file (bong);
      if (!temp) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in the handler.  Remember case sensitivity.\n", ({ }));
        return 0;
      }
      if (temp->status != member_array ("playtesting", STATUS)) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in playtesting.\n", ({ }));
        return 0;
      }
      if (temp) {
        tmp += ({ temp });
      }
      verbose = 1;
    break;
    case "passign":
    case "punassign":
       temp = PROJECT_HANDLER->get_project_file (proj);
       if (temp) {
        tmp += ({ temp });
      }
    break;
  }
  if (!sizeof (tmp) && !sizeof (ret)) {
    ret += "There are no projects in playtesting for this category.\n";
  }
  else {
    switch (bing) {
      case "passign":
        blue = PROJECT_HANDLER->add_playtester (proj, ({ bong }));
        if (!sizeof (blue)) {
          ret = "You cannot perform this operation.";
        }
        else {
          ret = "You assign " + capitalize (bong) + " to project " +
            proj + ".\n";
        }
      break;
      case "punassign":
        i = PROJECT_HANDLER->remove_playtester (proj, ({ bong }));
        if (!i) {
          ret = "This project does not exist.";
        }
        else {
          ret = "You remove " + capitalize (bong) + " from project " +
            proj + ".\n";
        }
      break;
      break;
      case "list":
      case "domain":
      case "playtester":
      case "details":
        ret = get_output (tmp, verbose);
      break;
      case "report":
      tell_object (this_player(), "Please enter your report for project " +
        bong + ".\n");
      this_player()->do_edit(0, "end_of_report");
      _globals [this_player()->query_name()]  = bong;
      break;
      case "assign":
      if (!PLAYTESTER_HAND->query_exec_access
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "execs can assign themselves to projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->add_playtester (bong,
          ({ this_player()->query_name() }), this_player()->query_name());
        ret += "You assign yourself to the project " + bong;
      }
      break;
      case "unassign":
      if (!PLAYTESTER_HAND->query_exec_access
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "Execs can unassign themselves from projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->remove_playtester (bong,
          ({ this_player()->query_name() }), this_player()->query_name());
        ret += "You unassign yourself from the project " + bong;
      }
      break;
    }
  }
  if (sizeof (ret)) {
    this_player()->more_string (ret);
  }
  return 1;
}
mixed *query_patterns() {
    mixed *patterns = ({ "list", (: cmd("list") :),
    "list <word>", (: cmd ( "list", $4[0]) :),
    "details <word>", (: cmd ( "details", $4[0]) :),
    "report <word>", (: cmd ( "report", $4[0]) :),
    "assign <word>", (: cmd ("assign", $4[0]) :),
    "unassign <word>", (: cmd ("unassign", $4[0]) :),
    "assignments [for] <word>", (: cmd ("assignments", $4[0]) :),
    "assignments", (: cmd ("allassign") :),
    });
    if (PLAYTESTER_HAND->query_exec_access (this_player()->query_name())) {
      patterns += ({
        "unassign <word> from <word>", (: cmd ("punassign", $4[0], $4[1]) :),
        "assign <word> to <word>", (: cmd ("passign", $4[0], $4[1]) :),
      });
    }
    return patterns;
}
string format_array (string *tmp) {
  if (!sizeof (tmp)) {
    return "None";
  }
  return query_multiple_short (map (tmp, (: capitalize ($1) :)));
}
string get_output (class project *tmp, int verbose) {
  int i;
  string ret = "";
  if (sizeof (tmp)) {
    if (!verbose) {
      ret += "The following projects match this query:\n";
      ret += sprintf ("%-20s %-40s %s\n\n", "Project ID",
          "Name", "Domains");
      foreach (class project p in tmp ) {
        ret += sprintf ("%-20s %-40s %s\n", p->id,
          p->name, format_array (p->domains));
      }
    }
    else {
      ret += "The details for this project are:\n\n";
      foreach (class project p in tmp ) {
        i = PROJECT_HANDLER->find_project (p->id);
        ret += sprintf ("$I$5=Project ID: %s\n$I$5=Project Name: %s\n$I$5="
        "Project Leader: %s\n$I$5=Description: %s\n$I$5=Domains: %s\n$I$5="
        "Creators: %s\n$I$5=Assigned Playtesters: "
        "%s.\n$I$5=Size: %s.\n$I$5=Complexity: %s.\n$I$5=Next Rotation: %s\n"
        "$I$5=Rotation: %d of %d.\n"
        "$I$5=Guilds: %s.\n"
        "$I$5=Playtester notes: "
        "%s\n$I$5=Flagged for playtesting: %s",
        p->id, p->name, capitalize (p->leader),
        replace (p->description, ({"\n\n", "\n"})),
        format_array (p->domains), format_array (p->creators),
        format_array (p->playtesters), (p->size != -1 ? SIZE[p->size] :
        "Unknown"),
        (p->complexity != -1 ? COMPLEXITY[p->complexity] : "Unknown"),
        (PROJECT_HANDLER->query_number_rotations() > p->current_rotation ?
        ctime (PROJECT_HANDLER->next_rotation_time (i)) : "On last rotation"),
        PROJECT_HANDLER->query_rotation (i),
        PROJECT_HANDLER->query_number_rotations (i),
        (sizeof (p->guild_specific) ? query_multiple_short (p->guild_specific) :
        "All guilds"),
        (sizeof (p->pt_notes) ? p->pt_notes :
        "None"), ctime(p->last_status_change));
      }
    }
  }
  return ret;
}
void end_of_report (string body) {
  int i = 0, j;
  if (!sizeof (body)) {
    tell_object (this_player(), "No report given.  Aborting.\n");
    return;
  }
  do {
    i++;
    j = PROJECT_HANDLER->find_note (_globals[this_player()->query_name()],
      capitalize (this_player()->query_name()) + "Report" + i);
  } while (j != -1);
  PROJECT_HANDLER->add_note_to_project (_globals[this_player()->query_name()],
    capitalize (this_player()->query_name()) + "Report" + i, body,
    this_player()->query_name());
  PLAYTESTER_HAND->adjust_quota( this_player()->query_name(), 1 );
  map_delete (_globals, this_player()->query_name());
  tell_object (this_player(), "Thank you for your report!\n");
}

==================================================
FILE: playtester/ptapp_lications.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
string query_applicant_text();
varargs int cmd(string check, string name) {
  string ret = "";
  mixed args;
  switch (check) {
    case "comments":
      if (!sizeof (name)) {
        ret = PT_APPLICATION_HANDLER->get_comment_list();
      }
      else {
        ret = PT_APPLICATION_HANDLER->get_comments_on_applicant (name);
      }
    break;
    break;
    case "summary":
    case "list":
      ret = "";
      ret =   PT_APPLICATION_HANDLER->get_applicant_list();
    break;
  }
  tell_object (this_player(), ret);
  return 1;
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "list", (: cmd("list") :),
    });
  if (this_player()->query_lord() ||
    load_object ("/d/playtesters/master")->query_deputy
    (this_player()->query_name())) {
    patterns +=
    ({
      "comments",  (: cmd ("comments") :),
      "comments for <string>", (: cmd ("comments", $4[0]) :),
    });
  }
    return patterns;
}

==================================================
FILE: playtester/pterrors.c
==================================================

inherit "/cmds/base";
#include <db.h>
#include <error_handler.h>
#include <player_handler.h>
void finish_lookup(object player, int type, mixed summary) {
   string bugs;
   class error_summary error;
   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bugs.\n" + summary + "\n");
      return ;
   }
   if (!sizeof(summary)) {
      tell_object(player, "No bugs found.\n");
      return ;
   }
   bugs = "";
   foreach (error in summary) {
      bugs += "#" + error->id + " " +
              ctime(error->entry_date)[4..15] +
              " by " + error->reporter + " (" +
              error->type + " - " + error->category + " - " +
              error->status + ")";
      if (error->assigned_to) {
         bugs += " assigned to " + error->assigned_to;
      }
      bugs += "\n";
   }
   tell_object(player, "$P$Bug List$P$" + bugs);
}
int cmd() {
   string fname;
   fname = base_name(environment(this_player()));
   if (!ERROR_HANDLER->do_query_open_bugs_for_fname(fname,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int do_query(string reporter, string status) {
   class error_query query;
   query = new(class error_query);
   if (status) {
      query->status = ({ status });
   }
   query->reporter = reporter;
   if (!this_player()->query_property("pterrors order")) {
      query->order_by = ERROR_ORDER_BY_DATE;
   } else {
      query->order_by = this_player()->query_property("pterrors order");
   }
   this_player()->add_property("pterrors query", query, 120);
   return ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :));
}
int cmd_next() {
   class error_query query;
   query = this_player()->query_property("pterrors query");
   if (!query) {
      add_failed_mess("You have not done a bugs query recently enough.\n");
      return 0;
   }
   query->bug_offset += 150;
   this_player()->add_property("pterrors query", query, 120);
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int cmd_mine(string status) {
   if (!do_query(this_player()->query_name(), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int cmd_order(string order) {
   switch (order) {
   case "date" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DATE);
      break;
   case "filename" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_FILENAME);
      break;
   case "directory" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DIRECTORY);
      break;
   }
   write("Set your pterrors bug order to " + order + "\n");
   return 1;
}
int cmd_ptbugs(string name, string status) {
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("There is no player called " + name + ".\n");
      return 0;
   }
   if (!do_query(lower_case(name), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
void finish_details(object player, int type, mixed details) {
   string bugs;
   class error_complete complete;
   class error_details error;
   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bug.\n" + details + "\n");
      return ;
   }
   if (!sizeof(details)) {
      tell_object(player, "No bugs found with that id.\n");
      return ;
   }
   bugs = "";
   foreach (complete in details) {
      error = complete->details;
      bugs += "%^BOLD%^#" + error->summary->id + " " +
              ctime(error->summary->entry_date)[4..15] +
              " by " + error->summary->reporter + " (" +
              error->summary->type + " - " + error->summary->category + " - " +
              error->summary->status + ")";
      if (error->summary->assigned_to) {
         bugs += " assigned to " + error->summary->assigned_to;
      }
      bugs += "\n%^RESET%^";
      bugs += error->report;
      if (player->query_creator()) {
         bugs += error->runtime;
      }
   }
   tell_object(player, "$P$Bug #" + error->summary->id + "$P$" + bugs);
}
int cmd_bug(int bug_id) {
   if (!ERROR_HANDLER->do_query_bug_details(bug_id,
                   (: finish_details($(this_player()), $1, $2) :))) {
      add_failed_mess("Unable to lookup the bug.\n");
      return 0;
   }
   write("Looking up bug, please wait.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd :),
             "next", (: cmd_next() :),
             "mine", (: cmd_mine(0) :),
             "mine status {open|fixed|considering|denied}", (: cmd_mine($4[0]) :),
             "order {date|directory|filename}", (: cmd_order($4[0]) :),
             "player <string'name'>", (: cmd_ptbugs($4[0], 0) :),
             "player <string'name'> status {open|fixed|considering|denied}", (: cmd_ptbugs($4[0], $4[1]) :),
             "<number>", (: cmd_bug($4[0]) :) });
}

==================================================
FILE: living/accept.c
==================================================

#include <cmds/offer.h>
#include <money.h>
#include <move_failures.h>
inherit "/cmds/base";
int is_in(object ob, object source);
int do_buy(object *people) {
   object person;
   int ret;
   class offer_sale wombat;
   object *obs;
   object *moved;
   mixed *payment;
   object ob;
   int i;
   foreach (person in people) {
      wombat = this_player()->query_respond_command("sell", person);
      if (wombat) {
         obs = filter(wombat->sell_obs, (: is_in($1, $2) :),
                      wombat->seller);
         if (sizeof(obs) != sizeof(wombat->sell_obs)) {
            add_failed_mess("$I no longer has " +
                            query_multiple_short(wombat->sell_obs - obs) +
                            " to buy.\n",
                            ({ person }) );
         } else if (this_player()->query_value_in(wombat->place) <
                    wombat->value) {
            add_failed_mess("You no longer have enough money to buy " +
                            query_multiple_short(wombat->sell_obs) +
                            " from $I.\n", ({ person }));
         } else {
            payment = MONEY_HAND->query_person_payments(wombat->value,
                                                        wombat->place,
                                                        this_player(), person);
            if (!payment) {
               add_failed_mess("You no longer have the correct change "
                               "to pay for $I.\n", ({ person }) );
            } else {
               moved = ({ });
               foreach (ob in wombat->sell_obs) {
                  if (ob->move(this_player()) == MOVE_OK) {
                     moved += ({ ob });
                  }
               }
               if (sizeof(moved) != sizeof(wombat->sell_obs)) {
                  moved->move(person);
                  tell_object(person, "Unable to move " +
                                      query_multiple_short(wombat->sell_obs -
                                                           moved) +
                                      " out of your inventory, cancelling "
                                      "the sale.\n");
                  add_failed_mess("Unable to move some objects out "
                                  "of the inventory of $I, canceling sale.\n",
                                  ({ person }) );
               } else {
                  if (sizeof(payment[MONEY_PAY_CHANGE])) {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " from " + this_player()->the_short() +
                              " and give back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " to " + person->the_short() +
                              " and receive back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                  } else {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " from " + this_player()->the_short() +".\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " to " + person->the_short() + ".\n");
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_RETURN]); i += 2) {
                     this_player()->adjust_money(-payment[MONEY_PAY_RETURN][i+1],
                                                 payment[MONEY_PAY_RETURN][i]);
                     person->adjust_money(payment[MONEY_PAY_RETURN][i+1],
                                          payment[MONEY_PAY_RETURN][i]);
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_CHANGE]); i += 2) {
                     person->adjust_money(-payment[MONEY_PAY_CHANGE][i+1],
                                                 payment[MONEY_PAY_CHANGE][i]);
                     this_player()->adjust_money(payment[MONEY_PAY_CHANGE][i+1],
                                          payment[MONEY_PAY_CHANGE][i]);
                  }
                  add_succeeded_mess("$N buy$s " +
                                     query_multiple_short(wombat->sell_obs) +
                                     " from $I.\n", ({ person }) );
                  ret++;
               }
            }
         }
         this_player()->remove_respond_command("sell", person);
      } else {
         add_failed_mess("Sorry, $I has not offered to sell you anything.\n",
                         ({ person }) );
      }
   }
   return ret;
}
int is_in(object ob, object source) {
   object env;
   if (!ob) {
      return 0;
   }
   env = ob;
   do {
      env = environment(env);
      if (env == source) {
         return 1;
      }
   } while (env);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer from <indirect:living'person'>", (: do_buy($1) :) });
}
int query_theft_command() {
   return 1;
}

==================================================
FILE: living/attack.c
==================================================

inherit "/cmds/living/kill";

==================================================
FILE: living/climb.c
==================================================

#include <tasks.h>
#define TP this_player()
#define SKILL "other.movement.climbing.rock"
inherit "/cmds/base";
void fall_off( object place, int number ) {
   if ( place->query_at_bottom() ) {
      write( "You try to climb, but you can't seem to get anywhere.\n" );
      say( (string)TP->one_short() + " tries to climb, but fails.\n" );
      return;
   }
   if ( random( (int)TP->query_dex() ) < number / 20 ) {
      write( "You begin to climb, but your fatigue makes you "+
            "clumsily lose your grip.\n" );
      say( (string)TP->one_short() +
            " begins to climb but clumsily loses "+
            (string)TP->query_possessive() +" grip.\n" );
      place->fall_down( TP );
      return;
   }
   write( "You begin to climb but wobble precariously and decide to "+
         "stay put for the moment.\n" );
   say( (string)TP->one_short() +
            " begins to climb, but wobbles precariously and stops.\n" );
}
mixed cmd( string words ) {
   int difficulty;
   object place;
   mixed ghost_action;
   mixed *move;
   string *move_descs = ({ "", "", "" });
   string skill;
   place = environment( TP );
   if ( !place ) {
      add_failed_mess( "You cannot climb anything: you're in limbo!\n" );
      return 0;
   }
   move = (mixed *)place->query_move( words );
   if ( !move ) {
      if( sizeof( place->query_moves() ) )
         add_failed_mess( "You cannot climb \""+ words +"\" from here.\n" );
      else
         add_failed_mess( "There is nothing to climb here.\n" );
      return 0;
   }
   if( stringp( move[2] ) ) {
      move_descs[0] =
         "You climb "+ words +".\n";
      move_descs[1] =
         "$N slowly climb$s "+ words +" and disappears from view.";
      move_descs[2] =
         copy( move[2] );
   } else if( sizeof( move[2] ) == 3 ) {
      move_descs = copy( move[2] );
      move_descs[0] += "\n";
   } else {
      return 0;
   }
   if ( TP->query_property( "dead" ) ) {
      ghost_action = place->query_ghost_action( place );
      if ( ! ghost_action ) {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
      else if ( intp( ghost_action ) && ghost_action == 1 ) {
          add_failed_mess( "How can you climb anything?  You're dead!\n");
          return 0;
      }
      else if ( stringp( ghost_action ) ) {
          write( "As you move to climb the wall, your inherent wispiness gets "
              "the better of you, and you fall through to the other side.\n" );
          TP->move_with_look( ghost_action,
              "$N wisps through the wall with some undue haste.",
              "$N tries to climb the wall, but falls through it." );
          add_succeeded_mess( "" );
          return 1;
      }
      else if ( arrayp( ghost_action ) ) {
          write( ghost_action[ 1 ][ 0 ] + "\n" );
          TP->move_with_look( ghost_action[ 0 ],
              ghost_action[ 1 ][ 1 ], ghost_action[ 1 ][ 2 ] );
          add_succeeded_mess( "" );
          return 1;
      }
      else {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
   }
   if( intp( move[0] ) ) {
      difficulty = move[0] + (int)TP->query_loc_weight() / 10;
      skill = SKILL;
   } else if( arrayp( move[0] ) && sizeof( move[0] ) > 1 ) {
      difficulty = move[0][0] + (int)TP->query_loc_weight() / 10;
      skill = move[0][1];
      debug_printf( "Base difficulty: %d, total difficulty: %d, skill: %s\n",
                    move[0][0], difficulty, move[0][1] );
   }
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty / 2 );
   switch ( (int)TASKER->perform_task(TP, skill, difficulty,
                                      TM_COMMAND)) {
      case AWARD :
         call_out( "advance_notice", random( 60 ), TP );
      case SUCCEED :
         write( move_descs[ 0 ] );
         TP->move_with_look( move[ 1 ], move_descs[ 2 ],
               move_descs[ 1 ] );
         return 1;
      default :
         break;
   }
   difficulty = random( difficulty );
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty );
   switch ( (int)TASKER->perform_task(TP, skill,  difficulty / 2,
                                      TM_COMMAND)) {
      case AWARD :
         write( "%^YELLOW%^You manage not to fall off!%^RESET%^\n" );
      case SUCCEED :
         write( "You begin to climb but wobble precariously and decide to "+
               "stay put for the moment.\n" );
         say( (string)TP->one_short() +
               " begins to climb, but wobbles precariously and stops.\n" );
         break;
      default :
         fall_off( place, difficulty );
         break;
   }
   add_succeeded_mess("");
   return 1;
}
void advance_notice( object thing ) {
   if ( !thing )
      return;
   tell_object( thing, "%^YELLOW%^"+ ({
      "In a flash of inspiration, you realise how to balance better "+
            "when climbing.",
      "Thinking about your climb, you realise something important.",
      "You realise that you've been using better grips to climb.",
      "You realise you've discovered how to find better places to "+
            "support your feet.",
      "You find you've worked out a more sensible way to distribute "+
            "your weight as you climb.",
      "With all your climbing, you discover you've found a better way "+
            "to locate handholds."
   })[ random( 6 ) ] +"%^RESET%^\n" );
}
mixed *query_patterns() {
   return ({ "<string'direction'>", (: cmd($4[0]) :) });
}

==================================================
FILE: living/concentrate.c
==================================================

inherit "/cmds/base";
int concentrate_list( ) {
   object conc;
   conc = this_player()->query_concentrating();
   if ( !conc ) {
      write("You are not currently concentrating on "
                  "any particular opponent.\n" );
   } else {
      write("You are currently concentrating on "+
            conc->the_short() + ".\n");
   }
   return 1;
}
int concentrate(object *things ) {
   if ( sizeof( things ) > 1 ) {
      return notify_fail( "You can only concentrate on one thing at once.\n" );
   }
   if (!sizeof(this_player()->query_attacker_list())) {
      add_failed_mess("You are not fighting anyone.\n");
      return 0;
   }
   if ( things[0] == this_player() ) {
      return notify_fail( "It would be silly to concentrate on yourself.\n" );
   }
   if (member_array(things[0], this_player()->query_attacker_list()) == -1) {
     return notify_fail("You can only concentrate on people you are "
                        "fighting.\n");
   }
   if (this_player()->set_concentrating(things[0])) {
        add_succeeded_mess(({"You are now concentrating on $I.\n", "" }),
                           things);
   } else {
      add_succeeded_mess(({"Unable to concentrate on $I.\n", "" }), things);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "[on] <indirect:living>", (: concentrate($1) :),
             "", (: concentrate_list() :) });
}

==================================================
FILE: living/crawl.c
==================================================

#define EFFECTPATH "/std/effects/other/"
#define PT "/obj/handlers/playtesters"
inherit "/cmds/base";
int is_in_water( object room );
varargs int cmd( string str ) {
   if( str == "stop" ) {
      if( !this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You should be crawling first in order"
                                         " to stop doing it, don't you "
                                         "think?\n",
                                         ({ }) );
         return 0;
      };
      this_player()->stop_crawling();
      return 1;
   };
   if( !str ) {
      if( this_player()->query_property( "dead" ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You appear to be dead.  There is no "
                                         "necessity to torture your morphogenic"
                                         " arms, you know?\n",
                                         ({ }) );
         return 0;
      } else if( this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are already crawling.\n",
                                         ({ }) );
         return 0;
      } else if( is_in_water( environment( this_player() ) ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are in water at the moment, so "
                                         "crawling is impossible.\n",
                                         ({ }) );
         return 0;
      } else {
         this_player()->add_effect( EFFECTPATH + "crawling" );
         return 1;
      };
   };
}
mixed* query_patterns() {
   return ({
      "", (: cmd() :),
      "stop", (: cmd( "stop" ) :)
   });
}
int is_in_water( object room ) {
   if( inherits( "/std/water_inside.c", room ) ||
       inherits("/std/water_outside.c", room ) ||
       inherits("/std/uwater.c", room ) ) {
      return 1;
   } else
      return 0;
}

==================================================
FILE: living/crouch.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("crouch", "down", CROUCHING);
}

==================================================
FILE: living/debate.c
==================================================

#include <tasks.h>
#define EFFECT "/std/effects/religious/theological_debate"
#define HANDLER "/obj/handlers/philosophies"
#define DEBATE_MULT 4
inherit "/cmds/base";
mapping _debaters;
void create() {
   _debaters = ([ ]);
}
mixed cmd(object * indirect_obs,
          string indir_match,
          string dir_match,
          mixed *args,
          string pattern)
{
   int bonus;
   string topic;
   string type;
   string needed;
   object target;
   if (sizeof((int *)this_player()->effects_matching("debating"))) {
      return notify_fail("You are already engaged in a debate.\n");
   }
   if (_debaters[this_player()]) {
      tell_object(_debaters[this_player()][0],
                  this_player()->the_short() + " withdraws their debating "
                  "challenge from you.\n");
      map_delete(_debaters, this_player());
   }
   target = indirect_obs[0];
   if (target == this_player()) {
      return notify_fail("Debating with yourself?  Which one of your "
         "personalities are you trying to outwit?\n");
   }
   if (userp(target) && !interactive(target)) {
      return notify_fail("How can you debate anything with a net-dead "
                         "statue?\n");
   }
   topic = args[0];
   if (_debaters[target] && _debaters[target][0] == this_player()) {
      if ((_debaters[target][0] == this_player()) &&
          (_debaters[target][1] == topic)) {
         write("You accept " + (string) target->the_short() +
               "'s challenge to debate " + topic + ".\n");
         say((string) this_player()->the_short() + " accepts " +
             (string) target->the_short() + "'s challenge to debate " +
             topic + ".\n", target);
         tell_object(target, (string) this_player()->the_short() +
                     " accepts your challenge to debate " + topic + ".\n");
         map_delete(_debaters, target);
         this_player()->add_effect(EFFECT, target);
         target->add_effect(EFFECT, this_player());
         return 1;
      }
   }
   if (!HANDLER->query_philosophy(topic)) {
      return notify_fail("You cannot debate \"" + topic + "\".  You can " +
                         "debate " + query_multiple_short((string *) HANDLER->
                                                          query_philosophy_names
                                                          ()) + ".\n");
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) HANDLER->query_philosophy_bonus(topic);
   needed = (string) HANDLER->query_philosophy_needed(topic);
   if (this_player()->query_skill_bonus(type + ".points") < bonus) {
      return notify_fail(needed + " is not sufficient to debate " +
                         topic + " at the moment.\n");
   }
   if (this_player()->query_specific_gp(type) < bonus) {
      return notify_fail("You are too tired to debate " + topic +
                         " at the moment.\n");
   }
   this_player()->adjust_gp(-(bonus * DEBATE_MULT));
   write("You challenge " + (string) target->the_short() +
         " to a debate on " + topic + ".\n");
   say((string) this_player()->one_short() + " challenges " +
       (string) target->one_short() + " to a debate on " + topic + ".\n",
       target);
   tell_object(target,
               (string) this_player()->one_short() +
               " challenges you to a debate on " + topic + ".\n");
   _debaters[this_player()] = ({ target, topic });
   call_out("answer_challenge", 5, this_player(), target, topic);
   return 1;
}
void answer_challenge(object challenger,
                      object target,
                      string topic)
{
   int bonus;
   int diff;
   string type;
   if (!challenger) {
      return;
   }
   if (!target) {
      return;
   }
   if (environment(challenger) != environment(target)) {
      return;
   }
   if (!_debaters[challenger]) {
      return;
   }
   if ((_debaters[challenger][0] != target) || (_debaters[challenger][1] != topic)) {
      return;
   }
   if (pk_check(challenger, target)) {
      tell_object(target, "Use \"debate " + topic + " with " +
                  (string) challenger->query_name() +
                  "\" to accept the challenge.\n");
      return;
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) target->query_skill_bonus(type + ".points");
   diff = (int) target->query_skill_bonus(type + ".points") / 3;
   switch ((int) TASKER->perform_task(challenger, type + ".points", 2 * diff,
                                      TM_COMMAND)) {
   case AWARD:
      tell_object(challenger, "You feel " +
                  (string) HANDLER->query_philosophy_needed(topic) +
                  " surge for a moment.\n");
   case SUCCEED:
      tell_object(target, "You find yourself accepting " +
                  (string) challenger->the_short() +
                  "'s challenge to debate " + topic + ".\n");
      tell_room(environment(target),
                (string) target->the_short() + " accepts " +
                (string) challenger->the_short() + "'s challenge to debate " +
                topic + ".\n", ({ target, challenger }));
      tell_object(challenger,
                  (string) target->the_short() +
                  " accepts your challenge to debate " + topic + ".\n");
      map_delete(_debaters, target);
      this_player()->add_effect(EFFECT, target);
      target->add_effect(EFFECT, this_player());
      return;
   default:
      if (userp(target)) {
         tell_object(target, "Use \"debate " + topic + " with " +
                     (string) challenger->query_name() +
                     "\" to accept the challenge.\n");
      }
   }
}
mapping query_debaters()
{
   return _debaters;
}
mixed *query_patterns()
{
   return ({ "<word'topic'> with <indirect:living'person'>",
             (: cmd($1, $2, $3, $4, $5) :) });
}

==================================================
FILE: living/defend.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *defendees;
  things -= ({ TP });
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much defense as a ghost.\n" );
    return 0;
  }
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot defend yourself!\n");
     return 0;
  }
  if(TP->query_combat_response() != "parry") {
    add_failed_mess("Dodging out of the way will not help " +
                    query_multiple_short(things) + ".\n");
    return 0;
  }
  defendees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_defender( TP ) ) {
      defendees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( defendees ) ) {
    add_failed_mess("You cannot defend $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot defend "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will defend $I.\n",
                        "$N moves to defend $I.\n" }),
                  defendees);
  return 1;
}
int show_defenders() {
   object *defend;
   object womble;
   defend = this_player()->query_defenders();
   if (sizeof(defend)) {
      write("You are being defended by " + query_multiple_short(defend) +
            ".\n");
   } else {
      write("You are not being defended by anyone.\n");
   }
   defend = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_defenders()) != -1) {
            defend += ({ womble });
         }
      }
   }
   if (sizeof(defend)) {
      write("Of the people in this room, you are defending " +
            query_multiple_short(defend) + ".\n");
   } else {
      write("You are not defending anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_defenders() :) });
}

==================================================
FILE: living/double_quote.c
==================================================

#include "/cmds/living/lsay.c"
