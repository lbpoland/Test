# Total Tokens: 17890
# Total Files Merged: 32
# Total Characters: 59728

/team.c
==================================================

#define TEAM "/obj/handlers/team"
object player;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
}
void destruct_team_shadow() { destruct( this_object() ); }
string extra_score() {
   string team;
   team = (string)TEAM->query_group( player );
   if ( !team ) {
      call_out( "destruct_team_shadow", 1 );
      return (string)player->extra_score();
   }
   return (string)player->extra_score() +
         "You are a team member of "+ team +".\n";
}
varargs int adjust_xp( int number, int shared ) {
   int plvl, olvl, divisor;
   string team;
   object other, *others;
   if ( ( number < 0 ) || !shared )
      return (int)player->adjust_xp( number );
   team = (string)TEAM->query_group( player );
   if ( !team ) {
      call_out( "destruct_team_shadow", 1 );
      return (int)player->adjust_xp( number );
   }
   others = (object *)TEAM->query_members( team );
   if ( !others ) {
      call_out( "destruct_team_shadow", 1 );
      return (int)player->adjust_xp( number );
   }
   if ( sizeof( others ) == 1 )
      return (int)player->adjust_xp( number );
   divisor = (sizeof(others)-1/ 2);
   if(divisor)
     number /= divisor;
   plvl = (int)player->query_level() / 2;
   foreach ( other in others - ({ player }) )
      if ( objectp( other ) ) {
         if ( environment( other ) != environment( player ) )
            continue;
         olvl = (int)other->query_level();
         if ( ( olvl > plvl ) || !plvl )
            other->adjust_xp( number, 0 );
         else
            other->adjust_xp( ( number * ( 1 +
                  ( 99 * olvl ) / plvl ) ) / 100, 0 );
      }
   return (int)player->adjust_xp(number * divisor);
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
  int diff_0, diff_1, diff, width_0, width;
  string team;
  object other, *others;
  if ( ( lvl != 1 ) || intp(exp) ||
       (objectp(exp) && base_name(exp) == base_name(this_object())))
    return (int)player->add_skill_level( skill, lvl, exp );
  if(!exp)
    exp = previous_object();
  team = (string)TEAM->query_group( player );
  if ( !team ) {
    call_out( "destruct_team_shadow", 1 );
    return (int)player->add_skill_level( skill, lvl, exp );
  }
  others = (object *)TEAM->query_members( team );
  if ( !others ) {
    call_out( "destruct_team_shadow", 1 );
    return (int)player->add_skill_level( skill, lvl, exp );
  }
  if(skill == "other.perception" || skill[<7..] == ".points")
    return (int)player->add_skill_level( skill, lvl, exp );
  if ( sizeof( others ) == 1 )
    return (int)player->add_skill_level( skill, lvl, exp );
  if(!player->add_skill_level(skill, lvl, exp))
     return 0;
  diff_0 = (int)player->query_skill_bonus(skill);
  diff_1 = (int)player->query_skill(skill);
  width_0 = (int)player->stat_modify( 25 * 25, skill );
  foreach ( other in others - ({ player }) ) {
    if (!objectp( other ) )
      continue;
    if ( environment( other ) != environment( player ) )
      continue;
    if(diff_0 - (int)other->query_skill_bonus(skill) >
       diff_1 - (int)other->query_skill(skill))
      diff = diff_0 - (int)other->query_skill_bonus( skill );
    else
      diff = diff_1 - (int)other->query_skill(skill);
    width = (int)other->stat_modify( width_0, skill );
    if (random( width + diff * diff + sqrt(other->query_skill(skill)))
        < (width/2) &&
        other->add_skill_level( skill, lvl, this_object())) {
      tell_object( other, "%^YELLOW%^By watching "+
                   (string)player->the_short() +
                   ", you feel you've learnt something.%^RESET%^\n" );
    }
  }
  return 1;
}

==================================================
FILE: shadows/misc/water.c
==================================================

#include <move_failures.h>
#define SWIMMING_SKILL "other.movement.swimming"
#define STAMINA_SKILL "other.health"
#define BUOYANT_PROP "buoyancy"
#define ANCHOR_PROP "anchor"
#define GILLS_PROP "gills"
#define TROLL_RACE "troll"
object swimmer;
int bonus, buoyancy, drown_stage, swimming = 0, recheck_delay = -1;
string sweep_dir = "";
void calc_swim_bonus();
int abs( int i );
void test_sweep();
void test_float();
void test_drown();
string sweep_string( mixed *dest_other_info, int pos );
varargs int exit_command( string word, mixed verb, object thing );
int abs( int i )  {  return i < 0 ? -i : i;  }
int start_floating();
int start_swimming();
void setup_shadow( object this_swimmer )  {
   shadow( this_swimmer, 1 );
   swimmer = this_swimmer;
   calc_swim_bonus();
}
void event_enter( object ob, string message, object from )  {
   int old_bonus, old_buoy;
   if (swimmer) {
      swimmer->event_enter( ob, message, from );
   }
   old_bonus = bonus;
   old_buoy = buoyancy;
   calc_swim_bonus();
   if ( bonus != old_bonus )  test_sweep();
   if ( buoyancy != old_buoy )  {
      buoyancy += (int)ob->query_property( BUOYANT_PROP );
      test_float();
   }
   return;
}
void event_exit( object ob, string message, object to )  {
   int old_bonus, old_buoy;
   if (swimmer) {
      swimmer->event_exit(ob, message, to);
   }
   old_bonus = bonus;
   old_buoy = buoyancy;
   calc_swim_bonus();
   if ( bonus != old_bonus )  test_sweep();
   if ( buoyancy != old_buoy )  {
      buoyancy -= (int)ob->query_property( BUOYANT_PROP );
      test_float();
   }
   return;
}
void calc_swim_bonus()  {
   float pct;
   object *held;
   if ( living( swimmer )  &&
        ( held = (object *)swimmer->query_holding() ) )  {
      swimmer->calc_burden();
      bonus = (int)swimmer->query_skill_bonus( SWIMMING_SKILL ) /
                            ( sizeof( held - (object *)({ 0 }) ) + 1 );
      buoyancy = bonus - (int)swimmer->query_loc_weight() +
                      (int)swimmer->query_property( BUOYANT_PROP );
      if ( (string)swimmer->query_race() == TROLL_RACE )  buoyancy -= 300;
      if ( buoyancy < 0  &&  bonus )  {
         pct = -buoyancy / bonus;
         if ( pct < 1.0 )  {
            bonus += buoyancy;
            buoyancy = 0;
         }
         else  {
            pct -= 1.0;
            buoyancy *= pct;
            bonus = 0;
         }
      }
   } else  {
      if (swimmer) {
         bonus = (int)swimmer->query_property( ANCHOR_PROP );
         buoyancy = (int)swimmer->query_property( BUOYANT_PROP ) -
                    (int)swimmer->query_weight();
      }
   }
   return;
}
void add_property( string prop, mixed val, int time )  {
   if (swimmer) {
      swimmer->add_property( prop, val, time );
   }
   if ( prop == GILLS_PROP  &&  val > 0 )  remove_call_out("do_drown");
   if ( prop == BUOYANT_PROP  &&  val )  {
      calc_swim_bonus();
      test_float();
   }
   return;
}
void remove_property( string prop )  {
   if (swimmer) {
     swimmer->remove_property( prop );
   }
   if ( prop == GILLS_PROP )  test_drown();
   else if ( prop == BUOYANT_PROP )  {
      calc_swim_bonus();
      test_float();
   }
   return;
}
int add_skill_level( string skill, int lev )  {
   int lvl;
   if ( living(swimmer) )  {
      lvl = (int)swimmer->add_skill_level( skill, lev );
      if ( skill == SWIMMING_SKILL  &&  lev )  {
         calc_swim_bonus();
         test_sweep();
         test_float();
      }
      return lvl;
   }
   else return 0;
}
varargs int query_skill_bonus( string skill, int use_base_stats ) {
  if( ( skill == SWIMMING_SKILL ) &&
      ( !use_base_stats ) &&
      ( query_verb() != "skills" ) ) {
    calc_swim_bonus();
    return bonus;
  }
  return swimmer->query_skill_bonus(skill, use_base_stats);
}
int query_swim_bonus()  {  return bonus;  }
int query_buoyancy()  {  return buoyancy;  }
void test_sweep()  {
   mapping flows, possible;
   int total_flow, r, f, s, flow_rate;
   string *dirs, dir, *dest_dir_info;
   object room;
   s = find_call_out( "do_sweep" );
   room = environment( swimmer );
   flows = (mapping)room->query_flows();
   dest_dir_info = (string *)room->query_dest_dir();
   f = ( 300 - ( evaluate( flows[ sweep_dir ] ) - swimming * bonus ) ) / 30;
   if ( f < 0 )  f = 0;
   f += room->query_min_sweep_delay( sweep_dir );
   if ( s > f )  {
      remove_call_out( "do_sweep" );
      call_out( "do_sweep", f,
                dest_dir_info[ member_array( sweep_dir,
                                             dest_dir_info ) + 1 ] );
   }
   else if ( s == -1  ||
             (int)room->query_flow( sweep_dir ) - swimming * bonus <= 0 )  {
      remove_call_out( "do_sweep" );
      dirs = keys( flows );
      total_flow = 0;
      possible = ([ ]);
      foreach ( dir in dirs )  {
         flow_rate = evaluate( flows[ dir ] );
         if ( ( f = flow_rate - swimming * bonus ) > 0  &&  flow_rate > 0)  {
            total_flow += f;
            possible += ([ dir : f ]);
         }
      }
      r = random( total_flow );
      dirs = keys( possible );
      total_flow = 0;
      foreach ( dir in dirs )  {
         if ( r < total_flow + possible[ dir ] )  {
            sweep_dir = dir;
            f = ( 300 - possible[ dir ] ) / 30;
            if ( f < 0 )  f = 0;
            f += room->query_min_sweep_delay( dir );
            call_out( "do_sweep", f,
                      dest_dir_info[ member_array( sweep_dir,
                                                   dest_dir_info ) + 1 ] );
            return;
         }
         else total_flow += possible[ dir ];
      }
   }
   return;
}
void test_float()  {
   object room;
   int s, t;
   room = environment( swimmer );
   if ( buoyancy < 0 )  {
      remove_call_out( "do_rise" );
      s = find_call_out( "do_sink" );
      if ( !( room->query_bottom() ) )  {
         t = (300 + buoyancy) / 30;
         if ( s > t )  {
            remove_call_out( "do_sink" );
            s = -1;
         }
         if ( s == -1 )  {
            call_out( "do_sink", t + room->query_min_sweep_delay( room->
                         query_down_dir() ) );
            swimmer->add_property( "there",
                                   (string)room->query_nonfloat_mess() );
         }
      }
      else  {
         swimmer->add_property( "there", (string)room->query_bottom_mess() );
         if ( s > -1 )  remove_call_out( "do_sink" );
      }
   }
   else if ( buoyancy > bonus )  {
      remove_call_out( "do_sink" );
      s = find_call_out( "do_rise" );
      if ( !( room->query_surface() ) )  {
         t = (300 - buoyancy) / 30;
         if ( s > t )  {
            remove_call_out( "do_rise" );
            s = -1;
         }
         if ( s == -1 )  {
            call_out( "do_rise", t + room->query_min_sweep_delay( room->
                         query_up_dir() ) );
            swimmer->add_property( "there",
                                   (string)room->query_float_mess() );
         }
      }
      else if ( s > -1 )  remove_call_out( "do_rise" );
   }
   else  {
      remove_call_out( "do_rise" );
      remove_call_out( "do_sink" );
      swimmer->add_property( "there", (string)room->query_float_mess() );
   }
   return;
}
void test_drown()  {
   int delay;
   if ( environment( swimmer )->query_surface() )
      remove_call_out("do_drown");
   else if ( find_call_out( "do_drown" ) == -1  &&
             !( swimmer->query_property( GILLS_PROP ) ) )  {
      delay = (int)swimmer->query_skill_bonus( STAMINA_SKILL ) / 20;
      if ( delay < 15 )  delay = 15;
      call_out( "do_drown", delay );
      drown_stage = 0;
   }
   return;
}
void do_sweep( string dest )  {
   mixed *dest_other_info;
   object room;
   room = environment(swimmer);
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( sweep_dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( !( swimmer->query_property("player") ) )
      swimmer->move( dest,
                     replace_string( (string)room->query_sweep_in_mess(),
                                     "$F",sweep_string( dest_other_info,
                                        member_array( sweep_dir,
                                          dest_other_info ) + 1 ) ),
                     replace_string( (string)room->query_sweep_out_mess(),
                                     "$T", sweep_dir ) );
   else  {
      tell_object( swimmer, "The current pulls you " + sweep_dir + ".\n" );
      swimmer->move_with_look( dest,
                               replace_string( (string)room->
                                               query_sweep_in_mess(), "$F",
                                               sweep_string( dest_other_info,
                                                 member_array( sweep_dir,
                                                   dest_other_info ) + 1 ) ),
                               replace_string( (string)room->
                                               query_sweep_out_mess(), "$T",
                                               sweep_dir ) );
   }
   return;
}
void do_sink()  {
   string dir;
   mixed *dest_other_info;
   int i;
   object room;
   room = environment(swimmer);
   dir = (string)room->query_down_dir();
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( ( i = member_array( dir, dest_other_info ) ) > -1 )  {
      if ( !( swimmer->query_property("player") ) )
         swimmer->move( dest_other_info[ i + 1 ][0],
                        replace_string( (string)room->query_sink_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                        replace_string( (string)room->query_sink_out_mess(),
                                        "$T", dir ) );
      else  {
         tell_object( swimmer, "You sink toward the bottom.\n" );
         swimmer->move_with_look( dest_other_info[ i + 1 ][0],
                                  replace_string( (string)room->
                                                          query_sink_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                                  replace_string( (string)room->
                                                     query_sink_out_mess(),
                                                  "$T", dir ) );
      }
   }
   return;
}
void do_rise()  {
   string dir;
   mixed *dest_other_info;
   int i;
   object room;
   room = environment( swimmer );
   dir = (string)room->query_up_dir();
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( ( i = member_array( dir, dest_other_info ) ) > -1 )  {
      if ( !( swimmer->query_property("player") ) )
         swimmer->move( dest_other_info[ i + 1 ][0],
                        replace_string( (string)room->query_float_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                        replace_string( (string)room->query_float_out_mess(),
                                        "$T", dir ) );
      else  {
         tell_object( swimmer, "You drift toward the surface.\n" );
         swimmer->move_with_look( dest_other_info[ i + 1 ][0],
                                  replace_string( (string)room->
                                                     query_float_in_mess(),
                                     "$F", sweep_string( dest_other_info,
                                       i + 1 ) ),
                                  replace_string( (string)room->
                                                     query_float_out_mess(),
                                                  "$T", dir ) );
      }
   }
   return;
}
void do_drown()  {
   string *exits, up;
   int delay;
   delay = (int)swimmer->query_skill_bonus( STAMINA_SKILL ) / 5;
   if ( delay < 15 )  delay = 15;
   switch ( drown_stage )  {
      case 0:
         tell_object( swimmer, "Your lungs start to feel a bit heavy.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " begins to look a bit uncomfortable.\n", swimmer );
         call_out( "do_drown", delay );
         break;
      case 1:
         tell_object( swimmer, "Your lungs are starting to burn.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " starts to look slightly blue.\n", swimmer );
         call_out( "do_drown", delay );
         break;
      case 2:
         tell_object( swimmer, "Your lungs are fairly bursting.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " begins to look panicky.\n", swimmer);
         call_out( "do_drown", delay );
         break;
      default:
         swimmer->adjust_hp( ( 2 - drown_stage ) * 5 *
                             ( 30 - (int)swimmer->query_con() ) );
         if ( swimmer->query_hp() > 0 )  {
            call_out( "do_drown", delay );
            exits = (string *)environment( swimmer )->query_dest_dir();
            if ( member_array( up = (string)environment( swimmer )->
                                            query_up_dir(),
                               exits ) > -1 )  {
               tell_object( swimmer, "You panic and try to flee for the "
                            "surface.\n" );
               tell_room( environment( swimmer ),
                          (string)swimmer->query_short() + " panics and madly "
                          "tries to flee for the surface.\n", swimmer );
               swimmer->exit_command( up );
            }
            else  {
               up = exits[ random( sizeof( exits ) ) / 2 ];
               tell_object( swimmer, "You panic and try to flee " + up +
                            ".\n" );
               tell_room( environment( swimmer ),
                          (string)swimmer->query_short() + " panics and tries "
                          "to flee " + up + ".\n", swimmer );
               swimmer->exit_command( up );
            }
         }
         else swimmer->attack_by( environment( swimmer ) );
         break;
   }
   ++drown_stage;
   return;
}
void do_soak()  {
   swimmer->add_effect("/std/effects/other/wetness", swimmer->query_weight());
   swimmer->do_soak();
}
void cancel_sweep()  {
   remove_call_out( "do_sweep" );
   sweep_dir = "";
   return;
}
void dest_water_shadow()  {
   remove_call_out( "do_sweep" );
   remove_call_out( "do_rise" );
   remove_call_out( "do_sink" );
   remove_call_out( "do_drown" );
   remove_call_out( "do_soak" );
   remove_call_out( "test_again" );
   if (swimmer) {
      swimmer->remove_property("there");
   }
   destruct( this_object() );
   return;
}
object find_water_shadow()  {  return this_object();  }
int command_shadowed( string verb, string args )  {
   string my_mess, others_mess;
   my_mess = 0;
   if ( !( environment( swimmer )->query_surface() ) )  {
      if ( verb == "say"  ||  verb == "'" )  {
         my_mess = "You try to talk, but only generate some bubbles.";
         others_mess = (string)swimmer->query_short() + " emits a 'glub glub' "
                       "noise.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  In the process you inhale some water.\n";
            others_mess += "  In the process, " +
                           (string)swimmer->query_pronoun() + " inhales "
                           "some water.\n";
            ++drown_stage;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
      else if ( verb == "lsay" )  {
         my_mess = "You try to speak loudly, but can only produce a lot of "
                   "bubbles.";
         others_mess = (string)swimmer->query_short() + " produces a sort "
                       "of 'glooob gloob' sound.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  You also inhale a fair amount of water.\n";
            others_mess += "  " + (string)swimmer->query_pronoun() + "also "
                           "inhales a fair amount of water.\n";
            drown_stage += 2;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
      else if ( verb == "shout" )  {
         my_mess = "You try to shout, but your main effects are a muffled "
                   "'arrrble' and a lot of bubbles.";
         others_mess = (string)swimmer->query_short() + " open " +
                       (string)swimmer->query_possessive() + " mouth and "
                       "emits a muffled 'arrrble' noise.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  You also inhale about a lungful of water.\n";
            others_mess += "  " + (string)swimmer->query_pronoun() + " sucks "
                           "in a large amount of water in the process.\n";
            drown_stage += 3;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
   }
   if ( my_mess )  {
      tell_object( swimmer, my_mess );
      tell_object( environment( swimmer ), others_mess );
      return 1;
   }
   else return (int)swimmer->command_shadowed( verb, args );
}
int *set_hold( object ob, int pos )  {
   int *other, old_bonus;
   old_bonus = bonus;
   other = (int *)swimmer->set_hold( ob, pos );
   calc_swim_bonus();
   if ( old_bonus != bonus )  {
      test_sweep();
      test_float();
   }
   return other;
}
void do_death( object thing )  {
   if (swimmer) {
      swimmer->do_death( thing );
   }
   remove_call_out( "do_sweep" );
   remove_call_out( "do_rise" );
   remove_call_out( "do_sink" );
   remove_call_out( "do_drown" );
   remove_call_out( "do_soak" );
   swimmer->remove_property("there");
   return;
}
void remove_ghost()  {
  swimmer->remove_ghost();
  environment( swimmer )->event_enter( swimmer, "", 0 );
  return;
}
int *set_unhold( object ob )  {
   int *other, old_bonus;
   old_bonus = bonus;
   other = (int *)swimmer->set_unhold( ob );
   calc_swim_bonus();
   if ( old_bonus != bonus )  {
      test_sweep();
      test_float();
   }
   return other;
}
int move( mixed dest, string messin, string messout )  {
   string where, *dest_dir_info;
   int pos;
   if ( !swimmer->query_property( "dead" )  &&  living( swimmer ) )  {
      if ( objectp( dest ) )  where = file_name( dest );
      else where = dest;
      dest_dir_info = (string *)environment( swimmer )->query_dest_dir();
      pos = member_array( where, dest_dir_info ) - 1;
      if ( pos > -1  &&
           !(int)environment( swimmer )->
                    attempt_exit( dest_dir_info[ pos ], swimmer ) )  {
         notify_fail( "" );
         return MOVE_NO_DROP;
      }
   }
   return swimmer->move( dest, messin, messout );
}
int do_float()  {
   if ( !swimming )  {
      tell_object( swimmer, "You are already drifting with the current.\n" );
   }
   else  {
      tell_object( swimmer, "You stop resisting the current.\n" );
      swimming = 0;
      test_sweep();
   }
   return 1;
}
int do_swim()  {
   if ( swimming )  {
      tell_object( swimmer, "You are already fighting the current.\n" );
   }
   else  {
      tell_object( swimmer, "You start to resist the current.\n" );
      swimming = 1;
      test_sweep();
   }
   return 1;
}
void test_again()  {
   test_float();
   test_sweep();
   call_out( "test_again", recheck_delay );
}
void update_recheck( int time_out )  {
   int t;
   recheck_delay = time_out;
   if ( time_out == -1 )  {
      remove_call_out( "test_again" );
   }
   else if ( ( t = find_call_out( "test_again" ) ) == -1 )  {
      call_out( "test_again", time_out );
   }
   else if ( time_out < t )  {
      remove_call_out( "test_again" );
      call_out( "test_again", time_out );
   }
   return;
}
string sweep_string( mixed *dest_other_info, int pos )  {
   if ( pointerp( dest_other_info[pos][5] ) )  {
      return dest_other_info[pos][5][1];
   }
   else  {
      return dest_other_info[pos][5];
   }
}

==================================================
FILE: shadows/fighting/bob.c
==================================================

#include <tasks.h>
#include <weapon.h>
#define QUEST_MAX 570
#define DIFFICULTY 100
inherit "/std/effect_shadow";
string *data;
void set_data( string *words ) { data = words; }
mapping special_attack( object target ) {
    int damage;
    int skill;
    int difficulty;
    object *args;
    args = arg();
    if((object)environment(target) != (object)environment(player)) {
        tell_object(player, "Where did "+target->short()+" go?\n");
        remove_this_effect();
        return ([ ]);
    }
    if (!sizeof(match_objects_for_existence("bucket", ({ this_player() }))) &&
        !sizeof(match_objects_for_existence("apple", ({ this_player() })))) {
       add_failed_mess("You must have an apple and a bucket to use bob.\n");
       return 0;
    }
    difficulty += target->query_str() * 10;
    skill = (int)player->query_skill_bonus("fighting.combat.melee."+ data[1]);
    damage = 4 + sqrt( damage ) / 2;
    damage = 2 * damage + 8 * (random(damage)) +
             2 * damage + 8 * (random(damage));
    switch( (int)TASKER->perform_task(player, "fighting.combat.melee."+ data[1],
        difficulty, TM_COMMAND)) {
    case AWARD :
        tell_object( player, "%^YELLOW%^"+ replace( ({ "You feel that "+
              "your skill with a bucket has increased.", "You feel "+
              "more able to use a bucket.", "You seem to be a step "+
              "closer to mastering a bucket." })[ random( 3 ) ],
            "$weapon$", ( args[ 1 ] == player ? "unarmed combat" :
              (string)args[ 1 ]->a_short() ) ) +"%^RESET%^\n" );
    case SUCCEED :
        tell_object( player, "You grab hold of " +
          (string)target->the_short() + "'s head and shove it down "
          "into the bucket.\nYou scream out 'Bob for this!'\n"
          "You try and drown " + target->the_short() + ".\n");
        tell_room( environment(player),
          player->the_short() + " grabs hold of " +
          (string)target->the_short() + "'s head and shoves it down "
          "into the bucket.\n" + player->the_short() +
          " scream out 'Bob for this!'\n" +
          player->the_short() + " tries to drown " + target->the_short() +
          ".\n", ({ player, }));
        set_arg(0);
        break;
    default:
        tell_object( player, "You manage to botch your use of a bucket.\n");
        remove_this_effect();
        return 0;
    }
#ifdef DEBUG
    tell_creator("ceres", sprintf("Crush: player: %s, weapon: %s (%d), Diff: %d, Dam: %d Ski: %d\n",
        player->query_name(),
        args[ 1 ]->query_name(),
        args[1]->query_enchant(),
        difficulty, damage, skill));
#endif
    remove_this_effect();
    return ([ args[ 1 ] : ({ damage }) + data ]);
}
int tasking_done() { return 1; }
void event_death(object killed, object * others, object killer, string rmess,
                      string kmess) {
  object *args;
  player->event_death(killed, others, killer, rmess, kmess);
  args = arg();
  if ( killed == args[ 0 ] ) remove_this_effect();
}

==================================================
FILE: shadows/fighting/combat.c
==================================================

#include <obj_parser.h>
inherit "/std/effect_shadow";

==================================================
FILE: shadows/fighting/special_attack.c
==================================================

#include <tasks.h>
#define QUEST_MAX 570
#define INFORM
inherit "/std/effect_shadow";
string *data;
void set_data( string *words ) { data = words; }
mapping special_attack( object target ) {
   int i, damage, skill;
   object *args;
   mixed *attacks;
   args = arg();
   if (!args) {
      return 0;
   }
   if ( !data || ( (string)player->query_combat_attitude() != "offensive" ) ||
         ( target != args[ 0 ] ) || !args[ 1 ] ) {
      tell_object( player, "You lose the moment!\n" );
      set_arg( 0 );
      remove_this_effect();
      return ([ ]);
   }
   if ( ( (object)args[ 1 ]->query_wielded() != player ) &&
         ( args[ 1 ] != player ) ) {
      tell_object( player, "What did you do with "+
            (string)args[ 1 ]->the_short() +"?\n" );
      set_arg( 0 );
      remove_this_effect();
      return ([ ]);
   }
   if((object)environment(target) != (object)environment(player)) {
     tell_object(player, "Where did "+target->short()+" go?\n");
     remove_this_effect();
     return ([ ]);
   }
   attacks = (mixed *)args[ 1 ]->weapon_attacks( 100, target );
   if ( !sizeof( attacks ) )
   {
      return 0;
   }
   for ( i = 0; i < sizeof( attacks ); i += 4 ) {
      if (attacks[i + 2] == data[1] ||
            attacks[i + 2][0..sizeof(data[1])] == data[1] + "-")
        damage += attacks[ i ];
   }
   if ( !damage ) {
     tell_object( player, "You manage to botch your use of "+
                  ( args[ 1 ] == player ? "unarmed combat" :
                    (string)args[ 1 ]->the_short() ) +
                  " and barely launch a mediocre attack at "+
                  (string)target->the_short() +".\n" );
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre failed (no damage)", "combat");
#endif
     return 0;
   }
   skill = (int)player->query_skill_bonus( "fighting.combat.melee."+
         data[ 0 ] );
   switch( (int)TASKER->perform_task(player, "fighting.combat.melee."+data[0],
                                     damage, TM_COMMAND) ) {
      case AWARD :
        tell_object( player, "%^YELLOW%^"+ replace( ({ "You feel that "+
               "your skill with $weapon$ has increased.", "You feel "+
               "more able to use $weapon$.", "You seem to be a step "+
               "closer to mastering $weapon$." })[ random( 3 ) ],
               "$weapon$", ( args[ 1 ] == player ? "unarmed combat" :
               (string)args[ 1 ]->a_short() ) ) +"%^RESET%^\n" );
      case SUCCEED :
         tell_object( player, "You launch a powerful attack on "+
               (string)target->the_short() + ( args[ 1 ] == player ? "" :
               " with "+ (string)args[ 1 ]->the_short() ) +".\n" );
         damage = sqrt( ((damage*2/3)) * skill ) + ( damage * skill ) /
           QUEST_MAX;
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre success, damage: " +damage, "combat");
#endif
         break;
      default :
        damage = 1;
         tell_object( player, "You manage to botch your use of "+
               ( args[ 1 ] == player ? "unarmed combat" :
               (string)args[ 1 ]->the_short() ) +
               " and barely launch a mediocre attack at "+
               (string)target->the_short() +".\n" );
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre failed", "combat");
#endif
   }
   set_arg( 0 );
   remove_this_effect();
   return ([ args[ 1 ] : ({ damage }) + data ]);
}
int tasking_done() { return 1; }

==================================================
FILE: shadows/attached/path.h
==================================================

#define PATH "/std/shadows/attached/"
#define EFFECTS "/std/effects/attached/"

==================================================
FILE: shadows/attached/single_shoulder.c
==================================================

#include "path.h"
inherit "/std/effect_shadow";
private int test_sash( object thing ) {
   return (string)thing->query_type() == "sash" &&
          sizeof(thing->query_pockets());
}
private int test_for_effect( object thing ) {
   return member_array( EFFECTS +"single_shoulder",
      (string *)thing->query_wear_effects() ) != -1;
}
void check_handicap() {
   int new_arg;
   mixed old_arg;
   object *things;
   things = (object *)player->query_wearing() - ({ 0 });
   old_arg = arg();
   if (objectp(old_arg)) {
      old_arg = 0;
   }
   new_arg = sizeof( filter_array( things, (: test_sash :), this_object() ) ) *
         sizeof( filter_array( things, (: test_for_effect :), this_object() ) );
   if ( !new_arg ) {
      remove_this_effect();
      return;
   }
   new_arg /= 2;
   if ( old_arg == new_arg ) {
      return;
   }
   player->adjust_bonus_dex( old_arg - new_arg );
   set_arg( new_arg );
}
void now_worn( object thing ) {
   player->now_worn( thing );
   if ( find_call_out( "check_handicap" ) == -1 ) {
      call_out( "check_handicap", 0 );
   }
}
void now_removed( object thing ) {
   player->now_removed( thing );
   if ( find_call_out( "check_handicap" ) == -1 ) {
      call_out( "check_handicap", 0 );
   }
}

==================================================
FILE: shadows/attached/talker_response.c
==================================================

class response {
    string  sender;
    string *triggers;
    string *responses;
    int     probability;
    int     delay;
}
inherit "/std/effect_shadow";
public          object  query_listener      ( );
public  varargs void    query_responses     ( string );
public  varargs void    add_respond_to_talker_with( string, string,
                                                        string *, int, int );
public          int     delete_response     ( string, string, string * );
public          void    receive             ( string, string, string,
                                                        object * );
public          void    process_response    ( string *, string * );
private varargs int     register_listener   ( object );
private         int     compare_arrays      ( mixed *, mixed *);
mapping responses = ([ ]);
object listener;
private varargs int register_listener(object target) {
  if(objectp(target)) {
    listener = target;
  }
  else
    listener = this_object()->arg_of(this_object()->
                                effects_matching("object.talker.response")[0]);
  if(!objectp(listener))
    this_object()->delete_effect(this_object()->
                                effects_matching("object.talker.response")[0]);
  return 1;
}
public object query_listener() {
  return listener;
}
public varargs void query_responses(string key) {
  if(stringp(key)) {
    class response *womble = responses[key];
    foreach(class response cabbage in womble) {
      printf("Channel: %s\n\tChatter: %s\n", key, cabbage->sender);
      printf("\tTrigger:\n");
      foreach(string trigger in cabbage->triggers)
        printf("\t\t\"%s\"\n",trigger);
      printf("\tResponse:\n");
      foreach(string resp in cabbage->responses)
        printf("\t\t\"%s\"\n", resp);
      printf("\tProbability:\t%d\n\tDelay:\t%d\n\n",
             cabbage->probability, cabbage->delay);
    }
    return;
  } else {
    foreach(string nextkey in keys(responses)) {
      query_responses(nextkey);
    }
    return;
  }
}
public varargs void add_respond_to_talker_with(string channel, string sender,
                                               string *trigger,
                                               string *response, int probability,
                                               int delay ) {
  class response new_item;
  if(!listener)
    register_listener();
  if (!channel || !sender || !trigger || !response ){
    listener->call_out("do_command", 3, "'Err. I haven't been setup "
                       "correctly in regards to my talker!");
    return;
  }
  channel = lower_case(channel);
  if (undefinedp(responses[channel]))
    responses[channel] = ({});
  else {
      foreach(class response item in responses[channel]) {
        if(item->sender == sender && item->triggers - trigger == ({}) &&
           item->responses - response == ({}) && item->probability == probability)
            return;
      }
  }
  if(!probability)
    probability = 10;
  if(!delay)
    delay = 1;
  if(delay == -1)
    delay = 0;
  if(probability > 100)
    probability = 100;
  new_item = new(class response, sender : sender, triggers : trigger,
                 responses : response, probability : probability, delay : delay);
  responses[channel] += ({ new_item });
  return;
}
public int delete_response( string channel, string sender, string *triggers ) {
  if( sizeof(responses[channel]) !=
      sizeof(responses[channel]   = responses[channel] -
             filter(filter(responses[channel], (: $1->sender == $(sender) :)),
                    (: compare_arrays( $1->triggers, $(triggers) ) :)) ) )
    return 1;
  return 0;
}
public void receive(string channel, string sender, string text,
                    object *receivers) {
  class response response;
  if(!listener) {
    register_listener();
    return;
  }
  if(sizeof(responses) && listener->query_name() != lower_case(sender) ) {
    if(member_array(lower_case(channel), keys(responses)) > -1 &&
       responses[channel]) {
      foreach( response in responses[channel]) {
        if(response->sender == sender ||
           response->sender == "anyone" ) {
          foreach( string trigger in response->triggers ) {
            if(regexp(text, trigger)) {
              if(random(100) < response->probability) {
                call_out("process_response", response->delay,
                         response->responses,
                         ({ channel, sender, text }));
              }
              break;
            }
          }
        }
      }
    }
  } else {
    query_shadowing(this_object())->receive(channel, sender, text, receivers);
  }
}
private int compare_arrays( mixed *ar1, mixed *ar2 ) {
  int i;
  if ( !ar1 && !ar2 )
    return 0;
  if ( sizeof( ar1 ) != sizeof( ar2 ) )
    return 1;
  i = sizeof( ar1 );
  while ( i-- ) {
    if ( ar1[ i ] != ar2[ i ] ) {
      return 1;
    }
  }
  return 0;
}
public void process_response( string *commands, string *arguments) {
  if(!query_listener()) return;
  foreach(string response in commands) {
    if(response[0] == '#') {
      if(function_exists(response[1..], listener)) {
        call_other( listener, ({ response[1..] }) + arguments);
      }
    } else {
      listener->do_command(response);
    }
  }
}

==================================================
FILE: house/tworoomflat/flatN.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("front room");
   set_base_desc("a small and cosy front room" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({ "door short", "front door"}));
   add_exit("%2%", PATH+"flat%N%bed", "door");
   modify_exit("%2%", ({ "door short", "bedroom door"}));
   modify_exit("out", ({"exit mess", "$N leaves the flat.",
                         "enter mess",
                           ({ 1,
                              "$N enters from a flat.",
                              "$N enter from a flat."
                           }),
                       }) );
   modify_exit( "out", ({ "closed", 1 }) );
}

==================================================
FILE: house/tworoomflat/flatNbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%6%", PATH +"flat%N%", "door" );
   modify_exit("%6%", ({ "door short", "livingroom door" }));
}

==================================================
FILE: house/onebedhouse/Nbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "down", PATH +"%N%livingroom", "stair" );
   modify_exit("down", ({ "downgrade", 9 }));
}

==================================================
FILE: house/onebedhouse/Nhall.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%hall");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("front room");
   set_base_desc("a small hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the house.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a house.",
                               "$N enter from a house."
                               }),
                          }) );
   add_exit("%0%", PATH+"%N%livingroom", "door");
   modify_exit("%0%", ({ "door short", "livingroom door"}));
}

==================================================
FILE: house/onebedhouse/Nlivingroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a comfortable livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   add_exit("%4%", PATH+"%N%hall", "door");
   modify_exit("%4%", ({"door short", "hallway door"}));
   add_exit("up", PATH+"%N%bed", "stair");
   modify_exit("up", ({ "upgrade", 9 }));
}

==================================================
FILE: house/onebedhut/Nbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "stone paving" );
   add_surface( "ceiling", "roughly finished wood" );
   add_surface( "%0% wall", "roughly finished wood" );
   add_surface( "%2% wall", "roughly finished wood" );
   add_surface( "%4% wall", "roughly finished wood" );
   add_surface( "%6% wall", "roughly finished wood" );
   add_exit( "%4%", PATH +"%N%livingroom", "door" );
   modify_exit("%4%", ({ "door short", "living room door" }));
}

==================================================
FILE: house/onebedhut/Nlivingroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a small cramped livingroom");
   add_surface("floor", "stone paving" );
   add_surface("ceiling", "roughly finished wood" );
   add_surface("%0% wall", "roughly finished wood" );
   add_surface("%2% wall", "roughly finished wood" );
   add_surface("%4% wall", "roughly finished wood" );
   add_surface("%6% wall", "roughly finished wood" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the hut.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a hut.",
                               "$N enter from a hut."
                               }),
                          }) );
   add_exit("%0%", PATH+"%N%bed", "door");
   modify_exit("%0%", ({"door short", "bedroom door"}));
}

==================================================
FILE: house/fourbedhouse/Nbed2.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed2");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%landing1", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

==================================================
FILE: house/fourbedhouse/Nbed3.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed3");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%landing2", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

==================================================
FILE: house/fourbedhouse/Nbed4.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed4");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%4%", PATH +"%N%landing2", "door" );
   modify_exit("%4%", ({ "door short", "livingroom door" }));
}

==================================================
FILE: house/fourbedhouse/Ndiningroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%diningroom");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("spacious dining room");
   set_base_desc("a spacious dining room");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%3%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%kitchen", "corridor");
   add_exit("window", PATH+"%N%garden", "window");
}

==================================================
FILE: house/fourbedhouse/Nfamilyroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%study");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("small study");
   set_base_desc("a small study");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%6%", PATH+"%N%kitchen", "corridor");
   add_exit("%0%", PATH+"%N%garden", "door");
}

==================================================
FILE: house/fourbedhouse/Ngarden.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE_OUTSIDE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%garden");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("small garden");
   set_base_desc("a quiet and secluded garden");
   add_surface("floor", "grass");
   add_surface("%0% wall", "red brick" );
   add_surface( "%2% wall", "red brick" );
   add_surface( "%6% wall", "red brick" );
   add_exit("%4%", PATH+"%N%familyroom", "door");
   modify_exit("%4%", ({ "door short", "garden door" }));
   add_exit("window", PATH+"%N%diningroom", "window");
}

==================================================
FILE: house/fourbedhouse/Nhalf-roof.c
==================================================

#include "path.h";
inherit "/std/rooftop";
void setup() {
  set_light(100);
  set_short("half-roof");
  set_long("This is a half-roof, a piece of sloping roof halfway up the "
           "front of the house.  There is a window to the %2% and another "
           "to the %6%.\n");
  set_slope(30, "half-roof", %out%);
  add_exit("%6% window", PATH+"%N%bed2", "window");
  add_exit("%2% window", PATH+"%N%bed3", "window");
  set_wall( ({ "bottom", ({ %out", 250 }), }) );
  set_wall( ({ "move", ({ "down", 30, %out%,
                            "$N climb$s down from above to join you." }) }) );
}

==================================================
FILE: house/fourbedhouse/Nkitchen.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%kitchen");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("large kitchen");
   set_base_desc("a large kitchen");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%6%", PATH+"%N%diningroom", "corridor");
   add_exit("%4%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%familyroom", "corridor");
}

==================================================
FILE: house/fourbedhouse/Nlanding1.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%landing1");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("landing");
   set_base_desc( "a landing at the top of the stairs" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%masterbed", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit( "%4%", PATH +"%N%bed2", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
   add_exit("%2%", PATH+"%N%landing2", "corridor");
   add_exit("down", PATH+"%N%livingroom", "corridor");
   modify_exit("down", ({"downgrade", 9 }));
}

==================================================
FILE: house/fourbedhouse/Nlanding2.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("hallway");
   set_base_desc( "a hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%bed4", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit( "%4%", PATH +"%N%bed3", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
   add_exit( "%6%", PATH +"%N%landing1", "corridor" );
}

==================================================
FILE: house/fourbedhouse/Nlivingroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a large, comfortable, and sunny livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door"}));
   add_exit("%7%", PATH+"%N%diningroom", "corridor");
   add_exit("%0%", PATH + "%N%kitchen", "corridor");
   add_exit("up", PATH + "%N%landing1", "corridor");
   modify_exit("up", ({"upgrade", 9}));
   modify_exit("out", ({"message", "$N leaves the house.",
                          "enter",
                          ({ 1,
                             "$N enters from a house.",
                             "$N enter from a house." }),
                          "closed", 1,
                          "door long", "This is the front door to a house.  "
                          "It has the numerals '%N%' in brass lettering.\n",
                          }) );
}

==================================================
FILE: house/fourbedhouse/Nmasterbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%masterbed");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a huge master bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%4%", PATH +"%N%landing1", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
}

==================================================
FILE: effects/basic.c
==================================================

#include "potion_attrs.h"
int x1, x2, y1, y2;
void set_boundaries(int *min, int *max)
{
   x1 = min[0];
   x2 = max[0];
   y1 = min[1];
   y2 = max[1];
}
int *query_coordinate()
{
   return ({ (x1 + x2) / 2, (y1 + y2) / 2 });
}
#pragma no_warnings
mixed *query_attrs(int *coord)
{
   return ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
}
int query_pass_through(int *coord)
{
   return 100;
}
void install_effect()
{
   (void)POTION_SPACE_HANDLER->remove_effect(file_name(this_object()));
   (void)POTION_SPACE_HANDLER->add_effect(file_name(this_object()), x1, x2, y1, y2);
}
int sqrt(int p)
{
   int i;
   for (i = 1; i < 500; i++) if (i * i > p) return i-1;
}
int distance_within_region(int *coord)
{
   int dx, dy;
   if (x1 < 0) {
      if (x2 > 0)
         dx = (coord[0] < 0) ? -coord[0] : coord[0];
      else
         dx = (x2 - coord[0]);
   } else
      dx = coord[0] - x1;
   if (y1 < 0) {
      if (y2 > 0)
         dy = (coord[1] < 0) ? -coord[1] : coord[1];
      else
         dy = (y2 - coord[1]);
   } else
      dy = coord[1] - y1;
   return sqrt(dx * dx + dy * dy);
}
int distance_from_origin(int *coord)
{
   return sqrt(coord[0] * coord[0] + coord[1] * coord[1]);
}

==================================================
FILE: effects/object/basic_trap.c
==================================================

#include "path.h"
string query_classification() { return "object.trap.basic"; }
string query_shadow_ob() { return SHADOWS +"basic_trap"; }
int query_indefinite() { return 1; }
int beginning( object thing, int amount, int id ) {
	tell_object(find_player("ceres"), sprintf("Adding trap to %O\n",
																						thing));
	thing->set_lock_trap(thing, "trap_lock");
	return 0;
}

==================================================
FILE: effects/object/bug_effect.c
==================================================

#include <effect.h>
void beginning( object player, int time, int id ) {
   if (time == 0) {
      time = 30*60;
   }
   player->submit_ee( "create_bug", ({ 5*60, 5*60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
}
void end( object player, int time, int id ) {
}
void create_bug( object player, int time, int id ) {
   object bug;
   object room;
   string env_string;
   object *ignore;
   bug = clone_object("/obj/monster/cockroach");
   room = environment(player);
   env_string = player->the_short();
   ignore = ({ });
   while (room) {
      if (room == environment(player) && living(player)) {
         tell_object(player, env_string+" have "+bug->a_short()+
                             " suddenly pop out of your "
                             "ear.\n");
         ignore += ({ player });
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else if (living(player)) {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of it.\n", ignore);
      }
      if (living(room))
        ignore += ({ room });
      env_string = env_string + " in " + room->the_short();
      if (!environment(room))
        bug->move(room);
      room = environment(room);
   }
}
string query_classification() { return "object.bug"; }

==================================================
FILE: effects/object/cabbage.c
==================================================

#include <effect.h>
void beginning( object player, int time, int id ) {
   player->submit_ee( "make_stink", ({ 20, 20 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
}
void end( object player, int time, int id ) {
   tell_object( player, "Your stomach calms down at last.\n" );
}
void make_stink( object player, int time, int id ) {
   tell_object( player, "A huge trumpeting noise comes from your "
   "rear, closely followed by a stench of boiled cabbage.\n" );
   tell_room( environment( player ), "The smell of sprouts and cabbages from "
   + (string)player->one_short() +
         " wafts over you and you find yourself thinking of school dinners."
         "\n", player );
}
string query_classification() { return "body.smell.scent"; }
string smell_string( object player, int time ) {
   return "the delicious doughnutty smell";
}

==================================================
FILE: effects/object/death_ward.c
==================================================

#include "path.h"
string query_classification() { return "magic.ward.death"; }
string query_shadow_ob() { return SHADOWS +"death_ward"; }
int query_indefinite() { return 1; }
int beginning( object thing, int amount, int id ) { return 0; }
