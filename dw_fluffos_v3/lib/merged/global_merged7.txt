# Total Tokens: 9023
# Total Files Merged: 6
# Total Characters: 30094

k.c
==================================================

#include <armoury.h>
#include <config.h>
#ifndef  __DISTRIBUTION_LIB__
#include <priest.h>
#endif
#define CABBAGE "/obj/monster/cabbage"
#define LEMON "/obj/monster/muffled_lemon"
#define STICK "/obj/misc/boring_stick"
#define CAT "/obj/monster/present_cat"
#define BUG "/obj/misc/bug"
#define BINKY_PATH "/obj/misc/binky/"
#define BINKY_TOY (BINKY_PATH "my_binky")
#define BINKY_BRUSH (BINKY_PATH "binky_brush")
#define BINKY_COMB (BINKY_PATH "binky_comb")
#define BINKY_KEY (BINKY_PATH "binky_key")
void start_player(object pl) {
  object ob, bucket, bottle, drink, label;
  seteuid(getuid());
  bucket = ARMOURY->request_item( "bucket small", 100 );
  bucket->set_short( "champagne bucket" );
  bucket->set_long( "This metal bucket was designed for a purpose, "
    "and looks like it would fit a champagne bottle perfectly.\n" );
  bucket->add_adjective( "champagne", "wine" );
  bucket->add_alias( "cooler" );
  bucket->add_read_mess( this_player()->query_cap_name(),
    "etched characters", "general" );
  bucket->move(this_player());
  bottle = clone_object( "/obj/bottle" );
  bottle->set_max_volume( 750 );
  bottle->set_name( "bottle" );
  bottle->set_short( "champagne bottle" );
  bottle->set_main_plural( "champagne bottles" );
  bottle->add_adjective( "champagne" );
  bottle->add_alias( "champagne" );
  bottle->set_long( "An expensive-looking bottle of champagne, just right "
               "to celebrate being on " + mud_name() + ".\n" );
  bottle->set_weight( 5 );
  bottle->set_max_weight( 20 );
  bottle->set_full_weight( 25 );
  bottle->set_volume( 750 );
  bottle->set_value( 400 );
  bottle->set_leak_rate( 0 );
  drink = clone_object("/obj/reagents/generic_liquid.ob");
  drink->set_name("champagne");
  drink->set_short("fine champagne");
  drink->set_long("This is a fine champagne, $amount_size$.\n");
  drink->set_medium_alias("Champagne");
  drink->add_eat_effect("/std/effects/ingested/drunk", 500);
  drink->set_amount(750);
  drink->move(bottle);
  label = clone_object("/obj/misc/label");
  label->add_read_mess( "\n    _________________  \n"
                          "   |                 | \n"
                          "   |                 | \n"
                          "   | Vintage Century | \n"
                          "   |      of the     | \n"
                          "   |    Fruit Bat,   | \n"
                          "   |   Year of the   | \n"
                          "   |  Midnight Frog  | \n"
                          "   |                 | \n"
                          "   |_________________| \n",
                     "cursive lettering on the bottle's label", "general" );
  bottle->add_effect("/std/effects/object/label", label);
  bottle->move( bucket );
  ob = clone_object("/obj/armour");
  ob->set_name("sash");
  ob->set_long("A large colourful sash.\n");
  ob->add_read_mess( "Welcome to " + mud_name() + ", "+
                     capitalize( (string)(pl->query_name()) ) +".", 0,
                     "general");
  ob->set_type( "sash" );
  ob->set_weight(3);
  ob->set_adjective(({ "large", "colourful" }));
  ob->setup_armour(1000);
  ob->set_damage_chance(10);
  if (ob->move(pl)) {
    if (ob->move(environment(pl)))
      ob->dest_me();
  }
  pl->wear_armour( ob );
  ob = ARMOURY->request_item( "torch" );
  ob->add_read_mess( "\n" + mud_name() + " MUD, it brightens up your night!  "
                     "More torches can be purchased from the general stores "
                     "found across the Disc!", "to the wood",
                     "general" );
  ob->move( pl );
  ob = clone_object( "/d/liaison/NEWBIE/newbie_book" );
  ob->move( pl );
  pl->adjust_money( 8, "Pumpkin dollar" );
  pl->adjust_money( 100, "Pumpkin pence" );
}
void give_junk(object pl) {
  call_out("start_player", 2, pl);
}
void logged_on_times(int num) {
  object ob;
  int bing;
  this_player()->remove_property("binky level");
  switch (num) {
  case 3 :
    ob = clone_object(CABBAGE);
    if(!environment(this_player()))
      return;
    ob->move(environment(this_player()));
    ob->set_owner(this_player());
    ob->init_command("follow "+this_player()->query_name());
    tell_object(this_player(),
                "%^YELLOW%^Congratulations on logging onto " + mud_name() + " for the "
                "third time.  Please accept this cabbage as a token of our "
                "appreciation.%^RESET%^\n");
    break;
  case 10 :
    ob = clone_object("/obj/clothing");
    ob->set_name("badge");
    ob->set_type("badge");
    ob->set_short("fruitbat flavoured badge");
    ob->add_adjective(({ "fruitbat", "flavoured" }));
    ob->set_weight(1);
    ob->set_damage_chance(5);
    ob->setup_clothing(10000);
    ob->set_long("The badge is brightly fruitbat flavoured with a bit of "
                 "banana around the edges.  You are very proud to own it.\n");
    ob->add_read_mess("Congratulations on being a 10 time loginer to "
                      "" + mud_name() + " MUD!\n", 0,
                      this_player()->query_default_language());
    if (ob->move(this_player()))
      ob->move(environment(this_player()));
    tell_object(this_player(),
                "%^CYAN%^A little fruitbat flies down out of a small "
                "non-existent black hole and gives you a badge.  The "
                "fruitbat chirps excitedly at you in fruitbat and then "
                "leaps into your badge.%^RESET%^\n");
    break;
  case 42 :
    ob = clone_object("/obj/misc/paper");
    ob->add_read_mess("What do you get when you multiply 6 by nine.", 0,
                      this_player()->query_default_language());
    if (ob->move(this_player()))
      ob->move(environment(this_player()));
    tell_object(this_player(),
                "%^YELLOW%^This is your 42nd login.  You suddenly discover "
                "a piece of paper in your hand, something froths up in your "
                "mind and you just have to write it on the paper.\nAfterwards "
                "you stare blankly down at the paper not remembering what "
                "you just wrote.%^RESET%^\n");
    break;
  case 100 :
    ob = clone_object(LEMON);
    ob->set_owner(this_player());
    tell_object(this_player(),
                "%^YELLOW%^Congratulations!  You have now logged onto "
                "" + mud_name() + " 100 times.  You are now officially addicted.  "
                "This lemon will help you on your travels.%^RESET%^\n");
    break;
  case 150 :
    ob = clone_object(STICK);
    if (ob->move(this_player()))
      ob->move(environment(this_player()));
    tell_object(this_player(),
                "%^YELLOW%^This is your 150th login!  Everybody here "
                "wishes you a good time, to help you in designs we have "
                "provided this stick for you.%^RESET%^\n");
    break;
  case 200 :
    ob = clone_object(CAT);
    ob->set_owner(this_player());
    tell_object(this_player(),
                "A cat slinks in from somewhere and rubs itself up "
                "against your leg.\n");
    ob->move(environment(this_player()));
    break;
  case 512 :
    ob = clone_object(BUG);
    tell_object(this_player(),
                "A strange black noise starts to slowly grow louder and "
                "louder.  Suddenly in a bunch of silvery wiggling a black "
                "bug crawls into your inventory.\n");
    ob->move(this_player());
    break;
  case 990 :
    ob = clone_object(BINKY_KEY);
    ob->move(this_player());
    tell_object(this_player(),
                "You hear a tinkling noise in the distance which slowly "
                "grows closer.  Something sparkly and shiny drops out of "
                "the sky into your hands.  It appears to be some sort of "
                "key.\n");
    break;
  case 1000 :
    ob = clone_object(BINKY_TOY);
    ob->move(environment(this_player()));
    tell_object(this_player(),
                "You feel a chill in your bones and turn around to see "
                "a large imposing figure wearing a black coat.  He smiles "
                "down at you in a way that makes your hair stand on end "
                "and places a small horse on the ground in front of "
                "you.\nDeath says: TREAT HIM WELL AND COMB HIM OFTEN.\n");
    break;
  case 1010 :
    ob = clone_object(BINKY_COMB);
    ob->move(this_player());
    tell_object(this_player(),
                "Something black and unseen taps you on the shoulder.\n"
                "Death says: I FORGOT THIS.\n"
                "Death gives you a small ivory comb.\n");
    break;
  case 1020 :
    ob = clone_object(BINKY_BRUSH);
    ob->move(this_player());
    tell_object(this_player(),
                "You feel a brush in your hands, you wonder where this "
                "came from?\n");
    break;
  }
  bing = -this_player()->query_time_on();
  if (bing / (24 * 60 * 60) > 100) {
    this_player()->add_player_title("old man");
    this_player()->add_player_title("old woman");
  }
}

==================================================
FILE: nickname.c
==================================================

mapping map_nicknames;
void nickname_commands() {
}
mapping query_nicknames() { return map_nicknames; }
void set_nicknames(mapping map) { map_nicknames = map; }
string expand_nickname( string phrase ) {
   int i;
   string new_n, *words;
   if ( stringp( phrase ) )
      words = explode( phrase, " " );
   else
      return phrase;
   if ( !map_nicknames )
      map_nicknames = ([ ]);
   for ( i = 0; i < sizeof( words ); i++ ) {
      new_n = map_nicknames[ lower_case( words[ i ] ) ];
      if ( new_n )
         words[ i ] = new_n;
   }
   return implode( words, " " );
}

==================================================
FILE: options_control.c
==================================================

#define PLAYER_OPTIONS_CLASS
#include <player.h>
mixed query_property(string);
varargs void add_property(string,mixed,int);
private class player_options_control query_player_options() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return new(class player_options_control);
   }
   if (sizeof(options) == 4) {
      class player_options_control newbit;
      newbit = new(class player_options_control);
      newbit->follow_everyone = options->follow_everyone;
      newbit->follow_groups = options->follow_groups;
      newbit->follow_friends = options->follow_friends;
      newbit->lead_behind = options->lead_behind;
      options = newbit;
   }
   return options;
}
int query_auto_follow_group() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->follow_groups;
}
int query_auto_follow_friends() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->follow_friends;
}
int query_auto_follow_everyone() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->follow_everyone;
}
int query_lead_from_behind() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->lead_behind;
}
void set_auto_follow_group(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_groups = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_auto_follow_friends(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_friends = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_auto_follow_everyone(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_everyone = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_lead_from_behind(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->lead_behind = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_mxp_disable(int flag) {
   class player_options_control options;
   options = query_player_options();
   options->mxp_disable = 1;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
int query_mxp_disable() {
   class player_options_control options;
   options = query_player_options();
   return options->mxp_disable;
}
int is_mxp_enabled() {
#if efun_defined(has_mxp)
   if (has_mxp(this_object())) {
      return !query_mxp_disable();
   }
#endif
   return 0;
}

==================================================
FILE: parser.c
==================================================

#include <creator.h>
#include <parser.h>
#define LMASTER "/d/liaison/master"
int pos, force_string;
mixed func;
protected void create() {
  seteuid("Root");
}
mixed *parse_args(string str, string close) {
  mixed *args, *m, *m2;
  object *obs;
  string s1, s2, s3, s4, s5, s6, s7;
  int i;
  mapping map;
  args = ({ });
  while (strlen(str)) {
    while (strlen(str) && str[0] == ' ') str = str[1..<1];
    if (!strlen(str) || str[0..0] == close) return ({ args, str[1..<1] });
    switch (str[0]) {
      case '\'' :
        if (sscanf(str, "'%s'%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '`' :
        if (sscanf(str, "`%s`%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '"' :
        if (sscanf(str, "\"%s\"%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '{' :
        m = parse_args(str[1..<1], "}");
        if (!m) {
          return 0;
        }
        args += ({ m[0] });
        str = m[1];
        break;
      case '[' :
       if (sscanf(str[1..<1], "%s]%s", s1, s2) != 2) {
          printf("Unmatched [.\n");
          return 0;
        }
        str = str[1..<1];
        map = ([ ]);
        while (1) {
          m = parse_args(str, ":");
          if (!m) {
            while (strlen(str) && str[0] == ' ') {
               str = str[1..<1];
            }
            if (str[0] == ']') {
              break;
            }
          }
          if (!(m2 = parse_args(str, ","))) {
            if (!(m2 = parse_args(str, "]"))) {
              return 0;
            }
            if (sizeof(m[0])) {
              map[m[0][0]] = (sizeof(m2[0])?m2[0][0]:0);
            }
            break;
          }
          if (sizeof(m[0])) {
            map[m[0][0]] = (sizeof(m2[0])?m2[0][0]:0);
          }
        }
        args += ({ map });
        break;
      case '|' :
        if (sscanf(str, "|%s|%s", s1, s2) != 2) {
          printf("Unmatched |\n");
          return 0;
        }
        obs = WIZ_PRESENT->wiz_present(str, this_player());
        if (!sizeof(obs)) {
          args += ({ this_player() });
        } else if (sizeof(obs) == 1) {
          args += ({ obs[0] });
        } else {
          args += ({ obs });
        }
        str = s2;
        break;
      case '0'..'9' :
      case '-' :
        if (sscanf(str, "%d%s", i, str) != 2) {
          printf("Number expected.\n");
          return 0;
        }
        args += ({ i });
        break;
      default :
        s2 = s3 = 0;
        sscanf(str, "%s,%s", s4, s2);
        sscanf(str, "%s"+close+"%s", s5, s3);
        if (sscanf(str, "%s->%s", s6, s7) == 2 &&
            (!s3 || strlen(s5) > strlen(s6)) &&
            (!s2 || strlen(s4) > strlen(s6))) {
          while (s7[0] == ' ') s7 = s7[1..<1];
          if (sscanf(s7, "%s(%s", s1, s7) != 2) {
            printf("'(' expected.\nLine left unprocessed %s\n", s7);
            return 0;
          }
          obs = WIZ_PRESENT->wiz_present(s6, this_player());
          if (!sizeof(obs)) {
            printf("The object %s needs to exist.\n", s6);
            return 0;
          }
          m = parse_args(s7, ")");
          if (!m) {
             return 0;
          }
          if (sizeof(m[0]) < 6) {
             m[0] += allocate(6-sizeof(m[0]));
          }
          obs = map_array(obs, "mapped_call", this_object(), s1, m[0]);
          if (sizeof(obs) == 1) {
            args += obs;
          } else {
            args += ({ obs });
          }
          str = m[1];
          break;
        } else if (s2 && s3)
          if (strlen(s4) < strlen(s5)) {
            s1 = ",";
            str = s4;
          } else {
            s1 = close;
            s2 = s3;
            str = s5;
          } else if (s2) {
            s1 = ",";
            str = s4;
          } else if (s3) {
            s1 = close;
            s2 = s3;
            str = s5;
          } else {
            s1 = "";
            s2 = "";
          }
          obs = WIZ_PRESENT->wiz_present(str, this_player());
          if (!sizeof(obs)) {
            if (str[0] >= '0' && str[0] <= '9' || str[0] == '-') {
              sscanf(str, "%d%s", i, str);
              args += ({ i });
            } else
              args += ({ replace_string(str, "\\n", "\n") });
          } else if (sizeof(obs) == 1)
            args += ({ obs[0] });
          else
            args += ({ obs });
          str = s1+s2;
          break;
    }
    while (strlen(str) && str[0] == ' ') {
       str = str[1..<1];
    }
    if (!strlen(str)) {
      return ({ args, str });
    }
    if (str[0..0] == close) {
      return ({ args, str[1..<1] });
    }
    if (str[0] != ',') {
      printf("Parse error reading arguments, ',' or '%s' expected.\n", close);
      printf("Line left unprocessed %s\n", str);
      return 0;
    }
    str = str[1..<1];
  }
  return ({ args, str });
}
#ifdef NOPE
void inform_of_call(object ob, mixed *argv) {
  string str;
  int i;
  str = this_object()->query_cap_name() + " calls " + argv[0] + "(";
  for (i=1; i<sizeof(argv); ) {
    str += replace(sprintf("%O", argv[i]), "\n", " ");
    if (++i < sizeof(argv)) str += ",";
  }
}
#endif
protected mixed mapped_call(object ob, string func, mixed *argv) {
  return call_other(ob, func, argv ...);
}
protected int parse_frogs(string str) {
  mixed junk;
  junk = parse_args(str, ";");
  if (!junk)
    return 1;
  write("The line "+str+" returns: \n");
  printf("%O\n", junk[0]);
  return 1;
}
mixed expr();
protected mixed bit4() {
  mixed val1, val2, val3;
  if (pos < sizeof(func)) {
    if (pointerp(func[pos])) {
      return func[pos++][0];
    }
    if (stringp(func[pos])) {
      if (func[pos][0] == '$') {
        val1 = (object)this_player()->get_obvar(func[pos][1..<1]);
        pos++;
        return val1;
      }
      if (force_string) {
        force_string = 0;
        return func[pos++];
      }
      val1 = (object *)WIZ_PRESENT->wiz_present(func[pos], this_player());
      if (!sizeof(val1)) {
        return func[pos++];
      }
      pos++;
      if (sizeof(val1) == 1) {
        return val1[0];
      }
      return val1;
    }
    switch (func[pos]) {
      case TOK_OBRAC :
        pos++;
        val1 = expr();
        if (func[pos] != TOK_CBRAC) {
          printf("Mismatched brackets.\n");
        } else {
          pos++;
        }
        break;
      case TOK_SARRAY :
        pos++;
        val1 = ({ });
        while (pos < sizeof(func) &&
            func[pos] != TOK_EARRAY) {
          if (func[pos] == TOK_COMMA) {
             pos++;
          }
          val2 = expr();
          if (func[pos] != TOK_COMMA &&
              func[pos] != TOK_EARRAY) {
            printf("Error processing array.\n");
            return 0;
          }
          val1 += ({ val2 });
        }
        pos++;
        break;
      case TOK_SMAPPING :
        pos++;
        val1 = ([ ]);
        while (pos < sizeof(func) && func[pos] != TOK_EMAPPING) {
          if (func[pos] == TOK_COMMA) pos++;
          val2 = expr();
          if (func[pos] != TOK_COLON) {
            printf("Error processing mapping, expected :.\n");
            return 0;
          }
          pos++;
          val3 = expr();
          if (func[pos] != TOK_EMAPPING && func[pos] != TOK_COMMA) {
            printf("Error processing mapping, expected , or ].\n");
            return 0;
          }
          val1[val2] = val3;
        }
        printf("End of mapping.\n");
        pos++;
        break;
      default :
        printf("Broken parser....\n");
        break;
    }
  }
  return val1;
}
protected mixed do_function_call(object ob, string name, mixed stuff) {
  string found;
  object shad;
  if (objectp(ob)) {
    shad = ob;
    while ((shad = shadow(shad, 0))) {
      if ((found = function_exists(name, ob)))
        break;
    }
    if (!found && !(found = function_exists(name, ob))) {
      printf("*** function %s not found in %s ***\n",
          name, file_name(ob));
      return 0;
    } else {
      printf("*** function %s on %s found in %s ***\n", name, file_name(ob),
          found);
    }
    if ((ob != this_player()) && ob->query_property("player") &&
        !ob->query_property("no score")) {
        unguarded((: write_file,
                   (LMASTER->query_member(this_player()->query_name()) ?
                    "/d/admin/log/CALL_LIAISONS.log" :
                    "/d/admin/log/CALL_CREATORS.log" ),
                   sprintf("%s: %s (%O) called %s(%s) on %s (%O)\n",
                           ctime(time()),
                           this_player()->query_name(), this_player(),
                           name,
                           implode(stuff - ({0}), ", "), ob->query_name(),
                           ob) :));
        user_event( this_object(), "inform",
              sprintf("%s called %s(%s) on %s",
            this_player()->query_name(), name, implode(stuff - ({0}), ", "),
            ob->query_name()), "calls");
    }
    return call_other(ob, name, stuff[0], stuff[1], stuff[2],
        stuff[3], stuff[4], stuff[5]);
  }
  return 0;
}
protected mixed bit3() {
  mixed *tmp, val1, val2, val3;
  int i;
  val1 = bit4();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_CALL :
        pos++;
        force_string = 1;
        val2 = bit4();
        force_string = 0;
        if (func[pos] != TOK_OBRAC) {
          printf("Open bracket expected.\n");
        } else {
          tmp = ({ });
          pos++;
          while (pos < sizeof(func) && func[pos] != TOK_CBRAC) {
            if (func[pos] == TOK_COMMA) pos++;
            val3 = expr();
            if (func[pos] != TOK_COMMA && func[pos] != TOK_CBRAC) {
              printf("Error in function arguments.\n");
              return 0;
            }
            tmp += ({ val3 });
          }
          pos++;
        }
        if (objectp(val1)) {
          val1 = ({ val1 });
        }
        if (!pointerp(val1)) {
          printf("Array or object expected for function call.\n");
          break;
        }
        if (!stringp(val2)) {
          printf("String expected for the function call name.\n");
          break;
        }
        if (sizeof(tmp) < 6) {
          tmp += allocate(6-sizeof(tmp));
        }
        for (i=0;i<sizeof(val1);i++) {
          val1[i] = do_function_call(val1[i], val2, tmp);
        }
        if (sizeof(val1) == 1) {
          val1 = val1[0];
        }
        break;
      case TOK_SMAPPING :
        pos++;
        val2 = expr();
        if (func[pos] == TOK_DOTDOT) {
          pos++;
          val3 = expr();
          if (func[pos] != TOK_EMAPPING) {
            printf("Expected closeing ].\n");
            break;
          }
          pos++;
          if (!pointerp(val1)) {
            printf("Can only use the .. syntax on arrays.\n");
            break;
          }
          if (!intp(val2) || !intp(val3)) {
            printf("Indexes must be integers.\n");
            break;
          }
          val1 = val1[val2..val3];
          break;
        }
        if (func[pos] != TOK_EMAPPING) {
          printf("Expected closeing ].\n");
          break;
        }
        pos++;
        if (mapp(val1)) {
          val1 = val1[val2];
        } else if (pointerp(val1)) {
          if (!intp(val2)) {
            printf("Can only use integers as an index on an array.\n");
          } else if (val2 < 0 || val2 >= sizeof(val1)) {
            printf("Index out of bounds.\n");
          } else {
            val1 = val1[val2];
          }
        } else {
          printf("Can only index off arrays or mappings.\n");
        }
        break;
      default :
        return val1;
    }
  }
  return val1;
}
protected mixed bit2() {
  mixed val1, val2;
  val1 = bit3();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_MULT :
        pos ++;
        val2 = bit3();
        if ((!intp(val1) && !floatp(val1)) || (!intp(val2) && !floatp(val2))) {
          printf("Incompatible types in multiply, both must be integers.\n");
          val1 = 0;
        } else {
          val1 = val1*val2;
        }
        break;
      case TOK_DIV :
        pos ++;
        val2 = bit3();
        if ((!intp(val1) && !floatp(val1)) || (!intp(val2) && !floatp(val2))) {
          printf("Incompatible types in division, both must be integers.\n");
          val1 = 0;
        } else if (!val2) {
          printf("Division by 0 error.\n");
        } else {
          val1 = val1/val2;
        }
        break;
      default :
        return val1;
    }
  }
  return val1;
}
mixed expr() {
  mixed val1, val2;
  val1 = bit2();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_PLUS :
        pos ++;
        val2 = bit2();
        if (pointerp(val1) && !pointerp(val2)) {
          printf("Incompatible types in addition, array and something "
                 "else.\n");
          val1 = 0;
        } else {
          val1 = val1 + val2;
        }
        break;
      case TOK_MINUS :
        pos ++;
        val2 = bit2();
        if (pointerp(val1) && !pointerp(val2)) {
          printf("Incompatible types in addition, array and something "
                 "else.\n");
          val1 = 0;
        } else {
          val1 = val1 + val2;
        }
        break;
      case TOK_ASSIGN :
        pos++;
        val2 = expr();
        if (pointerp(val1) || mapp(val1)) {
          printf("Cannot use an array or mapping as a variable name.\n");
        } else {
          this_player()->set_obvar(val1, val2);
        }
        val1 = val2;
        break;
      default :
        return val1;
    }
  }
  return val1;
}
void init_expr(string expr) {
  pos = 0;
  force_string = 0;
  func = TOKENISER->tokenise(expr);
}
void finish_expr() {
  func = 0;
}
#ifdef BOOLEAN
mixed eval() {
  mixed *tmp, val1, val2;
  int i, j;
  val1 = bit2();
  while (pos < sizeof(func))
    switch(func[pos]) {
      case TOK_EQUAL :
      case TOK_GREATOR :
      case TOK_LESS :
      case TOK_GREATOREQ :
      case TOK_LESSEQ :
    }
}
#endif

==================================================
FILE: parser.h
==================================================

#define TOKENISER "/obj/handlers/tokeniser"
#include "tokenise.h"

==================================================
FILE: path.c
==================================================

private string home_dir;
private nosave string current_path;
string get_path(string str) {
   string *array;
   string *array1;
   string temp;
   int i;
   if (!str) {
      if(!home_dir) {
         home_dir = "/w/" + this_player()->query_name();
      }
      str = home_dir;
   }
   if (str == "~") {
      str = "w/"+this_player()->query_name();
   } else {
      if(str[0] == '~') {
         if(str[1] == '/') {
            sscanf(str, "~%s", temp);
            str = "/w/" + this_player()->query_name() + temp;
         } else {
            string name;
            if (sscanf(str,"~%s/%s",name,str)!=2) {
               name = extract(str,1);
               str = "w/"+name;
            } else {
               str = "w/"+name+"/"+str;
            }
         }
      } else {
         if (str[0] != '/') {
            str = current_path+"/"+str+"/";
         }
      }
      if (str == "/") {
         return "/";
      } else {
         array = explode(str,"/") - ({ "" }) ;
         array1 = ({ });
      }
      for (i = 0; i < sizeof(array); i++) {
         reset_eval_cost();
         if (array[i] == "..") {
           if (sizeof(array1)) {
             array1 = array1[0..<2];
           }
         } else if (array[i] != ".") {
           array1 += ({ array[i] });
         }
      }
      if (sizeof(array1)) {
         str = implode(array1, "/");
      } else {
         str = "";
      }
   }
   return "/"+str;
}
string *get_files( string str ) {
   int loop;
   int count;
   string *filenames;
   string rmpath;
   string temp1;
   string temp2;
   string *names;
   string *files;
   names = explode(str, " ")- ({ "" });
   if(sizeof(names) == 0) {
      return ({ });
   }
   filenames = ({ });
   for(count = 0; count < sizeof(names); count++) {
      str = names[count];
      str = rmpath = get_path(str);
      if(rmpath == "/") {
         filenames += ({ "/" });
         continue;
      }
      if(sscanf(rmpath, "%s/%s", temp1, temp2) == 2) {
         string *path_elements;
         path_elements = explode(rmpath, "/") - ({ "" });
         rmpath = implode(path_elements[0..sizeof(path_elements) - 2], "/");
      }
      files = get_dir(str);
      if(files) {
         int loop2;
         for(loop2 = 0; loop2 < sizeof(files); loop2++) {
            filenames += ({ rmpath + "/" + files[loop2] });
         }
      }
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      if(filenames[loop][0] != '/') {
         filenames[loop] = "/" + filenames[loop];
      }
   }
   return filenames;
}
string *get_cfiles(string str) {
   int loop;
   string temp, *names, temp2;
   names = explode(str, " ") - ({ "" });
   for(loop = 0; loop < sizeof(names); loop++) {
      if(sscanf(names[loop], "%s.%s", temp, temp2) != 2) {
         names[loop] += ".c";
      }
   }
   str = implode(names, " ");
   return get_files(str);
}
string query_current_path() {
   return current_path;
}
string query_home_dir() {
   return home_dir;
}
protected int set_home_dir(string dir) {
   home_dir = dir;
   return 1;
}
void set_current_path(string str) {
   current_path = str;
}
