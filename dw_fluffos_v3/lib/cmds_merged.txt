
==================================================
FILE: base.c
==================================================

void create() {
  seteuid(getuid(this_object()));
}
void dest_me() {
  if(this_object())
    destruct(this_object());
}
int clean_up() {
  dest_me();
  return 1;
}
void reset() {
  dest_me();
}

==================================================
FILE: bug_replies.c
==================================================

#include <error_handler.h>
#include <db.h>
#include <nroff.h>
#define HELP_FILE "/doc/helpdir/bug_replies"
class player_data {
   int position;
   int date;
   class error_replies* replys;
}
nosave private mapping _player_replies;
void print_menu_input();
void create() {
   _player_replies = ([ ]);
}
void print_bug_replies(object player) {
   string str;
   class error_replies* replies;
   int i;
   int pos;
   replies = _player_replies[player]->replys;
   if (!sizeof(replies)) {
      tell_object(player, "No bug replies.\n");
      return ;
   }
   pos = _player_replies[player]->position;
   str = "";
   for (i = 0; i < sizeof(replies); i++) {
      if (i == pos) {
         str += ">";
      } else {
         str += " ";
      }
      switch (replies[i]->status) {
      case "NEW" :
         str += "N";
         break;
      case "DELETED" :
         str += "D";
         break;
      default :
         str += " ";
         break;
      }
      str += (i+1) + ") " + replies[i]->sender + " Sub: " +
             replies[i]->subject + "\n";
   }
   player->set_finish_func("finish_more_replies", this_object());
   tell_object(player, "$P$Bug replies$P$" + str);
}
void finish_more_replies() {
   print_menu_input();
}
void print_menu(object player) {
   int len;
   len = sizeof(_player_replies[player]->replys);
   if (len == 0) {
      tell_object(player, "[None] QDRULH?<num>: ");
   } else {
      tell_object(player, "[1-" + len + "] QDRULH?<num>: ");
   }
}
void delete_message(int start_pos, int end_pos) {
   int pos;
   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                           "DELETED",
                                           (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "DELETED";
   }
   if (start_pos != end_pos) {
      write("Delete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Delete error reply " + (pos) + ".\n");
   }
}
void undelete_message(int start_pos, int end_pos) {
   int pos;
   for (pos = start_pos - 1; pos <= end_pos - 1; pos++) {
      ERROR_HANDLER->do_status_error_reply(_player_replies[this_player()]->replys[pos]->id,
                                        "READ",
                                        (: 1 :));
      _player_replies[this_player()]->replys[pos]->status = "READ";
   }
   if (start_pos != end_pos) {
      write("Undelete error reply " + start_pos + " from " + end_pos + ".\n");
   } else {
      write("Undelete error reply " + (pos) + ".\n");
   }
}
int valid_message(int pos) {
   pos--;
   if (pos < 0 || pos >= sizeof(_player_replies[this_player()]->replys)) {
      return 0;
   }
   return 1;
}
void print_menu_input() {
   print_menu(this_player());
   input_to("bug_replies_menu");
}
void read_message(int pos) {
   class error_replies reply;
   pos--;
   reply = _player_replies[this_player()]->replys[pos];
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string("Date Sent: " + ctime(reply->senddate) + "\n"
         "From: " + reply->sender + "\n"
         "Subject: " + reply->subject + "\n\n" +
         reply->message + "\n");
   if (reply->status == "NEW") {
      ERROR_HANDLER->do_status_error_reply(reply->id, "READ", (: 1 :));
      reply->status = "READ";
   }
}
int read_next_new() {
   int i;
   class error_replies* replies;
   replies = _player_replies[this_player()]->replys;
   for (i = 0; i < sizeof(replies); i++) {
      if (replies[i]->status == "NEW") {
         read_message(i + 1);
         return 1;
      }
   }
   write("No new unread error replies.\n");
   return 0;
}
void finish_editing_message(string mess, int pos) {
   class error_replies reply;
   if (!mess || !strlen(mess)) {
      write("Aborting send of message.\n");
   } else {
      reply = _player_replies[this_player()]->replys[pos];
      ERROR_HANDLER->do_add_error_reply(reply->id,
                             this_player()->query_name(),
                             reply->sender,
                             "Re: " + reply->subject,
                             mess);
      write("Sent message to " + reply->sender + "\n");
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}
int reply_message(int pos) {
   write("Replying to message:\n");
   pos--;
   this_player()->do_edit("", "finish_editing_message", this_object(), 0, pos);
   return 1;
}
void help_command() {
   string nroff_fn;
   string str;
   nroff_fn = HELP_FILE + ".o";
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(HELP_FILE, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   this_player()->set_finish_func("print_menu_input", this_object());
   this_player()->more_string(str);
}
void bug_replies_menu(string inp) {
   int pos;
   int new_pos;
   int end_pos;
   while (strlen(inp) && inp[0] == ' ') {
      inp = inp[1..];
   }
   while (strlen(inp) && inp[<1] == ' ') {
      inp = inp[0..<2];
   }
   end_pos = -1;
   if (!strlen(inp)) {
      if (read_next_new()) {
         return ;
      }
   } else {
      if (inp[0] >= '0' && inp[0] <= '9') {
         while (pos < strlen(inp) && inp[pos] >= '0' && inp[pos] <= '9') {
            pos ++;
         }
         pos = to_int(inp[0..pos-1]);
         if (valid_message(pos)) {
            read_message(pos);
            return ;
         } else {
            write("Message " + pos + " is invalid.\n");
         }
      } else {
         while (pos < strlen(inp) && (inp[pos] < '0' || inp[pos] > '9')) {
            pos++;
         }
         if (pos < strlen(inp)) {
            new_pos = pos + 1;
            while (new_pos < strlen(inp) && inp[new_pos] >= '0' && inp[new_pos] <= '9') {
               new_pos++;
            }
            pos = to_int(inp[pos..new_pos-1]);
            if (inp[new_pos] == '-') {
               end_pos = new_pos + 1;
               while (end_pos < strlen(inp) && inp[end_pos] >= '0' && inp[end_pos] <= '9') {
                  end_pos++;
               }
               end_pos = to_int(inp[new_pos + 1..end_pos-1]);
            }
         } else {
            pos = -1;
         }
         switch(lower_case(inp)[0]) {
         case 'q' :
            write("Exiting the system.\n");
            map_delete(_player_replies, this_player());
            return ;
         case 'r' :
            if (valid_message(pos)) {
               if (reply_message(pos)) {
                  return ;
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'd' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     delete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'u' :
            if (end_pos == -1) {
               end_pos = pos;
            }
            if (valid_message(pos)) {
               if (valid_message(end_pos)) {
                  if (end_pos >= pos) {
                     undelete_message(pos, end_pos);
                  } else {
                     write("Your end position (" + end_pos + ") must be higher "
                           "than the start position (" + pos + ").\n");
                  }
               } else {
                  write("Message " + end_pos + " is invalid.\n");
               }
            } else {
               write("Message " + pos + " is invalid.\n");
            }
            break;
         case 'h' :
         case '?' :
            help_command();
            return ;
         case 'l' :
            print_bug_replies(this_player());
            return ;
         }
      }
   }
   print_menu(this_player());
   input_to("bug_replies_menu");
}
void bug_replies_result(int type, mixed* data, object player) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error retrieving replies.\n");
   } else {
      _player_replies[player] = new(class player_data, date : time(),
                                    replys : data);
      print_bug_replies(player);
   }
}
int bug_replies(int only_new) {
  _player_replies[this_player()] = new(class player_data, date : time(),
                                replys : ({ }));
   if (ERROR_HANDLER->do_error_replies(this_player()->query_name(), only_new,
                             (: bug_replies_result($1, $2, $(this_player()) ) :))) {
      input_to("bug_replies_menu");
      return 1;
   }
   add_failed_mess("Unable to find the bug replies.\n");
   return 0;
}

==================================================
FILE: errors_base.c
==================================================

#include <db.h>
#include <log.h>
#include <config.h>
private class _report {
  int row;
  string newstatus;
  string newdir;
  string newtype;
  int changed;
}
private class _bugs {
  int fd;
  mapping errors;
  int *rows;
  string *fieldnames;
  int changed;
}
#define FD ((class _bugs)globvars[key])->fd
#define ERRORS ((class _bugs)globvars[key])->errors
#define ROWS ((class _bugs)globvars[key])->rows
#define FIELDNAMES ((class _bugs)globvars[key])->fieldnames
#define CHANGED ((class _bugs)globvars[key])->changed
private nosave mapping globvars;
protected varargs mixed get_row(mixed key, int row, int nomap);
protected varargs string init_errors(mixed key, string user, int replace) {
  string ret;
  if (!mapp(globvars)) {
    globvars = ([ ]);
  } else {
    if (!(replace || undefinedp(globvars[key]))) {
      return "key already in use";
    }
    if (globvars[key]) {
      catch(db_close(FD));
    }
  }
  globvars[key] = new(class _bugs);
  if ((ret = catch(FD = db_connect("localhost", "errors", user)))) {
    map_delete(globvars, key);
    return ret;
  }
  return 0;
}
protected string finish_errors(mixed key) {
  string ret;
  if (!classp(globvars[key])) {
    return "unknown key";
  }
  ret = catch(db_close(FD));
  map_delete(globvars, key);
  return ret;
}
protected varargs mixed sql_query(mixed key, string query, mixed *args ...) {
  string error;
  mixed ret;
  ERRORS = 0;
  ROWS = 0;
  FIELDNAMES = 0;
  error = catch(ret = db_exec(FD, query, args ...));
  if (error) {
    return error;
  }
  if (stringp(ret)) {
    return ret;
  }
  if (ret) {
    ROWS = allocate(ret + 1, (: $1 :));
  }
  return ret;
}
protected varargs mixed get_fields(mixed key, string directory,
                                   string fields, string type) {
  string query, temp;
  mixed ret;
  if (!strlen(type)) {
    type = "OPEN";
  }
  ERRORS = 0;
  ROWS = 0;
  FIELDNAMES = 0;
  fields += ", Directory";
  query = sprintf("SELECT %s FROM errors WHERE Directory = '%s' AND "
                  "Status = '%s' ORDER BY DirEntryDate;", fields, directory,
                  type);
  temp = catch(ret = db_exec(FD, query));
  if (temp) {
    return temp;
  }
  if (stringp(ret)) {
    return ret;
  }
  if (ret) {
    ROWS = allocate(ret + 1, (: $1 :));
  }
  return ret;
}
protected mixed get_forwards(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping forwards;
  int fd;
  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  query = sprintf("SELECT ForwardDate, Forwarder, OldDirectory FROM forwards "
                  "WHERE Id = %d ORDER BY ForwardDate;", ret["Id"]);
  err = catch(ret = db_exec(fd, query));
  if (err) {
    catch(db_close(fd));
    return err;
  }
  if (stringp(ret)) {
    catch(db_close(fd));
    return ret;
  }
  if (ret) {
    err = catch {
      int *dates, i;
      string *forwarders, *dirs;
      mixed *vals;
      dates = allocate(ret);
      forwarders = allocate(ret);
      dirs = allocate(ret);
      for (i = 0; i < ret; i++) {
        vals = db_fetch(fd, i + 1);
        dates[i] = vals[0];
        forwarders[i] = vals[1];
        dirs[i] = vals[2];
      }
      forwards = allocate_mapping(3);
      forwards["ForwardDate"] = dates;
      forwards["Forwarder"] = forwarders;
      forwards["OldDirectory"] = dirs;
    };
    if (err) {
      catch(db_close(fd));
      return err;
    }
  }
  catch(db_close(fd));
  return forwards;
}
protected mixed get_comments(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping comments;
  int fd;
  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  query = sprintf("SELECT CommentDate, Commenter, Comment FROM comments "
                  "WHERE Id = %d ORDER BY CommentDate;", ret["Id"]);
  err = catch(ret = db_exec(fd, query));
  if (err) {
    catch(db_close(fd));
    return err;
  }
  if (stringp(ret)) {
    catch(db_close(fd));
    return ret;
  }
  if (ret) {
    err = catch {
      int *dates, i;
      string *commenters, *texts;
      mixed *vals;
      dates = allocate(ret);
      commenters = allocate(ret);
      texts = allocate(ret);
      for (i = 0; i < ret; i++) {
        vals = db_fetch(fd, i + 1);
        dates[i] = vals[0];
        commenters[i] = vals[1];
        texts[i] = vals[2];
      }
      comments = allocate_mapping(3);
      comments["CommentDate"] = dates;
      comments["Commenter"] = commenters;
      comments["Comment"] = texts;
    };
    if (err) {
      catch(db_close(fd));
      return err;
    }
  }
  catch(db_close(fd));
  return comments;
}
protected varargs mixed get_row(mixed key, int row, int nomap) {
  mixed *res;
  string ret, *keys;
  mapping rowvals;
  if (!arrayp(FIELDNAMES)) {
    ret = catch(res = db_fetch(FD, 0));
    if (ret)
      return ret;
    keys = res;
    FIELDNAMES = res;
  } else {
    keys = FIELDNAMES;
  }
  if (!nomap) {
    row = ROWS[row];
  }
  ret = catch(res = db_fetch(FD, row));
  if (ret)
    return ret;
  if (sizeof(keys) != sizeof(res)) {
    return "Database engine lost results(?)\n";
  }
  rowvals = allocate_mapping(keys, res);
  return rowvals;
}
protected int set_status(mixed key, int row, string status) {
  int realrow = ROWS[row];
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  if (!classp(ERRORS[realrow])) {
    ERRORS[realrow] = new(class _report, row : realrow);
  }
  ((class _report)ERRORS[realrow])->newstatus = status;
  ((class _report)ERRORS[realrow])->changed = 1;
  ROWS = delete(ROWS, row, 1);
  CHANGED = 1;
  return 1;
}
protected int set_type(mixed key, int row, string type) {
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  row = ROWS[row];
  if (!classp(ERRORS[row])) {
    ERRORS[row] = new(class _report, row : row);
  }
  ((class _report)ERRORS[row])->newtype = type;
  ((class _report)ERRORS[row])->changed = 1;
  CHANGED = 1;
  return 1;
}
protected int forward_bug(mixed key, int row, string directory) {
  int realrow = ROWS[row];
  if (!mapp(ERRORS))
    ERRORS = ([ ]);
  if (!classp(ERRORS[realrow])) {
    ERRORS[realrow] = new(class _report, row : realrow);
  }
  while (directory[<1] == '/') {
    directory = directory[0..<2];
  }
  ((class _report)ERRORS[realrow])->newdir = directory;
  ((class _report)ERRORS[realrow])->changed = 1;
  ROWS = delete(ROWS, row, 1);
  CHANGED = 1;
  return 1;
}
protected string comment_bug(mixed key, int row, string who, string comment) {
  string query, err;
  int fd;
  mixed ret;
  ret = get_row(key, row);
  if (stringp(ret)) {
    return ret;
  }
  err = catch(fd = db_connect("localhost", "errors", CONFIG_DB_USER));
  if (err) {
    return err;
  }
  comment = db_escape(comment);
  query = sprintf("INSERT LOW_PRIORITY INTO comments VALUES "
                  "(%d, %d, '%s', '%s');",
                  ret["Id"], time(), who, comment);
  err = catch(ret = db_exec(fd, query));
  if (stringp(ret)) {
    err = ret;
  }
  catch(db_close(fd));
  return err;
}
private string save_status(mixed key, int *ids, string user, string status) {
  string query, ret, err;
  mixed res;
  ret = "";
  if (sizeof(ids)) {
    if (sizeof(ids) == 1) {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id = %d;", status,
                      time(), user, ids[0]);
    } else {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id IN (%s);", status,
                      time(), user, implode(ids, (: "" + $1 + ", " + $2 :)));
    }
    err = catch(res = db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  return ret;
}
protected string save_changes(mixed key, string user) {
  class _report *reports, report;
  string query, *queries, ret, err;
  int *ids_fixed, *ids_denied, *ids_fixing, *ids_considering, *ids_open, ftime;
  mixed res, row;
  if (!CHANGED) {
    return 0;
  }
  reports = filter(values(ERRORS), (: ((class _report)$1)->changed :));
  ids_fixed = ids_denied = ids_fixing = ids_considering = ids_open = queries = ({ });
  ret = "";
  foreach (report in reports) {
    row = get_row(key, report->row, 1);
    if (stringp(row)) {
      ret += row;
      continue;
    }
    switch (report->newstatus) {
    case "FIXED":
      ids_fixed += ({ row["Id"] });
      break;
    case "DENIED":
      ids_denied += ({ row["Id"] });
      break;
    case "FIXING":
      ids_fixing += ({ row["Id"] });
      break;
    case "CONSIDERING":
      ids_considering += ({ row["Id"] });
      break;
    case "OPEN":
      ids_open += ({ row["Id"] });
      break;
    case 0:
    case "":
      if (report->newdir) {
        ftime = time();
        query = sprintf("UPDATE LOW_PRIORITY errors SET Directory = '%s', "
                        "DirEntryDate = %d WHERE Id = %d;",
                        report->newdir, ftime, row["Id"]);
        queries += ({ query });
        query = sprintf("INSERT LOW_PRIORITY INTO forwards VALUES "
                        "(%d, %d, '%s', '%s');",
                        row["Id"], ftime, user, row["Directory"]);
        queries += ({ query });
      }
      if (report->newtype) {
        query = sprintf("UPDATE LOW_PRIORITY errors SET Type = '%s' "
                        "WHERE Id = %d;", report->newtype, row["Id"]);
        queries += ({ query });
      }
      break;
    default:
      ret += sprintf("Unknown report status: %s\n", report->newstatus);
      break;
    }
  }
  ret += save_status(key, ids_fixed, user, "FIXED");
  ret += save_status(key, ids_denied, user, "DENIED");
  ret += save_status(key, ids_fixing, user, "FIXING");
  ret += save_status(key, ids_considering, user, "CONSIDERING");
  ret += save_status(key, ids_open, user, "OPEN" );
  foreach (query in queries) {
    err = catch(db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  if (ret == "") {
    ret = 0;
  }
  return ret;
}

==================================================
FILE: errors_base2.c
==================================================

#include <db.h>
#include <log.h>
#include <config.h>
private class report {
  int row;
  string newstatus;
  string newdir;
  string newtype;
  int changed;
}
private class bugs {
  mixed* errors;
  string user;
  int changed;
}
private nosave mapping _globvars;
protected varargs mixed get_row(mixed key, int row, int nomap);
protected varargs string init_errors(mixed key, string user, int replace) {
  string ret;
  if (!mapp(_globvars)) {
    _globvars = ([ ]);
  } else {
    if (!(replace || undefinedp(_globvars[key]))) {
      return "key already in use";
    }
  }
  _globvars[key] = new(class bugs);
  _globvars[key]->user = user;
  _globvars[key]->errors = ([ ]);
  return 0;
}
protected string finish_errors(mixed key) {
  string ret;
  if (!classp(_globvars[key])) {
    return "unknown key";
  }
  map_delete(_globvars, key);
  return ret;
}
void event_finished_get_fields(string key) {
}
private void finished_get_fields(mixed key, int type, mixed* data) {
   _globvars[key]->errors = data;
   event_finished_get_fields(key);
}
protected void get_fields(mixed key, string directory,
                          string fields, string type) {
  string query;
  string temp;
  mixed ret;
  if (!strlen(type)) {
    type = "OPEN";
  }
  _globvars[key]->errors = ({ });
  fields += ", Directory";
  query = sprintf("SELECT %s FROM errors WHERE Directory = '%s' AND "
                  "Status = '%s' ORDER BY DirEntryDate;", fields, directory,
                  type);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_fields($(key), $1, $2) :));
}
void event_finish_get_forwards(mixed key, int row) {
}
protected void finish_get_forwards(mixed key, int row, int type, mixed* data) {
   _globvars[key]->forwards[row] = data;
   event_finish_get_forwards(key, row);
}
protected void get_forwards(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping forwards;
  ret = _globvars[key]->errors[row];
  if (_globvars[key]->forwards[row]) {
     return _globvars[key]->forwards[row];
  }
  query = sprintf("SELECT ForwardDate, Forwarder, OldDirectory FROM forwards "
                  "WHERE Id = %d ORDER BY ForwardDate;", ret["Id"]);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_forwards($(key), $(row),
                                     $1, $2) :));
}
void event_finish_get_comments(mixed key, int row) {
}
protected void finish_get_comments(mixed key, int row, int type, mixed* data) {
   _globvars[key]->comments[row] = data;
   event_finish_get_comments(key, row);
}
protected void get_comments(mixed key, int row) {
  string query, err;
  mixed ret;
  mapping comments;
  int fd;
  ret = _globvars[key]->errors[row];
  if (_globvars[key]->comments[row]) {
     return _globvars[key]->comments[row];
  }
  query = sprintf("SELECT CommentDate, Commenter, Comment FROM comments "
                  "WHERE Id = %d ORDER BY CommentDate;", ret["Id"]);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query,
                                  (: finished_get_comments($(key), $(row),
                                     $1, $2) :));
}
protected void get_row(mixed key, int row) {
  mixed *res;
  string ret, *keys;
  mapping rowvals;
  return _globvars[key]->errors[row];
}
protected int set_status(mixed key, int row, string status) {
  int realrow = ROWS[row];
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newstatus = status;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
}
protected int set_type(mixed key, int row, string type) {
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newtype = status;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
}
protected int forward_bug(mixed key, int row, string directory) {
  int realrow = ROWS[row];
  while (directory[<1] == '/') {
    directory = directory[0..<2];
  }
  if (!classp(_globvars[key]->changes[row])) {
    _globvars[key]->changes[row] = new(class _report, row : realrow);
  }
  _globvars[key]->changes[row]->newdir = directory;
  _globvars[key]->changes[row]->changed = 1;
  return 1;
}
protected string comment_bug(mixed key, int row, string who, string comment) {
  string query, err;
  int fd;
  mixed ret;
  query = sprintf("INSERT LOW_PRIORITY INTO comments VALUES "
                  "(%d, %d, '%s', '%s');",
                  ret["Id"], time(), who, comment);
  MYSQL_HANDLER->make_sql_request("errors", USER, "", query);
  return 0;
}
private string save_status(mixed key, int *ids, string user, string status) {
  string query, ret, err;
  mixed res;
  ret = "";
  if (sizeof(ids)) {
    if (sizeof(ids) == 1) {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id = %d;", status,
                      time(), user, ids[0]);
    } else {
      query = sprintf("UPDATE LOW_PRIORITY errors SET Status = '%s', "
                      "FixDate = %d, Fixer = '%s' WHERE Id IN (%s);", status,
                      time(), user, implode(ids, (: "" + $1 + ", " + $2 :)));
    }
    MYSQL_HANDLER->make_sql_request("errors", USER, "", query);
  }
  return ret;
}
protected string save_changes(mixed key, string user) {
  class _report *reports, report;
  string query, *queries, ret, err;
  int *ids_fixed, *ids_denied, *ids_fixing, *ids_considering, *ids_open, ftime;
  mixed res, row;
  if (!CHANGED) {
    return 0;
  }
  reports = filter(values(ERRORS), (: ((class _report)$1)->changed :));
  ids_fixed = ids_denied = ids_fixing = ids_considering = ids_open = queries = ({ });
  ret = "";
  foreach (report in reports) {
    row = get_row(key, report->row, 1);
    if (stringp(row)) {
      ret += row;
      continue;
    }
    switch (report->newstatus) {
    case "FIXED":
      ids_fixed += ({ row["Id"] });
      break;
    case "DENIED":
      ids_denied += ({ row["Id"] });
      break;
    case "FIXING":
      ids_fixing += ({ row["Id"] });
      break;
    case "CONSIDERING":
      ids_considering += ({ row["Id"] });
      break;
    case "OPEN":
      ids_open += ({ row["Id"] });
      break;
    case 0:
    case "":
      if (report->newdir) {
        ftime = time();
        query = sprintf("UPDATE LOW_PRIORITY errors SET Directory = '%s', "
                        "DirEntryDate = %d WHERE Id = %d;",
                        report->newdir, ftime, row["Id"]);
        queries += ({ query });
        query = sprintf("INSERT LOW_PRIORITY INTO forwards VALUES "
                        "(%d, %d, '%s', '%s');",
                        row["Id"], ftime, user, row["Directory"]);
        queries += ({ query });
      }
      if (report->newtype) {
        query = sprintf("UPDATE LOW_PRIORITY errors SET Type = '%s' "
                        "WHERE Id = %d;", report->newtype, row["Id"]);
        queries += ({ query });
      }
      break;
    default:
      ret += sprintf("Unknown report status: %s\n", report->newstatus);
      break;
    }
  }
  ret += save_status(key, ids_fixed, user, "FIXED");
  ret += save_status(key, ids_denied, user, "DENIED");
  ret += save_status(key, ids_fixing, user, "FIXING");
  ret += save_status(key, ids_considering, user, "CONSIDERING");
  ret += save_status(key, ids_open, user, "OPEN" );
  foreach (query in queries) {
    err = catch(db_exec(FD, query));
    if (err) {
      ret += err;
    }
    if (stringp(res)) {
      ret += res;
    }
  }
  if (ret == "") {
    ret = 0;
  }
  return ret;
}

==================================================
FILE: guild_base.c
==================================================

inherit "/cmds/base";
#include <nroff.h>
#include <cmds/guild_base.h>
#define NROFF_SOURCE "/doc/known_command/"
nosave string _nroff_fname;
nosave class teach_skill *_teach_skills;
nosave string _command_name;
nosave string _teach_guild;
void create() {
   _teach_skills = ({ });
}
void set_nroff_file(string str) {
   _nroff_fname = str;
}
string query_nroff_file() {
  return _nroff_fname;
}
private string nroff_file(string name, int html) {
   string nroff_fn;
   string str;
   if (name[0] != '/') {
      name = NROFF_SOURCE + name;
   }
   nroff_fn = NROFF_DIR + replace(name, "/", ".");
   if (html) {
      str = NROFF_HAND->html_file(nroff_fn, 1);
   } else {
      str = NROFF_HAND->cat_file(nroff_fn, 1);
   }
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      if (html) {
         str = NROFF_HAND->html_file(nroff_fn, 0);
      } else {
         str = NROFF_HAND->cat_file(nroff_fn, 0);
      }
   }
   return str;
}
function help_function() {
   if (_nroff_fname) {
      return (: nroff_file(_nroff_fname, 0) :);
   }
   return 0;
}
string help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 0);
   }
   return 0;
}
string query_www_help() {
   if (_nroff_fname) {
      return nroff_file(_nroff_fname, 1);
   }
   return 0;
}
void add_teach_skill(string skill, int teach, int learn) {
   class teach_skill bing;
   bing = new(class teach_skill);
   bing->skill = skill;
   bing->teach = teach;
   bing->learn = learn;
   _teach_skills += ({ bing });
}
class teach_skill *query_teach_skills() {
   return _teach_skills;
}
void set_command_name(string name) {
   _command_name = name;
}
string query_command_name() {
   return _command_name;
}
void set_teach_guild(string guild) {
   _teach_guild = guild;
}
string query_teach_guild() {
   return _teach_guild;
}
int can_teach_command(object teacher, object student) {
   class teach_skill bing;
   if (!sizeof(_teach_skills) ||
       !_command_name) {
     return 0;
   }
   foreach (bing in _teach_skills) {
      if (teacher->query_skill(bing->skill) < bing->teach) {
         return -1;
      }
      if (student->query_skill(bing->skill) < bing->learn) {
         return -2;
      }
   }
   if (_teach_guild &&
       student->query_guild_ob() != _teach_guild) {
      return -3;
   }
   return 1;
}
int teach_command(object teacher, object student) {
   int ret;
   ret = can_teach_command(teacher, student);
   if (ret == 1) {
      student->add_known_command(_command_name);
   }
   return ret;
}

==================================================
FILE: position_base.c
==================================================

inherit "/cmds/base";
#include <position.h>
string position;
string up_down;
string position_type;
int query_position_command() {
   return 1;
}
string query_up_down() {
   return up_down;
}
string query_position() {
   return position;
}
string query_position_type() {
   return position_type;
}
void setup_position(string pos, string up, string type) {
   position = pos;
   up_down = up;
   position_type = type;
}
int position(object person, int silent) {
   string pos_type;
   if (person->query_position() == position_type) {
      if (person == this_player()) {
         add_failed_mess("You are already "+position_type+".\n");
      }
      return 0;
   }
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   if (!silent) {
      if (up_down != "") {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position+" " + up_down +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
                      person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$ "  + up_down +
                      " " + pos_type + " " +
                      person->query_position_on_short() + ".\n",
                      ({ person }));
         } else {
            tell_object(person, "You " + position+" " + up_down + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + "," +
                      position+"$V$ " +
                      up_down + ".\n",
                      ({ person }));
         }
      } else {
         if (person->query_position_on()) {
            pos_type = person->query_position_type();
            tell_object(person, "You " + position +
                             " " + pos_type + " " +
                             person->query_position_on_short() + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                             "$V$ " + pos_type + " " +
                             person->query_position_on_short() + ".\n",
               ({ person }));
         } else {
            tell_object(person, "You " + position + ".\n");
            tell_room(environment(person),
               person->one_short() + " $V$0=" + pluralize(position) + ","+
                      position+"$V$.\n",
               ({ person }));
         }
      }
   }
   person->set_position(position_type);
   return 1;
}
int position_floor(object person, int silent) {
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   if (person->query_position_on()) {
      if (!silent) {
         if (up_down != "") {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + " " + up_down + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + up_down + ".\n",
                ({ person }));
         } else {
            tell_object(person, "You get off " +
                person->query_position_on_short() +
                " and " + position + ".\n");
            tell_room(environment(person),
                person->one_short() + " gets off " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$.\n",
                ({ person }));
         }
      }
      person->set_position(position_type);
      person->set_position_on(0);
      person->set_position_type(0);
      person->set_position_multiple(0);
      return 1;
   }
   return position(person, 0);
}
string *query_position_strings(object person) {
   string bit;
   string bit_other;
   switch (person->query_position_type()) {
      case AT_TYPE :
      case BESIDE_TYPE :
         bit = "move away from";
         bit_other = "moves away from";
         break;
      case ON_TYPE :
      default :
         bit = "get off";
         bit_other = "gets off";
         break;
   }
   return ({ bit, bit_other });
}
int position_object(object *obs, string pos_type, object person) {
   int i;
   int mult;
   string rabbit;
   string *pos_strings;
   if (!environment(person) ||
       !environment(person)->is_allowed_position(position_type)) {
      if (person == this_player()) {
         add_failed_mess("You cannot " + position +  " " + up_down +
                         " here.\n");
      }
      return 0;
   }
   pos_strings = query_position_strings(person);
   for (i = 0; i < sizeof(obs); i++) {
      if (obs[i]->query_property(CAN_POSITION_PROPERTY)) {
         mult = obs[i]->query_property(MULTIPLE_POSITION_PROPERTY);
         if (person->query_position_on()) {
            if (person->query_position_on() == obs[i] &&
                person->query_position_type() == pos_type) {
               if (person->query_position() != position_type) {
                  return position(person, 0);
               }
               if (person == this_player()) {
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
               }
               return 0;
            }
            tell_object(person, "You " + pos_strings[0] + " " +
                person->query_position_on_short() +
                " and " + position + " " + pos_type+" "+
                obs[i]->a_short()+".\n");
            tell_room(environment(person),
                person->one_short() + " " + pos_strings[1] + " " +
                person->query_position_on_short() +
                " and $V$0=" + pluralize(position) + ","+position+"$V$ " + pos_type + " " +
                obs[i]->a_short() + ".\n",
                ({ person }));
            person->set_position(position_type);
            person->set_position_on(obs[i]);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
         tell_object(person, "You " + position + " " + pos_type +
                             " " + obs[i]->a_short()+".\n");
         tell_room(environment(person),
                   person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                   "$V$ " + pos_type + " " +
                   obs[i]->a_short() + ".\n",
                   ({ person }));
         person->set_position(position_type);
         person->set_position_on(obs[i]);
         person->set_position_type(pos_type);
         person->set_position_multiple(mult);
         return 1;
      } else  {
         rabbit = obs[i]->query_position_string(position_type);
         if (rabbit) {
            mult = obs[i]->query_position_multiple(position_type);
            if (person->query_position_on()) {
               if (person->query_position_on() == rabbit &&
                   person->query_position_type() == pos_type) {
                  if (person->query_position() != position_type) {
                     return position(person, 0);
                  }
                  add_failed_mess("You are already " + position_type + " " +
                                  pos_type + " $I.\n",
                                  obs[i..i]);
                  return 0;
               }
               tell_object(person, "You " + pos_strings[0] +  " " +
                   person->query_position_on_short() +
                   " and " + position + " " + pos_type + " " +
                   rabbit + ".\n");
               tell_room(environment(person),
                         person->one_short() + " " + pos_strings[1] + " " +
                         person->query_position_on_short() +
                         " and $V$0=" + pluralize(position) + ","+position+"$V$ " +
                         pos_type + " " +
                         rabbit + ".\n",
                         ({ person }));
               person->set_position(position_type);
               person->set_position_on(rabbit);
               person->set_position_type(pos_type);
               person->set_position_multiple(mult);
               return 1;
            }
            tell_object(person, "You "+position+" " + pos_type + " " +
                                 rabbit + ".\n");
            tell_room(environment(person),
                person->one_short() + " $V$0=" + pluralize(position) + ","+position+
                      "$V$ "+pos_type + " " +rabbit + ".\n",
                      ({ person }));
            person->set_position(position_type);
            person->set_position_on(rabbit);
            person->set_position_type(pos_type);
            person->set_position_multiple(mult);
            return 1;
         }
      }
   }
   return 0;
}
mixed *query_patterns() {
   return ({ "", (: position(this_player(), 0) :),
             "on [the] floor", (: position_floor(this_player(), 0) :),
             "{on|at|in|beside} <indirect:object>",
                    (: position_object($1, $4[0], this_player()) :) });
}

==================================================
FILE: report_base.c
==================================================

#include <creator.h>
#include <log.h>
#include <command.h>
#include <spells.h>
#include <user_parser.h>
#include <soul.h>
#include <error_handler.h>
inherit "/cmds/base";
inherit "/cmds/bug_replies";
class errors {
   int type;
   string file;
   string error;
   string extra;
}
#define ROOM_BUG    1
#define OBJECT_BUG  2
#define RITUAL_BUG  3
#define SPELL_BUG   4
#define HELP_BUG    5
#define COMMAND_BUG 6
#define GENERAL_BUG 7
#define WEB_BUG     8
#define SYNONYMS "/doc/SYNONYMS"
int bug_command(string str);
int bug_spell(string str);
int bug_ritual(string str);
int bug_object(object * obj,
               string str);
int bug_help(string str);
int bug_man(string str);
int bug_room();
int bug_general();
int bug_soul(string str);
private nosave mapping _globals;
private nosave string _error_type;
private nosave int _use_last_error;
void create()
{
   bug_replies::create();
   _globals = ([ ]);
}
void set_error_type(string type)
{
   _error_type = type;
}
void set_use_last_error(int error)
{
   _use_last_error = error;
}
int query_use_last_error()
{
   return _use_last_error;
}
int bug_room()
{
   if (environment(this_player())) {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:file_name(environment
             (this_player
              ())));
  } else {
 _globals[this_player()] = new (class errors, type: ROOM_BUG, error: "ROOM " + _error_type, file:"/d/mudlib/void");
   }
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_special(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/d/special/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}
int bug_misc(string which) {
  _globals[this_player()] = new (class errors,
                                 type: GENERAL_BUG,
                                 error: "GENERAL " + _error_type,
                                 file: "/obj/"+which+"/BugReports");
  this_player()->do_edit(0, "end_of_edit");
  return 1;
}
int bug_general()
{
   string dir;
   string *bits;
   string file;
   if (!environment(this_player())) {
      dir = "/d/am/fluff";
   } else {
      dir = file_name(environment(this_player()));
   }
   bits = explode(dir, "/");
   if (bits[0] == "d") {
      file = implode(bits[0..1], "/") + "/general";
   } else {
      file = file_name(environment(this_player()));
   }
 _globals[this_player()] = new (class errors, type: GENERAL_BUG, error: "GENERAL " + _error_type, file:file);
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_command(string str)
{
   int i;
   string dir;
   string file;
   string *bits;
   mixed *junk,
    *coms;
   class command cmd;
   class errors bing;
   class command_data cmd_data;
   class command_class cmd_class;
   mapping temp;
   bing = new (class errors);
   coms = ({ });
   junk = actions_defined(this_player(), 0, 12);
   for (i = 0; i < sizeof(junk); i += 2) {
      if (junk[i] == str) {
         coms += ({ junk[i], junk[i + 1][0], junk[i + 1][1] });
      }
   }
   if (sizeof(coms) > 3) {
      return notify_fail("More than one commands with the name \"" + str +
                         "\" found.  Please be more specific.\n");
   }
   if (sizeof(coms)) {
      bing->file = function_exists((string) coms[2], (object) coms[1]);
      if (!(bing->file)) {
         bing->file = base_name((object) coms[1]);
         str += " (protected method, so it might not be in this file)";
      }
   } else {
    cmd = new (class command, verb:str);
      if (CMD_D->HandleStars(cmd) &&
          sizeof((coms = (mixed *) CMD_D->GetPaths(cmd->verb) &
                  (mixed *) this_player()->GetSearchPath()))) {
         bing->file = coms[0] + "/" + cmd->verb;
      } else {
         if ((cmd_class = this_player()->query_parse_command(str))) {
            temp = cmd_class->patterns;
            cmd_data = temp[keys(temp)[0]];
            bing->file = base_name(cmd_data->calls[0]);
         } else {
            if ((coms = SOUL_OBJECT->query_soul_command(str))) {
               bing->file = "/soul/" + str[0..0] + "/" + str;
            } else if (_error_type == "IDEA") {
               dir = file_name(environment(this_player()));
               bits = explode(dir, "/");
               if (bits[0] == "d") {
                  file = implode(bits[0..1], "/") + "/general";
               } else {
                  file = file_name(environment(this_player()));
               }
               bing->file = file;
            } else {
               return notify_fail("Command " + str + " not found.\n");
            }
         }
      }
   }
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_help(string str)
{
   mixed *stuff;
   class errors bing;
   string tmp;
   bing = new (class errors);
   tmp = "/cmds/player/help"->query_synonym(str);
   if (strlen(tmp))
      str = tmp;
   if (str && str != "") {
      stuff = "/cmds/player/help"->query_help_on(str);
      if (!sizeof(stuff)) {
         if (!SOUL_OBJECT->query_soul_command(str)) {
            notify_fail("Could not find the help file '" + str +
                        "'.  If you wish "
                        "to suggest a new command use 'idea help'\n");
            return 0;
         } else {
            bing->file = "/soul/" + str;
         }
      } else {
         sscanf(stuff[0][0], "%*s (%s)", bing->file);
      }
   } else {
     bing->file = "/cmds/player/help";
   }
   bing->error = "HELP " + _error_type + " " + str;
   bing->type = HELP_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_soul(string str)
{
   class errors bing;
   string tmp;
   bing = new (class errors);
   if (str)  {
      tmp = sprintf("/soul/%c/%s.s", str[0], str);
      if (file_size(tmp) < 1)  {
         notify_fail("No such soul command \"" + str + "\".\n");
         return 0;
      }
      else return bug_command(str);
   }
   bing->file = "/soul/ideas";
   bing->error = "COMMAND " + _error_type + " " + str;
   bing->type = COMMAND_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_ritual(string str)
{
   mapping junk;
   class errors bing;
   string sname;
   mixed* data;
   string file;
   str = this_player()->expand_nickname(str);
   bing = new (class errors);
   junk = this_player()->query_spells();
   foreach (sname, data in junk) {
      if (lower_case(sname) == lower_case(str)) {
         if (sizeof(data) <= S_OBJECT) {
            file = file_name(environment(this_player()));
         } else {
            file = data[S_OBJECT];
         }
      }
   }
   if (!file) {
      notify_fail("Ritual " + str + " not found.\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = file;
   bing->error = "RITUAL " + _error_type + " " + str;
   bing->type = RITUAL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_web(string url)
{
   class errors bing;
   bing = new (class errors);
   bing->file = "/www/fluff";
   bing->error = "OBJECT " + _error_type + " " + url;
   bing->type = WEB_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit("Url: " + url + "\n\n", "end_of_edit");
   return 1;
}
int bug_spell_file(string file, string name)
{
   class errors bing;
   bing = new (class errors);
   bing->file = file;
   bing->error = "SPELL " + _error_type + " " + name;
   bing->type = SPELL_BUG;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_spell(string str)
{
   mapping junk;
   string file;
   string sname;
   mixed data;
   if (str == "wizards" || str == "witches") {
      file = "/obj/spells/" + str;
   } else {
      str = this_player()->expand_nickname(str);
      junk = this_player()->query_spells();
      foreach (sname, data in junk) {
         if (lower_case(sname) == lower_case(str) && arrayp(data)) {
            file = data[S_OBJECT];
         }
      }
      if (!file) {
         notify_fail("Spell " + str + " not found.\n");
         map_delete(_globals, this_player());
         return 0;
      }
   }
   bug_spell_file(file, str);
   return 1;
}
int bug_object_new(string name)
{
   string info;
   class errors bing;
   bing = new (class errors);
   bing->file = base_name(environment(this_player()));
   bing->error = "OBJECT " + _error_type + " " + name;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
int bug_object(object * obj,
               string str)
{
   string info;
   class errors bing;
   string name;
   string short;
   string* bits;
   bing = new (class errors);
   if (sizeof(obj) > 1) {
      notify_fail("More than one object can be identified with the name " +
                  str + "\n");
      map_delete(_globals, this_player());
      return 0;
   }
   bing->file = base_name(obj[0]);
   switch (bing->file) {
   case "/std/room/basic/item":
      bing->file = base_name(environment(this_player()));
      info = sprintf("Room item %s.\n\n", str);
      break;
   case "/std/bit" :
      bing->file = "/std/races/happy_bit";
      break;
   case "/std/book" :
   case "/obj/armour":
   case "/obj/baggage":
   case "/obj/clothing":
   case "/obj/container":
   case "/obj/food":
   case "/obj/monster":
   case "/obj/weapon":
   case "/std/object":
      if (obj[0]->query_property("virtual name")) {
         bing->file = obj[0]->query_property("virtual name");
         info = sprintf("VObject: %s, Object: %s\nName: %s, Short: %s\n\n",
                        obj[0]->query_property("virtual name"),
                        bing->file,
                        obj[0]->query_name(), obj[0]->query_short());
         break;
      } else {
         bing->file = base_name(environment(this_player()));
      }
   default:
      bits = explode(bing->file, "/");
      name = bits[0];
      if (name == "obj" || name == "std") {
         if (sizeof(bits) == 2 ||
             (bits[1] != "food" && bits[1] != "armours" &&
             bits[1] != "weapons" && bits[1] != "amulets" &&
             bits[1] != "monster" && bits[1] != "music" &&
             bits[1] != "plants" && bits[1] != "rings" &&
             bits[1] != "furnitures" && bits[1] != "jewellery" &&
             bits[1] != "wands")) {
            bing->file = base_name(environment(this_player()));
         }
      }
      if (pointerp(obj[0]->query_name()))  {
         name = (obj[0]->query_name())[0];
      } else {
         name = obj[0]->query_name();
      }
      if (!name) {
         name = "<Bad name>";
      }
      short = obj[0]->query_short();
      if (!short) {
         short = "<Bad short>";
      }
      info = sprintf("Name: %s, Short: %s\n\n", name, short);
      break;
   }
   bing->error = "OBJECT " + _error_type + " " + str;
   bing->type = OBJECT_BUG;
   bing->extra = info;
   _globals[this_player()] = bing;
   this_player()->do_edit(0, "end_of_edit");
   return 1;
}
void end_of_edit(string body)
{
   if (strlen(body)) {
      int ending;
      string name,
        trace = 0;
      mapping last_error;
      class errors bing;
      bing = _globals[this_player()];
      if (bing->extra) {
         body = bing->extra + body;
      }
      if (body[<1] != '\n') {
         ending = 1;
      }
      if (environment(this_player())) {
         if (ending) {
            body += "\n";
            ending = 0;
         }
         body += sprintf("\nEnvironment: %s (%s)\n",
                         file_name(environment(this_player())),
                         environment(this_player())->short());
      }
      if (_use_last_error) {
         last_error = (mapping) this_player()->get_last_error();
         if (mapp(last_error)) {
            trace = (string) master()->standard_trace(last_error, 1);
            this_player()->set_last_error(0);
         }
      }
      if (ending) {
         body += "\n";
      }
      name = (string) this_player()->query_name();
      SMART_LOG->smart_log(bing->error, name, body, trace, bing->file);
      printf("Thank you for your %s report.\n", lower_case(_error_type));
   } else {
      printf("Not saving %s report, aborting.\n", lower_case(_error_type));
   }
   map_delete(_globals, this_player());
}
int clean_up()
{
   return 0;
}
void reset()
{
}
mixed *query_patterns()
{
   return ({ "command <string'name'>", (: bug_command($4[0]) :),
             "replies", (: bug_replies(0) :),
             "replies new", (: bug_replies(1) :),
             "web <string'url'>", (: bug_web($4[0]) :),
             "spell <string'name'>", (: bug_spell($4[0]) :),
             "spell {generic|wizards|witches}", (: bug_spell_file("/obj/spells/" + $4[0], $4[0]) :),
             "spell new", (: bug_spell_file("/obj/spells/generic", "generic") :),
             "object new",
             (: bug_object_new("new") :),
             "object name <string'name'>",
             (: bug_object_new($4[0]) :),
             "object <indirect:object:me-here'name of NPC or item'>",
             (: bug_object($1, $4[0]) :),
             "ritual <string'name'>", (: bug_ritual($4[0]) :),
             "ritual generic", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "ritual new", (: bug_spell_file("/obj/rituals/generic", "generic") :),
             "help <string'subject'>", (: bug_help($4[0]) :),
             "help", (: bug_help("") :),
             "soul <string'soul command'>", (: bug_command($4[0]) :),
             "soul new", (: bug_soul(0) :),
             "room", (: bug_room() :),
             "special {" +
               implode(filter(get_dir("/d/special/"),
                              (: file_size("/d/special/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_special($4[0]) :),
             "misc {" +
               implode(filter(get_dir("/obj/"),
                              (:  file_size("/obj/"+$1+"/BugReports") >= 0 :)),
                       "|") + "}", (: bug_misc($4[0]) :) });
}

==================================================
FILE: speech.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
#include <cmds/options.h>
#define TP this_player()
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)
#define REPLACEMENTS (["ne1":"anyone",\
                       "u":"you",\
                       "r":"are", \
                       "NE1":"anyone",\
                       "U":"you",\
                       "R":"are", \
                       "ur":"you are",\
                       "teh":"the", \
                       "some1":"someone"])
class message {
   string text;
   string emote;
   string language;
   string type;
   string notify_mess;
   int status;
}
varargs string query_word_type(string str, string def) {
  int i;
  if (!str || strlen(str) < 1)
    return "";
  for (i = strlen(str) - 1; i >= 0 && str[i] == ' '; i--);
  if (i < 0) {
    return "discombobulate";
  }
  switch (str[i]) {
  case '!':
    return "exclaim";
  case '?':
    return "ask";
  default:
    if (def)
      return def;
    else
      return "say";
  }
}
string mangle_tell(string mess, object dest) {
  int i;
  string ret;
  if (!TP || !environment(TP))
    return mess;
  if (environment(TP)->query_property("reverse_tell") &&
      !dest->query_creator() && !TP->query_creator()) {
    for (i = 0; i < strlen(mess); i++)
      ret = mess[i..i] + ret;
    return ret;
  }
  return mess;
}
string drunk_speech(string str) {
  return replace(str, ({ "S", "sh", "r", "rr", "ing", "in'", "x", "xsh",
                           "S", "SH", "R", "RR" }));
}
string de_eight(string arg) {
  object g;
  string replace_num;
  g = (object) TP->query_guild_ob();
  if (g && ((string) g->query_name() == "wizards") && !TP->query_creator()) {
    arg = "@ " + arg + "@";
    replace_num = ({ " seven plus one", " nine minus one",
                       " two to the power of three",
                       " four times two" })[random(4)];
    arg = implode(explode(arg, " eight"), replace_num);
    replace_num = ({ "(7+1)", "(9-1)", "(2^3)", "(4*2)" })[random(4)];
    arg = implode(explode(arg, "8"), replace_num);
    arg = arg[2.. < 2];
  }
  return arg;
}
string fix_shorthand(string mess) {
  string *bits, name, value;
  mixed *tmp;
  int index, i;
  bits = explode(mess, " ");
  foreach(name, value in REPLACEMENTS) {
    tmp = regexp(bits, "(^|[^A-Za-z]+)"+name+"($|[^A-Za-z]+)", 1);
    if(sizeof(tmp)) {
      for(i=0; i<sizeof(tmp); i+=2) {
        index = tmp[i+1]-1;
        bits[index] = replace(bits[index], name, value);
      }
    }
  }
  return implode(bits, " ");
}
void my_mess(string fish, string erk) {
  int bing;
  if (!interactive(TP)) {
    return;
  }
  bing = strlen(fish);
  if (bing > 15) {
    bing = 15;
  }
  efun::tell_object(TP, TP->fix_string(sprintf("%s%s\n", fish, erk),
                                       (int) TP->query_cols(), bing));
}
class message build_message(string arg, mixed target, string word_type) {
  string lang;
  string s1;
  string emotion;
  string word;
  string *langs;
  int i;
  class message mess;
  int done;
  mess = new (class message);
  if (!arg || arg == "" || arg == " ") {
    mess->status = NO_MESSAGE;
    return mess;
  }
  while (!done && (!lang || !emotion)) {
    switch (arg[0]) {
    case '#':
      if(word_type == "tell") {
        done = 1;
        continue;
      }
      if (arg[1] == '\'' && sscanf(arg, "#'%s' %s", lang, arg) == 2)
        continue;
      if (sscanf(arg, "%s %s", lang, arg) == 2) {
        lang = lang[1..];
        langs = LANGUAGE_HAND->query_languages();
        if (member_array(lang, langs) == -1) {
          for (i = 0; i < sizeof(langs); i++) {
            if (TP->query_skill(LANGUAGE_HAND->
                                query_language_spoken_skill(langs[i])) > 1 ||
                TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
              if (langs[i][0..strlen(lang)-1] == lang) {
                lang = langs[i];
              }
            }
          }
        }
      } else {
        done = 1;
      }
      break;
    case '@':
      if (sscanf(arg, "%s %s", emotion, arg) == 2) {
        emotion = emotion[1..] + " ";
      } else {
        done = 1;
      }
      break;
    default:
      done = 1;
    }
  }
  if (!emotion)
    emotion = "";
  if(lang == "general" && interactive(TP) && !TP->query_creator()) {
    mess->status = NOT_KNOWN;
    return mess;
  }
  if(!lang)
    lang = (string) TP->query_current_language();
  mess->language = lang;
  if(!LANGUAGE_HAND->query_language_spoken(lang)) {
    mess->status = NOT_SPOKEN;
    return mess;
  }
  if(word_type == "shout" && !LANGUAGE_HAND->query_language_distance(lang)) {
    mess->status = NOT_DISTANCE;
    return mess;
  }
  if(word_type != "tell" &&
     !TP->query_skill(LANGUAGE_HAND->query_language_spoken_skill(lang)) &&
     !LANGUAGE_HAND->query_language_always_spoken(lang)) {
    mess->status = NOT_KNOWN;
    return mess;
  }
  if (!interactive(TP)) {
    arg = TP->convert_message(arg);
    arg = TP->fit_message(arg);
  }
  arg = replace(arg, ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                            "[D", "", "%^", " " }));
  if(TP->query_property(SHORTHAND_PROP))
    arg = LANGUAGES->fix_shorthand(arg);
  if(word_type != "tell") {
    if(TP->query_volume(D_ALCOHOL))
      arg = drunk_speech(arg);
    s1 = TP->mangle_speech(arg);
    if (stringp(s1))
      arg = s1;
    if(TP && environment(TP) &&
       function_exists("mangle_speech", environment(TP)))
      arg = (string) environment(TP)->mangle_speech(word_type, arg, target);
    arg = de_eight(arg);
  }
  word = query_word_type(arg, word_type);
  mess->text = arg;
  mess->type = word;
  mess->emote = emotion;
  mess->status = MESSAGE_OK;
  if (target)
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$ $target$: ";
  else
    mess->notify_mess = "$one_short:" + file_name(TP) + "$ " + emotion +
      "$V$0=" + word + "s," + word + "$V$: ";
  return mess;
}
int say_it(class message mess) {
  string accent;
  if (!environment(TP))
    write("You are in limbo, noone can hear you.\n");
  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  TP->remove_hide_invis("hiding");
  accent = TP->query_nationality_accent_ob();
  TP->comm_event(environment(TP), "person_say",
                 mess->notify_mess, mess->text, mess->language, accent);
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    my_mess("You " + mess->emote + mess->type + " in " +
            capitalize(mess->language) + ": ", mess->text);
  } else {
    my_mess("You " + mess->emote + mess->type + ": ", mess->text);
  }
  TP->adjust_time_left(-5);
  return 1;
}
int say_it_to(class message mess, mixed targets, int priv, string event) {
  string lstr;
  string extra;
  string accent;
  if (!environment(TP)) {
    write("You are in limbo, noone can hear you.\n");
  }
  switch(mess->status) {
  case NO_MESSAGE:
    return notify_fail("Syntax: " + query_verb() + " <something>\n");
  case NOT_SPOKEN:
    return notify_fail(capitalize(mess->language) +
                       " is not a spoken language.\n");
  case NOT_KNOWN:
    return notify_fail("You cannot speak " + capitalize(mess->language) + ".\n");
  }
  if (!sizeof(targets)) {
    return 0;
  }
  targets -= ({ this_player() });
  TP->remove_hide_invis("hiding");
  this_player()->adjust_time_left(-5);
  accent = TP->query_nationality_accent_ob();
  switch (mess->type) {
  case "exclaim":
  case "whisper":
  case "say":
    extra = "to ";
    break;
  default:
    extra = "";
  }
  switch (priv) {
  case 2:
    break;
  case 1:
    TP->comm_event_to(environment(this_player()), event,
                      (string) this_player()->one_short(1) +
                      " " + mess->emote + mess->type + "s " +
                      extra, mess->text, targets, mess->language,
                      this_player(), accent);
    break;
  case 0:
    TP->comm_event(environment(TP), event,
                   "$one_short:" + file_name(TP) + "$ " + mess->emote +
                   "$V$0=" + mess->type + "s," + mess->type + "$V$ " +
                   extra + query_multiple_short(targets, "the") + ": ",
                   mess->text, mess->language, accent);
    break;
  }
  if (mess->language != TP->query_default_language() &&
      mess->language != "general") {
    lstr = " in " + cap_words(mess->language);
  } else {
    lstr = "";
  }
  write("You " + mess->emote + mess->type + " " + extra +
        query_multiple_short(targets, "the") + lstr + ": " +
        mess->text + "\n");
  return 1;
}

==================================================
FILE: template.c
==================================================

inherit "/cmds/base";
mixed cmd(string args) {
  return 0;
}
string help() {
  return "No help defined for this command, bug a creator about it!\n";
}

==================================================
FILE: theft_base.c
==================================================

#include <thief.h>
#include <obj_parser.h>
#include <player.h>
#define SKILL "covert.manipulation.stealing"
#define PERCEPTION "other.perception"
inherit "/cmds/guild_base";
int query_theft_command() { return 1; }
int victim_checks(object thief, object victim) {
  if(thief == victim)
    return notify_fail("Be serious!\n");
  if(thief->query_property("dead"))
    return notify_fail("Be serious, you're dead!\n");
  if(thief->query_auto_loading())
    return notify_fail("You don't have all your equipment yet..\n");
  if(victim->query_auto_loading())
    return notify_fail( "Be sporting; "+ (string)victim->the_short() +
                        " doesn't have "+ (string)victim->query_possessive() +
                        " equipment yet.\n" );
  if(userp(victim) && !interactive(victim))
    return notify_fail( "You can't " + query_verb() +
                        " from a net dead statue.\n");
  if(victim->query_property("nosteal"))
    return notify_fail("You cannot " + query_verb() + " from " +
                       victim->the_short() + ".\n");
  if(victim->query_sanctuary())
    return notify_fail("You can't snatch from someone who is protected.\n");
  if(pk_check(thief, victim))
    return notify_fail("You feel it would be wrong to " + query_verb() +
                       " from "+ victim->short()+".\n");
  if(victim->query_creator() && !thief->query_creator() ) {
    notify_fail("Stop trying to steal from creators.\n");
    thief->adjust_tmp_dex(-10);
    return 0;
  }
  return 1;
}
mixed get_item(object thief, mixed location, string str) {
  class obj_match result;
  result = (class obj_match)match_objects_in_environments(str, location, 0, thief);
  if(result->result != OBJ_PARSER_SUCCESS)
    return notify_fail("Pssst, they don't have one of those.\n");
  result->objects = filter(result->objects,
                           (: environment($1) == $(location) :));
  if(!sizeof(result->objects))
    return notify_fail("Pssst, they don't have one of those.\n");
  if(sizeof(result->objects) != 1)
    return notify_fail("You can only " + query_verb() +
                       " one thing at a time.\n");
  return result->objects[0];
}
int combat_checks(object thief, object victim) {
  if(thief->query_fighting()) {
    notify_fail("You can't attempt to " + query_verb() +
                " while in battle.\n");
    return 2;
  }
  if(member_array(thief, victim->query_attacker_list()) != -1) {
    notify_fail("You cannot attempt to " + query_verb() + " from someone "
                "that is fighting you.\n");
    return 1;
  }
  return 0;
}
int item_checks(object victim, object item, int wielded_ok, int worn_ok) {
  if(item->query_liquid() && item->query_food_object())
    return notify_fail("You cannot " + query_verb() + " liquids!\n");
  if(item->query_property("nosteal") ||
     (!wielded_ok && item->query_wielded() == victim) ||
     (!worn_ok && item->query_worn_by() == victim))
    return notify_fail("You cannot " + query_verb() + " " +
                       item->the_short() + " from " +
                       victim->the_short() + ".\n");
#ifdef QUOTA_CHECK
  if(!check_player_quota(victim, item))
    return notify_fail("A quick reveals that " + query_verb() + "ing " +
                       item->the_short() + " would exceed " +
                       victim->query_possessive() + "'s theft quota.\n");
#endif
  return 1;
}
int calc_value(object ob) {
  int value;
  object tmp, *inv;
  string name;
  sscanf( file_name( ob ), "%s#%*d", name );
  if( name = "/obj/package" ) {
    value = 0;
  }
  else {
    value = ob->query_value();
  }
  inv = deep_inventory(ob);
  if(sizeof(inv))
    foreach(tmp in inv)
      value += tmp->query_value();
  return value;
}
int check_player_quota(object victim, object ob) {
  object *things, thing;
  int quota, reported, valid, value;
  value = 0;
  things = ({ ob });
  things += deep_inventory(ob);
  foreach(thing in things) {
    if(thing->query_property("money") ) {
      value += thing->query_value_in("Ankh-Morpork");
    } else {
      value += thing->query_value();
    }
  }
  quota = QUOTA->query_player_quota(victim->query_name());
  reported = QUOTA->query_player_reported(victim->query_name());
  valid = QUOTA->query_player_valid(victim->query_name());
  if((quota - (reported + valid)) < value)
    return 0;
  return 1;
}
int steal_item(object thief, object victim, object item) {
  object *stolen;
  string sh;
  if(item->move(thief))
    return notify_fail( "You cannot " + query_verb() + " " +
                        item->the_short()+" from "+
                        (string)victim->the_short() +".\n");
  stolen = ({ item });
  stolen += deep_inventory(item);
  tell_object(thief, "You steal "+query_multiple_short(stolen, "the" )+
              " from "+ victim->the_short() +".\n" );
  if( environment(thief)->query_theft_handler() &&
      regexp(environment(thief)->query_theft_handler(), "/d/am/") &&
        thief->query_name() == "wobin" )
      stolen = THEFT_INSURANCE->check_items(stolen, victim, thief);
  event( environment( thief ), "theft", thief, victim, stolen );
  event( stolen, "theft", thief, victim );
  item->event_ward( thief, victim );
  if(thief->query_property("player") &&
     query_ip_number(thief) == query_ip_number(victim) &&
     sizeof(PLAYER_MULTIPLAYER_HANDLER->check_allowed(thief, ({victim})))) {
    sh = capitalize(thief->query_name())+ " stole " +
      query_multiple_short(stolen) +
      " from " + victim->query_name() + " while logged in from the same IP "
      "address.";
    user_event("inform", sh, "multiplayer");
    sh = victim->convert_message(sh);
    log_file("MULTIPLAYERS", ctime(time()) + ": " + sh + "\n");
  }
  return 1;
}

==================================================
FILE: lord/authorise.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
nosave string var_name = "map_prop ";
nosave string fname;
mapping map_prop;
mapping player_info;
string name;
string password;
string email;
int last_log_on;
string basename;
mixed cmd(string player) {
  if(find_player(player)) {
    find_player(player)->add_property("authorised player", 1);
    return 1;
  }
  if (PLAYER_HANDLER->test_user(player)) {
    if("/cmds/lord/playera_ddproperty"->cmd(player, "authorised player","1")) {
      PLAYER_HANDLER->remove_cache_entry(player);
      return 1;
    }
    return 0;
  }
  write(capitalize(player) + " does not exists.  Do you wish to create them? ");
  input_to("really_create", 0, player);
  add_succeeded_mess("");
  return 1;
}
void really_create(string response, string player) {
   response = lower_case(response);
   if (response[0] != 'y') {
      write("Aborting create.\n");
      return ;
   }
   write("Ok, creating player " + capitalize(player) + ".\n");
   write("What is their authorised email address: ");
   input_to("get_email", 0, player);
}
void get_email(string str, string player) {
  email = str;
  write("What password do you wish to use: ");
  input_to("get_password", 0, player);
}
void get_password(string passw, string player) {
   string save_file_name;
   save_file_name = PLAYER_HANDLER->query_player_file_name(player);
   map_prop = ([ "authorised player" : 1,
                 "new player" : 1,
                 "player" : 1,
                 "authorised email" : email, ]);
   player_info = ([ "email" : ":"+email, ]);
   last_log_on = time();
   name = player;
   password = crypt(passw, 0);
   save_object(save_file_name);
   write("Create player " + capitalize(player) + " with authorisation to login "
         "from nologin sites.\n");
}
int enable(string player, string address) {
  string *ips, file, *bits;
  int i;
  if(!PLAYER_HANDLER->test_user(player))
    return notify_fail("No such user " + player + ".\n");
  basename = "/save/players/" + player[0..0] + "/" + player;
  unguarded ( (: uncompress_file (basename + ".o.gz") :));
  file = unguarded( (: read_file(basename + ".o") :));
  bits = explode(file, "\n");
  for (i = 0; i < sizeof(bits); i++) {
    if (bits[i][0..strlen("player_info")-1] == "player_info") {
      player_info = restore_variable(bits[i][strlen("player_info") + 1..]);
      break;
    }
  }
  ips = player_info["allowed_ips"];
  if(!ips)
    ips = ({ });
  if ( member_array(address, ips ) == -1 )  {
    ips += ({ address });
    player_info["allowed_ips"] = ips;
    if (i < sizeof(bits)) {
      bits[i] = "player_info " + save_variable(player_info);
    } else {
      bits += ({ "player_info " + save_variable(player_info) });
    }
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", implode($(bits), "\n") + "\n") :));
    unguarded ( (: compress_file (basename + ".o") :));
  } else  {
    write( player + " is already allowed to login from  " + address + ".\n" );
  }
  write(player + " is now allowed to login from "+address+".\n");
  return 1;
}
int disable(string player, string address) {
  string *ips, file, *bits;
  int i;
  if(!PLAYER_HANDLER->test_user(player))
    return notify_fail("No such user " + player + ".\n");
  basename = "/save/players/" + player[0..0] + "/" + player;
  unguarded ( (: uncompress_file (basename + ".o.gz") :));
  file = unguarded( (: read_file(basename + ".o") :));
  bits = explode(file, "\n");
  for (i = 0; i < sizeof(bits); i++) {
    if (bits[i][0..strlen("player_info")-1] == "player_info") {
      player_info = restore_variable(bits[i][strlen("player_info") + 1..]);
      break;
    }
  }
  ips = player_info["allowed_ips"];
  if(!ips)
    ips = ({ });
  if ( member_array(address, ips ) != -1 )  {
    ips -= ({ address });
    player_info["allowed_ips"] = ips;
    if (i < sizeof(bits)) {
      bits[i] = "player_info " + save_variable(player_info);
    } else {
      bits += ({ "player_info " + save_variable(player_info) });
    }
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", implode($(bits), "\n") + "\n") :));
    unguarded ( (: compress_file (basename + ".o") :));
  } else  {
    write( player + " is not already allowed to login from  " +address+ ".\n");
  }
  write(player + " is now not allowed to login from "+address+".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "enable <word'player'> <string'address'>",
              (: enable($4[0], $4[1]) :),
              "disable <word'player'> <string'address'>",
              (: disable($4[0], $4[1]) :),
              "<word'player'>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/clubs.c
==================================================

#include <clubs.h>
#include <mail.h>
inherit "/cmds/base";
#define CONTROL_ROOM "/std/room/club_control_room"
#define ELEN 20
nosave string *bad_words = ({ "black", "blood", "cyber", "dark", "penis",
                              "cock", "pussy", "fuck", "shit", "death",
                              "dragon", "fight", "hell", "mage", "pink",
                              "lord", "shadow", "evil", "kill", "slay",
                              "hate", "anti", "bastard" });
private void do_invalid(string extra, int width);
private int do_delete(string extra, string reason, int width);
mixed cmd(string command, string extra, string rest) {
  if (this_player() != this_player(1))
    return 0;
  switch(command) {
  case "invalid":
    do_invalid(extra, this_player()->query_cols());
    break;
  case "delete":
    return do_delete(extra, rest, this_player()->query_cols());
  }
  return 1;
}
private string club_line(string club, int width, int verbose) {
  string tmp, tmp2, member;
  int clubtype, i;
  clubtype = CLUB_HANDLER->query_club_type(club);
  tmp = sprintf("%%^BOLD%%^%%^RED%%^%-9s%%^RESET%%^ %-15s\n",
                CLUB_ARRAY[clubtype]+":", club);
  if(verbose) {
        tmp+= sprintf(" %%^BOLD%%^Club Name:%%^RESET%%^ %s\n",
                  CLUB_HANDLER->query_club_name(club));
    tmp += sprintf(" %%^BOLD%%^Founder:%%^RESET%%^ %s\n"
                   " %%^BOLD%%^Members:%%^RESET%%^\n",
                   CLUB_HANDLER->query_founder(club));
    i = 0;
    tmp2 = "";
    foreach(member in CLUB_HANDLER->query_members(club)) {
      tmp2 += sprintf("%-15s ", member);
      if((i-1 * ELEN) % (width/ELEN) == 0  && tmp2 != "") {
        tmp += this_player()->fix_string("   " + tmp2 + "\n", width, 10);
        tmp2 = "";
      }
      i++;
    }
  }
  return tmp;
}
private int check_dodgy_name(string club) {
  string s1, s2, lname, word;
  lname = lower_case(club);
  lname = replace(lname, ({"'", "", "_", "", " ", ""}) );
  foreach(word in bad_words)
    if ( sscanf( lname, "%s" + word + "%s", s1, s2 ) == 2 )
      return 1;
  return 0;
}
private void do_invalid(string extra, int width) {
  string club, *clubs, tmp, tmp2;
  int ok;
  tmp = "";
  tmp2 = "";
  clubs = sort_array(CLUB_HANDLER->query_clubs(),
                     (: strcmp($1, $2 ) :) );
  foreach(club in clubs) {
    ok = 1;
    switch(CLUB_HANDLER->query_club_type(club)) {
    case CLUB_FAMILY:
      ok = CONTROL_ROOM->is_valid_family_name(club);
      break;
    case CLUB_PERSONAL:
    case CLUB_ELECTED:
      ok = CONTROL_ROOM->is_valid_club_name(club);
      break;
    }
    if(!ok)
      tmp += club_line(club, width, extra == "verbose");
    else if(check_dodgy_name(club))
      tmp2 += club_line(club, width, extra == "verbose");
  }
  if(tmp == "")
    write("No invalid clubs.\n");
  else
    this_player()->more_string(tmp, "Clubs", 1);
  if(tmp2 == "")
    write("No dodgy clubs.\n");
  else
    this_player()->more_string("Dodgy names:\n\n" + tmp2, "Clubs", 1);
}
private int do_delete(string club, string reason, int width) {
  string founder, members, message, cname;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return notify_fail("You must be a lord to delete a club.");
  if(!club)
    return notify_fail("You must give a club name.\n");
  if(!CLUB_HANDLER->is_club(club))
    return notify_fail(club+" is not a current club.\n");
  write("Disbanding: " + club);
  founder = CLUB_HANDLER->query_founder(club);
  members = implode(CLUB_HANDLER->query_members(club), ", ");
  cname = CLUB_HANDLER->query_club_name(club);
  if(CLUB_HANDLER->disband_club(club)) {
    write(" succeeded.\n");
    message = sprintf("The club %s has been deleted by %s for "
                      "%s\n", cname,
                      this_player()->query_name(),
                      reason);
    MAILER->do_mail_message(founder, this_player()->query_name(),
                            "Your club has been deleted.",
                            members, message);
  } else
    write(" failed.\n");
  return 1;
}
mixed *query_patterns() {
  return ({
            "invalid", (: cmd("invalid", "", "") :),
            "invalid <string>", (: cmd("invalid", $4[0], "") :),
            "delete <word> <string>", (: cmd("delete", $4[0], $4[1]) :),
        });
}

==================================================
FILE: lord/conv.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
private string print_access(string bit, mapping bing, int depth, int cols, string filter);
mixed cmd(string ip, string ident, string level, string reason) {
   seteuid("Root");
   if (this_player() != this_player(1))
      return 0;
   switch(level) {
   case "nonew":
      level = "2";
      break;
   case "noacccess":
      level = "3";
      break;
   case "normal":
      level = "1";
      break;
   }
   if (!"/secure/bastards.old"->change_access(explode(ip, "."), ident,
                                                             to_int(level), reason)) {
      write("Error changing permissions.\n");
      return 0;
   }
   write("Access permisions changed.\n");
   printf("User %s at site %s set to %s for %s\n",
             ident, ip, PERM_NAMES[to_int(level)], reason);
   return 1;
}
int access(string filter) {
   mixed bing;
   seteuid("Root");
   if (this_player() != this_player(1))
      return 0;
   bing = (mixed)"/secure/bastards.old"->query_all_access();
   if (!m_sizeof(bing)) {
      notify_fail("No access control defined.\n");
      return 0;
   }
   write("Current access list:\n");
   bing = print_access("", bing, 0, (int)this_player()->query_cols(), filter);
   this_player()->more_string(bing, "site access");
   return 1;
}
private string print_access(string bit, mapping bing, int depth, int cols,
                            string filter) {
   mixed *bits;
   int i;
   string ret;
   string colour;
   ret = "" ;
   if (this_player() != this_player(1)) {
      return 0;
   }
   bits = m_indices(bing);
   if (depth == 4) {
      if(!filter || filter == "" ||
          strsrch(bit, filter) != -1 || strsrch(bits[i], filter) != -1) {
         for (i=0;i<sizeof(bits);i++) {
            switch (bing[bits[i]][0]) {
            case NO_NEW:
               colour = "%^CYAN%^";
               break;
            case NO_ACCESS:
               colour = "%^YELLOW%^";
               break;
            default :
               colour = "";
               break;
            }
            write(replace(bit, ".*", "")[1..] + "\n");
            "/secure/bastards"->change_access(replace(bit, ".*", "")[1..],
                                              bing[bits[i]][0],
                 "/secure/bastards.old"->query_reason(explode(bit, "."), bits[i]));
         }
      }
      return "";
   }
   for (i=0;i<sizeof(bits);i++) {
      ret += print_access(bit+"."+bits[i], bing[bits[i]], depth+1, cols,
                          filter);
   }
   return ret;
}
int help() {
   return notify_fail(
      "Syntax: site access\n"+
      "            site ban <ip number> <ident> <level> <reason>\n"+
      "                         <level> := normal [1] normal access,\n"+
      "                                          nonew [2] no new players, \n"+
      "                                          noaccess [3] no access.\n");
}
mixed *query_patterns() {
   return ({ "ban <word'address'> <word'ident'> <word'level'> "
                     "<string'reason'>",
                     (: cmd($4[0], $4[1], $4[2], implode($4[3..], "")) :),
                     "access <word'address'>", (: access($4[0]) :),
                     "access", (: access("") :),
                     "", (: help() :),
                     "help", (: help() :)
                     });
}

==================================================
FILE: lord/dinfo.c
==================================================

#include <player_handler.h>
string master;
string dinfo( string name, int cols, string option );
string get_last_log( int last_log_on );
mixed cmd(string name, string option) {
  if (!name) {
    return notify_fail("You must give a domain.\n");
  }
  this_player()->more_string(dinfo(name, (int)this_player()->query_cols(),
                                   option), "Domain Info");
  return 1;
}
string dinfo( string name, int cols, string option ) {
  string ret, *members;
  int i;
  if(member_array(name, "/secure/master"->query_domains()) == -1)
    return "No such domain: " + name + "\n";
  master = "/d/"+name+"/master";
  write(master+"\n");
  members = master->query_members();
  switch (option[0..0]) {
  case "n":
    members = sort_array(members, 1);
    break;
  case "p":
    members = sort_array(members,
                         (: strcmp(master->query_project($1),
                                   master->query_project($2)) :));
    break;
  case "l":
    members = sort_array(members,
                         (:PLAYER_HANDLER->test_last($2) -
                          PLAYER_HANDLER->test_last($1):));
    break;
  }
  ret = "The current members of this domain are:";
  for (i=0;i<sizeof(members);i++) {
    ret += sprintf("\n%-12s: Last login: %s\n",
                   capitalize(members[i]),
                   find_player(members[i])?
                     "%^GREEN%^%^BOLD%^Now%^RESET%^"
                     :get_last_log((int)PLAYER_HANDLER->test_last(members[i])),
                   );
    ret += sprintf("              Project   : %-=*s\n", cols-27,
                   master->query_project(members[i]));
  }
  return ret;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}
string get_last_log(int last_log_on) {
    string retval;
    int tmp_time, sec, min, hour, day;
    tmp_time = time()-last_log_on;
    if (!tmp_time) {
      sec = min = hour = day = 0;
    }
    if(tmp_time > 24*60*60) {
      retval = (day = tmp_time/(24*60*60))+" day"+
                (day<2?"":"s")+" ago.";
      if(day > 14)
        retval = "%^RED%^"+retval+"%^RESET%^";
      else if(day > 7)
        retval = "%^YELLOW%^"+retval+"%^RESET%^";
      else
        retval = "%^GREEN%^"+retval+"%^RESET%^";
    } else
      retval = "%^GREEN%^Today%^RESET%^";
    return retval;
}
mixed query_patterns() {
  return ({
    "<string'domain'>", (: cmd($4[0], " ") :),
    "<string'domain'> [by] {n|name|p|project|l|login}",
      (: cmd($4[0], $4[1]) :)
  });
}

==================================================
FILE: lord/dom_ain.c
==================================================

#include <parser.h>
#include <access.h>
#include <player_handler.h>
inherit "/cmds/base";
#define MASTER "/secure/master"
string get_last_log( int last_log_on );
string master;
int list(string arg) {
  int i, num, cols;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = get_dir("/d/");
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  if(arg) {
    if(member_array(arg, domains) == -1) {
      notify_fail("No such domain as " + arg + ".\n");
      return 0;
    } else {
      mast = "/d/" + arg + "/master";
      write(capitalize((string)mast->query_lord()) + " is the lord of " +
        arg + ".\nMembers         Project\n");
      members = (string *)mast->query_members();
      cols = (int)this_player()->query_cols();
      for (i=0;i<sizeof(members);i++)
        printf("%-15s %*-=s\n", members[i], cols-16,
                               mast->query_project(members[i]));
      return 1;
    }
  }
  write("Current domains:\n");
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    members = (string *)mast->query_members(arg);
    printf( "%15s has %2d %-7s and is owned by %s.\n", domains[ i ],
            num = sizeof( (string *)mast->query_members() ),
            ( ( num == 1 ) ? "member" : "members" ),
            capitalize( (string)mast->query_lord() ) );
  }
  return 1;
}
int add_creator(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if(!mast->add_member(cre)) {
    notify_fail("Failed to add " + capitalize(cre) + " to domain " +
      dom + ".\n");
    return 0;
  }
  write("Creator " + capitalize(cre) + " now added to domain " + dom + ".\n");
  return 1;
}
int delete_creator(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if (!mast->remove_member(cre)) {
    notify_fail("Failed to remove " + capitalize(cre) + " from domain " +
       dom + "\n");
    return 0;
  }
  write("Member " + capitalize(cre) + " removed from domain " + dom + ".\n");
  return 1;
}
int do_project(string cre, string dom, string project) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if((string)mast->query_lord() != geteuid(previous_object()) &&
     !"/secure/master"->query_player_trustee(this_player()->query_name())) {
    notify_fail("You are not the Lord of that domain.\n");
    return 0;
  }
  if (!mast->set_project(cre, project)) {
    notify_fail("Failed to set the project " + project + " for " +
                capitalize(cre) + " in the domain " + dom + "\n");
    return 0;
  }
  write("Project for " + capitalize(cre) + " set to " + project +
        " in the domain " + dom + ".\n");
  return 1;
}
#ifdef DISABLED
int do_info() {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;
  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = "/secure/master"->query_domains();
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!PLAYER_HANDLER->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
    creators -= mem;
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!PLAYER_HANDLER->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  cre_not -= ({ ".dead_ed_files", ".old_creators" });
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
}
#endif
int detailed_info( string name, string option ) {
  string ret, *members;
  int i, cols;
  if(member_array(name, "/secure/master"->query_domains()) == -1)
    return notify_fail("No such domain: " + name + "\n");
  cols = this_player()->query_cols();
  master = "/d/"+name+"/master";
  write(master+"\n");
  members = master->query_members();
  switch (option[0..0]) {
  case "n":
    members = sort_array(members, 1);
    break;
  case "p":
    members = sort_array(members,
                         (: strcmp(master->query_project($1),
                                   master->query_project($2)) :));
    break;
  case "l":
    members = sort_array(members,
                         (:PLAYER_HANDLER->test_last($2) -
                          PLAYER_HANDLER->test_last($1):));
    break;
  }
  ret = "The current members of this domain are:";
  for (i=0;i<sizeof(members);i++) {
    ret += sprintf("\n%-12s: Last login: %s\n",
                   capitalize(members[i]),
                   find_player(members[i])?
                     "%^GREEN%^%^BOLD%^Now%^RESET%^"
                     :get_last_log((int)PLAYER_HANDLER->test_last(members[i])),
                   );
    ret += sprintf("              Project   : %-=*s\n", cols-27,
                   master->query_project(members[i]));
  }
  this_player()->more_string(ret, "Domain Info");
  return 1;
}
string get_last_log(int last_log_on) {
    string retval;
    int tmp_time, sec, min, hour, day;
    tmp_time = time()-last_log_on;
    if (!tmp_time) {
      sec = min = hour = day = 0;
    }
    if(tmp_time > 24*60*60) {
      retval = (day = tmp_time/(24*60*60))+" day"+
                (day<2?"":"s")+" ago.";
      if(day > 14)
        retval = "%^RED%^"+retval+"%^RESET%^";
      else if(day > 7)
        retval = "%^YELLOW%^"+retval+"%^RESET%^";
      else
        retval = "%^GREEN%^"+retval+"%^RESET%^";
    } else
      retval = "%^GREEN%^Today%^RESET%^";
    return retval;
}
mixed *query_patterns() {
  return ({
    "list <string'list'>", (: list($4[0]) :),
    "add <word'creator'> <word'domain'>", (: add_creator($4[0], $4[1]) :),
    "delete <word'creator'> <word'domain'>",
      (: delete_creator($4[0], $4[1]) :),
    "project <word'creator'> <word'domain'> <string'project'>",
      (: do_project($4[0], $4[1], implode($4[2..], " ")) :),
#ifdef DISABLED
    "info", (: do_info() :),
#endif
    "info <string'domain'>", (: detailed_info($4[0], " ") :),
    "info <string'domain'> [by] {n|name|p|project|l|login}",
      (: detailed_info($4[0], $4[1]) :) });
}

==================================================
FILE: lord/domainlock.c
==================================================

#include <applications.h>
inherit "/cmds/base";
int domain_check() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  foreach (string s, int o in map) {
    ret += capitalize (s) + " is " + (o ? "open" : "closed") + " to "
      "applications and is managed by " +
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n";
  }
  this_player()->more_string (ret);
  return 1;
}
int cmd( string domain, int status ) {
  int i = APPLICATIONS_HANDLER->query_domain_status()[domain];
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "You do not have "
      "permission to close the " + domain + " domain.\n");
    return 0;
  }
  if (status != i) {
    APPLICATIONS_HANDLER->toggle_domain_lock (domain);
    this_player()->add_succeeded_mess (this_object(), "$N furtively "
      "toggle$s something.\n", ({ }));
    return 1;
  }
  this_player()->add_failed_mess (this_object(), "Your domainlock is "
    "already set to that.\n", ({ }));
  return 0;
}
mixed *query_patterns() {
    return ({ "<string'domain'> on", (: cmd( $4[0], 0 ):),
      "<string'domain'> off", (: cmd( $4[0], 1  ):),
      "list", (: domain_check() :) });
}

==================================================
FILE: lord/invcheck.c
==================================================

#define INV_CHECK "/d/admin/obj/inv_check"
inherit "/cmds/base";
int cmd( string filename, string switch_on) {
    switch (switch_on) {
      case "ban":
        INV_CHECK->ban_object (filename);
      break;
      case "unban":
        INV_CHECK->unban_object (filename);
      break;
      default:
        tell_object (this_player(), INV_CHECK->list_banned());
      break;
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "ban <string'filename'>", (: cmd( $4[0], "ban"):),
      "unban <string'filename'>", (: cmd( $4[0], "unban"  ):),
      "list", (: cmd("", "list"):)});
}

==================================================
FILE: lord/jumps.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }
   return load_object(str);
}
int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;
   from_ob = find_location(from);
   to_ob = find_location(to);
   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }
   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}
int do_path_list() {
   string str;
   string from;
   string* dest;
   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}
int do_remove_jump(string from, string to) {
   string* dests;
   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}

==================================================
FILE: lord/mkdirect_or.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_trustee( previous_object( -1 ) ) )
    return notify_fail("You must be a trustee to add a director.\n");
  if("/secure/master"->add_director(creator)) {
    write(creator + " promoted to directorship.\n");
    return 1;
  } else
    return notify_fail("Call to add_director failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/mkl_ord.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->high_programmer( previous_object( -1 ) ) )
    return notify_fail("You must be a highlord to add a lord.\n");
  if("/secure/master"->add_director(creator)) {
    write(creator + " promoted to director.\n");
    return 1;
  } else
    return notify_fail("Call to add_director failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/mks_enior.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_lord( previous_object( -1 ) ) )
    return notify_fail("You must be a lord to create a senior creator.\n");
  if("/secure/master"->add_senior(creator)) {
    write(creator + " promoted to senior.\n");
    return 1;
  } else
    return notify_fail("Call to add_senior failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/nskills.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
int new_skill_value(int sk) {
	float f = 1000.0;
	float k = 0.3;
	if(sk == 0)
		return 0;
	return to_int(f * log( 1.0 + sk/(f + sk * k) ) + 0.5);
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      if(tp[0..14] != ".other.language" && tp[0..13] != "other.language") {
        sk = new_skill_value(sk);
      }
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)new_skill_value(pl->query_skill_bonus( tp )) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
int cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );
		 this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
     result += "New guild level: " +
		   (pl->query_guild_ob())->query_new_level(pl) + "\n";
   this_player()->more_string( result, "Skills" );
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}
mixed *query_patterns() {
  return ({ "<indirect:any-living> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:any-living>",
            (: cmd($1, 0) :) });
}

==================================================
FILE: lord/playera_ddproperty.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
string var_name = "map_prop ";
string fname;
mixed cmd(string player, string name, mixed value) {
   mixed *args;
   string file;
   string *bits;
   mapping map_prop;
   int i, found;
   seteuid("Root");
   fname = "/save/players/" + player[0..0] + "/" + player;
   map_prop = ([ ]);
   if (!PLAYER_HANDLER->test_user(player))
     return notify_fail("Unable to find player "+player+".\n");
   uncompress_file (fname+".o.gz");
   file = unguarded( (: read_file(fname+".o") :));
   if(!file)
     return notify_fail("Error reading player file " + fname + ".\n");
   bits = explode(file, "\n");
   map_prop = ([ ]);
   for (i = 0; i < sizeof(bits); i++) {
     if (bits[i][0..strlen(var_name)-1] == var_name) {
       map_prop = restore_variable(bits[i][strlen(var_name) + 0..]);
       found = 1;
       break;
     }
   }
   if(!found || !map_prop)
     return notify_fail("Failed to find property mapping.\n");
   if(stringp(args)) {
     args = PARSER->parse_args(value);
     if(!args || !sizeof(args[0]))
       return notify_fail("No useful args...\n");
     map_prop[name] = args[0][0];
     write(sprintf("Added property %s to %s; value = %O\n",
                   name, player, args[0][0]));
   } else {
     map_prop[name] = value;
   }
   if (i < sizeof(bits)) {
     bits[i] = var_name + save_variable(map_prop);
   } else {
     bits += ({ var_name + save_variable(map_prop) });
   }
   unguarded( (: rm(fname + ".old") :) );
   unguarded( (: rename(fname+".o", fname+".old") :) );
   unguarded( (: write_file(fname + ".o",
                            implode($(bits), "\n") + "\n") :));
   compress_file (fname+".o");
   this_player()->add_succeeded_mess (this_object(), "$N manipulate$s "
    "reality a little.\n", ({ }));
   return 1;
}
mixed *query_patterns() {
  return ({ "<word> <string:quoted> <string>", (: cmd($4[0], $4[1], $4[2]) :),
            });
}

==================================================
FILE: lord/playerp_roperty.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mapping map_prop;
mixed cmd(string str) {
   string name;
   string value;
   string player;
   mixed *args;
   if (!str) {
      return notify_fail("You must give a property...\n");
   }
   if (sscanf(str, "%s \"%s\" %s", player, name, value) == 3) {
      seteuid("Root");
      unguarded( (: restore_object("/players/" + $(player[0..0]) +
                                   "/" + $(player)) :));
      if (PLAYER_HANDLER->test_user(player)) {
         args = PARSER->parse_args(value);
         if (args && sizeof(args[0]) > 0) {
            map_prop[name] = args[0][0];
            unguarded( (: write_file("/players/" + $(player[0..0]) +
                               "/" + $(player) + ".o",
                       "map_prop "+save_variable(map_prop)+"\n") :));
            write(sprintf("Added property %s to %s; value = %O\n",
                          name, player, args[0][0]));
         } else {
            write("No useful args...\n");
         }
      } else {
         write("Unable to find player "+player+".\n");
      }
   } else {
      write("Syntax: player_add_property <name> \"<prop>\" <value>\n");
   }
   return 1;
}

==================================================
FILE: lord/ptest_ers.c
==================================================

#include <player.h>
#define LOGIN "/secure/login"
inherit "/cmds/base";
int main_menu( string cmd, string name, string reason ) {
   string str;
   switch ( cmd[ 0 ] ) {
      case 'L' :
      case 'l' :
         str = PLAYTESTER_HAND->query_show_list();
         str += "\n\nSee: 'ptesters H' for help.\n";
         this_player()->more_string(str, "Playtester");
         return 1;
      case 'A' :
      case 'a' :
         if ( !name ) {
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if (!PLAYTESTER_HAND->valid_playtester( name ) ) {
            printf( capitalize( name ) + " cannot be made a play tester "
                    "because: " + PLAYTESTER_HAND->reason_invalid_playtester(name) +
                    ".\n");
            break;
         }
         if ( (int)PLAYTESTER_HAND->add_playtester( name ) ) {
            printf( capitalize( name ) +" is now a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is already a playtester.\n" );
         }
         break;
      case 'S' :
      case 's' :
         if ( !name ) {
            return 0;
         }
         if ( !PLAYTESTER_HAND->query_playtester( name ) ) {
            printf( capitalize( name ) +" is not yet a playtester.\n" );
         } else {
            if ( (int)PLAYTESTER_HAND->add_senior_playtester( name ) ) {
               printf( capitalize( name ) +" is now a senior playtester.\n" );
            } else {
               printf( capitalize( name ) +" is already a senior playtester.\n" );
            }
         }
         break;
      case 'R' :
      case 'r' :
         if ( !name ) {
            return 0;
         }
         if ( !reason) {
            notify_fail("You need to supply a reason when deleting someone.\n");
            return 0;
         }
         if ( !LOGIN->test_user( name ) ) {
            printf( capitalize( name ) +" does not exist.\n" );
            break;
         }
         if ( (int)PLAYTESTER_HAND->remove_playtester( name, reason ) ) {
            printf( capitalize( name ) +" is no longer a playtester.\n" );
         } else {
            printf( capitalize( name ) +" is not a playtester.\n" );
         }
         break;
      default :
      case 'H' :
      case 'h' :
      case '?' :
         printf( "\nPlaytesters editor commands:\n\n"
               "Q        : quit the playtester editor\n"
               "L        : list playtesters\n"
               "A <name> : add a new playtester\n"
               "S <name> : promote someone to senior playtester\n"
               "R <name> : remove an existing playtester\n"
               "H        : get this list of commands\n\n" );
         break;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: main_menu("L", 0, 0) :),
             "{l|h|?}", (: main_menu($4[0], 0, 0) :),
             "{a|s|h|r|?} <word>", (: main_menu($4[0], $4[1], 0) :),
             "r <word> <string>", (: main_menu("r", $4[0], $4[1]) :) });
}

==================================================
FILE: lord/quests.c
==================================================

#include <quest_handler.h>
#define TEXTS_DIR "/save/quests/"
inherit "/cmds/base";
private string *names;
private mapping makers;
protected void create() {
   makers = ([ ]);
}
private void print_info( int i ) {
   string text;
   text = read_file( TEXTS_DIR + replace( names[ i ], " ", "_" ) +".txt" );
   if ( !text )
      text = "There is no text file for this quest.\n";
   printf( "\nQuest %d of %d  \"%s\", level %d\n"
           "   title: %s\n   story: %s\n"
           "   Active: %s\n"
           "   completed %d times, last by %s\n\n"
           "%s\n",
           i + 1, sizeof( names ), names[ i ],
           (int)QUEST_HANDLER->query_quest_level( names[ i ] ),
           (string)QUEST_HANDLER->query_quest_title( names[ i ] ),
           (string)QUEST_HANDLER->query_quest_story( names[ i ] ),
           (int)QUEST_HANDLER->query_quest_status(names[i]) ? "Yes" : "No",
           (int)QUEST_HANDLER->query_quest_times( names[ i ] ),
           capitalize( (string)QUEST_HANDLER->query_quest_done( names[ i ] ) ),
           text );
}
private void change_status( int i ) {
  switch(QUEST_HANDLER->change_quest_status(names[i])) {
  case 1:
    printf("Quest %s set to active.\n", names[i]);
    break;
  case 0:
    printf("Quest %s set to inactive.\n", names[i]);
    break;
  case -1:
    printf("No such quest: %s.\n", names[i]);
    break;
  }
}
void main_menu( string word ) {
   int number, which;
   string name;
   mixed *args;
   which = makers[ this_player() ][ 0 ];
   args = makers[ this_player() ][ 1 ];
   if ( !word || ( word == "" ) )
      word = " ";
   switch ( word[ 0 ] ) {
      case 'Q' :
      case 'q' :
         return;
      case 'N' :
      case 'n' :
         if ( which > sizeof( names ) - 2 ) {
            printf( "No more quests.\n" );
            which = sizeof( names ) - 1;
            break;
         }
         which++;
         print_info( which );
         break;
      case 'A':
      case 'a':
         change_status(which);
         break;
      case 'P' :
      case 'p' :
         if ( which < 1 ) {
            printf( "No previous quests.\n" );
            which = 0;
            break;
         }
         which--;
         print_info( which );
         break;
      case 'G' :
      case 'g' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: G <number>\n" );
            break;
         }
         if ( sscanf( word[ 2 .. ], "%d", number ) != 1 ) {
            printf( "Syntax: G <number>\n" );
            break;
         }
         if ( ( number < 1 ) || ( number > sizeof( names ) ) ) {
            printf( "Number must be between 1 and %d.\n", sizeof( names ) );
            break;
         }
         which = number - 1;
         print_info( which );
         break;
      case 'C' :
      case 'c' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: C <quest>\n" );
            break;
         }
         if ( args[ 0 ] < 1 ) {
            printf( "No quest level set.\n" );
            break;
         }
         if ( !stringp( args[ 1 ] ) ) {
            printf( "No quest title set.\n" );
            break;
         }
         if ( !stringp( args[ 2 ] ) ) {
            printf( "No quest story set.\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, names ) != -1 ) {
            printf( "There is already a quest \""+ word +"\".\n" );
            break;
         }
         QUEST_HANDLER->add_quest( word, args[ 0 ], args[ 1 ], args[ 2 ] );
         names += ({ word });
         args = allocate( 3 );
         printf( "Quest \""+ word +"\" added.\n" );
         which = sizeof( names ) - 1;
         print_info( which );
         break;
      case 'L' :
      case 'l' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: L <level>\n" );
            break;
         }
         if ( sscanf( word[ 2 .. ], "%d", number ) != 1 ) {
            printf( "Syntax: L <level>\n" );
            break;
         }
         if ( number < 1 ) {
            printf( "Level must be at least 1.\n" );
            break;
         }
         args[ 0 ] = number;
         printf( "Quest level set to "+ number +".\n" );
         break;
      case 'T' :
      case 't' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: T <title>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, (string)QUEST_HANDLER->query_quest_titles() )
               != -1 ) {
            printf( "There is already a quest that gives the title \""+
                  word +"\".\n" );
            break;
         }
         args[ 1 ] = word;
         printf( "Quest title set to \""+ word +"\".\n" );
         break;
      case 'S' :
      case 's' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: S <story>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, (string)QUEST_HANDLER->query_quest_stories() )
               != -1 ) {
            printf( "There is already a quest that has the story \""+
                  word +"\".\n" );
            break;
         }
         args[ 2 ] = word;
         printf( "Quest story set to \""+ word +"\".\n" );
         break;
      case 'R' :
      case 'r' :
         printf( "\nQuest data so far:\n" );
         if ( args[ 0 ] < 1 )
            word = "not set";
         else
            word = sprintf( "%d", args[ 0 ] );
         printf( "   level: %s\n", word );
         if ( !stringp( args[ 1 ] ) )
            word = "not set";
         else
            word = args[ 1 ];
         printf( "   title: %s\n", word );
         if ( !stringp( args[ 2 ] ) )
            word = "not set";
         else
            word = args[ 2 ];
         printf( "   story: %s\n\n", word );
         break;
      case 'E' :
      case 'e' :
         printf( "Editing the text file...\n"
               "The log will show that you edited this file; if you "
               "ruin it,\nyou will be hunted down and eviscerated.\n" );
         this_player()->do_edit( read_file( TEXTS_DIR +
               replace( names[ which ], " ", "_" ) +".txt" ),
               "end_edit" );
         return;
      case 'F' :
      case 'f' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: F <word>\n" );
            break;
         }
         word = word[ 2 .. ];
         number = 0;
         foreach ( name in ( names[ which + 1 .. ] + names[ 0 .. which ] ) ) {
            which = ( which + 1 ) % sizeof( names );
            if ( strsrch( name, word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
            if ( strsrch( lower_case( (string)QUEST_HANDLER->
                  query_quest_title( name ) ), word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
            if ( strsrch( lower_case( (string)QUEST_HANDLER->
                  query_quest_story( name ) ), word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
         }
         if ( !number )
            printf( "\""+ word +"\" not found.\n" );
         break;
      case 'H' :
      case 'h' :
         printf( "\nQuest editor commands:\n\n"
               "Q          : quit the quest editor\n"
               "N          : go to the next quest\n"
               "P          : go to the previous quest\n"
               "G <number> : go to a particular quest by number\n"
               "A          : toggle a quests active/inactive flag\n"
               "C <quest>  : create a new quest\n"
               "L <level>  : set a new quest's level\n"
               "T <title>  : set a new quest's title\n"
               "S <story>  : set a new quest's story\n"
               "R          : review the new quest's data\n"
               "E          : edit the quest's text file\n"
               "F <word>   : find the next quest using that word\n"
               "H          : get this list of commands\n\n"
               "To create a new quest, set the level, title and \n"
               "story first, then use C to create the quest with \n"
               "the title that creators will see.\n\n"
               "No command will reprint the current quest.\n\n" );
         break;
      default :
         print_info( which );
   }
   makers[ this_player() ] = ({ which, args });
   printf( "Choose one of Q, N, P, G, C, L, T, S, R, E, F or H (for help) : " );
   input_to( "main_menu" );
}
void end_edit( string text ) {
   string name;
   if ( !text || ( text == "" ) ) {
      printf( "Aborted.\n" );
      main_menu( "Z" );
      return;
   }
   if ( text[ <1 ] != '\n' )
      text += "\n";
   name = names[ makers[ this_player() ][ 0 ] ];
   log_file( "QUESTS", ctime( time() ) +" "+
         (string)this_player()->query_name() +
         " changed text file for "+ name +"\n" );
   printf( "Writing file...\n" );
   unguarded( (: write_file, TEXTS_DIR + replace( name, " ", "_" ) +
         ".txt", text, 1 :) );
   main_menu( "Z" );
}
private int cmd() {
   names = (string *)QUEST_HANDLER->query_quest_names();
   makers[ this_player() ] = ({ 0, allocate( 3 ) });
   main_menu( "G 1" );
   return 1;
}
public mixed *query_patterns() {
    return ({ "", (: cmd() :) });
}

==================================================
FILE: lord/resetpw.c
==================================================

#include <parser.h>
#include <liaison.h>
#include <player_handler.h>
inherit "/cmds/base";
string basename;
string file;
int do_reset(string player, string newpw) {
  string password;
  string *bits, t1, t2;
  int i;
  if(base_name(previous_object())[0..12] != "/secure/login" &&
     base_name(previous_object())[0..13] != "/secure/nlogin") {
    if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
                 ": illegal attempt to reset password.\nTrace: " + back_trace()
                 :));
      return 0;
    }
    if (!master()->high_programmer(previous_object(-1)) &&
        !(master()->query_director(previous_object(-1)) &&
          this_player(1)->query_name() == "/d/liaison/master"->query_lord())) {
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
                 ": illegal attempt to reset password.\nTrace: " + back_trace()
                 :));
      return 0;
    }
  }
  seteuid("Root");
  if (PLAYER_HANDLER->test_user(player)) {
    basename = "/save/ramdisk/players/" + player[0..0] + "/" + player;
    if(file_size(basename+".o.gz")>0 ||
       file_size(basename+".o")>0) {
      unguarded((: uncompress_file(basename+".o.gz") :));
    } else {
      basename = "/save/players/" + player[0..0] + "/" + player;
      if(file_size(basename+".o.gz")>0 ||
         file_size(basename + ".o") > 0) {
        unguarded((: uncompress_file(basename+".o.gz") :));
      } else {
        basename = "/save/players/delete/" + player;
        if(file_size(basename+".o.gz")>0) {
          unguarded((: uncompress_file(basename+".o.gz") :));
        }
      }
    }
    file = unguarded( (: read_file(basename + ".o") :));
    if(!file) {
      write("Error reading file " + basename + ".\n");
      return notify_fail("Error reading file " + basename +".o\n");
    }
    bits = explode(file, "\n");
    for (i = 0; i < sizeof(bits); i++) {
      if (bits[i][0..strlen("password")-1] == "password") {
        t1 = bits[i];
        password = restore_variable(bits[i][strlen("password") + 1..]);
        break;
      }
    }
    password = crypt(newpw, newpw[0..1]);
    t2 = "password " + save_variable(password);
    file = replace(file, t1, t2);
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", file) :));
    unguarded( (: compress_file(basename+".o") :));
    PLAYER_HANDLER->remove_cache_entry(player);
    return 1;
  }
  return 0;
}
mixed cmd(string player, string newpw) {
  if(!newpw || newpw == "")
    return notify_fail("Syntax: resetpw <player> <new password>\n");
  if(do_reset(player, newpw)) {
    write(sprintf("Reset password for %s to %s\n", player, newpw));
  } else {
    write("Unable to find player "+player+".\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word> <string>", (: cmd($4[0], $4[1]) :),
            });
}

==================================================
FILE: lord/rmdirector.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_trustee( previous_object( -1 ) ) )
    return notify_fail("You must be a trustee to remove a director.\n");
  if("/secure/master"->remove_director(creator)) {
    write(creator + " removed from directorship.\n");
    return 1;
  } else
    return notify_fail("Call to remove_director failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/rms_enior.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_lord( previous_object( -1 ) ) )
    return notify_fail("You must be a lord to remove a senior creator.\n");
  if("/secure/master"->remove_senior(creator)) {
    write(creator + " removed from senior.\n");
    return 1;
  } else
    return notify_fail("Call to remove_senior failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/rstats.c
==================================================

inherit "/cmds/base";
int cmd(string str) {
  mapping stats;
  string obj, file;
  int total, num;
  stats = "/secure/master"->query_read_stats();
  if(str) {
    if(!stats[str])
      return notify_fail("No such file\n");
    foreach(file in keys(stats[str])) {
      if(stats[str][file] > 1)
        printf("%-60s %5d\n", file, stats[str][file]);
    }
    return 1;
  }
  printf("%-60s %5s %5s\n", "Object", "Total", "Files");
  foreach(obj in keys(stats)) {
    total = 0;
    num = 0;
    foreach(file in keys(stats[obj])) {
      num++;
      total += stats[obj][file];
    }
    if(total > 200)
      printf("%-60s %5d %5d\n", obj, total, num);
  }
  return 1;
}

==================================================
FILE: lord/site.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
mixed cmd(string address, string level, string reason) {
   seteuid("Root");
   if (this_player() != this_player(1))
      return 0;
   switch(level) {
   case "nonew":
      level = "2";
      break;
   case "noacccess":
      level = "3";
      break;
   case "authnew":
     level = "4";
     break;
   case "normal":
      level = "1";
      break;
   }
   address = replace(address, ".*", "");
   if (!"/secure/bastards"->change_access(address, to_int(level), reason)) {
     write("Error changing permissions.\n");
     return 0;
   }
   write("Access permisions changed.\n");
   printf("Site %s set to %s for %s\n", address, PERM_NAMES[to_int(level)],
          reason);
   return 1;
}
int access(string filter) {
  string addr, ret;
  mapping list;
  int found;
  seteuid("Root");
  if (this_player() != this_player(1))
    return 0;
  list = "/secure/bastards"->query_all_access();
  ret = "";
  foreach(addr in keys(list)) {
    if(!filter || filter == "" || strsrch(addr, filter) != -1) {
      found = 1;
      ret += sprintf("%-20s %-18s %-=39s\n", addr,
                     PERM_NAMES[list[addr][ACCESS_LEVEL]],
                     list[addr][ACCESS_REASON]);
    }
  }
  if (!found)
    return notify_fail("No access control defined.\n");
  write("Current access list:\n");
  this_player()->more_string(ret, "site access");
  return 1;
}
int multi(int allow, string address) {
  if("/secure/bastards"->change_multi(address, allow, 0)) {
    if(allow)
      write("Site " + address + " has been permitted for multiplayers.\n");
    else
      write("Site " + address + " has been blocked for multiplayers.\n");
  } else
    write("Error multiplayer settings for site " + address + ".\n");
  return 1;
}
int list_multi(string filter) {
  string addr, ret;
  mapping list;
  int found;
  list = "/secure/bastards"->query_all_multi();
  ret = "";
  foreach(addr in keys(list)) {
    if(!filter || filter == "" || strsrch(addr, filter) != -1) {
      found = 1;
      ret += sprintf("%-30s\n", addr);
    }
  }
  if (!found)
    return notify_fail("No access control defined.\n");
  write("Current multuser site list:\n");
  this_player()->more_string(ret, "site access");
  return 1;
}
int help() {
   return notify_fail(
      "Syntax: site access\n"+
      "            site ban <ip number|site name> <level> <reason>\n"+
      "                     <level> := normal normal access,\n"+
      "                                nonew no new players, \n"+
      "                                authnew authorised new players\n"+
      "                                noaccess no access.\n");
}
mixed *query_patterns() {
   return ({ "ban <word'address'> <word'level'> <string'reason'>",
               (: cmd($4[0], $4[1], implode($4[2..], "")) :),
               "allow multi <word'address'>",
               (: multi(1, $4[0]) :),
               "disallow multi <word'address'>",
               (: multi(0, $4[0]) :),
               "list multi", (: list_multi("") :),
               "list multi <word'address'>", (: list_multi($4[0]) :),
               "access <word'address'>", (: access($4[0]) :),
               "access", (: access("") :),
               "", (: help() :),
               "help", (: help() :)
               });
}

==================================================
FILE: lord/tmstats.c
==================================================

inherit "/cmds/base";
#include <tasks.h>
#define STATS_DIR "/save/tasks/"
#define DIVISOR 100
int do_summary();
int cmd(string str) {
  string file, cmd, tmp;
  mapping awards, summary, obs;
  int lvl, i, total, files;
  return do_summary();
  if(!str)
    str="";
  tmp = "";
  obs = ([ ]);
  summary = ([ ]);
  foreach(file in get_dir(STATS_DIR+str+"*")) {
    file = file[0..sizeof(file)-3];
    files++;
    awards = TASKER->query_stats(file);
    foreach(lvl in keys(awards)) {
      foreach(cmd in keys(awards[lvl])) {
        total += awards[lvl][cmd];
        obs[cmd] += 1;
      }
    }
  }
  foreach(cmd in keys(obs)) {
    if(obs[cmd] > 100)
      i += 1;
  }
  printf("%s: Skills: %d, Total: %d: Ratio: %d, Objects: %d, "
         "Obs over 100: %d\n",
         str, files, total, total/files, sizeof(keys(obs)), i);
  return 1;
}
int do_summary() {
  string skill;
  mapping sum, stats;
  int i;
  int tries, awards;
  stats = TASKER->query_stats("summary");
  sum = stats;
  foreach(skill in keys(sum)) {
    if("/std/skills"->query_skill(({ skill })) != skill)
      continue;
    printf("Skill: %s \n", skill);
    printf("  Level 0..49:       Tries: %d, Awards: %d, ",
           sum[skill][0][0], sum[skill][0][1]);
    if(sum[skill][0][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][0][0]/(sum[skill][0][1]));
    printf("  Level 50..149:     Tries: %d, Awards: %d, ",
           sum[skill][1][0], sum[skill][1][1]);
    if(sum[skill][1][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][1][0]/(sum[skill][1][1]));
    printf("  Level 150..299:    Tries: %d, Awards: %d, ",
           sum[skill][2][0], sum[skill][2][1]);
    if(sum[skill][2][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][2][0]/(sum[skill][2][1]));
    printf("  Level 300..599:    Tries: %d, Awards: %d, ",
           sum[skill][3][0], sum[skill][3][1]);
    if(sum[skill][3][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][3][0]/(sum[skill][3][1]));
    printf("  Level >= 600:      Tries: %d, Awards: %d, ",
           sum[skill][4][0], sum[skill][4][1]);
    if(sum[skill][4][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][4][0]/(sum[skill][4][1]));
    tries = 0;
    awards = 0;
    for(i=0; i<3; i++) {
      tries += sum[skill][i][0];
      awards += sum[skill][i][1];
    }
    printf("  Total:              Tries: %d, Awards: %d, ", tries, awards);
    if(!awards)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", tries/awards);
  }
  return 1;
}

==================================================
FILE: lord/wstats.c
==================================================

inherit "/cmds/base";
int cmd(string str) {
  mapping stats;
  string obj, file;
  int total, num;
  stats = "/secure/master"->query_write_stats();
  if(str) {
    if(!stats[str])
      return notify_fail("No such file\n");
    foreach(file in keys(stats[str])) {
      if(stats[str][file] > 1)
        printf("%-60s %5d\n", file, stats[str][file]);
    }
    return 1;
  }
  printf("%-60s %5s %5s\n", "Object", "Total", "Files");
  foreach(obj in keys(stats)) {
    total = 0;
    num = 0;
    foreach(file in keys(stats[obj])) {
      num++;
      total += stats[obj][file];
    }
        if(total > 50)
      printf("%-60s %5d %5d\n", obj, total, num);
  }
  return 1;
}

==================================================
FILE: player/accept.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
inherit "/cmds/base";
mixed do_surrender(object player) {
  object *victims;
  victims = this_player()->query_surrenderers();
  if (!victims  ||  member_array(player, victims) == -1) {
    add_failed_mess("Sorry, but $I has not offered to surrender to you.\n",
                    ({ player }) );
    return 0;
  }
  this_player()->remove_surrenderer(player);
  player->accepted_surrender(this_player());
  write("Good show!\n");
  return 1;
}
mixed do_club(string club_name, object *players) {
   object ob;
   string club;
   int ok;
   foreach (ob in players) {
      club = this_player()->query_respond_command(CLUB_RESPOND_TYPE, ob);
      if (club) {
         if (lower_case(club) == lower_case(club_name)) {
            if (CLUB_HANDLER->is_member_of(club_name,
                                           this_player()->query_name())) {
               add_failed_mess("You are already a member of '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "'.\n");
            } else {
               CLUB_HANDLER->add_member(club_name,
                                        this_player()->query_name());
               add_succeeded_mess("$N join$s '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "' with an invite from $I.\n",
                               ({ ob }) );
	       ob->remove_respond_command(CLUB_RESPOND_TYPE, ob);
               ok++;
               all_inventory(this_player())->event_joined_club(this_player(),
                                                               club_name);
            }
         } else {
            add_failed_mess("$I is inviting you to join '" +
                            CLUB_HANDLER->query_club_name(club) +
                            "' not '" + club_name + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to join any clubs.\n",
                         ({ ob }));
      }
   }
   return ok;
}
int do_family(string family,
              string relationship,
              object *players) {
   object ob;
   int ok;
   string curr_family;
   class family_response_data frog;
   curr_family = this_player()->query_family_name();
   if (curr_family) {
      curr_family = CLUB_HANDLER->query_club_name(curr_family);
   }
   relationship = CLUB_HANDLER->query_ungendered_relationship(relationship);
   if (!relationship) {
      add_failed_mess("Could not figure out the relationship.\n");
      return 0;
   }
   foreach (ob in players) {
      frog = this_player()->query_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                                  ob);
      if (!family) {
         family = frog->family;
      }
      if (frog && frog->family) {
         if (lower_case(frog->family) == lower_case(family)) {
  	    if (lower_case(frog->relationship) != lower_case(relationship)) {
               add_failed_mess("You were asked to have the relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(frog->relationship,
                                     this_player()->query_female()) +
                               "', not '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' in the family '" +
                               CLUB_HANDLER->query_club_name(frog->family) +
                               "'.\n");
	    } else if (CLUB_HANDLER->is_relationship(frog->family,
                                                     this_player()->query_name(),
                                                     ob->query_name(),
                                                     relationship) &&
                       frog->family == curr_family) {
               add_failed_mess("You have already setup a relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' with $I.\n", ({ ob }) );
            } else {
               if (!CLUB_HANDLER->is_member_of(frog->family,
                                               this_player()->query_name())) {
                  if (frog->family != curr_family &&
                      curr_family) {
                     if (!CLUB_HANDLER->move_family_member(curr_family,
                                                           this_player()->query_name(),
                                                           frog->family)) {
                       add_failed_mess("Unable to move you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  } else {
                     if (!CLUB_HANDLER->add_member(frog->family,
                                                  this_player()->query_name())){
                       add_failed_mess("Unable to add you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  }
                  this_player()->set_family_name(frog->family);
               }
	       if (!CLUB_HANDLER->is_relationship(frog->family,
                                                  this_player()->query_name(),
                                                  ob->query_name(),
                                                  relationship)) {
                  if (!CLUB_HANDLER->add_relationship(ob->query_family_name(),
                                                     ob->query_name(),
                                                     frog->family,
                                                     this_player()->query_name(),
                                                     relationship)) {
                     add_failed_mess("Unable to add the relationship to $I for "
                                     "some reason.\n");
                  } else {
                     add_succeeded_mess("$N set$s up a relationship with $I " +
                                        "in '" +
                                        CLUB_HANDLER->query_club_name(frog->family) +
                                        "'.\n",
                                        ({ ob }) );
                     ok++;
                  }
               } else {
                  add_succeeded_mess("$N set$s up a relationship with $I " +
                                     "in '" +
                                     CLUB_HANDLER->query_club_name(frog->family) +
                                     "'.\n",
                                     ({ ob }) );
                  ok++;
               }
               ob->remove_respond_command(CLUB_FAMILY_RESPOND_TYPE, ob);
            }
         } else {
            add_failed_mess("$I is inviting you to a relationship in '" +
                            CLUB_HANDLER->query_club_name(frog->family) +
                            "' not '" + family + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to setup any relationships.\n",
                         ({ ob }));
      }
   }
   return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:living:here>", (: do_surrender($1[0]) :),
            "invite from <indirect:living:here> to <string'club name'>",
                (: do_club($4[1], $1) :),
            "relationship from <indirect:living:here> to <string'family'> as <string'relationship'>",
                (: do_family($4[1], $4[2], $1) :),
            "relationship from <indirect:living:here> as <string'relationship'>",
	       (: do_family(this_player()->query_family_name(), $4[1], $1) :) });
}

==================================================
FILE: player/access.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#define TP this_player()
inherit "/cmds/base";
int cmd_list() {
   string *ips;
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if ( !sizeof(ips) )  {
     write( "You are allowed to login from anywhere.\n" );
   } else  {
     ips = sort_array(ips, 1);
     write( "You are currently allowed to login from: " +
            query_multiple_short(ips) + ".\n" );
   }
   return 1;
}
int enable( string str) {
   string *ips;
   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if(member_array(str, ips) == -1 )  {
     ips += ({ str });
     TP->set_rhosts(ips);
   } else  {
     write( "You are already allowed to login from  " + str + ".\n" );
   }
   write("You are now allowed to login from "+str+".\n");
   return 1;
}
int disable( string str) {
   string *ips;
   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if ( member_array( str, ips ) != -1 )  {
     ips -= ({ str });
     if(!sizeof(ips))
       TP->set_rhosts(0);
     else
       TP->set_rhosts(ips);
   } else  {
     write( "You are already not allowed to login from  " + str + ".\n" );
   }
   if(!sizeof(ips))
     write("You are now allowed to login from anywhere.\n");
   else
     write("You are not now allowed to login from "+str+".\n");
   return 1;
}
int authorise_for (string name, string address) {
  string fname;
  string file,  *bits;
  string var_name = "player_info ";
  mapping info = ([ ]);
  int i, found = 0;
  if (!this_player()->query_lord()) {
    return notify_fail ("You may not do this.\n");
  }
  if (find_player (name)) {
    return notify_fail ("This player is online.\n");
  }
  if (!PLAYER_HANDLER->test_user(name)) {
    return notify_fail ("No such player.\n");
  }
  seteuid("Root");
  fname = "/save/players/" + name[0..0] + "/" + name;
  uncompress_file (fname+ ".o.gz");
  file = unguarded( (: read_file($(fname)+".o") :));
  if (!file) {
    return notify_fail ("Error reading file.\n");
  }
   bits = explode(file, "\n");
   for (i = 0; i < sizeof(bits); i++) {
     if (bits[i][0..strlen(var_name)-1] == var_name) {
       info = restore_variable(bits[i][strlen(var_name)..]);
       found = 1;
       break;
     }
   }
  if(!found) {
    return notify_fail ("Cannot find mapping.\n");
  }
  if (address == "reset") {
    info["allowed_ips"] = ({ });
  }
  else if (sizeof (info ["allowed_ips"])) {
    if (member_array (address, info["allowed_ips"]) == -1) {
      info["allowed_ips"] += ({ address });
    }
  }
  else {
    info["allowed_ips"] = ({ address });
  }
  if (i < sizeof(bits)) {
     bits[i] = var_name + save_variable(info);
   } else {
     bits += ({ var_name + save_variable(info) });
  }
  unguarded( (: rm($(fname) + ".old") :) );
  unguarded( (: rename($(fname)+".o", $(fname)+".old") :) );
  unguarded( (: write_file($(fname) + ".o",
    implode($(bits), "\n") + "\n") :));
  compress_file (fname + ".o");
  unguarded( (: rm($(fname) + ".o") :) );
  PLAYER_HANDLER->remove_cache_entry(name);
  tell_object (this_player(), "Access for " + name + " changed.\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "enable <string'address'>", (: enable($4[0]) :),
              "disable <string'address'>", (: disable($4[0]) :),
              "for <string'name'> <string'address'>",
                (: authorise_for ($4[0], $4[1]) :),
              "reset for <string'name'>", (: authorise_for ($4[0],
              "reset") :),
              "", (: cmd_list() :) });
}

==================================================
FILE: player/al_ias.c
==================================================

#include <alias.h>
inherit "/cmds/base";
private nosave string gfilter;
string alias_string(mixed *al) {
   int i;
   int num;
   int *add_thing;
   string str;
   str = "";
   add_thing = ({ });
   for (i=0;i<sizeof(al);i++) {
      if (stringp(al[i])) {
         str += replace(al[i], ({";", "\\;"}));
      } else {
         num = al[i] & ALIAS_MASK;
         switch (al[i] - num) {
         case NEW_LINE  :
            str += ";";
            break;
         case ALL_ARGS  :
            str += "$*$";
            break;
         case ONE_ARG   :
            str += "$"+num+"$";
            break;
         case TO_ARG    :
            str += "$*"+num+"$";
            break;
         case FROM_ARG  :
            str += "$"+num+"*$";
            break;
         case ALL_ARG   :
            str += "$arg:"+al[++i]+"$";
            break;
         case ARG_THING :
            str += "$arg"+num+":"+al[++i]+"$";
            break;
         case ELSE_THING :
           str += "$else$";
           break;
         case ALL_IFARG :
            str += "$ifarg:";
            break;
         case IFARG_THING :
            str += "$ifarg"+num+":";
            break;
         case CURR_LOC :
            str += "$!$";
            break;
         case END_IF      :
            str += "$endif$";
            break;
         }
      }
   }
   return str;
}
int print_aliases(string filter, int sorted) {
   int i;
   int len;
   string str;
   string str1;
   string str2;
   string *tmp;
   string bing;
   mapping aliases;
   string ret;
   aliases = this_player()->query_aliases();
   if (!m_sizeof(aliases)) {
      notify_fail("None defined.\n");
      return 0;
   }
   str1 = "";
   str2 = "";
   tmp = m_indices(aliases);
   if (filter) {
      if (regexp(filter,
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (filter[0] == '*' || filter[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      gfilter = "^" + filter;
      if (catch(tmp = filter_array(tmp, (: $1 && regexp($1, gfilter) :)))) {
         add_failed_mess("Bad pattern to alias (mismatched brackets?).\n");
         return 0;
      }
   }
   tmp = sort_array(tmp, 1);
   ret = "You currently have the following aliases:\n";
   for (i = 0; i < sizeof(tmp); i++) {
      if (!tmp[i]) {
         map_delete(aliases, 0);
         continue;
      }
      bing = alias_string(aliases[tmp[i]]);
      if (!bing) {
         bing = "Error in the alias!";
      }
      if (!tmp[i]) {
         tmp[i] = "icky";
      }
      if (strsrch(bing, "%^") != -1) {
         bing = replace_string(bing, "%^", "% ^");
         tmp[i] += " (colour replace)";
      }
      str = tmp[i] + ": " + bing;
      if (strlen(str) > 39 || sorted) {
         len = this_player()->query_cols() - strlen(tmp[i]) - 2;
         if (len < 0) {
            len = 10;
         }
         ret += sprintf("%s: %-=*s\n", tmp[i], len, bing);
      } else if (strlen(str) > 19) {
         str1 += str+"\n";
      } else {
         str2 += str+"\n";
      }
   }
   if (strlen(str1)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str1);
   }
   if (strlen(str2)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str2);
   }
   ret += sprintf("A total of %d aliases.\n", sizeof(tmp));
   this_player()->more_string(ret);
   return 1;
}
mixed *compile_alias(string str) {
   mixed *ret;
   int i;
   int space;
   string *frog;
   string s1;
   int tmp;
   int gumby;
   int nodollar;
   int ending_dollar;
   mixed *ifargs;
   str = replace(str, ({ "\\;", "$escaped$", ";", "$new_line$", " ", " " }));
   str = replace(str, "$escaped$", ";");
   if(str[sizeof(str)-1] == '$')
     ending_dollar = 1;
   frog = explode("&" + str + "&", "$");
   if (frog[0] == "&") {
      frog[0] = "";
   } else {
      frog[ 0 ] = frog[ 0 ][ 1 .. ];
   }
   s1 = frog[<1];
   if (s1 == "&") {
      frog = frog[0..<2];
   } else {
      frog[<1] = s1[0..<2];
   }
   ret = ({ frog[0] });
   ifargs = ({ });
   nodollar = 1;
   for (i = 1; i < sizeof(frog); i++) {
      switch (frog[i]) {
      case "new_line" :
         ret += ({ NEW_LINE });
         nodollar = 1;
         break;
      case "*" :
         ret += ({ ALL_ARGS });
         gumby = 1;
         nodollar = 1;
         break;
      case "!" :
         if (this_object()->query_creator()) {
            ret += ({ CURR_LOC });
            nodollar = 1;
         }
         break;
      case "else" :
         if (sizeof(ifargs)) {
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret) -
               ifargs[sizeof(ifargs)-1]+1;
            ret += ({ ELSE_THING, 0, "" });
            ifargs[sizeof(ifargs)-1] = sizeof(ret)-2;
            nodollar = 1;
         }
         break;
      case "~" :
      case "endif" :
         if (sizeof(ifargs)) {
            ret += ({ END_IF });
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
               ifargs[sizeof(ifargs)-1];
            ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
            nodollar = 1;
            space = 1;
         }
         break;
      default :
         if (frog[i][0..4] == "ifarg") {
            if (sscanf(frog[i], "ifarg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ IFARG_THING+ tmp, 0, "" });
               frog[i--] = s1;
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
            } else if (frog[i][5] == ':') {
               ret += ({ ALL_IFARG, 0, "" });
               frog[i] = frog[i][6..];
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
               i--;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
            }
         } else if (frog[i][0..2] == "arg") {
            if (sscanf(frog[i], "arg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ ARG_THING+ tmp, s1, "" });
               nodollar = 1;
               gumby = 1;
            } else if (frog[i][3] == ':') {
               ret += ({ ALL_ARG, frog[i][4..100], "" });
               nodollar = 1;
               gumby = 1;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
               gumby = 1;
               space = 0;
            }
         } else if (strlen(frog[i]) && frog[i][<1] == '*' &&
                    sscanf(frog[i], "%d%s*", tmp, s1) == 2 && s1 == "") {
            if (tmp < 0) {
               tmp = 0;
            }
            if (tmp > ALIAS_MASK) {
               tmp = ALIAS_MASK;
            }
            ret += ({ FROM_ARG + tmp });
            gumby = 1;
            nodollar = 1;
         } else if (strlen(frog[i]) && frog[i][0] == '*' &&
                    sscanf(frog[i][1..], "%d%s", tmp,s1) == 2 && s1 == "") {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ TO_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else if (sscanf(frog[i], "%d%s", tmp, s1) == 2 && s1 == "" &&
                    (i < sizeof(frog)-1 || ending_dollar)) {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ ONE_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else {
            if (!nodollar) {
               frog[i] = "$"+frog[i];
            }
            nodollar = 0;
            space = 0;
            if (strlen(frog[i]) && frog[i][<1] == '~') {
               if (sizeof(ifargs)) {
                  if (strlen(frog[i]) == 1) {
                     frog[i] = "";
                  } else {
                     frog[i] = frog[i][0..<2];
                  }
                  ret += ({ END_IF });
                  ret[ifargs[<1]] = sizeof(ret) - ifargs[<1];
                  ifargs = ifargs[0..<2];
                  nodollar = 1;
                  space = 1;
               }
            }
            if (sizeof(ret) && stringp(ret[<1]) && space != 2) {
               ret[<1] += frog[i];
            } else {
               ret += ({ frog[i] });
            }
            if (space) {
               space = 2;
            }
         }
      }
   }
   while (sizeof(ifargs)) {
      ret += ({ END_IF });
      ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
         ifargs[sizeof(ifargs)-1];
      ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
   }
   if (!gumby) {
      if (sizeof(ret) && !stringp(ret[sizeof(ret)-1]) || space) {
         ret += ({ " ", ALL_ARGS });
      } else if(sizeof(ret)) {
         ret[sizeof(ret)-1] += " ";
         ret += ({ ALL_ARGS });
      }
   }
   return ret;
}
int print_some_aliases(string str, int every) {
   if (this_player()->is_alias(str) && !every) {
      printf("%s: %-=*s\n", str,
                (int)this_player()->query_cols() - strlen(str) -2,
                alias_string(this_player()->query_player_alias(str)));
      return 1;
   }
   return print_aliases(str, 0);
}
protected int alias(string name, string value) {
#ifdef DISALLOW_COLOUR
   if (strsrch(name, "%^") >= 0 || strsrch(value, "%^") >= 0) {
      notify_fail("Cannot add an alias with a colour escape "
                  "sequence (% ^).\n");
      return 0;
   }
#endif
   if (strsrch(value, "END_ALIAS") != -1) {
      add_failed_mess("You cannot use 'END_ALIAS' in an alias.\n");
      return 0;
   }
   name = implode(explode(name, " "), "");
   if (name == "unalias" || name == "alias" || name == "ealias")  {
      add_failed_mess("You can't alias the '" + name + "' command, because "
                      "otherwise, there would be Problems.\n");
      return 0;
   }
   if (!this_player()->is_alias(name)) {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Added alias '" + name + "'.\n");
   } else {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Changed alias '" + name + "'.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({
         "", (: print_aliases("", 0) :),
         "sorted", (: print_aliases("", 1) :),
         "every <word'alias'>", (: print_some_aliases($4[0], 1) :),
         "<word'alias'>", (: print_some_aliases($4[0], 0) :),
         "<word'alias'> <string>", (: alias($4[0], $4[1]) :)
         });
}

==================================================
FILE: player/apply.c
==================================================

#include <applications.h>
#include <board.h>
#include <playerinfo.h>
#include <mail.h>
#include <player.h>
inherit "/cmds/base";
varargs void begin_application (object, string, string);
class applying_player {
   int step;
   object player;
   string domain;
   string next_method;
   string type;
   string *questions;
   string *answers;
}
class vouch_info {
  string applicant;
  string voucher;
  string position;
}
void create() {
  seteuid (geteuid());
}
int do_creator_apply(string domain, string type) {
  int temp;
  if (!domain) {
    domain = type;
  }
  if( this_player()->query_property( "guest" ) ) {
    write( "Only people with permanent characters are allowed to "
      "become Creators.\n" );
    return 1;
  }
  temp = APPLICATIONS_HANDLER->query_applications_accepted( domain );
  if( temp == -1 ) {
    this_player()->add_failed_mess( this_object(), "The domain " +
       domain + " is not a valid domain.\n" );
    return 0;
  }
  if( temp == 0 ) {
    this_player()->add_failed_mess (this_object(), "The domain " +
    domain + " is not currently open for applications.\n");
    return 0;
  }
  if( !APPLICATIONS_HANDLER->valid_application (this_player()->query_name(),
    type ) && !this_player()->query_lord() ) {
      write( "Sorry, you have not fulfilled the requirements yet.\n" );
      return 1;
  }
  if (domain == "liaison") {
    type = "liaison";
  }
  if (strsrch (domain, "playtester") != -1) {
    type = "playtester";
  }
  begin_application (this_player(), type, domain);
  return 1;
}
void confirm (string message,  class applying_player tmp) {
  if (!message || !sizeof (message) || strsrch (message, "no") != -1
    || strsrch (message, "n") != -1) {
    return;
  }
  else {
    call_other (this_object(), tmp->next_method, tmp->player, tmp);
  }
}
string query_application_info (string domain) {
  string ret;
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
    ret = read_file( "/d/" + domain + "/application.txt" );
  }
  return ret;
}
varargs void begin_application (object player, string type, string domain) {
  class applying_player tmp;
  string ret = APPLICATIONS_HANDLER->query_intro_text (type);
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
      ret += "\nPlease read the following information about applying to "
             "$C$" + domain + ": \n\n" ;
      ret += query_application_info (domain);
   }
  tell_object (this_player(), ret + "\n");
  tmp = new (class applying_player);
  tmp->type = type;
  tmp->domain = domain;
  tmp->answers = ({ });
  tmp->step = 1;
  tmp->next_method = "do_questions";
  tmp->player = player;
  tell_object (player, "Do you wish to continue your application?\n");
  this_player()->do_edit( "", "confirm", this_object(), 0,
    tmp);
}
varargs void do_questions (object player, class applying_player tmp) {
  if (tmp->step == 1) {
    tmp->questions = APPLICATIONS_HANDLER->query_questions (tmp->type);
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[0]
    + "%^RESET%^\n");
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void start_asking(string message, class applying_player tmp) {
  object player = tmp->player;
  if (!message || sizeof (message) == 0) {
    tell_object (player, "Your application has been aborted.\n");
    return;
  }
  tmp->answers += ({ message });
  if (tmp->step == sizeof (tmp->questions)) {
    tell_object (player, "Do you wish to submit your application?\n");
    tmp->next_method = "submit_application";
    this_player()->do_edit( "", "confirm", this_object(), 0,
      tmp);
    return;
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[tmp->step]
    + "%^RESET%^\n");
  tmp->step += 1;
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void submit_application (object player, class applying_player tmp) {
  int i;
  string *text = ({ });
  for (int j = 0; j < sizeof (tmp->questions); j++) {
    text += ({ "%^CYAN%^" +sprintf( "%2d) %-=*s", ( j + 1), 70,
      tmp->questions[j] ) + "%^RESET%^\n" });
    text += ({ sprintf( "      %-=*s\n\n", 72, tmp->answers[j] )});
  }
  i = APPLICATIONS_HANDLER->add_application (tmp->type, player->query_name(),
    implode (text, "\n"), tmp->domain);
  if (!i) {
    tell_object (player, "Something has gone wrong!\n");
    return;
  }
  else {
    tell_object (player, "Thank you for your application... it has been "
      "placed in the handler ready for people to vouch.\n");
  }
}
int do_list_types() {
  string ret = "";
  string *types;
  types = APPLICATIONS_HANDLER->query_types();
  ret += "You can apply for the following positions with this command:\n\n";
  foreach (string t in types) {
    ret += t + "\n";
  }
  this_player()->more_string (ret);
  return 1;
}
int do_list_requirements(string type) {
  string ret = APPLICATIONS_HANDLER->application_requirements (type);
  this_player()->more_string (ret);
  return 1;
}
int domain_status() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  foreach (string s, int o in map) {
    ret += (o ? "%^BOLD%^%^CYAN%^" : "") + capitalize (s) + " is " +
           (o ? "open" : "closed") + "%^RESET%^ to "
      "applications and is managed by " +
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n";
  }
  write("$P$Domain Status$P$" + ret);
  return 1;
}
int do_list_questions (string type) {
  string *quest = APPLICATIONS_HANDLER->query_questions (type);
  tell_object (this_player(), "\n\nPlease take time to write your application.  "
     "Preferably, prepare an answer to each of these questions off-line "
     "and copy your response into the editor on the MUD if possible.  "
     "You will be asked these questions one-by-one during the application "
     "process, so you should answer each question thoroughly.  Remember, "
     "this is a formal application to a position of responsibility, so "
     "treat each question seriously.\n\n");
  this_player()->more_string (implode (quest, "\n\n"));
  return 1;
}
int do_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->find_application (name, position);
  class vouch_info tmp;
  tmp = new (class vouch_info);
  if (i == -1) {
    write (capitalize (name) + " has not applied for a "
      + position + " position.\n");
    return 1;
  }
  tell_object (this_player(), "%^BOLD%^Why do you think " + capitalize (name)
    + " would be a suitable " + position + "? %^RESET%^");
  tmp->applicant = name;
  tmp->voucher = this_player()->query_name();
  tmp->position = position;
  this_player()->do_edit( "", "vouch_edit", this_object(), 0,
    tmp);
  return 1;
}
void vouch_edit(string message, class vouch_info tmp) {
  object ob;
  int i;
  string name = tmp->applicant;
  string position = tmp->position;
  ob = find_player (tmp->voucher);
  if (!sizeof (message) || message == "") {
    if (ob) {
      tell_object (ob, "Your vouch has been aborted.\n");
    }
  }
  else {
    i = APPLICATIONS_HANDLER->make_vouch (position, name, tmp->voucher, message);
    switch (i) {
      case 2:
        tell_object (ob, "You submit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 1:
        tell_object (ob, "You resubmit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 0:
        tell_object (ob, "You cannot submit a vouch for yourself.\n");
      break;
      case -1:
        tell_object (ob, "There is no application for " + capitalize (name) +
          " as a " + position + ".\n");
      break;
    }
  }
}
int do_delete_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->delete_vouch (this_player()->query_name(),
    name, position);
  if (i) {
    tell_object (this_player(), "You delete your vouch for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), "You have not vouched for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  return 1;
}
int query_my_vouch (string name, string position) {
  string v = APPLICATIONS_HANDLER->query_vouch (position, name,
    this_player()->query_name());
  if (!v) {
    tell_object (this_player(), "There is no application for "
      + capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), v + "\n");
  }
  return 1;
}
int delete_application (string pos) {
  int i = APPLICATIONS_HANDLER->delete_application (pos,
    this_player()->query_name());
  if (!i) {
    tell_object (this_player(), "You have no pending applications for "
      "that position.\n");
  }
  else {
    tell_object (this_player(), "Your application has been deleted.\n");
  }
  return 1;
}
int do_register() {
   if ( this_player()->query_property( "guest" )==1 ) {
      write ( "You are a guest. Registering as a player killer is not an "
        "option for you.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+
        " (" +query_ip_number(this_player()) + ") (a guest) tried to "
        "register as a player killer.\n");
      return 1;
   }
   if (this_player()->query_player_killer()) {
      add_failed_mess( "You already are a player killer, silly!\n" );
      return 0;
   }
   if (-this_player()->query_time_on() < PKER_MINIMUM_AGE) {
      add_failed_mess( "You are not old enough to be a player killer.  You "
        "must be " + (PKER_MINIMUM_AGE / (60 * 60 * 24)) + " days old to "
        "register as a player killer.\n");
      return 0;
   }
   if (this_player()->query_property(PKER_NOT_ALLOWED)) {
      write( "Due to previous abuses of the playerkiller system, you are "
         "not allowed to become a playerkiller.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+ " (" +query_ip_number(this_player()) +
        ") (not allowed to be a pk) tried to register as a player "
        "killer.\n");
      return 1;
   }
   write( "%^BOLD%^%^YELLOW%^You are hereby registering yourself as "
          "a player killer.\n\n"
          "This means that you can attack and be attacked by other "
          "player killers.  Once you are a registered player killer, "
          "there is NO going back.  Please note, this is NOT a quest "
          "and you will NOT get any experience points from doing "
          "it.%^RESET%^\n");
   write( "Are you sure about this, (Y/N)?\n");
   input_to("register2");
   return 1;
}
void register2(string str)
{
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
      write("You need to type 'y' or 'n'.\n");
      write("Are you sure about this, (Y/N)? ");
      input_to("register2");
      return ;
   }
   if (str[0] == 'n' ||
       str[0] == 'q') {
      write("You have chosen not to register as a playerkiller at this "
         "time.  You may choose to register later if you wish.\n");
   } else {
      write("%^BOLD%^%^YELLOW%^You are now a playerkiller, ready to kill and be killed.%^RESET%^\n");
      this_player()->set_player_killer(1);
      PLAYERINFO_HANDLER->add_entry( this_player(),
        this_player()->query_name(), "misc",
        "Registered as a Player Killer." );
   }
}
int do_query_all_vouches() {
  mapping tmp = APPLICATIONS_HANDLER->query_vouches_for_all
    (this_player()->query_name());
  string *ret = ({ });
  string tmp2;
  if (!sizeof (tmp)) {
    this_player()->add_failed_mess (this_object(), "You have made no "
      "vouches for anyone.\n", ({ }));
    return 0;
  }
  foreach (string n, string v in tmp) {
    tmp2 = "$I$5=%^CYAN%^" + capitalize (n) + "%^RESET%^: " + v;
    ret += ({ tmp2 });
  }
  this_player()->more_string (implode (ret, "\n\n"));
  return 1;
}
private int do_list_applicants() {
  string ret;
  if (!this_player()->query_lord()) {
    return 0;
  }
  ret = APPLICATIONS_HANDLER->list_applications();
  this_player()->more_string (ret);
  return 1;
}
private int do_browse_app (string type, string name) {
  int i = APPLICATIONS_HANDLER->find_application (name, type);
  string ret;
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "There is no "
      +type + " application for " + name + ".\n", ({ }));
    return 0;
  }
  ret = APPLICATIONS_HANDLER->format_application (i);
  this_player()->more_string (ret);
  return 1;
}
int query_my_vouches (string position) {
  mapping i = APPLICATIONS_HANDLER->query_application_vouches
    (this_player()->query_name(), position);
  if (!i) {
    this_player()->add_failed_mess (this_object(), "You currently have no vouches "
      "for a " + position + " application.\n", ({ }));
    return 0;
  }
  else {
    tell_object (this_player(), "The following people have vouched for your " +
      position + " application:  " + query_multiple_short (map (keys (i),
        (: capitalize ($1) :))) + ".\n");
    return 1;
  }
}
mixed* query_patterns() {
   string t = "{" + implode (APPLICATIONS_HANDLER->query_types(), "|")
    + "}";
   mixed *tmp;
   tmp = ({
             "as creator in <word> domain", (: do_creator_apply($4[0], "creator") :),
             "as player killer", (: do_register() :),
             "as playtester", (: do_creator_apply("playtesters", "playtester") :),
             "as liaison", (: do_creator_apply(0, "liaison") :),
             "delete my application as <word'position'>",
              (: delete_application ($4[0]) :),
             "list available positions", (: do_list_types() :),
             "list requirements for " + t + " applications",
              (: do_list_requirements($4[0]) :),
             "list position status", (: domain_status() :),
             "list questions for " + t + " applications",
              (: do_list_questions ($4[0]) :),
             "vouch for <word'name'> as <word'position'>",
              (: do_vouch ($4[0], $4[1]) :),
             "delete vouch for <word'name'> as <word'position'>",
              (: do_delete_vouch ($4[0], $4[1]) :),
             "query vouch for <word'name'> as <word'position'>",
              (: query_my_vouch ($4[0], $4[1]) :),
             "query all my vouches", (: do_query_all_vouches() :),
             "query vouches for my <word> application", (: query_my_vouches($4[0]) :),
  });
  if (this_player()->query_lord()) {
    tmp += ({"browse <word'type'> application for <word'name'>", (: do_browse_app($4[0], $4[1]) :) });
    tmp += ({"list applicants", (: do_list_applicants() :) });
  }
  return tmp;
}
void clean_up() {
  return 0;
}
int application_board_access_check( int type, string board,
                                    object previous, string name ) {
   switch(type) {
      case B_ACCESS_READ :
         return 1;
      case B_ACCESS_WRITE :
         if( file_name(previous) == file_name( this_object() ) )
            return 1;
          if (base_name (previous) == APPLICATIONS_HANDLER) {
            return 1;
          }
         return master()->query_lord(name);
      case B_ACCESS_DELETE :
         return 0;
   }
}
void reset() {
}

==================================================
FILE: player/appraise.c
==================================================

#include <volumes.h>
int cmd(object *things);
string query_length_mess(int number) {
    int half_feet;
    switch(number) {
        case 0:
            return "not very";
        case 1:
            return "an inch";
        case 2:
            return "a couple of inches";
        case 3:
            return "three inches";
        case 4:
            return "four inches";
        case 5..7:
            return "about six inches";
        case 8..10:
            return "about nine inches";
        case 11..14:
            return "about a foot";
        case 15..21:
            return "about a foot and a half";
        case 22..27:
            return "about two feet";
        case 28..33:
            return "about two and a half feet";
        default:
            half_feet = (number + 3)/6;
            if( half_feet%2 ) {
                return "about " + query_num(half_feet/2) + " and a half feet";
            }
            else {
                return "about " + query_num(half_feet/2) + " feet";
            }
    }
}
string query_dimensions_mess(object thing) {
    return "is " + query_length_mess(thing->query_length()) + " long and " +
        query_length_mess(thing->query_width()) + " wide.";
}
string query_appearance_mess(object thing) {
    string material_mess;
    if( !sizeof(thing->query_materials()) ) {
        material_mess = "some unidentifiable material";
    }
    else {
        material_mess = query_multiple_short(thing->query_materials());
    }
    if(thing->query_colour()) {
        return "is " + thing->query_colour() + " and is made of " +
            material_mess;
    }
    else {
        return "is made of " + material_mess;
    }
}
string query_type_mess(object thing) {
    if( thing->query_plant() ) {
        return "appears to be some sort of plant";
    }
    if( thing->query_food_object() ) {
        if( thing->query_liquid() ) {
            return "looks drinkable";
        }
        else {
            return "looks edible";
        }
    }
    if( thing->query_furniture() ) {
        return "could be placed as furniture";
    }
    if( thing->query_property("shop type") == "jewellers" ) {
        return "appears to be a piece of jewellery";
    }
    if( thing->query_weapon() ) {
        return "could be used as a weapon";
    }
    if( thing->query_armour() && thing->query_wearable()) {
        return "could be worn as armour";
    }
    if( thing->query_wearable() ) {
        return "looks like you could wear it";
    }
    if (thing->query_no_limbs() > 0) {
        return "looks like you could hold it";
    }
    return 0;
}
string query_container_mess(object thing) {
   int volume;
   int size;
   string str;
   volume = thing->query_max_volume();
   if (thing->query_container()) {
      size = thing->query_max_size();
   }
   if (size || volume) {
      str = "";
      if (size) {
         str += "can hold about " + (size / 9) + " pounds";
      }
      if (volume) {
         if (size) {
            str += " and ";
         }
         str += "can hold about ";
         if (volume > VOLUME_GALLON) {
            str += ((volume + VOLUME_GALLON / 2) / VOLUME_GALLON) + " gallons";
         } else if (volume >= VOLUME_QUART) {
            str += ((volume + VOLUME_QUART / 2) / VOLUME_QUART) + " quarts";
         } else if (volume >= VOLUME_PINT) {
            str += ((volume + VOLUME_PINT / 2) / VOLUME_PINT) + " pints";
         } else if (volume >= VOLUME_GILL) {
            str += ((volume + VOLUME_GILL / 2) / VOLUME_GILL) + " gills";
         } else if (volume >= VOLUME_SHOT) {
            str += ((volume + VOLUME_SHOT / 2) / VOLUME_SHOT) + " shots";
         } else {
            str += "nothing";
         }
      }
      return str;
   }
   return 0;
}
int cmd(object *things) {
    object thing;
    string mess;
    string tmp;
    if(!sizeof(things)) {
        add_failed_mess("For some reason, you "
            "have nothing to appraise.  Please bugrep this.\n", ({ }) );
        return 0;
    }
    if(sizeof(things) > 1) {
        add_failed_mess("You cannot appraise "
            "more than one object at once.\n", ({ }) );
        return 0;
    }
    if (thing == this_player()) {
        if (this_player()->query_name() == "penguin") {
           write("Is that a tuxuedo you are wearing?  No, probably not.\n");
        } else {
           write("You appraise yourself.  " + (random(10) + 1) + " out of 10.\n");
        }
        return 0;
    }
    thing = things[0];
    if(environment(thing) != this_player()) {
        add_failed_mess("You cannot appraise "
            "objects you are not carrying.\n", ({ }) );
        return 0;
    }
    if(living(thing)) {
        write("You appraise " + thing->the_short() + " and mmmm, very "
            "sexy.\n");
        return 1;
    }
    if(thing->query_worn_by()) {
        add_failed_mess("You cannot appraise "
            "$I while you are wearing it.\n", ({ thing }) );
        return 0;
    }
    if( !thing->query_clothing() ) {
        mess = thing->the_short() + " " + query_dimensions_mess(thing);
        mess += "  ";
    }
    else {
        mess = "";
    }
    tmp = query_type_mess(thing);
    if(tmp) {
        mess += "It " + query_appearance_mess(thing);
        mess += " and " + tmp + ".";
    }
    else {
        mess += "It " + query_appearance_mess(thing) + ".";
    }
    tmp = query_container_mess(thing);
    if (tmp) {
       mess += "  It " + tmp + ".";
    }
    if(thing->cond_string() && thing->cond_string() != "") {
        mess += "  " + thing->cond_string();
    }
    else {
        mess += "\n";
    }
    write("$P$Appraise$P$" + mess );
    add_succeeded_mess("");
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me-here'item'>", (: cmd($1) :) });
}

==================================================
FILE: player/arguments.c
==================================================

#include <philosophies.h>
inherit "/cmds/base";
int cmd() {
   string *args;
   args = PHILOSOPHY_HANDLER->query_all_known(this_player()->query_name());
   if (!sizeof(args)) {
      write("You do not know any theological arguments.\n");
   } else {
      write("You know the following theological arguments:\n" +
            query_multiple_short(args) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/birthdays.c
==================================================

inherit "/cmds/base";
int cmd()  {
   object *peeps;
   peeps = filter(users(), (: $1->query_visible(this_player())  &&
                              $1->query_is_birthday_today() :));
   if (sizeof(peeps) == 0)
      return notify_fail("No one has a birthday today.\n");
   if (sizeof(peeps) == 1)
      printf("%s has a birthday today.\n", peeps[0]->short());
   else
      write(query_multiple_short(peeps) + " have a birthday today.\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/brief.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(string which, string type) {
  string t, disp;
  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types())
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    write(disp + "\n");
  }
  else if(type == "all") {
    foreach(t in TP->query_verbose_types())
      TP->set_verbose(t, which == "verbose");
    write("Ok\n");
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
  } else {
    write("No such option.\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("brief", $4[0]) :),
            "", (: cmd("brief", 0) :),
         });
}

==================================================
FILE: player/bright.c
==================================================

inherit "/cmds/base";
#include <dirs.h>
#define THRESHOLDS ({ 10, 30, 200, 300 })
string illumination( int number ) {
   if ( number < 0 ) {
      return "in the darkness that lies beyond darkness";
   }
   if ( number < THRESHOLDS[ 0 ] ) {
      return "in pitch darkness";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "in near darkness";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return "too brightly lit to see";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return "too brightly lit to see clearly";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 5 :
      return "very poorly lit";
   case 6 .. 10 :
      return "poorly lit";
   case 11 .. 20 :
      return "dimly lit";
   case 21 .. 30 :
      return "quite well lit";
   case 31 .. 40 :
      return "well lit";
   case 41 .. 50 :
      return "brightly lit";
   default :
      return "very brightly lit";
   }
}
string intensity(int number, object thing) {
   int flag = (thing == this_player());
   if (number < 0) {
      return (flag?"are":"is") + " dark beyond darkness";
   }
   if (number < THRESHOLDS[0]) {
      return "produce" + (flag?"":"s") + " a faint light";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "produce" + (flag?"":"s") + " a bit of light";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return (flag?"are":"is") + " so bright you can't bear to look";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return (flag?"are":"is") + " so bright it hurts to look";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 24 :
      return "produce" + (flag?"":"s") + " quite a bit of light";
   case 25 .. 49 :
      return (flag?"are":"is") + " very bright";
   default :
      return (flag?"are":"is") + " extremely bright";
   }
}
int check_exists(string file) {
  int retval;
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    retval = 1;
  } else {
    retval = 0;
  }
  return retval;
}
mixed cmd(object *things) {
   int its_light;
   string results;
   string no_light_results;
   object thing;
   object* no_light;
   int result_light;
   results = "";
   if (environment(this_player())->query_light() < THRESHOLDS[0]) {
      results += "Wherever you are, it's ";
   } else {
      results += "$C$"+ environment(this_player())->the_short(1) + " is ";
   }
   results += illumination(environment(this_player())->query_light()) + ".\n";
   if (!things) {
      write(results);
      return 1;
   }
   no_light_results = "";
   no_light = ({ });
   foreach(thing in things) {
      its_light = (int)thing->query_light();
      if (its_light) {
        results += "$C$" + thing->the_short(1) + " " +
          intensity(its_light, thing) + ".\n";
        result_light = 1;
      } else {
         no_light += ({ thing });
      }
   }
   if (sizeof(no_light) && !result_light) {
      write("$C$" + query_multiple_short(no_light, "one", 0, 1) +
            ((sizeof(no_light) == 1  &&  no_light[0] != this_player()) ?
               " produces" : " produce") + " no light at all.\n");
   }
   write(results);
   return 1;
}
int cmd_exit(string arg) {
   object room;
   string other;
   room = environment(this_player());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if(!room->query_exit(arg)) {
     arg = (string)this_player()->find_abs(arg);
   }
   if ( room->query_exit( arg ) ) {
      other = room->query_destination(arg);
      if ( check_exists( other )) {
         object door;
         door = room->query_door_control(arg);
         if(room->query_door_open(arg) ||
            door->query_transparent()) {
            write(other->the_short(1) + " is " +
                       illumination(other->query_light()) + ".\n");
            return 1;
         } else {
            add_failed_mess("The exit " + arg + " is not open.\n");
            return 0;
         }
      } else {
         add_failed_mess("The exit " + arg + " does not exist.\n");
         return 0;
      }
   }
   add_failed_mess("Unable to find the exit " + arg + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "exit <string'exit name'>", (: cmd_exit($4[0]) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/bug.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("BUG");
   set_use_last_error(1);
}

==================================================
FILE: player/bugcheck.c
==================================================

#define WEIRD_OBJECT_LOG "/log/secure/playtesters/bugcheck-weird-objects"
inherit "/cmds/base";
varargs int cmd(object *obs) {
    string* s;
    string txt;
    foreach ( object ob in obs ) {
        if ( stringp( ob->query_property( "virtual name" ) ) )
            s = explode( ob->query_property( "virtual name" ), "/" );
        else
            s = explode( base_name( ob ), "/" );
        switch ( s[ 0 ] ) {
        case "d":
            write(capitalize( ob->the_short() ) +
                         " is a domain thing.  It's probably safe to "
                         "bugrep it directly.\n" );
            break;
        case "w":
            write(capitalize( ob->the_short() ) +
                         "... why do you have a creator item?\n" );
            log_file ("ILLEGAL_OBJECT", "%s: %s tried to bugcheck %s.\n\n",
              ctime(time()), this_player()->query_name(), base_name (ob));
            break;
        case "std":
            write(capitalize( ob->the_short() ) +
                         " is a weird MUD library thing.  If you bugrep "
                         "it, the response might be slow.  It may be a "
                         "better idea to bugrep the room that the object "
                         "was found in.\n" );
            break;
        case "obj":
          switch (s[1]) {
            case "weapons":
            case "armours":
            case "clothes":
            case "food":
            case "jewellery":
              write(capitalize( ob->the_short() ) +
                         " is a Disc-wide item, but belongs to a directory "
                         "that is checked regularly.  Best to make the "
                         "bugrep directly on the item.\n" );
            break;
            default:
              write(capitalize( ob->the_short() ) +
                         " is a fairly general Disc-wide object.  If you "
                         "bugrep it, the response might be slow.  It would "
                         "most likely be a better idea to bugrep the room "
                         "in which the object was found.\n" );
            break;
          }
        break;
        case "global":
          switch (s[1]) {
            case "player":
            case "lord":
            case "playtester":
              if ( ob == this_player() ) {
                  txt = "are";
              }
              else {
                  txt = "is";
              }
              write(capitalize( ob->the_short() ) +
                         " " + txt + " the general " + s[1] + " object... if your "
                         "bugrep is on this, then bugrep this object.  If "
                         "your bugrep is along the frivolous lines of '"
                         + ob->the_short() +" " + txt + " overpowered!', "
                         "then don't "
                         "bugreport it... be sure and raise the issue on the "
                         "nearest bulletin board.\n" );
            break;
          }
        break;
        default:
            write("I've got no idea about " +
                         ob->the_short() + ".  Sorry it didn't work out.\n" );
            log_file( WEIRD_OBJECT_LOG, implode( s, "/" ) + "\n" );
            break;
        }
    }
    return 1;
}
int cmd_room() {
   write("Bug report the room for anything that seems to be odd in the room, "
         "descriptions being wrong, items you look at being wrong.  Anything "
         "odd you see that does not seem to fit anywhere else should also be "
         "reported to the room.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:'thing'>", (: cmd($1) :),
             "here", (: cmd_room :)
    });
}

==================================================
FILE: player/bury.c
==================================================

#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
inherit "/cmds/base";
#define TP this_player()
#define GP_INCREMENT 10
#define MAX_BURY_NUMBER 20
mixed cmd(object *obs) {
   string person;
   mixed effs, *xp;
   string* messages;
   object ob, tmp;
   object *sobs;
   object *fobs;
   object *too_many;
   int gp;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   sobs = ({ });
   fobs = ({ });
   too_many = ({ });
   if (TP->query_property("dead")) {
      add_failed_mess("You are a disembodied spirit, how do you expect to bury "
                      "anything at all?\n");
      return 0;
   }
   if(sizeof(filter_array(TP->query_attacker_list(),
                          (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot bury items while in combat.\n");
      return 0;
   }
   if(environment(TP)->query_property("no burial")) {
      add_failed_mess("You cannot bury things here.\n");
      return 0;
   }
   fobs = filter(obs, (: !is_in_me_or_environment($1, this_player()) :));
   obs -= fobs;
   foreach (ob in obs) {
      if (sizeof(sobs) >= MAX_BURY_NUMBER) {
         too_many += ({ ob });
      } else if ((ob->query_owner() == this_player()->query_cap_name()) ||
                 ((ob->get() == MOVE_OK) ||
                  (ob->get() == MOVE_TOO_HEAVY)) &&
                 (ob->query_property("no burial") != 1) &&
                 !ob->ok_to_bury(this_player())) {
        if (ob->query_property("player") != 1 ||
            ob->query_owner() == this_player()->query_name()) {
            effs = ob->effects_matching("mudlib.owned.weapon");
            if(sizeof(effs)) {
               person = ob->arg_of(effs[0]);
               log_file("BURIAL", "%s: %s's %s buried by %s\n", ctime(time()),
                        person, ob->query_short(), TP->query_name());
            }
            environment(this_player())->add_effect(BURY_EFFECT, ob);
            sobs += ({ ob });
            if (ob->query_property("corpse bit") ||
                ob->query_property("money")) {
               gp--;
            } else if(base_name(ob) == "/obj/corpse" &&
                      !ob->query_property("already buried")) {
               gp += GP_INCREMENT;
               ob->add_property("already buried", 1);
               xp = ob->query_property("XP");
               if(xp && sizeof(xp) == 2) {
                 foreach(tmp in xp[0]) {
                   if(tmp)
                     tmp->adjust_xp(xp[1], 1);
                 }
               }
               ob->remove_property("XP");
            }
         } else {
            fobs += ({ ob });
         }
      } else {
         fobs += ({ ob });
      }
   }
   if (!sizeof(sobs)) {
      if (sizeof(fobs)) {
         if (member_array(TP, fobs) == -1) {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs)+".\n");
            return 0;
         } else {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs - ({TP}) +
                                                 ({"yourself"}))+
                            ".\n");
            return 0;
         }
      } else {
         add_failed_mess("You cannot find anything here to bury!\n");
         return 0;
      }
   }
   if (sizeof(too_many)) {
      write("You can only bury up to " + MAX_BURY_NUMBER +
            " items at a time, not burying " +
            query_multiple_short(too_many) + ".\n");
   }
   messages = environment(TP)->query_burial_message();
   if (messages) {
      write(replace_string(messages[0], "$objs$", query_multiple_short(sobs)));
      say(replace(messages[1], ({ "$N", TP->the_short(), "$objs$", query_multiple_short(sobs) })));
   } else if (environment(TP)->query_property("location") != "outside") {
      write("You tidy up the place, clearing away "+
            query_multiple_short(sobs)+".\n");
      say( (string)this_player()->one_short() +
           " tidies up the place, clearing away "+
           query_multiple_short( sobs ) +".\n" );
   } else {
      write("You bury "+query_multiple_short(sobs)+" deep within the earth.\n");
      say( (string)this_player()->one_short() +
           " buries "+ query_multiple_short( sobs ) +
           " deep within the ground.\n" );
   }
   TP->adjust_gp(gp);
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:here>", (: cmd($1) :),
            "",
            (: cmd(match_objects_for_existence("corpse", environment(TP))) :) });
}

==================================================
FILE: player/chfn.c
==================================================

inherit "/cmds/base";
#define TP this_player()
#define MAX_EMAIL_LEN 50
int cmd(string str) {
  write("Change finger information.\n");
  write("Pressing return at the prompts will take the default.  The default "
        "is the option in []'s.\n");
  write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
  input_to("real_name");
  return 1;
}
int real_name(string str) {
  string real_name;
  str = strip_colours(str);
  real_name = TP->query_real_name();
  if (str && str != "") {
    if (str == "none") {
      real_name = 0;
    } else {
      real_name = str;
    }
  }
  if (real_name && strlen(real_name) > MAX_EMAIL_LEN) {
    write("Real name is too long, a maximum of " + MAX_EMAIL_LEN + " characters is allowed.\n");
    write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
    input_to("real_name");
    return 1;
  }
  if (real_name && real_name != "") {
    write("Ok real name set to "+real_name+".\n");
  } else {
    write("Real name cleared.\n");
  }
  TP->set_real_name(real_name);
  write("Enter your location (ie Perth, oz, whatever) ["+
        TP->query_where()+"]\n(none for none) : ");
  input_to("get_where");
  return 1;
}
int get_where(string str) {
  string where;
  str = strip_colours(str);
  where = TP->query_where();
  if (str && str != "") {
    if (str == "none") {
      where = 0;
    } else {
      where = str;
    }
  }
  if (where && where != "") {
    write("Ok location set to "+where+".\n");
  } else {
    write("Location cleared.\n");
  }
  if (where && strlen(where) > MAX_EMAIL_LEN) {
     write("Your location is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
     write("Enter your location (ie Perth, oz, whatever) ["+
           TP->query_where()+"]\n(none for none) : ");
     input_to("get_where");
     return 1;
  }
  TP->set_where(where);
  if(TP->query_birthday() == "Unknown") {
    write("Enter your birthday (ddmm) ["+TP->query_birthday()+
          "] (none for none) : ");
    input_to("birthday");
  } else {
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
  }
  return 1;
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}
int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
void birthday(string str) {
  string birth_day;
  birth_day = TP->query_birthday();
  if (str == "") {
    if (birth_day)
      write("Birthday unchanged from "+birth_day+".\n");
    else
      write("Birthday left as blank.\n");
  } else {
    if(birth_day != "Unknown") {
      write("You can't change when you were born! Please ask a Creator or "
        "a Lord to change it if you made an error.\n");
    } else if(!valid_birthday(str)) {
        write("Invalid Birthday.  Birthday cleared.\n");
        birth_day = 0;
    } else {
      birth_day = convert_birthday(str);
      write("Birthday set to " + birth_day + ".\n");
      TP->birthday_gifts();
    }
  }
  TP->set_birthday(birth_day);
  write("What email address do you wish to use.  Set to none to clear.\n");
  write("Putting a : in front of it means that only the creators and lords "
        "can read it.\n");
  write("["+TP->query_email()+"] : ");
  input_to("get_email");
}
void get_email(string str) {
  string email;
  email = TP->query_email();
  str = strip_colours(str);
  if (str == "") {
    if (!email || email == "") {
      write("Email address left blank.\n");
    } else {
      write("Email address left as "+email+".\n");
    }
  } else if (str == "none") {
    email = 0;
    write("Email address cleared.\n");
  } else {
    email = str;
    write("Email address set to "+email+".\n");
  }
  if (email && strlen(email) > MAX_EMAIL_LEN) {
    write("Your email address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators and lords "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
    return ;
  }
  TP->set_email(email);
  write("Please enter your home page (World Wide Web page address), "
        "type 'none' to clear it.\n");
  if (!TP->query_homepage()) {
    write("[none] : ");
  } else {
    write("["+TP->query_homepage()+"] : ");
  }
  input_to("get_home_page");
}
void get_home_page(string str) {
  str = strip_colours(str);
  if (str == "") {
    if (!TP->query_homepage()) {
      write("Home page left as blank.\n");
    } else {
      write("Home page left as "+TP->query_homepage()+"\n");
    }
  } else if (str == "none") {
    TP->set_homepage("");
    write("Home page cleared.\n");
  } else if (strlen(str) <= MAX_EMAIL_LEN) {
    TP->set_homepage(str);
    write("Home page set to "+str+"\n");
  } else {
    write("Your home page address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("Please enter your home page (World Wide Web page address), "
          "type 'none' to clear it.\n");
    if (!TP->query_homepage()) {
      write("[none] : ");
    } else {
      write("["+TP->query_homepage()+"] : ");
    }
    input_to("get_home_page");
    return ;
  }
  TP->save_me();
}

==================================================
FILE: player/co_mmands.c
==================================================

inherit "/cmds/base";
int cmd( ) {
  string *cmds;
  write( "Your current commands are:\n"+ sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)this_player()->query_known_commands(), 1 ),
         "\n" ) ) );
  if (this_player()->query_playtester()) {
    cmds = get_dir ("/cmds/playtester/");
    cmds = filter (cmds, (: strsrch ($1, ".c") == (sizeof ($1) - 2) :));
    write( "\n\nYour playtester commands are:\n"+ replace (sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)cmds, 1 ),
         "\n" ) ), ({".c", ""})) );
  }
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/colo_urs.c
==================================================

#include <colour.h>
#include <clubs.h>
#include <creator.h>
#include <newbiehelpers.h>
inherit "cmds/base";
private string* _colours;
void create() {
  ::create();
  _colours = ({
   "BOLD",
   "FLASH",
   "BLACK",
   "RED",
   "BLUE",
   "CYAN",
   "MAGENTA",
   "ORANGE",
   "YELLOW",
   "GREEN",
   "WHITE",
   "B_RED",
   "B_ORANGE",
   "B_YELLOW",
   "B_BLACK",
   "B_CYAN",
   "B_WHITE",
   "B_GREEN",
   "B_MAGENTA" });
}
int is_valid_colour(string name) {
   if (member_array(name, _colours) != -1) {
      return 1;
   }
   return 0;
}
int show_allowed_colours() {
   write("The allowed colour codes are " +
         query_multiple_short(map(_colours, (: lower_case($1) :)), 0, 0, 1) +
         ".\n");
   return 1;
}
string* query_colour_list(int inform) {
  string* colour_list;
  string* clubs;
  string bing;
  switch (inform) {
  case 0:
    colour_list = USER_COLOUR_LIST;
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      colour_list += ({"newbiehelpers"});
    }
    if(this_player()->query_creator()) {
      colour_list += this_player()->channel_list();
    }
    break;
  case 1 :
    colour_list = this_player()->query_inform_types();
    break;
  case 2 :
    clubs = this_player()->query_player_clubs();
    clubs = filter(clubs, (: !CLUB_HANDLER->is_club($1) :));
    foreach (bing in clubs) {
       this_player()->remove_player_club(bing);
    }
    colour_list = map(this_player()->query_player_clubs(), (: "club_" + $1 :));
    break;
  }
  return colour_list;
}
mixed set_colours(int inform, string event_type, string colour, int force) {
  mapping my_colours;
  string *colour_list;
  string *bad;
  string tmp;
  string name;
  colour_list = query_colour_list(inform);
  if (inform == 2) {
    name = CLUB_HANDLER->query_club_name(event_type);
    event_type = "club_" + event_type;
  } else {
    name = lower_case(event_type);
  }
  if(member_array(event_type, colour_list) == -1) {
    return notify_fail("No such type.\n");
  }
  my_colours = this_player()->query_my_colours();
  if(colour == "default") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to default.\n");
  } else if(colour == "none") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to none.\n");
  } else {
    colour_list = map(explode(colour, " "),
                      (: upper_case($1) :));
    bad = filter(colour_list, (: !is_valid_colour($1) :));
    if (sizeof(bad) && !force) {
       if (sizeof(bad) > 1) {
          add_failed_mess("The colours " + query_multiple_short(bad) +
                          " are not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       } else {
          add_failed_mess("The colour " + query_multiple_short(bad) +
                          " is not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       }
       return 0;
    }
    tmp = "%^" + implode(colour_list, (: $1 + "%^ %^" + $2 :)) + "%^";
    this_player()->set_my_colours(event_type, tmp);
    write(name + " colour set to " + tmp + "[" + colour +
          "]%^RESET%^.\n");
  }
  return 1;
}
private int show_colours(int inform) {
  string *colour_list, event;
  mapping my_colours;
  string name;
  colour_list = query_colour_list(inform);
  my_colours = this_player()->query_my_colours();
  if (!inform) {
    write(sprintf("%-20s %s\n", "Clubs", "<list>"));
    write(sprintf("%-20s %s\n", "Inform", "<list>"));
  }
  foreach(event in colour_list) {
    if (inform == 2) {
       name = CLUB_HANDLER->query_club_name(event[5..]);
    } else {
       name = event;
    }
    if(my_colours[event]) {
      if(my_colours[event] != "") {
        write(sprintf("%-20s %s\n", name, my_colours[event] +
                      "[" + replace(my_colours[event], "%^", "") +
                      "]%^RESET%^"));
      } else {
        write(sprintf("%-20s %s\n", name, "[none]"));
      }
    } else {
      write(sprintf("%-20s %s\n", name, "[default]"));
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 0) :),
            "force <word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 1) :),
            "", (: show_colours(0) :),
            "inform <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 0) :),
            "inform force <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 1) :),
            "club <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 0) :),
            "club force <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 1) :),
            "inform", (: show_colours(1) :),
            "allowed", (: show_allowed_colours() :),
            "clubs", (: show_colours(2) :) });
}

==================================================
FILE: player/components.c
==================================================

#define OBJ 0
inherit "/cmds/base";
int cmd( string spell_name ) {
  mapping spells = this_player()->query_spells_nocase();
  string spell_ob;
  string *consumed, *needed;
  string mess;
  if( !sizeof( spells ) ) {
    add_failed_mess( "You don't know any magic spells.\n" );
    return 0;
  }
  spell_name = this_player()->expand_nickname( spell_name );
  spell_name = capitalize( spell_name );
  if( !spells[ lower_case(spell_name) ] ) {
    add_failed_mess( "You don't know a spell named " + spell_name +
        ".\n" );
    return 0;
  }
  spell_ob = spells[ lower_case(spell_name) ][ OBJ ];
  consumed = spell_ob->query_consumables();
  needed   = spell_ob->query_needed();
  if( !sizeof( consumed ) && !sizeof( needed ) ) {
    mess = "You don't need anything to cast " + spell_name;
  } else if( sizeof( consumed ) ) {
    mess = spell_name + " will consume " + query_multiple_short(
           consumed );
    if( sizeof( needed ) ) {
      mess += ".  It also requires " + query_multiple_short(
                 needed ) + " but will not consume " +
                 ( sizeof( needed ) > 1 ? "them" : "it" );
    }
  } else {
    mess = spell_name + " requires " + query_multiple_short( needed ) +
           " but will not consume " + ( sizeof ( needed ) > 1 ?
           "them" : "it" );
  }
  add_succeeded_mess( ({ mess + ".\n", "" }) );
  return 1;
}
mixed *query_patterns() {
  return ({ "[for] <string'spell'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/con_sider.c
==================================================

#define CREATOR "Ceres"
#include <weapon.h>
#include <cmr.h>
#include <player.h>
inherit "/cmds/base";
int calc_danger(object ob);
string do_compare(int dif);
mixed cmd(object *obs) {
  object ob;
  int level, ok, dif, total, them;
  string out;
  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) < 0) {
     add_failed_mess("It's too dark to consider anyone.\n");
     return 0;
  }
  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) > 0) {
     add_failed_mess("It's too bright to consider anyone.\n");
     return 0;
  }
  if (sizeof(obs) > 1) {
     obs -= ({ this_player() });
  }
  if (sizeof(obs) > 5) {
     add_failed_mess("You can only consider five things at once.\n");
     return 0;
  }
  if (this_player()->query_property("dead"))  {
    add_failed_mess( "You're dead.  You could just about kill a "
                        "conversation.\n" );
    return 0;
  }
  level = calc_danger(previous_object());
  foreach (ob in obs) {
    if (!living(ob)) {
       continue;
    }
    if (ob == previous_object()) {
       if (sizeof(obs) == 1) {
          write("You are exactly equal to yourself, you had better go and "
                "arm yourself with more spiky things and try to not arm "
                "your reflection at the same time.  No problems?\n");
          ok++;
       }
       continue;
    }
    ok++;
    them = calc_danger(ob);
    total += them;
    dif = ((level - them) * 100) / level;
    if ( userp( ob ) && this_player()->query_player_killer() &&
          !ob->query_player_killer() ) {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() +
             " [not a killer]" );
    } else {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() );
    }
    if (userp(ob)) {
       tell_object(ob, this_player()->the_short(1) + " looks you up and down "
                       "carefully checking out your weapons and armour.\n");
    } else {
       ob->event_npc_consider(this_player());
    }
    write( out +"\n" );
  }
  if(!ok) {
    add_failed_mess("You need to consider someone.\n");
    return 0;
  }
  return 1;
}
string do_compare(int dif) {
   string ret;
   int level;
   ret = "$C$$who$";
   level = PLAYER_DRUNK_EFFECT->query_drunk_level(this_player());
   if (level > 4) {
      if (level > 7) {
         return "%^BOLD%^%^GREEN%^Mate!  They looked at you wrong, you "
                "better sort them out before they get more cocky.%^RESET%^";
      }
      return "%^BOLD%^%^GREEN%^You reckon they would be an easy "
             "target.  Why bother with weapons?%^RESET%^";
   }
  if(dif > 320) {
    ret = "%^BOLD%^GREEN%^"+ret+" is too weak to bother attacking";
  } else {
    switch(dif) {
    case 161..320:
      ret = "%^BOLD%^%^GREEN%^"+ret+" is someone you look down on";
      break;
    case 81..160:
      ret = "%^GREEN%^"+ret+" would be an easy target";
      break;
    case 41..80:
      ret = "%^GREEN%^"+ret+" is a lot weaker than you";
      break;
    case 21..40:
      ret = "%^GREEN%^"+ret+" is weaker than you";
      break;
    case 11..20:
      ret = "%^CYAN%^"+ret+" is slightly weaker than you";
      break;
    case -10..10:
      ret = "%^CYAN%^"+ret+" is about equal with you";
      break;
    case -20..-11:
      ret = "%^CYAN%^"+ret+" is slightly tougher than you";
      break;
    case -40..-21:
      ret = "%^RED%^"+ret+" is tougher than you";
      break;
    case -80..-41:
      ret = "%^RED%^"+ret+" is a lot tougher than you";
      break;
    case -160..-81:
      ret = "%^RED%^"+ret+" looks pretty nasty";
      break;
    case -320..-161:
      ret = "%^BOLD%^%^RED%^"+ret+" is into the don't-even-think-about-it "
        "region";
      break;
    default:
      ret = "%^BOLD%^%^RED%^You would have to be utterly insane to attack "
        "$who$";
      break;
    }
   }
   return ret + ".%^RESET%^";
}
int calc_weapon_damage(object weapon) {
  mixed *data;
  int wdam, *damage, i;
  data = (mixed *)weapon->query_attack_data();
  if(sizeof(data)) {
    wdam = 0;
    for ( i = 0; i < sizeof( data ); i += W_ARRAY_SIZE ) {
      if (member_array( data[ i + W_TYPE ], ({ "blunt", "unarmed",
                                               "sharp", "pierce" }) ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      wdam += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
                        ( damage[ F_NUM ] * damage[ F_DIE ] ) / 2 ) ) / 100;
      wdam += damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
    }
  }
  return wdam;
}
int calc_value(mixed arr) {
  if (intp(arr))
    return arr;
  if (!pointerp(arr))
    return 0;
  if (sizeof(arr) == 1)
    return arr[F_FIXED];
  if (sizeof(arr) == 2)
    return arr[F_FIXED]+arr[F_NUM];
  return arr[F_FIXED]+(arr[F_NUM] * arr[F_DIE]);
}
int calc_armour_protection(object armour) {
  int ac, i;
  mapping data;
  mixed *stuff;
  if(!armour->query_armour())
    return 0;
  data = armour->query_armour_class();
  if(!sizeof(data))
     return 0;
  stuff = keys(data);
  for(i=0; i<sizeof(stuff); i++)
    ac += calc_value(data[stuff[i]][0]);
  return ac;
}
int calc_danger(object ob) {
   object weapon;
   object *weapons;
   object armour;
   object rider;
   int wdam;
   int wskill;
   int dskill;
   int ac;
   int hp;
   int trans;
   if (ob->query_transport()) {
      foreach (rider in ob->query_riders()) {
         trans += calc_danger(rider);
      }
   }
  weapons = ob->query_holding();
  if(weapons && sizeof(weapons) > 0 && (weapons[0] != 0) && (weapons[0]->
    query_weapon())) {
    weapon = weapons[0];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else if(weapons && sizeof(weapons) > 1 && (weapons[1] != 0) &&
      (weapons[1]->query_weapon())) {
    weapon = weapons[1];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else {
    weapon = ob;
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  }
  dskill += ob->query_skill_bonus("fighting.combat.dodging.melee");
  wdam = calc_weapon_damage(weapon);
  if(!sizeof(weapon->query_attack_data())) {
    wskill += ob->query_skill_bonus("fighting.combat.melee.unarmed");
    wskill += ob->query_skill_bonus("fighting.combat.special.unarmed") / 2;
  } else {
    wskill += ob->query_skill_bonus("fighting.combat.melee."+
              (string)weapon->query_attack_data()[W_SKILL]);
    wskill += ob->query_skill_bonus("fighting.combat.special.weapon") / 2;
  }
  wskill += ob->query_skill_bonus("fighting.combat.special.tactics");
  wskill += ob->query_specific_gp("fighting");
  hp = ob->query_hp();
  if(ob->query_wearing())
    foreach(armour in ob->query_wearing())
      if(armour)
        ac += calc_armour_protection(armour);
  wdam /= 3;
  hp /= 3;
  dskill /= 2;
  ac /= 6;
  return trans + wdam + wskill + dskill + ac + hp;
}
mixed* query_patterns() {
  return ({ "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: player/cond_ition.c
==================================================

inherit "/cmds/base";
class cond_info {
   object cond_item;
   string cond_string;
   int cond_percent;
}
int compare(float, float);
string cond_colour(int percent)
{
   switch (100 - percent) {
   case 0..50:
      return "";
   case 51..60:
      return "%^CYAN%^";
   case 61..70:
      return "%^GREEN%^";
   case 71..80:
      return "%^YELLOW%^";
   case 81..90:
      return "%^RED%^";
   case 91..100:
      return "%^BOLD%^%^RED%^";
   }
}
int is_valid_environment(object ob) {
   object env;
   env = environment(ob);
   if (env == environment(this_player())) {
      return 1;
   }
   while (env) {
      if (env == this_player()) {
         return 1;
      }
      env = environment(env);
   }
   return 0;
}
int cmd(object *things, int dir, int no_excellent)
{
   int i;
   string list;
   object thing;
   class cond_info *info = ({ });
   class cond_info new_info;
   int dark;
   if (!this_player()->query_property("dead")) {
      dark =
         this_player()->check_dark(environment(this_player())->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   things = filter(things, (: is_valid_environment :));
   if (!sizeof(things)) {
      add_failed_mess("Can only check the condition of things you "
                      "have in your inventory or on the ground.\n");
      return 0;
   }
   if (sizeof(things) == 1) {
      list = things[0]->cond_string();
      if (!list || list == "") {
         list = " has no condition.\n";
      } else {
         if (things[0]->query_is_pair())  list = list[4 .. ];
         else list = list[2..];
      }
      write("$C$" + things[0]->the_short() + list);
      return 1;
   }
   foreach(thing in things) {
      list = thing->cond_string();
      if (list && list != "") {
       if (thing->query_is_pair())  list = list[4 .. ];
       else list = list[2 .. ];
       info += ({ new (class cond_info,
                       cond_item: thing,
                       cond_string: list,
                       cond_percent:(thing->query_cond() * 100) /
                         thing-> query_max_cond()
                    )
            });
      }
   }
   if (!sizeof(info)) {
      add_failed_mess("None of those things has a condition.\n");
      return 0;
   } else if (sizeof(info) == 1) {
      write("$C$" + info[0]->cond_item->the_short() + info[0]->cond_string);
   } else {
      if (dir) {
         info = sort_array
            (info, (: $(dir) * compare($1->cond_percent, $2->cond_percent) :));
      }
      i = 0;
      foreach(new_info in info) {
         if (!no_excellent || new_info->cond_percent <= 90) {
            write(cond_colour(new_info->cond_percent) + "$C$" +
                  new_info->cond_item->the_short() + " (" + (i + 1) + ")" +
                  new_info->cond_string + "%^RESET%^");
            ++i;
         }
      }
      if (!i && no_excellent) {
         write("Everything is in excellent condition.\n");
      }
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object'item(s)'> sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 0) :),
             "<indirect:object'item(s)'>",
             (: cmd($1, 0, 0) :),
             "<indirect:object'item(s)'> damaged",
             (: cmd($1, 0, 1) :),
             "<indirect:object'item(s)'> damaged sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 1) :), });
}
int compare(float first, float second)
{
   if (first > second)
      return 1;
   if (first < second)
      return -1;
   return 0;
}

==================================================
FILE: player/count.c
==================================================

#include <money.h>
inherit "/cmds/base";
#define MAX_COUNT_SIZE 50
int is_not_in_other_player(object thing);
int cmd(object *things, int brief)  {
   string  list;
   string *aliases;
   string  message;
   mixed  *stuff;
   object  thing;
   object  money;
   object  sack;
   object *continuous, *collective;
   object *room_items;
   object *tmp;
   object tmp_ob;
   int     i;
   int     total;
   if (this_player()->
       check_dark(environment(this_player())->query_light()) < 0) {
      add_failed_mess("It's too dark to count anything.\n");
      return 0;
   }
   if(sizeof(things) > MAX_COUNT_SIZE)
     return add_failed_mess("You cannot count that many things!\n");
   things = filter(things, (: !is_not_in_other_player($1) :));
   if (!sizeof(things))  {
      write("You can't count things carried by other people.\n");
      return 1;
   }
   money = 0;
   total = 0;
   list = "";
   foreach (thing in things)  {
      aliases = thing->query_alias();
      if (aliases  &&  member_array(MONEY_ALIAS, aliases) > -1)  {
         if (!money) {
            money = clone_object(MONEY_OBJECT);
         }
         money->adjust_money(thing->query_money_array());
         things -= ({ thing });
      }
   }
   if (money)  {
      total += money->query_number_coins();
      if (sizeof(things))  {
         list = implode(money->half_short(1), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list = query_multiple_short(money->half_short(1));
      }
      money->dest_me();
   }
   continuous = filter(things, (: $1->query_continuous() :));
   if (sizeof(continuous))  {
      sack = clone_object("/std/container");
      foreach (thing in continuous) {
         thing->make_medium_clone(thing->query_amount())->move(sack);
      }
      things -= continuous;
      continuous = all_inventory(sack);
      foreach (thing in continuous)  {
         total += thing->query_how_many();
      }
      if (sizeof(things))  {
         list += implode(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list += query_multiple_short(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)));
      }
      sack->dest_me();
   }
   collective = filter(things, (: $1->query_collective() :));
   if (sizeof(collective))  {
     sack = clone_object("/std/container");
     foreach (thing in collective) {
       if (thing) {
          tmp_ob = thing->make_medium_clone(thing->query_amount());
          if (tmp_ob) {
             tmp_ob->move(sack);
          }
       }
     }
     things -= collective;
     collective = all_inventory(sack);
     foreach (thing in collective) {
       total += thing->query_amount();
     }
     if(sizeof(things)) {
       list += implode(map(collective,
                           (: $1->query_amount() + " " +
                            ($1->query_amount() == 1 ? $1->short() :
                             $1->query_plural()) :)),
                       ", ");
       if (sizeof(things) == 1) {
         list += " and ";
       } else {
         list += ", ";
       }
     } else {
       list += query_multiple_short(map(collective,
                                        (: $1->query_amount() + " " +
                                         ($1->query_amount() == 1 ?
                                          $1->short() :
                                          $1->query_plural()) :)));
     }
     sack->dest_me();
   }
   room_items = filter(things, (: strsrch(file_name($1),
                                          "/std/room/basic/item") > -1 :));
   if (sizeof(room_items))  {
      things -= room_items;
      tmp = filter(room_items, (: $1->query_count() :));
      room_items -= tmp;
      if (sizeof(things))  {
         if (sizeof(tmp)) {
            list += implode(map(tmp, (: query_num($1->query_count()) +
                    " " + ($1->query_count() > 1 ? $1->pretty_plural()
                                                 : $1->pretty_short()) :)),
                    ", ");
            foreach (thing in tmp)  {
               total += thing->query_count();
            }
         }
         if (sizeof(room_items)) {
            list += implode(map(room_items, (: "at least one " +
                                               $1->pretty_short() :)), ", ");
            total += sizeof(room_items);
         }
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else  {
         if (sizeof(tmp)) {
            list += query_multiple_short(map(tmp,
                    (: query_num($1->query_count()) + " " +
                    ($1->query_count() > 1 ? $1->pretty_plural()
                                           : $1->pretty_short()) :)), ", ");
            total += sizeof(tmp);
         }
         if (sizeof(room_items)) {
            list += query_multiple_short(map(room_items,
                    (: "at least one " + $1->pretty_short() :)));
            total += sizeof(room_items);
         }
      }
   }
   if (sizeof(things))  {
      list += query_multiple_short(things, "one");
if (this_player() == find_player("presto"))
tell_creator("presto", "list == %s\n", list);
      stuff = this_player()->reform_message(list, ({}));
if (this_player() == find_player("presto"))
printf("test message: %O\n", this_player()->evaluate_message(stuff));
      message = stuff[0];
      for (i = 0; i < sizeof(stuff[1]); i++)  {
         message = replace_string(message, "$" + i + "$",
            this_player()->calc_shorts(stuff[1][i], 1));
      }
      total += sizeof(things);
   } else {
      message = list;
   }
   if (brief) {
      write("You count " + total + " items.\n");
   } else {
      write("You count " + message + " with a total of " +
            query_num(total) + (total > 1 ? " items.\n" : " item.\n"));
   }
   return 1;
}
int is_not_in_other_player(object env)  {
   while ((env = environment(env))  &&  !living(env))
      ;
   if (env  &&  env != this_player())
      return 1;
   else
      return 0;
}
mixed *query_patterns()  {
   return ({ "<indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 0) :),
             "<indirect:object:me'things'> in inventory", (: cmd($1, 0) :),
             "<indirect:object:here'things'> in room", (: cmd($1, 0) :),
             "brief <indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 1) :),
             "brief <indirect:object:me'things'> in inventory", (: cmd($1, 1) :),
             "brief <indirect:object:here'things'> in room", (: cmd($1, 1) :) });
}

==================================================
FILE: player/countries.c
==================================================

#define COUNTRIES_NO_SHOW_PROP "don't show on countries list"
mapping common_countries = ([
   "N/A" : ({ 0, "An unresolved address" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "net" : ({ 0, "Network" }),
   "uk" : ({ 0, "United Kingdom" }),
   "au" : ({ 0, "Australia" })
   ]);
mapping all_countries = ([
   "ad" : ({ 0, "Andorra", }),
   "ae" : ({ 0, "United Arab Emirates" }),
   "af" : ({ 0, "Afghanistan" }),
   "ag" : ({ 0, "Antigua and Barbuda" }),
   "ai" : ({ 0, "Anguila" }),
   "al" : ({ 0, "Albania" }),
   "am" : ({ 0, "Armenia" }),
   "an" : ({ 0, "Netherlands Antilles" }),
   "ao" : ({ 0, "Angola" }),
   "aq" : ({ 0, "Antarctica" }),
   "ar" : ({ 0, "Argentina" }),
   "as" : ({ 0, "American Samoa" }),
   "at" : ({ 0, "Austria" }),
   "au" : ({ 0, "Australia" }),
   "aw" : ({ 0, "Aruba" }),
   "az" : ({ 0, "Azerbaijan" }),
   "ba" : ({ 0, "Bosnia and Herzegovina" }),
   "bb" : ({ 0, "Barbados" }),
   "bd" : ({ 0, "Bangladesh" }),
   "be" : ({ 0, "Belgium" }),
   "bf" : ({ 0, "Burkina Faso" }),
   "bg" : ({ 0, "Bulgaria" }),
   "bh" : ({ 0, "Bahrain" }),
   "bi" : ({ 0, "Burundi" }),
   "bj" : ({ 0, "Benin" }),
   "bm" : ({ 0, "Bermuda" }),
   "bn" : ({ 0, "Brunei Darussalam" }),
   "bo" : ({ 0, "Bolivia" }),
   "br" : ({ 0, "Brazil" }),
   "bs" : ({ 0, "Bahamas" }),
   "bt" : ({ 0, "Bhutan" }),
   "bv" : ({ 0, "Bouvet Island" }),
   "bw" : ({ 0, "Botswana" }),
   "by" : ({ 0, "Belarus" }),
   "bz" : ({ 0, "Belize" }),
   "ca" : ({ 0, "Canada" }),
   "cc" : ({ 0, "Cocos (Keeling) Islands" }),
   "cf" : ({ 0, "Central African Republic" }),
   "cg" : ({ 0, "Congo" }),
   "ch" : ({ 0, "Switzerland" }),
   "ci" : ({ 0, "Cote D'Ivoire (Ivory Coast)" }),
   "ck" : ({ 0, "Cook Island" }),
   "cl" : ({ 0, "Chile" }),
   "cm" : ({ 0, "Cameroon" }),
   "cn" : ({ 0, "China" }),
   "co" : ({ 0, "Colombia" }),
   "cr" : ({ 0, "Costa Rica" }),
   "cs" : ({ 0, "Czechoslovakia (former)" }),
   "cu" : ({ 0, "Cuba" }),
   "cv" : ({ 0, "Cape Verde" }),
   "cx" : ({ 0, "Christmas Island" }),
   "cy" : ({ 0, "Cyprus" }),
   "cz" : ({ 0, "Czech Republic" }),
   "de" : ({ 0, "Germany" }),
   "dk" : ({ 0, "Denmark" }),
   "dm" : ({ 0, "Dominica" }),
   "do" : ({ 0, "Dominican Republic" }),
   "dz" : ({ 0, "Algeria" }),
   "ec" : ({ 0, "Ecuador" }),
   "ee" : ({ 0, "Estonia" }),
   "eg" : ({ 0, "Egypt" }),
   "eh" : ({ 0, "Western Sahara" }),
   "er" : ({ 0, "Eritrea" }),
   "es" : ({ 0, "Spain" }),
   "et" : ({ 0, "Ethiopia" }),
   "fi" : ({ 0, "Finland" }),
   "fj" : ({ 0, "Fiji" }),
   "fk" : ({ 0, "Falkland Islands (Malvinas)" }),
   "fm" : ({ 0, "Micronesia" }),
   "fo" : ({ 0, "Faroe Islands" }),
   "fr" : ({ 0, "France" }),
   "fx" : ({ 0, "France, Metropolitan" }),
   "ga" : ({ 0, "Gabon" }),
   "gd" : ({ 0, "Grenada" }),
   "ge" : ({ 0, "Georgia" }),
   "gf" : ({ 0, "French Guiana" }),
   "gh" : ({ 0, "Ghana" }),
   "gi" : ({ 0, "Gibraltar" }),
   "gl" : ({ 0, "Greenland" }),
   "gm" : ({ 0, "Gambia" }),
   "gn" : ({ 0, "Guinea" }),
   "gp" : ({ 0, "Guadeloupe" }),
   "gq" : ({ 0, "Equatorial Guinea" }),
   "gr" : ({ 0, "Greece" }),
   "gs" : ({ 0, "S. Georgia and S. Sandwich Isls." }),
   "gt" : ({ 0, "Guatemala" }),
   "gu" : ({ 0, "Guam" }),
   "gw" : ({ 0, "Guinea-Bissau" }),
   "gy" : ({ 0, "Guyana" }),
   "hk" : ({ 0, "Hong Kong" }),
   "hm" : ({ 0, "Heard and McDonald Islands" }),
   "hn" : ({ 0, "Honduras" }),
   "hr" : ({ 0, "Croatia (Hrvatska)" }),
   "ht" : ({ 0, "Haiti" }),
   "hu" : ({ 0, "Hungary" }),
   "id" : ({ 0, "Indonesia" }),
   "ie" : ({ 0, "Ireland" }),
   "il" : ({ 0, "Israel" }),
   "in" : ({ 0, "India" }),
   "io" : ({ 0, "British Indian Ocean Territory" }),
   "iq" : ({ 0, "Iraq" }),
   "ir" : ({ 0, "Iran" }),
   "is" : ({ 0, "Iceland" }),
   "it" : ({ 0, "Italy" }),
   "jm" : ({ 0, "Jamaica" }),
   "jo" : ({ 0, "Jordan" }),
   "jp" : ({ 0, "Japan" }),
   "ke" : ({ 0, "Kenya" }),
   "kg" : ({ 0, "Kyrgyzstan" }),
   "kh" : ({ 0, "Cambodia" }),
   "ki" : ({ 0, "Kiribati" }),
   "km" : ({ 0, "Comoros" }),
   "kn" : ({ 0, "Saint Kitts and Nevis" }),
   "kp" : ({ 0, "Korea (North)" }),
   "kr" : ({ 0, "Korea (South)" }),
   "kw" : ({ 0, "Kuwait" }),
   "ky" : ({ 0, "Cayman Islands" }),
   "kz" : ({ 0, "Kazakhstan" }),
   "la" : ({ 0, "Laos" }),
   "lb" : ({ 0, "Lebanon" }),
   "lc" : ({ 0, "Saint Lucia" }),
   "li" : ({ 0, "Liechtenstein" }),
   "lk" : ({ 0, "Sri Lanka" }),
   "lr" : ({ 0, "Liberia" }),
   "ls" : ({ 0, "Lesotho" }),
   "lt" : ({ 0, "Lithuania" }),
   "lu" : ({ 0, "Luxembourg" }),
   "lv" : ({ 0, "Latvia" }),
   "ly" : ({ 0, "Libya" }),
   "ma" : ({ 0, "Morocco" }),
   "mc" : ({ 0, "Monaco" }),
   "md" : ({ 0, "Moldovia" }),
   "mg" : ({ 0, "Madagascar" }),
   "mh" : ({ 0, "Marshall Islands" }),
   "mk" : ({ 0, "Macedonia" }),
   "ml" : ({ 0, "Mali" }),
   "mm" : ({ 0, "Myanmar" }),
   "mn" : ({ 0, "Mongolia" }),
   "mo" : ({ 0, "Macau" }),
   "mp" : ({ 0, "Northern Mariana Islands" }),
   "mq" : ({ 0, "Martinique" }),
   "mr" : ({ 0, "Mauritania" }),
   "ms" : ({ 0, "Montserrat" }),
   "mt" : ({ 0, "Malta" }),
   "mu" : ({ 0, "Mauritius" }),
   "mv" : ({ 0, "Maldives" }),
   "mw" : ({ 0, "Malawi" }),
   "mx" : ({ 0, "Mexico" }),
   "my" : ({ 0, "Malaysia" }),
   "mz" : ({ 0, "Mozambique" }),
   "na" : ({ 0, "Namibia" }),
   "nc" : ({ 0, "New Caledonia" }),
   "ne" : ({ 0, "Niger" }),
   "nf" : ({ 0, "Norfolk Islands" }),
   "ng" : ({ 0, "Nigeria" }),
   "ni" : ({ 0, "Nicaragua" }),
   "nl" : ({ 0, "Netherlands" }),
   "no" : ({ 0, "Norway" }),
   "np" : ({ 0, "Nepal" }),
   "nr" : ({ 0, "Nauru" }),
   "nt" : ({ 0, "Neutral Zone" }),
   "nu" : ({ 0, "Niue" }),
   "nz" : ({ 0, "New Zealand (Aotearoa)" }),
   "om" : ({ 0, "Oman" }),
   "pa" : ({ 0, "Panama" }),
   "pe" : ({ 0, "Peru" }),
   "pf" : ({ 0, "French Polynesia" }),
   "pg" : ({ 0, "Papua New Guinea" }),
   "ph" : ({ 0, "Philippines" }),
   "pk" : ({ 0, "Pakistan" }),
   "pl" : ({ 0, "Poland" }),
   "pm" : ({ 0, "St. Pierre and Miquelon" }),
   "pn" : ({ 0, "Pitcairn" }),
   "pr" : ({ 0, "Puerto Rico" }),
   "pt" : ({ 0, "Portugal" }),
   "pw" : ({ 0, "Palau" }),
   "py" : ({ 0, "Paraguay" }),
   "qa" : ({ 0, "Qatar" }),
   "re" : ({ 0, "Reunion" }),
   "ro" : ({ 0, "Romania" }),
   "ru" : ({ 0, "Russian Federation" }),
   "rw" : ({ 0, "Rwanda" }),
   "sa" : ({ 0, "Saudi Arabia" }),
   "sb" : ({ 0, "Solomon Islands" }),
   "sc" : ({ 0, "Seychelles" }),
   "sd" : ({ 0, "Sudan" }),
   "se" : ({ 0, "Sweden" }),
   "sg" : ({ 0, "Singapore" }),
   "sh" : ({ 0, "St. Helena" }),
   "si" : ({ 0, "Slovenia" }),
   "sj" : ({ 0, "Svalbard and Jan Mayen Islands" }),
   "sk" : ({ 0, "Slovak Republic" }),
   "sl" : ({ 0, "Sierra Leone" }),
   "sm" : ({ 0, "San Marino" }),
   "sn" : ({ 0, "Senegal" }),
   "so" : ({ 0, "Somalia" }),
   "sr" : ({ 0, "Suriname" }),
   "st" : ({ 0, "Sao Tome and Principe" }),
   "su" : ({ 0, "USSR (former)" }),
   "sv" : ({ 0, "El Salvador" }),
   "sy" : ({ 0, "Syria" }),
   "sz" : ({ 0, "Swaziland" }),
   "tc" : ({ 0, "Turks and Caicos Islands" }),
   "td" : ({ 0, "Chad" }),
   "tf" : ({ 0, "French Southern Territories" }),
   "tg" : ({ 0, "Togo" }),
   "th" : ({ 0, "Thailand" }),
   "tj" : ({ 0, "Tajikistan" }),
   "tk" : ({ 0, "Tokelau" }),
   "tm" : ({ 0, "Turkmenistan" }),
   "tn" : ({ 0, "Tunisia" }),
   "to" : ({ 0, "Tonga" }),
   "tp" : ({ 0, "East Timor" }),
   "tr" : ({ 0, "Turkey" }),
   "tt" : ({ 0, "Trinidad and Tobago" }),
   "tv" : ({ 0, "Tuvalu" }),
   "tw" : ({ 0, "Taiwan" }),
   "tz" : ({ 0, "Tanzania" }),
   "ua" : ({ 0, "Ukraine" }),
   "ug" : ({ 0, "Uganda" }),
   "uk" : ({ 0, "United Kingdom" }),
   "um" : ({ 0, "US Minor Outlying Islands" }),
   "us" : ({ 0, "United States" }),
   "uy" : ({ 0, "Uruguay" }),
   "uz" : ({ 0, "Uzbekistan" }),
   "va" : ({ 0, "Vatican City State (Holy See)" }),
   "vc" : ({ 0, "Saint Vincent and the Grenadines" }),
   "ve" : ({ 0, "Venezuela" }),
   "vg" : ({ 0, "Virgin Islands (British)" }),
   "vi" : ({ 0, "Virgin Islands (U.S.)" }),
   "vn" : ({ 0, "Viet Nam" }),
   "vu" : ({ 0, "Vanuatu" }),
   "wf" : ({ 0, "Wallis and Futuna Islands" }),
   "ws" : ({ 0, "Samoa" }),
   "ye" : ({ 0, "Yemen" }),
   "yt" : ({ 0, "Mayotte" }),
   "yu" : ({ 0, "Yugoslavia" }),
   "za" : ({ 0, "South Africa" }),
   "zm" : ({ 0, "Zambia" }),
   "zr" : ({ 0, "Zaire" }),
   "zw" : ({ 0, "Zimbabwe" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "gov" : ({ 0, "US Government" }),
   "int" : ({ 0, "International" }),
   "mil" : ({ 0, "US Military" }),
   "net" : ({ 0, "Network" }),
   "org" : ({ 0, "Non-Profit Organization" }),
   "arpa" : ({ 0, "Old Style Arpanet" }),
   "nato" : ({ 0, "NATO Field" })
   ]);
int cmd();
int handle_no_show( int hide );
string resolve_domain_suffix( object player );
int cmd() {
   int left, right, size;
   float percentage;
   object person, *users;
   string suffix, message, country;
   mixed *unsorted, *sorted, *data;
   mapping countries;
   countries = copy( common_countries );
   users = filter( users(), (: $1->query_visible( this_player() ) &&
      !$1->query_property( COUNTRIES_NO_SHOW_PROP ) :) );
   if( !size = sizeof( users ) ) {
      return notify_fail( "No visible players.\n" );
   }
   foreach( person in users ) {
      suffix = resolve_domain_suffix( person );
      if( undefinedp( countries[ suffix ] ) ) {
         if( undefinedp( all_countries[ suffix ] ) ) {
            countries[ "N/A" ][ 0 ] ++;
            continue;
         } else {
            common_countries += ([ suffix : all_countries[ suffix ] ]);
            countries += ([ suffix : copy( all_countries[ suffix ] ) ]);
         }
      }
      countries[ suffix ][ 0 ] ++;
   }
   unsorted = ({ });
   size -= countries[ "N/A" ][ 0 ];
   map_delete( countries, "N/A" );
   foreach( country, data in countries ) {
      if( !data[ 0 ] ) {
         map_delete( common_countries, country );
         continue;
      } else {
         data[ 1 ] += " (%^BOLD%^" + upper_case( country ) + "%^RESET%^)";
         unsorted += ({ data });
      }
   }
   sorted = sort_array( unsorted, -1 );
   message = "\nA total of %^BOLD%^" + query_num( size ) +
      "%^RESET%^ visible " + ( size != 1 ? "users" : "user" ) +
      " with resolvable addresses logged on:\n";
   left = this_player()->query_cols() / 3 * 2;
   left -= 3;
   right = this_player()->query_cols() - left;
   foreach( data in sorted ) {
      percentage = data[ 0 ] * 100.0 / size;
      message += sprintf( "   %-=*'.'s%*-=s\n",
      left, data[ 1 ],
      right, "  " + to_int( percentage + 0.5 ) + "%" );
   }
   this_player()->more_string( message );
   return 1;
}
string resolve_domain_suffix( object player ) {
   string addy, *host;
   addy = query_ip_name( player );
   if( !addy ) {
      return 0;
   }
   host = explode( lower_case( addy ), "." );
   return host[ sizeof( host ) - 1 ];
}
int handle_no_show( int hide ) {
   switch( hide ) {
      case 1:
         if( this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already hidden on the "
               "countries list.\n" );
            return 1;
         }
         this_player()->add_property( COUNTRIES_NO_SHOW_PROP, 1 );
         tell_object( this_player(), "You will no longer be included in "
            "the countries list.\n" );
         return 1;
      case 0:
         if( !this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already visible on "
               "the countries list.\n" );
            return 1;
         }
         this_player()->remove_property( COUNTRIES_NO_SHOW_PROP );
         tell_object( this_player(), "You will now be shown on the "
            "countries list.\n" );
         return 1;
      default:
         return notify_fail( "This shouldn't happen.\n" );
   }
}
mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "hide", (: handle_no_show( 1 ) :),
             "show", (: handle_no_show( 0 ) :)
          });
}

==================================================
FILE: player/coverage.c
==================================================

inherit "/cmds/base.c";
#define CLOTHING_HANDLER "/obj/handlers/clothing_handler"
private string _zone_patterns;
int cmd(object *items, int inverse, string bits)  {
   object   armor;
   object  *wearing;
   object  *fail = ({ });
   object  *armors;
   object  *covering;
   string  *types;
   string   equiv_type;
   string   type;
   string  *zones;
   string  *all_zones;
   string  *parts;
   string   zone;
   string   verb;
   string   mess;
   mapping  covered;
   mapping  pot_covered;
   all_zones = keys(CLOTHING_HANDLER->query_all_clothing_zones());
   covered = allocate_mapping(sizeof(all_zones));
   pot_covered = allocate_mapping(sizeof(all_zones));
   foreach (zone in all_zones)  {
      covered[zone] = ({ });
      pot_covered[zone] = ({ });
   }
   if (sizeof(items) == 0)
      armors = this_player()->query_armours();
   else
      armors = items;
   fail = filter(armors,
                 (: !$1->query_armour()  &&  !$1->query_clothing() :));
   armors -= fail;
   wearing = this_player()->query_wearing();
   if (bits)  {
      bits = replace(bits, " ", ",");
      bits = replace(bits, ",and,", ",");
      zones = explode(bits, ",") - ({ "" });
      parts = filter(zones, (: member_array($1, $(all_zones)) != -1 :));
      if (sizeof(parts) == 0)  {
         write("Please choose some combination of " +
               query_multiple_short(all_zones) + ".\n");
         return 1;
      }
   }
   foreach (armor in armors)  {
      if (!arrayp(armor->query_type()))
         types = ({ armor->query_type() });
      else
         types = armor->query_type();
      zones = ({ });
      foreach (type in types)  {
         equiv_type = CLOTHING_HANDLER->query_equivilant_type(type);
         if (equiv_type)
            zones += CLOTHING_HANDLER->query_zone_names(equiv_type);
         else
            zones += CLOTHING_HANDLER->query_zone_names(type);
      }
      if (sizeof(zones))  {
         if (member_array(armor, wearing) > -1)
            foreach (zone in zones)
               covered[zone] += ({ armor });
         else
            foreach (zone in zones)
               pot_covered[zone] += ({ armor });
      }
      else fail += ({ armor });
   }
   if (bits)  {
      covered = filter(covered, (: member_array($1, $(parts)) != -1 :));
      pot_covered = filter(pot_covered,
                           (: member_array($1, $(parts)) != -1 :));
   }
   if (inverse)  {
      zones = filter(all_zones, (: sizeof($(covered)[$1]) == 0 :));
      if (sizeof(zones) > 0)  {
         if (sizeof(zones) > 1  ||
             zones[0] == "arms"  ||  zones[0] == "hands"  ||
             zones[0] == "legs"  || zones[0] == "feet")
            verb = " are";
         else
            verb = " is";
         write("Your " + query_multiple_short(zones) + verb +
               " unprotected.\n");
      }
      else write("You are covered from head to foot.\n");
      return 1;
   }
   zones = sort_array(keys(covered) | keys(pot_covered), 1);
   foreach (zone in zones)  {
      if (zone == "arms"  ||  zone == "hands"  ||
          zone == "legs"  ||  zone == "feet")
         verb = " are";
      else
         verb = " is";
      if (sizeof(covering = covered[zone]) > 0)  {
         if (sizeof(covering) == 1)
            mess = "Your " + zone + verb + " protected by " +
                   covering[0]->one_short();
         else
            mess = "Your " + zone + verb + " protected by " +
                   query_num(sizeof(covering)) + " things, " +
                   query_multiple_short(covering, "one");
         if (sizeof(pot_covered[zone]) > 0)  {
            mess += " and could be protected by " +
                    query_multiple_short(pot_covered[zone], "one") + ".\n";
            pot_covered[zone] = ({ });
         }
         else mess += ".\n";
         write(mess);
      }
      else if (sizeof(covering = pot_covered[zone]) > 0)  {
         write("Your " + zone + " could be protected by " +
               query_multiple_short(covering, "one") + ".\n");
      }
      else if (bits) write("Your " + zone + verb + " unprotected.\n");
   }
   if (sizeof(fail) != 0  &&  sizeof(items) != 0)  {
      if (sizeof(fail) == 1  &&  fail[0] == this_player())
         write("You don't offer any protection.  Perhaps you should invest "
               "in some sonkies?\n");
      else
         write(query_multiple_short(fail, "the") +
               (sizeof(fail) == 1 ? " doesn't" : " don't") +
               " offer any protection.\n");
   }
   else if (sizeof(armors - fail) == 0)
      write("You are completely unprotected.  Good luck!\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd(({ }), 0, 0) :),
             "[by] <indirect:object'armour/clothing'>", (: cmd($1, 0, 0) :),
             "unprotected", (: cmd(({ }), 1, 0) :),
             "of <string'body part(s)'>", (: cmd(({ }), 0, $4[0]) :) });
}

==================================================
FILE: player/date.c
==================================================

#include "/cmds/player/time.c";

==================================================
FILE: player/describe.c
==================================================

#include <player.h>
#include <clothing.h>
inherit "/cmds/base";
#define TP this_player()
int use_count = 0;
private string _zone_str;
void create() {
   string zone;
   _zone_str = "face|hair";
   foreach (zone in keys(CLOTHING_HANDLER->query_all_clothing_zones())) {
      _zone_str += "|" + zone;
   }
}
int cmd(string str) {
   string desc;
   string zone;
   desc = TP->query_desc();
   if (!str) {
      if (desc) {
         write("Description reads:\n" + TP->query_cap_name() + " " +
               desc + "\n");
      } else {
         write("No description set.\n");
      }
      if (sizeof(TP->query_zone_desc_names())) {
         foreach (zone in TP->query_zone_desc_names()) {
            write("$I$5=$C$" + zone + ": " + TP->query_zone_desc(zone) + "\n");
         }
         if (!desc) {
            write("%^YELLOW%^Warning! Your zone descriptions will not be "
                  "displayed unless you also have a main description.%^RESET%^\n");
         } else {
            write("Each zone description is a sentence, or multiple "
                  "sentences.  If you do not do this then the descriptions "
                  "will look wrong.\n");
         }
      } else {
         write("No zone descriptions setup.\n");
      }
      return 1;
   }
   else if (str == "clear") {
      write("Description cleared.\n");
      TP->set_desc(0);
      return 1;
   }
   else if (str == "edit") {
     if (desc) {
         this_player()->do_edit(sprintf("%-=*s", this_player()->query_cols(),
                                        this_player()->query_cap_name() + " " +
                                        replace(strip_colours(desc), "\n",
                                                "\n\n") + "\n"),
                                "finish_desc_edit");
     } else
       this_player()->do_edit("", "finish_desc_edit");
     ++use_count;
     return 1;
   }
   else if (strlen(str) > MAX_DESC) {
      notify_fail("Description unchanged.  Given description was too long.  "
                  "Maximum allowed length is " + MAX_DESC+ ".\n");
      return 0;
   }
   TP->set_desc(strip_colours(str));
   write("Description set.\n");
   return 1;
}
void finish_desc_edit(string str) {
   string cname;
   --use_count;
   if (!str) {
      write("Description unchanged.\n");
     return;
   }
   cname = this_player()->query_cap_name();
   if (str[0 .. strlen(cname)] == cname + " ")
      str = str[strlen(cname) + 1 .. 10000];
   str = strip_colours(str);
   str = replace(str, ({ "\n\n", "$NEW_LINE$", "\n", " " }));
   str = replace(str, "$NEW_LINE$", "\n");
   if (strlen(str) > MAX_DESC) {
      write("Description unchanged.  Given description was too long.  "
            "Maximum allowed length is " + MAX_DESC+ ".\n");
      return;
   }
   TP->set_desc(str);
   write("Description set.\n");
   return;
}
int cmd_zone(string zone, string desc) {
   this_player()->set_zone_desc(zone, desc);
   write("Set the description for the zone " + zone + " as \"" + desc + "\".\n");
   return 1;
}
int cmd_zone_clear(string zone) {
   this_player()->set_zone_desc(zone, 0);
   write("Cleared the description for the zone " + zone + ".\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd(0) :),
             "main <string'description'>", (: cmd($4[0]) :),
             "edit", (: cmd("edit") :),
             "clear", (: cmd("clear") :),
             "zone {" + _zone_str + "} <string'description'>",
                  (: cmd_zone($4[0], $4[1]) :),
             "zone {" + _zone_str + "} clear",
                  (: cmd_zone_clear($4[0]) :),
               });
}

==================================================
FILE: player/dnickname.c
==================================================

inherit "cmds/base";
mixed cmd(string str) {
  mapping map_nicknames;
  map_nicknames = this_player()->query_nicknames();
  if (!map_nicknames)
    map_nicknames = ([ ]);
  if (!map_nicknames[str]) {
    notify_fail("That nickname does not exist.\n");
    return 0;
  }
  map_nicknames = m_delete(map_nicknames, str);
  this_player()->set_nicknames(map_nicknames);
  write("Deleted nickname \"" + str + "\".\n");
  return 1;
}
mixed *query_patterns()  {
  return ({ "<string'nickname'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/ea_lias.c
==================================================

#include <alias.h>
inherit "/cmds/base";
mapping editing_alias;
void create() {
   editing_alias = ([ ]);
}
protected int edit_alias(string str, int new_flag) {
   string al;
   if (editing_alias[this_player()]) {
      add_failed_mess("You are already editing the '" +
                  editing_alias[this_player()] + "' alias.\n");
      return 0;
   }
   if (!this_player()->is_alias(str))  {
      if (!new_flag)  {
         add_failed_mess("No alias '"+str+"' defined.\n");
         return 0;
      }
   } else if (new_flag)  {
      add_failed_mess("You already have an alias called \"" + str + "\".");
      return 0;
   }
   editing_alias[this_player()] = str;
   if (new_flag)  al = "";
   else al = replace(ALIAS_CMD->alias_string(this_player()->
      query_player_alias(str)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
}
protected int edit_alias_copy(string alias, string new_alias) {
   string al;
   if (!this_player()->is_alias(alias)) {
      add_failed_mess("No alias '"+alias+"' defined.\n");
      return 0;
   }
   if (this_player()->is_alias(new_alias)) {
      add_failed_mess("The alias '"+new_alias+"' already exists.\n");
      return 0;
   }
   new_alias = replace_string(new_alias, "END_ALIAS", "NO YOU DONT");
   editing_alias[this_player()] = new_alias;
   al = replace(ALIAS_CMD->alias_string(this_player()->query_player_alias(alias)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
}
void finish_alias_edit(string str) {
   string alias;
   if (!editing_alias[this_player()]) {
      write("Oh dear.  We got terribly confused and forgot "
            "what you were trying to do.  Terribly sorry.\n");
      return ;
   }
   if (!str  ||  str == "") {
      write("Can't save an empty alias, sorry.\n");
      editing_alias[this_player()] = 0;
      return ;
   }
   str = replace(str, "\n", ";");
   alias = editing_alias[this_player()];
   if (!this_player()->is_alias(alias))
      printf("Added alias '%s'.\n", alias);
   else
      printf("Changed alias '%s'\n", alias);
   this_player()->add_player_alias(alias, ALIAS_CMD->compile_alias(str));
   map_delete(editing_alias, this_player());
   return ;
}
mixed *query_patterns() {
  return ({
    "<word'alias'>", (: edit_alias($4[0], 0) :),
    "new <word'alias'>", (: edit_alias($4[0], 1) :),
    "copy <word'alias'> to <word'new alias'>", (: edit_alias_copy($4[0], $4[1]) :),
      });
}
int clean_up()  {
   if (sizeof(editing_alias) == 0)
      ::clean_up();
   return 1;
}
void reset()  {
   if (sizeof(editing_alias) == 0)
      ::reset();
   return;
}

==================================================
FILE: player/ear_muffs.c
==================================================

#define TP this_player()
#include <player.h>
#include <newbiehelpers.h>
inherit "/cmds/base";
private string *_normal_types;
private string *_cre_types;
private string _player_format;
void create() {
   ::create();
   _normal_types = ({ "shout", "newbie", "cryer", "remote-soul",
         "multiple-soul", "multiple-tell",  "teach",
         "tell", "remote", "multiple-remote" });
   _cre_types = ({ "cre", "lord", "code", "liaison",
         "intermud-all", "intercre", "intergossip",
         "dwcre", "dwchat", "remote-spam", "newbiehelpers",
                     "verbose-logon"});
   _player_format = "{" + implode(_normal_types, "|") + "}";
}
int check_earmuffs() {
  string *on;
  string *types;
  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }
  if (TP->query_earmuffs()) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      printf("Your earmuffs are set to allow friends through.\n");
    } else {
      printf("Your earmuffs are on.\n");
    }
  } else {
    printf("Your earmuffs are off.\n");
  }
  if (!sizeof(on)) {
    printf("You have nothing set to be earmuffed.\n");
    write("$I$5=Earmuffable events are "+ query_multiple_short(types)+
          ".\n");
  } else {
    write("$I$5=You have "+ query_multiple_short(on)+ " earmuffed.\n");
    types -= on;
    if (sizeof(types)) {
      write("$I$5=You are not currently earmuffing "+
            query_multiple_short(types)+ " events.\n");
    }
  }
  return 1;
}
int do_earmuff_control(string str) {
  string *types;
  string *on;
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }
  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  switch (str) {
    case "on" :
      if (!TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      } else if (TP->query_allow_friends_earmuffs()) {
        TP->toggle_earmuffs();
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned on.\n");
      break;
    case "off" :
      if (TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned off.\n");
      break;
    case "allowfriends" :
      TP->set_allow_friends_earmuffs();
      write("Earmuffs set to allow friends through.\n");
      break;
    case "all" :
      on = types;
      if (sizeof(on)) {
        write("$I$5=Your "+ query_multiple_short(on)+
              " events will now be earmuffed.\n");
      }
      break;
    case "none" :
      write("Nothing will be earmuffed any more.  (No news is good news?)\n");
      on = ({ });
      break;
  }
  TP->add_property(PLAYER_EARMUFF_PROP, on);
  return 1;
}
int do_earmuff(string str, string onOff) {
  string *types, *on, *off;
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types;
  }
  on = (string *)TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  off = ({ });
  switch (onOff) {
    case "on" :
      if (member_array(str, on) == -1) {
        on += ({ str });
      }
      write("You are now earmuffing " + str + " events.\n");
      break;
    case "off" :
      off += ({ str });
      write("You are not earmuffing " + str + " events anymore.\n");
      break;
    default :
      if (member_array(str, on) == -1) {
        on += ({ str });
        write("You are now earmuffing " + str + " events.\n");
      } else {
        off += ({ str });
        write("You are not earmuffing " + str + " events anymore.\n");
      }
      break;
  }
  on -= off;
  TP->add_property(PLAYER_EARMUFF_PROP, on);
  return 1;
}
mixed *query_patterns() {
  string cre_format;
  if (this_player()->query_creator()) {
    cre_format = "{" + implode(_normal_types +
                     _cre_types + this_player()->channel_list(), "|") + "}";
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                cre_format, (: do_earmuff($4[0], "") :),
                cre_format + " {on|off}", (: do_earmuff($4[0], $4[1]) :) });
  } else {
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      _player_format = "{" +
                       implode(_normal_types + ({"newbiehelpers"}), "|") + "}";
    }
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                _player_format, (: do_earmuff($4[0], "") :) ,
                _player_format + " {on|off}",
                (: do_earmuff($4[0], $4[1]) :) });
  }
}

==================================================
FILE: player/email.c
==================================================

#include <player.h>
inherit "/cmds/base";
#define TP this_player()
int cmd(string str) {
   string email;
  email = TP->query_email();
   if (!str) {
      write("Your current email address is "+email+"\n");
      write("To clear use \"email CLEAR\"\n");
      write("For the email address to be only visible by lords prepend a :\n");
      write("eg email :frog@frogcentral.froguni.swamp\n");
      return 1;
   }
   if (str == "CLEAR")
      email = "";
   else
      email = str;
   if (email != "")
      write("Email address set to "+str+".\n");
   else
      write("Email address is null.\n");
   TP->set_email(email);
   return 1;
}

==================================================
FILE: player/ex_amine.c
==================================================

inherit "/cmds/living/l_ook";
mixed *query_patterns() {
    return ({ "<string'direction'>", (: cmd_string($4[0]) :),
              "<indirect:object>", (: cmd_object($1, $4[0]) :) });
}

==================================================
FILE: player/finger.c
==================================================

inherit "/cmds/base";
#include <clubs.h>
mixed cmd() {
  string ret;
  object ob, *obs;
  string type;
  string str;
    obs = users();
    obs = sort_array(obs, (: strcmp($1->query_cap_name(),
    $2->query_cap_name()) :));
    str = sprintf("%-12.12s    %-20.20s %-20.20s %-20.20s\n",
                  "Name", "Real name", "Where", "Birthday");
    foreach (ob in obs) {
      string euid;
      type = (ob->query_earmuffs() ? "e" : " ");
      euid = geteuid(ob);
      type += ob->query_object_type();
      str += sprintf("%-12.12s %2.2s %-20.20s %-20.20s %-20.20s\n",
      (ob->query_invis()?"("+ob->query_cap_name()+")":(string)ob->query_cap_name()),
                    type,
                    ((ret = (string)ob->query_real_name())?ret:"-"),
                    ((ret = (string)ob->query_where())?ret:"-"),
                    ((ret = (string)ob->query_birthday())?ret:"-"));
    }
    write("$P$Finger$P$" + str);
    return 1;
}
int finger_player(string str) {
  string ret;
  string mud;
  if (str) {
    str = lower_case(str);
    str = (string)this_player()->expand_nickname(str);
  }
  ret = (string)"/secure/finger"->finger_info(str);
  if (ret) {
    write("$P$finger: " + str + "$P$" + ret);
    return 1;
  } else if (this_player()->query_creator() &&
             sscanf(str, "%s@%s", mud, mud) == 2) {
    "/net/daemon/out_finger"->do_finger(str);
    return 1;
  } else {
    add_failed_mess("No one going by the name of " + str + " has ever visited "
      "" + mud_name() + ".\n");
    return 0;
  }
}
mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "<string'name|domain|club'>", (: finger_player($4[0]) :) });
}

==================================================
FILE: player/friend_s.c
==================================================

inherit "/cmds/base";
#include <player.h>
#include <player_handler.h>
int cmd_display(string person, string pattern) {
   string* friends;
   string ret;
   if (person == "online") {
      friends = filter(this_player()->query_friends(), (: find_player($1) :));
   } else if (person != "") {
      person = this_player()->expand_nickname(person);
      if (!this_player()->is_friend(person)) {
         add_failed_mess(person + " is not your friend.\n");
         return 0;
      }
      friends = ({ person });
   } else {
      friends = this_player()->query_friends();
   }
   if (pattern) {
      if (regexp(pattern,
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (pattern[0] == '*' || pattern[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      if (catch(regexp("test str", pattern))) {
         add_failed_mess("Pattern has an error in it, mismatched brackets?\n");
         return 0;
      }
      foreach (person in friends) {
         if (!regexp(this_player()->query_friend_tag(person), pattern)) {
            friends -= ({ person });
         }
      }
      if (!sizeof(friends)) {
         add_failed_mess("The tag '" + pattern + "' did not exist "
                         "in your friends list.\n");
         return 0;
      }
   }
   if (!sizeof(friends)) {
     if(person == "online") {
       add_failed_mess("You do not have any friends online.\n");
     } else {
       add_failed_mess("You do not have any friends.\n");
     }
     return 0;
   }
   ret = "";
   foreach (person in sort_array(friends, 0)) {
      ret += "$I$5=" + capitalize(person) + ": " +
             this_player()->query_friend_tag(person) + "%^RESET%^\n";
   }
   write("$P$Friends$P$" + ret);
   return 1;
}
int cmd_add(string person, string tag) {
   person = lower_case(person);
   person = this_player()->expand_nickname(person);
   if(person == this_player()->query_name()) {
     add_failed_mess("Are you really that lonely?\n");
     return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess(person + " does not exist.\n");
      return 0;
   }
   if (strlen(tag) > PLAYER_MAX_FRIEND_TAG_LEN) {
      add_failed_mess("Your tag for " + person + " is too long, the "
                      "maximum is " + PLAYER_MAX_FRIEND_TAG_LEN + ".\n");
      return 0;
   }
   if (!this_player()->is_friend(person)) {
      this_player()->add_friend(person, tag);
      add_succeeded_mess(({ "You add " + person + " with a tag of: " +
                            tag + "%^RESET%^.\n",
                            "" }));
   } else {
      this_player()->add_friend(person, tag);
      add_succeeded_mess(({ "You change " + person + "'s tag to: " +
                            tag + "%^RESET%^.\n",
                            "" }));
   }
   return 1;
}
int cmd_remove(string person) {
   person = lower_case(person);
   person = this_player()->expand_nickname(person);
   if (!this_player()->is_friend(person)) {
      add_failed_mess("Sorry, " + person + " is not your friend to remove.\n");
      return 0;
   }
   this_player()->remove_friend(person);
   add_succeeded_mess(({ "You remove " + person + " from your friends list.\n",
                         "" }));
   return 1;
}
int cmd_clear() {
   write("This will clear all of your friends.  Are you sure you want to do "
         "this? ");
   input_to("clear_check");
   add_succeeded_mess("");
   return 1;
}
void clear_check(string str) {
   string friend;
   if (!strlen(str) || str[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   foreach (friend in this_player()->query_friends()) {
      this_player()->remove_friend(friend);
   }
   write("Friend list cleared.\n");
}
mixed *query_patterns() {
   return ({ "<word'friend'>",
                (: cmd_display($4[0], 0) :),
             "",
                (: cmd_display("", 0) :),
             "list <string>",
                (: cmd_display("", $4[0]) :),
             "online",
                (: cmd_display("online", 0) :),
             "add <word'friend'>",
                (: cmd_add($4[0], "needs no introduction") :),
             "add <word'friend'> <string'tag'>",
                (: cmd_add($4[0], $4[1]) :),
             "remove <word'friend'>",
                (: cmd_remove($4[0]) :),
             "clear",
                (: cmd_clear() :),
             });
}

==================================================
FILE: player/gather.c
==================================================

#include <move_failures.h>
inherit "/cmds/base";
#define TP this_player()
int cmd( string str ) {
  object *items, *moved = ({ }), *left = ({ });
  int i;
  if( !stringp(str) || (str == "" )) {
    add_failed_mess("Syntax: gather <plant>\n");
    return 0;
  }
  items = "/obj/handlers/gathering"->gather_item(str, TP);
  if (!sizeof(items)) {
    if (str[<1] != 's') {
       str = pluralize(str);
    }
    add_failed_mess( "You couldn't find any " + str + ".\n");
    return 0;
  }
  for (i = 0; i < sizeof(items); i++) {
    if (items[i]->move(TP) == MOVE_OK) {
    moved += ({ items[i] });
  }  else
    if(items[i]->move(environment(TP)) == MOVE_OK) {
      left += ({ items[i] });
    } else {
      items[i]->move("/room/rubbish");
    }
  }
  if (sizeof(moved)) {
#ifdef NO_DECAY
    moved->set_decay_speed(0);
#endif
    add_succeeded_mess( "$N gather$s $I.\n", moved );
    event( environment( this_player() ), "gather", this_player(), str,
        moved );
  }
  left -= ({ this_player() });
  if (sizeof(left))
    write("You found but couldn't get " + query_multiple_short(left) + ".\n");
  return 1;
}
mixed query_patterns() {
  return ({ "<string>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/gchat.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "cmds/speech";
#define TEAM_HANDLER "/obj/handlers/team"
#define TP this_player()
mixed cmd(string arg) {
  string word, cur_lang, group;
  object ob, *members, *earmuffed;
  return notify_fail( "This command is no longer used.  Please "
   "use \"group say\" instead.\n" );
  if( TP->check_earmuffs( "gchat" ) )
     return notify_fail( "You have gchat ear muffed.\n" );
  group = TEAM_HANDLER->query_group(this_player());
  if(!group)
    return notify_fail("You are not a member of any group.\n");
  if(!arg)
    return notify_fail("Syntax: gchat <message>\n");
  cur_lang = TP->query_current_language();
  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");
  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken at a "
                       "distance.\n");
  word = query_word_type(arg, "");
  if (word != "")
    word = word + "ing";
  if (TP->query_volume(D_ALCOHOL))
    arg = drunk_speech(arg);
  if(function_exists("mangle_tell", environment(TP)))
    arg = environment(TP)->mangle_tell(arg, ob, 0);
  members = TEAM_HANDLER->query_members(group);
  members -= ({ this_player() });
  if ( !members ) {
    TEAM_HANDLER->leave_group( group, this_player() );
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no members.  "
        "Your group has been ended.  "
        "I hope this is okay.\n" );
    return 1;
  }
  earmuffed = ({ });
  foreach( ob in members ) {
    if( ob->check_earmuffs( "gchat" ) ) {
      earmuffed += ({ ob });
      members -= ({ ob });
    }
  }
  if( sizeof( earmuffed ) ) {
    write( capitalize( query_multiple_short( earmuffed ) ) +
        ( sizeof( earmuffed ) > 1 ? " have":" has" )+
        " gchat ear muffed.\n");
  }
  if( !sizeof( members ) ) {
    return notify_fail( "It seems you are the only one listening to "
          "this channel.\n" );
  } else if(word != "asking") {
    if( word != "" )
      word = " "+ word;
    foreach(ob in members) {
      if ( ob && interactive( ob ) )
        ob->event_person_tell(TP, capitalize((string)TP->query_name())+
                              " tells "+ group + word +": ", arg,
                              cur_lang );
    }
    if(cur_lang != "common")
      word += " in "+cur_lang;
    my_mess("You tell "+ group + word +": ", arg);
    TP->add_tell_history( "You tell "+ group + word + ": ", arg );
  } else {
    foreach(ob in members) {
      if ( ob && interactive( ob ) )
        ob->event_person_tell(TP, capitalize((string)TP->query_name())+
                              " asks "+group+": ", arg, cur_lang );
    }
    if(cur_lang != "common")
      word = " in "+ cur_lang;
    else word = "";
    my_mess( "You ask "+ group + word +": ", arg);
    TP->add_tell_history( "You ask "+ group + word + ": ", arg );
  }
  TP->adjust_time_left(-5);
  return 1;
}

==================================================
FILE: player/godmother.c
==================================================

#include <panic.h>
#include <move_failures.h>
inherit "/cmds/base";
void create() {
  seteuid(getuid());
}
int cmd( ) {
  mixed why_not;
  string destination;
  int ret;
  string str;
  if (!environment(this_player())) {
      destination = this_player()->query_last_pos();
      str = catch(ret = this_player()->move_with_look(destination,
                             "$N appears out of nowhere.",
                             "$N disappears with a pop."));
      if (str || ret != MOVE_OK) {
         destination = this_player()->query_start_pos();
         str = catch(ret = this_player()->move_with_look(destination,
                                "$N appears out of nowhere.",
                                "$N disappears with a pop."));
      }
      if (str || ret != MOVE_OK) {
         destination = this_player()->query_nationality()->query_default_start_location();
         str = catch(ret = this_player()->move_with_look(destination,
                                "$N appears out of nowhere.",
                                "$N disappears with a pop."));
      }
      if (str || ret != MOVE_OK) {
         add_failed_mess("Unable to move you out of limbo.  Try again "
                         "soon.\n");
         return 0;
      }
     add_succeeded_mess("You escape from limbo.\n");
     return 1;
  }
  if (environment() ||
      (why_not = environment(this_player())->query_property("no godmother"))) {
          if ( why_not && stringp( why_not ) ) {
              add_failed_mess( why_not );
          } else {
              add_failed_mess("You cannot summon the godmother here.\n");
          }
          return 0;
   }
   why_not = this_player()->query_property( "no godmother" );
   if( why_not )
   {
      if( stringp( why_not ) && sizeof( why_not ) ) {
         add_failed_mess( why_not );
      } else {
         add_failed_mess( "You cannot summon a godmother at this moment.\n" );
      }
      return 0;
   }
   if (PANIC_HANDLER->do_startup(previous_object())) {
      this_player()->add_succeeded_mess(this_object(),
                      ({ "",
                         "$N stares into space and looks pensive.\n" }),
                      ({ }) );
   } else {
      return 0;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "help", (: cmd() :) });
}

==================================================
FILE: player/group.c
==================================================

#include <group_handler.h>
#include <function.h>
#include <player.h>
#undef IN_TESTING
#undef IN_STRICT_TESTING
mixed *_patterns;
mapping _sub_commands;
class sub_command {
   string file_name;
   mixed *data;
}
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
int allowed_to_use( object user );
#endif
void rehash_group_sub_commands();
void make_patterns_array();
mixed *query_patterns();
int group_command_control( string verb, mixed *indirect_obs,
   string dir_match, string indir_match, mixed *args, string pattern );
int do_help( string on_what );
void create() {
   rehash_group_sub_commands();
   make_patterns_array();
}
void rehash_group_sub_commands() {
   mixed *files;
   object cmd_object;
   string dir, verb, file, pattern;
   _sub_commands = ([ ]);
   dir = GROUP_SUB_CMDS_DIR;
   dir += GROUP_SUB_CMDS_FILE_WILDCARD;
   files = get_dir( dir );
   if( !sizeof( files ) ) {
      return;
   }
   foreach( file in files ) {
      sscanf( file, "%s.%*s", file );
      cmd_object = load_object( ( GROUP_SUB_CMDS_DIR + file ) );
      if( !cmd_object ) {
         continue;
      }
      if( !cmd_object->query_group_sub_command_amount() ) {
         continue;
      }
      foreach( verb in cmd_object->query_group_sub_command_verbs() ) {
         if( !_sub_commands[ verb ] ) {
            _sub_commands += ([ verb : new( class sub_command ) ]);
         }
         _sub_commands[ verb ]->data = ( mixed * )({ });
         _sub_commands[ verb ]->file_name = ( string )file_name( cmd_object );
         foreach( pattern in
            cmd_object->query_group_sub_command_patterns( verb ) ) {
            _sub_commands[ verb ]->data +=
               ({
               pattern,
               cmd_object->query_group_sub_command_function( verb, pattern )
               });
         }
      }
   }
}
int group_command_control( string verb, mixed *indirect_obs,
   string dir_match, string indir_match, mixed *args, string pattern ) {
   int count, size;
   string cmd_pattern, mangled_pattern, group;
   function cmd_fun;
   object cmd_object;
   class sub_command info;
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   if( !allowed_to_use( this_player() ) ) {
      return 0;
   }
#endif
   info = _sub_commands[ verb ];
   if( !info ) {
      printf( "ERROR: Command information for \"" + verb + "\""
         " not found.\n" );
      return 0;
   }
   if( pattern != verb ) {
      sscanf( pattern, verb + " %s", mangled_pattern );
   }
   else {
      mangled_pattern = "";
   }
   size = sizeof( info->data );
   for( count = 0; count < size; count += 2 ) {
      if( mangled_pattern == info->data[ count ] ) {
         cmd_pattern = info->data[ count ];
         cmd_fun     = info->data[ count + 1 ];
         break;
      }
   }
   if( !cmd_pattern || !cmd_fun ) {
      printf( "ERROR: Correct version of \"" + verb + "\" not found.\n" );
      tell_creator( this_player(), "DEBUG: Verb: %s, pattern: %s\n",
         verb, pattern );
      return 0;
   }
   if( !cmd_object = load_object( info->file_name ) ) {
      printf( "ERROR: Cannot load command \"" + verb + "\"!\n" );
      tell_creator( this_player(), "DEBUG: File name: %s\n", info->file_name );
      return 0;
   }
   if( functionp( cmd_fun ) & FP_OWNER_DESTED ) {
      info->data[ count + 1 ] = cmd_fun =
         cmd_object->query_group_sub_command_function( verb, cmd_pattern );
   }
   if( !cmd_fun || !functionp( cmd_fun ) ) {
      printf( "ERROR: Could not find command function for verb " +
         "\"" + verb + "\".\n" );
      return 0;
   }
   group = this_player()->query_group();
   if( cmd_object->query_membership_required( verb, cmd_pattern ) > 0 ) {
      if( !group ) {
         return notify_fail( "You must be a member of a group in order "
            "to use this command.\n" );
      }
   }
   if( cmd_object->query_leadership_required( verb, cmd_pattern ) > 0 ) {
      if( GROUP->leader_of( group ) != this_player() ) {
         return notify_fail( "Only the leader of a group can use this "
            "command.\n" );
      }
   }
   return evaluate( cmd_fun, indirect_obs, dir_match, indir_match,
      args, pattern, group );
}
int do_help( string on_what ) {
   int top_left;
   string help, message;
   object command;
   on_what = lower_case( on_what );
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   if( !allowed_to_use( this_player() ) ) {
      return 0;
   }
#endif
   if( on_what == "help" ) {
      return notify_fail( "To get help on a command, use \"group help <sub-"
         "command>\".  That is, if you wanted to get help on the command "
         "\"group create <name>\", you would type \"group help create\".\n" );
   }
   if( !_sub_commands[ on_what ] ) {
      return notify_fail( "There is no sub-command called \"" + on_what +
         "\".\n" );
   }
   command = load_object( _sub_commands[ on_what ]->file_name );
   if( !command ) {
      tell_creator( this_player(), "Alleged file name: %s\n",
         _sub_commands[ on_what ]->file_name );
      return notify_fail( "ERROR: Cannot find or load sub-command "
         "\"" + on_what + "\".\n" );
   }
   help = command->query_help_string_for( on_what );
   if( !help ) {
      return notify_fail( "No help found for sub-command \"" + on_what +
         "\".\n" );
   }
   top_left = this_player()->query_cols();
   message = sprintf(
      "\n%' '|*s\n"
      "%' '-=*s\n",
      top_left, "Help on sub-command \"" + on_what + "\":\n",
      top_left, help );
   this_player()->more_string( message );
   return 1;
}
void make_patterns_array() {
   int count, size;
   string verb, pattern;
   class sub_command command;
   _patterns = ({ });
   _patterns += ({
      "help <word'sub-command'>", (: do_help( $4[ 0 ] ) :) });
   foreach( verb, command in _sub_commands ) {
      size = sizeof( command->data );
      for( count = 0; count < size; count += 2 ) {
         if( sizeof( command->data[ count ] ) ) {
            pattern = verb + " " + command->data[ count  ];
         }
         else {
            pattern = verb;
         }
         _patterns += ({
            pattern, (: group_command_control( $( verb ), $1, $2, $3, $4,
               $5 ) :) });
      }
   }
}
mixed *query_patterns() {
   return _patterns;
}
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
int allowed_to_use( object user ) {
#endif
#ifdef IN_STICT_TESTING
   if( !user->query_creator() ) {
      tell_object( user, "You are not allowed to use this feature at this "
         "time.\n" );
      return 0;
   }
#endif
#ifdef IN_TESTING
   if( !PLAYTESTER_HAND->query_tester( user ) ) {
      tell_object( user, "You are not allowed to use this feature at this "
         "time.\n" );
      return 0;
   }
#endif
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   return 1;
}
#endif
mapping dump_info() { return _sub_commands; }
mixed *dump_patterns() { return _patterns; }

==================================================
FILE: player/groups.c
==================================================

#include <group_handler.h>
inherit "/cmds/base";
mixed cmd(string str, string pattern) {
   return GROUP_CMD->group_command_control( "list", "", "", "",
                                            ({ str }), pattern );
}
mixed *query_patterns() {
   return ({ "", (: cmd("", "list") :),
             "[with] <string'player'>",
             (: cmd($4[0], "list [with] <string'player'>") :) });
}

==================================================
FILE: player/gstat_us.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
mixed cmd(string str) {
  string group;
  string locked;
  object member;
  return notify_fail( "This command is no longer used.  Please use the "
   "\"group\" command from now on.  Also have a read of \"help "
   "grouping\".\n" );
  group = TEAM_HANDLER->query_group(this_player());
  if(!group || !TEAM_HANDLER->query_members(group))
    return notify_fail("You are not a member of any group.\n");
  if(TEAM_HANDLER->query_locked(group))
    locked = "(locked) ";
  else
    locked = "";
  printf("Members of %s%s:\n", locked, group);
  printf("%-12s %|20s   Idle\n", "Name", "Health");
  foreach(member in TEAM_HANDLER->query_members(group)) {
    if(member && interactive(member))
      printf("%-12s %-20s %3d:%02d\n", member->short(),
       member->health_string(), (query_idle(member)/60),
       (query_idle(member)%60));
    else if(member)
      printf("%s\n", member->short());
  }
  return 1;
}

==================================================
FILE: player/haunt.c
==================================================

#define HAUNT_EARMUFF "remote-soul"
inherit "/cmds/base";
string ooo() {
    return implode( allocate( 3 + random( 15 ),
        (: ({ "O", "o" })[ random( 2 ) ] :) ), "" );
}
int haunt_player( object *victims ) {
    victims = filter( victims, (: !sizeof( $1->query_ignoring( ({ this_player() }) ) ) :) );
    victims = filter( victims, (: !$1->check_earmuffs( HAUNT_EARMUFF,
        $(this_player()) ) :) );
    victims = filter( victims,
        (: interactive( $1 ) || ( $1->query_property( "npc" ) &&
        environment( $1 ) == environment( this_player() ) ) :) );
    if ( !this_player()->query_property("dead") ) {
        add_failed_mess( "You are nowhere near wispy enough to "
          "haunt people.  You could probably scare a table or "
          "chair, though.\n" );
        return -1;
    }
    if ( !sizeof( victims ) ) {
        return 0;
    }
    add_succeeded_mess( "$N wave$s $p arms about anxiously and say$s: \""
   + ooo() + "\" at $I.\n", victims );
    return 1;
}
int cmd() {
    if ( !this_player()->query_property("dead") ) {
        add_failed_mess( "You are nowhere near wispy enough to "
          "haunt people.  You could probably scare a table or "
          "chair, though.\n" );
        return -1;
    }
    add_succeeded_mess( "$N wave$s $p arms about anxiously and intone$s: \"" +
        ooo() + "\".\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd() :),
      "<indirect:any-living>", (: haunt_player($1) :)  });
}

==================================================
FILE: player/health.c
==================================================

inherit "cmds/base";
string *level_colors = ({ "", "%^BOLD%^%^RED%^", "%^RED%^", "%^YELLOW%^",
                          "%^CYAN%^", "" });
mixed cmd(object *who, int wounded) {
   object person;
   string health;
   int level;
   int found;
   if(this_player()->check_dark((int)environment(this_player())->
                                 query_light())) {
      add_failed_mess("You cannot see well enough to examine someone's "
                      "health.\n");
      return 0;
   }
   foreach(person in who) {
      health = person->health_string(1, ref level);
      if (this_player() == person) {
         health = replace(health, ({ "is ", "are ", "appears ", "appear " }));
      }
      if (health) {
         if (!wounded || level != 5) {
            write(level_colors[level] + "$C$" + person->one_short(1) + " " +
                  level_colors[level] + health + ".\n%^RESET%^");
            found++;
         }
      } else {
         write(person->one_short(1) + " is so unhealthy they have forgotten "
               "how healthy they are.\n");
      }
      if (person != this_player())
         tell_object(person, this_player()->the_short(1) + " appears to be "
                  "checking out all your wounds.\n");
   }
   if (wounded && !found) {
      add_failed_mess("Unable to find any wounded people.\n");
      return 0;
   }
   say(this_player()->one_short(1) + " studies " +
       query_multiple_short(who) + ".\n");
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1, 0) :),
            "wounded <indirect:living>", (: cmd($1, 1) :) });
}

==================================================
FILE: player/help.c
==================================================

inherit "/cmds/base";
#include <nroff.h>
#include <soul.h>
#include <log.h>
#include <autodoc.h>
#include <login_handler.h>
#include <player_handler.h>
#include <command.h>
#define SYNONYMS "/doc/SYNONYMS"
#define MATCH_THRESHOLD 55
void do_help(mixed *stuff);
private void list_help(string title, string dir);
private mixed *help_list(string name);
int command_cmd(string name);
int here_cmd();
int object_cmd(object ob);
int spell_cmd(string name, int spell);
int file_help(string name);
void rehash_dirs();
mixed *query_help_on(string name, int creator, int, int);
mixed *create_help_files(string *names, string nroff_dir);
private mapping read_directories(string *directories, int recurse);
private mapping read_synonyms();
private string letter_name(int letter, mixed *things);
private string start_letter( mixed *things );
private string end_letter( mixed *things );
private int query_number_from_string(string name, mixed *things );
private nosave mapping _help_files_player;
private nosave mapping _help_files_creator;
private nosave mapping _help_files_playtester;
private nosave mapping _help_files_lord;
private nosave mapping _synonyms;
private nosave string *_player_dirs;
private nosave string *_creator_dirs;
private nosave string *_lord_dirs;
private nosave string *_playtester_dirs;
void create() {
   ::create();
   _player_dirs = ({ "/doc/helpdir/",
                    "/doc/concepts/",
                    "/doc/known_command/",
                    "/doc/room/",
                    "/doc/spells/",
                    "/doc/object/" });
   _creator_dirs = ({"/doc/creator/",
                    "/doc/driver/",
                    "/doc/policy/",
                    "/doc/new/" });
   _playtester_dirs = ({ "/doc/playtesters/" });
   _lord_dirs = ({"/doc/lord/"});
   unguarded((: rehash_dirs() :));
}
int *find_match_in_array( string entry, string *items )  {
   int i;
   int j;
   int elength;
   int ilength;
   int this_match;
   int best_match;
   int best_try;
   elength = strlen( entry );
   best_match = this_match = -1;
   for ( i = sizeof( items ) - 1; i >= 0; i--, this_match = 0 )  {
      ilength = strlen( items[ i ] );
      for ( j = 0; j < elength  &&  j < ilength; j++ )
        if ( entry[ j ] == items[ i ][ j ] ||
             entry[ j ] == items[ i ][ j - 1 + ( j == 0 ) ]  ||
             entry[ j ] == items[ i ][ j + 1 - ( j + 1 == ilength ) ] )
          ++this_match;
      this_match = 100 * this_match / ( j == elength ? ilength : elength );
      if ( this_match > best_match )  {
        best_match = this_match;
        best_try = i;
      }
   }
   return ({ best_try, best_match });
}
int cmd(string name) {
  class command cmd;
   mixed *list;
   string str;
   string suggestion;
   int i;
   int *matches;
   list = help_list(name);
   if (sizeof(list) == 0 &&
       mapp(_synonyms) &&
       _synonyms[name]) {
      list = help_list(_synonyms[name]);
   }
   if (sizeof(list) == 0) {
      if (PLAYER_HANDLER->test_user(name)) {
         add_failed_mess("That is a player, silly.\n");
         return 0;
      }
      list = keys(_help_files_player) + ({ "command_list", "concepts"});
      matches = find_match_in_array(name, list);
      if (matches[1] > MATCH_THRESHOLD) {
         suggestion = list[matches[0]];
      } else {
         list = keys(_synonyms);
         matches = find_match_in_array(name, list);
         if(matches[1] > MATCH_THRESHOLD) {
            suggestion = _synonyms[list[matches[0]]];
         }
      }
      if (!this_player()->query_creator()) {
         log_file("MISSING_HELP", "%s %s looked for help on %s, "
                  "recommended %s\n",
                  ctime(time()), this_player()->query_name(),
                  name, suggestion);
      }
      str = "Could not find any help on '" + name + "'.  ";
      if (!suggestion && this_player()->query_known_command("newbie"))
        str += "Many useful commands are explained in 'help essentials'.  ";
      else if(suggestion)
        str += "Perhaps you are looking for 'help " +suggestion + "'?  ";
      cmd = new(class command, verb : name);
      if((CMD_D->IsGRCommand(name) &&
          this_player()->query_known_command(name)) ||
         (CMD_D->HandleStars(cmd) &&
          sizeof(((mixed *)CMD_D->GetPaths(cmd->verb) &
                  (mixed *)this_player()->GetSearchPath()))) ||
         sizeof(this_player()->query_parse_command_objects(name)))
        str += "The syntax for the command '" + name + "' can be found by "
          "entering 'syntax " + name + "'.  ";
      if (environment(this_player()) &&
          environment(this_player())->help_function())
         str += "Type 'help here' for help on how to use this room.";
      return notify_fail(str + "\n");
   }
   if (sizeof(list) == 1) {
      do_help(list[0]);
      return 1;
   }
   str = "";
   for (i = 0; i < sizeof(list); i++) {
      str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
   }
   printf("Discworld help found multiple matches, please choose one of:\n"
          "%-*#s\nChoice: ", this_player()->query_cols(), str);
   input_to("help_input", 0, list);
   return 1;
}
void help_input(string str, mixed *list) {
   int num;
   str = lower_case(str);
   if (str == "quit" || str == "**" || str == "." || str == "") {
      write("OK, exiting help.\n");
      return ;
   }
   if ( ( num = query_number_from_string( str, list ) ) == -1 ) {
       printf("Incorrect choice, must be between %s and %s.\nChoice: ",
        start_letter( list ), end_letter( list ) );
      input_to("help_input", 0, list);
      return ;
   }
   do_help(list[num]);
}
void do_help(mixed *stuff) {
   string str;
   str = evaluate(stuff[1]);
   if (!str || !strlen(str)) {
      write("Broken help file!\n");
   } else {
      write("$P$" + stuff[0] + "$P$" + str);
   }
}
int here_cmd() {
  mixed str;
  mixed *list;
  int i;
  str = environment(this_player())->help_function();
  if(pointerp(str))
    list = str;
  else if(str)
    list += ({ ({ environment(this_player())->short(), str }) });
  else {
    write("There is no help available for this room.\n");
    return 1;
  }
  if (sizeof(list) == 1) {
    do_help(list[0]);
    return 1;
  }
  str = "";
  for (i = 0; i < sizeof(list); i++) {
    str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
  }
  printf("Discworld help found multiple matches, please choose one of:\n"
         "%-*#s\nChoice: ", this_player()->query_cols(), str);
  input_to("help_input", 0, list);
  return 1;
}
int object_cmd(object ob) {
  mixed str;
  mixed *list;
  int i;
  str = ob->help_function();
  if(pointerp(str))
    list = str;
  else if(str)
    list += ({ ({ environment(this_player())->short(), str }) });
  else {
    add_failed_mess("There is no help available for $I.\n", ({ob}));
    return -1;
  }
  if (sizeof(list) == 1) {
    do_help(list[0]);
    return 1;
  }
  str = "";
  for (i = 0; i < sizeof(list); i++) {
    str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
  }
  printf("Discworld help found multiple matches, please choose one of:\n"
         "%-*#s\nChoice: ", this_player()->query_cols(), str);
  input_to("help_input", 0, list);
  return 1;
}
int command_cmd(string name) {
   mixed help;
   help = this_player()->help_command(name);
   if (!help) {
      notify_fail("No such command as '" + name + "'.\n");
      return 0;
   } else {
      if (functionp(help)) {
         help = evaluate(help);
      }
      write("$P$" + name + "$P$P" + help);
      return 1;
   }
}
int soul_cmd(string name) {
   string help;
   help = SOUL_OBJECT->help_string(name);
   if (!help) {
      notify_fail("No such soul as '" + name + "'.\n");
      return 0;
   } else {
      write("$P$" + name + "$P$P" + help);
      return 1;
   }
}
int spell_cmd(string name, int spell) {
   mixed help;
   help = this_player()->help_spell(name);
   if (!help) {
      notify_fail("No such spell as '" + name + "'.\n");
      return 0;
   } else {
      if (functionp(help)) {
         this_player()->move_string(evaluate(help), name);
      } else {
         write("$P$" + name + "$P$P" + help);
      }
      return 1;
   }
}
int command_list_cmd() {
   list_help("Command list, try 'help concepts' for a list of concepts.",
       "/doc/helpdir/");
   return 1;
}
int concepts_list_cmd() {
   list_help("Concepts list, try 'help command_list' for a list of commands.",
       "/doc/concepts/");
   return 1;
}
int error_log_cmd() {
   notify_fail("Unable to get help on '" + ERROR_LOG + "'.\n");
   return 0;
}
private void list_help(string title, string dir) {
   string *files;
   files = get_dir(dir + "*") - ({ ".", "..", "ERROR_REPORTS", "RCS", "old" });
   write("$P$Help$P$" + sprintf("%s\n%-#*s\n", title,
                                     (int)this_player()->query_cols(),
                                     implode(files, "\n")));
}
 mixed *help_list(string name) {
   string* stuff;
   mixed str;
   object* fluff;
   object blue;
   stuff = query_help_on(name, this_player()->query_creator(),
                         this_player()->query_lord(),
                         this_player()->query_playtester());
   if (name == "room" || name == "here") {
      str = environment(this_player())->help_function();
      if (pointerp(str)) {
         stuff += str;
      } else if (str) {
         stuff += ({ ({ environment(this_player())->short(),
                        str }) });
      } else {
         add_failed_mess("There is no help available for this room.\n");
         return 0;
      }
   }
   str = this_player()->help_spell(name);
   if (stringp(str)) {
      stuff += ({ ({ name + " (Spell)",
                    (: $(str) :) }) });
   }
   if (functionp(str)) {
      stuff += ({ ({ name + " (Spell)", str }) });
   }
   str = SOUL_OBJECT->help_string(name);
   if (str) {
      stuff += ({ ({ name + " (Soul)",
                    (: $(SOUL_OBJECT)->help_string($(name)) :) }) });
   }
   fluff = filter(match_objects_for_existence(name, ({ this_player(),
                                      environment(this_player()) })),
                    (: $1 && $1->help_function() :));
   if (sizeof(fluff)) {
      foreach (blue in fluff) {
         stuff += blue->help_function();
      }
   }
   return stuff;
}
private string letter_name(int letter, mixed *things) {
   string bing;
   if (sizeof(things) > 26) {
      bing = "aa";
      bing[0] = 'a' + (letter / 26);
      bing[1] = 'a' + (letter % 26);
      return bing;
   }
   bing = "a";
   bing[0] = 'a' + letter;
   return bing;
}
private string start_letter( mixed *things ) {
   return letter_name(0, things);
}
private string end_letter( mixed *things ) {
   return letter_name(sizeof(things) - 1, things);
}
private int query_number_from_string(string name, mixed *things ) {
   int pos;
   if (sizeof(things) > 26) {
      if (strlen(name) != 2) {
         return -1;
      }
      name = lower_case(name);
      if (name[0] < 'a' || name[0] > 'z') {
         return -1;
      }
      if (name[1] < 'a' || name[1] > 'z') {
         return -1;
      }
      pos = (name[0] - 'a') * 26 + name[1] - 'a';
      if (pos >= sizeof(things)) {
         return -1;
      }
      return pos;
   }
   if (strlen(name) != 1) {
      return -1;
   }
   name = lower_case(name);
   if (name[0] < 'a' || name[0] > 'z') {
      return -1;
   }
   pos = name[0] - 'a';
   if (pos >= sizeof(things)) {
      return -1;
   }
   return pos;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :),
               "here", (: here_cmd() :),
               "object <indirect:object:me-here'item'>", (: object_cmd($1[0]) :),
               "command <string>", (: command_cmd($4[0]) :),
               "spell <string>", (: spell_cmd($4[0], 0) :),
               "ritual <string>", (: spell_cmd($4[0], 1) :),
               "soul <string>", (: soul_cmd($4[0]) :),
               "command_list", (: command_list_cmd() :),
               "concepts", (: concepts_list_cmd() :),
               "", (: concepts_list_cmd() :) });
}
void rehash_dirs() {
   _help_files_player = read_directories(_player_dirs, 1);
   _help_files_creator = read_directories(_creator_dirs, 1);
   _help_files_lord = read_directories(_lord_dirs, 1);
   _help_files_playtester = read_directories(_playtester_dirs, 1);
   _synonyms = read_synonyms();
}
void rehash_specific_dir(string dir) {
   string start;
   mapping ret;
   string name;
   string* files;
   if (dir[<1] != '/') {
      dir += "/";
   }
   start = "/" + implode(explode(dir, "/")[0..1], "/") + "/";
   if (member_array(start, _player_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_player[name]) {
            _help_files_player[name] &= files;
         } else {
            _help_files_player[name] = files;
         }
      }
   }
   if (member_array(start, _creator_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_creator[name]) {
            _help_files_creator[name] &= files;
         } else {
            _help_files_creator[name] = files;
         }
      }
   }
   if (member_array(start, _lord_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_lord[name]) {
            _help_files_lord[name] &= files;
         } else {
            _help_files_lord[name] = files;
         }
      }
   }
   if (member_array(start, _playtester_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_playtester[name]) {
            _help_files_playtester[name] &= files;
         } else {
            _help_files_playtester[name] = files;
         }
      }
   }
}
private mapping read_synonyms() {
  string *bits, *bits2;
  int i;
  mapping tmp;
  tmp = ([ ]);
  bits = explode(read_file(SYNONYMS), "\n");
  for(i=0; i<sizeof(bits); i++) {
    bits2 = explode(bits[i], " ");
    tmp[bits2[0]] = bits2[1];
  }
  return tmp;
}
private mapping read_directories(string *directories, int recurse) {
   string *files;
   string fname;
   int i;
   string dir;
   mapping ret;
   ret = ([ ]);
   for (i = 0; i < sizeof(directories); i++) {
     dir = directories[i];
     files = get_dir(dir + "*") - ({ "ERROR_REPORTS" });
     foreach (fname in files) {
       if (file_size( dir + fname) == -2) {
         if (fname != "." &&
             fname != ".." &&
             fname != "old" &&
             fname != "RCS") {
           directories += ({ dir + fname + "/" });
         }
       } else if (fname != "." &&
                  fname != ".." &&
                  fname != "old") {
         if (!ret[fname]) {
           ret[fname] = ({ dir + fname });
         } else {
           ret[fname] += ({ dir + fname });
         }
         if (strsrch(fname, "_") > 0) {
           fname = replace(fname, "_", " ");
           if (!ret[fname]) {
             ret[fname] = ({ dir + fname });
           } else {
             ret[fname] += ({ dir + fname });
           }
         }
       }
     }
   }
   return ret;
}
mixed *query_help_on(string name, int creator, int lord, int pt) {
   string *files;
   mapping map;
   files = ({ });
   name = replace_string(name, " ", "_");
   if (_help_files_player[name]) {
      files += create_help_files(_help_files_player[name], NROFF_DIR);
   }
   if (lord || creator || pt) {
     if(_help_files_playtester && _help_files_playtester[name]) {
         files += create_help_files(_help_files_playtester[name], NROFF_DIR);
      }
   }
   if (lord || creator) {
     if(_help_files_creator && _help_files_creator[name]) {
         files += create_help_files(_help_files_creator[name], NROFF_DIR);
      }
      map = AUTODOC_HANDLER->query_help_map();
      if (map && map[name]) {
         files += create_help_files(map[name], NROFF_DIR);
      }
   }
   if (lord) {
     if(_help_files_lord && _help_files_lord[name]) {
         files += create_help_files(_help_files_lord[name], NROFF_DIR);
      }
      map = AUTODOC_HANDLER->query_help_map();
      if (map && map[name]) {
         files += create_help_files(map[name], NROFF_DIR);
      }
  }
   return files;
}
string query_synonym(string name) {
  if(mapp(_synonyms) && _synonyms[name])
    return _synonyms[name];
  return "";
}
private string nroff_file(string name, string nroff_dir) {
   string nroff_fn;
   string str;
   nroff_fn = nroff_dir + replace(name, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   return str;
}
mixed *create_help_files(string *names, string nroff_dir) {
   int i;
   mixed *ret;
   string *bits;
   ret = ({ });
   for (i = 0; i < sizeof(names); i++) {
      bits = explode(names[i], "/");
      ret += ({ ({ bits[<1] + " (" +
                   names[i] + ")",
                   (: nroff_file($(names[i]), $(nroff_dir)) :) }) });
   }
   return ret;
}
mapping query_help_files_player() { return _help_files_player; }
mapping query_help_files_creator() { return _help_files_creator; }
mixed *stats() {
  mapping map;
  map = AUTODOC_HANDLER->query_help_map();
  return ({
      ({ "player help files", sizeof( keys(_help_files_player) ) }),
      ({ "creator help files", sizeof( keys(_help_files_creator) ) }),
        ({ "autodoc help map", sizeof(keys(map)) }) ,
          });
}
int clean_up() {
  return 0;
}
void dest_me() {
}

==================================================
FILE: player/helper_s.c
==================================================

#include <player_handler.h>
inherit "/cmds/base";
int cmd() {
    object *helpers;
    string mess;
    helpers = filter( users(), (: !$1->query_creator() &&
        $1->query_property( "newbie helper" ) &&
        !$1->query_login_ob() :) );
    switch( sizeof( helpers ) ) {
        case 0:
            add_failed_mess("There are no newbie helpers logged on at the "
                "moment.\n");
            return 0;
        case 1:
            if ( helpers[ 0 ] == this_player() ) {
                mess = "You are the only newbie helper logged on at the "
                    "moment.\n";
            }
            else {
                mess = helpers[ 0 ]->query_short() + " is the only newbie "
                    "helper logged on at the moment.\n";
            }
        break;
        default:
            mess = query_multiple_short( helpers->query_short() ) + " are "
                "newbie helpers.\n";
    }
    this_player()->add_succeeded_mess(this_object(), ({mess, ""}),
      ({ }));
    return 1;
}
int test_helper( string player_name ) {
    player_name = lower_case( player_name );
    if ( PLAYER_HANDLER->test_property( player_name, "newbie helper" ) ) {
        this_player()->add_succeeded_mess(this_object(), ({
          capitalize( player_name ) + " is a newbie helper.\n",
          ""}), ({ }));
        return 1;
    }
    add_failed_mess(capitalize( player_name ) +
        " is not a newbie helper.\n" );
    return 0;
}
mixed *query_patterns() {
    return ({ "", (: cmd :),
              "<string'name'>", (: test_helper( $4[ 0 ] ) :) });
}

==================================================
FILE: player/hi_story.c
==================================================

int cmd(string arg){
   return this_player()->print_history(arg);
}
mixed query_patterns() {
   return ({ "", (: cmd("") :),
               "<string'number|number,number'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/hnew_bie.c
==================================================

#include <player.h>
inherit "/cmds/guild_base";
#define HIST "/obj/handlers/hist_handler"
int cmd() {
  mixed *history;
  string result;
  history = HIST->query_chat_history("newbie");
  if ( !arrayp( history ) || !sizeof( history ) ) {
    tell_object(this_player(), "Nothing has been said on the newbie "
                "channel.\n");
  }
  else {
    result = "$P$Newbie Channel$P$";
    result += implode(map(history, (: "$I$5=*" + ctime($1[2])[11..18] +
                                      "* $C$" + $1[0] + $1[1] +
                                    "%^RESET%^" :)), "\n");
    tell_object(this_player(), result);
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd() :) });
}

==================================================
FILE: player/ht_ell.c
==================================================

int cmd(string arg, int brief){
  function bing;
  bing = this_player()->get_htell_func();
  arg = this_player()->expand_nickname(arg);
  return evaluate(bing, arg, brief);
}
mixed *query_patterns()  {
    return ({ "brief search <string'name'>", (: cmd(lower_case($4[0]), 1) :),
              "search <string'name'>", (: cmd(lower_case($4[0]),
                                     !this_player()->query_verbose("htell")) :),
              "brief", (: cmd("", 1) :),
              "verbose", (: cmd("", 0) :),
              "", (: cmd("", !this_player()->query_verbose("htell")) :)
           });
}

==================================================
FILE: player/i.c
==================================================

inherit "/cmds/player/inv_entory";

==================================================
FILE: player/idea.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("IDEA");
   set_use_last_error(0);
}

==================================================
FILE: player/identify.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
mixed cmd(object *indirect_obs, string new_name)
{
   string  word;
   object  thing;
   object *things;
   int *ees;
   int keep;
   if (!new_name)  {
      things = filter(indirect_obs, (: $1->query_identifier() :));
      if (!sizeof(things))  {
         if (sizeof(indirect_obs) > 1) {
            write("You do not have any of those objects identified.\n");
         } else {
            write("You do not have " + indirect_obs[0]->the_short() +
                  " identified.\n");
         }
      } else foreach (thing in things)  {
         write("You have " + thing->the_short() + " identified as \"" +
               thing->query_full_identifier() + "\".\n");
      }
   } else if (sizeof(indirect_obs) == 1)  {
      word = lower_case(new_name);
      if (word == "none") {
         ees = indirect_obs[0]->effects_matching(EFFECT->query_classification());
         if (!sizeof(ees)) {
            add_failed_mess("No identities to remove.");
            return 0;
         }
         keep = indirect_obs[0]->query_keep();
         indirect_obs[0]->delete_effect(ees[0]);
         if (keep) {
            thing->add_effect( EFFECT, ([ "keep" : 1 ]) );
         }
         write("You remove the description from " +
               indirect_obs[0]->the_short() + ".\n");
      } else {
         indirect_obs[0]->add_effect(EFFECT, ([ "identity" : word ]));
         write(indirect_obs[0]->the_short() + " may now be identified as \"" +
               word + "\".\n");
      }
   } else {
      write("You may only identify one thing at a time.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me'object'> as <string'some new name'>",
             (: cmd($1, $4[1]) :),
             "<indirect:object:me'object(s)'>",
             (: cmd($1, 0) :) });
}

==================================================
FILE: player/idle.c
==================================================

inherit "/cmds/base";
int cmd(object who) {
  if (!interactive(who))
    write(who->query_cap_name() + " is net-dead.\n");
  else
    write(who->query_cap_name() + " has been idle for " +
          "/secure/finger"->time_elapsed_string(query_idle(who)) + ".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}

==================================================
FILE: player/ignore.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#define TP this_player()
inherit "/cmds/base";
int cmd_list() {
   string *ignoring;
   ignoring = TP->query_property("ignoring");
   if(!ignoring) {
      ignoring = ({ });
   }
   if ( !sizeof(ignoring) )  {
      write( "You are not ignoring anyone.\n" );
   } else  {
      ignoring = sort_array(ignoring, 1);
      write( "You are currently ignoring " +
              query_multiple_short( map(ignoring, (: capitalize($1) :)),
                                    0, 0, 1, 0 ) + ".\n" );
   }
   return 1;
}
int cmd( string str) {
   string *ignoring;
   ignoring = TP->query_property("ignoring");
   if(!ignoring) {
      ignoring = ({ });
   }
   str = lower_case( TP->expand_nickname(str) );
   if ( !(PLAYER_HANDLER->test_user(str))  &&  !find_player(str)) {
      if (find_living(str)) {
         add_failed_mess("You cannot ignore an npc.\n");
         return 0;
      } else {
         add_failed_mess( "Ignoring someone that doesn't exist?  Is this some "
                           "kind of zen?\n" );
         return 0;
      }
   }
   if (TP->query_name() == str) {
      add_failed_mess("Ignoring yourself.  Novel.\n");
      return 0;
   }
   if ( member_array( str, ignoring ) == -1 )  {
      ignoring += ({ str });
      TP->add_property("ignoring", ignoring, 604800);
   } else  {
      write( "You are already ignoring " + capitalize(str) + ".\n" );
   }
   write("You are now ignoring "+capitalize(str)+".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person'>", (: cmd($4[0]) :),
             "", (: cmd_list() :) });
}

==================================================
FILE: player/inv_entory.c
==================================================

inherit "/cmds/base";
mixed cmd()
{
   if (this_player()->query_property("dead")) {
      object *obs;
      write("You are just a disembodied spirit.  "
            "You have mist; what else do you want?\n");
      obs = all_inventory(this_player());
      obs = filter_array(obs, (: $1->query_property("dead usable") :));
      if (sizeof(obs)) {
         write("Hang on!  You appear to have " +
               query_multiple_short(obs) + ".  Amazing.\n");
      }
      return 1;
   }
   write(sprintf("You are %s by:\n", this_player()->burden_string()) +
	 this_player()->query_living_contents(1));
   if (this_player()->query_auto_loading()) {
      write("\n%^YELLOW%^Please note that your inventory is still being "
            "generated.%^RESET%^\n");
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/joing_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
mixed cmd(string str) {
  object owner, person;
  int policy;
  if(!str)
    return notify_fail("Syntax: joingroup <group name>\n");
  if(TEAM_HANDLER->query_group(this_player()))
    return notify_fail("You are already a member of a group.\n");
  if(!TEAM_HANDLER->test_group(str))
    return notify_fail("Sorry, there is no group by that name.\n");
  owner = TEAM_HANDLER->query_owner(str);
  if(!owner || environment(owner) != environment(this_player()))
    return notify_fail("Sorry, the owner of "+str+" is not here.\n");
  if(TEAM_HANDLER->query_full(str))
    return notify_fail("Sorry, that group is full, you cannot join.\n");
  if(TEAM_HANDLER->query_locked(str))
    return notify_fail("Sorry, that group is locked, you cannot join.\n");
  policy = TEAM_HANDLER->query_policy(str);
  if(!TEAM_HANDLER->join_group(str, this_player()))
    return notify_fail("Ack, something went wrong.\n");
  foreach(person in TEAM_HANDLER->query_members(str)) {
    if(person && present(person, environment(this_player())) &&
       person != this_player()) {
      this_player()->add_protector(person);
      person->add_protector(this_player());
      if(policy == 1)
  this_player()->add_follower(person);
      if((policy == 1) || (person == owner))
  person->add_follower(this_player());
    }
  }
  write("You join "+str+" and will now protect and be protected by "
  "them.\n");
  say(this_player()->short()+" joins "+str+" and will protect and be "
      "protected by its members.\n");
  write("You are now a member of "+str+"\n");
  return 1;
}

==================================================
FILE: player/keep.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
int cmd( object *obs )  {
   object thing;
   foreach(thing in obs) {
      thing->add_effect( EFFECT, ([ "keep" : 1 ]) );
   }
   write( "You will now attempt to keep "+
         (string)query_multiple_short(obs)+".\n" );
   return 1;
}
int cmd_list() {
   object* obs;
   obs = all_inventory(this_player());
   obs = filter(obs, (: $1->query_keep() :) );
   if (!sizeof(obs)) {
      add_failed_mess("You are not keeping anything.\n");
      return 0;
   }
   write("You are keeping " + query_multiple_short(obs) + ".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :),
             "", (: cmd_list :) });
}

==================================================
FILE: player/killers.c
==================================================

#include <player_handler.h>
#include <clubs.h>
inherit "/cmds/base";
string second_name( string str );
mixed cmd( string mode ) {
   object *killers;
   object player = this_player();
   string *names, *tmp, name;
   int i, brief, number, guild;
   mixed *unique_names;
   if ( mode == "verbose" ) brief = 0;
   else brief = 1;
   killers = filter_array( users(),
                         (: !($1->query_creator())  &&
                            !($1->query_login_ob())  &&
                            !($1->query_property("test character")) &&
                            $1->query_player_killer() :) );
   if (mode) mode = lower_case(mode);
   if (mode &&
       mode != "verbose" &&
       mode != "brief") {
      guild = 1;
      mode = replace(mode, ({  "assassins",   "assassin",
                               "priests",     "priest",
                               "thieves",     "thief",
                               "warriors",    "warrior",
                               "witches",     "witch",
                               "wizards",     "wizard",
                               "adventurers", "adventurer",
                               "fighters",    "warrior",
                               "fighter",     "warrior",
                               "monks",       "monk",
                              }));
      killers = filter_array( killers,
                      (: $1->query_guild_ob() == "/std/guilds/" + $(mode) :) );
   }
   if (brief) {
      names = killers->query_cap_name();
   } else {
      names = killers->short();
   }
   for (i = 0; i < sizeof(killers); i++) {
      if (names[i] && this_player()->is_friend(killers[i]->query_name())) {
         names[i] += "(%^GREEN%^F%^RESET%^)";
      }
   }
   names -= ({ 0 });
   if (!sizeof(names)) {
      write("There are no " + (guild?mode + " ":"") + "player killers logged"
            " in.\n");
   } else {
      if(sizeof(names) == 1)  {
         if ( names[0] == (brief? player->query_cap_name(): player->short()) ) {
            write( "You are the only player killer on " + mud_name() + ".\n" );
         } else {
            write("The only " + (guild?mode:"") + " player killer currently "
                  "logged in is "+ names[0]+".\n");
         }
      } else {
         i = 0;
         if ( member_array(
              (brief? player->query_cap_name(): player->short()),
              names ) > -1 )  {
            names -= ({ (brief? player->query_cap_name(): player->short()) });
            i = 1;
         }
         names = sort_array( names,
                             (: strcmp( lower_case( $1 ),
                                        lower_case( $2 ) ) :) );
         if ( i ) {
             name = this_player()->query_cap_name();
             if (this_player()->query_family_name() &&
                 !brief) {
                name += " " + this_player()->query_family_name();
             }
             names += ({ name });
         }
         if (!brief) {
           unique_names = unique_array( names, (: second_name($1) :) );
           names = ({ });
           foreach ( tmp in unique_names ) {
                names += tmp;
           }
         }
         number = sizeof(names);
         write("There are " + sizeof(names) + (guild?" " + mode:"") +
               " player killers logged in:\n" +
               query_multiple_short(names) + "\n");
      }
   }
   return 1;
}
int cmd_here() {
   string *killers;
   killers = filter_array( all_inventory(environment(this_player())),
                         (: !($1->query_creator())  &&
                            !($1->query_property("test character")) &&
                            $1->query_player_killer() &&
                            $1->query_visible( this_player() ) &&
                            $1 != this_player() :) );
   if (!sizeof(killers)) {
      add_failed_mess("There are no killers here.\n");
      return 0;
   }
   if (sizeof(killers) > 1) {
      write("The killers here are " +
            query_multiple_short(killers) + ".\n");
   } else {
      write("The killer here is " +
            query_multiple_short(killers) + ".\n");
   }
   return 1;
}
string second_name( string str ) {
  int pos;
  pos = strsrch( str, " " );
  if (pos == -1) {
     return "";
  }
  return str[pos+1..];
}
int cmd_club( string club ) {
    int number;
    string *names;
    if( CLUB_HANDLER->query_club_secret( club ) &&
        !CLUB_HANDLER->is_member_of( club, this_player()->query_name() ) ) {
        add_failed_mess( "That is a secret club! Killers information about "
            "secret clubs is only shown to club members.\n" );
        return -1;
    }
    names = map( filter( CLUB_HANDLER->query_members( club ),
       (: find_player( $1 ) && !PLAYER_HANDLER->test_creator( $1 ) &&
        pk_check( $1, this_player(), 1 ) != 1 :) ),
        (: capitalize( $1 ) :) );
    if ( number = sizeof( names ) ) {
        if ( number > 1 ) {
            write("There are " + number + " player killers logged on "
                "who are members of " + capitalize( club ) + ":\n" +
                sprintf("%-#*s", this_player()->query_cols(), implode( names,
                "\n" ) ) + "\n");
        }
        else {
            write("There is " + number + " player killer logged on "
                "who is a member of " + capitalize( club ) + ":\n" +
                sprintf("%-#*s", this_player()->query_cols(), implode( names,
                "\n" ) ) + "\n");
        }
    }
    else {
        add_failed_mess( "There are no player killers in that club.\n" );
        return -1;
    }
     return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
            "{verbose|brief}", (: cmd( $4[0] ) :),
            "here", (: cmd_here() :),
            "club <string'club name'>", (: cmd_club( $4[0] ) :),
            "guild <string'guild name'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/lang_uages.c
==================================================

#include <move_failures.h>
#include <language.h>
inherit "cmds/base";
#define TP this_player()
mixed cmd(object *obs, string indir, string str) {
   int i;
   string *langs;
   langs = LANGUAGE_HAND->query_languages();
   for (i = 0; i < sizeof(langs); i++) {
      if (TP->query_skill(
               LANGUAGE_HAND->query_language_spoken_skill(langs[i])) > 1 ||
          TP->query_skill(
               LANGUAGE_HAND->query_language_written_skill(langs[i])) > 1) {
      } else {
         langs = langs[0..i-1] + langs[i+1..];
         i--;
      }
   }
   write("You can currently speak " +( TP->query_womens_day()?"wommon":
                 implode(langs, ", ") ) +" and grunt.\n");
   return 1;
}

==================================================
FILE: player/last.c
==================================================

#include <player_handler.h>
inherit "/cmds/base";
#define BASENAME "/d/admin/log/ENTER"
string process_file(string fname, string str);
string get_details(string str, string file);
string mtime(string t);
string stime(string t);
nosave int logged_on;
nosave string time;
mixed cmd(string str) {
  string retval;
  int i;
  write("This command is no longer available.\n");
  return 1;
  if (!str || str == "") {
    notify_fail("Usage: last <name>\n");
    return 0;
  }
  if(!this_player()->query_creator() &&
     PLAYER_HANDLER->test_creator(str)) {
    return notify_fail("Sorry, you can't do that, "+ str + " is a "
           "creator.\n");
  }
  if("/secure/master"->query_lord(str) &&
     !"/secure/master"->query_lord(this_player()->query_name())) {
    return notify_fail("Sorry, you can't do that, "+ str +" is a "
           "lord\n");
  }
  logged_on = 0;
  retval = "";
  time = "";
  str = (string)this_player()->expand_nickname(str);
  retval = process_file(BASENAME + ".log", str);
  if(logged_on == 1) {
    if (!find_player(str)) {
      retval += sprintf("%15-s %s - Destd (??:??)\n", str, mtime(time));
    } else {
      retval += sprintf("%15-s %s - Not logged off\n", str, mtime(time));
    }
  }
  if(retval == "") {
    if(PLAYER_HANDLER->test_user(str)) {
      i = (int)PLAYER_HANDLER->test_last(str);
      if(i) {
        write(sprintf("%15-s %s\n", str, ctime(i)));
        return 1;
      }
    }
    write("No such user " + str + "\n");
  } else {
    write(retval);
  }
  return 1;
}
string process_file(string fname, string str) {
  int size, bits, length, i;
  string retval, file;
  retval = "";
  seteuid("Root");
  size = file_size(fname);
  if(size > 50000) {
    length = file_length(fname);
    bits = size / 50000;
  } else {
    bits = 1;
  }
  if(bits > 10) {
    i = bits - 10;
  } else {
    i = 0;
  }
  for(; i< bits; i++) {
    file = unguarded((: read_file, fname,
          i * (length/bits), length / bits :) );
    if (!file) {
      write("Log file non existant, or bad things are happening.  "
      "(Bad vibes man!)\n");
      return "";
    }
    retval += get_details(str, file);
  }
  seteuid("Room");
  return retval;
}
string get_details(string str, string file) {
  string *sarr;
  string retval;
  string t2;
  string type;
  string time_str;
  int i;
  retval = "";
  sarr = explode(file, "\n");
  for (i = 0; i < sizeof(sarr); i++) {
    if (sscanf(sarr[i], "%s [%s] " + str + " ", time_str, type) == 2 ||
        sscanf(sarr[i], "%s [%s]  " + str + " ", time_str, type) == 2)  {
      switch(type)  {
        case "Enter":
          time = time_str;
          logged_on = 1;
          break;
        case "Recon":
          time = time_str;
          logged_on = 1;
          break;
        case "Su":
          t2 = time_str;
          logged_on = 0;
          retval += sprintf("%15-s %s - %s [Quit]\n", str, mtime(time),
                            stime(t2));
          break;
        case "NDead":
          t2 = time_str;
          logged_on = 1;
          retval += sprintf("%15-s %s - %s [NetDead]\n", str, mtime(time),
                    stime(t2));
          time = "";
          break;
        case "Exit":
          t2 = time_str;
          logged_on = 0;
          retval += sprintf("%15-s %s - %s [Quit]\n", str, mtime(time),
                            stime(t2));
          break;
        default:
          write("Someone has stuffed up... please file a bug report\n");
          break;
      }
    }
  }
  return retval;
}
string mtime(string t) {
  if(t == "")
    return "??? ?? ??:??";
  return t[0..<4];
}
string stime(string t) {
  if(t == "")
    return "??:??";
  return t[7..11];
}

==================================================
FILE: player/leaveg_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
int do_leave(string group, object member);
mixed cmd(string str) {
   object member, *members;
   string group;
   int disband;
   group = TEAM_HANDLER->query_group(this_player());
   if(!group)
      return notify_fail("You are not a member of any group.\n");
   members = TEAM_HANDLER->query_members( group );
   if ( !members) {
     TEAM_HANDLER->leave_group(group, this_player());
     TEAM_HANDLER->end_group( group );
     write( "Somehow your group has no members.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
     return 1;
   } else if(!(TEAM_HANDLER->query_owner(group))) {
     TEAM_HANDLER->leave_group( group, member );
     TEAM_HANDLER->end_group( group );
     write( "Somehow your group has no leader.  "
      "Your group has been ended.  "
      "I hope this is okay.\n" );
     return 1;
   }
   if((object)TEAM_HANDLER->query_owner(group) == this_player())
      disband = 1;
   foreach( member in members ) {
      if ( !member || ( member == this_player() ) )
         continue;
      if ( disband ) {
         tell_object(member, this_player()->short()+" leaves the group and "
                     "it disbands, everyone going their separate ways.\n");
         do_leave(group, member);
      } else
         tell_object(member, this_player()->short()+" leaves the group.\n");
   }
   if(disband) {
      TEAM_HANDLER->end_group(group);
      write("You disband "+group+" and everyone goes their separate "
            "ways.\n");
   } else {
      do_leave(group, this_player());
      write("You leave "+group+".\n");
   }
   return 1;
}
int do_leave(string group, object member) {
   object person;
   if(!TEAM_HANDLER->leave_group(group, member))
      return notify_fail("Ack, something went wrong.\n");
   if ( !sizeof( (object *)TEAM_HANDLER->query_members( group ) ) )
      return 0;
   foreach(person in TEAM_HANDLER->query_members(group)) {
      if(person) {
         member->remove_protector(person);
         person->remove_protector(member);
         member->remove_follower(person);
         person->remove_follower(member);
      }
   }
   return 1;
}

==================================================
FILE: player/liaison_s.c
==================================================

inherit "/cmds/base";
private string idle_time(object person) {
  int hours, mins, secs;
  string s, m, h;
  secs = query_idle(person);
  mins = secs / 60;
  secs %= 60;
  hours = mins / 60;
  mins %= 60;
  s = ("0"+secs)[<2..<1];
  m = ("0"+mins)[<2..<1];
  if ( !hours )  {
    return " (idle: "+m+":"+s+")";
  }
  h = ("0"+hours)[<2..<1];
  return " (idle: "+h+":"+m+":"+s+")";
}
mixed cmd( ) {
   int i, j;
   string *members, *member_alias, *aliases;
   object person;
   members = (string *)"/d/liaison/master"->query_members();
   aliases = ({ });
   i = sizeof( members );
   while ( i-- ) {
      person = find_player( members[ i ] );
      if ( ! person ) {
         member_alias = "/d/liaison/master"->member_alias( members[ i ] );
         j = sizeof( member_alias );
         while ( j-- ) {
            if ( find_player( member_alias[ j ] ) ) {
               aliases += ({ capitalize( member_alias[ j ] ) +"("+
                     capitalize( members[ i ] ) +")" });
            }
         }
         members = delete( members, i, 1 );
      } else if (!person) {
          members = delete(members, i, 1);
      } else {
         if ( !interactive( person ) ) {
            members = delete( members, i, 1 );
         } else {
            members[ i ] = capitalize( members[ i ] );
            switch( person->query_invis()  )  {
            case 0:
               break;
            case 1:
               members[ i ] = sprintf( "(%s)", members[ i ] );
               break;
            case 2:
               members[ i ] = sprintf( "({%s})", members[ i ] );
               break;
            default:
               members[ i ] = sprintf( "([%s])", members[ i ] );
               break;
            }
            members[ i ] = capitalize( members[ i ] );
            if (person->query_busy()) {
               members[ i ] += " (busy)";
            }
            if ( query_idle( person ) > 120 )  {
               members[ i ] += idle_time( person );
            }
         }
      }
   }
   if ( this_player()->query_creator() || !sizeof( members )) {
      members += aliases;
   }
   if ( !sizeof( members ) ) {
      add_failed_mess( "There are no Liaison creators currently logged on.\n" );
      return 0;
   }
   if ( sizeof( members ) > 1 ) {
      write( "Liaison creators logged on are "+
            query_multiple_short( members ) +".\n" );
   } else {
      write( "The only Liaison creator logged on is "+ members[ 0 ] +".\n" );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/locate.c
==================================================

inherit "/cmds/base";
#define TP this_player()
object *look_in_container(object fluff,
                          string word) {
   object frog;
   object *obs;
   object *things;
   things = match_objects_for_existence(word, ({ fluff }));
   obs = all_inventory(fluff);
   foreach (frog in obs) {
      if (sizeof(all_inventory(frog))) {
         things += look_in_container(frog, word);
      }
   }
   return things;
}
mixed cmd( string word ) {
   int i;
   int base_num;
   string list;
   object thing;
   object *things;
   object *extra_things;
   debug_printf("%s", word);
   if (environment(TP)) {
      switch(TP->check_dark(environment(TP)->query_light())) {
      case -2:
      case -1:
        if (this_player()->query_creator()) {
          write("It is too dark to locate anything, but since you are a cre...\n");
        } else {
          return notify_fail("It's too dark to locate anything.\n");
        }
        break;
      case 1:
      case 2:
        if (this_player()->query_creator()) {
          write("It is too bright to locate anything, but since you are a cre...\n");
        } else {
           return notify_fail("It's too bright to locate anything.\n");
        }
        break;
      }
   }
   things = match_objects_for_existence( word, ({ environment( TP ) }) );
   things = filter(things, (: environment($1) == environment(TP) ||
                             environment($1) == TP :));
   extra_things = look_in_container(this_player(), word) - things;
   base_num = sizeof(things);
   things += extra_things;
   if ( !sizeof( things ) ) {
      return notify_fail( "There is nothing here matching \""+ word +"\".\n" );
   }
   if ( sizeof( things ) == 1 ) {
     if ( things[0] == TP ) {
       write("You are here! :)\n");
       return 1;
     }
     list = "$C$"+ (string)things[ 0 ]->the_short();
     if ( (object)things[ 0 ]->query_wielded() == TP ) {
       list += " (held in " + query_multiple_short(TP->query_holding_limbs(things[0])) + ")";
     }
     if ( (object)things[ 0 ]->query_worn_by() == TP ) {
       list += " (worn)";
     }
     if ( things[ 0 ]->query_keep() ) {
       list += " (keeping)";
     }
     word = (string)things[ 0 ]->query_full_identifier();
     if ( stringp( word ) ) {
       list += " (\""+ word +"\")";
     }
     if (environment(things[0]) == this_player()) {
       list += (things[0]->group_object() ? " are" : " is") +
         " in your inventory.\n";
     } else {
       list += (things[0]->group_object() ? " are in " : " is in ");
       list += inside_the_short(environment( things[ 0 ] )) + ".\n";
     }
     write( list );
     return 1;
   }
   list = "";
   foreach ( thing in things ) {
      i++;
      if ( thing == TP ) {
         list += "You (" + i + ") are here :)\n";
         continue;
      }
      if (i > 30) {
         list += "Truncated list!  Cannot list more than 30 items.\n";
         break;
      }
      list += "$C$" + (string)thing->the_short();
      if (i <= base_num) {
         list += " (" + i + ")";
      }
      if ( (object)thing->query_wielded() == TP ) {
         list += " (held in " + query_multiple_short(TP->query_holding_limbs(thing)) + ")";
      }
      if ( (object)thing->query_worn_by() == TP ) {
         list += " (worn)";
      }
      if ( thing->query_keep() ) {
         list += " (keeping)";
      }
      word = (string)thing->query_full_identifier();
      if ( stringp( word ) ) {
         list += " (\""+ word +"\")";
      }
      if (environment(thing) == this_player()) {
         list += (thing->group_object() ? " are " : " is ") +
           "in your inventory.\n";
      } else {
        list += (thing->group_object() ? " are in " : " is in ");
         list += inside_the_short(environment( thing )) + ".\n";
      }
   }
   write( "$P$Locate$P$"+ list );
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'object name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/lockg_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
mixed cmd(string str) {
  object owner;
  int locked;
   str = TEAM_HANDLER->query_group(this_player());
   if(!str)
      return notify_fail("You are not a member of any group.\n");
  owner = TEAM_HANDLER->query_owner(str);
  if(!owner || owner != this_player())
    return notify_fail("Sorry, you are not the owner of "+str+".\n");
  locked = TEAM_HANDLER->query_locked(str);
  if(locked) {
    TEAM_HANDLER->set_locked(str, 0);
    write("Team "+str+" unlocked for new members.\n");
  } else {
    TEAM_HANDLER->set_locked(str, 1);
    write("Team "+str+" locked to new members.\n");
  }
  return 1;
}

==================================================
FILE: player/lockout.c
==================================================

#include <player_handler.h>
#include <playerinfo.h>
inherit "/cmds/base";
nosave mapping info = ([ ]);
private int cmd(int tim, string type, string reason, int use_alts) {
   string p1;
   string* alts;
   if (this_player() != this_player(1))
    return 0;
   if(type[<1] != 's')
      type += "s";
  switch (type) {
   case "days":
      tim *= 24;
      break;
   case "weeks":
      tim *= 24 * 7;
    break;
   case "hours":
     tim = tim;
     break;
   default:
      return notify_fail("Invalid time.\n");
  }
  if (tim > 24 * 31) {
    return notify_fail( "You can't lock yourself out for more than "
                        "one month!\n" );
  }
  if(sizeof(reason) > 80) {
    return notify_fail("Reason cannot be more than 80 characters.\n");
  }
   if (use_alts) {
      p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
      alts = (string*)PLAYERINFO_HANDLER->query_alts(this_player()->query_name()) |
             (string*)PLAYERINFO_HANDLER->query_alts(p1) |
             ({ this_player()->query_name() });
   } else {
      alts = ({ this_player()->query_name() });
   }
  info[this_player()->query_name()] = ({ tim, reason, alts });
  write("This will lockout " + query_multiple_short(alts) + ".\n");
  write("Enter your password: ");
  input_to("get_pw", 1, this_player());
  return 1;
}
int get_pw(string pass, object player) {
   int tim;
  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("\nSorry, incorrect password.\n");
    return 0;
  }
   if(!info[player->query_name()]) {
      write("\nSomething went wrong, please try again.\n");
      return 0;
   }
  tim = info[player->query_name()][0];
  if (tim < 24) {
    write("\nYour lockout will last " + tim  + " hour" +
          (tim == 1 ? "" : "s" ) + ".  It cannot be " +
          "undone.  Are you completely sure you wish to continue?\n");
  } else {
    write("\nYour lockout will last " + tim / 24 + " day" +
          ((tim / 24) == 1 ? "" : "s" ) + ".  It cannot be " +
          "undone.  Are you completely sure you wish to continue?\n");
  }
  input_to("confirm", 0, this_player());
  return 1;
}
int confirm(string yesno, object player) {
   int tim;
   string reason;
   string* alts;
   string name;
   if (yesno[0] != 'y') {
      write("Ok, cancelling lockout...\n");
      write("Lockout cancelled.\n");
      return 1;
   }
   if(!info[player->query_name()]) {
      write("Something went wrong, please try again.\n");
      return 0;
   }
   tim = info[player->query_name()][0];
   reason = info[player->query_name()][1];
   alts = info[player->query_name()][2];
   foreach (name in alts) {
      if (!"/secure/bastards"->lockout_person(name,
                                           tim*60*60, reason)) {
         write("Sorry, we failed.\n");
         return 0;
      }
   }
   write("Ok, you are now locked out.  Quit when ready.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<number'number of'> "
                     "<word'days|weeks|hours'> <string'reason'>",
                     (: cmd($4[0], $4[1], implode($4[2..], " "), 0 ) :),
             "alts <number'number of'> "
                     "<word'days|weeks|hours'> <string'reason'>",
                     (: cmd($4[0], $4[1], implode($4[2..], " "), 1 ) :) });
}

==================================================
FILE: player/mailinfo.c
==================================================

#include <mail.h>
#include <player_handler.h>
mixed cmd(string str) {
  if (!str || str=="")
    str = this_player()->query_name();
  else
    str = this_player()->expand_nickname(str);
  if (!PLAYER_HANDLER->test_user(lower_case(str)))
  {
    write("Sorry, but I don't know any "+capitalize(str)+".\n");
    return 1;
  }
  write("Player "+capitalize(str)+": "+(string)MAILER->finger_mail(str));
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: player/make.c
==================================================

#include <config.h>
#include <weather.h>
#include <move_failures.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
inherit  "/cmds/base";
#define TP this_player()
private string *_snow_creatures = ({
    "snowman",
    "snowwoman",
    "snowboy",
    "snowgirl",
    "snowbunny",
    "snowfrog",
    "snowball",
    "snowwomble",
    "snowangel",
    "snowcabbage",
    "snowwitch",
    "snowwizard",
    "snowwarrior",
    "snowthief",
    "snowpriest",
    "snowassassin",
    "snowfamily",
    "snowfox",
    "snowdwarf",
    "snowplayerkiller",
    "snowtroll"
});
private string _make_pattern_cache;
void create() {
    ::create();
    _snow_creatures = sort_array( _snow_creatures, 1 );
}
int is_snowing(object player, string str) {
  object env;
  int *co_ords;
  env = environment(player);
  if ((string)env->query_property("location") == "inside") {
    add_failed_mess("You must be outside to make a " + str + ".\n");
    return 0;
  }
  co_ords = (mixed *)env->query_co_ord();
  if (!WEATHER->query_snowing(env)) {
     add_failed_mess("You need snow to make a " + str + ".\n");
     return 0;
  }
  return 1;
}
mixed cmd(string str) {
  object ob;
  object env;
  env = environment(TP);
  switch (str) {
  case "snowball" :
    if (is_snowing(TP, str)) {
      ob = clone_object("/std/environ/snowball");
      if (ob->move(TP) != MOVE_OK) {
        add_succeeded_mess(({ "$N try to make a snowball, but you cannot "
                              "pick it up so it disintergrates in "
                              "disinterest.\n",
                              "$N tries to make a snowball, but they cannot "
                                "pick it up.\n" }));
      } else {
        add_succeeded_mess(({
          "$N $V a lovely big snowball.  Have fun with it ;)\n",
            "$N $V a lovely big snowball.\n" }));
      }
      return 1;
    }
    break;
#ifndef __DISTRIBUTION_LIB__
  case "cream pie":
    if (SPECIAL_DAY_HANDLER->query_special_day() == CREAM_PIE_DAY) {
      if (TP->query_property("made cream pie")) {
        add_failed_mess("You made a cream pie less than 30 seconds ago.  "
                        "Don't be greedy now.\n");
      } else {
        ob = clone_object("/obj/misc/cream_pie");
        if (ob->move(TP) != MOVE_OK) {
          add_succeeded_mess(({ "You try to magicaly conjure a cream pie up "
                                  "out of nowhere, but you cannot pick it up.\n",
                                  "$N tries to conjure up a cream pie, but "
                                  "just looks silly.\n" }));
          ob->dest_me();
          return 1;
        } else {
          TP->add_property("made cream pie", 1, 30);
          add_succeeded_mess("$N conjure$s up $I.\n", ({ ob }));
          return 1;
        }
      }
    } else {
       add_failed_mess("You can only create cream pies on cream pie day!\n");
    }
    break;
  default:
    if ( member_array( str, _snow_creatures ) > -1 ) {
        if (is_snowing(TP, str)) {
          ob = clone_object("/std/environ/snowman");
          ob->set_type(str);
          ob->move(env);
          add_succeeded_mess("$N $V a beautiful " + str + ".\n");
          return 1;
        }
    }
    break;
#endif
  }
  return 0;
}
mixed *query_patterns() {
    if ( !_make_pattern_cache ) {
        _make_pattern_cache = "{" + implode( _snow_creatures +
            ({ "cream pie" }), "|" ) + "}";
    }
   return ({ _make_pattern_cache, (: cmd($4[0]) :) });
}

==================================================
FILE: player/map.c
==================================================

inherit "/cmds/base";
int do_map() {
   string map;
   int* coords;
   object env;
   string handler;
   env = environment(this_player());
   if (!env)  {
      add_failed_mess("You are somewhere not on any map.\n");
      return 0;
   }
   if (this_player()->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   switch(this_player()->check_dark(environment(this_player())->query_light()))
   {
   case -2:
   case -1:
     return add_failed_mess("It is too dark to see anything.\n");
   case 2:
   case 1:
     return add_failed_mess("It is too bright to see anything.\n");
   }
   coords = env->query_terrain_coords();
   handler = env->query_terrain_handler();
   if (!coords  ||  !handler) {
      add_failed_mess("You can only do this in a terrain.\n");
      return 0;
   }
   map = handler->query_player_map(coords[0], coords[1], coords[2],
                                   env->query_visibility(env));
   if (!map) {
      add_failed_mess("There is no map available here.\n");
      return 0;
   }
   write(map);
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: do_map :) });
}

==================================================
FILE: player/maptemp.c
==================================================

inherit "/cmds/base";
int do_map() {
   string map;
   int* coords;
   object env;
   string handler;
   env = environment(this_player());
   if (!env)  {
      add_failed_mess("You are somewhere not on any map.\n");
      return 0;
   }
   if (this_player()->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   switch(this_player()->check_dark(environment(this_player())->query_light()))
   {
   case -2:
   case -1:
     return add_failed_mess("It is too dark to see anything.\n");
   case 2:
   case 1:
     return add_failed_mess("It is too bright to see anything.\n");
   }
   coords = env->query_terrain_coords();
   handler = env->query_terrain_handler();
   if (!coords  ||  !handler) {
      add_failed_mess("You can only do this in a terrain.\n");
      return 0;
   }
   map = handler->query_player_map_template(coords[0], coords[1], coords[2],
                                   env->query_visibility(env));
   if (!map) {
      add_failed_mess("There is no map available here.\n");
      return 0;
   }
   write(map);
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: do_map :) });
}

==================================================
FILE: player/mccp.c
==================================================

inherit "/cmds/base";
int cmd() {
    object *players;
    int compressed;
    if ( compressedp( this_player() ) ) {
        tell_object( this_player(), "You are currently using MCCP to "
          "connect to " + mud_name() + ".\n" );
    }
    else {
        tell_object( this_player(), "You are not currently using MCCP to "
          "connect to " + mud_name() + ".  Please read 'help compression' for "
          "more information about MCCP.\n" );
    }
    players = filter( users(), (: !$1->query_login_ob() &&
        reference_allowed( $1, $(this_player()) ) :) );
    compressed = sizeof( filter( players, (: compressedp :) ) );
    tell_object( this_player(), "%^BOLD%^$C$" + query_num( compressed, 1000 ) +
                 " users (" + ((compressed * 100) / sizeof(players)) + "%) are "
                 "currently using MCCP and " + query_num(sizeof(players) - compressed, 1000) + " users (" + (((sizeof(players) - compressed) * 100) / sizeof(players)) + "%) are uncompressed.%^RESET%^\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd :) });
}

==================================================
FILE: player/money.c
==================================================

#include <money.h>
inherit "/cmds/base";
private mapping _money_types;
void create()
{
   string zone;
   string *zones;
   zones = MONEY_HAND->query_all_places();
   _money_types = allocate_mapping(sizeof(zones));
   foreach(zone in zones) {
      _money_types[lower_case(zone)] = zone;
   }
   ::create();
   return;
}
int cmd(string str,
        int brief,
        object * containers)
{
   object *monies;
   object new_money;
   object *divided_money;
   object money;
   object tmp_money;
   object *inv;
   mixed *total;
   int success;
   if (this_player()->
          check_dark(environment(this_player())->query_light()) < 0)
   {
      add_failed_mess("It's too dark to count your money.\n");
      return 0;
   }
   if (str) {
      if (str == "here") {
         if (environment(this_player())->query_bank_name())
            str = environment(this_player())->query_money_place();
         else
            str = environment(this_player())->query_property("place");
         if (!str) {
            add_failed_mess("No idea what type of currency is used here.\n");
            return 0;
         }
      }
      str = lower_case(str);
      if (!_money_types[str]) {
         add_failed_mess("This is not a valid type of money, try one of " +
            query_multiple_short(keys(_money_types) + ({ "here" })) + ".\n");
         return 0;
      }
   }
   inv = all_inventory(this_player());
   monies = filter_array(inv, (: this_object()->find_the_dough($1) :));
   total = ({ });
   if (sizeof(monies)) {
      success = 0;
      divided_money = ({ 0, 0 });
      foreach(money in monies) {
         tmp_money = 0;
         if (!str) {
            tmp_money = money;
         } else if (str && _money_types[str]) {
            new_money = MONEY_VAULT->get_money_ob();
            new_money->set_money_array(money->query_money_array());
            divided_money = MONEY_HAND->
               filter_legal_tender(new_money, _money_types[lower_case(str)]);
            tmp_money = divided_money[0];
            if (divided_money[1]) {
               divided_money[1]->dest_me();
            }
         }
         if (tmp_money) {
               if (!brief) {
                  write("Your purse contains " +
                        query_multiple_short(tmp_money->half_short(1)) +
                        ".\n");
               }
               else  {
                  write("Your purse contains " +
                     query_multiple_short(tmp_money->half_symbol_short()) +
                     ".\n");
               }
            success++;
            if (divided_money[0]) {
               divided_money[0]->dest_me();
            }
         }
      }
      if (!success) {
         write("You have no money from the Land of " + capitalize(str) +
               ".\n");
      }
   }
   else write("You are flat broke.\n");
   return 1;
}
int find_the_dough(object env)
{
   if (member_array(MONEY_ALIAS, env->query_alias()) > -1) {
      while ((env = environment(env)) != this_player()) {
         if (env->query_closed() && !env->query_transparent()) {
            return 0;
         }
      }
      return 1;
   } else
      return 0;
}
mixed *query_patterns()
{
   return ({ "", (: cmd(0, 0, 0) :),
             "brief", (: cmd(0, 1, 0) :),
             "<string'area name'>", (: cmd($4[0], 0, 0) :),
             "<string'area name'> brief", (: cmd($4[0], 1, 0) :),
          });
}

==================================================
FILE: player/monitor.c
==================================================

#include <cmds/options.h>
inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  int monitor;
  monitor = TP->query_monitor();
  if(!str) {
    write("Your hit point monitor is set to " + MONITOR_OPTIONS[monitor] +
          ".\n");
    return 1;
  }
  if(member_array(str, MONITOR_OPTIONS) != -1) {
    write("Your hit point monitor is set to " + str + ".\n");
    TP->set_monitor(member_array(str, MONITOR_OPTIONS));
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{" + implode(MONITOR_OPTIONS, "|") + "}", (: cmd($4[0]) :) });
}

==================================================
FILE: player/mudlist.c
==================================================

#define INTERMUD_D "/net/intermud3/intermud"
int cmd(string str) {
  mixed *info;
  string *list;
  mapping borg;
  string mud;
  if( str && str != "") {
    mapping tmp;
    string opt, tmpstr;
    tmp = (mapping)INTERMUD_D->GetMudList();
    if( str[0] != '-' ) str = "-n " + str;
    opt = str[1..1];
    str = str[3..];
    borg = ([]);
    foreach(mud, info in tmp) {
      int x, y, z;
      switch(opt) {
      case "m":
        x = 5;
        break;
      case "d":
        x = 7;
        break;
      case "n":
        x = 0;
        break;
      }
      tmpstr = (x ? info[x] : mud);
      z = strlen(str = replace_string(lower_case(str), " ", ""));
      y = strlen(tmpstr = replace_string(lower_case(tmpstr), " ", ""));
      if( str == tmpstr ) {
        borg = ([ mud : info ]);
        break;
      }
      else if( y > z && tmpstr[0..z-1] == str && info[0] == -1 )
        borg[mud] = info;
    }
  }
  else {
    borg = ([ ]);
    foreach( mud, info in (mapping)INTERMUD_D->GetMudList() )
      if( info[0] == -1 ) borg[mud] = info;
  }
  if( !sizeof(borg) ) {
    write(mud_name()+" does not have any MUD matching "+str+" in "
          "its mudlist.\n");
    return 1;
  }
  else if( sizeof(borg) == 1 ) {
    string msg, svc;
    int val, comma = 0;
    mud = keys(borg)[0];
    msg = "\nDetailed information on %^GREEN%^" + mud + "%^RESET%^:\n";
    msg += "Server: " + borg[mud][7] + " (" + borg[mud][8] + ")\n";
    msg += "BaseLib: " + borg[mud][6] + "\n";
    msg += "Library: " + borg[mud][5] + "\n";
    msg += "Status: " + borg[mud][9] + "\n";
    msg += "Admin E-mail: " + borg[mud][10] + "\n";
    msg += "Services: ";
    foreach(svc, val in borg[mud][11]) {
      if( val == 1 ) {
        if( comma ) msg += ", " + svc;
        else {
          msg += svc;
          comma = 1;
        }
      }
    }
    msg += "\nHost: " + borg[mud][1] + "\n";
    msg += "Telnet port: " + borg[mud][2] + "\n";
    if( borg[mud][11]["http"] )
      msg += "HTTP port (World Wide Web): " + borg[mud][11]["http"]+"\n";
    if( borg[mud][11]["ftp"] )
      msg += "FTP port (File Transfer): " + borg[mud][11]["ftp"] + "\n";
    if( borg[mud][11]["rcp"] )
      msg += "RCP port (Remote Creator): " + borg[mud][11]["rcp"] + "\n";
    write(msg);
    return 1;
  }
  list = ({});
  foreach(mud, info in borg)
    list += ({ sprintf("%:-15s %:-10s %:-15s %:-15s %s %d",
                       mud, info[8], info[7], info[5], info[1], info[2]) });
  list = sort_array(list, 1);
  list = ({ mud_name() + " recognizes " + sizeof(borg)+" muds"
              " matching your query: ", "" }) + list;
  previous_object()->more_string(implode(list, "\n")+"\n", "Mudlist");
  return 1;
}
int alphabet(string a, string b) {
    if((a = lower_case(a)) == (b = lower_case(b))) return 0;
    else if(a > b) return 1;
    else return -1;
}
void help() {
    message("help", "Syntax: <mudlist>\n"
      "        <mudlist -dmn [arg]>\n\n"
      "Without any arguments, it gives a full listing of all muds "
      "with which this mud is capable of communication through "
      "tell, mail, finger, rwho, and other intermud services.  "
      "With arguments, <mudlist> requires one and only one option "
      "which must be one of the following:\n"
      "\t-d [driver]: List only muds using the named driver\n"
      "\t-m [mudlib]: List only muds using the named mudlib\n"
      "\t-n [mudname]: List only the muds with the name given\n\n"
      "Note that the argument need not be complete, for example:\n"
      "\t mudlist -n idea\n"
      "will list IdeaExchange as well as any other mud whose name "
      "begins with the string \"idea\".\n\n"
      "See also: finger, mail, rwho, tell", this_player());
}
void clean_up() {
  destruct(this_object());
}
void reset() {
  destruct(this_object());
}
void dest_me() {
  destruct(this_object());
}

==================================================
FILE: player/news.c
==================================================

#include <board.h>
inherit "/cmds/base";
object board;
string board_name = "announcements";
void do_list(int all);
int do_read(int num);
#define LOGON_LIMIT 10
#define MOST 1
#define ALL 2
#define SOME 0
mixed cmd(string str) {
  int msg;
  switch(str) {
  case "help":
  case "?":
  case "h":
    tell_object( this_player(),
                "Usage:\n"
                "To read next news item type: \"news\".\n"
                "To read a specific news item type: \"news <num>\".\n"
                "To list new news items type: \"news list\".\n"
                "To list all news items type: \"news review\".\n");
    break;
  case "l":
  case "list":
    do_list(MOST);
    break;
  case "r":
  case "review":
    do_list(ALL);
    break;
  default:
    if(str) sscanf(str, "%d", msg);
    do_read(msg);
  }
  return 1;
}
int do_read(int num) {
  mapping news_rc;
  mixed *stuff;
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if ( !news_rc ) {
    news_rc = ([ ]);
  }
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if(!num) {
    num = sizeof(stuff);
    while((num > 0) && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
    }
    if(num == sizeof(stuff)) {
      write("No news is good news.\n");
      return 1;
    }
    num++;
  }
  if(num < 0) {
    num = sizeof(stuff) + num + 1;
  }
  if(( num < 1) || (num > sizeof(stuff))) {
    write("No news item of that number.\n");
    return 1;
  }
  num--;
  if(news_rc[ board_name ] < stuff[ num ][ B_TIME ]) {
    news_rc[ board_name ] = stuff[ num ][ B_TIME ];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  this_player()->more_string( "Note #"+ ( num + 1 ) +" posted at " +
        ctime(stuff[num][B_TIME])[0..9] + " Title: \""+
        stuff[ num ][ B_SUBJECT ][ 0 .. (int)this_player()->query_cols() -
       10 ] +"\"\n\n"+ (string)BOARD_HAND->get_message( board_name, num ),
       "[Note "+ ( num + 1 ) +"]" );
  return 1;
}
string the_date(int i) {
  return ctime(i)[4..9];
}
void do_list(int all) {
  int i, newones;
  mixed *stuff;
  string ret;
  mapping news_rc;
  ret = "";
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (!sizeof(stuff)) {
    tell_object(this_player(), "No news is good news.\n");
    return;
  }
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc) {
    news_rc = ([ ]);
  }
  newones = 0;
  for (i = 0; i < sizeof(stuff); i++) {
    if (news_rc[board_name] < stuff[i][B_TIME]) {
      ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
      newones += 1;
      if (all == SOME) {
        if (newones > LOGON_LIMIT) {
          write("Plus more....\n");
          break;
        }
      }
    } else if(all == ALL) {
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
    }
  }
  if(!newones && all != ALL) {
    ret += "\nNo news is good news.\n";
  }
  if (all == SOME) {
    ret += "\nUse 'news list' for all new news items and 'news review' for all news times.\n";
  }
  this_player()->more_string( ret, "News" );
}

==================================================
FILE: player/nickname.c
==================================================

inherit "cmds/base";
int print_nicknames(mapping map_nicknames);
int add_nickname(string str, mapping map_nicknames);
int print_single_nickname(string str) {
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  str = lower_case(str);
  if(!map_nicknames[str]) {
    add_failed_mess("That nickname does not exist.\n");
    return 0;
  }
  write("Setting for nickname "+str+" is "+map_nicknames[str]+".\n");
  return 1;
}
int print_nicknames(int sorted) {
  int i;
  int cols;
  string str;
  string str_long;
  string str_middle;
  string str_small;
  string bit;
  string *tmp;
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  bit = "";
  str_long = "";
  str_middle = "";
  str_small = "";
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!sizeof(map_nicknames)) {
     write("You do not have any nicknames.\n");
     return 1;
  }
  tmp = sort_array(keys(map_nicknames), 1);
  cols = (int)this_player()->query_cols();
  for (i=0;i<sizeof(tmp);i++) {
    str = tmp[i]+": "+map_nicknames[tmp[i]]+"  ";
    if (strlen(str) > 39 || sorted) {
      str_long += sprintf(tmp[i]+": %-=*s\n", cols - strlen(tmp[i]), map_nicknames[tmp[i]]);
    } else if (strlen(str) > 19) {
      str_middle += str+"\n";
    } else {
      str_small += str+"\n";
    }
  }
  if (strlen(str_middle)) {
    str_long += sprintf("%-#*s\n", cols, str_middle);
  }
  if (strlen(str_small)) {
    str_long += sprintf("%-#*s\n", cols, str_small);
  }
  this_player()->more_string(str_long, "Nicknames");
  return 1;
}
int add_nickname(string s1, string s2) {
  mapping map_nicknames;
  s1 = lower_case(s1);
  s2 = lower_case(s2);
  if( member_array( s1, ({ "a", "an", "the" }) ) != -1 ) {
    add_failed_mess( "Using articles as nicknames confuses the parser.  "
                     "Choose another.\n" );
    return 0;
  }
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!map_nicknames[s1]) {
    map_nicknames[s1] = s2;
    write("Added nickname "+s1+" for "+s2+".\n");
    return 1;
  }
  write("Changed nickname "+s1+" from "+map_nicknames[s1]+" to "+s2+".\n");
  map_nicknames[s1] = s2;
  this_player()->set_nicknames(map_nicknames);
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: print_nicknames(0) :),
             "sorted", (: print_nicknames(1) :),
             "<string'nickname'>", (: print_single_nickname($4[0]) :),
             "<string'nickname'> <string'realname'>", (: add_nickname($4[0], $4[1]) :)
           });
}

==================================================
FILE: player/options.c
==================================================

inherit "/cmds/base";
#include <cmds/options.h>
int cmd_set(string option, string value);
int cmd_display(string option) {
   string *bits;
   string *groups;
   string bing;
   if (sscanf(option, "%s=%s", option, bing) == 2) {
      return cmd_set(option, bing);
   }
   if (OPTION_HANDLER->is_option(this_player(), option)) {
     write(sprintf("%-20s = %s (%s)\n", option,
                   OPTION_HANDLER->query_option_value(this_player(), option),
                   OPTION_HANDLER->query_option_help(this_player(),option)));
      return 1;
   } else if (OPTION_HANDLER->is_option_group(this_player(), option)) {
      bits = OPTION_HANDLER->query_sub_options(this_player(), option);
      if (option == "") {
         write("Top level:\n");
      } else {
         write(option + ":\n");
      }
      bits = sort_array(bits, (: strcmp :));
      groups = filter(bits, (: OPTION_HANDLER->is_option_group(this_player(),
                                               $2 + " " + $1) :), option);
      bits -= groups;
      foreach (bing in groups) {
         write(sprintf("   %-17s <more options>\n", bing));
      }
      foreach (bing in bits) {
         if (OPTION_HANDLER->is_option(this_player(), option + " " + bing)) {
            write(sprintf("$I$30=   %-17s = %-10s <%s>\n", bing,
                    OPTION_HANDLER->query_option_value(this_player(),
                                                     option + " " + bing),
                    implode(OPTION_HANDLER->query_option_values(this_player(),
                                        option + " " + bing), "|")));
         }
      }
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
int cmd_set_all(string option, string value) {
   string* stuff;
   string* ok;
   string* bad;
   string opt;
   if (!OPTION_HANDLER->is_option_group(this_player(), option)) {
      add_failed_mess("The option must be an option group to use the 'all' "
                      "keywork.\n");
      return 0;
   }
   stuff = OPTION_HANDLER->query_sub_options(this_player(), option);
   option += " ";
   ok = ({ });
   bad = ({ });
   foreach (opt in stuff) {
      if (OPTION_HANDLER->is_option(this_player(), option + opt)) {
         if (OPTION_HANDLER->set_option_value(this_player(), option + opt,
                                              value)) {
            ok += ({ option + opt });
         } else {
            bad += ({ option + opt });
         }
      } else {
         bad += ({ option + opt });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("Set " + query_multiple_short(ok) + " to " +
                         value + ".\n");
      return 1;
   }
   add_failed_mess("Unable to set " + query_multiple_short(bad) + " to " +
                   value + ".\n");
   return 0;
}
int cmd_set(string option, string value) {
   string *bits;
   if (!option  ||  option == "")
      return 0;
   bits = explode(option, " ");
   if(!sizeof(bits))
     return 0;
   if (bits[<1] == "all") {
      if (sizeof(bits) > 1) {
         return cmd_set_all(implode(bits[0..<2], " "), value);
      }
      add_failed_mess("Cannot use 'all' as an option by itself.\n");
      return 0;
   }
   if (OPTION_HANDLER->is_option(this_player(), option)) {
      if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
         write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
         return 1;
      } else {
         add_failed_mess("Unable to set option " + option + " to " +
                value +
                ".\n");
         return 0;
      }
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
int cmd_edit(string option) {
   string value;
   if (OPTION_HANDLER->is_option(this_player(), option)) {
      value = OPTION_HANDLER->query_option_value(this_player(), option);
      write("Editing the option " + option + ".\n");
      this_player()->do_edit(value, "finish_edit", this_object(),
                             0, option);
      return 1;
   } else {
      add_failed_mess("There is no option " + option + ".\n");
      return 0;
   }
}
void finish_edit(string value, string option) {
   if (!value) {
      write("Aborting.\n");
      return ;
   }
   if (OPTION_HANDLER->set_option_value(this_player(), option, value)) {
      write("Set option " + option + " to " +
                OPTION_HANDLER->query_option_value(this_player(), option) +
                ".\n");
   } else {
      write("Unable to set the option " + option + ".\n");
   }
}
mixed *query_patterns() {
   return ({ "<string'option'>",
               (: cmd_display($4[0]) :),
             "",
               (: cmd_display("") :),
             "edit <string'option'>",
                (: cmd_edit($4[0]) :),
             "<string'option'> = <word'value'>",
                (: cmd_set($4[0], $4[1]) :),
             "<string'option'> all = <word'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             "set <string'option'> all <string:quoted'value'>",
                (: cmd_set_all($4[0], $4[1]) :),
             });
}

==================================================
FILE: player/perm_it.c
==================================================

inherit "/cmds/base";
int cmd( object player ) {
  object *corpses, corpse;
  int i;
  corpses = filter( children( "/obj/corpse" ),
                    (: $1 && $1->query_property("player" ) :) );
  corpses = filter( corpses,
                    (: $1 && $1->query_ownership() ==
                     $(this_player()->query_name()) :) );
  if( sizeof( corpses ) ) {
    foreach( corpse in corpses ){
      if(member_array(player->query_name(), corpse->query_permitted()) != -1) {
        i++;
      } else {
        corpse->give_permission( player->query_name() );
      }
    }
  } else {
    add_failed_mess("You don't seem to have a corpse!  Why not die and try "
                    "again?%^RESET%^\n");
    return 0;
  }
  if( i == sizeof( corpses ) ){
    write(capitalize(player->query_name()) + " is already permitted to "
          "remove items from your corpse.%^RESET%^\n" );
  } else {
    write(capitalize(player->query_name()) + " is now permitted to "
          "remove items from your corpse.%^RESET%^\n" );
    tell_object(player, "%^BOLD%^%^GREEN%^You now have permission to get "
                "items from " + this_player()->query_cap_name() +
                "'s corpse.%^RESET%^\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}

==================================================
FILE: player/position.c
==================================================

#include <player.h>
#define MAXLEN 30
inherit "/cmds/base";
private string* _bad_words;
void create() {
   _bad_words = ({ "teach", "skill", "finger", "lesson", ":)", ";)",
                   "chainsaw", "0", "1", "2", "3", "4", "5", "6", "7", "8",
                   "9", ":", ";", ",", "'", "*", "%", "!",
                   "@", "~", "`", "#", "$", "^", "&", "(", ")",
                   "_", "-", "=", "+", "{", "}", "[", "]",
                   "<", ".", ">", "?", "/", "\\",
                   ":->", ":-)", ";-)", ";->", "\""});
}
int cmd( string new_pos ) {
  object player = this_player();
  string word, tmp;
  if (!new_pos) {
    write("You are " + player->query_position_short() + ".\n");
    return 1;
  }
  if ( strlen(new_pos) > MAXLEN ) {
    add_failed_mess("Sorry, your position cannot be more than " +
                        MAXLEN + " letters long.\n");
    return 0;
  }
  if ( player->query_sp() < SET_POSITION_COST ) {
    add_failed_mess( NO_POWER );
    return 0;
  }
  new_pos = replace_string(new_pos, "^", "");
  new_pos = replace_string(new_pos, "%", "");
  tmp = lower_case(new_pos);
  foreach(word in _bad_words) {
    if(strsrch(tmp, word) != -1) {
      add_failed_mess("You cannot bring yourself to set that position.\n");
      return 0;
    }
  }
  player->set_position( new_pos );
  player->adjust_sp( - SET_POSITION_COST );
  tell_object( player, "People will now see:\n" +
               player->query_cap_name() + " is " + new_pos + ".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
          "<string'new position'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/pstatus.c
==================================================

broken
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <tune.h>
#include <skills.h>
inherit "/cmds/base";
string find_hp_string( int current, int max );
string find_gp_string( int current, int max );
string find_xp_string( int current );
string find_wimpy_string( int wimpy );
string find_surrender_string( int surr );
string find_align_string( object tp );
string find_death_string( int remaining );
int calc_percent( float x, float y );
int calc_xp_cost( string skill );
int cmd() {
   object me;
   me = this_player();
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if (this_player()->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   switch( me->query_verbose( "score" ) ) {
   case 1:
      printf( "%s.\n%s and %s.\n%s.\n%s.\n%s and %s.\n%s.\n%s.\n",
              "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ),
              capitalize( find_align_string( me ) ),
              capitalize( find_wimpy_string( me->query_wimpy() ) ),
              find_surrender_string( me->query_surrender() ),
              "You are "+ me->burden_string(),
              find_death_string( me->query_max_deaths() - me->query_deaths() ) );
      return 1;
   default:
      printf( "%s and %s.\n%s.\n",
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ) );
      return 1;
   }
}
int cmd_stats() {
   object me;
   int stat;
   string ret;
   me = this_player();
   ret = "";
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if ( stat = ( me->query_tmp_str() + me->query_bonus_str() ) ) {
      if ( stat > 0 ) {
         ret += "You feel stronger then usual.\n";
      } else {
         ret += "You feel weaker then usual.\n";
      }
   }
   if ( stat = ( me->query_tmp_int() + me->query_bonus_int() ) ) {
      if ( stat > 0 ) {
         ret += "You feel smarter then normal.\n";
      } else {
         ret += "You feel less smart then normal.\n";
      }
   }
   if ( stat = ( me->query_tmp_con() + me->query_bonus_con() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more healthy then usual.\n";
      } else {
         ret += "You feel a bit sickly.\n";
      }
   }
   if ( stat = ( me->query_tmp_dex() + me->query_bonus_dex() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more nimble then usual.\n";
      } else {
         ret += "You feel more clumsy than you normally do.\n";
      }
   }
   if ( stat = ( me->query_tmp_wis() + me->query_bonus_wis() ) ) {
      if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
      } else {
         ret += "You feel a bit vague.\n";
      }
   }
   if ( !strlen( ret ) ) {
      ret += "You feel fine.\n";
   }
   printf( "%s", ret );
   return 1;
}
string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are in perfect health";
   case 70..89:
      return "you are slightly wounded";
   case 50..69:
      return "you are moderately wounded";
   case 30..49:
      return "you are seriously wounded";
   case 15..29:
      return "you are critically wounded";
   case 6..14:
      return "you are fatally wounded";
   case 0..5:
      return "you are near death";
   default:
      return "you are broken";
   }
}
string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are full of energy";
   case 70..89:
      return "you are enthusiastic";
   case 50..69:
      return "you are not quite so full of beans";
   case 30..49:
      return "you are weary";
   case 15..29:
      return "you are tired";
   case 6..14:
      return "you are exhausted";
   case 0..5:
      return "you are nearly unconscious";
   default:
      return "you are broken";
   }
}
string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   xptotal /= sizeof( skills );
   tell_creator( find_player( "terano" ), "%s: Current XP is: %d, Avg XP is %d, Ratio is: %d.\n",
                 this_player()->query_name(), current, xptotal, calc_percent( current, xptotal ) );
   switch( calc_percent( current, xptotal ) ) {
   case 0..20:
      return "you don't think you can learn much at the moment";
   case 21..59:
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100:
      return "if you squeezed it, you could gain some insight";
   case 101..300:
      return "you might be able to learn something new, if you found the right teacher";
   case 301..400:
      return "a small amount could be learned with training";
   case 401..800:
      return "a bit of training might be in order";
   case 801..1200:
      return "you could very well learn something new from training";
   case 1201..1500:
      return "you could benefit from training";
   case 1501..2000:
      return "you feel like training might help";
   case 2001..2500:
      return "you should consider training your skills";
   case 2501..4000:
      return "your skills could be greatly improved with training";
   default:
      return "certainly a hearty training session is in order!";
   }
}
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
}
string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
}
string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
}
string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }
   switch ( remaining ) {
   case 0..0:
      return "Death has a special interest in your next appointment";
   case 1..3:
      return "Death is starting to lose patience with you";
   case 4..7:
      return "You and Death are on good terms";
   default:
      return "You have an \"arrangement\" with Death";
   }
}
int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;
   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   if (!total) {
      total = cost;
   }
   return total;
}
int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
}
mixed *query_patterns() {
   return ({ "", (: cmd() :), "stats", (: cmd_stats() :) });
}

==================================================
FILE: player/qalias.c
==================================================

int cmd()
{
   string *aliases, alias_mess, message;
   int cols;
   aliases = keys( this_player()->query_aliases() );
   if( !sizeof( aliases ) )
   {
      tell_object( this_player(), "You have no aliases.\n" );
      return 1;
   }
   message = "\nYou have the following aliases:\n";
   aliases = sort_array( aliases, (: strcmp :) );
   alias_mess = implode( aliases, ", " );
   cols = this_player()->query_cols() - 3;
   message += sprintf( "   %-=*s\n", cols, alias_mess );
   message += "A total of " + sizeof( aliases ) + " aliases.\n";
   tell_object( this_player(), message );
   return 1;
}
mixed *query_patterns()
{
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/qwho.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>
int playercompare(object p1, object p2);
int cmd(string guild_name) {
   int i;
   int countcre;
   int countplay;
   int counttest;
   int countloginq;
   int countlogins;
   int compressed;
   string obtyp;
   string tmp;
   object *arr;
   string nam;
   string cres;
   string plays;
   string testers;
   string *login_q;
   string logins;
   int showmasters;
   mapping user_data;
   object *liaisons;
   string friends;
   int countFriends;
   int totalUsers;
   int totalPlayers;
   int totalCompressed;
   if (this_player()->query_creator()) {
      showmasters = 1;
   } else {
      showmasters = 0;
   }
   countcre = 0;
   countplay = 0;
   counttest = 0;
   compressed = 0;
   cres = "";
   plays = "";
   testers = "";
   logins = "";
   friends = "";
   user_data = unique_mapping( users(),
       (: "/d/liaison/master"->query_member( $1->query_name() ) :) );
   if ( user_data[1] ) {
       liaisons = sort_array( user_data[1], (: playercompare :) );
   }
   else {
       liaisons = ({ });
    }
   if ( user_data[0] ) {
       arr = sort_array( user_data[0], (: playercompare :));
   }
   else {
       arr = ({ });
   }
   arr = liaisons + arr;
   arr = filter(arr, (: (!$1->query_invis() || reference_allowed(this_player(),
     $1)) && !$1->query_login_ob() :) );
   if (guild_name) {
      arr = "/cmds/player/who"->filter_users(arr, guild_name, 1);
      if (!sizeof(arr)) {
         add_failed_mess("Unable to find any members of " +
                         guild_name + ".\n");
         return 0;
      }
   }
   for(i=0;i<sizeof(arr);i++) {
      nam = arr[i]->query_cap_name();
      if (!nam) {
         if (showmasters) {
            nam = "/secure/master";
         } else {
            continue;
         }
      }
      switch (arr[i]->query_invis()) {
      case 0:
         break;
      case 1:
         nam = "[" + nam + "]";
         break;
      case 2:
         nam = "[{" + nam + "}]";
         break;
      case 3:
         nam = "[<" + nam + ">]";
         break;
      default:
         nam = "?" + nam + "?";
         break;
      }
      obtyp = arr[i]->query_object_type();
      switch(obtyp) {
      case "X":
         break;
      case " ":
         break;
      case "C":
         nam += "(%^CYAN%^C%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "S":
         nam += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "T":
         nam += "(%^BOLD%^%^RED%^T%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      case "D":
         nam += "(%^RED%^D%^RESET%^)";
         if ( "/d/liaison/master"->query_member((string)arr[i]->query_name())) {
            nam += "(%^YELLOW%^l%^RESET%^)";
         }
         break;
      default:
         break;
      }
      if (this_player()->is_friend(arr[i]->query_name())) {
         nam += "(%^GREEN%^F%^RESET%^)";
      }
      if (compressedp(arr[i])) {
          compressed++;
      }
      if (arr[i]->query_creator()) {
         countcre++;
         cres = cres + " " + nam;
      } else if (obtyp == "p") {
         counttest++;
         testers = testers + " " + nam;
      } else if(arr[i]->query_login_ob()) {
         countlogins++;
         logins = logins + " " + nam;
      } else if (this_player()->is_friend(arr[i]->query_name())) {
         countFriends++;
         friends = friends + " " + nam;
      } else {
         countplay++;
         plays = plays + " " + nam;
      }
   }
   if (guild_name) {
      arr = LOGIN_HANDLER->query_login_queue();
      arr = "/cmds/player/who"->filter_users(arr, guild_name);
      login_q = map(arr, (: $1->query_cap_name() :));
   } else {
      login_q = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
   }
   login_q = filter(login_q, (: $1 :));
   login_q = sort_array(login_q, 1);
   countloginq = sizeof(login_q);
   tmp = sprintf("%%^BOLD%%^%d Creator%s:%%^RESET%%^%s\n",
                 countcre, countcre != 1 ? "s" : "", cres);
   write(tmp);
   if (guild_name != "creator" && guild_name != "creators") {
      switch (counttest) {
        case 0:
            break;
        case 1:
           write("%^BOLD%^" + counttest + " Playtester:%^RESET%^" + testers + "\n");
        break;
        default:
           write("%^BOLD%^" + counttest + " Playtesters:%^RESET%^" + testers + "\n");
        break;
     }
      if (countFriends) {
         write("%^GREEN%^" + countFriends + " Friend" +
             (countFriends > 1 ? "s" : "") + ":%^RESET%^" + friends + "\n");
      }
      write("%^BOLD%^" + countplay + " Players:%^RESET%^" + plays + "\n");
      if (countlogins < countloginq) {
         countlogins = countloginq;
      }
      if (countlogins-countloginq) {
         logins = replace(logins, ({ "[", "", "]", ""}));
         if(countloginq) {
            foreach(tmp in login_q) {
               logins = replace(logins, tmp+" ", "");
            }
         }
         write("%^BOLD%^" + (countlogins - countloginq) +
               " Logging in:%^RESET%^" + logins + "\n");
      }
      if(countloginq) {
         write("%^BOLD%^" + countloginq + " Queued:%^RESET%^ " +
               implode(login_q, " ") + "\n");
      }
   } else {
      countlogins = 0;
      counttest = 0;
      countplay = 0;
   }
   totalUsers = countcre + counttest + countplay + countlogins + countFriends;
   totalPlayers = counttest + countplay + countFriends;
   totalCompressed = compressed - countFriends;
   write("%^BOLD%^" + (totalPlayers) + " Players, " +
         totalUsers + " Total%^RESET%^\n" );
   return 1;
}
int playercompare(object p1, object p2) {
   return strcmp(p1->query_name(), p2->query_name());
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string'guild name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/recover.c
==================================================

#include <obj_parser.h>
inherit "/cmds/base";
#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
#include <player.h>
#define MAX_RECOVER 20
int cmd_recover(string name) {
   object* obs;
   object* fail;
   object* ok_me;
   object* ok_here;
   object cont;
   object ob;
   class obj_match omatch;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   if (this_player()->query_property("dead")) {
      add_failed_mess("You're a disembodied spirit, how do you expect to "
                      "recover anything at all?\n");
      return 0;
   }
   cont = BURY_EFFECT->query_buried_container(environment(this_player()));
   if (!cont) {
      add_failed_mess("There is nothing buried here.\n");
      return 0;
   }
   omatch = (class obj_match)match_objects_in_environments(name, cont);
   if (omatch->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(omatch));
      return 0;
   }
   obs = omatch->objects;
   if ( sizeof( obs ) > MAX_RECOVER ) {
      add_failed_mess( "You can only recover " +
        query_num( MAX_RECOVER ) + " items at a time.\n" );
      return 0;
   }
   fail = ({ });
   ok_me = ({ });
   ok_here = ({ });
   if (sizeof(obs)) {
      foreach (ob in obs) {
#ifndef __DISTRIBUTION_LIB__
        if(interactive(this_player()) &&
           PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("recover",
                                                           this_player(),
                                                           ob)) {
          fail += ({ ob });
        } else
#endif
         if (ob->move(this_player()) == MOVE_OK) {
            ok_me += ({ ob });
         } else if (ob->move(environment(this_player())) == MOVE_OK) {
            ok_here += ({ ob });
         } else {
            fail += ({ ob });
         }
      }
      if (!sizeof(ok_me) && !sizeof(ok_here)) {
         add_failed_mess("Unable to recover $I.\n", fail);
         return 0;
      }
      if (sizeof(ok_me)) {
         add_succeeded_mess("$N $V $I.\n", ok_me);
      }
      if (sizeof(ok_here)) {
         add_succeeded_mess("$N $V $I and leave$s " +
                            (sizeof(ok_here) > 1?"them":"it") +
                            " here.\n", ok_here);
      }
      return 1;
   } else {
      ok_me = all_inventory(cont);
      if (sizeof(ok_me)) {
         add_failed_mess("Unable to recover " + name + ", available objects "
                       "are " + query_multiple_short(ok_me) +
                      ".\n");
      } else {
         add_failed_mess("Unable to recover " + name + ".\n");
      }
      return 0;
   }
}
mixed* query_patterns() {
   return ({ "<string'buried object'>", (: cmd_recover($4[0]) :) });
}

==================================================
FILE: player/refer.c
==================================================

#include <login.h>
#include <clubs.h>
inherit "/cmds/base";
int cmd(string str) {
   string ret;
   str = lower_case(str);
   str = (string)this_player()->expand_nickname(str);
   ret = (string)"/secure/finger"->refer_info(str);
   if (ret) {
      this_player()->more_string( this_player()->fit_message(ret),
                                  "refer: "+str );
      return 1;
   }
   add_failed_mess("No one by the name of " + str + " has "
                   "ever visited " + mud_name() + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({"<string'name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/register.c
==================================================

#include <player_handler.h>
#include <playerinfo.h>
inherit "/cmds/base";
int cmd(string alt) {
  string p1;
  string p2;
  alt = lower_case(alt);
  if (!PLAYER_HANDLER->test_user(alt))
    return notify_fail(alt + " is not a player.\n");
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if(!p1 || p1 == "") {
     p1 = this_player()->query_name();
   }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(p1 == p2) {
     add_failed_mess("You and " + alt + " are already registered.\n");
     return 0;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2)) &&
      sizeof(PLAYERINFO_HANDLER->query_alts(p1))) {
     add_failed_mess("Sorry, there is a clash of alts here, you'll need to "
                     "ask a creator for assistance.\n");
     return 0;
   }
  write("Enter your password (this character): ");
  input_to("get_pw", 1, this_player(), alt);
  return 1;
}
void get_pw(string pass, object player, string alt) {
  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  write("\nEnter the password for " + alt + ": ");
  input_to("get_alt_pw", 1, player, alt);
}
void get_alt_pw(string pass, object player, string alt) {
  string result;
  string p1, p2;
  write("\n");
  if(this_player() != player) {
    write("Something has gone wrong, player objects don't match.\n");
    return;
  }
  if (!PLAYER_HANDLER->test_password(alt, pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  p1 = PLAYERINFO_HANDLER->query_alt_of(player->query_name());
  if(!p1 || p1 == "") {
    p1 = player->query_name();
  }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2))) {
     write("Registering " + p1 + " as an alt of " + p2 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p2, p1);
   } else {
     write("Registering " + p2 + " as an alt of " + p1 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p1, p2);
   }
   write(result);
}
int cmd_list() {
   string* alts;
   string p1;
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!p1) {
      p1 = this_player()->query_name();
   }
   alts = (string*)PLAYERINFO_HANDLER->query_alts(p1) |
          (string*)PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!sizeof(alts)) {
      write("No alts registered.\n");
      return 1;
   }
   write("Your registered alts are " + query_multiple_short(alts) + ".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "list", (: cmd_list :),
             "<word'alt-name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/relationship.c
==================================================

#include <clubs.h>
inherit "/cmds/base";
string show_relationship(object from, object to, string rel, object telling);
int do_relationship(string relationship, object *players, int force) {
   object player;
   string family;
   string my_family;
   string their_family;
   string rel;
   class family_response_data frog;
   int ok;
   string *relations;
   my_family = this_player()->query_family_name();
   if (!my_family) {
      add_failed_mess("You must be in a family to form a relationship with "
                      "someone.\n");
      return 0;
   }
   my_family = CLUB_HANDLER->query_club_name(my_family);
   rel = CLUB_HANDLER->query_ungendered_relationship(relationship);
   if (!rel) {
      add_failed_mess("The relationship '" + relationship +
                      "' is not valid.  The valid relationships are " +
                      query_multiple_short(
                              CLUB_HANDLER->query_all_relationships()) +
                      ".\n");
      return 0;
   }
   relationship = rel;
   foreach (player in players) {
      player->check_family_name();
      their_family = player->query_family_name();
      relations = CLUB_HANDLER->query_relationships_to(my_family,
                                                      this_player()->query_name(),
                                                      player->query_name());
      if (!their_family && sizeof(relations)) {
         foreach (rel in relations) {
            CLUB_HANDLER->remove_relationship(my_family,
                                              this_player()->query_name(),
                                              their_family,
                                              player->query_name(),
                                              rel);
         }
      }
      rel = CLUB_HANDLER->query_relationship_gender(relationship,
                                                    player->query_female());
      if (sizeof(relations)) {
         if (member_array(relationship, relations) != -1 &&
             force) {
            family = my_family;
	    tell_object(player, this_player()->the_short() +
                             " offers to use "
                             "the relationship of " + rel + " with "
                             "you in the family " + my_family + " to allow "
                             "you to join the family.  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
            frog = new(class family_response_data);
            frog->family = family;
            frog->relationship = relationship;
            player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                        this_player(),
                                        frog);
            ok++;
            add_succeeded_mess(({
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\nThis will setup the "
                               "relationships of: " +
                               show_relationship(this_player(), player,
                                                 relationship, this_player()) + "\n",
                               "$N offer$s to setup a relationship of " +
                               rel + " with $I.\n",
                                }),
                               ({ player }));
         } else {
            add_failed_mess("You are already related to $I, you can only force "
                            "them to join your family.\n", ({ player }) );
         }
      } else if (player->query_family_name()) {
         if (!force) {
	    if (!CLUB_HANDLER->is_valid_interfamily_relationship(relationship)) {
	       add_failed_mess("$I is in a family already and '" +
                               rel +
			       "' is not a valid interfamily relationship.\n");
	       continue;
	    }
	    family = player->query_family_name();
	    tell_object(player, this_player()->the_short() +
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you.  This will not cause you to change the "
                             "family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() +
                             " as " + rel + "\n");
	 } else {
            if (!CLUB_HANDLER->is_valid_join_family_relationship(relationship)) {
               add_failed_mess("$I is in a family already and the "
                               "relationship '" + rel +
                               "' is not valid to cause them to join "
                               "your family.\n");
               continue;
            }
            family = my_family;
	    tell_object(player, this_player()->the_short() +
                             " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
	 }
         frog = new(class family_response_data);
         frog->family = family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                     this_player(),
                                     frog);
         ok++;
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      } else {
         tell_object(player, this_player()->the_short() + " offers to setup "
                             "a relationship of " + rel + " with "
                             "you in the family " + my_family + ".  WARNING! "
                             "This "
                             "will cause you to join the family.\n" +
                             "This will setup the relationships of: " +
                             show_relationship(this_player(), player,
                                               relationship, player) + "\n" +
                             "To accept the offer type:\n"
                             "accept relationship from " +
                             this_player()->query_name() + " to " +
                             my_family + " as " + rel + "\n");
         frog = new(class family_response_data);
         frog->family = my_family;
         frog->relationship = relationship;
         player->add_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                     this_player(),
                                     frog);
         ok++;
         add_succeeded_mess(({
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\nThis will setup the "
                            "relationships of: " +
                            show_relationship(this_player(), player,
                                              relationship, this_player()) + "\n",
                            "$N offer$s to setup a relationship of " +
                            rel + " with $I.\n",
                             }),
                            ({ player }));
      }
   }
   return ok;
}
string show_relationship(object from, object to, string rel, object telling) {
   string opp;
   string from_arg;
   string to_arg;
   opp = CLUB_HANDLER->query_opposite_relationship(rel);
   if (from == telling) {
      from_arg = "are";
   } else {
      from_arg = "is";
   }
   if (to == telling) {
      to_arg = "are";
   } else {
      to_arg = "is";
   }
   return from->the_short() + " " + from_arg + " the " +
          CLUB_HANDLER->query_relationship_gender(rel, from->query_female()) +
          " of " + to->the_short() + " and " +
          to->the_short() + " " + to_arg + " the " +
          CLUB_HANDLER->query_relationship_gender(opp, to->query_female()) +
          " of " + from->the_short() + ".";
}
int list_relationships() {
   string *relationships;
   relationships = CLUB_HANDLER->query_all_relationships();
   relationships = map(sort_array(relationships, 1), (: capitalize($1) :));
   printf("The currently allowed relationships are:\n   %-=*s\n",
          this_player()->query_cols() - 4,
          query_multiple_short(relationships) + ".");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'relationship'> with <indirect:player:here>",
                (: do_relationship($4[0], $1, 0) :),
             "<string'relationship'> with <indirect:player:here> and join family",
                (: do_relationship($4[0], $1, 1) :),
             "list",
               (: list_relationships() :) });
}

==================================================
FILE: player/rem_ote.c
==================================================

#include <library.h>
#include <player.h>
#include <network.h>
#define TELL_REPLY_LOCK_ID "lock fluff"
inherit "/cmds/base";
mixed cmd( object *obs, string words ) {
   object other;
   object *ok;
   object *ignoring;
   object *roleplaying;
   object *net_dead;
   object *fail;
   object *earmuffed;
   object *multiple_earmuffed;
   object *update_list;
   string* prop;
   string me_name;
   string tmp;
   string pad = " ";
   string* ok_string;
   int colour;
   if ( this_player()->query_role_playing() ) {
      add_failed_mess( "You cannot use remotes when you are role playing.\n" );
      return -1;
   }
   if ( this_player()->check_earmuffs( "remote" ) ) {
      if (this_player()->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         if (sizeof(filter(obs, (: !this_player()->is_friend($1->query_name()) :)))) {
            add_failed_mess("One of the people you are trying to remote is not a "
                            "friend (and you have tells earmuffed).\n");
            return -1;
         }
      } else {
         return notify_fail( "You have remote ear muffed.\n" );
      }
   }
   if ( userp( this_player() ) && !this_player()->query_creator() ) {
      if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
            "remote" ) )
         return notify_fail( NOT_ALLOWED );
      if ( environment( this_player() )->query_property( "no remote" ) )
         return 0;
      if ( (int)this_player()->adjust_sp( -REMOTE_COST ) < 0 )
         return notify_fail( NO_POWER );
   }
   ok = ({ });
   ignoring = ({ });
   roleplaying = ({ });
   net_dead = ({ });
   earmuffed = ({ });
   multiple_earmuffed = ({ });
   update_list = ({ });
   if (sizeof(obs) == 0)  {
      prop = this_player()->query_tell_reply_list();
      if (prop)
         obs = map(prop, (: find_player($1) :));
      else  {
         add_failed_mess("No one has told you anything in the last 15 "
                         "minutes.\n");
         return 0;
      }
   }
   if (sizeof(obs) == 1 && obs[0] == this_player()) {
      add_failed_mess("Interesting way of expression emotion, try "
                      "talking to someone else.\n");
      return 0;
   }
   fail = this_player()->query_ignoring(obs);
   if ( sizeof( fail ) )  {
      write( "You are currently ignoring " +
             query_multiple_short(fail) + ", so you ought to leave " +
             (sizeof(fail) > 1 ? "them" : fail[0]->query_objective()) +
             " alone.\n" );
      obs -= fail;
   }
   ok_string = ({ this_player()->query_name() });
   foreach (other in obs) {
      if ( other && other->query_property( "ignoring" ) ) {
         if ( member_array( (string)this_player()->query_name(),
                             other->query_property( "ignoring" ) ) != -1 &&
               !this_player()->query_creator()) {
           ignoring += ({ other });
           other = 0;
         }
      }
      if ( other && other->query_role_playing() &&
          !this_player()->query_creator() ) {
         roleplaying += ({ other });
         other = 0;
      }
      if (other) {
         this_player()->adjust_time_left( -10 );
         if( userp(other) &&
             !interactive( other ) ) {
            net_dead += ({ other });
         } else if( other->check_earmuffs( "remote" ) ) {
            earmuffed += ({ other });
         } else if( other->check_earmuffs( "multiple-remote" ) &&
                    sizeof(obs) > 1) {
            multiple_earmuffed += ({ other });
         } else if (other != this_player()) {
            ok += ({ other });
            ok_string |= ({ other->query_name() });
            prop = other->query_tell_reply_list();
            if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
               if (member_array(this_player()->query_name(), prop) != -1) {
                  other->set_tell_reply_list(prop);
               }
            } else {
               update_list += ({ other });
            }
         }
      }
   }
   update_list->set_tell_reply_list(ok_string);
   if( sizeof( ignoring ) ) {
      write( query_multiple_short(ignoring) +
            ( sizeof( ignoring ) > 1 ? " are":" is" ) +
            " ignoring you and will not have seen your message.\n" );
   }
   if ( sizeof( roleplaying ) ) {
      write( query_multiple_short( roleplaying ) +
            ( sizeof( roleplaying ) > 1 ? " are":" is" ) +
            " currently role playing and will not have seen your message.\n" );
   }
   if( sizeof( earmuffed ) ) {
      write( query_multiple_short( earmuffed ) +
            ( sizeof( earmuffed ) > 1 ? " have":" has" ) +
            " remotes earmuffed and will not have seen your message.\n" );
   }
   if (sizeof( multiple_earmuffed)) {
      write( query_multiple_short( multiple_earmuffed ) +
            ( sizeof( multiple_earmuffed ) > 1 ? " have":" has" ) +
            " multiple-remotes earmuffed and will not have seen your "
            "message.\n" );
   }
   colour = strsrch(words, "%^") != -1;
   words = replace(words, ({"        ", " ",
                              "       ", " ",
                              "      ", " ",
                              "     ", " ",
                              "    ", " ",
                              "   ", " ",
                              "  ", " "}));
   if (colour) {
      words += "%^RESET%^";
   }
   me_name = this_player()->query_short();
   if (this_player()->query_family_name()) {
      me_name += " " + this_player()->query_family_name();
   }
   if (words[0..0] == "'") pad = "";
   if (sizeof(net_dead) || sizeof(ok)) {
     if (sizeof(ok + net_dead) > 1) {
       foreach(other in ok)  {
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                         tmp +
                         "$C$Remotes to " +
                         query_multiple_short(net_dead + ok) + ": " +
                         me_name + pad + words +
                         (colour?"\n" + tmp + "--End of remote--": "") +
                         "%^RESET%^\n");
         other->add_tell_history(me_name + " remotes ", words, 1);
       }
     } else {
       foreach(other in ok)  {
         tmp = other->colour_event("remote", "%^MAGENTA%^");
         other->event_emote(this_player(),
                       tmp + "$C$" + me_name + pad +
                       words +
                       (colour?"\n" + tmp + "--End of remote--": "") +
                       "%^RESET%^\n");
         other->add_tell_history(me_name + " ", words, 1);
       }
     }
     this_player()->add_tell_history("You remote to " +
                                      query_multiple_short(net_dead + ok, "a", 1) +
                                     ": ",
                                     me_name + pad + words, 1);
     write( "You remote to " + query_multiple_short(net_dead + ok) + ": $C$" +
            me_name + pad + words +"%^RESET%^\n" );
   }
   if( sizeof( net_dead ) ) {
      write( query_multiple_short( net_dead ) +
            ( sizeof( net_dead ) > 1 ? " are":" is" ) +
            " netdead and may not have seen your message.\n" );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player> <string>", (: cmd($1, $4[1]) :),
              "reply <string>",
              (: cmd(({ }), $4[0]) :) });
}

==================================================
FILE: player/removeg_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
int do_leave(string group, object member);
mixed cmd(string str) {
  string group;
  object player, *members, member;
  notify_fail("Syntax: removegroup <member>\n");
  player = find_player(str);
  if(!(group = TEAM_HANDLER->query_group(this_player())))
    return notify_fail("You are not a member of a group.\n");
  if(TEAM_HANDLER->query_owner(group) != player)
    return notify_fail("Sorry, you are not the leader of " + group + ".\n");
  if(member_array(player, TEAM_HANDLER->query_members(group)) == -1)
    return notify_fail("Sorry, " + str + " is not a member of " + group +
                       ".\n");
  members = TEAM_HANDLER->query_members( group );
  if ( !members) {
    TEAM_HANDLER->leave_group(group, this_player());
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no members.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  } else if(!(TEAM_HANDLER->query_owner(group))) {
    TEAM_HANDLER->leave_group( group, member );
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no leader.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
    return 1;
  }
  foreach( member in members ) {
    if ( !member )
      continue;
    tell_object(member, player->short()+" is removed from the "
                "group.\n");
  }
  do_leave(group, player);
  return 1;
}
int do_leave(string group, object member) {
   object person;
   if(!TEAM_HANDLER->leave_group(group, member))
      return notify_fail("Ack, something went wrong.\n");
   if ( !sizeof( (object *)TEAM_HANDLER->query_members( group ) ) )
      return 0;
   foreach(person in TEAM_HANDLER->query_members(group)) {
      if(person) {
         member->remove_protector(person);
         person->remove_protector(member);
         member->remove_follower(person);
         person->remove_follower(member);
      }
   }
   return 1;
}

==================================================
FILE: player/resize.c
==================================================

#include <telnet.h>
inherit "/cmds/base";
mixed cmd(string str) {
  printf("%c%c%c", IAC, DO, TELOPT_NAWS);
  write("Okay, resizing your terminal...\n");
  return 1;
}

==================================================
FILE: player/rituals.c
==================================================

#include <spells.h>
inherit "/cmds/base";
int cmd( string words ) {
   string spell, *religious;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   religious = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( sscanf( spells[ spell ][ 0 ], "%*spriest%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*srituals%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*swizard%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*switch%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*sspell%*s" ) == 2 )
         continue;
   }
   if ( !sizeof( religious ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   if ( sizeof( religious ) ) {
      write( "You know the following religious ritual"+
            ( sizeof( religious ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( religious, 1 ), "\n" ) );
   }
   return 1;
}

==================================================
FILE: player/rot13.c
==================================================

inherit "/cmds/base";
string rot13(string str);
int cmd(string str) {
   printf("You rot: \"%s\".\n", rot13(str));
   return 1;
}
string rot13(string str) {
   int i;
   for(i = 0; i < sizeof(str); i++) {
      if(str[i] >= 'A' && str[i] <= 'Z') {
         str[i] = ((13 + str[i] - 'A') % 26) + 'A';
      } else if(str[i] >= 'a' && str[i] <= 'z') {
         str[i] = ((13 + str[i] - 'a') % 26) + 'a';
      } else if(str[i] >= '0' && str[i] <= '9') {
         str[i] = ((5 + str[i] - '0') % 10) + '0';
      }
   }
   return str;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/rpskills.c
==================================================

#include <skills.h>
inherit "/cmds/base";
string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }
    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) ||
              (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero))))
        str += sprintf( "%*'| 's%*'.'-s " + (no_bonus?"\n":"%4s\n"),
              ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ],
              bonus_to_string( (int)this_player()->query_skill_bonus( tp ) ) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         if ((only_leaf || o_l) && (tmp != ""))
           str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
int cmd( string word ) {
   int i;
   string result, *bits;
   mixed *args;
   result = "";
   if ( !"/obj/handlers/playtesters"->query_tester( this_player() ) )
       return 0;
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Proficiency" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Proficiency");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/score.c
==================================================

inherit "/cmds/base";
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <player_handler.h>
#include <clubs.h>
#include <player.h>
#include <nomic_system.h>
#include <tune.h>
#include <skills.h>
#include <combat.h>
#define essify(x,y) (x > 1  ||  x == 0 ? " " y "s" : " " y)
#define LIMIT 150
int score_quests(object ob, int sorted) {
   string *quests;
   mixed *quest_info;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   if(this_player()->query_role_playing()) {
     write("Sorry, you're roleplaying.\n");
     return 1;
   }
   quests = LIBRARY->query_quests( ob->query_name() );
   if ( !sizeof( quests ) ) {
      printf( "You have not completed any quests.\n" );
      return 1;
   }
   quest_info = map(quests, (: ({ QUEST_HANDLER->query_quest_title($1),
                                  QUEST_HANDLER->query_quest_story($1) }) :));
   if (sorted) {
      quest_info = sort_array(quest_info, (: strcmp($1[0], $2[0]) :));
   }
   write( "$P$Quests$P$You have completed the following quests:\n"+
         implode( map_array( map_array( quest_info, (: "     \""+
         $1[0] +"\", in which you "+
         replace( $1[1],
         "was", "were" ) :) ), (: sprintf( $1[ 0 .. 24 ] +"%*-=s",
         $(ob)->query_cols() - 30, $1[ 25 .. ] ) :) ), ",\n" ) +".\n" );
   return 1;
}
int query_verbose(object ob, string verbose)  {
   if (!verbose) {
      return ob->query_verbose("score");
   }
   if (verbose == "verbose") {
      return 1;
   }
   return 0;
}
int score_stats(object ob, string verbose)  {
   string word;
   int stat;
   string ret;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
     write( "You are just a disembodied spirit.  What use does a wispy thing "
            "like you have for a collection of meaningless numbers?\n" );
     return 1;
   }
   if(this_player()->query_role_playing()) {
     ret = "";
     if(stat = (this_player()->query_tmp_str() +
                this_player()->query_bonus_str())) {
       if ( stat > 0 ) {
         ret += "You feel stronger than usual.\n";
       } else {
         ret += "You feel weaker than usual.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_int() +
                   this_player()->query_bonus_int() ) ) {
       if ( stat > 0 ) {
         ret += "You feel smarter than normal.\n";
       } else {
         ret += "You feel less smart than normal.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_con() +
                   this_player()->query_bonus_con() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more healthy than usual.\n";
       } else {
         ret += "You feel a bit sickly.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_dex() +
                   this_player()->query_bonus_dex() ) ) {
       if ( stat > 0 ) {
         ret += "You feel more nimble than usual.\n";
       } else {
         ret += "You feel more clumsy than you normally do.\n";
       }
     }
     if ( stat = ( this_player()->query_tmp_wis() +
                   this_player()->query_bonus_wis() ) ) {
       if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
       } else {
         ret += "You feel a bit vague.\n";
       }
     }
     if ( !strlen( ret ) ) {
       ret += "You feel fine.\n";
     }
     printf( "%s", ret );
   } else {
     word = ( ob->query_weight() / 20 ) +"."+ ( ob->query_weight() % 10 );
     if (query_verbose(ob, verbose))  {
       printf( "%-#*s\n", ob->query_cols(),
               "Constitution ... "+ ob->query_con() +"\n"+
               "Dexterity ...... "+ ob->query_dex() +"\n"+
               "Intelligence ... "+ ob->query_int() +"\n"+
               "Strength ....... "+ ob->query_str() +"\n"+
               "Wisdom ......... "+ ob->query_wis() +"\n"+
               "Height ......... "+ ob->query_height() +" cm\n"+
               "Weight ......... "+ word +"kg\n" );
     } else  {
       printf( "%-#*s\n", ob->query_cols(),
               "Con: "+ ob->query_con() +"\nDex: "+ ob->query_dex() +"\n"+
               "Int: "+ ob->query_int() +"\nStr: "+ ob->query_str() +"\n"+
               "Wis: "+ ob->query_wis() +"\nHgt: "+ ob->query_height() +" cm\n"+
               "Wgt: "+ word +"kg\n" );
     }
   }
   return 1;
}
int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
}
string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are in perfect health";
   case 70..89:
      return "you are slightly wounded";
   case 50..69:
      return "you are moderately wounded";
   case 30..49:
      return "you are seriously wounded";
   case 15..29:
      return "you are critically wounded";
   case 6..14:
      return "you are fatally wounded";
   case 0..5:
      return "you are near death";
   default:
      return "you are broken";
   }
}
string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are full of energy";
   case 70..89:
      return "you are enthusiastic";
   case 50..69:
      return "you are not quite so full of beans";
   case 30..49:
      return "you are weary";
   case 15..29:
      return "you are tired";
   case 6..14:
      return "you are exhausted";
   case 0..5:
      return "you are nearly unconscious";
   default:
      return "you are broken";
   }
}
int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;
   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   if (!total) {
      total = cost;
   }
   return total;
}
string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   xptotal /= sizeof( skills );
   switch( calc_percent( current, xptotal ) ) {
   case 0..20:
      return "you don't think you can learn much at the moment";
   case 21..59:
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100:
      return "if you squeezed it, you could gain some insight";
   case 101..300:
      return "you might be able to learn something new, if you found the right teacher";
   case 301..400:
      return "a small amount could be learned with training";
   case 401..800:
      return "a bit of training might be in order";
   case 801..1200:
      return "you could very well learn something new from training";
   case 1201..1500:
      return "you could benefit from training";
   case 1501..2000:
      return "you feel like training might help";
   case 2001..2500:
      return "you should consider training your skills";
   case 2501..4000:
      return "your skills could be greatly improved with training";
   default:
      return "certainly a hearty training session is in order";
   }
}
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
}
string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
}
string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
}
string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }
   switch ( remaining ) {
   case 0..0:
      return "Death has a special interest in your next appointment";
   case 1..3:
      return "Death is starting to lose patience with you";
   case 4..7:
      return "You and Death are on good terms";
   default:
      return "You have an \"arrangement\" with Death";
   }
}
int score_rp(object me, string verbose) {
  if(query_verbose(me, verbose)) {
    printf( "%s.\n%s and %s.\n%s.\n%s.\n%s.\n%s.\n%s.\n",
            "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ),
            capitalize( find_align_string( me ) ),
            capitalize( find_wimpy_string( me->query_wimpy() ) ),
            "You are "+ me->burden_string() + " and " +
               this_player()->query_temp_str(),
            find_death_string( me->query_max_deaths() - me->query_deaths() ) );
  } else {
    printf( "%s and %s.\n%s.\n",
            capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
            find_gp_string( me->query_gp(), me->query_max_gp() ),
            capitalize( find_xp_string( me->query_xp() ) ) );
  }
  return 1;
}
int score_burden(object me, string verbose) {
  write( sprintf("You are %s (%d%%).\n", me->burden_string(),
          me->query_burden()));
  return 1;
}
int score_normal(object ob, string verbose)  {
   string word;
   string guild_ob;
   string area;
   string* magistrates;
   string* citizens;
   int age, temp1, temp2, temp3, temp4;
   int no_title;
   if ( !this_player()->query_creator() && ob->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   if(ob->query_role_playing())
     return score_rp(ob, verbose);
   if (query_verbose(ob, verbose))  {
      guild_ob = ob->query_guild_ob();
      if (!guild_ob) {
         guild_ob = "/std/guilds/warrior";
         no_title = 1;
      }
      temp1 = ob->query_hp();
      temp2 = ob->query_gp();
      temp3 = (int)LIBRARY->query_quest_points( ob->query_name() );
      temp4 = ob->query_sp();
      printf( "%-=*s", ob->query_cols(), "You have " +
            temp1 + " (" + ob->query_max_hp() + ") hit" +
            essify(temp1, "point") + ", " +
            temp2 + " (" + ob->query_max_gp() + ") guild" +
            essify(temp2, "point") + ", " +
            temp3 + " (" + (int)QUEST_HANDLER->query_total_qp() + ") quest" +
            essify(temp3, "point") + " and " +
            temp4 + " (" + ob->query_max_sp() + ") social" +
            essify( temp4, "point") + ".\n" );
      if ( guild_ob && find_object( guild_ob ) )  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() + " and you are level " +
               (int)ob->query_level() + " in the " +
               (no_title?"Adventurers' Guild":guild_ob->query_short()) +
               ((ob->query_guild_ob() == "/std/guilds/thief" &&
               !(ob->query_guild_data() == 0)) ?
               ", specialised as a " + ob->query_guild_data() : "") +
               "; your overall rating is " + (int)TOP_TEN_HANDLER->
               calculate_rating( ob ) + ".\n" );
      }  else  {
         printf( "%-=*s", ob->query_cols(), "Your current experience is " +
               ob->query_xp() +".\n" );
      }
      temp1 = ob->query_deaths();
      temp2 = ob->query_max_deaths() - temp1;
      printf( "%-=*s", ob->query_cols(), "You have died " +
            temp1 + essify(temp1, "time") + " and can die " +
            temp2 + essify(temp2, "time") + " before you are completely "
            "dead.\n" );
      if ( ob->query_wimpy() )  {
         printf( "Your wimpy is set to %d%%.\n", ob->query_wimpy() );
      } else  {
         printf( "You are in brave mode.\n" );
      }
#ifdef USE_SURRENDER
      if (ob->query_surrender())  {
         printf("You will surrender at %d%% of your maximum hit points.\n",
            ob->query_surrender());
      } else  {
         printf("You won't surrender.\n");
      }
#endif
      printf( "You are %s (%d%%) and %s.\n", ob->burden_string(),
              ob->query_burden(),
               this_player()->query_temp_str());
      word = ob->query_deity();
#ifndef __DISTRIBUTION_LIB__
      if ( stringp( word ) )  {
         printf( "You are %s, worshipping %s.\n", ob->align_string(),
               capitalize( word ) +", "+ (string)DEITY->query_title( word ) );
      } else  {
         printf( "You are %s, worshipping no god.\n", ob->align_string() );
      }
#endif
      citizens = ({ });
      magistrates = ({ });
      word = ob->query_name();
      foreach (area in NOMIC_HANDLER->query_citizenship_areas()) {
         if (NOMIC_HANDLER->is_magistrate_of(area, word)) {
            magistrates += ({ area });
         } else if (NOMIC_HANDLER->is_citizen_of(area, word)) {
            citizens += ({ area });
         }
      }
      if (sizeof(magistrates)) {
          printf("You are a magistrate of: " +
                 query_multiple_short(magistrates) + ".\n");
      }
      if (sizeof(citizens)) {
          printf("You are a citizen of: " +
                 query_multiple_short(citizens) + ".\n");
      }
      if ( ob->query_property( PKER ) )  {
         printf( "You are registered as a player killer.\n" );
      }
      if ( m_sizeof( ob->query_hide_invis() ) )  {
         printf( "%-=*s\n", ob->query_cols(), "You are " +
               query_multiple_short( m_indices( ob->query_hide_invis() ) +
                                     ({ }) ) + "." );
      }
      printf( "%-=*s", ob->query_cols(), (string)ob->extra_score() );
      age = -ob->query_time_on();
      temp3 = ob->query_no_logins();
      word = sprintf("You are %s old and have logged in %d %s.\n",
                     query_time_string(age, -1),
                     temp3, (temp3 == 1 ? "time" : "times"));
      printf("%-=*s", ob->query_cols(), word);
   } else {
      printf( "%-=*s", ob->query_cols(), "Hp: " + ob->query_hp() + "(" +
            ob->query_max_hp() + ")  Gp: " + ob->query_gp() + "(" +
            ob->query_max_gp() + ")  Xp: "+ ob->query_xp() + "\n" );
   }
   return 1;
}
string create_relationship_text( string relationship, mapping data ) {
    string *relatives;
    int size;
    if ( !( relatives = data[ relationship ] ) )
        return "";
    if ( !size = sizeof( relatives ) )
        return "";
    if ( size == 1 ) {
        return capitalize( relatives[0] ) + " is your " +
            relationship;
    }
    return query_multiple_short( map( sort_array( relatives, 1 ),
        (: capitalize( $1 ) :) ) ) + " are your " +
        pluralize( relationship );
}
int get_gender( string name ) {
    int gender;
    gender = PLAYER_HANDLER->test_gender( name );
    if ( gender )
        gender -= 1;
    return gender;
}
int score_relationships( object ob, int verbose ) {
    string txt, family;
    string *sorted;
    class relationship_data *bing;
    mapping grouped;
    family = ob->query_family_name();
    if ( !family || !CLUB_HANDLER->is_family( family ) ) {
        add_failed_mess( "You're not in a family!\n" );
        return 0;
    }
    bing = CLUB_HANDLER->query_relationships( family, ob->query_name() );
    if ( !sizeof( bing ) ) {
        add_failed_mess( "You have no relatives.\n" );
        return 0;
    }
    grouped = unique_mapping( bing,
        (: CLUB_HANDLER->query_relationship_gender(
           CLUB_HANDLER->query_opposite_relationship( $1->relationship ),
           get_gender( $1->related_to ) )  :) );
    grouped = map( grouped, (: map( $2, (: $1->related_to :) ) :) );
    sorted = sort_array( keys( grouped ), 1 );
    txt = implode( map( sorted,
        (: create_relationship_text( $1, $(grouped) ) :) ), ".\n" );
    tell_object( ob, "$P$Relationships$P$" + txt + ".\n" );
    return 1;
}
int score_align( object ob, int verbose ) {
  int upper, lower, middle, align;
  string god, opinion;
  if (ob->query_property( "dead" )) {
     write( "You're dead.  Things such as 'good' and 'evil' are no longer of
      your concern.\n" );
     return 1;
  }
   if( !ob->query_deity() ) {
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
    }
  else {
    god = ob->query_deity();
    align = ob->query_al();
#ifndef __DISTRIBUTION_LIB__
    lower = DEITY->query_al_lower( god );
    upper = DEITY->query_al_upper( god );
    middle = DEITY->query_al_middle( god );
    opinion = "pleased with";
    if( align <= lower - LIMIT || align >= upper + LIMIT )
      opinion = "very angry with";
    if( ( align < lower && align > lower - LIMIT ) ||
        ( align > upper && align < upper + LIMIT ) )
      opinion = "quite annoyed with";
    if( ( align >= lower && align <= lower + LIMIT ) ||
        ( align <= upper && align >= upper - LIMIT ) )
      opinion = "a little concerned about";
    if( align > middle - ( LIMIT / 2 ) && align < middle + ( LIMIT / 2 ) )
      opinion = "very happy with";
    write( "You are " + ob->align_string() + ".  " + capitalize( god ) +
      " is " + opinion + " you.\n" );
#else
    write( "You are " + ob->align_string() + ", and not worried about "
        "the approval of any deity at all.\n" );
#endif
  }
  return 1;
}
int score_fighting( object player, int verbose ) {
    object *attacker_list;
    object *attacker_list_here;
    string ret;
    class tactics tactics;
    attacker_list = player->query_attacker_list() - ({ 0 });
    ret = "";
    if ( attacker_list ) {
       attacker_list_here = filter( attacker_list, (: $1 && living( $1 ) &&
           environment( $1 ) == environment( $(player) ) :) );
       if ( !sizeof( attacker_list ) ) {
           ret += "You are not fighting anything!\n";
       } else {
          attacker_list -= attacker_list_here;
          if (sizeof(attacker_list_here)) {
             ret += "$I$5=You are currently fighting " +
                 query_multiple_short( attacker_list_here ) + " here.\n";
          }
          if (sizeof(attacker_list)) {
             ret += "$I$5=You are currently fighting " +
                 query_multiple_short( attacker_list ) + " (these are "
                 "people you will auto attack on sight).\n" ;
          }
       }
    }
    tactics = (class tactics) this_player()->query_tactics();
    ret += "$I$0=Your current tactics are:\n"
      "   Attitude       :   "+ tactics->attitude +"\n"
      "   Response       :   "+ tactics->response +"\n"
#ifdef USE_SURRENDER
      "   Mercy          :   "+ (tactics->mercy?tactics->mercy:"none") + "\n"
#endif
      "   Focus          :   "+
      (tactics->focus_zone?tactics->focus_zone:"none") + "\n"
#ifdef USE_DISTANCE
      "   Target distance:   "+
      (tactics->ideal_distance?tactics->ideal_distance:"none") + "\n"
#endif
      "   Attack         :   "+ (tactics->attack == "both" ? "both" :
                     (tactics->attack?tactics->attack:"both")) + "\n"
      "   Parry          :   " + (tactics->parry == "both" ? "both" :
                      (tactics->parry?tactics->parry:"both")) + "\n"
      "   Unarmed Parry  :   " + (tactics->parry_unarmed ? "yes" : "no") + "\n";
    write(ret);
    return 1;
}
int score_temperature( object player, int verbose ) {
   return "/cmds/player/temp_erature"->cmd();
}
mixed *query_patterns() {
   return ({
             "quests", (: score_quests(this_player(), 0) :),
             "quests sorted", (: score_quests(this_player(), 1) :),
             "{brief|verbose} stats", (: score_stats(this_player(), $4[0]) :),
             "stats", (: score_stats(this_player(), 0) :),
             "{brief|verbose}", (: score_normal(this_player(), $4[0]) :),
             "relationships", (: score_relationships( this_player(), 0 ) :),
             "temperature", (: score_temperature( this_player(), 0 ) :),
             "burden", (: score_burden( this_player(), 0 ) :),
             "", (: score_normal(this_player(), 0) :),
             "{align|alignment}", (: score_align(this_player(), 0) :),
             "fighting", (: score_fighting( this_player(), 0 ) :) });
}

==================================================
FILE: player/sea_rch.c
==================================================

#include <tasks.h>
#include <player.h>
inherit "/cmds/base";
#define SKILL "other.perception"
#define GP_COST 15
nosave mapping callouts = ([]);
int cmd(string str) {
   if (this_player()->query_specific_gp("other") < GP_COST) {
      add_failed_mess("You are too weary to complete a "
                      "proper search of your surroundings.\n");
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess("Ghosts cannot search!\n");
      return 0;
   }
   if (sizeof(filter(this_player()->query_attacker_list(),
                     (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot search, you are in combat!\n");
      return 0;
   }
   this_player()->adjust_time_left( -ROUND_TIME * 4 );
   if (callouts[this_player()->query_name()]) {
      remove_call_out(callouts[this_player()->query_name()]);
   }
   callouts[this_player()->query_name()] =
      call_out("search_callout", 4*1, this_player(), str);
   this_player()->adjust_gp(-GP_COST);
   write("You start to search around.\n");
   say(this_player()->the_short() + " $V$0=starts,start$V$ to search around.\n");
   return 1;
}
void search_callout(object who, string str) {
   mapping hide_invis;
   int i;
   string *types;
   string* ground;
   mixed see;
   object *found, ob;
   if (who->query_fighting()) {
      write("Oops!  You appear to have entered combat and cannot "
            "finish searching.\n");
      return ;
   }
   if ( function_exists( "do_search", environment( who ) ) ) {
      i = (int)environment( who )->do_search( str );
      switch(i) {
      case 1:
         return;
      case 0:
         if(query_notify_fail())
            write(query_notify_fail());
         return;
      default:
         break;
      }
   }
   if(!str) {
      found = ({ });
      foreach(ob in all_inventory(environment(who))) {
         if(ob->query_visible(who) ||
            ob->query_creator() ||
            pk_assist(this_player(), ob))
           continue;
         hide_invis =  ob->query_hide_invis();
         if(mapp(hide_invis)) {
            types = m_indices( hide_invis );
         } else {
            types = ({});
         }
         if ( !sizeof( types ) ) {
            continue;
         }
         for ( i = 0; i < sizeof( types ); i++ ) {
            if ( hide_invis[ types[ i ] ][ 0 ] == who ) {
               continue;
            }
            see = hide_invis[ types[ i ] ][ 1 ];
            if ( intp( see ) ) {
               see -= random(environment(who)->query_light());
               see /= 2;
               switch(TASKER->perform_task(who, SKILL, see, TM_FREE)) {
               case AWARD:
                  write("%^YELLOW%^"+
                        ({"You feel very perceptive", "You realise "
                             "something new about searching"})[random(2)]+
                             "%^RESET%^.\n");
               case SUCCEED:
                  found += ({ ob });
                  ob->remove_hide_invis(types[i]);
                  break;
               }
               break;
            }
         }
      }
   }
   if(sizeof(found)) {
      write("You search around and find "+query_multiple_short(found)+".\n");
   } else {
      ground = environment(who)->query_default_search_description();
      if (!ground) {
         write( ({
         "You search around for a while, but don't find anything.\n",
         "You scrounge around.  The ground does look interesting, "
            "you decide.\n",
         "You look carefully at everything, but you find nothing.\n",
         "After an intense search, you find nothing.\n" })[ random( 4 ) ] );
      } else {
         write(ground[random(sizeof(ground))]);
      }
   }
   say("$one_short:" + file_name(who) + "$ $V$0=searches,search$V$ around the "
       "place a bit.\n" );
   event(environment(who), "player_search");
   map_delete(callouts, who->query_name());
   return;
}
void interrupt_search(object who) {
   if(callouts[who->query_name()]) {
      remove_call_out(callouts[who->query_name()]);
      tell_object(who, "You stop searching.\n");
      map_delete(callouts, who->query_name());
   }
}
mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :),
             "here", (: cmd(0) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/shields.c
==================================================

#include <armour.h>
#include <combat.h>
inherit "/cmds/base";
string construct_shield_message( object player, int not_self );
int cmd() {
  string mess;
  mess = construct_shield_message(this_player(), 0);
  if( sizeof( mess ) ) {
    tell_object( this_player(), "Arcane protection status:\n" + mess );
  } else {
    tell_object( this_player(), "You do not have any arcane protection.\n" );
  }
  return 1;
}
string construct_shield_message( object player, int not_self ) {
  int i, j;
  string mess;
  mixed *callbacks;
  string *res;
  class armour_callback cb;
  class combat_special cs;
  mess = "";
  callbacks = player->query_armour_callbacks();
  for( i = 0; i < sizeof(callbacks); i++) {
    for(j=0; j < sizeof(callbacks[i]); j++) {
      cb = callbacks[i][j];
      if(cb->callback[0]) {
        res = (cb->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
      }
    }
  }
  callbacks = player->query_specials();
  for(i=0; i<sizeof(callbacks); i++) {
    cs = callbacks[i];
    if(cs->callback[0]) {
      res = (cs->callback[0])->query_arcane_shields(player);
        if(sizeof(res))
          mess += " * $I$+3,+0=$C$" + res[not_self] + "$I$-3,-0=\n";
    }
  }
  return mess;
}
mixed *query_patterns() {
  return ({ "", (: cmd :) });
}

==================================================
FILE: player/spells.c
==================================================

#include <spells.h>
inherit "/cmds/base";
int cmd() {
   string spell, *magic;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   magic = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( !stringp( spells[ spell ][ S_OBJECT ] ) ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*spriest%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*srituals%*s" ) == 2 ) {
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*swizard%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*switch%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ S_OBJECT ], "%*sspell%*s" ) == 2 ) {
         magic += ({ spell });
         continue;
      }
   }
   if ( !sizeof( magic ) ) {
      write( "You don't know any magic spells.\n" );
      return 1;
   }
   if ( sizeof( magic ) ) {
      write( "You know the following magic spell"+
            ( sizeof( magic ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( magic, 1 ), "\n" ) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/splash.c
==================================================

inherit "/cmds/base";
#include <weather.h>
#define TP this_player()
mixed cmd(object *obs) {
    object env, ob;
    string str;
    env = environment(TP);
    if ( !env->query_baths()  &&  (!env->query_water()  ||  !env->query_surface()) ) {
        if ((string)env->query_property("location") == "inside")
            return notify_fail("You must be outside to do that.\n");
        if (!WEATHER->query_raining(env))
            return notify_fail("It must be raining to splash someone.\n");
    }
    foreach(ob in obs) {
        ob->add_effect("/std/effects/other/wetness", 2 + random(4));
        if(ob == this_player())
            continue;
        tell_object(ob, (string)TP->a_short()+" splashes "+
          query_multiple_short(obs - ({ ob }) + ({ "you" }))+".\n");
    }
    str = query_multiple_short(obs);
    write("You splash "+str+".\n");
    say(TP->a_short()+" splashes "+str+".\n", obs);
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:living>",(: cmd($1) :) });
}

==================================================
FILE: player/start.c
==================================================

inherit "/cmds/base";
int clear_starts() {
  write( "Clearing your list of starting positions...\n" );
  this_player()->reset_starts();
  return 1;
}
int list_starts() {
   int z, i;
   string *starts;
   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;
   if ( z == -1 ) {
      write( "Your starting position is " +
             this_player()->query_start_pos()->the_short() + ".\n");
      return 1;
   }
   if ( !z ) {
      write( "Your starting position is "+ starts[ 1 ] +".\n" );
      return 1;
   }
   write( "Your current starting position is "+ starts[ 1 ] +".\n"+
         "You can also choose your starting position from:\n" );
   for ( i = 1; i <= z; i++ )
      write( sprintf( "% 5d: $I$7=%s\n", i, starts[ 2 * i + 1 ] ) );
   write( "Choose a new starting position using: start <number>\n"+
         "To clear your list of starting positions, use: start clear\n" );
   return 1;
}
int set_start( int num ) {
   string *starts;
   int z;
   starts = this_player()->query_starts();
   z = ( sizeof( starts ) - 2 ) / 2;
   if (sizeof(starts) < 2) {
      add_failed_mess("You only have one starting location.\n");
      return 0;
   }
   if (z == 0) {
      add_failed_mess("You have no starting locations to choose from at all.\n");
      return 0;
   }
   if ( ( num < 1 ) || ( num > z ) ) {
      add_failed_mess( "You must choose a number from 1 to "+ z +".\n" );
      return 0;
   }
   num *= 2;
   write( "Your new starting position is "+ starts[ num + 1 ]  +".\n" );
   this_player()->set_start_location(starts[num]);
   return 1;
}
mixed *query_patterns() {
  return ({ "<number>", (: set_start($4[0]) :),
            "clear", (: clear_starts() :),
            "", (: list_starts() :) });
}

==================================================
FILE: player/stop.c
==================================================

inherit "/cmds/base";
int no_okay;
object tmp;
mixed cmd( string word ) {
   object *atts;
   switch( word ) {
      case "debate" :
      case "debating" :
         this_player()->interrupt_debate();
         break;
      case "spell" :
         this_player()->interrupt_spell();
         break;
      case "ritual" :
         this_player()->interrupt_ritual();
         break;
      case "fight" :
      case "fighting" :
         atts = this_player()->query_attacker_list();
         if ( !sizeof( atts ) ) {
            write( "You are not fighting anyone.\n" );
            return 1;
         }
         if ( (int)this_player()->query_hp() < 0 ) {
            write( "You have already died; stopping now is pointless.\n" );
            return 1;
         }
         write( "Stopping fight.  Please wait.\n" );
         call_out( "stop_fight", 5+random(10), this_player() );
         return 1;
      default:
         no_okay = 1;
         cmd( "debate" );
         cmd( "spell" );
         cmd( "ritual" );
         cmd( "fight" );
         no_okay = 0;
   }
   "/cmds/player/sea_rch"->interrupt_search(this_player());
   if ( !no_okay )
      write( "Okay.\n" );
   return 1;
}
void stop_fight( object who ) {
  object *atts, ob;
  if ( !who )
    return;
  atts = who->query_attacker_list();
  atts -= ({ 0 });
  tmp = who;
  if(atts == ({ }))
    return;
  tell_object( who, "You stop fighting "+
               query_multiple_short( map_array( atts,
         (: $1->query_property( "dead" ) ? (string)$1->a_short() + " (dead anyway)" : $1 :) ) ) +".\n" );
  foreach(ob in atts)
    who->stop_fight(ob);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "{debate|debating|spell|ritual|fight|fighting}", (: cmd($4[0]) :) });
}

==================================================
FILE: player/su.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>;
#define TEAM_HANDLER "/obj/handlers/team"
#define TP this_player()
mixed cmd(string str) {
  string from;
  if (!str || str == "")
    return notify_fail("Usage: su <name>\n");
  if ( TP->query_auto_loading() ) {
    printf("You cannot quit yet: your inventory is still being generated.\n" );
    return 1;
  }
  if ( find_object( "/obj/shut" )) {
    write("You cannot su during a reboot.\n");
    return 1;
  }
  if(sizeof(TP->query_attacker_list())) {
    write("You cannot quit while in combat.\n");
    return 1;
  }
  if (TEAM_HANDLER->query_group(this_player()))  {
    "/cmds/player/leaveg_roup"->cmd(0);
  }
  if (environment(this_player()) == find_object("/room/departures"))  {
    write("You can't use su in the departure lounge.\n");
    return 1;
  }
  from = TP->query_name();
  clone_object("/secure/login")->do_su(str);
  seteuid( "Root" );
  if(str == from)
    LOGIN_HANDLER->write_log("Su", TP->query_name(),
                             TP->query_property("guest"), "(to self)");
  else
    LOGIN_HANDLER->write_log("Su", from, TP->query_property("guest"), str);
  return 1;
}
mixed* query_patterns() {
   return ({ "<string'new name'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/t_ell.c
==================================================

#include <drinks.h>
#include <player.h>
#include <language.h>
#define TP this_player()
#define TELL_REPLY_LOCK_ID "lock fluff"
#define CUT_THOUGH_PROPERTY "cut earmuffed tells"
#define FAIL_DONT_ASK 0
#define ASK 1
#define CUT_DONT_ASK 2
inherit "/cmds/base";
inherit "/cmds/speech";
void delayed_tell(string yesno,
                  object * recicipients,
                  string message);
#ifdef USE_SMILEYS
string *two_smileys = ({ ":)", ":(", ":P", ":p", ":b", ";)",
                           ";(", ";P", ";p", ";b", "=)", "=("
                           });
string *three_smileys = ({ ":-)", ":-(", ":-P", ":-p", ":-b",
                             ";-)", ";-(", ";-P", ";-p", ";-b", ":o)", ":o(",
                             ":oP", ":op", ":ob", ";o)", ";o(", ";oP", ";op",
                             ";ob", "=-)", "=-(", "=o)", "=o("
                             });
#endif
int cmd(string arg, mixed thing, int silent) {
  class message mess;
  string words,
    word;
  string them_mess,
    extra;
  string *ok_string;
  string *prop;
  object *obs;
  object *net_dead;
  object *multiple_earmuffed;
  object *cannot_see;
  object *ok;
  object *fail;
  object *earmuffed;
  object *roleplaying;
  mixed busy;
  if (pointerp(thing)) {
    words = arg;
    thing -= ({ 0 });
    if (TP && environment(TP) &&
        function_exists("trap_tell", environment(TP)) &&
        member_array(this_object(), previous_object(-1)) == -1) {
      return (int) environment(TP)->trap_tell(words, thing, 0);
    }
  } else if (!objectp(thing)) {
    if (!arg || sscanf(arg, "%s %s", word, words) != 2) {
      return 0;
    }
    word = lower_case(word);
    word = (string) TP->expand_nickname(word);
    if (sizeof(thing = explode(word, ",")) == 1)
      thing = ({ find_player(word) });
    else {
      thing = map(thing, (: find_player :));
    }
    thing -= ({ 0 });
    if (sizeof(thing) == 0) {
      if (TP->query_creator() && sscanf(word, "%*s@%*s") == 2) {
        "/net/daemon/out_tell"->do_tell(word + " " + words);
        return 1;
      }
      add_failed_mess(capitalize(word) + " is not logged in.\n");
      return 0;
    }
    if (environment(TP)) {
      if (function_exists("trap_tell", environment(TP)) &&
          member_array(this_object(), previous_object(-1)) == -1) {
        return environment(TP)->trap_tell(words, thing, 0);
      }
    }
  } else {
    thing = ({ thing }) - ({ 0 });
    words = arg;
  }
  if (TP->check_earmuffs("tell")) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      fail = filter(thing, (: !TP->is_friend($1->query_name()) &&
                            $1 != this_player() :));
      if (sizeof(fail)) {
        add_failed_mess("One of the people ($I) you "
                        "are trying to tell is not a "
                        "friend (and you have tells earmuffed).\n",
                        fail );
        return -1;
      }
    } else {
      add_failed_mess("You have tells ear muffed.\n");
      return -1;
    }
  }
  if(TP->query_role_playing()) {
    add_failed_mess("You cannot send tells as you are currently "
        "role playing.\n");
    return -1;
  }
  mess = build_message(words, thing, "tell");
  switch(mess->status) {
  case NOT_DISTANCE:
    return add_failed_mess("The language " + capitalize(mess->language) +
                           " is not able to used over a distance.\n");
  case NOT_SPOKEN:
    return add_failed_mess(capitalize(mess->language) +
                           " is not a spoken language.\n");
  case NO_MESSAGE:
    return add_failed_mess("No message given.\n");
  }
  obs = thing - ({ this_player() });
  if (!sizeof(obs)) {
    add_failed_mess("Talking to yourself again.  I don't know.\n");
    return 0;
  }
  if (sizeof(obs) > 20) {
    add_failed_mess("You can only tell up to 20 people a message.\n");
    return 0;
  }
  fail = this_player()->query_ignoring(obs);
  if (sizeof(fail)) {
    write("You are currently ignoring " +
          query_multiple_short(fail, 0, 1, 0, 0) + ", so " +
          (sizeof(fail) > 1 ? " they" : fail[0]->query_pronoun()) +
          " couldn't reply anyway.\n");
    obs -= fail;
    if (!sizeof(obs)) {
      return 1;
    }
  }
  fail = this_player()->query_ignored_by(obs);
  if (sizeof(fail)) {
    if (!this_player()->query_creator()) {
      write("You are currently being ignored by " +
            query_multiple_short(fail, 0, 1, 0, 0) + ", so "
            "you cannot tell them anything.\n");
      obs -= fail;
      if (!sizeof(obs)) {
        return 1;
      }
    } else {
      write("Warning!  " + query_multiple_short(fail, 0, 1, 0, 0) +
            " have you on ignore.\n");
    }
  }
  if (!TP->query_creator() && (TP->adjust_sp(-TELL_COST) < 0)) {
    return notify_fail(NO_POWER);
  }
  net_dead = ({ });
  multiple_earmuffed = ({ });
  earmuffed = ({ });
  ok = ({ });
  roleplaying = ({ });
  cannot_see = ({ });
  if (sizeof(obs) > 1 && this_player()->check_earmuffs("multiple-tell")) {
    add_failed_mess("You cannot do a multiple-tell if you have them "
                    "earmuffed yourself.\n");
    return 0;
  }
  foreach(thing in obs) {
    if (sizeof(obs) > 1 && thing->check_earmuffs("multiple-tell")) {
      multiple_earmuffed += ({ thing });
    } else if (thing->check_earmuffs("tell")) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        write("You cut through the ear muffs of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your ear muffs.\n");
        ok += ({ thing });
      } else {
        earmuffed += ({ thing });
      }
    } else if(thing->query_role_playing()) {
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) == CUT_DONT_ASK) {
        write("You cut through the roleplaying mode of " +
              thing->the_short() + ".\n");
        tell_object(thing, TP->the_short()
                    + " cuts through your roleplaying mode.\n");
        ok += ({ thing });
      } else {
        roleplaying += ({ thing });
      }
    } else if (!this_player()->query_invis() ||
               reference_allowed(this_player(), thing)) {
      ok += ({ thing });
    } else {
      cannot_see += ({ thing });
      ok += ({ thing });
    }
  }
  ok_string = map(ok, (: $1->query_name() :)) +
    ({ this_player()->query_name() });
  switch (mess->type) {
  case "exclaim":
    extra = " to";
    break;
  default:
    extra = "";
    break;
  }
  foreach(thing in ok) {
    them_mess = query_multiple_short(map(ok- ({ thing }),
                                         (: $1->short(0, 0) :)) +
                                     ({ "you"  }), 0, 1, 0, 0);
    if ( interactive( this_player() ) ) {
      thing->event_person_tell(TP, capitalize((string) TP->short(0, 0)) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    else {
      thing->event_person_tell(TP, capitalize( TP->the_short()) +
                               " " + mess->emote + mess->type + "s" + extra +
                               " " + them_mess + ": ",
                               mess->text);
    }
    prop = thing->query_tell_reply_list();
    if (prop && prop[0] == TELL_REPLY_LOCK_ID) {
      if (member_array(TP->query_name(), prop) != -1) {
        thing->set_tell_reply_list(prop);
      }
    } else {
      thing->set_tell_reply_list(ok_string);
    }
    if (!interactive(thing) && userp(thing)) {
      net_dead += ({ thing });
    }
  }
  if (!silent) {
    if (sizeof(net_dead)) {
      write("Warning: " +
            query_multiple_short(map(net_dead, (: $1->query_cap_name() :)), 0,
                                 1, 0, 0) + " " +
            (sizeof(net_dead) > 1 ? "are" : "is") + " net dead.\n");
    }
    if (sizeof(multiple_earmuffed)) {
      write(capitalize(query_multiple_short(multiple_earmuffed, 0, 1, 0, 0)) +
            (sizeof(multiple_earmuffed) > 1 ? " have " : " has ") +
            "multiple tells ear muffed.\n");
    }
    if (sizeof(earmuffed)) {
      write(capitalize(query_multiple_short(earmuffed, 0, 1, 0, 0)) +
            (sizeof(earmuffed) > 1 ? " have " : " has ") +
            "tells ear muffed.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    if (sizeof(roleplaying)) {
      write(capitalize(query_multiple_short(roleplaying, 0, 1, 0, 0)) +
            (sizeof(roleplaying) > 1 ? " are " : " is ") +
            "role playing.\n");
      if (TP->query_creator() &&
          TP->query_property(CUT_THOUGH_PROPERTY) != FAIL_DONT_ASK) {
        write("Cut through ear muffs? (y/n) ");
        input_to((: delayed_tell :), earmuffed, words);
      }
    }
    busy = this_player()->query_busy();
    if (busy == 1) {
      write("Warning! You have your busy flag on.\n");
    } else if (pointerp(busy) && sizeof(ok - busy)) {
      write("Warning! You are currently set as busy with " +
            query_multiple_short(busy, 0, 1, 0, 0) + ".\n");
    }
    if (sizeof(cannot_see)) {
      write("Warning! " + query_multiple_short(cannot_see, 0, 1, 0, 0) +
            " cannot see you and will not be able to respond.\n");
    }
    if (sizeof(ok)) {
      them_mess =
        TP->convert_message(query_multiple_short(map(ok, (:
$1->short(0,0) :)), 0, 1, 1, 0));
      my_mess("You " + mess->emote + mess->type + extra + " " +
              them_mess + ": ", mess->text);
      TP->add_tell_history("You " + mess->emote + mess->type + extra +
                           " " + them_mess + ": ", mess->text);
    } else if (TP->query_creator() && !sizeof(earmuffed)) {
      add_failed_mess("It seems no one was listening.\n");
      return -1;
    }
  }
  TP->adjust_time_left(-5);
  return 1;
}
int reply_cmd(string mess) {
  string *rep;
  object *obs;
  rep = this_player()->query_tell_reply_list();
  if (!rep) {
    add_failed_mess
      ("No one has told you anything in the last 15 minutes.\n");
    return 0;
  }
  obs = map(rep, (: find_living($1) :)) - ({ 0 });
  if (!sizeof(obs)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are currenttly online.\n");
    return 0;
  }
  this_player()->set_tell_reply_list(rep);
  return cmd(mess, obs, 0);
}
int replylock_cmd(string names) {
  string *rest;
  string *rep;
  rep = uniq_array(explode(names, ","));
  rep = map(rep, (: this_player()->expand_nickname($1) :));
  rest = filter(rep, (: $1 && find_player($1) && interactive(find_player($1)) :));
  if(!sizeof(rest)) {
    add_failed_mess("None of " + query_multiple_short(rep, 0, 1, 0, 0) +
                    " are logged in.  You cannot lock onto someone who is "
                    "not here.\n");
    return 0;
  }
  this_player()->set_tell_reply_list(({ TELL_REPLY_LOCK_ID }) + rest);
  add_succeeded_mess(({ "You lock in " +
                          query_multiple_short(rest, 0, 1, 0, 0) +
                          " in your reply list.\n", "" }));
  return 1;
}
int replylockremove_cmd() {
  this_player()->set_tell_reply_list(0);
  add_succeeded_mess(({ "You remove any possible reply locks.\n", "" }));
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player> <string'message'>",
              (: cmd($4[1], $1, 0) :),
              "reply <string'message'>", (: reply_cmd($4[0]) :),
              "replylock <string'names'>", (: replylock_cmd($4[0]) :),
              "replylock remove", (: replylockremove_cmd() :),
              "<string>", (: cmd($4[0], 0, 0) :) });
}
void delayed_tell(string yesno,
                  object * recicipients,
                  string message) {
  object ob,
    *netdead;
  int disappeared;
  if (!(yesno == "yes" || yesno == "y")) {
    write("Ok, tell aborted.\n");
    return;
  }
  netdead = ({ });
  foreach(ob in recicipients) {
    if (!ob) {
      disappeared++;
      recicipients -= ({ ob });
    } else {
      if (!interactive(ob))
        netdead += ({ ob });
      message = replace(message, "%^", " ");
      ob->event_person_tell(TP, capitalize(TP->query_name()) +
                            " cuts through your ear muffs and tells "
                            + query_multiple_short(recicipients -
                                                   ({ ob }) + ({ "you" }), 0,
                                                   1, 0, 0) + ": ", message);
    }
  }
  if (sizeof(netdead))
    write("Warning: " + query_multiple_short(netdead, 0, 1, 0, 0) +
          (sizeof(netdead) > 1 ? " is" : " are") + " net dead.\n");
  if (disappeared)
    write("It seems " + disappeared + " person" +
          (disappeared > 1 ? "s have" : " has")
          + " disappeared.\n");
  if (!sizeof(recicipients)) {
    write("No one wanted to stay around long enough "
          "to hear what you had to say.\n");
    return;
  }
  my_mess("You tell " +
          TP->convert_message(query_multiple_short(recicipients, 0, 1, 0, 0))
          + ": ", message);
  TP->add_tell_history("You cut through earmuffs and tell " +
                       TP->convert_message(capitalize(
                       query_multiple_short(recicipients, 0, 1, 0, 0))) +
                       ": ", message);
  return;
}

==================================================
FILE: player/temp_erature.c
==================================================

#include <weather.h>
#include <clothing.h>
#include <playtesters.h>
#define COMFORTABLE 20
#define ABS(x) (x > 0? x : -x)
string disp_warmth(int, int);
string disp_total(int i);
int cmd(string str) {
  object where, *clothes, item;
  string zone, type, *zones, tmp;
  mixed types;
  int adjustment, correction, temperature, room_temp, *enums, cwarm, ccool;
  where = environment(this_player());
  if(!where)
    return notify_fail("You have no environment.\n");
  if(!where->query_property("location") &&
     environment(where) &&
     environment(where)->query_property("location")) {
    where = environment(where);
  }
  switch(where->query_property("location")) {
  case "outside":
    room_temp = (WEATHER->query_temperature(where) - COMFORTABLE);
    break;
  default:
    room_temp = 0;
  }
  temperature = this_player()->query_personal_temp();
  room_temp += where->query_property("warmth");
  room_temp -= where->query_property("cooling");
  write(sprintf("It's %s here.\n",
         WEATHER->temp_string(room_temp + COMFORTABLE)));
  clothes = filter_array(this_player()->query_wearing(),
                         (: !$1->id("scabbard") &&
                          !$1->id("belt") &&
                          !$1->id("backpack") &&
                          !$1->id("glasses") &&
                          !$1->id("jewellery") :));
  zones = ({ });
  foreach(item in clothes) {
    types = item->query_type();
    if(!arrayp(types)) {
      types = ({ item->query_type() });
    }
    ccool = 0;
    cwarm = 0;
    foreach(type in types) {
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth")) {
          adjustment += item->query_property("warmth");
          cwarm += item->query_property("warmth");
        } else {
          adjustment++;
          cwarm++;
        }
        if(room_temp > 0 && item->query_property("cooling")) {
          adjustment -= item->query_property("cooling");
          ccool += item->query_property("cooling");
        }
      }
    }
    tmp = item->query_name();
    if(cwarm && ccool) {
      write(sprintf("Your %s provide%s %s and %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1),
             disp_warmth(ccool, 0)));
    } else if(cwarm) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(cwarm, 1)));
    } else if(ccool) {
      write(sprintf("Your %s provide%s %s.\n", item->query_short(),
             (tmp[<1] == 's'  &&  tmp[<2 .. <1] != "ss") ? "" : "s",
             disp_warmth(ccool, 0)));
    }
  }
  if(room_temp < 0) {
    adjustment += sizeof(zones);
    if(room_temp + sizeof(zones) > 5)
      adjustment -= (room_temp + sizeof(zones) - 5);
  } else {
    adjustment -= sizeof(zones);
    if(room_temp - sizeof(zones) < -5)
      adjustment -= (room_temp - sizeof(zones) + 5);
  }
  ccool = 0;
  enums = (int *)this_player()->effects_matching("body.wetness");
  if ( sizeof( enums ) ) {
    adjustment -= sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
    ccool = sqrt(sqrt((int)this_player()->arg_of( enums[ 0 ] ))) * 2;
  }
  adjustment += this_player()->query_property("warmth");
  adjustment -= this_player()->query_property("cooling");
  if(temperature > room_temp && room_temp >= 0 || temperature > 5)
    correction -= (temperature / 5) + 5;
  if(temperature < room_temp && room_temp <= 0 || temperature < -5)
    correction -= (temperature / 5) - 5;
  write(sprintf("On balance, you are %s and %s.\n",
         this_player()->query_temp_str(),
         disp_total(to_int((room_temp+adjustment + correction)))));
  return 1;
}
string disp_warmth(int i, int warm) {
  string pos, neg;
  if(warm) {
    pos = " warmth";
    neg = " cooling";
  } else {
    pos = " cooling";
    neg = " warmth";
  }
  switch(i) {
  case -1000..-19: return "an enormous amount of"+neg;
  case -9..-18: return "a lot of"+neg;
  case -8..-4: return "quite a lot of"+neg;
  case -3..-2: return "some"+neg;
  case -1: return "a bit of"+neg;
  case 0: return "no"+pos;
  case 1: return "a bit of"+pos;
  case 2..3: return "some"+pos;
  case 4..8: return "quite a lot of"+pos;
  case 9..18: return "a lot of"+pos;
  default: return "an enormous amount of"+pos;
  }
}
string disp_total(int i) {
  switch(i) {
  case -1000..-51: return "are freezing fast";
  case -50..-21: return "are cooling down quickly";
  case -20..-11: return "are cooling down";
  case -10..-6: return "are cooling down slowly";
  case -5..5: return "will stay pretty much as you are";
  case 6..10: return "are warming up slowly";
  case 11..20: return "are warming up";
  case 21..50: return "are warming up quickly";
  case 51..1000: return "are cooking rapidly";
  default:
    return "broken: " + i + "\n";
  }
}
mixed *query_patterns()  {
   return ({ "", (: cmd("") :) });
}

==================================================
FILE: player/time.c
==================================================

#include <localtime.h>
#include <dst.h>
#include <am_time.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
#include <config.h>
inherit "/cmds/base";
mixed *_timezones;
void show_mud_time();
void create() {
   mixed *time_rubbish;
   time_rubbish = localtime(time());
   _timezones = ({
      "Seattle", - time_rubbish[LT_GMTOFF] + (US_DST * 60 * 60),
      "Toronto", - time_rubbish[LT_GMTOFF] + (3 + CA_DST) * (60 * 60),
     "London", (UK_DST * 60 * 60),
      "Sydney", (10 + AUS_DST) * (60 * 60),
                 });
}
mixed cmd( string word ) {
   mixed *time_rubbish;
   int i;
   string mess;
   time_rubbish = localtime(time());
   mess = "";
   for (i = 0; i < sizeof(_timezones); i += 2) {
      mess += sprintf( "[%s in %-9s]\n", ctime(time() + time_rubbish[LT_GMTOFF] +
                                    _timezones[i + 1]), _timezones[i]);
   }
   if ( this_player()->query_creator() )
      show_mud_time();
   write(mess);
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd :) });
}
void show_mud_time() {
#ifndef __DISTRIBUTION_LIB__
   string mess;
   string day = cap_words(SPECIAL_DAY_HANDLER->query_special_day());
   mess = sprintf( "In Ankh-Morpork, it is %s%s\n", amtime( time() ),
           ( strlen(day) ? ".  Today is "+ day +".": ".") );
   write( mess );
#endif
}

==================================================
FILE: player/title.c
==================================================

inherit "/cmds/base";
#include <player.h>
mixed cmd_list() {
   string* titles;
   if (this_player()->query_player_title()) {
      write("Your player title is currently set to: " +
            this_player()->query_player_title() + ".\n");
   } else {
      write("Your player title is currently not set.\n");
   }
   titles = this_player()->query_all_player_titles();
   write("You can set your player title to one of " +
         query_multiple_short(map(titles, (: capitalize($1) :))) + ".\n");
   return 1;
}
int cmd_set(string title) {
    mixed mess;
   title = lower_case(title);
   if (strlen(title) > 20) {
      add_failed_mess("Your title is too long.\n");
   }
   if (member_array(title,
                    this_player()->query_all_player_titles()) == -1) {
      add_failed_mess("The title '" + title + "' is not valid.\n");
      return 0;
   }
   if (this_player()->query_player_title() &&
       lower_case(this_player()->query_player_title()) == title) {
      add_failed_mess("You already have your player title set to '" + title +
                      "'.\n");
      return 0;
   }
   this_player()->set_player_title(title);
   if ( sizeof( this_player()->query_hide_invis() ) ) {
       mess = ({ "$N set$s $p player title to " + capitalize(title) +
           ".\n", "" });
   }
   else {
       mess = "$N set$s $p player title to " + capitalize(title) +  ".\n";
   }
   add_succeeded_mess(mess);
   return 1;
}
int cmd_reset() {
   if (!this_player()->query_player_title()) {
      add_failed_mess("Your player title is already unset.\n");
      return 0;
   }
   this_player()->set_player_title(0);
   add_succeeded_mess("$N reset$s $p player title.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "<string'title'>", (: cmd_set($4[0]) :),
             "none", (: cmd_reset() :) });
}

==================================================
FILE: player/tu_rn.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  int i;
  mixed * facing;
  if ( !( i = ([ "half right": 1, "right": 2, "rt": 2, "around": 4, "left": 6,
      "lt": 6, "half left": 7 ])[ str ] ) ) {
    return 0;
  }
  facing = TP->query_facing();
  facing[ 0 ] = ( i + facing[ 0 ] ) % 8;
  write( "You reorient yourself with the world.\n" );
  if(TP->query_sneak_level())
    say( TP->one_short(1)+" reorients "+ TP->query_objective() +"self.\n");
  else
    say(TP->one_short() +" reorients "+ TP->query_objective() +"self.\n" );
  TP->set_facing(facing);
  if ( environment(TP) )
    environment(TP)->init();
  return 1;
}
mixed *query_patterns()  {
    return ({ "<string'around, [half] right, [half] left, rt, lt'>",
              (: cmd($4[0]) :) });
}

==================================================
FILE: player/typo.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("TYPO");
   set_use_last_error(0);
}

==================================================
FILE: player/un_alias.c
==================================================

inherit "/cmds/base";
varargs int unalias(string str, object who ) {
    if (!who) who = this_player();
   if (!who->is_alias(str)) {
      add_failed_mess("The alias '" + str +
                      "' does not exist, cannot unalias.\n");
      return 0;
   }
   if (who->remove_player_alias(str)) {
      write("Successfully unaliased '" + str + "'.\n");
      return 1;
   } else {
      add_failed_mess("Unable to unalias '" + str + "'.\n");
      return 0;
   }
}
varargs int unalias_pattern(string filter) {
   mapping aliases;
   string* tmp;
   string* ok;
   string gfilter;
   string bing;
   aliases = this_player()->query_aliases();
   tmp = m_indices(aliases);
   if (regexp(filter,
        "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
      add_failed_mess("Bad pattern to alias.\n");
      return 0;
   }
   if (filter[0] == '*' || filter[0] == '+') {
      add_failed_mess("Cannot start a regular expression with a '*' or '+', "                         "try: '.*' or '.+'.\n");
      return 0;
   }
   gfilter = "^" + filter;
   tmp = filter_array(tmp, (: $1 && regexp($1, $(gfilter)) :));
   ok = ({ });
   foreach (bing in tmp) {
      if (this_player()->remove_player_alias(bing)) {
         ok += ({ bing });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("Successfuly removed the aliases " +
            query_multiple_short(map(ok, (: "'" + $1 + "'" :))) + ".\n");
      return 1;
   }
   add_failed_mess("Unable to remove any of the aliases " +
            query_multiple_short(map(tmp, (: "'" + $1 + "'" :))) + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({
      "pattern <word'alias'>", (: unalias_pattern($4[0]) :),
      "<word'alias'>", (: unalias($4[0]) :),
         });
}

==================================================
FILE: player/unidentify.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
mixed cmd(object *indirect_obs)
{
   object *things;
   things = filter(indirect_obs, (: $1->query_identifier() :));
   if (!sizeof(things))  {
      if (sizeof(indirect_obs) > 1)
         write("You do not have any of those things identified.\n");
      else
         write("You do not have " + indirect_obs[0]->the_short() +
               " identified.\n");
   }
   else  {
      things->set_identifier(0);
      write("You stop identifying " + query_multiple_short(things, "one") +
            ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me'object(s)'>", (: cmd($1) :) });
}

==================================================
FILE: player/unignore.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#define TP this_player()
inherit "/cmds/base";
int cmd(string str) {
  string *ignoring;
  ignoring = TP->query_property("ignoring");
  if(!ignoring)
    ignoring = ({ });
  if(!str)
    return notify_fail("unignore who?\n");
  str = lower_case(TP->expand_nickname(str));
  if(str == "all") {
    TP->remove_property("ignoring");
    write("You are no longer ignoring anyone.\n");
    return 1;
  }
  if(member_array(str, ignoring) == -1) {
    write("You are not ignoring "+str+".\n");
    return 1;
  }
  ignoring = delete(ignoring, member_array(str, ignoring), 1);
  TP->add_property("ignoring", ignoring);
  write(str+" has been removed from your list of ignored players.\n");
  return 1;
}

==================================================
FILE: player/unkeep.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
int cmd( object *obs ) {
   object thing, *success;
   success = ({ });
   foreach (thing in obs)  {
      if (thing->query_keep())  {
         thing->reset_keep();
         success += ({ thing });
      }
   }
   if (!sizeof(success))  {
      write("You are not attempting to keep anything.\n");
   }
   else  {
      write("You will no longer attempt to keep " +
            query_multiple_short(success) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

==================================================
FILE: player/upt_ime.c
==================================================

#include <player.h>
inherit "/cmds/base";
mixed cmd(int brief) {
  mapping u;
  int r;
  string str;
  string output;
  str = "/secure/finger"->time_elapsed_string(uptime());
#ifndef __DISTRIBUTION_LIB__
  output = "A'Tuin has been paddling through space for "+
      str + ".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
  output += "  He (or as it may be, she) has been "
      "performing "+ query_load_average()+".";
#else
  output += mud_name() + " has been up for "+ str +
      ".  The load average is " +
      query_load_average()+".";
  if (brief) {
     write(output + "\n");
     return 1;
  }
#endif
  u = rusage();
#ifndef __DISTRIBUTION_LIB__
  output += sprintf("  This has taken %.2f%% of his (or her) energy and %.2fMB "
                    "of his (or her) mental capacity.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#else
  output += sprintf("  This has taken %.2f%% of the cpu and %.2fMB of "
                    "of memory.  ",
                    ((u["stime"] + u["utime"]) / 10.0) / uptime(),
                    (memory_info() / 1024000.0));
#endif
#ifndef __DISTRIBUTION_LIB__
  r = "/obj/handlers/garbage"->query_next_reboot();
  if (r == -1) {
    output += "It is unknown when he (or she) will be "
      "taking his (or her) next rest.";
  } else if (r < 0 || find_object(OFFLER)) {
    output += "He (or she) will be taking his (or her) next rest "
      "any moment now.";
  } else {
    str = "";
    if(r / (60*60*24)) {
      str += (string) (r / (60*60*24)) + " day";
      str += ((r /(60*60*24)) > 1 ? "s" : "");
    }
    if(r / ((60*60)) % 24) {
      if(str != "") {
        str += " and ";
      }
      str += (string)((r/(60*60))%24);
      str += " hour" + (((r/(60*60))%24) > 1 ? "s" : "");
    } else if(str == "") {
      switch(r/ 60) {
      case 0..7:
        str = "less than 15 minutes";
        break;
      case 8..22:
        str = "about a quarter of an hour";
        break;
      case 23..38:
        str = "about half an hour";
        break;
      case 39..53:
        str = "about three quarters of an hour";
        break;
      default:
        str = "just under an hour";
        break;
      }
    }
    output += "He (or she) will be taking his (or her) next rest "
      "in " + str + ".";
  }
#endif
  write(sprintf("%-=*s\n",
                  (int)this_player()->query_cols(), output));
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd(0) :),
             "{brief|verbose}", (: cmd($4[0] == "brief") :) });
}

==================================================
FILE: player/users.c
==================================================

inherit "/cmds/base";
#include <login_handler.h>
int cmd() {
  int players, logins, login_q, first, creators, total;
  string output, *str, *logins_n;
  object pl;
  str = ({ });
  foreach(pl in users()) {
    if (pl->query_login_ob())
      logins++;
    else {
      str += ({ pl->query_cap_name() });
      if (pl->query_creator())
        creators++;
      else
        players++;
    }
  }
  logins_n = map(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_cap_name() :));
  logins_n = filter(logins_n, (: $1 :));
  logins_n = sort_array(logins_n,
                        (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (login_q > 0) {
    first = 0;
    if (login_q > 1)
      write(sprintf(login_q+" currently queued: %-=*s\n",
                    this_player()->query_cols()-17,
                    implode(logins_n[0..<2], ", ")+" and "+
                    logins_n[<1]));
    else
      write(sprintf("Currently Queued: %-=*s\n",
                    this_player()->query_cols()-19,
                    logins_n[0]));
  }
  output = "There ";
  first = 1;
  if (creators > 0) {
    if (first)
      if (creators == 1)
        output += "is ";
      else
        output += "are ";
    if (creators == 1)
      output += "one creator";
    else
      output += creators +" creators";
    first = 0;
    if (logins - login_q > 0)
      output += ", ";
    else
      if ( !players )
        output += " logged on.\n";
      else
        output += " and ";
  }
  if (logins - login_q > 0) {
    if (first)
      if (logins - login_q == 1)
        output += "is ";
      else
        output += "are ";
    if (logins - login_q == 1)
      output += "one person logging in";
    else
      output += ( logins - login_q ) +" people logging in";
    first = 0;
    if ( !players )
      output += ".\n";
    else
      output += " and ";
  }
  if ( players ) {
    if (first)
      if (players == 1)
        output += "is ";
      else
        output += "are ";
    if (players == 1)
      output += "one player ";
    else
      output += players +" players ";
  }
  total = sizeof(users());
  output += "a total of "+ sizeof(users()) + " people logged on.\n";
  write( output );
  str = filter(str, (: $1 :));
  str = sort_array(str, (: strcmp(lower_case($1), lower_case($2)) :));
  login_q = sizeof(logins_n);
  if (sizeof(str) > 1) {
    this_player()->more_string(sprintf("Currently logged on: %-=*s\n",
                  this_player()->query_cols()-24,
                  implode(str[0..<2], ", ")+" and "+
                  str[<1]), "Who", 1 );
  } else {
    write("Currently logged on: "+str[0]+".\n");
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/verbose.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(string which, string type) {
  string t, disp;
  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types()) {
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    }
    write(disp + "\n");
    return 1;
  }
  if(type == "all") {
    foreach(t in TP->query_verbose_types()) {
      TP->set_verbose(t, which == "verbose");
    }
    write("Ok\n");
    return 1;
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
    return 1;
  } else {
    write("No such option.\n");
    return 1;
  }
}
mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("verbose", $4[0]) :),
            "", (: cmd("verbose", 0) :),
         });
}

==================================================
FILE: player/weigh.c
==================================================

#define MAX_OBJECTS_AT_ONCE   5
string weight_string(int number);
int cmd(object *things, int brief);
string weight_string(int number) {
   number = (number + 4) / 9;
   switch (number) {
      case 0:
         return "uh oh";
      case 1:
         return "half a pound";
      case 2:
         return "a pound";
      case 3:
         return "a pound and a half";
      case 4 .. 14 :
         return query_num((number + 1) / 2) + " pounds";
      case 15 .. 24:
         return "ten pounds";
      case 25 .. 34:
         return "fifteen pounds";
      case 35 .. 149:
         return query_num(((number + 10) / 20) * 10) + " pounds";
      case 150 .. 249:
         return "a hundred pounds";
      case 250 .. 349:
         return "a hundred and fifty pounds";
      case 350 .. 1499:
         return query_num(((number + 100) / 200) * 100) + " pounds";
      case 1500 .. 2499:
         return "a thousand pounds";
      case 2500 .. 2499:
         return "fifteen hundred pounds";
      case 3500 .. 14999:
         return query_num(((number + 1000) / 2000) * 1000) + " pounds";
      case 15000 .. 24999:
         return "ten thousand pounds";
      case 25000 .. 34999:
         return "fifteen thousand pounds";
      default:
         return query_num(((number + 10000) / 20000) * 10000) + " pounds";
   }
}
int cmd(object *things, int brief) {
   int     accuracy;
   int     weight;
   int     total = 0;
   string  results;
   object  thing;
   object *worn;
   object *wearing;
   if (sizeof(things) > MAX_OBJECTS_AT_ONCE)
   {
      return notify_fail("You cannot weigh that many things at once.\n");
   }
   accuracy = 9 + 89 / (1 + this_player()->query_dex());
   results = "";
   wearing = this_player()->query_wearing();
   worn = filter(things, (: member_array($1, $(wearing)) > -1 :));
   things -= worn;
   if (brief)  {
      foreach (thing in things)
         total += thing->query_complete_weight();
   }
   else foreach (thing in things)  {
      results += "You heft " + thing->the_short() +
                 " and guess that " +
        (thing->group_object() ? "they weigh " :
         thing->query_pronoun() + " weighs ");
      weight = thing->query_complete_weight();
      total += weight;
      if (4 * weight > accuracy)  {
         weight = (4 * weight + accuracy) / (2 * accuracy);
         results += "about " + weight_string(weight * accuracy) + ".\n";
      }
      else  {
         results += "less than " + weight_string(accuracy)+ ".\n";
      }
   }
   if (sizeof(worn))  {
      write("You are wearing " + query_multiple_short(worn, "the") +
             ".\n");
   }
   if (sizeof(things))  {
      if (!brief)  {
         write(results);
      }
      if (sizeof(things) > 1  ||  brief)  {
         if (4 * total > accuracy)  {
             total = (4 * total + accuracy) / (2 * accuracy);
             printf("The total weight is about " +
                    weight_string(total * accuracy) + ".\n");
         }
         else  {
             printf("The total weight is less than " +
                    weight_string(accuracy) + ".\n");
         }
      }
      tell_room(environment(this_player()),
                this_player()->one_short() + " hefts " +
                query_multiple_short(things) + (sizeof(things) > 1 ?
                " one at a time to see how much they weigh" :
                " to see how much it weighs" ) + ".\n",
                ({ this_player() }));
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me'item(s)'>", (: cmd($1, 0) :),
             "<indirect:object:me'item(s)'> brief", (: cmd($1, 1) :) });
}

==================================================
FILE: player/wet.c
==================================================

inherit "/cmds/base";
#include <dirs.h>
#define THRESHOLDS ({ 10, 30, 200, 300 })
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define BODY_WET_EFFECT "/std/effects/other/wetness"
mixed cmd(object *things) {
   string results;
   string no_wet_results;
   object thing;
   object* not_wet;
   string wet_mess;
   if (!things) {
      things = all_inventory(this_player()) + ({ this_player() });
   }
   results = "";
   not_wet = ({ });
   no_wet_results = "";
   foreach (thing in things) {
      wet_mess = OBJECT_WET_EFFECT->wet_string(thing);
      if (strlen(wet_mess)) {
         if (thing == this_player()) {
            wet_mess = "are " + wet_mess;
         } else {
            wet_mess = "is " + wet_mess;
         }
      } else {
         wet_mess = BODY_WET_EFFECT->wet_string(thing, thing == this_player());
      }
      if (strlen(wet_mess)) {
         results += "$C$" + thing->the_short(1) + " " + wet_mess + ".\n";
      } else {
         not_wet += ({ thing });
      }
   }
   if (results == "") {
      write(query_multiple_short(not_wet) +
            ((sizeof(not_wet) > 1  ||  not_wet[0] == this_player()) ?
               " are ":" is ") + "not wet.\n");
   } else {
      write(results);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/when.c
==================================================

#include <login.h>
inherit "/cmds/base";
int cmd(string who)   {
   object player;
   int last;
   int caller;
   string* bits;
   string womble;
   int bing;
   bits = explode(who, ",");
   if (sizeof(bits) > 1) {
      bing = 0;
      foreach (womble in bits) {
         if (cmd(womble)) {
            bing = 1;
         }
      }
      return bing;
   }
   caller = this_player()->query_invis();
   who = this_player()->expand_nickname(lower_case(who));
   player = find_player( who );
   if (player &&
       (caller >= player->query_invis() ||
        reference_allowed(player, this_player()))) {
      if ( interactive( player ) ) {
         write( who + " has been on for " +
                   query_time_string(time() - player->query_last_log_on(), -1) +
                   ".\n");
      } else {
         write( who + " is currently net-dead.\n" );
      }
      return 1;
   } else {
      last = PLAYER_HANDLER->test_last(who);
      if ( last < 1 ) {
         return notify_fail( "Cannot find any record of $C$" + who + ".\n" );
      } else   {
         if (time() - last < 30) {
            write(who + " only just logged off.\n");
         } else {
            write(who + " last logged off " +
                  query_time_string(time() - last, -1) +
                  " ago.\n");
         }
         return 1;
      }
   }
}
mixed *query_patterns()   {
   return ({ "<string'player name'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/who.c
==================================================

#include <clubs.h>
#include <playtesters.h>
#include <config.h>
inherit "/cmds/base";
#include <player.h>
string who_string(int width, int cre, int verbose, string name);
string who_line(object ob, int cre, int width);
mapping _nationalities;
void create() {
  string file;
  object ob;
  ::create();
  _nationalities = ([ ]);
  foreach(file in get_dir("/std/nationality
object *filter_users(object *tarr, string name, int no_cres)  {
  string *guilds;
  string guild;
  string start_guild;
  string *domains;
  object *ret_arr;
  object *arr;
  int not_tag;
  name = lower_case(name);
  name = replace(name, ({"assassins", "assassin",
                           "priests", "priest",
                           "thieves",   "thief",
                           "warriors",    "warrior",
                           "witches",   "witch",
                           "wizards",     "wizard",
                           "creators",  "creator",
                           "liaisons", "liaison",
                           "adventurers", "adventurer",
                           "fighters", "warrior",
                           "fighter", "warrior",
                           "killers", "killer",
                           "helpers", "helper",
                           "playtesters", "playtester",
                           "friends", "friend",
                           "families", "family" }));
  guilds = explode(name, "&") - ({ "" });
  if (sizeof(guilds) > 1) {
    arr = filter_users(tarr, guilds[0], no_cres);
    foreach (guild in guilds[1..]) {
      arr &= filter_users(tarr, guild, no_cres);
    }
    return arr;
  }
  guilds = explode(name, ",") - ({ "", 0 });
  domains = "/secure/master"->query_domains();
  ret_arr = ({ });
  foreach (guild in guilds)  {
    start_guild = guild;
    guild = replace(guild, " ", "", "\t", "");
    if (guild[0] == '-') {
       not_tag = 1;
       guild = guild[1..];
    } else {
       not_tag = 0;
    }
    arr = ({ });
    if (guild == "adventurer")  {
      arr += filter(tarr, (: !$1->query_guild_ob()  &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "friend")  {
      arr += filter(tarr, (: !$1->query_login_ob() && this_player()->is_friend($1->query_name()) :));
    } else if (guild == "creator")  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           $1->query_visible(this_player()) :) );
    } else if (guild == "helper") {
      arr += filter( tarr, (: !$1->query_creator() &&
                            $1->query_property( "newbie helper" ) :) );
    } else if (guild == "killer") {
      arr += filter(tarr, (: $1->query_player_killer() &&
                           (!$(no_cres) || !$1->query_creator()) :));
    } else if (guild == "family") {
      arr += filter(tarr, (: $1->query_family_name() :));
    } else if (guild == "playtester") {
      arr += filter(tarr,
                    (: PLAYTESTER_HAND->query_playtester($1->query_name()) :));
    } else if (member_array(guild, domains) > -1)  {
      arr += filter(tarr, (: $1->query_creator()  &&
                           ("/d/"+$(guild)+"/master")->query_member($1->query_name())  &&
                           $1->query_visible(this_player()) :));
    } else if(member_array(guild, keys(_nationalities)) > -1) {
      arr += filter(tarr, (: $1->query_nationality() == $2 :),
                    _nationalities[guild]);
    } else  {
      if (file_size("/std/guilds/" + guild + ".c") > 0)  {
        arr += filter(tarr,
                      (: (!$(no_cres) || !$1->query_creator()) &&
                       stringp($1->query_guild_ob()) &&
                       $1->query_guild_ob() == "/std/guilds/" + $(guild) :));
      } else if (CLUB_HANDLER->is_family(start_guild)) {
        arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1) :));
      } else if (CLUB_HANDLER->is_club(start_guild)) {
        if (!CLUB_HANDLER->query_club_secret(start_guild) ||
            CLUB_HANDLER->is_member_of(start_guild, this_player()->query_name())) {
          arr += filter(tarr, (: CLUB_HANDLER->is_member_of($(start_guild), $1->query_name()) :));
        }
      } else {
        arr += filter(tarr, (: $1->query_deity() == $2 &&
                             (!$(no_cres) || !$1->query_creator()) :),
                      guild);
      }
    }
    if (not_tag) {
       ret_arr |= (tarr - arr);
    } else {
       ret_arr |= arr;
    }
  }
  return ret_arr;
}
int cmd(string str, int verbose)  {
  this_player()->more_string( who_string(this_player()->query_cols(),
                                         this_player()->query_creator(),
                                         verbose,
                                         str),
                              "Who", 1 );
  return 1;
}
string who_string(int width, int cre, int verbose, string name) {
  object *arr;
  int number;
  string tmp;
  string tmp2;
  string prt;
  int x;
  if (name == "here") {
    arr = filter(all_inventory(environment(this_player())), (: userp($1) &&
                                                             $1->query_visible(this_player()) :) );
  } else {
    arr = filter(users(), (: strsrch(file_name($1), "secure/login") == -1 :));
    if (name && sizeof(arr))  {
      arr = filter_users(arr, name, 1);
    }
  }
  number = sizeof(arr);
  if (number == 0)  {
    if (name)  {
      return "There are no guild(s) or members of " + name + " online.\n";
    }
    return "There is no one on " + mud_name() + "?\n";
  }
  prt = sprintf("%|*'-'s\n", width-1, "==========]  " + mud_name() + "  [===========");
  arr = sort_array(arr, (: strcmp($1->query_name(), $2->query_name() ) :) );
  tmp2 = "";
  if(!name && verbose == 0) {
    int i;
#ifndef __DISTRIBUTION_LIB__
    arr = filter_array(arr, (: !$1->query_creator() ||
                             "/d/liaison/master"->query_member($1->query_name()) :) );
#endif
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = (string)arr[i]->query_cap_name();
      if(!tmp) {
        --number;
      } else {
        x = 14;
        if (arr[i]->query_creator()) {
          if ("/secure/master"->query_trustee(arr[i]->query_name())) {
            tmp += " (%^RED%^T";
          } else if("/secure/master"->query_director(arr[i]->query_name())){
            tmp += " (%^RED%^D";
          } else if("/secure/master"->query_senior(arr[i]->query_name())){
            tmp += " (%^RED%^S";
          } else  {
            tmp += " (%^RED%^C";
          }
          x += 16;
          if ( "/d/liaison/master"->query_member(arr[i]->query_name())) {
            tmp += "%^YELLOW%^l";
            x += 10;
          }
          if(this_player()->is_friend(arr[i]->query_name())) {
            tmp += "%^GREEN%^F";
            x += 9;
          }
          tmp += "%^RESET%^)";
        } else if(this_player()->is_friend(arr[i]->query_name())) {
          tmp += " (%^GREEN%^F%^RESET%^)";
          x += 18;
        }
        tmp2 += sprintf("%-" + x + "s ", tmp);
        if((i+1) % (width/15) == 0  && tmp2 != "") {
          prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
          tmp2 = "";
        }
      }
    }
    prt += this_player()->fix_string(" " + tmp2 + "\n", width, 10);
  } else {
    int i;
    for (i = 0; i < sizeof(arr); i++)  {
      tmp = who_line(arr[i], cre, width);
      if ( !tmp )  {
        --number;
      } else  {
        prt += this_player()->fix_string(tmp + "\n", width, 10);
      }
    }
  }
  if ( name == "here" )  {
    if (number == 1)
      tmp = "> You are all by yourself. <";
    else
      tmp = "> There are " + query_num(number, 500) + " people here. <";
  } else if ( name )  {
    tmp = "> There " + (number > 1 ? "are " : "is ") +
      query_num(number, 500) +
      (number > 1 ? " members of" : " member of");
    if (strsrch(name, ",") != -1) {
      tmp += " those guilds on the " + mud_name() + ". <";
    } else {
      tmp += " this guild on the " + mud_name() + ". <";
    }
  } else if (number < 2)  {
    tmp = "> You are all alone on the " + mud_name() + ". <";
  } else  {
    tmp = "> There are " + query_num(number, 500) +
      " mudders on the " + mud_name() + ". <";
  }
  prt += sprintf("%*'-'|s\n", width-1, tmp);
  return prt;
}
string who_line(object ob, int cre, int width)  {
  string s;
  string tmp;
  tmp = ob->query_player_title();
  if (tmp) {
    tmp += " ";
  } else {
    tmp = "";
  }
  s = tmp + ob->query_cap_name();
  if ( !s )  {
    return 0;
  }
  tmp = ob->query_family_name();
  if (tmp) {
    s += " " + tmp;
  }
  if ( "/d/liaison/master"->query_member( (string)ob->query_name() ) )  {
    s += " (%^YELLOW%^Liaison%^RESET%^)";
  }
  if (ob->query_creator()) {
    if ("/secure/master"->query_trustee((string)ob->query_name()))  {
      s += " (%^RED%^Trustee%^RESET%^)";
    } else if("/secure/master"->query_director((string)ob->query_name())){
      s += " (%^RED%^Director%^RESET%^)";
    } else if("/secure/master"->query_senior((string)ob->query_name())) {
      s += " (%^RED%^Senior%^RESET%^)";
    } else  {
      s += " (%^RED%^Creator%^RESET%^)";
    }
    if (ob->query_invis() == 1) {
      s += " (Invisible)";
    } if (ob->query_invis() > 1) {
      s += " (Super Invisible)";
    }
  }
  if (cre)  {
    if ((tmp = (string)ob->query_in_editor()))  {
      s += " (editing: " + tmp + ")";
    }
  }
  if (ob->query_property("guest"))  {
    s += " guest of " + mud_name() + "";
  } else if (tmp = (string)ob->query_gtitle())  {
    s += " " + tmp;
  } else  {
    s += " the Adventurer";
  }
  if (tmp = (string)ob->query_property("player_title"))  {
    s += ", " + tmp;
  }
  tmp = (string)ob->query_title();
  if ( tmp && ( tmp != "" ) )  {
    s += ", " + tmp;
  }
  if ( PLAYTESTER_HAND->query_playtester( ob->query_name() ) ) {
    if ( PLAYTESTER_HAND->query_senior_playtester( ob->query_name() ) ) {
      s += ", (%^BOLD%^%^CYAN%^Senior Playtester%^RESET%^)";
    }
    else {
      s += ", (%^CYAN%^Playtester%^RESET%^)";
    }
  }
  if (interactive(ob))  {
    if (query_idle(ob) > 120)  {
      s += " (Idle: " + (query_idle(ob) / 60) + ")";
    }
  }
  return s + "%^RESET%^";
}
mixed *query_patterns() {
  return ({ "", (: cmd(0, 0) :),
              "verbose", (: cmd(0, 1) :),
              "here", (: cmd("here", 1) :),
              "<string'guild|liaisons|creators|killers|helpers|playtesters|friends|families|nationality'>", (: cmd( $4[0], 0 ) :) });
}

==================================================
FILE: player/whoami.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd() {
  write( "You are "+ (string)( DIR_PLAYER_CMDS +"/who" )->
         who_line(this_player(), this_player()->query_creator(),
                  this_player()->query_cols(), 1) +".\n" );
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/whois.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd(object *obs) {
  write("That is " + (string)(DIR_PLAYER_CMDS +"/who")->
        who_line(this_player()->expand_nickname(obs[0]),
                 this_player()->query_creator(),
                 this_player()->query_cols()) +".\n" );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1) :),
            this_player()->query_name(), (: cmd(({this_player()})) :) });
}

==================================================
FILE: player/xyzzy.c
==================================================

#include <command.h>
inherit "/cmds/base";
mixed cmd() {
   write("Nothing happens.\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/group_cmds/assist.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_assist( object member, string group );
int do_unassist( object member, string group );
int do_assist_list(string group);
void create() {
   ::create();
   add_group_sub_command( "assist", "<indirect:living'member'>",
      (: do_assist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "unassist", "<indirect:distant-living'member'>",
      (: do_unassist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "assist", "list",
      (: do_assist_list( $6 ) :) );
   set_membership_required( "assist", 0, 1 );
}
int do_assist_list( string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( sizeof( assisting ) )
   {
      tell_object( this_player(), "You are currently "
         "assisting " + query_multiple_short( assisting ) +
         ".\n" );
      return 1;
   }
   add_failed_mess("You are not assisting anyone.\n");
   return 0;
}
int do_assist( object member, string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( !GROUP->is_member( group, member ) ) {
      add_failed_mess( member->the_short() + " is not a "
         "member of your group.\n" );
      return 0;
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      add_failed_mess( "You are already assisting " + member->the_short() +
         ".\n" );
      return 0;
   }
   if( sizeof( assisting ) >= MAX_PEOPLE_YOU_CAN_ASSIST ) {
      add_failed_mess( "You can not assist any more people.\n" );
      return 0;
   }
   add_succeeded_mess( "$N begin$s keeping a close eye on $I.\n",
                       ({ member }) );
   member->add_assister( this_player() );
   return 1;
}
int do_unassist( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      member->remove_assister( this_player() );
      add_succeeded_mess( ({ "You stop assisting " + member->the_short() +
         ".\n", "" }) );
      return 1;
   }
   add_failed_mess("You are not assisting $I.\n", ({ member }));
   return 0;
}
string query_help_string_for( string sub ) {
   return "With this command you can guard a group member.  If the "
      "person you're guarding gets attacked, you will automatically "
      "join the fight after a delay.  The length of the delay depends "
      "on how many people you're guarding at the moment.  Use "
      "\"list\" to see who you are currently assisting.  To stop "
      "assisting someone, use \"group assist <someone>\" again "
      "on that person.\n";
}

==================================================
FILE: player/group_cmds/base_group.c
==================================================

#define GROUP_ARRAY_SIZE      3
#define GROUP_ARRAY_FUNCTION  0
#define GROUP_ARRAY_MEM_REQ   1
#define GROUP_ARRAY_LDR_REQ   2
mapping _commands;
void create() {
   _commands = ([ ]);
}
int query_group_sub_command_amount() {
   return sizeof( _commands );
}
int add_group_sub_command( string verb, string pattern,
   function cmd_function ) {
   if( !_commands[ verb ] ) {
      _commands += ([ verb : ([ pattern : ({ cmd_function, 0, 0 }) ]) ]);
      return 1;
   }
   if( _commands[ verb ][ pattern ] ) {
      return 0;
   }
   _commands[ verb ] += ([ pattern : ({ cmd_function, 0, 0 }) ]);
   return 1;
}
varargs int remove_group_sub_command( string verb, string pattern ) {
   if( undefinedp( pattern ) ) {
      if( !_commands[ verb ] ) {
         return 0;
      }
      map_delete( _commands, verb );
      return 1;
   }
   if( !_commands[ verb ] || !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   map_delete( _commands[ verb ], pattern );
   return 1;
}
string *query_group_sub_command_verbs() {
   return keys( _commands );
}
string *query_group_sub_command_patterns( string verb ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   return keys( _commands[ verb ] );
}
varargs function *query_group_sub_command_function( string verb, string
   pattern ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( undefinedp( pattern ) ) {
      return values( _commands[ verb ] );
   }
   if( !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_FUNCTION ];
}
int set_membership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_MEM_REQ ] = flag;
   }
   return 1;
}
int set_leadership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_LDR_REQ ] = flag;
   }
   return 1;
}
varargs int query_membership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_MEM_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ];
}
varargs int query_leadership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_LDR_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ];
}

==================================================
FILE: player/group_cmds/create.c
==================================================

#include <group_handler.h>
#include <player_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_create( string name );
void create() {
   ::create();
   add_group_sub_command( "create", "<string'name'>", (: do_create( $4[ 0 ] ) :) );
}
int do_create( string name ) {
   string short;
   name = strip_colours(name);
   if( this_player()->query_group() ) {
      return notify_fail( "You are already a member of " +
         this_player()->query_group() + ".\n" );
   }
   if( GROUP->is_group( name ) ) {
      return notify_fail( "Such a group already exists.\n" );
   }
   short = name;
   name = GROUP->short_to_name( short );
   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }
   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }
   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   if( !GROUP->create_group( name, this_player() ) ) {
      return notify_fail( "You failed to create the group.\n" );
   }
   GROUP->set_group_short( name, short );
   this_player()->add_succeeded_mess( this_object(), "$N begin$s "
      "an adventuring group.\n" );
   GROUP->add_member( name, this_player() );
   GROUP->set_leader( name, this_player() );
   return 1;
}
string query_help_string_for( string sub_command ) {
   if( sub_command != "create" ) {
      return 0;
   }
   return "This sub-command creates a new group and sets you as the "
      "leader of it.  You create it by typing \"group create <name>\" "
      "with <name> being the name of your group.";
}

==================================================
FILE: player/group_cmds/emote.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_emote( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "emote", "<string'message'>",
      (: do_group_emote( $4[ 0 ], $6 ) :) );
   set_membership_required( "emote", 0, 1 );
}
int do_group_emote( string message, string group ) {
   message = replace( message, ({ "%^", "", }) );
   GROUP->notify_group( group, this_player(), ({
      "You emote: " + this_player()->query_cap_name() + " " + message,
      this_player()->query_cap_name() + " " + message
      }) );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to emote on the group "
      "channel.";
}

==================================================
FILE: player/group_cmds/follow.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_follow( object *who, string group, int unfollow );
void create() {
   ::create();
   add_group_sub_command( "follow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 0 ) :) );
   add_group_sub_command( "unfollow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 1 ) :) );
   set_membership_required( "follow", 0, 1 );
   set_membership_required( "unfollow", 0, 1 );
}
int do_group_follow( object *who, string group, int unfollow ) {
   int size;
   string fault_message;
   object *what_not, *follow, *already_following;
   fault_message = "";
   who -= ({ 0 });
   if( member_array( this_player(), who ) != -1 ) {
      who -= ({ this_player() });
      fault_message += "You cannot follow yourself.  ";
   }
   follow = ( who & GROUP->members_of( group ) );
   what_not = who - follow;
   switch( unfollow ) {
      case 1:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) == -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are not following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      case 0:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) != -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are already following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      default:
         printf( "Barf.\n" );
   }
   size = sizeof( what_not );
   if( size ) {
      fault_message += "$C$" + query_multiple_short( what_not, "the" ) +
         ( size > 1 ? " are not members of your group" :
         " is not a member of your group" ) + ".  ";
   }
   fault_message += "\n";
   if( sizeof( follow ) ) {
      GROUP->handle_group_follow( group, this_player(), follow,
         unfollow, 0 );
      return 1;
   } else {
      tell_object( this_player(), fault_message );
      return 1;
   }
}
string query_help_string_for( string sub ) {
   switch( sub ) {
      case "follow":
         return "This command lets you follow your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
      case "unfollow":
         return "This command lets you stop following your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
   }
   return 0;
}

==================================================
FILE: player/group_cmds/history.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_channel_history();
void create() {
   ::create();
   add_group_sub_command( "history", "", (: do_channel_history() :) );
   set_membership_required( "history", 0, 1 );
}
int do_channel_history() {
   this_player()->display_group_history();
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you recap what has been said on your "
      "group's channel.";
}

==================================================
FILE: player/group_cmds/invite.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_invite( object person, string group );
void create() {
   ::create();
   add_group_sub_command( "invite", "<indirect:living'person'>", (:
      do_invite( $1, $6 ) :) );
   set_membership_required( "invite", 0, 1 );
   set_leadership_required( "invite", 0, 1 );
}
int do_invite( object *persons, string group ) {
   object person;
   persons -= ({ this_player() });
   if( !sizeof( persons ) ) {
      return notify_fail( "I would come up with "
         "something witty, but I'm not going to "
         "bother.\n" );
   }
   if( sizeof( persons ) > 1 ) {
      return notify_fail( "You can only invite one person "
         "at a time.\n" );
   }
   person = persons[ 0 ];
   if( sizeof( GROUP->invitations_of( group ) ) >=
      MAX_INVITATIONS_PER_PARTY_AT_ONCE ) {
      return notify_fail( "You can only have a total of " +
         MAX_INVITATIONS_PER_PARTY_AT_ONCE + " invitations pending "
         "at one time.\n" );
   }
   if( GROUP->is_invited( group, person ) ) {
      return notify_fail( person->the_short() + " has "
         "already been invited to your group.\n" );
   }
   if( GROUP->is_member( group, person ) ) {
      return notify_fail( person->the_short() + " is "
         "already a member of your group.\n" );
   }
   if( !userp( person ) ) {
      return notify_fail( "You cannot invite " + person->the_short() +
         " to your group.\n" );
   }
   GROUP->add_invite( group, person );
   GROUP->notify_group( group, this_player(), person->query_cap_name() +
      " has been invited by " + this_player()->query_cap_name() + ".  " );
   tell_object( person, "You have been invited by " +
      this_player()->a_short() + " to join " +
      this_player()->query_possessive() + " group.  "
      "You have " + INVITE_TIMEOUT + " seconds to join "
      "the group before the invitation is withdrawn.  Use "
      "\"group join " + this_player()->query_name() + "\" "
      "to join.\n" );
   if( person->query_group() ) {
      tell_object( person, "%^BOLD%^Note that accepting the invitation "
         "will force you to leave your current group.%^RESET%^\n" );
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "With this command the leader of a group can invite new "
      "members to the group.  A person who has been invited must then "
      "use the \"join\" command to actually become a member.";
}

==================================================
FILE: player/group_cmds/join.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_join( object member );
void create() {
   ::create();
   add_group_sub_command( "join", "<indirect:living'existing member'>",
      (: do_join( $1[ 0 ] ) :) );
}
int do_join( object member ) {
   string his_group, my_group;
   his_group = member->query_group();
   if( this_player() == member ) {
      return notify_fail( "I could come up with something witty, "
         "but I'm not going to bother.\n" );
   }
   if( !his_group ) {
      return notify_fail( member->the_short() + " is not a member "
         "of any group.\n" );
   }
   if( !GROUP->is_invited( his_group, this_player() ) ) {
      return notify_fail( "You have not been invited to that "
         "group.\n" );
   }
   if( sizeof( GROUP->members_of( his_group ) ) >= MAX_PEOPLE_PER_PARTY ) {
      return notify_fail( "The group you are trying to join is "
         "full.\n" );
   }
   my_group = this_player()->query_group();
   if( my_group && ( my_group == his_group ) ) {
      return notify_fail( "You are already a member of "
         "that group.\n" );
   }
   if( my_group ) {
      if( !GROUP->remove_member( my_group, this_player() ) ) {
         return notify_fail( "You fail to leave your previous "
            "group.. for some reason.\n" );
      }
      tell_object( this_player(), "%^BOLD%^You leave your current "
         "group behind to join a new one.%^RESET%^\n" );
   }
   if( !GROUP->add_member( his_group, this_player() ) ) {
      return notify_fail( "You failed to join the group "
         "for some weird reason.\n" );
   }
   return 1;
}
string query_help_string_for( string sub_command ) {
   switch( sub_command ) {
      case "join":
         return "This command lets you join an existing group.  To join, "
            "type \"group join <existing member>\" where "
            "<existing member> is someone who is already a member of the "
            "group you wish to be a part of.  You must be invited to a "
            "group by its leader before you can join.";
      default:
         return 0;
   }
}

==================================================
FILE: player/group_cmds/kick.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_kick_member( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "kick", "<indirect:any-living'member'>",
      (: do_kick_member( $1[ 0 ], $6 ) :) );
   set_membership_required( "kick", 0, 1 );
   set_leadership_required( "kick", 0, 1 );
}
int do_kick_member( object member, string group ) {
   if( this_player() == member ) {
      this_player()->new_parser(
         "skick " + this_player()->query_name() );
      return 1;
   }
   if( !GROUP->is_member( group, member ) ) {
      return notify_fail( member->the_short() + " is not a member "
         "of your group.\n" );
   }
   GROUP->notify_group( group, this_player(), ({
      "You kick " + member->query_cap_name() + " from your ranks.",
      this_player()->query_cap_name() + " has kicked " +
      member->the_short() + " from the group." }) );
   GROUP->remove_member( group, member );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you boot out offending members in "
      "your group.";
}

==================================================
FILE: player/group_cmds/leader.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_leader( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "leader", "<indirect:any-living'member'>",
      (: do_leader( $1[ 0 ], $6 ) :) );
   set_membership_required( "leader", 0, 1 );
   set_leadership_required( "leader", 0, 1 );
}
int do_leader( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Oh, good thinking, sparky.\n" );
   }
   if( member->query_group() != group ) {
      return notify_fail( member->the_short(1) + " is not in your "
         "group.\n" );
   }
   GROUP->set_leader( group, member, this_player() );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to relinquish command and "
      "appoint a new leader for the group.  It does not remove "
      "your membership of the group, but you lose all special "
      "privileges granted to leaders.";
}

==================================================
FILE: player/group_cmds/leave.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_leave( string group );
void create() {
   ::create();
   add_group_sub_command( "leave", "", (: do_leave( $6 ) :) );
   set_membership_required( "leave", 0, 1 );
}
int do_leave( string group ) {
   if( !GROUP->remove_member( this_player()->query_group(),
      this_player() ) ) {
      return notify_fail( "You failed to leave the group "
         "for some odd-ball reason.\n" );
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to leave your current "
      "group.  If you're the leader, a new one will be "
      "chosen at random from the remaining members.";
}

==================================================
FILE: player/group_cmds/list.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
string *leader_adjectives =
   ({
      "daring",
      "heroic",
      "brave",
      "bold",
      "courageous",
      "dauntless",
      "fearless",
      "intrepid",
      "valiant",
      "awesome",
      "stalwart"
   });
string *follower_messages =
   ({
      " and also includes",
      " and features such prominent figures as",
      ", whose supporters consist of",
      " and features such renowned names as",
   });
int do_list_groups(string person);
void create() {
   ::create();
   add_group_sub_command( "list", "", (: do_list_groups(0) :) );
   add_group_sub_command( "list", "[with] <string'player'>",
                           (: do_list_groups($4[0]) :) );
}
int do_list_groups(string person) {
   string group, *groups, prefix, suffix, message, adjective, colour, stats;
   object *members, leader;
   int num_groups, num_members;
   object person_ob;
   groups = sort_array( GROUP->query_groups(),
       (: strcmp( lower_case(GROUP->query_group_short( $1 )),
            lower_case(GROUP->query_group_short( $2 )) ) :) );
   num_groups = sizeof( groups );
   if (person) {
      person = this_player()->expand_nickname(person);
      person_ob = find_player(person);
      if (!person_ob) {
         add_failed_mess("Sorry, " + person + " is not logged on.\n");
         return 0;
      }
   }
   if( !num_groups )
   {
      return notify_fail( "There are currently no active groups.\n" );
   }
   prefix = "$I$+8,+0=  + ";
   suffix = "$I$-8,-0=\n";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   message = "";
   num_members = 0;
   num_groups = 0;
   foreach( group in groups )
   {
      leader = GROUP->leader_of( group );
      members = GROUP->members_of( group );
      if( !leader || !sizeof( members ) )
      {
         continue;
      }
      if (!person_ob || person_ob == leader ||
          member_array(person_ob, members) != -1) {
         num_members += sizeof( members );
         message += prefix;
         message += colour + GROUP->query_group_short( group ) +
            "%^RESET%^ is led by ";
         members -= ({ leader });
         adjective = leader_adjectives[ random( sizeof(
                                                       leader_adjectives ) ) ];
         message += "the " + adjective + " %^BOLD%^" +
            leader->query_short(1) + "%^RESET%^";
         if( sizeof( members ) )
         {
            message += follower_messages[ random( sizeof( follower_messages )
               ) ] + " %^BOLD%^" + query_multiple_short( members->short(1) ) +
               "%^RESET%^.";
         }
         else
         {
            message += " and has no other members.";
         }
         message += suffix;
         num_groups++;
      }
   }
   switch( num_groups )
   {
      case 0:
         if (!person) {
            stats = "There are currently no groups, ";
         } else {
            add_failed_mess("There are no groups with " + person +
                            " in them.\n");
            return 0;
         }
         break;
      case 1:
         stats = "There is currently %^BOLD%^one%^RESET%^ active group, ";
         break;
      default:
         stats = "There are currently %^BOLD%^" + query_num( num_groups ) +
            "%^RESET%^ active groups, ";
         break;
   }
   stats += "with a total number of %^BOLD%^" +
      query_num( num_members ) + "%^RESET%^ persons:\n";
   tell_object( this_player(), stats + message );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you list all currently active "
      "groups and their members and leaders.";
}

==================================================
FILE: player/group_cmds/rename.c
==================================================

#include <group_handler.h>
#include <player_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_rename_group( object member, string group );
void create() {
   ::create();
   add_group_sub_command( "rename", "<string'new name'>",
      (: do_rename_group( $4[ 0 ], $6 ) :) );
   set_membership_required( "rename", 0, 1 );
   set_leadership_required( "rename", 0, 1 );
}
int do_rename_group( string new_group, string group ) {
   string short;
   string name;
   if( GROUP->is_group( new_group ) ) {
      return notify_fail( new_group + " already exists.\n");
   }
   short = new_group;
   name = GROUP->short_to_name( short );
   if(!sizeof( name ) || !PLAYER_HANDLER->test_valid(name)) {
      return notify_fail( "That is an invalid name for a group.\n" );
   }
   if( sizeof( name ) > MAX_GROUP_NAME_SIZE ) {
      return notify_fail( "That is too long a name for a "
         "group.\n" );
   }
   if( sscanf( name, "%*s%%^^%*s" ) == 2 )
   {
      return notify_fail( "Colour tags are not allowed in group "
         "names.\n" );
   }
   if (!GROUP->rename_group( group, name)) {
      add_failed_mess("Not allowed to rename the group.\n");
      return 0;
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command lets you rename a group to something more "
          "exciting.";
}

==================================================
FILE: player/group_cmds/report.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
#define GROUP_CMD_STATUS  ( GROUP_SUB_CMDS_DIR+"status" )
int do_report( string group );
void create() {
   ::create();
   add_group_sub_command( "report", "", (: do_report( $6 ) :) );
   set_membership_required( "report", 0, 1 );
}
int do_report( string group ) {
   string message;
   message = this_player()->query_cap_name() + " reports that " +
      this_player()->query_pronoun() + " is ";
   message += GROUP_CMD_STATUS->generate_status_message( this_player() );
   GROUP->notify_group( group, this_player(), ({
      "You report:  " + message,
      message
      }) );
   return 1;
}
string query_help_string_for( string sub_command ) {
   return "This command lets you report your current "
      "condition on the group's channel.";
}

==================================================
FILE: player/group_cmds/say.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_say( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "say", "<string'message'>",
      (: do_group_say( $4[ 0 ], $6 ) :) );
   set_membership_required( "say", 0, 1 );
}
int do_group_say( string message, string group ) {
   message = replace( message, ({ "%^", "" }) );
   GROUP->notify_group( group, this_player(),
      this_player()->query_cap_name() + ": " + message );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to say something on "
      "the group's channel.";
}

==================================================
FILE: player/group_cmds/shields.c
==================================================

#include <command.h>
#include <group_handler.h>
#define CMD_SHIELDS ( DIR_PLAYER_CMDS "/shields" )
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_shields( object *members, string group );
void create()
{
   ::create();
   add_group_sub_command( "shields", "", (: do_shields( 0, $6 ) :) );
   add_group_sub_command( "shields", "<indirect:any-living'member'>",
      (: do_shields( $1, $6 ) :) );
   set_membership_required( "shields", 0, 1 );
}
int do_shields( object *suggested_members, string group )
{
   object cmd_shields, member, *members, *check_for;
   string shields, mess, colour;
   cmd_shields = load_object( CMD_SHIELDS );
   if( !cmd_shields )
   {
      return notify_fail( "Cannot find the \"shield\" command.  "
         "Please bug report this group command.\n" );
   }
   check_for = members = GROUP->members_of( group );
   if( sizeof( suggested_members ) )
   {
      check_for = ( suggested_members & members );
   }
   if( !sizeof( check_for ) )
   {
      return notify_fail( "$C$" + query_multiple_short( suggested_members ) +
         ( sizeof( suggested_members ) > 1 ? " are not members " : " is not "
         "a member " ) + "of your group.\n" );
   }
   mess = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   foreach( member in check_for )
   {
		 if(!member)
			 continue;
		 shields = cmd_shields->construct_shield_message( member, 1 );
		 if( sizeof( shields ) ) {
         mess += "Arcane protection for " + colour +
					 member->query_cap_name() + "%^RESET%^:-\n";
         mess += shields + "\n";
		 } else {
			 mess += colour + member->query_cap_name() +
				 "%^RESET%^ has no arcane protection.\n\n";
		 }
   }
   if( sizeof( mess ) > 2 && mess[ sizeof( mess ) - 1 ] == '\n' )
   {
      mess = mess[ 0..( sizeof( mess ) - 2 ) ];
   }
   tell_object( this_player(), mess );
   return 1;
}
string query_help_string_for( string what )
{
   return "The \"group shields\" command allows you to view "
      "the arcane protection of all or some of your group's "
      "members.  You can either specify no arguments, or "
      "you can include the names of only those members "
      "whose protection you wish to check.\n";
}

==================================================
FILE: player/group_cmds/status.c
==================================================

#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_status( string verbose, string group );
int display_verbose_group_status( string group );
int display_brief_group_status( string group );
string calc_idle_string( object player );
string generate_status_message( object player );
string convert_percentage_to_colour( int percentage );
string convert_percentage_to_hp_message( int percentage );
string convert_percentage_to_gp_message( int percentage );
void create() {
   ::create();
   add_group_sub_command( "status", "<word'brief|verbose'>",
      (: do_group_status( $4[ 0 ], $6 ) :) );
   add_group_sub_command( "status", "",
      (: do_group_status( "default", $6 ) :) );
   set_membership_required( "status", 0, 1 );
}
int do_group_status( string verbose, string group ) {
   int use_verbose;
   switch( verbose ) {
      case "default":
         use_verbose = this_player()->query_verbose( "score" );
         break;
      case "verbose":
         use_verbose = 1;
         break;
      case "brief":
         use_verbose = 0;
         break;
      default:
         return notify_fail( "[ERROR]: Unknown return value from verbose information.\n" );
   }
   switch( use_verbose ) {
      case 1:
         return display_verbose_group_status( group );
      case 0:
         return display_brief_group_status( group );
      default:
         return notify_fail( "[ERROR]: This shouldn't happen.\n" );
   }
}
int display_verbose_group_status( string group ) {
   int size, cols;
   object member, *members, *assisting;
   string pronoun, message, status, short, colour, idle;
   cols = this_player()->query_cols();
   short = GROUP->query_group_short( group );
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   message = "\n";
   message += sprintf( "   %'+'*|s\n", cols - 3, "|" + short + "|" );
   size = sizeof( message ) - 3;
   message = replace( message, ({ short, ( colour + short +
      "%^RESET%^" ) }) );
   message += "\n";
   message += sprintf( "%' '*|s\n",
      cols - 3,
      "The group was started on " +
         ctime( GROUP->query_start_time( group ) ) + "." );
   message += "\n";
   members = GROUP->members_of( group );
   message += sprintf( "   %-=*s\n\n",
      size, "The group has %^BOLD%^" + query_num( sizeof( members ) ) +
      "%^RESET%^ " + ( sizeof( members ) > 1 ? "members" : "member" ) +
      ":" );
   if (!members) {
      message += "Very unhappy group.\n";
   } else {
      foreach( member in members ) {
          if(!member)
             continue;
          status = "$I$+8,+0=   " + colour;
          status += capitalize( member->query_cap_name() ) + "%^RESET%^" +
             " is " + generate_status_message( member ) + "  ";
          pronoun = member->query_pronoun();
          idle = calc_idle_string( member );
          if( idle ) {
             status += "  %^BOLD%^" + idle + ".%^RESET%^";
          }
          if( member == GROUP->leader_of( group ) ) {
             status += "  " + capitalize( pronoun ) + " is the " +
                colour + "current leader%^RESET%^ of the group.";
          }
          assisting = member->query_assisting();
          if( sizeof( assisting ) ) {
             status += "  " + capitalize( pronoun ) + " is assisting " +
                query_multiple_short( assisting, "one", 0, 1 ) + ".";
          }
          status += "$I$-8,-0=\n";
          message += status;
      }
   }
   tell_object( this_player(), message );
   return 1;
}
int display_brief_group_status( string group ) {
   object member, *others;
   string message, colour, idle;
   int my_gp, my_hp, my_max_hp, my_max_gp;
   message = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   others = GROUP->members_of( group ) - ({ this_player() });
   my_hp = this_player()->query_hp();
   my_gp = this_player()->query_gp();
   my_max_hp = this_player()->query_max_hp();
   my_max_gp = this_player()->query_max_gp();
   message += colour;
   message += capitalize( this_player()->query_cap_name() );
   message += "%^RESET%^; Hp: " + convert_percentage_to_colour( my_hp * 100 / my_max_hp ) +
      my_hp + "/" + my_max_hp + "%^RESET%^ Gp: " +
      convert_percentage_to_colour( my_gp * 100 / my_max_gp ) +
      my_gp + "/" + my_max_gp + "%^RESET%^.\n";
   foreach( member in others ) {
     if(!member)
       continue;
      message += colour;
      message += capitalize( member->query_cap_name() );
      message += "%^RESET%^ is " + generate_status_message( member );
      idle = calc_idle_string( member );
      if( idle ) {
         message += "  (" + idle + ")";
      }
      if( member == GROUP->leader_of( group ) ) {
         message += " (" + colour + "L%^RESET%^)";
      }
      if( member->query_property( "dead" ) ) {
         message += " (%^BOLD%^%^RED%^D%^RESET%^)";
      }
      message += "\n";
   }
   tell_object( this_player(), message );
   return 1;
}
string calc_idle_string( object player ) {
   int idle;
   if( !interactive( player ) ) {
      return "Net Dead";
   }
   idle = query_idle( player );
   if( idle < 15 ) {
      return 0;
   }
   return "Idle: " + ( idle / 60 ) + ":" + sprintf("%'0'2d", ( idle % 60 ));
}
string generate_status_message( object player ) {
   int hp_percentage, gp_percentage;
   hp_percentage = player->query_hp() * 100 / player->query_max_hp();
   gp_percentage = player->query_gp() * 100 / player->query_max_gp();
   return (
      convert_percentage_to_colour( hp_percentage ) +
      convert_percentage_to_hp_message( hp_percentage ) +
      "%^RESET%^ and " +
      convert_percentage_to_colour( gp_percentage ) +
      convert_percentage_to_gp_message( gp_percentage ) +
      "%^RESET%^." );
}
string query_help_string_for( string sub_command ) {
   return "The status sub-command displays vital statistics "
      "of your group's members.  Depending on your brief "
      "settings for \"score\", the command will either "
      "show the verbose statistics or prompt a brief "
      "display.  You can also force either version by "
      "adding the argument \"verbose\" or \"brief\".";
}
string convert_percentage_to_colour( int percentage ) {
   switch( percentage ) {
      case -1000..10: return "%^BOLD%^%^RED%^";
      case 11..20:    return "%^RED%^";
      case 21..30:    return "%^ORANGE%^";
      case 31..40:    return "%^YELLOW%^";
      case 41..50:    return "%^MAGENTA%^";
      case 51..60:    return "%^CYAN%^";
      case 61..70:    return "%^BOLD%^%^CYAN%^";
      case 71..80:    return "%^GREEN%^";
      case 81..90:    return "%^BOLD%^%^GREEN%^";
      case 91..100:   return "%^BOLD%^%^WHITE%^";
      default:        return "";
   }
}
string convert_percentage_to_hp_message( int percentage ) {
   switch( percentage ) {
      case -1000..0: return "perfectly healthy, for a ghost";
      case 1..5:     return "near death";
      case 6..10:    return "critically wounded";
      case 11..20:   return "seriously wounded";
      case 21..30:   return "heavily wounded";
      case 31..40:   return "badly wounded";
      case 41..50:   return "wounded";
      case 51..60:   return "slightly wounded";
      case 61..70:   return "injured";
      case 71..80:   return "slightly injured";
      case 81..89:   return "slightly hurt";
      case 90..94:   return "scratched";
      case 95..99:   return "almost unhurt";
      case 100:      return "unhurt";
      default:       return "ERROR";
   }
}
string convert_percentage_to_gp_message( int percentage ) {
   switch( percentage ) {
      case 0..10:    return "near unconscious";
      case 11..20:   return "severely fatigued";
      case 21..30:   return "highly fatigued";
      case 31..40:   return "very fatigued";
      case 41..50:   return "fatigued";
      case 51..60:   return "slightly fatigued";
      case 61..70:   return "confused";
      case 71..80:   return "slightly confused";
      case 81..90:   return "concentrated";
      case 91..99:   return "clear of mind";
      case 100:      return "refreshed";
      default:       return "ERROR";
   }
}
string convert_percentage_to_share_message( int percentage ) {
   switch( percentage ) {
      case 100:       return "all";
      case 95..99:    return "almost all";
      case 90..94:    return "a very large portion";
      case 80..89:    return "a large portion";
      case 70..79:    return "a major portion";
      case 60..69:    return "an above average portion";
      case 52..59:    return "a slightly above average portion";
      case 49..51:    return "an average portion";
      case 41..48:    return "a slightly below average portion";
      case 31..40:    return "a below average portion";
      case 21..30:    return "a minor portion";
      case 11..20:    return "a small portion";
      case 6..10:     return "a very small portion";
      case 1..5:      return "a miniscule portion";
      case 0:         return "next to none";
      default:        return "an ERRONEOUS portion ";
   }
}

==================================================
FILE: guild-race/gp.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_nroff_file("gp");
   set_command_name("gp");
}
int cmd() {
   int i, gp, max_gp, other_gp;
   gp = (int)this_player()->query_gp();
   max_gp = (int)this_player()->query_max_gp();
   write( "You have "+ gp +" ("+ max_gp +") guild points.\n" );
   for ( i = 0; i < sizeof( STD_SKILLS ); i += SKILL_ARR_SIZE ) {
      other_gp = (int)this_player()->query_skill_bonus( STD_SKILLS[ i ]
            +".points" ) + 50;
      if ( other_gp >= max_gp ) {
         write( "* All of your guild points can be used for "+
               STD_SKILLS[ i ] +" commands.\n" );
         continue;
      }
      if ( gp + other_gp <= max_gp ) {
         write( "* You cannot use any guild points for "+
               STD_SKILLS[ i ] +" commands until\n    your points "+
               "reach "+ ( max_gp - other_gp ) +".\n" );
         continue;
      }
      write( "* You can use "+ ( gp + other_gp - max_gp ) +" ("+ other_gp +
            ") for "+ STD_SKILLS[ i ] +" commands.\n" );
   }
   return 1;
}

==================================================
FILE: guild-race/newb_ie.c
==================================================

#include <player.h>
#include <language.h>
#include <cmds/options.h>
#include <newbiehelpers.h>
#define HIST "/obj/handlers/hist_handler"
#define SPAM_PROPERTY "newbie_tell"
#define TIME_OUT     30
#define TIME  0
#define WORDS 1
inherit "/cmds/guild_base";
inherit "/cmds/speech";
int newbie_history(object who);
void create() {
   ::create();
   set_nroff_file("newbie");
   set_command_name("newbie");
}
int cmd( string words ) {
   mixed *array;
   if (words == "history") {
      return newbie_history(this_player());
   }
   if ( this_player()->query_mature() &&
        !this_player()->query_creator() &&
        !this_player()->query_property( "newbie helper" ) &&
        !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      write( "You are no longer a newbie, being older than " + MATURITY +
             " hours.\n" );
      this_player()->remove_known_command( "newbie" );
      return 1;
   }
   if ( array = this_player()->query_property( SPAM_PROPERTY ) ) {
     if ( array[ WORDS ] == words ) {
       write( "You only said that a few seconds ago, why not wait for a "
         "response?\n" );
       return 1;
     }
     if ( time() < array[ TIME ] ) {
       write( "You only used the newbie channel a few seconds ago, why not "
         "wait for a response?\n" );
       return 1;
     }
   }
   if (this_player()->query_property("gagged")) {
      write("You are gagged!  You will not be able to use the "
            "newbie channel until a creator removes your gag.\n");
      return 1;
   }
   if(this_player()->query_property(SHORTHAND_PROP))
     words = LANGUAGES->fix_shorthand(words);
   words = strip_colours (words);
   write( "You newbie-tell: "+ words +"\n" );
   user_event("newbie", this_player()->query_cap_name() + ": "+words);
   HIST->add_chat_history("newbie", this_player()->query_name() +
                          " newbie-told: ", words);
   if (!this_player()->query_creator() &&
       !this_player()->query_property( "newbie helper") &&
       !NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
     this_player()->add_property( SPAM_PROPERTY, ({ time() + 5, words }),
                                  TIME_OUT );
     write( "Please remember: this command is for obtaining assistance; "
            "it is not a chat channel.  If you over use it players "
            "stop listening and you don't get assistance when you "
            "really need it!\n");
   }
   return 1;
}
int newbie_history(object who) {
    mixed *history;
    string result;
    history = HIST->query_chat_history("newbie");
    if ( !arrayp( history ) || !sizeof( history ) ) {
        tell_object(who, "Nothing has been said on the newbie channel.\n");
    }
    else {
        result = "$P$Newbie Channel$P$";
        result += implode(map(history, (: "$I$5=$C$" + $1[0] + $1[1] +
                    "%^RESET%^" :)), "\n");
        tell_object(who, result);
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<string'message'>", (: cmd($4[0]) :),
              "history", (: cmd("history") :) });
}

==================================================
FILE: guild-race/rearrange.c
==================================================

#include <playerinfo.h>
#define ME_CON points[ this_player() ][ "me_con" ]
#define ME_DEX points[ this_player() ][ "me_dex" ]
#define ME_INT points[ this_player() ][ "me_int" ]
#define ME_STR points[ this_player() ][ "me_str" ]
#define ME_WIS points[ this_player() ][ "me_wis" ]
#define POOL points[ this_player() ][ "pool" ]
inherit "/cmds/guild_base";
mapping points = ([ ]);
int cmd();
void create() {
   ::create();
   set_command_name("rearrange");
}
void do_save() {
   int player, here;
   player = this_player()->query_real_con() +
      this_player()->query_real_dex() +
      this_player()->query_real_str() +
      this_player()->query_real_int() +
      this_player()->query_real_wis();
   here = ME_CON + ME_DEX + ME_STR + ME_INT + ME_WIS;
   if (player != here) {
      log_file("BAD_REARRANGE",
         sprintf("%s: %s had %d now has %d\n",
            ctime(time()),
            this_player()->query_name(),
            player, here));
      PLAYERINFO_HANDLER->add_entry(
         this_object(),
         this_player()->query_name(),
         "misc",
         sprintf("rearranged from %d points to %d points", player, here),
         0);
   }
   this_player()->set_con( ME_CON );
   this_player()->set_dex( ME_DEX );
   this_player()->set_int( ME_INT );
   this_player()->set_wis( ME_WIS );
   this_player()->set_str( ME_STR );
   this_player()->remove_known_command( "rearrange" );
   map_delete(points, this_player());
}
void display_stats() {
   printf( "Con: %d Dex: %d Int: %d Str: %d Wis: %d Pool: %d\n",
         ME_CON, ME_DEX, ME_INT, ME_STR, ME_WIS, POOL );
}
int get_stat_bit( string word ) {
   int num;
   string stat;
   word = lower_case( word );
   if ( word == "save" ) {
      if ( POOL ) {
         write( "WARNING: You still have points left in your pool that "
		   "could be used to make your character more powerful. If you "
		   "leave these unspent now, you will not be able to get them again later. "
           "Are you sure you want to save? [y/n] " );
         input_to( "get_check" );
         return 1;
      }
      write( "Saving.\n" );
      do_save();
      return 1;
   }
   if ( word == "quit") {
      write( "Quitting.\n" );
      map_delete(points, this_player());
      return 1;
   }
   if ( word == "reset" ) {
      write( "Resetting to previous arrangement.\n" );
      return cmd();
   }
   if ( sscanf( word, "%s %d", stat, num ) != 2 )
      stat = word;
   if ( !stat || ( stat == "" ) )
      stat = "X";
   if ( num > POOL )
      if ( !POOL ) {
         write( "Cannot add to stat.  Need to add to the pool first.\n" );
         stat = "X";
      } else {
         write( "Pool has only "+ POOL +" points in it.  "+
               "Adding these to stat.\n" );
         num = POOL;
      }
   switch( stat[ 0 ] ) {
      case 'c' :
         if ( ( ME_CON + num ) < 8 ) {
            write( "Cannot set constitution to less than 8.\n" );
         } else
            if ( ( ME_CON + num ) > 23 ) {
               write( "Cannot set constitution to more than 23.\n" );
            } else {
               ME_CON += num;
               POOL -= num;
            }
         break;
      case 'd' :
         if ( ( ME_DEX + num ) < 8 ) {
            write( "Cannot set dexterity to less than 8.\n" );
         } else
            if ( ( ME_DEX + num ) > 23 ) {
               write( "Cannot set dexterity to more than 23.\n" );
            } else {
               ME_DEX += num;
               POOL -= num;
            }
         break;
      case 'i' :
         if ( ( ME_INT + num ) < 8 ) {
            write( "Cannot set intelligence to less than 8.\n" );
         } else
            if ( ( ME_INT + num ) > 23 ) {
               write( "Cannot set intelligence to more than 23.\n" );
            } else {
               ME_INT += num;
               POOL -= num;
            }
         break;
      case 's' :
         if ( ( ME_STR + num ) < 8 ) {
            write( "Cannot set strength to less than 8.\n" );
         } else
            if ( ( ME_STR + num ) > 23 ) {
               write( "Cannot set strength to more than 23.\n" );
            } else {
               ME_STR += num;
               POOL -= num;
            }
         break;
      case 'w' :
         if ( ( ME_WIS + num ) < 8 ) {
            write( "Cannot set wisdom to less than 8.\n" );
         } else
            if ( ( ME_WIS + num ) > 23 ) {
               write( "Cannot set wisdom to more than 23.\n" );
            } else {
               ME_WIS += num;
               POOL -= num;
            }
         break;
      default :
         break;
   }
   display_stats();
   write( "Enter [d|c|i|w|s|save|reset|quit] <num> : " );
   input_to( "get_stat_bit" );
   return 1;
}
int get_check( string word ) {
   word = lower_case( word );
   if ( word[ 0 ] != 'y' ) {
      write( "Going back to stat entering.\n" );
      return get_stat_bit( "" );
   }
   do_save();
   write( "Saving.\n" );
   return 1;
}
int cmd() {
   write( "Rearranging stats.\n\n" );
   points[ this_player() ] = ([ ]);
   ME_CON = (int)this_player()->query_real_con();
   ME_DEX = (int)this_player()->query_real_dex();
   ME_INT = (int)this_player()->query_real_int();
   ME_STR = (int)this_player()->query_real_str();
   ME_WIS = (int)this_player()->query_real_wis();
   POOL = 0;
   if ( ME_CON > 8)  {
      POOL += ME_CON - 8;
      ME_CON = 8;
   }
   if ( ME_DEX > 8) {
      POOL += ME_DEX - 8;
      ME_DEX = 8;
   }
   if ( ME_INT > 8 ) {
      POOL += ME_INT - 8;
      ME_INT = 8;
   }
   if ( ME_STR > 8 ) {
      POOL += ME_STR - 8;
      ME_STR = 8;
   }
   if ( ME_WIS > 8 ) {
      POOL += ME_WIS - 8;
      ME_WIS = 8;
   }
   write( "Type \"c 3\" to add 3 points to your constitution from the pool, "+
         "or \"c -4\" to remove 4 points from constitution and add them to "+
         "the pool.  Use \"save\" to save the current state and quit.  Note "+
         "that \"%^YELLOW%^reset%^RESET%^\" will return you to your "+
         "starting position, while \"%^YELLOW%^quit%^RESET%^\" will quit "+
         "without saving any changes.\n\n" );
   return get_stat_bit( "" );
}
int teach( object thing ) { return 0; }
int clean_up() {
  if (sizeof(points))
    return 1;
  ::clean_up();
}
void reset() {
  if (sizeof(points))
    return;
  ::reset();
}
string query_name()
{
  return "Rearrange Command";
}

==================================================
FILE: guild-race/skills.c
==================================================

#include <skills.h>
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_command_name("skills");
}
string bonus_to_string( int bonus ) {
    if ( bonus < 0 ) {
        return "incompetent";
    }
    switch( bonus ) {
        case 0..50:
            return "novice";
        case 51..100:
            return "apprentice";
        case 101..200:
            return "competent";
        case 201..300:
            return "proficient";
        case 301..350:
            return "skilled";
        case 351..400:
            return "adept";
        case 401..500:
            return "expert";
        default:
            return "master";
    }
}
string level_to_string( int level ) {
    switch( level ) {
        case 0..15:
            return "novice";
        case 16..30:
            return "apprentice";
        case 31..45:
            return "competent";
        case 46..60:
            return "proficient";
        case 61..75:
            return "skilled";
        case 76..85:
            return "adept";
        case 86..95:
            return "expert";
        default:
            return "master";
    }
}
string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf ) {
   int i, sk, o_l, non_zero;
   int no_bonus, rp;
   string str, tp, tmp;
   rp = this_player()->query_role_playing();
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      if (tp[0] == '.') {
         tp = tp[1..];
      }
      sk = (int)this_player()->query_skill( tp );
      non_zero = SKILL_OB->query_only_show_if_non_zero( tp );
      no_bonus = SKILL_OB->query_no_bonus( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) ||
          (!sizeof(args[i+SKILL_BIT]) && (sk > 0 || (all && !non_zero)))) {
        if(rp) {
          str += sprintf( "%*'| 's%*'.'-s %4s\n",
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ),
              args[ i ],
              (no_bonus ? level_to_string(sk) : bonus_to_string( this_player()->query_skill_bonus( tp ) ) ), "" );
        } else {
          str += sprintf( "%*'| 's%*'.'-s %4d " + (no_bonus?"   -\n":"%4d\n"),
                          ( lvl-1 ) * 2, "",
                          20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
                          (int)this_player()->query_skill_bonus( tp ) );
        }
      }
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l );
         if ((only_leaf || o_l) && (tmp != "")) {
           if(rp) {
             str += sprintf( "%*'| 's%*'.'-s          \n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           } else {
             str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                             20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
           }
         } else
           str += tmp;
      }
   }
   return str;
}
int cmd( string word ) {
   int i, rp;
   string result, *bits;
   mixed *args;
   result = "";
   if(this_player()->query_stupid_skills() != 0) {
      write(this_player()->query_stupid_skills());
      return 1;
   }
   rp = this_player()->query_role_playing();
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      if(rp) {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Proficiency" );
      } else {
        result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                          "=======SKILLS=======Level/Bonus" );
      }
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0 ) );
      this_player()->more_string( result, "Skills" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   if(rp) {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Proficiency");
   } else {
     result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
                        "=======SKILLS=======Level/Bonus");
   }
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0 ) );
   this_player()->more_string( result, "Skills" );
   return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
              "<word'skill'>", (: cmd($4[0]) :) });
}

==================================================
FILE: guild-race/crafts/duplicate.c
==================================================

#include <artifacts.h>
#include <move_failures.h>
#define COST 50
#define LEVEL 100
#define SHAPING "crafts.pottery.forming.shaping"
#define SMITHING "crafts.smithing"
#define TURNING "crafts.carpentry.turning"
#define WHITTLING "crafts.carpentry.whittling"
inherit "/cmds/guild_base";
inherit "/std/basic/cute_look";
void create() {
   ::create();
   set_nroff_file("duplicate");
}
int cmd( object* things) {
   int i, bonus;
   object form;
   mapping map;
   for ( i = 0; i < sizeof( things ); i++ ) {
      if ( !function_exists( "query_artifact_type", things[ i ] ) ) {
         write( "You cannot duplicate "+  things[ i ]->the_short() +".\n" );
         continue;
      }
      if ( (int)this_player()->query_specific_gp( "crafts" ) < COST ) {
         write( "You don't have enough guild points to duplicate "+
               things[ i ]->the_short() +".\n" );
         continue;
      }
      switch( (string)things[ i ]->query_artifact_type() ) {
       case "wand" :
         bonus = (int)this_player()->query_skill_bonus( TURNING );
         break;
       default :
         write( "Oops, something went wrong with "+ things[ i ]->the_short() +
               ".  Please contact a creator.\n" );
        continue;
      }
      if ( bonus < LEVEL ) {
         write( "Your skill is insufficient to make a form from "+
               things[ i ]->the_short() +".\n" );
         continue;
      }
      this_player()->adjust_gp( -COST );
      switch ( (string)things[ i ]->query_artifact_type() ) {
       case "wand" :
         form = clone_object( "/obj/weapon" );
         break;
      }
      map = (mapping)things[ i ]->query_static_auto_load();
      if ( !m_sizeof( map ) ) {
         map = (mapping)things[ i ]->int_query_static_auto_load();
         form->init_static_arg( map );
      } else
      form->init_static_arg( map[ "::" ] );
      map = (mapping)things[ i ]->query_dynamic_auto_load();
      form->init_dynamic_arg( map[ "::" ] );
      form->set_enchant( 0 );
      form->set_value_info( "artifact", 0 );
      if ( bonus < LEVEL + random( LEVEL ) )
         form->remove_property( "artifact form" );
      write( "You duplicate a form from "+ things[ i ]->the_short() +".\n" );
      if ( (int)form->move( this_player() ) != MOVE_OK )
         form->move( environment( this_player() ) );
   }
   return 1;
}
mixed *query_pattern() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: guild-race/crafts/fix.c
==================================================

#include <money.h>
#include <tasks.h>
#define TEACH_LEVEL 10
#define LEARN_LEVEL 10
#define SKILL "crafts.smithing.black"
#define SKILLS ({ "crafts.smithing.black.weapons", \
                  "crafts.smithing.black.armour", \
                  "crafts.smithing.black.tools" })
#define A_MAX 5
#define C_MAX 100
#define A_COND 5
#define C_COND 25
#define SCALE 50
#define USE_WEAPON_SKILL 1
#define USE_ARMOUR_SKILL 2
#define USE_TOOL_SKILL 3
inherit "/cmds/guild_base";
int query_item_type( object ob );
int query_fix_cost( object player, object smithy, object item, int costing, int max, int cond, int low );
int test_fixed( object item );
void create() {
   ::create();
   set_nroff_file("fix");
   set_command_name("fix");
   add_teach_skill(SKILL, 10, 10);
}
object find_smithy(object player) {
   if (environment(player)->query_property("smithy")) {
      return environment(player);
   }
   foreach (object ob in all_inventory(player)) {
      if (ob->query_smithy()) {
         return ob;
      }
   }
   return 0;
}
int cmd( object *things, int costing ) {
    int type, bonus, cond, low, max, diff, cost, val, award;
    int new_cost;
    object here, item, fixer;
    string place;
    fixer = this_player();
    here = find_smithy(fixer);
    if ( !here || !here->query_property( "smithy" ) ) {
        add_failed_mess( "You are not in a smithy, so you cannot fix "
            "anything.\n" );
        return 0;
    }
    place = here->query_property( "place" );
    if ( !place || ( place == "" ) )
        place = "default";
    if ( sizeof( things ) > 1 ) {
        add_failed_mess( "You can only fix one thing at a time.\n" );
        return 0;
    }
    item = things[ 0 ];
    type = query_item_type( item );
    if ( !type ) {
      add_failed_mess( "$I is neither armour nor a weapon.\n", things );
      return 0;
    }
    if ( item->query_worn_by() ) {
        add_failed_mess( "You should probably remove $I before making it "
                         "hot and hitting it with a hammer.\n", things );
        return 0;
    }
    if( member_array( "leather", item->query_materials() ) != -1 ) {
      add_failed_mess( "$I would be destroyed if you put it in the fire.\n",
                       things );
      return 0;
    }
    if( member_array( "wool", item->query_materials() ) != -1 ) {
      add_failed_mess( "Putting a woolen item in the fire isn't going "
                       "to improve its condition.\n",
                       things );
      return 0;
    }
    if( item->query_unfixable() ) {
        add_failed_mess( "Sticking $I in a hot forge probably isn't "
            "going to do much for its condition.\n", things );
        return 0;
    }
    bonus = (int)fixer->query_skill_bonus( SKILLS[ type - 1 ] );
    val = (int)fixer->query_value_in( place );
    if ( place != "default" )
        val += (int)fixer->query_value_in( "default" );
    low = (int)item->query_lowest_cond();
    if ( !low )
        low = 1;
    cond = (int)item->query_cond();
    max = (int)item->query_max_cond();
    if ( !max )
        max = 1;
    if ( test_fixed( item ) ) {
        add_failed_mess( "$I is already in top condition.\n", things );
        return 0;
    }
    diff = max - cond;
    cost = query_fix_cost( this_player(), here, item, costing, max, cond, low );
    new_cost = here->generate_cost(cost, 0);
    if (new_cost == -1) {
       return 0;
    }
    if (new_cost) {
       cost = new_cost;
    }
    if ( ( diff > bonus ) && !costing ) {
        diff = ( 150 * diff ) / max;
        switch ( (int)TASKER->perform_task( fixer,
            SKILLS[ type-1 ], diff, TM_COMMAND ) ) {
            case AWARD :
                award = 1;
            case SUCCEED :
                diff = max - cond;
            break;
            default :
                diff = bonus;
        }
    }
    if ( ( val < cost ) &&
         !fixer->query_property( "freelance smith" ) && !costing ) {
        add_failed_mess( "You cannot afford the materials to fix "
            "$I.\n", things );
        return 0;
    }
    if ( costing ) {
      add_succeeded_mess( ({ "To attempt to fix $I, it would probably cost "
        "you about " + MONEY_HAND->money_value_string( cost, place ) +
        ".\n", "" }), things );
        return 1;
    }
    if ( !cond ) {
        add_succeeded_mess( ({ "You begin to work on $I when it breaks!  "
            "It must have been too damaged to fix.\n",
            "$N begin$s to work on $I when it breaks!\n" }), things );
        item->break_me();
        return 1;
    }
    item->adjust_cond( diff );
    if ( !fixer->query_property( "freelance smith" ) ) {
        fixer->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
            place ), place );
        here->generate_cost(cost, 1);
    }
    if ( award ) {
        write( "%^YELLOW%^"+ replace( ({ "As you begin to fix $I, you realise "
            "how to make better use of the materials.", "As you work on $I, "
            "you find that you're able to fix it completely.", "You discover "
            "that you can fix $I more effectively." })[ random( 3 ) ], "$I",
            item->the_short() ) +"%^RESET%^\n" );
    }
    if ( test_fixed( item ) )
        write( "You fix "+ item->the_short() +
        ", bringing it to top condition.\n" );
    else
        write( "You manage to fix "+ item->the_short() +
            " a little, although it's still not in top condition.\n" );
    write( "The repair materials cost you " +
        MONEY_HAND->money_value_string( cost, place ) +".\n" );
    add_succeeded_mess( ({ "", "$N fixes up $I.\n" }), things );
    return 1;
}
int test_fixed( object item ) {
    return ( 100 * item->query_cond() > 98 * item->query_max_cond() );
}
int query_item_type( object ob ) {
    if ( ob->query_weapon() == 1 ) {
        return USE_WEAPON_SKILL;
    }
    if ( ob->query_armour() || ob->query_scabbard() ) {
        return USE_ARMOUR_SKILL;
    }
    if ( ob->query_material() == "metal" ) {
        return USE_TOOL_SKILL;
    }
    return 0;
}
int query_fix_cost( object player, object smithy,
                            object item, int costing, int max, int cond, int low ) {
    int cost, diff, per;
    if ( !max )
        max = item->query_max_cond();
    if ( !cond )
        cond = item->query_cond();
    if ( !low )
        low = item->query_lowest_cond();
    diff = max - cond;
    per = 100 - smithy->query_discount( player );
    if ( per < 0 )
        per = 0;
    cost = ( diff * sqrt( item->query_full_value() ) ) / max;
    cost *= A_MAX + ( C_MAX * ( max - low ) ) / max;
    cost *= A_COND + ( C_COND * ( cond - low ) ) / ( cond + !cond );
    cost /= SCALE;
    if ( costing ) {
        cost *= 2;
    }
    else {
        cost += roll_MdN( 4, cost / 4 );
    }
    cost = ( cost * per ) / 100;
    if ( cost < 100 ) {
        cost = 100;
    }
    return cost;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1, 0) :),
            "cost <indirect:object:me>", (: cmd($1, 1) :) });
}

==================================================
FILE: guild-race/crafts/leatherwork.c
==================================================

#include <money.h>
#include <tasks.h>
#define TEACH_LEVEL 10
#define LEARN_LEVEL 10
#define SKILL "crafts.materials.leatherwork"
#define SKILLS ({ "crafts.materials.leatherwork", \
                  "crafts.materials.needlework" })
#define A_MAX 5
#define C_MAX 100
#define A_COND 5
#define C_COND 25
#define SCALE 50
inherit "/cmds/guild_base";
void create() {
   ::create();
   set_nroff_file("leatherwork");
   add_teach_skill(SKILL, 20, 10);
   set_command_name("leatherwork");
}
int cmd( object *things, int costing ) {
   int bonus, cond, low, max, diff, cost, per, val, award;
   string place;
   if ( !environment( this_player() )->query_property( "leatherwork" )&&
      member_array(1,  (all_inventory(environment(this_player()))->
      query_property("leatherwork"))) == -1 )
      return notify_fail( "You are not in a leatherworking shop, "
            "so you cannot repair anything.\n" );
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) ){
      place = "default";
   }
   if ( sizeof( things ) > 1 )
      return notify_fail( "You can only repair one thing at a time.\n" );
   if (things[0]->query_material() != "leather")
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is not made of leather!  Wrong shop!\n" );
   if ( things[ 0 ]->query_worn_by() )
      return notify_fail( "You should probably remove "+
            (string)things[ 0 ]->the_short() +
            " before you jab yourself with a needle "
            "while trying to patch it up.\n" );
   per = 100 -
    (int)environment( this_player() )->query_discount( this_player() );
   if ( per < 0 )
      per = 0;
   val = (int)this_player()->query_value_in( place );
   if ( place != "default" )
      val += (int)this_player()->query_value_in( "default" );
   low = (int)things[ 0 ]->query_lowest_cond();
   if ( !low )
      low = 1;
   cond = (int)things[ 0 ]->query_cond();
   max = (int)things[ 0 ]->query_max_cond();
   if ( !max )
      max = 1;
   if ( 100 * cond > 98 * max )
      return notify_fail( (string)things[ 0 ]->the_short() +
            " is already in top condition.\n" );
   diff = max - cond;
   if ((100 * diff)/max > 70){
     bonus = (int)this_player()->query_skill_bonus( SKILLS[ 1 ] );
     cost = (( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) /
       (max * 50) + 13);
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[1],
                                          diff, TM_COMMAND ) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the thread to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
      write( "%^YELLOW%^"+ replace( ({ "As you begin to fix $I, you realise "
            "how to make better use of the materials.", "As you work on $I, "
            "you find that you're able to fix it completely.", "You discover "
            "that you can fix $I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "You sew up all the holes in "+ (string)things[ 0 ]->the_short() +
            ", bringing it to top condition.\n" );
   else
      write( "You manage to sew up some of the holes in "+ (string)things[ 0 ]->the_short() +
            " but a few pop back open due to poor stitching.\n" );
   write( "The thread and sinew costs you "+
         (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
         (string)things[ 0 ]->a_short() +".\n" );
   return 1;
  }else{
  bonus = (int)this_player()->query_skill_bonus( SKILLS[ 0 ] );
  cost = ( diff * sqrt( (int)things[ 0 ]->query_full_value() ) ) /
      (max * 3) +123;
   if ( !cond ) {
      write( "You begin to work on "+ (string)things[ 0 ]->the_short() +
            " when it falls apart!  It must have been too damaged to fix.\n" );
      say( (string)this_player()->one_short() +" begins to work on "+
            (string)things[ 0 ]->the_short() +" when it falls to scraps!\n" );
      things[ 0 ]->break_me();
      return 1;
   }
    if ( ( diff > bonus ) && !costing ) {
       diff = ( 150 * diff ) / max;
       switch ( (int)TASKER->perform_task(this_player(), SKILLS[0],
                                          diff, TM_COMMAND) ) {
         case AWARD :
            award = 1;
         case SUCCEED :
            diff = max - cond;
            break;
         default :
            diff = 0;
      }
    }
   if ( ( val < cost ) && !costing )
      return notify_fail( "You cannot afford the leather to repair "+
            (string)things[ 0 ]->the_short() +".\n" );
   if ( costing ) {
      write( "To attempt to repair "+ (string)things[ 0 ]->the_short() +
            ", it would probably cost you about "+
            (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
      return 1;
   }
   things[ 0 ]->adjust_cond( diff );
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( cost,
         place ), place );
   if ( award) {
     write("%^YELLOW%^"+ replace( ({ "As you begin to cut and sew the "
           "leather patches for $I, you realise how to make better use of "
           "the leather.", "As you work on $I, you find that you're able "
           "to repair it completely.", "You discover that you can repair "
           "$I more effectively." })[ random( 3 ) ], "$I",
            (string)things[ 0 ]->the_short() ) +"%^RESET%^\n" );
   }
   if ( 100 * (int)things[ 0 ]->query_cond() > 98 * max )
      write( "Your patching of "+ (string)things[ 0 ]->the_short() +
            " goes quite well, and you bring it to top condition.\n" );
   else
      write( "You manage to create reasonably good patches for "+
             (string)things[ 0 ]->the_short() +
             ", but the size wasn't quite right, and the stitching doesn't "
             "look like it will hold very well.\n" );
   write( "The repair materials cost you "+
          (string)MONEY_HAND->money_value_string( cost, place ) +".\n" );
   say( (string)this_player()->one_short() +" fixes up "+
        (string)things[ 0 ]->a_short() +".\n" );
   return 1;
 }
}
int teach( object thing ) {
   if ( (int)this_player()->query_skill( SKILL ) < TEACH_LEVEL )
      return -1;
   if ( (int)thing->query_skill( SKILL ) < LEARN_LEVEL )
      return -2;
   thing->add_known_command( "leatherwork" );
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1, 0) :),
            "cost <indirect:object:me>", (: cmd($1, 1) :) });
}

==================================================
FILE: guild-race/other/judge.c
==================================================

#include <tasks.h>
#include <weapon.h>
#undef DEBUG
#define COST 25
#define SKILL "other.evaluating.weapons"
#define QUEST_AVE 140
#define QUEST_MAX 300
#define LEARN 5
#define TEACH 50
inherit "/cmds/guild_base";
nosave string *_attack_types = ({ "blunt", "sharp", "pierce" });
nosave string *attacks;
void create() {
    ::create();
    set_nroff_file("judge");
    set_command_name("judge");
    add_teach_skill(SKILL, 50, 5);
}
varargs int *calc_rating( object weapon, object player ) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;
    data = (mixed *)weapon->query_attack_data();
    if ( !( size = sizeof( data ) ) )
        return ({ 0, 0 });
    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
      debug_printf("[%s - ave: %d max: %d]\n", data[ i + W_TYPE],
                   ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100,
                   damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ]);
    }
    debug_printf("[%s - ave: %d max: %d]\n", weapon->short(), ave, max );
    return ({ ave, max });
}
void judge_against( object player, object first, object second ) {
  int grain, rating, rating_1, rating_2, difficulty, margin, *data_1,
    *data_2;
  data_1 = calc_rating( first, player );
  data_2 = calc_rating( second, player );
  difficulty = data_1[ 0 ] - data_2[ 0 ];
    if ( difficulty > 0 )
        difficulty = QUEST_AVE - difficulty;
    else
        difficulty = QUEST_AVE + difficulty;
    margin = ( difficulty + ( difficulty * ( data_1[ 1 ] + data_2[ 1 ] ) ) /
        ( 2 * QUEST_MAX ) ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL, difficulty - 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapons$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to better judge "
                "$weapons$.", "As you inspect $weapons$, you feel a sense "
                "of surety in your judgement." })[ random( 3 ) ], "$weapons$",
                query_multiple_short( ({ first, second }), "the" ) ) +
                "%^RESET%^\n" );
        case SUCCEED:
            break;
        default:
            tell_object( player,
                "You examine "+ query_multiple_short( ({ first, second }),
                    "the" ) + " closely, but you're not sure which is "
                    "better.\n" );
            return;
    }
    grain = sqrt( (int)this_player()->query_skill_bonus( SKILL ) );
    if ( grain > 12 )
        grain = 12;
    rating_1 = QUEST_AVE * data_1[ 1 ] + QUEST_MAX * data_1[ 0 ];
    rating_1 = ( grain * rating_1 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating_2 = QUEST_AVE * data_2[ 1 ] + QUEST_MAX * data_2[ 0 ];
    rating_2 = ( grain * rating_2 + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
    rating = rating_1 - rating_2;
    if ( rating > 0 )
        rating++;
    else
        rating--;
    rating = 6 + rating / 2;
    if ( rating > 12 )
        rating = 12;
    if ( rating < 0 )
        rating = 0;
    if ( rating == 6 ) {
        tell_object( player, "You think that " +
            query_multiple_short( ({ first, second }), "the" ) +
            " are exactly the same.\n" );
        return;
    }
    tell_object( player, "You think that " + first->the_short() +" is "+ ({
         "amazingly worse", "extremely worse", "very much worse",
         "much worse", "worse", "a bit worse", "!", "a bit better",
         "better", "much better", "very much better",
         "extremely better", "amazingly better" })[ rating ] +" than "+
         second->the_short() +".\n" );
}
int judge_weapon( object player, object weapon ) {
    int grain, rating, margin, *data;
    string res;
    data = calc_rating( weapon, player );
    margin = ( data[ 0 ] + ( data[ 0 ] * data[ 1 ] ) / QUEST_MAX ) / 2;
    switch ( TASKER->perform_task(this_player(), SKILL,  data[ 0 ] + 25,
        TM_COMMAND) ) {
        case AWARD:
            tell_object( player,
                "%^YELLOW%^"+ replace( ({ "As you scrutinise $weapon$, you "
                "recognise an aspect of judging that you didn't use before.",
                "You realise something else that you can use to judge "
                "$weapon$.", "As you inspect $weapon$, you feel a sense of "
                "surety in your judgement." })[ random( 3 ) ], "$weapon$",
                weapon->the_short() ) +"%^RESET%^\n" );
    case SUCCEED:
      break;
    default:
      tell_object( player, "You think that " + weapon->the_short() +
                   " is a good weapon, but you're not sure.\n" );
      return 0;
    }
    grain = sqrt( player->query_skill_bonus( SKILL ) / 2 );
    if ( grain > 14 )
      grain = 14;
    rating = QUEST_AVE * data[ 1 ] + QUEST_MAX * data[ 0 ];
    rating = ( grain * rating + QUEST_AVE * QUEST_MAX ) /
      ( 2 * QUEST_AVE * QUEST_MAX );
    rating += 14 - grain;
    if ( rating > 14 ) {
#ifdef DEBUG
      log_file( "BAD_WEAPON", "%s exceeds weapon specifications, rating is "
                "%d.\n", file_name( weapon ), rating );
#endif
      rating = 14;
    }
    attacks = player->query_known_commands();
    attacks = filter(weapon->query_attack_names(),
                  (: (member_array($1, attacks) != -1) :));
    attacks -= ({ "crush" });
    attacks -= ({ "impale" });
    attacks -= ({ "behead" });
    if(member_array("smash", weapon->query_attack_names()) != -1 &&
       member_array("crush", player->query_known_commands()) != -1)
       attacks += ({ "crush" });
    if(member_array("pierce", weapon->query_attack_names()) != -1 &&
       member_array("impale", player->query_known_commands()) != -1)
       attacks += ({ "impale" });
    if(member_array("slice", weapon->query_attack_names()) != -1 &&
       member_array("behead", player->query_known_commands()) != -1)
       attacks += ({ "behead" });
    res = "You think that "+ weapon->the_short() +" is " + ({
      "an atrocius", "an extremely poor", "a very poor", "a rather poor",
        "a poor", "a pretty poor", "a quite poor", "a reasonable",
        "a quite good", "a pretty good", "a good", "a rather good",
        "a very good", "an extremely good", "an excellent" })[ rating ] +
      " weapon";
    debug_printf("attacks: %O", attacks);
    if(sizeof(attacks))
      res += " that can be used to " + query_multiple_short(attacks, "", 0, 1,
                                                            0);
    res += ".\n";
    tell_object(player, res);
    return rating;
}
int valid_weapon( object player, object ob ) {
  if ( living( ob ) ) {
    if ( ob == player ) {
      add_failed_mess( "You stare at your muscles for a moment, "
                       "and decide that you're more than capable of destroying "
                       "any enemy that decides to interfere with you.\n" );
      return 0;
    }
    add_failed_mess( "You stare at $I for a while, but decide it "
                     "would be better if you considered them instead.\n",
                     ({ ob }) );
    return 0;
  }
  if ( !ob->query_weapon() ) {
    add_failed_mess( "$C$$I is not a weapon.\n", ({ ob }) );
    return 0;
  }
  if(environment(ob) != this_player())
    return add_failed_mess("You can't find $I.\n", ({ ob }));
  return 1;
}
int cmd( object first, object second ) {
  object *indirect_obs;
  int cost;
  function judge_func;
  if ( !valid_weapon( this_player(), first ) ) {
    return 0;
  }
  cost = COST;
  if ( second ) {
    if ( !valid_weapon( this_player(), second ) ) {
      return 0;
    }
    cost *= 2;
    indirect_obs = ({ first, second });
    judge_func = (: judge_against :);
  } else {
    indirect_obs = ({ first });
    judge_func = (: judge_weapon :);
  }
  if ( this_player()->query_specific_gp( "other" ) < cost ) {
    add_failed_mess( "You can't muster the energy to scrutinise "
                     "$I at the moment.\n", indirect_obs );
    return 0;
  }
  this_player()->adjust_gp( -cost );
  call_out( judge_func, 0, this_player(), first, second );
  add_succeeded_mess( "$N look$s closely at $I.\n", indirect_obs );
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object'weapon'>", (: cmd( $1[0], 0 ) :),
              "<indirect:object:me'weapon'> against <indirect:object:me'weapon'>",
              (: cmd( $1[0][0], $1[1][0] ) :) });
}

==================================================
FILE: guild-race/other/vurdere.c
==================================================

#include <clothing.h>
#include <weapon.h>
#define COST 5
#define SKILL "other.evaluating.armour"
#define LEARN_LEVEL 2
#define TEACH_LEVEL 10
inherit "/cmds/guild_base";
void create() {
  ::create();
  set_nroff_file("vurdere");
  set_command_name("vurdere");
  add_teach_skill(SKILL, 10, 2);
}
mixed *calc_ac( object ob ) {
  int j;
  string i;
  mapping ac;
  mixed *ret, bit;
  ac = (mapping)ob->query_armour_class();
  ret = ({ });
  foreach ( i in keys( ac ) ) {
    if ( member_array( ac[ i ][ A_TYPE ], ({ "blunt",
                                               "sharp", "pierce" }) ) == -1 )
      continue;
    bit = ac[ i ][ A_AC ];
    if( (j = member_array( ac[ i ][ A_TYPE ], ret )) == -1 ) {
      j = sizeof( ret );
      ret += ({ ac[ i ][ A_TYPE ], ({ 0, 0, 0 }) });
    }
    j++;
    if ( intp( bit ) ) {
      ret[ j ][ 1 ] += bit / 2;
      ret[ j ][ 2 ] += bit;
    } else
      switch ( sizeof( bit ) ) {
      case 1 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += bit[ 0 ];
        ret[ j ][ 2 ] += bit[ 0 ];
        break;
      case 2 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ]);
        break;
      case 3 :
        ret[ j ][ 0 ] += bit[ 0 ];
        ret[ j ][ 1 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ] / 2);
        ret[ j ][ 2 ] += (bit[ 0 ] + bit[ 1 ] * bit[ 2 ]);
        break;
      default :
        write( "Barf!\n" );
      }
  }
  return ret;
}
int calc_sausage( int sausage, int lvl ) {
  int tmp;
  tmp = 99 - (lvl * 99) / 200;
  if( tmp < 0 )
    tmp = 0;
  return random( sausage ) * tmp / 100 - random( sausage ) * tmp / 100 +
    sausage;
}
string check_string( int val, int bon ) {
  int dist;
  string s;
  dist = (350 - bon) / 10;
  if( dist > (val < 0 ? -val : val) )
    return " is the same as ";
  if( val > 0 )
    s = "better than ";
  else {
    s = "worse than ";
    val -= val;
  }
  if( !val )
    return " is exactly the same as ";
  if( val < 10 )
    return " is slightly " + s;
  if( val < 20 )
    return " " + s;
  if( val < 40 )
    return " is much " + s;
  return " is amazingly " + s;
}
int cmd_against( object*from, object *to ) {
  int i, j, k, l, arm_lvl;
  object *ok, *fail;
  mixed *rat, *to_ac, *zip;
  arm_lvl = (int)this_player()->query_skill_bonus( SKILL );
  if(sizeof(from) + sizeof(to) > 10) {
    add_failed_mess("You cannot compare that many items at once.\n");
    return 0;
  }
  i = (COST*(sizeof(from)+sizeof(to)));
  if(this_player()->query_specific_gp("other") < i) {
    add_failed_mess("You cannot concentrate enough to compare these "
                       "items.\n");
    return 0;
  }
  this_player()->adjust_gp( -i);
  to_ac = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( to ); i++ ) {
    if( to[ i ]->query_armour() ) {
      rat = calc_ac( to[ i ] );
      to_ac += ({ to[ i ], rat });
    } else {
      fail += ({ to[ i ] });
      to = delete( to, i, 1 );
      i--;
    }
  }
  if( !sizeof( to ) ) {
    notify_fail( "None of " + query_multiple_short( fail ) +
                 " are armour.\n" );
    return 0;
  }
  fail = ({ });
  ok = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      if( !sizeof( to_ac ) ) {
        fail += ({ from[ i ] });
        continue;
      }
      rat = calc_ac( from[ i ] );
      zip = ({ });
      for( j = 0; j < sizeof( to_ac ); j += 2 ) {
        for( k = 0; k < sizeof( to_ac[ j + 1 ] ); k += 2 ) {
          if( (l = member_array( to_ac[ j + 1 ][ k ], rat )) == -1 ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                      to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          } else {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( (rat[ l + 1 ][ 0 ] + rat[ l + 1 ][ 1 ] +
                                  rat[ l + 1 ][ 2 ]) / 3 -
                                 (to_ac[ j + 1 ][ k + 1 ][ 0 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 1 ] +
                                  to_ac[ j + 1 ][ k + 1 ][ 2 ]) / 3,
                                 arm_lvl ) +
                   to_ac[ j ]->short() + " at protecting from " +
                   to_ac[ j + 1 ][ k ] + ".\n" );
          }
          zip += ({ to_ac[ j + 1 ][ k ] });
        }
        for( k = 0; k < sizeof( rat ); k += 2 ) {
          if( member_array( rat[ 0 ], zip ) ) {
            write( capitalize( (string)from[ i ]->short() ) +
                   check_string( 0 - (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] +
                                      rat[ j + 1 ][ 2 ]) / 3, arm_lvl ) +
                   to_ac[ j ]->short() + " at " + rat[ j ] + ".\n" );
          }
        }
      }
      if(member_array(from[i], ok) == -1) {
        ok += ({ from[ i ] });
      }
    } else {
      if(member_array(from[i], fail) == -1) {
        fail += ({ from[ i ] });
      }
    }
  }
  if( sizeof( fail ) ) {
    add_failed_mess( "Failed to compare " + query_multiple_short( fail ) +
                 " against " + query_multiple_short( to ) + ".\n" );
    return 0;
  }
  if( sizeof( ok ) ) {
    say( this_player()->query_cap_name() + " looks closely at " +
         query_multiple_short( uniq_array( ok + to ) ) + ".\n" );
  }
  return 1;
}
int cmd_normal( object* from ) {
  int i, j;
  object *ok, *fail;
  mixed *rat, bing;
  string type, *types, *zones;
  ok = ({ });
  fail = ({ });
  for( i = 0; i < sizeof( from ); i++ ) {
    if( from[ i ]->query_armour() ) {
      rat = calc_ac( from[ i ] );
      for( j = 0; j < sizeof( rat ); j += 2 ) {
        bing = (rat[ j + 1 ][ 0 ] + rat[ j + 1 ][ 1 ] + rat[ j + 1 ][ 2 ]) / 3;
        bing /= 5;
        if( bing >= 10 ) {
          bing = 9;
        }
        if( bing < 0 ) {
          bing = 0;
        }
        write( from[ i ]->the_short() + ({ " is terrible",
                                       " is amazingly poor",
                                       " is pretty poor",
                                       " is poor",
                                       " is ok",
                                       " is average",
                                       " is good",
                                       " is very good",
                                       " is extremely good",
                                       " is excellent", })[ bing ] +
                                       " at stopping " + rat[ j ] +
                                       " attacks.\n" );
        ok += ({ from[ i ] });
      }
      if(!arrayp(from[i]->query_type())) {
        types = ({ from[i]->query_type() });
      } else {
        types = from[i]->query_type();
      }
      zones = ({ });
      foreach(type in types) {
        if(CLOTHING_HANDLER->query_equivilant_type(type)) {
          zones += CLOTHING_HANDLER->query_zone_names(CLOTHING_HANDLER->query_equivilant_type(type));
        } else {
          zones += CLOTHING_HANDLER->query_zone_names(type);
        }
      }
      if(!sizeof(zones)) {
      	write(from[i]->the_short() +
              " does not protect any parts of your body.\n");
      } else {
        write(from[i]->the_short() + " protects your " +
              query_multiple_short(zones, "poss") + ".\n");
      }
      continue;
    }
    fail += ({ from[ i ] });
  }
   from = uniq_array( from );
  if( !sizeof( ok ) ) {
    notify_fail( "You failed to vurdere " + query_multiple_short( from ) +
                 ".\n" );
    return 0;
  }
    ok = uniq_array( ok );
  say( this_player()->query_cap_name() + " peers carefully at " +
       query_multiple_short( ok ) + ".\n" );
  return 1;
}
int teach( object ob ) {
  if( this_player()->query_skill( SKILL ) < TEACH_LEVEL )
    return -1;
  if( ob->query_skill( SKILL ) < LEARN_LEVEL )
    return -2;
  ob->add_known_command( "vurdere" );
  return 1;
}
mixed* query_patterns() {
   return ({ "<indirect:object:me'from'> against <indirect:object:me'to'>",
                (: cmd_against($1[0], $1[1]) :),
             "<indirect:object:me'normal'>",
                (: cmd_normal($1) :) });
}

==================================================
FILE: playtester/check.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
string query_applicant_text();
string pt_protected();
varargs int cmd(string check, string name) {
  object ob = environment (this_player());
  int min, max;
  mixed *chats;
  mixed *chatsd, *chatsn;
  string day, night;
  string ret = "";
  int count;
  mixed *args, *args1;
  if (ob->query_property ("restrict check")) {
    this_player()->add_failed_mess (this_object(), "The use of the check "
      "command in this room has been restricted.\n", ({ }));
    return 0;
  }
  switch (check) {
    case "chats":
      args= ob->query_room_chats();
      chatsd = ob->query_room_day_chats();
      chatsn = ob->query_room_night_chats();
      if (!args && !sizeof (chatsd) && !sizeof (chatsn)) {
        tell_object (this_player(), "There are no chats defined here.\n");
        return 1;
      }
      if (args) {
         min = args[0];
         max = args[1];
         if (!arrayp(args[2])) {
            ret += "%^BOLD%^%^RED%^Error in the room chats!%^RESET%^\n";
            chats = ({ });
         } else {
            chats = args[2];
         }
      } else {
         chats = ({ });
      }
      if (sizeof (chats)) {
        ret = "This room has the following chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          if (!stringp(chats[i])) {
             ret += "%^BOLD%^%^RED%^Broken chat setup in room.%^RESET%^\n";
             break;
          }
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
      if (sizeof (chatsd)) {
        min = chatsd[0];
        max = chatsd[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room day chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsd[2];
        }
        ret += "\n\nThis room has the following day chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
      if (sizeof (chatsn)) {
        min = chatsn[0];
        max = chatsn[1];
        if (!arrayp(chatsd[2])) {
           ret += "%^BOLD%^%^RED%^Error in the room night chats!%^RESET%^\n";
           chats = ({ });
        } else {
           chats = chatsn[2];
        }
        ret += "\n\nThis room has the following night chats, set to occur "
          "at the rate of one every " + min + " to " + max + " seconds:\n\n";
        for (int i = 0; i < sizeof (chats); i++) {
          ret += (i + 1) + ". " + chats[i];
          ret += "\n";
        }
      }
    break;
    case "long":
      day = ob->query_day_long();
      night = ob->query_night_long();
      ret = "Day long description:\n\n" + day;
      ret += "\n\nNight long description:\n\n" + night;
    break;
    case "items":
      ob = ob->query_item();
      if (!ob) {
        ret = "%^CYAN%^There are no add_items defined in this room.%^RESET%^\n";
      }
      else {
        args = ob->query_shrt();
        args1 = ob->query_lng();
        count = sizeof (args);
        ret += "%^YELLOW%^Main items:%^RESET%^\n";
        for (int i = 0; i < count; i++) {
          if (!sizeof (args[i])) {
            continue;
          }
          ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args1[i]) ?  ("*" + evaluate (args1[i]) + "*") : args1[i]);
          ret += "\n\n";
        }
        args = ob->query_day_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no day items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Day Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";
          }
        }
        args = ob->query_night_items();
        if (!sizeof(args)) {
           ret += "%^CYAN%^There are no night items defined in this room.%^RESET%^\n";
        } else {
          ret += "%^YELLOW%^Night Items:%^RESET%^\n";
          for (int i = 0; i < sizeof (args) ; i=i+2) {
            ret += "%^BOLD%^" + args[i] + "%^RESET%^: " + (functionp (args[i+1]) ?
              ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
            ret += "\n\n";
          }
        }
      }
    break;
    case "day items":
      args = ob->query_day_items();
      if (!sizeof (args)) {
        ret += "There are no day items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";
        }
      }
    break;
    case "night items":
      args = ob->query_night_items();
      if (!sizeof (args)) {
        ret += "There are no night items defined here.\n";
      }
      else {
        for (int i = 0; i < sizeof (args) ; i=i+2) {
          ret += args[i] + ": " + (functionp (args[i+1]) ?
            ("*" + evaluate (args[i+1]) + "*") : args[i+1]);
          ret += "\n\n";
        }
      }
    break;
    case "protected":
      if (!PLAYTESTER_HAND->query_exec_access(this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "This facility is "
          "available only to PT Executives.\n", ({ }));
        return 0;
      }
      else {
        ret = pt_protected();
      }
    break;
  }
  write("$P$Items$P$" + ret);
  return 1;
}
private string time_string( int time_elapsed ) {
    string retval = "";
    int sec = time_elapsed % 60;
    int min = ( time_elapsed / 60 ) % 60;
    int hour = time_elapsed / 3600;
    if ( hour > 0 )
        retval += hour + "h";
    if ( min > 0 )
        retval += min + "m";
    if ( sec > 0 )
        retval += sec + "s";
    if ( sizeof( retval ) == 0 )
        return "0s";
    return retval;
}
int do_check_quota() {
    string* bits;
    string shortdate;
    int* spam;
    int reports;
    int age;
    int curage;
    mapping spamtoo;
    bits = explode( ctime( time() ), " " ) - ({ "" });
    shortdate = bits[ 1 ] + " " + bits[ 4 ];
    spamtoo = PLAYTESTER_HAND->
        query_bugs( this_player()->query_name() );
    if ( mapp( spamtoo ) ) {
        spam = spamtoo[ shortdate ];
        if ( arrayp( spam ) ) {
            reports = spam[ 0 ];
            age = spam[ 1 ];
            curage = PLAYTESTER_HAND->get_age_uncached(this_player()->query_name());
            age += curage - spam[2];
            tell_object( this_player(), "This month (" + shortdate + "), you "
                         "have made " + reports + " report" +
                         ( ( reports == 1 ) ? "" : "s" ) +  " in " +
                         time_string( age ) + " online.\n" );
            return 1;
        } else {
            tell_object( this_player(), "You cannot check your playtester "
                         "quota.\n" );
            return 1;
        }
    } else {
        tell_object( this_player(), "You cannot check your playtester "
                     "quota.\n" );
        return 1;
    }
}
int cmd_chats(object* obs) {
   mixed* chats;
   string ret;
   int i;
   object ob;
   ret = "";
   foreach (ob in obs) {
      ret += "$I$0=%^YELLOW%^$C$" + ob->the_short() + "%^RESET%^:\n";
      chats = ob->query_chat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_achat_string();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Attack Chats:%^RESET%^ (Chance: " + chats[0] + ")\n";
         chats = chats[1];
         for (i = 0; i < sizeof(chats); i += 2) {
            if (stringp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + "): " + chats[i + 1] + "\n";
            } else if (arrayp(chats[i + 1])) {
               ret += "$I$6=   (Weight " + chats[i] + ") Story:\n ";
               foreach (string story in chats[i + 1]) {
                  ret += story + "\n";
               }
            } else {
               ret += "%^BOLD%^%^RED%^Bad chat type%^RESET%^";
            }
         }
      }
      chats = ob->query_chats();
      if (sizeof(chats)) {
         ret += "$I$0=   %^BOLD%^Item Chats:%^RESET%^ (Min time " + chats[0] + ", "
                "Max time " + chats[1] + ")\n";
         foreach (string story in chats[2]) {
            ret += "$I$6=   " + story + "\n";
         }
      }
   }
   write("$P$Npc/Item chats$P$" + ret);
   return 1;
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "{chats|long|items|day items|night items|"
        "protected}", (: cmd($4[0]) :),
      "chats <indirect:object>",
        (: cmd_chats :),
      "quota", (: do_check_quota :),
    });
    return patterns;
}
string pt_protected() {
  object *obs = filter (users(), (: $1->query_playtester() :));
  string ret = "";
  obs = filter (obs, (: $1->query_pt_protection() :));
  if (!sizeof(obs)) {
    tell_object (this_player(), "No-one is currently using PT Protection.\n");
  }
  else {
    ret += "The following people have PT protection enabled:\n\n";
    foreach (object ob in obs) {
      ret += sprintf ("%s: %s (%s).\n\n", ob->query_name(),
        environment(ob)->query_short(), base_name (environment (ob)));
    }
  }
  return ret;
}

==================================================
FILE: playtester/comment.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
varargs int cmd(string name, string comment) {
  object ob = load_object (PT_APPLICATION_HANDLER);
  string ret = "";
  int i;
  if (!ob) {
    this_player()->add_failed_mess (this_object(), "Horrible, horrible "
      "error!\n", ({ }));
    return 0;
  }
  if (!sizeof (comment)) {
    this_player()->do_edit(0, "comment_editor", this_object(), "", name);
  }
  else {
    i =  ob->do_comment (name, comment);
    if (i) {
      tell_object (this_player(), "Thank you for your comments.\n");
    }
    else {
      tell_object (this_player(), "No candidate of that name registered.\n");
    }
  }
  return 1;
}
mixed* query_patterns() {
   return ({
      "<word'name'> <string'comment'>", (: cmd($4[0], $4[1]) :),
      "<word'name'>", (: cmd ($4[0]) :),
  });
}
void comment_editor (string comment, string name) {
  object ob = load_object (PT_APPLICATION_HANDLER);
  int i;
  if (!sizeof (comment)) {
    return;
  }
  else {
   i =  ob->do_comment (name, comment);
  }
  if (i) {
    tell_object (this_player(), "Thank you for your comments.\n");
  }
  else {
    tell_object (this_player(), "No candidate of that name registered.\n");
  }
}

==================================================
FILE: playtester/define.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   string ret;
   string* bing;
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object (player, "No definitions for " + word + ".\n");
      } else {
         ret = "";
         foreach (bing in results) {
            ret += bing[1] + "\n" + bing[2] + "\n\n";
         }
         tell_object(player, "Definitions for " + word + ":\n" + ret);
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->define_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   write ("You look up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: playtester/jumps.c
==================================================

#include <playtesters.h>
#define LOG_FILE PT_LOGS + "badge_log"
inherit "/cmds/base";
void log_attackers (object);
int do_list() {
   mapping jumps;
   string str;
   string start;
   string tmp;
   string* dest;
   object there;
   object to_there;
   object* theres;
   jumps = PLAYTESTER_HAND->query_jump_points();
   if (!sizeof(jumps)) {
      add_failed_mess("No current jumps.\n");
      return 0;
   }
   str = "Current jumps:\n";
   foreach (start, dest in jumps) {
      if ( !( there = find_object( start ) ) ) {
         catch(load_object(start));
         there = find_object( start );
         if ( !there ) {
           str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                           start, "Someone happy" );
           continue;
         }
      }
      theres = ({ });
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%O will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              continue;
            }
         }
         theres += ({ to_there });
      }
      str += "$I$6= * From " + there->the_short() + " [" +
             explode(start, "/")[1] + "] you can get to " +
             query_multiple_short(theres, "the") + ".\n";
   }
   write("$P$Jump points$P$" + str);
   return 1;
}
int do_list_from_here() {
   string* dest;
   string here;
   string str;
   string tmp;
   object to_there;
   int pos;
   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (sizeof(dest)) {
      str = "";
      foreach (tmp in dest) {
         if ( !( to_there = find_object( tmp ) ) ) {
            catch(load_object(tmp));
            to_there = find_object( tmp );
            if ( !to_there ) {
              str += sprintf( "$I$3=%s will not load, please contact %s.\n",
                              tmp, "Someone happy" );
              return 1;
            }
         }
         str += sprintf("$I$6=   %c: %s\n", pos + 'A', to_there->the_short());
         pos++;
      }
      write("$I$3=From here you can get to:\n" + str);
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}
int do_jump(string id) {
   string here;
   string* dest;
   string real_dest;
   object to_there;
   int pos;
   if (strlen(id) > 1) {
      add_failed_mess("The id to jump to must be a single letter.\n");
      return 0;
   }
   id = lower_case(id);
   pos = id[0] - 'a';
   here = file_name(environment(this_player()));
   dest = PLAYTESTER_HAND->query_jump_destination(here);
   if (!sizeof(dest)) {
      add_failed_mess("There are no jump points here.\n");
      return 0;
   }
   if (pos < 0 || pos >= sizeof(dest)) {
      add_failed_mess("The id must be in 'A'..'" +
                      sprintf("%c", sizeof(dest) + 'A') + "'.\n");
      return 0;
   }
   real_dest = dest[pos];
   if (real_dest) {
      if ( !( to_there = find_object( real_dest ) ) ) {
         catch(load_object(real_dest));
         to_there = find_object( real_dest );
         if ( !to_there ) {
           write(sprintf( "$I$3=%s will not load, please contact %s.\n",
                           real_dest, "Someone happy" ) );
           return 1;
         }
      }
      catch( log_attackers( this_player() ) );
      write( "Moving you to "+ to_there->the_short() +"...\n" );
      this_player()->move_with_look( to_there,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
      return 1;
   }
   add_failed_mess("No destinations from here.\n");
   return 0;
}
int do_armoury() {
   string env;
   string ret;
   object ob;
   env = file_name(environment(this_player()));
   if (environment(this_player())->query_armoury()) {
        ret = this_player()->query_property("pt return");
        if (ret) {
           if (strsrch(ret, "#") != -1) {
              if (!find_object(ret)) {
                 ret = 0;
              }
            } else if (!load_object (ret)) {
              ret = 0;
            }
        }
        if (!ret) {
           ret = this_player()->query_start_pos();
        }
      write( "Moving you from the pt armoury.\n");
      this_player()->move_with_look( ret,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   } else {
      catch( log_attackers( this_player() ) );
      write( "Moving you to the pt armoury.\n");
      if (explode (env,"/")[1] != "playtesters") {
        this_player()->add_property("pt return", env);
      }
      this_player()->move_with_look( PLAYTESTER_ARMOURY,
           "$N appear$s in a gout of green fire.",
           "$N disappear$s in a puff of yellow smoke." );
   }
   return 1;
}
protected void log_attackers( object o ) {
    string s;
    object* obs;
    object e;
    if ( sizeof( obs = o->query_attacker_list() ) > 0 ) {
        tell_object( o, "%^BOLD%^%^WHITE%^Please stop combat before using "
                     "the jumps command to go places.%^RESET%^\n" );
        e = environment( o );
        obs -= ({ 0 });
        obs = filter( obs, (: environment( $1 ) == $(e) :) );
        if ( sizeof( obs ) > 0 ) {
            s = ctime( time() ) + " - " + o->query_name() + " tried to "
                "teleport out of combat from " +
                ( environment( o ) ? file_name( environment( o ) ) :
                  "NULLSPACE" ) + "; query_attacker_list() == ({ ";
            foreach ( object ob in o->query_attacker_list() ) {
                s += "\"" + ob->query_short() + "\" [" +
                    file_name( ob ) + "]";
                if ( environment( ob ) != environment( o ) )
                    s += " (not in same room: " +
                        ( environment( ob ) ?
                          file_name( environment( ob ) ) :
                          "NULLSPACE" ) + ")";
                else
                    s += " (IN SAME ROOM)";
                s += ", ";
            }
            s += "});\n\n";
            log_file( LOG_FILE, s );
        }
    }
}
mixed* query_patterns() {
   return ({ "list", (: do_list :),
             "list here", (: do_list_from_here :),
             "goto <string'id'>", (: do_jump($4[0]) :),
             "armoury", (: do_armoury :) });
}

==================================================
FILE: playtester/playtesting.c
==================================================

#include <project_management.h>
#include <playtesters.h>
inherit "/cmds/base";
string format_array (string*);
string get_output (class project*, int);
mapping _globals = ([ ]);
varargs int cmd(string bing, string bong, string proj) {
  class project temp, *tmp = ({ });
  mapping query = ([ ]);
  string *blue, *blah;
  string ret = "";
  int verbose = 0, i;
  if (!PLAYTESTER_HAND->query_tester (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "Only playtesters may "
      "use this command.\n", ({ }));
    return 0;
  }
  if (bing == "list" && sizeof (bong)) {
    if (find_object ("/d/" + lower_case (bong) + "/master")) {
      bing = "domain";
    }
    else if (PLAYTESTER_HAND->query_tester (lower_case (bong))) {
      bing = "playtester";
    }
    else {
      bing = "nomatch";
    }
  }
  switch (bing) {
    case "assignments":
      bong = lower_case (bong);
      blue = PROJECT_HANDLER->query_pt_projects (bong);
      ret = sprintf (capitalize (bong) + " $I$5=%s.\n", (sizeof (blue) ? "is "
      "assigned to the following projects: " + query_multiple_short (blue) :
      "is not currently assigned to any projects"));
    break;
    case "allassign":
      blue = sort_array (PLAYTESTER_HAND->query_playtesters(), 1);
      foreach (string b in blue) {
        blah = PROJECT_HANDLER->query_pt_projects (b);
        ret += sprintf ("$I$5=%s is assigned to %s.\n",
          capitalize (b),
          (sizeof (blah) ? query_multiple_short (blah) : "nothing"));
      }
    case "list":
      query["status"] = "playtesting";
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "domain":
      query["status"] = "playtesting";
      query["domains"] = lower_case (bong);
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "playtester":
      query["status"] = "playtesting";
      query["playtesters"] = lower_case (bong);
      tmp = PROJECT_HANDLER->filter_by_query (query);
    break;
    case "details":
    case "report":
    case "assign":
    case "unassign":
      query["status"] = "playtesting";
      query["projid"] = bong;
      temp = PROJECT_HANDLER->get_project_file (bong);
      if (!temp) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in the handler.  Remember case sensitivity.\n", ({ }));
        return 0;
      }
      if (temp->status != member_array ("playtesting", STATUS)) {
        this_player()->add_failed_mess (this_object(), "This project is "
          "not in playtesting.\n", ({ }));
        return 0;
      }
      if (temp) {
        tmp += ({ temp });
      }
      verbose = 1;
    break;
    case "passign":
    case "punassign":
       temp = PROJECT_HANDLER->get_project_file (proj);
       if (temp) {
        tmp += ({ temp });
      }
    break;
  }
  if (!sizeof (tmp) && !sizeof (ret)) {
    ret += "There are no projects in playtesting for this category.\n";
  }
  else {
    switch (bing) {
      case "passign":
        blue = PROJECT_HANDLER->add_playtester (proj, ({ bong }));
        if (!sizeof (blue)) {
          ret = "You cannot perform this operation.";
        }
        else {
          ret = "You assign " + capitalize (bong) + " to project " +
            proj + ".\n";
        }
      break;
      case "punassign":
        i = PROJECT_HANDLER->remove_playtester (proj, ({ bong }));
        if (!i) {
          ret = "This project does not exist.";
        }
        else {
          ret = "You remove " + capitalize (bong) + " from project " +
            proj + ".\n";
        }
      break;
      break;
      case "list":
      case "domain":
      case "playtester":
      case "details":
        ret = get_output (tmp, verbose);
      break;
      case "report":
      tell_object (this_player(), "Please enter your report for project " +
        bong + ".\n");
      this_player()->do_edit(0, "end_of_report");
      _globals [this_player()->query_name()]  = bong;
      break;
      case "assign":
      if (!PLAYTESTER_HAND->query_exec_access
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "execs can assign themselves to projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->add_playtester (bong,
          ({ this_player()->query_name() }), this_player()->query_name());
        ret += "You assign yourself to the project " + bong;
      }
      break;
      case "unassign":
      if (!PLAYTESTER_HAND->query_exec_access
        (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "Only PT "
          "Execs can unassign themselves from projects.\n", ({ }));
        return 0;
      }
      else {
        PROJECT_HANDLER->remove_playtester (bong,
          ({ this_player()->query_name() }), this_player()->query_name());
        ret += "You unassign yourself from the project " + bong;
      }
      break;
    }
  }
  if (sizeof (ret)) {
    this_player()->more_string (ret);
  }
  return 1;
}
mixed *query_patterns() {
    mixed *patterns = ({ "list", (: cmd("list") :),
    "list <word>", (: cmd ( "list", $4[0]) :),
    "details <word>", (: cmd ( "details", $4[0]) :),
    "report <word>", (: cmd ( "report", $4[0]) :),
    "assign <word>", (: cmd ("assign", $4[0]) :),
    "unassign <word>", (: cmd ("unassign", $4[0]) :),
    "assignments [for] <word>", (: cmd ("assignments", $4[0]) :),
    "assignments", (: cmd ("allassign") :),
    });
    if (PLAYTESTER_HAND->query_exec_access (this_player()->query_name())) {
      patterns += ({
        "unassign <word> from <word>", (: cmd ("punassign", $4[0], $4[1]) :),
        "assign <word> to <word>", (: cmd ("passign", $4[0], $4[1]) :),
      });
    }
    return patterns;
}
string format_array (string *tmp) {
  if (!sizeof (tmp)) {
    return "None";
  }
  return query_multiple_short (map (tmp, (: capitalize ($1) :)));
}
string get_output (class project *tmp, int verbose) {
  int i;
  string ret = "";
  if (sizeof (tmp)) {
    if (!verbose) {
      ret += "The following projects match this query:\n";
      ret += sprintf ("%-20s %-40s %s\n\n", "Project ID",
          "Name", "Domains");
      foreach (class project p in tmp ) {
        ret += sprintf ("%-20s %-40s %s\n", p->id,
          p->name, format_array (p->domains));
      }
    }
    else {
      ret += "The details for this project are:\n\n";
      foreach (class project p in tmp ) {
        i = PROJECT_HANDLER->find_project (p->id);
        ret += sprintf ("$I$5=Project ID: %s\n$I$5=Project Name: %s\n$I$5="
        "Project Leader: %s\n$I$5=Description: %s\n$I$5=Domains: %s\n$I$5="
        "Creators: %s\n$I$5=Assigned Playtesters: "
        "%s.\n$I$5=Size: %s.\n$I$5=Complexity: %s.\n$I$5=Next Rotation: %s\n"
        "$I$5=Rotation: %d of %d.\n"
        "$I$5=Guilds: %s.\n"
        "$I$5=Playtester notes: "
        "%s\n$I$5=Flagged for playtesting: %s",
        p->id, p->name, capitalize (p->leader),
        replace (p->description, ({"\n\n", "\n"})),
        format_array (p->domains), format_array (p->creators),
        format_array (p->playtesters), (p->size != -1 ? SIZE[p->size] :
        "Unknown"),
        (p->complexity != -1 ? COMPLEXITY[p->complexity] : "Unknown"),
        (PROJECT_HANDLER->query_number_rotations() > p->current_rotation ?
        ctime (PROJECT_HANDLER->next_rotation_time (i)) : "On last rotation"),
        PROJECT_HANDLER->query_rotation (i),
        PROJECT_HANDLER->query_number_rotations (i),
        (sizeof (p->guild_specific) ? query_multiple_short (p->guild_specific) :
        "All guilds"),
        (sizeof (p->pt_notes) ? p->pt_notes :
        "None"), ctime(p->last_status_change));
      }
    }
  }
  return ret;
}
void end_of_report (string body) {
  int i = 0, j;
  if (!sizeof (body)) {
    tell_object (this_player(), "No report given.  Aborting.\n");
    return;
  }
  do {
    i++;
    j = PROJECT_HANDLER->find_note (_globals[this_player()->query_name()],
      capitalize (this_player()->query_name()) + "Report" + i);
  } while (j != -1);
  PROJECT_HANDLER->add_note_to_project (_globals[this_player()->query_name()],
    capitalize (this_player()->query_name()) + "Report" + i, body,
    this_player()->query_name());
  PLAYTESTER_HAND->adjust_quota( this_player()->query_name(), 1 );
  map_delete (_globals, this_player()->query_name());
  tell_object (this_player(), "Thank you for your report!\n");
}

==================================================
FILE: playtester/ptapp_lications.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
string query_applicant_text();
varargs int cmd(string check, string name) {
  string ret = "";
  mixed args;
  switch (check) {
    case "comments":
      if (!sizeof (name)) {
        ret = PT_APPLICATION_HANDLER->get_comment_list();
      }
      else {
        ret = PT_APPLICATION_HANDLER->get_comments_on_applicant (name);
      }
    break;
    break;
    case "summary":
    case "list":
      ret = "";
      ret =   PT_APPLICATION_HANDLER->get_applicant_list();
    break;
  }
  tell_object (this_player(), ret);
  return 1;
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "list", (: cmd("list") :),
    });
  if (this_player()->query_lord() ||
    load_object ("/d/playtesters/master")->query_deputy
    (this_player()->query_name())) {
    patterns +=
    ({
      "comments",  (: cmd ("comments") :),
      "comments for <string>", (: cmd ("comments", $4[0]) :),
    });
  }
    return patterns;
}

==================================================
FILE: playtester/pterrors.c
==================================================

inherit "/cmds/base";
#include <db.h>
#include <error_handler.h>
#include <player_handler.h>
void finish_lookup(object player, int type, mixed summary) {
   string bugs;
   class error_summary error;
   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bugs.\n" + summary + "\n");
      return ;
   }
   if (!sizeof(summary)) {
      tell_object(player, "No bugs found.\n");
      return ;
   }
   bugs = "";
   foreach (error in summary) {
      bugs += "#" + error->id + " " +
              ctime(error->entry_date)[4..15] +
              " by " + error->reporter + " (" +
              error->type + " - " + error->category + " - " +
              error->status + ")";
      if (error->assigned_to) {
         bugs += " assigned to " + error->assigned_to;
      }
      bugs += "\n";
   }
   tell_object(player, "$P$Bug List$P$" + bugs);
}
int cmd() {
   string fname;
   fname = base_name(environment(this_player()));
   if (!ERROR_HANDLER->do_query_open_bugs_for_fname(fname,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int do_query(string reporter, string status) {
   class error_query query;
   query = new(class error_query);
   if (status) {
      query->status = ({ status });
   }
   query->reporter = reporter;
   if (!this_player()->query_property("pterrors order")) {
      query->order_by = ERROR_ORDER_BY_DATE;
   } else {
      query->order_by = this_player()->query_property("pterrors order");
   }
   this_player()->add_property("pterrors query", query, 120);
   return ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :));
}
int cmd_next() {
   class error_query query;
   query = this_player()->query_property("pterrors query");
   if (!query) {
      add_failed_mess("You have not done a bugs query recently enough.\n");
      return 0;
   }
   query->bug_offset += 150;
   this_player()->add_property("pterrors query", query, 120);
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                   (: finish_lookup($(this_player()), $1, $2) :))) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int cmd_mine(string status) {
   if (!do_query(this_player()->query_name(), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
int cmd_order(string order) {
   switch (order) {
   case "date" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DATE);
      break;
   case "filename" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_FILENAME);
      break;
   case "directory" :
      this_player()->add_property("pterrors order", ERROR_ORDER_BY_DIRECTORY);
      break;
   }
   write("Set your pterrors bug order to " + order + "\n");
   return 1;
}
int cmd_ptbugs(string name, string status) {
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("There is no player called " + name + ".\n");
      return 0;
   }
   if (!do_query(lower_case(name), status)) {
      add_failed_mess("Error attempting to query the bugs.\n");
      return 0;
   }
   return 1;
}
void finish_details(object player, int type, mixed details) {
   string bugs;
   class error_complete complete;
   class error_details error;
   if (type != DB_SUCCESS) {
      tell_object(player, "Error looking up the bug.\n" + details + "\n");
      return ;
   }
   if (!sizeof(details)) {
      tell_object(player, "No bugs found with that id.\n");
      return ;
   }
   bugs = "";
   foreach (complete in details) {
      error = complete->details;
      bugs += "%^BOLD%^#" + error->summary->id + " " +
              ctime(error->summary->entry_date)[4..15] +
              " by " + error->summary->reporter + " (" +
              error->summary->type + " - " + error->summary->category + " - " +
              error->summary->status + ")";
      if (error->summary->assigned_to) {
         bugs += " assigned to " + error->summary->assigned_to;
      }
      bugs += "\n%^RESET%^";
      bugs += error->report;
      if (player->query_creator()) {
         bugs += error->runtime;
      }
   }
   tell_object(player, "$P$Bug #" + error->summary->id + "$P$" + bugs);
}
int cmd_bug(int bug_id) {
   if (!ERROR_HANDLER->do_query_bug_details(bug_id,
                   (: finish_details($(this_player()), $1, $2) :))) {
      add_failed_mess("Unable to lookup the bug.\n");
      return 0;
   }
   write("Looking up bug, please wait.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd :),
             "next", (: cmd_next() :),
             "mine", (: cmd_mine(0) :),
             "mine status {open|fixed|considering|denied}", (: cmd_mine($4[0]) :),
             "order {date|directory|filename}", (: cmd_order($4[0]) :),
             "player <string'name'>", (: cmd_ptbugs($4[0], 0) :),
             "player <string'name'> status {open|fixed|considering|denied}", (: cmd_ptbugs($4[0], $4[1]) :),
             "<number>", (: cmd_bug($4[0]) :) });
}

==================================================
FILE: playtester/spell.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "Matches for " + word + ": None.\n");
      } else {
         tell_object(player, "Matches for " + word + ": " +
                             query_multiple_short(map(results, (: $1[1] :))) +
                             "\n");
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->spell_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   write ("You look up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: playtester/senior/mail.c
==================================================

#include <mail.h>
mixed cmd(string str) {
  return (int)MAIL_TRACK->mail(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: living/'_.c
==================================================

#include "/cmds/living/sa_y.c"

==================================================
FILE: living/:_.c
==================================================

inherit "/cmds/living/em_ote";

==================================================
FILE: living/accept.c
==================================================

#include <cmds/offer.h>
#include <money.h>
#include <move_failures.h>
inherit "/cmds/base";
int is_in(object ob, object source);
int do_buy(object *people) {
   object person;
   int ret;
   class offer_sale wombat;
   object *obs;
   object *moved;
   mixed *payment;
   object ob;
   int i;
   foreach (person in people) {
      wombat = this_player()->query_respond_command("sell", person);
      if (wombat) {
         obs = filter(wombat->sell_obs, (: is_in($1, $2) :),
                      wombat->seller);
         if (sizeof(obs) != sizeof(wombat->sell_obs)) {
            add_failed_mess("$I no longer has " +
                            query_multiple_short(wombat->sell_obs - obs) +
                            " to buy.\n",
                            ({ person }) );
         } else if (this_player()->query_value_in(wombat->place) <
                    wombat->value) {
            add_failed_mess("You no longer have enough money to buy " +
                            query_multiple_short(wombat->sell_obs) +
                            " from $I.\n", ({ person }));
         } else {
            payment = MONEY_HAND->query_person_payments(wombat->value,
                                                        wombat->place,
                                                        this_player(), person);
            if (!payment) {
               add_failed_mess("You no longer have the correct change "
                               "to pay for $I.\n", ({ person }) );
            } else {
               moved = ({ });
               foreach (ob in wombat->sell_obs) {
                  if (ob->move(this_player()) == MOVE_OK) {
                     moved += ({ ob });
                  }
               }
               if (sizeof(moved) != sizeof(wombat->sell_obs)) {
                  moved->move(person);
                  tell_object(person, "Unable to move " +
                                      query_multiple_short(wombat->sell_obs -
                                                           moved) +
                                      " out of your inventory, cancelling "
                                      "the sale.\n");
                  add_failed_mess("Unable to move some objects out "
                                  "of the inventory of $I, canceling sale.\n",
                                  ({ person }) );
               } else {
                  if (sizeof(payment[MONEY_PAY_CHANGE])) {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " from " + this_player()->the_short() +
                              " and give back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " to " + person->the_short() +
                              " and receive back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                  } else {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " from " + this_player()->the_short() +".\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " to " + person->the_short() + ".\n");
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_RETURN]); i += 2) {
                     this_player()->adjust_money(-payment[MONEY_PAY_RETURN][i+1],
                                                 payment[MONEY_PAY_RETURN][i]);
                     person->adjust_money(payment[MONEY_PAY_RETURN][i+1],
                                          payment[MONEY_PAY_RETURN][i]);
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_CHANGE]); i += 2) {
                     person->adjust_money(-payment[MONEY_PAY_CHANGE][i+1],
                                                 payment[MONEY_PAY_CHANGE][i]);
                     this_player()->adjust_money(payment[MONEY_PAY_CHANGE][i+1],
                                          payment[MONEY_PAY_CHANGE][i]);
                  }
                  add_succeeded_mess("$N buy$s " +
                                     query_multiple_short(wombat->sell_obs) +
                                     " from $I.\n", ({ person }) );
                  ret++;
               }
            }
         }
         this_player()->remove_respond_command("sell", person);
      } else {
         add_failed_mess("Sorry, $I has not offered to sell you anything.\n",
                         ({ person }) );
      }
   }
   return ret;
}
int is_in(object ob, object source) {
   object env;
   if (!ob) {
      return 0;
   }
   env = ob;
   do {
      env = environment(env);
      if (env == source) {
         return 1;
      }
   } while (env);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer from <indirect:living'person'>", (: do_buy($1) :) });
}
int query_theft_command() {
   return 1;
}

==================================================
FILE: living/attack.c
==================================================

inherit "/cmds/living/kill";

==================================================
FILE: living/climb.c
==================================================

#include <tasks.h>
#define TP this_player()
#define SKILL "other.movement.climbing.rock"
inherit "/cmds/base";
void fall_off( object place, int number ) {
   if ( place->query_at_bottom() ) {
      write( "You try to climb, but you can't seem to get anywhere.\n" );
      say( (string)TP->one_short() + " tries to climb, but fails.\n" );
      return;
   }
   if ( random( (int)TP->query_dex() ) < number / 20 ) {
      write( "You begin to climb, but your fatigue makes you "+
            "clumsily lose your grip.\n" );
      say( (string)TP->one_short() +
            " begins to climb but clumsily loses "+
            (string)TP->query_possessive() +" grip.\n" );
      place->fall_down( TP );
      return;
   }
   write( "You begin to climb but wobble precariously and decide to "+
         "stay put for the moment.\n" );
   say( (string)TP->one_short() +
            " begins to climb, but wobbles precariously and stops.\n" );
}
mixed cmd( string words ) {
   int difficulty;
   object place;
   mixed ghost_action;
   mixed *move;
   string *move_descs = ({ "", "", "" });
   string skill;
   place = environment( TP );
   if ( !place ) {
      add_failed_mess( "You cannot climb anything: you're in limbo!\n" );
      return 0;
   }
   move = (mixed *)place->query_move( words );
   if ( !move ) {
      if( sizeof( place->query_moves() ) )
         add_failed_mess( "You cannot climb \""+ words +"\" from here.\n" );
      else
         add_failed_mess( "There is nothing to climb here.\n" );
      return 0;
   }
   if( stringp( move[2] ) ) {
      move_descs[0] =
         "You climb "+ words +".\n";
      move_descs[1] =
         "$N slowly climb$s "+ words +" and disappears from view.";
      move_descs[2] =
         copy( move[2] );
   } else if( sizeof( move[2] ) == 3 ) {
      move_descs = copy( move[2] );
      move_descs[0] += "\n";
   } else {
      return 0;
   }
   if ( TP->query_property( "dead" ) ) {
      ghost_action = place->query_ghost_action( place );
      if ( ! ghost_action ) {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
      else if ( intp( ghost_action ) && ghost_action == 1 ) {
          add_failed_mess( "How can you climb anything?  You're dead!\n");
          return 0;
      }
      else if ( stringp( ghost_action ) ) {
          write( "As you move to climb the wall, your inherent wispiness gets "
              "the better of you, and you fall through to the other side.\n" );
          TP->move_with_look( ghost_action,
              "$N wisps through the wall with some undue haste.",
              "$N tries to climb the wall, but falls through it." );
          add_succeeded_mess( "" );
          return 1;
      }
      else if ( arrayp( ghost_action ) ) {
          write( ghost_action[ 1 ][ 0 ] + "\n" );
          TP->move_with_look( ghost_action[ 0 ],
              ghost_action[ 1 ][ 1 ], ghost_action[ 1 ][ 2 ] );
          add_succeeded_mess( "" );
          return 1;
      }
      else {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
   }
   if( intp( move[0] ) ) {
      difficulty = move[0] + (int)TP->query_loc_weight() / 10;
      skill = SKILL;
   } else if( arrayp( move[0] ) && sizeof( move[0] ) > 1 ) {
      difficulty = move[0][0] + (int)TP->query_loc_weight() / 10;
      skill = move[0][1];
      debug_printf( "Base difficulty: %d, total difficulty: %d, skill: %s\n",
                    move[0][0], difficulty, move[0][1] );
   }
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty / 2 );
   switch ( (int)TASKER->perform_task(TP, skill, difficulty,
                                      TM_COMMAND)) {
      case AWARD :
         call_out( "advance_notice", random( 60 ), TP );
      case SUCCEED :
         write( move_descs[ 0 ] );
         TP->move_with_look( move[ 1 ], move_descs[ 2 ],
               move_descs[ 1 ] );
         return 1;
      default :
         break;
   }
   difficulty = random( difficulty );
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty );
   switch ( (int)TASKER->perform_task(TP, skill,  difficulty / 2,
                                      TM_COMMAND)) {
      case AWARD :
         write( "%^YELLOW%^You manage not to fall off!%^RESET%^\n" );
      case SUCCEED :
         write( "You begin to climb but wobble precariously and decide to "+
               "stay put for the moment.\n" );
         say( (string)TP->one_short() +
               " begins to climb, but wobbles precariously and stops.\n" );
         break;
      default :
         fall_off( place, difficulty );
         break;
   }
   add_succeeded_mess("");
   return 1;
}
void advance_notice( object thing ) {
   if ( !thing )
      return;
   tell_object( thing, "%^YELLOW%^"+ ({
      "In a flash of inspiration, you realise how to balance better "+
            "when climbing.",
      "Thinking about your climb, you realise something important.",
      "You realise that you've been using better grips to climb.",
      "You realise you've discovered how to find better places to "+
            "support your feet.",
      "You find you've worked out a more sensible way to distribute "+
            "your weight as you climb.",
      "With all your climbing, you discover you've found a better way "+
            "to locate handholds."
   })[ random( 6 ) ] +"%^RESET%^\n" );
}
mixed *query_patterns() {
   return ({ "<string'direction'>", (: cmd($4[0]) :) });
}

==================================================
FILE: living/concentrate.c
==================================================

inherit "/cmds/base";
int concentrate_list( ) {
   object conc;
   conc = this_player()->query_concentrating();
   if ( !conc ) {
      write("You are not currently concentrating on "
                  "any particular opponent.\n" );
   } else {
      write("You are currently concentrating on "+
            conc->the_short() + ".\n");
   }
   return 1;
}
int concentrate(object *things ) {
   if ( sizeof( things ) > 1 ) {
      return notify_fail( "You can only concentrate on one thing at once.\n" );
   }
   if (!sizeof(this_player()->query_attacker_list())) {
      add_failed_mess("You are not fighting anyone.\n");
      return 0;
   }
   if ( things[0] == this_player() ) {
      return notify_fail( "It would be silly to concentrate on yourself.\n" );
   }
   if (member_array(things[0], this_player()->query_attacker_list()) == -1) {
     return notify_fail("You can only concentrate on people you are "
                        "fighting.\n");
   }
   if (this_player()->set_concentrating(things[0])) {
        add_succeeded_mess(({"You are now concentrating on $I.\n", "" }),
                           things);
   } else {
      add_succeeded_mess(({"Unable to concentrate on $I.\n", "" }), things);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "[on] <indirect:living>", (: concentrate($1) :),
             "", (: concentrate_list() :) });
}

==================================================
FILE: living/crawl.c
==================================================

#define EFFECTPATH "/std/effects/other/"
#define PT "/obj/handlers/playtesters"
inherit "/cmds/base";
int is_in_water( object room );
varargs int cmd( string str ) {
   if( str == "stop" ) {
      if( !this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You should be crawling first in order"
                                         " to stop doing it, don't you "
                                         "think?\n",
                                         ({ }) );
         return 0;
      };
      this_player()->stop_crawling();
      return 1;
   };
   if( !str ) {
      if( this_player()->query_property( "dead" ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You appear to be dead.  There is no "
                                         "necessity to torture your morphogenic"
                                         " arms, you know?\n",
                                         ({ }) );
         return 0;
      } else if( this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are already crawling.\n",
                                         ({ }) );
         return 0;
      } else if( is_in_water( environment( this_player() ) ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are in water at the moment, so "
                                         "crawling is impossible.\n",
                                         ({ }) );
         return 0;
      } else {
         this_player()->add_effect( EFFECTPATH + "crawling" );
         return 1;
      };
   };
}
mixed* query_patterns() {
   return ({
      "", (: cmd() :),
      "stop", (: cmd( "stop" ) :)
   });
}
int is_in_water( object room ) {
   if( inherits( "/std/water_inside.c", room ) ||
       inherits("/std/water_outside.c", room ) ||
       inherits("/std/uwater.c", room ) ) {
      return 1;
   } else
      return 0;
}

==================================================
FILE: living/crouch.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("crouch", "down", CROUCHING);
}

==================================================
FILE: living/debate.c
==================================================

#include <tasks.h>
#define EFFECT "/std/effects/religious/theological_debate"
#define HANDLER "/obj/handlers/philosophies"
#define DEBATE_MULT 4
inherit "/cmds/base";
mapping _debaters;
void create() {
   _debaters = ([ ]);
}
mixed cmd(object * indirect_obs,
          string indir_match,
          string dir_match,
          mixed *args,
          string pattern)
{
   int bonus;
   string topic;
   string type;
   string needed;
   object target;
   if (sizeof((int *)this_player()->effects_matching("debating"))) {
      return notify_fail("You are already engaged in a debate.\n");
   }
   if (_debaters[this_player()]) {
      tell_object(_debaters[this_player()][0],
                  this_player()->the_short() + " withdraws their debating "
                  "challenge from you.\n");
      map_delete(_debaters, this_player());
   }
   target = indirect_obs[0];
   if (target == this_player()) {
      return notify_fail("Debating with yourself?  Which one of your "
         "personalities are you trying to outwit?\n");
   }
   if (userp(target) && !interactive(target)) {
      return notify_fail("How can you debate anything with a net-dead "
                         "statue?\n");
   }
   topic = args[0];
   if (_debaters[target] && _debaters[target][0] == this_player()) {
      if ((_debaters[target][0] == this_player()) &&
          (_debaters[target][1] == topic)) {
         write("You accept " + (string) target->the_short() +
               "'s challenge to debate " + topic + ".\n");
         say((string) this_player()->the_short() + " accepts " +
             (string) target->the_short() + "'s challenge to debate " +
             topic + ".\n", target);
         tell_object(target, (string) this_player()->the_short() +
                     " accepts your challenge to debate " + topic + ".\n");
         map_delete(_debaters, target);
         this_player()->add_effect(EFFECT, target);
         target->add_effect(EFFECT, this_player());
         return 1;
      }
   }
   if (!HANDLER->query_philosophy(topic)) {
      return notify_fail("You cannot debate \"" + topic + "\".  You can " +
                         "debate " + query_multiple_short((string *) HANDLER->
                                                          query_philosophy_names
                                                          ()) + ".\n");
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) HANDLER->query_philosophy_bonus(topic);
   needed = (string) HANDLER->query_philosophy_needed(topic);
   if (this_player()->query_skill_bonus(type + ".points") < bonus) {
      return notify_fail(needed + " is not sufficient to debate " +
                         topic + " at the moment.\n");
   }
   if (this_player()->query_specific_gp(type) < bonus) {
      return notify_fail("You are too tired to debate " + topic +
                         " at the moment.\n");
   }
   this_player()->adjust_gp(-(bonus * DEBATE_MULT));
   write("You challenge " + (string) target->the_short() +
         " to a debate on " + topic + ".\n");
   say((string) this_player()->one_short() + " challenges " +
       (string) target->one_short() + " to a debate on " + topic + ".\n",
       target);
   tell_object(target,
               (string) this_player()->one_short() +
               " challenges you to a debate on " + topic + ".\n");
   _debaters[this_player()] = ({ target, topic });
   call_out("answer_challenge", 5, this_player(), target, topic);
   return 1;
}
void answer_challenge(object challenger,
                      object target,
                      string topic)
{
   int bonus;
   int diff;
   string type;
   if (!challenger) {
      return;
   }
   if (!target) {
      return;
   }
   if (environment(challenger) != environment(target)) {
      return;
   }
   if (!_debaters[challenger]) {
      return;
   }
   if ((_debaters[challenger][0] != target) || (_debaters[challenger][1] != topic)) {
      return;
   }
   if (pk_check(challenger, target)) {
      tell_object(target, "Use \"debate " + topic + " with " +
                  (string) challenger->query_name() +
                  "\" to accept the challenge.\n");
      return;
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) target->query_skill_bonus(type + ".points");
   diff = (int) target->query_skill_bonus(type + ".points") / 3;
   switch ((int) TASKER->perform_task(challenger, type + ".points", 2 * diff,
                                      TM_COMMAND)) {
   case AWARD:
      tell_object(challenger, "You feel " +
                  (string) HANDLER->query_philosophy_needed(topic) +
                  " surge for a moment.\n");
   case SUCCEED:
      tell_object(target, "You find yourself accepting " +
                  (string) challenger->the_short() +
                  "'s challenge to debate " + topic + ".\n");
      tell_room(environment(target),
                (string) target->the_short() + " accepts " +
                (string) challenger->the_short() + "'s challenge to debate " +
                topic + ".\n", ({ target, challenger }));
      tell_object(challenger,
                  (string) target->the_short() +
                  " accepts your challenge to debate " + topic + ".\n");
      map_delete(_debaters, target);
      this_player()->add_effect(EFFECT, target);
      target->add_effect(EFFECT, this_player());
      return;
   default:
      if (userp(target)) {
         tell_object(target, "Use \"debate " + topic + " with " +
                     (string) challenger->query_name() +
                     "\" to accept the challenge.\n");
      }
   }
}
mapping query_debaters()
{
   return _debaters;
}
mixed *query_patterns()
{
   return ({ "<word'topic'> with <indirect:living'person'>",
             (: cmd($1, $2, $3, $4, $5) :) });
}

==================================================
FILE: living/defend.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *defendees;
  things -= ({ TP });
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much defense as a ghost.\n" );
    return 0;
  }
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot defend yourself!\n");
     return 0;
  }
  if(TP->query_combat_response() != "parry") {
    add_failed_mess("Dodging out of the way will not help " +
                    query_multiple_short(things) + ".\n");
    return 0;
  }
  defendees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_defender( TP ) ) {
      defendees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( defendees ) ) {
    add_failed_mess("You cannot defend $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot defend "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will defend $I.\n",
                        "$N moves to defend $I.\n" }),
                  defendees);
  return 1;
}
int show_defenders() {
   object *defend;
   object womble;
   defend = this_player()->query_defenders();
   if (sizeof(defend)) {
      write("You are being defended by " + query_multiple_short(defend) +
            ".\n");
   } else {
      write("You are not being defended by anyone.\n");
   }
   defend = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_defenders()) != -1) {
            defend += ({ womble });
         }
      }
   }
   if (sizeof(defend)) {
      write("Of the people in this room, you are defending " +
            query_multiple_short(defend) + ".\n");
   } else {
      write("You are not defending anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_defenders() :) });
}

==================================================
FILE: living/double_quote.c
==================================================

#include "/cmds/living/lsay.c"

==================================================
FILE: living/drag.c
==================================================

#include <player.h>
#include <room.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd( object *indirect_obs, string direction) {
  string owner;
  object owner_ob;
  string *words, word;
  if( this_player()->query_property( "dead" ) )
    return add_failed_mess( "You're dead.  You can't drag anything.\n" );
  if( objectp( (object)this_player()->query_dragging() ) )
    return add_failed_mess( "You're already dragging something.\n" );
  if( sizeof( indirect_obs ) > 1 )
    return add_failed_mess( "You can only drag one thing at a time.\n" );
  if( indirect_obs[0] == this_player() )
    return add_failed_mess( "You try and drag yourself away from the keyboard, "
      "but you cannot.  Oh no!\n");
  if( living( indirect_obs[ 0 ] ) ) {
    if( !indirect_obs[ 0 ]->query_property( PASSED_OUT_PROP )
        || pk_check( indirect_obs[ 0 ], this_player() ) )
      return add_failed_mess( (string)indirect_obs[ 0 ]->the_short() +
        " doesn't want to be dragged away, thank you very much.\n" );
  } else
    if( base_name(indirect_obs[0]) == "/obj/corpse" ) {
      owner = indirect_obs[ 0 ]->query_owner();
      words = explode( lower_case( owner ),  " " );
      words = filter( words, (: PLAYER_HANDLER->test_user($1) :) );
      foreach( word in words ) {
          owner_ob = find_player( lower_case( word ) );
          if( owner_ob && userp( owner_ob ) &&
            pk_check( owner_ob, this_player() ) &&
            member_array ( this_player()->query_name(), indirect_obs[0]->
            query_permitted() ) == -1 )
            return add_failed_mess( "For some reason, you can't get hold of "+
              (string)indirect_obs[ 0 ]->the_short() +".\n" );
      }
  }
  if( ( environment( indirect_obs[ 0 ] ) != environment( this_player() ) ) ||
    indirect_obs[ 0 ]->get() )
      return add_failed_mess( "For some reason, you can't get hold of " +
        (string)indirect_obs[ 0 ]->the_short() +".\n" );
  write( "You get hold of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->one_short() + " gets hold of " +
    (string)indirect_obs[ 0 ]->a_short() + ".\n" );
  if( (int)indirect_obs[ 0 ]->query_complete_weight() +
    (int)this_player()->query_loc_weight() > 2 *
    (int)this_player()->query_max_weight() ) {
      write( "You struggle and strain, but you can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
      say( (string)this_player()->one_short() + " struggles and strains, but " +
        (string)this_player()->query_pronoun() + " can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
  } else {
    this_player()->set_dragging( indirect_obs[ 0 ] );
    if( !this_player()->exit_command( direction ) )
      write( "You can't drag " + (string)indirect_obs[ 0 ]->the_short() +
        " that way.\n" );
    else
      if( interactive( this_player() ) )
        indirect_obs[0]->add_property( "dropped",
          ({this_player()->query_name(), query_ip_number( this_player() ),
          time()}), 1800 );
    this_player()->reset_dragging();
  }
  write( "You let go of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->the_short() + " releases " +
    (string)this_player()->query_possessive() + " hold of " +
    (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  return 1;
}
mixed *query_patterns() {
  return
    ({ "<indirect:object:here> [to] <word'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :),
       "<indirect:object:here> [to] <string'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :) });
}

==================================================
FILE: living/draw.c
==================================================

#include <move_failures.h>
#include <obj_parser.h>
#define DEFAULT -1
#define LEFT 0
#define RIGHT 1
inherit "/cmds/base";
int cmd( string weapon_str, object * scabbards, string hand_str ) {
   object scabbard, * weapons, weapon;
   class obj_match match;
   string *limbs;
   string *hands;
   int *what_in;
   int targeted, result;
   int hand;
   match = new( class obj_match );
   targeted = scabbards ? 1 : 0;
   debug_printf( "targeted = %d\nscabbards = %O\n", targeted, scabbards );
   if( !scabbards ) {
      scabbards = filter( all_inventory( this_player() ),
        (: $1->query_scabbard() :) );
      if( !sizeof(scabbards) ) {
         add_failed_mess( "Can't find any scabbards in your inventory.\n" );
         return 0;
      }
      foreach( scabbard in scabbards ) {
         match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
           0, this_player() );
         result = match->result;
         if( result == OBJ_PARSER_SUCCESS ) {
            weapons = match->objects;
            break;
         } else if( result == OBJ_PARSER_AMBIGUOUS ) {
            add_failed_mess( "Ambiguous reference to \"" + weapon_str
              + "\" in at least one scabbard.\n" );
         }
      }
      if( !sizeof(weapons) ) {
         add_failed_mess( "Cannot find " + weapon_str + " in any "
           "scabbard in your inventory.\n" );
         return 0;
      }
   } else {
      if( sizeof(scabbards) > 1 ) {
         add_failed_mess( "You can only draw from one scabbard at a "
           "time.\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not a scabbard.\n" );
         return 0;
      }
      if ( environment(scabbard) != this_player() ) {
         add_failed_mess( "You can only draw from a scabbard in your "
           "inventory.\n" );
         return -1;
      }
      match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
        0, this_player() );
      if( match->result == OBJ_PARSER_SUCCESS ) {
         weapons = match->objects;
      } else {
         add_failed_mess( "Cannot find " + weapon_str + " in " +
           scabbard->the_short() + ".\n" );
         return -1;
      }
   }
   weapon = weapons[0];
   if ( scabbard->query_closed() ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + "; it is closed.\n" );
      return targeted ? -1 : 0;
   }
   if( !scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if ( weapon->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  hand = -1;
   else hand = member_array(hand_str, this_player()->query_limbs());
   if ( !sizeof( weapon->hold_item( this_player(), hand ) ) ) {
      weapon->move( scabbard );
      add_failed_mess( "You cannot hold " + weapon->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  {
      limbs = this_player()->query_limbs();
      what_in = find_member(weapon, this_player()->query_holding());
      hands = allocate(sizeof(what_in));
      for (hand = 0; hand < sizeof(what_in); hand++)
         hands[hand] = limbs[what_in[hand]];
      hand_str = query_multiple_short(hands);
   }
   this_player()->add_succeeded_mess(scabbard, "$N $V $I from $D into $p " +
                                     hand_str + ".\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   string limbs;
   limbs = "{" + implode(this_player()->query_limbs(), "|") + "}";
   return ({
      "<string'weapon'>",
        (: cmd( $4[0], 0, 0 ) :),
      "<string'weapon'> from <indirect:object:me'scabbard'>",
        (: cmd( $4[0], $1, 0 ) :),
      "<string'weapon'> into [my] " + limbs,
        (: cmd($4[0], 0, $4[1]) :),
      "<string'weapon'> from <indirect:object:me'scabbard'> into [my] " + limbs,
        (: cmd( $4[0], $1, $4[2]) :),
   });
}

==================================================
FILE: living/drop.c
==================================================

#include <move_failures.h>
#include <player.h>
#define MAX_DROP_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *obs, string str) {
   int num, max;
   object bing;
   string env_sh;
   object ob;
   object *fail;
   object *too_many;
   object *keep;
   mapping ret;
   object env;
   string drop_mess;
   ret = ([ ]);
   fail = ({ });
   too_many = ({ });
   keep = ({ });
   if (sizeof(obs) > MAX_DROP_NUMBER) {
      too_many = obs[MAX_DROP_NUMBER..];
      obs = obs[0..MAX_DROP_NUMBER-1];
   }
   foreach(ob in obs) {
      if (!ob->short()) {
         continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      env = environment(ob);
      if (function_exists("do_drop", ob) ||
            function_exists("command_control", ob)) {
         if (function_exists("do_drop", ob)) {
            max = (int)call_other(ob, "do_drop", ({ }), str, 0, ({ str }),
                                             "<direct:object:me>");
         } else {
            max = ob->command_control("drop", ({ }), str, 0, ({ str }),
                                                   "<direct:object:me>");
         }
         if (max == 0)  {
            fail += ({ ob });
            continue;
         }
      }
      if (ob->move(environment(TP)) == MOVE_OK) {
         if (ret[env]) {
            ret[env] += ({ ob });
         } else {
            ret[env] = ({ ob });
         }
#ifndef __DISTRUBUTION_LIB__
         if(interactive(TP))
           PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
      } else {
        fail += ({ ob });
      }
   }
   if (sizeof(ret)) {
      foreach (env, bing in ret) {
         if (env != this_player()) {
            env_sh = " from inside " + inside_the_short(env);
         } else {
            env_sh = "";
         }
         if ( drop_mess = this_player()->query_drop_mess() ) {
            add_succeeded_mess( drop_mess, bing );
         }
         else {
            add_succeeded_mess("$N $V $I" + env_sh + ".\n", bing);
         }
      }
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding.\n", "" }));
      }
   } else {
      if (sizeof(keep)) {
         add_failed_mess("You are keeping $I.\n", keep);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot drop $I.\n", fail);
         return 0;
      }
      if (sizeof(too_many)) {
         add_failed_mess("You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding $I.\n", too_many);
         return 0;
      }
   }
   num = sizeof(fail)+sizeof(ret);
   if (!num) {
        return 0;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1, $3) :) });
}

==================================================
FILE: living/dry.c
==================================================

inherit "/cmds/base";
mixed cmd(mixed *things)
{
   int pwet;
   int twet;
   int max;
   int *enums;
   object thing;
   object with;
   thing = things[0][0];
   with = things[1][0];
   if (!with->id("towel") && !with->query_property("dryer")) {
      return notify_fail("You can't dry anyone with " +
                         (string) with->the_short() + ".\n");
   }
   if (environment(with) != this_player())  {
      return notify_fail(with->a_short() + " isn't going to do much good "
         "inside " + environment(with)->a_short() + ".\n");
   }
   if (thing->query_property("dead")) {
      return notify_fail((string) thing->the_short() + " is dead; " +
                         (string) thing->query_pronoun() +
                         " has more immediate problems than being wet.\n");
   }
   max = 200 * (int) with->query_weight();
   enums = (int *) with->effects_matching("object.wet");
   if (sizeof(enums)) {
      twet = (int) with->arg_of(enums[0]);
   }
   if (twet > max / 2) {
      return notify_fail((string) with->the_short() +
                         " is already dripping wet.  You can't dry anybody "
                         "with it.\n");
   }
   enums = (int *) thing->effects_matching("body.wetness");
   if (sizeof(enums)) {
      pwet = (int) thing->arg_of(enums[0]);
   }
   if (pwet < 10) {
      if (thing == this_player()) {
         return notify_fail("You don't need drying.\n");
      } else {
         return notify_fail((string) thing->the_short() +
                            " doesn't need drying.\n");
      }
   }
   if (pwet + twet > max) {
      pwet = max - twet;
   }
   pwet -= random(10);
   if (pwet > 0) {
      thing->add_effect("/std/effects/other/wetness", -pwet);
      with->add_effect("/std/effects/object/wet", pwet);
   }
   if (thing == this_player()) {
      write("You dry yourself with " + with->the_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) this_player()->query_objective() + "self with " +
          (string) with->poss_short() + ".\n");
   } else {
      write("You dry " + (string) thing->the_short() + " with " +
            (string) with->the_short() + ".\n");
      tell_object(thing, (string) this_player()->one_short() +
                  " dries you with " + (string) with->poss_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) thing->the_short() + " with " +
          (string) with->poss_short() + ".\n", thing);
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:living'person'> with <indirect:object:me>",
             (: cmd($1) :),
             "myself with <indirect:object:me>",
             (: cmd(({ ({ this_player() }), $1 })) :) });
}

==================================================
FILE: living/echo.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("echo"))
    return notify_fail(NOT_ALLOWED);
  if (!str || str == "")
    return notify_fail("Syntax : echo <text>\n");
  if (!TP->query_creator() && TP->adjust_sp(-ECHO_COST) < 0)
    return notify_fail(NO_POWER);
  if (TP->query_volume(D_ALCOHOL))
    str = TP->drunk_speech(str);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos: "+
     str+"\n");
  str += "%^RESET%^";
  my_mess("You echo: ", str);
  TP->comm_event(environment(TP), "player_echo", str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/echoto.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string who, what;
  object ob;
  if(!TP->query_creator() && !TP->query_property("echoto"))
    return notify_fail(NOT_ALLOWED);
  if(!str || str == "")
    return notify_fail("Syntax : echoto <player> <text>\n");
  if(sscanf(str, "%s %s", who, what) != 2)
    return notify_fail("Syntax : echoto <player> <text>\n");
  who = lower_case(who);
  who = (string)TP->expand_nickname(who);
  if(!TP->query_creator() && TP->adjust_sp(-ECHOTO_COST) < 0)
    return notify_fail(NO_POWER);
  ob = find_player(who);
  if(!ob)
    return notify_fail("Can't find "+who+".\n");
  if (TP->query_volume(D_ALCOHOL))
    what = TP->drunk_speech(what);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos "+
     "to "+who+": "+what+"\n" );
  what += "%^RESET%^";
  my_mess("You echo to " + who + ": ", what);
  event(ob, "player_echo_to", what + "\n", TP);
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/em_ote.c
==================================================

#include <library.h>
#include <player.h>
inherit "/cmds/base";
mixed cmd( string words ) {
  string pad = " ";
  if(!environment(this_player())) {
    return notify_fail("You are in limbo, you cannot emote.\n");
  }
  if ( userp( this_player() ) && !this_player()->query_creator() ) {
    if ( this_player()->query_property( "emote" ) ) {
      LIBRARY->set_quest( (string)this_player()->query_name(), "emote" );
      this_player()->remove_property( "emote" );
    }
    if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
                                     "emote" ) ) {
      return notify_fail( NOT_ALLOWED );
    }
    if(this_player()->query_property("no emote")) {
      return notify_fail(NOT_ALLOWED);
    }
    if ( (int)this_player()->adjust_sp( -EMOTE_COST ) < 0 ) {
      return notify_fail( NO_POWER );
    }
  }
  if ( !words || ( words == "" ) ) {
    return notify_fail( "Syntax: emote <text>\n" );
  }
  words = strip_colours(words);
  words = replace(words, ({"        ", " ",
                           "       ", " ",
                           "      ", " ",
                           "     ", " ",
                           "    ", " ",
                           "   ", " ",
                            }) );
  this_player()->adjust_time_left( -5 );
  if (words[0..0] == "'") pad = "";
  environment( this_player() )->event_emote( this_player(),
                                             "$C$" + this_player()->one_short() + pad +
                                             words +"\n" );
  all_inventory( environment( this_player() ) )->
    event_emote( this_player(), "$C$" + this_player()->one_short() +
                                pad + words + "%^RESET%^\n" );
  write( "You emote: $C$"+
         (string)this_player()->pretty_short( this_player() ) + pad + words +
         "%^RESET%^\n" );
  return 1;
}

==================================================
FILE: living/emoteall.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
#define BEEP sprintf("%c",7)
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("emoteall")) {
    return notify_fail(NOT_ALLOWED);
  }
  if(!str || str == "") {
    return notify_fail("Syntax : emoteall <string>\n");
  }
  if(!TP->query_creator() &&
     TP->adjust_sp(-EMOTEALL_COST*((strlen(str)/10)+1)+100) < 0) {
    return notify_fail(NO_POWER);
  }
  str = replace(str, BEEP, "");
  if (TP->query_volume(D_ALCOHOL)) {
    str = TP->drunk_speech(str);
  }
  log_file("ECHOS", ctime(time())+" "+TP->query_name()+" emotes "+
           "to all: "+str+"\n");
  str += "%^RESET%^";
  my_mess("You emoteall : ", TP->query_cap_name()+" " + str);
  TP->comm_event(users(), "player_emote_all", "%^BOLD%^%^RED%^" + TP->query_cap_name() + " " + str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: living/eq_uip.c
==================================================

#define TP this_player()
inherit "/cmds/base";
int cmd() {
   int no_limbs;
   string stuff;
   object thing;
   object *equipped;
   object *things;
   equipped = ({ });
   things = all_inventory( TP ) - TP->query_wearing() -
            TP->query_holding();
   foreach ( thing in things ) {
      no_limbs = thing->query_no_limbs();
      if ( no_limbs > TP->query_free_limbs() ) {
         continue;
      }
      if ( thing->query_wearable() ) {
         if ( !TP->wear_armour( thing, 0 ) ) {
            equipped += ({ thing });
         }
         continue;
      }
      if (thing->query_weapon() && no_limbs) {
         if ( sizeof( TP->set_hold( thing,
               member_array( 0, TP->query_holding() ) ) ) ) {
            equipped += ({ thing });
         }
      }
   }
   if ( !sizeof( equipped ) ) {
      return notify_fail( "You have no equippable items.\n" );
   }
   stuff = query_multiple_short( equipped );
   say( (string)TP->one_short() +" equips "+ stuff +".\n" );
   write( "You equip "+ stuff +".\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: living/facing.c
==================================================

#include <dirs.h>
inherit "/cmds/base";
string find_direction( object who );
int check_reference_point( object where );
int cmd( object *indirect_obs ) {
    mapping details;
    object *oblist;
    string *show, dir;
    if ( !check_reference_point( environment( this_player() ) ) ) {
        add_failed_mess( "You can't make out a point of reference "
            "to use to determine which way you're facing!\n" );
        return 0;
    }
    if ( !indirect_obs || sizeof( indirect_obs ) == 1 &&
        indirect_obs[ 0 ] == this_player()) {
        tell_object( this_player(), "You are facing " +
            find_direction( this_player() ) + ".\n" );
        return 1;
    }
    indirect_obs -= ({ this_player() });
    details = unique_mapping( indirect_obs,
        (: find_direction( $1 ) :) );
    show = ({ });
    foreach(dir, oblist in details)  {
      if (sizeof(oblist) > 1)  {
        show += ({ query_multiple_short(oblist) + " are facing " + dir });
      }
      else  {
        show += ({ oblist[0]->one_short() + " is facing " + dir });
      }
    }
    write(query_multiple_short(show) + ".\n");
    return 1;
}
string find_direction( object who ) {
    int facing;
    mapping directions;
    facing = who->query_facing()[ 0 ];
    directions = filter( ABS_FACING, (: $2 == $(facing) :) );
    if ( !sizeof( directions ) )
        return "north";
    return keys( directions )[ 0 ];
}
int check_reference_point( object where ) {
    string *relatives;
    relatives = map( where->query_direc(),
        (: $(where)->query_relative( $1 ) :) );
    return member_array( 0, relatives ) > -1;
}
mixed *query_patterns() {
    return ({ "", (: cmd( 0 ) :),
        "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: living/flip.c
==================================================

#include <money.h>
#define EFFECTS "/obj/handlers/mag_eff_handler"
inherit "/cmds/base";
mixed cmd( object *things ) {
   int *effect;
   object place;
   mixed *stuff, *details;
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only flip one thing at once.\n");
      return 0;
   }
   stuff = (mixed *)things[ 0 ]->query_money_array();
   if ( !sizeof( stuff ) ) {
      add_failed_mess( "You must have a coin to flip.\n" );
      return 0;
   }
   if ( ( sizeof( stuff ) > 2 ) || ( stuff[ 1 ] != 1 ) ) {
      add_failed_mess( "You can only flip one coin at a time.\n" );
      return 0;
   }
   details = (mixed *)MONEY_HAND->query_details_for( stuff[ 0 ] );
   if ( details[ MONEY_DETAILS_COMPOSITION ] == "paper" ) {
       add_failed_mess( "You cannot flip $I as you would a coin, because "
        "it is made of paper.\n", things );
       return -1;
   }
   write( "You flip "+ (string)things[ 0 ]->the_short() +".\n" );
   say( (string)this_player()->one_short() +" flips "+
         (string)things[ 0 ]->a_short() +".\n" );
   effect = (int *)EFFECTS->choose_effect(
         (int)EFFECTS->ambient_enchantment( things[ 0 ] ) );
   place = environment( this_player() );
   if ( random( 1000 ) < effect[ 0 ] ) {
      switch( effect[ 1 ] ) {
         case 0 :
            things[ 0 ]->move( place );
            tell_room( place, (string)things[ 0 ]->the_short() +
                  " lands on its edge.\n" );
            break;
         default :
            things[ 0 ]->move( "/room/rubbish" );
      }
      EFFECTS->do_effect( effect[ 1 ], (string)things[ 0 ]->the_short(),
            place );
      return 1;
   }
   things[ 0 ]->move( place );
   tell_room( place, (string)things[ 0 ]->the_short() +" falls "+
         (string)place->query_property( "here" ) +", "+
         details[ random( 2 ) ] +" up.\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

==================================================
FILE: living/fo_llow.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   object *ok, ob;
   object *already;
   string s;
   mapping hide_invis;
   int hiding, sneaking;
   ok = ({ });
   already = ({ });
   foreach (ob in obs) {
      if (member_array(TP, ob->query_followers()) == -1) {
         if (ob->add_follower(TP)) {
            ok += ({ ob });
         }
      } else {
         already += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      if (sizeof(already)) {
         add_failed_mess("You are already following $I.\n", already);
      }
      obs -= already;
      if (sizeof(obs)) {
         if(member_array(TP, obs) == -1) {
            add_failed_mess("You cannot follow " + query_multiple_short(obs) +
                                          ".\n");
         } else {
            add_failed_mess("You can't follow " +
                          query_multiple_short(obs - ({TP}) + ({"yourself"})) +
                          ".\n");
         }
      }
      return 0;
   }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
    write("You follow " + ( s = query_multiple_short( ok ) ) + " unseen.\n" );
  else {
   write("You follow "+(s=query_multiple_short(ok))+".\n");
   say(TP->one_short(1)+" follows "+s+".\n", ok);
   foreach (ob in ok)
      tell_object(ob, TP->one_short(1)+
                      " follows "+query_multiple_short((ok + ({"you"})) -
                      ({ ob }))+".\n");
  }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/g_lance.c
==================================================

#include <obj_parser.h>
#include <dirs.h>
#include <player.h>
inherit "/cmds/base";
int check_exists(string file);
string room_glance(object person, object room, int dark);
mixed cmd_direction(string dir);
int check_pre_stuff() {
   int dark;
   object room;
   room = environment(previous_object());
   if (!room) {
      return notify_fail("You are in limbo... sorry you can't look at "+
             "anything.\n");
   }
   if (!previous_object()->query_property("dead")) {
      dark = (int)previous_object()->check_dark((int)room->query_light());
   }
   if( dark < 0 ) {
      write("It's too dark to look at anything.\n");
      return 1;
   } else if( dark > 0 ) {
      write("It's too bright to look at anything.\n");
      return 1;
   }
   return 2;
}
mixed cmd_ob(object* obs) {
   object thing;
   int retval;
   int dark;
   object room;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   foreach (thing in obs) {
      string tmp;
      if(thing == this_player()) {
        write("That's you that is.\n");
      } else {
        tmp = (string)thing->a_short( dark );
        if (tmp) {
          write(capitalize(tmp) + ".\n");
        }
      }
   }
   return 1;
}
mixed cmd_direction(string dir, int from_string) {
   object room;
   int dark;
   int retval;
   string ret;
   string dest;
   mixed *func;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   retval = 0;
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dir = EXPAND_EXIT(dir);
   if ( room->query_relative( dir ) ) {
      add_failed_mess( "You do not think that the "+ dir +" is here.\n" );
      return 0;
   }
   dir = (string)this_player()->find_abs(dir);
   if(room->query_exit(dir)) {
      room->set_destination( dir );
      if ( check_exists( (string)room->query_destination( dir ) ) ) {
         write("You glance " + dir + " and see:\n");
         ret = room->query_look(dir);
         if (ret) {
            write(ret+"\n");
            return 1;
         }
         func = room->query_look_func(dir);
         if(sizeof(func)) {
            call_other(func[0], func[1], 1);
            return 1;
         }
         dest = room->query_destination(dir);
         if(room->query_door_open(dir) != 0) {
            if (!dark && !previous_object()->query_property("dead") &&
                !previous_object()->query_creator()) {
               dark = previous_object()->check_dark(dest->query_light());
            }
            load_object(dest);
            this_player()->set_looked( find_object( dest ) );
            if (dark) {
               write("It's too dark to see that far.\n");
            } else  {
               write( (string)dest->a_short( dark ) +" "+
                     (string)dest->query_short_exit_string()+".\n"+
                     (string)dest->query_contents(""));
            }
            return 1;
         } else if(room->query_door_open(dir) == 0) {
            write("The "+dir+" door is closed.\n");
         }
      }
   }
   if (!retval) {
      add_failed_mess("You do not think that the "+dir+" is here.\n");
   }
   return retval;
}
string room_glance(object person, object room, int dark) {
   string ret;
   string sees;
   object mirror;
   ret = "";
   if (person->query_creator()) {
      ret += " %^CYAN%^" + file_name(room) + "%^RESET%^";
      sees=(string)room->query_property("creator sees");
      if (sees) {
         ret += sees +"\n"+ (string)room->query_contents();
      }
   }
   mirror = room->query_mirror_room();
   if (mirror) {
      room = mirror;
   }
   if(!dark || previous_object()->query_creator()) {
      if (mirror) {
         ret += ".\n" + (string)mirror->query_contents();
      } else {
         ret += (string)room->query_short_exit_string()+".\n"+
           (string)room->query_contents();
      }
   } else if((dark == 2) || (dark == -2)) {
      if (!mirror) {
         ret += (string)room->query_short_exit_string()+"\n";
      } else {
         ret += "\n";
      }
      if((string)room->query_contents("") != "") {
         ret += person->colour_event("inventory", "%^GREEN%^") +
           "Some objects you can't make out are here.%^RESET%^\n";
      }
   } else {
      ret += "\n";
   }
   if (dark == 1 || dark == -1) {
      ret += "You can't see your hand in front of your face.\n";
   } else  {
      ret = "$a_short:"+ file_name(room) + "$"+ ret;
   }
   if (mirror) {
      ret += "Around " + room->the_short() + " is:\n";
      ret += room_glance(person, mirror, dark);
   }
   return ret;
}
int cmd_here() {
   object room;
   int dark;
   int retval;
   string str;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dark = previous_object()->check_dark((int)room->query_light());
   str = room_glance(previous_object(), room, dark);
   write(str);
   return 1;
}
int check_exists(string file) {
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    return 1;
  }
  return 0;
}
mixed* query_patterns() {
   return ({
             "", (: cmd_here() :),
             "exit <string'exit'>", (: cmd_direction($4[0], 1) :),
             "[at] <indirect:object>", (: cmd_ob($1) :),
             "<string'exit'>", (: cmd_direction($4[0], 0) :),
            });
}

==================================================
FILE: living/get.c
==================================================

#include <obj_parser.h>
#include <move_failures.h>
#include <player.h>
#define DROP_H 40
#define PINCH_H 120
#define MAX_GET_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
object* find_matching_obs(string match_str, object dob) {
   class obj_match result;
   result = (class obj_match)match_objects_in_environments(match_str, dob);
   if (result->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(result));
      return 0;
   }
   return result->objects;
}
mixed cmd(object * obs, string dir, string indir, mixed *args) {
   object *dest;
   object ob;
   object dob;
   object *fail_dest;
   object *too_many;
   mixed *fail;
   mixed *ret;
   mixed amt;
   string sh;
   string hand_unit;
   string match_str;
   int i;
   int num;
   int cap;
   int perc;
   int handful;
   int total_num;
   mixed we;
   object env;
   object *bing;
   fail_dest = ({ });
   cap = (int) TP->query_max_weight();
   if (indir && sizeof(obs) > 10) {
      add_failed_mess("Please be more specific as to what you want "
                      "to get from.\n");
      return 0;
   }
   if (indir) {
      match_str = args[0];
      dest = obs;
   } else {
      if (environment(TP)->query_mirror_room()) {
         dest = ({ environment(TP), environment(TP)->query_mirror_room() });
      } else {
         dest = ({ environment(TP) });
      }
   }
   too_many = ({ });
   foreach(dob in dest) {
     if (!is_in_me_or_environment(dob, this_player())) {
         fail_dest += ({ dob });
         continue;
      }
      if (dob->cannot_get_stuff() || dob->query_closed()) {
         fail_dest += ({ dob });
         continue;
      }
      if (living(dob) && !dob->allowed_to_loot(this_player())) {
        fail_dest += ({ dob });
        continue;
      } else if (indir) {
         obs = find_matching_obs(match_str, dob);
      }
      if (!obs) {
         continue;
      }
      if (total_num + sizeof(obs) > MAX_GET_NUMBER) {
         if (total_num > MAX_GET_NUMBER) {
            too_many += obs;
            obs = ({ });
         } else {
            too_many += obs[MAX_GET_NUMBER - total_num..];
            obs = obs[0..MAX_GET_NUMBER - total_num - 1];
         }
      }
      total_num += sizeof(obs);
      ret = ({ ([ ]), ([ ]), ([ ]), ([ ]), ([ ]), });
      fail = ({ });
      foreach(ob in obs) {
        env = environment(ob);
        if(env != dob) {
          if(ob->query_collective())
            ob->move(dob);
          else
            dob = env;
        }
        if ((living(dob) && !dob->allowed_to_loot(this_player(), ob)) ||
            (ob->query_liquid() && ob->query_food_object())) {
          fail += ({ ob });
          num++;
          continue;
        }
         if (ob->query_continuous()) {
            amt = ob->query_amount_types();
            if (amt["handful"]) {
               hand_unit = "handful";
               handful = amt["handful"][0];
            } else if ((amt["drop"]) && (ob->query_liquid())) {
               hand_unit = "drops";
               handful = amt["drop"][0] * DROP_H;
            } else if (amt["pinch"]) {
               hand_unit = "pinches";
               handful = amt["pinch"][0] * PINCH_H;
            } else {
               handful = ob->query_amount();
            }
            if (ob->query_amount() > handful) {
               if (!match_str) {
                  match_str = ob->query_name();
               }
               if (i = strsrch(match_str, "of") >= 0) {
                  i += 3;
               }
               if (hand_unit == "handful") {
                  handful = 1;
               }
               match_str = handful + " " + hand_unit + " of " +
                  match_str[i..];
               fail += ({ "all of the " + ob->short() });
               ob = ob->query_parse_id(({ handful, match_str }));
               if (!ob) {
                  continue;
               }
               num++;
            }
         }
         if (function_exists("do_get", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_get", ob)) {
               we = (int) call_other(ob, "do_get", dob, 0, match_str,
                                     ({ 0, match_str }),
                                     "<direct:object> from <indirect:object>");
            } else {
               we = ob->command_control("get", dob, 0, match_str,
                                        ({ 0, match_str }),
                                        "<direct:object> from <indirect:object>");
            }
            if (!objectp(we)) {
               if (we) {
                  we = (int) ob->query_weight();
                  perc = (we * 100) / cap;
                  if (perc >= 95) {
                     i = 4;
                  } else {
                     i = perc / 25;
                  }
                  if (!ret[i][env]) {
                     ret[i][env] = ({ ob });
                  } else {
                     ret[i][env] += ({ ob });
                  }
               } else {
                  if (member_array(ob, this_player()->query_succ_mess_indir())
                      == -1 && !query_notify_fail() && !living(ob)) {
                     fail += ({ ob });
                  }
                  num++;
               }
               continue;
            } else {
               ob = we;
            }
         }
#ifndef __DISTRIBUTION_LIB__
         if(interactive(TP) &&
            PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("get", TP, ob)) {
           fail += ({ ob });
           num++;
         } else
#endif
         if ((int) ob->move(TP) == MOVE_OK) {
            we = (int) ob->query_weight();
            perc = (we * 100) / cap;
            if (perc >= 95) {
               i = 4;
            } else {
               i = perc / 25;
            }
            if (!ret[i][env]) {
               ret[i][env] = ({ ob });
            } else {
               ret[i][env] += ({ ob });
            }
         } else {
            fail += ({ ob });
            num++;
         }
      }
      for (i = 0; i < sizeof(ret); i++) {
         if (sizeof(ret[i])) {
            foreach(env, bing in ret[i]) {
               if (this_player()->query_succ_mess_dir()) {
                  bing -= this_player()->query_succ_mess_dir();
               }
               if (sizeof(bing)) {
                  sh = query_multiple_short(bing);
                  write("You " + ({ "get", "get with a bit of difficulty",
                                    "struggle somewhat to get",
                                    "find it very difficult to get",
                                    "use all your strength and just barely manage to get" })
                        [i] + " " + sh + " from " + inside_the_short(dob) +
                        ".\n");
                  say(capitalize((string) TP->one_short()) + " " +
                      ({ "gets", "gets with a bit of difficulty",
                         "struggles somewhat to get",
                         "finds it very difficult to get",
                         "uses all " + TP->query_possessive() +
                         " strength and just barely manages to get" })[i] +
                      " " + sh + " from " + inside_a_short(dob) + ".\n");
               }
            }
         }
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot get $I.\n", fail);
      }
   }
   if (num == total_num) {
      if (query_notify_fail()) {
         return 0;
      }
      if (indir) {
         if (sizeof(fail_dest)) {
            add_failed_mess("You cannot get anything from $I.\n", fail_dest);
         }
      } else {
         add_failed_mess("You cannot get $I.\n", obs);
      }
      return -1;
   } else {
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You cannot pick up more than " +
                               query_num(MAX_GET_NUMBER) +
                               " objects at a time; " "discarding $I.\n",
                               "" }), too_many);
      }
   }
   return 1;
}
mixed *
query_patterns()
{
   return ({ "<indirect:object:here>", (: cmd($1, 0, 0, 0) :),
             "<string> from <indirect:object>", (: cmd($1, $2, $3, $4) :) });
}

==================================================
FILE: living/give.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "cmds/base";
#define TP this_player()
#define SUPPRESS_MESS "suppress give messages"
mixed cmd(mixed *indir, string *indir_match) {
  string sh;
  string s1;
  string failmess;
  int tot;
  int max;
  int ok;
  object *per;
  object *ret;
  object *fail;
  object pobj;
  object ob;
  object *obs;
  object *succ;
  object *keep;
  per = indir[1];
  succ = ({ });
  keep = ({ });
  failmess = "";
  foreach(pobj in per) {
    obs = indir[0];
    obs -= per;
    if (pobj->query_property("player") && !interactive(pobj)) {
      failmess = pobj->the_short()+" seems too chalky to accept your "
        "gift.\n";
      continue;
    }
    if (pobj == TP) {
     failmess = "You nag yourself for a while, but can't convince "
                 "yourself to accept things from yourself.\n";
     continue;
    }
    if (!sizeof(obs)) {
      failmess = "Nothing to give to "+ pobj->short() +".\n";
      continue;
    }
    ret = ({ });
    fail = ({ });
    foreach(ob in obs) {
      if ( member_array( ob, succ ) > -1 ) {
        continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      if (function_exists("do_give", ob) ||
          function_exists("command_control", ob)) {
        if (function_exists("do_give", ob)) {
          max = call_other(ob, "do_give", pobj, indir_match[0],
                                indir_match[1],
                                ({ indir_match[0], indir_match[1] }),
                                "<direct:object:me> to <indirect:living>");
        } else {
          max = ob->command_control("give", pobj, indir_match[0],
                                    indir_match[1],
                                    ({ indir_match[0], indir_match[1] }),
                                    "<direct:object:me> to <indirect:living>");
        }
        if (max == 0)  {
          fail += ({ ob });
          continue;
        }
      }
#ifndef __DISTRIBUTION_LIB__
      PLAYER_MULTIPLAYER_HANDLER->record_object("give", TP, ob);
      if(pobj->query_property("player") && interactive(TP) &&
         "/obj/handlers/multiplayer"->check_multiplayers("give", pobj, ob)) {
        fail += ({ ob });
      } else
#endif
      if (pobj->query_closed()  ||  ob->move(pobj) != MOVE_OK) {
        fail += ({ ob });
      } else  {
        ret += ({ ob });
        tot += ob->query_weight();
      }
    }
    if (sizeof(ret)) {
      ok = 1;
      succ += ret;
      if (pobj->query_clothing()) {
        s1 = pobj->query_pocket_mess();
      } else {
        s1 = "$ob_short$";
      }
      sh = query_multiple_short(ret);
      if ( interactive( pobj ) || !pobj->query_property( SUPPRESS_MESS ) ) {
        tell_object(TP, "You give "+ sh +" to "+
                  replace_string(s1, "$ob_short$", pobj->one_short())+
                  ".\n");
        tell_room(environment(TP), TP->one_short() + " gives " + sh +
               " to " + replace_string(s1, "$ob_short$",
                                      pobj->one_short()) +
               ".\n", ({ TP, pobj }));
        tell_object(pobj, capitalize(TP->one_short() ) + " gives "+
                    sh + " to you.\n" );
      }
      if (living(pobj) && (max = pobj->query_max_weight()))
        if ((max = tot*100/max) > 25)
          if (max >= 95) {
            tell_room(environment(TP),
                      pobj->the_short()+" staggers under a weight "+
                      pobj->query_pronoun()+" can only just carry.\n",
                      ({ pobj }) );
            pobj->event_say(TP, "You stagger under a weight you can only "
                            "just carry.\n");
          } else {
            tell_room(environment(TP), pobj->the_short()+ ({
              " is only mildly discomforted by the additional weight.\n",
              " braces "+pobj->query_objective()+"self to take the load.\n",
              " stumbles as "+pobj->query_pronoun()+" takes the load.\n"
              })[(max/25)-1], ({ pobj }) );
            pobj->event_say(TP, "You"+ ({
              " are only mildly discomforted by the additional weight.\n",
              " brace yourself under the load.\n",
              " stumble as you take the load.\n"
              })[(max/25)-1]);
          }
    }
    if (sizeof(fail)) {
      failmess += "You cannot give "+query_multiple_short(fail)+ " to "+
                  pobj->one_short() +".\n";
    }
  }
  if (!ok) {
    add_failed_mess(failmess);
    if (sizeof(keep)) {
       add_failed_mess("You have $I set to be kept.\n", keep);
    }
  }
  return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me> to <indirect:living>",
            (: cmd($1, $3) :) });
}

==================================================
FILE: living/ho_ld.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object * obs,
        string str)
{
   int num_limbs;
   int avail;
   int old_avail;
   int reqd;
   int i;
   int pos;
   int success;
   int *used;
   int *already_used;
   int *limbs_used;
   object ob;
   object weapon;
   object *using;
   object *fails;
   object *unfails;
   object *holds;
   object *unholds;
   object *already;
   object *no_change;
   string *limbs;
   string *hhands;
   string *uhands;
   limbs = TP->query_limbs();
   num_limbs = sizeof(limbs);
   avail = TP->query_free_limbs();
   no_change = ({ });
   already = filter(obs, (: $1->query_holder() :));
   if (sizeof(already) > 0) {
      using = this_player()->query_holding();
      foreach (ob in already)  {
         limbs_used = find_member(ob, using);
         if (str)  {
            if (sizeof(limbs_used) == 1  &&
                member_array(str, limbs) == limbs_used[0])
            {
               no_change += ({ ob });
            }
            else already -= ({ ob });
         }
         else if (sizeof(limbs_used) != ob->query_no_limbs())
            already -= ({ ob });
      }
      if (sizeof(obs) == sizeof(no_change))  {
         add_failed_mess("You are already holding " +
                         query_multiple_short(obs) +
                         " in your " + str + ".\n");
         return -1;
      }
      else if (sizeof(obs) == sizeof(already)) {
         return notify_fail("You are already holding " +
                            query_multiple_short(obs) + ".\n");
      } else {
         obs -= already;
         if (sizeof(already) > 0)
            write(sprintf("You are already holding %s, you instead try to "
                          "hold %s.\n", query_multiple_short(already),
                          query_multiple_short(obs)));
         already_used = map(already, (: $1->query_my_limb() :));
      }
   } else {
      already_used = ({ });
   }
   fails = holds = unholds = hhands = uhands = unfails = ({ });
   if (str && obs[0]) {
      pos = member_array(str, limbs);
      if (pos == -1) {
         if (!sizeof(limbs)) {
            return
               notify_fail("You seem to have a singular lack of limbs.\n");
         }
         return notify_fail("Incorrect limb type, must be one of " +
                            query_multiple_short(limbs) + ".\n");
      }
      using = TP->query_holding();
      if (sizeof(unfails) == 0  &&  using[pos]) {
         used = TP->set_unhold(using[pos]);
         if (sizeof(used) == 0) {
            unfails += ({ using[pos] });
            uhands += ({ limbs[pos] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ using[pos] });
         }
      }
      if ((i = member_array(obs[0], using - unholds)) != -1)  {
         used = TP->set_unhold(obs[0]);
         if (sizeof(used) == 0) {
            unfails += ({ obs[0] });
            uhands += ({ limbs[i] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ obs[0] });
         }
      }
      if (sizeof(unfails) == 0) {
         used = TP->set_hold(obs[0], pos, 1);
         if (sizeof(used) == 0) {
            fails += ({ obs[0] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               hhands += ({ limbs[used[i]] });
            }
            holds += ({ obs[0] });
            success = 1;
         }
      }
   } else {
      foreach(ob in obs) {
         reqd += ob->query_no_limbs();
      }
      if (reqd > num_limbs) {
         add_failed_mess("You do not have enough limbs to hold $I.\n", obs);
         return 0;
      }
      old_avail = -1;
      while ((avail < reqd) && (avail < num_limbs)) {
         if ((reqd > num_limbs - sizeof(unfails)) || (old_avail == avail)) {
            if (sizeof(unfails)) {
               add_failed_mess
                  ("You do not have enough limbs to hold $I, since " +
                   query_multiple_short(unfails) + " failed " "to unhold.\n",
                   obs);
            } else {
               add_failed_mess
                  ("Not able to free up enough limbs to hold $I.\n", obs);
            }
            return 0;
         }
         old_avail = avail;
         using = TP->query_holding();
         for (i = 0; i < sizeof(using); i++) {
            weapon = using[i];
            if (weapon && member_array(i, already_used) == -1) {
               used = TP->set_unhold(weapon);
               if (sizeof(used)) {
                  for (i = 0; i < sizeof(used) && used[i] < sizeof(limbs);
                       i++) {
                     uhands += ({ limbs[used[i]] });
                  }
                  unholds += ({ weapon });
                  avail = TP->query_free_limbs();
                  break;
               } else {
                  if (member_array(weapon, unfails) == -1) {
                     unfails += ({ weapon });
                  }
                  uhands += ({ limbs[i] });
               }
            }
         }
      }
      if (!sizeof(unfails)) {
         foreach(ob in obs) {
            using = TP->query_holding();
            pos = 0;
            if (!ob->query_no_limbs() || avail < ob->query_no_limbs()) {
               fails += ({ ob });
               break;
            }
            while ((using[pos]) && (pos < num_limbs)) {
               pos++;
            }
            used = TP->set_hold(ob, pos, ob->query_no_limbs());
            if (used == ({ })) {
               fails += ({ ob });
            } else {
               for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
                  hhands += ({ limbs[used[i]] });
               }
               holds += ({ ob });
               success = 1;
               avail = TP->query_free_limbs();
            }
         }
      }
   }
   if (sizeof(unfails)) {
      tell_object(TP,
                  "You fail to put down " + query_multiple_short(unfails) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " fails to put down " +
          query_multiple_short(unholds) + " from " + TP->query_possessive() +
          " " + query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(unholds)) {
      tell_object(TP, "You put down " + query_multiple_short(unholds) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " puts down " + query_multiple_short(unholds) +
          " from " + TP->query_possessive() + " " +
          query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(holds)) {
      tell_object(TP,
                  "You hold " + query_multiple_short(holds) + " in your " +
                  query_multiple_short(hhands) + ".\n");
      say(TP->one_short() + " holds " + query_multiple_short(holds) + " in " +
          TP->query_possessive() + " " + query_multiple_short(hhands) +
          ".\n");
   }
   if (!success && sizeof(fails)) {
      tell_object(TP,
                  "You fail to hold " + query_multiple_short(fails) + ".\n");
      say(TP->one_short() + " fails to hold " + query_multiple_short(fails) +
          ".\n");
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me>", (: cmd($1, 0) :),
             "<indirect:object:me> in [my] {" +
             implode(this_player()->query_limbs(), "|") + "}",
             (: cmd($1, implode($4[1..], " ")) :) });
}

==================================================
FILE: living/kill.c
==================================================

#include <player.h>
inherit "/cmds/base";
int cmd( object* things ) {
   object thing;
   object *fighting;
   if ( !environment( this_player() ) ) {
      add_failed_mess( "You are in limbo...\n" );
      return 0;
   }
   if ( this_player()->no_offense() ) {
      add_failed_mess( "You cannot attack anyone at the moment.\n" );
      return 0;
   }
   things -= ({ this_player() });
   if ( !sizeof( things ) ) {
      add_failed_mess( "You shouldn't beat yourself up so much.\n");
      return 0;
   }
   foreach ( thing in things ) {
      if ( !userp( thing ) ) {
         if ( userp( this_player() ) ||
               !thing->query_property( "no attack" ) ) {
            this_player()->attack_ob( thing );
            thing->attack_by(this_player());
         }
         continue;
      }
      if ( !interactive( thing ) ) {
         write( (string)thing->the_short() +" is net-dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "guest" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +" is a guest.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "dead" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +
                " is already dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_auto_loading() ) {
         write( "Be sporting; "+ (string)thing->the_short() +
               " doesn't have "+ (string)thing->query_possessive() +
               " equipment yet.\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
           !this_player()->query_player_killer() ) {
         write( "You cannot summon the courage to attack "+
               (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
            !thing->query_player_killer() ) {
         write( "Something tells you that it would be wrong "
               "to attack "+ (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      call_out( (: this_player()->attack_ob( $(thing) ) :), 0);
      call_out( (: $(thing)->attack_by(this_player()) :), 0);
   }
    if ( sizeof( things ) ) {
      fighting = ({ });
      foreach(thing in things) {
        object *list;
        list = thing->query_attacker_list();
        if (arrayp(list)) {
           fighting += list;
        }
      }
      if(sizeof(fighting))
        fighting = filter(uniq_array(fighting),
                          (: $1 && environment($1) != environment(this_player()) :));
      if(!sizeof(fighting))
        this_player()->add_succeeded_mess(this_object(),
                                          ({ "You prepare to attack " + query_multiple_short(things) + ".\n", "" }), ({ }) );
      else
        this_player()->add_succeeded_mess(this_object(),
					  ({ "You prepare to attack " + query_multiple_short(things) + " who " + (sizeof(things) > 1 ? "are" : "is") + " already hunting " + query_multiple_short(fighting) + ".\n", "" }), ({ }) );
        return 1;
    } else {
        add_failed_mess("");
        return 0;
    }
}
mixed *query_patterns() {
   return ({ "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: living/kneel.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("kneel", "down", KNEELING);
}

==================================================
FILE: living/l_ook.c
==================================================

#include <player.h>
#include <weather.h>
#include <dirs.h>
#include <error_handler.h>
#include <db.h>
#include <terrain_map.h>
inherit "/cmds/base";
#define TP this_player()
string weather_long(string str);
int check_exists(string file);
string look_around();
mixed cmd_string(string arg);
void finish_bug_summary(object player, int type, mixed data) {
   class error_complete summ;
   class error_complete* errors;
   string str;
   int pos;
   if (type != DB_SUCCESS) {
      return ;
   }
   errors = data;
   if (!sizeof(errors)) {
      tell_object(player, "No errors for this room.\n");
      return ;
   }
   str = "";
   str = sprintf("#<bug id>  ( <date> ) %5-s %4-s %-4s by %11-s %11-s\n",
                 "Status", "Type", "Cat", "Reporter", "Assigned");
   foreach (summ in errors) {
      pos = strsrch(summ->details->report, "\n");
      if (pos < 0 || pos > player->query_cols() - 5) {
         pos = player->query_cols() - 5;
      } else {
         pos --;
      }
      str += sprintf("$I$3=#%d (%s) %5-s %4-s %-4s by %11-s %11-s\n%s\n",
                     summ->details->summary->id,
                     ctime(summ->details->summary->entry_date)[4..15],
                     summ->details->summary->status[0..4],
                     summ->details->summary->type,
                     summ->details->summary->category[0..3],
                     summ->details->summary->reporter,
                     summ->details->summary->assigned_to,
                     summ->details->report[0..pos]);
   }
   tell_object(player, str);
}
void show_error_summary(object player, string* types) {
   class error_query query;
   if (!arrayp(types) || !sizeof(types)) {
      return ;
   }
   query = new(class error_query);
   query->file_name = file_name(environment(player));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   query->type = types;
   query->no_extra_details = 1;
   ERROR_HANDLER->do_query_multiple_bug_details(query, (: finish_bug_summary, player :));
}
int cmd_look_room()
{
   object room;
   int dark;
   string ret;
   int *coords;
   room = environment(TP);
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (TP->query_creator()) {
      coords = room->query_co_ord();
      if (sizeof(coords)) {
         ret = "  (" + coords[0] + "," + coords[1] + "," + coords[2] + ")";
      } else {
         ret = "  (unset)";
      }
      if (virtualp(room)) {
         write("%^CYAN%^" + file_name(room) + " [" +
                room->query_property("base path")  + "]" + ret + "%^RESET%^\n");
      } else {
         write("%^CYAN%^" + file_name(room) + ret + "%^RESET%^\n");
      }
   }
   if ((TP->query_creator() || TP->query_playtester()) &&
       TP->query_property(TERRAIN_MAP_IN_LOOK_PROP)) {
      ret = room->long_test(0, dark);
      if (ret) {
         write("$P$Look$P$" + ret);
      } else {
         write("$P$Look$P$" + (string) room->long(0, dark));
      }
   } else {
      write("$P$Look$P$" + (string) room->long(0, dark));
   }
   if (dark && TP->query_creator()) {
      write("%^YELLOW%^As a creator, you can see:%^RESET%^\n" +
            (string) room->long(0, 0));
   }
   if (TP->query_creator() && TP->query_property(PLAYER_SHOW_ERRORS_PROP)) {
      show_error_summary(this_player(), TP->query_property(PLAYER_SHOW_ERRORS_PROP));
   }
   return 1;
}
string query_look_thing(object thing,
                        object player,
                        int dark,
                        string verb,
                        string arg)
{
   string ret;
   object env;
   string other;
   string replaced;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   ret = "";
   if (living(thing)) {
      if (thing == player) {
         ret += "Looking at yourself again?  What a narcissist!\n";
      } else {
         tell_object(thing, "$one_short:" + file_name(player) +
                     "$ $V$0=looks,look$V$ at you.\n");
      }
   } else {
      env = environment(thing);
      while (env && !living(env)) {
         env = environment(env);
      }
   }
   if (env && env != player) {
      tell_object(env, player->the_short() + " " + verb + " "
                  "at your " + thing->pretty_short() + ".\n");
      other = thing->query_long(arg, dark);
      if (other) {
         replaced = thing->replace_long_dollars(player, other);
         if (replaced) {
            ret += replaced;
         }
         else {
            ret += other;
         }
      }
      other = thing->query_long_details(arg, dark, player);
      if (other) {
         ret += other;
      }
   } else {
      ret += thing->long(arg, dark);
   }
   return ret;
}
mixed cmd_object(object * obs,
                 string arg)
{
   object thing;
   object room;
   int dark;
   int retval;
   string ret;
   room = environment(TP);
   if (LENGTHEN[arg]) {
     arg = LENGTHEN[arg];
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   ret = "";
   foreach(thing in obs) {
      ret += query_look_thing(thing, this_player(), dark, "looks", arg);
   }
   if (ret != "") {
      write("$P$Look$P$" + ret);
      retval = 1;
   }
   if (room->query_exit(arg))
      cmd_string(arg);
   else {
      arg = (string) this_player()->find_abs(arg);
      if (room->query_exit(arg))
         cmd_string(arg);
   }
   return 1;
}
mixed cmd_string(string arg)
{
   object room;
   int dark;
   int retval;
   string ret;
   string other;
   string orig_arg;
   mixed *func;
   room = environment(TP);
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   switch (arg) {
   case "soul":
      write((string) "/obj/handlers/new_soul"->help_list());
      return 1;
   case "sun":
   case "moon":
   case "stars":
   case "weather":
   case "sky":
      write(weather_long(arg));
      return 1;
   case "around":
      write(look_around());
      return 1;
   }
   orig_arg = arg;
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (!room->query_exit(arg)) {
      arg = (string) this_player()->find_abs(arg);
   }
   if (room->query_exit(arg)) {
      int tmp_ret_val;
      room->set_destination(arg);
      other = (string) room->query_destination(arg);
      ret = room->query_look(arg);
      if (ret && ret != "") {
         write(ret + "\n");
         retval = 1;
         tmp_ret_val = 1;
      }
      func = room->query_look_func(arg);
      if (pointerp(func) && sizeof(func) >= 1 && func[0] && func[1]) {
         if (call_other(func[0], func[1], 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      } else if (functionp(func)) {
         if (evaluate(func, 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      }
      if (check_exists(other) && !tmp_ret_val) {
         object door;
         door = room->query_door_control(arg);
         if (room->query_door_open(arg) || door->query_transparent()) {
            other->force_load();
            dark = (int) TP->check_dark((int) other->query_light());
            ret = other->long(0, dark);
            this_player()->set_looked(find_object(other));
            write(ret);
            retval = 1;
         } else {
            add_failed_mess(door->the_short() +
                            " is closed and not transparent.\n");
            retval = 0;
         }
      }
   }
   return retval;
}
int check_exists(string file)
{
   int retval;
   if (objectp(find_object(file))) {
      return 1;
   }
   if (strsrch(file, ":")) {
      return 1;
   }
   if (file_size(file + ".c") > 0) {
      retval = 1;
   } else {
      retval = 0;
   }
   return retval;
}
string weather_long(string str)
{
   object env;
   string temp;
   string whandler;
   env = environment(TP);
   temp = (string) env->query_property("location");
   switch (temp) {
   case ("inside"):
      return "You are not outside.\n";
   }
   whandler = env->query_weather_handler() ;
   if ( ! whandler ) {
       whandler = WEATHER ;
   }
   if (str == "sun") {
      if (whandler->query_day(env)) {
         return "Ouch that hurts.\n";
      } else {
         return "The sun is not up, sorry.\n";
      }
   }
   if (str == "moon") {
      if (whandler->query_day(env)) {
         return "The moon is not up, try at night.\n";
      } else if ( (temp = whandler->query_moon_string(env)) ) {
         return temp;
      } else {
         return "The moon is not up at the moment, try again later.\n";
      }
   }
   if (str == "stars") {
       if (whandler->query_day(env)) {
           return "The stars are not out at the moment - try at night.\n" ;
       } else {
           if ( (temp = whandler->query_star_string(env)) ) {
               return temp ;
           } else {
               return "There aren't any visible stars right now.\n" ;
           }
       }
   }
   return "You look up at the sky.  " + whandler->weather_string(env) + ".\n";
}
string look_around()
{
   int i;
   int j;
   string prep;
   string room;
   string *parts;
   string *rooms;
   object place;
   object thing;
   object *contents;
   mixed *locations;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   place = environment(this_player());
   if (place->query_linked()) {
      rooms = (string *) place->query_rooms();
   } else {
      rooms = ({ });
   }
   locations = ({ });
   say((string) this_player()->one_short() + " $V$0=looks,look$V$ around.\n");
   foreach(room in rooms) {
      if (!find_object(room)) {
         continue;
      }
      if (this_player()->check_dark((int) room->query_light())) {
         continue;
      }
      contents = ({ });
      foreach(thing in all_inventory(find_object(room))) {
         if (living(thing) && thing->query_visible(this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         continue;
      }
      prep = (string) room->query_static_preposition();
      if (prep != "") {
         if (!stringp(prep)) {
            prep = sprintf("%O", prep);
         }
         prep += " ";
      }
      locations += ({ ({ contents, prep +
                         (string) this_player()->
                         convert_message((string) room->the_short())
                      }) });
   }
   if (!sizeof(locations)) {
      contents = ({ });
      if (this_player()->check_dark((int) place->query_light())) {
         return "You can't see well enough to look around here.\n";
      }
      foreach(thing in all_inventory(place)) {
         if (living(thing) && thing->query_visible(this_player()) &&
             (thing != this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         return "You do not see anyone else about.\n";
      }
      return "$C$" + query_multiple_short(contents) +
         " $V$0=is,are$V$ here.\n";
   }
   for (i = 0; i < sizeof(locations) - 1; i++) {
      for (j = i + 1; j < sizeof(locations); j++) {
         if (locations[i][1] == locations[j][1]) {
            locations[i][0] += locations[j][0];
            locations = delete(locations, j, 1);
            j--;
         }
      }
   }
   parts = ({ });
   for (i = 0; i < sizeof(locations); i++) {
      parts += ({ query_multiple_short(locations[i][0]) + " " +
                  locations[i][1] });
   }
   if (sizeof(parts) == 1) {
      return "You can see " + parts[0] + ".\n";
   }
   return "You can see " + query_multiple_short(parts) + ".\n";
}
mixed *query_patterns()
{
   return ({ "", (: cmd_look_room() :),
             "<string'direction'>", (: cmd_string($4[0]) :),
             "<indirect:object>", (: cmd_object($1, $4[0]) :),
             "at <indirect:object>", (: cmd_object($1, $4[0]) :),
             "in <indirect:object>", (: cmd_object($1, $4[0]) :),
             "inside <indirect:object>", (: cmd_object($1, $4[0]) :),
             "around", (: cmd_string("around") :) });
}

==================================================
FILE: living/learn.c
==================================================

#include <skills.h>
#include <tune.h>
#include <cmds/teach.h>
#include <command.h>
inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str, object *obs);
mixed cmd(string str, object *obs) {
  object *diff_lvl;
  object *no_xp;
  object *not_offer;
  object *ok;
  object *moved;
  object ob;
  int time;
  string skill;
  string cmd;
  string cmd_ob;
  string *bits;
  string levelstr;
  class teaching_skill womble;
  if (TP->query_property("dead")) {
    notify_fail("Your dead.  Your mind slips off the task and goes for "
                "a wander down memory lane.\n");
    return 0;
  }
  skill = str;
  bits = explode(implode(explode(skill, " "), "."), ".");
  skill = SKILL_OB->query_skill(bits);
  if (!skill) {
    ok = ({ });
    cmd = str;
    if (sizeof(CMD_D->GetPaths(cmd)) &&
        CMD_D->GetPaths(cmd)[0]) {
       cmd_ob = CMD_D->GetPaths(cmd)[0] + "/" + cmd;
       foreach (ob in obs) {
          bits = TP->query_respond_command(TEACH_COMMAND_TYPE, ob);
          if (pointerp(bits) && member_array(cmd, bits) != -1) {
             cmd_ob->teach_command(ob, this_player());
             ok += ({ ob });
             bits -= ({ cmd });
             if (sizeof(bits)) {
                TP->add_respond_command(TEACH_COMMAND_TYPE, ob, bits);
             } else {
                TP->remove_respond_command(TEACH_COMMAND_TYPE, ob);
             }
             event(environment(this_player()), "teach", "command", ob, this_player());
             break;
          }
       }
       if (sizeof(ok)) {
          add_succeeded_mess("$N learn$s " + cmd + " from $I.\n", ok);
          return 1;
       }
       add_failed_mess("The skill \"" + cmd + "\" is invalid, or $I "
                       "is not trying to teach you the \"" + cmd + "\" "
                       "command.\n");
    } else {
       add_failed_mess("The skill '" + cmd + "' is invalid.\n");
    }
    return 0;
  }
  moved = ok = not_offer = no_xp = diff_lvl = ({ });
  foreach (ob in obs) {
    womble = TP->query_respond_command(TEACH_SKILL_TYPE, ob);
    if (!womble) {
      not_offer += ({ ob });
      continue;
    }
    if (skill != womble->skill) {
      not_offer += ({ ob });
      continue;
    }
    if ((int)TP->query_xp() < womble->xp ||
        !womble->xp) {
      no_xp += ({ ob });
      continue;
    }
    if (TP->query_skill(womble->skill) != womble->lvl) {
      diff_lvl += ({ ob });
      TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
      continue;
    }
    if (sizeof(ok)) {
      continue;
    }
    if(womble->num == 1)
      levelstr = "level";
    else
      levelstr = "levels";
    if (environment(this_player()) != womble->room) {
       moved += ({ ob });
       TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
       continue;
    }
    if (ob != TP) {
      write(ob->short()+" starts to teach you " + womble->num + " " +
            levelstr + " of " + womble->skill + " for " + womble->xp +
            " xp.\n");
      tell_object(ob, "You start to teach " + TP->short() +
                  " " + womble->num + " " + levelstr +
                  " of " + womble->skill +
                  " for " + womble->xp + " xp.\n");
      say(ob->short()+" starts to teach "+TP->short()+" some skills.\n",
          ({ TP, ob }));
      ok += ({ ob });
    } else {
      write("You start to teach yourself " + womble->num + " " +
            levelstr + " in "+
            womble->skill + " for " + womble->xp + " xp.\n");
      say(TP->short()+" starts to teach " + TP->query_objective() +
          "self some skills.\n", ({ TP }));
    }
    time = womble->xp / TIME_DIV;
    if(time > 1000) {
      time = 1000;
    }
    TP->adjust_time_left(-time);
    womble->teacher = ob;
    womble->taught = TP;
    TP->set_interupt_command("stop_teaching_skills", file_name(this_object()),
                             womble);
    if (TP != ob) {
      ob->adjust_time_left(-time);
      ob->set_interupt_command("stop_teaching_skills", TP, womble);
    }
  }
  if (sizeof(not_offer)) {
    if(sizeof(not_offer) == 1) {
      if(not_offer[0] != this_player())
        write(capitalize(query_multiple_short(not_offer)) +
              " is not offering to teach you "+ skill+".\n");
      else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach yourself "+ skill+".\n");
    } else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach you "+ skill+".\n");
  }
  if (sizeof(moved)) {
    write("You appear to have moved away from the excellent teaching "
          "environment selected by "+
          query_multiple_short(moved)+".\n");
  }
  if (sizeof(no_xp)) {
    write("You do not have enough xp to learn "+skill+" from "+
          query_multiple_short(no_xp)+".\n");
  }
  if (sizeof(diff_lvl)) {
    write("You were a different level in "+skill+" when "+
          query_multiple_short(diff_lvl)+" offered to teach you.\n");
  }
  if (sizeof(ok)) {
    say(TP->short()+" learns some skills from "+query_multiple_short(ok)+
        ".\n", ok);
  }
  return 1;
}
void stop_teaching_skills(int time_left, class teaching_skill womble,
                          object us, object interupter, string cmd) {
   object ob;
   mixed *stuff;
   string levelstr;
   if (time_left > 0) {
      if (womble->teacher == us) {
         if (womble->teacher == womble->taught) {
            say(womble->taught->short() + " stops teaching " +
                womble->taught->query_objective() + "self some "
                "skills.\n");
         } else if (us == interupter) {
            ob = womble->teacher;
            tell_object(ob, womble->taught->short() + " interupts your "
                            "training.\n");
         } else {
            tell_object(us, interupter->short() + " interupts your "
                            "training.\n");
         }
         say(interupter->short() + " stops teaching some skills to " +
             womble->taught->short() + ".\n",
             ({ us, interupter }));
      }
      if (us == womble->teacher) {
         ob = womble->taught;
      } else {
         ob = womble->teacher;
      }
      if (ob) {
         stuff = ob->query_interupt_command();
         if (stuff) {
            if (stuff[0] == "stop_teaching_skills") {
               ob->interupt_command(us);
            }
         }
      }
      us->adjust_time_left(-((int)womble->taught->query_time_left()));
      us->set_interupt_command(0);
      return ;
   }
   if (interupter != us) {
      return ;
   }
   if (environment(womble->taught) != environment(womble->teacher) ||
       environment(womble->taught) != womble->room) {
      tell_object(us, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      tell_object(womble->teacher, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      return;
   }
   if(womble->taught->query_xp() < womble->xp) {
      write("Something has gone wrong. :(\n");
      return;
   }
   if (womble->taught != womble->teacher) {
      womble->teacher->adjust_xp(womble->xp / 10);
   }
   womble->taught->adjust_xp(-womble->xp);
   if(womble->num == 1)
     levelstr = "level";
   else
     levelstr = "levels";
   if(womble->taught->add_skill_level(womble->skill, womble->num, womble->xp))
     {
       if (us != womble->teacher) {
         tell_object(us, "You finish learning " + womble->num +
                     " " + levelstr + " of "
                     + womble->skill + " from " + womble->teacher->short() +
                     ".\n");
         tell_object(womble->teacher, womble->taught->short() + " finishes " +
                     "learning " + womble->num + " " + levelstr + " of "
                     + womble->skill + " from you.\n");
         say(us->short() + " finishes learning some skills "+
             "from "+ womble->teacher->short()+".\n",
             ({ us, womble->teacher }));
       } else {
         tell_object(us, "You finish teaching yourself " + womble->num +
                     " " + levelstr + " of " +
                     womble->skill + ".\n");
         say(us->short() + " finishes learning some skills "
             "from " + us->query_objective() + "self.\n",
             ({ us, womble->teacher }));
       }
     } else {
       tell_object(womble->taught, "Something went wrong learning " +
                   womble->skill + " from " + womble->teacher->query_short() +
                   ".\n");
     }
   womble->taught->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
}
mixed *query_patterns() {
   return ({ "<string'skill/command'> from <indirect:living>",
             (: cmd($4[0], $1) :) });
}

==================================================
FILE: living/lie.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("lie", "down", LYING);
}

==================================================
FILE: living/lo_se.c
==================================================

inherit "/cmds/base";
mixed cmd(object *obs, string str) {
  object *ok, ob;
  string s;
  if (str == "everyone")
    obs = this_player()->query_followers();
  if (!sizeof(obs)) {
    write("You are not being followed by anyone.\n");
    return 1;
  }
  ok = ({ });
  foreach (ob in obs)
    if (this_player()->remove_follower(ob))
      ok += ({ ob });
  if (!sizeof(ok)) {
    if (member_array(this_player(), obs) == -1)
      return notify_fail("You are not being followed by "+
                         query_multiple_short(obs)+".\n");
    else
      return notify_fail("You are not being followed by " +
                         query_multiple_short(obs - ({this_player()}) +
                                              ({"yourself"})) + ".\n");
  }
  write("You lose "+(s=query_multiple_short(ok))+".\n");
  say(this_player()->the_short()+" loses "+s+".\n", ok);
  foreach (ob in ok)
    tell_object(ob, this_player()->the_short() + " loses " +
                query_multiple_short((ok + ({ "you" })) - ({ ob }))+".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "everyone", (: cmd(0, "everyone") :),
            "<indirect:living>", (: cmd($1, 0) :) });
}

==================================================
FILE: living/lsay.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
#include <broadcaster.h>
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(string arg) {
  int *co_ords;
  int status;
  class message mess;
  if (!arg)  arg = "";
  mess = build_message("@loudly " + arg, 0, "say");
  status = say_it(mess);
  if(status && TP && environment(TP))  {
    co_ords = environment(TP)->query_co_ord();
    BROADCASTER->npc_shout_event(TP, mess->notify_mess, mess->text,
                                 mess->language, co_ords, 20);
  }
  return status;
}
mixed *query_pattern() {
   return ({ "<string'message'>", (: cmd($4[0]) :) });
}

==================================================
FILE: living/meditate.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("meditate", "", MEDITATING);
}

==================================================
FILE: living/offer.c
==================================================

#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int offer_sale(object *to_sell, object *sell_to, string amt, int each) {
   int value;
   int num;
   string *fluff;
   string place;
   string *gumboot;
   object *fail;
   class offer_sale wombat;
   fluff = MONEY_HAND->query_all_places();
   gumboot = ({ });
   foreach (place in fluff) {
      value = MONEY_HAND->value_from_string(amt, place);
      if (value) {
        gumboot += ({ place });
      }
   }
   if (!sizeof(gumboot)) {
      add_failed_mess("Unable to understand the value of " + amt + ".\n",
                      to_sell);
      return 0;
   }
   if (member_array("Ankh-Morpork", gumboot) != -1) {
      gumboot = ({ "Ankh-Morpork" });
   }
   if (sizeof(gumboot) > 1) {
      add_failed_mess("Too many types of currency matched, matched currency "
                      "from " + query_multiple_short(gumboot) + ", try and "
                      "be more specific.  ie:  Ankh-Morpork dollars, not just "
                      "dollars.\n",
                      to_sell);
      return 0;
   }
   fail = this_player()->query_ignoring(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since you are "
                         "ignoring them.\n", fail);
         return 0;
      }
   }
   fail = this_player()->query_ignored_by(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since they are "
                         "ignoring you.\n", fail);
         return 0;
      }
   }
   place = gumboot[0];
   value = MONEY_HAND->value_from_string(amt, place);
   if (value < 0) {
      add_failed_mess("The value of the item was set too high.\n");
      return 0;
   }
   if (sizeof(sell_to) > 1) {
      add_failed_mess("Attempted to sell to $I, cannot sell to more than "
                      "one person.\n", sell_to);
      return 0;
   }
   if (sell_to[0] == this_player()) {
      add_failed_mess("You cannot sell $I to yourself.\n", to_sell);
      return 0;
   }
   if (each) {
      num = 0;
      foreach(object item in to_sell) {
          if ( item->query_collective() || item->query_continuous() ) {
             num += item->query_amount();
          }
          else {
             num++;
          }
      }
      value = value * num;
   }
#ifdef CHECK_MONEY
   if (sell_to[0]->query_value_in(gumboot[0]) < value) {
      add_failed_mess(sell_to[0]->the_short() + " does not have enough money "
                      "to buy $I.\n", to_sell);
      return 0;
   }
   if (!MONEY_HAND->query_person_payments(value, gumboot[0], sell_to[0], this_player())) {
      add_failed_mess(sell_to[0]->the_short() + " does not have the correct "
                      "change to pay " +
                      MONEY_HAND->money_value_string(value, gumboot[0]) +
                      " (and you do not have change to give back).\n");
      return 0;
   }
#endif
   wombat = new(class offer_sale);
   wombat->sell_obs = to_sell;
   wombat->seller = this_player();
   wombat->buyer = sell_to[0];
   wombat->value = value;
   wombat->place = gumboot[0];
   sell_to->add_respond_command("sell", this_player(), wombat);
   tell_object(sell_to[0],
               "You can accept the offer by typing:\n"
               "accept offer from " + this_player()->query_name() + "\n");
   add_succeeded_mess("$N offer$s to sell $I to " + sell_to[0]->the_short() +
                      " for " + MONEY_HAND->money_value_string(value,
                                            gumboot[0]) + ".\n", to_sell);
   return 1;
}
mixed *query_patterns() {
   return ({
 "<indirect:object:me'sell object'> to <indirect:living> for <string>",
             (: offer_sale($1[0], $1[1], $4[2], 0) :),
 "<indirect:object:me'sell object'> to <indirect:living> for <string> each",
             (: offer_sale($1[0], $1[1], $4[2], 1) :) });
}

==================================================
FILE: living/protect.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *protectees;
  things -= ({ TP });
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot protect yourself!\n");
     return 0;
  }
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much protection as a ghost.\n" );
    return 0;
  }
  protectees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_protector( TP ) ) {
      protectees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( protectees ) ) {
    add_failed_mess("You cannot protect $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot protect "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will protect $I.\n",
                        "$N moves to protect $I.\n" }),
	                protectees);
  return 1;
}
int show_protectors() {
   object *protect;
   object womble;
   protect = this_player()->query_protectors();
   if (sizeof(protect)) {
      write("You are being protected by " + query_multiple_short(protect) +
            ".\n");
   } else {
      write("You are not being protected by anyone.\n");
   }
   protect = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_protectors()) != -1) {
            protect += ({ womble });
         }
      }
   }
   if (sizeof(protect)) {
      write("Of the people in this room, you are protecting " +
            query_multiple_short(protect) + ".\n");
   } else {
      write("You are not protecting anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_protectors() :) });
}

==================================================
FILE: living/put.c
==================================================

#include <move_failures.h>
#include <player.h>
#define MAX_PUT_NUMBER 20
inherit "cmds/base";
#define TP this_player()
string con;
mixed cmd(mixed *indir,
          string *indir_match,
          string *args)
{
   string person;
   string thing;
   string sh;
   int tot;
   int max;
   object *per;
   object *ret;
   object *fail;
   object pobj;
   object ob;
   object *obs;
   object *succ;
   object *too_many;
   int num;
   con = args[1];
   per = indir[1];
   thing = indir_match[0];
   person = indir_match[1];
   succ = ({ });
   too_many = ({ });
   foreach(pobj in per) {
      if (living(pobj) && !pobj->query_living_container()) {
         tell_object(TP,
                     "You cannot put things " + con + " living things.\n");
         continue;
      }
      obs = indir[0];
      obs -= per;
      if (!sizeof(obs)) {
         tell_object(TP, "Nothing to " + query_verb() + " " + con + " " +
                     inside_the_short(pobj) + ".\n");
         continue;
      }
      if (!is_in_me_or_environment(pobj, this_player())) {
         add_failed_mess("Cannot $V $I " + con + " " + pobj->the_short() +
                         ".\n", obs);
         continue;
      }
      ret = ({ });
      fail = ({ });
      foreach(ob in obs) {
         if (member_array(ob, succ) > -1) {
            continue;
         }
         if (num > MAX_PUT_NUMBER) {
            too_many += ({ ob });
            continue;
         }
         if (function_exists("do_put", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_put", ob)) {
               max = (int) call_other(ob, "do_put", pobj, thing, person,
                                      ({ thing, person }),
                                      "<direct:object> " + con +
                                      " <indirect:object>");
            } else {
               max = ob->command_control("put", pobj, thing, person,
                                         ({ thing, person }),
                                         "<indirect:object> " +
                                         con + " <indirect:object>");
            }
            if (max == 0) {
               fail += ({ ob });
               continue;
            }
         }
         if (pobj->query_closed() || ob->move(pobj) != MOVE_OK) {
            fail += ({ ob });
         } else {
            ret += ({ ob });
            tot += (int) ob->query_weight();
#ifndef __DISTRUBUTION_LIB__
            if(interactive(TP))
              PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
            num++;
         }
      }
      if (sizeof(ret)) {
         succ += ret;
         sh = query_multiple_short(ret);
         add_succeeded_mess("$N $V $I " + con + " " +
                            inside_the_short(pobj) + ".\n", ret);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot $V $I " + con + " " +
                         inside_the_short(pobj) + ".\n", fail);
      }
   }
   if (sizeof(too_many)) {
      if (sizeof(succ) > 0) {
         add_succeeded_mess(({ "You cannot handle more than " +
                               query_num(MAX_PUT_NUMBER) +
                               " objects with $V; discarding $I.\n", "" }),
                            too_many);
      } else {
         add_failed_mess("You cannot handle more than " +
                         query_num(MAX_PUT_NUMBER) +
                         " objects with $V; discarding $I.\n", too_many);
      }
   }
   return sizeof(succ) > 0;
}
string query_con() {
  return con;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me> {in|on|into} <indirect:object>",
             (: cmd($1, $3, $4) :) });
}

==================================================
FILE: living/r_ead.c
==================================================

#include <language.h>
inherit "/cmds/base";
varargs string create_text( object thing, int label );
mixed cmd( object *things ) {
   string gendstr;
   string text;
   string read;
   string reader;
   string *others;
   string r_short;
   object thing;
   mapping hide_invis;
   int dark;
   dark = this_player()->check_dark(environment(this_player())->query_light());
   if (dark < 0) {
      add_failed_mess("It is too dark to read $I.\n", things);
      return 0;
   }
   if (dark > 0) {
      add_failed_mess("It is too bright to read $I.\n", things);
      return 0;
   }
   reader = "";
   others = ({ });
   foreach( thing in things ) {
      if (!is_in_me_or_environment(thing, this_player())) {
          add_failed_mess("You cannot read $I.\n", ({ thing }));
          continue;
      }
      text = thing->query_readable_message(this_player());
      read = thing->query_read_short();
      if (!read) {
         read = "$name$";
      }
      if ( !text) {
        if (living(thing)) {
            gendstr = thing->query_objective();
        } else {
           gendstr = "it";
        }
        r_short = thing->query_read_short();
        if (!r_short) {
           r_short = "$name$";
        }
        if (!thing->command_control("read")) {
            if (thing != this_player()) {
               reader += "$C$"+ replace_string(r_short,
                                        "$name$",
                                        thing->a_short()) +
                     " does not have anything written on " +
                     gendstr + ".\n";
            } else {
               reader += "You cannot read yourself.\n";
            }
         } else {
            others += ({ replace( read, "$name$", (string)thing->a_short() ) });
            reader += "";
         }
         continue;
      }
      reader += "You read "+ replace_string( read, "$name$",
            (string)thing->the_short() ) +":\n"+ text + "\n";
      if ( read == "$name$" ) {
          others += ({ thing });
      }
      else {
          others += ({ replace( read, "$name$", (string)thing->a_short() ) });
      }
   }
   if ( !sizeof( others ) ) {
      add_failed_mess(reader);
      return 0;
   }
   write( "$P$Read$P$"+ reader );
   hide_invis = this_player()->query_hide_invis();
   if(!hide_invis["hiding"]) {
      add_succeeded_mess(({ "", "$N read$s $I.\n" }), others);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :) });
}

==================================================
FILE: living/remove.c
==================================================

#include <clothing.h>
#include <tasks.h>
#define SKILL "covert.manipulation.sleight-of-hand"
#ifdef DEBUG
#define TELL_ME "presto"
#endif
inherit "cmds/base";
int cmd(object *things)  {
   object  *removed = ({ });
   object  *blocking = ({ });
   object  *blocked;
   object  *total_blocking = ({ });
   object  *succeeded;
   object  *failed;
   object  *failed_rewear;
   object   ob;
   object   blocker;
   mapping  is_blocking = ([ ]);
   mapping  hide_invis;
   string   tmp1;
   string   tmp2;
   int      last_blocking;
   int      limit;
   int      i;
   int      hiding;
   int      sneaking;
   int      difficulty;
   int      light;
   int      my_light;
   succeeded = this_player()->query_wearing();
   failed = filter(things, (: member_array($1, $(succeeded)) == -1 :));
   things -= failed;
   if (sizeof(things) == 0)  {
      write("You are not wearing " + query_multiple_short(failed, "the") +
            ".\n");
      return 1;
   }
   succeeded = things;
   for (i = 0; i < sizeof(succeeded); i++)  {
      ob = succeeded[i];
      blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player()) -
                 ({ ob });
      if (sizeof(blocking))  {
         foreach (blocker in blocking)  {
            if (undefinedp(is_blocking[blocker]))
               is_blocking[blocker] = ({ ob });
            else
               is_blocking[blocker] |= ({ ob });
         }
         total_blocking |= blocking;
         succeeded = ({ things..., total_blocking... });
      }
   }
   total_blocking = ({ });
   foreach (ob, blocked in is_blocking)  {
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
      tell_creator(TELL_ME, "ob == %s, blocked == %O\n",
                   ob->short(), blocked->short());
#endif
      last_blocking = -1;
      for (i = sizeof(total_blocking) - 1; i >= 0; i--)  {
         if (member_array(ob, is_blocking[total_blocking[i]]) > -1)  {
            last_blocking = i;
            break;
         }
      }
      if (last_blocking == -1)  {
         total_blocking = ({ ob, total_blocking... });
#ifdef DEBUG
         if (this_player() == find_player(TELL_ME))
            tell_creator(TELL_ME, "Nothing is blocking ob, adding it to "
                         "the beginning\n%O\n", total_blocking->short());
#endif
         continue;
      }
      total_blocking = ({ total_blocking[0 .. last_blocking]...,
                          ob,
                          total_blocking[(last_blocking + 1) .. ]... });
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
         tell_creator(TELL_ME, "Adding ob after last_blocking position "
                      "(%d)\n%O\n",
                      last_blocking, total_blocking->short());
#endif
      limit = last_blocking;
      blocking = copy(blocked);
      for (i = 0; i < limit; i++)  {
         if (member_array(total_blocking[i], blocking) > -1)  {
            blocking += is_blocking[total_blocking[i]];
            if (i == 0)
               total_blocking =
                  ({ total_blocking[1 .. (last_blocking + 1)]...,
                     total_blocking[0],
                     total_blocking[(last_blocking + 2) .. ]... });
            else
               total_blocking =
                  ({ total_blocking[0 .. (i - 1)]...,
                     total_blocking[(i + 1) .. (last_blocking + 1)]...,
                     total_blocking[i],
                     total_blocking[(last_blocking + 2) .. ]... });
            --limit;
            --i;
#ifdef DEBUG
            if (this_player() == find_player(TELL_ME))
               tell_creator(TELL_ME, "Reordered list:\n%O\n",
                            total_blocking->short());
#endif
         }
      }
   }
   foreach (blocker in total_blocking)  {
      tmp1 = CLOTHING_HANDLER->can_wear_or_remove(blocker, this_player());
      if (tmp1)  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " " + tmp1 + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else if (this_player()->remove_armour(blocker))  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " because you cannot remove " + blocker->one_short() + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else removed += ({ blocker });
   }
   succeeded = things & removed;
   failed = ({ });
   foreach (ob in things - removed)  {
      if (this_player()->remove_armour(ob))
         failed += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      removed -= things;
      tmp2 = query_multiple_short(succeeded, "the") ;
      if (sizeof(removed) > 0)  {
         tmp1 = query_multiple_short(removed, "the");
         write("You remove " + tmp1 + " so you can remove " + tmp2 + ".\n");
         say(this_player()->the_short() + " removes " + tmp1 + " so " +
             this_player()->query_pronoun() + " can remove " + tmp2 + ".\n");
      }
      else  {
        hide_invis = ( mapping )this_player()->query_hide_invis();
        hiding = hide_invis[ "hiding" ] ? 1 : 0;
        sneaking = this_player()->query_sneak_level() ? 1 : 0;
        if( hiding || sneaking ) {
          my_light = this_player()->query_light();
          light = environment( this_player() )->query_light();
          difficulty = light + ( 4 * my_light ) / ( light + 1 );
          difficulty += succeeded[0]->query_complete_weight();
          debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                        difficulty, SKILL, this_player()->
                        query_skill_bonus( SKILL ) );
          switch( TASKER->perform_task( this_player(), SKILL, difficulty,
            TM_FREE ) ) {
            case AWARD :
              write( "%^YELLOW%^" + ({
                "You discover something that lets your fingers move more "
                  "nimbly.",
                "You find yourself capable of deceiving the eye with greater "
                  "ease than before.",
                "You realise how to deceive the eye more effectively."
              })[ random(3) ] + "%^RESET%^\n" );
            case SUCCEED :
              add_succeeded_mess( ({ "$N $V " + tmp2 + ", managing to stay "
                "unnoticed.\n",
                "" }) );
              break;
            default :
              this_player()->add_succeeded_mess( this_object(), "$N "
                "unsuccessfully tr$y to " + query_verb() + " " + tmp2 +
                " while staying unnoticed.\n", ({ }) );
              break;
          }
        } else {
          this_player()->add_succeeded_mess( this_object(), "$N $V " + tmp2 +
            ".\n", ({ }) );
        }
      }
   }
   succeeded = ({ });
   failed_rewear = ({ });
   foreach (ob in removed)  {
      if (this_player()->wear_armour(ob))
         failed_rewear += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      this_player()->force_burden_recalculate();
      tmp1 = query_multiple_short(succeeded, "the");
      write("You wear " + tmp1 + ".\n");
      say(this_player()->the_short() + " wears " + tmp1 + ".\n");
   }
   if (sizeof(failed_rewear) > 0)  {
      write("You cannot put " +
            query_multiple_short(failed_rewear, "the") + " back on.\n");
   }
   if (sizeof(failed) > 0)  {
      write("You cannot remove " + query_multiple_short(failed, "the") +
            ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/sa_y.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "cmds/speech";
mixed cmd(string arg) {
  class message mess;
  mess = build_message(arg, 0, "say");
  return say_it(mess);
}

==================================================
FILE: living/sayto.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(object *obs, string str) {
  class message mess;
  obs = filter(obs, (: $1 && $1 != this_player() :));
  if(!sizeof(obs)) {
    return notify_fail("Be serious.\n");
  }
  mess = build_message(str, obs, "say");
  return say_it_to(mess, obs, 0, "person_say");
}
mixed *query_patterns() {
   return ({ "<indirect:living> <string>", (: cmd($1, $4[1]) :) });
}

==================================================
FILE: living/sh_out.c
==================================================

#include <player.h>
#include <drinks.h>
#include <language.h>
#include <cmds/options.h>
#include "/d/am/path.h"
inherit "/cmds/base";
inherit "/cmds/speech";
#define TP this_player()
#define BEEP sprintf("%c",7)
#define NO_QUIT_INVENTORY 1
#define NO_QUIT_COMBAT    2
#define BROADCASTER "/obj/handlers/broadcaster"
int query_no_quit();
string query_shout_word_type(string str);
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string s1, s2, s;
  object g;
  string cur_lang;
  object lag;
  int tim, cost;
  if(!str || str == "")
    return notify_fail("Syntax : shout <text>\n");
  if (!environment(this_player()))
    return notify_fail( "You appear to be in limbo...\n" );
  if(TP->query_property("dead") == 1)
    return notify_fail("You don't have any lungs, how can you shout?\n");
  if (TP->check_earmuffs("shout"))
    return notify_fail("Why shout when you can't hear people "
                       "shout back?\n");
  cur_lang = TP->query_current_language();
  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");
  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken "
                       "at a distance.\n");
  if (TP->query_invis())
    return notify_fail("Invisible people cannot shout, they cannot "
                       "see their arm in front of their face.  Shouting is "
                       "out of the question.\n");
  if (TP->query_property("gagged"))
    return notify_fail("You have been gagged!  You will not be able "
                       "to shout again until the gag is removed.  Perhaps "
                       "you should talk to a creator about this.\n");
  if (TP->query_property("recently shouted")) {
    return notify_fail("You have shouted very recently, perhaps you "
                       "should give your lungs a small break and try again "
                       "in a couple seconds.\n");
  }
  if(TP->query_property("player") == 1 && !TP->query_creator()) {
    cost = SHOUT_COST * ((strlen(str) / 5) + 1);
    cost += sizeof(filter(explode(str, ""), (: $1 <= "Z" :))) / 2;
    if(TP->adjust_sp(-cost) < 0)
      return notify_fail(NO_POWER);
    TP->adjust_max_sp(- (cost / 5));
  }
  if (!interactive(TP)) {
    str = TP->convert_message( str );
    str = TP->fit_message( str );
  }
  s1 = query_shout_word_type(str);
  if (s1 != "yell")
    s = "shouts" + s1;
  else
    s = s1 + "s";
  if(TP->query_property(SHORTHAND_PROP))
    str = fix_shorthand(str);
  if(TP->query_volume( D_ALCOHOL))
    str = drunk_speech( str );
  TP->remove_hide_invis("hiding");
  if (s1 != "yell") {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You shout" + s1 + ": ", str);
  } else {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You " + s1 + ": ", str);
  }
  s2 =  " " + lower_case(str);
  if (sscanf(" "+s2, "%s eight%s", s1, s1)==2 ||
      sscanf(s2, "%s8%s", s1, s1)==2) {
    s1 = replace(str, ({ "8", "", " eight", "", " ", "" }));
    switch (query_no_quit()) {
    case NO_QUIT_INVENTORY:
      return notify_fail("You only just arrived.  You are far too "
                         "busy strapping on equipment to shout like that.\n");
    case NO_QUIT_COMBAT:
      return notify_fail("You are too busy fighting to shout "
                         "like that.\n");
    default:
      if (s1 == "") {
        write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
      else {
        g = (object)TP->query_guild_ob();
        if (random(100) < 40 ||
            (g && (string)g->query_name() == "wizards"))
          write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
    }
  }
  lag = load_object(SHORT + "short20")->lag_for_shout();
  if(lag && sscanf(" "+lower_case(s2), "%*s lag%*s") == 2) {
    tim = TP->query_property("lag shout time");
    TP->add_property("lag shout time", time(), 300);
    if((tim + 300 > time()) && lag != TP) {
      switch (query_no_quit()) {
      case NO_QUIT_INVENTORY:
        lag->init_command("hug "+ TP->query_name() +
                          " Welcome to " + mud_name() + "", 0);
        return notify_fail("The air is suddenly squeezed out "
                           "of you.\n");
      case NO_QUIT_COMBAT:
        lag->init_command("wedgie " + TP->query_name(), 0);
        return notify_fail("You are rudely interrupted "
                           "mid-shout.  Fortunately you are not distracted "
                           "from the fight.\n");
      default:
        call_out( "summon_bel_shamharoth", 10, TP, 1);
      }
    }
  }
  if(environment(this_player()) &&
     environment(this_player())->query_property("location") == "inside")
    tim = 10;
  else
    tim = 3;
  user_event( this_player(), "person_shout",
              (string)this_player()->a_short() +" "+ s,
              str, cur_lang,
              (int *)environment( this_player() )->query_co_ord(),
              ( 100 * ( (int)this_player()->query_con() +
                        (int)this_player()->query_str() ) ) / tim );
  environment(TP)->event_person_shout( 0, (string)TP->a_short() +" "+ s,
                                       str + "%^RESET%^", cur_lang );
  BROADCASTER->npc_shout_event(TP, (string)TP->a_short() +" "+ s,
                               str + "%^RESET%^", cur_lang,
                               (int *)environment(TP)->query_co_ord(),
                               (100 * ((int)TP->query_con() +
                                       (int)TP->query_str() ) ) / 3);
  if (TP->query_property("player") == 1 && !TP->query_creator()) {
    TP->add_property("recently shouted", 1, 2);
  }
  return 1;
}
string query_shout_word_type(string str) {
  switch (str[<1]) {
  case '!':
    return "yell";
  case '?':
    return " asking";
  default:
    return "";
  }
}
void my_mess(string fish, string erk) {
  if(!interactive(TP))
    return;
  printf("%s%-=*s\n", fish, TP->query_cols() - strlen(fish),
         TP->fix_string(erk));
}
void summon_bel_shamharoth(object who, int lag_shout) {
  object env;
  if (!who || !objectp(who))
    return;
  if (!random(3))
    who->adjust_tmp_con(-2);
  if (!random(3))
    who->adjust_tmp_int(-2);
  if (!random(3))
    who->adjust_tmp_wis(-2);
  if (!random(3))
    who->adjust_tmp_dex(-2);
  env = environment(who);
  if ("/secure/master"->query_lord(geteuid(who))) {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                 "The heavens shake with a hideous roar and just as suddenly "
                 "all is quiet.\n$C$"+ who->query_name() + " chuckles in the "
                 "distance.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object(who, "Your lordliness saves you from a grizzly "
                "encounter with the Sender of Eight.\n");
  } else {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                             "a sudden chill passes through the land as $C$" +
                           who->query_name() + " is carried off screaming "
                           "to the land of shades.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object( who, "You think you'd best be careful what you "
                 "shout in the future as shadowy tentacles drag you "
                 "into the ground...\n" );
    if(lag_shout)
      BROADCASTER->broadcast_event(users(),
                                   (int *)env->query_co_ord(),
                                   ( 100 * ( (int)who->query_con() +
                  "The heavens shake with a hideous chuckle and in the "
                  "distance a booming yet apologetic voice says: Oops.\n",
                                             (int)who->query_str() ) ) / 3,
                                   1, 0);
    if(base_name(env) != "/room/departures")
      who->quit();
  }
}
int query_no_quit() {
  if (TP->query_save_inhibit() || TP->query_auto_loading()) {
    return NO_QUIT_INVENTORY;
  }
  if (sizeof(filter_array(TP->query_attacker_list(), (: living($1) :)))) {
    return NO_QUIT_COMBAT;
  }
  return 0;
}

==================================================
FILE: living/sheathe.c
==================================================

#include <move_failures.h>
inherit "/cmds/base";
int cmd( object * weapons, object * scabbards ) {
   object weapon;
   object scabbard;
   if( sizeof(weapons) > 1 ) {
      add_failed_mess( "You can only sheathe one thing at a time.\n" );
      return 0;
   }
   weapon = weapons[0];
   if ( ( scabbard = environment( weapon ) )->query_scabbard() &&
        scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( weapon->the_short() + " is already sheathed.\n" );
      return 0;
   }
   if ( environment( weapon ) != this_player() ) {
      add_failed_mess( weapon->the_short() + " is not in your inventory.\n" );
      return 0;
   }
   if ( scabbards ) {
      if ( sizeof(scabbards) > 1 ) {
         add_failed_mess( "For shame! Trying to sheathe your weapon "
           "in more than one object at a time?\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if ( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not even a "
           "scabbard!\n" );
         return -1;
      }
      if( !scabbard->test_type_ok( weapon ) ) {
        return add_failed_mess( "$C$"+scabbard->the_short() + " is not a "
                                "suitable scabbard for " + weapon->a_short()
                                + ".\n" );
      }
   } else {
      scabbards = filter( all_inventory( this_player() ),
                          (: $1->query_scabbard() &&
                             $1->test_type_ok( $(weapon) ) :) );
      if ( !sizeof( scabbards ) ) {
         return add_failed_mess( "Can't find any suitable scabbards in "
           "your inventory.\n" );
      }
      scabbards = filter( scabbards, (: $1->test_add( $(weapon), 0, 1 ) :) );
      if ( !sizeof(scabbards) ) {
         return add_failed_mess( "Can't find any empty scabbards in your "
           "inventory.\n" );
      }
      scabbard = scabbards[0];
   }
   if ( weapon->query_wielded() &&
       !sizeof( this_player()->set_unhold(weapon) ) )
   {
      return add_failed_mess( "You cannot let go of " + weapon->the_short()
        + ".\n" );
   }
   if ( weapon->move(scabbard) != MOVE_OK ) {
      this_player()->add_failed_mess( scabbard, "You cannot $V $I in $D.\n",
        ({ weapon }) );
      return 0;
   }
   this_player()->add_succeeded_mess( scabbard, "$N $V $I in $D.\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   return ({
      "<indirect:object:me'weapon'>",
        (: cmd( $1, 0 ) :),
      "<indirect:object:me'weapon'> in <indirect:object:me'scabbard'>",
        (: cmd( $1[0], $1[1]) :)
   });
}

==================================================
FILE: living/show.c
==================================================

#include <command.h>
#define READ ( DIR_LIVING_CMDS "/r_ead" )
inherit "/cmds/base";
int do_show_object( object shower, object item, object owner, object target, int no_mess );
#ifdef DEBUG
int notify_fail(string str) {
  tell_object(find_player("tape"), "%^YELLOW%^"+
              this_player()->query_short()+" "+str+"%^RESET%^\n");
  return efun::notify_fail(str);
}
#endif
int cmd( object item, object target )
{
   return do_show_object( this_player(), item, this_player(), target, 0 );
}
int do_show_object( object shower, object item, object owner, object target, int nomess )
{
   tell_creator( shower, "%O\n%O\n", item, target );
   if( target == shower ) {
      add_failed_mess( "Why not just look at it?\n");
      return 0;
   }
   if( !shower->query_visible( target ) ) {
      add_failed_mess( "It appears that " + target->the_short() +
         " can't see you or your item.\n" );
      return 0;
   }
   if( target->query_property( "ignoring" ) ) {
      if( member_array( shower->query_name(),
         target->query_property( "ignoring" ) ) != -1 ) {
         add_failed_mess( target->the_short() + " ignores you.\n" );
         return 0;
      }
   }
   if( item->query_worn_by() ) {
      add_failed_mess( item->the_short() + " must be removed before it can be "
         "shown.\n" );
      return 0;
   }
   target->add_respond_command( "show offer", this_object(),
      ({ item, owner, shower }) );
   if( !nomess )
   {
      tell_room( environment( shower ), shower->the_short() +
         " offers to show " + item->a_short() + " to " +
         target->a_short() + ".\n",
         ({ target, shower }) );
      tell_object( shower, "You offer " + item->the_short() +
         " to " + target->the_short() + " for inspection.\n" );
      tell_object( target, shower->the_short() + " offers you " +
         item->a_short() + " for inspection.  Use \"show accept offer "
         "from " + shower->query_name() + "\" to view it.\n" );
   }
   return 1;
}
int accept_show( object target, int read ) {
   mixed *stuff;
   object from;
   object owner;
   object item;
   string message;
   if( target == this_player() ) {
      add_failed_mess( "You cannot show stuff to yourself.\n");
      return 0;
   }
   stuff = this_player()->query_respond_command(
      "show offer", this_object() );
   if( !sizeof( stuff ) ) {
      add_failed_mess( "No one has offered to show you anything.\n");
      return 0;
   }
   item     = stuff[ 0 ];
   owner    = stuff[ 1 ];
   from     = stuff[ 2 ];
   if( !from || target != from ) {
      add_failed_mess( target->the_short() + " hasn't offered "
         "to show you anything.\n" );
      return 0;
   }
   if( !item || ( owner && environment( item ) != owner ) )
   {
      add_failed_mess( "It appears that " + target->the_short() +
         " has misplaced " + target->query_possessive() + " item.\n");
      return 0;
   }
   this_player()->remove_respond_command( "show offer", this_object() );
   tell_room( environment( this_player() ), this_player()->the_short() +
      " accepts the offer from " +
      target->the_short() +
      " to see " + item->the_short() + ".\n", ({ this_player(), target }) );
   message = "You accept " + target->the_short() + "'s offer.\n";
   tell_object( target, "You show " + item->the_short() + " to " +
      this_player()->the_short() + ".\n" );
   message += "\n";
   if( this_player()->query_creator() ) {
      message += "%^CYAN%^" + file_name( item ) + ":%^RESET%^\n";
   }
   message += item->long();
   if( sizeof( item->query_read_mess() ) ) {
      message += item->the_short() + " also contains some writing.\n";
      message += item->query_readable_message(this_player());
   }
   write("$P$Show$P$" + message);
   return 1;
}
mixed *query_patterns() {
   return ({
      "<indirect:object:me'item'> to <indirect:living'living'>",
         (: cmd( $1[ 0 ][ 0 ], $1[ 1 ][ 0 ] ) :),
      "accept [offer] [from] <indirect:living'living'>",
         (: accept_show( $1[ 0 ], 0 ) :) });
}

==================================================
FILE: living/sit.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   if(this_player()->query_position() == "lying")
     setup_position("sit", "up", SITTING);
   else
     setup_position("sit", "down", SITTING);
}

==================================================
FILE: living/sp_eak.c
==================================================

inherit "/cmds/base";
#include <language.h>
#define TP this_player()
int cmd(string which)
{
   string *langs;
   string skill;
   int i;
   mapping skills;
   skills = TP->query_skills();
   if (!which) {
      langs = LANGUAGE_HAND->query_languages();
      for (i = 0; i < sizeof(langs); i++) {
         if (TP->
             query_skill(LANGUAGE_HAND->
                         query_language_spoken_skill(langs[i])) > 1
             || TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
         } else {
            langs = langs[0..i - 1] + langs[i + 1..];
            i--;
         }
      }
      write("You are currently speaking " +
            cap_words(TP->query_current_language()) + " and your default "
            "language is " + cap_words(TP->query_default_language()) + ".\n");
      write("You can speak " +
            query_multiple_short(map(langs, (: cap_words :)) +
                                 ({ "Grunt" })) + ".\n");
      write("Please note that the language you are speaking is used for "
            "writing as well, so some of the languages may be just written.\n");
      return 1;
   }
   which = lower_case(which);
   skill = LANGUAGE_HAND->query_language_spoken_skill(which);
   if (!skill) {
      return notify_fail("You cannot speak that language.\n");
   }
   if((!TP->query_skill(skill) && which != "grunt" && which != "general") ||
      (which == "general" && !TP->query_creator() && interactive(TP)))
      return notify_fail("You don't know that language.\n");
   if (which == this_player()->query_current_language()) {
      add_failed_mess("You are already speaking " + cap_words(which) + ".\n");
      return 0;
   }
   if (!TP->set_language(which)) {
      return notify_fail("Argh... something weird happened.\n");
   }
   write("Now using " + cap_words(which) + " for speaking and writing.\n");
   return 1;
}
mixed *query_patterns()
{
   string *languages;
   string tmp;
   languages = LANGUAGE_HAND->query_languages();
   if ( TP->query_womens_day() ) {
       languages += ({ "wommon" });
   }
   tmp = implode(languages + map(languages, (: cap_words :)), "|");
   return ({ "{" + tmp + "}", (: cmd(implode($4, " ")) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: living/stand.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("stand", "up", STANDING);
}

==================================================
FILE: living/surr_ender.c
==================================================

inherit "/cmds/base";
mixed cmd(int mode, int val) {
  if (!mode) {
    int surr = this_player()->query_surrender();
    if (surr)
      write(sprintf("You will surrender at %d%% of your max hps.\n", surr));
    else
      write("You will not surrender.\n");
    return 1;
  } else {
    if (val < 0 || val > 100)
      return notify_fail("Your surrender must be between 0 and 100.\n");
    this_player()->set_surrender(val);
    write(sprintf("Surrender set to %d%%\n", this_player()->query_surrender()));
    return 1;
  }
}
mixed *query_patterns()
{
  return ({ "", (: cmd(0, 0) :),
            "<number>", (: cmd(1, $4[0]) :) });
}

==================================================
FILE: living/swim.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("swim", "around", SWIMMING);
}

==================================================
FILE: living/tactics.c
==================================================

inherit "/cmds/base";
#include <combat.h>
int cmd() {
  class tactics tactics;
  tactics = (class tactics) this_player()->query_tactics();
  write("Your combat options are:\n\n" );
  write("   Attitude - "+ tactics->attitude +".\n" );
  write("   Response - "+ tactics->response +".\n" );
#ifdef USE_SURRENDER
  write("   Mercy - "+ (tactics->mercy?tactics->mercy:"none") + ".\n");
#endif
  write("   Focus - "+ (tactics->focus_zone?tactics->focus_zone:"none") + ".\n" );
#ifdef USE_DISTANCE
  write("   Target distance - "+ (tactics->ideal_distance?tactics->ideal_distance:"none") + ".\n" );
#endif
  write("You will use "+
        (tactics->attack == "both" ? "both hands" :
         "your "+ (tactics->attack?tactics->attack:"either") +" hand" ) +
        " to attack.\n" );
  write("You will use "+
        (tactics->parry == "both" ? "both hands" :
         "your "+ (tactics->parry?tactics->parry:"either") +" hand" ) +
        " to parry.\n" );
  write("\nYou will"+ ( tactics->parry_unarmed ? " " : " not " ) +
        "attempt to parry unarmed.\n" );
  return 1;
}
int attitude(string word) {
  class tactics my_tactics;
  my_tactics = new(class tactics);
  my_tactics = (class tactics) this_player()->query_tactics();
  switch(word) {
  case "insane":
  case "offensive":
  case "neutral":
  case "defensive":
  case "wimp":
    if((my_tactics->attitude) == word) {
      write("Your attitude is already " + word + ".\n");
    } else {
      my_tactics->attitude = word;
      write("Your attitude is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics attitude "
                       "insane|offensive|neutral|defensive|wimp.\n");
  }
}
int response(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "dodge":
  case "neutral":
  case "parry":
    if(my_tactics->response == word) {
      write("Your response is already " + word + ".\n");
    } else {
      my_tactics->response = word;
      write("Your response is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics response dodge|neutral|parry\n");
  }
}
int parry(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "unarmed":
    my_tactics->parry_unarmed = 1 - my_tactics->parry_unarmed;
    write("You will"+ ( my_tactics->parry_unarmed ? " " : " not " ) +
          "now attempt to parry unarmed.\n" );
    this_player()->set_tactics(my_tactics);
    return 1;
  case "left":
  case "right":
  case "both":
    if(my_tactics->parry == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
    } else {
      my_tactics->parry = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics parry "+
                        "left|right|both [hand(s)]\n        "
                        "tactics parry unarmed\n" );
  }
}
int attack(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "left":
  case "right":
  case "both":
    if(my_tactics->attack == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
    } else {
      my_tactics->attack = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics attack "+
                        "left|right|both [hand(s)]\n" );
  }
}
int focus(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "head":
  case "neck":
  case "chest":
  case "abdomen":
  case "arms":
  case "hands":
  case "legs":
  case "feet":
  case "upper body":
  case "lower body":
    if(my_tactics->focus_zone == word) {
      write("You are already focussing on your opponent's "+ word + ".\n");
    } else {
      my_tactics->focus_zone = word;
      write("You will now focus on your opponent's "+ word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  case "none":
    if(!my_tactics->focus_zone) {
      write("You are not currently focussing on any particular target "
            "area.\n");
    } else {
      my_tactics->focus_zone = 0;
      write("You will no longer focus on a specific target area.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics focus " +
                        "upper body|lower body|head|neck|chest|abdomen|arms|hands|legs|feet|none\n");
  }
}
int distance(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "long":
  case "medium":
  case "close":
  case "hand-to-hand":
    if(my_tactics->ideal_distance == word) {
      write("You are already set for " + word + " range.\n");
      return 1;
    }
    my_tactics->ideal_distance = word;
    write("You will now aim for "+ word + " range combat.\n");
    this_player()->set_tactics(my_tactics);
    return 1;
  case "none":
    if(!my_tactics->ideal_distance) {
      write("You are not currently aiming for any specific combat distance.\n");
    } else {
      my_tactics->ideal_distance = 0;
      write("You will no longer aim for a specific combat distance.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics distance " +
                        "{long|medium|close|hand-to-hand\n");
  }
}
#ifdef USE_SURRENDER
int mercy(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "always":
  case "ask":
  case "never":
    if(my_tactics->mercy == word) {
      write("Your mercy is already " + word + ".\n");
    } else {
      my_tactics->mercy = word;
      write("Your mercy is now "+ word +".\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics mercy always|ask|never\n");
  }
}
#endif
mixed *query_patterns() {
  return ({ "", (: cmd() :),
              "attitude <word'insane|offensive|neutral|defensive|wimp'>",
              (: attitude($4[0]) :),
              "response <word'dodge|neutral|parry'>", (: response($4[0]) :),
#ifdef USE_SURRENDER
              "mercy <word'always|ask|never'>", (: mercy($4[0]) :),
#endif
              "parry <word'left|right|both|unarmed'>", (: parry($4[0]) :),
              "attack <word'left|right|both'>", (: attack($4[0]) :),
              "focus <string'upper body|lower body|head|neck|chest|abdomen|"
              "arms|hands|legs|feet|none'>", (: focus($4[0]) :),
#ifdef USE_DISTANCE
              "distance <word'long|medium|close|hand-to-hand|none'>",
              (: distance($4[0]) :),
#endif
              });
}

==================================================
FILE: living/take.c
==================================================

inherit "/cmds/living/get";

==================================================
FILE: living/teach.c
==================================================

#include <skills.h>
#include <tune.h>
#include <command.h>
#include <cmds/teach.h>
#include <playtesters.h>
#include <player.h>
inherit "/cmds/base";
#define DEBUGGER "ceres"
#undef ENFORCE_MAX_TEACH_LEVEL
int command_teach( object *obs, string comm, object teacher );
int spell_teach(object *obs, string spell, object teacher);
int teach_skill(object *obs, string str, object teacher);
int cmd_int(string str, object *obs, object teacher);
int check_ignoring(object ignorer, object ignoree);
int query_auto_teaching(object teacher, object learner) {
   return teacher->query_property(TEACH_COMMAND_AUTO_PROPERTY);
}
int cmd(string str, object *obs, object player) {
  int ret;
  object ob;
  object* ear;
  if (this_player()->query_property(PASSED_OUT_PROP)) {
     add_failed_mess("You cannot teach while passed out.\n");
     return 0;
  }
  if (this_player()->query_fighting()) {
    add_failed_mess("You cannot teach or learn anything while you are "
                    "fighting!\n");
    return 0;
  }
  if (this_player()->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  if (player) {
    ear = filter(obs, (: userp($1) && !interactive($1) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$C$$I does not have enough responsiveness to teach "
                      "you.\n", ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->check_earmuffs("teach") :));
    if (sizeof(ear)) {
      obs -= ear;
      if (sizeof(ear) == 1) {
        add_failed_mess("$I has " + ear[0]->query_possessive() + " earmuffs "
                        "on.\n", ear);
      } else {
        add_failed_mess("$I have their earmuffs on.\n", ear);
      }
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: check_ignoring($1, this_player()) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is ignoring you, or you are ignoring them.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->query_property(PASSED_OUT_PROP) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is passed out and looks rather worse for wear.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->query_fighting() :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is currently beating stuff up, please wait "
                      "for them to finish.\n", ear);
      if (!obs) {
        return 0;
      }
    }
    obs = filter(obs, (: !$1->query_creator() :) );
    if (!sizeof(obs)) {
      add_failed_mess("None of those people are allowed to teach you.\n");
      return 0;
    }
    obs = filter(obs, (: query_auto_teaching($1, this_player()) :));
    if (!sizeof(obs)) {
      add_failed_mess("None of those people have auto teaching turned "
                      "on.\n");
      return 0;
    }
    obs = filter(obs, (: $1->query_time_left() > 0 :));
    if (!sizeof(obs)) {
      add_failed_mess("All the people you are trying to learn from appear "
                      "to be busy.\n");
      return 0;
    }
    foreach (ob in obs) {
      ret |= cmd_int(str, ({ this_player() }), ob);
    }
    return ret;
  }
  return cmd_int(str, obs, this_player());
}
int cmd_int(string str, object *obs, object teacher) {
  if (teacher->query_property("dead")) {
    add_failed_mess("You wave your arms around, and your lips move but "
                       "they can't hear what you are saying.\n");
    return 0;
  }
  obs = filter(obs,  (: !$1->query_property("dead") :));
  if (!sizeof(obs)) {
    add_failed_mess("You must teach someone, preferably living.\n");
    return 0;
  }
  if (sizeof(obs) > 1) {
    add_failed_mess("You can only teach one person at a time.\n");
    return 0;
  }
  if (!command_teach(obs, str, teacher) &&
      !spell_teach(obs, str, teacher) &&
      !teach_skill(obs, str, teacher))
  {
    return 0;
  }
  return 1;
}
int check_ignoring(object ignorer, object ignoree) {
  return (ignorer->query_property("ignoring") &&
          member_array(ignoree->query_name(),
                       ignorer->query_property("ignoring")) != -1);
}
int command_teach(object *obs, string comm, object teacher) {
  string cmd_ob;
  object *succ;
  object *no_go;
  object *me_low;
  mixed *him_low;
  object *know_already;
  object *ear_muffed;
  object *ignored;
  object *ignoring;
  object ob;
  string *tmp_stuff;
  int i;
  class command cmd = new(class command, verb : comm);
  mixed tmp;
  if (member_array(comm, teacher->query_known_commands()) == -1 ||
      !CMD_D->HandleStars(cmd))
  {
    if (CMD_D->HandleStars(cmd)) {
      if (teacher == this_player()) {
        add_failed_mess("You do not know the command " + comm + ".\n");
      } else {
        add_failed_mess(teacher->the_short(1) +
                        " does not know the command " + comm + ".\n");
      }
    }
    return 0;
  }
  obs -= ({ teacher });
  if (!sizeof(obs)) {
    add_failed_mess("You cannot teach yourself a command.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    if (teacher == this_player()) {
      add_failed_mess("You have teaching earmuffed.\n");
    } else {
      add_failed_mess(teacher->the_short(1) + " has teaching earmuffed.\n");
    }
    return 0;
  }
  cmd_ob = CMD_D->GetPaths(cmd->verb)[0] + "/" + cmd->verb;
  succ = ({ });
  ear_muffed = ({ });
  know_already = ({ });
  no_go = ({ });
  me_low = ({ });
  him_low = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (!living(ob)) {
      continue;
    }
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (member_array(comm, ob->query_known_commands()) != -1) {
      know_already += ({ tmp });
    } else if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
    } else if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
    } else {
      switch (cmd_ob->can_teach_command(teacher, ob)) {
        case 1:
          succ += ({ ob });
          break;
        case 0 :
          no_go += ({ tmp });
          break;
        case -1 :
          me_low += ({ tmp });
          break;
        case -2 :
          him_low += ({ tmp });
          break;
      }
    }
  }
  if (!succ || !sizeof(succ)) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + comm + " from you automatically, "
                  "but failed.\n");
    }
    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() + " cannot teach " + comm +
                      " to $I.\n", no_go);
    }
    if (sizeof(me_low)) {
      if (teacher == this_player()) {
        add_failed_mess(teacher->the_short() +
                        " are too low a level to teach " + comm +
                        " to $I.\n", me_low);
      } else {
        add_failed_mess(teacher->the_short() +
                        " is too low a level to teach " + comm +
                        " to $I.\n", me_low);
      }
    }
    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("$I has teaching events earmuffed, you are unable "
                      "to teach them.\n", ear_muffed);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " +
                      ((sizeof(him_low) == 1  &&
                        him_low[0] != this_player()) ? "is" : "are") +
                      " too low a level to learn " + comm + ".\n", him_low);
    }
    if (sizeof(know_already)) {
      add_failed_mess("$I already know" +
                      (sizeof(know_already) > 1  ||
                       teacher != this_player()? "" : "s") +
                      " the command " + comm + ".\n", know_already);
    }
    if (sizeof(ignoring)) {
      if (this_player() == teacher) {
        add_failed_mess("You are ignoring $I.\n", ignoring);
      } else {
        add_failed_mess(teacher->the_short(1) + " is ignoring $I.\n",
                        ignoring);
      }
    }
    if (sizeof(ignored)) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    return 0;
  }
  write(teacher->the_short() + " offer" +
        (this_player() == teacher ? "" : "s") + " to teach " + comm +
        " to " + query_multiple_short(succ) + ".\n");
  if (teacher == this_player()) {
    if (sizeof(no_go)) {
      write("You cannot teach " + comm + " to " +
            query_multiple_short(no_go, "the", 0, 1 ) + ".\n");
    }
    if (sizeof(ear_muffed) > 0) {
      write(capitalize(query_multiple_short(ear_muffed, "the", 0, 1)) +
            " has teaching events earmuffed, you are unable "
            "to teach them.\n");
    }
    if (sizeof(me_low) > 0) {
      write("You are too low a level to teach " + comm + " to " +
            query_multiple_short(me_low, "the", 0, 1) + ".\n");
    }
    if (sizeof(him_low) > 0) {
      write(capitalize(query_multiple_short(him_low, "the", 0, 1)) +
            ((sizeof(him_low) == 1) ? " is" : " are") +" too low a "
            "level to learn " + comm + ".\n");
    }
  } else {
    tell_object(teacher,
                "You automatically offer to teach " + comm + " to " +
                query_multiple_short(succ) + ".\n");
  }
  say(capitalize((string)teacher->short()) + " teaches something to " +
      query_multiple_short(succ) + ".\n", succ + ({ teacher }));
  for (i = 0; i < sizeof(succ); i++) {
    tell_object(succ[i], capitalize(teacher->the_short()) +
                " offers to teach " +
                query_multiple_short(delete(succ, i, 1) +
                ({ "you" }) ) + " the command \"" + comm + "\".\n"
                "Type \"learn " + comm + " from " +
                teacher->query_name() + "\" to learn the command.\n");
    tmp_stuff = succ[i]->query_respond_command(TEACH_COMMAND_TYPE, teacher);
    if (!tmp_stuff) {
      tmp_stuff = ({ comm });
    } else if (member_array(comm, tmp_stuff) == -1) {
      tmp_stuff += ({ comm });
    }
    succ[i]->add_respond_command(TEACH_COMMAND_TYPE, teacher, tmp_stuff);
  }
  add_succeeded_mess("");
  return 1;
}
int spell_teach(object *obs, string spell, object teacher) {
  object *succ, *no_go, *me_low, *him_low, ob;
  object *ignoring;
  object *ignored;
  object *ear_muffed;
  string ret;
  string is_are;
  mapping spells;
  mixed tmp;
  spells = teacher->query_spells();
  if (!spells[spell]) {
    return 0;
  }
  if (teacher == this_player()) {
    is_are = "are";
  } else {
    is_are = "is";
  }
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  ear_muffed = succ = no_go = me_low = him_low = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (living(ob)) {
      if (ob->check_earmuffs("teach")) {
        ear_muffed += ({ ob });
        continue;
      } else if (check_ignoring(ob, teacher)) {
        ignored += ({ ob });
      } else {
        if (teacher == this_player()) {
          tmp = ob;
        } else {
          tmp = "you";
        }
        switch (spells[spell][0]->teach(ob, spell)) {
          case 1:
            succ += ({ ob });
            break;
          case 0:
            no_go += ({ ob });
            break;
          case -1:
            me_low += ({ ob });
            break;
          case -2:
            him_low += ({ ob });
            break;
        }
      }
    }
  }
  if (sizeof(succ) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + spell +
                  " from you automatically, but failed.\n");
    }
    ret = "";
    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() +
                      " cannot teach " + spell + " to $I.\n", no_go);
    }
    if (sizeof(me_low) > 0) {
      add_failed_mess(teacher->the_short() +
                      " " + is_are +
                      " too low a level to teach $I " + spell + ".\n",
                      me_low);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " + is_are + " too low a level to learn " +
                       spell + ".\n", him_low);
    }
    if (sizeof(ignoring)) {
       add_failed_mess("You are ignoring $I.\n", ignoring);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("$I has teaching earmuffed.\n", ignored);
    }
    return 0;
   }
   if (teacher == this_player()) {
     write(teacher->the_short() +
           " successfuly teach " + query_multiple_short(succ) + " " +
           spell + ".\n");
     if (sizeof(no_go) > 0) {
       write("You cannot teach " + spell + " to " +
             query_multiple_short(no_go, "the", 0, 1) + ".\n");
     }
     if (sizeof(me_low) > 0) {
       write("You are too low a level to teach " +
             query_multiple_short(me_low, "the", 0, 1) + " " + spell +
             ".\n");
     }
     if (sizeof(him_low) > 0) {
       write(capitalize(query_multiple_short(him_low, 0, 1)) +
             (sizeof(him_low) == 1 ? " is " : " are ") +
             "too low a level to learn " + spell + ".\n");
     }
     if (sizeof(ignoring) > 0) {
       add_failed_mess("You are ignoring " +
                       query_multiple_short(ignoring, "the", 0, 1) +
                       ".\n");
     }
     if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by " +
                       query_multiple_short(ignored, "the", 0, 1) + ".\n");
     }
   } else {
     write(teacher->the_short() +
           " successfuly teaches " + query_multiple_short(succ) + " " +
           spell + ".\n");
   }
   return 1;
}
#define CANNOT 0
#define TOO_LOW 1
#define ONLY_LEAF 2
#define TOO_HIGH 3
#define CANNOT_TEACH 4
int teach_skill(object *obs, string str, object teacher) {
  int num;
  int lvl;
  int my_lvl;
  int lvl_up;
  int j;
  int cost;
  int total;
  int total2;
  int sk;
  int depth;
  object *ok;
  object *too_little;
  mixed  *too_low;
  object *cannot_teach;
  object *only_leaf;
  object *ignored;
  object *ignoring;
  object *ear_muffed;
  object *too_high;
  object ob;
  string skill;
  string skill_start;
  mixed *bits;
  class teaching_skill frog;
  float k;
  mixed tmp;
  num = 1;
  if (sscanf(str, "%d levels of %s", num, skill) != 2) {
    if (sscanf(str, "%d level of %s", num, skill) != 2) {
      if (sscanf(str, "%d %s", num, skill) != 2) {
        num = 1;
        skill = str;
      }
    }
  }
  if (num < 1) {
    add_failed_mess("You cannot teach a negative or zero number of "
                    "levels.\n");
    return 0;
  }
  if (num > 50) {
    add_failed_mess("You cannot teach more than 50 levels at a time.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  skill_start = skill;
  bits = explode(implode(explode(skill, " "), "."), ".") - ({ "" });
  if (!bits || !(skill = (string)SKILL_OB->query_skill(bits))) {
    if (member_array(skill_start, teacher->query_known_commands()) != -1) {
      return 0;
    }
    add_failed_mess("The skill " + implode(bits, ".") + " is invalid.\n");
    return 0;
  }
  bits = explode(skill, ".");
  my_lvl = teacher->query_skill_bonus(skill, 1);
  ear_muffed = ({ });
  too_high = ({ });
  only_leaf = ({ });
  too_low = ({ });
  ok = ({ });
  too_little = ({ });
  cannot_teach = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach (ob in obs) {
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (!interactive(ob)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (!SKILL_OB->query_allowed_to_teach(skill)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
      continue;
    }
    if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
      continue;
    }
    if (SKILL_OB->query_only_leaf(skill) &&
        sizeof((mixed *)SKILL_OB->query_immediate_children(skill)))
    {
      only_leaf += ({ tmp });
      continue;
    }
    lvl = (int)ob->query_skill(skill);
    if (ob != teacher) {
      if ((int)ob->calc_bonus(lvl + num, skill, 1) > my_lvl) {
        add_failed_mess(teacher->the_short() +
                        " cannot teach $I, since their bonus is " +
                        (teacher == this_player() ? "higher" : "lower") +
                        " than yours.\n", ({ tmp }));
        continue;
      }
#ifdef ENFORCE_MAX_TEACH_LEVEL
      if (lvl + num > SKILL_MAX_TEACH) {
        too_high += ({ tmp });
        continue;
      }
#endif
    }
    if (sizeof(bits) > 1) {
      lvl_up = ob->query_skill(implode(bits[0 .. sizeof(bits) - 2], "."));
    } else {
      lvl_up = lvl;
    }
    depth = SKILL_OB->query_skill_depth(bits);
    if (!SKILL_OB->query_only_leaf(skill) && depth * 5 > lvl_up) {
      too_low += ({ tmp });
      continue;
    }
    total = 0;
    total2 = 0;
    foreach (sk in SKILL_OB->query_all_children(skill)) {
      if (SKILL_OB->query_immediate_children(sk) != ({ })) {
        continue;
      }
      my_lvl = teacher->query_skill_bonus(sk, 1);
      lvl = (int)ob->query_skill(sk);
      cost = DEFAULT_COST;
      cost *= STD_COST / 5;
      if (!my_lvl) {
        my_lvl = 1;
      }
      for (j = 0; j < num; j++) {
        k = 0.5 * (int)ob->calc_bonus(lvl + j, sk, 1 ) / my_lvl + 1.0;
        total2 += 500 + to_int(cost * (lvl+j) * exp((lvl + j) / 500.0) * k);
        if (total > total2) {
          num = j;
          break;
        } else {
          total = total2;
        }
      }
#ifdef DEBUG
      tell_object(find_player(DEBUGGER),
                  sprintf("%s:%s j:%d, lvl: %d, mylvl: %d, newbonus: %d, "
                          "total: %d\n",
                          this_player()->query_name(),
                          ob->query_name(),
                          j, lvl,
                          my_lvl,
                          (int)ob->calc_bonus(lvl + j, sk, 1),
                          lvl,
                          total2));
#endif
      if (!total) {
        total = cost;
      }
    }
    if (total > (int)ob->query_xp()) {
      if (teacher == this_player()) {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to $I.\n", ({ ob }));
      } else {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to you from " + teacher->the_short() +
                        ".\n");
      }
      too_little += ({ tmp });
      continue;
    }
    if (ob != teacher) {
      if (teacher == this_player()) {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\nUse "
                    "\"learn\" to learn the skill.\n");
        write("You offer to teach $M$$the_short:" + file_name(ob) +
              "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
              skill + " for " + total + " xp.\n");
      } else {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for "+total+" xp.\nUse \"learn\" "
                    "to learn the skill.\n");
        tell_object(teacher,
                    "You offer to teach $M$$the_short:" + file_name(ob) +
                    "$$M$ " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\n");
      }
    } else {
      write("You can teach yourself " + num + " level" +
            (num > 1 ? "s" : "") + " of " + skill + " for " + total +
            " xp.\nUse \"learn\" to learn the skill.\n");
      write("You offer to teach $M$$the_short:" + file_name(ob) +
            "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
            skill + " for " + total + " xp.\n");
    }
    ok += ({ tmp });
    frog = new(class teaching_skill);
    frog->num = num;
    frog->lvl = ob->query_skill(skill);
    frog->skill = skill;
    frog->xp = total;
    frog->room = environment(this_player());
    ob->add_respond_command(TEACH_SKILL_TYPE, teacher, frog);
  }
  if (sizeof(ok) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher,
                  this_player()->the_short() + " tried to learn " + skill +
                  " from you automatically but failed.\n");
    }
    if (sizeof(only_leaf) > 0) {
      add_failed_mess("You cannot teach the skill " + skill +
                      ", as it is only possible to teach leaf skills in "
                      "this skill tree.\n");
    }
    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      " to $I, they have teaching earmuffed and cannot "
                      "hear you.\n", ear_muffed);
    }
    if (sizeof(cannot_teach) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      "; you need to look for alternative methods of "
                      "advancement.\n");
    }
    if (sizeof(too_low) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_low) > 1    ||
                        too_low[0] == teacher  ||
                        teacher != this_player()) ? " are " : " is ") +
                      "not at a high enough level in the outer skills to "
                      "learn " + num + " levels of " + skill + ".   See "
                      "'help skills' for more details.\n");
    }
    if (sizeof(too_high) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_high) > 1     ||
                        teacher != this_player() ||
                        too_low[0] == teacher) ? " are " : " is ") +
                      "too high a level to learn " + num + " levels of " +
                      skill + ", they must be less than " +
                      SKILL_MAX_TEACH + " to learn from someone else.\n");
    }
    if (sizeof(ignoring) > 0) {
      add_failed_mess("You are ignoring $I.\n", ignoring);
    }
    if (sizeof(ignored) > 0) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
  }
  return sizeof(ok);
}
mixed *query_patterns() {
   return ({
      "<string:'skill|n levels of skill|command'> to <indirect:living>",
                   (: cmd($4[0], $1, 0) :),
      "me <string:'skill|n levels of skill|command'> from <indirect:living>",
                   (: cmd($4[0], $1, this_player()) :)});
}

==================================================
FILE: living/th_row.c
==================================================

#define CREATOR "Ceres"
#include <player.h>
#include <move_failures.h>
#include <tasks.h>
#define ASKILL "fighting.combat.range.thrown"
#define DSKILL "fighting.combat.dodging.range"
#define PSKILL "fighting.combat.parry.range"
#define COMMAND_GP_COST 5
inherit "/cmds/base";
int valid_target( object target, object thrower, object item );
int cmd( mixed *indirect_obs ) {
    object target, item;
    int dchance, damage;
    if ( sizeof( indirect_obs[ 0 ] ) > 1 ) {
        add_failed_mess( "You can only throw one item at a time!\n" );
        return 0;
    }
    item = indirect_obs[ 0 ][ 0 ];
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You can only throw $I at one target at a time!\n",
            ({ item }) );
        return 0;
    }
    target = indirect_obs[ 1 ][ 0 ];
    if ( item->query_wielded() != this_player() ) {
        add_failed_mess( "You must be holding $I to throw it.\n",
            ({ item }) );
        return 0;
    }
    if ( this_player() == target ) {
        add_failed_mess( "You cannot throw $I at yourself!\n", ({ item }) );
        return 0;
    }
    if ( !living( target ) && !target->query_property( "targetable" ) ) {
        add_failed_mess( "Why do you want to throw $I at " +
            target->the_short() + "?\n", ({ item }) );
        return 0;
    }
    if (this_player()->query_gp() < COMMAND_GP_COST) {
        add_failed_mess( "You need " + COMMAND_GP_COST + " points to "
            "throw " + item->the_short() + " at " + target->the_short() +
            ".\n");
        return 0;
    }
    if ( !valid_target( target, this_player(), item ) ) {
        add_failed_mess( "You decide against throwing $I at " +
            target->the_short() + ".\n", ({ item }) );
        return 0;
    }
    if ( living( target ) ) {
        switch ( (string)target->query_combat_response() ) {
            case "dodge" :
                dchance = target->query_skill_bonus( DSKILL );
            break;
            default:
                dchance = target->query_skill_bonus( PSKILL );
        }
    }
    else {
        dchance = target->query_property( "targetable" );
    }
    dchance += item->query_weight() / ( this_player()->query_str() / 2 );
    if( !this_player()->query_visible( target ) ) {
        dchance /= 2;
    }
    this_player()->adjust_gp(-COMMAND_GP_COST);
    switch( TASKER->perform_task(this_player(), ASKILL, dchance, TM_FREE) ) {
        case AWARD:
            tell_object(this_player(), "%^YELLOW%^You feel that your "
                "skill in throwing weapons has increased.%^RESET%^\n");
        case SUCCEED:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " and hit!\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                    " at " + target->the_short() + " and hits!\n",
                    this_player() );
            if ( living( target ) ) {
                damage = ( item->query_weight() / 4 ) +
                    ( this_player()->query_str() * 2) +
                    ( this_player()->query_skill_bonus( ASKILL ) / 3 );
                damage -= target->query_ac( "blunt", damage );
                target->attack_by( this_player() );
                target->adjust_hp( -damage, this_player() );
                this_player()->attack_ob( target );
                event( item, "thrown", this_player(), target );
                    this_player()->adjust_time_left(-(ROUND_TIME*2));
            }
            target->thrown_at( this_player(), 1, item );
            if ( item->move( target ) != MOVE_OK ) {
                item->move( environment( target ) );
            }
        break;
        default:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " but miss.\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                " at " + target->the_short() + " but misses.\n", this_player() );
            item->move( environment( target ) );
            if( !interactive( target ) && living( target ) ) {
                this_player()->attack_ob( target );
                target->attack_by( this_player() );
            }
            target->thrown_at( this_player(), 0 );
        break;
    }
    return 1;
}
int valid_target( object target, object thrower, object item ) {
    mixed owner;
    if ( target->query_property( "dead" ) || target->query_auto_loading() ) {
        return 0;
    }
    if ( userp( target ) && !interactive( target ) ) {
        return 0;
    }
    if ( pk_check( thrower, target ) )
        return 0;
    if ( ( owner = target->query_owner() ) && pk_check( thrower, owner ) ) {
        return 0;
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me'weapon'> at <indirect:object'target'>",
        (: cmd($1) :) });
}

==================================================
FILE: living/und_efend.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  object *defendees;
  object ob;
  object *fail;
  if(!things) {
    things = ({ });
  }
  things -= ({ TP });
  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot undefend yourself!\n");
    return 0;
  }
  defendees = ({ });
  fail = ({ });
  foreach ( ob in things) {
    if ( ob->remove_defender( TP ) ) {
      defendees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not defending " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(defendees)) {
     add_succeeded_mess("$N stop$s defending $I.\n", defendees);
     return 1;
  } else {
     return 0;
  }
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/unf_ollow.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   mapping hide_invis;
   int hiding, sneaking;
  object *ok, ob;
  string s;
  ok = ({ });
  foreach (ob in obs) {
    if (ob->remove_follower(TP)) {
      ok += ({ ob });
    }
  }
  if (!sizeof(ok)) {
    if (member_array(TP, obs) == -1) {
      return notify_fail("You are not following "+query_multiple_short(obs)+
                         ".\n");
    } else {
      return notify_fail("You are not following " +
        query_multiple_short(obs - ({ TP }) + ({ "yourself" })) + ".\n");
    }
  }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
   write("You stop following "+(s=query_multiple_short(ok))+" unseen.\n");
  else {
    write("You stop following "+(s=query_multiple_short(ok))+".\n");
    say(TP->the_short()+" stops following "+s+".\n", ok);
    foreach (ob in ok) {
      tell_object(ob, TP->the_short() +
                  " stops following "+query_multiple_short((ok + ({"you"})) -
                                                           ({ ob }))+".\n");
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/unh_old.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object obs) {
  object *ok, *zip, *failed, ob, *using;
  string s;
  mixed ret;
  using = TP->query_holding();
  failed = ok = zip = ({ });
  foreach (ob in obs) {
    if (member_array(ob, using) != -1) {
      if (!sizeof(ret = TP->set_unhold(ob)) || !ret)
        failed += ({ ob });
      else
        ok += ({ ob });
    }
    else
      zip += ({ ob });
  }
  if (!sizeof(ok)) {
    s = "";
    if (sizeof(failed))
      s += "Could not unhold "+query_multiple_short(failed)+".\n";
    if (sizeof(zip))
      s += capitalize("You are not holding " +
                      query_multiple_short(zip, "the") + ".\n");
    return notify_fail(s);
  }
  tell_object(TP, "You put down "+(s = query_multiple_short(ok))+".\n");
  tell_room(environment(TP), TP->one_short()+" puts down "+s+".\n", TP);
  TP->force_burden_recalculate();
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/unp_rotect.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  object *protectees;
  object ob;
  object *fail;
  if(!things) {
    things = ({ });
  }
  things -= ({ TP });
  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot unprotect yourself!\n");
    return 0;
  }
  protectees = ({ });
  fail = ({ });
  foreach ( ob in things) {
    if ( ob->remove_protector( TP ) ) {
      protectees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not protecting " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(protectees)) {
     add_succeeded_mess("$N stop$s protecting $I.\n", protectees);
     return 1;
  } else {
     return 0;
  }
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/watch.c
==================================================

#define COST 50
inherit "/cmds/base";
mixed cmd() {
   if ( this_player()->query_blinded() ) {
      add_failed_mess( "How can you watch anything?  You're blind.\n" );
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess( "Dead people don't watch. It is rude!\n");
      return 0;
   }
   if ( sizeof( (int *)this_player()->effects_matching( "mind.alertness" ) ) ) {
      add_failed_mess( "You are already alert and watching "
        "your surroundings.\n" );
      return 0;
   }
   if ( this_player()->query_specific_gp( "other" ) < COST ) {
      add_failed_mess( "You can't concentrate enough to watch "
        "your surroundings.\n" );
      return 0;
   }
   this_player()->adjust_gp( -COST );
   this_player()->add_effect( "/std/effects/other/alertness", 60 +
     (int)this_player()->query_skill_bonus( "other.perception" ) / 2 );
   return 1;
}
int stop_watching() {
   int *enums, id;
   enums = this_player()->effects_matching( "mind.alertness" );
   if ( sizeof( enums ) ) {
      foreach( id in enums ) {
         this_player()->delete_effect( id );
      }
   }
   else {
      add_succeeded_mess( ({ "You are not currently watching!\n", "" }) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "stop", (: stop_watching() :),
     "", (: cmd() :) });
}

==================================================
FILE: living/wea_r.c
==================================================

#include <clothing.h>
#include <tasks.h>
inherit "/cmds/base";
#define TP this_player()
#define SKILL "covert.manipulation.sleight-of-hand"
mapping add_to_failed(mapping failed, string word, object thing);
int cmd(object *things) {
  int i;
  string result;
  string stuff;
  string *reasons;
  object *okay;
  object *blocking;
  object *total_blocking;
  object ob;
  object tmp;
  mapping failed;
  mapping hide_invis;
  int hiding, sneaking, difficulty, light, my_light;
  okay = ({ });
  failed = ([ ]);
  things = sort_array(things, (: CLOTHING_HANDLER->query_clothing_depth($2->query_type()) -
                                 CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :) );
  total_blocking = ({ });
  foreach (ob in things) {
    if (environment(ob) != this_player())  {
      failed = add_to_failed(failed, "not carrying", ob);
      continue;
    }
    if ( !ob->query_wearable() ) {
      failed = add_to_failed( failed, "cannot wear", ob);
      continue;
    }
    if (member_array(ob, TP->query_wearing()) != -1) {
      failed = add_to_failed(failed, "already wearing", ob);
      continue;
    }
    if (ob->cannot_be_worn()) {
      failed = add_to_failed(failed, "cannot wear", ob);
      continue;
    }
    blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player());
if (this_player() == find_player("presto"))
printf("blocking == %O\n", blocking);
    if (sizeof(blocking)) {
       total_blocking += blocking;
       foreach (tmp in blocking) {
          TP->remove_armour(tmp);
       }
    }
    result = CLOTHING_HANDLER->can_wear_or_remove(ob, this_player());
if (this_player() == find_player("presto"))
printf("ob == %s, result == %s\n", ob->short(), result);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    result = TP->wear_armour(ob, 0);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    okay += ({ ob });
  }
  if (total_blocking) {
    foreach (tmp in total_blocking) {
      TP->wear_armour(tmp);
    }
  }
  result = "";
  if (sizeof(failed)) {
    reasons = keys(failed);
    for (i = 0; i < sizeof(reasons); i++) {
      stuff = query_multiple_short(failed[reasons[i]], "the");
      switch (reasons[i]) {
      case "cannot wear" :
        if (!sizeof(okay)) {
           result += capitalize(stuff) +" cannot be worn.\n";
        }
        break;
      case "already wearing" :
        result += "You are already wearing "+ stuff +".\n";
        break;
      case "already holding" :
        result += "You cannot wear "+ stuff +" as you do not "
          "have enough free limbs.\n";
        break;
      case "oh dear" :
        result += "I'm not sure why you can't wear "+ stuff +
          "; something has probably gone wrong, so please "
          "contact a creator.\n";
        break;
      case "not carrying":
        result += "You aren't carrying " + stuff + ".\n";
        break;
      default :
        result += "You cannot put on "+ stuff +" "+ reasons[i] +".\n";
      }
    }
  }
  if (!sizeof(okay)) {
    return notify_fail(result);
  }
  stuff = query_multiple_short(okay);
  if (sizeof(total_blocking)) {
     tell_room(environment(TP), TP->one_short() + " removes " +
               query_multiple_short(total_blocking) + " so " +
               TP->query_pronoun() + " can wear "+
               stuff +".\n" + TP->one_short() + " wears " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
     write("You remove " +
               query_multiple_short(total_blocking) + " so you can wear "+
               stuff +".\nYou wear " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
  } else {
    hide_invis = ( mapping )this_player()->query_hide_invis();
    hiding = hide_invis[ "hiding" ] ? 1 : 0;
    sneaking = this_player()->query_sneak_level() ? 1 : 0;
    if( hiding || sneaking ) {
      my_light = this_player()->query_light();
      light = environment( this_player() )->query_light();
      difficulty = light + ( 4 * my_light ) / ( light + 1 );
      if( sizeof( total_blocking ) ) {
        difficulty += 50 * sizeof( total_blocking );
      }
      difficulty += okay[0]->query_complete_weight();
      debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                    difficulty, SKILL, this_player()->
                    query_skill_bonus( SKILL ) );
      switch( TASKER->perform_task( this_player(), SKILL, difficulty,
        TM_FREE ) ) {
        case AWARD :
          write( "%^YELLOW%^" + ({
            "You discover something that lets your fingers move more "
              "nimbly.",
            "You find yourself capable of deceiving the eye with greater "
              "ease than before.",
            "You realise how to deceive the eye more effectively."
          })[ random(3) ] + "%^RESET%^\n" );
        case SUCCEED :
          add_succeeded_mess( ({ "$N $V " + stuff + ", managing to stay "
            "unnoticed.\n",
            "" }) );
          break;
        default :
          this_player()->add_succeeded_mess( this_object(), "$N "
            "unsuccessfully tr$y to " + query_verb() + " " + stuff +
            " while staying unnoticed.\n", ({ }) );
          break;
      }
    } else {
      this_player()->add_succeeded_mess( this_object(), "$N $V " + stuff +
        ".\n", ({ }) );
    }
  }
  return 1;
}
mapping add_to_failed(mapping failed, string word, object thing) {
  if (!failed[word]) {
    failed += ([ word : ({ thing }) ]);
  } else {
    failed[word] += ({ thing });
  }
  return failed;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/whi_sper.c
==================================================

inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd( object *others, string last ) {
  class message mess;
  if (sizeof(others) == 1 && others[0] == this_player()) {
     add_failed_mess("Whispering to yourself?  Neat trick.\n");
     return 0;
  }
  mess = build_message(last, others, "whisper");
  mess->type = "whisper";
  return say_it_to(mess, others, 1, "whisper");
}
mixed *query_patterns() {
   return ({ "<string'message'> to <indirect:living>", (: cmd($1, $4[0]) :),
             "<indirect:living> <string'message'>", (: cmd($1, $4[1]) :) });
}

==================================================
FILE: living/wi_eld.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  if (!interactive(this_player()))
    return "/cmds/living/ho_ld"->cmd(str);
  return notify_fail("Use hold; see help hold for more details.\n");
}

==================================================
FILE: living/withdraw.c
==================================================

#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int withdraw_offer(object *sell_to) {
   object *removed;
   object ob;
   removed = ({ });
   foreach (ob in sell_to) {
      if (ob->query_respond_command("sell", this_player())) {
         ob->remove_respond_command("sell", this_player());
         removed += ({ ob });
      }
   }
   if (sizeof(removed)) {
      add_succeeded_mess("$N withdraw$s $p offer of sale to $I.\n", removed);
      return 1;
   }
   add_failed_mess("You cannot withdraw your offer of sale to $I since "
                   "you have not offered to sell them anything in the "
                   "first place.\n", sell_to);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer {from|to} <indirect:living>",
             (: withdraw_offer($1) :) });
}

==================================================
FILE: living/wring.c
==================================================

inherit "/cmds/base";
int cmd(object *things)  {
   object *towels;
   int    *enums;
   int     wetness;
   int     success;
   string  str;
   towels = filter(things,
                   (: $1->id("towel")  ||  $1->query_property("dryer") :));
   things -= towels;
   str = "";
   if (sizeof(towels) == 1)  {
      enums = towels[0]->effects_matching("object.wet");
      if (sizeof(enums)) {
         wetness = towels[0]->arg_of(enums[0]);
      }
      if (wetness < 36 - this_player()->query_str())  {
         str = "You can't wring any more moisture out of " +
               towels[0]->one_short();
         success = 0;
      } else  {
         towels[0]->add_effect("/std/effects/object/wet",
            -wetness / ((36 - this_player()->query_str()) / 4));
         str = "You wring some moisture out of " +
               towels[0]->one_short();
         success = 1;
      }
   } else if (sizeof(towels))  {
      str = "You can only wring out one thing at a time";
      success = 0;
   }
   if (sizeof(things))  {
      if (success) {
         str += ", but you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      } else {
         str += ", and you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      }
   } else {
      str += ".\n";
   }
   write(str);
   return 1;
}
mixed *query_patterns()  {
   return ({ "[out] <indirect:object:me'towel'>", (: cmd($1) :) });
}

==================================================
FILE: creator/addalt.c
==================================================

#include <creator.h>
#include <playerinfo.h>
inherit "/cmds/base";
int add_alt(string s1, string s2) {
  string *alts, alt;
  s1 = this_player()->expand_nickname(lower_case(s1));
  alts = explode(lower_case(s2)," ") - ({ "" }) - ({ 0 });
  foreach(alt in alts)
    write(PLAYERINFO_HANDLER->add_alt(this_player(), s1, alt));
  return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <string'alt-name alt-name ...'>",
        (: add_alt($4[0],$4[1]) :)
    });
}

==================================================
FILE: creator/addevent.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
inherit "/cmds/base";
void update_database(string comment, string *data) {
    if (comment == 0) {
       return;
    }
    if (PLAYERINFO_HANDLER->add_entry(this_player(),
                                      data[0],
                                      data[1],
                                      comment+"\n")) {
        write(capitalize(data[0])+"'s dossier updated.  \n");
    } else {
        write("Cannot update "+capitalize(data[0])+"'s dossier.  \n");
    }
}
int add_event(string player, string event, string comment) {
    string *events;
    string myself;
    player = this_player()->expand_nickname(lower_case(player));
    event = lower_case(event);
    if (!PLAYER_HANDLER->test_user(player)) {
        add_failed_mess("No such player: " + player + ".\n");
        return 0;
    }
    myself = base_name(this_object());
    events = filter(PLAYERINFO_HANDLER->query_events(),
                (: PLAYERINFO_HANDLER->query_source_ok($1, $(myself)) :));
    if (member_array(event, events) == -1) {
       add_failed_mess("Incorrect event type '" + event +
                       "' it must be one of " +
                       query_multiple_short(events) + ".\n");
       return 0;
    }
    if (comment != 0) {
        update_database(comment, ({ player, event }));
        return 1;
    }
    write("Please enter your comments:\n");
    this_player()->do_edit(0, "update_database", this_object(), 0,
                           ({ player, event }));
    return 1;
}
int list_events() {
    string result;
    string myself;
    string *list;
    result = "";
    myself = base_name(this_object());
    list = sort_array(
            filter(PLAYERINFO_HANDLER->query_events(),
                (: PLAYERINFO_HANDLER->query_source_ok($1, $(myself)) :)), 1);
    write("The following events can be added using addevent: " +
          query_multiple_short(list) + ". \n");
    return 1;
}
mixed *query_patterns()
{
    return ({
        "list",
        (: list_events() :),
        "<word'player-name'> <word'event'>",
        (: add_event($4[0],$4[1],0) :),
        "<word'player-name'> <word'event'> <string'comment'>",
        (: add_event($4[0],$4[1],$4[2]) :)
    });
}

==================================================
FILE: creator/auto_doc.c
==================================================

inherit "/cmds/base";
#include <autodoc.h>
int cmd(string str) {
   string *files;
   string file;
   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->recreate_documentation(file)) {
         write("Recreating documentation for " + file + ".\n");
      } else {
         write("Unable to recreate documentation for " + file + ".\n");
      }
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
 }

==================================================
FILE: creator/autodocadd.c
==================================================

inherit "/cmds/base";
#include <autodoc.h>
int cmd(string str) {
   string *files;
   string file;
   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->add_file(file)) {
         write("Added file " + file + ".\n");
      } else {
         write("Unable to add file " + file + ".\n");
      }
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
 }

==================================================
FILE: creator/autodocrm.c
==================================================

inherit "/cmds/base";
#include <autodoc.h>
int cmd(string str) {
   string *files;
   string file;
   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->remove_file(file)) {
         write("Removed file " + file + ".\n");
      } else {
         write("Unable to remove file " + file + ".\n");
      }
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
 }

==================================================
FILE: creator/ban.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
mixed cmd(string ip, string reason) {
  seteuid("Root");
  if (this_player() != this_player(1))
    return 0;
  if(!"/secure/master"->query_lord(geteuid(previous_object())) &&
     !"/d/liaison/master"->query_deputy(geteuid(previous_object())))
    return notify_fail("Only lords or liaison deputies can do that.\n");
  if(strsrch(ip, "*") != -1)
    return notify_fail("This command does not take wildcards.\n");
  if (!"/secure/bastards"->change_access(ip, 2, reason,
                                         time() + (60*60*2))) {
    write("Error changing permissions.\n");
    return 0;
  }
  write("Site banned.\n");
  return 1;
}
int help() {
  return notify_fail(
    "Syntax: ban <ip number> <reason>\n");
}
mixed *query_patterns() {
  return ({ "<word'address'> <string'reason'>",
              (: cmd($4[0], implode($4[1..], "")) :),
              "help", (: help() :)
              });
}

==================================================
FILE: creator/bugreps.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Reporter"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Reporter, count(*) as bing from errors "
                   "group by Reporter order by bing desc";
   } else {
      request = "select Reporter, count(*) as bing from errors "
		   "where Reporter = '" + who + "'"
                   "group by Reporter order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/callouts.c
==================================================

#define CALL_OUT_SORT_THRESHOLD 1000
#define CALL_OUT_FILE_NAME 0
#define CALL_OUT_FUNCTION 1
#define CALL_OUT_TIME 2
inherit "/cmds/base";
private mixed *get_call_outs() {
    mixed *junk;
    junk = call_out_info();
    if (sizeof(junk) < CALL_OUT_SORT_THRESHOLD) {
        junk = sort_array( junk, (: ( $1[ 2 ] > $2[ 2 ] ) -
            ( $1[ 2 ] < $2[ 2 ] ) :) );
    }
    return junk;
}
int count_callouts() {
    mixed *call_outs = get_call_outs();
    mapping count = ([ ]);
    string ret = "";
    foreach( mixed *func in call_outs) {
        count[ file_name( func[ CALL_OUT_FILE_NAME ] ) + ":" +
            func[ CALL_OUT_FUNCTION ] ] += 1;
    }
    foreach( string key, int value in count ) {
        ret += sprintf( "%-30s %d\n", key, value );
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int count_clean() {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        if ( base_name( func[CALL_OUT_FUNCTION] ) != "effect_timer" &&
          base_name( func[CALL_OUT_FUNCTION] ) != "print_messages" ) {
            ret += sprintf( "%O: %O in %O\n",
                        file_name( func[ CALL_OUT_FILE_NAME ] ),
                        func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
        }
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int count_for_file( string str ) {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        if ( sscanf( file_name( func[ 0 ] ), "%*s"+ str +"%*s" ) == 2 ) {
            ret += sprintf( "%O: %O in %O\n",
                file_name( func[ CALL_OUT_FILE_NAME ] ),
                func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
        }
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int count_time(string choice, int mtime ) {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        if ( choice == "before" && func[ CALL_OUT_TIME ] >= mtime ) {
            continue;
        } else if ( choice == "after" && func[ CALL_OUT_TIME ] <= mtime ) {
            continue;
        } else if ( choice == "at" && func[ CALL_OUT_TIME ] != mtime ) {
            continue;
        }
        ret += sprintf( "%O: %O in %O\n", func[ CALL_OUT_FILE_NAME ],
            func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
    }
    if ( ret == "" ) {
        add_failed_mess( "No callouts matching that criteria found.\n" );
        return -1;
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int cmd() {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        ret += sprintf( "%O: %O in %O\n", func[ CALL_OUT_FILE_NAME ],
            func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
mixed *query_patterns() {
    return ({ "{-c|count}", (: count_callouts :),
              "{-b|no effects}", (: count_clean :),
              "<string'file'>", (: count_for_file( $4[0] ) :),
              "{before|at|after} <number'time'>",
                (: count_time($4[0], $4[1]) :),
              "", (: cmd :),
    });
}

==================================================
FILE: creator/cloner.c
==================================================

inherit "/cmds/base";
#define CLONER "/global/cloner"
#define LIFE_TIME 7257600
int do_list(string file) {
  string *files, change;
  mapping changes;
  string ret;
  if(file && file != "") {
    files = this_player()->get_files(file);
  }
  changes = CLONER->query_changes();
  ret = "";
  foreach(change in keys(changes)) {
    if(files && member_array(change, files) == -1 &&
       strsrch(change, file) == -1) {
      continue;
    }
    ret += sprintf("%s:\n  %s until %s\n", change, changes[change][0],
           ctime(changes[change][1] + LIFE_TIME));
  }
  this_player()->more_string( ret, "Cloner list", 1 );
  return 1;
}
int do_move(string source, string dest) {
  string *sources, *tmp, destp, rcs;
  seteuid(geteuid(this_player()));
  sources = this_player()->get_files(source);
  if(!sizeof(sources))
    return notify_fail("No source files found.\n");
  destp = this_player()->get_path(dest);
  if(file_size(destp) != -2 && !mkdir(dest))
    return notify_fail("Destination must be a directory.\n");
  foreach(source in sources) {
    if(file_size(source) == -2 || file_size(source) == -1) {
      if(source[<4..] == "/RCS") {
        if(rename(source, source+".tmp"))
          return notify_fail("Error moving RCS directory to temp location.\n");
        else
          rcs = source+".tmp";
      } else
        write("Not moving directory: " + source + "\n");
    } else {
      tmp = explode(source, "/");
      dest = destp + "/" + tmp[sizeof(tmp)-1];
      if(rename(source, dest))
        return notify_fail("Error renaming [" + source + "] to [" + dest +
                           "]\n");
      CLONER->add_mapping(source, dest);
    }
  }
  if(rcs && rename(rcs, destp + "/RCS"))
    return notify_fail("Error moving RCS directory.\n");
  return 1;
}
int do_add(string source, string dest) {
  CLONER->add_mapping(source, dest);
  return 1;
}
int do_remove(string source) {
  CLONER->remove_mapping(source);
  return 1;
}
mixed *query_patterns() {
  return ({ "list", (: do_list(0) :),
            "list <word'file'>", (: do_list($4[0]) :),
            "move <word'source'> <word'dest'>", (: do_move($4[0], $4[1]) :),
            "add <word'source'> <word'dest'>", (: do_add($4[0], $4[1]) :),
            "remove <word'source'>", (: do_remove($4[0]) :),
              });
}

==================================================
FILE: creator/clubs.c
==================================================

#include <runtime_config.h>
#include <clubs.h>
#include <mail.h>
#include <money.h>
inherit "/cmds/base";
#define CONTROL_ROOM "/std/room/club_control_room"
#define ELEN 20
private void do_list(string extra, int width);
private void do_invalid(string extra, int width);
mixed cmd(string command, string extra, string rest) {
  if (this_player() != this_player(1))
    return 0;
  switch(command) {
  case "list":
    do_list(extra, this_player()->query_cols());
    break;
  case "invalid":
    do_invalid(extra, this_player()->query_cols());
    break;
  }
  return 1;
}
private string club_line(string club, int width, int verbose) {
  string tmp, tmp2, member;
  int clubtype, i;
  clubtype = CLUB_HANDLER->query_club_type(club);
  tmp = sprintf("%%^BOLD%%^%%^RED%%^%-9s%%^RESET%%^ %-15s\n",
                CLUB_ARRAY[clubtype]+":", club);
  if(verbose) {
        tmp+= sprintf(" %%^BOLD%%^Club Name:%%^RESET%%^ %s\n",
                  CLUB_HANDLER->query_club_name(club));
    tmp += sprintf(" %%^BOLD%%^Founder:%%^RESET%%^ %s\n"
                   " %%^BOLD%%^Members:%%^RESET%%^\n",
                   CLUB_HANDLER->query_founder(club));
    i = 0;
    tmp2 = "";
    foreach(member in CLUB_HANDLER->query_members(club)) {
      tmp2 += sprintf("%-15s ", member);
      if((i-1 * ELEN) % (width/ELEN) == 0  && tmp2 != "") {
        tmp += this_player()->fix_string("   " + tmp2 + "\n", width, 10);
        tmp2 = "";
      }
      i++;
    }
  }
  return tmp;
}
private void do_list(string extra, int width) {
  string club, tmp, t2, *clubs;
  tmp = "";
  clubs = sort_array(CLUB_HANDLER->query_clubs(),
                     (: strcmp($1, $2 ) :) );
  foreach(club in clubs) {
    if(extra == "" || extra == "brief" || extra == "verbose" ||
       strsrch(club, extra) != -1) {
      t2 = club_line(club, width, (extra != "brief"));
      if(strlen(tmp) + strlen(t2) < 200000)
        tmp += t2;
      else
        break;
    }
}
  if(tmp == "")
    write("No clubs matching " + extra + ".\n");
  else
    this_player()->more_string(tmp, "Clubs", 1);
}
private int do_balance(string club_name) {
   int balance;
   string place;
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("There is no club called '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   }
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   balance = CLUB_HANDLER->query_balance(club_name);
   write("The balance of the club '" +
         CLUB_HANDLER->query_club_name(club_name) + "' is " +
         MONEY_HAND->money_value_string(balance, place) + ".\n");
   return 1;
}
mixed *query_patterns() {
  return ({ "list", (: cmd("list", "", "") :),
            "list <string'club name'>", (: cmd("list", $4[0], "") :),
            "balance <string'club name'>", (: do_balance($4[0]) :)
        });
}

==================================================
FILE: creator/comment.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("COMMENT");
   set_use_last_error(1);
}

==================================================
FILE: creator/compare.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd( string words ) {
  string *name = allocate(2);
  string *mess = allocate(2);
  object *person = allocate(2);
  object *tmp;
  object thing;
  mixed *inv = allocate(2);
  mixed *matching = allocate(2);
  int i;
  sscanf( words, "%s with %s", name[0], name[1] );
  for( i=0; i<2; i++)
    name[i] = this_player()->expand_nickname( name[i] );
  for( i=0; i<2; i++) {
    if( !(person[i] = find_player( name[i] )) )
         return notify_fail("No such player - " + name[i] + ".\n");
    inv[i] = all_inventory( person[i] );
    tmp = ({ });
    foreach( thing in inv[i] )
      if( thing->query_cloned_by() == name[!i] ) tmp += ({ thing });
    if(tmp) {
      switch( arrayp(tmp) ) {
        case 1:  matching[i] = tmp; break;
        default: matching[1] = ({ tmp });
      }
    }
    switch( sizeof(matching[i]) ) {
      case 0:
        mess[i] = "No items in " + name[i] + " were cloned by " + name[!i] + ".\n";
        break;
      case 1:
        mess[i] = "One item in " + name[i] + " was cloned by " + name[!i] + ".\n";
        mess[i] += "  " + WIZ_PRESENT->desc_f_object(matching[i][0]) + "\n";
        break;
      default:
        mess[i] = sizeof(matching[i]) + " items in " + name[i] +
                                       " were cloned by " + name[!i] + ".\n";
        foreach( thing in matching[i] )
          mess[i] += "  " + WIZ_PRESENT->desc_f_object(thing) + "\n";
    }
  }
  write(mess[1] + "\n" + mess[0]);
  return 1;
}

==================================================
FILE: creator/compare2.c
==================================================

#include <creator.h>
inherit "/cmds/base";
string format_data( object *items, object victim, object target ) {
    int size;
    string vname, tname;
    vname = victim->the_short();
    tname = target->the_short();
    switch( size = sizeof( items ) ) {
    case 0:
        return "No objects in " + vname + " were cloned by " +
        tname;
    case 1:
        return "One object, " + query_multiple_short( items ) +
        " in " + vname + "'s inventory was cloned by " +
        tname;
    default:
        return query_num( size, 100 ) + " objects in " +
        vname + "'s inventory were cloned by " + tname;
    }
}
void describe_objects( object player1, object player2 ) {
    string mess;
    mapping data;
    data = filter( unique_mapping( all_inventory( player1 ),
        (: $1->query_cloned_by() :) ),
      (: $1 == $(player2)->query_name() :) );
    if ( !sizeof( data ) ) {
        data[ player1->query_name() ] = ({ });
    }
    mess = implode( values( map( data,
          (: format_data( $2, $(player1), $(player2) ) :) ) ), "\n" );
    tell_object( this_player(), "$P$compare$P$" + mess + "." );
}
int cmd( object player1, object player2 ) {
    describe_objects( player1, player2 );
    describe_objects( player2, player1 );
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present> {against|with|and} "
      "<indirect:wiz-present>",
      (: cmd( $1[0][0], $1[1][0] ) :) });
}

==================================================
FILE: creator/crea_tor.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ov, ob;
  notify_fail("Creator of what?\n");
  ov = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ov)) return 0;
  foreach (ob in ov) {
    write("Creator of " + WIZ_PRESENT->desc_object(ob) + ": " +
        master()->creator_file (file_name(ob)) + ", uid: " +
        getuid(ob) + ", euid: "+geteuid(ob)+"\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/cst_at.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ob, thing;
  mixed *ob1, *thing1;
  string s, bing;
  string long_fields, temp;
  int long_length;
  bing = "";
  str = (string)this_player()->expand_nickname(str);
  ob = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ob)) {
    write("No such object.\n");
    return 1;
  }
  foreach (thing in ob) {
    ob1 = (mixed *)thing->stats();
    if (!pointerp(ob1))
      continue;
    s = "";
    long_fields = "";
    long_length = ( (int)this_player()->query_cols() / 3 ) - 1;
    foreach (thing1 in (pointerp(ob1[0][0])?ob1[0]:ob1))
      if ( thing1[ 1 ] && !sscanf(thing1[0],"(%s)",temp)) {
        temp = thing1[0] +": "+ thing1[ 1 ] +"\n";
        if (strlen(temp) > long_length) long_fields += temp;
        else s += temp;
      }
    bing += sprintf("%-*#s\n", this_player()->query_cols(), long_fields) +
        sprintf( "%-*#s\n", this_player()->query_cols(), s );
  }
  this_player()->more_string(bing);
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/data.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd(object *obs, string var) {
    object ob;
    foreach (ob in obs) {
        if ( userp(ob) && !master()->query_lord( this_player()->query_name() ) ) {
            write("You cannot dump a player object.\n");
            continue;
        }
        else {
            this_player()->more_string( WIZ_PRESENT->desc_object( ob ) + ":\n" +
              debug_info( 2, ob ) + "\n", "Data" );
        }
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd($1, 0) :) });
}

==================================================
FILE: creator/dbxwhere.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  mapping error;
  object ob;
  if (str) {
    str = this_player()->expand_nickname(str);
    ob = find_player(str);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  } else
    ob = this_player();
  if (error = (mapping)ob->get_last_error()) {
    printf("%s\n", master()->standard_trace(error, 1));
  } else write("No error.\n");
  return 1;
}

==================================================
FILE: creator/debug.c
==================================================

inherit "/cmds/base";
#include <creator.h>
int cmd(object *obs, int detail) {
   object ob;
   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(detail, ob) + "\n");
   }
   return 1;
}
mixed *query_patterns() {
  return ({ "-v <indirect:wiz-present>", (: cmd($1, 2) :),
              "<indirect:wiz-present>", (: cmd($1, 1) :) });
}

==================================================
FILE: creator/define.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   string ret;
   string* bing;
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "No definitions for " + word + ".\n");
      } else {
         ret = "";
         foreach (bing in results) {
            ret += bing[1] + "\n" + bing[2] + "\n\n";
         }
         tell_object(player, "Definitions for " + word + ":\n" + ret);
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->define_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   add_succeeded_mess("$N look$s up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/delalt.c
==================================================

#include <creator.h>
#include <playerinfo.h>
inherit "/cmds/base";
int delete_alt(string s1, string s2) {
  string *alts, alt;
  s1 = this_player()->expand_nickname(lower_case(s1));
  alts =  explode(lower_case(s2)," ") - ({ "" }) - ({ 0 });
  foreach(alt in alts)
    write(PLAYERINFO_HANDLER->delete_alt(this_player(), s1, alt));
  return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <string'alt-name alt-name ...'>",
        (: delete_alt($4[0],$4[1]) :)
    });
}

==================================================
FILE: creator/delevent.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
inherit "/cmds/base";
int delete_event(string s1, string s2, int n)
{
    string  who = lower_case(s1);
    string  event = lower_case(s2);
    if(!PLAYER_HANDLER->test_user(who)) {
        write("No such player: "+who+".  \n");
        return 1;
    }
    if(PLAYERINFO_HANDLER->delete_entry(this_player(),who,event,n))
        write("Entry #" + n + " of " + capitalize(who) +
            "'s dossier deleted.  \n");
    else
        write("Cannot remove entry #" + n + " from " +
            capitalize(who) + "'s dossier.  \n");
    return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <word'event'> <number'entry-number'>",
        (: delete_event($4[0],$4[1],$4[2]) :)
    });
}

==================================================
FILE: creator/denied.c
==================================================

int db;
int cmd(string who){
  mixed rows;
  string ret;
  db = db_connect("localhost", "errors");
  if(who == "all")
    rows = db_exec(db, "select Reporter, count(*) as bing from errors "
		   "where Status = 'DENIED' "
                   "group by Reporter order by bing desc");
  else
    rows = db_exec(db, sprintf("select Reporter, count(*) from errors "
                               "where Reporter = '%s' and Status = 'DENIED' "
			       "group by Reporter",
                               who));
  if(intp(rows)){
    ret = sprintf("%-15s %s\n", "player", "reports");
    ret += implode(allocate(rows, function(int i){
      mixed *tmp = db_fetch(db, i+1);
      return sprintf("%-15s %s", tmp[0], ""+tmp[1]);
    }), "\n");
    ret += "\n";
    db_close(db);
    this_player()->more_string(ret);
  } else printf(rows);
  return 1;
}

==================================================
FILE: creator/dest_ruct.c
==================================================

#include <creator.h>
inherit "/cmds/base";
void main_dest_bit(object *ob);
void ask_dest(object *obs) {
  if (!pointerp(obs) || !sizeof(obs)) {
    write("No more things to dest.\n");
    return;
  }
  write("Dest object " + WIZ_PRESENT->desc_object(obs[0]) + " ? ");
  input_to("dest_answer", 0, 0, obs);
  return;
}
void dest_answer(string s, int majd, object *obs) {
  string err, shrt;
  if (this_player()->affirmative(s)) {
    if (majd) {
      shrt = (string)obs[0]->short();
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
        write("It REALLY doesn't want to be dested.\n");
        err = catch(destruct(obs[0]));
        this_player()->handle_error(err, "destruct()");
      }
      majd = 0;
      if (obs[0]) write("It didn't dest.\n");
      else {
        say((string)this_player()->query_cap_name()+" disintegrates "+
            (shrt ? shrt : "something") +".\n");
        write("Ok.\n");
      }
      ask_dest(obs[1..]);
      return;
    } else {
      obs[0]->move("/room/rubbish");
      err = catch(obs[0]->dest_me());
      this_player()->handle_error(err, "dest_me");
      if (obs[0]) {
        write("This object does NOT want to be dested.  Are you sure? ");
        input_to("dest_answer", 0, 1, obs);
        return;
      }
      write("Ok.\n");
      ask_dest(obs[1..]);
      return;
    }
  } else if (s == "q" || s == "quit") {
    write("Ok.  No more objects will be destd.\n");
    return;
  }
  write("Ok.  Not destd.\n");
  ask_dest(obs[1..]);
  return;
}
mixed cmd(string str) {
  object *ob, *dest_obj;
  string qstr;
  dest_obj = ({ });
  notify_fail("Can't find " + str + " to dest.\n");
  if ( !str || ( str == "" ) )
    return notify_fail( "Destruct what?\n" );
  if (this_player()->query_name() == "simidh") {
     write("Bye bye...\n");
     this_player()->dest_me();
     return 1;
  }
  if (sscanf(str, "query %s", qstr) == 1) {
    dest_obj = WIZ_PRESENT->wiz_present(qstr, this_player());
    if (!sizeof(dest_obj)) return 0;
    ask_dest(dest_obj);
    return 1;
  }
  ob = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ob)) return 0;
  main_dest_bit(ob);
  return 1;
}
void main_dest_bit(object *ob) {
  object thing, *rest, *dest_obj;
  string err, shrt, dobj;
  rest = ({ });
  dest_obj = ({ });
  foreach (thing in ob) {
    if (interactive(thing) && sizeof(ob) != 1) {
      write("You DON'T destruct " + thing->query_name() + ".\n");
      continue;
    }
    catch(shrt = (string)thing->short());
    dobj = WIZ_PRESENT->desc_object(thing);
    thing->move("/room/rubbish");
    err = catch(thing->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (thing)
      dest_obj += ({ thing });
    else {
      write("You destruct " + dobj + ".\n");
      say((string)this_player()->query_cap_name()+" disintegrates "+
          (shrt ? shrt : "something") + ".\n");
    }
  }
  if (sizeof(dest_obj) > 0) {
    ask_dest(dest_obj);
    return;
  }
  return;
}

==================================================
FILE: creator/dir_s.c
==================================================

inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("dir list");
   if (!stuff) {
      stuff = D_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/dist_ribution.c
==================================================

inherit "/cmds/base";
varargs int cmd(string num) {
  object player, *players;
  int division, i, max, slot;
  mapping stuff;
  division = to_int(num);
  if(!division) {
    division = 50;
  }
  stuff = ([ ]);
  players = users();
  max = 0;
  foreach( player in players )  {
    if ( !player->query_creator() )  {
      slot = player->query_level() / division;
      ++stuff[slot];
      if ( slot > max )  max = slot;
    }
    else players -= ({ player });
  }
  write("%^ORANGE%^Player level distribution:%^RESET%^\n");
  for ( i = 0; i < max; i++ )  {
    if ( stuff[i] )  {
      printf( "%5d ..%4d:\t%3d\t%3d%%\n", division * i, division * (i + 1) - 1,
              stuff[i], stuff[i] * 100  / sizeof( players ) );
    }
  }
  return 1;
}

==================================================
FILE: creator/dump.c
==================================================

inherit "/cmds/base";
#include <creator.h>
int cmd(object *obs) {
   object ob;
   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(0, ob) + "\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:wiz-present>", (: cmd($1) :) });
}

==================================================
FILE: creator/dupd_ate.c
==================================================

inherit "/cmds/base";
#include <creator.h>
string other;
int do_it(string str){
  object ob, *obs;
  string *all, *dil, file, fnob ;
  obs = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(obs))
    return 0;
  foreach(ob in obs){
    fnob = file_name(ob);
    all = inherit_list(ob);
    foreach(file in all){
      if (other){
        dil = deep_inherit_list(find_object(file));
        if (!((member_array(other, dil) != -1) || other == file))
          continue;
      }
      do_it(file);
    }
    ob->dest_me();
    if (ob)
      ob->dwep();
    if (ob)
      destruct(ob);
    ob = load_object(fnob);
    printf("Updated %s.\n", WIZ_PRESENT->desc_f_object(ob));
  }
  return 1;
}
int cmd(string str){
  object *tmp;
  other = 0;
  notify_fail("usage: dupdate <object> [<object>]\n");
  if (!str)
    return 0;
  sscanf(str, "%s %s", str, other);
  if (other){
    tmp = WIZ_PRESENT->wiz_present(other, this_player());
    if (sizeof(tmp)){
      other = file_name(tmp[0]);
      other += ".c";
    }
    else
      return 0;
  }
  return do_it(str);
}

==================================================
FILE: creator/eff_ects.c
==================================================

inherit "/cmds/base";
int cmd( object * obs, int brief ) {
   object who;
   int num, * enums;
   mixed arg;
   if( !obs )
      obs = ({ this_player() });
   foreach( who in obs ) {
      write( "%^BOLD%^Effects on " + who->query_short() + ":%^RESET%^\n" );
      enums = who->effects_matching( "" );
      if( !sizeof( enums ) ) {
         write( "No effects.\n" );
         printf( "%s\n",
           "-----------------------------------------------------------" );
         continue;
      }
      foreach( num in enums ) {
         arg = who->arg_of(num);
         if ( brief && ( arrayp(arg) || classp(arg) || mapp(arg) ) ) {
            arg = "COMPLEX";
         }
         if ( !brief ) {
            printf( "%s\n",
              "-----------------------------------------------------------" );
         }
         printf( "[%d]   %s (%O)\n", num,
           find_object( who->eff_of(num) )->query_classification(),
           arg );
      }
      printf( "%s\n",
        "-----------------------------------------------------------" );
   }
   return 1;
}
mixed * query_patterns() {
   return ({
     "<indirect:wiz-present> verbose", (: cmd( $1, 0 ) :),
     "<indirect:wiz-present> [brief]", (: cmd( $1, 1 ) :),
     "[me] verbose", (: cmd( 0, 0 ) :),
     "[me] [brief]", (: cmd( 0, 1 ) :),
   });
}

==================================================
FILE: creator/errors.c
==================================================

inherit "/cmds/base";
#include <error_handler.h>
#include <db.h>
#include <nroff.h>
#include <player_handler.h>
class user_data {
   class error_query query;
   class error_summary* errors;
   int pos;
   int last_touched;
   string direction;
   string report;
}
private mapping _user_query;
void create() {
   _user_query = ([ ]);
}
int find_index(object person, int id) {
   int i;
   class error_summary* errors;
   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   errors = _user_query[person->query_name()]->errors;
   for (i = 0; i < sizeof(errors); i++) {
      if (id == errors[i]->id) {
         return i;
      }
   }
   return 0;
}
int max_index(object person) {
   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   return sizeof(_user_query[person->query_name()]->errors);
}
int id_at(object person, int index) {
   if (!_user_query[person->query_name()] || index < 0 ||
       index >= sizeof(_user_query[person->query_name()]->errors)) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   return _user_query[person->query_name()]->errors[index]->id;
}
string menu_line(object person) {
   string ret;
   ret = "[" + (_user_query[person->query_name()]->pos + 1) + " of " +
          sizeof(_user_query[person->query_name()]->errors) + "] "
         "STFCOLHA-+PNGQ : ";
   return ret;
}
void finish_details(object person, int verbose,
                    int type, mixed data) {
   string ret;
   class error_details details;
   class error_complete complete;
   class error_comment comment;
   class error_forward forward;
   class error_replies reply;
   class user_data user_data;
   if (type != DB_SUCCESS) {
      tell_object(person, "%^BOLD%^%^RED%^Error: " + data + "%^RESET%^\n");
      return ;
   }
   user_data = _user_query[person->query_name()];
   complete = data[0];
   details = complete->details;
   ret = "%^BOLD%^%^CYAN%^Bug #" + details->summary->id + "%^RESET%^ " +
         details->summary->status + " " + details->summary->type + " " +
         details->summary->category + "\n";
   ret += "%^BOLD%^Date Reported%^RESET%^     : " +
             ctime(details->summary->entry_date) + "\n";
   ret += "%^BOLD%^Assigned To%^RESET%^       : " +
          details->summary->assigned_to + "\n";
   ret += "%^BOLD%^Reporter%^RESET%^          : " + details->summary->reporter + "\n";
   ret += "%^BOLD%^File name%^RESET%^         : " + details->summary->filename + "\n";
   if (verbose) {
      ret += "%^BOLD%^Directory%^RESET%^         : " + details->summary->directory + "\n";
   }
   if (details->summary->status == "FIXED" ||
       details->summary->status == "DENIED") {
      ret += "%^BOLD%^Fixed By%^RESET%^          : " + details->fixer +
             " (" + ctime(details->fix_date) + ")\n";
   }
   if (verbose) {
      if (sizeof(complete->forwards)) {
         ret += "%^BOLD%^Forwards%^RESET%^          :\n";
         foreach (forward in complete->forwards) {
            ret += "$I$5=     " + forward->forwarder + " from " +
                   forward->old_directory + " at " +
                   ctime(forward->date)[4..15] + "\n";
         }
      }
   }
   ret += "$I$0=" + details->report;
   if (verbose) {
      ret += details->runtime;
   } else if (details->runtime && details->runtime != "") {
      ret += "[Runtime Available]\n";
   }
   user_data->report = details->report;
   if (verbose) {
      ret += "$I$3=   ";
      foreach (reply in complete->replies) {
         ret += "%^BOLD%^Date Sent%^RESET%^   : " + ctime(reply->senddate)[4..15] +
                "\n%^BOLD%^From%^RESET%^        : " + reply->sender +
                "\n%^BOLD%^To%^RESET%^          : " + reply->recipient +
                "\n%^BOLD%^Subject%^RESET%^     : " + reply->subject + "<br>" +
                reply->message + "\n";
      }
      if (sizeof(complete->replies) && sizeof(complete->comments)) {
         ret += "$I$0=-------------------------------------------------------------\n$I$3=   ";
      }
      foreach (comment in complete->comments) {
         ret += "%^BOLD%^Comment by " + comment->commenter + " at " +
                ctime(comment->date)[4..15] + "%^RESET%^\n" +
                comment->comment + "\n";
      }
   } else {
      if (sizeof(complete->replies) > 0) {
         ret += sizeof(complete->replies) + " error replies.\n";
      }
      if (sizeof(complete->comments) > 0) {
         ret += sizeof(complete->comments) + " comments.\n";
      }
   }
   person->set_finish_func("finish_more_details", this_object());
   tell_object(person, "$P$Bug #" + details->summary->id + "$P$" + ret);
}
int finish_more_details() {
   object ob;
   ob = this_player();
   write(menu_line(ob));
   input_to("menu_response");
}
int finish_forward(object person, int pos, string new_dir, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Unable to forward bug #" +
                          data->errors[data->pos]->id +
                          " to " + new_dir + " (" + mess + ")");
   } else {
      tell_object(person, "Forwarded bug #" +
                          data->errors[data->pos]->id +
                          " from " + data->errors[data->pos]->directory +
                          " to " + new_dir);
      data->errors[data->pos]->directory = new_dir;
   }
}
void finish_change_status(object person, string status, int command,
                          string subject, int no_reply, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Database error: " + mess);
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }
   tell_object(person, "Updated status of bug #" + data->errors[data->pos]->id +
               " to " + status + (no_reply ?  " (no reply) " : "") +"\n");
   if (!command) {
      data = _user_query[person->query_name()];
      tell_object(person, menu_line(person));
      data->errors[data->pos]->status = status;
   }
}
void finish_status_message(object person, string status, int command,
                           string subject, string mess) {
   class user_data data;
   int pos;
   data = _user_query[person->query_name()];
   if (!mess) {
      tell_object(person, "Message aborted.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }
   if (status == "THANKS" || status == "TEMPORARY") {
      status = "FIXED";
   }
   if (status == "NOTREPRODUCIBLE" || status == "NOINFO" ||
       status == "NOTPOSSIBLE") {
      status = "DENIED";
   }
   pos = strsrch("$report$", mess);
   if (pos == -1) {
      mess += "\n\n" + data->report;
   } else {
      mess = replace_string(mess, "$report$", data->report);
   }
   if (!command) {
      input_to("menu_response");
   }
   if (!ERROR_HANDLER->do_change_status(data->errors[data->pos]->id,
                        status, subject == 0, subject, person->query_name(),
                        mess,
                        (: finish_change_status, person, status, command,
                                          subject, subject == 0 :))) {
      tell_object(person, "Unhappily an error occured.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
   }
}
string query_subject_from_type(string type, class error_summary error) {
   switch (type) {
   case "THANKS" :
      return "Thanks for " + error->category + " " + error->type;
   case "NOTPOSSIBLE" :
      return "Not possible to fix " + error->category + " " + error->type;
   case "NOTREPRODUCIBLE" :
      return "Not able to reproduce " + error->category + " " + error->type;
   case "FIXED" :
      return "Fixed bug #" + error->id;
   case "DENIED" :
      return "Denied bug #" + error->id;
   default :
      return "Change status of bug #" + error->id + " to " +
             type;
   }
}
string query_message_from_type(object person, string type,
                               class error_summary error) {
   switch (upper_case(type)) {
   case "THANKS" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "TEMPORARY" :
      return "Your " + lower_case(error->type) +
             " report was a temporary problem in the system and has "
             "since been resolved.  Thanks for reporting it."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTENOUGHINFORMATION" :
      return "Your " + lower_case(error->type) +
             " report did not contain enough information for this " +
             lower_case(error->type) + " to be resolved.  Please report "
             "again with more detailed information."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTREPRODUCIBLE" :
      return "Unable to reproduce your " + lower_case(error->type) +
             " report.  If you can track down exactly the circumstances "
             "which generate this error, please report it again."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTPOSSIBLE" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is not possible to fix, because of code restrictions."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXED" :
   case "DENIED" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " has now been " + lower_case(type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being fixed.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CONSIDERING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being considered for future fixing.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CUSTOM" :
      return "custom";
   case "NONE" :
      return "none";
   case "OPEN" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   }
}
void finish_change_type(object person, string new_type, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new type of " + new_type + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_type;
}
void finish_change_category(object person, string new_category, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new category of " + new_category + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_category;
}
void finish_assign_bug(object person, string assigner, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " is assigned to " + assigner + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->assigned_to = assigner;
}
void finish_adding_comment(object person, int type, mixed mess) {
   if (type != DB_SUCCESS) {
      tell_object(person, "SQL Error: " + mess);
      tell_object(person, menu_line(person));
   }
   tell_object(person, "Added a comment to the bug.\n");
   tell_object(person, menu_line(person));
}
void finish_comment(object person, int id, string comment) {
   if (!comment) {
      write("Aborted adding the comment.\n");
      write(menu_line(person));
      input_to("menu_response");
      return ;
   }
   input_to("menu_response");
   if (!ERROR_HANDLER->do_comment(id, person->query_name(), comment,
                             (: finish_adding_comment, person :))) {
      write("Big bad error.\n");
      write(menu_line(person));
   }
}
int do_bug_details(object person, int id, int verbose) {
   if (!ERROR_HANDLER->do_query_bug_details(id, (: finish_details, person,
                                                   verbose :))) {
      tell_object(person, "Error doing stuff.");
   }
   return 1;
}
int do_forward(object person, string new_dir) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_forward(data->errors[data->pos]->id,
                person->query_name(), new_dir,
                    (: finish_forward, person, data->pos, new_dir :))) {
      write("A horrible error occured.\n");
      return 0;
   }
   return 1;
}
int do_change_status(object person, string status, int command, string subject,
                     string mess) {
   if (mess == "custom") {
      tell_object(person, "User $report$ to place the error report in the "
                  "mail.  If $report$ is not included, the report will be "
                  "added onto the end.\n");
      person->do_edit("", (: finish_status_message, person, status, command,
                                                    subject :));
   } else if (mess == "none") {
      finish_status_message(person, status, command, 0, "");
   } else {
      finish_status_message(person, status, command, subject, mess);
   }
}
int do_change_type(object person, string type) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_type(data->errors[data->pos]->id, type,
       (: finish_change_type, person, type :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_change_category(object person, string category) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_category(data->errors[data->pos]->id, category,
       (: finish_change_category, person, category :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_assign_bug(object person, string assigner) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_assign_bug_to(data->errors[data->pos]->id, assigner,
       (: finish_assign_bug, person, assigner :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_comment(object person) {
   class user_data data;
   data = _user_query[person->query_name()];
   this_player()->do_edit("", (: finish_comment, person,
                                   data->errors[data->pos]->id :));
}
int do_help(object player) {
   string str;
   str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   if (!str) {
      NROFF_HAND->create_nroff("/doc/creator/commands/errors", "/doc/creatornr/errors");
      str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   }
   player->set_finish_func("finish_more_details", this_object());
   tell_object(player, "$P$Error help$P$" + str);
}
int do_list_errors() {
   class user_data data;
   class error_summary error;
   string str;
   int i;
   data = _user_query[this_player()->query_name()];
   str = "";
   i = 1;
   str += sprintf("ndx: #<num> %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                  "Status", "Cat", "Type", "Reporter", "Filename", "Directory");
   foreach (error in data->errors) {
      str += sprintf("$I$3=%3d: #%d %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                     i++, error->id, error->status[0..4], error->category[0..3],
                     error->type, error->reporter, error->filename[<15..],
                     error->directory[<15..]);
   }
   this_player()->set_finish_func("finish_more_details", this_object());
   write("$P$Error list$P$" + str);
}
int show_current_bug(object player, int verbose) {
   class user_data data;
   data = _user_query[player->query_name()];
   if (verbose == -1) {
      verbose = player->query_verbose("errors");
   }
   return do_bug_details(player, data->errors[data->pos]->id, verbose);
}
string expand_short_type(string name) {
   string str;
   str = upper_case(name);
   switch (str) {
   case "F" :
      return ERROR_STATUS_FIXED;
   case "D" :
      return ERROR_STATUS_DENIED;
   case "I" :
      return ERROR_STATUS_FIXING;
   case "C" :
      return ERROR_STATUS_CONSIDERING;
   case "O" :
      return ERROR_STATUS_OPEN;
   case "U" :
      return "CUSTOM";
   case "R" :
      return "NOTREPRODUCIBLE";
   case "R" :
      return "NOTPOSSIBLE";
   case "N" :
      return "NONE";
   case "T" :
      return "THANKS";
   case "M" :
      return "NOTENOUGHINFORMATION";
   case "E" :
      return "TEMPORARY";
   default :
      return str;
   }
}
void finish_change_status_command(object player, int id, string status,
                        string messtype, int type, mixed data) {
   string mess;
   string subject;
   class error_summary error;
   if (type != DB_SUCCESS) {
      tell_object(player, "SQL error: " + data + "\n");
      return ;
   }
   if (!sizeof(data)) {
      tell_object(player, "No bug found with an id of #" + id + "\n");
      return ;
   }
   error = data[0];
   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;
   status = expand_short_type(status);
   if (messtype) {
      messtype = expand_short_type(messtype);
      mess = query_message_from_type(player, messtype, error);
      subject = query_subject_from_type(messtype, error);
      if (!mess) {
         tell_object(player, "The reply type " + messtype + " was not valid.\n");
      } else {
         if (member_array(status, ERROR_TYPE) != -1) {
            tell_object(player, "The error type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
         } else {
            do_change_status(player, status, 1, subject, mess);
            return ;
         }
      }
   } else {
      mess = query_message_from_type(player, status, error);
      subject = query_subject_from_type(status, error);
      if (mess) {
         do_change_status(player, status, 1, subject, mess);
         return ;
      }
   }
   tell_object(player, "Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
   tell_object(player, "The default message is based on the type it is changed to.\n");
   tell_object(player, "The type has some short forms: o -> open, f -> fixed, d ->denied\n");
   tell_object(player, "   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
   tell_object(player, "   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
   tell_object(player, "   t ->temporary.\n");
}
void menu_response(string str) {
   string* bits;
   class user_data data;
   int print_menu_line;
   class error_summary error;
   string mess;
   string subject;
   int id;
   bits = explode(str, " ");
   if (!sizeof(bits)) {
      bits = ({ "n" });
   }
   data = _user_query[this_player()->query_name()];
   switch(lower_case(bits[0])) {
   case "v" :
      if (sizeof(bits) > 1) {
         show_current_bug(this_player(), bits[1] == "verbose");
      } else {
         show_current_bug(this_player(), -1);
      }
      break;
   case "+" :
   case "n" :
      if (data->pos < sizeof(data->errors) - 1) {
         data->pos++;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No next bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "-" :
   case "p" :
      if (data->pos > 0) {
         data->pos--;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No previous bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "f" :
      if (sizeof(bits) == 2) {
         if (do_forward(this_player(), bits[1])) {
            input_to("menu_response");
         } else {
            print_menu_line = 1;
         }
      } else {
         write("Need to specify the destination directory (and nothing else)\n");
         print_menu_line = 1;
      }
      break;
   case "s" :
      if (sizeof(bits) > 1) {
         bits[1] = expand_short_type(bits[1]);
         error = data->errors[data->pos];
         if (sizeof(bits) > 2) {
            bits[2] = expand_short_type(bits[2]);
            mess = query_message_from_type(this_player(), bits[2], error);
            subject = query_subject_from_type(bits[1], error);
            if (!mess) {
               write("The reply type " + bits[2] + " was not valid.\n");
               print_menu_line = 1;
            } else {
               if (member_array(bits[1], ERROR_TYPE) != -1) {
                  write("The error type must be one of " +
                        query_multiple_short(ERROR_TYPE) + ".\n");
                  print_menu_line = 1;
               } else {
                  do_change_status(this_player(), bits[1], 0, subject, mess);
                  input_to("menu_response");
               }
            }
         } else {
            mess = query_message_from_type(this_player(), bits[1], error);
            subject = query_subject_from_type(bits[1], error);
            if (mess) {
               do_change_status(this_player(), bits[1], 0, subject, mess);
               input_to("menu_response");
            }
         }
         if (!mess) {
            write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
            write("The default message is based on the type it is changed to.\n");
            write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
            write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
            write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
            write("   t ->temporary.\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
         write("The default message is based on the type it is changed to.\n");
         write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
         write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
         write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
         write("   t ->temporary.\n");
         print_menu_line = 1;
      }
      break;
   case "t" :
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_TYPE) != -1) {
            do_change_type(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {TYPO|BUG|IDEA}\n");
         print_menu_line = 1;
      }
      break;
   case "o" :
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_CATEGORIES) != -1) {
            do_change_category(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_CATEGORIES) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {ROOM|OBJECT|COMMAND|HELP|RITUAL|SPELL|GENERAL}\n");
         print_menu_line = 1;
      }
      break;
   case "g" :
      if (sizeof(bits) > 0) {
         id = to_int(bits[1]);
         if (id <= sizeof(data->errors)) {
            data->pos = id - 1;
            show_current_bug(this_player(), -1);
         } else {
            id = find_index(this_player(), id);
            if (id == -1) {
               write("Unable to find the bug #" + id + "\n");
               print_menu_line = 1;
            }
         }
      } else {
         write("Syntax: g <num>\nNum can either be the index number or the "
               "bug id.\n");
         print_menu_line = 1;
      }
      break;
   case "c" :
      do_comment(this_player());
      break;
   case "i" :
   case "l" :
      do_list_errors();
      break;
   case "q" :
      write("Bye bye.\n");
      return ;
   case "a" :
      if (sizeof(bits) > 1) {
         if (!PLAYER_HANDLER->test_creator(bits[1])) {
            write("You can only assign a bug to a creator.\n");
            print_menu_line = 1;
         } else {
            do_assign_bug(this_player(), bits[1]);
            input_to("menu_response");
         }
      } else {
         write("You need to specify someone to assign the error to.\n");
         print_menu_line = 1;
      }
      break;
   case "h" :
      do_help(this_player());
      break;
   default :
      write("Bad command.\n");
      print_menu_line = 1;
      break;
   }
   if (print_menu_line) {
      write(menu_line(this_player()));
      input_to("menu_response");
   }
}
void finish_query(object player, int type, mixed data) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error: " + data + "\n");
      return ;
   }
   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;
   if (!sizeof(data)) {
      tell_object(player, "No bugs with that query.\n");
      return ;
   }
   show_current_bug(player, -1);
}
int setup_query(object player, class error_query query) {
   if (!ERROR_HANDLER->do_query_bug_summary(query, (: finish_query, player :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   return 1;
}
int errors_change_status(int id, string status, string messtype) {
   class error_query query;
   query = new (class error_query);
   query->id = id;
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                     (: finish_change_status_command, this_player(), id, status,
                        messtype :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   write("Looking up bug #" + id + " to fix.\n");
   return 1;
}
int errors_this_dir(int recursive) {
   class error_query query;
   query = new (class error_query);
   query->dir = this_player()->query_path();
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_by_person(string person) {
   class error_query query;
   query = new (class error_query);
   query->reporter = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_assigned_to_person(string person) {
   class error_query query;
   query = new (class error_query);
   query->assigned_to = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_assigned_to_me() {
   return errors_assigned_to_person(this_player()->query_name());
}
int errors_in_dir(string str, int recursive) {
   class error_query query;
   string path;
   path = this_player()->get_path(str);
   query = new (class error_query);
   query->dir = path;
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_with_id(int id) {
   class error_query query;
   query = new (class error_query);
   query->id = id;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_for_file(string file) {
   class error_query query;
   query = new (class error_query);
   query->file_name = file;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_in_this_room() {
   class error_query query;
   query = new (class error_query);
   query->file_name = file_name(environment(this_player()));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
mixed* query_patterns() {
   return ({ "", (: errors_this_dir(0) :),
             "status <number'bug id'> <word'status'>",
                   (: errors_change_status($4[0], $4[1], 0) :),
             "status <number'bug id'> <word'status'> <word'reply'>",
                   (: errors_change_status($4[0], $4[1], $4[2]) :),
             "recursive", (: errors_this_dir(1) :),
             "mine", (: errors_assigned_to_me :),
             "here", (: errors_in_this_room :),
             "assigned <string'person'>", (: errors_assigned_to_person($4[0]) :),
             "by <string'person'>", (: errors_by_person($4[0]) :),
             "id <number'bug id'>", (: errors_with_id($4[0]) :),
             "file <string'file'>", (: errors_for_file($4[0]) :),
             "dir <string'dir'>", (: errors_in_dir($4[0], 0) :),
             "dir recursive <string'dir'>", (: errors_in_dir($4[0], 1) :) });
}

==================================================
FILE: creator/family.c
==================================================

#include <clubs.h>
#include <money.h>
inherit "/cmds/base";
inherit "/std/basic/club_listing";
#include <player_handler.h>
#include <playerinfo.h>
mixed family_reverse(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string opp;
  string relation;
  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }
  foreach (relation in relations_from) {
    opp = CLUB_HANDLER->query_opposite_relationship(relation);
    if (!opp) {
      write("Unable to swap " + relation + ".\n");
    } else {
      if (!CLUB_HANDLER->remove_relationship(family_from,
                                             from,
                                             family_to,
                                             to,
                                             relation)) {
        write("Could not remove relationship " + relation + " between " +
              from + " and " + to + ".\n");
      } else {
        CLUB_HANDLER->add_relationship(family_from,
                                       from,
                                       family_to,
                                       to,
                                       opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      from,
                                      "family",
                                      "Changed relationship with " + to + " to " +
                                      opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      to,
                                      "family",
                                      "Changed relationship with " + from + " to " +
                                      relation);
        write("Swapped relationship " + relation + " between " +
              from + " and " + to + ".\n");
      }
    }
  }
  return 1;
}
int family_remove(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string relation;
  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }
  foreach (relation in relations_from) {
    if (!CLUB_HANDLER->remove_relationship(family_from,
                                           from,
                                           family_to,
                                           to,
                                           relation)) {
      write("Could not remove relationship " + relation + " between " +
            from + " and " + to + ".\n");
    } else {
      write("Removed relationship " + relation + " between " +
            from + " and " + to + ".\n");
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    from,
                                    "family",
                                    "Removed relationship with " + to);
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    to,
                                    "family",
                                    "Removed relationship with " + from);
    }
  }
  return 1;
}
private int do_balance(string club_name) {
   int balance;
   string place;
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("There is no family called '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   }
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   balance = CLUB_HANDLER->query_balance(club_name);
   write("The balance of the family '" +
         CLUB_HANDLER->query_club_name(club_name) + "' is " +
         MONEY_HAND->money_value_string(balance, place) + ".\n");
   return 1;
}
private int do_all_balance() {
   string *clubs;
   string club;
   string place;
   mapping bing;
   string ret;
   clubs = CLUB_HANDLER->query_clubs();
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   bing = ([ ]);
   foreach (club in clubs) {
      if (!CLUB_HANDLER->is_family(club)) {
         continue;
      }
      bing[club] = CLUB_HANDLER->query_balance(club);
   }
   clubs = keys(bing);
   clubs = sort_array(clubs, (: $3[$1] - $3[$2] :), bing);
   ret = "";
   foreach (club in clubs) {
      ret += sprintf("Family '%-20s': %s\n",
            CLUB_HANDLER->query_club_name(club),
            MONEY_HAND->money_value_string(bing[club], place));
   }
   write("$P$Club Balances$P$" + ret);
   return 1;
}
mixed *query_patterns() {
  return ({ "info <word'family name'>",
              (: family_info($4[0], this_player()->query_name()) :),
            "reverse relationship <word'player name'> <word'player name'>",
              (: family_reverse($4[0], $4[1]) :),
            "remove relationship <word'player name'> <word'player name'>",
              (: family_remove($4[0], $4[1]) :),
            "balance <string'family name'>", (: do_balance($4[0]) :),
            "balance all", (: do_all_balance() :) });
}

==================================================
FILE: creator/fds.c
==================================================

inherit "/cmds/base";
mixed cmd(string) {
  this_player()->more_string(dump_file_descriptors());
  return 1;
}

==================================================
FILE: creator/fetch.c
==================================================

#include <move_failures.h>
#include <playerinfo.h>
#define BROKEN_ROOM "/room/broken"
inherit "/cmds/base";
int cmd( mixed *indirect_obs ) {
    object *broken_items, *failed, *success;
    object player;
    if ( sizeof( indirect_obs ) != 2 ) {
        return 0;
    }
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You cannot $V an object for more than one "
            "player at once.\n" );
        return 0;
    }
    player = indirect_obs[ 1 ][ 0 ];
    broken_items = indirect_obs[ 0 ];
    failed = filter( broken_items,
        (: $1->move( $(player), "$N appear$s in your inventory." ) != MOVE_OK :) );
    success = broken_items - failed;
    if ( sizeof( failed ) ) {
        tell_object( this_player(), "Warning-- could not move " +
            query_multiple_short( failed ) + " to " +
            player->the_short() + ".\n" );
    }
    if ( sizeof( success ) ) {
        PLAYERINFO_HANDLER->add_entry(
            this_player(), player->query_name(), "replace",
            "Fetched " + implode( success->short(), "," ) + " from /room/broken.");
        add_succeeded_mess( "$N $V $I for " + player->the_short() + " from "
            "the broken room.\n", success );
        return 1;
    }
    add_failed_mess( "No objects could be retrieved for $I.\n",
        ({ player }) );
    return -1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:" + BROKEN_ROOM + "> [for] <indirect:player>",
        (: cmd($1) :) });
}

==================================================
FILE: creator/findc_orpse.c
==================================================

inherit "/cmds/base";
int cmd( string arg ) {
   object *cs, c;
   string r;
   r = "player corpse objects\n";
   cs = filter( children( "/obj/corpse" ), (: $1 && $1->query_property(
      "player" ) :) );
   if( !arg ) {
      foreach( c in cs ) r += file_name( c ) + " - " + c->query_owner() +
         " - " + ( environment( c ) ? file_name( environment( c ) ) :
         "In void" ) + "\n";
      tell_object( this_player(), r );
      tell_object( this_player(), sizeof( cs ) + " player corpses.\n" );
   } else {
      cs = filter( cs, (: $1 && $1->query_ownership() == $( arg ) :) );
      if( sizeof( cs ) ) {
         r = "Corpse objects of " + arg + ": \n";
         foreach( c in cs ) r += file_name( c ) + " in " + (
         environment( c ) ? file_name( environment( c ) ) : "void" ) + "\n";
         tell_object( this_player(), r );
      } else {
         tell_object( this_player(), arg + " has no corpses loaded.\n" );
      }
   }
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/findr_edef.c
==================================================

string *find_stuff(object ob, string varname){
  string *variables = variables(ob);
  string *ret = ({});
  if(member_array(varname, variables) > -1){
    object *inhobs = map(inherit_list(ob), (:find_object:));
    object obj;
    foreach(obj in inhobs){
      ret += find_stuff(obj, varname);
    }
    if(ret == ({})){
      ret = ({file_name(ob)});
    }
  }
  return ret;
}
int cmd(object ob, string var){
  string *files = find_stuff(ob, var);
  if(sizeof(files) > 1)
    printf("%s is defined in %s and %s.\n", var, implode(files[0..<2], ", "),
           files[<1]);
  else
    write("No redefinition found.\n");
  return 1;
}
string *query_patterns(){
  return ({"<indirect:wiz-present> <word'global'>", (:cmd($1[0], $4[1]):)});
}

==================================================
FILE: creator/fixed.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Fixer"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer is not NULL and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   } else {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer = '" + who +
                            "' and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/forwards.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Forwarder"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder is not NULL "
                   "group by Forwarder order by bing desc";
   } else {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder = '" + who + "' "
                   "group by Forwarder order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/fry.c
==================================================

#include <playerinfo.h>
#define LIGHTNING "%^WHITE%^BOLD%^lightning%^RESET%^"
#define THUNDER "%^RED%^BOLD%^thunder%^RESET%^"
inherit "/cmds/base";
mapping banned = ([
    "macchirton"    :   "it's tradition.",
    "que"           :   "you're an arse.",
    ]);
mixed cmd(string words) {
  string player, reason;
  object ob;
    add_failed_mess("At Pinkfish's request this command has been disabled.\n" );
    return 0;
  if(member_array (this_player()->query_name(), keys(banned)) != -1)
  {
    return notify_fail("You cannot use 'fry', because " +
        banned[this_player()->query_name()] + "\n");
  }
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: fry <player> <reason>\n");
  }
  if (!"/secure/master"->query_senior(this_player()->query_name()))
  {
    return notify_fail ("Only Senior Creators and above may smite players "
        "with Righteous Vengeance!\n");
  }
  ob = find_player(this_player()->expand_nickname(player));
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y/n): ");
  input_to("are_sure", ob, reason);
  return 1;
}
void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("There's a good "+gender+"!  Now you go play nice with little "
        + ob->one_short() + "!\n");
    return;
  }
  write("Would you like the whole Disc to be aware of the reason "
    "for your ire? (y/n): ");
  input_to("positive", ob, reason);
}
void positive (string str, object ob, string reason) {
  str = lower_case(str);
  if(str[0] != 'y') {
    write ("Okay, we'll keep it between you and me.\n");
    call_out("fry2", 5+random (3), ob);
  }
  else
  {
    write ("Bwah-ha-ha-ha!\n");
    call_out("fry2", 5+random (3), ob, reason);
  }
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("SMITE", "%s: %s smote %s: %s\n", ctime(time()),
    this_player()->query_short(), ob->query_short(), reason);
  shout("The sky grows dark.  Thick black clouds roll in.\n");
  shout("A loud peal of " + THUNDER + " rumbles, shaking the ground, "
    "and bolts of " + LIGHTNING + " flash through the sky!\n");
  write("Smiting "+capitalize (ob->query_name()) +" with Righteous Vengeance!\n");
}
varargs void fry2(object ob, string reason) {
    string *shout_mess = ({
        "A bolt of ferocious " + LIGHTNING + " rips the sky in two!  ",
        "A peal of deafening " + THUNDER + " rumbles o'er the land!  ",
        "The clouds gather, spitting forth bolts of vicious " + LIGHTNING +
            " from their folds!  ",
        "The clouds gather into great dark masses, spitting " + LIGHTNING +
            " at the cowering Disc below!  "
        });
    string *player_mess = ({
        "A bolt of shimmering " + LIGHTNING + " spears the ground in front "
            "of you!\n",
        "A bolt of " + LIGHTNING + " pierces the air above you, melting "
            "your eyebrows.\n",
        "A bolt of " + LIGHTNING + " flares before your face, causing "
            "little blobs of light to dance over your retinas.\n"
            });
    shout (shout_mess[random(sizeof(shout_mess))] + "It appears one "
        "of the " + mud_name() + "'s creators is unhappy...\n");
    tell_object(ob, player_mess[random(sizeof(player_mess))]);
    call_out("fry3", 8 + random (10), ob, reason);
}
varargs void fry3(object ob, string reason)
{
    string name;
    string *TMs = ({
        "You feel more able to spear players with bolts of lightning!\n",
        "You feel more confident about your aim when trying to hit small "
            "scurrying figures from Cori Celesti!\n",
        "You manage to grasp one of the principles of creator justice "
            "more firmly!\n",
        });
    string *shout_mess = ({
        "Another spear of " + LIGHTNING + " lances through the clouds, "
            "followed closely by a deafening peal of " + THUNDER + "!\n",
        "A deafening roll of " + THUNDER + " followed by a bolt of brilliant "
        + LIGHTNING + " rolls over the " + mud_list() + ".\n",
        "The clouds spit out another violent bolt of " + LIGHTNING + " as "
        + THUNDER + " shatters the relative peace of the " + mud_list() + ".\n"
        });
    string *player_mess = ({
        "A bolt of " + LIGHTNING + " strikes you and sends you into the "
            "%^RED%^oblivion%^RESET%^ of the real world!\n",
        "A bolt of " + LIGHTNING + " pierces the skies and strikes you!  "
        "%^RED%^Zzzzzot!%^RESET%^\n",
        "A bolt of " + LIGHTNING + " spears down from the sky and %^RED%^"
            "smites%^RESET%^ you!\n",
        });
  if (random (100) > 80)
  {
        tell_object (this_player(), "The " + LIGHTNING + " blasts " + ob->short() +
            " into oblivion!\n");
        tell_object (this_player(), "%^YELLOW%^%^BOLD%^" + TMs[random(sizeof(TMs))]
            + "%^RESET%^");
        this_player()->add_skill_level ("fighting.combat.range.thrown", 1);
  }
  shout(shout_mess[random(sizeof(shout_mess))]);
  if (this_player()->query_invis())
  {
        name = "Someone";
  }
  else
  {
        name = this_player()->short();
  }
  if (reason)
  {
      shout(name + " shouts from the clouds:  This is " + reason +
      ", " + ob->short() +"!\n");
  }
  else
  {
      shout(name + " cackles in the distance.\n");
  }
  tell_object(ob, player_mess[random(sizeof(player_mess))]);
  ob->save();
  ob->quit();
  shout(ob->query_cap_name()+" was smote by " + name + "'s "
    "lightning.\n"+ capitalize(ob->query_pronoun())+" is no more.\n");
  shout ("The clouds roll back across the sky.");
}

==================================================
FILE: creator/ftpwho.c
==================================================

inherit "/cmds/base";
#define FTPD "/secure/ftpd"
#define UNIX_FTPD "/secure/ftp_auth"
mixed cmd(string) {
  mixed *who_unix, *who;
  int i;
  if(!find_object(FTPD)) {
    write("MUD FTP is currently disabled.\n");
  } else {
    who = FTPD->query_connections();
    if ((i = sizeof(who))) {
      write("People currently using MUD FTP :\n");
      while (i--)
        write(" - "+who[i]+"\n");
    } else {
      write("No one is using MUD FTP at the moment.\n");
    }
  }
  who_unix = UNIX_FTPD->query_connections();
  if ((i = sizeof(who_unix))) {
    write("People currently using UNIX FTP :\n");
    while (i--)
      write(" - "+who_unix[i]+"\n");
  } else {
    write("No one is using UNIX FTP at the moment.\n");
  }
  return 1;
}

==================================================
FILE: creator/gag.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
int cmd( object victim, string reason, int number ) {
   victim->add_property( "gagged", reason, 60 * number );
   log_file( "GAG", ctime(time()) +": "+ this_player()->query_short()
             + " gagged " + victim->query_short() + " for " + number
             + " minutes.  Reason: " + reason +".\n");
   PLAYERINFO_HANDLER->add_entry( this_player(), victim->query_name(),
             "gag", "Gagged for " + number + " minutes.  Reason: '" + reason +
             "'.\n");
   tell_object( victim,
         "%^RED%^%^BOLD%^You have been gagged by " +
         this_player()->query_short() + " for the reason: '" + reason +
         "'.\nYou will not be able to shout, chat or use the newbie "
         "channel until the gag is removed.%^RESET%^\n" );
   write( "Okay, gagged " + victim->query_short() + " for " + number +
          " minutes.  Now please discuss your reason for gagging with "
          "them.  IMPORTANT! You should only be gagging for deliberately "
          "offensive language.\n" );
   event( users(), "inform", this_player()->query_short()
          + " gagged " + victim->query_short() + " for: " + reason, "gag");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player'player'> <string'reason'>",
                (: cmd( $1[0], $4[1], 15 ) :),
             "<indirect:player'player'> <string'reason'> <number'minutes'>",
                (: cmd( $1[0], $4[1], $4[2] ) :) });
}

==================================================
FILE: creator/gna_.c
==================================================

inherit "/cmds/base";
protected int cmd( string pattern, object *obs ) {
    string gn;
    object ob;
    string verb = query_verb();
    if ( sizeof( explode( verb, "" ) - ({ "g", "n", "a", "h" }) ) ) {
        return 0;
    }
    gn = "gn" + implode( allocate( sizeof( pattern ) - 2, "a" ), "" ) + "h!";
    if ( arrayp( obs ) ) {
        obs = filter( obs, (: !$1->check_earmuffs( "remote-soul" ) :) );
        obs -= ({ this_player() });
         if ( sizeof( obs ) ) {
            tell_object( this_player(), "You go '$C$" + gn + "' at " +
                query_multiple_short( obs ) + ".\n" );
            foreach (ob in obs) {
                tell_object(ob, this_player()->the_short() + " goes '$C$" +
                    gn + "' at you.\n" );
            }
            return 1;
        }
    }
    write( capitalize( gn ) + "\n" );
    return 1;
}
mixed *query_patterns() {
    mixed *pat = ({ "", (: cmd($6, 0) :) });
    if ( previous_object(1)->query_lord() ) {
        pat += ({ " <indirect:wiz-present>", (: cmd($6, $1) :) });
    }
    else {
        pat += ({ " <indirect:any-living>", (: cmd($6, $1) :),
                  " <indirect:object>", (: cmd($6, $1) :) });
    }
    return pat;
}

==================================================
FILE: creator/go_to.c
==================================================

mixed cmd(string str) {
  object dest;
  string *names, nick;
  string tname;
  if (!str)
    return notify_fail("Teleport where?\n");
  nick = (string)this_player()->expand_nickname(str);
  dest = find_living(nick);
  if (!dest && objectp(this_player()->get_obvar(str))) {
    dest = this_player()->get_obvar(str);
    if (dest == environment(this_player()))
      return notify_fail("You look around and realise you are already there.\n");
    this_player()->set_last_location(base_name(environment(this_player())));
    this_player()->move_with_look( dest,
                                   (string)this_player()->query_mmsgin(),
                                   (string)this_player()->query_mmsgout() );
    return 1;
  }
  if (dest) {
    if(dest = environment(dest)) {
      if (dest == environment(this_player()))
        return notify_fail("You look around and realise you are already "
                           "there.\n");
      this_player()->set_last_location(base_name(environment(this_player())));
      this_player()->move_with_look( dest,
            (string)this_player()->query_mmsgin(),
            (string)this_player()->query_mmsgout() );
      return 1;
    } else
      return notify_fail(capitalize(nick) + " is not standing in a location.\n");
  } else {
    names = (string *)this_player()->get_cfiles(str);
    if(sizeof(names)) {
      str = names[0];
    } else {
      if (strsrch(str, ":") == -1) {
         return notify_fail("No such room.\n");
      }
      if (str[0] != '/') {
         str = this_player()->query_current_path() + "/" + str;
      }
    }
    dest = load_object(str);
    if (!dest) {
      return notify_fail("Failed to load " + str + "\n");
    } else if(!dest->query_property("location")) {
      return notify_fail("Not a room: " + str + "\n");
    } else {
      if (dest == environment(this_player())) {
        notify_fail("You look around and realise you are already there.\n");
        return 0;
      }
      if (environment(this_player())) {
         tname = environment(this_player())->query_property("terrain name");
         if (tname) {
           this_player()->set_last_location(
             ({ tname, environment(this_player())->query_co_ord() })
             );
         } else {
           this_player()->set_last_location(
             base_name(environment(this_player()))
             );
         }
      }
      this_player()->move_with_look( dest,
                                     (string)this_player()->query_mmsgin(),
                                     (string)this_player()->query_mmsgout() );
      return 1;
    }
  }
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/gob_ack.c
==================================================

#include <terrain.h>
mixed cmd(string str) {
  mixed dest;
  string tname;
  dest = this_player()->query_last_location();
  if(!dest)
    return notify_fail("No stored location.\n");
  if (stringp(dest)) {
    dest = load_object(dest);
  } else if (arrayp(dest) && stringp(dest[0]) && arrayp(dest[1])) {
    dest = TERRAIN_MAP->find_location(dest[0], dest[1]);
  } else {
    return notify_fail("I don't understand your stored location.\n");
  }
  tname = environment(this_player())->query_property("terrain name");
  if (tname) {
    this_player()->set_last_location(
      ({ tname, environment(this_player())->query_co_ord() })
      );
  } else {
    this_player()->set_last_location(
      base_name(environment(this_player()))
      );
  }
  this_player()->move_with_look( dest,
                                 this_player()->query_mmsgin(),
                                 this_player()->query_mmsgout() );
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/guildl_ist.c
==================================================

inherit "/cmds/base";
int cmd(string arg) {
  object ob;
  mapping guilds;
  string guild, *fields;
  guilds = ([ ]);
  foreach(ob in users()) {
    if(ob->query_creator())
      continue;
    if(!ob->query_guild_ob()) {
      guilds["none"]++;
    } else {
      fields = explode((string)ob->query_guild_ob(), "/");
      guilds[fields[2]]++;
    }
  }
  write("Guild memberships:\n");
  foreach(guild in keys(guilds))
    printf("  %s: %d\n", guild, guilds[guild]);
  return 1;
}

==================================================
FILE: creator/hcode.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("code");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the code channel.\n");
   }
   write("The code channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/hcre.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("cre");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the cre channel.\n");
   }
   write("The creator channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/he_ad.c
==================================================

mixed cmd(string str) {
  int i;
  string *files;
  seteuid(geteuid(this_player()));
  if (!str)
    return notify_fail("Usage: head <file>\n");
  files = this_player()->get_files(str);
  if (!sizeof(files))
    return notify_fail("File does not exist.\n");
  str = files[0];
  i = file_length(str);
  if (i < 0) {
    printf("File not found.\n");
    return 1;
  }
  if (i > 20) i=20;
  write(read_file(str,1,i));
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/hliaison.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("liaison");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the liaison channel.\n");
   }
   write("The liaison channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/ho_me.c
==================================================

mixed cmd(string str) {
  write("Usage : alias home goto <wherever> :)\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/host.c
==================================================

inherit "/cmds/base";
mapping lookups = ([]);
int cmd( string w ) {
    string ip = lower_case( this_player()->expand_nickname( w ) );
    string ip2;
    if ( find_player( ip ) ) {
        ip2 = query_ip_number( find_player( ip ) );
        lookups[ resolve( ip2, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip +
                     " (" + ip2 + ").\n" );
    } else {
        lookups[ resolve( ip, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip + ".\n" );
    }
    return 1;
}
void lookup_callback( string address, string resolved, int key ) {
    if ( lookups[ key ] ) {
        tell_object( lookups[ key ], "Resolved " +
                     ( address ? address : "?unknown" ) +
                     " to " +
                     ( resolved ? resolved : "?unknown" ) + ".\n" );
    }
    map_delete( lookups, key );
}
mixed *query_patterns() {
   return ({ "<string'ip-address, host or player'>",
                 (: cmd( $4[0] ) :) });
}

==================================================
FILE: creator/hours.c
==================================================

inherit "/cmds/base";
int cmd( int time, string all) {
    mapping people;
    int seconds, num;
    string mess;
    if ( !time ) {
      if(all == "")
        people = unique_mapping( filter( users(),
            (: interactive( $1 ) && !$1->query_login_ob() &&
             !$1->query_creator() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
      else
        people = unique_mapping( filter( users(),
            (: interactive( $1 ) && !$1->query_login_ob() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
        people = map( people, (: sort_array( $2, (: strcmp( $1->query_name(),
            $2->query_name() ) :) ) :) );
        mess = "";
        foreach( num in sort_array( keys( people ), -1 ) ) {
            if ( num > 0 ) {
                mess += "Online for " + query_num( num ) +
                    ( num == 1 ? " hour: \n" : " hours: \n" ) +
                    query_multiple_short( people[ num ] ) + ".\n\n";
            }
        }
        tell_object( this_player(), "$P$Online time$P$" +
            mess );
    }
    else {
        seconds = time * 60 * 60;
        people = allocate_mapping( users(), (: $(time()) -  $1->query_last_log_on() :) );
        people = filter( people, (: interactive($1) && !$1->query_login_ob()
            && $2 > $(seconds) :) );
        if ( sizeof( people ) ) {
            tell_object( this_player(), "The following people have been "
                "connected for more than " + query_num( time ) +
                ( time % 3600 < 2 ? " hour: " : " hours: " ) +
                query_multiple_short( keys( people ) ) + ".\n" );
        }
        else {
            tell_object( this_player(), "No one has been connected for that "
                "long.\n" );
        }
    }
    return 1;
}
mixed *query_patterns() {
  return ({ "<number>", (: cmd($4[0], "") :),
            "<number> all", (: cmd($4[0], "all") :),
            "all", (: cmd(0, "all") :),
            "", (: cmd(0, "") :) });
}

==================================================
FILE: creator/hous_ing.c
==================================================

#include <housing.h>
#include <login_handler.h>
#include <money.h>
inherit "/cmds/base";
private string get_file(string fname) {
  string *tmp;
  tmp = this_player()->get_files(fname);
  if(sizeof(tmp) != 1) {
    tmp = this_player()->get_files(fname + ".c");
    if(sizeof(tmp) != 1)
      return "";
  }
  return tmp[0][0..<3];
}
int do_remove(string house) {
  house = get_file(house);
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");
  HOUSING->remove_house(house);
  write("House removed.\n");
  return 1;
}
int do_add(string house, string region, int rented, string address) {
  object ob;
  house = get_file(house);
  if(house == "")
    return notify_fail("House does not exist.\n");
  load_object(house);
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The file " + house + " is not a player house.\n");
     return 0;
  }
  HOUSING->add_house(house, ({ }), address, region, rented);
  write("House added.\n");
  return 1;
}
int do_modify(string house, string region, int rented, string address) {
  string *rooms;
  house = get_file(house);
  if(house == "")
    return notify_fail("House does not exist.\n");
  if(!HOUSING->query_house(house))
    return notify_fail("That house is not registered.\n");
  rooms = HOUSING->query_rooms(house) - ({ house });
  HOUSING->modify_house(house, rooms, address, region, rented);
  write("House modified.\n");
  return 1;
}
int add_room(string house, string room) {
  string *files, file;
  object ob;
  int added;
  house = get_file(house);
  if(!HOUSING->query_house(house)) {
    return notify_fail("No such house.\n");
  }
  files = this_player()->get_files(room);
  if(!sizeof(files)) {
    return notify_fail("That room doesn't exist.\n");
  }
  house->force_load();
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The start point is not a player house!\n");
     return 0;
  }
  added = 0;
  foreach(file in files) {
    room = file[0..<3];
    if(room == house) {
      continue;
    }
    if(!HOUSING->add_rooms(house, ({ room }))) {
      write("Error adding room " + room + ".\n");
    } else {
      write("Room added [" + room + "]\n");
    }
  }
  return 1;
}
int remove_room(string house, string room) {
  house = get_file(house);
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");
  if(!HOUSING->remove_rooms(house, ({ room })))
    return notify_fail("Error removing room.\n");
  write("Room removed.\n");
  return 1;
}
int do_owner(string house, string owner) {
  if(owner == "none")
    owner = "For Sale";
  if(owner != "For Sale" && owner != "Under Offer" &&
     !PLAYER_HANDLER->test_user(owner))
    return notify_fail("No such user " + owner + ".\n");
  house = get_file(house);
  if(!HOUSING->set_owner(house, owner))
     return notify_fail("Error changing owner.\n");
  write("Owner set to " + owner + ".\n");
  return 1;
}
int do_list(string search) {
  string house;
  string str;
  string tmp;
  int num, negative;
  debug_printf("search: %s", search);
  if(search) {
    house = get_file(search);
    if(HOUSING->query_house(house)) {
      printf("House: %s\n  Owner: %s\n  Address: %s\n  Region: %s\n  "
             "Type: %s\n  Value: %d\n  Rooms: %s\n",
             house,
             HOUSING->query_owner(house),
             HOUSING->query_address(house),
             HOUSING->query_region(house),
             (HOUSING->query_type(house) ? "Rented" : "Owned"),
             HOUSING->query_value(house),
             implode(HOUSING->query_rooms(house), ", "));
      return 1;
    }
  }
  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }
  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s: %s. %d rooms (%s).\n",
                  house,
                  (HOUSING->query_type(house) ? "Renter" +
                   (HOUSING->query_value(house) ? " (" +
                    MONEY_HAND->money_value_string(HOUSING->query_value(house), "Ankh-Morpork") + ")" : "")
                   : "Owner"),
                  HOUSING->query_owner(house),
                  sizeof(HOUSING->query_rooms(house)),
                  (stringp(HOUSING->query_region(house))?HOUSING->query_region(house):"Bad region"));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }
  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}
int do_sell(string house) {
   house = get_file(house);
   if (!HOUSING->set_for_sale(house)) {
      add_failed_mess("Unable to set the house " + house + " up for sale.\n");
      return 0;
   }
   write("Set the house up for sale.\n");
   return 1;
}
int do_list_address(string search) {
  string house;
  string str;
  string tmp;
  int num;
  int negative;
  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }
  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s (%s).\n",
                  house,
                  HOUSING->query_address(house),
                  HOUSING->query_region(house));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }
  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}
mixed *query_patterns() {
  return ({ "list", (: do_list(0) :),
              "list <string'search'>", (: do_list($4[0]) :),
              "list address", (: do_list_address(0) :),
              "list address <string'search'>", (: do_list_address($4[0]) :),
              "sell <word'house'>", (: do_sell($4[0]) :),
              "add <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_add($4[0], $4[1], $4[2], $4[3]) :),
              "modify <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_modify($4[0], $4[1], $4[2], $4[3]) :),
              "add room <word'house'> <string'room'>",
              (: add_room($4[0], $4[1]) :),
              "remove room <word'house'> <string'room'>",
              (: remove_room($4[0], $4[1]) :),
              "owner <word'house'> <string'owner'>",
              (: do_owner($4[0], $4[1]) :),
              "remove <word'house'>", (: do_remove($4[0]) :),
              });
}

==================================================
FILE: creator/iemote.c
==================================================

#include <network.h>
inherit "/cmds/base";
int cmd(string person, string text) {
    string target, mud;
    if (sscanf(person, "%s@%s", target, mud) != 2) {
        return 0;
    }
    if ( !strlen( target ) || !strlen( mud ) ) {
        return 0;
    }
    SERVICES_D->eventSendEmote(target, mud, text);
    add_succeeded_mess( ({ sprintf("You emote to %s@%s: %s@%s %s\n",
        capitalize(target), mud, this_player()->query_cap_name(),
        mud_name(), text), "" }) );
    return 1;
}
mixed *query_patterns() {
    return ({ "<string'person'> <string'message'>",
              (: cmd($4[0], $4[1]) :) });
}

==================================================
FILE: creator/iloc_ate.c
==================================================

#include <network.h>
mixed cmd(string who) {
  if (!who) {
    notify_fail("Syntax: locate <name>\n");
    return 0;
  }
  SERVICES_D->eventSendLocateRequest(who);
  printf("Locating %s. Don't explode !\n", who);
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/inh_eritance.c
==================================================

#include <creator.h>
inherit "/cmds/base";
private string inherith(string ob, string ind, string leaf);
private int cmd(string fn, string fn2) {
    object ob, ob2;
    fn = this_player()->get_path( fn );
    if (!( ob = find_object( fn ))) {
        add_failed_mess( "No such object: " + fn + "\n" );
        return 0;
    }
    if ( fn2 ) {
        fn2 = this_player()->get_path( fn2 );
        if (!( ob2 = find_object( fn2 ))) {
            add_failed_mess( "No such object: " + fn2 + "\n" );
            return 0;
        }
    }
    fn = file_name(ob);
    write(fn + "\n" + inherith(fn, "  ", fn2 ));
    return 1;
}
private string inherith(string ob, string ind, string leaf) {
    string *fn, rtn = "", s;
    int i;
    if(!load_object(ob))
      return ind + "unable to find " + ob + "\n";
    fn = inherit_list(find_object(ob));
    for (i = 0; i < sizeof(fn); i++) {
        if (leaf && (find_object(fn[i]) == find_object(leaf))) {
            rtn += ind + fn[i] + "\n";
        } else {
            s = inherith(fn[i], ind + "  ", leaf);
            if (!leaf || (s != "")) {
                rtn += ind + fn[i] + "\n" + s;
            }
        }
    }
    return rtn;
}
int wiz_present_cmd( mixed indirect_obs ) {
    object fo, fo2;
    string fn, fn2;
    if ( !arrayp( indirect_obs ) ) {
        return 0;
    }
    if ( sizeof( indirect_obs ) < 1 ) {
        return 0;
    }
    if ( arrayp( indirect_obs[0] ) ) {
        fo = indirect_obs[0][0];
        if ( sizeof( indirect_obs ) == 2 ) {
            fo2 = indirect_obs[ 1 ][ 0 ];
        }
    }
    else {
        fo = indirect_obs[ 0 ];
        if ( sizeof( indirect_obs ) == 2 ) {
            fo2 = indirect_obs[ 1 ];
        }
    }
    if ( fo ) {
        fn = file_name( fo );
    }
    if ( fo2 ) {
        fn2 = file_name( fo2 );
    }
    debug_printf( "%O, %O\n", fn, fn2 );
    return cmd( fn, fn2 );
}
public mixed *query_patterns() {
    return ({
              "<word> [with] <word>", (: cmd( $4[0], $4[1] ) :),
              "<word>", (: cmd( $4[0], 0 ) :),
              "<indirect:wiz-present> with <indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
              "<indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
    });
}

==================================================
FILE: creator/inv.c
==================================================

#include <creator.h>
inherit "/cmds/base";
protected int cmd( object *obs ) {
    object ob;
    object *inventory;
    foreach( ob in obs ) {
        inventory = filter( all_inventory( ob ),
          (: reference_allowed( $1, $( this_player() ) ) :) );
        tell_object( this_player(), "Inv of " + WIZ_PRESENT->desc_object( ob ) +
          " in " + WIZ_PRESENT->desc_object(
            environment( ob ) ) + ":\n" );
        tell_object( this_player(), implode( map( inventory,
              (: "  " + WIZ_PRESENT->desc_f_object( $1 ) :) ), "\n" ) + "\n" );
        if ( !sizeof( inventory ) ) {
            continue;
        }
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "[of] <indirect:wiz-present>", (: cmd($1) :) });
}

==================================================
FILE: creator/jumps.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }
   return load_object(str);
}
int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;
   from_ob = find_location(from);
   to_ob = find_location(to);
   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }
   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}
int do_path_list() {
   string str;
   string from;
   string* dest;
   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}
int do_remove_jump(string from, string to) {
   string* dests;
   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}

==================================================
FILE: creator/loc_alcmd.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int flags, i, j, pos;
  mixed flag_types;
  object *obs;
  string *coms, flag;
  mixed *junk;
  if (!str) str = "";
  flag_types = ({ "priority", "star", "function", "object" });
  while (strlen(str) && str[0] == '-') {
    if (sscanf(str, "-%s %s", flag, str) != 2) {
      flag = str[1..100];
      str = "";
    }
    i = member_array(flag, flag_types, 1);
    if (i != -1) {
      flags |= 1 << i;
    }
  }
  if (!flags) {
    if (!strlen(str))
      coms = actions_defined(this_player());
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_player());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
      coms = map(obs, (: actions_defined($1) :));
    }
  } else {
    if (!strlen(str))
      junk = actions_defined(0, 0, flags);
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_object());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
      junk = map(obs, (: actions_defined($1, 0, $(flags)) :));
    }
    coms = ({ });
    for (i=1;i<sizeof(junk);i+=2) {
      pos = 0;
      str = junk[i-1];
      if ((flags&0xc) == 0xc) {
        str = WIZ_PRESENT->desc_f_object(junk[i][0])+"->"+junk[i][1]+":"+str;
        pos += 2;
      } else if (flags&0x8) {
        str = WIZ_PRESENT->desc_object(junk[i][0])+":"+str;
        pos++;
      } else if (flags&0x4) {
        str = junk[i][0]+"%"+str;
        pos++;
      }
      if (flags&0x2) {
        if (j = junk[i][pos]) {
          if (strlen(junk[i-1]) == j)
            str += "*";
          else {
            j = strlen(str)-junk[i][pos];
            str = str[0..j]+"*"+str[j+1..10000];
          }
        }
        pos++;
      }
      if (flags&1) {
        str += "|"+junk[i][pos];
      }
      coms += ({ str });
    }
  }
  this_player()->more_string( sprintf( "%-#*s\n",
      (int)this_player()->query_cols(),
      implode( coms, "\n" ) ), "Commands" );
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/lpc_info.c
==================================================

mixed cmd(string str) {
  printf("%s", lpc_info());
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mail.c
==================================================

#include <mail.h>
mixed cmd(string str) {
  return (int)MAIL_TRACK->mail(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/malloc.c
==================================================

mixed cmd(string str) {
  printf("%s", malloc_status());
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mem_stat.c
==================================================

#include <creator.h>
#define OBJ_LIMIT 50
#define TP this_player()
inherit "/cmds/base";
string help();
mixed cmd(string str) {
  int memtotal, limit, i = TP->query_cols() -7 -1, j;
  string ret, str2, str3;
   object *objlist;
  if (!str || str == "")
    return notify_fail(help());
  while (strlen(str) && str[0] == ' ')
    str = str[1..];
  if (sscanf(str, "-%s%d %s", str3, limit, str2) == 3) {
    if (str3[0..0] != "l")
      return notify_fail("Error: Only valid character following '-' is 'l' at "
                         "this time.\n");
    str = str2;
  }
  seteuid(geteuid(TP));
  objlist = WIZ_PRESENT->wiz_present(str, TP);
  if (!arrayp(objlist) || sizeof(objlist) < 1) {
    mixed *filelist;
    str = TP->get_path(str);
    notify_fail("Unable to find any objects or files corresponding"
                " to the given name.\n");
    if (sizeof(filelist = TP->get_files(str)) > 0) {
      filelist = filter(filelist, (: (sizeof($1) > 2) &&
                                   ($1[sizeof($1) - 2..] == ".c") :));
      if (sizeof(filelist) < 1)
        return 0;
      filelist = filter(filelist, (: find_object($1) :));
      objlist = map(filelist, (: find_object($1) :));
    } else
      return 0;
  }
  ret = sprintf("%-"+ i +"s %-7s\n", "Object name", "Memory");
  ret += sprintf("%-"+ i +"s %-7s\n", "------------", "-------");
  if (!limit)
    limit = OBJ_LIMIT;
  if (limit > sizeof(objlist))
    limit = sizeof(objlist);
  if (limit == 1)
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   WIZ_PRESENT->desc_f_object(objlist[sizeof(objlist) - 1]),
                   memory_info(objlist[sizeof(objlist) - 1]));
  else
    for (j = 0; j < limit; j++)
      ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                     WIZ_PRESENT->desc_f_object(objlist[j]),
                     memory_info(objlist[j]));
  if (sizeof(objlist) > 1) {
    for (j = 0; j < sizeof(objlist); j++)
      memtotal += memory_info(objlist[j]);
    ret += sprintf("%-"+ i +"."+ i +"s %7.7s\n",
                   "", "=======");
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   "Total memory used for all "+ sizeof(objlist) +
                   " object(s):", memtotal);
  }
  TP->more_string(ret);
  return 1;
}
string help() {
  return "Usage: memstat [-l<number>] [<filename(s)>|<wiz_present syntax>]\n\n"
"Memstat lists the guestimated amount of memory the specified object(s) use. "
"Using the -l option, a maximum amount of objects to be listed may be "
"specified otherwise a default limit of "+ OBJ_LIMIT +" objects are listed. "
"Paths including wildcards are taken as a way of specifying more than one "
"file.\n";
}
mixed *query_patterns() {
    return ({ "<string>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: creator/meteor.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
mixed cmd(string words) {
  string player, reason;
  object ob;
  if(this_player()->query_name() == "macchirton") {
    return notify_fail("You cannot use meteor.\n");
  }
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: meteor <player> <reason>\n");
  }
  ob = find_player(this_player()->expand_nickname(player));
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y|n): ");
  input_to("are_sure", ob, reason);
  return 1;
}
void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("Good little "+gender+"!  Now go play nice with "
      +ob->one_short()+".\n");
    return;
  }
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("NUKE", "%s: %s nuked %s: %s\n", ctime(time()),
    this_player()->query_short(), ob->query_short(), reason);
  shout("You see a very large %^YELLOW%^meteor%^RESET%^ up in the sky.\n");
  write("Nuking player "+ob->query_name()+".\n");
  call_out("nuke2", 2, ob);
}
void nuke2(object ob) {
  shout("The %^YELLOW%^meteor%^RESET%^ rushes towards the ground.\n");
  tell_object(ob, "It looks like it's heading for you.\n");
  call_out("nuke3", 5, ob);
}
void nuke3(object ob) {
  tell_object(ob, "The %^YELLOW%^meteor%^RESET%^ hits you ......"+
    "%^RED%^WALLOP.%^RESET%^\n");
  shout(ob->query_cap_name()+" has been struck by a meteor.\n"+
        capitalize(ob->query_pronoun())+" is no more.\n");
  ob->save();
  ob->quit();
}

==================================================
FILE: creator/mk_dir.c
==================================================

mixed cmd(string str) {
   seteuid(geteuid(this_player()));
   if (!str || str == "") {
      notify_fail("Make what directory?\n");
      return 0;
      }
   str = this_player()->get_path(str);
   str = replace(str, " ", "_");
   if (!str)
      return 1;
   if (file_size(str) != -1) {
      notify_fail(str + " already exists.\n");
      return 0;
      }
   if (!mkdir(str)) {
      notify_fail("Couldn't make dir.\n");
      return 0;
   }
   write("Ok.\n");
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mo_re.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *things;
  seteuid(geteuid(this_player()));
  if(!str) {
    notify_fail("More which file(s)/object?\n");
    return 0;
  }
  if(sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    str = file_name(things[0]);
    sscanf(str, "%s#%*d", str);
    if (file_size(str) <= 0)
      str += ".c";
  }
  return this_player()->more_file(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mobs.c
==================================================

#include <creator.h>
#define COUNT 10
int cmd(string arg){
  mapping m = ([]);
  string *obs, ob, ret = "";
  if(!master()->query_senior(this_player()->query_name()))
    return 0;
  switch(arg){
  case "all":
    objects((:$(m)[base_name($1)]++,reset_eval_cost():));
    break;
  case "inside":
    objects((:environment($1) && $(m)[base_name($1)]++:));
    break;
  default:
    objects((:environment($1) && living($1) &&
       $(m)[base_name($1)]++:));
  }
  obs = keys(filter(m, (:$2 > COUNT:)));
  foreach(ob in obs){
    object *things, thing;
    m = ([]);
    reset_eval_cost();
    if(arg != "all")
      things = filter(children(ob), (:environment($1):));
    else
      things = children(ob);
    foreach(thing in things)
      m[environment(thing)]++;
    m = filter(m, (:$2 > COUNT:));
    if(sizeof(m)){
      object *rooms = keys(m);
      foreach(thing in rooms){
        ret += sprintf("%3d %s in %s\n", m[thing],
                       WIZ_PRESENT->desc_f_object(find_object(ob)),
                       WIZ_PRESENT->desc_f_object(thing));
      }
    }
  }
  ob = sprintf("/w/%s/mobs", this_player()->query_name());
  printf("Saving to %s.\n", ob);
  seteuid(geteuid(this_player()));
  unguarded((:rm($(ob)),write_file($(ob), $(ret)):));
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
      "{all|inside}", (: cmd($4[0]) :) });
}
string help() {
  return "Shows groups of NPCs of one kind that are in the same room.";
}

==================================================
FILE: creator/mudinfo.c
==================================================

inherit "/cmds/base";
#ifndef __COMPILER__
#define __COMPILER__     "probably gcc"
#define __OPTIMIZATION__ "bugged driver?"
#endif
#define WIDTH 15
#define PAD(x,y)      sprintf("%-*s: %s\n", WIDTH, x,"" + y)
varargs string pretty_time(int tim, int len);
private nosave int num_obs;
mixed cmd(string str) {
   mapping r;
   float cpu;
   string name, cc, tmp;
   int *ltype;
   name = capitalize(mud_name()) + "   (" + query_host_name() + " " +
          __PORT__ + ")";
   cc = __COMPILER__ + "   (" + __OPTIMIZATION__ + ")";
   r = rusage();
   cpu = ((r["utime"] + r["stime"]) / uptime() / 10.0);
   num_obs = 0;
   objects((: num_obs++ :));
   ltype = implode(users(), (:$1[compressedp($2)]++, $1:), ({0,0}));
   tmp = PAD("Mud name", name) +
         PAD("Driver", __VERSION__) +
         PAD("Architecture", __ARCH__) +
         PAD("Compiler", cc) +
         PAD("Driver uptime", pretty_time(uptime(), 4)) +
         PAD("Avg Cpu usage", sprintf("%4.2f%%",cpu)) +
         PAD("Load Average", query_load_average()) +
         PAD("No of users", sizeof(users())) +
         PAD("Using MCCP", ltype[1]) +
         PAD("Plain telnet", ltype[0]) +
         PAD("Named Livings", sizeof(named_livings())) +
         PAD("Objects", num_obs) +
         PAD("Call Outs", sizeof(call_out_info()) + " pending.") +
         PAD("Memory usage", memory_info());
   tell_object(this_player(), tmp);
   return 1;
}
varargs string pretty_time(int tim, int len) {
   int num;
   string *bits, tmp;
   if(!len)
     len = 99999;
   bits = ({ });
   if(tim >= 60*60*24 && sizeof(bits) < len)
      bits += ({ (num=tim/(60*60*24))+" day"+(num==1?"":"s") });
   if(tim >= 60*60 && tim%(60*60*24) && sizeof(bits) < len)
      bits += ({ (num=(tim/(60*60))%24)+" hour"+(num==1?"":"s") });
   if(tim >= 60 && tim%(60*60) && sizeof(bits) <len)
      bits += ({ (num=(tim/60)%60)+" minute"+(num==1?"":"s") });
   if(tim%60 && sizeof(bits) <len)
      bits += ({ (num=tim%60)+" second"+(num==1?"":"s") });
   for(len =0; len<sizeof(bits); len++)
      if(sscanf(bits[len],"%d %s", num, tmp) == 2 && num == 0)
         bits[len] = 0;
   return implode(bits, ", ");
}

==================================================
FILE: creator/multipl_ayer.c
==================================================

#include <creator.h>
#include <player.h>
inherit "/cmds/base";
varargs int cmd(string command, string name, string what, string extra) {
  switch (command) {
  case "add":
    if (!call_other(PLAYER_MULTIPLAYER_HANDLER, "add_" + what, name, extra)) {
      printf("\"%s\"%s isn't known here.\n", name, (extra ? " and/or \"" +
                extra + "\"" : ""));
    } else {
      if (what == "allowed") {
        printf("\"%s\" and \"%s\" added as allowed together.\n", name, extra);
      } else {
        printf("\"%s\" added.\n", name);
      }
    }
    break;
  case "del":
    if(!call_other(PLAYER_MULTIPLAYER_HANDLER, "delete_" + what, name)) {
      printf("\"%s\" isn't on the list.\n", name);
    } else {
      printf("\"%s\" deleted.\n", name);
    }
    break;
  case "log":
    PLAYER_MULTIPLAYER_HANDLER->mark_log(name, extra);
    if (extra) {
      printf("Added \"multiplay\" playerinfo event for \"%s\": \"%s\".\n",
           name, extra);
    } else {
      printf("Marked \"multiplay\" playerinfo events for \"%s\" as handled.\n",
           name);
    }
    break;
  case "list":
    write("The list currently consists of: $I$5=\n" +
          query_multiple_short(sort_array(call_other(PLAYER_MULTIPLAYER_HANDLER,
                                                     "query_" + what),
                                          (: strcmp($1, $2) :)))
          + "$I$0=\n");
    break;
  case "site":
    if(find_player(name)) {
      name = query_ip_number(find_player(name));
    }
    if("/secure/bastards"->change_multi(name, 1, time() + 3600)) {
      write("Site " + name + " has been permitted for multiplayers "
            "for the next hour.\n");
    } else {
      write("Error permitting site " + name + " for multiplayers.\n");
    }
    break;
  default:
    write("Unknown option.\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "[list]",  (: cmd("list", 0, "gits") :),
              "{list allow}", (: cmd("list", 0, "allowed") :),
            "add git <word'name'>", (: cmd("add", $4[0], "git") :),
            "add allowed <word'first name'> <word'second name'>",
            (: cmd("add", $4[0], "allowed", $4[1]) :),
            "allow site <word'address|name'>", (: cmd("site", $4[0], "allowed") :),
            "del allowed <word'name'>", (: cmd("del", $4[0], "allowed") :),
            "log <word'name'>", (: cmd("log", $4[0], "git") :),
            "log <word'name'> <string'log text'>", (: cmd("log", $4[0], "git",
                                                       implode($4[1..], " ")) :)
         });
}

==================================================
FILE: creator/mv.c
==================================================

mixed cmd(string str) {
  int loop, fs, pos, multi;
  string *filenames, dest, *fnames, trash1, trash2, trash3, trash4;
  string path, *temp, start, end;
  seteuid(geteuid(this_player()));
  if ((!str) || (sscanf(str, "%s %s", trash1, trash2) != 2))
    return notify_fail("Usage : mv file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2], " "));
  if(!sizeof(filenames))
    return notify_fail("Usage : mv file [file|dir...]\n");
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if (!dest) {
    write("No destination\n");
    return 1;
  }
  if (sscanf(str, "%s*%s %s*%s", trash1, trash2, trash3, trash4) == 4) {
    multi = 1;
    temp = explode(dest, "/");
    path = implode(temp[0..sizeof(temp) - 2], "/") + "/";
    sscanf(temp[sizeof(temp)-1], "%s*%s", start, end);
    temp = explode(implode(fnames[0..sizeof(fnames) -2], " "), "/");
    sscanf(temp[sizeof(temp)-1], "%s*%s", trash1, trash2);
    pos = strlen(trash1);
  }
  for (loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(file_size(str) == -1) {
      write("No such file : " + str + "\n");
      continue;
    }
    if(multi) {
      temp = explode(str, "/");
      trash1 = temp[sizeof(temp)-1];
      fs  = strlen(trash1) - strlen(trash2) - 1;
      dest = path + start + trash1[pos..fs] + end;
      fs = file_size(dest);
    }
    else {
      fs = file_size(dest);
      if(fs == -2) {
        string *names;
        names = explode(str, "/");
        fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      }
    }
    if(fs != -1) {
      write("File exists : " + dest + "\n");
      continue;
    }
    rename(str, dest);
  }
  write("Ok.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/net_stat.c
==================================================

#include <creator.h>
inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("netstat list");
   if (!stuff) {
      stuff = N_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/netdups.c
==================================================

#include <creator.h>
#include <peopler.h>
int cmd(string str) {
   mixed *bing;
   bing = this_player()->query_property("netdups list");
   if (!bing) {
      bing = ND_DEFAULT;
   }
   return PEOPLER->do_command(bing, str,
      (: query_ip_number($1) == 0 || query_ip_number($2) == 0 ||
         strcmp(query_ip_number($1), query_ip_number($2)) :),
      1);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/nslookup.c
==================================================

inherit "/cmds/creator/host";

==================================================
FILE: creator/ob_ject.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int i, j, cols;
  string obvarname, start, end;
  mixed *names, *objects;
  if (str) {
    if (sscanf(str, "%s=%s", obvarname, str) != 2)
      return notify_fail("USAGE: object ObVarName=ObjectSpec\n");
    notify_fail("Can't find object.\n");
    objects = WIZ_PRESENT->wiz_present(str, this_player());
    if (!sizeof(objects))
      return 0;
    if (sizeof(objects) > 1)
      write("Only using first object of several matched.\n");
    this_player()->set_obvar(obvarname, objects[0]);
    write("Var "+obvarname+" now attached to "+
        WIZ_PRESENT->desc_object(objects[0])+".\n");
    return 1;
  }
  objects = m_values((mapping)this_player()->get_obvars());
  names = m_indices((mapping)this_player()->get_obvars());
  j = sizeof(objects);
  cols = this_player()->query_cols();
  for (i=0; i<sizeof(objects); i++) {
    if (!objects[i]) {
      j--;
      this_player()->del_obvar(names[i]);
      break;
    }
    if (objectp(names[i]))
      start = WIZ_PRESENT->desc_object(names[i]);
    else
      start = sprintf("%O", names[i]);
    if (objectp(objects[i]))
      end = WIZ_PRESENT->desc_object(objects[i]);
    else {
      end = sprintf("%O", objects[i]);
      end = replace(end, "\n", "");
    }
    printf("%s; %*-=s\n", start, cols-strlen(start)-2, end);
  }
  if (!j) write("No obvars set.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/on_line.c
==================================================

inherit "/cmds/base";
string idle_time(object person) {
  int hours, mins, secs;
  string s, m, h;
  secs = query_idle(person);
  mins = secs / 60;
  secs %= 60;
  hours = mins / 60;
  mins %= 60;
  s = ("0"+secs)[<2..<1];
  m = ("0"+mins)[<2..<1];
  if ( !hours )  {
    return " (idle: "+m+":"+s+")";
  }
  h = ("0"+hours)[<2..<1];
  return " (idle: "+h+":"+m+":"+s+")";
}
int cmd( int show_idle ) {
  object *people, person;
  string *cre, *invis, *director, *trustee, bing, obtyp;
  cre = ({ });
  invis = ({ });
  director = ({ });
  trustee = ({ });
  people = filter_array( users(), (: $1->query_creator() :) );
  people = people - this_player()->query_ignoring( people );
  people = sort_array( people,
    (: strcmp( $1->query_name(), $2->query_name() ) :) );
  foreach( person in people )  {
    bing = person->query_cap_name();
    if ( show_idle && query_idle( person ) > 120 )  {
      bing += idle_time( person );
    }
    if (!this_player()->query_property("nod")) {
      obtyp = person->query_object_type();
        switch(obtyp) {
        case "X":
           break;
        case " ":
           break;
        case "C":
           bing += "(%^CYAN%^C%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
              bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "S":
           bing += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "T":
           bing += "(%^BOLD%^%^RED%^T%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "D":
           bing += "(%^RED%^D%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        default:
           break;
      }
    }
    switch( person->query_invis()  )  {
      case 0:
        cre += ({ bing });
        break;
      case 1:
        invis += ({ bing });
        break;
      case 2:
        director += ({ bing });
        break;
      default:
        trustee += ({ bing });
        break;
    }
  }
  if(sizeof(cre)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^GREEN%^"
      "Visible%^RESET%^: "+query_multiple_short(cre)+".\n"));
  }
  if(sizeof(invis)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^CYAN%^"
      "Invisible%^RESET%^: "+query_multiple_short(invis)+".\n"));
  }
  if(sizeof(director)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^YELLOW%^Director "
      "Invisible%^RESET%^: "+query_multiple_short(director)+".\n"));
  }
  if(sizeof(trustee)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^RED%^Trustee "
      "Invisible%^RESET%^: "+query_multiple_short(trustee)+".\n"));
  }
  return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd(1) :),
              "noidle", (: cmd(0) :) });
}

==================================================
FILE: creator/panic.c
==================================================

#include <panic.h>
inherit "/cmds/base";
int cmd( ) {
    return 0;
  PANIC_HANDLER->do_startup(previous_object());
  this_player()->add_succeeded_mess(this_object(),
                  "$N panic$s hopefully.", ({ }) );
  return 1;
}
mixed *query_pattern() {
  return ({ "", (: cmd() :) });
}

==================================================
FILE: creator/path_of.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ov, ob;
  if(strsrch(str, "in everyone") != -1)
    return notify_fail("Please don't do that.  You've been asked not to "
      "and it causes lag.\n");
  notify_fail("Pathof what?\n");
  ov = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ov)) return 0;
  foreach (ob in ov) {
    if (!objectp(ob)) continue;
    write("Path of " + WIZ_PRESENT->desc_object(ob) + " in " +
        WIZ_PRESENT->desc_object(environment(ob)) + ":\n");
    write(file_name(ob)+ "\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/pe_ople.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#include <peopler.h>
int num_sort(object first, object second) {
  int one, two;
  one = first->query_level();
  two = second->query_level();
  if(one < two)
    return 1;
  if(one > two)
    return -1;
  return 0;
}
int guild_sort(object first, object second) {
  object g1, g2;
  g1 = first->query_guild_ob();
  g2 = second->query_guild_ob();
  return strcmp(g1 ? g1->query_name() : "",
                g2 ? g2->query_name() : "");
}
int domain_sort(object first, object second) {
  object d1, d2;
  d1 = environment(first);
  d2 = environment(second);
  return strcmp(d1 ? file_name(d1) : "", d2 ? file_name(d2) : "");
}
int age_sort(object first, object second) {
  int one, two;
  one = first->query_time_on();
  two = second->query_time_on();
  if(one < two)
    return -1;
  if(one > two)
    return 1;
  return 0;
}
mixed cmd(string str) {
  mixed *stuff;
  string bit, *bits;
  function sort_func;
  stuff = this_player()->query_property("people list");
  if (!stuff)
    stuff = P_DEFAULT;
  if(str) {
    bits = explode(str, " ");
    str = 0;
    foreach(bit in bits) {
      switch(bit) {
      case "-l":
        sort_func = (: num_sort :);
        break;
      case "-g":
        sort_func = (: guild_sort :);
        break;
      case "-a":
        sort_func = (: age_sort :);
        break;
      case "-d":
        sort_func = (: domain_sort :);
        break;
      default:
        if(str)
          str += " " + bit;
        else
          str = bit;
      }
    }
  }
  return (int)PEOPLER->do_command(stuff, str, sort_func);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/perm_it.c
==================================================

#include <parser.h>
#include <access.h>
#include <player_handler.h>
#include <error_handler.h>
inherit "/cmds/base";
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8
int help();
mixed cmd(string command, string euid, string path) {
  string* euids;
  string* bing;
  if (this_player() != this_player(1)) {
    return 0;
  }
  seteuid("Root");
  notify_fail("Something went wrong.\n");
  path = (string)this_player()->get_path(path);
  switch(command) {
  case "assign" :
    if (file_size(path) != -2) {
       notify_fail("The path " + path + " does not exist.\n");
       return 0;
    }
    euids = explode(replace_string(euid, " ", ""), ",") - ({ "none" });
    bing = filter(euids, (: !PLAYER_HANDLER->test_creator($1) &&
                            $1 != ERROR_ASSIGNED_NO_ONE:));
    if (sizeof(bing)) {
       notify_fail("The people " + query_multiple_short(bing) +
                   " are not creators.\n");
       return 0;
    }
    if ((int)master()->assign_people_to_directory(path, euids)) {
       add_succeeded_mess("Assigned the directory " + path +
                         " to " + query_multiple_short(euids) + ".\n");
       return 1;
    }
    notify_fail("Unable to assign the directory, not creator names?\n");
    return 0;
  case "read":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to add read access.\n");
    return (int)master()->add_read_permission(euid, path);
    break;
  case "write":
      if (!master()->high_programmer(previous_object(-1)) &&
          !master()->valid_grant(this_player(), path, WRITE_MASK))
        return notify_fail("You do not have permission to add write "
                           "access.\n");
      return (int)master()->add_write_permission(euid, path);
      break;
  case "grant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to add grant access.\n");
    return (int)master()->add_grant_permission(euid, path);
    break;
  case "lock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->lock_path(path);
  case "noread":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to remove read "
                         "access.\n");
    return (int)master()->remove_read_permission(euid, path);
  break;
  case "nowrite":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, WRITE_MASK))
      return notify_fail("You do not have permission to remove write "
                         "access.\n");
    return (int)master()->remove_write_permission(euid, path);
    break;
  case "nogrant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to remove grant "
                         "access.\n");
    return (int)master()->remove_grant_permission(euid, path);
    break;
  case "unlock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->unlock_path(path);
    break;
  default:
    return help();
  }
}
int do_directory_summary(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;
   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }
   paths = sort_array( keys( assignments ), 1 );
   ret = sprintf("%40-s Assigned To\n", "Path");
   foreach (path in paths) {
      ret += sprintf("%-40s %s\n", path, query_multiple_short(assignments[path]));
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}
int do_directory_update(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;
   string* bits;
   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }
   paths = sort_array( keys( assignments ), 0 );
   foreach (path in paths) {
      if (sizeof(assignments[path])) {
         bits = explode(path, "/");
         if (bits[0] == "d") {
           ERROR_HANDLER->do_update_directory_assignment(("/d/" + bits[1] + "/master")->query_lord(), assignments[path][0], path, (: 1 :));
         } else {
           ERROR_HANDLER->do_update_directory_assignment("nobody", assignments[path][0], path, (: 1 :));
         }
         write("Updated " + path + " to " + assignments[path][0] + "\n");
      }
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}
int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!PLAYER_HANDLER->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str;
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  paths = sort_array( keys( perms ), 1 );
  if (!sizeof(paths)) {
    ret = "No permissions set.\n";
  } else {
    ret = sprintf("%11-s    Path\n", "Euid");
  }
  for (i=0;i<sizeof(paths);i++) {
    euids = keys(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
}
int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;
   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !PLAYER_HANDLER->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
}
int help() {
  write("Available commands:\n"
"  read    <euid> <path>     : add read permison to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n"
"  assign <euid> <path>      : assigns someone to look after a directory.\n"
"  assignment summary        : summary of directory assignments.\n" );
   return 1;
}
mixed *query_patterns() {
  return ({ "summary", (: do_summary(0) :),
              "summary <string>", (: do_summary($4[0]) :),
              "assignment summary", (: do_directory_summary(0) :),
              "assignment summary <string'filter'>", (: do_directory_summary($4[0]) :),
              "tidy", (: do_tidy() :),
              "help", (: help() :),
              "<word'permission'> <string'euid'> <word'path'>",
              (: cmd($4[0], $4[1], $4[2] ) :)
#ifdef 0
              ,
              "write <string'euid'> <string>", (: cmd("write", $4[0], $4[1]) :),
              "grant <string'euid'> <string>", (: cmd("grant", $4[0], $4[1]) :),
              "lock <string'euid'> <string>", (: cmd("lock", $4[0], $4[1]) :),
              "noread <string'euid'> <string>", (: cmd("noread", $4[0], $4[1]) :),
              "nowrite <string'euid'> <string>", (: cmd("nowrite", $4[0], $4[1]) :),
              "nogrant <string'euid'> <string>", (: cmd("nogrant", $4[0], $4[1]) :),
              "unlock <string'euid'> <string>", (: cmd("unlock", $4[0], $4[1])
                                                 :),
#endif
              });
}

==================================================
FILE: creator/playerinfo.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
#define LOGGING
inherit "/cmds/base";
int do_report( string player, string event, int lastn, int interleaved ) {
   string who = this_player()->expand_nickname( lower_case(player) );
   string ret;
   if( !PLAYER_HANDLER->test_user(who) ) {
      tell_object( this_player(), "%^RED%^%^BOLD%^NOTE: %^RESET%^"
        "This is a player that either "
        "never existed or no longer exists.  Some deleted players' "
        "dossiers remain, while others do not.\n" );
   }
#ifdef LOGGING
   log_file( "/d/admin/log/PLAYERINFO.log", "%s: %s read dossier of %s.\n",
     ctime( time() ), this_player()->query_name(), who );
#endif
   if( interleaved ) {
     ret = PLAYERINFO_HANDLER->query_interleaved(this_player(), who,
                                                 event);
   } else if( !event ) {
     ret = PLAYERINFO_HANDLER->query_dossier( this_player(), who, lastn );
   } else {
     ret = PLAYERINFO_HANDLER->query_event( this_player(), who,
                                            lower_case(event) );
   }
   ret = this_player()->fix_string(ret, this_player()->query_cols());
   return this_player()->more_string(ret, "Playerinfo", 1);
}
int list_events() {
   string * list;
   string event, myself, result;
   list = sort_array( PLAYERINFO_HANDLER->query_events(), 1 );
   myself = base_name(this_object());
   result = "";
   foreach( event in list )
     result += ( event == list[0] ) ? event : ( ", " + event );
   write( "The following events exist: " + result + ". \n" );
   list = filter( list,
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );
   write( "You can manually add the following events: "
     + query_multiple_short(list) + ". \n" );
   return 1;
}
void update_database( string comment, string * data ) {
   if( !comment )
      return;
   if( PLAYERINFO_HANDLER->add_entry( this_player(), data[0], data[1],
                                      comment + "\n" ) ) {
      write( capitalize( data[0] ) + "'s dossier updated.\n" );
   } else {
      write( "Cannot update " + capitalize( data[0] ) + "'s dossier.\n" );
   }
}
int do_acknowledge( string player, string event, int idx, string update ) {
   if( !(PLAYERINFO_HANDLER->is_alert( player, idx ) ) ) {
      add_failed_mess( "That event is not an alert, so cannot be "
        "acknowledged.\n" );
      return -1;
   }
   if( !PLAYERINFO_HANDLER->acknowledge_alert( this_player(), player,
     event, idx, update, 0 ) ) {
      add_failed_mess( "You do not have the permission to acknowledge that alert, "
        "or the event type is invalid.\n" );
      return -1;
   }
   add_succeeded_mess( ({ "Event acknowledged.\n", "" }) );
   return 1;
}
int list_alerts( int foo ) {
   string * names;
   if( foo )
      names = PLAYERINFO_HANDLER->query_online_alerts();
   else
      names = keys( PLAYERINFO_HANDLER->query_alerts() );
   if( !sizeof( names ) )
      write( "There are no players with unacknowledged alerts.\n" );
   else
      write( "The following players have unacknowledged alerts: "
        + query_multiple_short( names ) + ". (" + sizeof( names ) +
        ")\n" );
   return 1;
}
int add_event( string player, string event, string comment ) {
   string *events;
   string myself;
   player = this_player()->expand_nickname( lower_case(player) );
   event = lower_case(event);
   if( !PLAYER_HANDLER->test_user(player) ) {
      add_failed_mess( "No such player: " + player + ".\n" );
      return 0;
   }
   myself = base_name( this_object() );
   events = filter( PLAYERINFO_HANDLER->query_events(),
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );
   if( member_array( event, events ) == -1 ) {
      add_failed_mess( "Incorrect event type '" + event
        + "': it must be one of " + query_multiple_short(events) + ".\n" );
      return 0;
   }
   if( comment ) {
      update_database( comment, ({ player, event }) );
      return 1;
   }
   write( "Please enter your comments:\n" );
   this_player()->do_edit( 0, "update_database", this_object(), 0,
     ({ player, event }) );
   return 1;
}
int add_alts( string s1, string s2, int deleting ) {
   string who, result;
   string * alts;
   who = this_player()->expand_nickname( lower_case(s1) );
   alts = explode( lower_case(s2), " " );
   alts = explode( implode( alts, "," ), "," ) - ({ "" }) - ({ 0 });
   if( deleting ) {
      result = PLAYERINFO_HANDLER->delete_alts( this_player(), who, alts );
   } else {
      result = PLAYERINFO_HANDLER->add_alts( this_player(), who, alts );
   }
   add_succeeded_mess( ({ result, "" }) );
   return 1;
}
mixed *query_patterns() {
   return ({
     "list",
       (: list_events() :),
     "list alerts",
       (: list_alerts(0) :),
     "list alerts online",
       (: list_alerts(1) :),
     "<word'playername'>",
       (: do_report( $4[0], 0, 10, 0 ) :),
     "<word'playername'> verbose",
       (: do_report( $4[0], 0, 0, 0 ) :),
     "<word'playername'> interleaved",
       (: do_report( $4[0], 0, 0, 1 ) :),
     "<word'playername'> <word'event type'> interleaved",
       (: do_report( $4[0], $4[1], 0, 1 ) :),
     "<word'playername'> <word'event type'>",
       (: do_report( $4[0], $4[1], 0, 0 ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "<string'comment'>",
       (: do_acknowledge( $4[0], "misc", $4[1], $4[2] ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "as <word'event type'> <string'comment'>",
       (: do_acknowledge( $4[0], $4[2], $4[1], $4[3] ) :),
     "<word'playername'> add [event] <word'event type'>",
       (: add_event( $4[0], $4[1], 0 ) :),
     "<word'playername'> add [event] <word'event type'> <string'comment'>",
       (: add_event( $4[0], $4[1], $4[2] ) :),
     "<word'playername'> addalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 0 ) :),
     "<word'playername'> delalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 1 ) :),
   });
}
