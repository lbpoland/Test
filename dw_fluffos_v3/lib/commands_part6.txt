
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/assist.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_assist( object member, string group );
int do_unassist( object member, string group );
int do_assist_list(string group);
void create() {
   ::create();
   add_group_sub_command( "assist", "<indirect:living'member'>",
      (: do_assist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "unassist", "<indirect:distant-living'member'>",
      (: do_unassist( $1[ 0 ], $6 ) :) );
   add_group_sub_command( "assist", "list",
      (: do_assist_list( $6 ) :) );
   set_membership_required( "assist", 0, 1 );
}
int do_assist_list( string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( sizeof( assisting ) )
   {
      tell_object( this_player(), "You are currently "
         "assisting " + query_multiple_short( assisting ) +
         ".\n" );
      return 1;
   }
   add_failed_mess("You are not assisting anyone.\n");
   return 0;
}
int do_assist( object member, string group ) {
   object *assisting;
   assisting = this_player()->query_assisting();
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( !GROUP->is_member( group, member ) ) {
      add_failed_mess( member->the_short() + " is not a "
         "member of your group.\n" );
      return 0;
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      add_failed_mess( "You are already assisting " + member->the_short() +
         ".\n" );
      return 0;
   }
   if( sizeof( assisting ) >= MAX_PEOPLE_YOU_CAN_ASSIST ) {
      add_failed_mess( "You can not assist any more people.\n" );
      return 0;
   }
   add_succeeded_mess( "$N begin$s keeping a close eye on $I.\n",
                       ({ member }) );
   member->add_assister( this_player() );
   return 1;
}
int do_unassist( object member, string group ) {
   if( member == this_player() ) {
      return notify_fail( "Don't be stupid.\n" );
   }
   if( member->query_assisters() &&
      member_array( this_player(), member->query_assisters() ) != -1 ) {
      member->remove_assister( this_player() );
      add_succeeded_mess( ({ "You stop assisting " + member->the_short() +
         ".\n", "" }) );
      return 1;
   }
   add_failed_mess("You are not assisting $I.\n", ({ member }));
   return 0;
}
string query_help_string_for( string sub ) {
   return "With this command you can guard a group member.  If the "
      "person you're guarding gets attacked, you will automatically "
      "join the fight after a delay.  The length of the delay depends "
      "on how many people you're guarding at the moment.  Use "
      "\"list\" to see who you are currently assisting.  To stop "
      "assisting someone, use \"group assist <someone>\" again "
      "on that person.\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/report.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
#define GROUP_CMD_STATUS  ( GROUP_SUB_CMDS_DIR+"status" )
int do_report( string group );
void create() {
   ::create();
   add_group_sub_command( "report", "", (: do_report( $6 ) :) );
   set_membership_required( "report", 0, 1 );
}
int do_report( string group ) {
   string message;
   message = this_player()->query_cap_name() + " reports that " +
      this_player()->query_pronoun() + " is ";
   message += GROUP_CMD_STATUS->generate_status_message( this_player() );
   GROUP->notify_group( group, this_player(), ({
      "You report:  " + message,
      message
      }) );
   return 1;
}
string query_help_string_for( string sub_command ) {
   return "This command lets you report your current "
      "condition on the group's channel.";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/follow.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_follow( object *who, string group, int unfollow );
void create() {
   ::create();
   add_group_sub_command( "follow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 0 ) :) );
   add_group_sub_command( "unfollow", "<indirect:living'member(s)'>",
      (: do_group_follow( $1, $6, 1 ) :) );
   set_membership_required( "follow", 0, 1 );
   set_membership_required( "unfollow", 0, 1 );
}
int do_group_follow( object *who, string group, int unfollow ) {
   int size;
   string fault_message;
   object *what_not, *follow, *already_following;
   fault_message = "";
   who -= ({ 0 });
   if( member_array( this_player(), who ) != -1 ) {
      who -= ({ this_player() });
      fault_message += "You cannot follow yourself.  ";
   }
   follow = ( who & GROUP->members_of( group ) );
   what_not = who - follow;
   switch( unfollow ) {
      case 1:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) == -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are not following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      case 0:
         already_following = filter( follow,
            (: member_array( this_player(),
               $1->query_followers() ) != -1 :) );
         if( sizeof( already_following ) ) {
            fault_message += "You are already following $C$" +
               query_multiple_short( already_following,
               "the" ) + ".  ";
            follow -= already_following;
         }
         break;
      default:
         printf( "Barf.\n" );
   }
   size = sizeof( what_not );
   if( size ) {
      fault_message += "$C$" + query_multiple_short( what_not, "the" ) +
         ( size > 1 ? " are not members of your group" :
         " is not a member of your group" ) + ".  ";
   }
   fault_message += "\n";
   if( sizeof( follow ) ) {
      GROUP->handle_group_follow( group, this_player(), follow,
         unfollow, 0 );
      return 1;
   } else {
      tell_object( this_player(), fault_message );
      return 1;
   }
}
string query_help_string_for( string sub ) {
   switch( sub ) {
      case "follow":
         return "This command lets you follow your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
      case "unfollow":
         return "This command lets you stop following your fellow "
            "group members.  Using \"all\" will only target "
            "all group members, not all people, in the room.\n";
   }
   return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/join.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_join( object member );
void create() {
   ::create();
   add_group_sub_command( "join", "<indirect:living'existing member'>",
      (: do_join( $1[ 0 ] ) :) );
}
int do_join( object member ) {
   string his_group, my_group;
   his_group = member->query_group();
   if( this_player() == member ) {
      return notify_fail( "I could come up with something witty, "
         "but I'm not going to bother.\n" );
   }
   if( !his_group ) {
      return notify_fail( member->the_short() + " is not a member "
         "of any group.\n" );
   }
   if( !GROUP->is_invited( his_group, this_player() ) ) {
      return notify_fail( "You have not been invited to that "
         "group.\n" );
   }
   if( sizeof( GROUP->members_of( his_group ) ) >= MAX_PEOPLE_PER_PARTY ) {
      return notify_fail( "The group you are trying to join is "
         "full.\n" );
   }
   my_group = this_player()->query_group();
   if( my_group && ( my_group == his_group ) ) {
      return notify_fail( "You are already a member of "
         "that group.\n" );
   }
   if( my_group ) {
      if( !GROUP->remove_member( my_group, this_player() ) ) {
         return notify_fail( "You fail to leave your previous "
            "group.. for some reason.\n" );
      }
      tell_object( this_player(), "%^BOLD%^You leave your current "
         "group behind to join a new one.%^RESET%^\n" );
   }
   if( !GROUP->add_member( his_group, this_player() ) ) {
      return notify_fail( "You failed to join the group "
         "for some weird reason.\n" );
   }
   return 1;
}
string query_help_string_for( string sub_command ) {
   switch( sub_command ) {
      case "join":
         return "This command lets you join an existing group.  To join, "
            "type \"group join <existing member>\" where "
            "<existing member> is someone who is already a member of the "
            "group you wish to be a part of.  You must be invited to a "
            "group by its leader before you can join.";
      default:
         return 0;
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/status.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_status( string verbose, string group );
int display_verbose_group_status( string group );
int display_brief_group_status( string group );
string calc_idle_string( object player );
string generate_status_message( object player );
string convert_percentage_to_colour( int percentage );
string convert_percentage_to_hp_message( int percentage );
string convert_percentage_to_gp_message( int percentage );
void create() {
   ::create();
   add_group_sub_command( "status", "<word'brief|verbose'>",
      (: do_group_status( $4[ 0 ], $6 ) :) );
   add_group_sub_command( "status", "",
      (: do_group_status( "default", $6 ) :) );
   set_membership_required( "status", 0, 1 );
}
int do_group_status( string verbose, string group ) {
   int use_verbose;
   switch( verbose ) {
      case "default":
         use_verbose = this_player()->query_verbose( "score" );
         break;
      case "verbose":
         use_verbose = 1;
         break;
      case "brief":
         use_verbose = 0;
         break;
      default:
         return notify_fail( "[ERROR]: Unknown return value from verbose information.\n" );
   }
   switch( use_verbose ) {
      case 1:
         return display_verbose_group_status( group );
      case 0:
         return display_brief_group_status( group );
      default:
         return notify_fail( "[ERROR]: This shouldn't happen.\n" );
   }
}
int display_verbose_group_status( string group ) {
   int size, cols;
   object member, *members, *assisting;
   string pronoun, message, status, short, colour, idle;
   cols = this_player()->query_cols();
   short = GROUP->query_group_short( group );
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   message = "\n";
   message += sprintf( "   %'+'*|s\n", cols - 3, "|" + short + "|" );
   size = sizeof( message ) - 3;
   message = replace( message, ({ short, ( colour + short +
      "%^RESET%^" ) }) );
   message += "\n";
   message += sprintf( "%' '*|s\n",
      cols - 3,
      "The group was started on " +
         ctime( GROUP->query_start_time( group ) ) + "." );
   message += "\n";
   members = GROUP->members_of( group );
   message += sprintf( "   %-=*s\n\n",
      size, "The group has %^BOLD%^" + query_num( sizeof( members ) ) +
      "%^RESET%^ " + ( sizeof( members ) > 1 ? "members" : "member" ) +
      ":" );
   if (!members) {
      message += "Very unhappy group.\n";
   } else {
      foreach( member in members ) {
          if(!member)
             continue;
          status = "$I$+8,+0=   " + colour;
          status += capitalize( member->query_cap_name() ) + "%^RESET%^" +
             " is " + generate_status_message( member ) + "  ";
          pronoun = member->query_pronoun();
          idle = calc_idle_string( member );
          if( idle ) {
             status += "  %^BOLD%^" + idle + ".%^RESET%^";
          }
          if( member == GROUP->leader_of( group ) ) {
             status += "  " + capitalize( pronoun ) + " is the " +
                colour + "current leader%^RESET%^ of the group.";
          }
          assisting = member->query_assisting();
          if( sizeof( assisting ) ) {
             status += "  " + capitalize( pronoun ) + " is assisting " +
                query_multiple_short( assisting, "one", 0, 1 ) + ".";
          }
          status += "$I$-8,-0=\n";
          message += status;
      }
   }
   tell_object( this_player(), message );
   return 1;
}
int display_brief_group_status( string group ) {
   object member, *others;
   string message, colour, idle;
   int my_gp, my_hp, my_max_hp, my_max_gp;
   message = "";
   colour = this_player()->colour_event( GROUP_COLOUR_EVENT, "" );
   others = GROUP->members_of( group ) - ({ this_player() });
   my_hp = this_player()->query_hp();
   my_gp = this_player()->query_gp();
   my_max_hp = this_player()->query_max_hp();
   my_max_gp = this_player()->query_max_gp();
   message += colour;
   message += capitalize( this_player()->query_cap_name() );
   message += "%^RESET%^; Hp: " + convert_percentage_to_colour( my_hp * 100 / my_max_hp ) +
      my_hp + "/" + my_max_hp + "%^RESET%^ Gp: " +
      convert_percentage_to_colour( my_gp * 100 / my_max_gp ) +
      my_gp + "/" + my_max_gp + "%^RESET%^.\n";
   foreach( member in others ) {
     if(!member)
       continue;
      message += colour;
      message += capitalize( member->query_cap_name() );
      message += "%^RESET%^ is " + generate_status_message( member );
      idle = calc_idle_string( member );
      if( idle ) {
         message += "  (" + idle + ")";
      }
      if( member == GROUP->leader_of( group ) ) {
         message += " (" + colour + "L%^RESET%^)";
      }
      if( member->query_property( "dead" ) ) {
         message += " (%^BOLD%^%^RED%^D%^RESET%^)";
      }
      message += "\n";
   }
   tell_object( this_player(), message );
   return 1;
}
string calc_idle_string( object player ) {
   int idle;
   if( !interactive( player ) ) {
      return "Net Dead";
   }
   idle = query_idle( player );
   if( idle < 15 ) {
      return 0;
   }
   return "Idle: " + ( idle / 60 ) + ":" + sprintf("%'0'2d", ( idle % 60 ));
}
string generate_status_message( object player ) {
   int hp_percentage, gp_percentage;
   hp_percentage = player->query_hp() * 100 / player->query_max_hp();
   gp_percentage = player->query_gp() * 100 / player->query_max_gp();
   return (
      convert_percentage_to_colour( hp_percentage ) +
      convert_percentage_to_hp_message( hp_percentage ) +
      "%^RESET%^ and " +
      convert_percentage_to_colour( gp_percentage ) +
      convert_percentage_to_gp_message( gp_percentage ) +
      "%^RESET%^." );
}
string query_help_string_for( string sub_command ) {
   return "The status sub-command displays vital statistics "
      "of your group's members.  Depending on your brief "
      "settings for \"score\", the command will either "
      "show the verbose statistics or prompt a brief "
      "display.  You can also force either version by "
      "adding the argument \"verbose\" or \"brief\".";
}
string convert_percentage_to_colour( int percentage ) {
   switch( percentage ) {
      case -1000..10: return "%^BOLD%^%^RED%^";
      case 11..20:    return "%^RED%^";
      case 21..30:    return "%^ORANGE%^";
      case 31..40:    return "%^YELLOW%^";
      case 41..50:    return "%^MAGENTA%^";
      case 51..60:    return "%^CYAN%^";
      case 61..70:    return "%^BOLD%^%^CYAN%^";
      case 71..80:    return "%^GREEN%^";
      case 81..90:    return "%^BOLD%^%^GREEN%^";
      case 91..100:   return "%^BOLD%^%^WHITE%^";
      default:        return "";
   }
}
string convert_percentage_to_hp_message( int percentage ) {
   switch( percentage ) {
      case -1000..0: return "perfectly healthy, for a ghost";
      case 1..5:     return "near death";
      case 6..10:    return "critically wounded";
      case 11..20:   return "seriously wounded";
      case 21..30:   return "heavily wounded";
      case 31..40:   return "badly wounded";
      case 41..50:   return "wounded";
      case 51..60:   return "slightly wounded";
      case 61..70:   return "injured";
      case 71..80:   return "slightly injured";
      case 81..89:   return "slightly hurt";
      case 90..94:   return "scratched";
      case 95..99:   return "almost unhurt";
      case 100:      return "unhurt";
      default:       return "ERROR";
   }
}
string convert_percentage_to_gp_message( int percentage ) {
   switch( percentage ) {
      case 0..10:    return "near unconscious";
      case 11..20:   return "severely fatigued";
      case 21..30:   return "highly fatigued";
      case 31..40:   return "very fatigued";
      case 41..50:   return "fatigued";
      case 51..60:   return "slightly fatigued";
      case 61..70:   return "confused";
      case 71..80:   return "slightly confused";
      case 81..90:   return "concentrated";
      case 91..99:   return "clear of mind";
      case 100:      return "refreshed";
      default:       return "ERROR";
   }
}
string convert_percentage_to_share_message( int percentage ) {
   switch( percentage ) {
      case 100:       return "all";
      case 95..99:    return "almost all";
      case 90..94:    return "a very large portion";
      case 80..89:    return "a large portion";
      case 70..79:    return "a major portion";
      case 60..69:    return "an above average portion";
      case 52..59:    return "a slightly above average portion";
      case 49..51:    return "an average portion";
      case 41..48:    return "a slightly below average portion";
      case 31..40:    return "a below average portion";
      case 21..30:    return "a minor portion";
      case 11..20:    return "a small portion";
      case 6..10:     return "a very small portion";
      case 1..5:      return "a miniscule portion";
      case 0:         return "next to none";
      default:        return "an ERRONEOUS portion ";
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/invite.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_invite( object person, string group );
void create() {
   ::create();
   add_group_sub_command( "invite", "<indirect:living'person'>", (:
      do_invite( $1, $6 ) :) );
   set_membership_required( "invite", 0, 1 );
   set_leadership_required( "invite", 0, 1 );
}
int do_invite( object *persons, string group ) {
   object person;
   persons -= ({ this_player() });
   if( !sizeof( persons ) ) {
      return notify_fail( "I would come up with "
         "something witty, but I'm not going to "
         "bother.\n" );
   }
   if( sizeof( persons ) > 1 ) {
      return notify_fail( "You can only invite one person "
         "at a time.\n" );
   }
   person = persons[ 0 ];
   if( sizeof( GROUP->invitations_of( group ) ) >=
      MAX_INVITATIONS_PER_PARTY_AT_ONCE ) {
      return notify_fail( "You can only have a total of " +
         MAX_INVITATIONS_PER_PARTY_AT_ONCE + " invitations pending "
         "at one time.\n" );
   }
   if( GROUP->is_invited( group, person ) ) {
      return notify_fail( person->the_short() + " has "
         "already been invited to your group.\n" );
   }
   if( GROUP->is_member( group, person ) ) {
      return notify_fail( person->the_short() + " is "
         "already a member of your group.\n" );
   }
   if( !userp( person ) ) {
      return notify_fail( "You cannot invite " + person->the_short() +
         " to your group.\n" );
   }
   GROUP->add_invite( group, person );
   GROUP->notify_group( group, this_player(), person->query_cap_name() +
      " has been invited by " + this_player()->query_cap_name() + ".  " );
   tell_object( person, "You have been invited by " +
      this_player()->a_short() + " to join " +
      this_player()->query_possessive() + " group.  "
      "You have " + INVITE_TIMEOUT + " seconds to join "
      "the group before the invitation is withdrawn.  Use "
      "\"group join " + this_player()->query_name() + "\" "
      "to join.\n" );
   if( person->query_group() ) {
      tell_object( person, "%^BOLD%^Note that accepting the invitation "
         "will force you to leave your current group.%^RESET%^\n" );
   }
   return 1;
}
string query_help_string_for( string sub ) {
   return "With this command the leader of a group can invite new "
      "members to the group.  A person who has been invited must then "
      "use the \"join\" command to actually become a member.";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/base_group.c ===
#define GROUP_ARRAY_SIZE      3
#define GROUP_ARRAY_FUNCTION  0
#define GROUP_ARRAY_MEM_REQ   1
#define GROUP_ARRAY_LDR_REQ   2
mapping _commands;
void create() {
   _commands = ([ ]);
}
int query_group_sub_command_amount() {
   return sizeof( _commands );
}
int add_group_sub_command( string verb, string pattern,
   function cmd_function ) {
   if( !_commands[ verb ] ) {
      _commands += ([ verb : ([ pattern : ({ cmd_function, 0, 0 }) ]) ]);
      return 1;
   }
   if( _commands[ verb ][ pattern ] ) {
      return 0;
   }
   _commands[ verb ] += ([ pattern : ({ cmd_function, 0, 0 }) ]);
   return 1;
}
varargs int remove_group_sub_command( string verb, string pattern ) {
   if( undefinedp( pattern ) ) {
      if( !_commands[ verb ] ) {
         return 0;
      }
      map_delete( _commands, verb );
      return 1;
   }
   if( !_commands[ verb ] || !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   map_delete( _commands[ verb ], pattern );
   return 1;
}
string *query_group_sub_command_verbs() {
   return keys( _commands );
}
string *query_group_sub_command_patterns( string verb ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   return keys( _commands[ verb ] );
}
varargs function *query_group_sub_command_function( string verb, string
   pattern ) {
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( undefinedp( pattern ) ) {
      return values( _commands[ verb ] );
   }
   if( !_commands[ verb ][ pattern ] ) {
      return 0;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_FUNCTION ];
}
int set_membership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_MEM_REQ ] = flag;
   }
   return 1;
}
int set_leadership_required( string verb, string pattern, int flag ) {
   mixed *dummy;
   string key;
   if( !_commands[ verb ] ) {
      return 0;
   }
   if( pattern ) {
      if( !_commands[ verb ][ pattern ] ) {
         return 0;
      }
      _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ] = flag;
      return 1;
   }
   foreach( key, dummy in _commands[ verb ] ) {
      _commands[ verb ][ key ][ GROUP_ARRAY_LDR_REQ ] = flag;
   }
   return 1;
}
varargs int query_membership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_MEM_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_MEM_REQ ];
}
varargs int query_leadership_required( string verb, string pattern ) {
   if( !_commands[ verb ] ) {
      return -1;
   }
   if( undefinedp( pattern ) ) {
      return _commands[ verb ][ keys( _commands[ verb ] )[ 0 ] ]
         [ GROUP_ARRAY_LDR_REQ ];
   }
   if( !_commands[ verb ][ pattern ] ) {
      return -1;
   }
   return _commands[ verb ][ pattern ][ GROUP_ARRAY_LDR_REQ ];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/say.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_say( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "say", "<string'message'>",
      (: do_group_say( $4[ 0 ], $6 ) :) );
   set_membership_required( "say", 0, 1 );
}
int do_group_say( string message, string group ) {
   message = replace( message, ({ "%^", "" }) );
   GROUP->notify_group( group, this_player(),
      this_player()->query_cap_name() + ": " + message );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to say something on "
      "the group's channel.";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/group_cmds/emote.c ===
#include <group_handler.h>
inherit GROUP_SUBCOMMAND_INHERITABLE;
int do_group_emote( string message, string group );
void create() {
   ::create();
   add_group_sub_command( "emote", "<string'message'>",
      (: do_group_emote( $4[ 0 ], $6 ) :) );
   set_membership_required( "emote", 0, 1 );
}
int do_group_emote( string message, string group ) {
   message = replace( message, ({ "%^", "", }) );
   GROUP->notify_group( group, this_player(), ({
      "You emote: " + this_player()->query_cap_name() + " " + message,
      this_player()->query_cap_name() + " " + message
      }) );
   return 1;
}
string query_help_string_for( string sub ) {
   return "This command allows you to emote on the group "
      "channel.";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/sa_y.c ===
#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "cmds/speech";
mixed cmd(string arg) {
  class message mess;
  mess = build_message(arg, 0, "say");
  return say_it(mess);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/accept.c ===
#include <cmds/offer.h>
#include <money.h>
#include <move_failures.h>
inherit "/cmds/base";
int is_in(object ob, object source);
int do_buy(object *people) {
   object person;
   int ret;
   class offer_sale wombat;
   object *obs;
   object *moved;
   mixed *payment;
   object ob;
   int i;
   foreach (person in people) {
      wombat = this_player()->query_respond_command("sell", person);
      if (wombat) {
         obs = filter(wombat->sell_obs, (: is_in($1, $2) :),
                      wombat->seller);
         if (sizeof(obs) != sizeof(wombat->sell_obs)) {
            add_failed_mess("$I no longer has " +
                            query_multiple_short(wombat->sell_obs - obs) +
                            " to buy.\n",
                            ({ person }) );
         } else if (this_player()->query_value_in(wombat->place) <
                    wombat->value) {
            add_failed_mess("You no longer have enough money to buy " +
                            query_multiple_short(wombat->sell_obs) +
                            " from $I.\n", ({ person }));
         } else {
            payment = MONEY_HAND->query_person_payments(wombat->value,
                                                        wombat->place,
                                                        this_player(), person);
            if (!payment) {
               add_failed_mess("You no longer have the correct change "
                               "to pay for $I.\n", ({ person }) );
            } else {
               moved = ({ });
               foreach (ob in wombat->sell_obs) {
                  if (ob->move(this_player()) == MOVE_OK) {
                     moved += ({ ob });
                  }
               }
               if (sizeof(moved) != sizeof(wombat->sell_obs)) {
                  moved->move(person);
                  tell_object(person, "Unable to move " +
                                      query_multiple_short(wombat->sell_obs -
                                                           moved) +
                                      " out of your inventory, cancelling "
                                      "the sale.\n");
                  add_failed_mess("Unable to move some objects out "
                                  "of the inventory of $I, canceling sale.\n",
                                  ({ person }) );
               } else {
                  if (sizeof(payment[MONEY_PAY_CHANGE])) {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " from " + this_player()->the_short() +
                              " and give back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place)+
                              " to " + person->the_short() +
                              " and receive back " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_CHANGE],
                                                       wombat->place) +
                              " in change.\n");
                  } else {
                     tell_object(person, "You accept " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " from " + this_player()->the_short() +".\n");
                     tell_object(this_player(), "You give " +
                            MONEY_HAND->money_string(payment[MONEY_PAY_RETURN],
                                                       wombat->place) +
                              " to " + person->the_short() + ".\n");
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_RETURN]); i += 2) {
                     this_player()->adjust_money(-payment[MONEY_PAY_RETURN][i+1],
                                                 payment[MONEY_PAY_RETURN][i]);
                     person->adjust_money(payment[MONEY_PAY_RETURN][i+1],
                                          payment[MONEY_PAY_RETURN][i]);
                  }
                  for (i = 0; i < sizeof(payment[MONEY_PAY_CHANGE]); i += 2) {
                     person->adjust_money(-payment[MONEY_PAY_CHANGE][i+1],
                                                 payment[MONEY_PAY_CHANGE][i]);
                     this_player()->adjust_money(payment[MONEY_PAY_CHANGE][i+1],
                                          payment[MONEY_PAY_CHANGE][i]);
                  }
                  add_succeeded_mess("$N buy$s " +
                                     query_multiple_short(wombat->sell_obs) +
                                     " from $I.\n", ({ person }) );
                  ret++;
               }
            }
         }
         this_player()->remove_respond_command("sell", person);
      } else {
         add_failed_mess("Sorry, $I has not offered to sell you anything.\n",
                         ({ person }) );
      }
   }
   return ret;
}
int is_in(object ob, object source) {
   object env;
   if (!ob) {
      return 0;
   }
   env = ob;
   do {
      env = environment(env);
      if (env == source) {
         return 1;
      }
   } while (env);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer from <indirect:living'person'>", (: do_buy($1) :) });
}
int query_theft_command() {
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/g_lance.c ===
#include <obj_parser.h>
#include <dirs.h>
#include <player.h>
inherit "/cmds/base";
int check_exists(string file);
string room_glance(object person, object room, int dark);
mixed cmd_direction(string dir);
int check_pre_stuff() {
   int dark;
   object room;
   room = environment(previous_object());
   if (!room) {
      return notify_fail("You are in limbo... sorry you can't look at "+
             "anything.\n");
   }
   if (!previous_object()->query_property("dead")) {
      dark = (int)previous_object()->check_dark((int)room->query_light());
   }
   if( dark < 0 ) {
      write("It's too dark to look at anything.\n");
      return 1;
   } else if( dark > 0 ) {
      write("It's too bright to look at anything.\n");
      return 1;
   }
   return 2;
}
mixed cmd_ob(object* obs) {
   object thing;
   int retval;
   int dark;
   object room;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   foreach (thing in obs) {
      string tmp;
      if(thing == this_player()) {
        write("That's you that is.\n");
      } else {
        tmp = (string)thing->a_short( dark );
        if (tmp) {
          write(capitalize(tmp) + ".\n");
        }
      }
   }
   return 1;
}
mixed cmd_direction(string dir, int from_string) {
   object room;
   int dark;
   int retval;
   string ret;
   string dest;
   mixed *func;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   retval = 0;
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dir = EXPAND_EXIT(dir);
   if ( room->query_relative( dir ) ) {
      add_failed_mess( "You do not think that the "+ dir +" is here.\n" );
      return 0;
   }
   dir = (string)this_player()->find_abs(dir);
   if(room->query_exit(dir)) {
      room->set_destination( dir );
      if ( check_exists( (string)room->query_destination( dir ) ) ) {
         write("You glance " + dir + " and see:\n");
         ret = room->query_look(dir);
         if (ret) {
            write(ret+"\n");
            return 1;
         }
         func = room->query_look_func(dir);
         if(sizeof(func)) {
            call_other(func[0], func[1], 1);
            return 1;
         }
         dest = room->query_destination(dir);
         if(room->query_door_open(dir) != 0) {
            if (!dark && !previous_object()->query_property("dead") &&
                !previous_object()->query_creator()) {
               dark = previous_object()->check_dark(dest->query_light());
            }
            load_object(dest);
            this_player()->set_looked( find_object( dest ) );
            if (dark) {
               write("It's too dark to see that far.\n");
            } else  {
               write( (string)dest->a_short( dark ) +" "+
                     (string)dest->query_short_exit_string()+".\n"+
                     (string)dest->query_contents(""));
            }
            return 1;
         } else if(room->query_door_open(dir) == 0) {
            write("The "+dir+" door is closed.\n");
         }
      }
   }
   if (!retval) {
      add_failed_mess("You do not think that the "+dir+" is here.\n");
   }
   return retval;
}
string room_glance(object person, object room, int dark) {
   string ret;
   string sees;
   object mirror;
   ret = "";
   if (person->query_creator()) {
      ret += " %^CYAN%^" + file_name(room) + "%^RESET%^";
      sees=(string)room->query_property("creator sees");
      if (sees) {
         ret += sees +"\n"+ (string)room->query_contents();
      }
   }
   mirror = room->query_mirror_room();
   if (mirror) {
      room = mirror;
   }
   if(!dark || previous_object()->query_creator()) {
      if (mirror) {
         ret += ".\n" + (string)mirror->query_contents();
      } else {
         ret += (string)room->query_short_exit_string()+".\n"+
           (string)room->query_contents();
      }
   } else if((dark == 2) || (dark == -2)) {
      if (!mirror) {
         ret += (string)room->query_short_exit_string()+"\n";
      } else {
         ret += "\n";
      }
      if((string)room->query_contents("") != "") {
         ret += person->colour_event("inventory", "%^GREEN%^") +
           "Some objects you can't make out are here.%^RESET%^\n";
      }
   } else {
      ret += "\n";
   }
   if (dark == 1 || dark == -1) {
      ret += "You can't see your hand in front of your face.\n";
   } else  {
      ret = "$a_short:"+ file_name(room) + "$"+ ret;
   }
   if (mirror) {
      ret += "Around " + room->the_short() + " is:\n";
      ret += room_glance(person, mirror, dark);
   }
   return ret;
}
int cmd_here() {
   object room;
   int dark;
   int retval;
   string str;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dark = previous_object()->check_dark((int)room->query_light());
   str = room_glance(previous_object(), room, dark);
   write(str);
   return 1;
}
int check_exists(string file) {
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    return 1;
  }
  return 0;
}
mixed* query_patterns() {
   return ({
             "", (: cmd_here() :),
             "exit <string'exit'>", (: cmd_direction($4[0], 1) :),
             "[at] <indirect:object>", (: cmd_ob($1) :),
             "<string'exit'>", (: cmd_direction($4[0], 0) :),
            });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/kill.c ===
#include <player.h>
inherit "/cmds/base";
int cmd( object* things ) {
   object thing;
   object *fighting;
   if ( !environment( this_player() ) ) {
      add_failed_mess( "You are in limbo...\n" );
      return 0;
   }
   if ( this_player()->no_offense() ) {
      add_failed_mess( "You cannot attack anyone at the moment.\n" );
      return 0;
   }
   things -= ({ this_player() });
   if ( !sizeof( things ) ) {
      add_failed_mess( "You shouldn't beat yourself up so much.\n");
      return 0;
   }
   foreach ( thing in things ) {
      if ( !userp( thing ) ) {
         if ( userp( this_player() ) ||
               !thing->query_property( "no attack" ) ) {
            this_player()->attack_ob( thing );
            thing->attack_by(this_player());
         }
         continue;
      }
      if ( !interactive( thing ) ) {
         write( (string)thing->the_short() +" is net-dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "guest" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +" is a guest.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "dead" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +
                " is already dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_auto_loading() ) {
         write( "Be sporting; "+ (string)thing->the_short() +
               " doesn't have "+ (string)thing->query_possessive() +
               " equipment yet.\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
           !this_player()->query_player_killer() ) {
         write( "You cannot summon the courage to attack "+
               (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
            !thing->query_player_killer() ) {
         write( "Something tells you that it would be wrong "
               "to attack "+ (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      call_out( (: this_player()->attack_ob( $(thing) ) :), 0);
      call_out( (: $(thing)->attack_by(this_player()) :), 0);
   }
    if ( sizeof( things ) ) {
      fighting = ({ });
      foreach(thing in things) {
        object *list;
        list = thing->query_attacker_list();
        if (arrayp(list)) {
           fighting += list;
        }
      }
      if(sizeof(fighting))
        fighting = filter(uniq_array(fighting),
                          (: $1 && environment($1) != environment(this_player()) :));
      if(!sizeof(fighting))
        this_player()->add_succeeded_mess(this_object(),
                                          ({ "You prepare to attack " + query_multiple_short(things) + ".\n", "" }), ({ }) );
      else
        this_player()->add_succeeded_mess(this_object(),
					  ({ "You prepare to attack " + query_multiple_short(things) + " who " + (sizeof(things) > 1 ? "are" : "is") + " already hunting " + query_multiple_short(fighting) + ".\n", "" }), ({ }) );
        return 1;
    } else {
        add_failed_mess("");
        return 0;
    }
}
mixed *query_patterns() {
   return ({ "<indirect:living:here>", (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/draw.c ===
#include <move_failures.h>
#include <obj_parser.h>
#define DEFAULT -1
#define LEFT 0
#define RIGHT 1
inherit "/cmds/base";
int cmd( string weapon_str, object * scabbards, string hand_str ) {
   object scabbard, * weapons, weapon;
   class obj_match match;
   string *limbs;
   string *hands;
   int *what_in;
   int targeted, result;
   int hand;
   match = new( class obj_match );
   targeted = scabbards ? 1 : 0;
   debug_printf( "targeted = %d\nscabbards = %O\n", targeted, scabbards );
   if( !scabbards ) {
      scabbards = filter( all_inventory( this_player() ),
        (: $1->query_scabbard() :) );
      if( !sizeof(scabbards) ) {
         add_failed_mess( "Can't find any scabbards in your inventory.\n" );
         return 0;
      }
      foreach( scabbard in scabbards ) {
         match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
           0, this_player() );
         result = match->result;
         if( result == OBJ_PARSER_SUCCESS ) {
            weapons = match->objects;
            break;
         } else if( result == OBJ_PARSER_AMBIGUOUS ) {
            add_failed_mess( "Ambiguous reference to \"" + weapon_str
              + "\" in at least one scabbard.\n" );
         }
      }
      if( !sizeof(weapons) ) {
         add_failed_mess( "Cannot find " + weapon_str + " in any "
           "scabbard in your inventory.\n" );
         return 0;
      }
   } else {
      if( sizeof(scabbards) > 1 ) {
         add_failed_mess( "You can only draw from one scabbard at a "
           "time.\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not a scabbard.\n" );
         return 0;
      }
      if ( environment(scabbard) != this_player() ) {
         add_failed_mess( "You can only draw from a scabbard in your "
           "inventory.\n" );
         return -1;
      }
      match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
        0, this_player() );
      if( match->result == OBJ_PARSER_SUCCESS ) {
         weapons = match->objects;
      } else {
         add_failed_mess( "Cannot find " + weapon_str + " in " +
           scabbard->the_short() + ".\n" );
         return -1;
      }
   }
   weapon = weapons[0];
   if ( scabbard->query_closed() ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + "; it is closed.\n" );
      return targeted ? -1 : 0;
   }
   if( !scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if ( weapon->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  hand = -1;
   else hand = member_array(hand_str, this_player()->query_limbs());
   if ( !sizeof( weapon->hold_item( this_player(), hand ) ) ) {
      weapon->move( scabbard );
      add_failed_mess( "You cannot hold " + weapon->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  {
      limbs = this_player()->query_limbs();
      what_in = find_member(weapon, this_player()->query_holding());
      hands = allocate(sizeof(what_in));
      for (hand = 0; hand < sizeof(what_in); hand++)
         hands[hand] = limbs[what_in[hand]];
      hand_str = query_multiple_short(hands);
   }
   this_player()->add_succeeded_mess(scabbard, "$N $V $I from $D into $p " +
                                     hand_str + ".\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   string limbs;
   limbs = "{" + implode(this_player()->query_limbs(), "|") + "}";
   return ({
      "<string'weapon'>",
        (: cmd( $4[0], 0, 0 ) :),
      "<string'weapon'> from <indirect:object:me'scabbard'>",
        (: cmd( $4[0], $1, 0 ) :),
      "<string'weapon'> into [my] " + limbs,
        (: cmd($4[0], 0, $4[1]) :),
      "<string'weapon'> from <indirect:object:me'scabbard'> into [my] " + limbs,
        (: cmd( $4[0], $1, $4[2]) :),
   });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/withdraw.c ===
#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int withdraw_offer(object *sell_to) {
   object *removed;
   object ob;
   removed = ({ });
   foreach (ob in sell_to) {
      if (ob->query_respond_command("sell", this_player())) {
         ob->remove_respond_command("sell", this_player());
         removed += ({ ob });
      }
   }
   if (sizeof(removed)) {
      add_succeeded_mess("$N withdraw$s $p offer of sale to $I.\n", removed);
      return 1;
   }
   add_failed_mess("You cannot withdraw your offer of sale to $I since "
                   "you have not offered to sell them anything in the "
                   "first place.\n", sell_to);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer {from|to} <indirect:living>",
             (: withdraw_offer($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/th_row.c ===
#define CREATOR "Ceres"
#include <player.h>
#include <move_failures.h>
#include <tasks.h>
#define ASKILL "fighting.combat.range.thrown"
#define DSKILL "fighting.combat.dodging.range"
#define PSKILL "fighting.combat.parry.range"
#define COMMAND_GP_COST 5
inherit "/cmds/base";
int valid_target( object target, object thrower, object item );
int cmd( mixed *indirect_obs ) {
    object target, item;
    int dchance, damage;
    if ( sizeof( indirect_obs[ 0 ] ) > 1 ) {
        add_failed_mess( "You can only throw one item at a time!\n" );
        return 0;
    }
    item = indirect_obs[ 0 ][ 0 ];
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You can only throw $I at one target at a time!\n",
            ({ item }) );
        return 0;
    }
    target = indirect_obs[ 1 ][ 0 ];
    if ( item->query_wielded() != this_player() ) {
        add_failed_mess( "You must be holding $I to throw it.\n",
            ({ item }) );
        return 0;
    }
    if ( this_player() == target ) {
        add_failed_mess( "You cannot throw $I at yourself!\n", ({ item }) );
        return 0;
    }
    if ( !living( target ) && !target->query_property( "targetable" ) ) {
        add_failed_mess( "Why do you want to throw $I at " +
            target->the_short() + "?\n", ({ item }) );
        return 0;
    }
    if (this_player()->query_gp() < COMMAND_GP_COST) {
        add_failed_mess( "You need " + COMMAND_GP_COST + " points to "
            "throw " + item->the_short() + " at " + target->the_short() +
            ".\n");
        return 0;
    }
    if ( !valid_target( target, this_player(), item ) ) {
        add_failed_mess( "You decide against throwing $I at " +
            target->the_short() + ".\n", ({ item }) );
        return 0;
    }
    if ( living( target ) ) {
        switch ( (string)target->query_combat_response() ) {
            case "dodge" :
                dchance = target->query_skill_bonus( DSKILL );
            break;
            default:
                dchance = target->query_skill_bonus( PSKILL );
        }
    }
    else {
        dchance = target->query_property( "targetable" );
    }
    dchance += item->query_weight() / ( this_player()->query_str() / 2 );
    if( !this_player()->query_visible( target ) ) {
        dchance /= 2;
    }
    this_player()->adjust_gp(-COMMAND_GP_COST);
    switch( TASKER->perform_task(this_player(), ASKILL, dchance, TM_FREE) ) {
        case AWARD:
            tell_object(this_player(), "%^YELLOW%^You feel that your "
                "skill in throwing weapons has increased.%^RESET%^\n");
        case SUCCEED:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " and hit!\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                    " at " + target->the_short() + " and hits!\n",
                    this_player() );
            if ( living( target ) ) {
                damage = ( item->query_weight() / 4 ) +
                    ( this_player()->query_str() * 2) +
                    ( this_player()->query_skill_bonus( ASKILL ) / 3 );
                damage -= target->query_ac( "blunt", damage );
                target->attack_by( this_player() );
                target->adjust_hp( -damage, this_player() );
                this_player()->attack_ob( target );
                event( item, "thrown", this_player(), target );
                    this_player()->adjust_time_left(-(ROUND_TIME*2));
            }
            target->thrown_at( this_player(), 1, item );
            if ( item->move( target ) != MOVE_OK ) {
                item->move( environment( target ) );
            }
        break;
        default:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " but miss.\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                " at " + target->the_short() + " but misses.\n", this_player() );
            item->move( environment( target ) );
            if( !interactive( target ) && living( target ) ) {
                this_player()->attack_ob( target );
                target->attack_by( this_player() );
            }
            target->thrown_at( this_player(), 0 );
        break;
    }
    return 1;
}
int valid_target( object target, object thrower, object item ) {
    mixed owner;
    if ( target->query_property( "dead" ) || target->query_auto_loading() ) {
        return 0;
    }
    if ( userp( target ) && !interactive( target ) ) {
        return 0;
    }
    if ( pk_check( thrower, target ) )
        return 0;
    if ( ( owner = target->query_owner() ) && pk_check( thrower, owner ) ) {
        return 0;
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me'weapon'> at <indirect:object'target'>",
        (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/offer.c ===
#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int offer_sale(object *to_sell, object *sell_to, string amt, int each) {
   int value;
   int num;
   string *fluff;
   string place;
   string *gumboot;
   object *fail;
   class offer_sale wombat;
   fluff = MONEY_HAND->query_all_places();
   gumboot = ({ });
   foreach (place in fluff) {
      value = MONEY_HAND->value_from_string(amt, place);
      if (value) {
        gumboot += ({ place });
      }
   }
   if (!sizeof(gumboot)) {
      add_failed_mess("Unable to understand the value of " + amt + ".\n",
                      to_sell);
      return 0;
   }
   if (member_array("Ankh-Morpork", gumboot) != -1) {
      gumboot = ({ "Ankh-Morpork" });
   }
   if (sizeof(gumboot) > 1) {
      add_failed_mess("Too many types of currency matched, matched currency "
                      "from " + query_multiple_short(gumboot) + ", try and "
                      "be more specific.  ie:  Ankh-Morpork dollars, not just "
                      "dollars.\n",
                      to_sell);
      return 0;
   }
   fail = this_player()->query_ignoring(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since you are "
                         "ignoring them.\n", fail);
         return 0;
      }
   }
   fail = this_player()->query_ignored_by(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since they are "
                         "ignoring you.\n", fail);
         return 0;
      }
   }
   place = gumboot[0];
   value = MONEY_HAND->value_from_string(amt, place);
   if (value < 0) {
      add_failed_mess("The value of the item was set too high.\n");
      return 0;
   }
   if (sizeof(sell_to) > 1) {
      add_failed_mess("Attempted to sell to $I, cannot sell to more than "
                      "one person.\n", sell_to);
      return 0;
   }
   if (sell_to[0] == this_player()) {
      add_failed_mess("You cannot sell $I to yourself.\n", to_sell);
      return 0;
   }
   if (each) {
      num = 0;
      foreach(object item in to_sell) {
          if ( item->query_collective() || item->query_continuous() ) {
             num += item->query_amount();
          }
          else {
             num++;
          }
      }
      value = value * num;
   }
#ifdef CHECK_MONEY
   if (sell_to[0]->query_value_in(gumboot[0]) < value) {
      add_failed_mess(sell_to[0]->the_short() + " does not have enough money "
                      "to buy $I.\n", to_sell);
      return 0;
   }
   if (!MONEY_HAND->query_person_payments(value, gumboot[0], sell_to[0], this_player())) {
      add_failed_mess(sell_to[0]->the_short() + " does not have the correct "
                      "change to pay " +
                      MONEY_HAND->money_value_string(value, gumboot[0]) +
                      " (and you do not have change to give back).\n");
      return 0;
   }
#endif
   wombat = new(class offer_sale);
   wombat->sell_obs = to_sell;
   wombat->seller = this_player();
   wombat->buyer = sell_to[0];
   wombat->value = value;
   wombat->place = gumboot[0];
   sell_to->add_respond_command("sell", this_player(), wombat);
   tell_object(sell_to[0],
               "You can accept the offer by typing:\n"
               "accept offer from " + this_player()->query_name() + "\n");
   add_succeeded_mess("$N offer$s to sell $I to " + sell_to[0]->the_short() +
                      " for " + MONEY_HAND->money_value_string(value,
                                            gumboot[0]) + ".\n", to_sell);
   return 1;
}
mixed *query_patterns() {
   return ({
 "<indirect:object:me'sell object'> to <indirect:living> for <string>",
             (: offer_sale($1[0], $1[1], $4[2], 0) :),
 "<indirect:object:me'sell object'> to <indirect:living> for <string> each",
             (: offer_sale($1[0], $1[1], $4[2], 1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/echoto.c ===
#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string who, what;
  object ob;
  if(!TP->query_creator() && !TP->query_property("echoto"))
    return notify_fail(NOT_ALLOWED);
  if(!str || str == "")
    return notify_fail("Syntax : echoto <player> <text>\n");
  if(sscanf(str, "%s %s", who, what) != 2)
    return notify_fail("Syntax : echoto <player> <text>\n");
  who = lower_case(who);
  who = (string)TP->expand_nickname(who);
  if(!TP->query_creator() && TP->adjust_sp(-ECHOTO_COST) < 0)
    return notify_fail(NO_POWER);
  ob = find_player(who);
  if(!ob)
    return notify_fail("Can't find "+who+".\n");
  if (TP->query_volume(D_ALCOHOL))
    what = TP->drunk_speech(what);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos "+
     "to "+who+": "+what+"\n" );
  what += "%^RESET%^";
  my_mess("You echo to " + who + ": ", what);
  event(ob, "player_echo_to", what + "\n", TP);
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/swim.c ===
inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("swim", "around", SWIMMING);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/drag.c ===
#include <player.h>
#include <room.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd( object *indirect_obs, string direction) {
  string owner;
  object owner_ob;
  string *words, word;
  if( this_player()->query_property( "dead" ) )
    return add_failed_mess( "You're dead.  You can't drag anything.\n" );
  if( objectp( (object)this_player()->query_dragging() ) )
    return add_failed_mess( "You're already dragging something.\n" );
  if( sizeof( indirect_obs ) > 1 )
    return add_failed_mess( "You can only drag one thing at a time.\n" );
  if( indirect_obs[0] == this_player() )
    return add_failed_mess( "You try and drag yourself away from the keyboard, "
      "but you cannot.  Oh no!\n");
  if( living( indirect_obs[ 0 ] ) ) {
    if( !indirect_obs[ 0 ]->query_property( PASSED_OUT_PROP )
        || pk_check( indirect_obs[ 0 ], this_player() ) )
      return add_failed_mess( (string)indirect_obs[ 0 ]->the_short() +
        " doesn't want to be dragged away, thank you very much.\n" );
  } else
    if( base_name(indirect_obs[0]) == "/obj/corpse" ) {
      owner = indirect_obs[ 0 ]->query_owner();
      words = explode( lower_case( owner ),  " " );
      words = filter( words, (: PLAYER_HANDLER->test_user($1) :) );
      foreach( word in words ) {
          owner_ob = find_player( lower_case( word ) );
          if( owner_ob && userp( owner_ob ) &&
            pk_check( owner_ob, this_player() ) &&
            member_array ( this_player()->query_name(), indirect_obs[0]->
            query_permitted() ) == -1 )
            return add_failed_mess( "For some reason, you can't get hold of "+
              (string)indirect_obs[ 0 ]->the_short() +".\n" );
      }
  }
  if( ( environment( indirect_obs[ 0 ] ) != environment( this_player() ) ) ||
    indirect_obs[ 0 ]->get() )
      return add_failed_mess( "For some reason, you can't get hold of " +
        (string)indirect_obs[ 0 ]->the_short() +".\n" );
  write( "You get hold of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->one_short() + " gets hold of " +
    (string)indirect_obs[ 0 ]->a_short() + ".\n" );
  if( (int)indirect_obs[ 0 ]->query_complete_weight() +
    (int)this_player()->query_loc_weight() > 2 *
    (int)this_player()->query_max_weight() ) {
      write( "You struggle and strain, but you can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
      say( (string)this_player()->one_short() + " struggles and strains, but " +
        (string)this_player()->query_pronoun() + " can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
  } else {
    this_player()->set_dragging( indirect_obs[ 0 ] );
    if( !this_player()->exit_command( direction ) )
      write( "You can't drag " + (string)indirect_obs[ 0 ]->the_short() +
        " that way.\n" );
    else
      if( interactive( this_player() ) )
        indirect_obs[0]->add_property( "dropped",
          ({this_player()->query_name(), query_ip_number( this_player() ),
          time()}), 1800 );
    this_player()->reset_dragging();
  }
  write( "You let go of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->the_short() + " releases " +
    (string)this_player()->query_possessive() + " hold of " +
    (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  return 1;
}
mixed *query_patterns() {
  return
    ({ "<indirect:object:here> [to] <word'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :),
       "<indirect:object:here> [to] <string'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/unh_old.c ===
inherit "/cmds/base";
#define TP this_player()
int cmd(object obs) {
  object *ok, *zip, *failed, ob, *using;
  string s;
  mixed ret;
  using = TP->query_holding();
  failed = ok = zip = ({ });
  foreach (ob in obs) {
    if (member_array(ob, using) != -1) {
      if (!sizeof(ret = TP->set_unhold(ob)) || !ret)
        failed += ({ ob });
      else
        ok += ({ ob });
    }
    else
      zip += ({ ob });
  }
  if (!sizeof(ok)) {
    s = "";
    if (sizeof(failed))
      s += "Could not unhold "+query_multiple_short(failed)+".\n";
    if (sizeof(zip))
      s += capitalize("You are not holding " +
                      query_multiple_short(zip, "the") + ".\n");
    return notify_fail(s);
  }
  tell_object(TP, "You put down "+(s = query_multiple_short(ok))+".\n");
  tell_room(environment(TP), TP->one_short()+" puts down "+s+".\n", TP);
  TP->force_burden_recalculate();
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/whi_sper.c ===
inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd( object *others, string last ) {
  class message mess;
  if (sizeof(others) == 1 && others[0] == this_player()) {
     add_failed_mess("Whispering to yourself?  Neat trick.\n");
     return 0;
  }
  mess = build_message(last, others, "whisper");
  mess->type = "whisper";
  return say_it_to(mess, others, 1, "whisper");
}
mixed *query_patterns() {
   return ({ "<string'message'> to <indirect:living>", (: cmd($1, $4[0]) :),
             "<indirect:living> <string'message'>", (: cmd($1, $4[1]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/dry.c ===
inherit "/cmds/base";
mixed cmd(mixed *things)
{
   int pwet;
   int twet;
   int max;
   int *enums;
   object thing;
   object with;
   thing = things[0][0];
   with = things[1][0];
   if (!with->id("towel") && !with->query_property("dryer")) {
      return notify_fail("You can't dry anyone with " +
                         (string) with->the_short() + ".\n");
   }
   if (environment(with) != this_player())  {
      return notify_fail(with->a_short() + " isn't going to do much good "
         "inside " + environment(with)->a_short() + ".\n");
   }
   if (thing->query_property("dead")) {
      return notify_fail((string) thing->the_short() + " is dead; " +
                         (string) thing->query_pronoun() +
                         " has more immediate problems than being wet.\n");
   }
   max = 200 * (int) with->query_weight();
   enums = (int *) with->effects_matching("object.wet");
   if (sizeof(enums)) {
      twet = (int) with->arg_of(enums[0]);
   }
   if (twet > max / 2) {
      return notify_fail((string) with->the_short() +
                         " is already dripping wet.  You can't dry anybody "
                         "with it.\n");
   }
   enums = (int *) thing->effects_matching("body.wetness");
   if (sizeof(enums)) {
      pwet = (int) thing->arg_of(enums[0]);
   }
   if (pwet < 10) {
      if (thing == this_player()) {
         return notify_fail("You don't need drying.\n");
      } else {
         return notify_fail((string) thing->the_short() +
                            " doesn't need drying.\n");
      }
   }
   if (pwet + twet > max) {
      pwet = max - twet;
   }
   pwet -= random(10);
   if (pwet > 0) {
      thing->add_effect("/std/effects/other/wetness", -pwet);
      with->add_effect("/std/effects/object/wet", pwet);
   }
   if (thing == this_player()) {
      write("You dry yourself with " + with->the_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) this_player()->query_objective() + "self with " +
          (string) with->poss_short() + ".\n");
   } else {
      write("You dry " + (string) thing->the_short() + " with " +
            (string) with->the_short() + ".\n");
      tell_object(thing, (string) this_player()->one_short() +
                  " dries you with " + (string) with->poss_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) thing->the_short() + " with " +
          (string) with->poss_short() + ".\n", thing);
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:living'person'> with <indirect:object:me>",
             (: cmd($1) :),
             "myself with <indirect:object:me>",
             (: cmd(({ ({ this_player() }), $1 })) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/emoteall.c ===
#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
#define BEEP sprintf("%c",7)
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("emoteall")) {
    return notify_fail(NOT_ALLOWED);
  }
  if(!str || str == "") {
    return notify_fail("Syntax : emoteall <string>\n");
  }
  if(!TP->query_creator() &&
     TP->adjust_sp(-EMOTEALL_COST*((strlen(str)/10)+1)+100) < 0) {
    return notify_fail(NO_POWER);
  }
  str = replace(str, BEEP, "");
  if (TP->query_volume(D_ALCOHOL)) {
    str = TP->drunk_speech(str);
  }
  log_file("ECHOS", ctime(time())+" "+TP->query_name()+" emotes "+
           "to all: "+str+"\n");
  str += "%^RESET%^";
  my_mess("You emoteall : ", TP->query_cap_name()+" " + str);
  TP->comm_event(users(), "player_emote_all", "%^BOLD%^%^RED%^" + TP->query_cap_name() + " " + str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/flip.c ===
#include <money.h>
#define EFFECTS "/obj/handlers/mag_eff_handler"
inherit "/cmds/base";
mixed cmd( object *things ) {
   int *effect;
   object place;
   mixed *stuff, *details;
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only flip one thing at once.\n");
      return 0;
   }
   stuff = (mixed *)things[ 0 ]->query_money_array();
   if ( !sizeof( stuff ) ) {
      add_failed_mess( "You must have a coin to flip.\n" );
      return 0;
   }
   if ( ( sizeof( stuff ) > 2 ) || ( stuff[ 1 ] != 1 ) ) {
      add_failed_mess( "You can only flip one coin at a time.\n" );
      return 0;
   }
   details = (mixed *)MONEY_HAND->query_details_for( stuff[ 0 ] );
   if ( details[ MONEY_DETAILS_COMPOSITION ] == "paper" ) {
       add_failed_mess( "You cannot flip $I as you would a coin, because "
        "it is made of paper.\n", things );
       return -1;
   }
   write( "You flip "+ (string)things[ 0 ]->the_short() +".\n" );
   say( (string)this_player()->one_short() +" flips "+
         (string)things[ 0 ]->a_short() +".\n" );
   effect = (int *)EFFECTS->choose_effect(
         (int)EFFECTS->ambient_enchantment( things[ 0 ] ) );
   place = environment( this_player() );
   if ( random( 1000 ) < effect[ 0 ] ) {
      switch( effect[ 1 ] ) {
         case 0 :
            things[ 0 ]->move( place );
            tell_room( place, (string)things[ 0 ]->the_short() +
                  " lands on its edge.\n" );
            break;
         default :
            things[ 0 ]->move( "/room/rubbish" );
      }
      EFFECTS->do_effect( effect[ 1 ], (string)things[ 0 ]->the_short(),
            place );
      return 1;
   }
   things[ 0 ]->move( place );
   tell_room( place, (string)things[ 0 ]->the_short() +" falls "+
         (string)place->query_property( "here" ) +", "+
         details[ random( 2 ) ] +" up.\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/give.c ===
#include <move_failures.h>
#include <player.h>
inherit "cmds/base";
#define TP this_player()
#define SUPPRESS_MESS "suppress give messages"
mixed cmd(mixed *indir, string *indir_match) {
  string sh;
  string s1;
  string failmess;
  int tot;
  int max;
  int ok;
  object *per;
  object *ret;
  object *fail;
  object pobj;
  object ob;
  object *obs;
  object *succ;
  object *keep;
  per = indir[1];
  succ = ({ });
  keep = ({ });
  failmess = "";
  foreach(pobj in per) {
    obs = indir[0];
    obs -= per;
    if (pobj->query_property("player") && !interactive(pobj)) {
      failmess = pobj->the_short()+" seems too chalky to accept your "
        "gift.\n";
      continue;
    }
    if (pobj == TP) {
     failmess = "You nag yourself for a while, but can't convince "
                 "yourself to accept things from yourself.\n";
     continue;
    }
    if (!sizeof(obs)) {
      failmess = "Nothing to give to "+ pobj->short() +".\n";
      continue;
    }
    ret = ({ });
    fail = ({ });
    foreach(ob in obs) {
      if ( member_array( ob, succ ) > -1 ) {
        continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      if (function_exists("do_give", ob) ||
          function_exists("command_control", ob)) {
        if (function_exists("do_give", ob)) {
          max = call_other(ob, "do_give", pobj, indir_match[0],
                                indir_match[1],
                                ({ indir_match[0], indir_match[1] }),
                                "<direct:object:me> to <indirect:living>");
        } else {
          max = ob->command_control("give", pobj, indir_match[0],
                                    indir_match[1],
                                    ({ indir_match[0], indir_match[1] }),
                                    "<direct:object:me> to <indirect:living>");
        }
        if (max == 0)  {
          fail += ({ ob });
          continue;
        }
      }
#ifndef __DISTRIBUTION_LIB__
      PLAYER_MULTIPLAYER_HANDLER->record_object("give", TP, ob);
      if(pobj->query_property("player") && interactive(TP) &&
         "/obj/handlers/multiplayer"->check_multiplayers("give", pobj, ob)) {
        fail += ({ ob });
      } else
#endif
      if (pobj->query_closed()  ||  ob->move(pobj) != MOVE_OK) {
        fail += ({ ob });
      } else  {
        ret += ({ ob });
        tot += ob->query_weight();
      }
    }
    if (sizeof(ret)) {
      ok = 1;
      succ += ret;
      if (pobj->query_clothing()) {
        s1 = pobj->query_pocket_mess();
      } else {
        s1 = "$ob_short$";
      }
      sh = query_multiple_short(ret);
      if ( interactive( pobj ) || !pobj->query_property( SUPPRESS_MESS ) ) {
        tell_object(TP, "You give "+ sh +" to "+
                  replace_string(s1, "$ob_short$", pobj->one_short())+
                  ".\n");
        tell_room(environment(TP), TP->one_short() + " gives " + sh +
               " to " + replace_string(s1, "$ob_short$",
                                      pobj->one_short()) +
               ".\n", ({ TP, pobj }));
        tell_object(pobj, capitalize(TP->one_short() ) + " gives "+
                    sh + " to you.\n" );
      }
      if (living(pobj) && (max = pobj->query_max_weight()))
        if ((max = tot*100/max) > 25)
          if (max >= 95) {
            tell_room(environment(TP),
                      pobj->the_short()+" staggers under a weight "+
                      pobj->query_pronoun()+" can only just carry.\n",
                      ({ pobj }) );
            pobj->event_say(TP, "You stagger under a weight you can only "
                            "just carry.\n");
          } else {
            tell_room(environment(TP), pobj->the_short()+ ({
              " is only mildly discomforted by the additional weight.\n",
              " braces "+pobj->query_objective()+"self to take the load.\n",
              " stumbles as "+pobj->query_pronoun()+" takes the load.\n"
              })[(max/25)-1], ({ pobj }) );
            pobj->event_say(TP, "You"+ ({
              " are only mildly discomforted by the additional weight.\n",
              " brace yourself under the load.\n",
              " stumble as you take the load.\n"
              })[(max/25)-1]);
          }
    }
    if (sizeof(fail)) {
      failmess += "You cannot give "+query_multiple_short(fail)+ " to "+
                  pobj->one_short() +".\n";
    }
  }
  if (!ok) {
    add_failed_mess(failmess);
    if (sizeof(keep)) {
       add_failed_mess("You have $I set to be kept.\n", keep);
    }
  }
  return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me> to <indirect:living>",
            (: cmd($1, $3) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/lsay.c ===
#include <language.h>
#include <player.h>
#include <drinks.h>
#include <broadcaster.h>
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(string arg) {
  int *co_ords;
  int status;
  class message mess;
  if (!arg)  arg = "";
  mess = build_message("@loudly " + arg, 0, "say");
  status = say_it(mess);
  if(status && TP && environment(TP))  {
    co_ords = environment(TP)->query_co_ord();
    BROADCASTER->npc_shout_event(TP, mess->notify_mess, mess->text,
                                 mess->language, co_ords, 20);
  }
  return status;
}
mixed *query_pattern() {
   return ({ "<string'message'>", (: cmd($4[0]) :) });
}
