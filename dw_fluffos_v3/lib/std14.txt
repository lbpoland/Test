
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/general_shop.c ===
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shop.h>
#include <tasks.h>
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/open_shop";
private mixed our_storeroom;
private mixed buy_mess;
private mixed sell_mess;
private mixed list_mess;
private mixed value_mess;
private mixed too_costly_mess;
private mixed not_worthy_mess;
private mixed browse_mess;
private mixed *other_shops;
private int amount_sold;
private int amount_bought;
private int strict_shop;
private int no_steal;
private int sell_stolen;
private int steal_difficulty;
private int min_amount;
private int max_inventory;
private int sell_large;
private mixed shop_type;
private mixed buy_func;
private mixed sell_func;
private mixed value_func;
private mixed too_costly_func;
private mixed cannot_sell_func;
private mixed browse_func;
private mixed list_func;
private nosave string shoplift_handler;
private string original_storeroom;
private int _strict_currency;
private nosave mapping elist = (["north" : "south", "south" : "north",
  "east" : "west", "west" : "east", "up" : "down", "down" : "up"]);
string shop_list(mixed arr, int detail);
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which);
string find_free_exit();
int do_buy(object *ob);
int do_list_these(object *obs);
void do_buy_things( object *obs, int cost, object pl );
void do_parse(mixed arr, mixed ob, object client, string money,
  string extra);
object create_mercenary(object rep);
void event_shoplift(object command_ob, object thief, object victim);
object query_store_room();
int creator_object (object);
void create() {
    buy_mess = ({
      "You buy $ob$ for $money$.\n",
      "$client$ buys $ob$.\n"});
    sell_mess = ({
      "You sell $ob$ for $money$.\n",
      "$client$ sells $ob$.\n"});
    list_mess = "$extra$";
    value_mess = "$ob$ is valued at $money$.\n";
    too_costly_mess = "$ob$ is worth too much to be sold here.\n";
    not_worthy_mess = "$ob$ is not worth enough to be sold here.\n";
    browse_mess = "$ob$ costs $money$, it looks like:\n$extra$";
    other_shops = ({ });
    max_inventory = MAX_INVENTORY;
    min_amount = 50;
    add_help_file("shop");
    _strict_currency = 1;
    ::create();
}
void reset() {
    if(!random(3)) {
        remove_property("inventory_loss");
    }
    call_out("send_out_reps", 2);
}
void set_buy_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        buy_func = func;
    }
}
void set_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        sell_func = func;
    }
}
void set_value_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        value_func = func;
    }
}
void set_too_costly_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        too_costly_func = func;
    }
}
void set_cannot_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        cannot_sell_func = func;
    }
}
void set_browse_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        browse_func = func;
    }
}
void set_list_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        list_func = func;
    }
}
void set_sell_message(mixed str) {
    sell_mess = str;
}
void set_buy_message(mixed str) {
    buy_mess = str;
}
void set_value_message(mixed str) {
    value_mess = str;
}
void set_too_costly_message(mixed str) {
    too_costly_mess = str;
}
void set_not_worthy_message(mixed str) {
    not_worthy_mess = str;
}
void set_browse_message(mixed str) {
    browse_mess = str;
}
void set_list_message(mixed str) {
    list_mess = str;
}
void set_open_condition(mixed str) {
   if (functionp(str)) {
      ::set_open_function(str);
   } else if (intp(str)) {
      ::set_open_function( (: $(str) :) );
   } else if (pointerp(str)) {
      ::set_open_function( (: call_other($(str[0]), $(str[1]), $1) :) );
   } if ( stringp(str) ) {
      ::set_open_function( (: call_other( this_object(), $(str), $1 ) :) );
   }
}
void set_no_steal(int i) {
    no_steal = i;
}
void set_steal_difficulty(int i) {
    steal_difficulty = i;
}
void set_sell_stolen(int i) {
    sell_stolen = i;
    no_steal = 1;
}
void set_sell_large(int i) { sell_large = i; }
mixed query_sell_mess() {
    return sell_mess;
}
mixed query_list_mess() {
    return list_mess;
}
mixed query_value_mess() {
    return value_mess;
}
mixed query_too_costly_mess() {
    return too_costly_mess;
}
mixed query_not_worthy_mess() {
    return not_worthy_mess;
}
mixed query_buy_mess() {
    return buy_mess;
}
mixed query_browse_mess() {
    return browse_mess;
}
int query_no_steal() {
    return no_steal;
}
int query_steal_difficulty(int i) {
    return steal_difficulty;
}
string query_shoplift_response_handler() {
    return shoplift_handler;
}
int query_shop() {
    return 1;
}
object *query_shop_lift_items(string str, object player) {
    return match_objects_for_existence(str, ({ query_store_room() }));
}
object shoplift_success(object ob) {
    return ob;
}
void set_shoplift_response_handler(string word) {
    shoplift_handler = word;
}
void set_min_amount(int i) { min_amount = i; }
void set_max_inventory(int i) { max_inventory = i; }
void init() {
    string room;
    ::init();
    if(stringp(our_storeroom)) {
        room = our_storeroom;
    } else if(our_storeroom) {
        room = file_name(our_storeroom);
    } else {
      tell_room(this_object(),
                "Oh dear, we don't seem to have a storeroom.\n");
    }
    add_command("sell", "<indirect:object:me>");
    add_command("buy", "<indirect:object:"+room+">");
    add_command("list", "[all]");
    add_command("list", "<indirect:object:"+room+">",
      (: do_list_these($1) :));
    add_command("browse", "<indirect:object:"+room+">");
    add_command("value", "<indirect:object:me>");
}
int query_max_amount() {
    return MAX_AMOUNT;
}
int query_min_amount() {
    return min_amount;
}
varargs int query_value(object thing, int sell) {
     if ( thing->query_property("cost here") && !sell ) {
         return (int)thing->query_property("cost here");
     }
     else {
        return (int)thing->query_value_at( this_object() );
     }
}
int scaled_value(int n) {
    int i, tot, *fish;
    fish = PAY_RATES;
    if(n < fish[0]) {
        return n;
    } else {
        tot = fish[0];
        n -= fish[0];
    }
    i = 0;
    while(n && ((i + 1) < sizeof(fish))) {
        if(n >= fish[i]) {
            tot += fish[i + 1] * fish[i] / 100;
            n -= fish[i];
        } else {
            tot += fish[i + 1] * n / 100;
            n = 0;
        }
        i += 2;
    }
    if(n) {
        tot += (n * fish[sizeof(fish) - 1]) / 100;
    }
    return tot;
}
int do_sell(object *in_obs) {
    int i, amt, total_amt;
    string place, filename, *text = ({ });
    object money, *obs, *selling, *cannot, *stolen, storeob, one_item, *cre;
    object thing;
    mixed *m_array;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    in_obs = uniq_array( in_obs );
    obs = filter_array(in_obs, (: !$1->query_keep() :));
    cre = filter (obs, (: creator_object ($1) :));
    if (sizeof (cre) && strsrch (file_name (this_object()),
      "_dev") == -1) {
      if (!this_player()->query_creator()) {
        tell_object (this_player(), "Oh dear, you shouldn't have " +
          query_multiple_short (cre) + "!  They disappear with a flash "
          "of octarine light.\n");
        cre->move ("/room/rubbish");
      }
      else {
        tell_object (this_player(), "Oh dear, you shouldn't be trying to sell " +
          query_multiple_short (cre) + "!\n");
      }
      foreach (thing in cre) {
        if ( thing->query_property( "virtual name" ) ) {
          filename = thing->query_property( "virtual name" );
        } else {
          filename = base_name (thing);
        }
        text += ({filename});
      }
      log_file ("ILLEGAL_OBJECT", sprintf ("%s: %s tried to sell %s at "
        "%s.\n\n", ctime (time()), this_player()->query_name(),
        query_multiple_short (text), file_name (this_object())));
      obs -= cre;
   }
    if(!sizeof(obs)) {
        this_player()->add_failed_mess(this_object(),
          "You previously decided to keep $I.\n", in_obs);
        return 0;
    }
    in_obs = this_player()->query_holding() + this_player()->query_armours();
    cannot = filter(obs, (: member_array($1, $2) != -1 :), in_obs);
    if (sizeof(cannot)) {
        obs -= cannot;
        tell_object(this_player(), "You decide not to sell " +
          query_multiple_short(cannot, "the") + ", because "
          "you are wearing or holding $V$0=it,them$V$.\n");
    }
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) > max_inventory) {
        this_player()->add_failed_mess(this_object(),
          "Sorry, the shop is full up and isn't buying items!\n", ({ }));
        call_out("tidy_inventory", random(20));
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS - 1];
    }
    selling = cannot = stolen = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(!sell_stolen && obs[i]->query_property("stolen")) {
            stolen += ({obs[i]});
            continue;
        } else {
            obs[i]->remove_property("stolen");
        }
        if((this_object()->query_value(obs[i], 1) > 0) &&
          !obs[i]->do_not_sell() &&
          !this_object()->do_not_buy(obs[i]) && (!strict_shop ||
            shop_type == obs[i]->query_property("shop type")) &&
          environment(obs[i]) == this_player()) {
            if(obs[i]->move(our_storeroom)) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                continue;
            }
            amt = (int)this_object()->query_value(obs[i], 1);
            if(!(obs[i]->query_property("sale_value"))) {
                amt = scaled_value( amt );
            }
            if((amt <= (int)this_object()->query_max_amount()) &&
              (amt >= (int)this_object()->query_min_amount())) {
                if(shop_type != obs[i]->query_property("shop type")) {
                    amt = (amt * 90) / 100;
                }
                total_amt += amt;
                selling += ({obs[i]});
                obs[i]->being_sold();
            } else {
                if(obs[i]->short())
                    cannot += ({obs[i]});
                obs[i]->move(this_player());
            }
        } else {
            if(obs[i]->short()) {
                cannot += ({obs[i]});
            }
        }
    }
    if (!sizeof(selling)) {
        if (sizeof(cannot)) {
            if (stringp(cannot_sell_func)) {
                call_other(this_object(), cannot_sell_func, this_player(), cannot);
            } else if (functionp(cannot_sell_func)) {
                evaluate(cannot_sell_func, this_player(), cannot);
            }
            this_player()->add_failed_mess(this_object(),
              "You cannot sell $I.\n", cannot);
        } else if(sizeof(stolen)) {
            if(sizeof(stolen) > 1) {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because they're stolen!\n", stolen);
            } else {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because it's stolen!\n", stolen);
            }
            foreach(one_item in obs) {
                if(one_item->query_property("stolen") == this_player()->query_name()) {
                    event_shoplift(this_object(), this_player(), this_object());
                    break;
                }
            }
        } else {
            this_player()->add_failed_mess(this_object(),
              "You have nothing to sell.\n", ({ }));
        }
        return 0;
    }
    if(this_object()->cannot_afford(total_amt)) {
        selling->move(this_player());
        this_player()->add_failed_mess(this_object(),
          "The shop cannot afford to buy $I from you.\n", selling);
        return 0;
    }
    amount_sold += total_amt;
    m_array = (mixed *)MONEY_HAND->create_money_array(total_amt, place);
    money = clone_object(MONEY_OBJECT);
    money->set_money_array(m_array);
    if(sizeof(cannot)) {
        if(stringp(cannot_sell_func)) {
            call_other(this_object(), cannot_sell_func, this_player(), cannot);
        } else if (functionp(cannot_sell_func)) {
            evaluate(cannot_sell_func, this_player(), cannot);
        }
        write("You cannot sell "+query_multiple_short(cannot)+".\n");
        cannot->move(this_player());
    }
    if(stringp(sell_func)) {
        call_other(this_object(), sell_func, this_player(), obs);
    } else if (functionp(sell_func)) {
        evaluate(sell_func, this_player(), obs);
    }
    do_parse(sell_mess, selling, this_player(),
      (string)MONEY_HAND->money_string(m_array), "");
    if((int)money->move(this_player()) != MOVE_OK) {
        tell_object(this_player(),
          "You're too heavily burdened to accept all that money, "
          "so the shopkeeper puts it on the floor.\n");
        money->move(this_object());
    }
    this_object()->made_transaction(-total_amt, selling);
    return 1;
}
int creator_object( object ob ) {
    string path;
    if ( file_name( ob )[0..2] == "/w/" ) {
        return 1;
    }
    if ( ( path = ob->query_property( "virtual name" ) ) &&
      path[0..2] == "/w/" ) {
        return 1;
    }
    return 0;
}
int do_buy(object *obs) {
    int i, amt, ob_amt, total_cost;
    string place;
    object money, *to_buy, *cannot, *too_much;
    object *creator_obs;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS-1];
    }
    creator_obs = filter( obs, (: creator_object( $1 ) :) );
    if ( sizeof( creator_obs ) && file_name()[0..2] != "/w/" ) {
        tell_object( this_player(), "You cannot buy " +
          query_multiple_short( creator_obs, "the" ) +
          " because they shouldn't be in the game!\n" );
        obs -= creator_obs;
    }
    to_buy = too_much = cannot = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, this_player());
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You have no money.\n", obs);
        return 0;
    }
    amt = money->query_value_in(place);
    if(place != "default" && !_strict_currency ) {
        amt += money->query_value_in("default");
    }
    while(i < sizeof(obs)) {
        ob_amt = this_object()->query_value(obs[i], 0);
        if(ob_amt > amt) {
            if(obs[i]->short()) {
                too_much += ({obs[i]});
            }
            obs = delete(obs, i, 1);
            continue;
        }
        if(obs[i]->move(this_player())) {
            if(!sell_large) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                i++;
                continue;
            } else {
                obs[i]->move(this_object());
            }
        }
        amt -= ob_amt;
        total_cost += ob_amt;
        to_buy += ({obs[i]});
        i++;
    }
    amount_bought += total_cost;
    if(sizeof(cannot)) {
        this_player()->add_failed_mess(this_object(),
          "You cannot pick up $I.\n", cannot);
    }
    if(sizeof(too_much)) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), cannot);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), cannot);
        }
        this_player()->add_failed_mess(this_object(),
          "$I costs too much.\n", too_much);
    }
    if(!sizeof(to_buy)) {
        return 0;
    }
    do_buy_things(to_buy, total_cost, this_player());
    return 1;
}
void do_buy_things(object *obs, int cost, object pl) {
    int i, j;
    string place;
    object money, change;
    mixed m_array, p_array;
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, pl);
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_object(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You don't have any money.\n", obs);
        return 0;
    }
    change = clone_object(MONEY_OBJECT);
    m_array = (int)MONEY_HAND->create_money_array(cost, place);
    for(i = 0; i < sizeof(m_array); i += 2) {
        p_array = (mixed *)MONEY_HAND->make_payment(m_array[i],
          m_array[i + 1], money, place);
        if(!pointerp(p_array)) {
            continue;
        }
        for(j = 0; j < sizeof(p_array[0]); j += 2) {
            money->adjust_money(-p_array[0][j + 1], p_array[0][j]);
        }
        change->adjust_money(p_array[1]);
    }
    do_parse(buy_mess, obs, pl,
      (string)MONEY_HAND->money_string(m_array), "");
    if(stringp(buy_func)) {
        call_other(this_object(), buy_func, pl, obs);
    } else if (functionp(buy_func)) {
        evaluate(buy_func, pl, obs);
    }
    if((int)change->move(pl) != MOVE_OK) {
        tell_object(pl, "You are too heavily burdened to accept "
          "your change, so the shopkeeper puts it on the floor.\n");
        change->move(this_object());
    }
    this_object()->made_transaction(cost, obs);
}
int do_list() {
    object ob;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(objectp(our_storeroom)) {
        ob = our_storeroom;
    } else {
        if ( original_storeroom ) {
            our_storeroom = load_object( original_storeroom );
            ob = our_storeroom;
        }
        else {
            add_failed_mess( "Please notify a creator: the storeroom for "
                "this shop cannot load or has gone missing.\n" );
            return 0;
        }
    }
    if(stringp(list_func)) {
        call_other(this_object(), list_func, this_player());
    } else if (functionp(list_func)) {
        evaluate(list_func, this_player());
    }
    do_parse(list_mess, ({ this_object() }), this_player(), "",
      shop_list(all_inventory(ob), 0));
    return 1;
}
int do_list_these(object *obs) {
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    do_parse(list_mess, ({this_object()}),
      this_player(), "", shop_list(obs, 1));
    return 1;
}
int do_browse(object *obs) {
    int i, value;
    string place;
    if (!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    if(stringp(browse_func)) {
        call_other(this_object(), browse_func, this_player(), obs);
    } else if (functionp(browse_func)) {
        evaluate(browse_func, this_player(), obs);
    }
    for(i = 0; i < sizeof(obs); i++) {
        value = (int)this_object()->query_value(obs[i], 0);
        do_parse(browse_mess, obs[i..i], this_player(),
          (string)MONEY_HAND->money_value_string(value, place),
          (string)obs[i]->long());
    }
    return 1;
}
int do_value(object *obs) {
    int i;
    int val;
    int total;
    string place;
    int obnum;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->do_not_sell() || this_object()->do_not_buy(obs[i]) ||
          (environment(obs[i] ) != this_player()) ||
          (strict_shop &&
            (shop_type != (string)obs[i]->query_property("shop type")))) {
            val = 0;
        } else {
            val = (int)this_object()->query_value(obs[i], 1);
            if (shop_type != (string)obs[i]->query_property("shop type")) {
                val = (val * 90) / 100;
            }
        }
        val = scaled_value(val);
        total += val;
        if(val > (int)this_object()->query_max_amount()) {
            do_parse(too_costly_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else if(val < (int)this_object()->query_min_amount()) {
            do_parse(not_worthy_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else {
            do_parse(value_mess, obs[i..i], this_player(),
              (string)MONEY_HAND->money_value_string(val, place),
              (string)obs[i]->do_not_sell());
            if(stringp(value_func)) {
                call_other(this_object(), value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            } else if (functionp(value_func)) {
                evaluate(value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            }
        obnum++;
        }
    }
    if (obnum > 1) {
        write("This gives you a total value of " +
          MONEY_HAND->money_value_string(total, place) +
          ".\n");
        return 1;
    }
    this_player()->add_failed_mess( this_object(), "None of your items are "
        "suitable for sale here!\n", obs );
    return obnum;
}
string shop_list(mixed arr, int detail) {
    int i, j, value, num;
    string s, mon, place, *shorts, *vals;
    object *list;
    mapping inv, costs;
    mixed ind;
    if(pointerp(arr)) {
        list = arr;
    } else {
        list = all_inventory(this_object());
    }
    inv = ([ ]);
    for(i = 0; i < sizeof(list); i++) {
        s = (string)list[i]->short();
        if(!s || !this_object()->query_value(list[i], 1)) {
            continue;
        }
        if(!stringp(s)) {
            s = "get a creator for this one!";
        }
        if(inv[s]) {
            inv[s] += ({list[i]});
        } else {
            inv[s] = ({list[i]});
        }
    }
    s = "";
    shorts = m_indices(inv);
    if(!sizeof(shorts)) {
        if(detail) {
            return "The shop is all out of what you wanted.\n";
        } else {
            return "The shop is totally out of stock.\n";
        }
    }
    s = "You find on offer:\n";
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(shorts); i++) {
        ind = inv[shorts[i]];
	num = sizeof(ind);
	if(num == 1 && ind[0]->query_collective())
	  num = ind[0]->query_amount();
        switch(num) {
        case 1:
            s += "Our very last " + shorts[i];
            break;
        case 2..5 :
            s += capitalize(query_num(num, 0)+" "+
			    (string)ind[0]->query_plural());
            break;
        default:
            if(detail) {
                s += capitalize(query_num(num, 0) + " " +
                  (string)ind[0]->query_plural());
            } else {
                s += "A large selection of "+
                (string)ind[0]->query_plural();
            }
        }
        if(detail) {
            costs = ([ ]);
            for(j = 0; j < sizeof(ind); j++) {
                value = (int)this_object()->query_value(ind[j], 0);
                mon = (string)MONEY_HAND->money_value_string(value, place);
                if(!costs[mon]) {
                    costs[mon] = ({""+(j + 1)});
                } else {
                    costs[mon] += ({""+(j + 1)});
                }
            }
            if(m_sizeof(costs) == 1) {
                s += " for "+m_indices(costs)[0];
                if(sizeof(m_values(costs)[0]) > 1) {
                    s += " each.\n";
                } else {
                    s += ".\n";
                }
            } else {
                s += ":-\n";
                vals = m_indices(costs);
                for(j = 0; j < sizeof(vals); j++) {
                    s += "  [#"+implode(costs[vals[j]], ",")+"] for "
                    +vals[j]+".\n";
                }
            }
        } else {
            s += ".\n";
        }
    }
    return s;
}
void set_store_room(mixed ob) {
    if(stringp(ob)) {
        original_storeroom = ob;
        our_storeroom = find_object(ob);
        if(!our_storeroom) {
            our_storeroom = load_object(ob);
        }
    }
    else our_storeroom = ob;
}
void guards(object tp) {
    object ob;
    if(environment(tp) != this_object() && environment(tp) != our_storeroom) {
        return;
    }
    while(!random(6)) {
        ob = create_mercenary(0);
        ob->move(environment(tp));
        ob->attack_ob(tp);
    }
}
object query_store_room() {
    return our_storeroom;
}
void do_parse(mixed arr, object *ob, object client,
  string money, string extra) {
    if(stringp(arr)) {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr,
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(), "", ob);
    } else if (functionp(arr)) {
        evaluate(arr, ob, client, money, extra);
    } else {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr[0],
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(),
          ({"", replace(arr[1], ({"$ob$", "$I", "$client$",
                "$N", "$money$", money, "$extra$", extra}))}), ob);
    }
}
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which) {
    if(sizeof(ob)) {
        str = replace(str, "$ob$", query_multiple_short(ob, which));
    } else {
        str = replace(str, "$ob$", call_other(ob, which +"_short"));
    }
    if(client) {
        str = replace(str, "$client$", client->the_short());
    }
    str = replace(str, ({"$money$", money, "$extra$", extra}));
    return str;
}
void add_other_shop(mixed shop) {
    other_shops += ({shop});
}
string query_shop_type() {
    return shop_type;
}
void set_shop_type(string ty) {
    shop_type = ty;
}
void set_strict_shop(int i) {
    strict_shop = i;
}
int query_strict_shop() {
    return strict_shop;
}
object create_rep() {
    object ob;
    ob = clone_object("/obj/monster");
    ob->set_name("rep");
    ob->set_short("sales rep");
    ob->add_adjective("sales");
    ob->set_long("This is tall strong looking sales rep.  He "
      "stares at you with bright piercing eyes.\n");
    ob->add_alias("Sales rep alias");
    ob->set_guild("fighter");
    ob->set_race("human");
    ob->adjust_bon_str(15);
    ob->set_level(60);
    ARMOURY->request_weapon("dagger", 100)->move(ob);
    ARMOURY->request_armour("cloth robe", 100)->move(ob);
    ob->init_equip();
    ob->add_property("rep type", shop_type);
    all_inventory(ob)->add_property("mine", 1);
    return ob;
}
void send_out_reps() {
    int i;
    object ob;
    for(i = 0; i < sizeof(other_shops); i++) {
        ob = (object)this_object()->create_rep();
        ob->add_property("goto destination", other_shops[i]);
        ob->add_property("goto property", "shop");
        ob->move(this_object(),
          "$N stride$s determinedly into the room.");
        ob->add_triggered_action("froggy", "goto_destination",
          file_name(this_object()), "rep_made_it");
    }
}
void rep_made_it(int bing) {
    object *obs, rep;
    int i, cost;
    if(!bing) {
        previous_object()->init_command("'Oh no!  I am utterly lost!");
        previous_object()->init_command("sigh");
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = (previous_object()->query_current_room())->query_stock(shop_type);
    if(!obs) {
        obs = ({ });
    }
    if(!sizeof(obs)) {
        this_object()->none_to_sell();
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]) {
            cost += (int)this_object()->query_value( obs[ i ], 1 ) * 2 / 3;
        }
    }
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    cost += (int)this_object()->query_value(obs[i], 1) * 2 / 3;
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    previous_object()->adjust_value(cost);
}
object create_mercenary(object rep) {
    object ob;
    string nam;
    if(rep) {
        nam = implode(rep->query_adjectives(), " ")+" "+rep->query_name();
    }
    ob = clone_object("/obj/monster");
    ob->set_name("mercenary");
    ob->add_alias("troll");
    ob->add_adjective("troll");
    ob->set_short("troll mercenary");
    ob->set_main_plural("troll mercenaries");
    ob->set_race("troll");
    ob->set_class("fighter");
    ob->set_level(200 + random(200));
    ob->set_long("This is a large, hulking troll.  He looks "
      "quite competent and capable of mashing you with or "
      "without a weapon.\n");
    if(rep) {
        ob->move(environment(rep));
        ob->do_command("follow "+nam);
        ob->do_command("protect "+nam);
        ob->add_property("merchant", rep);
    } else {
        ARMOURY->request_weapon("spiked club", 100)->move(ob);
    }
    ob->set_natural(1);
    ob->init_equip();
    ob->set_join_fights("Troll yells something incomprehensible.\n");
    ob->set_join_fight_type(0);
    return ob;
}
object *query_stock(string type) {
    mapping blue;
    blue = (mapping)our_storeroom->query_shop_type_mapping();
    if(!blue[type]) {
        return ({ });
    }
    return blue[type];
}
void do_rep_buy(mixed *bing) {
    object rep, *obs;
    int cost;
    rep = bing[0];
    obs = bing[1];
    cost = bing[2];
    rep->adjust_money(cost, "brass");
    rep->query_current_room()->do_buy(obs, cost, rep);
    obs->move(present("Sales rep alias", rep->query_current_room()));
    call_out("set_up_return", 5, rep);
}
void set_up_return(object rep) {
    rep->add_property("goto destination", file_name(this_object()));
    rep->add_triggered_action("froggy", "goto_destination",
      this_object(), "rep_came_back");
}
void rep_came_back() {
    int i;
    object *obs, *obs2, rep;
    obs = previous_object()->find_inv_match("all", previous_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->query_property("mine")) {
            continue;
        }
        if(obs[i]->query_property("money")) {
            continue;
        }
        obs[i]->move(our_storeroom);
        obs2 += ({obs[i]});
    }
    if(sizeof(obs2)) {
        tell_room(this_object(), previous_object()->short()+" puts "+
          query_multiple_short(obs2)+" into the stock.\n");
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = all_inventory(this_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if((object)obs[i]->query_property("merchant") == rep) {
            obs2 += ({ obs[i] });
        }
    }
    if(sizeof(obs2)) {
        tell_room(this_object(),
          query_multiple_short(obs2+({previous_object()}), "one")+" go away.\n");
    } else {
        tell_room(this_object(), previous_object()->short()+" goes away.\n");
    }
    obs2->dest_me();
    previous_object()->dest_me();
}
void summon_guards(object tp) {
    object ob;
    int i;
    if(environment(tp) != this_object()) {
        return;
    }
    ob = environment(tp)->create_mercenary(0);
    if(!ob) {
        return;
    }
    ob->move(this_object(),
      "$N charge$s in to protect the shop!");
    ob->attack_ob(tp);
    for(i = 0; i < random(5); i++) {
        ob = create_mercenary(0);
        ob->move(this_object(),
          "$N charge$s in to protect the shop!");
        ob->attack_ob(tp);
    }
}
void set_strict_currency( int new_strict ) {
    _strict_currency = new_strict;
}
int query_strict_currency() {
    return _strict_currency;
}
void event_shoplift(object command_ob, object thief, object victim) {
    if(stringp(shoplift_handler)) {
        if(shoplift_handler != "none") {
            shoplift_handler->handle_shoplift(thief, victim);
        }
    } else if (functionp(shoplift_handler)) {
        evaluate(shoplift_handler, thief, victim);
    } else {
        "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
    }
}
void tidy_inventory() {
    object storeob;
    object *inventory;
    int i, inv_to_leave;
    int count;
    inv_to_leave = max_inventory - (max_inventory / 4);
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) < inv_to_leave)
        return;
    inventory = all_inventory(storeob);
    while(sizeof(inventory) > inv_to_leave) {
        i = random(sizeof(inventory));
        if(inventory[i])
            inventory[i]->dest_me();
        if(count++ > 500)
            break;
        inventory = all_inventory(storeob);
    }
}
void dest_me() {
    if(our_storeroom)
        our_storeroom->dest_me();
    ::dest_me();
}
mixed *stats() {
    return ::stats()+({
      ({"total sold", amount_sold}),
      ({"total bought", amount_bought}),
      ({"shop type", shop_type}),
      ({"shoplift handler", shoplift_handler }),
      ({"strict shop", strict_shop})});
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/item_shop_outside.c ===
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/std/room/outside";
inherit "/std/shops/inherit/item_shop";
void create() {
   item_shop::create();
   outside::create();
}
void init() {
   outside::init();
   item_shop::init();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
    outside::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen );
}
void dest_me() {
   item_shop::dest_me();
   outside::dest_me();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/bank_franchise.c ===
#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_franchise";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
string query_franchise() {
   return file_name(this_object());
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_franchise::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_franchise::init();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/craft_shop_category.c ===
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop_category";
void create() {
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   basic_room::create();
   craft_shop_category::create();
}
void init() {
   basic_room::init();
   craft_shop_category::init();
}
void dest_me() {
   craft_shop_category::dest_me();
   basic_room::dest_me();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/binding.c ===
inherit "/std/room/basic_room";
#include <money.h>
#include <language.h>
private int _cost_per_book;
private int _cost_per_page;
void create() {
   _cost_per_book = 4000;
   _cost_per_page = 400;
}
void init() {
   add_command("bind", "<object:indirect:me'pages'> into book");
}
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
}
int do_bind(object *obs) {
   object *magic;
   object *paper;
   object *fail;
   object ob;
   object book;
   string place;
   int cost;
   foreach (ob in obs) {
      if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      }
   }
   if (sizeof(fail) || sizeof(magic)) {
      if (sizeof(magic)) {
         add_failed_mess("Cannot bind up $I with magic stuff into "
                         "a book.\n", magic);
      }
      if (sizeof(fail)) {
         add_failed_mess("$I are not pieces of paper and cannot be "
                         "bound into a book.\n", fail);
      }
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _cost_per_book + _cost_per_page * sizeof(paper);
   if (this_player()->query_value(place) > cost) {
      add_failed_mess("You do not have enough money, you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to bind $I into a book.\n", paper);
      return 0;
   }
   book = clone_object("/std/book");
   foreach (ob in paper) {
      book->add_page_after(ob, book->query_num_pages() + 1);
   }
   book->move(this_player());
   this_player()->pay_money( MONEY_HAND->create_money_array(cost, place),
                             place);
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/book_shop.c ===
#include <shops/craft_shop.h>
inherit CRAFT_SHOP_INHERIT;
#define READ_PAGE_PROPERTY "browse page"
int browse_pages(object *obs);
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables);
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables);
void init() {
   string storeroom;
   ::init();
   storeroom = file_name(query_controller()->query_sell_list());
   add_command("browse", "page of <indirect:object:" + storeroom + ">",
               (: browse_pages($1) :) );
   set_extra_sell_check((: choose_which_page :));
}
int browse_pages(object *obs) {
   object *real_obs;
   object ob;
   int number;
   string mess;
   string read;
   object *no_pages;
   object *ok;
   int i;
   if (!check_open(this_player(), "browse")) {
      return 0;
   }
   real_obs = query_controller()->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse page$P$";
   no_pages = ({ });
   ok = ({ });
   for (i = 0; i < sizeof(obs); i++) {
      ob = real_obs[i];
      number = ob->query_property(READ_PAGE_PROPERTY);
      if (undefinedp(number)) {
         number = random(ob->query_num_pages() - 1) + 1;
         ob->add_property(READ_PAGE_PROPERTY, number);
         query_controller()->update_craft_object(obs[i], real_obs[i]);
      }
      if (number > ob->query_num_pages()) {
         no_pages += ({ ob });
      } else {
         ob->set_open_page(number);
         mess += ob->the_short() + ":\n" + ob->long();
         read = ob->query_readable_message();
         if (read) {
            mess += "You read " +
                    replace(ob->query_read_short(this_player()), "$name$",
                            ob->a_short()) + ":\n" +
                    ob->query_readable_message();
         }
         ok += ({ ob });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess(({ mess, "$N browses a page of $I.\n" }), ok);
      return 1;
   } else {
      add_failed_mess("There are not enough pages in $I to open to " +
                      " page " + number + ".\n", no_pages);
      return 0;
   }
}
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables) {
   write("Which page of " + query_multiple_short(sellables) +
         " would you like to let people browse (0 for the cover only)? ");
   input_to((: finish_choose :), 0, end_func, value, name, sellables);
}
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables) {
   int page;
   object *invalid;
   if (page_num == "quit" ||
       page_num == "q") {
      write("Aborting sale.\n");
      return ;
   }
   if (sscanf(page_num, "%d", page) != 1) {
      write("Need to actually enter a number.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   if (page < 0) {
      write("Need to specify a page number greator than zero.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   invalid = filter(sellables, (: $1->query_num_pages() < $(page) :) );
   if (sizeof(invalid)) {
      write("Page Number " + page + " is larger the number of pages in " +
            query_multiple_short(invalid) + ".\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   sellables->add_property(READ_PAGE_PROPERTY, page);
   sellables->set_open_page(0);
   evaluate(end_func, value, name, sellables);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/README ===
This directory contains all the small specialised shop inherits.  To
hopefully make the world of shops a bit more standard.

The inherits directory should contain all the nessessary inherits for
various types of shops, the objs directory should contain any special
objects required for the shops.

-- Pinkfish.


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/pub_shop.c ===
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/pub";
void create() {
   add_help_file("pub_shop");
   do_setup++;
   basic_room::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   basic_room::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   basic_room::dest_me();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/print_shop.c ===
#include <language.h>
#include <money.h>
#include <book_handler.h>
inherit "/std/room/basic_room";
#define COPYRIGHT_NUMBER 3
nosave mixed *discount_schedule;
mapping collectables;
int current_save_number;
nosave int letter_cost;
nosave int time_to_collect;
nosave int time_per_copy;
nosave string save_dir;
nosave string office_room;
nosave int no_collection;
nosave function open_func;
nosave string default_language;
nosave mapping translation_costs;
nosave string print_shop_name;
#define SCHEDULE_NUM 1
#define SCHEDULE_PERCENTAGE 0
#define COLLECT_TIME 0
#define COLLECT_NUM  1
#define COLLECT_OB_NAME 2
#define COLLECT_LANGUAGE 3
#define COLLECT_AUTO_LOAD_NUM 4
#define COLLECT_ARR_SIZE 5
#define BINDING_COST 600
#define DEFAULT_LETTER_COST 1
#define DEFAULT_TIME_TO_COLLECT (8*60*60)
#define DEFAULT_TIME_PER_COPY (20*60)
#define MAX_NUMBER 30
int price_object(object ob, int num, string language);
protected int do_print_copies(object *obs, int num, string language);
protected int do_print(object *obs, string language);
protected int do_claim(object *obs);
protected int do_collect();
void do_print_run(object ob, int number, int cost, string language);
void print_pricing(object ob, string language);
void remove_print_run(string name, mixed *info);
mixed *query_print_run(string name);
void add_print_run(string name, object ob, int number, string language);
void load_it();
void save_it();
string query_print_shop_name();
string query_static_auto_load_info(int num);
mapping query_dynamic_auto_load_info(int num);
protected int add_auto_load_info(string static, string dynamic);
private object create_fly_leaf(object book, string language);
private void remove_auto_load_info(int num);
void create() {
   letter_cost = DEFAULT_LETTER_COST;
   time_to_collect = DEFAULT_TIME_TO_COLLECT;
   time_per_copy = DEFAULT_TIME_PER_COPY;
   collectables = ([ ]);
   discount_schedule = ({ ({ 100, 5 }),
                          ({ 95, 10 }),
                          ({ 90, 20 }),
                          ({ 80, 101 }) });
   default_language = "common";
   translation_costs = ([ ]);
   print_shop_name = "Rabbits happy little printing press";
   ::create();
   load_it();
   add_help_file("print_shop");
}
void init() {
   string languages;
   if (!office_room) {
      add_command("print", "<indirect:object>",
                   (: do_print($1, default_language) :));
      add_command("print", "<number> [copies] of <indirect:object>",
                      (: do_print_copies($1, $4[0], default_language) :) );
      add_command("claim", "copyright on <indirect:object>", (: do_claim :));
      if (sizeof(translation_costs)) {
         languages = implode(keys(translation_costs) + ({ default_language }), "|");
         add_command("print", "<indirect:object> in {" + languages + "}",
                   (: do_print($1, $4[1]) :));
         add_command("print", "<number> [copies] of <indirect:object> in "
                              "{" + languages + "}",
                         (: do_print_copies($1, $4[0], $4[2]) :) );
      }
   }
   if (!no_collection) {
      add_command("collect", "", (: do_collect :));
   }
}
protected int is_copyright(object book) {
  if (BOOK_HANDLER->check_book_same(book, book->query_book_num())) {
     return 1;
  }
  return 0;
}
protected string copyright_holder(object book) {
   return BOOK_HANDLER->query_book_owner(book->query_book_num());
}
protected int do_claim(object *obs) {
   object ob;
   object *already_copyright;
   object *new_copyright;
   object *cannot_copyright;
   string name;
   string place;
   int value;
   int player_money;
   already_copyright = ({ });
   new_copyright = ({ });
   cannot_copyright = ({ });
   name = this_player()->query_name();
   foreach (ob in obs) {
      if (!ob->query_book()) {
         cannot_copyright += ({ ob });
      } else if (is_copyright(ob)) {
         already_copyright += ({ ob });
      } else {
         new_copyright += ({ ob });
      }
   }
   if (!sizeof(new_copyright)) {
      if (sizeof(cannot_copyright)) {
         add_failed_mess("You cannot copyright $I.\n", cannot_copyright);
      }
      if (sizeof(already_copyright) == 1) {
         add_failed_mess("$I is copyrighted.\n",
                         already_copyright);
      } else {
         add_failed_mess("$I are copyrighted.\n",
                         already_copyright);
      }
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   value = 0;
   foreach (ob in new_copyright) {
      value += price_object(ob, COPYRIGHT_NUMBER, default_language);
   }
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   write("It will cost you " + MONEY_HAND->money_value_string( value, place ) +
         " to make " + query_multiple_short(new_copyright) +
         " copyright.\n");
   if (player_money > value) {
      write("Do you wish to continue? ");
      input_to("check_copyright", 0, new_copyright, value);
   } else {
      write("Although you do not currently have enough money.\n");
   }
   add_succeeded_mess( ({ "", "$N enquires about copyrighting $I.\n" }),
                       new_copyright);
   return 1;
}
protected void check_copyright(string str, object *new_copyright, int value) {
   int new_num;
   object ob;
   string place;
   if (!strlen(str) || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, never mind.  See you again soon.\n");
      return ;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               value, place ), place );
   foreach (ob in new_copyright) {
      new_num = BOOK_HANDLER->add_book(ob, 0, this_player()->query_name());
      ob->set_book_num(new_num);
      ob->add_property(BH_COPYRIGHT, this_player()->query_name());
   }
   write("Ok, added " + query_multiple_short(new_copyright) +
         " as a copyright book.\n");
}
protected int do_collect() {
   object new_ob;
   object page;
   object fly_leaf;
   int i;
   int j;
   int number;
   int no_printed;
   string ob_name;
   mixed static_arg;
   mixed dynamic_arg;
   string language;
   mixed *info;
   mixed *stuff;
   mixed *collectables;
   mixed room;
   int auto_load_num;
   if (open_func) {
      if (!evaluate(open_func)) {
         return 0;
      }
   }
   if (office_room) {
      room = office_room;
   } else {
      room = this_object();
   }
   collectables = room->query_print_run(this_player()->query_name());
   if (!collectables) {
      add_failed_mess("No books available for collection.\n");
      return 0;
   }
   no_printed = 0;
   foreach (info in collectables) {
      if (time() < info[COLLECT_TIME]) {
         add_failed_mess("You need to wait until " +
                         amtime(info[COLLECT_TIME]) +
                         " to collect your book.\n");
         continue;
      }
      auto_load_num = info[COLLECT_AUTO_LOAD_NUM];
      static_arg = room->query_static_auto_load_info(auto_load_num);
      dynamic_arg = room->query_dynamic_auto_load_info(auto_load_num);
      ob_name = info[COLLECT_OB_NAME];
      number = info[COLLECT_NUM];
      language = info[COLLECT_LANGUAGE];
      if (office_room) {
         office_room->remove_print_run(this_player()->query_name(), info);
      } else {
         remove_print_run(this_player()->query_name(), info);
      }
      new_ob = clone_object(ob_name);
      if (static_arg) {
         new_ob->init_static_arg(static_arg);
      }
      if (dynamic_arg) {
         new_ob->init_dynamic_arg(dynamic_arg);
      }
      new_ob->set_open_page(0);
      for (j = 0; j < new_ob->query_num_pages(); j++) {
         if (j > 0) {
            page = new_ob->query_selected_page(j);
         } else {
            new_ob->set_open_page(0);
            page = new_ob;
         }
         if (j == 1) {
             fly_leaf = create_fly_leaf(new_ob, language);
             if (page->query_property(BH_IGNORE_PAGE)) {
                new_ob->replace_page_with(fly_leaf, j);
             } else {
                new_ob->add_page_after(fly_leaf, j - 1);
             }
             page = new_ob->query_selected_page(j + 1);
         }
         stuff = page->query_read_mess();
         foreach (info in stuff) {
            if (info[READ_LANG] != language) {
               info[READ_LANG] = language;
            }
         }
         page->set_read_mess(stuff);
      }
      static_arg = new_ob->query_static_auto_load();
      dynamic_arg = new_ob->query_dynamic_auto_load();
      new_ob->dest_me();
      for (i = 0; i < number; i++) {
         new_ob = clone_object(ob_name);
         new_ob->set_player(this_player());
         if (static_arg) {
            new_ob->init_static_arg(static_arg, this_player());
         }
         if (dynamic_arg) {
            new_ob->init_dynamic_arg(dynamic_arg, this_player());
         }
         new_ob->move(this_object());
      }
      if (number > 1) {
         write("Ok, your " + query_num(number, 1000) + " copies of " +
               new_ob->the_short() +
               " have been placed on the floor here.\n");
      } else {
         write("Ok, your copy of " + new_ob->the_short() +
               " has been placed on the floor here.\n");
      }
      no_printed++;
   }
   return no_printed;
}
private object create_fly_leaf(object book, string language) {
    object page;
    page = book->create_default_page_object();
    if (is_copyright(book)) {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n\nCopyright " +
                             this_player()->query_name(), 0,
                             language);
    } else {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n", 0,
                             language);
    }
    page->add_property(BH_IGNORE_PAGE, 1);
    return page;
}
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
}
int check_for_untranslatable_language(object ob) {
   mixed *stuff;
   int i;
   string lang;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      lang = stuff[i][READ_LANG];
      if (lang != default_language &&
          !translation_costs[lang]) {
         return 1;
      }
   }
   return 0;
}
object find_book_or_paper(object *obs) {
   object *paper;
   object *books;
   object *magic;
   object *torn_out;
   object *nothing;
   object ob;
   int page;
   int old_page;
   string owner;
   paper = ({ });
   books = ({ });
   magic = ({ });
   torn_out = ({ });
   nothing = ({ });
   foreach (ob in obs) {
      owner = copyright_holder(ob);
      if (is_copyright(ob) && owner != this_player()->query_name()) {
         add_failed_mess("$I has been copyrighted by " + owner +
                         " and cannot be copied.\n", ({ ob }));
      } else if (ob->query_book()) {
         if (ob->query_spell_book()) {
            magic += ({ ob });
         } else {
            old_page = ob->query_open_page();
            for (page = 0; page <= ob->query_num_pages(); page++) {
               ob->set_open_page(page);
               if (ob->is_current_page_torn_out()) {
                  torn_out += ({ ob });
                  break;
               }
               if (check_for_magic_writing(ob)) {
                  magic += ({ ob });
                  break;
               }
            }
            ob->set_open_page(old_page);
            if (page == ob->query_num_pages() + 1) {
               books += ({ ob });
            }
         }
      } else if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      } else {
         nothing += ({ ob });
      }
   }
   if (sizeof(magic)) {
      add_failed_mess("$I have magic writing in them and cannot be copied.\n",
                      magic);
   }
   if (sizeof(torn_out)) {
      add_failed_mess("$I have pages torn out and cannot be copied.\n",
                      torn_out);
   }
   if (!sizeof(books) && !sizeof(paper)) {
      if (sizeof(nothing)) {
         add_failed_mess("Unable to print $I as they are not a book or paper.\n", nothing);
      }
      return 0;
   }
   if (sizeof(books + paper) > 1) {
      add_failed_mess("Can only do print one book or piece of paper at a time.  "
                  "Please be more specific and choose from " +
                  query_multiple_short(books + paper) + ".\n");
      return 0;
   }
   if (sizeof(books) > 0) {
      return books[0];
   }
   return paper[0];
}
int do_print(object *obs, string language) {
   object ob;
   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }
   print_pricing(ob, language);
   write("Use: print <number> of <book>\n");
   add_succeeded_mess(({ "",
                       "$N enquires about the cost of printing a book.\n" }));
   return 1;
}
int do_print_copies(object *obs, int number, string language) {
   object ob;
   int cost;
   int player_money;
   string place;
   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }
   if (number < 1) {
      add_failed_mess("Must print at least one copy.\n", obs);
      return 0;
   }
   if (number > MAX_NUMBER) {
      add_failed_mess("Cannot print more than " + MAX_NUMBER +
                      " copies.\n", obs);
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }
   cost = price_object(ob, number, language);
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   if (player_money < cost) {
      add_failed_mess("This will cost you " +
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) + " and you do not have enough "
                  "money to afford it.\n", ({ ob }));
      return 0;
   }
   if (is_copyright(ob)) {
      write("NOTE:  You are printing a copyright document.\n");
   } else {
      write("NOTE:  Please use 'claim copyright' to claim copyright "
            "on a document.\n");
   }
   add_succeeded_mess(({ "This will cost you " +
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) +
                       " to do, do you wish to continue? ",
                       "$N starts to do some printing.\n" }));
   input_to("check_cost", 0, ob, number, cost, language);
   return 1;
}
void check_cost(string str, object ob, int number, int cost, string language) {
   if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, don't worry.  See you again.\n");
      return ;
   }
   do_print_run(ob, number, cost, language);
}
void do_print_run(object ob, int number, int cost, string language) {
   string place;
   int player_money;
   mixed *stuff;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   if (player_money < cost) {
      write("You do not seem to have enough money any more.\n");
      return ;
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
   add_print_run(this_player()->query_name(),
                 ob,
                 number,
                 language);
   stuff = query_print_run(this_player()->query_name());
   if (no_collection) {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion at the "
            "collection office.\n");
   } else {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion.\n");
   }
}
int price_object(object ob, int num, string to_language) {
   int i;
   int num_letters;
   int multiplier;
   int cost;
   mixed *stuff;
   if (num <= 0 || !ob) {
     return 0;
   }
   ob->set_open_page(0);
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      num_letters += strlen(stuff[i][READ_MESS]);
      if (stuff[i][READ_LANG] != default_language) {
         cost = translation_costs[stuff[i][READ_LANG]];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
      if (to_language != default_language) {
         cost = translation_costs[to_language];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
   }
   cost = ob->query_value() + (num_letters / 10) * letter_cost;
   if (ob->query_book()) {
      for (i = 1; i < ob->query_num_pages(); i++) {
         ob->set_open_page(i + 1);
         if (ob != ob->query_current_page()) {
            cost += price_object(ob->query_current_page(), 1, to_language);
         }
      }
      cost += BINDING_COST;
   }
   multiplier = 200;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      if (num < discount_schedule[i][SCHEDULE_NUM]) {
         multiplier = discount_schedule[i][SCHEDULE_PERCENTAGE];
      }
   }
   return (cost * num * multiplier) / 100;
}
void print_pricing(object ob, string language) {
   int i;
   int num;
   string place;
   int cost;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   write("The cost for the different numbers of " + ob->the_short() + " is:\n");
   write("  1 for " + (string)MONEY_HAND->money_value_string(
                    price_object(ob, 1, language), place ) +
                    " and will be ready at " +
                    amtime(time_to_collect + time_per_copy + time()) + ".\n");;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      num = discount_schedule[i][SCHEDULE_NUM];
      if (num < MAX_NUMBER) {
         write(sprintf("%3d for %s and will be ready at %s.\n", num,
                       (string)MONEY_HAND->money_value_string(
                       price_object(ob, num, language), place ),
                       amtime(time_to_collect + time_per_copy * num + time()) ));
      }
   }
   if (sizeof(translation_costs)) {
      write("You can translate a book to or from " +
            query_multiple_short(keys(translation_costs) + ({ default_language })) +
            ", the cost of doing the translation is defined in the "
            "following table.");
      if (sizeof(translation_costs) > 2) {
         write("  Translating between two of these languages "
               "is also possible, but it will cost the amount to translate "
               "from the language to " + default_language + " and back again.");
      }
      write("\n");
      foreach (language, cost in translation_costs) {
         write(sprintf("   %3d%% %s", cost, language));
      }
      write("\n");
   }
}
mixed *query_discount_schedule() {
   return discount_schedule;
}
void set_discount_schedule(mixed *value) {
   discount_schedule = value;
}
int query_letter_cost() {
   return letter_cost;
}
void set_letter_cost(int value) {
   letter_cost = value;
}
void add_print_run(string name, object ob, int number, string language) {
   mixed *arr;
   int num;
   if (!collectables[name]) {
      collectables[name] = ({ });
   }
   arr = allocate(COLLECT_ARR_SIZE);
   arr[COLLECT_TIME] = time() + time_to_collect + time_per_copy * number;
   arr[COLLECT_NUM] = number;
   arr[COLLECT_LANGUAGE] = language;
   arr[COLLECT_OB_NAME] = base_name(ob);
   num = add_auto_load_info(ob->query_static_auto_load(),
                             ob->query_dynamic_auto_load());
   arr[COLLECT_AUTO_LOAD_NUM] = num;
   collectables[name] += ({ arr });
   save_it();
}
mixed *query_print_run(string name) {
   return collectables[name];
}
void remove_print_run(string name, mixed *info) {
   int index;
   if (collectables[name]) {
      index = member_array(info, collectables[name]);
      if (index != -1) {
         remove_auto_load_info(info[COLLECT_AUTO_LOAD_NUM]);
         collectables[name] = collectables[name][0.. index - 1] +
                              collectables[name][index + 1..];
         if (!sizeof(collectables[name])) {
            map_delete(collectables, name);
         }
         save_it();
      }
   }
}
protected int add_auto_load_info(string static, string dynamic) {
   int num;
   num = current_save_number;
   while (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      num++;
   }
   current_save_number = num + 1;
   unguarded( (: write_file(save_dir + "/" + $(num),
                            save_variable( ({ $(static), $(dynamic) }) ) +
                            "\n") :) );
   return num;
}
private void remove_auto_load_info(int num) {
   unguarded( (: rm(save_dir + "/" + $(num) ) :) );
}
string query_static_auto_load_info(int num) {
   string *arr;
   string tmp;
   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[0];
      }
   }
   return 0;
}
mapping query_dynamic_auto_load_info(int num) {
   mixed arr;
   string tmp;
   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[1];
      }
   }
   return 0;
}
void set_save_dir(string name) {
   save_dir = name;
}
string query_save_dir() {
   return save_dir;
}
void load_it() {
   if (save_dir) {
      unguarded((: restore_object(save_dir + "/main") :));
      if (!collectables) {
         collectables = ([ ]);
      }
   }
}
void save_it() {
   if (save_dir) {
      unguarded((: save_object(save_dir + "/main") :));
   }
}
void set_office_room(string room) {
   office_room = room;
}
string query_office_room() {
   return office_room;
}
void set_no_collection(int collect) {
   no_collection = collect;
}
int query_no_collection() {
   return no_collection;
}
void set_open_func(function func) {
   open_func = func;
}
function query_open_func() {
   return open_func;
}
void set_default_language(string lang) {
   default_language = lang;
}
string query_default_language() {
   return default_language;
}
void add_translation_cost(string lang, int cost) {
   translation_costs[lang] = cost;
}
void remove_translation_cost(string lang) {
   map_delete(translation_costs, lang);
}
mapping query_all_translantion_costs() {
   return translation_costs;
}
void set_print_shop_name(string name) {
   print_shop_name = name;
}
string query_print_shop_name() {
   return print_shop_name;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/item_shop_close.c ===
inherit "/std/shops/item_shop";
inherit "/std/shops/inherit/store_close";
void womble() {
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/pub_shop_outside.c ===
inherit "/std/room/outside";
inherit "/std/shops/inherit/pub";
void create() {
   add_help_file("pub_shop");
   do_setup++;
   outside::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   outside::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   outside::dest_me();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/laundry_entry_inherit.c ===
#include <money.h>
#include <vault.h>
inherit "/std/room";
#define TIME_LIMIT 500
#define LO laundryowner->the_short()
string location, laundry_room;
int visit_cost;
object laundryowner;
void set_location(string str) { location = str; }
void set_visit_cost(int i) { visit_cost = i; }
void set_laundryowner(object ob) { laundryowner = ob; }
void set_laundry_exit(string direc, mixed dest, string type) {
  laundry_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  if(!laundryowner || environment(laundryowner) != this_object())
    return notify_fail("Since the owner of this laundry is missing "
      "you think twice before entering the laundry.\n");
  if( !interactive(thing) )
    return 0;
  owner = (string)thing->query_name();
  if ( !( vroom = find_object( laundry_room ) ) )  {
      laundry_room->load_me();
      vroom = find_object( laundry_room );
  }
  if(sizeof(filter_array(all_inventory(vroom),
                         (: userp( $1 ) :)))) {
    tell_object(thing, LO + " intercepts you.\n");
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing);
    laundryowner->do_command("say No more than one person at a time in "
      "laundry room.  It can be very dangerous!");
    laundryowner->do_command("emote taps his head implying madness.");
    return notify_fail( "" );
  }
  if(query_property(owner)) {
    remove_property(owner);
    tell_object(thing, LO + " opens the round door of the laundry and "
      "signalls you to enter.\n" );
    tell_room(this_object(), LO + " signalls "+
              (string)thing->the_short() +" to enter the laundry through "
                "the small round door of the laundry.\n", thing );
    call_out("check_idler", TIME_LIMIT, thing);
    return 1;
  }
  if ( (int)thing->query_value_in( location ) +
       (int)thing->query_value_in( "default" ) < visit_cost ) {
    tell_object( thing, LO + " intercepts you.\n" );
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    laundryowner->do_command("say Well... I am but a poor man.  I cannot "
      "just let you use my fine, imp-powered laundry for nothing!\n" );
    laundryowner->do_command("emote sniffs.\n" );
    return notify_fail( "" );
  }
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay " + LO + " who signals you to go through "
    "the small, round door of the laundry.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays " + LO + " who signals to "
             + (string)thing->query_objective() + " to move through "
             "a small, round door and enters the laundry.\n", thing );
   return 1;
}
void player_quitting(object who, object env) {
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/potion_shop.c ===
#define CONVERT "/global/events"->convert_message
#define MIN_VOLUME 1000
inherit "/std/shops/craft_shop_category";
void shopkeeper_say( string message );
int is_potion_or_salve( object ob );
void set_message_function( function wossname );
private nosave function _message_function;
private nosave string _shopkeeper;
void create() {
   set_message_function( (: shopkeeper_say :) );
   ::create();
   set_allowed_to_sell( (: is_potion_or_salve :) );
}
void set_message_function( function wossname ) {
   _message_function = wossname;
}
function query_message_function() {
   return _message_function;
}
void set_shopkeeper( string name ) {
   _shopkeeper = name;
}
string query_shopkeeper() {
   return _shopkeeper;
}
void shopkeeper_say( string message ) {
   object *frog;
   if( !message || message == "" )
      message = "Tuppence a bucket, well stamped down!";
   if( _shopkeeper ) {
      frog = match_objects_for_existence( _shopkeeper, this_object() );
      if( sizeof( frog ) == 1 ) {
         frog[0]->init_command( "' "+ message );
         return;
      }
   }
   write( message );
   return;
}
int is_potion_or_salve( object ob ) {
   object thing, *contents;
   int found_something;
   string contents_string;
   if( !ob->query_volume() ) {
      tell_creator( this_player(), "ob has 0 volume.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "There's nothing in "+ ob->the_short() +" that "
               "can be described as either potion or salve, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   } else if( ob->query_volume() < MIN_VOLUME ||
              ob->query_volume() < ( 7 * ob->query_max_volume() / 10 ) ) {
      tell_creator( this_player(), "ob does not contain enough stuff.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "We don't deal in quantities smaller than a cup, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   }
   contents = all_inventory( ob );
   if( !sizeof( contents ) ) {
      tell_creator( this_player(), "No contents.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( ob->the_short() +" is empty, "+
               this_player()->the_short() +"!\n" ) );
      return 0;
   }
   foreach( thing in contents )
      if( !( sizeof( thing->query_apply_effects() ) +
             sizeof( thing->query_eat_effects() ) ) ) {
         found_something = 1;
      } else {
         tell_creator( this_player(), "thing %s, effect %O.\n",
                       thing->query_short(), thing->query_eat_effects()  );
      }
   contents_string = ( sizeof( contents ) > 1 ) ?
         query_multiple_short( contents, "the" ) +" are neither potions nor "
            "salves, or they are " :
         contents[0]->the_short() +" is neither potion nor salve, or it is ";
   if( found_something ) {
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "Either "+ contents_string +"impure, or so weak as "
               "to make no difference, "+ this_player()->the_short() +"." ) );
      return 0;
   }
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/storeroom.c ===
#include <config.h>
#ifndef __DISTRIBUTION_LIB__
#include <thief.h>
#endif
inherit "/std/room/basic_room";
mapping room_cont;
int max_num;
int loot;
mapping shop_type;
void create() {
  room_cont = ([ ]);
  shop_type = ([ ]);
  max_num = 8;
  ::create();
  loot = random(10);
  set_keep_room_loaded(1);
  call_out("test_cont", 1);
}
mapping query_room_cont() {
  return room_cont;
}
int query_max_num() { return max_num; }
void set_max_num(int i) { max_num = i; }
void add_thing(object ob) {
  string shr;
  if (!ob || environment(ob) != this_object())
    return ;
  shr = (string)ob->query_property("shop type");
  if (!shop_type[shr])
    shop_type[shr] = ({ ob });
  else
    shop_type[shr] += ({ ob });
  shr = (string)ob->short();
  if (!room_cont[shr]) {
    room_cont[shr] = ({ ob });
    return ;
  }
  if (sizeof(room_cont[shr]) > max_num)
    call_out("do_dest", 1, ob);
  else
    room_cont[shr] += ({ ob });
  return ;
}
void test_cont() {
  int i;
  object *obs;
  obs = all_inventory();
  for (i=0;i<sizeof(obs);i++)
    add_thing(obs[i]);
}
void remove_thing(object ob) {
  mixed *arr;
  int i;
  string sh;
  if (!ob || environment(ob) == this_object())
    return ;
  sh = (string)ob->query_property("shop type");
  if (shop_type[sh])
    shop_type[sh] = (object *)shop_type[sh] - ({ ob });
  sh = (string)ob->short();
  if (!room_cont[sh])
    return ;
  arr = room_cont[sh];
  if ((i = member_array(ob, arr)) == -1)
    return ;
  if (sizeof(arr) <= 1) {
    room_cont = m_delete(room_cont, sh);
  } else
    room_cont[sh] = delete(arr, i, 1);
}
void event_enter(object ob, string, object) {
  call_out("add_thing", 1, ob);
}
void event_exit(object ob, string mesage, object to) {
  call_out("remove_thing", 1, ob);
}
void do_dest( object thing ) {
   if ( !thing )
      return;
   thing->move( "/room/rubbish" );
}
mapping query_shop_type_mapping() { return shop_type; }
int clean_up(int) { return 0; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/craft_shop.c ===
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop";
void create() {
   add_help_file("craft_shop");
   basic_room::create();
   craft_shop::create();
}
void init() {
   basic_room::init();
   craft_shop::init();
}
void dest_me() {
   craft_shop::dest_me();
   basic_room::dest_me();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/shops/bank_master.c ===
#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_master";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_master::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_master::init();
}
