
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/bounty.c ===
#include <money.h>
#define SAVE_FILE "/save/bounty"
#define EXPIRY 60 * 60 * 8 * 60
#define BASE 40000
#define TAXES 60
#define LOGIN "/secure/login"
class bounty {
   string short;
   string *victims;
   int value;
   int active;
   int time;
}
mapping bounty, collect;
void create() {
   bounty  = ([ ]);
   collect = ([ ]);
   seteuid( "Room" );
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
   call_out( "tidy_bounties", 120 );
}
void save_file() { unguarded( (: save_object, SAVE_FILE :) ); }
void delete_bounty( string word ) {
   map_delete( bounty, word );
   save_file();
}
void tidy_bounties() {
   int now = time();
   string word;
   object thing;
   class bounty record;
   foreach ( word, record in bounty ) {
      if ( LOGIN->test_creator( word ) ) {
         log_file( "BOUNTY", "%s: bounty removed from %s (creator)\n",
               ctime( now ), word );
         map_delete( bounty, word );
         continue;
      }
      if (record && record->time + EXPIRY < now ) {
         if (record->active )
            log_file( "BOUNTY", "%s: bounty on %s of %d expired\n",
                  ctime( now ), word, record->value );
         else
            log_file( "BOUNTY", "%s: inactive bounty on %s cancelled\n",
                  ctime( now ), word );
         thing = find_player( word );
         if ( objectp( thing ) )
            tell_object( thing, "You feel that there is no longer "
                  "a price on your head.\n" );
         map_delete( bounty, word );
         continue;
      }
   }
   foreach ( word, record in collect )
      if ( !LOGIN->test_user( word ) ) {
         map_delete( collect, word );
         continue;
      }
      if (record && record->time + EXPIRY < now ) {
         log_file( "BOUNTY", "%s: bounty of %d owed to %s expired\n",
               ctime( now ), record->value, word );
         thing = find_player( word );
         if ( objectp( thing ) )
            tell_object( thing, "You have the funniest feeling that "
                  "you just let a lot of money get away.\n" );
         map_delete( collect, word );
      }
   save_file();
}
void clear_bounties() {
   if ( !master()->high_programmer( geteuid( this_player( 1 ) ) ) )
      return 0;
   bounty  = ([ ]);
   collect = ([ ]);
   save_file();
}
void dest_me() { destruct( this_object() ); }
void register_kill( object victim, object *attackers ) {
   int now, reward;
   string killed, killer, *killers;
   object thing;
   class bounty record;
   if ( member_array( victim, attackers ) != -1 )
      return;
   if ( victim->query_creator() || victim->query_property( "no bounties" ) )
      return;
   if ( !environment( victim ) )
      return;
   if ( environment( victim )->query_property( "bar brawling" ) )
      return;
   now = time();
   killed = (string)victim->query_short();
   if ( undefinedp( bounty[ lower_case( killed ) ] ) ) {
      return;
      foreach ( thing in attackers ) {
         if ( !objectp( thing ) )
            continue;
         if ( thing->query_creator() )
            continue;
         if ( !userp( thing ) && !thing->query_property( "unique" ) )
            continue;
         if ( ( (object)thing->query_property( "inhumer" ) == victim ) &&
               ( (object)victim->query_property( "inhumee" ) == thing ) )
            continue;
         killer = (string)thing->query_short();
         if ( undefinedp( bounty[ lower_case( killer ) ] ) ) {
            record = new( class bounty );
            bounty[ lower_case( killer ) ] = record;
            record->short = killer;
            record->victims = ({ killed });
         } else {
            record = (class bounty)bounty[ lower_case( killer ) ];
            if ( strsrch( lower_case( killed ),
                  lower_case( implode( record->victims, ", " ) ) ) == -1 )
               record->victims += ({ killed });
         }
         record->time = now;
         if ( record->active ) {
            record->value = sizeof( record->victims ) * BASE;
            if ( sizeof( record->victims ) > 1 )
               call_out( "inform_bounty", 30, thing );
         }
      }
      save_file();
      return;
   }
   if ( !( ( (class bounty)bounty[ lower_case( killed ) ] )->active ) )
      return;
   killers = ({ });
   foreach ( thing in attackers ) {
      if ( !objectp( thing ) )
         continue;
      if ( thing->query_creator() )
         continue;
      if ( !userp( thing ) && !thing->query_property( "unique" ) &&
            !thing->query_property( "bounty hunter" ) )
         continue;
      killer = (string)thing->query_short();
      killers += ({ killer });
      call_out( "well_done", 30, thing, (string)victim->query_gender() );
   }
   if ( sizeof( killers ) ) {
      reward = ( (class bounty)bounty[ lower_case( killed ) ] )->value /
            sizeof( killers );
      foreach ( killer in killers ) {
         if ( !undefinedp( bounty[ lower_case( killer ) ] ) )
            continue;
         if ( undefinedp( collect[ lower_case( killer ) ] ) ) {
            record = new( class bounty );
            collect[ lower_case( killer ) ] = record;
            record->short = killer;
            record->victims = ({ killed });
         } else {
            record = (class bounty)collect[ lower_case( killer ) ];
            record->victims += ({ killed });
         }
         record->time = now;
         record->value += reward;
      }
      log_file( "BOUNTY", "%s: bounty on %s fulfilled by %s\n",
            ctime( now ), lower_case( killed ),
            query_multiple_short( map_array( killers,
            (: lower_case( $1 ) :) ) ) );
      map_delete( bounty, lower_case( killed ) );
   }
   save_file();
}
void inform_bounty( object thing ) {
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   tell_object( thing, "You feel the price on your head rise.\n" );
}
void well_done( object thing, int gender ) {
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   tell_object( thing, "You feel good about killing a wanted "+
         ({ "creature", "man", "woman" })[gender] +".\n" );
}
string report_murder( string killer ) {
   string place;
   class bounty record;
   if ( undefinedp( bounty[ lower_case( killer ) ] ) )
      return "According to the records, \""+ killer +
            "\" has never killed anyone.";
   killer = lower_case( killer );
   record = (class bounty)bounty[ killer ];
   if ( record->active ) {
      place = (string)environment( this_player() )->query_property( "place" );
      if ( !place || ( place == "" ) )
         place = "default";
      return "There is already a bounty of "+
            (string)MONEY_HAND->money_value_string( record->value, place ) +
            " offered for the death of "+ record->short +".";
   }
   record->active = 1;
   record->value = sizeof( record->victims ) * BASE;
   call_out( "issue_warrant", 30, killer );
   save_file();
   if ( strsrch( lower_case( (string)this_player()->query_short() ),
         lower_case( implode( record->victims, ", " ) ) ) == -1 )
      return "Ah, a concerned citizen reporting a murder.  I'll issue "
            "a bounty notice for "+ record->short +" right away.";
   return "I'm sorry to hear that "+ record->short +" caused you "
         "harm.  I'll issue a bounty notice right away.";
}
void issue_warrant( string killer ) {
   object thing;
   thing = find_player( killer );
   if ( !thing )
      return;
   if ( !userp( thing ) )
      return;
   thing->remove_hide_invis( "hide" );
   tell_room( environment( thing ), "There is a small unspectacular flash "
         "of light and a small orange imp appears.  It promptly informs "+
         (string)thing->the_short() +" that a bounty has been placed on "+
         (string)thing->query_possessive() +" head.  The imp bows deeply, "
         " smiles evilly, and vanishes in an equally unspectacular flash "
         "of light.\n", thing );
   tell_object( thing, "There is a small unspectacular flash of light and "
         "a small orange imp appears.  It promptly informs you that a bounty "
         "has been placed on your head.  The imp bows deeply, smiles evilly, "
         "and vanishes in an equally unspectacular flash of light.\n" );
}
string collect_bounty() {
   int money;
   string collector, place;
   class bounty record;
   collector = lower_case( (string)this_player()->query_short() );
   if ( undefinedp( collect[ collector ] ) )
      return "According to the records, you've done nothing "
            "to deserve a bounty.";
   record = (class bounty)collect[ collector ];
   money = ( record->value * ( 100 - TAXES ) ) / 100;
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   this_player()->adjust_money( (mixed *)MONEY_HAND->create_money_array( money,
         place ) );
   this_player()->set_title( "bounty", "Bounty Hunter" );
   map_delete( collect, collector );
   save_file();
   return "Ah yes, let's see.  Monies owed to you total "+
         (string)MONEY_HAND->money_value_string( record->value, place ) +
         ", minus death tax, inheritance tax, income tax, pension fund "
         "contribution, union dues, VAT, Save the Womble donations and "
         "administrative charges, which leaves you with the grand sum of "+
         (string)MONEY_HAND->money_value_string( money, place ) +
         ".  Nice doing business with you.";
}
int query_bounty( string word ) { return !undefinedp( bounty[ word ] ); }
int query_bounty_value( string word ) {
   if ( undefinedp( bounty[ word ] ) )
      return 0;
   return ( (class bounty)bounty[ word ] )->value;
}
string query_all_bounties() {
   int cre;
   string list, word, place;
   class bounty record;
   cre = (int)this_player( 1 )->query_creator();
   if ( !sizeof( bounty ) )
      return "There are no bounties currently offered.\n";
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   list = "";
   foreach ( word, record in bounty )
      if ( record->active ) {
         list += sprintf( " -   %-15s for %s\n", record->short,
               (string)MONEY_HAND->money_value_string( record->value,
               place ) );
         if ( cre )
            list += sprintf( "               %-#60s\n               %s\n",
                  implode( record->victims, "\n" ),
                  ctime( record->time + EXPIRY ) );
      } else
         if ( cre )
            list += sprintf( " -   %-15s (inactive)\n"
                  "               %-#60s\n               %s\n",
                  record->short, implode( record->victims, "\n" ),
                  ctime( record->time + EXPIRY ) );
   if ( list == "" )
      return "There are no bounties currently offered.\n";
   return "The following bounters are currently offered:\n"+ list;
}
string query_all_collectors() {
   string list, word, place;
   class bounty record;
   if ( !sizeof( collect ) )
      return "There are no bounties awaiting collection.\n";
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   list = "";
   foreach ( word, record in collect )
         list += sprintf( " -   %-15s owed %s\n               %s\n",
               record->short,
               (string)MONEY_HAND->money_value_string( record->value, place ),
               ctime( record->time + EXPIRY ) );
   return "The following bounties are awaiting collection:\n"+ list;
}
string query_bounty_info( string word ) {
   string place;
   class bounty record;
   place = (string)environment( this_player() )->query_property( "place" );
   if ( !place || ( place == "" ) )
      place = "default";
   if ( undefinedp( bounty[ word ] ) )
      return 0;
   record = (class bounty)bounty[ word ];
   if ( !record->active )
      return 0;
   return "A bounty of "+
         (string)MONEY_HAND->money_value_string( record->value, place ) +
         " is offered for the death of "+ record->short +" for the murder of "+
         query_multiple_short( record->victims ) +".\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/property_tracker.c ===
#include <login.h>
#define CACHE_PROPERTY "property_tracker"
nosave inherit "/std/object";
void save_file();
private string *_invalid_properties;
private mapping _property_funcs;
void create() {
    ::create();
    seteuid( "Root" );
    set_name( "tracker" );
    set_short( "property tracker" );
    unguarded( (: restore_object, "/save/property_tracker.o" :) );
    if ( !_invalid_properties ) {
        _invalid_properties = ({ "team", "ctf_deaths", "ctf_shared",
            "ctf_solo",
            "completed feather quest", "ChapelGapp",
            "scythe sharpness", "DJ to ephebe",
            "emote", "quiting frog", "woeshipper",
            "arresting", "Junior's friend", "donetd",
            "Sek_gem", "looky thingy", "riddle_master",
            "help shopkeeper" });
        _property_funcs = ([ ]);
        save_file();
    }
}
public void check_properties(mixed person, string type) {
    string property;
    mixed data;
    int result;
    int diff;
    if (type != LOGIN)
        return;
    if ( !objectp(person) && !( person = find_player( person ) ) ) {
        return;
    }
#ifdef CACHE_TIME
    diff = CACHE_TIME;
#else
    diff = 1;
#endif
    if ( time() > person->query_property( CACHE_PROPERTY ) + diff ) {
#ifdef DEBUG
        tell_creator( "taffyd", "Scanning %s (%O) for properties.\n",
            person->query_name(), person );
#endif
        foreach( property, data in person->query_properties() ) {
            if ( member_array( property, _invalid_properties ) > -1 ) {
#ifdef DEBUG
                tell_creator( "taffyd", "Checking to property %s.\n",
                    property );
#endif
                if ( _property_funcs[ property ] ) {
                    result = call_other( _property_funcs[ property ][ 1 ],
                        _property_funcs[ property ][ 0 ], property, person,
                        data );
                    if ( result ) {
                        continue;
                    }
                }
#ifdef DEBUG
                tell_creator( "taffyd", "Removing property %s.\n",
                    property );
#endif
                person->remove_property( property );
            }
        }
#ifdef CACHE_TIME
        person->add_property( CACHE_PROPERTY, time() );
#else
        person->remove_property( CACHE_PROPERTY );
#endif
    }
    person->add_skill_level( "other.language.common.spoken", -person->query_skill( "other.language.common.spoken" ) );
    person->add_skill_level( "other.language.common.written", -person->query_skill( "other.language.common.written" ) );
}
public string query_invalid_properties() {
    return copy( _invalid_properties );
}
varargs public int add_invalid_property( string property, mixed func, mixed obj ) {
#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    if ( member_array( property, _invalid_properties ) == -1 ) {
        if ( objectp( func ) ) {
            func = file_name( func );
        }
        if ( objectp( obj ) ) {
            obj = file_name( obj );
        }
        if ( func && obj ) {
            _property_funcs[ property ] = ({ func, obj });
        }
        _invalid_properties += ({ property });
        save_file();
        return 1;
    }
    return 0;
}
int remove_invalid_property( string property ) {
#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    if ( _property_funcs[ property ] ) {
        map_delete( _property_funcs, property );
    }
    _invalid_properties -= ({ property });
    save_file();
    return 1;
}
void save_file() {
    unguarded( (: save_object, "/save/property_tracker" :) );
}
void reset_data() {
    unguarded( (: rm, "/save/property_tracker.o" :) );
}
void convert_no_score( string property, object who, mixed data ) {
    if ( property != "no_score" )
        return;
    if ( data ) {
        who->remove_property( property );
        who->add_property( "no score", 1 );
    }
}
int remove_warmth( string property, object who, mixed data ) {
    if ( property != "warmth" ) {
        return 1;
    }
    if ( !who->query_property_time_left( property ) ) {
        who->remove_property( property );
        return 1;
    }
    return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/wander_handler.c ===
#include <player.h>
#define MH "/obj/handlers/map"
#define LAST_LOC_PROPERTY "last locations"
void do_move_after();
class route_traveller {
  object monster;
  int movetime;
  int delay;
  string dest;
}
class wander_group {
  object *monsters;
  int movetime;
}
private class wander_group *wanderers = ({});
private mapping wanderpos = ([]);
private class route_traveller *travellers = ({});
private mapping travelpos = ([]);
private int move_call_out_id;
private int after_call_out_id;
private void do_move_after();
private void move_monsters();
void delete_move_after( object monster );
private void do_wander(int running_away, object monster);
mixed query_next_mover() {
  return wanderers[0];
}
mixed query_anything(string thing){
  return copy(fetch_variable(thing));
}
int query_moving_monster(object ob) {
  return member_array(ob, travellers) != -1;
}
mixed query_route_monster() {
  return travellers[0];
}
int find_pos(mixed *arr, function func, int val, int ref found){
  int mid, high, low;
  high = sizeof(arr) - 1;
  low = 0;
  while(high >= low){
    mid = (high + low) / 2;
    if(val < (*func)(arr[mid]))
      high = mid - 1;
    else if(val > (*func)(arr[mid]))
      low = mid + 1;
    else break;
  }
  found = !(high < low);
  return mid;
}
private void add_traveller(class route_traveller new_traveller){
  if(sizeof(travellers)){
    int found, mid;
    mid = find_pos(travellers, (: $1->movetime :), new_traveller->movetime,
                   ref found);
    if(!found){
      if(new_traveller->movetime > travellers[mid]->movetime)
        mid++;
      if(mid == sizeof(travellers)){
        travellers += ({new_traveller});
        if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
          move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
        }
        return;
      }
    }
    if(mid == 0){
      travellers = ({new_traveller}) + travellers;
      remove_call_out(move_call_out_id);
      move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());
    } else {
        travellers = insert(travellers, new_traveller, mid);
    }
  } else {
    travellers = ({ new_traveller });
    move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());
  }
}
int move_me_please(int delay, string dest) {
  class route_traveller new_traveller;
  object monster;
  monster = previous_object();
  if(!intp(delay))
    return 0;
  if(travelpos[monster])
    travelpos[monster]->monster = 0;
  if(delay < 5)
    delay = 5;
  new_traveller = new (class route_traveller, monster:monster, delay:delay,
             movetime:time() + delay, dest:dest);
  travelpos[monster] = new_traveller;
  add_traveller(new_traveller);
}
private void move_monsters(){
  class route_traveller tmp;
  int virtual_move, right, refuse;
  object monster;
  string true_location, destination, direc;
  tmp = travellers[0];
  monster = tmp->monster;
  if(sizeof(travellers) > 1)
    travellers = travellers[1..];
  else
    travellers = ({});
  if (monster) {
    virtual_move = monster->query_virtual_move();
    true_location = monster->query_true_location();
    direc = monster->get_next_route_direction();
    if (direc) {
      if ( !virtual_move ){
        if(catch(monster->do_command(direc)))
          catch(monster->do_command(direc));
      } else {
        if ( "/room/virtual" != file_name( environment( monster ) ) )
          right = 1;
        if ( right ) {
          environment( monster )->set_destination( direc );
          destination = environment( monster )->query_destination( direc, monster );
        } else
          destination = (string)MH->qdes( direc, true_location );
        if ( right ) {
          if ( monster->check_anyone_here() || find_object( destination ) ){
            if(catch(monster->do_command( direc )))
              catch(monster->do_command( direc ));
          } else {
            "/room/virtual"->force_load();
            monster->move( find_object( "/room/virtual" ) );
            true_location = destination;
            monster->set_true_location( true_location );
          }
        } else {
          if ( !find_object( destination ) ) {
            true_location = destination;
            monster->set_true_location( true_location );
          } else {
            object ob = environment(monster);
            ob->remove_exit(direc);
            ob->add_exit(direc, destination,
               "plain" );
            monster->do_command(direc);
            ob->remove_exit(direc);
          }
        }
      }
    }
    tmp->movetime = time() + tmp->delay;
    if ( direc && (!(refuse = monster->query_stop_moving()))) {
      add_traveller( tmp );
    } else {
      if(!refuse)
        refuse = (file_name(environment(tmp->monster)) != tmp->dest);
      tmp->monster->stopped_route(!refuse);
      map_delete( travelpos, tmp->monster );
    }
  } else
    travelpos = filter(travelpos, (: $1 :));
  if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
    move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
  }
}
private void add_move_after(object monster, int movetime) {
  if(sizeof(wanderers)){
    int found, mid;
    reset_eval_cost();
    if(sizeof(wanderers) > 5000){
      wanderers=filter(wanderers, function(class wander_group thing){
        return sizeof(filter(thing->monsters, (:$1:)));
      });
      reset_eval_cost();
    }
    if (find_call_out(after_call_out_id) == -1)
      after_call_out_id = call_out((: do_move_after :), 0);
    mid = find_pos(wanderers, (: $1->movetime :), movetime, ref found);
    if(!found){
      if(movetime > wanderers[mid]->movetime)
        mid++;
      if(mid == sizeof(wanderers)){
        wanderers += ({ new(class wander_group, monsters:({monster}),
                            movetime:movetime) });
        wanderpos[monster] = wanderers[<1];
        return;
      }
      if(mid == 0){
        wanderers = ({ new(class wander_group, monsters:({monster}),
                           movetime:movetime) }) + wanderers;
        wanderpos[monster] = wanderers[0];
        remove_call_out(after_call_out_id);
        after_call_out_id = call_out((: do_move_after :), movetime - time());
        return;
        }
      wanderers = insert(wanderers, new(class wander_group,
                                        monsters:({monster}),
                                        movetime:movetime), mid);
      wanderpos[monster] = wanderers[mid];
      return;
    } else {
      wanderers[mid]->monsters += ({ monster });
      wanderpos[monster] = wanderers[mid];
      return;
    }
  } else {
    wanderers = ({ new(class wander_group, monsters:({monster}),
                       movetime:movetime) });
    wanderpos[monster] = wanderers[0];
    after_call_out_id = call_out((: do_move_after :), movetime - time());
  }
}
void move_after( int runaway ) {
  mixed move_after;
  if(runaway)
    return do_wander(runaway, previous_object());
  move_after = previous_object()->query_move_after();
  delete_move_after(previous_object());
  if (!arrayp(move_after) || (!move_after[0] && !move_after[1])) {
    return;
  }
  add_move_after(previous_object(), time() + move_after[ 0 ] +
                 random( move_after[ 1 ] ));
}
void delete_move_after(object monster) {
  if(wanderpos[monster]) {
    ((class wander_group)wanderpos[monster])->monsters -= ({monster});
  }
  map_delete(wanderpos, monster);
}
private void do_wander(int running_away, object monster) {
  int right, virtual_move;
  string destination, *direcs, *room_zones, true_location, *move_zones,
         *last_locs;
  if ( !monster )
    return ;
  if ( !environment( monster ) || monster->query_property( PASSED_OUT_PROP ) )
    return ;
  if ( !running_away &&
       sizeof( (object *)monster->query_attacker_list() ) )
    return ;
  if ( (int)monster->query_hp() <= 0 )
    return ;
  virtual_move = monster->query_virtual_move();
  true_location = monster->query_true_location();
  if (1 || !virtual_move ||
       (virtual_move && "/room/virtual" != file_name(environment(monster))))
    right = 1;
  if ( right )
   direcs = (string *)environment( monster )->query_direc( monster );
  else
    direcs = (string *)MH->qdir( true_location );
  last_locs = monster->query_propery( LAST_LOC_PROPERTY );
  if (!pointerp(last_locs))
    last_locs = ({ });
   if (!direcs) direcs = ({ });
  direcs = shuffle( direcs );
  while ( sizeof( direcs ) ) {
    if ( right ) {
      direcs[ 0 ] = (string)environment( monster )->expand_alias( direcs[ 0 ] );
      destination = environment( monster )->query_destination( direcs[0], monster );
    } else
      destination = (string)MH->qdes( direcs[ 0 ], true_location );
    if ( (!destination && !virtual_move) || (sizeof(direcs) > 1 &&
                          member_array(destination, last_locs) != -1 ) ||
         (0 && stringp(destination) && !find_object(destination) && !virtual_move) ) {
      direcs = direcs[1..];
      continue;
    }
    move_zones = (string *)monster->query_move_zones();
    if ( sizeof( move_zones ) ) {
      if ( find_object( destination ) )
        room_zones = (string *)destination->query_zones();
      else
        room_zones = (string *)MH->query_zones( destination );
      if (!room_zones ||
          (sizeof(room_zones) == sizeof(room_zones - move_zones))) {
        direcs = direcs[1..];
        continue;
      }
    }
    break;
  }
  last_locs += ({ destination });
  if (sizeof(last_locs) > 4)
    last_locs = last_locs[sizeof(last_locs)-4..];
  monster->add_property( LAST_LOC_PROPERTY, last_locs);
  if (sizeof(direcs)) {
    if (1 || !virtual_move ||
        (right && monster->check_anyone_here()) ||
        (find_object( destination ) ) ) {
      object ob;
      if (!right) {
        ob = environment(monster);
        ob->remove_exit(direcs[0]);
        ob->add_exit(direcs[0], destination, "plain");
        reset_eval_cost();
      }
      monster->do_move(direcs[0]);
      if(!right)
        ob->remove_exit(direcs[0]);
    } else {
      if (virtual_move) {
        "/room/virtual"->force_load();
        monster->move( find_object("/room/virtual"));
        monster->set_true_location(destination);
      }
    }
  }
}
private void do_move_after() {
  object monster;
  int movetime, *move_after, zero;
  class wander_group tmp;
  reset_eval_cost();
  if(sizeof(wanderers) > 5000){
    wanderers=filter(wanderers, function(class wander_group thing){
      return sizeof(filter(thing->monsters, (:$1:)));
    });
    reset_eval_cost();
  }
  while (sizeof(wanderers) && wanderers[0]->movetime <= time()) {
    reset_eval_cost();
    tmp = wanderers[0];
    wanderers = wanderers[1..];
    foreach(monster in tmp->monsters){
      map_delete(wanderpos, monster);
      if (objectp(monster) && environment(monster)) {
        move_after = monster->query_move_after();
        if (move_after[0] || move_after[1]) {
          movetime = time() + move_after[ 0 ] + random( move_after[ 1 ] );
          if( movetime < (time() + 2) ) {
            movetime = time() + 2;
          }
          add_move_after( monster, movetime );
          reset_eval_cost();
          if (!travelpos[monster]) {
            do_wander(0, monster);
          }
        }
      } else {
        zero = 1;
      }
    }
  }
  if (find_call_out(after_call_out_id) == -1 && sizeof(wanderers)) {
    after_call_out_id = call_out((: do_move_after :),
                                        wanderers[0]->movetime - time());
  }
  if(zero) {
    wanderpos = filter(wanderpos, (: $1 :));
  }
}
mapping query_dynamic_auto_load() {
   return ([
    "wanderers" : wanderers,
    "wanderpos" : wanderpos,
    "travellers" : travellers,
    "travelpos" : travelpos
     ]);
}
void init_dynamic_arg(mapping map) {
  if (map) {
     wanderers = map["wanderers"];
     wanderpos = map["wanderpos"];
     travellers = map["travellers"];
     travelpos = map["travelpos"];
     do_move_after();
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/haggle_handler.c ===
#include <money.h>
mixed *accept_sayings, *bodged_sayings, *finalb_sayings,
    *finals_sayings, *insult_sayings, *offerb_sayings,
    *offers_sayings, *sodoff_sayings;
void create() {
  accept_sayings = ({
      ({ "grin", "Done!" }),
      "Accepted!",
      "Fine...",
      ({ "smile", "Agreed!" }),
      ({ "mutter", "Okay..." }),
      "Taken!",
      "You drive a hard bargain, but taken...",
      "You'll make me bankrupt, but it's a deal...",
      ({ "sigh", "I'll take it..." }),
      "My poor sick children will starve, but done!",
      "Finally!  I accept...",
      ({ "grimace", "Robbed again..." }),
      "A pleasure to do business with you!",
      ({ "scowl", "My spouse will have my hide, but accepted." }) });
  bodged_sayings = ({
      "I must have heard you wrong...",
      "What was that?",
      "I'm sorry, say that again...",
      "What did you say?",
      "Sorry, what was that again?" });
  finalb_sayings = ({
      "I'll pay no more than $offer$; take it or leave it.",
      "You'll get no more than $offer$ from me.",
      "$offer$ and that's final." });
  finals_sayings = ({
      "$asking$ is my lowest price; take it or leave it...",
      "It'll cost you no less than $asking$.",
      "My patience grows thin... $asking$ is final." });
  insult_sayings = ({
      "You will have to do better than that!",
      "That's an insult!",
      "Do you wish to do business or not?",
      "Hah!  Try again...",
      "Ridiculous!",
      "You've got to be kidding!",
      "You'd better be kidding!",
      "You're trying my patience...",
      "I didn't hear that.  Say it again?",
      "Hmmm... Nice weather we're having..." });
  offerb_sayings = ({
      "$asking$ for that piece of junk?  No more than $offer$.",
      "For $asking$ I could own ten of those.  Try $offer$.",
      "$asking$?!?  Never!  $offer$ is more like it...",
      "Let's be reasonable...  How about $offer$?",
      ({ "cough", "$offer$ for that junk, no more..." }),
      "$offer$ and be thankful for it!",
      "$offer$ and not an iotum more...",
      "$asking$?  Ha!  $offer$ is more like it...",
      "Try $offer$...",
      "I wouldn't pay $asking$ for your children!  Try $offer$.",
      ({ "choke", "For that?!?  Let's say $offer$." }),
      "How about $offer$?",
      "That looks like army surplus!  Say $offer$.",
      "I'll buy it as scrap for $offer$.",
      "$asking is too much; let us say $offer$." });
  offers_sayings = ({
      "$offer$ for such a fine item?  Hah!  No less than $asking$.",
      "$offer$ is an insult!  Try $asking$...",
      "$offer$?!?  You would rob my poor starving children?  "+
          "Even they would give $asking$ for this.",
      "Why, I'll take no less than $asking$.",
      ({ "cackle", "No less than $asking$." }),
      "You swine!  No less than $asking$.",
      "$offer$ is far too little;  how about $asking$?",
      "I paid more than $offer$ for it myself!  Try $asking$.",
      ({ "boggle", "$offer$?  Are you mad?!?  How about $asking$?" }),
      "As scrap this would bring $offer$.  Try $asking$.",
      "May the fleas of a thousand camels molest you.  "+
          "I want $asking$.",
      "My mother you can get for $offer$, "+
          "this will cost you $asking$.",
      "May your chickens grow lips!  I want $asking$!",
      "Sell this for such a pittance?  Give me $asking$.",
      "May the Grflx find you tasty!  $asking$?",
      "Your mother was a troll!  $asking$ or I'll tell..." });
  sodoff_sayings = ({
      ({ "Enough!",
          "You have abused my generosity once too often!",
          "Out of my establishment!" }),
      ({ "That does it!",
          "You will waste my time no more!",
          "Out...  Out...  OUT!!!" }),
      ({ "This is getting nowhere!",
          "Leave me alone!",
          "Come back tomorrow..." }),
      ({ "Bah!",
          "No more will you insult me!",
          "Leave my place!  Begone!" }),
      ({ "Begone!",
          "I have had enough abuse for one day.",
          "Come back when you're richer..." }) });
}
int insult_factor( object keeper, object customer ) {
  return 150;
}
int bargain_factor( object keeper, object customer ) {
  return 50;
}
int *sell_haggle( int value, int offer, int asking, int insults,
    string place, object keeper, object customer ) {
  int adjustment, number;
  string text;
  if ( offer > asking ) {
    keeper->do_command( "boggle" );
    number = random( sizeof( bodged_sayings ) );
    keeper->do_command( "'"+ bodged_sayings[ number ] );
    return ({ 0, asking, insults });
  }
  if ( offer == asking ) {
    number = random( sizeof( accept_sayings ) );
    if ( sizeof( accept_sayings[ number ] ) == 2 ) {
      keeper->do_command( accept_sayings[ number ][ 0 ] );
      keeper->do_command( "'"+ accept_sayings[ number ][ 1 ] );
    } else
      keeper->do_command( "'"+ accept_sayings[ number ] );
    return ({ 1, asking, insults });
  }
  if ( ( offer * insult_factor( keeper, customer ) ) >
      ( asking * 100 ) ) {
    adjustment = ( ( asking - offer ) *
        bargain_factor( keeper, customer ) ) / 100;
    if ( adjustment < 0 ) adjustment = 0;
    asking -= adjustment;
    number = random( sizeof( offers_sayings ) );
    if ( sizeof( offers_sayings[ number ] ) == 2 ) {
      keeper->do_command( offers_sayings[ number ][ 0 ] );
      text = offers_sayings[ number ][ 1 ];
    } else
      text = offers_sayings[ number ];
    text = replace( text, "$offer$",
        (string)MONEY_HAND->money_value_string( offer, place ) );
    text = replace( text, "$asking$",
        (string)MONEY_HAND->money_value_string( asking, place ) );
    keeper->do_command( "'"+ text );
    return ({ 0, asking, insults });
  }
  insults++;
  if ( insults < (int)keeper->query_property( "max insults" ) ) {
    number = random( sizeof( insult_sayings ) );
    keeper->do_command( "'"+ insult_sayings[ number ] );
    return ({ 0, asking, insults });
  }
  number = random( sizeof( sodoff_sayings ) );
  keeper->do_command( "lsay "+ sodoff_sayings[ 0 ] );
  keeper->do_command( "'"+ sodoff_sayings[ 1 ] );
  keeper->do_command( "'"+ sodoff_sayings[ 2 ] );
  return ({ 0, 0, -1 });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/fuel_handler.c ===
#include <fuel_handler.h>
object *burners;
void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   burners = ({ });
   call_out( "consume_fuel", FUEL_TIME );
}
void add_burner( object thing ) {
   burners += ({ thing });
}
void consume_fuel() {
   burners -= ({ 0 });
   catch( burners->consume_fuel() );
   call_out( "consume_fuel", FUEL_TIME );
}
void remove_burner( object thing ) {
   burners -= ({ thing });
}
object *query_burners() {
   return burners - ({ 0 });
}
mixed *stats() {
  return ({
    ({ "burners" , sizeof( burners ) }),
    ({ "next event", find_call_out( "consume_fuel" ) }),
   });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/clusters.c ===
#if !efun_defined(db_exec)
#define OLD
#else
#include <db.h>
#endif
#include <map.h>
#define SIZE 7
#define LEVEL(x) load(x)->level
#include <config.h>
nosave int maxnum = 0;
nosave int lasttime = 0;
nosave int count = 0;
nosave mapping used = ([ ]);
nosave mixed *todo= ({ });
nosave mapping cache = ([ ]);
nosave int setup_done = 1;
nosave int db;
nosave int setup_start_time;
class cluster{
  mixed *members;
  int level;
  int cluster_number;
  int this_cluster;
  mixed *contacts;
}
#ifndef OLD
private int get_cluster(mixed);
private mixed cdb_fetch(int fd, int row){
  mixed stuff = db_fetch(fd, row);
  if(arrayp(stuff)){
    mixed tmp, ret = ({});
    foreach(tmp in stuff){
      if(stringp(tmp)){
        int i;
        sscanf(tmp, "%d", i);
        if(i || tmp == "0")
          tmp = i;
      }
      ret += ({tmp});
    }
    stuff = ret;
  }
  return stuff;
}
#endif
private class cluster load(int x){
  mixed rows;
  class cluster tmp = new(class cluster);
  if(cache[x])
    return cache[x];
#ifdef OLD
  cache[x] = restore_variable(unguarded((: read_file(sprintf("/save/clusters/%d",
                                                           (int)$(x))) :)));
#else
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", x);
  if(stringp(rows) || !rows)
    return 0;
  tmp->members = ({});
  rows++;
  while(--rows)
    tmp->members += cdb_fetch(db, rows);
  rows = db_exec(db, "select level, in_cluster from cluster_list where cluster_number = %d", x);
  if(stringp(rows)){
    db_close(db);
    db = db_connect("localhost","discworld",CONFIG_DB_USER);
    return 0;
  }
  rows = cdb_fetch(db, 1);
  tmp->level = rows[0];
  tmp->cluster_number = rows[1];
  tmp->this_cluster = x;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", x);
  if(stringp(rows))
    return 0;
  tmp->contacts = ({});
  rows++;
  while(--rows)
    tmp->contacts += cdb_fetch(db, rows);
  cache[x] = tmp;
#endif
  return cache[x];
}
private void save(class cluster x){
#ifdef OLD
  unguarded((:write_file(sprintf("/save/clusters/%d", $(x->this_cluster)),
                           save_variable($(x)), 1):));
#else
  db_exec(db, "insert into cluster_list values (%d, %d, %d)", x->this_cluster,
          x->level, x->cluster_number);
  map(x->members, (:db_exec(db, "insert into cluster_members values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
  map(x->contacts, (:db_exec(db, "insert into cluster_contacts values (%d, '%s')",
                            $(x->this_cluster), db_escape(""+$1)):));
#endif
  cache[x->this_cluster] = x;
}
private void make_clusters(mixed);
nosave function fix_contacts;
nosave function fix_room_contacts;
private void create(){
#ifndef OLD
  db = db_connect("localhost","discworld",CONFIG_DB_USER);
  map(({"cluster_members", "cluster_list", "cluster_contacts"}),
      (:db_exec(db, "delete from %s;", $1):));
#endif
  fix_room_contacts = function(int i){
    class cluster fixing = load(i);
    if((sizeof(fixing->contacts)) && intp(fixing->contacts[0])){
      error(sprintf("%d in two or more clusters", i));
      return;
    }
    fixing->contacts = uniq_array(map(fixing->contacts,
#ifdef OLD
                                      (:MAP->query_cluster($1):)
#else
                                      (:cache[$1]:)
#endif
                                      ));
  save(fixing);
  };
  fix_contacts = function (int i){
    class cluster fixing = load(i);
    reset_eval_cost();
    if(fixing->level){
      if((sizeof(fixing->contacts)) && (fixing->level ==
                                        LEVEL(fixing->contacts[0]))){
        error(sprintf("%d in two or more clusters", i));
        return;
      }
      fixing->contacts = uniq_array(map(fixing->contacts,
                                        (:load($1)->cluster_number:)));
      save(fixing);
      if(fixing->level > 1){
        map(fixing->members, (:efun::call_out((fix_contacts), 0, $1):));
        return;
      }
      map(fixing->members, fix_room_contacts);
    }
  };
#ifdef OLD
  unguarded(function(){
    string file, *files=get_dir("/save/clusters/");
    foreach(file in files)
      rm(sprintf("/save/clusters/%s", file));
  });
#endif
}
private void make_clusters(mixed start){
  int count = 0, depth = -1, oldmax = maxnum, level = (stringp(start)? 0 :
                                                       load(start)->level + 1);
  class cluster current;
  mixed *list;
  function qdd, real;
  if(stringp(start)){
    qdd = function(string room){
      function f = function(string there, string room){
        mixed tmp;
        return member_array(room,
                            (tmp = MAP->qdd(there), tmp? tmp : ({}))) + 1;
      };
      string *qdd = MAP->qdd(room);
      return filter(allocate(sizeof(qdd) / 2, (:$(qdd)[$1 * 2 + 1]:)), f, room);
    };
    real = (:$1:);
  } else {
    qdd = (:load($1)->contacts:);
    if(stringp(load(start)->contacts[0]))
      real = (:cache[$1]:);
    else
      real = (:load($1)->cluster_number:);
  }
  current = new (class cluster, members:({start}),
                 level:level,
                 this_cluster:++maxnum,
                 contacts:({}));
  list = ({start});
  if(used[start])
    error(sprintf("%O already in a cluster", start));
  used[start] = 1;
  while(++depth < sizeof(list) || sizeof(todo)){
    mixed *exits;
    mixed exit;
    if(depth < sizeof(list))
      exits = (*qdd)(list[depth]);
    else {
      count = SIZE + 1;
      exits = ({});
    }
    foreach(exit in exits) {
      if(!used[exit = (*real)(exit)]) {
        current->members += ({exit});
        list += ({exit});
        used[exit] = 1;
        if(++count > SIZE)
          break;
      }
    }
    if(count > SIZE || !(((1 + depth) < sizeof(list)) || sizeof(todo))){
      mixed tmp, *contacts = ({});
      count = 0;
      foreach(tmp in current->members){
        reset_eval_cost();
        if(stringp(tmp)){
#ifdef OLD
          MAP->set_cluster(tmp, current->this_cluster)
#endif
          ;
          cache[tmp] = current->this_cluster;
        }
        else{
          class cluster clust;
          clust = load(tmp);
          clust->cluster_number = current->this_cluster;
          cache[tmp] = clust;
        }
        exits = (*qdd)(tmp);
        if(exits){
          function add_non_member, convert_and_add;
          add_non_member = (: (member_array($2, $(current->members)) == -1)?
                            ($1 | ({ $2 })) :
                            $1
                           :);
          convert_and_add = (:evaluate($(add_non_member), $1,
                                      evaluate($(real), $2)):);
          contacts = implode(exits, convert_and_add, contacts);
        }
      }
      current->contacts = contacts;
      if(sizeof(contacts) || current->level > 1)
        cache[current->this_cluster] = current;
      else
        maxnum--;
      todo = filter(todo + list + contacts, (:!used[$1]:));
      depth = -1;
      if(sizeof(todo)){
        list = ({todo[0]});
        todo = todo[1..];
        if(used[list[0]])
          error("corrupt todo list");
        used[list[0]] = 1;
        current = new (class cluster, members:({list[0]}),
                       level:level,
                       this_cluster:++maxnum,
                       contacts:({}));
      } else
        list = ({ });
    }
  }
  if((maxnum - oldmax) > SIZE)
    make_clusters(current->this_cluster - 1);
  else {
    int i;
    for(i = oldmax + 1; i <= maxnum; i++)
      if(LEVEL(i))
        efun::call_out(fix_contacts, 0, i);
      else
        efun::call_out(fix_room_contacts, 0, i);
  }
  used = ([]);
  efun::call_out((:cache = ([]), setup_done = 1:), 2);
}
#ifndef OLD
private int get_cluster(mixed thing){
  if(stringp(thing)){
    mixed exret = db_exec(db, "select cluster_number from cluster_members where member = '%s'",
                          db_escape(thing));
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  } else if(intp(thing)){
    mixed exret = db_exec(db, "select in_cluster from cluster_list where cluster_number = %d",
                          thing);
    if(!stringp(exret) && exret){
      return cdb_fetch(db, 1)[0];
    }
  }
  return 0;
}
#endif
private int query_top_cluster(string room){
  int ret;
#ifdef OLD
  ret = MAP->query_cluster(room);
  if(ret && unguarded((:file_size(sprintf("/save/clusters/%d", $(ret))):)) > 0)
    while(load(ret)->cluster_number){
      int last = ret;
      ret = load(ret)->cluster_number;
      if(last == ret)
        return ret;
    }
#else
  ret = get_cluster(room);
  if(ret){
    int last = ret;
    ret = get_cluster(ret);
    while(ret){
      last = ret;
      ret = get_cluster(ret);
    }
    return last;
  }
#endif
  else{
    setup_start_time = time();
    setup_done = 0;
    make_clusters(room);
  }
  return ret;
}
#ifndef OLD
private mixed *get_members(int clust){
  mixed rows;
  rows = db_exec(db, "select member from cluster_members where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
private mixed *get_contacts(int clust){
  mixed rows;
  rows = db_exec(db, "select contact from cluster_contacts where cluster_number = %d", clust);
  if(stringp(rows))
    return ({ });
  return allocate(rows, (:cdb_fetch(db, $1 + 1)[0]:));
}
#endif
private mixed *find_places(int start, int end, int *places){
  int found = 0, depth = 0;
  int *key;
  int *exits, bing, *result, ob, exit;
  mapping search = ([]);
  if(start == end){
#ifdef OLD
    return load(start)->members;
#else
    return get_members(start);
#endif
  }
  key = ({ start });
  search[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
#ifdef OLD
      exits = load(ob)->contacts;
#else
      exits = get_contacts(ob);
#endif
      foreach(exit in exits) {
        if ((!search[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && ++depth >= sizeof(key))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
#ifdef OLD
    result += load(bing)->members;
#else
    result += get_members(bing);
#endif
    bing = search[bing];
  }
#ifdef OLD
  result += load(bing)->members;
#else
  result += get_members(bing);
#endif
  return result;
}
private mixed find_route(mixed start, mixed end, string *places){
  int found = 0, i, depth = 0;
  string *key;
  string *exits, bing, *result, ob;
  mapping route = ([]), search = ([]);
  int t = real_time();
  if(start == end)
    return ({});
  key = ({ start });
  route[start] = "binglewop";
  while (!found) {
    reset_eval_cost();
    ob = key[depth];
    if (ob) {
      exits = MAP->qdd(ob);
      for (i = 1; i < sizeof(exits); i += 2) {
        mixed exit = exits[i];
        if ((!route[exit]) && (member_array(exit, places) != -1 ||
                               sizeof(places) == 0)) {
          route[exit] = exits[i - 1];
          search[exit] = ob;
          key += ({ exit });
          if (exit == end)
            found = 1;
        }
      }
    }
    if (!found && (++depth >= sizeof(key) || (real_time() - t) > 4))
      return 0;
  }
  exits = ({ });
  bing = end;
  result = ({ });
  while (bing != start) {
    reset_eval_cost();
    result = ({route[bing]}) + result;
    bing = search[bing];
  }
  return result;
}
nosave int debugging = 0;
private void debug(int *clusters){
  int cluster;
  if(debugging)
    error("read the error trace");
  debugging = 1;
  reset_eval_cost();
  while(intp(load(clusters[0])->members[0]))
    clusters = implode(clusters, (:$1 + load($2)->members:), ({}));
  foreach(cluster in clusters){
    string *rooms = load(cluster)->members;
    string room, room2;
    reset_eval_cost();
    foreach(room in rooms)
      foreach(room2 in rooms)
        if(!this_object()->get_route(room, room2))
          error("cluster error");
  }
}
string* get_route(string start, string end, function callback){
  mixed *places = ({}), *oldplaces;
  int sip = 0;
  int from, to;
  int level;
  if(lasttime != time()){
    lasttime = time();
    count = 0;
  } else {
    if(count++ > 10) {
      return ({});
    }
  }
  if(!setup_done){
    if((time()-setup_start_time) < 5)  {
      return 0;
    }
#ifndef OLD
#endif
    catch(unguarded(function(){
      cp("/log/runtime", "/w/wodan/clusterruntime");
      cp("/log/catch", "/w/wodan/clustercatch");
    }));
    tell_creator("wodan", "would have dested");
    setup_done = 1;
    return 0;
  }
  if(!stringp(start)){
    start = base_name(start);
    if(!stringp(start))
      error("illegal start point");
  }
  if(!stringp(end)){
    end = base_name(end);
    if(!stringp(end))
      error("illegal end point");
  }
  if(catch(from = query_top_cluster(start))){
#ifndef OLD
    db_close(db);
    db = db_connect("localhost","discworld", CONFIG_DB_USER);
#endif
    return 0;
  }
  if(!setup_done) {
    return 0;
  }
  if(from) {
    level = LEVEL(from);
  }
  to = query_top_cluster(end);
  if(!to || (level != LEVEL(to))) {
    return ({});
  }
  while (level) {
#ifdef OLD
    from = MAP->query_cluster(start);
    to = MAP->query_cluster(end);
#else
    from = get_cluster(start);
    to = get_cluster(end);
#endif
    while((from != to) && (LEVEL(from) < level)){
      from = load(from)->cluster_number;
      to = load(to)->cluster_number;
    }
    level = LEVEL(from);
    if(!level){
      if(!sip) {
        break;
      }
      error("wrong level");
    }
    oldplaces = places;
    places = find_places(from, to, places);
    if(!places){
      if(!sip) {
        return ({});
      }
      debug(oldplaces);
      error("this can't happen, honest!");
    }
    sip = 1;
    level--;
  }
#ifdef OLD
  from = MAP->query_cluster(start);
  to = MAP->query_cluster(end);
#else
  from = get_cluster(start);
  to = get_cluster(end);
#endif
  oldplaces = places;
  places = find_places(from, to, places);
  if(!places){
    if(!sip) {
      return ({});
    }
    debug(oldplaces);
    error("this can't happen, honest!!");
  }
  cache = ([]);
  return find_route(start, end, places);
}
#ifndef OLD
void dest_me(){
  db_close(db);
  destruct(this_object());
}
#endif

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/armoury.c ===
#include <move_failures.h>
#include <armoury.h>
#define MAX_RECYCLE 6
inherit "/std/room/basic_room";
#define DEFAULT_RECYCLE_AREA "default"
#define SAVE "/save/armoury"
#define TYPES ({"armours", "clothes", "weapons", "plants", "foods", "scabbards", "jewelleries", "misc" })
private nosave int _total_requests;
private mapping _smalls;
private mapping _armour_list;
private mapping _weapon_list;
private mapping _clothing_list;
private mapping _jewellery_list;
private mapping _scabbard_list;
private mapping _food_list;
private mapping _misc_list;
private mapping _plant_list;
private mapping _areas;
private mapping forbidden;
private void rehash_all();
int rehash(string place);
string* walk_directory (string);
void save_me() {
   unguarded( (: save_object(SAVE, 3) :));
}
void load_me() {
   unguarded( (: restore_object(SAVE, 1) :));
}
void setup() {
   set_short( "" + mud_name() + " Armoury" );
   add_property( "determinate", "the " );
   set_light( 50 );
   set_long( "You are in the " + mud_name() + " Armoury.  From here you can list "
         "all of the \"weapons\", \"armour\", \"clothing\", \"jewellery\", "
         "\"food\", \"plants\", \"misc\" "
         "and \"scabbards\" that are available, and \"request\" one of "
         "them.  The armoury stores its list of items in mappings, which "
         "can be updated with \"rehash\".  The list of forbidden items "
         "can be listed out or added to with \"forbid\".\n" );
   _smalls = ([ ]);
   _areas = ([ ]);
   _armour_list = _weapon_list = _clothing_list = _plant_list = _misc_list =
      _jewellery_list = _scabbard_list = _food_list = ([ ]);
   load_me();
   rehash_all();
}
object *query_smalls(string area) {
   if (!area) {
      area = DEFAULT_RECYCLE_AREA;
   }
   return _smalls[area];
}
mapping query_area(string domain) {
  if (_areas[domain]) {
      return _areas[domain];
  }
  return ([ ]);
}
int request(string, int, string);
int forbid(string);
void init() {
   string comm;
   ::init();
   add_command("rehash", "{foods|clothes|weapons|armours|misc|jewelleries|"
                         "scabbards|plants}",
                (:rehash($4[0]) :));
   add_command("rehash", "domain <string'domain'>",
                (:rehash($4[0]) :));
   add_command("request", "<string'item name'> <number'percent'>",
                (:request($4[0], $4[1], 0):));
   add_command("request", "<string'item name'> <number'percent'> in <string'area'>",
               (:request($4[0], $4[1], $4[2]):));
   add_command("forbid", "", (:forbid, "":));
   add_command("forbid", "<string'name'>", (:forbid($4[0]):));
   foreach(comm in ({"weapons", "armour", "clothing", "jewellery", "plant",
                     "misc", "scabbards", "food", })) {
      add_command(comm, "", (:call_other(this_object(), $(comm)):));
   }
}
mapping make_list(string base_dir, string *extensions) {
  string *dirs, dir, extension, file_name;
  mapping list;
  dirs = walk_directory (base_dir);
  list = ([ ]);
  foreach(dir in dirs) {
    foreach(extension in extensions) {
      foreach(file_name in unguarded((: get_dir, dir+"*"+extension :))) {
        if (file_name[0] != '.') {
          list[ replace_string(explode(file_name, ".")[0], "_", " ") ] =
                    dir + "" + file_name;
        }
      }
    }
  }
  return list;
}
int clean_up(int i) { return 0; }
object choose_small_item(string area) {
  object ob;
  if(!area)
    area = DEFAULT_RECYCLE_AREA;
  if(!_smalls || !_smalls[area] || !arrayp(_smalls[area]) || !_smalls[area][0])
    return 0;
  ob = clone_object(_smalls[area][0]);
  _smalls[area] = _smalls[area][1..];
  return ob;
}
object request_item(string word, int percent, string area) {
  int add_area;
  object thing;
  string filename;
  if(!word) {
    return 0;
  }
  if (!area) {
    area = DEFAULT_RECYCLE_AREA;
  }
  if (_areas[area] &&
      _areas[area][word]) {
    filename = _areas[area][word];
    add_area = 1;
  } else if(_weapon_list[word]) {
    filename = _weapon_list[word];
  } else if(_armour_list[word]) {
    filename = _armour_list[word];
  } else if(_clothing_list[word]) {
    filename = _clothing_list[word];
  } else if(_jewellery_list[word]) {
    filename = _jewellery_list[word];
  } else if(_scabbard_list[word]) {
    filename = _scabbard_list[word];
  } else if(_misc_list[word]) {
    filename = _misc_list[word];
  } else if(_plant_list[word]) {
    filename = _plant_list[word];
  } else if(_food_list[word]) {
    filename = _food_list[word];
  } else {
    if(base_name(previous_object()) != "/cmds/creator/req_uest") {
      printf( "No file for item \"%s\".\n", word );
      log_file( "ARMOURY", "%s No file for %s (%s)\n", ctime(time())[4..9],
                word, file_name( previous_object() ) );
    }
    return 0;
  }
  if(file_size( filename ) > 0)
    thing = clone_object(filename);
  if(!thing) {
    printf( "Cannot find item \"%s\".\n", word );
    log_file( "ARMOURY", "Cannot find %s (%s)\n", word,
              file_name( previous_object() ) );
    return 0;
  }
  _total_requests++;
  if(!_smalls[area])
    _smalls[area] = ({ });
  if(sizeof(_smalls[area]) < 20 &&
     thing->query_weight() < roll_MdN(5, 20) &&
     thing->query_value() < random(4000) &&
     !thing->query_liquid() &&
     !sizeof((mapping)thing->query_value_info()) &&
     strsrch(filename, "_pt") == -1 &&
     strsrch(filename, "_dev") == -1 &&
     !thing->query_property("no recycling")) {
    _smalls[area] += ({ filename });
  }
  if (add_area)
    thing->add_property(ARMOURY_RECYCLING_AREA_PROP, area);
  thing->set_percentage( percent );
  return thing;
}
string remap_file_path(string path) {
   string* bits;
   mapping list;
   string new_fname;
   bits = explode(path, "/");
   if (bits[0] != "obj") {
      return path;
   }
   switch (bits[1]) {
   case "armours" :
      list = _armour_list;
      break;
   case "weapons" :
      list = _weapon_list;
      break;
   case "clothes" :
      list = _clothing_list;
      break;
   case "jewellery" :
      list = _jewellery_list;
      break;
   case "scabbards" :
      list = _scabbard_list;
      break;
   case "food" :
      list = _food_list;
      break;
   case "misc" :
      list = _misc_list;
      break;
   case "plants" :
      list = _plant_list;
      break;
   }
   if (list) {
      new_fname = list[replace_string(explode(bits[<1], ".")[0], "_", " ")];
      if (new_fname) {
         return new_fname;
      }
   }
   return path;
}
int rehash(string thing) {
  string special;
  int found;
  switch (thing) {
  case "armours" :
     _armour_list=make_list("/obj/armours/", ({".arm", ".c"}));
     break;
  case "clothes" :
     _clothing_list=make_list("/obj/clothes/", ({".clo", ".c"}));
     break;
  case "weapons" :
     _weapon_list = make_list("/obj/weapons/", ({".wep", ".c"}));
     break;
  case "scabbards" :
     _scabbard_list = make_list( "/obj/scabbards/", ({ ".sca", ".c" }));
     break;
  case "jewellery" :
  case "jewelleries" :
     _jewellery_list = make_list( "/obj/jewellery/", ({ ".arm", ".clo", ".c" }));
     break;
  case "food" :
  case "foods" :
     _food_list = make_list( "/obj/food/", ({ ".ob", ".food", ".c" }));
     break;
  case "misc" :
     _misc_list = make_list( "/obj/misc/", ({ ".ob", ".c" }));
     break;
  case "plants" :
     _plant_list = make_list( "/obj/plants/", ({ ".ob", ".food", ".c" }));
     break;
  default :
    if (file_size("/d/" + thing + "/items") == -2) {
      _areas[thing] = make_list( "/d/" + thing + "/items/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca",
                                     ".ob", ".food" }));
      found = 1;
    }
    if (file_size("/d/" + thing + "/armoury") == -2) {
      foreach (special in get_dir("/d/" + thing + "/armoury")) {
         if (file_size("/d/" + thing + "/armoury/" + special + "/") == -2) {
           _areas[special] = make_list( "/d/" + thing + "/armoury/" + special + "/",
                                  ({ ".arm", ".c", ".clo", ".wep", ".sca" }));
         }
      }
       return 0;
    }
  }
  save_me();
  write("Rehash of " + thing + " complete.\n");
  return 1;
}
int rehash_specific_dir(string dir) {
   return rehash(explode(dir, "/")[1]);
}
private void rehash_all() {
  string thing;
  int i;
  foreach(thing in TYPES + "/secure/master"->query_domains()) {
    i += 5;
    call_out("rehash", i, thing);
  }
}
string *query_types() { return TYPES + keys(_areas); }
mapping query_items(string type, string filter) {
  mapping items;
  string item;
  switch(type) {
  case "armours":
    items = _armour_list;
    break;
  case "weapons":
    items = _weapon_list;
    break;
  case "clothes":
    items = _clothing_list;
    break;
  case "jewellery":
  case "jewelleries":
    items = _jewellery_list;
    break;
  case "scabbards":
    items = _scabbard_list;
    break;
  case "food":
  case "foods":
    items = _food_list;
    break;
  case "misc":
    items = _misc_list;
    break;
  case "plants":
    items = _plant_list;
    break;
  default:
    if(member_array(type, "/secure/master"->query_domains()) != -1 &&
       _areas[type])
      items = _areas[type];
    else
      return 0;
  }
  items = copy (items);
  if (sizeof (filter)) {
    foreach(item in keys(items))
      if(strsrch(item, filter) == -1)
        map_delete(items, item);
  }
  return items;
}
int request( string word, int percentage, string area ) {
  object thing;
  thing = request_item( word, percentage, area );
  if ( !thing ) {
    add_failed_mess(word + " not found.\n");
    return 0;
  }
  if ( (int)thing->move( this_player() ) != MOVE_OK ) {
    write( (string)thing->a_short() +" has been placed in here.\n" );
    thing->move( this_object() );
  } else
    write( (string)thing->a_short() +
          " has been placed in your inventory.\n" );
  return 1;
}
mixed stats() {
  string tmp;
  mixed *ret;
  ret = ({ });
  foreach(tmp in keys(_areas)) {
    ret += ({ tmp, sizeof(_areas[tmp]) });
  }
  return ::stats() + ({
    ({ "item requests", _total_requests, }),
      ({ "armours", sizeof(_armour_list) }),
      ({ "clothes", sizeof(_clothing_list) }),
      ({ "weapons", sizeof(_weapon_list) }),
      ({ "scabbards", sizeof(_scabbard_list) }),
      ({ "jewellery", sizeof(_jewellery_list) }),
      ({ "food", sizeof(_food_list) }),
      ({ "misc", sizeof(_misc_list) }),
      ({ "plants", sizeof(_plant_list) }),
      ret });
}
string* walk_directory (string dir) {
  string *tmp, *dirs = ({ }), *tmp2;
  mixed *file;
  tmp = get_dir(dir, -1);
  if (sizeof (tmp))
    dirs += ({dir});
  foreach(file in tmp) {
    if(file[1] == -2) {
      tmp2 = walk_directory (dir + file [0] + "/");
      if (sizeof (tmp2))
        dirs += tmp2;
    }
  }
  return dirs;
}
