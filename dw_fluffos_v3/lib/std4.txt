
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/basic/enchant.c ===
nosave private int _enchanted;
nosave private int _set_enchant_time;
nosave private int _degrade_enchant;
#define ENCHANT_DEGRADE_TIME (8 * 7 * 24 * 60 * 60)
int query_max_enchant()
{
   return 5 + (int) this_object()->query_weight() / 4;
}
int query_degrade_enchant() {
   if (!_degrade_enchant) {
      return this_object()->query_max_enchant() / 2;
   }
   return _degrade_enchant;
}
void set_degrade_enchant(int enchant) {
   if (enchant > this_object()->query_max_enchant()) {
      enchant = this_object()->query_max_enchant();
   }
   _degrade_enchant = enchant;
}
string enchant_string()
{
   string tal_msg;
   string ench_msg;
   if (this_object()->query_property("talisman")) {
      tal_msg = (string) this_object()->query_property("talisman_mess");
      if (!tal_msg)
         tal_msg = "It has the hazy octarine sparkle of a magical talisman.";
      tal_msg += "\n";
   } else {
      tal_msg = "";
   }
   if (this_object()->query_property("octarine_mess")) {
      ench_msg = (string) this_object()->query_property("octarine_mess")
         + "\n";
   } else {
      switch ((this_object()->query_enchant() * 100) /
              this_object()->query_max_enchant()) {
      case 1..10:
         ench_msg = "It occasionally pulses with octarine light.\n";
         break;
      case 11..20:
         ench_msg = "It emits a slight octarine glow.\n";
         break;
      case 21..30:
         ench_msg = "It softly pulses in dull octarine shades.\n";
         break;
      case 31..40:
         ench_msg = "It gives off a steady but dull octarine glow.\n";
         break;
      case 41..50:
         ench_msg = "It gives off a steady octarine glow.\n";
         break;
      case 51..60:
         ench_msg = "It glows an intense octarine.\n";
         break;
      case 61..70:
         ench_msg = "It emits a bright octarine colour.\n";
         break;
      case 71..80:
         ench_msg = "It brightly pulses octarine.\n";
         break;
      case 81..90:
         ench_msg = "It glows brilliant octarine shades.\n";
         break;
      case 91..100:
         ench_msg = "It radiates pure octarine brilliance.\n";
         break;
      default:
         ench_msg = "";
      }
   }
   return ench_msg + tal_msg;
}
void set_enchant(int number)
{
   if (number > this_object()->query_max_enchant()) {
      number = this_object()->query_max_enchant();
   }
   _set_enchant_time = time();
   _enchanted = number;
}
int add_enchant(int number)
{
   set_enchant(this_object()->query_enchant() + number);
   return _enchanted;
}
int query_enchant()
{
   int max;
   int tmp;
   int tmp2;
   int degrade;
   max = this_object()->query_max_enchant();
   if (_enchanted > max) {
      _enchanted = max;
   }
   degrade = this_object()->query_degrade_enchant();
   if (_enchanted > degrade) {
      if (!_set_enchant_time) {
         _set_enchant_time = time();
      }
      if (time() - _set_enchant_time >= ENCHANT_DEGRADE_TIME) {
         _enchanted = degrade;
      } else {
         tmp2 = tmp = (_enchanted - degrade) * 100 + 99;
         tmp *= 100 - (((time() - _set_enchant_time) * 100) /
                       ENCHANT_DEGRADE_TIME);
         return degrade + (tmp / 10000);
      }
   }
   return _enchanted;
}
int query_real_enchant()
{
   return _enchanted;
}
int query_enchant_set_time()
{
   return _set_enchant_time;
}
protected void set_enchant_set_time(int tim)
{
   _set_enchant_time = tim;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/basic/id_match.c ===
#include <obj_parser.h>
private int _no_all;
protected void set_no_all(int no_all) {
   _no_all = no_all;
}
int query_no_all() {
   return _no_all;
}
protected int is_matching_object(string* input,
                          object viewer,
                          class obj_match_context context )
{
   string *adj;
   string *padj;
   string *names;
   string *pnames;
   int n;
   int ret;
   if( this_object() == context->him &&
       input[<1] == "him" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->her &&
              input[<1] == "her" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->it &&
              input[<1] == "it" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( context->plural &&
              input[<1] == "them" &&
              member_array( this_object(), context->plural ) != -1 ) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if( this_object() == viewer &&
              input[<1] == "me" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if (!_no_all && input[<1] == "all") {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "things" || input[<1] == "ones")) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "thing" || input[<1] == "one")) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   }
   if (!ret) {
      if (input[<1] == "here" &&
          viewer != environment() &&
          sizeof(input) > 1) {
         input = input[0..<2];
      }
      names = this_object()->parse_command_id_list();
      pnames = this_object()->parse_command_plural_id_list();
      if( member_array( input[<1], pnames ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_PLURAL;
      }
      if( member_array( input[<1], names ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_SINGULAR;
      }
      if (!ret) {
         return 0;
      }
   }
   adj = this_object()->parse_command_adjectiv_id_list();
   padj = this_object()->parse_command_plural_adjectiv_id_list();
   if( environment() == context->him ) {
      adj += ({ "his" });
   } else if( environment() == context->her ) {
      adj += ({ "her" });
   } else if( environment() == context->it ) {
      adj += ({ "its" });
   } else if( environment() == viewer ) {
      adj += ({ "my" });
   } else if( context->plural &&
                   member_array( environment(), context->plural ) != -1 ) {
      adj += ({ "their" });
   }
   for( n = 0; n < sizeof( input ) - 1; n++ )
   {
      if( member_array( input[n], adj ) == -1 ) {
         if (!padj || member_array(input[n], padj) == -1) {
            return 0;
         } else {
            ret &= ~OBJ_PARSER_MATCH_SINGULAR;
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }
   return ret;
}
protected int update_parse_match_context(class obj_match_context context,
                                         int num,
                                         int singular) {
   if (context->ordinal) {
      if (context->ordinal == -1) {
         return 1;
      }
      if (context->ordinal > num) {
         context->ordinal -= num;
         return 0;
      }
      context->ignore_rest = 1;
      return 1;
   } else if (context->number_included) {
      if (context->number_included <= num) {
         context->ignore_rest = 1;
         num = context->number_included;
         context->number_included = 0;
         return num;
      }
      context->number_included -= num;
      return num;
   } else {
      if (num > 0 && (singular & OBJ_PARSER_MATCH_SINGULAR)) {
         return 1;
      }
      return num;
   }
}
mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   int ret;
   ret = is_matching_object(input, viewer, context);
   if (!ret) {
      return 0;
   }
   if (!update_parse_match_context(context, 1, ret)) {
      return 0;
   }
   return ({ ret, ({ this_object() }) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/basic/club_insignia.c ===
#include <clubs.h>
inherit "/std/basic/club_listing";
inherit "/std/basic/club_discuss";
#include <broadcaster.h>
#define SAVE_START "club_insignia"
#define NOMINATION_STATE 1
#define ELECTION_STATE   2
private nosave string _club;
private nosave int _channel_off;
private nosave int _last_state;
private nosave int _last_club_time;
private nosave int _callout_id;
private nosave string _brief_string;
private nosave int _brief_mode;
private string *query_not_voted_for(string name);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int do_history();
protected int do_channel_off(int new_value);
protected int do_resign();
protected int do_resign_position(string name);
protected int do_disbar(string name);
protected int do_brief_mode(int mode);
protected int do_brief_string(string str);
private int query_has_nominated_someone(string name);
private void check_announce(object player);
protected int do_announcement();
string query_club();
private void add_broadcaster() {
   if (query_club()) {
      BROADCASTER->add_object_to_channel(lower_case(query_club()),
                                         this_object());
   }
}
void set_club(string club) {
   if (_club) {
      BROADCASTER->remove_object_from_channel(lower_case(_club),
                                              this_object());
   }
   if (club) {
      _club = CLUB_HANDLER->query_club_name(club);
      add_broadcaster();
   } else {
      _club = 0;
   }
}
string query_club() {
   return _club;
}
protected void add_elected_commands(object per) {
   string tmp_name;
   string *not_voted;
   int announce;
   if (!query_club()) {
      return ;
   }
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command(tmp_name, this_object(), "announcement",
               (: do_announcement() :));
   per->add_command(tmp_name,
                    this_object(),
                    "resign as <string'position'>",
                    (: do_resign_position($4[0]) :) );
   if (CLUB_HANDLER->is_nomination_in_progress(query_club())) {
      if (_last_state != NOMINATION_STATE ||
           _last_club_time + 24 * 60 * 60 < time()) {
         _last_state = NOMINATION_STATE;
         _last_club_time = time();
         if (!query_has_nominated_someone(this_player()->query_name())) {
            call_out((: tell_object($1,
                "%^YELLOW%^The club '" + query_club() + "' is currently accepting "
                "nominations for positions.%^RESET%^\n") :), 2, this_player());
         }
      }
   } else if (CLUB_HANDLER->is_voting_in_progress(query_club())) {
      if (_last_state != ELECTION_STATE ||
          _last_club_time + 24 * 60 * 60 < time()) {
         _last_state = ELECTION_STATE;
         _last_club_time = time();
         not_voted = query_not_voted_for(this_player()->query_name());
         if (sizeof(not_voted)) {
            call_out((: tell_object($1,
                "%^YELLOW%^You have not voted for " +
                query_multiple_short($(not_voted)) + " in '" + query_club() +
                "'.%^RESET%^\n") :), 2, this_player());
         }
      }
   } else {
      _last_state = 0;
   }
   announce = CLUB_HANDLER->query_announcement_time(query_club());
   if (announce &&
       announce != this_player()->query_property(_club + " announce time")) {
      remove_call_out(_callout_id);
      _callout_id = call_out((: check_announce :), 0, this_player());
   }
   this_player()->add_property(_club + " announce time",
              this_player()->query_property(_club + " announce time"),
                                  4 * 7 * (24 * 60 * 60));
   club_discuss::add_elected_commands(per);
}
protected void add_club_commands(object per) {
   string tmp_name;
   if (!query_club()) {
      return ;
   }
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command("recruit",
                    this_object(),
                    "<indirect:living'player'> into <string'club'>",
                  (: do_recruit($1, $4[1]) :) );
   per->add_command(tmp_name,
                    this_object(),
                    "members",
                         (: club_members(query_club(), 0, this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "recruit <indirect:living'player'>",
                         (: do_recruit($1, query_club()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "members {online|listening}",
                         (: club_members(query_club(), ($4[0]=="online"?1:2),
                                         this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "info",
                         (: club_info(query_club(), 1,
                                      this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "talk <string>", (: club_chat($4[0], 0) :));
   per->add_command(tmp_name,
                    this_object(),
                    "emote <string>", (: club_chat($4[0], 1) :));
   per->add_command(tmp_name,
                    this_object(),
                    "history", (: do_history() :));
   per->add_command(tmp_name,
                    this_object(),
                    "resign", (: do_resign() :));
   per->add_command(tmp_name,
                    this_object(),
                    "disbar <string'member'>", (: do_disbar($4[0]) :));
   per->add_command(tmp_name,
                    this_object(),
                    "mute {on|off}",
                    (: do_channel_off($4[0] == "on") :));
   per->add_command(tmp_name,
                    this_object(),
                    "brief {on|off}",
                    (: do_brief_mode($4[0] == "on") :));
   per->add_command(tmp_name,
                    this_object(),
                    "brief name <string'brief name'>",
                    (: do_brief_string($4[0]) :));
   club_discuss::add_club_commands(per);
   if (CLUB_HANDLER->is_elected_club(query_club())) {
      add_elected_commands(this_player());
   }
}
void init() {
   if (query_club() &&
       this_player() == environment() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      this_player()->add_player_club(query_club());
      add_club_commands(this_player());
   } else {
      this_player()->remove_player_club(query_club());
   }
}
private void check_announce(object player) {
   int announce;
   if (!query_club()) {
      return ;
   }
   announce = CLUB_HANDLER->query_announcement_time(query_club());
   if (this_player() &&
       announce &&
       announce != this_player()->query_property(_club + " announce time")) {
      remove_call_out(_callout_id);
      call_out((: check_announce :), 15 * 60, player);
      tell_object(player,
                  "\n%^YELLOW%^The club '" +
                  CLUB_HANDLER->query_club_name(query_club()) +
                  "' has a new announcement.\n%^RESET%^\n");
   }
}
private int query_has_nominated_someone(string name) {
   string *positions;
   string pos;
   string *people;
   string person;
   positions = CLUB_HANDLER->query_valid_positions(query_club());
   foreach (pos in positions) {
      people = CLUB_HANDLER->query_nominated_for(query_club(), pos);
      foreach (person in people) {
         if (member_array(name,
                 CLUB_HANDLER->query_nominators_for(query_club(), pos, person)) != -1) {
            return 1;
         }
      }
   }
   return 0;
}
private string *query_not_voted_for(string name) {
   string *positions;
   positions = CLUB_HANDLER->query_valid_positions(query_club());
   positions = filter(positions,
         (: !CLUB_HANDLER->has_person_voted(query_club(), $1, $(name)) &&
            sizeof(CLUB_HANDLER->query_nominated_for(query_club(), $1)) > 1 :));
   return positions;
}
int query_channel_off() {
   return _channel_off;
}
int query_brief_mode() {
   return _brief_mode;
}
string query_brief_string() {
   return _brief_string;
}
protected int club_chat(string str, int emote) {
   string player_name;
   string channel_name;
   string colour;
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You can only chat to clubs you are a member of.\n");
      return 0;
   }
   if (_channel_off) {
      add_failed_mess("You have your club channel turned off.\n");
      return 0;
   }
   player_name = this_player()->query_cap_name();
   if (this_player()->query_family_name()) {
      player_name += " " + this_player()->query_family_name();
   }
   BROADCASTER->broadcast_to_channel(this_player(),
                                     lower_case(query_club()),
                                     ({ str, emote }));
   if (_brief_mode) {
      channel_name = _brief_string;
   } else {
      channel_name = query_club();
   }
   colour = this_player()->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
   if (emote) {
      write("$I$5=(" + colour + channel_name +
            "%^RESET%^) " + player_name +
            " " + str + "\n");
   } else {
      write("$I$5=(" + colour + channel_name +
            "%^RESET%^) " + player_name +
            ": " + str + "\n");
   }
   if (!this_player()->query_hide_invis()["hiding"] &&
       !this_player()->query_invis()) {
      add_succeeded_mess(({ "",
                            "$N stare$s intently into space for a bit.\n" }));
   }
   return 1;
}
void event_channel_message(object ob, string channel, mixed *data) {
   object our_player;
   int emote;
   string message;
   string player_name;
   string channel_name;
   string colour;
   if (channel != lower_case(query_club())) {
      return ;
   }
   our_player = environment();
   if (our_player &&
       userp(our_player) &&
       our_player != this_player()) {
      if (sizeof(our_player->query_ignoring( ({ ob }) ))) {
          return ;
      }
      emote = data[CLUB_MESSAGE_EMOTE_INDEX];
      message = data[CLUB_MESSAGE_MESSAGE_INDEX];
      if (CLUB_HANDLER->is_member_of(query_club(), our_player->query_name()) &&
          !_channel_off) {
         player_name = ob->query_cap_name();
         if (ob->query_family_name()) {
            player_name += " " + ob->query_family_name();
         }
         if (_brief_mode) {
            channel_name = _brief_string;
         } else {
            channel_name = query_club();
         }
         colour = our_player->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
         if (emote) {
            our_player->add_message("$I$5=(" + colour + channel_name +
                                    "%^RESET%^) " +
                                    player_name + " " + message +
                                    "\n%^RESET%^", ({ }));
         } else {
            our_player->add_message("$I$5=(" + colour + channel_name +
                                    "%^RESET%^) " +
                                    player_name + ": " + message +
                                    "\n%^RESET%^", ({ }));
         }
      }
   }
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      map = ([ ]);
   }
   map[SAVE_START + "club"] =  query_club();
   map[SAVE_START + "channel off"] =  _channel_off;
   map[SAVE_START + "last state"] = _last_state;
   map[SAVE_START + "last time"] = _last_club_time;
   map[SAVE_START + "brief mode"] = _brief_mode;
   map[SAVE_START + "brief string"] = _brief_string;
   return club_discuss::query_dynamic_auto_load(map);
}
void init_dynamic_arg(mapping map) {
   string fluff;
   set_club(map[SAVE_START + "club"]);
   _channel_off = map[SAVE_START + "channel off"];
   _last_state = map[SAVE_START + "last state"];
   _last_club_time = map[SAVE_START + "last time"];
   _brief_mode = map[SAVE_START + "brief mode"];
   _brief_string = map[SAVE_START + "brief string"];
   if (query_club()) {
      fluff = CLUB_HANDLER->query_club_name(query_club());
   }
   if (fluff) {
      _club = fluff;
   }
   club_discuss::init_dynamic_arg(map);
}
protected int do_recruit(object *obs, string club) {
   object ob;
   object *already;
   object *invites;
   object *not_player;
   if (!query_club()) {
      add_failed_mess("The club associated with this badge appears to "
                      "have evaporated.\n");
      return 0;
   }
   if (lower_case(club) != lower_case(query_club())) {
      add_failed_mess("You can only recruit people to club '" + query_club() + "', "
                      "not '" + club  + "'.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_recruiter_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a recruiter to recruit people to "
                      "the club.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(query_club()) &&
       sizeof(CLUB_HANDLER->query_members(query_club())) >= CLUB_MAXIMUM_ELECTED_MEMBERS) {
      add_failed_mess("Your club has more than " +
                      query_num(CLUB_MAXIMUM_ELECTED_MEMBERS) + " members, so it "
                      "must change into an elected club before more "
                      "can be added.\n");
      return 0;
   }
   invites = ({ });
   already = ({ });
   not_player = ({ });
   foreach (ob in obs) {
      if (!userp(ob)) {
         not_player += ({ ob });
      } else if (!CLUB_HANDLER->is_member_of(query_club(), ob->query_name())) {
         invites += ({ ob });
         tell_object(ob, this_player()->the_short() + " invites you to "
                         "join the club '" + query_club() + "'.\nUse the command "
                         "'accept invite from " +
                         this_player()->query_name() +
                         " to " + query_club() + "'.\n");
         ob->add_respond_command(CLUB_RESPOND_TYPE, this_player(),
                                 query_club());
      } else {
         already += ({ ob });
      }
   }
   if (!sizeof(invites)) {
      if (sizeof(already)) {
         if (sizeof(already) > 1) {
            add_failed_mess("$I are already members of the club '" +
                         query_club() + "'.\n", already);
         } else {
            add_failed_mess("$I is already a member of the club '" +
                         query_club() + "'.\n", already);
         }
      }
      if (sizeof(not_player)) {
         add_failed_mess("You can only recruit players into the club, $I " +
                         (sizeof(not_player) > 1?"are not players":
                                                  "is not a player"),
                         not_player);
      }
   } else {
      add_succeeded_mess(({
        "$N invite $I to join the club '" + query_club() + "'.\n",
        "$N invites $I to join the club '" + query_club() + "'.\n" }),
                         invites);
   }
   return sizeof(invites) > 0;
}
protected int do_history() {
   mixed *history;
   mixed *data;
   int emote;
   string message;
   string name;
   string colour;
   string tim;
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the club to get a "
                      "history of its channel.\n");
      return 0;
   }
   history = BROADCASTER->query_channel_history(lower_case(query_club()));
   if (!history ||
       !sizeof(history)) {
      add_failed_mess("No history for this channel.\n");
      return 0;
   }
   colour = this_player()->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
   foreach (data in history) {
      name = data[0];
      emote = data[1][CLUB_MESSAGE_EMOTE_INDEX];
      message = data[1][CLUB_MESSAGE_MESSAGE_INDEX];
      if (sizeof(data) > 2) {
         tim = ctime(data[2])[4..15];
      } else {
         tim = "";
      }
      if (emote) {
         this_player()->add_message("$I$5=(" + colour +
                         CLUB_HANDLER->query_club_name(query_club()) +
                         "%^RESET%^ " + tim + ") " +
                     name + " " + message + "\n", ({ }));
      } else {
         this_player()->add_message("$I$5=(" + colour +
                         CLUB_HANDLER->query_club_name(query_club()) +
                         "%^RESET%^ " + tim + ") " +
                     name + ": " + message + "\n", ({ }));
      }
   }
   write("History for the '" + query_club() + "' club channel.\n");
   return 1;
}
protected int do_channel_off(int flag) {
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the channel to turn it off.\n");
      return 0;
   }
   if (_channel_off == flag) {
      if (_channel_off) {
         add_failed_mess("The channel is already muted.\n");
      } else {
         add_failed_mess("You are already listening to the channel.\n");
      }
      return 0;
   }
   _channel_off = flag;
   if (_channel_off) {
      add_succeeded_mess(({ "Muting the channel '" + query_club() + "'.\n", "" }));
   } else {
      add_succeeded_mess(({ "Removing the mute from the channel '" + query_club() +
                            "'.\n", "" }));
   }
   return 1;
}
protected int do_brief_mode(int mode) {
   if (!_brief_string) {
      add_failed_mess("You need to set a brief string for '" +
                      query_club() + "' before you can change the brief "
                      "mode.\n");
      return 0;
   }
   _brief_mode = mode;
   if (_brief_mode) {
      write("Set the channel '" + query_club() + "' into brief mode "
            "(using '" + _brief_string + "' as the channel name).\n");
   } else {
      write("Set the channel '" + query_club() + "' into verbose mode,\n");
   }
   return 1;
}
protected int do_brief_string(string str) {
   if (strlen(str) > strlen(query_club())) {
      add_failed_mess("Cannot set the channel name brief to longer than it "
                      "already is!\n");
      return 0;
   }
   write("Setting the brief channel name for '" + query_club() +
         "' to '" + str + "'.\n");
   _brief_string = str;
   return 1;
}
protected int do_resign_position(string position) {
   if (!query_club()) {
      add_failed_mess("This badge is not associated with any clubs!\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(query_club(),
                                   this_player()->query_name())) {
      add_failed_mess("You need to be a member of a club before you can "
                      "resign from it.\n");
      return 0;
   }
   if (!CLUB_HANDLER->holds_position_of(query_club(),
                                        position,
                                        this_player()->query_name())) {
      add_failed_mess("You need to hold a position before you can "
                      "resign from it.\n");
      return 0;
   }
   write("Are you sure you wish to resign from the position " + position +
         " in the club '" + query_club() + "'? ");
   input_to("confirm_resign", 0, position);
   add_succeeded_mess("");
   return 1;
}
protected int do_resign() {
   if (!query_club()) {
      add_failed_mess("This badge is not associated with any clubs!\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(query_club(),
                                   this_player()->query_name())) {
      add_failed_mess("You need to be a member of a club before you can "
                      "resign from it.\n");
      return 0;
   }
   write("Are you sure you wish to resign from the club '" +
         query_club() + "'? ");
   input_to("confirm_resign");
   add_succeeded_mess("");
   return 1;
}
private void do_fixup_badges(string club_name) {
   object ob;
   string club;
   foreach (ob in all_inventory(this_player())) {
      club = ob->query_club();
      if (club &&
          ob->query_club_insignia()) {
         if (CLUB_HANDLER->query_club_name(club) ==
             CLUB_HANDLER->query_club_name(query_club())) {
            set_club(0);
         }
      }
   }
}
protected void confirm_resign(string str, string position) {
   string club;
   str = lower_case(str);
   if (!strlen(str) ||
       str[0] == 'n') {
      write("Aborted resignation.\n");
      return 0;
   }
   if (str[0] == 'y') {
      if (!position) {
         if (CLUB_HANDLER->remove_member(query_club(),
                                         this_player()->query_name())) {
            write("You have resigned from the club '" + query_club() + "'.\n");
            club = query_club();
            set_club(0);
            call_out( (: do_fixup_badges :), 0, club);
         } else {
            write("You were unable to resign from the club '" + query_club() +
                  "'.\n");
         }
      } else {
         if (CLUB_HANDLER->set_position_holder(query_club(),
                                              position,
                                              CLUB_UNKNOWN_MEMBER)) {
            write("You have resigned from the position " + position +
                  " in the club '" + query_club() + "'.\n");
         } else {
            write("You were unable to resign from the position " + position +
                  " in the club '" + query_club() + "'.\n");
         }
      }
   } else {
      write("You need to answer yes or no.\n");
      if (!position) {
         write("Are you sure you wish to resign from the club '" +
                         query_club() + "'? ");
      } else {
         write("Are you sure you wish to resign from the position " + position +
               " in the club '" + query_club() + "'? ");
      }
      input_to("confirm_resign", 0, position);
   }
}
protected int do_disbar(string name) {
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the club before you can "
          "disbar people from it.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(query_club())) {
      if (!CLUB_HANDLER->is_president_of(query_club(), this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(query_club(), this_player()->query_name())) {
         add_failed_mess("You must be the president or the vice president to "
                         "disbar someone.\n");
         return 0;
      }
   } else if (!CLUB_HANDLER->is_founder_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to disbar "
                      "someone.\n");
      return 0;
   }
   name = lower_case(name);
   if (name == this_player()->query_name()) {
      add_failed_mess("You cannot disbar yourself.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(query_club(), name)) {
      add_failed_mess("You must disbar someone who is a member of the "
                      "club.\n");
      return 0;
   }
   write("Do you want to disbar " + capitalize(name) + " from the club '" +
                   query_club() + "'? ");
   add_succeeded_mess("");
   input_to("confirm_disbar", 0, name);
   return 1;
}
protected void confirm_disbar(string str, string name) {
   if (str == "" ||
       str[0] == 'q' ||
       str[0] == 'n') {
      write("Aborting disbar.\n");
      return ;
   }
   if (str[0] == 'y') {
      if (CLUB_HANDLER->remove_member(query_club(), name)) {
         write("Disbarred " + capitalize(name) +
               " from the club '" + query_club() + "'.\n");
      } else {
         write("You were unable to disbar " + capitalize(name) +
               " from the club '" + query_club() + "'.\n");
      }
   } else {
      write("You must type yes or no.\n");
      write("Do you want to disbar " + capitalize(name) + " from the club '" +
                      query_club() + "'? ");
      input_to("confirm_disbar", 0, name);
   }
}
protected int do_announcement() {
   string announce;
   announce = CLUB_HANDLER->query_announcement(query_club());
   if (!strlen(announce)) {
      add_failed_mess("There is no announcement to read.\n");
      return 0;
   }
   write("$P$Announcement$P$Added by the president or secretary at " +
         ctime(CLUB_HANDLER->query_announcement_time(query_club())) + "\n" +
         announce + "\n");
   this_player()->add_property(_club + " announce time",
                               CLUB_HANDLER->query_announcement_time(query_club()),
                               4 * 7 * (24 * 60 * 60));
   return 1;
}
void event_joined_club(object person, string club_name) {
   if (CLUB_HANDLER->query_club_name(query_club()) ==
       CLUB_HANDLER->query_club_name(club_name)) {
      add_club_commands(environment());
   }
}
void event_club_changed(object person,
                        string club_name) {
   if (CLUB_HANDLER->is_elected_club(club_name)) {
      call_out( (: add_elected_commands(environment()) :), 0);
   }
}
mixed * stats()
{
  return ({
    ({ "club name", _club })
    });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/basic/club_discuss.c ===
#include <clubs.h>
#include <player_handler.h>
#include <player_handler.h>
#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 20
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"
string query_club();
int do_vote(int id, string choice);
int do_nominate(int id, string person);
int do_withdraw(int id);
int do_list_all();
int do_list_item(int id);
int do_list_archives();
int do_archive(int num);
private nosave int _last_time;
string discussion_item_list(string player) {
   class discussion_idea* ideas;
   class discussion_idea bing;
   string ret;
   int no;
   ideas = CLUB_HANDLER->query_all_discussion_items(query_club());
   ret = "";
   no = 0;
   if (sizeof(ideas)) {
      foreach (bing in ideas) {
         if (CLUB_HANDLER->is_discussion_item_finished(query_club(),
                                                       bing->id)) {
            CLUB_HANDLER->complete_discussion_item(query_club(),
                                                   bing->id);
         } else {
            if (CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                            bing->id,
                                                            player)) {
               ret += bing->id + ") " +
                  CLUB_HANDLER->query_discussion_item_short_description(query_club(),
                                                                        bing->id);
               if (CLUB_HANDLER->is_discussion_item_quorum(query_club(),
                                                           bing->id)) {
                  ret += " (quorum)";
               }
               if (CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                                               bing->id,
                                                               player)) {
                  ret += " (voted)\n";
               } else {
                  ret += "\n";
               }
               no++;
            }
         }
      }
   }
   if (no == 0) {
      ret += "No items up for discussion.\n";
   }
   return ret;
}
string discussion_item(int id,
                       string player) {
   string ret;
   if (CLUB_HANDLER->query_discussion_item(query_club(), id) &&
       CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                   id,
                                                   player)) {
      ret = "Discussion item #" + id + " by " +
         CLUB_HANDLER->query_discussion_added_by(query_club(), id) +
         " (Finish: " +
         ctime(CLUB_HANDLER->query_discussion_time_finish(query_club(),
                                                          id)) + ")\n" +
         CLUB_HANDLER->query_discussion_item_long_description(query_club(),
                                                              id) +
         "\n\nWith voting choices of " +
         query_multiple_short(CLUB_HANDLER->query_discussion_choices(query_club(),
                                                                     id)) +
         ".\n";
      if (CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                                      id,
                                                      player)) {
         ret += "You have voted for the discussion item.\n";
      }
      if (CLUB_HANDLER->is_no_quorum_discussion_item(query_club(), id)) {
         ret += "The discussion item does not require a quorum to carry.\n";
      } else if (CLUB_HANDLER->is_discussion_item_quorum(query_club(), id)) {
         ret += "The discussion item has reached a quorum, so any result "
            "will be final.\n";
         ret += "The discussion item needed " +
                CLUB_HANDLER->query_discussion_item_quorum_number(query_club(),
                                                                  id) +
                " to vote for quorum and so far " +
                CLUB_HANDLER->query_discussion_item_number_voted(query_club(),
                                                                 id) +
                " people have voted.\n";
      } else {
         ret += "The discussion item needs " +
                CLUB_HANDLER->query_discussion_item_quorum_number(query_club(),
                                                                  id) +
                " to vote for quorum and so far " +
                CLUB_HANDLER->query_discussion_item_number_voted(query_club(),
                                                                 id) +
                " people have voted.\n";
      }
      if (CLUB_HANDLER->is_committee_discussion_item(query_club(), id)) {
         ret += "This is a committee only discussion item.\n";
      }
      return ret;
   }
   return "Lost discussion item of the far west.\n";
}
protected void add_elected_commands(object per) {
   string tmp_name;
   class discussion_idea* ideas;
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command(tmp_name,
               this_object(),
               "vote for <string'choice'> in <number'id'>",
               (: do_vote($4[1], $4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "nominate <string'person'> in <number'id'>",
               (: do_nominate($4[1], $4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "withdraw from <number'id'>",
               (: do_withdraw($4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "list all [discussion items]",
               (: do_list_all() :));
   per->add_command(tmp_name,
               this_object(),
               "list [discussion item] <number'id'>",
               (: do_list_item($4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "archives",
               (: do_list_archives() :));
   per->add_command(tmp_name,
               this_object(),
               "archives [list] <number>",
               (: do_archive($4[0]) :));
   if (_last_time + 24 * 60 * 60 < time()) {
      _last_time = time();
      ideas = CLUB_HANDLER->query_all_discussion_items(query_club());
      ideas = filter(ideas,  (:
                   CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                        $1->id,
                                        this_player()->query_name()) :) );
      ideas = filter(ideas, (:
                   !CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                        $1->id,
                                        this_player()->query_name()) :) );
      if (sizeof(ideas)) {
         write("%^YELLOW%^There are discussion items you have not voted "
               "for, use '" + tmp_name +
               " list all' for a list.\n%^RESET%^");
      }
   }
}
protected void add_club_commands(object per) {
}
int do_list_all() {
   string ret;
   ret = discussion_item_list(this_player()->query_name());
   write("$P$Discussion items$P$" + ret);
   return 1;
}
int do_list_item(int id) {
   string ret;
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   ret = discussion_item(id, this_player()->query_name());
   write("$P$Discussion item$P$" + ret);
   return 1;
}
int do_vote(int id,
            string choice) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_votable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be voted for.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_valid_discussion_choice(query_club(),
                                                 id,
                                                 choice)) {
      add_failed_mess("Invalid choice to the discussion item, the allowed "
                      "choices are " +
                      query_multiple_short(
                        CLUB_HANDLER->query_discussion_choices(query_club(),
                                                               id)) +
                      ".\n");
      return 0;
   }
   if (CLUB_HANDLER->vote_for_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              choice)) {
      add_succeeded_mess(({ "Voted '" + choice + "' for discussion item #" +
                            id + ".\n",
                            "$N voted for a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to vote for the discussion item for "
                      "some reason.\n");
      return 0;
   }
}
int do_nominate(int id, string person) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_nominateable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be nominated for.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_discuss_person_nominated(query_club(),
                                                 id,
                                                 person,
                                                 this_player()->query_name())) {
      add_failed_mess("The person " + person + " has already been nominated "
                      "for that position.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_creator_club(query_club()) &&
       PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You can only nominated creators to positions in "
                      "creator clubs.\n");
      return 0;
   }
   if (CLUB_HANDLER->nominate_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              person)) {
      add_succeeded_mess(({ "Nominated '" + person +
                            "' for discussion item #" + id + ".\n",
                            "$N nominated someone in a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to nominate " + person + " for "
                      "some reason.\n");
      return 0;
   }
}
int do_withdraw(int id) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_nominateable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be nominated for (and therefor withdrawn from).\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_person_nominated(query_club(),
                                                 id,
                                                 this_player()->query_name(),
                                                 this_player()->query_name())) {
      add_failed_mess("You have not been nominated for this position.\n");
      return 0;
   }
   if (CLUB_HANDLER->withdraw_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              this_player()->query_name())) {
      add_succeeded_mess(({ "Withdrew from discussion item #" + id + ".\n",
                            "$N withdrew from a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to withdraw from the discussion item for "
                      "some reason.\n");
      return 0;
   }
}
int do_list_archives() {
   class club_archive* archives;
   string bing;
   class club_archive fluff;
   int num;
   archives = CLUB_HANDLER->query_archives(query_club());
   if (!sizeof(archives)) {
      add_failed_mess("This club has no archives currently.\n");
      return 0;
   }
   bing = "";
   num = 1;
   foreach (fluff in archives) {
      bing += "#" + num + " finished at " + ctime(fluff->archive_date) + " " +
              fluff->subject + "\n";
      num++;
   }
   write("$P$Club Archives$P$" + bing);
   return 1;
}
int do_archive(int num) {
   string bing;
   class club_archive fluff;
   class club_archive* archives;
   archives = CLUB_HANDLER->query_archives(query_club());
   if (!sizeof(archives)) {
      add_failed_mess("This club has no archives currently.\n");
      return 0;
   }
   if (num < 1 || num > sizeof(archives)) {
      add_failed_mess("The number must be between 1 and " +
                      sizeof(archives) + ".\n");
      return 0;
   }
   fluff = archives[num - 1];
   bing = "Archive #" + num + " finished at " +
           ctime(fluff->archive_date) + " " +
           fluff->subject + "\n" + fluff->matter + "\n";
   write("$P$Club Archives$P$" + bing);
   return 1;
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      map = ([ ]);
   }
   map[SAVE_START + "last time"] = _last_time;
   return map;
}
void init_dynamic_arg(mapping map) {
   _last_time = map[SAVE_START + "last time"];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/ken_mangle.c ===
string *replace_matrix;
mapping trans;
void create() {
  replace_matrix = ({
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });
  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
}
string do_transmute(string str) {
  string tmp, *bits;
  mixed erp;
  int i;
  tmp = replace(" "+str+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/newbie_eff_shadow.c ===
inherit "/std/effect_shadow";
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
string name, my_name;
void remove_effect_shadow(int i) {
   if (i == id) {
      destruct(this_object());
      return;
   }
      else player->remove_effect_shadow(i);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/ken_curse.c ===
#include "path.h"
#define MY_NAME "ken curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"ken_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"ken_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"ken_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"ken_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"ken_mangle")->do_transmute(str));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/shout_curse.c ===
#include "path.h"
#define MY_NAME "Shout curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  printf("%O, %O\n", pl, this_object());
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"shout_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}
int do_shout(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/path.h ===
#define HERE "/std/curses/"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/newbie_curse.c ===
#include "path.h"
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/chef_mangle.c ===
string *replace_matrix;
void create() {
  replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
}
string do_transmute(string str) {
  return replace(" "+str, replace_matrix)[1..10000];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/chef_curse.c ===
#include "path.h"
#define MY_NAME "chef curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"chef_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"chef_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"chef_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"chef_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"chef_mangle")->do_transmute(str));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/curses/upper_case.c ===
#include "path.h"
#define MY_NAME "UPPER CASE"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string upper_case(string str) {
  string ret;
  int i;
  ret = "";
  for (i=0;i<strlen(str);i++)
    ret += capitalize(str[i..i]);
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(upper_case(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(upper_case(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(upper_case(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(upper_case(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(upper_case(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(upper_case(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(upper_case(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(upper_case(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(upper_case(str));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/basic.c ===
#include "potion_attrs.h"
int x1, x2, y1, y2;
void set_boundaries(int *min, int *max)
{
   x1 = min[0];
   x2 = max[0];
   y1 = min[1];
   y2 = max[1];
}
int *query_coordinate()
{
   return ({ (x1 + x2) / 2, (y1 + y2) / 2 });
}
#pragma no_warnings
mixed *query_attrs(int *coord)
{
   return ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
}
int query_pass_through(int *coord)
{
   return 100;
}
void install_effect()
{
   (void)POTION_SPACE_HANDLER->remove_effect(file_name(this_object()));
   (void)POTION_SPACE_HANDLER->add_effect(file_name(this_object()), x1, x2, y1, y2);
}
int sqrt(int p)
{
   int i;
   for (i = 1; i < 500; i++) if (i * i > p) return i-1;
}
int distance_within_region(int *coord)
{
   int dx, dy;
   if (x1 < 0) {
      if (x2 > 0)
         dx = (coord[0] < 0) ? -coord[0] : coord[0];
      else
         dx = (x2 - coord[0]);
   } else
      dx = coord[0] - x1;
   if (y1 < 0) {
      if (y2 > 0)
         dy = (coord[1] < 0) ? -coord[1] : coord[1];
      else
         dy = (y2 - coord[1]);
   } else
      dy = coord[1] - y1;
   return sqrt(dx * dx + dy * dy);
}
int distance_from_origin(int *coord)
{
   return sqrt(coord[0] * coord[0] + coord[1] * coord[1]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/bug_effect.c ===
#include <effect.h>
void beginning( object player, int time, int id ) {
   if (time == 0) {
      time = 30*60;
   }
   player->submit_ee( "create_bug", ({ 5*60, 5*60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
}
void end( object player, int time, int id ) {
}
void create_bug( object player, int time, int id ) {
   object bug;
   object room;
   string env_string;
   object *ignore;
   bug = clone_object("/obj/monster/cockroach");
   room = environment(player);
   env_string = player->the_short();
   ignore = ({ });
   while (room) {
      if (room == environment(player) && living(player)) {
         tell_object(player, env_string+" have "+bug->a_short()+
                             " suddenly pop out of your "
                             "ear.\n");
         ignore += ({ player });
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else if (living(player)) {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of it.\n", ignore);
      }
      if (living(room))
        ignore += ({ room });
      env_string = env_string + " in " + room->the_short();
      if (!environment(room))
        bug->move(room);
      room = environment(room);
   }
}
string query_classification() { return "object.bug"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/horse.c ===
#include <effect.h>
#define SHADOWS "/std/effects/object/"
string query_classification(){return "object.horse"; }
void beginning(object player, int amount){
    player->submit_ee(0, amount, EE_REMOVE);
    player->add_extra_look(this_object());
}
int merge_effect(object player, int old_amount, int new_amount){
   if (old_amount > new_amount)
      return old_amount;
   return new_amount;
}
string query_shadow_ob(){
   return SHADOWS+"shadow_horse";
}
int survive_death(){
   return 0;
}
string extra_look(object player){
   return capitalize((string)player->the_short()) +
         " is mounted on a large, black horse.\n";
}
void end(object player, int amount, int id){
   player->remove_extra_look(this_object());
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/cabbage.c ===
#include <effect.h>
void beginning( object player, int time, int id ) {
   player->submit_ee( "make_stink", ({ 20, 20 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
}
void end( object player, int time, int id ) {
   tell_object( player, "Your stomach calms down at last.\n" );
}
void make_stink( object player, int time, int id ) {
   tell_object( player, "A huge trumpeting noise comes from your "
   "rear, closely followed by a stench of boiled cabbage.\n" );
   tell_room( environment( player ), "The smell of sprouts and cabbages from "
   + (string)player->one_short() +
         " wafts over you and you find yourself thinking of school dinners."
         "\n", player );
}
string query_classification() { return "body.smell.scent"; }
string smell_string( object player, int time ) {
   return "the delicious doughnutty smell";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/wet.c ===
#include <effect.h>
string query_classification() { return "object.wet"; }
void beginning( object thing, int amount, int id ) {
   thing->submit_ee( "dry_off", ({ 30, 90 }), EE_CONTINUOUS );
   thing->add_extra_look( this_object() );
   thing->add_adjective("wet");
}
int merge_effect( object thing, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
}
void end( object thing, int amount, int id ) {
   thing->remove_extra_look( this_object() );
   thing->remove_adjective("wet");
}
void restart( object thing, int amount, int id ) {
   thing->add_extra_look( this_object() );
}
void dry_off( object thing, int amount, int id ) {
   amount -= 100 + amount / 10;
   if ( amount > 0 )
      thing->set_arg_of( (int)thing->sid_to_enum( id ), amount );
   else
      thing->submit_ee( 0, 0, EE_REMOVE );
}
string wet_string( object thing ) {
   int *enums;
   string wetness;
   enums = (int *)thing->effects_matching( "object.wet" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)thing->arg_of( enums[ 0 ] ) / ( 1 +
         (int)thing->query_weight() ) ) {
      case 0 :
         return "just barely damp";
      case 1 .. 5 :
         wetness = "slightly wet";
         break;
      case 6 .. 10 :
         wetness = "wet";
         break;
      case 11 .. 30 :
         wetness = "very wet";
         break;
      case 31 .. 80 :
         wetness = "sopping wet";
         break;
      default :
          wetness = "absolutely soaking wet";
   }
   return wetness;
}
string extra_look(object thing)  {
   return "It is " + wet_string(thing) + ".\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/death_ward.c ===
#include "path.h"
string query_classification() { return "magic.ward.death"; }
string query_shadow_ob() { return SHADOWS +"death_ward"; }
int query_indefinite() { return 1; }
int beginning( object thing, int amount, int id ) { return 0; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/owned_weapon.c ===
#include "path.h"
string query_classification() { return "mudlib.owned.weapon"; }
string query_shadow_ob() { return SHADOWS +"owned_weapon"; }
int query_indefinite() { return 1; }
void beginning( object thing, string owner, int id ) { return; }
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   write( "There is a bug with the ownership of "+
         (string)thing->the_short() +" ("+ file_name( thing ) +
         ")!  Please bug report it and contact a creator!\n" );
   return old_owner;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/swim_fins.c ===
#include <effect.h>
#define SHADOW "/std/shadows/object/swim_fins"
string query_classification() { return "clothing.swim_fins"; }
string query_shadow_ob() { return SHADOW; }
void beginning(object player, int time ) {
   player->submit_ee( "test_worn", 1, EE_ONCE );
   player->submit_ee( "test_worn", 20, EE_CONTINUOUS );
}
void restart( object player ) {
}
int merge_effect( object player, int old_state, int new_state ) {
   return old_state | new_state;
}
int test_for_effect( object thing ) {
   if ( !thing )
      return 0;
   return member_array( file_name( this_object() ),
         (string *)thing->query_wear_effects() ) != -1;
}
void test_worn( object player ) {
   if ( player->still_auto_loading() )
      return;
   if ( !sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/basic_trap.c ===
#include "path.h"
string query_classification() { return "object.trap.basic"; }
string query_shadow_ob() { return SHADOWS +"basic_trap"; }
int query_indefinite() { return 1; }
int beginning( object thing, int amount, int id ) {
	tell_object(find_player("ceres"), sprintf("Adding trap to %O\n",
																						thing));
	thing->set_lock_trap(thing, "trap_lock");
	return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/object/no_save.c ===
#include "path.h"
string query_classification() { return "mudlib.object.nosave"; }
string query_shadow_ob() { return SHADOWS +"no_save"; }
int query_indefinite() { return 1; }
void beginning( object thing, string owner, int id ) { return; }
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   return old_owner;
}
