
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.sta ===
ret += ({
  ({ "condition", cond }),
  ({ "max condition", max_cond }),
  ({ "lowest cond", lowest_cond }),
  ({ "damage chance", damage_chance }),
  ({ "wear effect", wear_effect }),
});
for (i=0;i<sizeof(immune_to);i++)
  ret += ({ ({ "immune to", immune_to[ i ] }) });
ret += armour_logic::stats();


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.inh ===
inherit "/std/armour_logic";
inherit "/std/basic/condition";


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.mov ===
if (dest != worn_by && worn_by && !drop() ) {
  worn_by->remove_armour(this_object());
  if (sizeof(wear_remove_func))
    call_other(wear_remove_func[0], wear_remove_func[1], 0);
  worn_by = 0;
}


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.qsa ===

ret += ([
  "ac" : ac,
  "armour types" : armour_types,
  "max cond" : max_cond,
  "damage chance" : damage_chance,
  "type" : type,
  "wear remove func" : wear_remove_func,
  "no limbs" : no_limbs,
]);


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.cre ===
damage_chance = 100;
condition::create();
armour_logic::create();
immune_to = ({ });
wear_remove_func = ({ });
object::create();
add_alias( "armour" );
add_plural( "armours" );
if (!query_property( "shop type" )) add_property( "shop type", "armoury" );


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.def ===


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.lon ===
ret += cond_string();


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.qda ===
ret += ([
  "lowest cond" : lowest_cond,
  "worn" : (no_limbs?(worn_by?held_in+1:0):!(!worn_by)),
  "cond" : cond,
  "effect" : wear_effect,
  "immune" : immune_to,
]);


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.inc ===
#include "money.h"


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.mod ===
void set_wear_remove_func(string ob, string func) {
  wear_remove_func = ({ ob, func });
} /* set_wear_remove_func() */

void set_wear_effect( string effect_name ) {
  wear_effect = effect_name;
} /* set_wear_effect() */

string query_wear_effect() { return wear_effect; }
 
int query_armour() { return 1; }
 
int query_ac( string type, int amount ) {
  int i, arm_class, damage;
  arm_class = ::query_ac( type, amount );
  if ( arm_class > 100 )
    arm_class = max_ac;
  else
    arm_class = ( arm_class * max_ac ) / 100;
  arm_class += ( arm_class * enchanted ) / query_max_enchant() + enchanted;
  if ( member_array( type, immune_to ) == -1 )
    adjust_cond( ( -2 * random( damage_chance ) * amount ) / 1000 );
  return ( arm_class * cond ) / max_cond;
} /* query_ac() */
 
void setup_armour(int c) {
  set_cond(c);
  set_max_cond(c);
  set_lowest_cond(c);
} /* setup_armour() */
 
void set_damage_chance(int i) { damage_chance = i; }
 
int set_worn_by( object thing ) {
  if ( sizeof( wear_remove_func ) ) {
    if ( thing != worn_by ) {
      if ( worn_by )
        call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], 0 );
      if ( thing )
        call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], thing );
    }
  }
  if ( ( thing != worn_by ) && thing && wear_effect )
    thing->add_effect( wear_effect );
  if ( ( thing != worn_by ) && worn_by && wear_effect )
    worn_by->taken_off( this_object(), wear_effect );
  worn_by = thing;
  return 1;
} /* set_worn_by() */
 
int query_damage_chance() { return damage_chance; }
object query_worn_by() { return worn_by; }
 
int query_worn() { return worn_by != 0; }
string *query_immune_to() { return immune_to; }
 
void add_immune_to(mixed arr) {
  int i;
 
  if (pointerp(arr))
    for (i=0;i<sizeof(arr);i++)
      add_immune_to(arr[i]);
  else
    if (member_array(arr, immune_to) == -1)
      immune_to += ({ arr });
} /* add_immune_to() */ 
 
void remove_immune_to(mixed arr) {
  int i;
 
  if (pointerp(arr))
    for (i=0;i<sizeof(arr);i++)
      remove_immune_to(arr[i]);
  else
    if ((i=member_array(arr, immune_to)) != -1)
      immune_to = delete(immune_to, i, 1);
} /* remove_immune_to() */
 
void set_type(string str) {
  if (type)
    remove_alias(type);
  switch (str) {
    case "armour" :
      max_ac = 40;
      break;
    case "shield" :
      max_ac = 20;
      break;
    case "boot" :
      max_ac = 10;
      break;
    case "helmet" :
      max_ac = 10;
      break;
    case "cloak" :
      max_ac = 10;
      break;
    case "glove" :
      max_ac = 10;
      break;
    case "ring" :
      max_ac = 10;
      break;
  }
  add_alias(str);
  type = str;
} /* set_type() */
 
string query_type() { return type; }
 
int query_value() {
  int val;
 
  val = ::query_value();
  return (val*10)/100 + (val*query_cond()*90)/(100*query_max_cond());
} /* query_value() */

int query_full_value() { return ::query_value(); }
 
mixed *query_money_array() {
  return (mixed *)MONEY_HAND->create_money_array(query_value());
} /* query_money_array() */
 
int query_money(string type) {
  int i;
  mixed *m_a;
 
  m_a = (mixed *)MONEY_HAND->create_money_array(query_value()); 
  if ((i=member_array(type, m_a)) == -1)
    return 0;
  return m_a[i+1];
} /* query_money() */

int query_no_limbs() { return no_limbs; }
void set_no_limbs(int i) { no_limbs = i; }

int set_holder(object ob, int pos) {
  held_in = pos;
  return 1;
} /* set_holder() */
 
void player_wear() {
  if (!environment()) return ;
  if (no_limbs)
    environment()->set_hold(this_object(), held_in);
  else
    environment()->wear_armour(this_object());
} /* player_wear() */

void break_me() {
  if ( !worn_by ) /* Don't know how this could happen, but... */
    return ::break_me();
  tell_object( worn_by, "%^RED%^Your "+ short( 0 ) +" breaks into "+
      "pieces!%^RESET%^\n" );
  tell_room( environment( worn_by ),
      capitalize( (string)worn_by->the_short() ) +"'s "+ short( 0 ) +
      " breaks into pieces!\n", worn_by );
  ::break_me();
} /* break_me() */
 


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/arm_modules/armour.var ===
int damage_chance, max_ac, no_limbs;
string type, wear_effect, *immune_to, *wear_remove_func;
static int held_in;
static object worn_by;


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/boring_stick.c ===
inherit "/std/held";
#include <move_failures.h>
int state;
void set_state(int state);
void setup() {
  set_name("stick");
  set_state(0);
  set_weight(2);
  set_value(10);
}
void init() {
  this_player()->add_command("turn", this_object(),
                                "<direct:object> {on|off}");
  this_player()->add_command("flick", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("press", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("push", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("flick", this_object(),
                                "<direct:object>");
  this_player()->add_command("turn", this_object(),
                                "switch {on|off} on <direct:object>");
  this_player()->add_command("switch", this_object(),
                                "<direct:object> {on|off}");
}
void set_state(int new_state) {
  state = new_state;
  if (state) {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.  Flashing lights "
"rush up and down the side of the stick in a mad progression.\n");
  } else {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.\n");
  }
  if (environment())
    if (state) {
      if (living(environment()))
        environment()->add_extra_look(this_object());
    } else
      environment()->remove_extra_look(this_object());
}
string extra_look() {
  return capitalize(previous_object()->query_pronoun())+
         " is surrounded by an aura of bees.\n";
}
int do_turn(mixed *indirect_obs, string indir_match,
            string dir_match, mixed *args, string pattern) {
  int new_state;
  new_state = 0;
  if ("<direct:object> {on|off}" == pattern) {
    if (args[1] == "on")
      new_state = 1;
  } else {
    if (args[0] == "on")
      new_state = 1;
  }
  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
}
int do_flick() {
  set_state(!state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V the switch on $D to the "+(state?"on":"off")+" position.\n", ({ }));
  return 1;
}
int do_press() {
  return do_flick();
}
int do_push() {
  return do_flick();
}
int do_switch(mixed *indirect_obs, string indir_match,
              string dir_match, mixed *args, string pattern) {
  int new_state;
  if (args[1] == "on")
    new_state = 1;
  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
}
mapping query_dynamic_auto_load() {
   return ([ "state" : state,
             "::" : held::query_dynamic_auto_load()
          ]);
}
void init_dynamic_arg(mapping map) {
   set_state(map["state"]);
   if ( map[ "::" ] )
      held::init_dynamic_arg( map[ "::" ] );
}
varargs int move(mixed dest, string str1, string str2) {
  int ret;
  object old;
  old = environment();
  ret = ::move(dest, str1, str2);
  if (ret == MOVE_OK) {
    if (state) {
      if (old)
        old->remove_extra_look(this_object());
      if (living(environment())) {
        environment()->add_extra_look(this_object());
      }
    }
  }
  return ret;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/perfume_bottle.c ===
#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
int squirts;
string glass, scent, scent_plural;
void create() {
   object::create();
   holdable::create();
}
void setup() {
   set_name( "bottle" );
   set_short( "perfume bottle" );
   add_adjective( "perfume" );
   set_value( 4000 );
   set_weight( 2 );
   squirts = 12;
}
void set_glass( string word ) {
   set_short( word +" perfume bottle" );
   add_adjective( word );
   set_main_plural( word +" perfume bottles" );
   glass = word;
}
void set_scent( string words ) { scent = words; }
void set_scent_plural( string words ) { scent_plural = words; }
string long( string word, int dark ) {
   string words;
   words = "This is a perfume bottle made out of "+ glass +" crystal.  "+
         "It is ";
   switch( squirts ) {
      case 0 :
         return words +"empty.\n";
      case 1 .. 3 :
         words += "about a quarter full";
         break;
      case 4 .. 6 :
         words += "about half full";
         break;
      case 7 .. 9 :
         words += "about three-quarters full";
         break;
      default :
         words += "almost full";
   }
   words += " of "+ scent +" perfume which can be sprayed onto "+
         "someone.\n";
   return words;
}
void init() {
   this_player()->add_command( "spray", this_object(), "<direct:object> at <indirect:object>" );
}
int do_spray( object *things ) {
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You can only spray $D "+
        "at one person at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot spray $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  if ( !living( things[ 0 ] ) ) {
    this_player()->add_failed_mess( this_object(), "SI would probably not "+
        "benefit from being sprayed.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !squirts ) {
    this_player()->add_failed_mess( this_object(), "There is no perfume in "+
        "$D to spray at $I.\n", ({ things[ 0 ] }) );
    return 0;
  }
  squirts--;
  things[ 0 ]->add_effect( "/std/effects/other/perfume", ({ 300, scent,
      scent_plural }) );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "squirts" : squirts
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] !=
      "/obj/misc/perfume_bottle" )
    return 0;
  return ([
    "::" : int_query_static_auto_load(),
    "glass" : glass,
    "scent" : scent,
    "scent_plural" : scent_plural
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  squirts = map[ "squirts" ];
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( map[ "glass" ] )
    set_glass( map[ "glass" ] );
  if ( map[ "scent" ] )
    scent = map[ "scent" ];
  if ( map[ "scent_plural" ] )
    scent_plural = map[ "scent_plural" ];
}
void dest_me() {
   holdable::dest_me();
   object::dest_me();
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/dead_duck.c ===
#include <move_failures.h>
#define DUCK_FEATHER "/obj/misc/duck_feather.ob"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "duck" );
  set_short( "dead duck" );
  add_alias( ({ "corpse", "duck corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead ducks" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled duck.  Judging "
                  "from the lack of feathers it is ready to be "
                  "cooked.\n";
              return
                  "This is the dead body of a bedraggled duck.  "
                  "Most people would pluck it and then cook it.\n";
            } );
  set_weight( 10 );
  set_value( 400 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The duck is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( DUCK_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead duck with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead duck cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/newspaper.c ===
inherit "/std/book";
#include <room/newspaper.h>
#define AUTO_LOAD_TAG "newspaper"
private string _paper;
private int _edition;
void setup() {
  set_name("newspaper");
  set_short("newspaper");
  add_alias("paper");
  add_plural("papers");
  set_long("A bunch of nice newspapers.\n");
  set_main_plural("newspapers");
  set_weight(10);
  set_value(10);
  set_ignore_saved_pages(1);
}
int query_binding_force() {
  return 100;
}
void setup_paper() {
   class article* articles;
   class advert* adverts;
   class advert data;
   string* bits;
   int i;
   int j;
   string header;
   string index;
   string fluff;
   int page;
   mixed* stuff;
   object ob;
   if (_paper && _edition) {
      bits = explode(_paper, " ");
      if (bits[0] != "The") {
         set_short("copy of the " + _paper);
         add_adjective( ({ "the" }) );
         set_main_plural("copies of the " + _paper);
      } else {
         set_short("copy of " + _paper);
         set_main_plural("copies of " + _paper);
         add_plural_adjective("copies");
      }
      bits = map(bits, (: lower_case($1) :));
      add_adjective( ({ "copy", "of" }) );
      add_adjective(bits[0..<2]);
      add_alias(lower_case(bits[<1]));
      add_property("determinate", "a ");
      page = query_open_page();
      articles = NEWSPAPER_HANDLER->query_edition_articles(_paper, _edition);
      set_no_pages(sizeof(articles) + 1);
      index = "Edition #" + _edition + " of " + _paper + ".\n%^BOLD%^" +
              NEWSPAPER_HANDLER->query_paper_headline(_paper, _edition) +
              "%^RESET%^\n\n";
      index += sprintf("%2d .... %70-=s\n", 1, "Contents");
      for (i = 0; i < sizeof(articles); i++) {
         set_open_page(i + 2);
         ob = query_current_page();
         ob->set_value(0);
         if (articles[i]->colour) {
            index += "%^" + articles[i]->colour + "%^";
         }
         switch (articles[i]->type) {
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            header = "%^BOLD%^%^CYAN%^'Adverts'%^RESET%^\n\n";
            adverts = NEWSPAPER_HANDLER->query_edition_adverts(_paper, _edition);
            stuff = unique_array(adverts, (: $1->category :) );
            foreach (adverts in stuff) {
               header += "\n$I$0=" + adverts[0]->category + "\n$I$3=   ";
               foreach (data in adverts)  {
                  header += data->text + "\n-- " + data->author + "\n\n";
               }
            }
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            header = "%^BOLD%^" + articles[i]->title + "'%^RESET%^\n\n";
            for (j = i + 1; j < sizeof(articles); j++) {
               if (articles[j]->type == NEWSPAPER_ARTICLE_TYPE_SECTION) {
                  break;
               }
               header += sprintf("%2d .... %70-=s\n", i + 2, articles[j]->title);
            }
            index += sprintf("%2d -=== %65|=s ===-\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            header = "%^BOLD%^%^CYAN%^'" + articles[i]->title + "'%^RESET%^ at " +
                     ctime(articles[i]->date_written)[0..10] + "\n" +
                     "by " + articles[i]->shown_name;
            header += NEWSPAPER_HANDLER->query_article_text_plain(articles[i]);
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         }
         if (articles[i]->colour) {
            index += "%^RESET%^";
         }
         set_read_mess( header, NEWSPAPER_HANDLER->query_language_for( _paper ),
             0 );
      }
      set_open_page(1);
      set_read_mess( index, NEWSPAPER_HANDLER->query_language_for( _paper ), 0);
      ob = query_current_page();
      ob->set_value(0);
      fluff = NEWSPAPER_HANDLER->query_paper_long(_paper);
      if (fluff[<1] != '\n') {
         fluff += "\n";
      }
      set_long(fluff + "Edition " + _edition + " of " + _paper + ".\n");
      set_open_page(page);
   }
}
void set_paper(string paper) {
   _paper = paper;
   set_long(NEWSPAPER_HANDLER->query_paper_long(_paper));
   setup_paper();
}
void set_edition(int edition) {
   _edition = edition;
   setup_paper();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, AUTO_LOAD_TAG, "paper", _paper);
   add_auto_load_value(map, AUTO_LOAD_TAG, "edition", _edition);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   ::init_dynamic_arg(map);
   set_paper(query_auto_load_value(map, AUTO_LOAD_TAG, "paper"));
   set_edition(query_auto_load_value(map, AUTO_LOAD_TAG, "edition"));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/golem_shard.c ===
inherit "/std/object";
void setup() {
    set_name( "shard" );
    set_short( "cracked clay shard" );
    add_adjective( ({"clay"}) );
    set_long( "This is a heavily cracked clay shard." );
    set_main_plural( "cracked clay shards" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/eel_skin.c ===
inherit "/std/object";
void setup()
{
  set_name( "skin" );
  set_short( "eel skin" );
  add_adjective( "eel" );
  set_main_plural( "eel skins" );
  set_long( "This is the skin of an eel.  It is very greasy and "
        "glistens prettily when you tilt it towards the light.\n" );
  set_weight( 3 );
  set_value( 100 );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/al_receipt.c ===
#include <virtual.h>
#include <player.h>
#include <move_failures.h>
#include <armoury.h>
inherit "/std/object";
private int _timestamp;
private string _obname;
private string _obpath;
private string _virt_name;
private mixed _static_save;
void setup()
{
   set_name("receipt");
   set_short( "missing item receipt" );
   _obname = "unknown object";
   _obpath = "***";
   set_value(5);
   set_weight(1);
   add_adjective(({"missing", "item"}));
   add_property("writeable", 1);
   add_property("sale_value", 1);
   add_property("paper", 1);
   add_property("nosteal", 1);
   set_max_size(1000);
   _timestamp = time();
}
void init() {
    this_player()->add_command("kiss", this_object());
}
void set_obname(string s) { _obname = s; }
void set_object(string s) { _obpath = s; }
void set_obpath(string s) { set_object(s); }
void set_virtobname(string s) { _virt_name = s; }
void set_virtname(string s) { set_virtobname(s); }
void set_static_save(mixed m) {
  mixed p;
  _static_save = m;
  if (_obname != "unknown object") {
    return;
  }
  p = m[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}
void setup_receipt(object ob) {
   mixed* bits;
   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_object(bits[1]);
   set_static_save(bits[2]);
   set_value(ob->query_value());
   if(_obpath == "/obj/misc/al_receipt") {
     log_file("BAD_RECEIPTS", "%s: set by %s\n",
              ctime(time())[4..18], base_name(previous_object()));
     call_out("dest_me", 2);
   }
}
void being_sold()
{
    call_out("dest_me", 4);
}
string long(string str, int light)
{
   return "This is a receipt for your missing " + _obname + ".  You can either "
      "sell it for something which may be close to replacement value (and may
not), "
      "or give it to a creator and ask very nicely to have it replaced.\n"
      "You can also try kissing it - who knows, you may get lucky.\n";
}
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "obname" : _obname,
             "obpath" : _obpath,
             "obvalue" : value,
             "virt" : _virt_name,
             "timestamp" : _timestamp,
             "static" : _static_save ]);
}
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
      add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   ::init_dynamic_arg(arg["::"]);
   if(_obpath == "/obj/misc/al_receipt") {
     call_out("dest_me", 2);
   }
}
string query_obname() { return _obname; }
string query_obpath() { return _obpath; }
int query_timestamp() { return _timestamp; }
string query_virt_obname() { return _virt_name; }
mixed query_static_save() { return _static_save; }
int query_missing_item_receipt() {
   return 1;
}
mixed *stats()
{
  mixed *stuff;
  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
  return stuff;
}
int do_kiss() {
    object thing;
    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 1;
    }
    if ((query_cloned_by() != this_player()->query_name())
        && !this_player()->query_creator()) {
        write("The receipt whispers: I don't belong to you!\n");
        return 1;
    }
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 1;
       }
    }
    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            if (!thing->move( environment(this_object()) )
                || !thing->move( environment(environment(this_object())) )) {
                thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
                write(the_short() + " suddenly transforms itself into " +
                      thing->a_short() + ".\n");
                tell_room(environment(this_player()),
                          this_player()->the_short() +
                          " kisses a piece of paper, which suddenly "
                          "transforms into " + thing->a_short() + ".\n",
                          ({ this_player() }));
                this_player()->add_succeeded_mess(this_object(), "", ({ }));
                move("/room/rubbish");
            } else {
                write("The receipt whispers: I'm going to need some "
                      "creator help.\n");
                thing->dest_me();
            }
        } else {
            write("The receipt whispers: Sorry, I'm still broken.  "
                  "Try again some other time, or contact a creator.\n");
        }
    } else {
        write("The receipt whispers: Sorry, I'm still broken.  "
              "Try again some other time, or contact a creator.\n");
    }
    return 1;
}
varargs int move(mixed dest, string messin, string messout)  {
   if (!objectp(dest))  {
      if (!stringp(dest)  ||  (dest = find_object(dest)) == 0)  {
         return MOVE_EMPTY_DEST;
      }
   }
   if (::move(dest, messin, messout) != MOVE_OK)  {
      if (environment(dest))  {
         return move(environment(dest), messin, messout);
      }
      else  {
         return MOVE_INVALID_DEST;
      }
   }
   return MOVE_OK;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/active_toy.c ===
inherit "/std/object";
inherit "/std/basic/item_chat";
string hug, pet, cuddle, fondle, snuggle, squeeze, spank;
void set_hug( string words ) { hug = words; }
void set_pet( string words ) { pet = words; }
void set_cuddle( string words ) { cuddle = words; }
void set_fondle( string words ) { fondle = words; }
void set_snuggle( string words ) { snuggle = words; }
void set_squeeze( string words ) { squeeze = words; }
void set_spank( string words ) { spank = words; }
void init() {
   item_chat::init();
   this_player()->add_command( "hug", this_object() );
   this_player()->add_command( "pet", this_object() );
   this_player()->add_command( "cuddle", this_object() );
   this_player()->add_command( "fondle", this_object() );
   this_player()->add_command( "snuggle", this_object() );
   this_player()->add_command( "squeeze", this_object() );
   this_player()->add_command( "spank", this_object() );
}
int do_hug() {
  if (!sizeof (hug)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( hug,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_pet() {
  if (!sizeof (pet)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( pet,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_cuddle() {
  if (!sizeof (cuddle)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( cuddle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_fondle() {
  if (!sizeof (fondle)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( fondle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_snuggle() {
  if (!sizeof (snuggle)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( snuggle,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_squeeze() {
  if (!sizeof (squeeze)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( squeeze,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
int do_spank() {
  if (!sizeof (spank)) {
    return 0;
  }
   this_player()->add_succeeded_mess( this_object(), replace_string( spank,
         "$poss_short$", poss_short() ), ({ }) );
   return 1;
}
mapping query_static_auto_load() {
   return ([
      "::" : int_query_static_auto_load(),
      "hug" : hug,
      "pet" : pet,
      "cuddle" : cuddle,
      "fondle" : fondle,
      "snuggle" : snuggle,
      "squeeze" : squeeze,
      "spank" : spank
   ]);
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "::" : object::query_dynamic_auto_load(),
            "chat" : item_chat::query_dynamic_auto_load(),
          ]);
   return tmp;
}
void init_dynamic_arg(mapping map) {
   if ( !map )
      return;
   if (map["::"])
      object::init_dynamic_arg(map["::"]);
   if (map["chat"])
      item_chat::init_dynamic_arg(map["chat"]);
}
void init_static_arg( mapping map ) {
   if ( !map )
      return;
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   hug = map[ "hug" ];
   pet = map[ "pet" ];
   cuddle = map[ "cuddle" ];
   fondle = map[ "fondle" ];
   snuggle = map[ "snuggle" ];
   squeeze = map[ "squeeze" ];
   spank = map[ "spank" ];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/camera.c ===
#include <weather.h>
inherit "/std/object";
int  colour;
int  black_white;
int  scene;
void setup() {
  colour = 2;
  black_white = 4;
  scene = 1;
  set_name( "box" );
  add_adjective( ({ "heavy" , "black" }) );
  set_short( "heavy black cube" );
  set_main_plural( "heavy black cubes" );
  set_long( "You see a heavy black box with a window on one side.  "
            "Looking through the window, you notice a tiny demon sitting "
            "patiently next to a miniscule painter's easel.\n" );
  set_weight( 10 );
  add_alias( ({ "cube" , "camera" }) );
  add_plurals(({ "cubes", "cameras"}));
  adjust_money( 1 , "gold" );
  add_help_file("camera");
}
void init() {
    add_command("use", "<direct:object> on <indirect:object>");
    add_command("use", "<direct:object>");
}
int query_colour()      { return colour;  }
int query_black_white() { return black_white;  }
int do_use(object *obs) {
  int i;
  string view;
  string photo_of;
  string chars_sorted;
  string things_sorted;
  object *players;
  object *chars;
  object *things;
  object  photo;
  object  env;
  object *yes;
  players = ({ });
  chars = ({ });
  things = ({ });
  yes = ({ });
  view = "";
  photo_of = "";
  chars_sorted = "";
  things_sorted = "";
  env = environment(this_player()) ;
  photo_of = "This is a beautiful ";
  if (env->query_light() < 60) {
    this_player()->add_failed_mess(this_object(),
                                   "The little imp whispers: Hey! "
                                   "Not everyone like you can see "
                                   "in the dark you know.\n",({ }));
    return 0;
  }
  if (env->query_light() >180) {
    this_player()->add_failed_mess(this_object(),
                                   "The little demon said quietly: "
                                   "Could I have a pair of sunspecs "
                                   "please! Not too much to ask, is it?\n",
                                   ({ }));
    return 0;
  }
  if (black_white <= 0) {
    call_out("out_of_paint", 0, env);
    this_player()->add_failed_mess(this_object(),
                                   "The little imp gives up painting "
                                   "for you.\n",({ }));
    return 0;
  }
  if (colour > 1) {
    photo_of += "colour ";
    colour --;
  } else if (colour == 1) {
    photo_of += "colour ";
    call_out("out_of_colour", 2, env);
    colour --;
  } else {
    photo_of += "black and white ";
    black_white --;
  }
  if (sizeof(obs)) {
    for (i=0;i<sizeof(obs);i++) {
      if (obs[i]->query_property("player")) {
        players += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else if (obs[i]->query_property("npc")) {
        chars   += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else {
        if (environment(obs[i]) != this_player()) {
          things  += ({ obs[i] });
          this_player()->add_succeeded(obs[i]);
          yes  += ({ obs[i] });
        }
      }
    }
    chars_sorted = query_multiple_short(chars);
    things_sorted = query_multiple_short(things);
    if (chars_sorted || things_sorted || sizeof(players)) {
      scene = 0;
    }
  }
  view = env->query_long();
  if(view[sizeof(view)-1] != 10)
    view += "\n";
  if(env->query_property("location") == "outside" &&
     !env->query_weather_obscured(WEATHER->query_day())) {
    view = WEATHER->weather_string(env) + ".  " + view;
  }
  photo_of += "picture of " + env->a_short() + ".";
  if (scene == 0) {
    if ((sizeof(chars)+sizeof(players)) == 1) {
      if (sizeof(chars) == 1) {
        view += capitalize( (string)chars[0]->query_short() ) +
          " is here smiling.\n";
      } else if (sizeof(players) == 1) {
        view += players[0]->one_short() +" is here smiling.\n";
      }
    } else if ((sizeof(players)+sizeof(chars)) > 1) {
      for(i=0;i<sizeof(players);i++) {
        view += players[i]->one_short() ;
        if (i < (sizeof(players)-1)) {
          view += ", ";
        }
      }
      if (chars_sorted != "" && sizeof(players) > 0) {
        view += ", " + chars_sorted ;
      } else if (chars_sorted != "") {
        view += capitalize(chars_sorted) ;
      }
      view += " are smiling here.\n";
    }
    if (sizeof(things) == 1) {
      view += "There is a "+ things_sorted +" in the photo.\n";
    } else if ( sizeof( things ) ) {
      view += "There are " + things_sorted+" lying here in the photo.\n" ;
    }
  }
  photo = clone_object("/std/object");
  photo->set_name("glass");
  photo->add_adjective( ({"tiny", "square"}) );
  photo->set_short("tiny square of glass");
  photo->set_main_plural("tiny squares of glass");
  photo->set_long("/global/events"->convert_message(view));
  photo->set_read_mess(photo_of);
  photo->add_property("photographer", (string)this_player()->query_name()) ;
  photo->move(this_player());
  if (scene == 0) {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on $I. After some frantic "
                                      "sounds of pens scratching and "
                                      "brushes brushing, a tiny "
                                      "demon inside hands a piece of painted "
                                      "glass to $N.\n", yes);
  } else {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on the scenery. After some "
                                      "frantic sounds of pens scratching "
                                      "and brushes brushing, a "
                                      "tiny demon inside hands a piece "
                                      "of painted glass to $N.\n");
  }
  return 1;
}
mapping query_static_auto_load() {
  return ([ "colour" : colour,
          "black_white" : black_white ]);
}
void init_static_arg(mapping map) {
  colour = map["colour"];
  black_white = map["black_white"];
}
void out_of_paint(object room) {
  tell_object(this_player(), "The tiny demon whispers sarcastically: "
              "Without any more paints, I can still paint "
              "you invisible picture if you like!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "paints to "+ this_player()->one_short() +".\n",
            this_player());
}
void out_of_colour(object room) {
  tell_object(this_player(), "The tiny demon whispers: There are no more "
              "colour paints. This picture is the "
              "last colour one. I can only do you "
              "black and white pictures from now!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "colour to "+ this_player()->one_short() +".\n",
            this_player());
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/envelope.c ===
#define SMALL   3
#define MEDIUM  5
#define LARGE   8
#define UNSEALED  1
#define SEALED    2
#define OPENED    3
inherit "/obj/baggage";
nosave int status;
void make_envelope( string description, int size ) {
   string adjective, noun;
   if( size < 2 )
      size = 2;
   switch( size ) {
      case 0..SMALL:
         adjective = "small";
         noun = "envelope";
         break;
      case SMALL + 1..MEDIUM:
         adjective = "medium sized";
         noun = "envelope";
         break;
      case MEDIUM + 1..LARGE:
         adjective = "large";
         noun = "envelope";
         break;
      default:
         adjective = "large";
         noun = "packet";
         add_alias("packet");
   }
   set_name( "envelope" );
   set_short( adjective + " " + description + " " + noun );
   add_adjective( adjective );
   add_adjective( explode( description, " " ) );
   set_long( "This is a " + adjective + " " + description + " envelope.  " );
   set_weight( 1 );
   set_value( 300 + size * 20 );
   set_max_weight( size );
   set_material( "paper" );
   add_property( "writeable", 1 );
   add_extra_look( this_object() );
   status = UNSEALED;
}
void init() {
   ::init();
   this_player()->add_command( "seal", this_object(),
      "<direct:object:me>" );
   this_player()->add_command( "unseal", this_object(),
      "<direct:object:me>" );
}
string long( string str, int dark ) {
   string desc;
   switch( status ) {
   case UNSEALED :
      desc = "It has a sticky flap at one end with which you could "
         "probably seal it if you wanted to, though it might be wise to put "
         "something into it first or you're going to feel rather silly.\n";
      break;
   case SEALED :
      desc = "The sticky flap seems to have been sealed down.\n";
      break;
   case OPENED :
      desc = "It looks like it has been sealed and then opened up.\n";
      break;
   default :
      desc = "It is completely broken - you'd better tell a liaison.\n";
   }
   return ::long( str, dark ) + desc;
}
int do_seal() {
   if( status != UNSEALED ) {
      return notify_fail( this_object()->the_short() + " has already been "
         "sealed.\n" );
   }
   do_close();
   set_stuck( 1 );
   status = SEALED;
   this_player()->add_succeeded_mess( this_object(), "$N lick$s the flap on "
      "$D and seal$s it down.\n", ({ }) );
   return 1;
}
int do_unseal() {
   if( status != SEALED ) {
      return notify_fail( this_object()->the_short() + " has not been "
         "sealed.\n" );
   }
   set_stuck( 0 );
   do_open();
   status = OPENED;
   this_player()->add_succeeded_mess( this_object(), "$N tear$s back the "
      "flap on $D and open$s it.\n", ({ }) );
   return 1;
}
int query_envelope_status() {
   return status;
}
mixed *stats() {
   return ::stats() + ({
      ({ "status", status, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "status" : status,
   ]);
}
void init_static_arg( mapping map ) {
   if( map["::"] )
      ::init_static_arg( map["::"] );
   if( !undefinedp( map["status"] ) )
      status = map["status"];
}
mixed query_static_auto_load() {
   if( base_name( this_object() ) + ".c" == __FILE__ )
      return int_query_static_auto_load();
   return ([ ]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/bank_credit_note.c ===
inherit "/std/object";
#include <money.h>
#define OBJECT_TAG "credit note"
private int _id;
private int _amount;
private string _franchise;
private string _bank;
void setup() {
   set_name("note");
   set_short("bank credit note");
   add_adjective( ({ "bank", "credit" }) );
   set_long("A small piece of paper which looks like some sort of "
            "bank transaction slip.\n");
   set_value(0);
   set_weight(1);
}
void setup_read_messages() {
   string extra;
   string place;
   place = query_property("place");
   if (_amount < 0) {
     extra = "Agrees to pay " +
             MONEY_HAND->money_value_string(-_amount, place) +
             " to the master bank.\n";
   } else {
     extra = "Slip for a withdrawl of " +
             MONEY_HAND->money_value_string(-_amount, place) +
             " from the master bank.\n";
   }
   add_read_mess("Credit note #" + _id + " for the bank " +
                    _bank + " from the franchise " +
                    _franchise->query_address() + ".\n\n" + extra,
                    0, "common", 0);
}
void set_credit_num(int num) {
   _id = num;
}
int query_credit_num() {
   return _id;
}
void set_bank_name(string bank) {
   _bank = bank;
}
string query_bank_name() {
   return _bank;
}
void set_franchise(string franchise) {
   _franchise = franchise;
}
string query_franchise() {
   return _franchise;
}
void set_amount(int amount) {
   _amount = amount;
}
int query_amount() {
   return _amount;
}
int is_valid_note() {
   object bank;
   object* obs;
   object ob;
   int ret;
   bank = load_object(query_franchise());
   obs = bank->find_commercial_items("bank");
   if (sizeof(obs)) {
      foreach (ob in obs) {
         ret = ob->is_valid_note(query_credit_num());
         if (ret) {
            return 1;
         }
      }
   }
   return 0;
}
int do_process() {
   object bank;
   object* obs;
   object ob;
   int ret;
   bank = load_object(query_franchise());
   obs = bank->find_commercial_items("bank");
   if (sizeof(obs)) {
      foreach (ob in obs) {
         ret = ob->process_note(query_credit_num());
         if (ret) {
            return 1;
         }
      }
   }
   return 0;
}
mixed* stats() {
   return ::stats() +
          ({ ({ "credit amount", query_amount() }),
             ({ "franchise", query_franchise() }),
             ({ "credit id", query_credit_num() }), });
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "amount", query_amount());
   add_auto_load_value(map, OBJECT_TAG, "franchise", query_franchise());
   add_auto_load_value(map, OBJECT_TAG, "id", query_credit_num());
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   return map;
}
void init_dynamic_arg(mapping map) {
   ::init_dynamic_arg(map);
   set_amount(query_auto_load_value(map, OBJECT_TAG, "amount"));
   set_franchise(query_auto_load_value(map, OBJECT_TAG, "franchise"));
   set_credit_num(query_auto_load_value(map, OBJECT_TAG, "id"));
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/golem_eye.c ===
inherit "/std/object";
void setup() {
    set_name( "triangle" );
    set_short( "clay triangle" );
    add_adjective( ({"clay"}) );
    set_long( "This is a cracked piece of clay.  A hole in the shape of a "
       "triangle is in its middle.\n" );
    set_main_plural( "clay triangles" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/juicer.c ===
#include  <bit.h>
inherit "/obj/vessel";
int juice_bit( object ob, string fn );
mapping juice_funs = ([
  "/std/bit" : (: juice_bit :),
]);
void setup() {
  set_name( "juicer" );
  set_short( "juicer" );
  set_main_plural( "juicers" );
  set_long( "This is a device for extracting the juice or liquid from " +
            "objects.  It has a hole at the top for inserting things, " +
            "and a small bowl at the bottom to catch the juice.  You " +
            "could probably \"juice\" something and then \"pour\" " +
            "the juicer into another container.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_volume( 19200 );
}
void init() {
  ::init();
  this_player()->add_command( "juice", this_object(), "%I 'in' %D" );
}
int do_juice( object *things ) {
  int i, amount, *weight_unit, percent;
  string medium_short, *types, fn;
  mapping amount_types;
  if ( living( environment() ) ) {
    this_player()->add_failed_mess( this_object(), "You have to put down "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  for ( i = 0; i < sizeof( things ); i++ )
    if ( environment( things[ i ] ) != this_player() ) {
      things = delete( things, i, 1 );
      i--;
    }
  if ( !sizeof( things ) ) {
    this_player()->add_failed_mess( this_object(), "You should be carrying "+
        "whatever you want to $V in $D", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You should only $V "+
        "one thing at a time in $D in case they get mixed up.\n", ({ }) );
    return 0;
  }
  if ( !function_exists( "query_continuous", things[ 0 ] ) ) {
    if ( fn = things[ 0 ]->query_property("juice")
        && functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    fn = explode(file_name(things[ 0 ]), "#")[ 0 ];
    if (functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    this_player()->add_failed_mess( this_object(), "You cannot $V $I "+
        "in $D.  Trust me on this.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !(percent = things[ 0 ]->query_property("%liquid")) ) {
    this_player()->add_failed_mess( this_object(), "$I apparently doesn't " +
        "contain much juice.\n", ({ things[ 0 ] }) );
    things[ 0 ]->move("/room/rubbish");
    return 0;
  }
  things[ 0 ]->add_plural( (string)things[ 0 ]->query_name() );
  if ((amount = (int)things[ 0 ]->query_amount()) == 0) {
    weight_unit = (int *)things[ 0 ]->query_weight_unit();
    amount = ( weight_unit[ 1 ] * (int)things[ 0 ]->query_weight() ) /
      weight_unit[ 0 ];
    amount = ( ( 50 + random( 21 ) ) * amount ) / 80;
  }
  things[ 0 ]->set_amount( amount*percent/100 );
  things[ 0 ]->set_weight_per_bite( 0 );
  things[ 0 ]->set_bites_gone( 0 );
  medium_short = (string)things[ 0 ]->query_medium_short();
  if ( !medium_short )
    medium_short = (string)things[ 0 ]->query_short();
  if ( !things[ 0 ]->query_medium_alias() )
    things[ 0 ]->set_medium_alias( "Ground"+ capitalize( medium_short ) );
  amount_types = ([ "drop" : ({ 1, "drops" }), "ounce" :
        ({ 120, "ounces" }), "pint" : ({ 2400, "pints" }) ]);
  things[ 0 ]->set_amount_types( amount_types );
  types = m_indices( amount_types );
  for ( i = 0; i < sizeof( types ); i++ )
    things[ 0 ]->add_adjective( ({ types[ i ],
        amount_types[ types[ i ] ][ 1 ] }) );
  things[ 0 ]->add_adjective( "of" );
  if ( !sizeof( (mixed *)things[ 0 ]->query_pile_types() ) )
    things[ 0 ]->set_pile_types( ({ 50, "small", 2400, "medium", 19200,
        "large", "huge" }) );
  things[ 0 ]->add_property( "determinate", "some " );
  things[ 0 ]->grind();
  things[ 0 ]->move( this_object() );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
      ({ things[ 0 ] }) );
  return 1;
}
int juice_bit( object ob, string fn ) {
    object juice_ob;
    mixed *bit_data;
    string *m, s;
    int i;
    juice_ob = clone_object("/obj/reagents/generic_liquid.ob");
    juice_ob->set_name("juice");
    if (s = ob->query_race_name())
      s = capitalize(s);
    bit_data = ob->query_bit_data();
    m = explode(bit_data[ BIT_NAME ], " ");
    for ( i = 0; i < sizeof(m); i++ )
      s += capitalize(m[i]?m[i]:"");
    juice_ob->set_medium_alias(s+"Juice");
    switch ( bit_data[ BIT_ALIAS ] ) {
      case "eye":
        juice_ob->add_adjective("eye");
        juice_ob->add_alias("ichor");
        juice_ob->set_short("clear liquid");
        juice_ob->set_long("This is a clear liquid, slightly tinged" +
                           "with blood.\n");
        juice_ob->set_amount(10*(int)ob->query_weight() + 10);
        break;
      default:
        juice_ob->set_short("liquid");
        juice_ob->set_long("This is a non-descript liquid.  It's probably " +
                           "useless.\n");
        break;
    }
    juice_ob->move(this_object());
    ob->move("/room/rubbish");
    this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
                                      ({ juice_ob }) );
    return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/trap.c ===
#include <move_failures.h>
#include <tasks.h>
inherit "/std/object";
int difficulty;
string trigger;
string description;
mixed message;
mixed effect;
void create() {
  add_help_file("door_trap");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void make_trap(int diff, string trig, string desc, mixed mess, mixed eff) {
  difficulty = diff;
  trigger = trig;
  description = desc;
  message = mess;
  effect = eff;
}
void init() {
  this_player()->add_command("rig", this_object(),
           "<indirect:object:here> with <direct:object:me>");
}
int do_rig(mixed *in_dir, string direct, string indirect, mixed *args,
             string) {
  object ob;
  object other;
  if(sizeof(in_dir) > 1) {
    this_player()->add_failed_mess(this_object(), "A trap can only be rigged "
                                   "on a single item.\n");
    return 0;
  }
  if(!difficulty) {
    this_player()->add_failed_mess(this_object(), "$D appears to be "
                                   "broken.\n");
    return 0;
  }
  ob = in_dir[0];
  if(ob->query_trap_difficulty() && ob->query_trap_armed()) {
    this_player()->add_failed_mess(this_object(),
                                   "$I already has an armed trap on it.\n",
                                   ({ in_dir[0] }));
    return 0;
  }
  if(!function_exists("setup_trap", ob, 0)) {
    this_player()->add_failed_mess(this_object(), "$I cannot be $Ved with "
                                   "$D.\n", ({ ob }));
    return 0;
  }
  if((trigger == "pick" || trigger == "unlock") &&
     (!ob->query_key() || ob->query_key() == "generic_key")) {
    this_player()->add_failed_mess(this_object(), "$I doesn't have a lock "
                                   "so $Vging it with $D which is triggered "
                                   "by " + trigger + "ing makes no sense.\n",
                                   ({ ob }));
    return 0;
  }
  switch(TASKER->perform_task(this_player(), "covert.items.traps", difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about rigging "
          "traps.%^RESET%^\n");
  case SUCCEED:
    difficulty +=
      random(this_player()->query_skill_bonus("covert.items.traps") / 10);
    break;
  default:
    if(random(difficulty) >
       this_player()->query_skill_bonus("covert.items.traps") ||
       difficulty >
       this_player()->query_skill_bonus("covert.items.traps") * 2) {
      if(arrayp(message)) {
        write(message[0]);
        say(message[1], this_player());
      } else
        write(message);
      if(intp(effect)) {
        if(effect > this_player()->query_hp())
          this_player()->do_death();
        else
          this_player()->adjust_hp(-(effect));
      } else if(arrayp(effect)) {
        switch(sizeof(effect)) {
        case 1:
          this_player()->add_effect(effect[0]);
          break;
        case 2:
          this_player()->add_effect(effect[0], effect[1]);
          break;
        default:
          this_player()->add_effect(effect[0], effect[1..]);
        }
      } else
        this_player()->add_effect(effect);
      this_object()->move("/room/rubbish");
      this_player()->add_succeeded_mess(this_object(), "As $N attempt$s to "
                                        "$V $D it goes off!\n");
      return 1;
    } else {
      difficulty -= random(difficulty -
                    this_player()->query_skill_bonus("covert.items.traps"));
    }
  }
  ob->setup_trap(difficulty, trigger, description, message, effect);
  if(function_exists("query_my_room", ob)) {
    other = load_object( (string)( ob->query_dest() ) );
    other = other->query_door_control( (string)( ob->query_other_id() ) );
    other->setup_trap(difficulty, trigger, description, message, effect);
    environment(this_player())->update_doors();
  }
  this_player()->add_succeeded_mess(this_object(), "$N carefully $V $I "
                                    "with $D.\n",
                                    ({ ob }));
  call_out("break_me", 1);
  return 1;
}
void break_me() {
  object ob;
  ob = clone_object("/std/object");
  ob->set_name("trap");
  ob->set_short("busted trap");
  ob->set_long("A broken trap.\n");
  ob->set_value(0);
  ob->set_weight(this_object()->query_weight());
  ob->move(environment());
  if(this_object()->move("/room/rubbish") != MOVE_OK)
    this_object()->dest_me();
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
            "difficulty" : difficulty,
            "trigger" : trigger,
            "description" : description,
            "message" : message,
            "effect" : effect
            ]);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping map) {
  if(!mapp(map))
    return;
  if(!undefinedp(map["::"]))
    ::init_static_arg(map["::"]);
  if(!undefinedp(map["difficulty"]))
    difficulty = map["difficulty"];
  if(!undefinedp(map["trigger"]))
    trigger = map["trigger"];
  if(!undefinedp(map["description"]))
    description = map["description"];
  if(!undefinedp(map["message"]))
    message = map["message"];
  if(!undefinedp(map["effect"]))
    effect = map["effect"];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/case.c ===
#define READ "/cmds/living/r_ead"
inherit "/obj/baggage";
void setup() {
  set_name("case");
  set_long("This is a nice glass display case that looks out of place "
           "here, you could \"peruse\" things in it perhaps.\n");
  add_alias("container");
  add_adjective("display");
  set_transparent();
  set_weight(1000);
  set_main_plural("cases");
  set_max_weight(500000);
  reset_get();
  reset_drop();
}
void init() {
  this_player()->add_command( "peruse", this_object(),
                              "<indirect:object:direct-obs> in <direct:object>");
}
int do_peruse( object *obs ) {
  obs = filter( obs, (: environment( $1 ) == this_object() :) );
  if ( !sizeof( obs ) ) {
    add_failed_mess( "You have to browse something in the display case.\n" );
    return 0;
  }
  if ( sizeof( obs ) > 1 ) {
    add_failed_mess( "You can only browse 1 thing at a time.\n" );
    return 0;
  }
  write( "You peruse the "+ obs[0]->query_short() +".\n" );
  write( obs[0]->long() );
  READ->cmd( ({ obs[0] }) );
  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;
}
int test_add( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
int test_remove( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
void setup_case( string name, string long ) {
  add_alias( name );
  set_long( long + "You feel you could \"peruse\" things in it.\n" );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/bug.c ===
inherit "/std/object";
int no_shots;
void setup() {
   no_shots = 10;
   set_name( "bug");
   set_long( "It sits there, happier than a clam, its long black silvery "
             "legs sticking out the side.  The legs look fixed in place and "
             "there are some silvery words carved onto the top.  When you "
             "shake it, it sounds like it has something rattling around "
             "inside.  There appears to be a spray nozzle at one end.\n");
   add_read_mess("68000\n", "silver writing", "general", 0);
}
void init() {
  add_command("shake", "<direct:object>");
  add_command("spray", "<indirect:object> with <direct:object>");
}
int do_shake() {
   this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and you can hear something rattling around inside.\n", ({ }));
   return 1;
}
int do_spray(object *obs) {
   int i;
   int done;
   if (no_shots <= 0) {
      return 0;
   }
   done = 0;
   for (i = 0; i < sizeof(obs); i++) {
      if (no_shots > 0 && obs[i] != this_object()) {
         obs[i]->add_effect("/std/effects/object/bug_effect", 0);
         no_shots--;
         this_player()->add_succeeded(obs[i]);
         done = 1;
      }
   }
   return done;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([ "::" : ::query_dynamic_auto_load(),
            "shots" : no_shots ]);
   return map;
}
void init_dynamic_arg(mapping map, object foo) {
   ::init_dynamic_arg(map["::"]);
   no_shots = map["shots"];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/wedding_ring.c ===
inherit "obj/armour";
string owner, giver;
void setup() {
   set_name( "ring" );
   set_short( "wedding ring" );
   add_adjective( "wedding" );
   set_long( "This is a wedding ring crafted from the purest gold from the "+
      "mines of Rimward Klatch.\n" );
   set_main_plural( "wedding rings" );
   set_type( "ring" );
   add_property( "shop type", "jewellers" );
   add_property( "no recycling", 1 );
   set_weight( 1 );
   setup_armour( 1000 );
   set_percentage( 100 );
   set_damage_chance( 0 );
   owner = giver = "nobody";
   set_wear_remove_func( file_name( this_object() ), "wear_remove" );
}
void do_inscription() {
   string language;
   object player;
   player = find_player( giver );
   if( !player ) {
      player = find_player( owner );
   }
   language = player->query_default_language();
   set_read_mess( "\"For you, "+ capitalize( owner ) +
         ", with eternal love, "+ capitalize( giver ) +".\"", language );
}
string query_owner() { return owner; }
void set_owner( string word ) {
  owner = lower_case( word );
  do_inscription();
}
string query_giver() { return giver; }
void set_giver( string word ) {
  giver = lower_case( word );
  do_inscription();
}
void wear_remove( int wear ) {
   if( environment() != this_player() )
      return;
   if ( living( environment() )  &&  wear ) {
      if ( (string)this_player()->query_name() != owner )
         write( "The ring feels uncomfortable on your finger.\n" );
      else
         write( "You are warmed anew by "+ capitalize( giver ) +"'s love.\n" );
   }
}
mixed *stats() {
   return ::stats() + ({
      ({ "owner", owner }),
      ({ "giver", giver }),
   });
}
void init_dynamic_arg( mapping args ) {
   if ( args[ "::" ] )
      ::init_dynamic_arg( args[ "::" ] );
   if ( args[ "owner" ] )
      owner = lower_case( args[ "owner" ] );
   if ( args[ "giver" ] )
      giver = lower_case( args[ "giver" ] );
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "owner" : owner,
      "giver" : giver
   ]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/newspaper_box.c ===
inherit "/std/object";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
private string _paper;
void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   reset_get();
}
void set_paper(string paper) {
   int cost;
   string place;
   string* bits;
   _paper = paper;
   place = query_property("place");
   if (!place) {
      if (environment()) {
         place = environment()->query_property("place");
      } else if (previous_object()) {
         place = previous_object()->query_property("place");
      }
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(paper);
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy() {
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_property("place");
   if (!place) {
      place = environment()->query_property("place");
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return -1;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return -1;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N $V a paper from $D.\n");
   return 1;
}
void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/present.c ===
#include <move_failures.h>
#define PAPER_LONG "This is a lovely big piece of " + _colour + " " + _type + " paper.  It looks like it could be used to wrap up something as a present.  Try \"wrap <objects> in paper\".\n"
#define PRESENT_LONG "This lovely piece of " + _colour + " paper has been used to wrap up something as a present.  Try \"unwrap\".\n"
inherit "/obj/baggage";
int do_wrap( object *things );
int do_unwrap();
private int wrapped;
private string _colour;
private string _type;
void setup() {
   set_name( "wrappingpaper" );
   set_short( "piece of wrapping paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of wrapping paper" );
   add_plural( ({ "pieces of wrapping paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   set_weight( 2 );
   set_max_weight( 225 );
   set_value( 600 );
   set_stuck(1);
   add_property( "writeable", 1 );
   add_property( "paper", 1);
}
void set_colour( string word ) {
   if( _colour ) {
      return;
   }
   _colour = word;
   if (!_colour) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _colour, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
void set_type( string word ) {
   if( _type ) {
      return;
   }
   _type = word;
   if (!_type) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _type, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
#ifdef MY_TEST_FUNC
int test_remove( object thing, int flag ) {
   if( ( query_verb() == "get" ) || ( query_verb() == "take" ) ) {
      return !wrapped;
   }
   return 1;
}
int test_add( object thing, int flag ) {
   if( ( query_verb() == "put" ) || ( query_verb() == "give" ) ) {
      return 0;
   }
   return 1;
}
#endif
void init() {
   add_command( "wrap", "<indirect:object:me> in <direct:object'present'>" );
   add_command( "unwrap", "<direct:object:'present'>", (: do_unwrap :) );
   add_command( "open", "<direct:object:'present'>", (: do_unwrap :) );
}
int do_wrap( object *things ) {
   object *valid, *failed;
   things -= ({ this_object() });
   if( wrapped ) {
      add_failed_mess( "The paper has already been used to wrap something.\n" );
      return 0;
   }
   if( !( sizeof( things ) ) ) {
      add_failed_mess( "You must wrap something!\n" );
      return 0;
   }
   valid = filter( things, (: !living( $1 ) &&
                              $1->move( this_object() ) == MOVE_OK :) );
   failed = things - valid;
   if( sizeof( failed ) ) {
      tell_object( this_player(), "You could not wrap " +
         query_multiple_short( failed ) + " in " + the_short() + ".\n" );
   }
   if( sizeof( valid ) ) {
      wrapped = 1;
      remove_alias( "paper" );
      remove_adjective( "piece of" );
      remove_adjective( "wrapping" );
      remove_plural( "pieces of wrapping paper" );
      remove_plural( "pieces of paper" );
      remove_plural( "papers" );
      call_out( "set_short", 1, _colour + " present" );
      add_alias( "present" );
      set_main_plural( _colour + " presents" );
      add_plural( "presents" );
      set_long( PRESENT_LONG );
      add_succeeded_mess( "$N $V $I in $D.\n", valid );
   } else {
      add_succeeded_mess( "" );
   }
   return 1;
}
int do_unwrap() {
   int i;
   object *things;
   if( !wrapped ) {
      write( "There is nothing wrapped in the paper.\n" );
      return 0;
   }
   wrapped = 0;
   things = all_inventory();
   write( "You open the present and find "+ query_multiple_short( things ) +
      " inside.\n" );
   for( i = 0; i < sizeof( things ); i++ ) {
      if( things[ i ]->move( environment() ) ) {
         if( environment( environment() ) ) {
            things[ i ]->move( environment( environment() ) );
            write( "The " + things[ i ]->short() + " falls onto the " +
               "floor as you unwrap the present.\n" );
         }
      }
   }
   remove_alias( "present" );
   remove_plural( "presents" );
   call_out( "set_short", 1, "piece of " + _colour + " " + _type + " paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   add_plural( ({ "pieces of " + _type + " paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   add_succeeded_mess("$N unwrap$s $D.\n");
   return 1;
}
mixed *stats() {
    return ::stats() + ({
      ({ "colour", _colour }),
      ({ "type", _type }),
      ({ "wrapped", wrapped }),
    });
}
mapping query_static_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "::": ::int_query_static_auto_load(),
    ]);
}
void init_static_arg( mapping args ) {
    _colour = args[ "colour" ];
    ::init_static_arg( args[ "::" ] );
}
mapping query_dynamic_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "wrapped": wrapped,
      "::": ::query_dynamic_auto_load(),
    ]);
}
void init_dynamic_arg( mapping args ) {
    _colour = args[ "colour"  ];
    _type   = args[ "type"    ];
    wrapped = args[ "wrapped" ];
    ::init_dynamic_arg( args[ "::" ] );
    if(!_colour) {
        _colour = "plain";
    }
    if(!_type) {
        _type = "wrapping";
    }
}
int query_closed() {
    return 1;
}
string long_status() {
    return "";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/dead_chicken.c ===
#include <move_failures.h>
#define CHICKEN_FEATHER "/obj/misc/chicken_feather"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "chicken" );
  set_short( "dead chicken" );
  add_alias( ({ "corpse", "chicken corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead chickens" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled chicken.  "
                  "Judging from the total lack of feathers it is "
                  "ready to be cooked.\n";
              return
                  "This is the dead body of a bedraggled chicken.  "
                  "Most people would pluck the few feathers on it "
                  "and then cook it.\n";
            } );
  set_weight( 8 );
  set_value( 300 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The chicken is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( CHICKEN_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead chicken with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead chicken cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/duck_feather.ob ===
#  -*- LPC -*- #
#
# $Locker:  $
# $Id: duck_feather.ob,v 1.1 2001/09/27 11:47:40 siel Exp $
#
#
#

::Name:: "feather"
::Short:: "duck feather"
::Adjective:: ({ "duck" })
::Long:: "This looks like a feather from the back of a duck.
 It is slightly greasy.\n"
::Main plural:: "duck feathers"
::Value::8
::Weight::1


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/quest_info_utils.c ===
#include <library.h>
string _quest_name;
void set_quest_name(string quest_name)
{
   _quest_name = quest_name;
}
void set_quest_param(mixed player, string key, mixed value)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      info = ([ ]);
   info[key] = value;
   LIBRARY->set_player_quest_info(player, _quest_name, info);
}
mixed query_quest_param(mixed player, string key)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      return 0;
   return info[key];
}
void clear_quest_info(mixed player)
{
   if (!stringp(player))
      player = player->query_name();
   LIBRARY->set_player_quest_info(player, _quest_name, 0);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/shop_owners_guide.c ===
inherit "/std/book_dir";
void setup() {
  set_name("book");
  set_short("brilliant vermillion book");
  add_adjective(({"brilliant", "vermillion"}));
  add_alias("guide");
  set_long("This is a brilliant vermillion coloured book with lots of "
           "pictures of money on the front cover.\n");
  set_read_mess("                   DIY\n\n"
                "          A guide for shop owners.\n");
  set_main_plural("brilliant vermillion books");
  set_weight(10);
  set_value(10);
  set_book_language( "general");
  set_book_dir("/save/books/shop_owner/page");
  set_open_page(0);
  set_ignore_saved_pages(1);
}
int do_tear() {
  return 0;
}
int query_binding_force() {
  return 100;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/quill.c ===
#include <language.h>
inherit "/obj/weapon";
int do_scribble( object *things, string mess);
object writing_on;
string type;
void setup() {
   set_name( "quill" );
   set_long( "This is a nice, long, feathery quill.  You could \"write\" "
         "on things with it.\n");
   set_weight( 3 );
   set_value( 1000 );
   new_weapon( 240 );
   add_help_file("quill");
   set_damage_chance( 100 );
   add_attack( "stab", 90, ({ 10, 2, 10 }), "pierce", "sharp", 0 );
   add_property( "paper writer", 1 );
   type = "ink";
}
void init() {
   add_command( "write", "on <indirect:object> with <direct:object>" );
   add_command( "write", "with <direct:object> on <indirect:object>" );
   add_command( "sign", "<indirect:object> with <direct:object>");
   add_command( "scribble",
                "<string'message'> on <indirect:object> with <direct:object>",
                (: do_scribble($1, $4[0]) :));
}
int do_scribble( object *things, string mess) {
   string language;
   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }
   if (things[0]->is_current_page_torn_out()) {
      add_failed_mess( "The page of " + things[0]->the_short() +
            " you were writing on appears to have been torn out.\n" );
      return 0;
   }
   things[0]->add_read_mess( mess, type, language, 0 );
   add_succeeded_mess("$N $V something on $I.\n", things);
   return 1;
}
int do_write( object *things ) {
   string language;
   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }
   if ( writing_on ) {
      add_failed_mess("You are already writing on $I with $D.\n", ({ writing_on }) );
      return 0;
   }
   add_succeeded_mess("$N start$s writing on $I with $D.\n", things );
   writing_on = things[ 0 ];
   call_out( "begin_writing", 0, this_player() );
   return 1;
}
void begin_writing( object writer ) {
   if ( !writer ) {
      writing_on = 0;
      return;
   }
   writer->do_edit( 0, "end_writing" );
}
void end_writing( string words ) {
   string language;
   if ( !words || ( words == "" ) ) {
      write( "You don't write anything on "+
            (string)writing_on->the_short() +".\n" );
      say( (string)this_player()->the_short() +" doesn't "+
            "write anything after all.\n" );
      writing_on = 0;
      return;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      write( "You seem to have changed to using a non-written language.\n" );
      say( (string)this_player()->the_short() +" seems "+
            "linguistically-challenged.\n" );
      writing_on = 0;
      return;
   }
   if ( !writing_on ) {
      write( "You seem to have lost what you were writing on.\n" );
      say( (string)this_player()->the_short() +" looks around "+
            "in puzzlement.\n" );
      return;
   }
   if ( member_array( environment( writing_on ), ({ environment(),
         environment( this_player() ) }) ) == -1 ) {
      write( (string)writing_on->the_short() +
            " seems to have run away from you.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }
   if (writing_on->is_current_page_torn_out()) {
      write( "The page of " + (string)writing_on->the_short() +
            " you were writing on appears to have been torn out.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }
   writing_on->add_read_mess( words, type, language, 0 );
   write( "You finish writing on "+
         (string)writing_on->the_short() +".\n" );
   say( (string)this_player()->the_short() +" finishes writing "+
         "on "+ (string)writing_on->a_short() +".\n" );
   writing_on = 0;
}
int do_sign(object* things) {
   object ob;
   string language;
   if ( query_wielded() != this_player() ) {
      add_failed_mess( "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V $I with $D when you're not "
            "using a language that can be written.\n", things );
      return 0;
   }
   things[ 0 ]->add_read_mess(this_player()->short(0, 1), "cursive, "
        "signed by", language, 0);
   add_succeeded_mess("$N $V $I with $D.\n", things);
   return 1;
}
int do_copy( mixed *in_dir, string direct, string indirect, mixed *args ) {
    mixed src_mess, mess;
    string lang, cur_lang;
    int i, c, siz, perr;
    if ( !present(direct, this_player()) ) return 0;
    if ( query_wielded() != this_player() ) {
        this_player()->add_failed_mess( this_object(), "You need to be "
                                       "holding $D to $V with it.\n", ({ }) );
        return 0;
    }
    if ((sizeof(in_dir) != 2) ||
        (sizeof(in_dir[0]) != 1) || (sizeof(in_dir[1]) != 1)) {
        this_player()->add_failed_mess(this_object(),
                                       "You can only $V to/from one object "
                                       "at a time.\n", ({ }));
        return 0;
    }
    if ( !in_dir[1][0]->query_property( "writeable" ) ) {
        this_player()->add_failed_mess( this_object(), "You can't write on "
                                       "$I.\n", in_dir[1] );
        return 0;
    }
    if ( sizeof(args) == 4 ) {
        if ( !LANGUAGE_HAND->query_language_written(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               args[3] + " is not a written language.\n",
                               ({ }));
            return 0;
        }
        if ( LANGUAGE_HAND->query_language_magic(args[3])) {
            this_player()->add_failed_mess(this_object(),
                               "You can't write " + args[3] + " like this.\n",
                               ({ }));
            return 0;
        }
        if ( !this_player()->query_language(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               "You don't know " + args[3] + ".\n", ({ }));
            return 0;
        }
        cur_lang = args[3];
    }
    src_mess = in_dir[0][0]->query_read_mess();
    if (!sizeof(src_mess)) {
        write("There is nothing written on " + in_dir[0][0]->the_short() +
              ".\n");
        this_player()->add_failed_mess(this_object(),
                                       "There is nothing written on $I.\n",
                                       in_dir[0]);
        return 0;
    }
    for (i = 0; i < sizeof(src_mess); i++) {
        mess = src_mess[i][0];
        lang = src_mess[i][2];
        siz = src_mess[i][3];
        if (LANGUAGE_HAND->query_language_magic(lang)) {
            mess = "A series of unintelligible scribbles.";
            lang = "common";
        } else if (!this_player()->query_language(lang) && stringp(mess)) {
            perr = this_player()->query_int() + this_player()->query_dex()
              - 20;
            for (c = random(perr); c < sizeof(mess); c += random(perr)+1) {
                if ((mess[c] >= 'a') && (mess[c] <= 'z')) {
                    mess[c] = 'a' + random(26);
                } else if ((mess[c] >= 'A') && (mess[c] <= 'Z')) {
                    mess[c] = 'A' + random(26);
                }
            }
        } else if ( stringp(cur_lang) ) {
            lang = cur_lang;
        }
        in_dir[1][0]->add_read_mess(mess, type, lang, siz);
    }
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V the writing on $I with $D.\n",
                                      in_dir[0]);
    return 1;
}
